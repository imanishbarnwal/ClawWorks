"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/runResearchTask.ts":
/*!************************************!*\
  !*** ./src/lib/runResearchTask.ts ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   runResearchTask: function() { return /* binding */ runResearchTask; }\n/* harmony export */ });\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/contract/contract.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/units.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/constants/numbers.js\");\n/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./registry */ \"(app-pages-browser)/./src/lib/registry.ts\");\n/* harmony import */ var _contracts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./contracts */ \"(app-pages-browser)/./src/lib/contracts.ts\");\n/* harmony import */ var _wallet__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wallet */ \"(app-pages-browser)/./src/lib/wallet.ts\");\n\n\n\n\nconst AGENT_TREASURY_ABI = [\n    \"function execute(address target, uint256 value, bytes calldata data) external returns (bytes)\",\n    \"function approveToken(address token, address spender, uint256 amount) external\",\n    \"function owner() view returns (address)\"\n];\n// Helper to extract revert reason\nconst getRevertReason = (err)=>{\n    var _err_info_error, _err_info;\n    if (err === null || err === void 0 ? void 0 : (_err_info = err.info) === null || _err_info === void 0 ? void 0 : (_err_info_error = _err_info.error) === null || _err_info_error === void 0 ? void 0 : _err_info_error.message) return err.info.error.message;\n    if (err === null || err === void 0 ? void 0 : err.message) return err.message;\n    return \"Transaction Failed (Unknown Reason)\";\n};\n/**\n * Executes the full research workflow by orchestrating the Research Agent.\n * Uses pure ethers.js v6 with window.ethereum.\n */ async function runResearchTask(taskDescription, onLog, onTreasuriesUpdate) {\n    console.log('\\uD83D\\uDE80 Starting Research Task: \"'.concat(taskDescription, '\"'));\n    // 0. Log User Task Submission (UI Only)\n    onLog({\n        task: \"User Task Submitted\",\n        agentName: \"User\",\n        amount: \"-\",\n        status: \"success\",\n        decision: {\n            reason: taskDescription,\n            cost: \"-\"\n        }\n    });\n    // 1. Connect Wallet\n    const { signer, address } = await (0,_wallet__WEBPACK_IMPORTED_MODULE_2__.connectWallet)();\n    console.log(\"\\uD83D\\uDC64 Connected wallet:\", address);\n    // 2. Load registry\n    const researchTreasuryAddr = _registry__WEBPACK_IMPORTED_MODULE_0__.AGENT_REGISTRY.research_agent.treasury_address;\n    const dataAgentAddr = _registry__WEBPACK_IMPORTED_MODULE_0__.AGENT_REGISTRY.data_agent.treasury_address;\n    const seoAgentAddr = _registry__WEBPACK_IMPORTED_MODULE_0__.AGENT_REGISTRY.seo_agent.treasury_address;\n    const formattingAgentAddr = _registry__WEBPACK_IMPORTED_MODULE_0__.AGENT_REGISTRY.formatting_agent.treasury_address;\n    // ✅ FIX 1 — Registry sanity check\n    if (!researchTreasuryAddr || !dataAgentAddr || !seoAgentAddr || !formattingAgentAddr) {\n        throw new Error(\"❌ Agent registry is missing treasury addresses\");\n    }\n    console.log(\"\\uD83D\\uDCD2 Registry OK\");\n    // 3. Instantiate contracts\n    const router = new ethers__WEBPACK_IMPORTED_MODULE_3__.Contract(_contracts__WEBPACK_IMPORTED_MODULE_1__.PROTOCOL_ROUTER_ADDRESS, _contracts__WEBPACK_IMPORTED_MODULE_1__.ROUTER_ABI, signer);\n    const researchTreasury = new ethers__WEBPACK_IMPORTED_MODULE_3__.Contract(researchTreasuryAddr, AGENT_TREASURY_ABI, signer);\n    // ✅ FIX 2 — Execution authority check\n    try {\n        const treasuryOwner = await researchTreasury.owner();\n        console.log(\"\\uD83C\\uDFE6 Research Treasury Owner:\", treasuryOwner);\n        console.log(\"✍️ Connected Wallet:\", address);\n        if (treasuryOwner.toLowerCase() !== address.toLowerCase()) {\n            console.warn(\"⚠️ Wallet is NOT treasury owner — execute() may revert\");\n        } else {\n            console.log(\"✅ Wallet IS treasury owner\");\n        }\n    } catch (e) {\n        console.log(\"ℹ️ Treasury has no owner() or uses role-based auth\");\n    }\n    // 4. Fetch payment token (AUSD)\n    console.log(\"\\uD83D\\uDCB0 Fetching payment token...\");\n    const ausdAddress = await router.paymentToken();\n    console.log(\"AUSD Address:\", ausdAddress);\n    const ausd = new ethers__WEBPACK_IMPORTED_MODULE_3__.Contract(ausdAddress, _contracts__WEBPACK_IMPORTED_MODULE_1__.ERC20_ABI, signer);\n    // ==========================================\n    // NEW STEP: User Funds Research Agent (1.00 AUSD)\n    // ==========================================\n    const fundingAmount = ethers__WEBPACK_IMPORTED_MODULE_4__.parseEther(\"1.0\");\n    console.log(\"Checking user allowance for funding...\");\n    const userAllowance = await ausd.allowance(address, _contracts__WEBPACK_IMPORTED_MODULE_1__.PROTOCOL_ROUTER_ADDRESS);\n    if (userAllowance < fundingAmount) {\n        console.log(\"\\uD83D\\uDCDD User approving Router...\");\n        onLog({\n            task: \"Approving AUSD Spend\",\n            agentName: \"User (You)\",\n            amount: \"0.00\",\n            status: \"pending\"\n        });\n        try {\n            const approveTx = await ausd.approve(_contracts__WEBPACK_IMPORTED_MODULE_1__.PROTOCOL_ROUTER_ADDRESS, ethers__WEBPACK_IMPORTED_MODULE_5__.MaxUint256);\n            console.log(\"User Approval Tx:\", approveTx.hash);\n            await approveTx.wait();\n            console.log(\"✅ User Approval Confirmed\");\n        } catch (err) {\n            console.error(\"User Approval Failed:\", err);\n            throw new Error(\"User Approval Failed: \".concat(getRevertReason(err)));\n        }\n    }\n    console.log(\"\\uD83D\\uDCB8 Funding Research Agent...\");\n    onLog({\n        task: \"Funding Research Agent\",\n        agentName: \"User (You)\",\n        amount: \"1.00\",\n        status: \"pending\"\n    });\n    try {\n        const fundTx = await router.processPayment(researchTreasuryAddr, fundingAmount, \"Initial Capital Infection\");\n        console.log(\"Funding Tx:\", fundTx.hash);\n        await fundTx.wait();\n        onLog({\n            task: \"Funding Complete\",\n            agentName: \"User (You)\",\n            amount: \"1.00\",\n            txHash: fundTx.hash,\n            status: \"success\"\n        });\n        console.log(\"✅ Funding Confirmed\");\n        if (onTreasuriesUpdate) {\n            console.log(\"\\uD83D\\uDD04 Refetching Live Treasuries...\");\n            await onTreasuriesUpdate();\n        }\n    } catch (err) {\n        console.error(\"Funding Failed:\", err);\n        onLog({\n            task: \"Funding Failed\",\n            agentName: \"User (You)\",\n            amount: \"1.00\",\n            status: \"error\"\n        });\n        throw new Error(\"Funding Failed: \".concat(getRevertReason(err)));\n    }\n    // ==========================================\n    // EXISTING FLOW: Research Agent Pays Downstream\n    // ==========================================\n    // 5. Allowance check (Research Treasury -> Router)\n    const currentAllowance = await ausd.allowance(researchTreasuryAddr, _contracts__WEBPACK_IMPORTED_MODULE_1__.PROTOCOL_ROUTER_ADDRESS);\n    const requiredAmount = ethers__WEBPACK_IMPORTED_MODULE_4__.parseEther(\"1.0\"); // Need enough for downstream payments\n    if (currentAllowance < requiredAmount) {\n        console.log(\"\\uD83D\\uDCDD Approving router to spend AUSD (Treasury)...\");\n        onLog({\n            task: \"Approving Payment Router\",\n            agentName: \"Research Treasury\",\n            amount: \"0.00\",\n            status: \"pending\"\n        });\n        const approveTx = await researchTreasury.approveToken(ausdAddress, _contracts__WEBPACK_IMPORTED_MODULE_1__.PROTOCOL_ROUTER_ADDRESS, ethers__WEBPACK_IMPORTED_MODULE_5__.MaxUint256);\n        console.log(\"Treasury Approval tx:\", approveTx.hash);\n        await approveTx.wait();\n        console.log(\"✅ Treasury Approval confirmed\");\n    } else {\n        console.log(\"✅ Treasury Allowance already sufficient\");\n    }\n    // 6. Agent Decision Engine\n    const decidePayments = (input)=>{\n        const t = input.toLowerCase();\n        const plan = [];\n        // Dynamic hiring based on keywords\n        if (t.includes(\"data\") || t.includes(\"research\") || t.includes(\"supply\") || t.includes(\"info\")) {\n            plan.push({\n                recipient: dataAgentAddr,\n                amount: \"0.20\",\n                task: \"Data Collection\",\n                agentName: \"Data Agent\",\n                decision: {\n                    reason: \"Task trigger 'data/research' -> Initiating Supply Chain Scan\",\n                    cost: \"0.20\"\n                }\n            });\n        }\n        if (t.includes(\"seo\") || t.includes(\"growth\") || t.includes(\"rank\") || t.includes(\"search\")) {\n            plan.push({\n                recipient: seoAgentAddr,\n                amount: \"0.10\",\n                task: \"SEO Optimization\",\n                agentName: \"SEO Agent\",\n                decision: {\n                    reason: \"Task trigger 'seo/growth' -> Optimizing Search Ranking\",\n                    cost: \"0.10\"\n                }\n            });\n        }\n        if (t.includes(\"format\") || t.includes(\"pdf\") || t.includes(\"report\") || t.includes(\"layout\")) {\n            plan.push({\n                recipient: formattingAgentAddr,\n                amount: \"0.05\",\n                task: \"Formatting\",\n                agentName: \"Formatting Agent\",\n                decision: {\n                    reason: \"Task trigger 'format/report' -> Structuring Final Output\",\n                    cost: \"0.05\"\n                }\n            });\n        }\n        // Fallback: If input is vague, trigger standard protocol\n        if (plan.length === 0) {\n            console.log(\"⚠️ No specific keywords - Defaulting to Full Suite\");\n            return [\n                {\n                    recipient: dataAgentAddr,\n                    amount: \"0.20\",\n                    task: \"Data Collection\",\n                    agentName: \"Data Agent\",\n                    decision: {\n                        reason: \"Ambiguous task input -> Default Protocol: Data\",\n                        cost: \"0.20\"\n                    }\n                },\n                {\n                    recipient: seoAgentAddr,\n                    amount: \"0.10\",\n                    task: \"SEO Optimization\",\n                    agentName: \"SEO Agent\",\n                    decision: {\n                        reason: \"Ambiguous task input -> Default Protocol: SEO\",\n                        cost: \"0.10\"\n                    }\n                },\n                {\n                    recipient: formattingAgentAddr,\n                    amount: \"0.05\",\n                    task: \"Formatting\",\n                    agentName: \"Formatting Agent\",\n                    decision: {\n                        reason: \"Ambiguous task input -> Default Protocol: Formatting\",\n                        cost: \"0.05\"\n                    }\n                }\n            ];\n        }\n        return plan;\n    };\n    const payments = decidePayments(taskDescription);\n    // 7. Execute payments (Loop)\n    for (const pay of payments){\n        console.log(\"➡️ Paying \".concat(pay.agentName));\n        onLog({\n            task: pay.task,\n            agentName: pay.agentName,\n            amount: pay.amount,\n            decision: pay.decision,\n            status: \"pending\"\n        });\n        try {\n            const calldata = router.interface.encodeFunctionData(\"processPayment\", [\n                pay.recipient,\n                ethers__WEBPACK_IMPORTED_MODULE_4__.parseEther(pay.amount),\n                \"Payment for \".concat(pay.task)\n            ]);\n            const tx = await researchTreasury.execute(_contracts__WEBPACK_IMPORTED_MODULE_1__.PROTOCOL_ROUTER_ADDRESS, 0, calldata);\n            console.log(\"Tx sent:\", tx.hash);\n            await tx.wait();\n            console.log(\"✅ \".concat(pay.task, \" complete\"));\n            onLog({\n                task: \"\".concat(pay.task, \" - Confirmed\"),\n                agentName: pay.agentName,\n                amount: pay.amount,\n                txHash: tx.hash,\n                status: \"success\"\n            });\n            if (onTreasuriesUpdate) {\n                console.log(\"\\uD83D\\uDD04 Refetching Live Treasuries...\");\n                await onTreasuriesUpdate();\n            }\n        } catch (err) {\n            console.error(\"❌ Payment failed:\", err);\n            onLog({\n                task: \"\".concat(pay.task, \" - FAILED\"),\n                agentName: pay.agentName,\n                amount: pay.amount,\n                status: \"error\"\n            });\n            throw new Error(getRevertReason(err));\n        }\n    }\n    console.log(\"\\uD83C\\uDF89 Research Task Workflow Completed\");\n    return \"SUCCESS\";\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvcnVuUmVzZWFyY2hUYXNrLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBZ0M7QUFDWTtBQUNpQztBQUNwQztBQUV6QyxNQUFNTSxxQkFBcUI7SUFDdkI7SUFDQTtJQUNBO0NBQ0g7QUFFRCxrQ0FBa0M7QUFDbEMsTUFBTUMsa0JBQWtCLENBQUNDO1FBQ2pCQSxpQkFBQUE7SUFBSixJQUFJQSxnQkFBQUEsMkJBQUFBLFlBQUFBLElBQUtDLElBQUksY0FBVEQsaUNBQUFBLGtCQUFBQSxVQUFXRSxLQUFLLGNBQWhCRixzQ0FBQUEsZ0JBQWtCRyxPQUFPLEVBQUUsT0FBT0gsSUFBSUMsSUFBSSxDQUFDQyxLQUFLLENBQUNDLE9BQU87SUFDNUQsSUFBSUgsZ0JBQUFBLDBCQUFBQSxJQUFLRyxPQUFPLEVBQUUsT0FBT0gsSUFBSUcsT0FBTztJQUNwQyxPQUFPO0FBQ1g7QUFFQTs7O0NBR0MsR0FDTSxlQUFlQyxnQkFDbEJDLGVBQXVCLEVBQ3ZCQyxLQVVVLEVBQ1ZDLGtCQUF3QztJQUV4Q0MsUUFBUUMsR0FBRyxDQUFDLHlDQUErQyxPQUFoQkosaUJBQWdCO0lBRTNELHdDQUF3QztJQUN4Q0MsTUFBTTtRQUNGSSxNQUFNO1FBQ05DLFdBQVc7UUFDWEMsUUFBUTtRQUNSQyxRQUFRO1FBQ1JDLFVBQVU7WUFDTkMsUUFBUVY7WUFDUlcsTUFBTTtRQUNWO0lBQ0o7SUFFQSxvQkFBb0I7SUFDcEIsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLE9BQU8sRUFBRSxHQUFHLE1BQU1yQixzREFBYUE7SUFDL0NXLFFBQVFDLEdBQUcsQ0FBQyxrQ0FBd0JTO0lBRXBDLG1CQUFtQjtJQUNuQixNQUFNQyx1QkFBdUIxQixxREFBY0EsQ0FBQzJCLGNBQWMsQ0FBQ0MsZ0JBQWdCO0lBQzNFLE1BQU1DLGdCQUFnQjdCLHFEQUFjQSxDQUFDOEIsVUFBVSxDQUFDRixnQkFBZ0I7SUFDaEUsTUFBTUcsZUFBZS9CLHFEQUFjQSxDQUFDZ0MsU0FB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RUEsTUFBTSxJQUFJZSxNQUFNN0IsZ0JBQWdCQztRQUNwQztJQUNKO0lBRUFRLFFBQVFDLEdBQUcsQ0FBQztJQUNaLE9BQU87QUFDWCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvbGliL3J1blJlc2VhcmNoVGFzay50cz9kYzNkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGV0aGVycyB9IGZyb20gJ2V0aGVycyc7XG5pbXBvcnQgeyBBR0VOVF9SRUdJU1RSWSB9IGZyb20gJy4vcmVnaXN0cnknO1xuaW1wb3J0IHsgUFJPVE9DT0xfUk9VVEVSX0FERFJFU1MsIFJPVVRFUl9BQkksIEVSQzIwX0FCSSB9IGZyb20gJy4vY29udHJhY3RzJztcbmltcG9ydCB7IGNvbm5lY3RXYWxsZXQgfSBmcm9tICcuL3dhbGxldCc7XG5cbmNvbnN0IEFHRU5UX1RSRUFTVVJZX0FCSSA9IFtcbiAgICBcImZ1bmN0aW9uIGV4ZWN1dGUoYWRkcmVzcyB0YXJnZXQsIHVpbnQyNTYgdmFsdWUsIGJ5dGVzIGNhbGxkYXRhIGRhdGEpIGV4dGVybmFsIHJldHVybnMgKGJ5dGVzKVwiLFxuICAgIFwiZnVuY3Rpb24gYXBwcm92ZVRva2VuKGFkZHJlc3MgdG9rZW4sIGFkZHJlc3Mgc3BlbmRlciwgdWludDI1NiBhbW91bnQpIGV4dGVybmFsXCIsXG4gICAgXCJmdW5jdGlvbiBvd25lcigpIHZpZXcgcmV0dXJucyAoYWRkcmVzcylcIlxuXTtcblxuLy8gSGVscGVyIHRvIGV4dHJhY3QgcmV2ZXJ0IHJlYXNvblxuY29uc3QgZ2V0UmV2ZXJ0UmVhc29uID0gKGVycjogYW55KSA9PiB7XG4gICAgaWYgKGVycj8uaW5mbz8uZXJyb3I/Lm1lc3NhZ2UpIHJldHVybiBlcnIuaW5mby5lcnJvci5tZXNzYWdlO1xuICAgIGlmIChlcnI/Lm1lc3NhZ2UpIHJldHVybiBlcnIubWVzc2FnZTtcbiAgICByZXR1cm4gXCJUcmFuc2FjdGlvbiBGYWlsZWQgKFVua25vd24gUmVhc29uKVwiO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlcyB0aGUgZnVsbCByZXNlYXJjaCB3b3JrZmxvdyBieSBvcmNoZXN0cmF0aW5nIHRoZSBSZXNlYXJjaCBBZ2VudC5cbiAqIFVzZXMgcHVyZSBldGhlcnMuanMgdjYgd2l0aCB3aW5kb3cuZXRoZXJldW0uXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBydW5SZXNlYXJjaFRhc2soXG4gICAgdGFza0Rlc2NyaXB0aW9uOiBzdHJpbmcsXG4gICAgb25Mb2c6IChsb2c6IHtcbiAgICAgICAgdGFzazogc3RyaW5nO1xuICAgICAgICBhZ2VudE5hbWU6IHN0cmluZztcbiAgICAgICAgYW1vdW50OiBzdHJpbmc7XG4gICAgICAgIHR4SGFzaD86IHN0cmluZztcbiAgICAgICAgc3RhdHVzOiBcInBlbmRpbmdcIiB8IFwic3VjY2Vzc1wiIHwgXCJlcnJvclwiO1xuICAgICAgICBkZWNpc2lvbj86IHtcbiAgICAgICAgICAgIHJlYXNvbjogc3RyaW5nO1xuICAgICAgICAgICAgY29zdDogc3RyaW5nO1xuICAgICAgICB9O1xuICAgIH0pID0+IHZvaWQsXG4gICAgb25UcmVhc3VyaWVzVXBkYXRlPzogKCkgPT4gUHJvbWlzZTx2b2lkPlxuKSB7XG4gICAgY29uc29sZS5sb2coYPCfmoAgU3RhcnRpbmcgUmVzZWFyY2ggVGFzazogXCIke3Rhc2tEZXNjcmlwdGlvbn1cImApO1xuXG4gICAgLy8gMC4gTG9nIFVzZXIgVGFzayBTdWJtaXNzaW9uIChVSSBPbmx5KVxuICAgIG9uTG9nKHtcbiAgICAgICAgdGFzazogXCJVc2VyIFRhc2sgU3VibWl0dGVkXCIsXG4gICAgICAgIGFnZW50TmFtZTogXCJVc2VyXCIsXG4gICAgICAgIGFtb3VudDogXCItXCIsXG4gICAgICAgIHN0YXR1czogXCJzdWNjZXNzXCIsXG4gICAgICAgIGRlY2lzaW9uOiB7XG4gICAgICAgICAgICByZWFzb246IHRhc2tEZXNjcmlwdGlvbixcbiAgICAgICAgICAgIGNvc3Q6IFwiLVwiXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIDEuIENvbm5lY3QgV2FsbGV0XG4gICAgY29uc3QgeyBzaWduZXIsIGFkZHJlc3MgfSA9IGF3YWl0IGNvbm5lY3RXYWxsZXQoKTtcbiAgICBjb25zb2xlLmxvZyhcIvCfkaQgQ29ubmVjdGVkIHdhbGxldDpcIiwgYWRkcmVzcyk7XG5cbiAgICAvLyAyLiBMb2FkIHJlZ2lzdHJ5XG4gICAgY29uc3QgcmVzZWFyY2hUcmVhc3VyeUFkZHIgPSBBR0VOVF9SRUdJU1RSWS5yZXNlYXJjaF9hZ2VudC50cmVhc3VyeV9hZGRyZXNzO1xuICAgIGNvbnN0IGRhdGFBZ2VudEFkZHIgPSBBR0VOVF9SRUdJU1RSWS5kYXRhX2FnZW50LnRyZWFzdXJ5X2FkZHJlc3M7XG4gICAgY29uc3Qgc2VvQWdlbnRBZGRyID0gQUdFTlRfUkVHSVNUUlkuc2VvX2FnZW50LnRyZWFzdXJ5X2FkZHJlc3M7XG4gICAgY29uc3QgZm9ybWF0dGluZ0FnZW50QWRkciA9IEFHRU5UX1JFR0lTVFJZLmZvcm1hdHRpbmdfYWdlbnQudHJlYXN1cnlfYWRkcmVzcztcblxuICAgIC8vIOKchSBGSVggMSDigJQgUmVnaXN0cnkgc2FuaXR5IGNoZWNrXG4gICAgaWYgKFxuICAgICAgICAhcmVzZWFyY2hUcmVhc3VyeUFkZHIgfHxcbiAgICAgICAgIWRhdGFBZ2VudEFkZHIgfHxcbiAgICAgICAgIXNlb0FnZW50QWRkciB8fFxuICAgICAgICAhZm9ybWF0dGluZ0FnZW50QWRkclxuICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCLinYwgQWdlbnQgcmVnaXN0cnkgaXMgbWlzc2luZyB0cmVhc3VyeSBhZGRyZXNzZXNcIik7XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coXCLwn5OSIFJlZ2lzdHJ5IE9LXCIpO1xuXG4gICAgLy8gMy4gSW5zdGFudGlhdGUgY29udHJhY3RzXG4gICAgY29uc3Qgcm91dGVyID0gbmV3IGV0aGVycy5Db250cmFjdChcbiAgICAgICAgUFJPVE9DT0xfUk9VVEVSX0FERFJFU1MsXG4gICAgICAgIFJPVVRFUl9BQkksXG4gICAgICAgIHNpZ25lclxuICAgICk7XG5cbiAgICBjb25zdCByZXNlYXJjaFRyZWFzdXJ5ID0gbmV3IGV0aGVycy5Db250cmFjdChcbiAgICAgICAgcmVzZWFyY2hUcmVhc3VyeUFkZHIsXG4gICAgICAgIEFHRU5UX1RSRUFTVVJZX0FCSSxcbiAgICAgICAgc2lnbmVyXG4gICAgKTtcblxuICAgIC8vIOKchSBGSVggMiDigJQgRXhlY3V0aW9uIGF1dGhvcml0eSBjaGVja1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHRyZWFzdXJ5T3duZXIgPSBhd2FpdCByZXNlYXJjaFRyZWFzdXJ5Lm93bmVyKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwi8J+PpiBSZXNlYXJjaCBUcmVhc3VyeSBPd25lcjpcIiwgdHJlYXN1cnlPd25lcik7XG4gICAgICAgIGNvbnNvbGUubG9nKFwi4pyN77iPIENvbm5lY3RlZCBXYWxsZXQ6XCIsIGFkZHJlc3MpO1xuXG4gICAgICAgIGlmICh0cmVhc3VyeU93bmVyLnRvTG93ZXJDYXNlKCkgIT09IGFkZHJlc3MudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwi4pqg77iPIFdhbGxldCBpcyBOT1QgdHJlYXN1cnkgb3duZXIg4oCUIGV4ZWN1dGUoKSBtYXkgcmV2ZXJ0XCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCLinIUgV2FsbGV0IElTIHRyZWFzdXJ5IG93bmVyXCIpO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwi4oS577iPIFRyZWFzdXJ5IGhhcyBubyBvd25lcigpIG9yIHVzZXMgcm9sZS1iYXNlZCBhdXRoXCIpO1xuICAgIH1cblxuICAgIC8vIDQuIEZldGNoIHBheW1lbnQgdG9rZW4gKEFVU0QpXG4gICAgY29uc29sZS5sb2coXCLwn5KwIEZldGNoaW5nIHBheW1lbnQgdG9rZW4uLi5cIik7XG4gICAgY29uc3QgYXVzZEFkZHJlc3MgPSBhd2FpdCByb3V0ZXIucGF5bWVudFRva2VuKCk7XG4gICAgY29uc29sZS5sb2coXCJBVVNEIEFkZHJlc3M6XCIsIGF1c2RBZGRyZXNzKTtcblxuICAgIGNvbnN0IGF1c2QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KGF1c2RBZGRyZXNzLCBFUkMyMF9BQkksIHNpZ25lcik7XG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBORVcgU1RFUDogVXNlciBGdW5kcyBSZXNlYXJjaCBBZ2VudCAoMS4wMCBBVVNEKVxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIGNvbnN0IGZ1bmRpbmdBbW91bnQgPSBldGhlcnMucGFyc2VFdGhlcihcIjEuMFwiKTtcblxuICAgIGNvbnNvbGUubG9nKFwiQ2hlY2tpbmcgdXNlciBhbGxvd2FuY2UgZm9yIGZ1bmRpbmcuLi5cIik7XG4gICAgY29uc3QgdXNlckFsbG93YW5jZSA9IGF3YWl0IGF1c2QuYWxsb3dhbmNlKGFkZHJlc3MsIFBST1RPQ09MX1JPVVRFUl9BRERSRVNTKTtcblxuICAgIGlmICh1c2VyQWxsb3dhbmNlIDwgZnVuZGluZ0Ftb3VudCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIvCfk50gVXNlciBhcHByb3ZpbmcgUm91dGVyLi4uXCIpO1xuICAgICAgICBvbkxvZyh7XG4gICAgICAgICAgICB0YXNrOiBcIkFwcHJvdmluZyBBVVNEIFNwZW5kXCIsXG4gICAgICAgICAgICBhZ2VudE5hbWU6IFwiVXNlciAoWW91KVwiLFxuICAgICAgICAgICAgYW1vdW50OiBcIjAuMDBcIixcbiAgICAgICAgICAgIHN0YXR1czogXCJwZW5kaW5nXCJcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGFwcHJvdmVUeCA9IGF3YWl0IGF1c2QuYXBwcm92ZShQUk9UT0NPTF9ST1VURVJfQUREUkVTUywgZXRoZXJzLk1heFVpbnQyNTYpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJVc2VyIEFwcHJvdmFsIFR4OlwiLCBhcHByb3ZlVHguaGFzaCk7XG4gICAgICAgICAgICBhd2FpdCBhcHByb3ZlVHgud2FpdCgpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCLinIUgVXNlciBBcHByb3ZhbCBDb25maXJtZWRcIik7XG4gICAgICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVXNlciBBcHByb3ZhbCBGYWlsZWQ6XCIsIGVycik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVzZXIgQXBwcm92YWwgRmFpbGVkOiAke2dldFJldmVydFJlYXNvbihlcnIpfWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coXCLwn5K4IEZ1bmRpbmcgUmVzZWFyY2ggQWdlbnQuLi5cIik7XG4gICAgb25Mb2coe1xuICAgICAgICB0YXNrOiBcIkZ1bmRpbmcgUmVzZWFyY2ggQWdlbnRcIixcbiAgICAgICAgYWdlbnROYW1lOiBcIlVzZXIgKFlvdSlcIixcbiAgICAgICAgYW1vdW50OiBcIjEuMDBcIixcbiAgICAgICAgc3RhdHVzOiBcInBlbmRpbmdcIlxuICAgIH0pO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZnVuZFR4ID0gYXdhaXQgcm91dGVyLnByb2Nlc3NQYXltZW50KFxuICAgICAgICAgICAgcmVzZWFyY2hUcmVhc3VyeUFkZHIsXG4gICAgICAgICAgICBmdW5kaW5nQW1vdW50LFxuICAgICAgICAgICAgXCJJbml0aWFsIENhcGl0YWwgSW5mZWN0aW9uXCJcbiAgICAgICAgKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJGdW5kaW5nIFR4OlwiLCBmdW5kVHguaGFzaCk7XG4gICAgICAgIGF3YWl0IGZ1bmRUeC53YWl0KCk7XG5cbiAgICAgICAgb25Mb2coe1xuICAgICAgICAgICAgdGFzazogXCJGdW5kaW5nIENvbXBsZXRlXCIsXG4gICAgICAgICAgICBhZ2VudE5hbWU6IFwiVXNlciAoWW91KVwiLFxuICAgICAgICAgICAgYW1vdW50OiBcIjEuMDBcIixcbiAgICAgICAgICAgIHR4SGFzaDogZnVuZFR4Lmhhc2gsXG4gICAgICAgICAgICBzdGF0dXM6IFwic3VjY2Vzc1wiXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zb2xlLmxvZyhcIuKchSBGdW5kaW5nIENvbmZpcm1lZFwiKTtcblxuICAgICAgICBpZiAob25UcmVhc3VyaWVzVXBkYXRlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIvCflIQgUmVmZXRjaGluZyBMaXZlIFRyZWFzdXJpZXMuLi5cIik7XG4gICAgICAgICAgICBhd2FpdCBvblRyZWFzdXJpZXNVcGRhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkZ1bmRpbmcgRmFpbGVkOlwiLCBlcnIpO1xuICAgICAgICBvbkxvZyh7XG4gICAgICAgICAgICB0YXNrOiBcIkZ1bmRpbmcgRmFpbGVkXCIsXG4gICAgICAgICAgICBhZ2VudE5hbWU6IFwiVXNlciAoWW91KVwiLFxuICAgICAgICAgICAgYW1vdW50OiBcIjEuMDBcIixcbiAgICAgICAgICAgIHN0YXR1czogXCJlcnJvclwiXG4gICAgICAgIH0pO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZ1bmRpbmcgRmFpbGVkOiAke2dldFJldmVydFJlYXNvbihlcnIpfWApO1xuICAgIH1cblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIEVYSVNUSU5HIEZMT1c6IFJlc2VhcmNoIEFnZW50IFBheXMgRG93bnN0cmVhbVxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgLy8gNS4gQWxsb3dhbmNlIGNoZWNrIChSZXNlYXJjaCBUcmVhc3VyeSAtPiBSb3V0ZXIpXG4gICAgY29uc3QgY3VycmVudEFsbG93YW5jZSA9IGF3YWl0IGF1c2QuYWxsb3dhbmNlKFxuICAgICAgICByZXNlYXJjaFRyZWFzdXJ5QWRkcixcbiAgICAgICAgUFJPVE9DT0xfUk9VVEVSX0FERFJFU1NcbiAgICApO1xuXG4gICAgY29uc3QgcmVxdWlyZWRBbW91bnQgPSBldGhlcnMucGFyc2VFdGhlcihcIjEuMFwiKTsgLy8gTmVlZCBlbm91Z2ggZm9yIGRvd25zdHJlYW0gcGF5bWVudHNcblxuICAgIGlmIChjdXJyZW50QWxsb3dhbmNlIDwgcmVxdWlyZWRBbW91bnQpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCLwn5OdIEFwcHJvdmluZyByb3V0ZXIgdG8gc3BlbmQgQVVTRCAoVHJlYXN1cnkpLi4uXCIpO1xuXG4gICAgICAgIG9uTG9nKHtcbiAgICAgICAgICAgIHRhc2s6IFwiQXBwcm92aW5nIFBheW1lbnQgUm91dGVyXCIsXG4gICAgICAgICAgICBhZ2VudE5hbWU6IFwiUmVzZWFyY2ggVHJlYXN1cnlcIixcbiAgICAgICAgICAgIGFtb3VudDogXCIwLjAwXCIsXG4gICAgICAgICAgICBzdGF0dXM6IFwicGVuZGluZ1wiXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGFwcHJvdmVUeCA9IGF3YWl0IHJlc2VhcmNoVHJlYXN1cnkuYXBwcm92ZVRva2VuKFxuICAgICAgICAgICAgYXVzZEFkZHJlc3MsXG4gICAgICAgICAgICBQUk9UT0NPTF9ST1VURVJfQUREUkVTUyxcbiAgICAgICAgICAgIGV0aGVycy5NYXhVaW50MjU2XG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc29sZS5sb2coXCJUcmVhc3VyeSBBcHByb3ZhbCB0eDpcIiwgYXBwcm92ZVR4Lmhhc2gpO1xuICAgICAgICBhd2FpdCBhcHByb3ZlVHgud2FpdCgpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIuKchSBUcmVhc3VyeSBBcHByb3ZhbCBjb25maXJtZWRcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coXCLinIUgVHJlYXN1cnkgQWxsb3dhbmNlIGFscmVhZHkgc3VmZmljaWVudFwiKTtcbiAgICB9XG5cbiAgICAvLyA2LiBBZ2VudCBEZWNpc2lvbiBFbmdpbmVcbiAgICBjb25zdCBkZWNpZGVQYXltZW50cyA9IChpbnB1dDogc3RyaW5nKSA9PiB7XG4gICAgICAgIGNvbnN0IHQgPSBpbnB1dC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCBwbGFuID0gW107XG5cbiAgICAgICAgLy8gRHluYW1pYyBoaXJpbmcgYmFzZWQgb24ga2V5d29yZHNcbiAgICAgICAgaWYgKHQuaW5jbHVkZXMoXCJkYXRhXCIpIHx8IHQuaW5jbHVkZXMoXCJyZXNlYXJjaFwiKSB8fCB0LmluY2x1ZGVzKFwic3VwcGx5XCIpIHx8IHQuaW5jbHVkZXMoXCJpbmZvXCIpKSB7XG4gICAgICAgICAgICBwbGFuLnB1c2goe1xuICAgICAgICAgICAgICAgIHJlY2lwaWVudDogZGF0YUFnZW50QWRkcixcbiAgICAgICAgICAgICAgICBhbW91bnQ6IFwiMC4yMFwiLFxuICAgICAgICAgICAgICAgIHRhc2s6IFwiRGF0YSBDb2xsZWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgYWdlbnROYW1lOiBcIkRhdGEgQWdlbnRcIixcbiAgICAgICAgICAgICAgICBkZWNpc2lvbjoge1xuICAgICAgICAgICAgICAgICAgICByZWFzb246IFwiVGFzayB0cmlnZ2VyICdkYXRhL3Jlc2VhcmNoJyAtPiBJbml0aWF0aW5nIFN1cHBseSBDaGFpbiBTY2FuXCIsXG4gICAgICAgICAgICAgICAgICAgIGNvc3Q6IFwiMC4yMFwiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodC5pbmNsdWRlcyhcInNlb1wiKSB8fCB0LmluY2x1ZGVzKFwiZ3Jvd3RoXCIpIHx8IHQuaW5jbHVkZXMoXCJyYW5rXCIpIHx8IHQuaW5jbHVkZXMoXCJzZWFyY2hcIikpIHtcbiAgICAgICAgICAgIHBsYW4ucHVzaCh7XG4gICAgICAgICAgICAgICAgcmVjaXBpZW50OiBzZW9BZ2VudEFkZHIsXG4gICAgICAgICAgICAgICAgYW1vdW50OiBcIjAuMTBcIixcbiAgICAgICAgICAgICAgICB0YXNrOiBcIlNFTyBPcHRpbWl6YXRpb25cIixcbiAgICAgICAgICAgICAgICBhZ2VudE5hbWU6IFwiU0VPIEFnZW50XCIsXG4gICAgICAgICAgICAgICAgZGVjaXNpb246IHtcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBcIlRhc2sgdHJpZ2dlciAnc2VvL2dyb3d0aCcgLT4gT3B0aW1pemluZyBTZWFyY2ggUmFua2luZ1wiLFxuICAgICAgICAgICAgICAgICAgICBjb3N0OiBcIjAuMTBcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHQuaW5jbHVkZXMoXCJmb3JtYXRcIikgfHwgdC5pbmNsdWRlcyhcInBkZlwiKSB8fCB0LmluY2x1ZGVzKFwicmVwb3J0XCIpIHx8IHQuaW5jbHVkZXMoXCJsYXlvdXRcIikpIHtcbiAgICAgICAgICAgIHBsYW4ucHVzaCh7XG4gICAgICAgICAgICAgICAgcmVjaXBpZW50OiBmb3JtYXR0aW5nQWdlbnRBZGRyLFxuICAgICAgICAgICAgICAgIGFtb3VudDogXCIwLjA1XCIsXG4gICAgICAgICAgICAgICAgdGFzazogXCJGb3JtYXR0aW5nXCIsXG4gICAgICAgICAgICAgICAgYWdlbnROYW1lOiBcIkZvcm1hdHRpbmcgQWdlbnRcIixcbiAgICAgICAgICAgICAgICBkZWNpc2lvbjoge1xuICAgICAgICAgICAgICAgICAgICByZWFzb246IFwiVGFzayB0cmlnZ2VyICdmb3JtYXQvcmVwb3J0JyAtPiBTdHJ1Y3R1cmluZyBGaW5hbCBPdXRwdXRcIixcbiAgICAgICAgICAgICAgICAgICAgY29zdDogXCIwLjA1XCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZhbGxiYWNrOiBJZiBpbnB1dCBpcyB2YWd1ZSwgdHJpZ2dlciBzdGFuZGFyZCBwcm90b2NvbFxuICAgICAgICBpZiAocGxhbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi4pqg77iPIE5vIHNwZWNpZmljIGtleXdvcmRzIC0gRGVmYXVsdGluZyB0byBGdWxsIFN1aXRlXCIpO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJlY2lwaWVudDogZGF0YUFnZW50QWRkcixcbiAgICAgICAgICAgICAgICAgICAgYW1vdW50OiBcIjAuMjBcIixcbiAgICAgICAgICAgICAgICAgICAgdGFzazogXCJEYXRhIENvbGxlY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgYWdlbnROYW1lOiBcIkRhdGEgQWdlbnRcIixcbiAgICAgICAgICAgICAgICAgICAgZGVjaXNpb246IHsgcmVhc29uOiBcIkFtYmlndW91cyB0YXNrIGlucHV0IC0+IERlZmF1bHQgUHJvdG9jb2w6IERhdGFcIiwgY29zdDogXCIwLjIwXCIgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByZWNpcGllbnQ6IHNlb0FnZW50QWRkcixcbiAgICAgICAgICAgICAgICAgICAgYW1vdW50OiBcIjAuMTBcIixcbiAgICAgICAgICAgICAgICAgICAgdGFzazogXCJTRU8gT3B0aW1pemF0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIGFnZW50TmFtZTogXCJTRU8gQWdlbnRcIixcbiAgICAgICAgICAgICAgICAgICAgZGVjaXNpb246IHsgcmVhc29uOiBcIkFtYmlndW91cyB0YXNrIGlucHV0IC0+IERlZmF1bHQgUHJvdG9jb2w6IFNFT1wiLCBjb3N0OiBcIjAuMTBcIiB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJlY2lwaWVudDogZm9ybWF0dGluZ0FnZW50QWRkcixcbiAgICAgICAgICAgICAgICAgICAgYW1vdW50OiBcIjAuMDVcIixcbiAgICAgICAgICAgICAgICAgICAgdGFzazogXCJGb3JtYXR0aW5nXCIsXG4gICAgICAgICAgICAgICAgICAgIGFnZW50TmFtZTogXCJGb3JtYXR0aW5nIEFnZW50XCIsXG4gICAgICAgICAgICAgICAgICAgIGRlY2lzaW9uOiB7IHJlYXNvbjogXCJBbWJpZ3VvdXMgdGFzayBpbnB1dCAtPiBEZWZhdWx0IFByb3RvY29sOiBGb3JtYXR0aW5nXCIsIGNvc3Q6IFwiMC4wNVwiIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBsYW47XG4gICAgfTtcblxuICAgIGNvbnN0IHBheW1lbnRzID0gZGVjaWRlUGF5bWVudHModGFza0Rlc2NyaXB0aW9uKTtcblxuICAgIC8vIDcuIEV4ZWN1dGUgcGF5bWVudHMgKExvb3ApXG4gICAgZm9yIChjb25zdCBwYXkgb2YgcGF5bWVudHMpIHtcbiAgICAgICAgY29uc29sZS5sb2coYOKeoe+4jyBQYXlpbmcgJHtwYXkuYWdlbnROYW1lfWApO1xuXG4gICAgICAgIG9uTG9nKHtcbiAgICAgICAgICAgIHRhc2s6IHBheS50YXNrLFxuICAgICAgICAgICAgYWdlbnROYW1lOiBwYXkuYWdlbnROYW1lLFxuICAgICAgICAgICAgYW1vdW50OiBwYXkuYW1vdW50LFxuICAgICAgICAgICAgZGVjaXNpb246IHBheS5kZWNpc2lvbixcbiAgICAgICAgICAgIHN0YXR1czogXCJwZW5kaW5nXCJcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGNhbGxkYXRhID0gcm91dGVyLmludGVyZmFjZS5lbmNvZGVGdW5jdGlvbkRhdGEoXG4gICAgICAgICAgICAgICAgXCJwcm9jZXNzUGF5bWVudFwiLFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgcGF5LnJlY2lwaWVudCxcbiAgICAgICAgICAgICAgICAgICAgZXRoZXJzLnBhcnNlRXRoZXIocGF5LmFtb3VudCksXG4gICAgICAgICAgICAgICAgICAgIGBQYXltZW50IGZvciAke3BheS50YXNrfWBcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBjb25zdCB0eCA9IGF3YWl0IHJlc2VhcmNoVHJlYXN1cnkuZXhlY3V0ZShcbiAgICAgICAgICAgICAgICBQUk9UT0NPTF9ST1VURVJfQUREUkVTUyxcbiAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgIGNhbGxkYXRhXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlR4IHNlbnQ6XCIsIHR4Lmhhc2gpO1xuICAgICAgICAgICAgYXdhaXQgdHgud2FpdCgpO1xuXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFICR7cGF5LnRhc2t9IGNvbXBsZXRlYCk7XG5cbiAgICAgICAgICAgIG9uTG9nKHtcbiAgICAgICAgICAgICAgICB0YXNrOiBgJHtwYXkudGFza30gLSBDb25maXJtZWRgLFxuICAgICAgICAgICAgICAgIGFnZW50TmFtZTogcGF5LmFnZW50TmFtZSxcbiAgICAgICAgICAgICAgICBhbW91bnQ6IHBheS5hbW91bnQsXG4gICAgICAgICAgICAgICAgdHhIYXNoOiB0eC5oYXNoLFxuICAgICAgICAgICAgICAgIHN0YXR1czogXCJzdWNjZXNzXCJcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAob25UcmVhc3VyaWVzVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCLwn5SEIFJlZmV0Y2hpbmcgTGl2ZSBUcmVhc3VyaWVzLi4uXCIpO1xuICAgICAgICAgICAgICAgIGF3YWl0IG9uVHJlYXN1cmllc1VwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIuKdjCBQYXltZW50IGZhaWxlZDpcIiwgZXJyKTtcblxuICAgICAgICAgICAgb25Mb2coe1xuICAgICAgICAgICAgICAgIHRhc2s6IGAke3BheS50YXNrfSAtIEZBSUxFRGAsXG4gICAgICAgICAgICAgICAgYWdlbnROYW1lOiBwYXkuYWdlbnROYW1lLFxuICAgICAgICAgICAgICAgIGFtb3VudDogcGF5LmFtb3VudCxcbiAgICAgICAgICAgICAgICBzdGF0dXM6IFwiZXJyb3JcIlxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihnZXRSZXZlcnRSZWFzb24oZXJyKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZyhcIvCfjokgUmVzZWFyY2ggVGFzayBXb3JrZmxvdyBDb21wbGV0ZWRcIik7XG4gICAgcmV0dXJuIFwiU1VDQ0VTU1wiO1xufVxuIl0sIm5hbWVzIjpbImV0aGVycyIsIkFHRU5UX1JFR0lTVFJZIiwiUFJPVE9DT0xfUk9VVEVSX0FERFJFU1MiLCJST1VURVJfQUJJIiwiRVJDMjBfQUJJIiwiY29ubmVjdFdhbGxldCIsIkFHRU5UX1RSRUFTVVJZX0FCSSIsImdldFJldmVydFJlYXNvbiIsImVyciIsImluZm8iLCJlcnJvciIsIm1lc3NhZ2UiLCJydW5SZXNlYXJjaFRhc2siLCJ0YXNrRGVzY3JpcHRpb24iLCJvbkxvZyIsIm9uVHJlYXN1cmllc1VwZGF0ZSIsImNvbnNvbGUiLCJsb2ciLCJ0YXNrIiwiYWdlbnROYW1lIiwiYW1vdW50Iiwic3RhdHVzIiwiZGVjaXNpb24iLCJyZWFzb24iLCJjb3N0Iiwic2lnbmVyIiwiYWRkcmVzcyIsInJlc2VhcmNoVHJlYXN1cnlBZGRyIiwicmVzZWFyY2hfYWdlbnQiLCJ0cmVhc3VyeV9hZGRyZXNzIiwiZGF0YUFnZW50QWRkciIsImRhdGFfYWdlbnQiLCJzZW9BZ2VudEFkZHIiLCJzZW9fYWdlbnQiLCJmb3JtYXR0aW5nQWdlbnRBZGRyIiwiZm9ybWF0dGluZ19hZ2VudCIsIkVycm9yIiwicm91dGVyIiwiQ29udHJhY3QiLCJyZXNlYXJjaFRyZWFzdXJ5IiwidHJlYXN1cnlPd25lciIsIm93bmVyIiwidG9Mb3dlckNhc2UiLCJ3YXJuIiwiYXVzZEFkZHJlc3MiLCJwYXltZW50VG9rZW4iLCJhdXNkIiwiZnVuZGluZ0Ftb3VudCIsInBhcnNlRXRoZXIiLCJ1c2VyQWxsb3dhbmNlIiwiYWxsb3dhbmNlIiwiYXBwcm92ZVR4IiwiYXBwcm92ZSIsIk1heFVpbnQyNTYiLCJoYXNoIiwid2FpdCIsImZ1bmRUeCIsInByb2Nlc3NQYXltZW50IiwidHhIYXNoIiwiY3VycmVudEFsbG93YW5jZSIsInJlcXVpcmVkQW1vdW50IiwiYXBwcm92ZVRva2VuIiwiZGVjaWRlUGF5bWVudHMiLCJpbnB1dCIsInQiLCJwbGFuIiwiaW5jbHVkZXMiLCJwdXNoIiwicmVjaXBpZW50IiwibGVuZ3RoIiwicGF5bWVudHMiLCJwYXkiLCJjYWxsZGF0YSIsImludGVyZmFjZSIsImVuY29kZUZ1bmN0aW9uRGF0YSIsInR4IiwiZXhlY3V0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/runResearchTask.ts\n"));

/***/ })

});