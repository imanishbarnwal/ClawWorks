"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/openapi-fetch";
exports.ids = ["vendor-chunks/openapi-fetch"];
exports.modules = {

/***/ "(ssr)/./node_modules/openapi-fetch/dist/cjs/index.cjs":
/*!*******************************************************!*\
  !*** ./node_modules/openapi-fetch/dist/cjs/index.cjs ***!
  \*******************************************************/
/***/ ((module) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all)=>{\n    for(var name in all)__defProp(target, name, {\n        get: all[name],\n        enumerable: true\n    });\n};\nvar __copyProps = (to, from, except, desc)=>{\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n            get: ()=>from[key],\n            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n        });\n    }\n    return to;\n};\nvar __toCommonJS = (mod)=>__copyProps(__defProp({}, \"__esModule\", {\n        value: true\n    }), mod);\n// src/index.js\nvar index_exports = {};\n__export(index_exports, {\n    createFinalURL: ()=>createFinalURL,\n    createPathBasedClient: ()=>createPathBasedClient,\n    createQuerySerializer: ()=>createQuerySerializer,\n    default: ()=>createClient,\n    defaultBodySerializer: ()=>defaultBodySerializer,\n    defaultPathSerializer: ()=>defaultPathSerializer,\n    mergeHeaders: ()=>mergeHeaders,\n    randomID: ()=>randomID,\n    removeTrailingSlash: ()=>removeTrailingSlash,\n    serializeArrayParam: ()=>serializeArrayParam,\n    serializeObjectParam: ()=>serializeObjectParam,\n    serializePrimitiveParam: ()=>serializePrimitiveParam,\n    wrapAsPathBasedClient: ()=>wrapAsPathBasedClient\n});\nmodule.exports = __toCommonJS(index_exports);\nvar PATH_PARAM_RE = /\\{[^{}]+\\}/g;\nvar supportsRequestInitExt = ()=>{\n    return typeof process === \"object\" && Number.parseInt(process?.versions?.node?.substring(0, 2)) >= 18 && process.versions.undici;\n};\nfunction randomID() {\n    return Math.random().toString(36).slice(2, 11);\n}\nfunction createClient(clientOptions) {\n    let { baseUrl = \"\", Request: CustomRequest = globalThis.Request, fetch: baseFetch = globalThis.fetch, querySerializer: globalQuerySerializer, bodySerializer: globalBodySerializer, headers: baseHeaders, requestInitExt = void 0, ...baseOptions } = {\n        ...clientOptions\n    };\n    requestInitExt = supportsRequestInitExt() ? requestInitExt : void 0;\n    baseUrl = removeTrailingSlash(baseUrl);\n    const middlewares = [];\n    async function coreFetch(schemaPath, fetchOptions) {\n        const { baseUrl: localBaseUrl, fetch = baseFetch, Request = CustomRequest, headers, params = {}, parseAs = \"json\", querySerializer: requestQuerySerializer, bodySerializer = globalBodySerializer ?? defaultBodySerializer, body, ...init } = fetchOptions || {};\n        let finalBaseUrl = baseUrl;\n        if (localBaseUrl) {\n            finalBaseUrl = removeTrailingSlash(localBaseUrl) ?? baseUrl;\n        }\n        let querySerializer = typeof globalQuerySerializer === \"function\" ? globalQuerySerializer : createQuerySerializer(globalQuerySerializer);\n        if (requestQuerySerializer) {\n            querySerializer = typeof requestQuerySerializer === \"function\" ? requestQuerySerializer : createQuerySerializer({\n                ...typeof globalQuerySerializer === \"object\" ? globalQuerySerializer : {},\n                ...requestQuerySerializer\n            });\n        }\n        const serializedBody = body === void 0 ? void 0 : bodySerializer(body, // Note: we declare mergeHeaders() both here and below because it’s a bit of a chicken-or-egg situation:\n        // bodySerializer() needs all headers so we aren’t dropping ones set by the user, however,\n        // the result of this ALSO sets the lowest-priority content-type header. So we re-merge below,\n        // setting the content-type at the very beginning to be overwritten.\n        // Lastly, based on the way headers work, it’s not a simple “present-or-not” check becauase null intentionally un-sets headers.\n        mergeHeaders(baseHeaders, headers, params.header));\n        const finalHeaders = mergeHeaders(// with no body, we should not to set Content-Type\n        serializedBody === void 0 || // if serialized body is FormData; browser will correctly set Content-Type & boundary expression\n        serializedBody instanceof FormData ? {} : {\n            \"Content-Type\": \"application/json\"\n        }, baseHeaders, headers, params.header);\n        const requestInit = {\n            redirect: \"follow\",\n            ...baseOptions,\n            ...init,\n            body: serializedBody,\n            headers: finalHeaders\n        };\n        let id;\n        let options;\n        let request = new CustomRequest(createFinalURL(schemaPath, {\n            baseUrl: finalBaseUrl,\n            params,\n            querySerializer\n        }), requestInit);\n        let response;\n        for(const key in init){\n            if (!(key in request)) {\n                request[key] = init[key];\n            }\n        }\n        if (middlewares.length) {\n            id = randomID();\n            options = Object.freeze({\n                baseUrl: finalBaseUrl,\n                fetch,\n                parseAs,\n                querySerializer,\n                bodySerializer\n            });\n            for (const m of middlewares){\n                if (m && typeof m === \"object\" && typeof m.onRequest === \"function\") {\n                    const result = await m.onRequest({\n                        request,\n                        schemaPath,\n                        params,\n                        options,\n                        id\n                    });\n                    if (result) {\n                        if (result instanceof CustomRequest) {\n                            request = result;\n                        } else if (result instanceof Response) {\n                            response = result;\n                            break;\n                        } else {\n                            throw new Error(\"onRequest: must return new Request() or Response() when modifying the request\");\n                        }\n                    }\n                }\n            }\n        }\n        if (!response) {\n            try {\n                response = await fetch(request, requestInitExt);\n            } catch (error2) {\n                let errorAfterMiddleware = error2;\n                if (middlewares.length) {\n                    for(let i = middlewares.length - 1; i >= 0; i--){\n                        const m = middlewares[i];\n                        if (m && typeof m === \"object\" && typeof m.onError === \"function\") {\n                            const result = await m.onError({\n                                request,\n                                error: errorAfterMiddleware,\n                                schemaPath,\n                                params,\n                                options,\n                                id\n                            });\n                            if (result) {\n                                if (result instanceof Response) {\n                                    errorAfterMiddleware = void 0;\n                                    response = result;\n                                    break;\n                                }\n                                if (result instanceof Error) {\n                                    errorAfterMiddleware = result;\n                                    continue;\n                                }\n                                throw new Error(\"onError: must return new Response() or instance of Error\");\n                            }\n                        }\n                    }\n                }\n                if (errorAfterMiddleware) {\n                    throw errorAfterMiddleware;\n                }\n            }\n            if (middlewares.length) {\n                for(let i = middlewares.length - 1; i >= 0; i--){\n                    const m = middlewares[i];\n                    if (m && typeof m === \"object\" && typeof m.onResponse === \"function\") {\n                        const result = await m.onResponse({\n                            request,\n                            response,\n                            schemaPath,\n                            params,\n                            options,\n                            id\n                        });\n                        if (result) {\n                            if (!(result instanceof Response)) {\n                                throw new Error(\"onResponse: must return new Response() when modifying the response\");\n                            }\n                            response = result;\n                        }\n                    }\n                }\n            }\n        }\n        if (response.status === 204 || request.method === \"HEAD\" || response.headers.get(\"Content-Length\") === \"0\") {\n            return response.ok ? {\n                data: void 0,\n                response\n            } : {\n                error: void 0,\n                response\n            };\n        }\n        if (response.ok) {\n            if (parseAs === \"stream\") {\n                return {\n                    data: response.body,\n                    response\n                };\n            }\n            return {\n                data: await response[parseAs](),\n                response\n            };\n        }\n        let error = await response.text();\n        try {\n            error = JSON.parse(error);\n        } catch  {}\n        return {\n            error,\n            response\n        };\n    }\n    return {\n        request (method, url, init) {\n            return coreFetch(url, {\n                ...init,\n                method: method.toUpperCase()\n            });\n        },\n        /** Call a GET endpoint */ GET (url, init) {\n            return coreFetch(url, {\n                ...init,\n                method: \"GET\"\n            });\n        },\n        /** Call a PUT endpoint */ PUT (url, init) {\n            return coreFetch(url, {\n                ...init,\n                method: \"PUT\"\n            });\n        },\n        /** Call a POST endpoint */ POST (url, init) {\n            return coreFetch(url, {\n                ...init,\n                method: \"POST\"\n            });\n        },\n        /** Call a DELETE endpoint */ DELETE (url, init) {\n            return coreFetch(url, {\n                ...init,\n                method: \"DELETE\"\n            });\n        },\n        /** Call a OPTIONS endpoint */ OPTIONS (url, init) {\n            return coreFetch(url, {\n                ...init,\n                method: \"OPTIONS\"\n            });\n        },\n        /** Call a HEAD endpoint */ HEAD (url, init) {\n            return coreFetch(url, {\n                ...init,\n                method: \"HEAD\"\n            });\n        },\n        /** Call a PATCH endpoint */ PATCH (url, init) {\n            return coreFetch(url, {\n                ...init,\n                method: \"PATCH\"\n            });\n        },\n        /** Call a TRACE endpoint */ TRACE (url, init) {\n            return coreFetch(url, {\n                ...init,\n                method: \"TRACE\"\n            });\n        },\n        /** Register middleware */ use (...middleware) {\n            for (const m of middleware){\n                if (!m) {\n                    continue;\n                }\n                if (typeof m !== \"object\" || !(\"onRequest\" in m || \"onResponse\" in m || \"onError\" in m)) {\n                    throw new Error(\"Middleware must be an object with one of `onRequest()`, `onResponse() or `onError()`\");\n                }\n                middlewares.push(m);\n            }\n        },\n        /** Unregister middleware */ eject (...middleware) {\n            for (const m of middleware){\n                const i = middlewares.indexOf(m);\n                if (i !== -1) {\n                    middlewares.splice(i, 1);\n                }\n            }\n        }\n    };\n}\nvar PathCallForwarder = class {\n    constructor(client, url){\n        this.GET = (init)=>{\n            return this.client.GET(this.url, init);\n        };\n        this.PUT = (init)=>{\n            return this.client.PUT(this.url, init);\n        };\n        this.POST = (init)=>{\n            return this.client.POST(this.url, init);\n        };\n        this.DELETE = (init)=>{\n            return this.client.DELETE(this.url, init);\n        };\n        this.OPTIONS = (init)=>{\n            return this.client.OPTIONS(this.url, init);\n        };\n        this.HEAD = (init)=>{\n            return this.client.HEAD(this.url, init);\n        };\n        this.PATCH = (init)=>{\n            return this.client.PATCH(this.url, init);\n        };\n        this.TRACE = (init)=>{\n            return this.client.TRACE(this.url, init);\n        };\n        this.client = client;\n        this.url = url;\n    }\n};\nvar PathClientProxyHandler = class {\n    constructor(){\n        this.client = null;\n    }\n    // Assume the property is an URL.\n    get(coreClient, url) {\n        const forwarder = new PathCallForwarder(coreClient, url);\n        this.client[url] = forwarder;\n        return forwarder;\n    }\n};\nfunction wrapAsPathBasedClient(coreClient) {\n    const handler = new PathClientProxyHandler();\n    const proxy = new Proxy(coreClient, handler);\n    function Client() {}\n    Client.prototype = proxy;\n    const client = new Client();\n    handler.client = client;\n    return client;\n}\nfunction createPathBasedClient(clientOptions) {\n    return wrapAsPathBasedClient(createClient(clientOptions));\n}\nfunction serializePrimitiveParam(name, value, options) {\n    if (value === void 0 || value === null) {\n        return \"\";\n    }\n    if (typeof value === \"object\") {\n        throw new Error(\"Deeply-nested arrays/objects aren’t supported. Provide your own `querySerializer()` to handle these.\");\n    }\n    return `${name}=${options?.allowReserved === true ? value : encodeURIComponent(value)}`;\n}\nfunction serializeObjectParam(name, value, options) {\n    if (!value || typeof value !== \"object\") {\n        return \"\";\n    }\n    const values = [];\n    const joiner = {\n        simple: \",\",\n        label: \".\",\n        matrix: \";\"\n    }[options.style] || \"&\";\n    if (options.style !== \"deepObject\" && options.explode === false) {\n        for(const k in value){\n            values.push(k, options.allowReserved === true ? value[k] : encodeURIComponent(value[k]));\n        }\n        const final2 = values.join(\",\");\n        switch(options.style){\n            case \"form\":\n                {\n                    return `${name}=${final2}`;\n                }\n            case \"label\":\n                {\n                    return `.${final2}`;\n                }\n            case \"matrix\":\n                {\n                    return `;${name}=${final2}`;\n                }\n            default:\n                {\n                    return final2;\n                }\n        }\n    }\n    for(const k in value){\n        const finalName = options.style === \"deepObject\" ? `${name}[${k}]` : k;\n        values.push(serializePrimitiveParam(finalName, value[k], options));\n    }\n    const final = values.join(joiner);\n    return options.style === \"label\" || options.style === \"matrix\" ? `${joiner}${final}` : final;\n}\nfunction serializeArrayParam(name, value, options) {\n    if (!Array.isArray(value)) {\n        return \"\";\n    }\n    if (options.explode === false) {\n        const joiner2 = {\n            form: \",\",\n            spaceDelimited: \"%20\",\n            pipeDelimited: \"|\"\n        }[options.style] || \",\";\n        const final = (options.allowReserved === true ? value : value.map((v)=>encodeURIComponent(v))).join(joiner2);\n        switch(options.style){\n            case \"simple\":\n                {\n                    return final;\n                }\n            case \"label\":\n                {\n                    return `.${final}`;\n                }\n            case \"matrix\":\n                {\n                    return `;${name}=${final}`;\n                }\n            // case \"spaceDelimited\":\n            // case \"pipeDelimited\":\n            default:\n                {\n                    return `${name}=${final}`;\n                }\n        }\n    }\n    const joiner = {\n        simple: \",\",\n        label: \".\",\n        matrix: \";\"\n    }[options.style] || \"&\";\n    const values = [];\n    for (const v of value){\n        if (options.style === \"simple\" || options.style === \"label\") {\n            values.push(options.allowReserved === true ? v : encodeURIComponent(v));\n        } else {\n            values.push(serializePrimitiveParam(name, v, options));\n        }\n    }\n    return options.style === \"label\" || options.style === \"matrix\" ? `${joiner}${values.join(joiner)}` : values.join(joiner);\n}\nfunction createQuerySerializer(options) {\n    return function querySerializer(queryParams) {\n        const search = [];\n        if (queryParams && typeof queryParams === \"object\") {\n            for(const name in queryParams){\n                const value = queryParams[name];\n                if (value === void 0 || value === null) {\n                    continue;\n                }\n                if (Array.isArray(value)) {\n                    if (value.length === 0) {\n                        continue;\n                    }\n                    search.push(serializeArrayParam(name, value, {\n                        style: \"form\",\n                        explode: true,\n                        ...options?.array,\n                        allowReserved: options?.allowReserved || false\n                    }));\n                    continue;\n                }\n                if (typeof value === \"object\") {\n                    search.push(serializeObjectParam(name, value, {\n                        style: \"deepObject\",\n                        explode: true,\n                        ...options?.object,\n                        allowReserved: options?.allowReserved || false\n                    }));\n                    continue;\n                }\n                search.push(serializePrimitiveParam(name, value, options));\n            }\n        }\n        return search.join(\"&\");\n    };\n}\nfunction defaultPathSerializer(pathname, pathParams) {\n    let nextURL = pathname;\n    for (const match of pathname.match(PATH_PARAM_RE) ?? []){\n        let name = match.substring(1, match.length - 1);\n        let explode = false;\n        let style = \"simple\";\n        if (name.endsWith(\"*\")) {\n            explode = true;\n            name = name.substring(0, name.length - 1);\n        }\n        if (name.startsWith(\".\")) {\n            style = \"label\";\n            name = name.substring(1);\n        } else if (name.startsWith(\";\")) {\n            style = \"matrix\";\n            name = name.substring(1);\n        }\n        if (!pathParams || pathParams[name] === void 0 || pathParams[name] === null) {\n            continue;\n        }\n        const value = pathParams[name];\n        if (Array.isArray(value)) {\n            nextURL = nextURL.replace(match, serializeArrayParam(name, value, {\n                style,\n                explode\n            }));\n            continue;\n        }\n        if (typeof value === \"object\") {\n            nextURL = nextURL.replace(match, serializeObjectParam(name, value, {\n                style,\n                explode\n            }));\n            continue;\n        }\n        if (style === \"matrix\") {\n            nextURL = nextURL.replace(match, `;${serializePrimitiveParam(name, value)}`);\n            continue;\n        }\n        nextURL = nextURL.replace(match, style === \"label\" ? `.${encodeURIComponent(value)}` : encodeURIComponent(value));\n    }\n    return nextURL;\n}\nfunction defaultBodySerializer(body, headers) {\n    if (body instanceof FormData) {\n        return body;\n    }\n    if (headers) {\n        const contentType = headers.get instanceof Function ? headers.get(\"Content-Type\") ?? headers.get(\"content-type\") : headers[\"Content-Type\"] ?? headers[\"content-type\"];\n        if (contentType === \"application/x-www-form-urlencoded\") {\n            return new URLSearchParams(body).toString();\n        }\n    }\n    return JSON.stringify(body);\n}\nfunction createFinalURL(pathname, options) {\n    let finalURL = `${options.baseUrl}${pathname}`;\n    if (options.params?.path) {\n        finalURL = defaultPathSerializer(finalURL, options.params.path);\n    }\n    let search = options.querySerializer(options.params.query ?? {});\n    if (search.startsWith(\"?\")) {\n        search = search.substring(1);\n    }\n    if (search) {\n        finalURL += `?${search}`;\n    }\n    return finalURL;\n}\nfunction mergeHeaders(...allHeaders) {\n    const finalHeaders = new Headers();\n    for (const h of allHeaders){\n        if (!h || typeof h !== \"object\") {\n            continue;\n        }\n        const iterator = h instanceof Headers ? h.entries() : Object.entries(h);\n        for (const [k, v] of iterator){\n            if (v === null) {\n                finalHeaders.delete(k);\n            } else if (Array.isArray(v)) {\n                for (const v2 of v){\n                    finalHeaders.append(k, v2);\n                }\n            } else if (v !== void 0) {\n                finalHeaders.set(k, v);\n            }\n        }\n    }\n    return finalHeaders;\n}\nfunction removeTrailingSlash(url) {\n    if (url.endsWith(\"/\")) {\n        return url.substring(0, url.length - 1);\n    }\n    return url;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3BlbmFwaS1mZXRjaC9kaXN0L2Nqcy9pbmRleC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxZQUFZQyxPQUFPQyxjQUFjO0FBQ3JDLElBQUlDLG1CQUFtQkYsT0FBT0csd0JBQXdCO0FBQ3RELElBQUlDLG9CQUFvQkosT0FBT0ssbUJBQW1CO0FBQ2xELElBQUlDLGVBQWVOLE9BQU9PLFNBQVMsQ0FBQ0MsY0FBYztBQUNsRCxJQUFJQyxXQUFXLENBQUNDLFFBQVFDO0lBQ3RCLElBQUssSUFBSUMsUUFBUUQsSUFDZlosVUFBVVcsUUFBUUUsTUFBTTtRQUFFQyxLQUFLRixHQUFHLENBQUNDLEtBQUs7UUFBRUUsWUFBWTtJQUFLO0FBQy9EO0FBQ0EsSUFBSUMsY0FBYyxDQUFDQyxJQUFJQyxNQUFNQyxRQUFRQztJQUNuQyxJQUFJRixRQUFRLE9BQU9BLFNBQVMsWUFBWSxPQUFPQSxTQUFTLFlBQVk7UUFDbEUsS0FBSyxJQUFJRyxPQUFPaEIsa0JBQWtCYSxNQUNoQyxJQUFJLENBQUNYLGFBQWFlLElBQUksQ0FBQ0wsSUFBSUksUUFBUUEsUUFBUUYsUUFDekNuQixVQUFVaUIsSUFBSUksS0FBSztZQUFFUCxLQUFLLElBQU1JLElBQUksQ0FBQ0csSUFBSTtZQUFFTixZQUFZLENBQUVLLENBQUFBLE9BQU9qQixpQkFBaUJlLE1BQU1HLElBQUcsS0FBTUQsS0FBS0wsVUFBVTtRQUFDO0lBQ3RIO0lBQ0EsT0FBT0U7QUFDVDtBQUNBLElBQUlNLGVBQWUsQ0FBQ0MsTUFBUVIsWUFBWWhCLFVBQVUsQ0FBQyxHQUFHLGNBQWM7UUFBRXlCLE9BQU87SUFBSyxJQUFJRDtBQUV0RixlQUFlO0FBQ2YsSUFBSUUsZ0JBQWdCLENBQUM7QUFDckJoQixTQUFTZ0IsZUFBZTtJQUN0QkMsZ0JBQWdCLElBQU1BO0lBQ3RCQyx1QkFBdUIsSUFBTUE7SUFDN0JDLHVCQUF1QixJQUFNQTtJQUM3QkMsU0FBUyxJQUFNQztJQUNmQyx1QkFBdUIs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QUkrRjtJQUN6QixLQUFLLE1BQU1DLEtBQUtGLFdBQVk7UUFDMUIsSUFBSSxDQUFDRSxLQUFLLE9BQU9BLE1BQU0sVUFBVTtZQUMvQjtRQUNGO1FBQ0EsTUFBTUMsV0FBV0QsYUFBYUQsVUFBVUMsRUFBRUUsT0FBTyxLQUFLckwsT0FBT3FMLE9BQU8sQ0FBQ0Y7UUFDckUsS0FBSyxNQUFNLENBQUNqQyxHQUFHWSxFQUFFLElBQUlzQixTQUFVO1lBQzdCLElBQUl0QixNQUFNLE1BQU07Z0JBQ2QzRSxhQUFhbUcsTUFBTSxDQUFDcEM7WUFDdEIsT0FBTyxJQUFJSyxNQUFNQyxPQUFPLENBQUNNLElBQUk7Z0JBQzNCLEtBQUssTUFBTXlCLE1BQU16QixFQUFHO29CQUNsQjNFLGFBQWFxRyxNQUFNLENBQUN0QyxHQUFHcUM7Z0JBQ3pCO1lBQ0YsT0FBTyxJQUFJekIsTUFBTSxLQUFLLEdBQUc7Z0JBQ3ZCM0UsYUFBYXNHLEdBQUcsQ0FBQ3ZDLEdBQUdZO1lBQ3RCO1FBQ0Y7SUFDRjtJQUNBLE9BQU8zRTtBQUNUO0FBQ0EsU0FBU2hELG9CQUFvQjRFLEdBQUc7SUFDOUIsSUFBSUEsSUFBSXdELFFBQVEsQ0FBQyxNQUFNO1FBQ3JCLE9BQU94RCxJQUFJOUQsU0FBUyxDQUFDLEdBQUc4RCxJQUFJcEIsTUFBTSxHQUFHO0lBQ3ZDO0lBQ0EsT0FBT29CO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGF3LXdvcmtzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL29wZW5hcGktZmV0Y2gvZGlzdC9janMvaW5kZXguY2pzPzYzMzciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xuXG4vLyBzcmMvaW5kZXguanNcbnZhciBpbmRleF9leHBvcnRzID0ge307XG5fX2V4cG9ydChpbmRleF9leHBvcnRzLCB7XG4gIGNyZWF0ZUZpbmFsVVJMOiAoKSA9PiBjcmVhdGVGaW5hbFVSTCxcbiAgY3JlYXRlUGF0aEJhc2VkQ2xpZW50OiAoKSA9PiBjcmVhdGVQYXRoQmFzZWRDbGllbnQsXG4gIGNyZWF0ZVF1ZXJ5U2VyaWFsaXplcjogKCkgPT4gY3JlYXRlUXVlcnlTZXJpYWxpemVyLFxuICBkZWZhdWx0OiAoKSA9PiBjcmVhdGVDbGllbnQsXG4gIGRlZmF1bHRCb2R5U2VyaWFsaXplcjogKCkgPT4gZGVmYXVsdEJvZHlTZXJpYWxpemVyLFxuICBkZWZhdWx0UGF0aFNlcmlhbGl6ZXI6ICgpID0+IGRlZmF1bHRQYXRoU2VyaWFsaXplcixcbiAgbWVyZ2VIZWFkZXJzOiAoKSA9PiBtZXJnZUhlYWRlcnMsXG4gIHJhbmRvbUlEOiAoKSA9PiByYW5kb21JRCxcbiAgcmVtb3ZlVHJhaWxpbmdTbGFzaDogKCkgPT4gcmVtb3ZlVHJhaWxpbmdTbGFzaCxcbiAgc2VyaWFsaXplQXJyYXlQYXJhbTogKCkgPT4gc2VyaWFsaXplQXJyYXlQYXJhbSxcbiAgc2VyaWFsaXplT2JqZWN0UGFyYW06ICgpID0+IHNlcmlhbGl6ZU9iamVjdFBhcmFtLFxuICBzZXJpYWxpemVQcmltaXRpdmVQYXJhbTogKCkgPT4gc2VyaWFsaXplUHJpbWl0aXZlUGFyYW0sXG4gIHdyYXBBc1BhdGhCYXNlZENsaWVudDogKCkgPT4gd3JhcEFzUGF0aEJhc2VkQ2xpZW50XG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKGluZGV4X2V4cG9ydHMpO1xudmFyIFBBVEhfUEFSQU1fUkUgPSAvXFx7W157fV0rXFx9L2c7XG52YXIgc3VwcG9ydHNSZXF1ZXN0SW5pdEV4dCA9ICgpID0+IHtcbiAgcmV0dXJuIHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIE51bWJlci5wYXJzZUludChwcm9jZXNzPy52ZXJzaW9ucz8ubm9kZT8uc3Vic3RyaW5nKDAsIDIpKSA+PSAxOCAmJiBwcm9jZXNzLnZlcnNpb25zLnVuZGljaTtcbn07XG5mdW5jdGlvbiByYW5kb21JRCgpIHtcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIsIDExKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNsaWVudChjbGllbnRPcHRpb25zKSB7XG4gIGxldCB7XG4gICAgYmFzZVVybCA9IFwiXCIsXG4gICAgUmVxdWVzdDogQ3VzdG9tUmVxdWVzdCA9IGdsb2JhbFRoaXMuUmVxdWVzdCxcbiAgICBmZXRjaDogYmFzZUZldGNoID0gZ2xvYmFsVGhpcy5mZXRjaCxcbiAgICBxdWVyeVNlcmlhbGl6ZXI6IGdsb2JhbFF1ZXJ5U2VyaWFsaXplcixcbiAgICBib2R5U2VyaWFsaXplcjogZ2xvYmFsQm9keVNlcmlhbGl6ZXIsXG4gICAgaGVhZGVyczogYmFzZUhlYWRlcnMsXG4gICAgcmVxdWVzdEluaXRFeHQgPSB2b2lkIDAsXG4gICAgLi4uYmFzZU9wdGlvbnNcbiAgfSA9IHsgLi4uY2xpZW50T3B0aW9ucyB9O1xuICByZXF1ZXN0SW5pdEV4dCA9IHN1cHBvcnRzUmVxdWVzdEluaXRFeHQoKSA/IHJlcXVlc3RJbml0RXh0IDogdm9pZCAwO1xuICBiYXNlVXJsID0gcmVtb3ZlVHJhaWxpbmdTbGFzaChiYXNlVXJsKTtcbiAgY29uc3QgbWlkZGxld2FyZXMgPSBbXTtcbiAgYXN5bmMgZnVuY3Rpb24gY29yZUZldGNoKHNjaGVtYVBhdGgsIGZldGNoT3B0aW9ucykge1xuICAgIGNvbnN0IHtcbiAgICAgIGJhc2VVcmw6IGxvY2FsQmFzZVVybCxcbiAgICAgIGZldGNoID0gYmFzZUZldGNoLFxuICAgICAgUmVxdWVzdCA9IEN1c3RvbVJlcXVlc3QsXG4gICAgICBoZWFkZXJzLFxuICAgICAgcGFyYW1zID0ge30sXG4gICAgICBwYXJzZUFzID0gXCJqc29uXCIsXG4gICAgICBxdWVyeVNlcmlhbGl6ZXI6IHJlcXVlc3RRdWVyeVNlcmlhbGl6ZXIsXG4gICAgICBib2R5U2VyaWFsaXplciA9IGdsb2JhbEJvZHlTZXJpYWxpemVyID8/IGRlZmF1bHRCb2R5U2VyaWFsaXplcixcbiAgICAgIGJvZHksXG4gICAgICAuLi5pbml0XG4gICAgfSA9IGZldGNoT3B0aW9ucyB8fCB7fTtcbiAgICBsZXQgZmluYWxCYXNlVXJsID0gYmFzZVVybDtcbiAgICBpZiAobG9jYWxCYXNlVXJsKSB7XG4gICAgICBmaW5hbEJhc2VVcmwgPSByZW1vdmVUcmFpbGluZ1NsYXNoKGxvY2FsQmFzZVVybCkgPz8gYmFzZVVybDtcbiAgICB9XG4gICAgbGV0IHF1ZXJ5U2VyaWFsaXplciA9IHR5cGVvZiBnbG9iYWxRdWVyeVNlcmlhbGl6ZXIgPT09IFwiZnVuY3Rpb25cIiA/IGdsb2JhbFF1ZXJ5U2VyaWFsaXplciA6IGNyZWF0ZVF1ZXJ5U2VyaWFsaXplcihnbG9iYWxRdWVyeVNlcmlhbGl6ZXIpO1xuICAgIGlmIChyZXF1ZXN0UXVlcnlTZXJpYWxpemVyKSB7XG4gICAgICBxdWVyeVNlcmlhbGl6ZXIgPSB0eXBlb2YgcmVxdWVzdFF1ZXJ5U2VyaWFsaXplciA9PT0gXCJmdW5jdGlvblwiID8gcmVxdWVzdFF1ZXJ5U2VyaWFsaXplciA6IGNyZWF0ZVF1ZXJ5U2VyaWFsaXplcih7XG4gICAgICAgIC4uLnR5cGVvZiBnbG9iYWxRdWVyeVNlcmlhbGl6ZXIgPT09IFwib2JqZWN0XCIgPyBnbG9iYWxRdWVyeVNlcmlhbGl6ZXIgOiB7fSxcbiAgICAgICAgLi4ucmVxdWVzdFF1ZXJ5U2VyaWFsaXplclxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHNlcmlhbGl6ZWRCb2R5ID0gYm9keSA9PT0gdm9pZCAwID8gdm9pZCAwIDogYm9keVNlcmlhbGl6ZXIoXG4gICAgICBib2R5LFxuICAgICAgLy8gTm90ZTogd2UgZGVjbGFyZSBtZXJnZUhlYWRlcnMoKSBib3RoIGhlcmUgYW5kIGJlbG93IGJlY2F1c2UgaXTigJlzIGEgYml0IG9mIGEgY2hpY2tlbi1vci1lZ2cgc2l0dWF0aW9uOlxuICAgICAgLy8gYm9keVNlcmlhbGl6ZXIoKSBuZWVkcyBhbGwgaGVhZGVycyBzbyB3ZSBhcmVu4oCZdCBkcm9wcGluZyBvbmVzIHNldCBieSB0aGUgdXNlciwgaG93ZXZlcixcbiAgICAgIC8vIHRoZSByZXN1bHQgb2YgdGhpcyBBTFNPIHNldHMgdGhlIGxvd2VzdC1wcmlvcml0eSBjb250ZW50LXR5cGUgaGVhZGVyLiBTbyB3ZSByZS1tZXJnZSBiZWxvdyxcbiAgICAgIC8vIHNldHRpbmcgdGhlIGNvbnRlbnQtdHlwZSBhdCB0aGUgdmVyeSBiZWdpbm5pbmcgdG8gYmUgb3ZlcndyaXR0ZW4uXG4gICAgICAvLyBMYXN0bHksIGJhc2VkIG9uIHRoZSB3YXkgaGVhZGVycyB3b3JrLCBpdOKAmXMgbm90IGEgc2ltcGxlwqDigJxwcmVzZW50LW9yLW5vdOKAnSBjaGVjayBiZWNhdWFzZSBudWxsIGludGVudGlvbmFsbHkgdW4tc2V0cyBoZWFkZXJzLlxuICAgICAgbWVyZ2VIZWFkZXJzKGJhc2VIZWFkZXJzLCBoZWFkZXJzLCBwYXJhbXMuaGVhZGVyKVxuICAgICk7XG4gICAgY29uc3QgZmluYWxIZWFkZXJzID0gbWVyZ2VIZWFkZXJzKFxuICAgICAgLy8gd2l0aCBubyBib2R5LCB3ZSBzaG91bGQgbm90IHRvIHNldCBDb250ZW50LVR5cGVcbiAgICAgIHNlcmlhbGl6ZWRCb2R5ID09PSB2b2lkIDAgfHwgLy8gaWYgc2VyaWFsaXplZCBib2R5IGlzIEZvcm1EYXRhOyBicm93c2VyIHdpbGwgY29ycmVjdGx5IHNldCBDb250ZW50LVR5cGUgJiBib3VuZGFyeSBleHByZXNzaW9uXG4gICAgICBzZXJpYWxpemVkQm9keSBpbnN0YW5jZW9mIEZvcm1EYXRhID8ge30gOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICB9LFxuICAgICAgYmFzZUhlYWRlcnMsXG4gICAgICBoZWFkZXJzLFxuICAgICAgcGFyYW1zLmhlYWRlclxuICAgICk7XG4gICAgY29uc3QgcmVxdWVzdEluaXQgPSB7XG4gICAgICByZWRpcmVjdDogXCJmb2xsb3dcIixcbiAgICAgIC4uLmJhc2VPcHRpb25zLFxuICAgICAgLi4uaW5pdCxcbiAgICAgIGJvZHk6IHNlcmlhbGl6ZWRCb2R5LFxuICAgICAgaGVhZGVyczogZmluYWxIZWFkZXJzXG4gICAgfTtcbiAgICBsZXQgaWQ7XG4gICAgbGV0IG9wdGlvbnM7XG4gICAgbGV0IHJlcXVlc3QgPSBuZXcgQ3VzdG9tUmVxdWVzdChcbiAgICAgIGNyZWF0ZUZpbmFsVVJMKHNjaGVtYVBhdGgsIHsgYmFzZVVybDogZmluYWxCYXNlVXJsLCBwYXJhbXMsIHF1ZXJ5U2VyaWFsaXplciB9KSxcbiAgICAgIHJlcXVlc3RJbml0XG4gICAgKTtcbiAgICBsZXQgcmVzcG9uc2U7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gaW5pdCkge1xuICAgICAgaWYgKCEoa2V5IGluIHJlcXVlc3QpKSB7XG4gICAgICAgIHJlcXVlc3Rba2V5XSA9IGluaXRba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1pZGRsZXdhcmVzLmxlbmd0aCkge1xuICAgICAgaWQgPSByYW5kb21JRCgpO1xuICAgICAgb3B0aW9ucyA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBiYXNlVXJsOiBmaW5hbEJhc2VVcmwsXG4gICAgICAgIGZldGNoLFxuICAgICAgICBwYXJzZUFzLFxuICAgICAgICBxdWVyeVNlcmlhbGl6ZXIsXG4gICAgICAgIGJvZHlTZXJpYWxpemVyXG4gICAgICB9KTtcbiAgICAgIGZvciAoY29uc3QgbSBvZiBtaWRkbGV3YXJlcykge1xuICAgICAgICBpZiAobSAmJiB0eXBlb2YgbSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbS5vblJlcXVlc3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG0ub25SZXF1ZXN0KHtcbiAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICBzY2hlbWFQYXRoLFxuICAgICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIGlkXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIEN1c3RvbVJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgcmVxdWVzdCA9IHJlc3VsdDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0IGluc3RhbmNlb2YgUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgcmVzcG9uc2UgPSByZXN1bHQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwib25SZXF1ZXN0OiBtdXN0IHJldHVybiBuZXcgUmVxdWVzdCgpIG9yIFJlc3BvbnNlKCkgd2hlbiBtb2RpZnlpbmcgdGhlIHJlcXVlc3RcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc3BvbnNlID0gYXdhaXQgZmV0Y2gocmVxdWVzdCwgcmVxdWVzdEluaXRFeHQpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgICAgIGxldCBlcnJvckFmdGVyTWlkZGxld2FyZSA9IGVycm9yMjtcbiAgICAgICAgaWYgKG1pZGRsZXdhcmVzLmxlbmd0aCkge1xuICAgICAgICAgIGZvciAobGV0IGkgPSBtaWRkbGV3YXJlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgY29uc3QgbSA9IG1pZGRsZXdhcmVzW2ldO1xuICAgICAgICAgICAgaWYgKG0gJiYgdHlwZW9mIG0gPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG0ub25FcnJvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG0ub25FcnJvcih7XG4gICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3JBZnRlck1pZGRsZXdhcmUsXG4gICAgICAgICAgICAgICAgc2NoZW1hUGF0aCxcbiAgICAgICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgICAgICBpZFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgZXJyb3JBZnRlck1pZGRsZXdhcmUgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICByZXNwb25zZSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIGVycm9yQWZ0ZXJNaWRkbGV3YXJlID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm9uRXJyb3I6IG11c3QgcmV0dXJuIG5ldyBSZXNwb25zZSgpIG9yIGluc3RhbmNlIG9mIEVycm9yXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvckFmdGVyTWlkZGxld2FyZSkge1xuICAgICAgICAgIHRocm93IGVycm9yQWZ0ZXJNaWRkbGV3YXJlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobWlkZGxld2FyZXMubGVuZ3RoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBtaWRkbGV3YXJlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGNvbnN0IG0gPSBtaWRkbGV3YXJlc1tpXTtcbiAgICAgICAgICBpZiAobSAmJiB0eXBlb2YgbSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbS5vblJlc3BvbnNlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG0ub25SZXNwb25zZSh7XG4gICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICBzY2hlbWFQYXRoLFxuICAgICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgIGlkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgaWYgKCEocmVzdWx0IGluc3RhbmNlb2YgUmVzcG9uc2UpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwib25SZXNwb25zZTogbXVzdCByZXR1cm4gbmV3IFJlc3BvbnNlKCkgd2hlbiBtb2RpZnlpbmcgdGhlIHJlc3BvbnNlXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc3BvbnNlID0gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDQgfHwgcmVxdWVzdC5tZXRob2QgPT09IFwiSEVBRFwiIHx8IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiQ29udGVudC1MZW5ndGhcIikgPT09IFwiMFwiKSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2Uub2sgPyB7IGRhdGE6IHZvaWQgMCwgcmVzcG9uc2UgfSA6IHsgZXJyb3I6IHZvaWQgMCwgcmVzcG9uc2UgfTtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICBpZiAocGFyc2VBcyA9PT0gXCJzdHJlYW1cIikge1xuICAgICAgICByZXR1cm4geyBkYXRhOiByZXNwb25zZS5ib2R5LCByZXNwb25zZSB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgZGF0YTogYXdhaXQgcmVzcG9uc2VbcGFyc2VBc10oKSwgcmVzcG9uc2UgfTtcbiAgICB9XG4gICAgbGV0IGVycm9yID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgIHRyeSB7XG4gICAgICBlcnJvciA9IEpTT04ucGFyc2UoZXJyb3IpO1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgICByZXR1cm4geyBlcnJvciwgcmVzcG9uc2UgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHJlcXVlc3QobWV0aG9kLCB1cmwsIGluaXQpIHtcbiAgICAgIHJldHVybiBjb3JlRmV0Y2godXJsLCB7IC4uLmluaXQsIG1ldGhvZDogbWV0aG9kLnRvVXBwZXJDYXNlKCkgfSk7XG4gICAgfSxcbiAgICAvKiogQ2FsbCBhIEdFVCBlbmRwb2ludCAqL1xuICAgIEdFVCh1cmwsIGluaXQpIHtcbiAgICAgIHJldHVybiBjb3JlRmV0Y2godXJsLCB7IC4uLmluaXQsIG1ldGhvZDogXCJHRVRcIiB9KTtcbiAgICB9LFxuICAgIC8qKiBDYWxsIGEgUFVUIGVuZHBvaW50ICovXG4gICAgUFVUKHVybCwgaW5pdCkge1xuICAgICAgcmV0dXJuIGNvcmVGZXRjaCh1cmwsIHsgLi4uaW5pdCwgbWV0aG9kOiBcIlBVVFwiIH0pO1xuICAgIH0sXG4gICAgLyoqIENhbGwgYSBQT1NUIGVuZHBvaW50ICovXG4gICAgUE9TVCh1cmwsIGluaXQpIHtcbiAgICAgIHJldHVybiBjb3JlRmV0Y2godXJsLCB7IC4uLmluaXQsIG1ldGhvZDogXCJQT1NUXCIgfSk7XG4gICAgfSxcbiAgICAvKiogQ2FsbCBhIERFTEVURSBlbmRwb2ludCAqL1xuICAgIERFTEVURSh1cmwsIGluaXQpIHtcbiAgICAgIHJldHVybiBjb3JlRmV0Y2godXJsLCB7IC4uLmluaXQsIG1ldGhvZDogXCJERUxFVEVcIiB9KTtcbiAgICB9LFxuICAgIC8qKiBDYWxsIGEgT1BUSU9OUyBlbmRwb2ludCAqL1xuICAgIE9QVElPTlModXJsLCBpbml0KSB7XG4gICAgICByZXR1cm4gY29yZUZldGNoKHVybCwgeyAuLi5pbml0LCBtZXRob2Q6IFwiT1BUSU9OU1wiIH0pO1xuICAgIH0sXG4gICAgLyoqIENhbGwgYSBIRUFEIGVuZHBvaW50ICovXG4gICAgSEVBRCh1cmwsIGluaXQpIHtcbiAgICAgIHJldHVybiBjb3JlRmV0Y2godXJsLCB7IC4uLmluaXQsIG1ldGhvZDogXCJIRUFEXCIgfSk7XG4gICAgfSxcbiAgICAvKiogQ2FsbCBhIFBBVENIIGVuZHBvaW50ICovXG4gICAgUEFUQ0godXJsLCBpbml0KSB7XG4gICAgICByZXR1cm4gY29yZUZldGNoKHVybCwgeyAuLi5pbml0LCBtZXRob2Q6IFwiUEFUQ0hcIiB9KTtcbiAgICB9LFxuICAgIC8qKiBDYWxsIGEgVFJBQ0UgZW5kcG9pbnQgKi9cbiAgICBUUkFDRSh1cmwsIGluaXQpIHtcbiAgICAgIHJldHVybiBjb3JlRmV0Y2godXJsLCB7IC4uLmluaXQsIG1ldGhvZDogXCJUUkFDRVwiIH0pO1xuICAgIH0sXG4gICAgLyoqIFJlZ2lzdGVyIG1pZGRsZXdhcmUgKi9cbiAgICB1c2UoLi4ubWlkZGxld2FyZSkge1xuICAgICAgZm9yIChjb25zdCBtIG9mIG1pZGRsZXdhcmUpIHtcbiAgICAgICAgaWYgKCFtKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBtICE9PSBcIm9iamVjdFwiIHx8ICEoXCJvblJlcXVlc3RcIiBpbiBtIHx8IFwib25SZXNwb25zZVwiIGluIG0gfHwgXCJvbkVycm9yXCIgaW4gbSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaWRkbGV3YXJlIG11c3QgYmUgYW4gb2JqZWN0IHdpdGggb25lIG9mIGBvblJlcXVlc3QoKWAsIGBvblJlc3BvbnNlKCkgb3IgYG9uRXJyb3IoKWBcIik7XG4gICAgICAgIH1cbiAgICAgICAgbWlkZGxld2FyZXMucHVzaChtKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKiBVbnJlZ2lzdGVyIG1pZGRsZXdhcmUgKi9cbiAgICBlamVjdCguLi5taWRkbGV3YXJlKSB7XG4gICAgICBmb3IgKGNvbnN0IG0gb2YgbWlkZGxld2FyZSkge1xuICAgICAgICBjb25zdCBpID0gbWlkZGxld2FyZXMuaW5kZXhPZihtKTtcbiAgICAgICAgaWYgKGkgIT09IC0xKSB7XG4gICAgICAgICAgbWlkZGxld2FyZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxudmFyIFBhdGhDYWxsRm9yd2FyZGVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjbGllbnQsIHVybCkge1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIHRoaXMudXJsID0gdXJsO1xuICB9XG4gIEdFVCA9IChpbml0KSA9PiB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LkdFVCh0aGlzLnVybCwgaW5pdCk7XG4gIH07XG4gIFBVVCA9IChpbml0KSA9PiB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LlBVVCh0aGlzLnVybCwgaW5pdCk7XG4gIH07XG4gIFBPU1QgPSAoaW5pdCkgPT4ge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5QT1NUKHRoaXMudXJsLCBpbml0KTtcbiAgfTtcbiAgREVMRVRFID0gKGluaXQpID0+IHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuREVMRVRFKHRoaXMudXJsLCBpbml0KTtcbiAgfTtcbiAgT1BUSU9OUyA9IChpbml0KSA9PiB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50Lk9QVElPTlModGhpcy51cmwsIGluaXQpO1xuICB9O1xuICBIRUFEID0gKGluaXQpID0+IHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuSEVBRCh0aGlzLnVybCwgaW5pdCk7XG4gIH07XG4gIFBBVENIID0gKGluaXQpID0+IHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuUEFUQ0godGhpcy51cmwsIGluaXQpO1xuICB9O1xuICBUUkFDRSA9IChpbml0KSA9PiB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LlRSQUNFKHRoaXMudXJsLCBpbml0KTtcbiAgfTtcbn07XG52YXIgUGF0aENsaWVudFByb3h5SGFuZGxlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jbGllbnQgPSBudWxsO1xuICB9XG4gIC8vIEFzc3VtZSB0aGUgcHJvcGVydHkgaXMgYW4gVVJMLlxuICBnZXQoY29yZUNsaWVudCwgdXJsKSB7XG4gICAgY29uc3QgZm9yd2FyZGVyID0gbmV3IFBhdGhDYWxsRm9yd2FyZGVyKGNvcmVDbGllbnQsIHVybCk7XG4gICAgdGhpcy5jbGllbnRbdXJsXSA9IGZvcndhcmRlcjtcbiAgICByZXR1cm4gZm9yd2FyZGVyO1xuICB9XG59O1xuZnVuY3Rpb24gd3JhcEFzUGF0aEJhc2VkQ2xpZW50KGNvcmVDbGllbnQpIHtcbiAgY29uc3QgaGFuZGxlciA9IG5ldyBQYXRoQ2xpZW50UHJveHlIYW5kbGVyKCk7XG4gIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KGNvcmVDbGllbnQsIGhhbmRsZXIpO1xuICBmdW5jdGlvbiBDbGllbnQoKSB7XG4gIH1cbiAgQ2xpZW50LnByb3RvdHlwZSA9IHByb3h5O1xuICBjb25zdCBjbGllbnQgPSBuZXcgQ2xpZW50KCk7XG4gIGhhbmRsZXIuY2xpZW50ID0gY2xpZW50O1xuICByZXR1cm4gY2xpZW50O1xufVxuZnVuY3Rpb24gY3JlYXRlUGF0aEJhc2VkQ2xpZW50KGNsaWVudE9wdGlvbnMpIHtcbiAgcmV0dXJuIHdyYXBBc1BhdGhCYXNlZENsaWVudChjcmVhdGVDbGllbnQoY2xpZW50T3B0aW9ucykpO1xufVxuZnVuY3Rpb24gc2VyaWFsaXplUHJpbWl0aXZlUGFyYW0obmFtZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgaWYgKHZhbHVlID09PSB2b2lkIDAgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJEZWVwbHktbmVzdGVkIGFycmF5cy9vYmplY3RzIGFyZW5cXHUyMDE5dCBzdXBwb3J0ZWQuIFByb3ZpZGUgeW91ciBvd24gYHF1ZXJ5U2VyaWFsaXplcigpYCB0byBoYW5kbGUgdGhlc2UuXCJcbiAgICApO1xuICB9XG4gIHJldHVybiBgJHtuYW1lfT0ke29wdGlvbnM/LmFsbG93UmVzZXJ2ZWQgPT09IHRydWUgPyB2YWx1ZSA6IGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSl9YDtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZU9iamVjdFBhcmFtKG5hbWUsIHZhbHVlLCBvcHRpb25zKSB7XG4gIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgY29uc3QgdmFsdWVzID0gW107XG4gIGNvbnN0IGpvaW5lciA9IHtcbiAgICBzaW1wbGU6IFwiLFwiLFxuICAgIGxhYmVsOiBcIi5cIixcbiAgICBtYXRyaXg6IFwiO1wiXG4gIH1bb3B0aW9ucy5zdHlsZV0gfHwgXCImXCI7XG4gIGlmIChvcHRpb25zLnN0eWxlICE9PSBcImRlZXBPYmplY3RcIiAmJiBvcHRpb25zLmV4cGxvZGUgPT09IGZhbHNlKSB7XG4gICAgZm9yIChjb25zdCBrIGluIHZhbHVlKSB7XG4gICAgICB2YWx1ZXMucHVzaChrLCBvcHRpb25zLmFsbG93UmVzZXJ2ZWQgPT09IHRydWUgPyB2YWx1ZVtrXSA6IGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZVtrXSkpO1xuICAgIH1cbiAgICBjb25zdCBmaW5hbDIgPSB2YWx1ZXMuam9pbihcIixcIik7XG4gICAgc3dpdGNoIChvcHRpb25zLnN0eWxlKSB7XG4gICAgICBjYXNlIFwiZm9ybVwiOiB7XG4gICAgICAgIHJldHVybiBgJHtuYW1lfT0ke2ZpbmFsMn1gO1xuICAgICAgfVxuICAgICAgY2FzZSBcImxhYmVsXCI6IHtcbiAgICAgICAgcmV0dXJuIGAuJHtmaW5hbDJ9YDtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJtYXRyaXhcIjoge1xuICAgICAgICByZXR1cm4gYDske25hbWV9PSR7ZmluYWwyfWA7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIHJldHVybiBmaW5hbDI7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3QgayBpbiB2YWx1ZSkge1xuICAgIGNvbnN0IGZpbmFsTmFtZSA9IG9wdGlvbnMuc3R5bGUgPT09IFwiZGVlcE9iamVjdFwiID8gYCR7bmFtZX1bJHtrfV1gIDogaztcbiAgICB2YWx1ZXMucHVzaChzZXJpYWxpemVQcmltaXRpdmVQYXJhbShmaW5hbE5hbWUsIHZhbHVlW2tdLCBvcHRpb25zKSk7XG4gIH1cbiAgY29uc3QgZmluYWwgPSB2YWx1ZXMuam9pbihqb2luZXIpO1xuICByZXR1cm4gb3B0aW9ucy5zdHlsZSA9PT0gXCJsYWJlbFwiIHx8IG9wdGlvbnMuc3R5bGUgPT09IFwibWF0cml4XCIgPyBgJHtqb2luZXJ9JHtmaW5hbH1gIDogZmluYWw7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVBcnJheVBhcmFtKG5hbWUsIHZhbHVlLCBvcHRpb25zKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICBpZiAob3B0aW9ucy5leHBsb2RlID09PSBmYWxzZSkge1xuICAgIGNvbnN0IGpvaW5lcjIgPSB7IGZvcm06IFwiLFwiLCBzcGFjZURlbGltaXRlZDogXCIlMjBcIiwgcGlwZURlbGltaXRlZDogXCJ8XCIgfVtvcHRpb25zLnN0eWxlXSB8fCBcIixcIjtcbiAgICBjb25zdCBmaW5hbCA9IChvcHRpb25zLmFsbG93UmVzZXJ2ZWQgPT09IHRydWUgPyB2YWx1ZSA6IHZhbHVlLm1hcCgodikgPT4gZW5jb2RlVVJJQ29tcG9uZW50KHYpKSkuam9pbihqb2luZXIyKTtcbiAgICBzd2l0Y2ggKG9wdGlvbnMuc3R5bGUpIHtcbiAgICAgIGNhc2UgXCJzaW1wbGVcIjoge1xuICAgICAgICByZXR1cm4gZmluYWw7XG4gICAgICB9XG4gICAgICBjYXNlIFwibGFiZWxcIjoge1xuICAgICAgICByZXR1cm4gYC4ke2ZpbmFsfWA7XG4gICAgICB9XG4gICAgICBjYXNlIFwibWF0cml4XCI6IHtcbiAgICAgICAgcmV0dXJuIGA7JHtuYW1lfT0ke2ZpbmFsfWA7XG4gICAgICB9XG4gICAgICAvLyBjYXNlIFwic3BhY2VEZWxpbWl0ZWRcIjpcbiAgICAgIC8vIGNhc2UgXCJwaXBlRGVsaW1pdGVkXCI6XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIHJldHVybiBgJHtuYW1lfT0ke2ZpbmFsfWA7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IGpvaW5lciA9IHsgc2ltcGxlOiBcIixcIiwgbGFiZWw6IFwiLlwiLCBtYXRyaXg6IFwiO1wiIH1bb3B0aW9ucy5zdHlsZV0gfHwgXCImXCI7XG4gIGNvbnN0IHZhbHVlcyA9IFtdO1xuICBmb3IgKGNvbnN0IHYgb2YgdmFsdWUpIHtcbiAgICBpZiAob3B0aW9ucy5zdHlsZSA9PT0gXCJzaW1wbGVcIiB8fCBvcHRpb25zLnN0eWxlID09PSBcImxhYmVsXCIpIHtcbiAgICAgIHZhbHVlcy5wdXNoKG9wdGlvbnMuYWxsb3dSZXNlcnZlZCA9PT0gdHJ1ZSA/IHYgOiBlbmNvZGVVUklDb21wb25lbnQodikpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZXMucHVzaChzZXJpYWxpemVQcmltaXRpdmVQYXJhbShuYW1lLCB2LCBvcHRpb25zKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvcHRpb25zLnN0eWxlID09PSBcImxhYmVsXCIgfHwgb3B0aW9ucy5zdHlsZSA9PT0gXCJtYXRyaXhcIiA/IGAke2pvaW5lcn0ke3ZhbHVlcy5qb2luKGpvaW5lcil9YCA6IHZhbHVlcy5qb2luKGpvaW5lcik7XG59XG5mdW5jdGlvbiBjcmVhdGVRdWVyeVNlcmlhbGl6ZXIob3B0aW9ucykge1xuICByZXR1cm4gZnVuY3Rpb24gcXVlcnlTZXJpYWxpemVyKHF1ZXJ5UGFyYW1zKSB7XG4gICAgY29uc3Qgc2VhcmNoID0gW107XG4gICAgaWYgKHF1ZXJ5UGFyYW1zICYmIHR5cGVvZiBxdWVyeVBhcmFtcyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgZm9yIChjb25zdCBuYW1lIGluIHF1ZXJ5UGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcXVlcnlQYXJhbXNbbmFtZV07XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlYXJjaC5wdXNoKFxuICAgICAgICAgICAgc2VyaWFsaXplQXJyYXlQYXJhbShuYW1lLCB2YWx1ZSwge1xuICAgICAgICAgICAgICBzdHlsZTogXCJmb3JtXCIsXG4gICAgICAgICAgICAgIGV4cGxvZGU6IHRydWUsXG4gICAgICAgICAgICAgIC4uLm9wdGlvbnM/LmFycmF5LFxuICAgICAgICAgICAgICBhbGxvd1Jlc2VydmVkOiBvcHRpb25zPy5hbGxvd1Jlc2VydmVkIHx8IGZhbHNlXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIHNlYXJjaC5wdXNoKFxuICAgICAgICAgICAgc2VyaWFsaXplT2JqZWN0UGFyYW0obmFtZSwgdmFsdWUsIHtcbiAgICAgICAgICAgICAgc3R5bGU6IFwiZGVlcE9iamVjdFwiLFxuICAgICAgICAgICAgICBleHBsb2RlOiB0cnVlLFxuICAgICAgICAgICAgICAuLi5vcHRpb25zPy5vYmplY3QsXG4gICAgICAgICAgICAgIGFsbG93UmVzZXJ2ZWQ6IG9wdGlvbnM/LmFsbG93UmVzZXJ2ZWQgfHwgZmFsc2VcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBzZWFyY2gucHVzaChzZXJpYWxpemVQcmltaXRpdmVQYXJhbShuYW1lLCB2YWx1ZSwgb3B0aW9ucykpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VhcmNoLmpvaW4oXCImXCIpO1xuICB9O1xufVxuZnVuY3Rpb24gZGVmYXVsdFBhdGhTZXJpYWxpemVyKHBhdGhuYW1lLCBwYXRoUGFyYW1zKSB7XG4gIGxldCBuZXh0VVJMID0gcGF0aG5hbWU7XG4gIGZvciAoY29uc3QgbWF0Y2ggb2YgcGF0aG5hbWUubWF0Y2goUEFUSF9QQVJBTV9SRSkgPz8gW10pIHtcbiAgICBsZXQgbmFtZSA9IG1hdGNoLnN1YnN0cmluZygxLCBtYXRjaC5sZW5ndGggLSAxKTtcbiAgICBsZXQgZXhwbG9kZSA9IGZhbHNlO1xuICAgIGxldCBzdHlsZSA9IFwic2ltcGxlXCI7XG4gICAgaWYgKG5hbWUuZW5kc1dpdGgoXCIqXCIpKSB7XG4gICAgICBleHBsb2RlID0gdHJ1ZTtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cmluZygwLCBuYW1lLmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgICBpZiAobmFtZS5zdGFydHNXaXRoKFwiLlwiKSkge1xuICAgICAgc3R5bGUgPSBcImxhYmVsXCI7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHJpbmcoMSk7XG4gICAgfSBlbHNlIGlmIChuYW1lLnN0YXJ0c1dpdGgoXCI7XCIpKSB7XG4gICAgICBzdHlsZSA9IFwibWF0cml4XCI7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHJpbmcoMSk7XG4gICAgfVxuICAgIGlmICghcGF0aFBhcmFtcyB8fCBwYXRoUGFyYW1zW25hbWVdID09PSB2b2lkIDAgfHwgcGF0aFBhcmFtc1tuYW1lXSA9PT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gcGF0aFBhcmFtc1tuYW1lXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIG5leHRVUkwgPSBuZXh0VVJMLnJlcGxhY2UobWF0Y2gsIHNlcmlhbGl6ZUFycmF5UGFyYW0obmFtZSwgdmFsdWUsIHsgc3R5bGUsIGV4cGxvZGUgfSkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIG5leHRVUkwgPSBuZXh0VVJMLnJlcGxhY2UobWF0Y2gsIHNlcmlhbGl6ZU9iamVjdFBhcmFtKG5hbWUsIHZhbHVlLCB7IHN0eWxlLCBleHBsb2RlIH0pKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoc3R5bGUgPT09IFwibWF0cml4XCIpIHtcbiAgICAgIG5leHRVUkwgPSBuZXh0VVJMLnJlcGxhY2UobWF0Y2gsIGA7JHtzZXJpYWxpemVQcmltaXRpdmVQYXJhbShuYW1lLCB2YWx1ZSl9YCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgbmV4dFVSTCA9IG5leHRVUkwucmVwbGFjZShtYXRjaCwgc3R5bGUgPT09IFwibGFiZWxcIiA/IGAuJHtlbmNvZGVVUklDb21wb25lbnQodmFsdWUpfWAgOiBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcbiAgfVxuICByZXR1cm4gbmV4dFVSTDtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRCb2R5U2VyaWFsaXplcihib2R5LCBoZWFkZXJzKSB7XG4gIGlmIChib2R5IGluc3RhbmNlb2YgRm9ybURhdGEpIHtcbiAgICByZXR1cm4gYm9keTtcbiAgfVxuICBpZiAoaGVhZGVycykge1xuICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gaGVhZGVycy5nZXQgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGhlYWRlcnMuZ2V0KFwiQ29udGVudC1UeXBlXCIpID8/IGhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpIDogaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSA/PyBoZWFkZXJzW1wiY29udGVudC10eXBlXCJdO1xuICAgIGlmIChjb250ZW50VHlwZSA9PT0gXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIikge1xuICAgICAgcmV0dXJuIG5ldyBVUkxTZWFyY2hQYXJhbXMoYm9keSkudG9TdHJpbmcoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGJvZHkpO1xufVxuZnVuY3Rpb24gY3JlYXRlRmluYWxVUkwocGF0aG5hbWUsIG9wdGlvbnMpIHtcbiAgbGV0IGZpbmFsVVJMID0gYCR7b3B0aW9ucy5iYXNlVXJsfSR7cGF0aG5hbWV9YDtcbiAgaWYgKG9wdGlvbnMucGFyYW1zPy5wYXRoKSB7XG4gICAgZmluYWxVUkwgPSBkZWZhdWx0UGF0aFNlcmlhbGl6ZXIoZmluYWxVUkwsIG9wdGlvbnMucGFyYW1zLnBhdGgpO1xuICB9XG4gIGxldCBzZWFyY2ggPSBvcHRpb25zLnF1ZXJ5U2VyaWFsaXplcihvcHRpb25zLnBhcmFtcy5xdWVyeSA/PyB7fSk7XG4gIGlmIChzZWFyY2guc3RhcnRzV2l0aChcIj9cIikpIHtcbiAgICBzZWFyY2ggPSBzZWFyY2guc3Vic3RyaW5nKDEpO1xuICB9XG4gIGlmIChzZWFyY2gpIHtcbiAgICBmaW5hbFVSTCArPSBgPyR7c2VhcmNofWA7XG4gIH1cbiAgcmV0dXJuIGZpbmFsVVJMO1xufVxuZnVuY3Rpb24gbWVyZ2VIZWFkZXJzKC4uLmFsbEhlYWRlcnMpIHtcbiAgY29uc3QgZmluYWxIZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgZm9yIChjb25zdCBoIG9mIGFsbEhlYWRlcnMpIHtcbiAgICBpZiAoIWggfHwgdHlwZW9mIGggIT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBpdGVyYXRvciA9IGggaW5zdGFuY2VvZiBIZWFkZXJzID8gaC5lbnRyaWVzKCkgOiBPYmplY3QuZW50cmllcyhoKTtcbiAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBpdGVyYXRvcikge1xuICAgICAgaWYgKHYgPT09IG51bGwpIHtcbiAgICAgICAgZmluYWxIZWFkZXJzLmRlbGV0ZShrKTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2KSkge1xuICAgICAgICBmb3IgKGNvbnN0IHYyIG9mIHYpIHtcbiAgICAgICAgICBmaW5hbEhlYWRlcnMuYXBwZW5kKGssIHYyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh2ICE9PSB2b2lkIDApIHtcbiAgICAgICAgZmluYWxIZWFkZXJzLnNldChrLCB2KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZpbmFsSGVhZGVycztcbn1cbmZ1bmN0aW9uIHJlbW92ZVRyYWlsaW5nU2xhc2godXJsKSB7XG4gIGlmICh1cmwuZW5kc1dpdGgoXCIvXCIpKSB7XG4gICAgcmV0dXJuIHVybC5zdWJzdHJpbmcoMCwgdXJsLmxlbmd0aCAtIDEpO1xuICB9XG4gIHJldHVybiB1cmw7XG59XG4iXSwibmFtZXMiOlsiX19kZWZQcm9wIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJfX2dldE93blByb3BEZXNjIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiX19nZXRPd25Qcm9wTmFtZXMiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiX19oYXNPd25Qcm9wIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJfX2V4cG9ydCIsInRhcmdldCIsImFsbCIsIm5hbWUiLCJnZXQiLCJlbnVtZXJhYmxlIiwiX19jb3B5UHJvcHMiLCJ0byIsImZyb20iLCJleGNlcHQiLCJkZXNjIiwia2V5IiwiY2FsbCIsIl9fdG9Db21tb25KUyIsIm1vZCIsInZhbHVlIiwiaW5kZXhfZXhwb3J0cyIsImNyZWF0ZUZpbmFsVVJMIiwiY3JlYXRlUGF0aEJhc2VkQ2xpZW50IiwiY3JlYXRlUXVlcnlTZXJpYWxpemVyIiwiZGVmYXVsdCIsImNyZWF0ZUNsaWVudCIsImRlZmF1bHRCb2R5U2VyaWFsaXplciIsImRlZmF1bHRQYXRoU2VyaWFsaXplciIsIm1lcmdlSGVhZGVycyIsInJhbmRvbUlEIiwicmVtb3ZlVHJhaWxpbmdTbGFzaCIsInNlcmlhbGl6ZUFycmF5UGFyYW0iLCJzZXJpYWxpemVPYmplY3RQYXJhbSIsInNlcmlhbGl6ZVByaW1pdGl2ZVBhcmFtIiwid3JhcEFzUGF0aEJhc2VkQ2xpZW50IiwibW9kdWxlIiwiZXhwb3J0cyIsIlBBVEhfUEFSQU1fUkUiLCJzdXBwb3J0c1JlcXVlc3RJbml0RXh0IiwicHJvY2VzcyIsIk51bWJlciIsInBhcnNlSW50IiwidmVyc2lvbnMiLCJub2RlIiwic3Vic3RyaW5nIiwidW5kaWNpIiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic2xpY2UiLCJjbGllbnRPcHRpb25zIiwiYmFzZVVybCIsIlJlcXVlc3QiLCJDdXN0b21SZXF1ZXN0IiwiZ2xvYmFsVGhpcyIsImZldGNoIiwiYmFzZUZldGNoIiwicXVlcnlTZXJpYWxpemVyIiwiZ2xvYmFsUXVlcnlTZXJpYWxpemVyIiwiYm9keVNlcmlhbGl6ZXIiLCJnbG9iYWxCb2R5U2VyaWFsaXplciIsImhlYWRlcnMiLCJiYXNlSGVhZGVycyIsInJlcXVlc3RJbml0RXh0IiwiYmFzZU9wdGlvbnMiLCJtaWRkbGV3YXJlcyIsImNvcmVGZXRjaCIsInNjaGVtYVBhdGgiLCJmZXRjaE9wdGlvbnMiLCJsb2NhbEJhc2VVcmwiLCJwYXJhbXMiLCJwYXJzZUFzIiwicmVxdWVzdFF1ZXJ5U2VyaWFsaXplciIsImJvZHkiLCJpbml0IiwiZmluYWxCYXNlVXJsIiwic2VyaWFsaXplZEJvZHkiLCJoZWFkZXIiLCJmaW5hbEhlYWRlcnMiLCJGb3JtRGF0YSIsInJlcXVlc3RJbml0IiwicmVkaXJlY3QiLCJpZCIsIm9wdGlvbnMiLCJyZXF1ZXN0IiwicmVzcG9uc2UiLCJsZW5ndGgiLCJmcmVlemUiLCJtIiwib25SZXF1ZXN0IiwicmVzdWx0IiwiUmVzcG9uc2UiLCJFcnJvciIsImVycm9yMiIsImVycm9yQWZ0ZXJNaWRkbGV3YXJlIiwiaSIsIm9uRXJyb3IiLCJlcnJvciIsIm9uUmVzcG9uc2UiLCJzdGF0dXMiLCJtZXRob2QiLCJvayIsImRhdGEiLCJ0ZXh0IiwiSlNPTiIsInBhcnNlIiwidXJsIiwidG9VcHBlckNhc2UiLCJHRVQiLCJQVVQiLCJQT1NUIiwiREVMRVRFIiwiT1BUSU9OUyIsIkhFQUQiLCJQQVRDSCIsIlRSQUNFIiwidXNlIiwibWlkZGxld2FyZSIsInB1c2giLCJlamVjdCIsImluZGV4T2YiLCJzcGxpY2UiLCJQYXRoQ2FsbEZvcndhcmRlciIsImNvbnN0cnVjdG9yIiwiY2xpZW50IiwiUGF0aENsaWVudFByb3h5SGFuZGxlciIsImNvcmVDbGllbnQiLCJmb3J3YXJkZXIiLCJoYW5kbGVyIiwicHJveHkiLCJQcm94eSIsIkNsaWVudCIsImFsbG93UmVzZXJ2ZWQiLCJlbmNvZGVVUklDb21wb25lbnQiLCJ2YWx1ZXMiLCJqb2luZXIiLCJzaW1wbGUiLCJsYWJlbCIsIm1hdHJpeCIsInN0eWxlIiwiZXhwbG9kZSIsImsiLCJmaW5hbDIiLCJqb2luIiwiZmluYWxOYW1lIiwiZmluYWwiLCJBcnJheSIsImlzQXJyYXkiLCJqb2luZXIyIiwiZm9ybSIsInNwYWNlRGVsaW1pdGVkIiwicGlwZURlbGltaXRlZCIsIm1hcCIsInYiLCJxdWVyeVBhcmFtcyIsInNlYXJjaCIsImFycmF5Iiwib2JqZWN0IiwicGF0aG5hbWUiLCJwYXRoUGFyYW1zIiwibmV4dFVSTCIsIm1hdGNoIiwiZW5kc1dpdGgiLCJzdGFydHNXaXRoIiwicmVwbGFjZSIsImNvbnRlbnRUeXBlIiwiRnVuY3Rpb24iLCJVUkxTZWFyY2hQYXJhbXMiLCJzdHJpbmdpZnkiLCJmaW5hbFVSTCIsInBhdGgiLCJxdWVyeSIsImFsbEhlYWRlcnMiLCJIZWFkZXJzIiwiaCIsIml0ZXJhdG9yIiwiZW50cmllcyIsImRlbGV0ZSIsInYyIiwiYXBwZW5kIiwic2V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/openapi-fetch/dist/cjs/index.cjs\n");

/***/ })

};
;