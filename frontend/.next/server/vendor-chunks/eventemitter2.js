"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/eventemitter2";
exports.ids = ["vendor-chunks/eventemitter2"];
exports.modules = {

/***/ "(ssr)/./node_modules/eventemitter2/lib/eventemitter2.js":
/*!*********************************************************!*\
  !*** ./node_modules/eventemitter2/lib/eventemitter2.js ***!
  \*********************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;\n!function(undefined) {\n    var hasOwnProperty = Object.hasOwnProperty;\n    var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {\n        return Object.prototype.toString.call(obj) === \"[object Array]\";\n    };\n    var defaultMaxListeners = 10;\n    var nextTickSupported = typeof process == \"object\" && typeof process.nextTick == \"function\";\n    var symbolsSupported = typeof Symbol === \"function\";\n    var reflectSupported = typeof Reflect === \"object\";\n    var setImmediateSupported = typeof setImmediate === \"function\";\n    var _setImmediate = setImmediateSupported ? setImmediate : setTimeout;\n    var ownKeys = symbolsSupported ? reflectSupported && typeof Reflect.ownKeys === \"function\" ? Reflect.ownKeys : function(obj) {\n        var arr = Object.getOwnPropertyNames(obj);\n        arr.push.apply(arr, Object.getOwnPropertySymbols(obj));\n        return arr;\n    } : Object.keys;\n    function init() {\n        this._events = {};\n        if (this._conf) {\n            configure.call(this, this._conf);\n        }\n    }\n    function configure(conf) {\n        if (conf) {\n            this._conf = conf;\n            conf.delimiter && (this.delimiter = conf.delimiter);\n            if (conf.maxListeners !== undefined) {\n                this._maxListeners = conf.maxListeners;\n            }\n            conf.wildcard && (this.wildcard = conf.wildcard);\n            conf.newListener && (this._newListener = conf.newListener);\n            conf.removeListener && (this._removeListener = conf.removeListener);\n            conf.verboseMemoryLeak && (this.verboseMemoryLeak = conf.verboseMemoryLeak);\n            conf.ignoreErrors && (this.ignoreErrors = conf.ignoreErrors);\n            if (this.wildcard) {\n                this.listenerTree = {};\n            }\n        }\n    }\n    function logPossibleMemoryLeak(count, eventName) {\n        var errorMsg = \"(node) warning: possible EventEmitter memory \" + \"leak detected. \" + count + \" listeners added. \" + \"Use emitter.setMaxListeners() to increase limit.\";\n        if (this.verboseMemoryLeak) {\n            errorMsg += \" Event name: \" + eventName + \".\";\n        }\n        if (typeof process !== \"undefined\" && process.emitWarning) {\n            var e = new Error(errorMsg);\n            e.name = \"MaxListenersExceededWarning\";\n            e.emitter = this;\n            e.count = count;\n            process.emitWarning(e);\n        } else {\n            console.error(errorMsg);\n            if (console.trace) {\n                console.trace();\n            }\n        }\n    }\n    var toArray = function(a, b, c) {\n        var n = arguments.length;\n        switch(n){\n            case 0:\n                return [];\n            case 1:\n                return [\n                    a\n                ];\n            case 2:\n                return [\n                    a,\n                    b\n                ];\n            case 3:\n                return [\n                    a,\n                    b,\n                    c\n                ];\n            default:\n                var arr = new Array(n);\n                while(n--){\n                    arr[n] = arguments[n];\n                }\n                return arr;\n        }\n    };\n    function toObject(keys, values) {\n        var obj = {};\n        var key;\n        var len = keys.length;\n        var valuesCount = values ? values.length : 0;\n        for(var i = 0; i < len; i++){\n            key = keys[i];\n            obj[key] = i < valuesCount ? values[i] : undefined;\n        }\n        return obj;\n    }\n    function TargetObserver(emitter, target, options) {\n        this._emitter = emitter;\n        this._target = target;\n        this._listeners = {};\n        this._listenersCount = 0;\n        var on, off;\n        if (options.on || options.off) {\n            on = options.on;\n            off = options.off;\n        }\n        if (target.addEventListener) {\n            on = target.addEventListener;\n            off = target.removeEventListener;\n        } else if (target.addListener) {\n            on = target.addListener;\n            off = target.removeListener;\n        } else if (target.on) {\n            on = target.on;\n            off = target.off;\n        }\n        if (!on && !off) {\n            throw Error(\"target does not implement any known event API\");\n        }\n        if (typeof on !== \"function\") {\n            throw TypeError(\"on method must be a function\");\n        }\n        if (typeof off !== \"function\") {\n            throw TypeError(\"off method must be a function\");\n        }\n        this._on = on;\n        this._off = off;\n        var _observers = emitter._observers;\n        if (_observers) {\n            _observers.push(this);\n        } else {\n            emitter._observers = [\n                this\n            ];\n        }\n    }\n    Object.assign(TargetObserver.prototype, {\n        subscribe: function(event, localEvent, reducer) {\n            var observer = this;\n            var target = this._target;\n            var emitter = this._emitter;\n            var listeners = this._listeners;\n            var handler = function() {\n                var args = toArray.apply(null, arguments);\n                var eventObj = {\n                    data: args,\n                    name: localEvent,\n                    original: event\n                };\n                if (reducer) {\n                    var result = reducer.call(target, eventObj);\n                    if (result !== false) {\n                        emitter.emit.apply(emitter, [\n                            eventObj.name\n                        ].concat(args));\n                    }\n                    return;\n                }\n                emitter.emit.apply(emitter, [\n                    localEvent\n                ].concat(args));\n            };\n            if (listeners[event]) {\n                throw Error(\"Event '\" + event + \"' is already listening\");\n            }\n            this._listenersCount++;\n            if (emitter._newListener && emitter._removeListener && !observer._onNewListener) {\n                this._onNewListener = function(_event) {\n                    if (_event === localEvent && listeners[event] === null) {\n                        listeners[event] = handler;\n                        observer._on.call(target, event, handler);\n                    }\n                };\n                emitter.on(\"newListener\", this._onNewListener);\n                this._onRemoveListener = function(_event) {\n                    if (_event === localEvent && !emitter.hasListeners(_event) && listeners[event]) {\n                        listeners[event] = null;\n                        observer._off.call(target, event, handler);\n                    }\n                };\n                listeners[event] = null;\n                emitter.on(\"removeListener\", this._onRemoveListener);\n            } else {\n                listeners[event] = handler;\n                observer._on.call(target, event, handler);\n            }\n        },\n        unsubscribe: function(event) {\n            var observer = this;\n            var listeners = this._listeners;\n            var emitter = this._emitter;\n            var handler;\n            var events;\n            var off = this._off;\n            var target = this._target;\n            var i;\n            if (event && typeof event !== \"string\") {\n                throw TypeError(\"event must be a string\");\n            }\n            function clearRefs() {\n                if (observer._onNewListener) {\n                    emitter.off(\"newListener\", observer._onNewListener);\n                    emitter.off(\"removeListener\", observer._onRemoveListener);\n                    observer._onNewListener = null;\n                    observer._onRemoveListener = null;\n                }\n                var index = findTargetIndex.call(emitter, observer);\n                emitter._observers.splice(index, 1);\n            }\n            if (event) {\n                handler = listeners[event];\n                if (!handler) return;\n                off.call(target, event, handler);\n                delete listeners[event];\n                if (!--this._listenersCount) {\n                    clearRefs();\n                }\n            } else {\n                events = ownKeys(listeners);\n                i = events.length;\n                while(i-- > 0){\n                    event = events[i];\n                    off.call(target, event, listeners[event]);\n                }\n                this._listeners = {};\n                this._listenersCount = 0;\n                clearRefs();\n            }\n        }\n    });\n    function resolveOptions(options, schema, reducers, allowUnknown) {\n        var computedOptions = Object.assign({}, schema);\n        if (!options) return computedOptions;\n        if (typeof options !== \"object\") {\n            throw TypeError(\"options must be an object\");\n        }\n        var keys = Object.keys(options);\n        var length = keys.length;\n        var option, value;\n        var reducer;\n        function reject(reason) {\n            throw Error('Invalid \"' + option + '\" option value' + (reason ? \". Reason: \" + reason : \"\"));\n        }\n        for(var i = 0; i < length; i++){\n            option = keys[i];\n            if (!allowUnknown && !hasOwnProperty.call(schema, option)) {\n                throw Error('Unknown \"' + option + '\" option');\n            }\n            value = options[option];\n            if (value !== undefined) {\n                reducer = reducers[option];\n                computedOptions[option] = reducer ? reducer(value, reject) : value;\n            }\n        }\n        return computedOptions;\n    }\n    function constructorReducer(value, reject) {\n        if (typeof value !== \"function\" || !value.hasOwnProperty(\"prototype\")) {\n            reject(\"value must be a constructor\");\n        }\n        return value;\n    }\n    function makeTypeReducer(types) {\n        var message = \"value must be type of \" + types.join(\"|\");\n        var len = types.length;\n        var firstType = types[0];\n        var secondType = types[1];\n        if (len === 1) {\n            return function(v, reject) {\n                if (typeof v === firstType) {\n                    return v;\n                }\n                reject(message);\n            };\n        }\n        if (len === 2) {\n            return function(v, reject) {\n                var kind = typeof v;\n                if (kind === firstType || kind === secondType) return v;\n                reject(message);\n            };\n        }\n        return function(v, reject) {\n            var kind = typeof v;\n            var i = len;\n            while(i-- > 0){\n                if (kind === types[i]) return v;\n            }\n            reject(message);\n        };\n    }\n    var functionReducer = makeTypeReducer([\n        \"function\"\n    ]);\n    var objectFunctionReducer = makeTypeReducer([\n        \"object\",\n        \"function\"\n    ]);\n    function makeCancelablePromise(Promise1, executor, options) {\n        var isCancelable;\n        var callbacks;\n        var timer = 0;\n        var subscriptionClosed;\n        var promise = new Promise1(function(resolve, reject, onCancel) {\n            options = resolveOptions(options, {\n                timeout: 0,\n                overload: false\n            }, {\n                timeout: function(value, reject) {\n                    value *= 1;\n                    if (typeof value !== \"number\" || value < 0 || !Number.isFinite(value)) {\n                        reject(\"timeout must be a positive number\");\n                    }\n                    return value;\n                }\n            });\n            isCancelable = !options.overload && typeof Promise1.prototype.cancel === \"function\" && typeof onCancel === \"function\";\n            function cleanup() {\n                if (callbacks) {\n                    callbacks = null;\n                }\n                if (timer) {\n                    clearTimeout(timer);\n                    timer = 0;\n                }\n            }\n            var _resolve = function(value) {\n                cleanup();\n                resolve(value);\n            };\n            var _reject = function(err) {\n                cleanup();\n                reject(err);\n            };\n            if (isCancelable) {\n                executor(_resolve, _reject, onCancel);\n            } else {\n                callbacks = [\n                    function(reason) {\n                        _reject(reason || Error(\"canceled\"));\n                    }\n                ];\n                executor(_resolve, _reject, function(cb) {\n                    if (subscriptionClosed) {\n                        throw Error(\"Unable to subscribe on cancel event asynchronously\");\n                    }\n                    if (typeof cb !== \"function\") {\n                        throw TypeError(\"onCancel callback must be a function\");\n                    }\n                    callbacks.push(cb);\n                });\n                subscriptionClosed = true;\n            }\n            if (options.timeout > 0) {\n                timer = setTimeout(function() {\n                    var reason = Error(\"timeout\");\n                    reason.code = \"ETIMEDOUT\";\n                    timer = 0;\n                    promise.cancel(reason);\n                    reject(reason);\n                }, options.timeout);\n            }\n        });\n        if (!isCancelable) {\n            promise.cancel = function(reason) {\n                if (!callbacks) {\n                    return;\n                }\n                var length = callbacks.length;\n                for(var i = 1; i < length; i++){\n                    callbacks[i](reason);\n                }\n                // internal callback to reject the promise\n                callbacks[0](reason);\n                callbacks = null;\n            };\n        }\n        return promise;\n    }\n    function findTargetIndex(observer) {\n        var observers = this._observers;\n        if (!observers) {\n            return -1;\n        }\n        var len = observers.length;\n        for(var i = 0; i < len; i++){\n            if (observers[i]._target === observer) return i;\n        }\n        return -1;\n    }\n    // Attention, function return type now is array, always !\n    // It has zero elements if no any matches found and one or more\n    // elements (leafs) if there are matches\n    //\n    function searchListenerTree(handlers, type, tree, i, typeLength) {\n        if (!tree) {\n            return null;\n        }\n        if (i === 0) {\n            var kind = typeof type;\n            if (kind === \"string\") {\n                var ns, n, l = 0, j = 0, delimiter = this.delimiter, dl = delimiter.length;\n                if ((n = type.indexOf(delimiter)) !== -1) {\n                    ns = new Array(5);\n                    do {\n                        ns[l++] = type.slice(j, n);\n                        j = n + dl;\n                    }while ((n = type.indexOf(delimiter, j)) !== -1);\n                    ns[l++] = type.slice(j);\n                    type = ns;\n                    typeLength = l;\n                } else {\n                    type = [\n                        type\n                    ];\n                    typeLength = 1;\n                }\n            } else if (kind === \"object\") {\n                typeLength = type.length;\n            } else {\n                type = [\n                    type\n                ];\n                typeLength = 1;\n            }\n        }\n        var listeners = null, branch, xTree, xxTree, isolatedBranch, endReached, currentType = type[i], nextType = type[i + 1], branches, _listeners;\n        if (i === typeLength) {\n            //\n            // If at the end of the event(s) list and the tree has listeners\n            // invoke those listeners.\n            //\n            if (tree._listeners) {\n                if (typeof tree._listeners === \"function\") {\n                    handlers && handlers.push(tree._listeners);\n                    listeners = [\n                        tree\n                    ];\n                } else {\n                    handlers && handlers.push.apply(handlers, tree._listeners);\n                    listeners = [\n                        tree\n                    ];\n                }\n            }\n        } else {\n            if (currentType === \"*\") {\n                //\n                // If the event emitted is '*' at this part\n                // or there is a concrete match at this patch\n                //\n                branches = ownKeys(tree);\n                n = branches.length;\n                while(n-- > 0){\n                    branch = branches[n];\n                    if (branch !== \"_listeners\") {\n                        _listeners = searchListenerTree(handlers, type, tree[branch], i + 1, typeLength);\n                        if (_listeners) {\n                            if (listeners) {\n                                listeners.push.apply(listeners, _listeners);\n                            } else {\n                                listeners = _listeners;\n                            }\n                        }\n                    }\n                }\n                return listeners;\n            } else if (currentType === \"**\") {\n                endReached = i + 1 === typeLength || i + 2 === typeLength && nextType === \"*\";\n                if (endReached && tree._listeners) {\n                    // The next element has a _listeners, add it to the handlers.\n                    listeners = searchListenerTree(handlers, type, tree, typeLength, typeLength);\n                }\n                branches = ownKeys(tree);\n                n = branches.length;\n                while(n-- > 0){\n                    branch = branches[n];\n                    if (branch !== \"_listeners\") {\n                        if (branch === \"*\" || branch === \"**\") {\n                            if (tree[branch]._listeners && !endReached) {\n                                _listeners = searchListenerTree(handlers, type, tree[branch], typeLength, typeLength);\n                                if (_listeners) {\n                                    if (listeners) {\n                                        listeners.push.apply(listeners, _listeners);\n                                    } else {\n                                        listeners = _listeners;\n                                    }\n                                }\n                            }\n                            _listeners = searchListenerTree(handlers, type, tree[branch], i, typeLength);\n                        } else if (branch === nextType) {\n                            _listeners = searchListenerTree(handlers, type, tree[branch], i + 2, typeLength);\n                        } else {\n                            // No match on this one, shift into the tree but not in the type array.\n                            _listeners = searchListenerTree(handlers, type, tree[branch], i, typeLength);\n                        }\n                        if (_listeners) {\n                            if (listeners) {\n                                listeners.push.apply(listeners, _listeners);\n                            } else {\n                                listeners = _listeners;\n                            }\n                        }\n                    }\n                }\n                return listeners;\n            } else if (tree[currentType]) {\n                listeners = searchListenerTree(handlers, type, tree[currentType], i + 1, typeLength);\n            }\n        }\n        xTree = tree[\"*\"];\n        if (xTree) {\n            //\n            // If the listener tree will allow any match for this part,\n            // then recursively explore all branches of the tree\n            //\n            searchListenerTree(handlers, type, xTree, i + 1, typeLength);\n        }\n        xxTree = tree[\"**\"];\n        if (xxTree) {\n            if (i < typeLength) {\n                if (xxTree._listeners) {\n                    // If we have a listener on a '**', it will catch all, so add its handler.\n                    searchListenerTree(handlers, type, xxTree, typeLength, typeLength);\n                }\n                // Build arrays of matching next branches and others.\n                branches = ownKeys(xxTree);\n                n = branches.length;\n                while(n-- > 0){\n                    branch = branches[n];\n                    if (branch !== \"_listeners\") {\n                        if (branch === nextType) {\n                            // We know the next element will match, so jump twice.\n                            searchListenerTree(handlers, type, xxTree[branch], i + 2, typeLength);\n                        } else if (branch === currentType) {\n                            // Current node matches, move into the tree.\n                            searchListenerTree(handlers, type, xxTree[branch], i + 1, typeLength);\n                        } else {\n                            isolatedBranch = {};\n                            isolatedBranch[branch] = xxTree[branch];\n                            searchListenerTree(handlers, type, {\n                                \"**\": isolatedBranch\n                            }, i + 1, typeLength);\n                        }\n                    }\n                }\n            } else if (xxTree._listeners) {\n                // We have reached the end and still on a '**'\n                searchListenerTree(handlers, type, xxTree, typeLength, typeLength);\n            } else if (xxTree[\"*\"] && xxTree[\"*\"]._listeners) {\n                searchListenerTree(handlers, type, xxTree[\"*\"], typeLength, typeLength);\n            }\n        }\n        return listeners;\n    }\n    function growListenerTree(type, listener, prepend) {\n        var len = 0, j = 0, i, delimiter = this.delimiter, dl = delimiter.length, ns;\n        if (typeof type === \"string\") {\n            if ((i = type.indexOf(delimiter)) !== -1) {\n                ns = new Array(5);\n                do {\n                    ns[len++] = type.slice(j, i);\n                    j = i + dl;\n                }while ((i = type.indexOf(delimiter, j)) !== -1);\n                ns[len++] = type.slice(j);\n            } else {\n                ns = [\n                    type\n                ];\n                len = 1;\n            }\n        } else {\n            ns = type;\n            len = type.length;\n        }\n        //\n        // Looks for two consecutive '**', if so, don't add the event at all.\n        //\n        if (len > 1) {\n            for(i = 0; i + 1 < len; i++){\n                if (ns[i] === \"**\" && ns[i + 1] === \"**\") {\n                    return;\n                }\n            }\n        }\n        var tree = this.listenerTree, name;\n        for(i = 0; i < len; i++){\n            name = ns[i];\n            tree = tree[name] || (tree[name] = {});\n            if (i === len - 1) {\n                if (!tree._listeners) {\n                    tree._listeners = listener;\n                } else {\n                    if (typeof tree._listeners === \"function\") {\n                        tree._listeners = [\n                            tree._listeners\n                        ];\n                    }\n                    if (prepend) {\n                        tree._listeners.unshift(listener);\n                    } else {\n                        tree._listeners.push(listener);\n                    }\n                    if (!tree._listeners.warned && this._maxListeners > 0 && tree._listeners.length > this._maxListeners) {\n                        tree._listeners.warned = true;\n                        logPossibleMemoryLeak.call(this, tree._listeners.length, name);\n                    }\n                }\n                return true;\n            }\n        }\n        return true;\n    }\n    function collectTreeEvents(tree, events, root, asArray) {\n        var branches = ownKeys(tree);\n        var i = branches.length;\n        var branch, branchName, path;\n        var hasListeners = tree[\"_listeners\"];\n        var isArrayPath;\n        while(i-- > 0){\n            branchName = branches[i];\n            branch = tree[branchName];\n            if (branchName === \"_listeners\") {\n                path = root;\n            } else {\n                path = root ? root.concat(branchName) : [\n                    branchName\n                ];\n            }\n            isArrayPath = asArray || typeof branchName === \"symbol\";\n            hasListeners && events.push(isArrayPath ? path : path.join(this.delimiter));\n            if (typeof branch === \"object\") {\n                collectTreeEvents.call(this, branch, events, path, isArrayPath);\n            }\n        }\n        return events;\n    }\n    function recursivelyGarbageCollect(root) {\n        var keys = ownKeys(root);\n        var i = keys.length;\n        var obj, key, flag;\n        while(i-- > 0){\n            key = keys[i];\n            obj = root[key];\n            if (obj) {\n                flag = true;\n                if (key !== \"_listeners\" && !recursivelyGarbageCollect(obj)) {\n                    delete root[key];\n                }\n            }\n        }\n        return flag;\n    }\n    function Listener(emitter, event, listener) {\n        this.emitter = emitter;\n        this.event = event;\n        this.listener = listener;\n    }\n    Listener.prototype.off = function() {\n        this.emitter.off(this.event, this.listener);\n        return this;\n    };\n    function setupListener(event, listener, options) {\n        if (options === true) {\n            promisify = true;\n        } else if (options === false) {\n            async = true;\n        } else {\n            if (!options || typeof options !== \"object\") {\n                throw TypeError(\"options should be an object or true\");\n            }\n            var async = options.async;\n            var promisify = options.promisify;\n            var nextTick = options.nextTick;\n            var objectify = options.objectify;\n        }\n        if (async || nextTick || promisify) {\n            var _listener = listener;\n            var _origin = listener._origin || listener;\n            if (nextTick && !nextTickSupported) {\n                throw Error(\"process.nextTick is not supported\");\n            }\n            if (promisify === undefined) {\n                promisify = listener.constructor.name === \"AsyncFunction\";\n            }\n            listener = function() {\n                var args = arguments;\n                var context = this;\n                var event = this.event;\n                return promisify ? nextTick ? Promise.resolve() : new Promise(function(resolve) {\n                    _setImmediate(resolve);\n                }).then(function() {\n                    context.event = event;\n                    return _listener.apply(context, args);\n                }) : (nextTick ? process.nextTick : _setImmediate)(function() {\n                    context.event = event;\n                    _listener.apply(context, args);\n                });\n            };\n            listener._async = true;\n            listener._origin = _origin;\n        }\n        return [\n            listener,\n            objectify ? new Listener(this, event, listener) : this\n        ];\n    }\n    function EventEmitter(conf) {\n        this._events = {};\n        this._newListener = false;\n        this._removeListener = false;\n        this.verboseMemoryLeak = false;\n        configure.call(this, conf);\n    }\n    EventEmitter.EventEmitter2 = EventEmitter; // backwards compatibility for exporting EventEmitter property\n    EventEmitter.prototype.listenTo = function(target, events, options) {\n        if (typeof target !== \"object\") {\n            throw TypeError(\"target musts be an object\");\n        }\n        var emitter = this;\n        options = resolveOptions(options, {\n            on: undefined,\n            off: undefined,\n            reducers: undefined\n        }, {\n            on: functionReducer,\n            off: functionReducer,\n            reducers: objectFunctionReducer\n        });\n        function listen(events) {\n            if (typeof events !== \"object\") {\n                throw TypeError(\"events must be an object\");\n            }\n            var reducers = options.reducers;\n            var index = findTargetIndex.call(emitter, target);\n            var observer;\n            if (index === -1) {\n                observer = new TargetObserver(emitter, target, options);\n            } else {\n                observer = emitter._observers[index];\n            }\n            var keys = ownKeys(events);\n            var len = keys.length;\n            var event;\n            var isSingleReducer = typeof reducers === \"function\";\n            for(var i = 0; i < len; i++){\n                event = keys[i];\n                observer.subscribe(event, events[event] || event, isSingleReducer ? reducers : reducers && reducers[event]);\n            }\n        }\n        isArray(events) ? listen(toObject(events)) : typeof events === \"string\" ? listen(toObject(events.split(/\\s+/))) : listen(events);\n        return this;\n    };\n    EventEmitter.prototype.stopListeningTo = function(target, event) {\n        var observers = this._observers;\n        if (!observers) {\n            return false;\n        }\n        var i = observers.length;\n        var observer;\n        var matched = false;\n        if (target && typeof target !== \"object\") {\n            throw TypeError(\"target should be an object\");\n        }\n        while(i-- > 0){\n            observer = observers[i];\n            if (!target || observer._target === target) {\n                observer.unsubscribe(event);\n                matched = true;\n            }\n        }\n        return matched;\n    };\n    // By default EventEmitters will print a warning if more than\n    // 10 listeners are added to it. This is a useful default which\n    // helps finding memory leaks.\n    //\n    // Obviously not all Emitters should be limited to 10. This function allows\n    // that to be increased. Set to zero for unlimited.\n    EventEmitter.prototype.delimiter = \".\";\n    EventEmitter.prototype.setMaxListeners = function(n) {\n        if (n !== undefined) {\n            this._maxListeners = n;\n            if (!this._conf) this._conf = {};\n            this._conf.maxListeners = n;\n        }\n    };\n    EventEmitter.prototype.getMaxListeners = function() {\n        return this._maxListeners;\n    };\n    EventEmitter.prototype.event = \"\";\n    EventEmitter.prototype.once = function(event, fn, options) {\n        return this._once(event, fn, false, options);\n    };\n    EventEmitter.prototype.prependOnceListener = function(event, fn, options) {\n        return this._once(event, fn, true, options);\n    };\n    EventEmitter.prototype._once = function(event, fn, prepend, options) {\n        return this._many(event, 1, fn, prepend, options);\n    };\n    EventEmitter.prototype.many = function(event, ttl, fn, options) {\n        return this._many(event, ttl, fn, false, options);\n    };\n    EventEmitter.prototype.prependMany = function(event, ttl, fn, options) {\n        return this._many(event, ttl, fn, true, options);\n    };\n    EventEmitter.prototype._many = function(event, ttl, fn, prepend, options) {\n        var self = this;\n        if (typeof fn !== \"function\") {\n            throw new Error(\"many only accepts instances of Function\");\n        }\n        function listener() {\n            if (--ttl === 0) {\n                self.off(event, listener);\n            }\n            return fn.apply(this, arguments);\n        }\n        listener._origin = fn;\n        return this._on(event, listener, prepend, options);\n    };\n    EventEmitter.prototype.emit = function() {\n        if (!this._events && !this._all) {\n            return false;\n        }\n        this._events || init.call(this);\n        var type = arguments[0], ns, wildcard = this.wildcard;\n        var args, l, i, j, containsSymbol;\n        if (type === \"newListener\" && !this._newListener) {\n            if (!this._events.newListener) {\n                return false;\n            }\n        }\n        if (wildcard) {\n            ns = type;\n            if (type !== \"newListener\" && type !== \"removeListener\") {\n                if (typeof type === \"object\") {\n                    l = type.length;\n                    if (symbolsSupported) {\n                        for(i = 0; i < l; i++){\n                            if (typeof type[i] === \"symbol\") {\n                                containsSymbol = true;\n                                break;\n                            }\n                        }\n                    }\n                    if (!containsSymbol) {\n                        type = type.join(this.delimiter);\n                    }\n                }\n            }\n        }\n        var al = arguments.length;\n        var handler;\n        if (this._all && this._all.length) {\n            handler = this._all.slice();\n            for(i = 0, l = handler.length; i < l; i++){\n                this.event = type;\n                switch(al){\n                    case 1:\n                        handler[i].call(this, type);\n                        break;\n                    case 2:\n                        handler[i].call(this, type, arguments[1]);\n                        break;\n                    case 3:\n                        handler[i].call(this, type, arguments[1], arguments[2]);\n                        break;\n                    default:\n                        handler[i].apply(this, arguments);\n                }\n            }\n        }\n        if (wildcard) {\n            handler = [];\n            searchListenerTree.call(this, handler, ns, this.listenerTree, 0, l);\n        } else {\n            handler = this._events[type];\n            if (typeof handler === \"function\") {\n                this.event = type;\n                switch(al){\n                    case 1:\n                        handler.call(this);\n                        break;\n                    case 2:\n                        handler.call(this, arguments[1]);\n                        break;\n                    case 3:\n                        handler.call(this, arguments[1], arguments[2]);\n                        break;\n                    default:\n                        args = new Array(al - 1);\n                        for(j = 1; j < al; j++)args[j - 1] = arguments[j];\n                        handler.apply(this, args);\n                }\n                return true;\n            } else if (handler) {\n                // need to make copy of handlers because list can change in the middle\n                // of emit call\n                handler = handler.slice();\n            }\n        }\n        if (handler && handler.length) {\n            if (al > 3) {\n                args = new Array(al - 1);\n                for(j = 1; j < al; j++)args[j - 1] = arguments[j];\n            }\n            for(i = 0, l = handler.length; i < l; i++){\n                this.event = type;\n                switch(al){\n                    case 1:\n                        handler[i].call(this);\n                        break;\n                    case 2:\n                        handler[i].call(this, arguments[1]);\n                        break;\n                    case 3:\n                        handler[i].call(this, arguments[1], arguments[2]);\n                        break;\n                    default:\n                        handler[i].apply(this, args);\n                }\n            }\n            return true;\n        } else if (!this.ignoreErrors && !this._all && type === \"error\") {\n            if (arguments[1] instanceof Error) {\n                throw arguments[1]; // Unhandled 'error' event\n            } else {\n                throw new Error(\"Uncaught, unspecified 'error' event.\");\n            }\n        }\n        return !!this._all;\n    };\n    EventEmitter.prototype.emitAsync = function() {\n        if (!this._events && !this._all) {\n            return false;\n        }\n        this._events || init.call(this);\n        var type = arguments[0], wildcard = this.wildcard, ns, containsSymbol;\n        var args, l, i, j;\n        if (type === \"newListener\" && !this._newListener) {\n            if (!this._events.newListener) {\n                return Promise.resolve([\n                    false\n                ]);\n            }\n        }\n        if (wildcard) {\n            ns = type;\n            if (type !== \"newListener\" && type !== \"removeListener\") {\n                if (typeof type === \"object\") {\n                    l = type.length;\n                    if (symbolsSupported) {\n                        for(i = 0; i < l; i++){\n                            if (typeof type[i] === \"symbol\") {\n                                containsSymbol = true;\n                                break;\n                            }\n                        }\n                    }\n                    if (!containsSymbol) {\n                        type = type.join(this.delimiter);\n                    }\n                }\n            }\n        }\n        var promises = [];\n        var al = arguments.length;\n        var handler;\n        if (this._all) {\n            for(i = 0, l = this._all.length; i < l; i++){\n                this.event = type;\n                switch(al){\n                    case 1:\n                        promises.push(this._all[i].call(this, type));\n                        break;\n                    case 2:\n                        promises.push(this._all[i].call(this, type, arguments[1]));\n                        break;\n                    case 3:\n                        promises.push(this._all[i].call(this, type, arguments[1], arguments[2]));\n                        break;\n                    default:\n                        promises.push(this._all[i].apply(this, arguments));\n                }\n            }\n        }\n        if (wildcard) {\n            handler = [];\n            searchListenerTree.call(this, handler, ns, this.listenerTree, 0);\n        } else {\n            handler = this._events[type];\n        }\n        if (typeof handler === \"function\") {\n            this.event = type;\n            switch(al){\n                case 1:\n                    promises.push(handler.call(this));\n                    break;\n                case 2:\n                    promises.push(handler.call(this, arguments[1]));\n                    break;\n                case 3:\n                    promises.push(handler.call(this, arguments[1], arguments[2]));\n                    break;\n                default:\n                    args = new Array(al - 1);\n                    for(j = 1; j < al; j++)args[j - 1] = arguments[j];\n                    promises.push(handler.apply(this, args));\n            }\n        } else if (handler && handler.length) {\n            handler = handler.slice();\n            if (al > 3) {\n                args = new Array(al - 1);\n                for(j = 1; j < al; j++)args[j - 1] = arguments[j];\n            }\n            for(i = 0, l = handler.length; i < l; i++){\n                this.event = type;\n                switch(al){\n                    case 1:\n                        promises.push(handler[i].call(this));\n                        break;\n                    case 2:\n                        promises.push(handler[i].call(this, arguments[1]));\n                        break;\n                    case 3:\n                        promises.push(handler[i].call(this, arguments[1], arguments[2]));\n                        break;\n                    default:\n                        promises.push(handler[i].apply(this, args));\n                }\n            }\n        } else if (!this.ignoreErrors && !this._all && type === \"error\") {\n            if (arguments[1] instanceof Error) {\n                return Promise.reject(arguments[1]); // Unhandled 'error' event\n            } else {\n                return Promise.reject(\"Uncaught, unspecified 'error' event.\");\n            }\n        }\n        return Promise.all(promises);\n    };\n    EventEmitter.prototype.on = function(type, listener, options) {\n        return this._on(type, listener, false, options);\n    };\n    EventEmitter.prototype.prependListener = function(type, listener, options) {\n        return this._on(type, listener, true, options);\n    };\n    EventEmitter.prototype.onAny = function(fn) {\n        return this._onAny(fn, false);\n    };\n    EventEmitter.prototype.prependAny = function(fn) {\n        return this._onAny(fn, true);\n    };\n    EventEmitter.prototype.addListener = EventEmitter.prototype.on;\n    EventEmitter.prototype._onAny = function(fn, prepend) {\n        if (typeof fn !== \"function\") {\n            throw new Error(\"onAny only accepts instances of Function\");\n        }\n        if (!this._all) {\n            this._all = [];\n        }\n        // Add the function to the event listener collection.\n        if (prepend) {\n            this._all.unshift(fn);\n        } else {\n            this._all.push(fn);\n        }\n        return this;\n    };\n    EventEmitter.prototype._on = function(type, listener, prepend, options) {\n        if (typeof type === \"function\") {\n            this._onAny(type, listener);\n            return this;\n        }\n        if (typeof listener !== \"function\") {\n            throw new Error(\"on only accepts instances of Function\");\n        }\n        this._events || init.call(this);\n        var returnValue = this, temp;\n        if (options !== undefined) {\n            temp = setupListener.call(this, type, listener, options);\n            listener = temp[0];\n            returnValue = temp[1];\n        }\n        // To avoid recursion in the case that type == \"newListeners\"! Before\n        // adding it to the listeners, first emit \"newListeners\".\n        if (this._newListener) {\n            this.emit(\"newListener\", type, listener);\n        }\n        if (this.wildcard) {\n            growListenerTree.call(this, type, listener, prepend);\n            return returnValue;\n        }\n        if (!this._events[type]) {\n            // Optimize the case of one listener. Don't need the extra array object.\n            this._events[type] = listener;\n        } else {\n            if (typeof this._events[type] === \"function\") {\n                // Change to array.\n                this._events[type] = [\n                    this._events[type]\n                ];\n            }\n            // If we've already got an array, just add\n            if (prepend) {\n                this._events[type].unshift(listener);\n            } else {\n                this._events[type].push(listener);\n            }\n            // Check for listener leak\n            if (!this._events[type].warned && this._maxListeners > 0 && this._events[type].length > this._maxListeners) {\n                this._events[type].warned = true;\n                logPossibleMemoryLeak.call(this, this._events[type].length, type);\n            }\n        }\n        return returnValue;\n    };\n    EventEmitter.prototype.off = function(type, listener) {\n        if (typeof listener !== \"function\") {\n            throw new Error(\"removeListener only takes instances of Function\");\n        }\n        var handlers, leafs = [];\n        if (this.wildcard) {\n            var ns = typeof type === \"string\" ? type.split(this.delimiter) : type.slice();\n            leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\n            if (!leafs) return this;\n        } else {\n            // does not use listeners(), so no side effect of creating _events[type]\n            if (!this._events[type]) return this;\n            handlers = this._events[type];\n            leafs.push({\n                _listeners: handlers\n            });\n        }\n        for(var iLeaf = 0; iLeaf < leafs.length; iLeaf++){\n            var leaf = leafs[iLeaf];\n            handlers = leaf._listeners;\n            if (isArray(handlers)) {\n                var position = -1;\n                for(var i = 0, length = handlers.length; i < length; i++){\n                    if (handlers[i] === listener || handlers[i].listener && handlers[i].listener === listener || handlers[i]._origin && handlers[i]._origin === listener) {\n                        position = i;\n                        break;\n                    }\n                }\n                if (position < 0) {\n                    continue;\n                }\n                if (this.wildcard) {\n                    leaf._listeners.splice(position, 1);\n                } else {\n                    this._events[type].splice(position, 1);\n                }\n                if (handlers.length === 0) {\n                    if (this.wildcard) {\n                        delete leaf._listeners;\n                    } else {\n                        delete this._events[type];\n                    }\n                }\n                if (this._removeListener) this.emit(\"removeListener\", type, listener);\n                return this;\n            } else if (handlers === listener || handlers.listener && handlers.listener === listener || handlers._origin && handlers._origin === listener) {\n                if (this.wildcard) {\n                    delete leaf._listeners;\n                } else {\n                    delete this._events[type];\n                }\n                if (this._removeListener) this.emit(\"removeListener\", type, listener);\n            }\n        }\n        this.listenerTree && recursivelyGarbageCollect(this.listenerTree);\n        return this;\n    };\n    EventEmitter.prototype.offAny = function(fn) {\n        var i = 0, l = 0, fns;\n        if (fn && this._all && this._all.length > 0) {\n            fns = this._all;\n            for(i = 0, l = fns.length; i < l; i++){\n                if (fn === fns[i]) {\n                    fns.splice(i, 1);\n                    if (this._removeListener) this.emit(\"removeListenerAny\", fn);\n                    return this;\n                }\n            }\n        } else {\n            fns = this._all;\n            if (this._removeListener) {\n                for(i = 0, l = fns.length; i < l; i++)this.emit(\"removeListenerAny\", fns[i]);\n            }\n            this._all = [];\n        }\n        return this;\n    };\n    EventEmitter.prototype.removeListener = EventEmitter.prototype.off;\n    EventEmitter.prototype.removeAllListeners = function(type) {\n        if (type === undefined) {\n            !this._events || init.call(this);\n            return this;\n        }\n        if (this.wildcard) {\n            var leafs = searchListenerTree.call(this, null, type, this.listenerTree, 0), leaf, i;\n            if (!leafs) return this;\n            for(i = 0; i < leafs.length; i++){\n                leaf = leafs[i];\n                leaf._listeners = null;\n            }\n            this.listenerTree && recursivelyGarbageCollect(this.listenerTree);\n        } else if (this._events) {\n            this._events[type] = null;\n        }\n        return this;\n    };\n    EventEmitter.prototype.listeners = function(type) {\n        var _events = this._events;\n        var keys, listeners, allListeners;\n        var i;\n        var listenerTree;\n        if (type === undefined) {\n            if (this.wildcard) {\n                throw Error(\"event name required for wildcard emitter\");\n            }\n            if (!_events) {\n                return [];\n            }\n            keys = ownKeys(_events);\n            i = keys.length;\n            allListeners = [];\n            while(i-- > 0){\n                listeners = _events[keys[i]];\n                if (typeof listeners === \"function\") {\n                    allListeners.push(listeners);\n                } else {\n                    allListeners.push.apply(allListeners, listeners);\n                }\n            }\n            return allListeners;\n        } else {\n            if (this.wildcard) {\n                listenerTree = this.listenerTree;\n                if (!listenerTree) return [];\n                var handlers = [];\n                var ns = typeof type === \"string\" ? type.split(this.delimiter) : type.slice();\n                searchListenerTree.call(this, handlers, ns, listenerTree, 0);\n                return handlers;\n            }\n            if (!_events) {\n                return [];\n            }\n            listeners = _events[type];\n            if (!listeners) {\n                return [];\n            }\n            return typeof listeners === \"function\" ? [\n                listeners\n            ] : listeners;\n        }\n    };\n    EventEmitter.prototype.eventNames = function(nsAsArray) {\n        var _events = this._events;\n        return this.wildcard ? collectTreeEvents.call(this, this.listenerTree, [], null, nsAsArray) : _events ? ownKeys(_events) : [];\n    };\n    EventEmitter.prototype.listenerCount = function(type) {\n        return this.listeners(type).length;\n    };\n    EventEmitter.prototype.hasListeners = function(type) {\n        if (this.wildcard) {\n            var handlers = [];\n            var ns = typeof type === \"string\" ? type.split(this.delimiter) : type.slice();\n            searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);\n            return handlers.length > 0;\n        }\n        var _events = this._events;\n        var _all = this._all;\n        return !!(_all && _all.length || _events && (type === undefined ? ownKeys(_events).length : _events[type]));\n    };\n    EventEmitter.prototype.listenersAny = function() {\n        if (this._all) {\n            return this._all;\n        } else {\n            return [];\n        }\n    };\n    EventEmitter.prototype.waitFor = function(event, options) {\n        var self = this;\n        var type = typeof options;\n        if (type === \"number\") {\n            options = {\n                timeout: options\n            };\n        } else if (type === \"function\") {\n            options = {\n                filter: options\n            };\n        }\n        options = resolveOptions(options, {\n            timeout: 0,\n            filter: undefined,\n            handleError: false,\n            Promise: Promise,\n            overload: false\n        }, {\n            filter: functionReducer,\n            Promise: constructorReducer\n        });\n        return makeCancelablePromise(options.Promise, function(resolve, reject, onCancel) {\n            function listener() {\n                var filter = options.filter;\n                if (filter && !filter.apply(self, arguments)) {\n                    return;\n                }\n                self.off(event, listener);\n                if (options.handleError) {\n                    var err = arguments[0];\n                    err ? reject(err) : resolve(toArray.apply(null, arguments).slice(1));\n                } else {\n                    resolve(toArray.apply(null, arguments));\n                }\n            }\n            onCancel(function() {\n                self.off(event, listener);\n            });\n            self._on(event, listener, false);\n        }, {\n            timeout: options.timeout,\n            overload: options.overload\n        });\n    };\n    function once(emitter, name, options) {\n        options = resolveOptions(options, {\n            Promise: Promise,\n            timeout: 0,\n            overload: false\n        }, {\n            Promise: constructorReducer\n        });\n        var _Promise = options.Promise;\n        return makeCancelablePromise(_Promise, function(resolve, reject, onCancel) {\n            var handler;\n            if (typeof emitter.addEventListener === \"function\") {\n                handler = function() {\n                    resolve(toArray.apply(null, arguments));\n                };\n                onCancel(function() {\n                    emitter.removeEventListener(name, handler);\n                });\n                emitter.addEventListener(name, handler, {\n                    once: true\n                });\n                return;\n            }\n            var eventListener = function() {\n                errorListener && emitter.removeListener(\"error\", errorListener);\n                resolve(toArray.apply(null, arguments));\n            };\n            var errorListener;\n            if (name !== \"error\") {\n                errorListener = function(err) {\n                    emitter.removeListener(name, eventListener);\n                    reject(err);\n                };\n                emitter.once(\"error\", errorListener);\n            }\n            onCancel(function() {\n                errorListener && emitter.removeListener(\"error\", errorListener);\n                emitter.removeListener(name, eventListener);\n            });\n            emitter.once(name, eventListener);\n        }, {\n            timeout: options.timeout,\n            overload: options.overload\n        });\n    }\n    var prototype = EventEmitter.prototype;\n    Object.defineProperties(EventEmitter, {\n        defaultMaxListeners: {\n            get: function() {\n                return prototype._maxListeners;\n            },\n            set: function(n) {\n                if (typeof n !== \"number\" || n < 0 || Number.isNaN(n)) {\n                    throw TypeError(\"n must be a non-negative number\");\n                }\n                prototype._maxListeners = n;\n            },\n            enumerable: true\n        },\n        once: {\n            value: once,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperties(prototype, {\n        _maxListeners: {\n            value: defaultMaxListeners,\n            writable: true,\n            configurable: true\n        },\n        _observers: {\n            value: null,\n            writable: true,\n            configurable: true\n        }\n    });\n    if (true) {\n        // AMD. Register as an anonymous module.\n        !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n            return EventEmitter;\n        }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else { var _global; }\n}();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXZlbnRlbWl0dGVyMi9saWIvZXZlbnRlbWl0dGVyMi5qcyIsIm1hcHBpbmdzIjoiO0FBT0MsQ0FBQyxTQUFTQSxTQUFTO0lBQ2xCLElBQUlDLGlCQUFnQkMsT0FBT0QsY0FBYztJQUN6QyxJQUFJRSxVQUFVQyxNQUFNRCxPQUFPLEdBQUdDLE1BQU1ELE9BQU8sR0FBRyxTQUFTRSxTQUFTQyxHQUFHO1FBQ2pFLE9BQU9KLE9BQU9LLFNBQVMsQ0FBQ0MsUUFBUSxDQUFDQyxJQUFJLENBQUNILFNBQVM7SUFDakQ7SUFDQSxJQUFJSSxzQkFBc0I7SUFDMUIsSUFBSUMsb0JBQW1CLE9BQU9DLFdBQVMsWUFBWSxPQUFPQSxRQUFRQyxRQUFRLElBQUU7SUFDNUUsSUFBSUMsbUJBQWtCLE9BQU9DLFdBQVM7SUFDdEMsSUFBSUMsbUJBQWtCLE9BQU9DLFlBQVk7SUFDekMsSUFBSUMsd0JBQXVCLE9BQU9DLGlCQUFpQjtJQUNuRCxJQUFJQyxnQkFBZUYsd0JBQXdCQyxlQUFlRTtJQUMxRCxJQUFJQyxVQUFTUixtQkFBbUJFLG9CQUFvQixPQUFPQyxRQUFRSyxPQUFPLEtBQUcsYUFBWUwsUUFBUUssT0FBTyxHQUFHLFNBQVNoQixHQUFHO1FBQ3JILElBQUlpQixNQUFLckIsT0FBT3NCLG1CQUFtQixDQUFDbEI7UUFDcENpQixJQUFJRSxJQUFJLENBQUNDLEtBQUssQ0FBQ0gsS0FBS3JCLE9BQU95QixxQkFBcUIsQ0FBQ3JCO1FBQ2pELE9BQU9pQjtJQUNULElBQUtyQixPQUFPMEIsSUFBSTtJQUVoQixTQUFTQztRQUNQLElBQUksQ0FBQ0MsT0FBTyxHQUFHLENBQUM7UUFDaEIsSUFBSSxJQUFJLENBQUNDLEtBQUssRUFBRTtZQUNkQyxVQUFVdkIsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUNzQixLQUFLO1FBQ2pDO0lBQ0Y7SUFFQSxTQUFTQyxVQUFVQyxJQUFJO1FBQ3JCLElBQUlBLE1BQU07WUFDUixJQUFJLENBQUNGLEtBQUss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X21vZHVsZXMvZXZlbnRlbWl0dGVyMi9saWIvZXZlbnRlbWl0dGVyMi5qcz9mMTQ4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogRXZlbnRFbWl0dGVyMlxuICogaHR0cHM6Ly9naXRodWIuY29tL2hpajFueC9FdmVudEVtaXR0ZXIyXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzIGhpajFueFxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICovXG47IWZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICB2YXIgaGFzT3duUHJvcGVydHk9IE9iamVjdC5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5ID8gQXJyYXkuaXNBcnJheSA6IGZ1bmN0aW9uIF9pc0FycmF5KG9iaikge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiO1xuICB9O1xuICB2YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuICB2YXIgbmV4dFRpY2tTdXBwb3J0ZWQ9IHR5cGVvZiBwcm9jZXNzPT0nb2JqZWN0JyAmJiB0eXBlb2YgcHJvY2Vzcy5uZXh0VGljaz09J2Z1bmN0aW9uJztcbiAgdmFyIHN5bWJvbHNTdXBwb3J0ZWQ9IHR5cGVvZiBTeW1ib2w9PT0nZnVuY3Rpb24nO1xuICB2YXIgcmVmbGVjdFN1cHBvcnRlZD0gdHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnO1xuICB2YXIgc2V0SW1tZWRpYXRlU3VwcG9ydGVkPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nO1xuICB2YXIgX3NldEltbWVkaWF0ZT0gc2V0SW1tZWRpYXRlU3VwcG9ydGVkID8gc2V0SW1tZWRpYXRlIDogc2V0VGltZW91dDtcbiAgdmFyIG93bktleXM9IHN5bWJvbHNTdXBwb3J0ZWQ/IChyZWZsZWN0U3VwcG9ydGVkICYmIHR5cGVvZiBSZWZsZWN0Lm93bktleXM9PT0nZnVuY3Rpb24nPyBSZWZsZWN0Lm93bktleXMgOiBmdW5jdGlvbihvYmope1xuICAgIHZhciBhcnI9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaik7XG4gICAgYXJyLnB1c2guYXBwbHkoYXJyLCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iaikpO1xuICAgIHJldHVybiBhcnI7XG4gIH0pIDogT2JqZWN0LmtleXM7XG5cbiAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBpZiAodGhpcy5fY29uZikge1xuICAgICAgY29uZmlndXJlLmNhbGwodGhpcywgdGhpcy5fY29uZik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29uZmlndXJlKGNvbmYpIHtcbiAgICBpZiAoY29uZikge1xuICAgICAgdGhpcy5fY29uZiA9IGNvbmY7XG5cbiAgICAgIGNvbmYuZGVsaW1pdGVyICYmICh0aGlzLmRlbGltaXRlciA9IGNvbmYuZGVsaW1pdGVyKTtcblxuICAgICAgaWYoY29uZi5tYXhMaXN0ZW5lcnMhPT11bmRlZmluZWQpe1xuICAgICAgICAgIHRoaXMuX21heExpc3RlbmVycz0gY29uZi5tYXhMaXN0ZW5lcnM7XG4gICAgICB9XG5cbiAgICAgIGNvbmYud2lsZGNhcmQgJiYgKHRoaXMud2lsZGNhcmQgPSBjb25mLndpbGRjYXJkKTtcbiAgICAgIGNvbmYubmV3TGlzdGVuZXIgJiYgKHRoaXMuX25ld0xpc3RlbmVyID0gY29uZi5uZXdMaXN0ZW5lcik7XG4gICAgICBjb25mLnJlbW92ZUxpc3RlbmVyICYmICh0aGlzLl9yZW1vdmVMaXN0ZW5lciA9IGNvbmYucmVtb3ZlTGlzdGVuZXIpO1xuICAgICAgY29uZi52ZXJib3NlTWVtb3J5TGVhayAmJiAodGhpcy52ZXJib3NlTWVtb3J5TGVhayA9IGNvbmYudmVyYm9zZU1lbW9yeUxlYWspO1xuICAgICAgY29uZi5pZ25vcmVFcnJvcnMgJiYgKHRoaXMuaWdub3JlRXJyb3JzID0gY29uZi5pZ25vcmVFcnJvcnMpO1xuXG4gICAgICBpZiAodGhpcy53aWxkY2FyZCkge1xuICAgICAgICB0aGlzLmxpc3RlbmVyVHJlZSA9IHt9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGxvZ1Bvc3NpYmxlTWVtb3J5TGVhayhjb3VudCwgZXZlbnROYW1lKSB7XG4gICAgdmFyIGVycm9yTXNnID0gJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAnbGVhayBkZXRlY3RlZC4gJyArIGNvdW50ICsgJyBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJztcblxuICAgIGlmKHRoaXMudmVyYm9zZU1lbW9yeUxlYWspe1xuICAgICAgZXJyb3JNc2cgKz0gJyBFdmVudCBuYW1lOiAnICsgZXZlbnROYW1lICsgJy4nO1xuICAgIH1cblxuICAgIGlmKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLmVtaXRXYXJuaW5nKXtcbiAgICAgIHZhciBlID0gbmV3IEVycm9yKGVycm9yTXNnKTtcbiAgICAgIGUubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgZS5lbWl0dGVyID0gdGhpcztcbiAgICAgIGUuY291bnQgPSBjb3VudDtcbiAgICAgIHByb2Nlc3MuZW1pdFdhcm5pbmcoZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3JNc2cpO1xuXG4gICAgICBpZiAoY29uc29sZS50cmFjZSl7XG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgdG9BcnJheSA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgdmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHN3aXRjaCAobikge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gW107XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiBbYV07XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiBbYSwgYl07XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHJldHVybiBbYSwgYiwgY107XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB2YXIgYXJyID0gbmV3IEFycmF5KG4pO1xuICAgICAgICB3aGlsZSAobi0tKSB7XG4gICAgICAgICAgYXJyW25dID0gYXJndW1lbnRzW25dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIHRvT2JqZWN0KGtleXMsIHZhbHVlcykge1xuICAgIHZhciBvYmogPSB7fTtcbiAgICB2YXIga2V5O1xuICAgIHZhciBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgdmFsdWVzQ291bnQgPSB2YWx1ZXMgPyB2YWx1ZXMubGVuZ3RoIDogMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgb2JqW2tleV0gPSBpIDwgdmFsdWVzQ291bnQgPyB2YWx1ZXNbaV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBmdW5jdGlvbiBUYXJnZXRPYnNlcnZlcihlbWl0dGVyLCB0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLl9lbWl0dGVyID0gZW1pdHRlcjtcbiAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy5fbGlzdGVuZXJzID0ge307XG4gICAgdGhpcy5fbGlzdGVuZXJzQ291bnQgPSAwO1xuXG4gICAgdmFyIG9uLCBvZmY7XG5cbiAgICBpZiAob3B0aW9ucy5vbiB8fCBvcHRpb25zLm9mZikge1xuICAgICAgb24gPSBvcHRpb25zLm9uO1xuICAgICAgb2ZmID0gb3B0aW9ucy5vZmY7XG4gICAgfVxuXG4gICAgaWYgKHRhcmdldC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICBvbiA9IHRhcmdldC5hZGRFdmVudExpc3RlbmVyO1xuICAgICAgb2ZmID0gdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXI7XG4gICAgfSBlbHNlIGlmICh0YXJnZXQuYWRkTGlzdGVuZXIpIHtcbiAgICAgIG9uID0gdGFyZ2V0LmFkZExpc3RlbmVyO1xuICAgICAgb2ZmID0gdGFyZ2V0LnJlbW92ZUxpc3RlbmVyO1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0Lm9uKSB7XG4gICAgICBvbiA9IHRhcmdldC5vbjtcbiAgICAgIG9mZiA9IHRhcmdldC5vZmY7XG4gICAgfVxuXG4gICAgaWYgKCFvbiAmJiAhb2ZmKSB7XG4gICAgICB0aHJvdyBFcnJvcigndGFyZ2V0IGRvZXMgbm90IGltcGxlbWVudCBhbnkga25vd24gZXZlbnQgQVBJJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdvbiBtZXRob2QgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvZmYgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignb2ZmIG1ldGhvZCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICB0aGlzLl9vbiA9IG9uO1xuICAgIHRoaXMuX29mZiA9IG9mZjtcblxuICAgIHZhciBfb2JzZXJ2ZXJzPSBlbWl0dGVyLl9vYnNlcnZlcnM7XG4gICAgaWYoX29ic2VydmVycyl7XG4gICAgICBfb2JzZXJ2ZXJzLnB1c2godGhpcyk7XG4gICAgfWVsc2V7XG4gICAgICBlbWl0dGVyLl9vYnNlcnZlcnM9IFt0aGlzXTtcbiAgICB9XG4gIH1cblxuICBPYmplY3QuYXNzaWduKFRhcmdldE9ic2VydmVyLnByb3RvdHlwZSwge1xuICAgIHN1YnNjcmliZTogZnVuY3Rpb24oZXZlbnQsIGxvY2FsRXZlbnQsIHJlZHVjZXIpe1xuICAgICAgdmFyIG9ic2VydmVyPSB0aGlzO1xuICAgICAgdmFyIHRhcmdldD0gdGhpcy5fdGFyZ2V0O1xuICAgICAgdmFyIGVtaXR0ZXI9IHRoaXMuX2VtaXR0ZXI7XG4gICAgICB2YXIgbGlzdGVuZXJzPSB0aGlzLl9saXN0ZW5lcnM7XG4gICAgICB2YXIgaGFuZGxlcj0gZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIGFyZ3M9IHRvQXJyYXkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIGV2ZW50T2JqPSB7XG4gICAgICAgICAgZGF0YTogYXJncyxcbiAgICAgICAgICBuYW1lOiBsb2NhbEV2ZW50LFxuICAgICAgICAgIG9yaWdpbmFsOiBldmVudFxuICAgICAgICB9O1xuICAgICAgICBpZihyZWR1Y2VyKXtcbiAgICAgICAgICB2YXIgcmVzdWx0PSByZWR1Y2VyLmNhbGwodGFyZ2V0LCBldmVudE9iaik7XG4gICAgICAgICAgaWYocmVzdWx0IT09ZmFsc2Upe1xuICAgICAgICAgICAgZW1pdHRlci5lbWl0LmFwcGx5KGVtaXR0ZXIsIFtldmVudE9iai5uYW1lXS5jb25jYXQoYXJncykpXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbWl0dGVyLmVtaXQuYXBwbHkoZW1pdHRlciwgW2xvY2FsRXZlbnRdLmNvbmNhdChhcmdzKSk7XG4gICAgICB9O1xuXG5cbiAgICAgIGlmKGxpc3RlbmVyc1tldmVudF0pe1xuICAgICAgICB0aHJvdyBFcnJvcignRXZlbnQgXFwnJyArIGV2ZW50ICsgJ1xcJyBpcyBhbHJlYWR5IGxpc3RlbmluZycpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9saXN0ZW5lcnNDb3VudCsrO1xuXG4gICAgICBpZihlbWl0dGVyLl9uZXdMaXN0ZW5lciAmJiBlbWl0dGVyLl9yZW1vdmVMaXN0ZW5lciAmJiAhb2JzZXJ2ZXIuX29uTmV3TGlzdGVuZXIpe1xuXG4gICAgICAgIHRoaXMuX29uTmV3TGlzdGVuZXIgPSBmdW5jdGlvbiAoX2V2ZW50KSB7XG4gICAgICAgICAgaWYgKF9ldmVudCA9PT0gbG9jYWxFdmVudCAmJiBsaXN0ZW5lcnNbZXZlbnRdID09PSBudWxsKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnNbZXZlbnRdID0gaGFuZGxlcjtcbiAgICAgICAgICAgIG9ic2VydmVyLl9vbi5jYWxsKHRhcmdldCwgZXZlbnQsIGhhbmRsZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBlbWl0dGVyLm9uKCduZXdMaXN0ZW5lcicsIHRoaXMuX29uTmV3TGlzdGVuZXIpO1xuXG4gICAgICAgIHRoaXMuX29uUmVtb3ZlTGlzdGVuZXI9IGZ1bmN0aW9uKF9ldmVudCl7XG4gICAgICAgICAgaWYoX2V2ZW50ID09PSBsb2NhbEV2ZW50ICYmICFlbWl0dGVyLmhhc0xpc3RlbmVycyhfZXZlbnQpICYmIGxpc3RlbmVyc1tldmVudF0pe1xuICAgICAgICAgICAgbGlzdGVuZXJzW2V2ZW50XT0gbnVsbDtcbiAgICAgICAgICAgIG9ic2VydmVyLl9vZmYuY2FsbCh0YXJnZXQsIGV2ZW50LCBoYW5kbGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgbGlzdGVuZXJzW2V2ZW50XT0gbnVsbDtcblxuICAgICAgICBlbWl0dGVyLm9uKCdyZW1vdmVMaXN0ZW5lcicsIHRoaXMuX29uUmVtb3ZlTGlzdGVuZXIpO1xuICAgICAgfWVsc2V7XG4gICAgICAgIGxpc3RlbmVyc1tldmVudF09IGhhbmRsZXI7XG4gICAgICAgIG9ic2VydmVyLl9vbi5jYWxsKHRhcmdldCwgZXZlbnQsIGhhbmRsZXIpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICB1bnN1YnNjcmliZTogZnVuY3Rpb24oZXZlbnQpe1xuICAgICAgdmFyIG9ic2VydmVyPSB0aGlzO1xuICAgICAgdmFyIGxpc3RlbmVycz0gdGhpcy5fbGlzdGVuZXJzO1xuICAgICAgdmFyIGVtaXR0ZXI9IHRoaXMuX2VtaXR0ZXI7XG4gICAgICB2YXIgaGFuZGxlcjtcbiAgICAgIHZhciBldmVudHM7XG4gICAgICB2YXIgb2ZmPSB0aGlzLl9vZmY7XG4gICAgICB2YXIgdGFyZ2V0PSB0aGlzLl90YXJnZXQ7XG4gICAgICB2YXIgaTtcblxuICAgICAgaWYoZXZlbnQgJiYgdHlwZW9mIGV2ZW50IT09J3N0cmluZycpe1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ2V2ZW50IG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY2xlYXJSZWZzKCl7XG4gICAgICAgIGlmKG9ic2VydmVyLl9vbk5ld0xpc3RlbmVyKXtcbiAgICAgICAgICBlbWl0dGVyLm9mZignbmV3TGlzdGVuZXInLCBvYnNlcnZlci5fb25OZXdMaXN0ZW5lcik7XG4gICAgICAgICAgZW1pdHRlci5vZmYoJ3JlbW92ZUxpc3RlbmVyJywgb2JzZXJ2ZXIuX29uUmVtb3ZlTGlzdGVuZXIpO1xuICAgICAgICAgIG9ic2VydmVyLl9vbk5ld0xpc3RlbmVyPSBudWxsO1xuICAgICAgICAgIG9ic2VydmVyLl9vblJlbW92ZUxpc3RlbmVyPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmRleD0gZmluZFRhcmdldEluZGV4LmNhbGwoZW1pdHRlciwgb2JzZXJ2ZXIpO1xuICAgICAgICBlbWl0dGVyLl9vYnNlcnZlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cblxuICAgICAgaWYoZXZlbnQpe1xuICAgICAgICBoYW5kbGVyPSBsaXN0ZW5lcnNbZXZlbnRdO1xuICAgICAgICBpZighaGFuZGxlcikgcmV0dXJuO1xuICAgICAgICBvZmYuY2FsbCh0YXJnZXQsIGV2ZW50LCBoYW5kbGVyKTtcbiAgICAgICAgZGVsZXRlIGxpc3RlbmVyc1tldmVudF07XG4gICAgICAgIGlmKCEtLXRoaXMuX2xpc3RlbmVyc0NvdW50KXtcbiAgICAgICAgICBjbGVhclJlZnMoKTtcbiAgICAgICAgfVxuICAgICAgfWVsc2V7XG4gICAgICAgIGV2ZW50cz0gb3duS2V5cyhsaXN0ZW5lcnMpO1xuICAgICAgICBpPSBldmVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZShpLS0+MCl7XG4gICAgICAgICAgZXZlbnQ9IGV2ZW50c1tpXTtcbiAgICAgICAgICBvZmYuY2FsbCh0YXJnZXQsIGV2ZW50LCBsaXN0ZW5lcnNbZXZlbnRdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9saXN0ZW5lcnM9IHt9O1xuICAgICAgICB0aGlzLl9saXN0ZW5lcnNDb3VudD0gMDtcbiAgICAgICAgY2xlYXJSZWZzKCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBmdW5jdGlvbiByZXNvbHZlT3B0aW9ucyhvcHRpb25zLCBzY2hlbWEsIHJlZHVjZXJzLCBhbGxvd1Vua25vd24pIHtcbiAgICB2YXIgY29tcHV0ZWRPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgc2NoZW1hKTtcblxuICAgIGlmICghb3B0aW9ucykgcmV0dXJuIGNvbXB1dGVkT3B0aW9ucztcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCcpXG4gICAgfVxuXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIG9wdGlvbiwgdmFsdWU7XG4gICAgdmFyIHJlZHVjZXI7XG5cbiAgICBmdW5jdGlvbiByZWplY3QocmVhc29uKSB7XG4gICAgICB0aHJvdyBFcnJvcignSW52YWxpZCBcIicgKyBvcHRpb24gKyAnXCIgb3B0aW9uIHZhbHVlJyArIChyZWFzb24gPyAnLiBSZWFzb246ICcgKyByZWFzb24gOiAnJykpXG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgb3B0aW9uID0ga2V5c1tpXTtcbiAgICAgIGlmICghYWxsb3dVbmtub3duICYmICFoYXNPd25Qcm9wZXJ0eS5jYWxsKHNjaGVtYSwgb3B0aW9uKSkge1xuICAgICAgICB0aHJvdyBFcnJvcignVW5rbm93biBcIicgKyBvcHRpb24gKyAnXCIgb3B0aW9uJyk7XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IG9wdGlvbnNbb3B0aW9uXTtcbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlZHVjZXIgPSByZWR1Y2Vyc1tvcHRpb25dO1xuICAgICAgICBjb21wdXRlZE9wdGlvbnNbb3B0aW9uXSA9IHJlZHVjZXIgPyByZWR1Y2VyKHZhbHVlLCByZWplY3QpIDogdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb21wdXRlZE9wdGlvbnM7XG4gIH1cblxuICBmdW5jdGlvbiBjb25zdHJ1Y3RvclJlZHVjZXIodmFsdWUsIHJlamVjdCkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgfHwgIXZhbHVlLmhhc093blByb3BlcnR5KCdwcm90b3R5cGUnKSkge1xuICAgICAgcmVqZWN0KCd2YWx1ZSBtdXN0IGJlIGEgY29uc3RydWN0b3InKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFrZVR5cGVSZWR1Y2VyKHR5cGVzKSB7XG4gICAgdmFyIG1lc3NhZ2U9ICd2YWx1ZSBtdXN0IGJlIHR5cGUgb2YgJyArIHR5cGVzLmpvaW4oJ3wnKTtcbiAgICB2YXIgbGVuPSB0eXBlcy5sZW5ndGg7XG4gICAgdmFyIGZpcnN0VHlwZT0gdHlwZXNbMF07XG4gICAgdmFyIHNlY29uZFR5cGU9IHR5cGVzWzFdO1xuXG4gICAgaWYgKGxlbiA9PT0gMSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2LCByZWplY3QpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSBmaXJzdFR5cGUpIHtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgfVxuICAgICAgICByZWplY3QobWVzc2FnZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGxlbiA9PT0gMikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2LCByZWplY3QpIHtcbiAgICAgICAgdmFyIGtpbmQ9IHR5cGVvZiB2O1xuICAgICAgICBpZiAoa2luZCA9PT0gZmlyc3RUeXBlIHx8IGtpbmQgPT09IHNlY29uZFR5cGUpIHJldHVybiB2O1xuICAgICAgICByZWplY3QobWVzc2FnZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2LCByZWplY3QpIHtcbiAgICAgIHZhciBraW5kID0gdHlwZW9mIHY7XG4gICAgICB2YXIgaSA9IGxlbjtcbiAgICAgIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgICAgIGlmIChraW5kID09PSB0eXBlc1tpXSkgcmV0dXJuIHY7XG4gICAgICB9XG4gICAgICByZWplY3QobWVzc2FnZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGZ1bmN0aW9uUmVkdWNlcj0gbWFrZVR5cGVSZWR1Y2VyKFsnZnVuY3Rpb24nXSk7XG5cbiAgdmFyIG9iamVjdEZ1bmN0aW9uUmVkdWNlcj0gbWFrZVR5cGVSZWR1Y2VyKFsnb2JqZWN0JywgJ2Z1bmN0aW9uJ10pO1xuXG4gIGZ1bmN0aW9uIG1ha2VDYW5jZWxhYmxlUHJvbWlzZShQcm9taXNlLCBleGVjdXRvciwgb3B0aW9ucykge1xuICAgIHZhciBpc0NhbmNlbGFibGU7XG4gICAgdmFyIGNhbGxiYWNrcztcbiAgICB2YXIgdGltZXI9IDA7XG4gICAgdmFyIHN1YnNjcmlwdGlvbkNsb3NlZDtcblxuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCwgb25DYW5jZWwpIHtcbiAgICAgIG9wdGlvbnM9IHJlc29sdmVPcHRpb25zKG9wdGlvbnMsIHtcbiAgICAgICAgdGltZW91dDogMCxcbiAgICAgICAgb3ZlcmxvYWQ6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHRpbWVvdXQ6IGZ1bmN0aW9uKHZhbHVlLCByZWplY3Qpe1xuICAgICAgICAgIHZhbHVlKj0gMTtcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyB8fCB2YWx1ZSA8IDAgfHwgIU51bWJlci5pc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJlamVjdCgndGltZW91dCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlzQ2FuY2VsYWJsZSA9ICFvcHRpb25zLm92ZXJsb2FkICYmIHR5cGVvZiBQcm9taXNlLnByb3RvdHlwZS5jYW5jZWwgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9uQ2FuY2VsID09PSAnZnVuY3Rpb24nO1xuXG4gICAgICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICAgICAgY2FsbGJhY2tzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGltZXIpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgIHRpbWVyID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgX3Jlc29sdmU9IGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBfcmVqZWN0PSBmdW5jdGlvbihlcnIpe1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfTtcblxuICAgICAgaWYgKGlzQ2FuY2VsYWJsZSkge1xuICAgICAgICBleGVjdXRvcihfcmVzb2x2ZSwgX3JlamVjdCwgb25DYW5jZWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2tzID0gW2Z1bmN0aW9uKHJlYXNvbil7XG4gICAgICAgICAgX3JlamVjdChyZWFzb24gfHwgRXJyb3IoJ2NhbmNlbGVkJykpO1xuICAgICAgICB9XTtcbiAgICAgICAgZXhlY3V0b3IoX3Jlc29sdmUsIF9yZWplY3QsIGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgIGlmIChzdWJzY3JpcHRpb25DbG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdVbmFibGUgdG8gc3Vic2NyaWJlIG9uIGNhbmNlbCBldmVudCBhc3luY2hyb25vdXNseScpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcignb25DYW5jZWwgY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhbGxiYWNrcy5wdXNoKGNiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHN1YnNjcmlwdGlvbkNsb3NlZD0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMudGltZW91dCA+IDApIHtcbiAgICAgICAgdGltZXI9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICB2YXIgcmVhc29uPSBFcnJvcigndGltZW91dCcpO1xuICAgICAgICAgIHJlYXNvbi5jb2RlID0gJ0VUSU1FRE9VVCdcbiAgICAgICAgICB0aW1lcj0gMDtcbiAgICAgICAgICBwcm9taXNlLmNhbmNlbChyZWFzb24pO1xuICAgICAgICAgIHJlamVjdChyZWFzb24pO1xuICAgICAgICB9LCBvcHRpb25zLnRpbWVvdXQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKCFpc0NhbmNlbGFibGUpIHtcbiAgICAgIHByb21pc2UuY2FuY2VsID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICBpZiAoIWNhbGxiYWNrcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVuZ3RoID0gY2FsbGJhY2tzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNhbGxiYWNrc1tpXShyZWFzb24pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGludGVybmFsIGNhbGxiYWNrIHRvIHJlamVjdCB0aGUgcHJvbWlzZVxuICAgICAgICBjYWxsYmFja3NbMF0ocmVhc29uKTtcbiAgICAgICAgY2FsbGJhY2tzID0gbnVsbDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kVGFyZ2V0SW5kZXgob2JzZXJ2ZXIpIHtcbiAgICB2YXIgb2JzZXJ2ZXJzID0gdGhpcy5fb2JzZXJ2ZXJzO1xuICAgIGlmKCFvYnNlcnZlcnMpe1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICB2YXIgbGVuID0gb2JzZXJ2ZXJzLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAob2JzZXJ2ZXJzW2ldLl90YXJnZXQgPT09IG9ic2VydmVyKSByZXR1cm4gaTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLy8gQXR0ZW50aW9uLCBmdW5jdGlvbiByZXR1cm4gdHlwZSBub3cgaXMgYXJyYXksIGFsd2F5cyAhXG4gIC8vIEl0IGhhcyB6ZXJvIGVsZW1lbnRzIGlmIG5vIGFueSBtYXRjaGVzIGZvdW5kIGFuZCBvbmUgb3IgbW9yZVxuICAvLyBlbGVtZW50cyAobGVhZnMpIGlmIHRoZXJlIGFyZSBtYXRjaGVzXG4gIC8vXG4gIGZ1bmN0aW9uIHNlYXJjaExpc3RlbmVyVHJlZShoYW5kbGVycywgdHlwZSwgdHJlZSwgaSwgdHlwZUxlbmd0aCkge1xuICAgIGlmICghdHJlZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGkgPT09IDApIHtcbiAgICAgIHZhciBraW5kID0gdHlwZW9mIHR5cGU7XG4gICAgICBpZiAoa2luZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIG5zLCBuLCBsID0gMCwgaiA9IDAsIGRlbGltaXRlciA9IHRoaXMuZGVsaW1pdGVyLCBkbCA9IGRlbGltaXRlci5sZW5ndGg7XG4gICAgICAgIGlmICgobiA9IHR5cGUuaW5kZXhPZihkZWxpbWl0ZXIpKSAhPT0gLTEpIHtcbiAgICAgICAgICBucyA9IG5ldyBBcnJheSg1KTtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBuc1tsKytdID0gdHlwZS5zbGljZShqLCBuKTtcbiAgICAgICAgICAgIGogPSBuICsgZGw7XG4gICAgICAgICAgfSB3aGlsZSAoKG4gPSB0eXBlLmluZGV4T2YoZGVsaW1pdGVyLCBqKSkgIT09IC0xKTtcblxuICAgICAgICAgIG5zW2wrK10gPSB0eXBlLnNsaWNlKGopO1xuICAgICAgICAgIHR5cGUgPSBucztcbiAgICAgICAgICB0eXBlTGVuZ3RoID0gbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0eXBlID0gW3R5cGVdO1xuICAgICAgICAgIHR5cGVMZW5ndGggPSAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGtpbmQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHR5cGVMZW5ndGggPSB0eXBlLmxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGUgPSBbdHlwZV07XG4gICAgICAgIHR5cGVMZW5ndGggPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsaXN0ZW5lcnM9IG51bGwsIGJyYW5jaCwgeFRyZWUsIHh4VHJlZSwgaXNvbGF0ZWRCcmFuY2gsIGVuZFJlYWNoZWQsIGN1cnJlbnRUeXBlID0gdHlwZVtpXSxcbiAgICAgICAgbmV4dFR5cGUgPSB0eXBlW2kgKyAxXSwgYnJhbmNoZXMsIF9saXN0ZW5lcnM7XG5cbiAgICBpZiAoaSA9PT0gdHlwZUxlbmd0aCkge1xuICAgICAgLy9cbiAgICAgIC8vIElmIGF0IHRoZSBlbmQgb2YgdGhlIGV2ZW50KHMpIGxpc3QgYW5kIHRoZSB0cmVlIGhhcyBsaXN0ZW5lcnNcbiAgICAgIC8vIGludm9rZSB0aG9zZSBsaXN0ZW5lcnMuXG4gICAgICAvL1xuXG4gICAgICBpZih0cmVlLl9saXN0ZW5lcnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0cmVlLl9saXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBoYW5kbGVycyAmJiBoYW5kbGVycy5wdXNoKHRyZWUuX2xpc3RlbmVycyk7XG4gICAgICAgICAgbGlzdGVuZXJzID0gW3RyZWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhhbmRsZXJzICYmIGhhbmRsZXJzLnB1c2guYXBwbHkoaGFuZGxlcnMsIHRyZWUuX2xpc3RlbmVycyk7XG4gICAgICAgICAgbGlzdGVuZXJzID0gW3RyZWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcblxuICAgICAgaWYgKGN1cnJlbnRUeXBlID09PSAnKicpIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gSWYgdGhlIGV2ZW50IGVtaXR0ZWQgaXMgJyonIGF0IHRoaXMgcGFydFxuICAgICAgICAvLyBvciB0aGVyZSBpcyBhIGNvbmNyZXRlIG1hdGNoIGF0IHRoaXMgcGF0Y2hcbiAgICAgICAgLy9cbiAgICAgICAgYnJhbmNoZXMgPSBvd25LZXlzKHRyZWUpO1xuICAgICAgICBuID0gYnJhbmNoZXMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAobi0tID4gMCkge1xuICAgICAgICAgIGJyYW5jaCA9IGJyYW5jaGVzW25dO1xuICAgICAgICAgIGlmIChicmFuY2ggIT09ICdfbGlzdGVuZXJzJykge1xuICAgICAgICAgICAgX2xpc3RlbmVycyA9IHNlYXJjaExpc3RlbmVyVHJlZShoYW5kbGVycywgdHlwZSwgdHJlZVticmFuY2hdLCBpICsgMSwgdHlwZUxlbmd0aCk7XG4gICAgICAgICAgICBpZiAoX2xpc3RlbmVycykge1xuICAgICAgICAgICAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzLnB1c2guYXBwbHkobGlzdGVuZXJzLCBfbGlzdGVuZXJzKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMgPSBfbGlzdGVuZXJzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaXN0ZW5lcnM7XG4gICAgICB9IGVsc2UgaWYgKGN1cnJlbnRUeXBlID09PSAnKionKSB7XG4gICAgICAgIGVuZFJlYWNoZWQgPSAoaSArIDEgPT09IHR5cGVMZW5ndGggfHwgKGkgKyAyID09PSB0eXBlTGVuZ3RoICYmIG5leHRUeXBlID09PSAnKicpKTtcbiAgICAgICAgaWYgKGVuZFJlYWNoZWQgJiYgdHJlZS5fbGlzdGVuZXJzKSB7XG4gICAgICAgICAgLy8gVGhlIG5leHQgZWxlbWVudCBoYXMgYSBfbGlzdGVuZXJzLCBhZGQgaXQgdG8gdGhlIGhhbmRsZXJzLlxuICAgICAgICAgIGxpc3RlbmVycyA9IHNlYXJjaExpc3RlbmVyVHJlZShoYW5kbGVycywgdHlwZSwgdHJlZSwgdHlwZUxlbmd0aCwgdHlwZUxlbmd0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBicmFuY2hlcyA9IG93bktleXModHJlZSk7XG4gICAgICAgIG4gPSBicmFuY2hlcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChuLS0gPiAwKSB7XG4gICAgICAgICAgYnJhbmNoID0gYnJhbmNoZXNbbl07XG4gICAgICAgICAgaWYgKGJyYW5jaCAhPT0gJ19saXN0ZW5lcnMnKSB7XG4gICAgICAgICAgICBpZiAoYnJhbmNoID09PSAnKicgfHwgYnJhbmNoID09PSAnKionKSB7XG4gICAgICAgICAgICAgIGlmICh0cmVlW2JyYW5jaF0uX2xpc3RlbmVycyAmJiAhZW5kUmVhY2hlZCkge1xuICAgICAgICAgICAgICAgIF9saXN0ZW5lcnMgPSBzZWFyY2hMaXN0ZW5lclRyZWUoaGFuZGxlcnMsIHR5cGUsIHRyZWVbYnJhbmNoXSwgdHlwZUxlbmd0aCwgdHlwZUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgaWYgKF9saXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnB1c2guYXBwbHkobGlzdGVuZXJzLCBfbGlzdGVuZXJzKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycyA9IF9saXN0ZW5lcnM7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF9saXN0ZW5lcnMgPSBzZWFyY2hMaXN0ZW5lclRyZWUoaGFuZGxlcnMsIHR5cGUsIHRyZWVbYnJhbmNoXSwgaSwgdHlwZUxlbmd0aCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGJyYW5jaCA9PT0gbmV4dFR5cGUpIHtcbiAgICAgICAgICAgICAgX2xpc3RlbmVycyA9IHNlYXJjaExpc3RlbmVyVHJlZShoYW5kbGVycywgdHlwZSwgdHJlZVticmFuY2hdLCBpICsgMiwgdHlwZUxlbmd0aCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBObyBtYXRjaCBvbiB0aGlzIG9uZSwgc2hpZnQgaW50byB0aGUgdHJlZSBidXQgbm90IGluIHRoZSB0eXBlIGFycmF5LlxuICAgICAgICAgICAgICBfbGlzdGVuZXJzID0gc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB0cmVlW2JyYW5jaF0sIGksIHR5cGVMZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF9saXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVycy5wdXNoLmFwcGx5KGxpc3RlbmVycywgX2xpc3RlbmVycyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzID0gX2xpc3RlbmVycztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGlzdGVuZXJzO1xuICAgICAgfSBlbHNlIGlmICh0cmVlW2N1cnJlbnRUeXBlXSkge1xuICAgICAgICBsaXN0ZW5lcnMgPSBzZWFyY2hMaXN0ZW5lclRyZWUoaGFuZGxlcnMsIHR5cGUsIHRyZWVbY3VycmVudFR5cGVdLCBpICsgMSwgdHlwZUxlbmd0aCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgICB4VHJlZSA9IHRyZWVbJyonXTtcbiAgICBpZiAoeFRyZWUpIHtcbiAgICAgIC8vXG4gICAgICAvLyBJZiB0aGUgbGlzdGVuZXIgdHJlZSB3aWxsIGFsbG93IGFueSBtYXRjaCBmb3IgdGhpcyBwYXJ0LFxuICAgICAgLy8gdGhlbiByZWN1cnNpdmVseSBleHBsb3JlIGFsbCBicmFuY2hlcyBvZiB0aGUgdHJlZVxuICAgICAgLy9cbiAgICAgIHNlYXJjaExpc3RlbmVyVHJlZShoYW5kbGVycywgdHlwZSwgeFRyZWUsIGkgKyAxLCB0eXBlTGVuZ3RoKTtcbiAgICB9XG5cbiAgICB4eFRyZWUgPSB0cmVlWycqKiddO1xuICAgIGlmICh4eFRyZWUpIHtcbiAgICAgIGlmIChpIDwgdHlwZUxlbmd0aCkge1xuICAgICAgICBpZiAoeHhUcmVlLl9saXN0ZW5lcnMpIHtcbiAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgbGlzdGVuZXIgb24gYSAnKionLCBpdCB3aWxsIGNhdGNoIGFsbCwgc28gYWRkIGl0cyBoYW5kbGVyLlxuICAgICAgICAgIHNlYXJjaExpc3RlbmVyVHJlZShoYW5kbGVycywgdHlwZSwgeHhUcmVlLCB0eXBlTGVuZ3RoLCB0eXBlTGVuZ3RoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJ1aWxkIGFycmF5cyBvZiBtYXRjaGluZyBuZXh0IGJyYW5jaGVzIGFuZCBvdGhlcnMuXG4gICAgICAgIGJyYW5jaGVzPSBvd25LZXlzKHh4VHJlZSk7XG4gICAgICAgIG49IGJyYW5jaGVzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUobi0tPjApe1xuICAgICAgICAgIGJyYW5jaD0gYnJhbmNoZXNbbl07XG4gICAgICAgICAgaWYgKGJyYW5jaCAhPT0gJ19saXN0ZW5lcnMnKSB7XG4gICAgICAgICAgICBpZiAoYnJhbmNoID09PSBuZXh0VHlwZSkge1xuICAgICAgICAgICAgICAvLyBXZSBrbm93IHRoZSBuZXh0IGVsZW1lbnQgd2lsbCBtYXRjaCwgc28ganVtcCB0d2ljZS5cbiAgICAgICAgICAgICAgc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB4eFRyZWVbYnJhbmNoXSwgaSArIDIsIHR5cGVMZW5ndGgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChicmFuY2ggPT09IGN1cnJlbnRUeXBlKSB7XG4gICAgICAgICAgICAgIC8vIEN1cnJlbnQgbm9kZSBtYXRjaGVzLCBtb3ZlIGludG8gdGhlIHRyZWUuXG4gICAgICAgICAgICAgIHNlYXJjaExpc3RlbmVyVHJlZShoYW5kbGVycywgdHlwZSwgeHhUcmVlW2JyYW5jaF0sIGkgKyAxLCB0eXBlTGVuZ3RoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlzb2xhdGVkQnJhbmNoID0ge307XG4gICAgICAgICAgICAgIGlzb2xhdGVkQnJhbmNoW2JyYW5jaF0gPSB4eFRyZWVbYnJhbmNoXTtcbiAgICAgICAgICAgICAgc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB7JyoqJzogaXNvbGF0ZWRCcmFuY2h9LCBpICsgMSwgdHlwZUxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHh4VHJlZS5fbGlzdGVuZXJzKSB7XG4gICAgICAgIC8vIFdlIGhhdmUgcmVhY2hlZCB0aGUgZW5kIGFuZCBzdGlsbCBvbiBhICcqKidcbiAgICAgICAgc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB4eFRyZWUsIHR5cGVMZW5ndGgsIHR5cGVMZW5ndGgpO1xuICAgICAgfSBlbHNlIGlmICh4eFRyZWVbJyonXSAmJiB4eFRyZWVbJyonXS5fbGlzdGVuZXJzKSB7XG4gICAgICAgIHNlYXJjaExpc3RlbmVyVHJlZShoYW5kbGVycywgdHlwZSwgeHhUcmVlWycqJ10sIHR5cGVMZW5ndGgsIHR5cGVMZW5ndGgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBsaXN0ZW5lcnM7XG4gIH1cblxuICBmdW5jdGlvbiBncm93TGlzdGVuZXJUcmVlKHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XG4gICAgdmFyIGxlbiA9IDAsIGogPSAwLCBpLCBkZWxpbWl0ZXIgPSB0aGlzLmRlbGltaXRlciwgZGw9IGRlbGltaXRlci5sZW5ndGgsIG5zO1xuXG4gICAgaWYodHlwZW9mIHR5cGU9PT0nc3RyaW5nJykge1xuICAgICAgaWYgKChpID0gdHlwZS5pbmRleE9mKGRlbGltaXRlcikpICE9PSAtMSkge1xuICAgICAgICBucyA9IG5ldyBBcnJheSg1KTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIG5zW2xlbisrXSA9IHR5cGUuc2xpY2UoaiwgaSk7XG4gICAgICAgICAgaiA9IGkgKyBkbDtcbiAgICAgICAgfSB3aGlsZSAoKGkgPSB0eXBlLmluZGV4T2YoZGVsaW1pdGVyLCBqKSkgIT09IC0xKTtcblxuICAgICAgICBuc1tsZW4rK10gPSB0eXBlLnNsaWNlKGopO1xuICAgICAgfWVsc2V7XG4gICAgICAgIG5zPSBbdHlwZV07XG4gICAgICAgIGxlbj0gMTtcbiAgICAgIH1cbiAgICB9ZWxzZXtcbiAgICAgIG5zPSB0eXBlO1xuICAgICAgbGVuPSB0eXBlLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIExvb2tzIGZvciB0d28gY29uc2VjdXRpdmUgJyoqJywgaWYgc28sIGRvbid0IGFkZCB0aGUgZXZlbnQgYXQgYWxsLlxuICAgIC8vXG4gICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgKyAxIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKG5zW2ldID09PSAnKionICYmIG5zW2kgKyAxXSA9PT0gJyoqJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuXG5cbiAgICB2YXIgdHJlZSA9IHRoaXMubGlzdGVuZXJUcmVlLCBuYW1lO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBuYW1lID0gbnNbaV07XG5cbiAgICAgIHRyZWUgPSB0cmVlW25hbWVdIHx8ICh0cmVlW25hbWVdID0ge30pO1xuXG4gICAgICBpZiAoaSA9PT0gbGVuIC0gMSkge1xuICAgICAgICBpZiAoIXRyZWUuX2xpc3RlbmVycykge1xuICAgICAgICAgIHRyZWUuX2xpc3RlbmVycyA9IGxpc3RlbmVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgdHJlZS5fbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0cmVlLl9saXN0ZW5lcnMgPSBbdHJlZS5fbGlzdGVuZXJzXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocHJlcGVuZCkge1xuICAgICAgICAgICAgdHJlZS5fbGlzdGVuZXJzLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cmVlLl9saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAhdHJlZS5fbGlzdGVuZXJzLndhcm5lZCAmJlxuICAgICAgICAgICAgICB0aGlzLl9tYXhMaXN0ZW5lcnMgPiAwICYmXG4gICAgICAgICAgICAgIHRyZWUuX2xpc3RlbmVycy5sZW5ndGggPiB0aGlzLl9tYXhMaXN0ZW5lcnNcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHRyZWUuX2xpc3RlbmVycy53YXJuZWQgPSB0cnVlO1xuICAgICAgICAgICAgbG9nUG9zc2libGVNZW1vcnlMZWFrLmNhbGwodGhpcywgdHJlZS5fbGlzdGVuZXJzLmxlbmd0aCwgbmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gY29sbGVjdFRyZWVFdmVudHModHJlZSwgZXZlbnRzLCByb290LCBhc0FycmF5KXtcbiAgICAgdmFyIGJyYW5jaGVzPSBvd25LZXlzKHRyZWUpO1xuICAgICB2YXIgaT0gYnJhbmNoZXMubGVuZ3RoO1xuICAgICB2YXIgYnJhbmNoLCBicmFuY2hOYW1lLCBwYXRoO1xuICAgICB2YXIgaGFzTGlzdGVuZXJzPSB0cmVlWydfbGlzdGVuZXJzJ107XG4gICAgIHZhciBpc0FycmF5UGF0aDtcblxuICAgICB3aGlsZShpLS0+MCl7XG4gICAgICAgICBicmFuY2hOYW1lPSBicmFuY2hlc1tpXTtcblxuICAgICAgICAgYnJhbmNoPSB0cmVlW2JyYW5jaE5hbWVdO1xuXG4gICAgICAgICBpZihicmFuY2hOYW1lPT09J19saXN0ZW5lcnMnKXtcbiAgICAgICAgICAgICBwYXRoPSByb290O1xuICAgICAgICAgfWVsc2Uge1xuICAgICAgICAgICAgIHBhdGggPSByb290ID8gcm9vdC5jb25jYXQoYnJhbmNoTmFtZSkgOiBbYnJhbmNoTmFtZV07XG4gICAgICAgICB9XG5cbiAgICAgICAgIGlzQXJyYXlQYXRoPSBhc0FycmF5IHx8IHR5cGVvZiBicmFuY2hOYW1lPT09J3N5bWJvbCc7XG5cbiAgICAgICAgIGhhc0xpc3RlbmVycyAmJiBldmVudHMucHVzaChpc0FycmF5UGF0aD8gcGF0aCA6IHBhdGguam9pbih0aGlzLmRlbGltaXRlcikpO1xuXG4gICAgICAgICBpZih0eXBlb2YgYnJhbmNoPT09J29iamVjdCcpe1xuICAgICAgICAgICAgIGNvbGxlY3RUcmVlRXZlbnRzLmNhbGwodGhpcywgYnJhbmNoLCBldmVudHMsIHBhdGgsIGlzQXJyYXlQYXRoKTtcbiAgICAgICAgIH1cbiAgICAgfVxuXG4gICAgIHJldHVybiBldmVudHM7XG4gIH1cblxuICBmdW5jdGlvbiByZWN1cnNpdmVseUdhcmJhZ2VDb2xsZWN0KHJvb3QpIHtcbiAgICB2YXIga2V5cyA9IG93bktleXMocm9vdCk7XG4gICAgdmFyIGk9IGtleXMubGVuZ3RoO1xuICAgIHZhciBvYmosIGtleSwgZmxhZztcbiAgICB3aGlsZShpLS0+MCl7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgb2JqID0gcm9vdFtrZXldO1xuXG4gICAgICBpZihvYmope1xuICAgICAgICAgIGZsYWc9IHRydWU7XG4gICAgICAgICAgaWYoa2V5ICE9PSAnX2xpc3RlbmVycycgJiYgIXJlY3Vyc2l2ZWx5R2FyYmFnZUNvbGxlY3Qob2JqKSl7XG4gICAgICAgICAgICAgZGVsZXRlIHJvb3Rba2V5XTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZsYWc7XG4gIH1cblxuICBmdW5jdGlvbiBMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgbGlzdGVuZXIpe1xuICAgIHRoaXMuZW1pdHRlcj0gZW1pdHRlcjtcbiAgICB0aGlzLmV2ZW50PSBldmVudDtcbiAgICB0aGlzLmxpc3RlbmVyPSBsaXN0ZW5lcjtcbiAgfVxuXG4gIExpc3RlbmVyLnByb3RvdHlwZS5vZmY9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5lbWl0dGVyLm9mZih0aGlzLmV2ZW50LCB0aGlzLmxpc3RlbmVyKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBmdW5jdGlvbiBzZXR1cExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgb3B0aW9ucyl7XG4gICAgICBpZiAob3B0aW9ucyA9PT0gdHJ1ZSkge1xuICAgICAgICBwcm9taXNpZnkgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25zID09PSBmYWxzZSkge1xuICAgICAgICBhc3luYyA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIW9wdGlvbnMgfHwgdHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdvcHRpb25zIHNob3VsZCBiZSBhbiBvYmplY3Qgb3IgdHJ1ZScpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhc3luYyA9IG9wdGlvbnMuYXN5bmM7XG4gICAgICAgIHZhciBwcm9taXNpZnkgPSBvcHRpb25zLnByb21pc2lmeTtcbiAgICAgICAgdmFyIG5leHRUaWNrID0gb3B0aW9ucy5uZXh0VGljaztcbiAgICAgICAgdmFyIG9iamVjdGlmeSA9IG9wdGlvbnMub2JqZWN0aWZ5O1xuICAgICAgfVxuXG4gICAgICBpZiAoYXN5bmMgfHwgbmV4dFRpY2sgfHwgcHJvbWlzaWZ5KSB7XG4gICAgICAgIHZhciBfbGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICAgICAgdmFyIF9vcmlnaW4gPSBsaXN0ZW5lci5fb3JpZ2luIHx8IGxpc3RlbmVyO1xuXG4gICAgICAgIGlmIChuZXh0VGljayAmJiAhbmV4dFRpY2tTdXBwb3J0ZWQpIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcigncHJvY2Vzcy5uZXh0VGljayBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvbWlzaWZ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwcm9taXNpZnkgPSBsaXN0ZW5lci5jb25zdHJ1Y3Rvci5uYW1lID09PSAnQXN5bmNGdW5jdGlvbic7XG4gICAgICAgIH1cblxuICAgICAgICBsaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICAgICAgdmFyIGV2ZW50ID0gdGhpcy5ldmVudDtcblxuICAgICAgICAgIHJldHVybiBwcm9taXNpZnkgPyAobmV4dFRpY2sgPyBQcm9taXNlLnJlc29sdmUoKSA6IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICBfc2V0SW1tZWRpYXRlKHJlc29sdmUpO1xuICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29udGV4dC5ldmVudCA9IGV2ZW50O1xuICAgICAgICAgICAgcmV0dXJuIF9saXN0ZW5lci5hcHBseShjb250ZXh0LCBhcmdzKVxuICAgICAgICAgIH0pKSA6IChuZXh0VGljayA/IHByb2Nlc3MubmV4dFRpY2sgOiBfc2V0SW1tZWRpYXRlKShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb250ZXh0LmV2ZW50ID0gZXZlbnQ7XG4gICAgICAgICAgICBfbGlzdGVuZXIuYXBwbHkoY29udGV4dCwgYXJncylcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBsaXN0ZW5lci5fYXN5bmMgPSB0cnVlO1xuICAgICAgICBsaXN0ZW5lci5fb3JpZ2luID0gX29yaWdpbjtcbiAgICAgIH1cblxuICAgIHJldHVybiBbbGlzdGVuZXIsIG9iamVjdGlmeT8gbmV3IExpc3RlbmVyKHRoaXMsIGV2ZW50LCBsaXN0ZW5lcik6IHRoaXNdO1xuICB9XG5cbiAgZnVuY3Rpb24gRXZlbnRFbWl0dGVyKGNvbmYpIHtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICB0aGlzLl9uZXdMaXN0ZW5lciA9IGZhbHNlO1xuICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVyID0gZmFsc2U7XG4gICAgdGhpcy52ZXJib3NlTWVtb3J5TGVhayA9IGZhbHNlO1xuICAgIGNvbmZpZ3VyZS5jYWxsKHRoaXMsIGNvbmYpO1xuICB9XG5cbiAgRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlcjIgPSBFdmVudEVtaXR0ZXI7IC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGZvciBleHBvcnRpbmcgRXZlbnRFbWl0dGVyIHByb3BlcnR5XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5Ubz0gZnVuY3Rpb24odGFyZ2V0LCBldmVudHMsIG9wdGlvbnMpe1xuICAgIGlmKHR5cGVvZiB0YXJnZXQhPT0nb2JqZWN0Jyl7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ3RhcmdldCBtdXN0cyBiZSBhbiBvYmplY3QnKTtcbiAgICB9XG5cbiAgICB2YXIgZW1pdHRlcj0gdGhpcztcblxuICAgIG9wdGlvbnMgPSByZXNvbHZlT3B0aW9ucyhvcHRpb25zLCB7XG4gICAgICBvbjogdW5kZWZpbmVkLFxuICAgICAgb2ZmOiB1bmRlZmluZWQsXG4gICAgICByZWR1Y2VyczogdW5kZWZpbmVkXG4gICAgfSwge1xuICAgICAgb246IGZ1bmN0aW9uUmVkdWNlcixcbiAgICAgIG9mZjogZnVuY3Rpb25SZWR1Y2VyLFxuICAgICAgcmVkdWNlcnM6IG9iamVjdEZ1bmN0aW9uUmVkdWNlclxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gbGlzdGVuKGV2ZW50cyl7XG4gICAgICBpZih0eXBlb2YgZXZlbnRzIT09J29iamVjdCcpe1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ2V2ZW50cyBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVkdWNlcnM9IG9wdGlvbnMucmVkdWNlcnM7XG4gICAgICB2YXIgaW5kZXg9IGZpbmRUYXJnZXRJbmRleC5jYWxsKGVtaXR0ZXIsIHRhcmdldCk7XG4gICAgICB2YXIgb2JzZXJ2ZXI7XG5cbiAgICAgIGlmKGluZGV4PT09LTEpe1xuICAgICAgICBvYnNlcnZlcj0gbmV3IFRhcmdldE9ic2VydmVyKGVtaXR0ZXIsIHRhcmdldCwgb3B0aW9ucyk7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgb2JzZXJ2ZXI9IGVtaXR0ZXIuX29ic2VydmVyc1tpbmRleF07XG4gICAgICB9XG5cbiAgICAgIHZhciBrZXlzPSBvd25LZXlzKGV2ZW50cyk7XG4gICAgICB2YXIgbGVuPSBrZXlzLmxlbmd0aDtcbiAgICAgIHZhciBldmVudDtcbiAgICAgIHZhciBpc1NpbmdsZVJlZHVjZXI9IHR5cGVvZiByZWR1Y2Vycz09PSdmdW5jdGlvbic7XG5cbiAgICAgIGZvcih2YXIgaT0wOyBpPGxlbjsgaSsrKXtcbiAgICAgICAgZXZlbnQ9IGtleXNbaV07XG4gICAgICAgIG9ic2VydmVyLnN1YnNjcmliZShcbiAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgZXZlbnRzW2V2ZW50XSB8fCBldmVudCxcbiAgICAgICAgICAgIGlzU2luZ2xlUmVkdWNlciA/IHJlZHVjZXJzIDogcmVkdWNlcnMgJiYgcmVkdWNlcnNbZXZlbnRdXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaXNBcnJheShldmVudHMpP1xuICAgICAgICBsaXN0ZW4odG9PYmplY3QoZXZlbnRzKSkgOlxuICAgICAgICAodHlwZW9mIGV2ZW50cz09PSdzdHJpbmcnPyBsaXN0ZW4odG9PYmplY3QoZXZlbnRzLnNwbGl0KC9cXHMrLykpKTogbGlzdGVuKGV2ZW50cykpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zdG9wTGlzdGVuaW5nVG8gPSBmdW5jdGlvbiAodGFyZ2V0LCBldmVudCkge1xuICAgIHZhciBvYnNlcnZlcnMgPSB0aGlzLl9vYnNlcnZlcnM7XG5cbiAgICBpZighb2JzZXJ2ZXJzKXtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgaSA9IG9ic2VydmVycy5sZW5ndGg7XG4gICAgdmFyIG9ic2VydmVyO1xuICAgIHZhciBtYXRjaGVkPSBmYWxzZTtcblxuICAgIGlmKHRhcmdldCAmJiB0eXBlb2YgdGFyZ2V0IT09J29iamVjdCcpe1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCd0YXJnZXQgc2hvdWxkIGJlIGFuIG9iamVjdCcpO1xuICAgIH1cblxuICAgIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgICBvYnNlcnZlciA9IG9ic2VydmVyc1tpXTtcbiAgICAgIGlmICghdGFyZ2V0IHx8IG9ic2VydmVyLl90YXJnZXQgPT09IHRhcmdldCkge1xuICAgICAgICBvYnNlcnZlci51bnN1YnNjcmliZShldmVudCk7XG4gICAgICAgIG1hdGNoZWQ9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdGNoZWQ7XG4gIH07XG5cbiAgLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhblxuICAvLyAxMCBsaXN0ZW5lcnMgYXJlIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2hcbiAgLy8gaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG4gIC8vXG4gIC8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuICAvLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmRlbGltaXRlciA9ICcuJztcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcbiAgICBpZiAobiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICAgICAgaWYgKCF0aGlzLl9jb25mKSB0aGlzLl9jb25mID0ge307XG4gICAgICB0aGlzLl9jb25mLm1heExpc3RlbmVycyA9IG47XG4gICAgfVxuICB9O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX21heExpc3RlbmVycztcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50ID0gJyc7XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZXZlbnQsIGZuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX29uY2UoZXZlbnQsIGZuLCBmYWxzZSwgb3B0aW9ucyk7XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX29uY2UoZXZlbnQsIGZuLCB0cnVlLCBvcHRpb25zKTtcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLl9vbmNlID0gZnVuY3Rpb24oZXZlbnQsIGZuLCBwcmVwZW5kLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hbnkoZXZlbnQsIDEsIGZuLCBwcmVwZW5kLCBvcHRpb25zKTtcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm1hbnkgPSBmdW5jdGlvbihldmVudCwgdHRsLCBmbiwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9tYW55KGV2ZW50LCB0dGwsIGZuLCBmYWxzZSwgb3B0aW9ucyk7XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTWFueSA9IGZ1bmN0aW9uKGV2ZW50LCB0dGwsIGZuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hbnkoZXZlbnQsIHR0bCwgZm4sIHRydWUsIG9wdGlvbnMpO1xuICB9O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21hbnkgPSBmdW5jdGlvbihldmVudCwgdHRsLCBmbiwgcHJlcGVuZCwgb3B0aW9ucykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWFueSBvbmx5IGFjY2VwdHMgaW5zdGFuY2VzIG9mIEZ1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdGVuZXIoKSB7XG4gICAgICBpZiAoLS10dGwgPT09IDApIHtcbiAgICAgICAgc2VsZi5vZmYoZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIGxpc3RlbmVyLl9vcmlnaW4gPSBmbjtcblxuICAgIHJldHVybiB0aGlzLl9vbihldmVudCwgbGlzdGVuZXIsIHByZXBlbmQsIG9wdGlvbnMpO1xuICB9O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5fZXZlbnRzICYmICF0aGlzLl9hbGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLl9ldmVudHMgfHwgaW5pdC5jYWxsKHRoaXMpO1xuXG4gICAgdmFyIHR5cGUgPSBhcmd1bWVudHNbMF0sIG5zLCB3aWxkY2FyZD0gdGhpcy53aWxkY2FyZDtcbiAgICB2YXIgYXJncyxsLGksaiwgY29udGFpbnNTeW1ib2w7XG5cbiAgICBpZiAodHlwZSA9PT0gJ25ld0xpc3RlbmVyJyAmJiAhdGhpcy5fbmV3TGlzdGVuZXIpIHtcbiAgICAgIGlmICghdGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAod2lsZGNhcmQpIHtcbiAgICAgIG5zPSB0eXBlO1xuICAgICAgaWYodHlwZSE9PSduZXdMaXN0ZW5lcicgJiYgdHlwZSE9PSdyZW1vdmVMaXN0ZW5lcicpe1xuICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgbCA9IHR5cGUubGVuZ3RoO1xuICAgICAgICAgIGlmIChzeW1ib2xzU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVtpXSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgICAgICAgICBjb250YWluc1N5bWJvbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFjb250YWluc1N5bWJvbCkge1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuam9pbih0aGlzLmRlbGltaXRlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGFsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgaGFuZGxlcjtcblxuICAgIGlmICh0aGlzLl9hbGwgJiYgdGhpcy5fYWxsLmxlbmd0aCkge1xuICAgICAgaGFuZGxlciA9IHRoaXMuX2FsbC5zbGljZSgpO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsID0gaGFuZGxlci5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcy5ldmVudCA9IHR5cGU7XG4gICAgICAgIHN3aXRjaCAoYWwpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGhhbmRsZXJbaV0uY2FsbCh0aGlzLCB0eXBlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGhhbmRsZXJbaV0uY2FsbCh0aGlzLCB0eXBlLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgaGFuZGxlcltpXS5jYWxsKHRoaXMsIHR5cGUsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBoYW5kbGVyW2ldLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAod2lsZGNhcmQpIHtcbiAgICAgIGhhbmRsZXIgPSBbXTtcbiAgICAgIHNlYXJjaExpc3RlbmVyVHJlZS5jYWxsKHRoaXMsIGhhbmRsZXIsIG5zLCB0aGlzLmxpc3RlbmVyVHJlZSwgMCwgbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5ldmVudCA9IHR5cGU7XG4gICAgICAgIHN3aXRjaCAoYWwpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBhcmdzID0gbmV3IEFycmF5KGFsIC0gMSk7XG4gICAgICAgICAgZm9yIChqID0gMTsgaiA8IGFsOyBqKyspIGFyZ3NbaiAtIDFdID0gYXJndW1lbnRzW2pdO1xuICAgICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgLy8gbmVlZCB0byBtYWtlIGNvcHkgb2YgaGFuZGxlcnMgYmVjYXVzZSBsaXN0IGNhbiBjaGFuZ2UgaW4gdGhlIG1pZGRsZVxuICAgICAgICAvLyBvZiBlbWl0IGNhbGxcbiAgICAgICAgaGFuZGxlciA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGFuZGxlciAmJiBoYW5kbGVyLmxlbmd0aCkge1xuICAgICAgaWYgKGFsID4gMykge1xuICAgICAgICBhcmdzID0gbmV3IEFycmF5KGFsIC0gMSk7XG4gICAgICAgIGZvciAoaiA9IDE7IGogPCBhbDsgaisrKSBhcmdzW2ogLSAxXSA9IGFyZ3VtZW50c1tqXTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDAsIGwgPSBoYW5kbGVyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0aGlzLmV2ZW50ID0gdHlwZTtcbiAgICAgICAgc3dpdGNoIChhbCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaGFuZGxlcltpXS5jYWxsKHRoaXMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgaGFuZGxlcltpXS5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBoYW5kbGVyW2ldLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGhhbmRsZXJbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuaWdub3JlRXJyb3JzICYmICF0aGlzLl9hbGwgJiYgdHlwZSA9PT0gJ2Vycm9yJykge1xuICAgICAgaWYgKGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGFyZ3VtZW50c1sxXTsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuY2F1Z2h0LCB1bnNwZWNpZmllZCAnZXJyb3InIGV2ZW50LlwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gISF0aGlzLl9hbGw7XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0QXN5bmMgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cyAmJiAhdGhpcy5fYWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5fZXZlbnRzIHx8IGluaXQuY2FsbCh0aGlzKTtcblxuICAgIHZhciB0eXBlID0gYXJndW1lbnRzWzBdLCB3aWxkY2FyZD0gdGhpcy53aWxkY2FyZCwgbnMsIGNvbnRhaW5zU3ltYm9sO1xuICAgIHZhciBhcmdzLGwsaSxqO1xuXG4gICAgaWYgKHR5cGUgPT09ICduZXdMaXN0ZW5lcicgJiYgIXRoaXMuX25ld0xpc3RlbmVyKSB7XG4gICAgICAgIGlmICghdGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUoW2ZhbHNlXSk7IH1cbiAgICB9XG5cbiAgICBpZiAod2lsZGNhcmQpIHtcbiAgICAgIG5zPSB0eXBlO1xuICAgICAgaWYodHlwZSE9PSduZXdMaXN0ZW5lcicgJiYgdHlwZSE9PSdyZW1vdmVMaXN0ZW5lcicpe1xuICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgbCA9IHR5cGUubGVuZ3RoO1xuICAgICAgICAgIGlmIChzeW1ib2xzU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVtpXSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgICAgICAgICBjb250YWluc1N5bWJvbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFjb250YWluc1N5bWJvbCkge1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuam9pbih0aGlzLmRlbGltaXRlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByb21pc2VzPSBbXTtcblxuICAgIHZhciBhbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGhhbmRsZXI7XG5cbiAgICBpZiAodGhpcy5fYWxsKSB7XG4gICAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5fYWxsLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0aGlzLmV2ZW50ID0gdHlwZTtcbiAgICAgICAgc3dpdGNoIChhbCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLl9hbGxbaV0uY2FsbCh0aGlzLCB0eXBlKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuX2FsbFtpXS5jYWxsKHRoaXMsIHR5cGUsIGFyZ3VtZW50c1sxXSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLl9hbGxbaV0uY2FsbCh0aGlzLCB0eXBlLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5fYWxsW2ldLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHdpbGRjYXJkKSB7XG4gICAgICBoYW5kbGVyID0gW107XG4gICAgICBzZWFyY2hMaXN0ZW5lclRyZWUuY2FsbCh0aGlzLCBoYW5kbGVyLCBucywgdGhpcy5saXN0ZW5lclRyZWUsIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5ldmVudCA9IHR5cGU7XG4gICAgICBzd2l0Y2ggKGFsKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHByb21pc2VzLnB1c2goaGFuZGxlci5jYWxsKHRoaXMpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHByb21pc2VzLnB1c2goaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgcHJvbWlzZXMucHVzaChoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBhcmdzID0gbmV3IEFycmF5KGFsIC0gMSk7XG4gICAgICAgIGZvciAoaiA9IDE7IGogPCBhbDsgaisrKSBhcmdzW2ogLSAxXSA9IGFyZ3VtZW50c1tqXTtcbiAgICAgICAgcHJvbWlzZXMucHVzaChoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGhhbmRsZXIgJiYgaGFuZGxlci5sZW5ndGgpIHtcbiAgICAgIGhhbmRsZXIgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgICBpZiAoYWwgPiAzKSB7XG4gICAgICAgIGFyZ3MgPSBuZXcgQXJyYXkoYWwgLSAxKTtcbiAgICAgICAgZm9yIChqID0gMTsgaiA8IGFsOyBqKyspIGFyZ3NbaiAtIDFdID0gYXJndW1lbnRzW2pdO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMCwgbCA9IGhhbmRsZXIubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZXZlbnQgPSB0eXBlO1xuICAgICAgICBzd2l0Y2ggKGFsKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKGhhbmRsZXJbaV0uY2FsbCh0aGlzKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKGhhbmRsZXJbaV0uY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHByb21pc2VzLnB1c2goaGFuZGxlcltpXS5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcHJvbWlzZXMucHVzaChoYW5kbGVyW2ldLmFwcGx5KHRoaXMsIGFyZ3MpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIXRoaXMuaWdub3JlRXJyb3JzICYmICF0aGlzLl9hbGwgJiYgdHlwZSA9PT0gJ2Vycm9yJykge1xuICAgICAgaWYgKGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChhcmd1bWVudHNbMV0pOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFwiVW5jYXVnaHQsIHVuc3BlY2lmaWVkICdlcnJvcicgZXZlbnQuXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX29uKHR5cGUsIGxpc3RlbmVyLCBmYWxzZSwgb3B0aW9ucyk7XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9vbih0eXBlLCBsaXN0ZW5lciwgdHJ1ZSwgb3B0aW9ucyk7XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbkFueSA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgcmV0dXJuIHRoaXMuX29uQW55KGZuLCBmYWxzZSk7XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kQW55ID0gZnVuY3Rpb24oZm4pIHtcbiAgICByZXR1cm4gdGhpcy5fb25BbnkoZm4sIHRydWUpO1xuICB9O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uO1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuX29uQW55ID0gZnVuY3Rpb24oZm4sIHByZXBlbmQpe1xuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignb25Bbnkgb25seSBhY2NlcHRzIGluc3RhbmNlcyBvZiBGdW5jdGlvbicpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fYWxsKSB7XG4gICAgICB0aGlzLl9hbGwgPSBbXTtcbiAgICB9XG5cbiAgICAvLyBBZGQgdGhlIGZ1bmN0aW9uIHRvIHRoZSBldmVudCBsaXN0ZW5lciBjb2xsZWN0aW9uLlxuICAgIGlmKHByZXBlbmQpe1xuICAgICAgdGhpcy5fYWxsLnVuc2hpZnQoZm4pO1xuICAgIH1lbHNle1xuICAgICAgdGhpcy5fYWxsLnB1c2goZm4pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuX29uID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIsIHByZXBlbmQsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuX29uQW55KHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignb24gb25seSBhY2NlcHRzIGluc3RhbmNlcyBvZiBGdW5jdGlvbicpO1xuICAgIH1cbiAgICB0aGlzLl9ldmVudHMgfHwgaW5pdC5jYWxsKHRoaXMpO1xuXG4gICAgdmFyIHJldHVyblZhbHVlPSB0aGlzLCB0ZW1wO1xuXG4gICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGVtcCA9IHNldHVwTGlzdGVuZXIuY2FsbCh0aGlzLCB0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucyk7XG4gICAgICBsaXN0ZW5lciA9IHRlbXBbMF07XG4gICAgICByZXR1cm5WYWx1ZSA9IHRlbXBbMV07XG4gICAgfVxuXG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PSBcIm5ld0xpc3RlbmVyc1wiISBCZWZvcmVcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyc1wiLlxuICAgIGlmICh0aGlzLl9uZXdMaXN0ZW5lcikge1xuICAgICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy53aWxkY2FyZCkge1xuICAgICAgZ3Jvd0xpc3RlbmVyVHJlZS5jYWxsKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKTtcbiAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSkge1xuICAgICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLl9ldmVudHNbdHlwZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gQ2hhbmdlIHRvIGFycmF5LlxuICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYWRkXG4gICAgICBpZihwcmVwZW5kKXtcbiAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgICAgfWVsc2V7XG4gICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICAgIGlmIChcbiAgICAgICAgIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgJiZcbiAgICAgICAgdGhpcy5fbWF4TGlzdGVuZXJzID4gMCAmJlxuICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gdGhpcy5fbWF4TGlzdGVuZXJzXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICAgIGxvZ1Bvc3NpYmxlTWVtb3J5TGVhay5jYWxsKHRoaXMsIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgsIHR5cGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZW1vdmVMaXN0ZW5lciBvbmx5IHRha2VzIGluc3RhbmNlcyBvZiBGdW5jdGlvbicpO1xuICAgIH1cblxuICAgIHZhciBoYW5kbGVycyxsZWFmcz1bXTtcblxuICAgIGlmKHRoaXMud2lsZGNhcmQpIHtcbiAgICAgIHZhciBucyA9IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyA/IHR5cGUuc3BsaXQodGhpcy5kZWxpbWl0ZXIpIDogdHlwZS5zbGljZSgpO1xuICAgICAgbGVhZnMgPSBzZWFyY2hMaXN0ZW5lclRyZWUuY2FsbCh0aGlzLCBudWxsLCBucywgdGhpcy5saXN0ZW5lclRyZWUsIDApO1xuICAgICAgaWYoIWxlYWZzKSByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZG9lcyBub3QgdXNlIGxpc3RlbmVycygpLCBzbyBubyBzaWRlIGVmZmVjdCBvZiBjcmVhdGluZyBfZXZlbnRzW3R5cGVdXG4gICAgICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSkgcmV0dXJuIHRoaXM7XG4gICAgICBoYW5kbGVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICAgIGxlYWZzLnB1c2goe19saXN0ZW5lcnM6aGFuZGxlcnN9KTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpTGVhZj0wOyBpTGVhZjxsZWFmcy5sZW5ndGg7IGlMZWFmKyspIHtcbiAgICAgIHZhciBsZWFmID0gbGVhZnNbaUxlYWZdO1xuICAgICAgaGFuZGxlcnMgPSBsZWFmLl9saXN0ZW5lcnM7XG4gICAgICBpZiAoaXNBcnJheShoYW5kbGVycykpIHtcblxuICAgICAgICB2YXIgcG9zaXRpb24gPSAtMTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoaGFuZGxlcnNbaV0gPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgICAoaGFuZGxlcnNbaV0ubGlzdGVuZXIgJiYgaGFuZGxlcnNbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB8fFxuICAgICAgICAgICAgKGhhbmRsZXJzW2ldLl9vcmlnaW4gJiYgaGFuZGxlcnNbaV0uX29yaWdpbiA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZih0aGlzLndpbGRjYXJkKSB7XG4gICAgICAgICAgbGVhZi5fbGlzdGVuZXJzLnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFuZGxlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgaWYodGhpcy53aWxkY2FyZCkge1xuICAgICAgICAgICAgZGVsZXRlIGxlYWYuX2xpc3RlbmVycztcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgdGhpcy5lbWl0KFwicmVtb3ZlTGlzdGVuZXJcIiwgdHlwZSwgbGlzdGVuZXIpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaGFuZGxlcnMgPT09IGxpc3RlbmVyIHx8XG4gICAgICAgIChoYW5kbGVycy5saXN0ZW5lciAmJiBoYW5kbGVycy5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHx8XG4gICAgICAgIChoYW5kbGVycy5fb3JpZ2luICYmIGhhbmRsZXJzLl9vcmlnaW4gPT09IGxpc3RlbmVyKSkge1xuICAgICAgICBpZih0aGlzLndpbGRjYXJkKSB7XG4gICAgICAgICAgZGVsZXRlIGxlYWYuX2xpc3RlbmVycztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICB0aGlzLmVtaXQoXCJyZW1vdmVMaXN0ZW5lclwiLCB0eXBlLCBsaXN0ZW5lcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5saXN0ZW5lclRyZWUgJiYgcmVjdXJzaXZlbHlHYXJiYWdlQ29sbGVjdCh0aGlzLmxpc3RlbmVyVHJlZSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZkFueSA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgdmFyIGkgPSAwLCBsID0gMCwgZm5zO1xuICAgIGlmIChmbiAmJiB0aGlzLl9hbGwgJiYgdGhpcy5fYWxsLmxlbmd0aCA+IDApIHtcbiAgICAgIGZucyA9IHRoaXMuX2FsbDtcbiAgICAgIGZvcihpID0gMCwgbCA9IGZucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYoZm4gPT09IGZuc1tpXSkge1xuICAgICAgICAgIGZucy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgaWYgKHRoaXMuX3JlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KFwicmVtb3ZlTGlzdGVuZXJBbnlcIiwgZm4pO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZucyA9IHRoaXMuX2FsbDtcbiAgICAgIGlmICh0aGlzLl9yZW1vdmVMaXN0ZW5lcikge1xuICAgICAgICBmb3IoaSA9IDAsIGwgPSBmbnMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgICAgIHRoaXMuZW1pdChcInJlbW92ZUxpc3RlbmVyQW55XCIsIGZuc1tpXSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9hbGwgPSBbXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmO1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAhdGhpcy5fZXZlbnRzIHx8IGluaXQuY2FsbCh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmICh0aGlzLndpbGRjYXJkKSB7XG4gICAgICB2YXIgbGVhZnMgPSBzZWFyY2hMaXN0ZW5lclRyZWUuY2FsbCh0aGlzLCBudWxsLCB0eXBlLCB0aGlzLmxpc3RlbmVyVHJlZSwgMCksIGxlYWYsIGk7XG4gICAgICBpZiAoIWxlYWZzKSByZXR1cm4gdGhpcztcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZWFmcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZWFmID0gbGVhZnNbaV07XG4gICAgICAgIGxlYWYuX2xpc3RlbmVycyA9IG51bGw7XG4gICAgICB9XG4gICAgICB0aGlzLmxpc3RlbmVyVHJlZSAmJiByZWN1cnNpdmVseUdhcmJhZ2VDb2xsZWN0KHRoaXMubGlzdGVuZXJUcmVlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2V2ZW50cykge1xuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgIHZhciBfZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgIHZhciBrZXlzLCBsaXN0ZW5lcnMsIGFsbExpc3RlbmVycztcbiAgICB2YXIgaTtcbiAgICB2YXIgbGlzdGVuZXJUcmVlO1xuXG4gICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHRoaXMud2lsZGNhcmQpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ2V2ZW50IG5hbWUgcmVxdWlyZWQgZm9yIHdpbGRjYXJkIGVtaXR0ZXInKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFfZXZlbnRzKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cblxuICAgICAga2V5cyA9IG93bktleXMoX2V2ZW50cyk7XG4gICAgICBpID0ga2V5cy5sZW5ndGg7XG4gICAgICBhbGxMaXN0ZW5lcnMgPSBbXTtcbiAgICAgIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgICAgIGxpc3RlbmVycyA9IF9ldmVudHNba2V5c1tpXV07XG4gICAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgYWxsTGlzdGVuZXJzLnB1c2gobGlzdGVuZXJzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhbGxMaXN0ZW5lcnMucHVzaC5hcHBseShhbGxMaXN0ZW5lcnMsIGxpc3RlbmVycyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhbGxMaXN0ZW5lcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLndpbGRjYXJkKSB7XG4gICAgICAgIGxpc3RlbmVyVHJlZT0gdGhpcy5saXN0ZW5lclRyZWU7XG4gICAgICAgIGlmKCFsaXN0ZW5lclRyZWUpIHJldHVybiBbXTtcbiAgICAgICAgdmFyIGhhbmRsZXJzID0gW107XG4gICAgICAgIHZhciBucyA9IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyA/IHR5cGUuc3BsaXQodGhpcy5kZWxpbWl0ZXIpIDogdHlwZS5zbGljZSgpO1xuICAgICAgICBzZWFyY2hMaXN0ZW5lclRyZWUuY2FsbCh0aGlzLCBoYW5kbGVycywgbnMsIGxpc3RlbmVyVHJlZSwgMCk7XG4gICAgICAgIHJldHVybiBoYW5kbGVycztcbiAgICAgIH1cblxuICAgICAgaWYgKCFfZXZlbnRzKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzID0gX2V2ZW50c1t0eXBlXTtcblxuICAgICAgaWYgKCFsaXN0ZW5lcnMpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicgPyBbbGlzdGVuZXJzXSA6IGxpc3RlbmVycztcbiAgICB9XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24obnNBc0FycmF5KXtcbiAgICB2YXIgX2V2ZW50cz0gdGhpcy5fZXZlbnRzO1xuICAgIHJldHVybiB0aGlzLndpbGRjYXJkPyBjb2xsZWN0VHJlZUV2ZW50cy5jYWxsKHRoaXMsIHRoaXMubGlzdGVuZXJUcmVlLCBbXSwgbnVsbCwgbnNBc0FycmF5KSA6IChfZXZlbnRzPyBvd25LZXlzKF9ldmVudHMpIDogW10pO1xuICB9O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xuICB9O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuaGFzTGlzdGVuZXJzID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBpZiAodGhpcy53aWxkY2FyZCkge1xuICAgICAgdmFyIGhhbmRsZXJzID0gW107XG4gICAgICB2YXIgbnMgPSB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgPyB0eXBlLnNwbGl0KHRoaXMuZGVsaW1pdGVyKSA6IHR5cGUuc2xpY2UoKTtcbiAgICAgIHNlYXJjaExpc3RlbmVyVHJlZS5jYWxsKHRoaXMsIGhhbmRsZXJzLCBucywgdGhpcy5saXN0ZW5lclRyZWUsIDApO1xuICAgICAgcmV0dXJuIGhhbmRsZXJzLmxlbmd0aCA+IDA7XG4gICAgfVxuXG4gICAgdmFyIF9ldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgdmFyIF9hbGwgPSB0aGlzLl9hbGw7XG5cbiAgICByZXR1cm4gISEoX2FsbCAmJiBfYWxsLmxlbmd0aCB8fCBfZXZlbnRzICYmICh0eXBlID09PSB1bmRlZmluZWQgPyBvd25LZXlzKF9ldmVudHMpLmxlbmd0aCA6IF9ldmVudHNbdHlwZV0pKTtcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyc0FueSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgaWYodGhpcy5fYWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYWxsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLndhaXRGb3IgPSBmdW5jdGlvbiAoZXZlbnQsIG9wdGlvbnMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2Ygb3B0aW9ucztcbiAgICBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIG9wdGlvbnMgPSB7dGltZW91dDogb3B0aW9uc307XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvcHRpb25zID0ge2ZpbHRlcjogb3B0aW9uc307XG4gICAgfVxuXG4gICAgb3B0aW9ucz0gcmVzb2x2ZU9wdGlvbnMob3B0aW9ucywge1xuICAgICAgdGltZW91dDogMCxcbiAgICAgIGZpbHRlcjogdW5kZWZpbmVkLFxuICAgICAgaGFuZGxlRXJyb3I6IGZhbHNlLFxuICAgICAgUHJvbWlzZTogUHJvbWlzZSxcbiAgICAgIG92ZXJsb2FkOiBmYWxzZVxuICAgIH0sIHtcbiAgICAgIGZpbHRlcjogZnVuY3Rpb25SZWR1Y2VyLFxuICAgICAgUHJvbWlzZTogY29uc3RydWN0b3JSZWR1Y2VyXG4gICAgfSk7XG5cbiAgICByZXR1cm4gbWFrZUNhbmNlbGFibGVQcm9taXNlKG9wdGlvbnMuUHJvbWlzZSwgZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCwgb25DYW5jZWwpIHtcbiAgICAgIGZ1bmN0aW9uIGxpc3RlbmVyKCkge1xuICAgICAgICB2YXIgZmlsdGVyPSBvcHRpb25zLmZpbHRlcjtcbiAgICAgICAgaWYgKGZpbHRlciAmJiAhZmlsdGVyLmFwcGx5KHNlbGYsIGFyZ3VtZW50cykpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5vZmYoZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuaGFuZGxlRXJyb3IpIHtcbiAgICAgICAgICB2YXIgZXJyID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgIGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZSh0b0FycmF5LmFwcGx5KG51bGwsIGFyZ3VtZW50cykuc2xpY2UoMSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUodG9BcnJheS5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBvbkNhbmNlbChmdW5jdGlvbigpe1xuICAgICAgICBzZWxmLm9mZihldmVudCwgbGlzdGVuZXIpO1xuICAgICAgfSk7XG5cbiAgICAgIHNlbGYuX29uKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpO1xuICAgIH0sIHtcbiAgICAgIHRpbWVvdXQ6IG9wdGlvbnMudGltZW91dCxcbiAgICAgIG92ZXJsb2FkOiBvcHRpb25zLm92ZXJsb2FkXG4gICAgfSlcbiAgfTtcblxuICBmdW5jdGlvbiBvbmNlKGVtaXR0ZXIsIG5hbWUsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zPSByZXNvbHZlT3B0aW9ucyhvcHRpb25zLCB7XG4gICAgICBQcm9taXNlOiBQcm9taXNlLFxuICAgICAgdGltZW91dDogMCxcbiAgICAgIG92ZXJsb2FkOiBmYWxzZVxuICAgIH0sIHtcbiAgICAgIFByb21pc2U6IGNvbnN0cnVjdG9yUmVkdWNlclxuICAgIH0pO1xuXG4gICAgdmFyIF9Qcm9taXNlPSBvcHRpb25zLlByb21pc2U7XG5cbiAgICByZXR1cm4gbWFrZUNhbmNlbGFibGVQcm9taXNlKF9Qcm9taXNlLCBmdW5jdGlvbihyZXNvbHZlLCByZWplY3QsIG9uQ2FuY2VsKXtcbiAgICAgIHZhciBoYW5kbGVyO1xuICAgICAgaWYgKHR5cGVvZiBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaGFuZGxlcj0gIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXNvbHZlKHRvQXJyYXkuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgb25DYW5jZWwoZnVuY3Rpb24oKXtcbiAgICAgICAgICBlbWl0dGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlcik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBoYW5kbGVyLFxuICAgICAgICAgICAge29uY2U6IHRydWV9XG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbigpe1xuICAgICAgICBlcnJvckxpc3RlbmVyICYmIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JMaXN0ZW5lcik7XG4gICAgICAgIHJlc29sdmUodG9BcnJheS5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBlcnJvckxpc3RlbmVyO1xuXG4gICAgICBpZiAobmFtZSAhPT0gJ2Vycm9yJykge1xuICAgICAgICBlcnJvckxpc3RlbmVyID0gZnVuY3Rpb24gKGVycil7XG4gICAgICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcihuYW1lLCBldmVudExpc3RlbmVyKTtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfTtcblxuICAgICAgICBlbWl0dGVyLm9uY2UoJ2Vycm9yJywgZXJyb3JMaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIG9uQ2FuY2VsKGZ1bmN0aW9uKCl7XG4gICAgICAgIGVycm9yTGlzdGVuZXIgJiYgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBlcnJvckxpc3RlbmVyKTtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcihuYW1lLCBldmVudExpc3RlbmVyKTtcbiAgICAgIH0pO1xuXG4gICAgICBlbWl0dGVyLm9uY2UobmFtZSwgZXZlbnRMaXN0ZW5lcik7XG4gICAgfSwge1xuICAgICAgdGltZW91dDogb3B0aW9ucy50aW1lb3V0LFxuICAgICAgb3ZlcmxvYWQ6IG9wdGlvbnMub3ZlcmxvYWRcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGU9IEV2ZW50RW1pdHRlci5wcm90b3R5cGU7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRXZlbnRFbWl0dGVyLCB7XG4gICAgZGVmYXVsdE1heExpc3RlbmVyczoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBwcm90b3R5cGUuX21heExpc3RlbmVycztcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgTnVtYmVyLmlzTmFOKG4pKSB7XG4gICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCduIG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyJylcbiAgICAgICAgfVxuICAgICAgICBwcm90b3R5cGUuX21heExpc3RlbmVycyA9IG47XG4gICAgICB9LFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgIH0sXG4gICAgb25jZToge1xuICAgICAgdmFsdWU6IG9uY2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMocHJvdG90eXBlLCB7XG4gICAgICBfbWF4TGlzdGVuZXJzOiB7XG4gICAgICAgICAgdmFsdWU6IGRlZmF1bHRNYXhMaXN0ZW5lcnMsXG4gICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9LFxuICAgICAgX29ic2VydmVyczoge3ZhbHVlOiBudWxsLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfVxuICB9KTtcblxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cbiAgICBkZWZpbmUoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gRXZlbnRFbWl0dGVyO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgIC8vIENvbW1vbkpTXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gZ2xvYmFsIGZvciBhbnkga2luZCBvZiBlbnZpcm9ubWVudC5cbiAgICB2YXIgX2dsb2JhbD0gbmV3IEZ1bmN0aW9uKCcnLCdyZXR1cm4gdGhpcycpKCk7XG4gICAgX2dsb2JhbC5FdmVudEVtaXR0ZXIyID0gRXZlbnRFbWl0dGVyO1xuICB9XG59KCk7XG4iXSwibmFtZXMiOlsidW5kZWZpbmVkIiwiaGFzT3duUHJvcGVydHkiLCJPYmplY3QiLCJpc0FycmF5IiwiQXJyYXkiLCJfaXNBcnJheSIsIm9iaiIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsImRlZmF1bHRNYXhMaXN0ZW5lcnMiLCJuZXh0VGlja1N1cHBvcnRlZCIsInByb2Nlc3MiLCJuZXh0VGljayIsInN5bWJvbHNTdXBwb3J0ZWQiLCJTeW1ib2wiLCJyZWZsZWN0U3VwcG9ydGVkIiwiUmVmbGVjdCIsInNldEltbWVkaWF0ZVN1cHBvcnRlZCIsInNldEltbWVkaWF0ZSIsIl9zZXRJbW1lZGlhdGUiLCJzZXRUaW1lb3V0Iiwib3duS2V5cyIsImFyciIsImdldE93blByb3BlcnR5TmFtZXMiLCJwdXNoIiwiYXBwbHkiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJrZXlzIiwiaW5pdCIsIl9ldmVudHMiLCJfY29uZiIsImNvbmZpZ3VyZSIsImNvbmYiLCJkZWxpbWl0ZXIiLCJtYXhMaXN0ZW5lcnMiLCJfbWF4TGlzdGVuZXJzIiwid2lsZGNhcmQiLCJuZXdMaXN0ZW5lciIsIl9uZXdMaXN0ZW5lciIsInJlbW92ZUxpc3RlbmVyIiwiX3JlbW92ZUxpc3RlbmVyIiwidmVyYm9zZU1lbW9yeUxlYWsiLCJpZ25vcmVFcnJvcnMiLCJsaXN0ZW5lclRyZWUiLCJsb2dQb3NzaWJsZU1lbW9yeUxlYWsiLCJjb3VudCIsImV2ZW50TmFtZSIsImVycm9yTXNnIiwiZW1pdFdhcm5pbmciLCJlIiwiRXJyb3IiLCJuYW1lIiwiZW1pdHRlciIsImNvbnNvbGUiLCJlcnJvciIsInRyYWNlIiwidG9BcnJheSIsImEiLCJiIiwiYyIsIm4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJ0b09iamVjdCIsInZhbHVlcyIsImtleSIsImxlbiIsInZhbHVlc0NvdW50IiwiaSIsIlRhcmdldE9ic2VydmVyIiwidGFyZ2V0Iiwib3B0aW9ucyIsIl9lbWl0dGVyIiwiX3RhcmdldCIsIl9saXN0ZW5lcnMiLCJfbGlzdGVuZXJzQ291bnQiLCJvbiIsIm9mZiIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiYWRkTGlzdGVuZXIiLCJUeXBlRXJyb3IiLCJfb24iLCJfb2ZmIiwiX29ic2VydmVycyIsImFzc2lnbiIsInN1YnNjcmliZSIsImV2ZW50IiwibG9jYWxFdmVudCIsInJlZHVjZXIiLCJvYnNlcnZlciIsImxpc3RlbmVycyIsImhhbmRsZXIiLCJhcmdzIiwiZXZlbnRPYmoiLCJkYXRhIiwib3JpZ2luYWwiLCJyZXN1bHQiLCJlbWl0IiwiY29uY2F0IiwiX29uTmV3TGlzdGVuZXIiLCJfZXZlbnQiLCJfb25SZW1vdmVMaXN0ZW5lciIsImhhc0xpc3RlbmVycyIsInVuc3Vic2NyaWJlIiwiZXZlbnRzIiwiY2xlYXJSZWZzIiwiaW5kZXgiLCJmaW5kVGFyZ2V0SW5kZXgiLCJzcGxpY2UiLCJyZXNvbHZlT3B0aW9ucyIsInNjaGVtYSIsInJlZHVjZXJzIiwiYWxsb3dVbmtub3duIiwiY29tcHV0ZWRPcHRpb25zIiwib3B0aW9uIiwidmFsdWUiLCJyZWplY3QiLCJyZWFzb24iLCJjb25zdHJ1Y3RvclJlZHVjZXIiLCJtYWtlVHlwZVJlZHVjZXIiLCJ0eXBlcyIsIm1lc3NhZ2UiLCJqb2luIiwiZmlyc3RUeXBlIiwic2Vjb25kVHlwZSIsInYiLCJraW5kIiwiZnVuY3Rpb25SZWR1Y2VyIiwib2JqZWN0RnVuY3Rpb25SZWR1Y2VyIiwibWFrZUNhbmNlbGFibGVQcm9taXNlIiwiUHJvbWlzZSIsImV4ZWN1dG9yIiwiaXNDYW5jZWxhYmxlIiwiY2FsbGJhY2tzIiwidGltZXIiLCJzdWJzY3JpcHRpb25DbG9zZWQiLCJwcm9taXNlIiwicmVzb2x2ZSIsIm9uQ2FuY2VsIiwidGltZW91dCIsIm92ZXJsb2FkIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJjYW5jZWwiLCJjbGVhbnVwIiwiY2xlYXJUaW1lb3V0IiwiX3Jlc29sdmUiLCJfcmVqZWN0IiwiZXJyIiwiY2IiLCJjb2RlIiwib2JzZXJ2ZXJzIiwic2VhcmNoTGlzdGVuZXJUcmVlIiwiaGFuZGxlcnMiLCJ0eXBlIiwidHJlZSIsInR5cGVMZW5ndGgiLCJucyIsImwiLCJqIiwiZGwiLCJpbmRleE9mIiwic2xpY2UiLCJicmFuY2giLCJ4VHJlZSIsInh4VHJlZSIsImlzb2xhdGVkQnJhbmNoIiwiZW5kUmVhY2hlZCIsImN1cnJlbnRUeXBlIiwibmV4dFR5cGUiLCJicmFuY2hlcyIsImdyb3dMaXN0ZW5lclRyZWUiLCJsaXN0ZW5lciIsInByZXBlbmQiLCJ1bnNoaWZ0Iiwid2FybmVkIiwiY29sbGVjdFRyZWVFdmVudHMiLCJyb290IiwiYXNBcnJheSIsImJyYW5jaE5hbWUiLCJwYXRoIiwiaXNBcnJheVBhdGgiLCJyZWN1cnNpdmVseUdhcmJhZ2VDb2xsZWN0IiwiZmxhZyIsIkxpc3RlbmVyIiwic2V0dXBMaXN0ZW5lciIsInByb21pc2lmeSIsImFzeW5jIiwib2JqZWN0aWZ5IiwiX2xpc3RlbmVyIiwiX29yaWdpbiIsImNvbnN0cnVjdG9yIiwiY29udGV4dCIsInRoZW4iLCJfYXN5bmMiLCJFdmVudEVtaXR0ZXIiLCJFdmVudEVtaXR0ZXIyIiwibGlzdGVuVG8iLCJsaXN0ZW4iLCJpc1NpbmdsZVJlZHVjZXIiLCJzcGxpdCIsInN0b3BMaXN0ZW5pbmdUbyIsIm1hdGNoZWQiLCJzZXRNYXhMaXN0ZW5lcnMiLCJnZXRNYXhMaXN0ZW5lcnMiLCJvbmNlIiwiZm4iLCJfb25jZSIsInByZXBlbmRPbmNlTGlzdGVuZXIiLCJfbWFueSIsIm1hbnkiLCJ0dGwiLCJwcmVwZW5kTWFueSIsInNlbGYiLCJfYWxsIiwiY29udGFpbnNTeW1ib2wiLCJhbCIsImVtaXRBc3luYyIsInByb21pc2VzIiwiYWxsIiwicHJlcGVuZExpc3RlbmVyIiwib25BbnkiLCJfb25BbnkiLCJwcmVwZW5kQW55IiwicmV0dXJuVmFsdWUiLCJ0ZW1wIiwibGVhZnMiLCJpTGVhZiIsImxlYWYiLCJwb3NpdGlvbiIsIm9mZkFueSIsImZucyIsInJlbW92ZUFsbExpc3RlbmVycyIsImFsbExpc3RlbmVycyIsImV2ZW50TmFtZXMiLCJuc0FzQXJyYXkiLCJsaXN0ZW5lckNvdW50IiwibGlzdGVuZXJzQW55Iiwid2FpdEZvciIsImZpbHRlciIsImhhbmRsZUVycm9yIiwiX1Byb21pc2UiLCJldmVudExpc3RlbmVyIiwiZXJyb3JMaXN0ZW5lciIsImRlZmluZVByb3BlcnRpZXMiLCJnZXQiLCJzZXQiLCJpc05hTiIsImVudW1lcmFibGUiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImRlZmluZSIsImFtZCIsImV4cG9ydHMiLCJtb2R1bGUiLCJfZ2xvYmFsIiwiRnVuY3Rpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eventemitter2/lib/eventemitter2.js\n");

/***/ })

};
;