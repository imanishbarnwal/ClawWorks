"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/rpc-websockets";
exports.ids = ["vendor-chunks/rpc-websockets"];
exports.modules = {

/***/ "(ssr)/./node_modules/rpc-websockets/dist/index.mjs":
/*!****************************************************!*\
  !*** ./node_modules/rpc-websockets/dist/index.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Client: () => (/* binding */ Client),\n/* harmony export */   CommonClient: () => (/* binding */ CommonClient),\n/* harmony export */   DefaultDataPack: () => (/* binding */ DefaultDataPack),\n/* harmony export */   Server: () => (/* binding */ Server),\n/* harmony export */   WebSocket: () => (/* binding */ WebSocket),\n/* harmony export */   createError: () => (/* binding */ createError)\n/* harmony export */ });\n/* harmony import */ var ws__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ws */ \"(ssr)/./node_modules/ws/wrapper.mjs\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! eventemitter3 */ \"(ssr)/./node_modules/eventemitter3/index.mjs\");\n/* harmony import */ var node_url__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node:url */ \"node:url\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! uuid */ \"(ssr)/./node_modules/uuid/dist/esm-node/v1.js\");\n\n\n\n\n// src/lib/client/websocket.ts\nfunction WebSocket(address, options) {\n    return new ws__WEBPACK_IMPORTED_MODULE_0__[\"default\"](address, options);\n}\n// src/lib/utils.ts\nvar DefaultDataPack = class {\n    encode(value) {\n        return JSON.stringify(value);\n    }\n    decode(value) {\n        return JSON.parse(value);\n    }\n};\n// src/lib/client.ts\nvar CommonClient = class extends eventemitter3__WEBPACK_IMPORTED_MODULE_1__.EventEmitter {\n    /**\n  * Instantiate a Client class.\n  * @constructor\n  * @param {webSocketFactory} webSocketFactory - factory method for WebSocket\n  * @param {String} address - url to a websocket server\n  * @param {Object} options - ws options object with reconnect parameters\n  * @param {Function} generate_request_id - custom generation request Id\n  * @param {DataPack} dataPack - data pack contains encoder and decoder\n  * @return {CommonClient}\n  */ constructor(webSocketFactory, address = \"ws://localhost:8080\", { autoconnect = true, reconnect = true, reconnect_interval = 1e3, max_reconnects = 5, ...rest_options } = {}, generate_request_id, dataPack){\n        super();\n        this.webSocketFactory = webSocketFactory;\n        this.queue = {};\n        this.rpc_id = 0;\n        this.address = address;\n        this.autoconnect = autoconnect;\n        this.ready = false;\n        this.reconnect = reconnect;\n        this.reconnect_timer_id = void 0;\n        this.reconnect_interval = reconnect_interval;\n        this.max_reconnects = max_reconnects;\n        this.rest_options = rest_options;\n        this.current_reconnects = 0;\n        this.generate_request_id = generate_request_id || (()=>typeof this.rpc_id === \"number\" ? ++this.rpc_id : Number(this.rpc_id) + 1);\n        if (!dataPack) this.dataPack = new DefaultDataPack();\n        else this.dataPack = dataPack;\n        if (this.autoconnect) this._connect(this.address, {\n            autoconnect: this.autoconnect,\n            reconnect: this.reconnect,\n            reconnect_interval: this.reconnect_interval,\n            max_reconnects: this.max_reconnects,\n            ...this.rest_options\n        });\n    }\n    /**\n  * Connects to a defined server if not connected already.\n  * @method\n  * @return {Undefined}\n  */ connect() {\n        if (this.socket) return;\n        this._connect(this.address, {\n            autoconnect: this.autoconnect,\n            reconnect: this.reconnect,\n            reconnect_interval: this.reconnect_interval,\n            max_reconnects: this.max_reconnects,\n            ...this.rest_options\n        });\n    }\n    /**\n  * Calls a registered RPC method on server.\n  * @method\n  * @param {String} method - RPC method name\n  * @param {Object|Array} params - optional method parameters\n  * @param {Number} timeout - RPC reply timeout value\n  * @param {Object} ws_opts - options passed to ws\n  * @return {Promise}\n  */ call(method, params, timeout, ws_opts) {\n        if (!ws_opts && \"object\" === typeof timeout) {\n            ws_opts = timeout;\n            timeout = null;\n        }\n        return new Promise((resolve, reject)=>{\n            if (!this.ready) return reject(new Error(\"socket not ready\"));\n            const rpc_id = this.generate_request_id(method, params);\n            const message = {\n                jsonrpc: \"2.0\",\n                method,\n                params: params || void 0,\n                id: rpc_id\n            };\n            this.socket.send(this.dataPack.encode(message), ws_opts, (error)=>{\n                if (error) return reject(error);\n                this.queue[rpc_id] = {\n                    promise: [\n                        resolve,\n                        reject\n                    ]\n                };\n                if (timeout) {\n                    this.queue[rpc_id].timeout = setTimeout(()=>{\n                        delete this.queue[rpc_id];\n                        reject(new Error(\"reply timeout\"));\n                    }, timeout);\n                }\n            });\n        });\n    }\n    /**\n  * Logins with the other side of the connection.\n  * @method\n  * @param {Object} params - Login credentials object\n  * @return {Promise}\n  */ async login(params) {\n        const resp = await this.call(\"rpc.login\", params);\n        if (!resp) throw new Error(\"authentication failed\");\n        return resp;\n    }\n    /**\n  * Fetches a list of client's methods registered on server.\n  * @method\n  * @return {Array}\n  */ async listMethods() {\n        return await this.call(\"__listMethods\");\n    }\n    /**\n  * Sends a JSON-RPC 2.0 notification to server.\n  * @method\n  * @param {String} method - RPC method name\n  * @param {Object} params - optional method parameters\n  * @return {Promise}\n  */ notify(method, params) {\n        return new Promise((resolve, reject)=>{\n            if (!this.ready) return reject(new Error(\"socket not ready\"));\n            const message = {\n                jsonrpc: \"2.0\",\n                method,\n                params\n            };\n            this.socket.send(this.dataPack.encode(message), (error)=>{\n                if (error) return reject(error);\n                resolve();\n            });\n        });\n    }\n    /**\n  * Subscribes for a defined event.\n  * @method\n  * @param {String|Array} event - event name\n  * @return {Undefined}\n  * @throws {Error}\n  */ async subscribe(event) {\n        if (typeof event === \"string\") event = [\n            event\n        ];\n        const result = await this.call(\"rpc.on\", event);\n        if (typeof event === \"string\" && result[event] !== \"ok\") throw new Error(\"Failed subscribing to an event '\" + event + \"' with: \" + result[event]);\n        return result;\n    }\n    /**\n  * Unsubscribes from a defined event.\n  * @method\n  * @param {String|Array} event - event name\n  * @return {Undefined}\n  * @throws {Error}\n  */ async unsubscribe(event) {\n        if (typeof event === \"string\") event = [\n            event\n        ];\n        const result = await this.call(\"rpc.off\", event);\n        if (typeof event === \"string\" && result[event] !== \"ok\") throw new Error(\"Failed unsubscribing from an event with: \" + result);\n        return result;\n    }\n    /**\n  * Closes a WebSocket connection gracefully.\n  * @method\n  * @param {Number} code - socket close code\n  * @param {String} data - optional data to be sent before closing\n  * @return {Undefined}\n  */ close(code, data) {\n        if (this.socket) this.socket.close(code || 1e3, data);\n    }\n    /**\n  * Enable / disable automatic reconnection.\n  * @method\n  * @param {Boolean} reconnect - enable / disable reconnection\n  * @return {Undefined}\n  */ setAutoReconnect(reconnect) {\n        this.reconnect = reconnect;\n    }\n    /**\n  * Set the interval between reconnection attempts.\n  * @method\n  * @param {Number} interval - reconnection interval in milliseconds\n  * @return {Undefined}\n  */ setReconnectInterval(interval) {\n        this.reconnect_interval = interval;\n    }\n    /**\n  * Set the maximum number of reconnection attempts.\n  * @method\n  * @param {Number} max_reconnects - maximum reconnection attempts\n  * @return {Undefined}\n  */ setMaxReconnects(max_reconnects) {\n        this.max_reconnects = max_reconnects;\n    }\n    /**\n  * Get the current number of reconnection attempts made.\n  * @method\n  * @return {Number} current reconnection attempts\n  */ getCurrentReconnects() {\n        return this.current_reconnects;\n    }\n    /**\n  * Get the maximum number of reconnection attempts.\n  * @method\n  * @return {Number} maximum reconnection attempts\n  */ getMaxReconnects() {\n        return this.max_reconnects;\n    }\n    /**\n  * Check if the client is currently attempting to reconnect.\n  * @method\n  * @return {Boolean} true if reconnection is in progress\n  */ isReconnecting() {\n        return this.reconnect_timer_id !== void 0;\n    }\n    /**\n  * Check if the client will attempt to reconnect on the next close event.\n  * @method\n  * @return {Boolean} true if reconnection will be attempted\n  */ willReconnect() {\n        return this.reconnect && (this.max_reconnects === 0 || this.current_reconnects < this.max_reconnects);\n    }\n    /**\n  * Connection/Message handler.\n  * @method\n  * @private\n  * @param {String} address - WebSocket API address\n  * @param {Object} options - ws options object\n  * @return {Undefined}\n  */ _connect(address, options) {\n        clearTimeout(this.reconnect_timer_id);\n        this.socket = this.webSocketFactory(address, options);\n        this.socket.addEventListener(\"open\", ()=>{\n            this.ready = true;\n            this.emit(\"open\");\n            this.current_reconnects = 0;\n        });\n        this.socket.addEventListener(\"message\", ({ data: message })=>{\n            if (message instanceof ArrayBuffer) message = Buffer.from(message).toString();\n            try {\n                message = this.dataPack.decode(message);\n            } catch (error) {\n                return;\n            }\n            if (message.notification && this.listeners(message.notification).length) {\n                if (!Object.keys(message.params).length) return this.emit(message.notification);\n                const args = [\n                    message.notification\n                ];\n                if (message.params.constructor === Object) args.push(message.params);\n                else for(let i = 0; i < message.params.length; i++)args.push(message.params[i]);\n                return Promise.resolve().then(()=>{\n                    this.emit.apply(this, args);\n                });\n            }\n            if (!this.queue[message.id]) {\n                if (message.method) {\n                    return Promise.resolve().then(()=>{\n                        this.emit(message.method, message?.params);\n                    });\n                }\n                return;\n            }\n            if (\"error\" in message === \"result\" in message) this.queue[message.id].promise[1](new Error('Server response malformed. Response must include either \"result\" or \"error\", but not both.'));\n            if (this.queue[message.id].timeout) clearTimeout(this.queue[message.id].timeout);\n            if (message.error) this.queue[message.id].promise[1](message.error);\n            else this.queue[message.id].promise[0](message.result);\n            delete this.queue[message.id];\n        });\n        this.socket.addEventListener(\"error\", (error)=>this.emit(\"error\", error));\n        this.socket.addEventListener(\"close\", ({ code, reason })=>{\n            if (this.ready) setTimeout(()=>this.emit(\"close\", code, reason), 0);\n            this.ready = false;\n            this.socket = void 0;\n            if (code === 1e3) return;\n            this.current_reconnects++;\n            if (this.reconnect && (this.max_reconnects > this.current_reconnects || this.max_reconnects === 0)) this.reconnect_timer_id = setTimeout(()=>this._connect(address, options), this.reconnect_interval);\n            else if (this.reconnect && this.max_reconnects > 0 && this.current_reconnects >= this.max_reconnects) {\n                setTimeout(()=>this.emit(\"max_reconnects_reached\", code, reason), 1);\n            }\n        });\n    }\n};\nvar Server = class extends eventemitter3__WEBPACK_IMPORTED_MODULE_1__.EventEmitter {\n    /**\n  * Instantiate a Server class.\n  * @constructor\n  * @param {Object} options - ws constructor's parameters with rpc\n  * @param {DataPack} dataPack - data pack contains encoder and decoder\n  * @return {Server} - returns a new Server instance\n  */ constructor(options, dataPack){\n        super();\n        this.namespaces = {};\n        if (!dataPack) this.dataPack = new DefaultDataPack();\n        else this.dataPack = dataPack;\n        this.wss = new ws__WEBPACK_IMPORTED_MODULE_0__.WebSocketServer(options);\n        this.wss.on(\"listening\", ()=>this.emit(\"listening\"));\n        this.wss.on(\"connection\", (socket, request)=>{\n            const u = node_url__WEBPACK_IMPORTED_MODULE_2__.parse(request.url, true);\n            const ns = u.pathname;\n            if (u.query.socket_id) socket._id = u.query.socket_id;\n            else socket._id = (0,uuid__WEBPACK_IMPORTED_MODULE_3__[\"default\"])();\n            socket[\"_authenticated\"] = false;\n            socket.on(\"error\", (error)=>this.emit(\"socket-error\", socket, error));\n            socket.on(\"close\", ()=>{\n                this.namespaces[ns].clients.delete(socket._id);\n                for (const event of Object.keys(this.namespaces[ns].events)){\n                    const index = this.namespaces[ns].events[event].sockets.indexOf(socket._id);\n                    if (index >= 0) this.namespaces[ns].events[event].sockets.splice(index, 1);\n                }\n                this.emit(\"disconnection\", socket);\n            });\n            if (!this.namespaces[ns]) this._generateNamespace(ns);\n            this.namespaces[ns].clients.set(socket._id, socket);\n            this.emit(\"connection\", socket, request);\n            return this._handleRPC(socket, ns);\n        });\n        this.wss.on(\"error\", (error)=>this.emit(\"error\", error));\n    }\n    /**\n  * Registers an RPC method.\n  * @method\n  * @param {String} name - method name\n  * @param {Function} fn - a callee function\n  * @param {String} ns - namespace identifier\n  * @throws {TypeError}\n  * @return {Object} - returns an IMethod object\n  */ register(name, fn, ns = \"/\") {\n        if (!this.namespaces[ns]) this._generateNamespace(ns);\n        this.namespaces[ns].rpc_methods[name] = {\n            fn,\n            protected: false\n        };\n        return {\n            protected: ()=>this._makeProtectedMethod(name, ns),\n            public: ()=>this._makePublicMethod(name, ns)\n        };\n    }\n    /**\n  * Sets an auth method.\n  * @method\n  * @param {Function} fn - an arbitrary auth method\n  * @param {String} ns - namespace identifier\n  * @throws {TypeError}\n  * @return {Undefined}\n  */ setAuth(fn, ns = \"/\") {\n        this.register(\"rpc.login\", fn, ns);\n    }\n    /**\n  * Marks an RPC method as protected.\n  * @method\n  * @param {String} name - method name\n  * @param {String} ns - namespace identifier\n  * @return {Undefined}\n  */ _makeProtectedMethod(name, ns = \"/\") {\n        this.namespaces[ns].rpc_methods[name].protected = true;\n    }\n    /**\n  * Marks an RPC method as public.\n  * @method\n  * @param {String} name - method name\n  * @param {String} ns - namespace identifier\n  * @return {Undefined}\n  */ _makePublicMethod(name, ns = \"/\") {\n        this.namespaces[ns].rpc_methods[name].protected = false;\n    }\n    /**\n  * Marks an event as protected.\n  * @method\n  * @param {String} name - event name\n  * @param {String} ns - namespace identifier\n  * @return {Undefined}\n  */ _makeProtectedEvent(name, ns = \"/\") {\n        this.namespaces[ns].events[name].protected = true;\n    }\n    /**\n  * Marks an event as public.\n  * @method\n  * @param {String} name - event name\n  * @param {String} ns - namespace identifier\n  * @return {Undefined}\n  */ _makePublicEvent(name, ns = \"/\") {\n        this.namespaces[ns].events[name].protected = false;\n    }\n    /**\n  * Removes a namespace and closes all connections\n  * @method\n  * @param {String} ns - namespace identifier\n  * @throws {TypeError}\n  * @return {Undefined}\n  */ closeNamespace(ns) {\n        const namespace = this.namespaces[ns];\n        if (namespace) {\n            delete namespace.rpc_methods;\n            delete namespace.events;\n            for (const socket of namespace.clients.values())socket.close();\n            delete this.namespaces[ns];\n        }\n    }\n    /**\n  * Creates a new event that can be emitted to clients.\n  * @method\n  * @param {String} name - event name\n  * @param {String} ns - namespace identifier\n  * @throws {TypeError}\n  * @return {Object} - returns an IEvent object\n  */ event(name, ns = \"/\") {\n        if (!this.namespaces[ns]) this._generateNamespace(ns);\n        else {\n            const index = this.namespaces[ns].events[name];\n            if (index !== void 0) throw new Error(`Already registered event ${ns}${name}`);\n        }\n        this.namespaces[ns].events[name] = {\n            sockets: [],\n            protected: false\n        };\n        this.on(name, (...params)=>{\n            if (params.length === 1 && params[0] instanceof Object) params = params[0];\n            for (const socket_id of this.namespaces[ns].events[name].sockets){\n                const socket = this.namespaces[ns].clients.get(socket_id);\n                if (!socket) continue;\n                socket.send(this.dataPack.encode({\n                    notification: name,\n                    params\n                }));\n            }\n        });\n        return {\n            protected: ()=>this._makeProtectedEvent(name, ns),\n            public: ()=>this._makePublicEvent(name, ns)\n        };\n    }\n    /**\n  * Returns a requested namespace object\n  * @method\n  * @param {String} name - namespace identifier\n  * @throws {TypeError}\n  * @return {Object} - namespace object\n  */ of(name) {\n        if (!this.namespaces[name]) this._generateNamespace(name);\n        const self = this;\n        return {\n            // self.register convenience method\n            register (fn_name, fn) {\n                if (arguments.length !== 2) throw new Error(\"must provide exactly two arguments\");\n                if (typeof fn_name !== \"string\") throw new Error(\"name must be a string\");\n                if (typeof fn !== \"function\") throw new Error(\"handler must be a function\");\n                return self.register(fn_name, fn, name);\n            },\n            // self.event convenience method\n            event (ev_name) {\n                if (arguments.length !== 1) throw new Error(\"must provide exactly one argument\");\n                if (typeof ev_name !== \"string\") throw new Error(\"name must be a string\");\n                return self.event(ev_name, name);\n            },\n            // self.eventList convenience method\n            get eventList () {\n                return Object.keys(self.namespaces[name].events);\n            },\n            /**\n      * Emits a specified event to this namespace.\n      * @inner\n      * @method\n      * @param {String} event - event name\n      * @param {Array} params - event parameters\n      * @return {Undefined}\n      */ emit (event, ...params) {\n                const nsEvent = self.namespaces[name].events[event];\n                if (nsEvent) for (const socket_id of nsEvent.sockets){\n                    const socket = self.namespaces[name].clients.get(socket_id);\n                    if (!socket) continue;\n                    socket.send(self.dataPack.encode({\n                        notification: event,\n                        params\n                    }));\n                }\n            },\n            /**\n      * Returns a name of this namespace.\n      * @inner\n      * @method\n      * @kind constant\n      * @return {String}\n      */ get name () {\n                return name;\n            },\n            /**\n      * Returns a hash of websocket objects connected to this namespace.\n      * @inner\n      * @method\n      * @return {Object}\n      */ connected () {\n                const socket_ids = [\n                    ...self.namespaces[name].clients.keys()\n                ];\n                return socket_ids.reduce((acc, curr)=>({\n                        ...acc,\n                        [curr]: self.namespaces[name].clients.get(curr)\n                    }), {});\n            },\n            /**\n      * Returns a list of client unique identifiers connected to this namespace.\n      * @inner\n      * @method\n      * @return {Array}\n      */ clients () {\n                return self.namespaces[name];\n            }\n        };\n    }\n    /**\n  * Lists all created events in a given namespace. Defaults to \"/\".\n  * @method\n  * @param {String} ns - namespaces identifier\n  * @readonly\n  * @return {Array} - returns a list of created events\n  */ eventList(ns = \"/\") {\n        if (!this.namespaces[ns]) return [];\n        return Object.keys(this.namespaces[ns].events);\n    }\n    /**\n  * Creates a JSON-RPC 2.0 compliant error\n  * @method\n  * @param {Number} code - indicates the error type that occurred\n  * @param {String} message - provides a short description of the error\n  * @param {String|Object} data - details containing additional information about the error\n  * @return {Object}\n  */ createError(code, message, data) {\n        return {\n            code,\n            message,\n            data: data || null\n        };\n    }\n    /**\n  * Closes the server and terminates all clients.\n  * @method\n  * @return {Promise}\n  */ close() {\n        return new Promise((resolve, reject)=>{\n            try {\n                this.wss.close();\n                this.emit(\"close\");\n                resolve();\n            } catch (error) {\n                reject(error);\n            }\n        });\n    }\n    /**\n  * Handles all WebSocket JSON RPC 2.0 requests.\n  * @private\n  * @param {Object} socket - ws socket instance\n  * @param {String} ns - namespaces identifier\n  * @return {Undefined}\n  */ _handleRPC(socket, ns = \"/\") {\n        socket.on(\"message\", async (data)=>{\n            const msg_options = {};\n            if (data instanceof ArrayBuffer) {\n                msg_options.binary = true;\n                data = Buffer.from(data).toString();\n            }\n            if (socket.readyState !== 1) return;\n            let parsedData;\n            try {\n                parsedData = this.dataPack.decode(data);\n            } catch (error) {\n                return socket.send(this.dataPack.encode({\n                    jsonrpc: \"2.0\",\n                    error: createError(-32700, error.toString()),\n                    id: null\n                }), msg_options);\n            }\n            if (Array.isArray(parsedData)) {\n                if (!parsedData.length) return socket.send(this.dataPack.encode({\n                    jsonrpc: \"2.0\",\n                    error: createError(-32600, \"Invalid array\"),\n                    id: null\n                }), msg_options);\n                const responses = [];\n                for (const message of parsedData){\n                    const response2 = await this._runMethod(message, socket._id, ns);\n                    if (!response2) continue;\n                    responses.push(response2);\n                }\n                if (!responses.length) return;\n                return socket.send(this.dataPack.encode(responses), msg_options);\n            }\n            const response = await this._runMethod(parsedData, socket._id, ns);\n            if (!response) return;\n            return socket.send(this.dataPack.encode(response), msg_options);\n        });\n    }\n    /**\n  * Runs a defined RPC method.\n  * @private\n  * @param {Object} message - a message received\n  * @param {Object} socket_id - user's socket id\n  * @param {String} ns - namespaces identifier\n  * @return {Object|undefined}\n  */ async _runMethod(message, socket_id, ns = \"/\") {\n        if (typeof message !== \"object\" || message === null) return {\n            jsonrpc: \"2.0\",\n            error: createError(-32600),\n            id: null\n        };\n        if (message.jsonrpc !== \"2.0\") return {\n            jsonrpc: \"2.0\",\n            error: createError(-32600, \"Invalid JSON RPC version\"),\n            id: message.id || null\n        };\n        if (!message.method) return {\n            jsonrpc: \"2.0\",\n            error: createError(-32602, \"Method not specified\"),\n            id: message.id || null\n        };\n        if (typeof message.method !== \"string\") return {\n            jsonrpc: \"2.0\",\n            error: createError(-32600, \"Invalid method name\"),\n            id: message.id || null\n        };\n        if (message.params && typeof message.params === \"string\") return {\n            jsonrpc: \"2.0\",\n            error: createError(-32600),\n            id: message.id || null\n        };\n        if (message.method === \"rpc.on\") {\n            if (!message.params) return {\n                jsonrpc: \"2.0\",\n                error: createError(-32e3),\n                id: message.id || null\n            };\n            const results = {};\n            const event_names = Object.keys(this.namespaces[ns].events);\n            for (const name of message.params){\n                const index = event_names.indexOf(name);\n                const namespace = this.namespaces[ns];\n                if (index === -1) {\n                    results[name] = \"provided event invalid\";\n                    continue;\n                }\n                if (namespace.events[event_names[index]].protected === true && namespace.clients.get(socket_id)[\"_authenticated\"] === false) {\n                    return {\n                        jsonrpc: \"2.0\",\n                        error: createError(-32606),\n                        id: message.id || null\n                    };\n                }\n                const socket_index = namespace.events[event_names[index]].sockets.indexOf(socket_id);\n                if (socket_index >= 0) {\n                    results[name] = \"socket has already been subscribed to event\";\n                    continue;\n                }\n                namespace.events[event_names[index]].sockets.push(socket_id);\n                results[name] = \"ok\";\n            }\n            return {\n                jsonrpc: \"2.0\",\n                result: results,\n                id: message.id || null\n            };\n        } else if (message.method === \"rpc.off\") {\n            if (!message.params) return {\n                jsonrpc: \"2.0\",\n                error: createError(-32e3),\n                id: message.id || null\n            };\n            const results = {};\n            for (const name of message.params){\n                if (!this.namespaces[ns].events[name]) {\n                    results[name] = \"provided event invalid\";\n                    continue;\n                }\n                const index = this.namespaces[ns].events[name].sockets.indexOf(socket_id);\n                if (index === -1) {\n                    results[name] = \"not subscribed\";\n                    continue;\n                }\n                this.namespaces[ns].events[name].sockets.splice(index, 1);\n                results[name] = \"ok\";\n            }\n            return {\n                jsonrpc: \"2.0\",\n                result: results,\n                id: message.id || null\n            };\n        } else if (message.method === \"rpc.login\") {\n            if (!message.params) return {\n                jsonrpc: \"2.0\",\n                error: createError(-32604),\n                id: message.id || null\n            };\n        }\n        if (!this.namespaces[ns].rpc_methods[message.method]) {\n            return {\n                jsonrpc: \"2.0\",\n                error: createError(-32601),\n                id: message.id || null\n            };\n        }\n        let response = null;\n        if (this.namespaces[ns].rpc_methods[message.method].protected === true && this.namespaces[ns].clients.get(socket_id)[\"_authenticated\"] === false) {\n            return {\n                jsonrpc: \"2.0\",\n                error: createError(-32605),\n                id: message.id || null\n            };\n        }\n        try {\n            response = await this.namespaces[ns].rpc_methods[message.method].fn(message.params, socket_id);\n        } catch (error) {\n            if (!message.id) return;\n            if (error instanceof Error) return {\n                jsonrpc: \"2.0\",\n                error: {\n                    code: -32e3,\n                    message: error.name,\n                    data: error.message\n                },\n                id: message.id\n            };\n            return {\n                jsonrpc: \"2.0\",\n                error,\n                id: message.id\n            };\n        }\n        if (!message.id) return;\n        if (message.method === \"rpc.login\" && response === true) {\n            const s = this.namespaces[ns].clients.get(socket_id);\n            s[\"_authenticated\"] = true;\n            this.namespaces[ns].clients.set(socket_id, s);\n        }\n        return {\n            jsonrpc: \"2.0\",\n            result: response,\n            id: message.id\n        };\n    }\n    /**\n  * Generate a new namespace store.\n  * Also preregister some special namespace methods.\n  * @private\n  * @param {String} name - namespaces identifier\n  * @return {undefined}\n  */ _generateNamespace(name) {\n        this.namespaces[name] = {\n            rpc_methods: {\n                __listMethods: {\n                    fn: ()=>Object.keys(this.namespaces[name].rpc_methods),\n                    protected: false\n                }\n            },\n            clients: /* @__PURE__ */ new Map(),\n            events: {}\n        };\n    }\n};\nvar RPC_ERRORS = /* @__PURE__ */ new Map([\n    [\n        -32e3,\n        \"Event not provided\"\n    ],\n    [\n        -32600,\n        \"Invalid Request\"\n    ],\n    [\n        -32601,\n        \"Method not found\"\n    ],\n    [\n        -32602,\n        \"Invalid params\"\n    ],\n    [\n        -32603,\n        \"Internal error\"\n    ],\n    [\n        -32604,\n        \"Params not found\"\n    ],\n    [\n        -32605,\n        \"Method forbidden\"\n    ],\n    [\n        -32606,\n        \"Event forbidden\"\n    ],\n    [\n        -32700,\n        \"Parse error\"\n    ]\n]);\nfunction createError(code, details) {\n    const error = {\n        code,\n        message: RPC_ERRORS.get(code) || \"Internal Server Error\"\n    };\n    if (details) error[\"data\"] = details;\n    return error;\n}\n// src/index.ts\nvar Client = class extends CommonClient {\n    constructor(address = \"ws://localhost:8080\", { autoconnect = true, reconnect = true, reconnect_interval = 1e3, max_reconnects = 5, ...rest_options } = {}, generate_request_id){\n        super(WebSocket, address, {\n            autoconnect,\n            reconnect,\n            reconnect_interval,\n            max_reconnects,\n            ...rest_options\n        }, generate_request_id);\n    }\n};\n //# sourceMappingURL=index.mjs.map\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcnBjLXdlYnNvY2tldHMvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFvRDtBQUNQO0FBQ2xCO0FBQ0Q7QUFFMUIsOEJBQThCO0FBQzlCLFNBQVNLLFVBQVVDLE9BQU8sRUFBRUMsT0FBTztJQUNqQyxPQUFPLElBQUlQLDBDQUFhQSxDQUFDTSxTQUFTQztBQUNwQztBQUVBLG1CQUFtQjtBQUNuQixJQUFJQyxrQkFBa0I7SUFDcEJDLE9BQU9DLEtBQUssRUFBRTtRQUNaLE9BQU9DLEtBQUtDLFNBQVMsQ0FBQ0Y7SUFDeEI7SUFDQUcsT0FBT0gsS0FBSyxFQUFFO1FBQ1osT0FBT0MsS0FBS0csS0FBSyxDQUFDSjtJQUNwQjtBQUNGO0FBRUEsb0JBQW9CO0FBQ3BCLElBQUlLLGVBQWUsY0FBY2IsdURBQVlBO0lBaUIzQzs7Ozs7Ozs7O0VBU0EsR0FDQWMsWUFBWUMsZ0JBQWdCLEVBQUVYLFVBQVUscUJBQXFCLEVBQUUsRUFDN0RZLGNBQWMsSUFBSSxFQUNsQkMsWUFBWSxJQUFJLEVBQ2hCQyxxQkFBcUIsR0FBRyxFQUN4QkMsaUJBQWlCLENBQUMsRUFDbEIsR0FBR0MsY0FDSixHQUFHLENBQUMsQ0FBQyxFQUFFQyxtQkFBbUIsRUFBRUMsUUFBUSxDQUFFO1FBQ3JDLEtBQUs7UUFDTCxJQUFJLENBQUNQLGdCQUFnQixHQUFHQTtRQUN4QixJQUFJLENBQUNRLEtBQUssR0FBRyxDQUFDO1FBQ2QsSUFBSSxDQUFDQyxNQUFNLEdBQUc7UUFDZCxJQUFJLENBQUNwQixPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDWSxXQUFXLEdBQUdBO1FBQ25CLElBQUksQ0FBQ1MsS0FBSyxHQUFHO1FBQ2IsSUFBSSxDQUFDUixTQUFTLEdBQUdBO1FBQ2pCLElBQUksQ0FBQ1Msa0JBQWtCLEdBQUcsS0FBSztRQUMvQixJQUFJLENBQUNSLGtCQUFrQixHQUFHQTtRQUMxQixJQUFJLENBQUNDLGNBQWMsR0FBR0E7UUFDdEIs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b2R1bGVzL3JwYy13ZWJzb2NrZXRzL2Rpc3QvaW5kZXgubWpzP2FkMTQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFdlYlNvY2tldEltcGwsIHsgV2ViU29ja2V0U2VydmVyIH0gZnJvbSAnd3MnO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRlbWl0dGVyMyc7XG5pbXBvcnQgdXJsIGZyb20gJ25vZGU6dXJsJztcbmltcG9ydCB7IHYxIH0gZnJvbSAndXVpZCc7XG5cbi8vIHNyYy9saWIvY2xpZW50L3dlYnNvY2tldC50c1xuZnVuY3Rpb24gV2ViU29ja2V0KGFkZHJlc3MsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBXZWJTb2NrZXRJbXBsKGFkZHJlc3MsIG9wdGlvbnMpO1xufVxuXG4vLyBzcmMvbGliL3V0aWxzLnRzXG52YXIgRGVmYXVsdERhdGFQYWNrID0gY2xhc3Mge1xuICBlbmNvZGUodmFsdWUpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICB9XG4gIGRlY29kZSh2YWx1ZSkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKHZhbHVlKTtcbiAgfVxufTtcblxuLy8gc3JjL2xpYi9jbGllbnQudHNcbnZhciBDb21tb25DbGllbnQgPSBjbGFzcyBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGFkZHJlc3M7XG4gIHJwY19pZDtcbiAgcXVldWU7XG4gIG9wdGlvbnM7XG4gIGF1dG9jb25uZWN0O1xuICByZWFkeTtcbiAgcmVjb25uZWN0O1xuICByZWNvbm5lY3RfdGltZXJfaWQ7XG4gIHJlY29ubmVjdF9pbnRlcnZhbDtcbiAgbWF4X3JlY29ubmVjdHM7XG4gIHJlc3Rfb3B0aW9ucztcbiAgY3VycmVudF9yZWNvbm5lY3RzO1xuICBnZW5lcmF0ZV9yZXF1ZXN0X2lkO1xuICBzb2NrZXQ7XG4gIHdlYlNvY2tldEZhY3Rvcnk7XG4gIGRhdGFQYWNrO1xuICAvKipcbiAgKiBJbnN0YW50aWF0ZSBhIENsaWVudCBjbGFzcy5cbiAgKiBAY29uc3RydWN0b3JcbiAgKiBAcGFyYW0ge3dlYlNvY2tldEZhY3Rvcnl9IHdlYlNvY2tldEZhY3RvcnkgLSBmYWN0b3J5IG1ldGhvZCBmb3IgV2ViU29ja2V0XG4gICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgLSB1cmwgdG8gYSB3ZWJzb2NrZXQgc2VydmVyXG4gICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSB3cyBvcHRpb25zIG9iamVjdCB3aXRoIHJlY29ubmVjdCBwYXJhbWV0ZXJzXG4gICogQHBhcmFtIHtGdW5jdGlvbn0gZ2VuZXJhdGVfcmVxdWVzdF9pZCAtIGN1c3RvbSBnZW5lcmF0aW9uIHJlcXVlc3QgSWRcbiAgKiBAcGFyYW0ge0RhdGFQYWNrfSBkYXRhUGFjayAtIGRhdGEgcGFjayBjb250YWlucyBlbmNvZGVyIGFuZCBkZWNvZGVyXG4gICogQHJldHVybiB7Q29tbW9uQ2xpZW50fVxuICAqL1xuICBjb25zdHJ1Y3Rvcih3ZWJTb2NrZXRGYWN0b3J5LCBhZGRyZXNzID0gXCJ3czovL2xvY2FsaG9zdDo4MDgwXCIsIHtcbiAgICBhdXRvY29ubmVjdCA9IHRydWUsXG4gICAgcmVjb25uZWN0ID0gdHJ1ZSxcbiAgICByZWNvbm5lY3RfaW50ZXJ2YWwgPSAxZTMsXG4gICAgbWF4X3JlY29ubmVjdHMgPSA1LFxuICAgIC4uLnJlc3Rfb3B0aW9uc1xuICB9ID0ge30sIGdlbmVyYXRlX3JlcXVlc3RfaWQsIGRhdGFQYWNrKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLndlYlNvY2tldEZhY3RvcnkgPSB3ZWJTb2NrZXRGYWN0b3J5O1xuICAgIHRoaXMucXVldWUgPSB7fTtcbiAgICB0aGlzLnJwY19pZCA9IDA7XG4gICAgdGhpcy5hZGRyZXNzID0gYWRkcmVzcztcbiAgICB0aGlzLmF1dG9jb25uZWN0ID0gYXV0b2Nvbm5lY3Q7XG4gICAgdGhpcy5yZWFkeSA9IGZhbHNlO1xuICAgIHRoaXMucmVjb25uZWN0ID0gcmVjb25uZWN0O1xuICAgIHRoaXMucmVjb25uZWN0X3RpbWVyX2lkID0gdm9pZCAwO1xuICAgIHRoaXMucmVjb25uZWN0X2ludGVydmFsID0gcmVjb25uZWN0X2ludGVydmFsO1xuICAgIHRoaXMubWF4X3JlY29ubmVjdHMgPSBtYXhfcmVjb25uZWN0cztcbiAgICB0aGlzLnJlc3Rfb3B0aW9ucyA9IHJlc3Rfb3B0aW9ucztcbiAgICB0aGlzLmN1cnJlbnRfcmVjb25uZWN0cyA9IDA7XG4gICAgdGhpcy5nZW5lcmF0ZV9yZXF1ZXN0X2lkID0gZ2VuZXJhdGVfcmVxdWVzdF9pZCB8fCAoKCkgPT4gdHlwZW9mIHRoaXMucnBjX2lkID09PSBcIm51bWJlclwiID8gKyt0aGlzLnJwY19pZCA6IE51bWJlcih0aGlzLnJwY19pZCkgKyAxKTtcbiAgICBpZiAoIWRhdGFQYWNrKSB0aGlzLmRhdGFQYWNrID0gbmV3IERlZmF1bHREYXRhUGFjaygpO1xuICAgIGVsc2UgdGhpcy5kYXRhUGFjayA9IGRhdGFQYWNrO1xuICAgIGlmICh0aGlzLmF1dG9jb25uZWN0KVxuICAgICAgdGhpcy5fY29ubmVjdCh0aGlzLmFkZHJlc3MsIHtcbiAgICAgICAgYXV0b2Nvbm5lY3Q6IHRoaXMuYXV0b2Nvbm5lY3QsXG4gICAgICAgIHJlY29ubmVjdDogdGhpcy5yZWNvbm5lY3QsXG4gICAgICAgIHJlY29ubmVjdF9pbnRlcnZhbDogdGhpcy5yZWNvbm5lY3RfaW50ZXJ2YWwsXG4gICAgICAgIG1heF9yZWNvbm5lY3RzOiB0aGlzLm1heF9yZWNvbm5lY3RzLFxuICAgICAgICAuLi50aGlzLnJlc3Rfb3B0aW9uc1xuICAgICAgfSk7XG4gIH1cbiAgLyoqXG4gICogQ29ubmVjdHMgdG8gYSBkZWZpbmVkIHNlcnZlciBpZiBub3QgY29ubmVjdGVkIGFscmVhZHkuXG4gICogQG1ldGhvZFxuICAqIEByZXR1cm4ge1VuZGVmaW5lZH1cbiAgKi9cbiAgY29ubmVjdCgpIHtcbiAgICBpZiAodGhpcy5zb2NrZXQpIHJldHVybjtcbiAgICB0aGlzLl9jb25uZWN0KHRoaXMuYWRkcmVzcywge1xuICAgICAgYXV0b2Nvbm5lY3Q6IHRoaXMuYXV0b2Nvbm5lY3QsXG4gICAgICByZWNvbm5lY3Q6IHRoaXMucmVjb25uZWN0LFxuICAgICAgcmVjb25uZWN0X2ludGVydmFsOiB0aGlzLnJlY29ubmVjdF9pbnRlcnZhbCxcbiAgICAgIG1heF9yZWNvbm5lY3RzOiB0aGlzLm1heF9yZWNvbm5lY3RzLFxuICAgICAgLi4udGhpcy5yZXN0X29wdGlvbnNcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgKiBDYWxscyBhIHJlZ2lzdGVyZWQgUlBDIG1ldGhvZCBvbiBzZXJ2ZXIuXG4gICogQG1ldGhvZFxuICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2QgLSBSUEMgbWV0aG9kIG5hbWVcbiAgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gcGFyYW1zIC0gb3B0aW9uYWwgbWV0aG9kIHBhcmFtZXRlcnNcbiAgKiBAcGFyYW0ge051bWJlcn0gdGltZW91dCAtIFJQQyByZXBseSB0aW1lb3V0IHZhbHVlXG4gICogQHBhcmFtIHtPYmplY3R9IHdzX29wdHMgLSBvcHRpb25zIHBhc3NlZCB0byB3c1xuICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICovXG4gIGNhbGwobWV0aG9kLCBwYXJhbXMsIHRpbWVvdXQsIHdzX29wdHMpIHtcbiAgICBpZiAoIXdzX29wdHMgJiYgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHRpbWVvdXQpIHtcbiAgICAgIHdzX29wdHMgPSB0aW1lb3V0O1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAoIXRoaXMucmVhZHkpIHJldHVybiByZWplY3QobmV3IEVycm9yKFwic29ja2V0IG5vdCByZWFkeVwiKSk7XG4gICAgICBjb25zdCBycGNfaWQgPSB0aGlzLmdlbmVyYXRlX3JlcXVlc3RfaWQobWV0aG9kLCBwYXJhbXMpO1xuICAgICAgY29uc3QgbWVzc2FnZSA9IHtcbiAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICBwYXJhbXM6IHBhcmFtcyB8fCB2b2lkIDAsXG4gICAgICAgIGlkOiBycGNfaWRcbiAgICAgIH07XG4gICAgICB0aGlzLnNvY2tldC5zZW5kKHRoaXMuZGF0YVBhY2suZW5jb2RlKG1lc3NhZ2UpLCB3c19vcHRzLCAoZXJyb3IpID0+IHtcbiAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgICAgdGhpcy5xdWV1ZVtycGNfaWRdID0geyBwcm9taXNlOiBbcmVzb2x2ZSwgcmVqZWN0XSB9O1xuICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgIHRoaXMucXVldWVbcnBjX2lkXS50aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5xdWV1ZVtycGNfaWRdO1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcInJlcGx5IHRpbWVvdXRcIikpO1xuICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgKiBMb2dpbnMgd2l0aCB0aGUgb3RoZXIgc2lkZSBvZiB0aGUgY29ubmVjdGlvbi5cbiAgKiBAbWV0aG9kXG4gICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIExvZ2luIGNyZWRlbnRpYWxzIG9iamVjdFxuICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICovXG4gIGFzeW5jIGxvZ2luKHBhcmFtcykge1xuICAgIGNvbnN0IHJlc3AgPSBhd2FpdCB0aGlzLmNhbGwoXCJycGMubG9naW5cIiwgcGFyYW1zKTtcbiAgICBpZiAoIXJlc3ApIHRocm93IG5ldyBFcnJvcihcImF1dGhlbnRpY2F0aW9uIGZhaWxlZFwiKTtcbiAgICByZXR1cm4gcmVzcDtcbiAgfVxuICAvKipcbiAgKiBGZXRjaGVzIGEgbGlzdCBvZiBjbGllbnQncyBtZXRob2RzIHJlZ2lzdGVyZWQgb24gc2VydmVyLlxuICAqIEBtZXRob2RcbiAgKiBAcmV0dXJuIHtBcnJheX1cbiAgKi9cbiAgYXN5bmMgbGlzdE1ldGhvZHMoKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuY2FsbChcIl9fbGlzdE1ldGhvZHNcIik7XG4gIH1cbiAgLyoqXG4gICogU2VuZHMgYSBKU09OLVJQQyAyLjAgbm90aWZpY2F0aW9uIHRvIHNlcnZlci5cbiAgKiBAbWV0aG9kXG4gICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZCAtIFJQQyBtZXRob2QgbmFtZVxuICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBvcHRpb25hbCBtZXRob2QgcGFyYW1ldGVyc1xuICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICovXG4gIG5vdGlmeShtZXRob2QsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAoIXRoaXMucmVhZHkpIHJldHVybiByZWplY3QobmV3IEVycm9yKFwic29ja2V0IG5vdCByZWFkeVwiKSk7XG4gICAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICBtZXRob2QsXG4gICAgICAgIHBhcmFtc1xuICAgICAgfTtcbiAgICAgIHRoaXMuc29ja2V0LnNlbmQodGhpcy5kYXRhUGFjay5lbmNvZGUobWVzc2FnZSksIChlcnJvcikgPT4ge1xuICAgICAgICBpZiAoZXJyb3IpIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgKiBTdWJzY3JpYmVzIGZvciBhIGRlZmluZWQgZXZlbnQuXG4gICogQG1ldGhvZFxuICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBldmVudCAtIGV2ZW50IG5hbWVcbiAgKiBAcmV0dXJuIHtVbmRlZmluZWR9XG4gICogQHRocm93cyB7RXJyb3J9XG4gICovXG4gIGFzeW5jIHN1YnNjcmliZShldmVudCkge1xuICAgIGlmICh0eXBlb2YgZXZlbnQgPT09IFwic3RyaW5nXCIpIGV2ZW50ID0gW2V2ZW50XTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmNhbGwoXCJycGMub25cIiwgZXZlbnQpO1xuICAgIGlmICh0eXBlb2YgZXZlbnQgPT09IFwic3RyaW5nXCIgJiYgcmVzdWx0W2V2ZW50XSAhPT0gXCJva1wiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkZhaWxlZCBzdWJzY3JpYmluZyB0byBhbiBldmVudCAnXCIgKyBldmVudCArIFwiJyB3aXRoOiBcIiArIHJlc3VsdFtldmVudF1cbiAgICAgICk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKipcbiAgKiBVbnN1YnNjcmliZXMgZnJvbSBhIGRlZmluZWQgZXZlbnQuXG4gICogQG1ldGhvZFxuICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBldmVudCAtIGV2ZW50IG5hbWVcbiAgKiBAcmV0dXJuIHtVbmRlZmluZWR9XG4gICogQHRocm93cyB7RXJyb3J9XG4gICovXG4gIGFzeW5jIHVuc3Vic2NyaWJlKGV2ZW50KSB7XG4gICAgaWYgKHR5cGVvZiBldmVudCA9PT0gXCJzdHJpbmdcIikgZXZlbnQgPSBbZXZlbnRdO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuY2FsbChcInJwYy5vZmZcIiwgZXZlbnQpO1xuICAgIGlmICh0eXBlb2YgZXZlbnQgPT09IFwic3RyaW5nXCIgJiYgcmVzdWx0W2V2ZW50XSAhPT0gXCJva1wiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHVuc3Vic2NyaWJpbmcgZnJvbSBhbiBldmVudCB3aXRoOiBcIiArIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKipcbiAgKiBDbG9zZXMgYSBXZWJTb2NrZXQgY29ubmVjdGlvbiBncmFjZWZ1bGx5LlxuICAqIEBtZXRob2RcbiAgKiBAcGFyYW0ge051bWJlcn0gY29kZSAtIHNvY2tldCBjbG9zZSBjb2RlXG4gICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgLSBvcHRpb25hbCBkYXRhIHRvIGJlIHNlbnQgYmVmb3JlIGNsb3NpbmdcbiAgKiBAcmV0dXJuIHtVbmRlZmluZWR9XG4gICovXG4gIGNsb3NlKGNvZGUsIGRhdGEpIHtcbiAgICBpZiAodGhpcy5zb2NrZXQpIHRoaXMuc29ja2V0LmNsb3NlKGNvZGUgfHwgMWUzLCBkYXRhKTtcbiAgfVxuICAvKipcbiAgKiBFbmFibGUgLyBkaXNhYmxlIGF1dG9tYXRpYyByZWNvbm5lY3Rpb24uXG4gICogQG1ldGhvZFxuICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVjb25uZWN0IC0gZW5hYmxlIC8gZGlzYWJsZSByZWNvbm5lY3Rpb25cbiAgKiBAcmV0dXJuIHtVbmRlZmluZWR9XG4gICovXG4gIHNldEF1dG9SZWNvbm5lY3QocmVjb25uZWN0KSB7XG4gICAgdGhpcy5yZWNvbm5lY3QgPSByZWNvbm5lY3Q7XG4gIH1cbiAgLyoqXG4gICogU2V0IHRoZSBpbnRlcnZhbCBiZXR3ZWVuIHJlY29ubmVjdGlvbiBhdHRlbXB0cy5cbiAgKiBAbWV0aG9kXG4gICogQHBhcmFtIHtOdW1iZXJ9IGludGVydmFsIC0gcmVjb25uZWN0aW9uIGludGVydmFsIGluIG1pbGxpc2Vjb25kc1xuICAqIEByZXR1cm4ge1VuZGVmaW5lZH1cbiAgKi9cbiAgc2V0UmVjb25uZWN0SW50ZXJ2YWwoaW50ZXJ2YWwpIHtcbiAgICB0aGlzLnJlY29ubmVjdF9pbnRlcnZhbCA9IGludGVydmFsO1xuICB9XG4gIC8qKlxuICAqIFNldCB0aGUgbWF4aW11bSBudW1iZXIgb2YgcmVjb25uZWN0aW9uIGF0dGVtcHRzLlxuICAqIEBtZXRob2RcbiAgKiBAcGFyYW0ge051bWJlcn0gbWF4X3JlY29ubmVjdHMgLSBtYXhpbXVtIHJlY29ubmVjdGlvbiBhdHRlbXB0c1xuICAqIEByZXR1cm4ge1VuZGVmaW5lZH1cbiAgKi9cbiAgc2V0TWF4UmVjb25uZWN0cyhtYXhfcmVjb25uZWN0cykge1xuICAgIHRoaXMubWF4X3JlY29ubmVjdHMgPSBtYXhfcmVjb25uZWN0cztcbiAgfVxuICAvKipcbiAgKiBHZXQgdGhlIGN1cnJlbnQgbnVtYmVyIG9mIHJlY29ubmVjdGlvbiBhdHRlbXB0cyBtYWRlLlxuICAqIEBtZXRob2RcbiAgKiBAcmV0dXJuIHtOdW1iZXJ9IGN1cnJlbnQgcmVjb25uZWN0aW9uIGF0dGVtcHRzXG4gICovXG4gIGdldEN1cnJlbnRSZWNvbm5lY3RzKCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRfcmVjb25uZWN0cztcbiAgfVxuICAvKipcbiAgKiBHZXQgdGhlIG1heGltdW0gbnVtYmVyIG9mIHJlY29ubmVjdGlvbiBhdHRlbXB0cy5cbiAgKiBAbWV0aG9kXG4gICogQHJldHVybiB7TnVtYmVyfSBtYXhpbXVtIHJlY29ubmVjdGlvbiBhdHRlbXB0c1xuICAqL1xuICBnZXRNYXhSZWNvbm5lY3RzKCkge1xuICAgIHJldHVybiB0aGlzLm1heF9yZWNvbm5lY3RzO1xuICB9XG4gIC8qKlxuICAqIENoZWNrIGlmIHRoZSBjbGllbnQgaXMgY3VycmVudGx5IGF0dGVtcHRpbmcgdG8gcmVjb25uZWN0LlxuICAqIEBtZXRob2RcbiAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHJlY29ubmVjdGlvbiBpcyBpbiBwcm9ncmVzc1xuICAqL1xuICBpc1JlY29ubmVjdGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5yZWNvbm5lY3RfdGltZXJfaWQgIT09IHZvaWQgMDtcbiAgfVxuICAvKipcbiAgKiBDaGVjayBpZiB0aGUgY2xpZW50IHdpbGwgYXR0ZW1wdCB0byByZWNvbm5lY3Qgb24gdGhlIG5leHQgY2xvc2UgZXZlbnQuXG4gICogQG1ldGhvZFxuICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgcmVjb25uZWN0aW9uIHdpbGwgYmUgYXR0ZW1wdGVkXG4gICovXG4gIHdpbGxSZWNvbm5lY3QoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVjb25uZWN0ICYmICh0aGlzLm1heF9yZWNvbm5lY3RzID09PSAwIHx8IHRoaXMuY3VycmVudF9yZWNvbm5lY3RzIDwgdGhpcy5tYXhfcmVjb25uZWN0cyk7XG4gIH1cbiAgLyoqXG4gICogQ29ubmVjdGlvbi9NZXNzYWdlIGhhbmRsZXIuXG4gICogQG1ldGhvZFxuICAqIEBwcml2YXRlXG4gICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgLSBXZWJTb2NrZXQgQVBJIGFkZHJlc3NcbiAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIHdzIG9wdGlvbnMgb2JqZWN0XG4gICogQHJldHVybiB7VW5kZWZpbmVkfVxuICAqL1xuICBfY29ubmVjdChhZGRyZXNzLCBvcHRpb25zKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMucmVjb25uZWN0X3RpbWVyX2lkKTtcbiAgICB0aGlzLnNvY2tldCA9IHRoaXMud2ViU29ja2V0RmFjdG9yeShhZGRyZXNzLCBvcHRpb25zKTtcbiAgICB0aGlzLnNvY2tldC5hZGRFdmVudExpc3RlbmVyKFwib3BlblwiLCAoKSA9PiB7XG4gICAgICB0aGlzLnJlYWR5ID0gdHJ1ZTtcbiAgICAgIHRoaXMuZW1pdChcIm9wZW5cIik7XG4gICAgICB0aGlzLmN1cnJlbnRfcmVjb25uZWN0cyA9IDA7XG4gICAgfSk7XG4gICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgKHsgZGF0YTogbWVzc2FnZSB9KSA9PiB7XG4gICAgICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKVxuICAgICAgICBtZXNzYWdlID0gQnVmZmVyLmZyb20obWVzc2FnZSkudG9TdHJpbmcoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIG1lc3NhZ2UgPSB0aGlzLmRhdGFQYWNrLmRlY29kZShtZXNzYWdlKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLm5vdGlmaWNhdGlvbiAmJiB0aGlzLmxpc3RlbmVycyhtZXNzYWdlLm5vdGlmaWNhdGlvbikubGVuZ3RoKSB7XG4gICAgICAgIGlmICghT2JqZWN0LmtleXMobWVzc2FnZS5wYXJhbXMpLmxlbmd0aClcbiAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0KG1lc3NhZ2Uubm90aWZpY2F0aW9uKTtcbiAgICAgICAgY29uc3QgYXJncyA9IFttZXNzYWdlLm5vdGlmaWNhdGlvbl07XG4gICAgICAgIGlmIChtZXNzYWdlLnBhcmFtcy5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSBhcmdzLnB1c2gobWVzc2FnZS5wYXJhbXMpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXNzYWdlLnBhcmFtcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGFyZ3MucHVzaChtZXNzYWdlLnBhcmFtc1tpXSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICB0aGlzLmVtaXQuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnF1ZXVlW21lc3NhZ2UuaWRdKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLm1ldGhvZCkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChtZXNzYWdlLm1ldGhvZCwgbWVzc2FnZT8ucGFyYW1zKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoXCJlcnJvclwiIGluIG1lc3NhZ2UgPT09IFwicmVzdWx0XCIgaW4gbWVzc2FnZSlcbiAgICAgICAgdGhpcy5xdWV1ZVttZXNzYWdlLmlkXS5wcm9taXNlWzFdKFxuICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgICdTZXJ2ZXIgcmVzcG9uc2UgbWFsZm9ybWVkLiBSZXNwb25zZSBtdXN0IGluY2x1ZGUgZWl0aGVyIFwicmVzdWx0XCIgb3IgXCJlcnJvclwiLCBidXQgbm90IGJvdGguJ1xuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIGlmICh0aGlzLnF1ZXVlW21lc3NhZ2UuaWRdLnRpbWVvdXQpXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnF1ZXVlW21lc3NhZ2UuaWRdLnRpbWVvdXQpO1xuICAgICAgaWYgKG1lc3NhZ2UuZXJyb3IpIHRoaXMucXVldWVbbWVzc2FnZS5pZF0ucHJvbWlzZVsxXShtZXNzYWdlLmVycm9yKTtcbiAgICAgIGVsc2UgdGhpcy5xdWV1ZVttZXNzYWdlLmlkXS5wcm9taXNlWzBdKG1lc3NhZ2UucmVzdWx0KTtcbiAgICAgIGRlbGV0ZSB0aGlzLnF1ZXVlW21lc3NhZ2UuaWRdO1xuICAgIH0pO1xuICAgIHRoaXMuc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCAoZXJyb3IpID0+IHRoaXMuZW1pdChcImVycm9yXCIsIGVycm9yKSk7XG4gICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcImNsb3NlXCIsICh7IGNvZGUsIHJlYXNvbiB9KSA9PiB7XG4gICAgICBpZiAodGhpcy5yZWFkeSlcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLmVtaXQoXCJjbG9zZVwiLCBjb2RlLCByZWFzb24pLCAwKTtcbiAgICAgIHRoaXMucmVhZHkgPSBmYWxzZTtcbiAgICAgIHRoaXMuc29ja2V0ID0gdm9pZCAwO1xuICAgICAgaWYgKGNvZGUgPT09IDFlMykgcmV0dXJuO1xuICAgICAgdGhpcy5jdXJyZW50X3JlY29ubmVjdHMrKztcbiAgICAgIGlmICh0aGlzLnJlY29ubmVjdCAmJiAodGhpcy5tYXhfcmVjb25uZWN0cyA+IHRoaXMuY3VycmVudF9yZWNvbm5lY3RzIHx8IHRoaXMubWF4X3JlY29ubmVjdHMgPT09IDApKVxuICAgICAgICB0aGlzLnJlY29ubmVjdF90aW1lcl9pZCA9IHNldFRpbWVvdXQoXG4gICAgICAgICAgKCkgPT4gdGhpcy5fY29ubmVjdChhZGRyZXNzLCBvcHRpb25zKSxcbiAgICAgICAgICB0aGlzLnJlY29ubmVjdF9pbnRlcnZhbFxuICAgICAgICApO1xuICAgICAgZWxzZSBpZiAodGhpcy5yZWNvbm5lY3QgJiYgdGhpcy5tYXhfcmVjb25uZWN0cyA+IDAgJiYgdGhpcy5jdXJyZW50X3JlY29ubmVjdHMgPj0gdGhpcy5tYXhfcmVjb25uZWN0cykge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuZW1pdChcIm1heF9yZWNvbm5lY3RzX3JlYWNoZWRcIiwgY29kZSwgcmVhc29uKSwgMSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG52YXIgU2VydmVyID0gY2xhc3MgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBuYW1lc3BhY2VzO1xuICBkYXRhUGFjaztcbiAgd3NzO1xuICAvKipcbiAgKiBJbnN0YW50aWF0ZSBhIFNlcnZlciBjbGFzcy5cbiAgKiBAY29uc3RydWN0b3JcbiAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIHdzIGNvbnN0cnVjdG9yJ3MgcGFyYW1ldGVycyB3aXRoIHJwY1xuICAqIEBwYXJhbSB7RGF0YVBhY2t9IGRhdGFQYWNrIC0gZGF0YSBwYWNrIGNvbnRhaW5zIGVuY29kZXIgYW5kIGRlY29kZXJcbiAgKiBAcmV0dXJuIHtTZXJ2ZXJ9IC0gcmV0dXJucyBhIG5ldyBTZXJ2ZXIgaW5zdGFuY2VcbiAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucywgZGF0YVBhY2spIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubmFtZXNwYWNlcyA9IHt9O1xuICAgIGlmICghZGF0YVBhY2spIHRoaXMuZGF0YVBhY2sgPSBuZXcgRGVmYXVsdERhdGFQYWNrKCk7XG4gICAgZWxzZSB0aGlzLmRhdGFQYWNrID0gZGF0YVBhY2s7XG4gICAgdGhpcy53c3MgPSBuZXcgV2ViU29ja2V0U2VydmVyKG9wdGlvbnMpO1xuICAgIHRoaXMud3NzLm9uKFwibGlzdGVuaW5nXCIsICgpID0+IHRoaXMuZW1pdChcImxpc3RlbmluZ1wiKSk7XG4gICAgdGhpcy53c3Mub24oXCJjb25uZWN0aW9uXCIsIChzb2NrZXQsIHJlcXVlc3QpID0+IHtcbiAgICAgIGNvbnN0IHUgPSB1cmwucGFyc2UocmVxdWVzdC51cmwsIHRydWUpO1xuICAgICAgY29uc3QgbnMgPSB1LnBhdGhuYW1lO1xuICAgICAgaWYgKHUucXVlcnkuc29ja2V0X2lkKSBzb2NrZXQuX2lkID0gdS5xdWVyeS5zb2NrZXRfaWQ7XG4gICAgICBlbHNlIHNvY2tldC5faWQgPSB2MSgpO1xuICAgICAgc29ja2V0W1wiX2F1dGhlbnRpY2F0ZWRcIl0gPSBmYWxzZTtcbiAgICAgIHNvY2tldC5vbihcImVycm9yXCIsIChlcnJvcikgPT4gdGhpcy5lbWl0KFwic29ja2V0LWVycm9yXCIsIHNvY2tldCwgZXJyb3IpKTtcbiAgICAgIHNvY2tldC5vbihcImNsb3NlXCIsICgpID0+IHtcbiAgICAgICAgdGhpcy5uYW1lc3BhY2VzW25zXS5jbGllbnRzLmRlbGV0ZShzb2NrZXQuX2lkKTtcbiAgICAgICAgZm9yIChjb25zdCBldmVudCBvZiBPYmplY3Qua2V5cyh0aGlzLm5hbWVzcGFjZXNbbnNdLmV2ZW50cykpIHtcbiAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMubmFtZXNwYWNlc1tuc10uZXZlbnRzW2V2ZW50XS5zb2NrZXRzLmluZGV4T2YoXG4gICAgICAgICAgICBzb2NrZXQuX2lkXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoaW5kZXggPj0gMClcbiAgICAgICAgICAgIHRoaXMubmFtZXNwYWNlc1tuc10uZXZlbnRzW2V2ZW50XS5zb2NrZXRzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KFwiZGlzY29ubmVjdGlvblwiLCBzb2NrZXQpO1xuICAgICAgfSk7XG4gICAgICBpZiAoIXRoaXMubmFtZXNwYWNlc1tuc10pIHRoaXMuX2dlbmVyYXRlTmFtZXNwYWNlKG5zKTtcbiAgICAgIHRoaXMubmFtZXNwYWNlc1tuc10uY2xpZW50cy5zZXQoc29ja2V0Ll9pZCwgc29ja2V0KTtcbiAgICAgIHRoaXMuZW1pdChcImNvbm5lY3Rpb25cIiwgc29ja2V0LCByZXF1ZXN0KTtcbiAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVSUEMoc29ja2V0LCBucyk7XG4gICAgfSk7XG4gICAgdGhpcy53c3Mub24oXCJlcnJvclwiLCAoZXJyb3IpID0+IHRoaXMuZW1pdChcImVycm9yXCIsIGVycm9yKSk7XG4gIH1cbiAgLyoqXG4gICogUmVnaXN0ZXJzIGFuIFJQQyBtZXRob2QuXG4gICogQG1ldGhvZFxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gbWV0aG9kIG5hbWVcbiAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIGEgY2FsbGVlIGZ1bmN0aW9uXG4gICogQHBhcmFtIHtTdHJpbmd9IG5zIC0gbmFtZXNwYWNlIGlkZW50aWZpZXJcbiAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9XG4gICogQHJldHVybiB7T2JqZWN0fSAtIHJldHVybnMgYW4gSU1ldGhvZCBvYmplY3RcbiAgKi9cbiAgcmVnaXN0ZXIobmFtZSwgZm4sIG5zID0gXCIvXCIpIHtcbiAgICBpZiAoIXRoaXMubmFtZXNwYWNlc1tuc10pIHRoaXMuX2dlbmVyYXRlTmFtZXNwYWNlKG5zKTtcbiAgICB0aGlzLm5hbWVzcGFjZXNbbnNdLnJwY19tZXRob2RzW25hbWVdID0ge1xuICAgICAgZm4sXG4gICAgICBwcm90ZWN0ZWQ6IGZhbHNlXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgcHJvdGVjdGVkOiAoKSA9PiB0aGlzLl9tYWtlUHJvdGVjdGVkTWV0aG9kKG5hbWUsIG5zKSxcbiAgICAgIHB1YmxpYzogKCkgPT4gdGhpcy5fbWFrZVB1YmxpY01ldGhvZChuYW1lLCBucylcbiAgICB9O1xuICB9XG4gIC8qKlxuICAqIFNldHMgYW4gYXV0aCBtZXRob2QuXG4gICogQG1ldGhvZFxuICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gYW4gYXJiaXRyYXJ5IGF1dGggbWV0aG9kXG4gICogQHBhcmFtIHtTdHJpbmd9IG5zIC0gbmFtZXNwYWNlIGlkZW50aWZpZXJcbiAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9XG4gICogQHJldHVybiB7VW5kZWZpbmVkfVxuICAqL1xuICBzZXRBdXRoKGZuLCBucyA9IFwiL1wiKSB7XG4gICAgdGhpcy5yZWdpc3RlcihcInJwYy5sb2dpblwiLCBmbiwgbnMpO1xuICB9XG4gIC8qKlxuICAqIE1hcmtzIGFuIFJQQyBtZXRob2QgYXMgcHJvdGVjdGVkLlxuICAqIEBtZXRob2RcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIG1ldGhvZCBuYW1lXG4gICogQHBhcmFtIHtTdHJpbmd9IG5zIC0gbmFtZXNwYWNlIGlkZW50aWZpZXJcbiAgKiBAcmV0dXJuIHtVbmRlZmluZWR9XG4gICovXG4gIF9tYWtlUHJvdGVjdGVkTWV0aG9kKG5hbWUsIG5zID0gXCIvXCIpIHtcbiAgICB0aGlzLm5hbWVzcGFjZXNbbnNdLnJwY19tZXRob2RzW25hbWVdLnByb3RlY3RlZCA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICogTWFya3MgYW4gUlBDIG1ldGhvZCBhcyBwdWJsaWMuXG4gICogQG1ldGhvZFxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gbWV0aG9kIG5hbWVcbiAgKiBAcGFyYW0ge1N0cmluZ30gbnMgLSBuYW1lc3BhY2UgaWRlbnRpZmllclxuICAqIEByZXR1cm4ge1VuZGVmaW5lZH1cbiAgKi9cbiAgX21ha2VQdWJsaWNNZXRob2QobmFtZSwgbnMgPSBcIi9cIikge1xuICAgIHRoaXMubmFtZXNwYWNlc1tuc10ucnBjX21ldGhvZHNbbmFtZV0ucHJvdGVjdGVkID0gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICogTWFya3MgYW4gZXZlbnQgYXMgcHJvdGVjdGVkLlxuICAqIEBtZXRob2RcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIGV2ZW50IG5hbWVcbiAgKiBAcGFyYW0ge1N0cmluZ30gbnMgLSBuYW1lc3BhY2UgaWRlbnRpZmllclxuICAqIEByZXR1cm4ge1VuZGVmaW5lZH1cbiAgKi9cbiAgX21ha2VQcm90ZWN0ZWRFdmVudChuYW1lLCBucyA9IFwiL1wiKSB7XG4gICAgdGhpcy5uYW1lc3BhY2VzW25zXS5ldmVudHNbbmFtZV0ucHJvdGVjdGVkID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgKiBNYXJrcyBhbiBldmVudCBhcyBwdWJsaWMuXG4gICogQG1ldGhvZFxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gZXZlbnQgbmFtZVxuICAqIEBwYXJhbSB7U3RyaW5nfSBucyAtIG5hbWVzcGFjZSBpZGVudGlmaWVyXG4gICogQHJldHVybiB7VW5kZWZpbmVkfVxuICAqL1xuICBfbWFrZVB1YmxpY0V2ZW50KG5hbWUsIG5zID0gXCIvXCIpIHtcbiAgICB0aGlzLm5hbWVzcGFjZXNbbnNdLmV2ZW50c1tuYW1lXS5wcm90ZWN0ZWQgPSBmYWxzZTtcbiAgfVxuICAvKipcbiAgKiBSZW1vdmVzIGEgbmFtZXNwYWNlIGFuZCBjbG9zZXMgYWxsIGNvbm5lY3Rpb25zXG4gICogQG1ldGhvZFxuICAqIEBwYXJhbSB7U3RyaW5nfSBucyAtIG5hbWVzcGFjZSBpZGVudGlmaWVyXG4gICogQHRocm93cyB7VHlwZUVycm9yfVxuICAqIEByZXR1cm4ge1VuZGVmaW5lZH1cbiAgKi9cbiAgY2xvc2VOYW1lc3BhY2UobnMpIHtcbiAgICBjb25zdCBuYW1lc3BhY2UgPSB0aGlzLm5hbWVzcGFjZXNbbnNdO1xuICAgIGlmIChuYW1lc3BhY2UpIHtcbiAgICAgIGRlbGV0ZSBuYW1lc3BhY2UucnBjX21ldGhvZHM7XG4gICAgICBkZWxldGUgbmFtZXNwYWNlLmV2ZW50cztcbiAgICAgIGZvciAoY29uc3Qgc29ja2V0IG9mIG5hbWVzcGFjZS5jbGllbnRzLnZhbHVlcygpKSBzb2NrZXQuY2xvc2UoKTtcbiAgICAgIGRlbGV0ZSB0aGlzLm5hbWVzcGFjZXNbbnNdO1xuICAgIH1cbiAgfVxuICAvKipcbiAgKiBDcmVhdGVzIGEgbmV3IGV2ZW50IHRoYXQgY2FuIGJlIGVtaXR0ZWQgdG8gY2xpZW50cy5cbiAgKiBAbWV0aG9kXG4gICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBldmVudCBuYW1lXG4gICogQHBhcmFtIHtTdHJpbmd9IG5zIC0gbmFtZXNwYWNlIGlkZW50aWZpZXJcbiAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9XG4gICogQHJldHVybiB7T2JqZWN0fSAtIHJldHVybnMgYW4gSUV2ZW50IG9iamVjdFxuICAqL1xuICBldmVudChuYW1lLCBucyA9IFwiL1wiKSB7XG4gICAgaWYgKCF0aGlzLm5hbWVzcGFjZXNbbnNdKSB0aGlzLl9nZW5lcmF0ZU5hbWVzcGFjZShucyk7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMubmFtZXNwYWNlc1tuc10uZXZlbnRzW25hbWVdO1xuICAgICAgaWYgKGluZGV4ICE9PSB2b2lkIDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQWxyZWFkeSByZWdpc3RlcmVkIGV2ZW50ICR7bnN9JHtuYW1lfWApO1xuICAgIH1cbiAgICB0aGlzLm5hbWVzcGFjZXNbbnNdLmV2ZW50c1tuYW1lXSA9IHtcbiAgICAgIHNvY2tldHM6IFtdLFxuICAgICAgcHJvdGVjdGVkOiBmYWxzZVxuICAgIH07XG4gICAgdGhpcy5vbihuYW1lLCAoLi4ucGFyYW1zKSA9PiB7XG4gICAgICBpZiAocGFyYW1zLmxlbmd0aCA9PT0gMSAmJiBwYXJhbXNbMF0gaW5zdGFuY2VvZiBPYmplY3QpXG4gICAgICAgIHBhcmFtcyA9IHBhcmFtc1swXTtcbiAgICAgIGZvciAoY29uc3Qgc29ja2V0X2lkIG9mIHRoaXMubmFtZXNwYWNlc1tuc10uZXZlbnRzW25hbWVdLnNvY2tldHMpIHtcbiAgICAgICAgY29uc3Qgc29ja2V0ID0gdGhpcy5uYW1lc3BhY2VzW25zXS5jbGllbnRzLmdldChzb2NrZXRfaWQpO1xuICAgICAgICBpZiAoIXNvY2tldCkgY29udGludWU7XG4gICAgICAgIHNvY2tldC5zZW5kKFxuICAgICAgICAgIHRoaXMuZGF0YVBhY2suZW5jb2RlKHtcbiAgICAgICAgICAgIG5vdGlmaWNhdGlvbjogbmFtZSxcbiAgICAgICAgICAgIHBhcmFtc1xuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHByb3RlY3RlZDogKCkgPT4gdGhpcy5fbWFrZVByb3RlY3RlZEV2ZW50KG5hbWUsIG5zKSxcbiAgICAgIHB1YmxpYzogKCkgPT4gdGhpcy5fbWFrZVB1YmxpY0V2ZW50KG5hbWUsIG5zKVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICogUmV0dXJucyBhIHJlcXVlc3RlZCBuYW1lc3BhY2Ugb2JqZWN0XG4gICogQG1ldGhvZFxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gbmFtZXNwYWNlIGlkZW50aWZpZXJcbiAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9XG4gICogQHJldHVybiB7T2JqZWN0fSAtIG5hbWVzcGFjZSBvYmplY3RcbiAgKi9cbiAgb2YobmFtZSkge1xuICAgIGlmICghdGhpcy5uYW1lc3BhY2VzW25hbWVdKSB0aGlzLl9nZW5lcmF0ZU5hbWVzcGFjZShuYW1lKTtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4ge1xuICAgICAgLy8gc2VsZi5yZWdpc3RlciBjb252ZW5pZW5jZSBtZXRob2RcbiAgICAgIHJlZ2lzdGVyKGZuX25hbWUsIGZuKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAyKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm11c3QgcHJvdmlkZSBleGFjdGx5IHR3byBhcmd1bWVudHNcIik7XG4gICAgICAgIGlmICh0eXBlb2YgZm5fbmFtZSAhPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJuYW1lIG11c3QgYmUgYSBzdHJpbmdcIik7XG4gICAgICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJoYW5kbGVyIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgcmV0dXJuIHNlbGYucmVnaXN0ZXIoZm5fbmFtZSwgZm4sIG5hbWUpO1xuICAgICAgfSxcbiAgICAgIC8vIHNlbGYuZXZlbnQgY29udmVuaWVuY2UgbWV0aG9kXG4gICAgICBldmVudChldl9uYW1lKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAxKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm11c3QgcHJvdmlkZSBleGFjdGx5IG9uZSBhcmd1bWVudFwiKTtcbiAgICAgICAgaWYgKHR5cGVvZiBldl9uYW1lICE9PSBcInN0cmluZ1wiKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5hbWUgbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgICAgICAgcmV0dXJuIHNlbGYuZXZlbnQoZXZfbmFtZSwgbmFtZSk7XG4gICAgICB9LFxuICAgICAgLy8gc2VsZi5ldmVudExpc3QgY29udmVuaWVuY2UgbWV0aG9kXG4gICAgICBnZXQgZXZlbnRMaXN0KCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoc2VsZi5uYW1lc3BhY2VzW25hbWVdLmV2ZW50cyk7XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAqIEVtaXRzIGEgc3BlY2lmaWVkIGV2ZW50IHRvIHRoaXMgbmFtZXNwYWNlLlxuICAgICAgKiBAaW5uZXJcbiAgICAgICogQG1ldGhvZFxuICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgLSBldmVudCBuYW1lXG4gICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtcyAtIGV2ZW50IHBhcmFtZXRlcnNcbiAgICAgICogQHJldHVybiB7VW5kZWZpbmVkfVxuICAgICAgKi9cbiAgICAgIGVtaXQoZXZlbnQsIC4uLnBhcmFtcykge1xuICAgICAgICBjb25zdCBuc0V2ZW50ID0gc2VsZi5uYW1lc3BhY2VzW25hbWVdLmV2ZW50c1tldmVudF07XG4gICAgICAgIGlmIChuc0V2ZW50KVxuICAgICAgICAgIGZvciAoY29uc3Qgc29ja2V0X2lkIG9mIG5zRXZlbnQuc29ja2V0cykge1xuICAgICAgICAgICAgY29uc3Qgc29ja2V0ID0gc2VsZi5uYW1lc3BhY2VzW25hbWVdLmNsaWVudHMuZ2V0KHNvY2tldF9pZCk7XG4gICAgICAgICAgICBpZiAoIXNvY2tldCkgY29udGludWU7XG4gICAgICAgICAgICBzb2NrZXQuc2VuZChcbiAgICAgICAgICAgICAgc2VsZi5kYXRhUGFjay5lbmNvZGUoe1xuICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbjogZXZlbnQsXG4gICAgICAgICAgICAgICAgcGFyYW1zXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICogUmV0dXJucyBhIG5hbWUgb2YgdGhpcyBuYW1lc3BhY2UuXG4gICAgICAqIEBpbm5lclxuICAgICAgKiBAbWV0aG9kXG4gICAgICAqIEBraW5kIGNvbnN0YW50XG4gICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgICovXG4gICAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAqIFJldHVybnMgYSBoYXNoIG9mIHdlYnNvY2tldCBvYmplY3RzIGNvbm5lY3RlZCB0byB0aGlzIG5hbWVzcGFjZS5cbiAgICAgICogQGlubmVyXG4gICAgICAqIEBtZXRob2RcbiAgICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAgKi9cbiAgICAgIGNvbm5lY3RlZCgpIHtcbiAgICAgICAgY29uc3Qgc29ja2V0X2lkcyA9IFsuLi5zZWxmLm5hbWVzcGFjZXNbbmFtZV0uY2xpZW50cy5rZXlzKCldO1xuICAgICAgICByZXR1cm4gc29ja2V0X2lkcy5yZWR1Y2UoXG4gICAgICAgICAgKGFjYywgY3VycikgPT4gKHtcbiAgICAgICAgICAgIC4uLmFjYyxcbiAgICAgICAgICAgIFtjdXJyXTogc2VsZi5uYW1lc3BhY2VzW25hbWVdLmNsaWVudHMuZ2V0KGN1cnIpXG4gICAgICAgICAgfSksXG4gICAgICAgICAge31cbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICogUmV0dXJucyBhIGxpc3Qgb2YgY2xpZW50IHVuaXF1ZSBpZGVudGlmaWVycyBjb25uZWN0ZWQgdG8gdGhpcyBuYW1lc3BhY2UuXG4gICAgICAqIEBpbm5lclxuICAgICAgKiBAbWV0aG9kXG4gICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAgKi9cbiAgICAgIGNsaWVudHMoKSB7XG4gICAgICAgIHJldHVybiBzZWxmLm5hbWVzcGFjZXNbbmFtZV07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgKiBMaXN0cyBhbGwgY3JlYXRlZCBldmVudHMgaW4gYSBnaXZlbiBuYW1lc3BhY2UuIERlZmF1bHRzIHRvIFwiL1wiLlxuICAqIEBtZXRob2RcbiAgKiBAcGFyYW0ge1N0cmluZ30gbnMgLSBuYW1lc3BhY2VzIGlkZW50aWZpZXJcbiAgKiBAcmVhZG9ubHlcbiAgKiBAcmV0dXJuIHtBcnJheX0gLSByZXR1cm5zIGEgbGlzdCBvZiBjcmVhdGVkIGV2ZW50c1xuICAqL1xuICBldmVudExpc3QobnMgPSBcIi9cIikge1xuICAgIGlmICghdGhpcy5uYW1lc3BhY2VzW25zXSkgcmV0dXJuIFtdO1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLm5hbWVzcGFjZXNbbnNdLmV2ZW50cyk7XG4gIH1cbiAgLyoqXG4gICogQ3JlYXRlcyBhIEpTT04tUlBDIDIuMCBjb21wbGlhbnQgZXJyb3JcbiAgKiBAbWV0aG9kXG4gICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgLSBpbmRpY2F0ZXMgdGhlIGVycm9yIHR5cGUgdGhhdCBvY2N1cnJlZFxuICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIC0gcHJvdmlkZXMgYSBzaG9ydCBkZXNjcmlwdGlvbiBvZiB0aGUgZXJyb3JcbiAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGRhdGEgLSBkZXRhaWxzIGNvbnRhaW5pbmcgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZXJyb3JcbiAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICovXG4gIGNyZWF0ZUVycm9yKGNvZGUsIG1lc3NhZ2UsIGRhdGEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29kZSxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBkYXRhOiBkYXRhIHx8IG51bGxcbiAgICB9O1xuICB9XG4gIC8qKlxuICAqIENsb3NlcyB0aGUgc2VydmVyIGFuZCB0ZXJtaW5hdGVzIGFsbCBjbGllbnRzLlxuICAqIEBtZXRob2RcbiAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAqL1xuICBjbG9zZSgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy53c3MuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5lbWl0KFwiY2xvc2VcIik7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICogSGFuZGxlcyBhbGwgV2ViU29ja2V0IEpTT04gUlBDIDIuMCByZXF1ZXN0cy5cbiAgKiBAcHJpdmF0ZVxuICAqIEBwYXJhbSB7T2JqZWN0fSBzb2NrZXQgLSB3cyBzb2NrZXQgaW5zdGFuY2VcbiAgKiBAcGFyYW0ge1N0cmluZ30gbnMgLSBuYW1lc3BhY2VzIGlkZW50aWZpZXJcbiAgKiBAcmV0dXJuIHtVbmRlZmluZWR9XG4gICovXG4gIF9oYW5kbGVSUEMoc29ja2V0LCBucyA9IFwiL1wiKSB7XG4gICAgc29ja2V0Lm9uKFwibWVzc2FnZVwiLCBhc3luYyAoZGF0YSkgPT4ge1xuICAgICAgY29uc3QgbXNnX29wdGlvbnMgPSB7fTtcbiAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgbXNnX29wdGlvbnMuYmluYXJ5ID0gdHJ1ZTtcbiAgICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEpLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICBpZiAoc29ja2V0LnJlYWR5U3RhdGUgIT09IDEpIHJldHVybjtcbiAgICAgIGxldCBwYXJzZWREYXRhO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGFyc2VkRGF0YSA9IHRoaXMuZGF0YVBhY2suZGVjb2RlKGRhdGEpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHNvY2tldC5zZW5kKFxuICAgICAgICAgIHRoaXMuZGF0YVBhY2suZW5jb2RlKHtcbiAgICAgICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgICAgICBlcnJvcjogY3JlYXRlRXJyb3IoLTMyNzAwLCBlcnJvci50b1N0cmluZygpKSxcbiAgICAgICAgICAgIGlkOiBudWxsXG4gICAgICAgICAgfSksXG4gICAgICAgICAgbXNnX29wdGlvbnNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcnNlZERhdGEpKSB7XG4gICAgICAgIGlmICghcGFyc2VkRGF0YS5sZW5ndGgpXG4gICAgICAgICAgcmV0dXJuIHNvY2tldC5zZW5kKFxuICAgICAgICAgICAgdGhpcy5kYXRhUGFjay5lbmNvZGUoe1xuICAgICAgICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICAgICAgICBlcnJvcjogY3JlYXRlRXJyb3IoLTMyNjAwLCBcIkludmFsaWQgYXJyYXlcIiksXG4gICAgICAgICAgICAgIGlkOiBudWxsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIG1zZ19vcHRpb25zXG4gICAgICAgICAgKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBwYXJzZWREYXRhKSB7XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UyID0gYXdhaXQgdGhpcy5fcnVuTWV0aG9kKG1lc3NhZ2UsIHNvY2tldC5faWQsIG5zKTtcbiAgICAgICAgICBpZiAoIXJlc3BvbnNlMikgY29udGludWU7XG4gICAgICAgICAgcmVzcG9uc2VzLnB1c2gocmVzcG9uc2UyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc3BvbnNlcy5sZW5ndGgpIHJldHVybjtcbiAgICAgICAgcmV0dXJuIHNvY2tldC5zZW5kKHRoaXMuZGF0YVBhY2suZW5jb2RlKHJlc3BvbnNlcyksIG1zZ19vcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fcnVuTWV0aG9kKHBhcnNlZERhdGEsIHNvY2tldC5faWQsIG5zKTtcbiAgICAgIGlmICghcmVzcG9uc2UpIHJldHVybjtcbiAgICAgIHJldHVybiBzb2NrZXQuc2VuZCh0aGlzLmRhdGFQYWNrLmVuY29kZShyZXNwb25zZSksIG1zZ19vcHRpb25zKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgKiBSdW5zIGEgZGVmaW5lZCBSUEMgbWV0aG9kLlxuICAqIEBwcml2YXRlXG4gICogQHBhcmFtIHtPYmplY3R9IG1lc3NhZ2UgLSBhIG1lc3NhZ2UgcmVjZWl2ZWRcbiAgKiBAcGFyYW0ge09iamVjdH0gc29ja2V0X2lkIC0gdXNlcidzIHNvY2tldCBpZFxuICAqIEBwYXJhbSB7U3RyaW5nfSBucyAtIG5hbWVzcGFjZXMgaWRlbnRpZmllclxuICAqIEByZXR1cm4ge09iamVjdHx1bmRlZmluZWR9XG4gICovXG4gIGFzeW5jIF9ydW5NZXRob2QobWVzc2FnZSwgc29ja2V0X2lkLCBucyA9IFwiL1wiKSB7XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICBlcnJvcjogY3JlYXRlRXJyb3IoLTMyNjAwKSxcbiAgICAgICAgaWQ6IG51bGxcbiAgICAgIH07XG4gICAgaWYgKG1lc3NhZ2UuanNvbnJwYyAhPT0gXCIyLjBcIilcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgIGVycm9yOiBjcmVhdGVFcnJvcigtMzI2MDAsIFwiSW52YWxpZCBKU09OIFJQQyB2ZXJzaW9uXCIpLFxuICAgICAgICBpZDogbWVzc2FnZS5pZCB8fCBudWxsXG4gICAgICB9O1xuICAgIGlmICghbWVzc2FnZS5tZXRob2QpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICBlcnJvcjogY3JlYXRlRXJyb3IoLTMyNjAyLCBcIk1ldGhvZCBub3Qgc3BlY2lmaWVkXCIpLFxuICAgICAgICBpZDogbWVzc2FnZS5pZCB8fCBudWxsXG4gICAgICB9O1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZS5tZXRob2QgIT09IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICBlcnJvcjogY3JlYXRlRXJyb3IoLTMyNjAwLCBcIkludmFsaWQgbWV0aG9kIG5hbWVcIiksXG4gICAgICAgIGlkOiBtZXNzYWdlLmlkIHx8IG51bGxcbiAgICAgIH07XG4gICAgaWYgKG1lc3NhZ2UucGFyYW1zICYmIHR5cGVvZiBtZXNzYWdlLnBhcmFtcyA9PT0gXCJzdHJpbmdcIilcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgIGVycm9yOiBjcmVhdGVFcnJvcigtMzI2MDApLFxuICAgICAgICBpZDogbWVzc2FnZS5pZCB8fCBudWxsXG4gICAgICB9O1xuICAgIGlmIChtZXNzYWdlLm1ldGhvZCA9PT0gXCJycGMub25cIikge1xuICAgICAgaWYgKCFtZXNzYWdlLnBhcmFtcylcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICAgIGVycm9yOiBjcmVhdGVFcnJvcigtMzJlMyksXG4gICAgICAgICAgaWQ6IG1lc3NhZ2UuaWQgfHwgbnVsbFxuICAgICAgICB9O1xuICAgICAgY29uc3QgcmVzdWx0cyA9IHt9O1xuICAgICAgY29uc3QgZXZlbnRfbmFtZXMgPSBPYmplY3Qua2V5cyh0aGlzLm5hbWVzcGFjZXNbbnNdLmV2ZW50cyk7XG4gICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgbWVzc2FnZS5wYXJhbXMpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBldmVudF9uYW1lcy5pbmRleE9mKG5hbWUpO1xuICAgICAgICBjb25zdCBuYW1lc3BhY2UgPSB0aGlzLm5hbWVzcGFjZXNbbnNdO1xuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgcmVzdWx0c1tuYW1lXSA9IFwicHJvdmlkZWQgZXZlbnQgaW52YWxpZFwiO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lc3BhY2UuZXZlbnRzW2V2ZW50X25hbWVzW2luZGV4XV0ucHJvdGVjdGVkID09PSB0cnVlICYmIG5hbWVzcGFjZS5jbGllbnRzLmdldChzb2NrZXRfaWQpW1wiX2F1dGhlbnRpY2F0ZWRcIl0gPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgICAgICBlcnJvcjogY3JlYXRlRXJyb3IoLTMyNjA2KSxcbiAgICAgICAgICAgIGlkOiBtZXNzYWdlLmlkIHx8IG51bGxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNvY2tldF9pbmRleCA9IG5hbWVzcGFjZS5ldmVudHNbZXZlbnRfbmFtZXNbaW5kZXhdXS5zb2NrZXRzLmluZGV4T2Yoc29ja2V0X2lkKTtcbiAgICAgICAgaWYgKHNvY2tldF9pbmRleCA+PSAwKSB7XG4gICAgICAgICAgcmVzdWx0c1tuYW1lXSA9IFwic29ja2V0IGhhcyBhbHJlYWR5IGJlZW4gc3Vic2NyaWJlZCB0byBldmVudFwiO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG5hbWVzcGFjZS5ldmVudHNbZXZlbnRfbmFtZXNbaW5kZXhdXS5zb2NrZXRzLnB1c2goc29ja2V0X2lkKTtcbiAgICAgICAgcmVzdWx0c1tuYW1lXSA9IFwib2tcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgIHJlc3VsdDogcmVzdWx0cyxcbiAgICAgICAgaWQ6IG1lc3NhZ2UuaWQgfHwgbnVsbFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKG1lc3NhZ2UubWV0aG9kID09PSBcInJwYy5vZmZcIikge1xuICAgICAgaWYgKCFtZXNzYWdlLnBhcmFtcylcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICAgIGVycm9yOiBjcmVhdGVFcnJvcigtMzJlMyksXG4gICAgICAgICAgaWQ6IG1lc3NhZ2UuaWQgfHwgbnVsbFxuICAgICAgICB9O1xuICAgICAgY29uc3QgcmVzdWx0cyA9IHt9O1xuICAgICAgZm9yIChjb25zdCBuYW1lIG9mIG1lc3NhZ2UucGFyYW1zKSB7XG4gICAgICAgIGlmICghdGhpcy5uYW1lc3BhY2VzW25zXS5ldmVudHNbbmFtZV0pIHtcbiAgICAgICAgICByZXN1bHRzW25hbWVdID0gXCJwcm92aWRlZCBldmVudCBpbnZhbGlkXCI7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLm5hbWVzcGFjZXNbbnNdLmV2ZW50c1tuYW1lXS5zb2NrZXRzLmluZGV4T2Yoc29ja2V0X2lkKTtcbiAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgIHJlc3VsdHNbbmFtZV0gPSBcIm5vdCBzdWJzY3JpYmVkXCI7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uYW1lc3BhY2VzW25zXS5ldmVudHNbbmFtZV0uc29ja2V0cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICByZXN1bHRzW25hbWVdID0gXCJva1wiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgcmVzdWx0OiByZXN1bHRzLFxuICAgICAgICBpZDogbWVzc2FnZS5pZCB8fCBudWxsXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAobWVzc2FnZS5tZXRob2QgPT09IFwicnBjLmxvZ2luXCIpIHtcbiAgICAgIGlmICghbWVzc2FnZS5wYXJhbXMpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgICBlcnJvcjogY3JlYXRlRXJyb3IoLTMyNjA0KSxcbiAgICAgICAgICBpZDogbWVzc2FnZS5pZCB8fCBudWxsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICghdGhpcy5uYW1lc3BhY2VzW25zXS5ycGNfbWV0aG9kc1ttZXNzYWdlLm1ldGhvZF0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgIGVycm9yOiBjcmVhdGVFcnJvcigtMzI2MDEpLFxuICAgICAgICBpZDogbWVzc2FnZS5pZCB8fCBudWxsXG4gICAgICB9O1xuICAgIH1cbiAgICBsZXQgcmVzcG9uc2UgPSBudWxsO1xuICAgIGlmICh0aGlzLm5hbWVzcGFjZXNbbnNdLnJwY19tZXRob2RzW21lc3NhZ2UubWV0aG9kXS5wcm90ZWN0ZWQgPT09IHRydWUgJiYgdGhpcy5uYW1lc3BhY2VzW25zXS5jbGllbnRzLmdldChzb2NrZXRfaWQpW1wiX2F1dGhlbnRpY2F0ZWRcIl0gPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICBlcnJvcjogY3JlYXRlRXJyb3IoLTMyNjA1KSxcbiAgICAgICAgaWQ6IG1lc3NhZ2UuaWQgfHwgbnVsbFxuICAgICAgfTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy5uYW1lc3BhY2VzW25zXS5ycGNfbWV0aG9kc1ttZXNzYWdlLm1ldGhvZF0uZm4oXG4gICAgICAgIG1lc3NhZ2UucGFyYW1zLFxuICAgICAgICBzb2NrZXRfaWRcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmICghbWVzc2FnZS5pZCkgcmV0dXJuO1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgICBlcnJvcjoge1xuICAgICAgICAgICAgY29kZTogLTMyZTMsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5uYW1lLFxuICAgICAgICAgICAgZGF0YTogZXJyb3IubWVzc2FnZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgaWQ6IG1lc3NhZ2UuaWRcbiAgICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgIGVycm9yLFxuICAgICAgICBpZDogbWVzc2FnZS5pZFxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCFtZXNzYWdlLmlkKSByZXR1cm47XG4gICAgaWYgKG1lc3NhZ2UubWV0aG9kID09PSBcInJwYy5sb2dpblwiICYmIHJlc3BvbnNlID09PSB0cnVlKSB7XG4gICAgICBjb25zdCBzID0gdGhpcy5uYW1lc3BhY2VzW25zXS5jbGllbnRzLmdldChzb2NrZXRfaWQpO1xuICAgICAgc1tcIl9hdXRoZW50aWNhdGVkXCJdID0gdHJ1ZTtcbiAgICAgIHRoaXMubmFtZXNwYWNlc1tuc10uY2xpZW50cy5zZXQoc29ja2V0X2lkLCBzKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICByZXN1bHQ6IHJlc3BvbnNlLFxuICAgICAgaWQ6IG1lc3NhZ2UuaWRcbiAgICB9O1xuICB9XG4gIC8qKlxuICAqIEdlbmVyYXRlIGEgbmV3IG5hbWVzcGFjZSBzdG9yZS5cbiAgKiBBbHNvIHByZXJlZ2lzdGVyIHNvbWUgc3BlY2lhbCBuYW1lc3BhY2UgbWV0aG9kcy5cbiAgKiBAcHJpdmF0ZVxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gbmFtZXNwYWNlcyBpZGVudGlmaWVyXG4gICogQHJldHVybiB7dW5kZWZpbmVkfVxuICAqL1xuICBfZ2VuZXJhdGVOYW1lc3BhY2UobmFtZSkge1xuICAgIHRoaXMubmFtZXNwYWNlc1tuYW1lXSA9IHtcbiAgICAgIHJwY19tZXRob2RzOiB7XG4gICAgICAgIF9fbGlzdE1ldGhvZHM6IHtcbiAgICAgICAgICBmbjogKCkgPT4gT2JqZWN0LmtleXModGhpcy5uYW1lc3BhY2VzW25hbWVdLnJwY19tZXRob2RzKSxcbiAgICAgICAgICBwcm90ZWN0ZWQ6IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjbGllbnRzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgICAgZXZlbnRzOiB7fVxuICAgIH07XG4gIH1cbn07XG52YXIgUlBDX0VSUk9SUyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgWy0zMmUzLCBcIkV2ZW50IG5vdCBwcm92aWRlZFwiXSxcbiAgWy0zMjYwMCwgXCJJbnZhbGlkIFJlcXVlc3RcIl0sXG4gIFstMzI2MDEsIFwiTWV0aG9kIG5vdCBmb3VuZFwiXSxcbiAgWy0zMjYwMiwgXCJJbnZhbGlkIHBhcmFtc1wiXSxcbiAgWy0zMjYwMywgXCJJbnRlcm5hbCBlcnJvclwiXSxcbiAgWy0zMjYwNCwgXCJQYXJhbXMgbm90IGZvdW5kXCJdLFxuICBbLTMyNjA1LCBcIk1ldGhvZCBmb3JiaWRkZW5cIl0sXG4gIFstMzI2MDYsIFwiRXZlbnQgZm9yYmlkZGVuXCJdLFxuICBbLTMyNzAwLCBcIlBhcnNlIGVycm9yXCJdXG5dKTtcbmZ1bmN0aW9uIGNyZWF0ZUVycm9yKGNvZGUsIGRldGFpbHMpIHtcbiAgY29uc3QgZXJyb3IgPSB7XG4gICAgY29kZSxcbiAgICBtZXNzYWdlOiBSUENfRVJST1JTLmdldChjb2RlKSB8fCBcIkludGVybmFsIFNlcnZlciBFcnJvclwiXG4gIH07XG4gIGlmIChkZXRhaWxzKSBlcnJvcltcImRhdGFcIl0gPSBkZXRhaWxzO1xuICByZXR1cm4gZXJyb3I7XG59XG5cbi8vIHNyYy9pbmRleC50c1xudmFyIENsaWVudCA9IGNsYXNzIGV4dGVuZHMgQ29tbW9uQ2xpZW50IHtcbiAgY29uc3RydWN0b3IoYWRkcmVzcyA9IFwid3M6Ly9sb2NhbGhvc3Q6ODA4MFwiLCB7XG4gICAgYXV0b2Nvbm5lY3QgPSB0cnVlLFxuICAgIHJlY29ubmVjdCA9IHRydWUsXG4gICAgcmVjb25uZWN0X2ludGVydmFsID0gMWUzLFxuICAgIG1heF9yZWNvbm5lY3RzID0gNSxcbiAgICAuLi5yZXN0X29wdGlvbnNcbiAgfSA9IHt9LCBnZW5lcmF0ZV9yZXF1ZXN0X2lkKSB7XG4gICAgc3VwZXIoXG4gICAgICBXZWJTb2NrZXQsXG4gICAgICBhZGRyZXNzLFxuICAgICAge1xuICAgICAgICBhdXRvY29ubmVjdCxcbiAgICAgICAgcmVjb25uZWN0LFxuICAgICAgICByZWNvbm5lY3RfaW50ZXJ2YWwsXG4gICAgICAgIG1heF9yZWNvbm5lY3RzLFxuICAgICAgICAuLi5yZXN0X29wdGlvbnNcbiAgICAgIH0sXG4gICAgICBnZW5lcmF0ZV9yZXF1ZXN0X2lkXG4gICAgKTtcbiAgfVxufTtcblxuZXhwb3J0IHsgQ2xpZW50LCBDb21tb25DbGllbnQsIERlZmF1bHREYXRhUGFjaywgU2VydmVyLCBXZWJTb2NrZXQsIGNyZWF0ZUVycm9yIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbIldlYlNvY2tldEltcGwiLCJXZWJTb2NrZXRTZXJ2ZXIiLCJFdmVudEVtaXR0ZXIiLCJ1cmwiLCJ2MSIsIldlYlNvY2tldCIsImFkZHJlc3MiLCJvcHRpb25zIiwiRGVmYXVsdERhdGFQYWNrIiwiZW5jb2RlIiwidmFsdWUiLCJKU09OIiwic3RyaW5naWZ5IiwiZGVjb2RlIiwicGFyc2UiLCJDb21tb25DbGllbnQiLCJjb25zdHJ1Y3RvciIsIndlYlNvY2tldEZhY3RvcnkiLCJhdXRvY29ubmVjdCIsInJlY29ubmVjdCIsInJlY29ubmVjdF9pbnRlcnZhbCIsIm1heF9yZWNvbm5lY3RzIiwicmVzdF9vcHRpb25zIiwiZ2VuZXJhdGVfcmVxdWVzdF9pZCIsImRhdGFQYWNrIiwicXVldWUiLCJycGNfaWQiLCJyZWFkeSIsInJlY29ubmVjdF90aW1lcl9pZCIsImN1cnJlbnRfcmVjb25uZWN0cyIsIk51bWJlciIsIl9jb25uZWN0IiwiY29ubmVjdCIsInNvY2tldCIsImNhbGwiLCJtZXRob2QiLCJwYXJhbXMiLCJ0aW1lb3V0Iiwid3Nfb3B0cyIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiRXJyb3IiLCJtZXNzYWdlIiwianNvbnJwYyIsImlkIiwic2VuZCIsImVycm9yIiwicHJvbWlzZSIsInNldFRpbWVvdXQiLCJsb2dpbiIsInJlc3AiLCJsaXN0TWV0aG9kcyIsIm5vdGlmeSIsInN1YnNjcmliZSIsImV2ZW50IiwicmVzdWx0IiwidW5zdWJzY3JpYmUiLCJjbG9zZSIsImNvZGUiLCJkYXRhIiwic2V0QXV0b1JlY29ubmVjdCIsInNldFJlY29ubmVjdEludGVydmFsIiwiaW50ZXJ2YWwiLCJzZXRNYXhSZWNvbm5lY3RzIiwiZ2V0Q3VycmVudFJlY29ubmVjdHMiLCJnZXRNYXhSZWNvbm5lY3RzIiwiaXNSZWNvbm5lY3RpbmciLCJ3aWxsUmVjb25uZWN0IiwiY2xlYXJUaW1lb3V0IiwiYWRkRXZlbnRMaXN0ZW5lciIsImVtaXQiLCJBcnJheUJ1ZmZlciIsIkJ1ZmZlciIsImZyb20iLCJ0b1N0cmluZyIsIm5vdGlmaWNhdGlvbiIsImxpc3RlbmVycyIsImxlbmd0aCIsIk9iamVjdCIsImtleXMiLCJhcmdzIiwicHVzaCIsImkiLCJ0aGVuIiwiYXBwbHkiLCJyZWFzb24iLCJTZXJ2ZXIiLCJuYW1lc3BhY2VzIiwid3NzIiwib24iLCJyZXF1ZXN0IiwidSIsIm5zIiwicGF0aG5hbWUiLCJxdWVyeSIsInNvY2tldF9pZCIsIl9pZCIsImNsaWVudHMiLCJkZWxldGUiLCJldmVudHMiLCJpbmRleCIsInNvY2tldHMiLCJpbmRleE9mIiwic3BsaWNlIiwiX2dlbmVyYXRlTmFtZXNwYWNlIiwic2V0IiwiX2hhbmRsZVJQQyIsInJlZ2lzdGVyIiwibmFtZSIsImZuIiwicnBjX21ldGhvZHMiLCJwcm90ZWN0ZWQiLCJfbWFrZVByb3RlY3RlZE1ldGhvZCIsInB1YmxpYyIsIl9tYWtlUHVibGljTWV0aG9kIiwic2V0QXV0aCIsIl9tYWtlUHJvdGVjdGVkRXZlbnQiLCJfbWFrZVB1YmxpY0V2ZW50IiwiY2xvc2VOYW1lc3BhY2UiLCJuYW1lc3BhY2UiLCJ2YWx1ZXMiLCJnZXQiLCJvZiIsInNlbGYiLCJmbl9uYW1lIiwiYXJndW1lbnRzIiwiZXZfbmFtZSIsImV2ZW50TGlzdCIsIm5zRXZlbnQiLCJjb25uZWN0ZWQiLCJzb2NrZXRfaWRzIiwicmVkdWNlIiwiYWNjIiwiY3VyciIsImNyZWF0ZUVycm9yIiwibXNnX29wdGlvbnMiLCJiaW5hcnkiLCJyZWFkeVN0YXRlIiwicGFyc2VkRGF0YSIsIkFycmF5IiwiaXNBcnJheSIsInJlc3BvbnNlcyIsInJlc3BvbnNlMiIsIl9ydW5NZXRob2QiLCJyZXNwb25zZSIsInJlc3VsdHMiLCJldmVudF9uYW1lcyIsInNvY2tldF9pbmRleCIsInMiLCJfX2xpc3RNZXRob2RzIiwiTWFwIiwiUlBDX0VSUk9SUyIsImRldGFpbHMiLCJDbGllbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/rpc-websockets/dist/index.mjs\n");

/***/ })

};
;