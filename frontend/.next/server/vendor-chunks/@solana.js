"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@solana";
exports.ids = ["vendor-chunks/@solana"];
exports.modules = {

/***/ "(ssr)/./node_modules/@solana/buffer-layout/lib/Layout.js":
/*!**********************************************************!*\
  !*** ./node_modules/@solana/buffer-layout/lib/Layout.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* The MIT License (MIT)\n *\n * Copyright 2015-2018 Peter A. Bigot\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */ /**\n * Support for translating between Uint8Array instances and JavaScript\n * native types.\n *\n * {@link module:Layout~Layout|Layout} is the basis of a class\n * hierarchy that associates property names with sequences of encoded\n * bytes.\n *\n * Layouts are supported for these scalar (numeric) types:\n * * {@link module:Layout~UInt|Unsigned integers in little-endian\n *   format} with {@link module:Layout.u8|8-bit}, {@link\n *   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},\n *   {@link module:Layout.u32|32-bit}, {@link\n *   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}\n *   representation ranges;\n * * {@link module:Layout~UIntBE|Unsigned integers in big-endian\n *   format} with {@link module:Layout.u16be|16-bit}, {@link\n *   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},\n *   {@link module:Layout.u40be|40-bit}, and {@link\n *   module:Layout.u48be|48-bit} representation ranges;\n * * {@link module:Layout~Int|Signed integers in little-endian\n *   format} with {@link module:Layout.s8|8-bit}, {@link\n *   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},\n *   {@link module:Layout.s32|32-bit}, {@link\n *   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}\n *   representation ranges;\n * * {@link module:Layout~IntBE|Signed integers in big-endian format}\n *   with {@link module:Layout.s16be|16-bit}, {@link\n *   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},\n *   {@link module:Layout.s40be|40-bit}, and {@link\n *   module:Layout.s48be|48-bit} representation ranges;\n * * 64-bit integral values that decode to an exact (if magnitude is\n *   less than 2^53) or nearby integral Number in {@link\n *   module:Layout.nu64|unsigned little-endian}, {@link\n *   module:Layout.nu64be|unsigned big-endian}, {@link\n *   module:Layout.ns64|signed little-endian}, and {@link\n *   module:Layout.ns64be|unsigned big-endian} encodings;\n * * 32-bit floating point values with {@link\n *   module:Layout.f32|little-endian} and {@link\n *   module:Layout.f32be|big-endian} representations;\n * * 64-bit floating point values with {@link\n *   module:Layout.f64|little-endian} and {@link\n *   module:Layout.f64be|big-endian} representations;\n * * {@link module:Layout.const|Constants} that take no space in the\n *   encoded expression.\n *\n * and for these aggregate types:\n * * {@link module:Layout.seq|Sequence}s of instances of a {@link\n *   module:Layout~Layout|Layout}, with JavaScript representation as\n *   an Array and constant or data-dependent {@link\n *   module:Layout~Sequence#count|length};\n * * {@link module:Layout.struct|Structure}s that aggregate a\n *   heterogeneous sequence of {@link module:Layout~Layout|Layout}\n *   instances, with JavaScript representation as an Object;\n * * {@link module:Layout.union|Union}s that support multiple {@link\n *   module:Layout~VariantLayout|variant layouts} over a fixed\n *   (padded) or variable (not padded) span of bytes, using an\n *   unsigned integer at the start of the data or a separate {@link\n *   module:Layout.unionLayoutDiscriminator|layout element} to\n *   determine which layout to use when interpreting the buffer\n *   contents;\n * * {@link module:Layout.bits|BitStructure}s that contain a sequence\n *   of individual {@link\n *   module:Layout~BitStructure#addField|BitField}s packed into an 8,\n *   16, 24, or 32-bit unsigned integer starting at the least- or\n *   most-significant bit;\n * * {@link module:Layout.cstr|C strings} of varying length;\n * * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link\n *   module:Layout~Blob#length|length} raw data.\n *\n * All {@link module:Layout~Layout|Layout} instances are immutable\n * after construction, to prevent internal state from becoming\n * inconsistent.\n *\n * @local Layout\n * @local ExternalLayout\n * @local GreedyCount\n * @local OffsetLayout\n * @local UInt\n * @local UIntBE\n * @local Int\n * @local IntBE\n * @local NearUInt64\n * @local NearUInt64BE\n * @local NearInt64\n * @local NearInt64BE\n * @local Float\n * @local FloatBE\n * @local Double\n * @local DoubleBE\n * @local Sequence\n * @local Structure\n * @local UnionDiscriminator\n * @local UnionLayoutDiscriminator\n * @local Union\n * @local VariantLayout\n * @local BitStructure\n * @local BitField\n * @local Boolean\n * @local Blob\n * @local CString\n * @local Constant\n * @local bindConstructorLayout\n * @module Layout\n * @license MIT\n * @author Peter A. Bigot\n * @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}\n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.s16 = exports.s8 = exports.nu64be = exports.u48be = exports.u40be = exports.u32be = exports.u24be = exports.u16be = exports.nu64 = exports.u48 = exports.u40 = exports.u32 = exports.u24 = exports.u16 = exports.u8 = exports.offset = exports.greedy = exports.Constant = exports.UTF8 = exports.CString = exports.Blob = exports.Boolean = exports.BitField = exports.BitStructure = exports.VariantLayout = exports.Union = exports.UnionLayoutDiscriminator = exports.UnionDiscriminator = exports.Structure = exports.Sequence = exports.DoubleBE = exports.Double = exports.FloatBE = exports.Float = exports.NearInt64BE = exports.NearInt64 = exports.NearUInt64BE = exports.NearUInt64 = exports.IntBE = exports.Int = exports.UIntBE = exports.UInt = exports.OffsetLayout = exports.GreedyCount = exports.ExternalLayout = exports.bindConstructorLayout = exports.nameWithProperty = exports.Layout = exports.uint8ArrayToBuffer = exports.checkUint8Array = void 0;\nexports.constant = exports.utf8 = exports.cstr = exports.blob = exports.unionLayoutDiscriminator = exports.union = exports.seq = exports.bits = exports.struct = exports.f64be = exports.f64 = exports.f32be = exports.f32 = exports.ns64be = exports.s48be = exports.s40be = exports.s32be = exports.s24be = exports.s16be = exports.ns64 = exports.s48 = exports.s40 = exports.s32 = exports.s24 = void 0;\nconst buffer_1 = __webpack_require__(/*! buffer */ \"buffer\");\n/* Check if a value is a Uint8Array.\n *\n * @ignore */ function checkUint8Array(b) {\n    if (!(b instanceof Uint8Array)) {\n        throw new TypeError(\"b must be a Uint8Array\");\n    }\n}\nexports.checkUint8Array = checkUint8Array;\n/* Create a Buffer instance from a Uint8Array.\n *\n * @ignore */ function uint8ArrayToBuffer(b) {\n    checkUint8Array(b);\n    return buffer_1.Buffer.from(b.buffer, b.byteOffset, b.length);\n}\nexports.uint8ArrayToBuffer = uint8ArrayToBuffer;\n/**\n * Base class for layout objects.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support the {@link\n * Layout#encode|encode} or {@link Layout#decode|decode} functions.\n *\n * @param {Number} span - Initializer for {@link Layout#span|span}.  The\n * parameter must be an integer; a negative value signifies that the\n * span is {@link Layout#getSpan|value-specific}.\n *\n * @param {string} [property] - Initializer for {@link\n * Layout#property|property}.\n *\n * @abstract\n */ class Layout {\n    constructor(span, property){\n        if (!Number.isInteger(span)) {\n            throw new TypeError(\"span must be an integer\");\n        }\n        /** The span of the layout in bytes.\n         *\n         * Positive values are generally expected.\n         *\n         * Zero will only appear in {@link Constant}s and in {@link\n         * Sequence}s where the {@link Sequence#count|count} is zero.\n         *\n         * A negative value indicates that the span is value-specific, and\n         * must be obtained using {@link Layout#getSpan|getSpan}. */ this.span = span;\n        /** The property name used when this layout is represented in an\n         * Object.\n         *\n         * Used only for layouts that {@link Layout#decode|decode} to Object\n         * instances.  If left undefined the span of the unnamed layout will\n         * be treated as padding: it will not be mutated by {@link\n         * Layout#encode|encode} nor represented as a property in the\n         * decoded Object. */ this.property = property;\n    }\n    /** Function to create an Object into which decoded properties will\n     * be written.\n     *\n     * Used only for layouts that {@link Layout#decode|decode} to Object\n     * instances, which means:\n     * * {@link Structure}\n     * * {@link Union}\n     * * {@link VariantLayout}\n     * * {@link BitStructure}\n     *\n     * If left undefined the JavaScript representation of these layouts\n     * will be Object instances.\n     *\n     * See {@link bindConstructorLayout}.\n     */ makeDestinationObject() {\n        return {};\n    }\n    /**\n     * Calculate the span of a specific instance of a layout.\n     *\n     * @param {Uint8Array} b - the buffer that contains an encoded instance.\n     *\n     * @param {Number} [offset] - the offset at which the encoded instance\n     * starts.  If absent a zero offset is inferred.\n     *\n     * @return {Number} - the number of bytes covered by the layout\n     * instance.  If this method is not overridden in a subclass the\n     * definition-time constant {@link Layout#span|span} will be\n     * returned.\n     *\n     * @throws {RangeError} - if the length of the value cannot be\n     * determined.\n     */ getSpan(b, offset) {\n        if (0 > this.span) {\n            throw new RangeError(\"indeterminate span\");\n        }\n        return this.span;\n    }\n    /**\n     * Replicate the layout using a new property.\n     *\n     * This function must be used to get a structurally-equivalent layout\n     * with a different name since all {@link Layout} instances are\n     * immutable.\n     *\n     * **NOTE** This is a shallow copy.  All fields except {@link\n     * Layout#property|property} are strictly equal to the origin layout.\n     *\n     * @param {String} property - the value for {@link\n     * Layout#property|property} in the replica.\n     *\n     * @returns {Layout} - the copy with {@link Layout#property|property}\n     * set to `property`.\n     */ replicate(property) {\n        const rv = Object.create(this.constructor.prototype);\n        Object.assign(rv, this);\n        rv.property = property;\n        return rv;\n    }\n    /**\n     * Create an object from layout properties and an array of values.\n     *\n     * **NOTE** This function returns `undefined` if invoked on a layout\n     * that does not return its value as an Object.  Objects are\n     * returned for things that are a {@link Structure}, which includes\n     * {@link VariantLayout|variant layouts} if they are structures, and\n     * excludes {@link Union}s.  If you want this feature for a union\n     * you must use {@link Union.getVariant|getVariant} to select the\n     * desired layout.\n     *\n     * @param {Array} values - an array of values that correspond to the\n     * default order for properties.  As with {@link Layout#decode|decode}\n     * layout elements that have no property name are skipped when\n     * iterating over the array values.  Only the top-level properties are\n     * assigned; arguments are not assigned to properties of contained\n     * layouts.  Any unused values are ignored.\n     *\n     * @return {(Object|undefined)}\n     */ fromArray(values) {\n        return undefined;\n    }\n}\nexports.Layout = Layout;\n/* Provide text that carries a name (such as for a function that will\n * be throwing an error) annotated with the property of a given layout\n * (such as one for which the value was unacceptable).\n *\n * @ignore */ function nameWithProperty(name, lo) {\n    if (lo.property) {\n        return name + \"[\" + lo.property + \"]\";\n    }\n    return name;\n}\nexports.nameWithProperty = nameWithProperty;\n/**\n * Augment a class so that instances can be encoded/decoded using a\n * given layout.\n *\n * Calling this function couples `Class` with `layout` in several ways:\n *\n * * `Class.layout_` becomes a static member property equal to `layout`;\n * * `layout.boundConstructor_` becomes a static member property equal\n *    to `Class`;\n * * The {@link Layout#makeDestinationObject|makeDestinationObject()}\n *   property of `layout` is set to a function that returns a `new\n *   Class()`;\n * * `Class.decode(b, offset)` becomes a static member function that\n *   delegates to {@link Layout#decode|layout.decode}.  The\n *   synthesized function may be captured and extended.\n * * `Class.prototype.encode(b, offset)` provides an instance member\n *   function that delegates to {@link Layout#encode|layout.encode}\n *   with `src` set to `this`.  The synthesized function may be\n *   captured and extended, but when the extension is invoked `this`\n *   must be explicitly bound to the instance.\n *\n * @param {class} Class - a JavaScript class with a nullary\n * constructor.\n *\n * @param {Layout} layout - the {@link Layout} instance used to encode\n * instances of `Class`.\n */ // `Class` must be a constructor Function, but the assignment of a `layout_` property to it makes it difficult to type\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction bindConstructorLayout(Class, layout) {\n    if (\"function\" !== typeof Class) {\n        throw new TypeError(\"Class must be constructor\");\n    }\n    if (Object.prototype.hasOwnProperty.call(Class, \"layout_\")) {\n        throw new Error(\"Class is already bound to a layout\");\n    }\n    if (!(layout && layout instanceof Layout)) {\n        throw new TypeError(\"layout must be a Layout\");\n    }\n    if (Object.prototype.hasOwnProperty.call(layout, \"boundConstructor_\")) {\n        throw new Error(\"layout is already bound to a constructor\");\n    }\n    Class.layout_ = layout;\n    layout.boundConstructor_ = Class;\n    layout.makeDestinationObject = ()=>new Class();\n    Object.defineProperty(Class.prototype, \"encode\", {\n        value (b, offset) {\n            return layout.encode(this, b, offset);\n        },\n        writable: true\n    });\n    Object.defineProperty(Class, \"decode\", {\n        value (b, offset) {\n            return layout.decode(b, offset);\n        },\n        writable: true\n    });\n}\nexports.bindConstructorLayout = bindConstructorLayout;\n/**\n * An object that behaves like a layout but does not consume space\n * within its containing layout.\n *\n * This is primarily used to obtain metadata about a member, such as a\n * {@link OffsetLayout} that can provide data about a {@link\n * Layout#getSpan|value-specific span}.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support {@link\n * ExternalLayout#isCount|isCount} or other {@link Layout} functions.\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @abstract\n * @augments {Layout}\n */ class ExternalLayout extends Layout {\n    /**\n     * Return `true` iff the external layout decodes to an unsigned\n     * integer layout.\n     *\n     * In that case it can be used as the source of {@link\n     * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},\n     * or as {@link UnionLayoutDiscriminator#layout|external union\n     * discriminators}.\n     *\n     * @abstract\n     */ isCount() {\n        throw new Error(\"ExternalLayout is abstract\");\n    }\n}\nexports.ExternalLayout = ExternalLayout;\n/**\n * An {@link ExternalLayout} that determines its {@link\n * Layout#decode|value} based on offset into and length of the buffer\n * on which it is invoked.\n *\n * *Factory*: {@link module:Layout.greedy|greedy}\n *\n * @param {Number} [elementSpan] - initializer for {@link\n * GreedyCount#elementSpan|elementSpan}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {ExternalLayout}\n */ class GreedyCount extends ExternalLayout {\n    constructor(elementSpan = 1, property){\n        if (!Number.isInteger(elementSpan) || 0 >= elementSpan) {\n            throw new TypeError(\"elementSpan must be a (positive) integer\");\n        }\n        super(-1, property);\n        /** The layout for individual elements of the sequence.  The value\n         * must be a positive integer.  If not provided, the value will be\n         * 1. */ this.elementSpan = elementSpan;\n    }\n    /** @override */ isCount() {\n        return true;\n    }\n    /** @override */ decode(b, offset = 0) {\n        checkUint8Array(b);\n        const rem = b.length - offset;\n        return Math.floor(rem / this.elementSpan);\n    }\n    /** @override */ encode(src, b, offset) {\n        return 0;\n    }\n}\nexports.GreedyCount = GreedyCount;\n/**\n * An {@link ExternalLayout} that supports accessing a {@link Layout}\n * at a fixed offset from the start of another Layout.  The offset may\n * be before, within, or after the base layout.\n *\n * *Factory*: {@link module:Layout.offset|offset}\n *\n * @param {Layout} layout - initializer for {@link\n * OffsetLayout#layout|layout}, modulo `property`.\n *\n * @param {Number} [offset] - Initializes {@link\n * OffsetLayout#offset|offset}.  Defaults to zero.\n *\n * @param {string} [property] - Optional new property name for a\n * {@link Layout#replicate| replica} of `layout` to be used as {@link\n * OffsetLayout#layout|layout}.  If not provided the `layout` is used\n * unchanged.\n *\n * @augments {Layout}\n */ class OffsetLayout extends ExternalLayout {\n    constructor(layout, offset = 0, property){\n        if (!(layout instanceof Layout)) {\n            throw new TypeError(\"layout must be a Layout\");\n        }\n        if (!Number.isInteger(offset)) {\n            throw new TypeError(\"offset must be integer or undefined\");\n        }\n        super(layout.span, property || layout.property);\n        /** The subordinated layout. */ this.layout = layout;\n        /** The location of {@link OffsetLayout#layout} relative to the\n         * start of another layout.\n         *\n         * The value may be positive or negative, but an error will thrown\n         * if at the point of use it goes outside the span of the Uint8Array\n         * being accessed.  */ this.offset = offset;\n    }\n    /** @override */ isCount() {\n        return this.layout instanceof UInt || this.layout instanceof UIntBE;\n    }\n    /** @override */ decode(b, offset = 0) {\n        return this.layout.decode(b, offset + this.offset);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        return this.layout.encode(src, b, offset + this.offset);\n    }\n}\nexports.OffsetLayout = OffsetLayout;\n/**\n * Represent an unsigned integer in little-endian format.\n *\n * *Factory*: {@link module:Layout.u8|u8}, {@link\n *  module:Layout.u16|u16}, {@link module:Layout.u24|u24}, {@link\n *  module:Layout.u32|u32}, {@link module:Layout.u40|u40}, {@link\n *  module:Layout.u48|u48}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class UInt extends Layout {\n    constructor(span, property){\n        super(span, property);\n        if (6 < this.span) {\n            throw new RangeError(\"span must not exceed 6 bytes\");\n        }\n    }\n    /** @override */ decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readUIntLE(offset, this.span);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeUIntLE(src, offset, this.span);\n        return this.span;\n    }\n}\nexports.UInt = UInt;\n/**\n * Represent an unsigned integer in big-endian format.\n *\n * *Factory*: {@link module:Layout.u8be|u8be}, {@link\n * module:Layout.u16be|u16be}, {@link module:Layout.u24be|u24be},\n * {@link module:Layout.u32be|u32be}, {@link\n * module:Layout.u40be|u40be}, {@link module:Layout.u48be|u48be}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class UIntBE extends Layout {\n    constructor(span, property){\n        super(span, property);\n        if (6 < this.span) {\n            throw new RangeError(\"span must not exceed 6 bytes\");\n        }\n    }\n    /** @override */ decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readUIntBE(offset, this.span);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeUIntBE(src, offset, this.span);\n        return this.span;\n    }\n}\nexports.UIntBE = UIntBE;\n/**\n * Represent a signed integer in little-endian format.\n *\n * *Factory*: {@link module:Layout.s8|s8}, {@link\n *  module:Layout.s16|s16}, {@link module:Layout.s24|s24}, {@link\n *  module:Layout.s32|s32}, {@link module:Layout.s40|s40}, {@link\n *  module:Layout.s48|s48}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class Int extends Layout {\n    constructor(span, property){\n        super(span, property);\n        if (6 < this.span) {\n            throw new RangeError(\"span must not exceed 6 bytes\");\n        }\n    }\n    /** @override */ decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readIntLE(offset, this.span);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeIntLE(src, offset, this.span);\n        return this.span;\n    }\n}\nexports.Int = Int;\n/**\n * Represent a signed integer in big-endian format.\n *\n * *Factory*: {@link module:Layout.s8be|s8be}, {@link\n * module:Layout.s16be|s16be}, {@link module:Layout.s24be|s24be},\n * {@link module:Layout.s32be|s32be}, {@link\n * module:Layout.s40be|s40be}, {@link module:Layout.s48be|s48be}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class IntBE extends Layout {\n    constructor(span, property){\n        super(span, property);\n        if (6 < this.span) {\n            throw new RangeError(\"span must not exceed 6 bytes\");\n        }\n    }\n    /** @override */ decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readIntBE(offset, this.span);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeIntBE(src, offset, this.span);\n        return this.span;\n    }\n}\nexports.IntBE = IntBE;\nconst V2E32 = Math.pow(2, 32);\n/* True modulus high and low 32-bit words, where low word is always\n * non-negative. */ function divmodInt64(src) {\n    const hi32 = Math.floor(src / V2E32);\n    const lo32 = src - hi32 * V2E32;\n    return {\n        hi32,\n        lo32\n    };\n}\n/* Reconstruct Number from quotient and non-negative remainder */ function roundedInt64(hi32, lo32) {\n    return hi32 * V2E32 + lo32;\n}\n/**\n * Represent an unsigned 64-bit integer in little-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.nu64|nu64}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */ class NearUInt64 extends Layout {\n    constructor(property){\n        super(8, property);\n    }\n    /** @override */ decode(b, offset = 0) {\n        const buffer = uint8ArrayToBuffer(b);\n        const lo32 = buffer.readUInt32LE(offset);\n        const hi32 = buffer.readUInt32LE(offset + 4);\n        return roundedInt64(hi32, lo32);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        const split = divmodInt64(src);\n        const buffer = uint8ArrayToBuffer(b);\n        buffer.writeUInt32LE(split.lo32, offset);\n        buffer.writeUInt32LE(split.hi32, offset + 4);\n        return 8;\n    }\n}\nexports.NearUInt64 = NearUInt64;\n/**\n * Represent an unsigned 64-bit integer in big-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.nu64be|nu64be}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */ class NearUInt64BE extends Layout {\n    constructor(property){\n        super(8, property);\n    }\n    /** @override */ decode(b, offset = 0) {\n        const buffer = uint8ArrayToBuffer(b);\n        const hi32 = buffer.readUInt32BE(offset);\n        const lo32 = buffer.readUInt32BE(offset + 4);\n        return roundedInt64(hi32, lo32);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        const split = divmodInt64(src);\n        const buffer = uint8ArrayToBuffer(b);\n        buffer.writeUInt32BE(split.hi32, offset);\n        buffer.writeUInt32BE(split.lo32, offset + 4);\n        return 8;\n    }\n}\nexports.NearUInt64BE = NearUInt64BE;\n/**\n * Represent a signed 64-bit integer in little-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.ns64|ns64}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */ class NearInt64 extends Layout {\n    constructor(property){\n        super(8, property);\n    }\n    /** @override */ decode(b, offset = 0) {\n        const buffer = uint8ArrayToBuffer(b);\n        const lo32 = buffer.readUInt32LE(offset);\n        const hi32 = buffer.readInt32LE(offset + 4);\n        return roundedInt64(hi32, lo32);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        const split = divmodInt64(src);\n        const buffer = uint8ArrayToBuffer(b);\n        buffer.writeUInt32LE(split.lo32, offset);\n        buffer.writeInt32LE(split.hi32, offset + 4);\n        return 8;\n    }\n}\nexports.NearInt64 = NearInt64;\n/**\n * Represent a signed 64-bit integer in big-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.ns64be|ns64be}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */ class NearInt64BE extends Layout {\n    constructor(property){\n        super(8, property);\n    }\n    /** @override */ decode(b, offset = 0) {\n        const buffer = uint8ArrayToBuffer(b);\n        const hi32 = buffer.readInt32BE(offset);\n        const lo32 = buffer.readUInt32BE(offset + 4);\n        return roundedInt64(hi32, lo32);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        const split = divmodInt64(src);\n        const buffer = uint8ArrayToBuffer(b);\n        buffer.writeInt32BE(split.hi32, offset);\n        buffer.writeUInt32BE(split.lo32, offset + 4);\n        return 8;\n    }\n}\nexports.NearInt64BE = NearInt64BE;\n/**\n * Represent a 32-bit floating point number in little-endian format.\n *\n * *Factory*: {@link module:Layout.f32|f32}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class Float extends Layout {\n    constructor(property){\n        super(4, property);\n    }\n    /** @override */ decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readFloatLE(offset);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeFloatLE(src, offset);\n        return 4;\n    }\n}\nexports.Float = Float;\n/**\n * Represent a 32-bit floating point number in big-endian format.\n *\n * *Factory*: {@link module:Layout.f32be|f32be}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class FloatBE extends Layout {\n    constructor(property){\n        super(4, property);\n    }\n    /** @override */ decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readFloatBE(offset);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeFloatBE(src, offset);\n        return 4;\n    }\n}\nexports.FloatBE = FloatBE;\n/**\n * Represent a 64-bit floating point number in little-endian format.\n *\n * *Factory*: {@link module:Layout.f64|f64}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class Double extends Layout {\n    constructor(property){\n        super(8, property);\n    }\n    /** @override */ decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readDoubleLE(offset);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeDoubleLE(src, offset);\n        return 8;\n    }\n}\nexports.Double = Double;\n/**\n * Represent a 64-bit floating point number in big-endian format.\n *\n * *Factory*: {@link module:Layout.f64be|f64be}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class DoubleBE extends Layout {\n    constructor(property){\n        super(8, property);\n    }\n    /** @override */ decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readDoubleBE(offset);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeDoubleBE(src, offset);\n        return 8;\n    }\n}\nexports.DoubleBE = DoubleBE;\n/**\n * Represent a contiguous sequence of a specific layout as an Array.\n *\n * *Factory*: {@link module:Layout.seq|seq}\n *\n * @param {Layout} elementLayout - initializer for {@link\n * Sequence#elementLayout|elementLayout}.\n *\n * @param {(Number|ExternalLayout)} count - initializer for {@link\n * Sequence#count|count}.  The parameter must be either a positive\n * integer or an instance of {@link ExternalLayout}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class Sequence extends Layout {\n    constructor(elementLayout, count, property){\n        if (!(elementLayout instanceof Layout)) {\n            throw new TypeError(\"elementLayout must be a Layout\");\n        }\n        if (!(count instanceof ExternalLayout && count.isCount() || Number.isInteger(count) && 0 <= count)) {\n            throw new TypeError(\"count must be non-negative integer \" + \"or an unsigned integer ExternalLayout\");\n        }\n        let span = -1;\n        if (!(count instanceof ExternalLayout) && 0 < elementLayout.span) {\n            span = count * elementLayout.span;\n        }\n        super(span, property);\n        /** The layout for individual elements of the sequence. */ this.elementLayout = elementLayout;\n        /** The number of elements in the sequence.\n         *\n         * This will be either a non-negative integer or an instance of\n         * {@link ExternalLayout} for which {@link\n         * ExternalLayout#isCount|isCount()} is `true`. */ this.count = count;\n    }\n    /** @override */ getSpan(b, offset = 0) {\n        if (0 <= this.span) {\n            return this.span;\n        }\n        let span = 0;\n        let count = this.count;\n        if (count instanceof ExternalLayout) {\n            count = count.decode(b, offset);\n        }\n        if (0 < this.elementLayout.span) {\n            span = count * this.elementLayout.span;\n        } else {\n            let idx = 0;\n            while(idx < count){\n                span += this.elementLayout.getSpan(b, offset + span);\n                ++idx;\n            }\n        }\n        return span;\n    }\n    /** @override */ decode(b, offset = 0) {\n        const rv = [];\n        let i = 0;\n        let count = this.count;\n        if (count instanceof ExternalLayout) {\n            count = count.decode(b, offset);\n        }\n        while(i < count){\n            rv.push(this.elementLayout.decode(b, offset));\n            offset += this.elementLayout.getSpan(b, offset);\n            i += 1;\n        }\n        return rv;\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Sequence}.\n     *\n     * **NOTE** If `src` is shorter than {@link Sequence#count|count} then\n     * the unused space in the buffer is left unchanged.  If `src` is\n     * longer than {@link Sequence#count|count} the unneeded elements are\n     * ignored.\n     *\n     * **NOTE** If {@link Layout#count|count} is an instance of {@link\n     * ExternalLayout} then the length of `src` will be encoded as the\n     * count after `src` is encoded. */ encode(src, b, offset = 0) {\n        const elo = this.elementLayout;\n        const span = src.reduce((span, v)=>{\n            return span + elo.encode(v, b, offset + span);\n        }, 0);\n        if (this.count instanceof ExternalLayout) {\n            this.count.encode(src.length, b, offset);\n        }\n        return span;\n    }\n}\nexports.Sequence = Sequence;\n/**\n * Represent a contiguous sequence of arbitrary layout elements as an\n * Object.\n *\n * *Factory*: {@link module:Layout.struct|struct}\n *\n * **NOTE** The {@link Layout#span|span} of the structure is variable\n * if any layout in {@link Structure#fields|fields} has a variable\n * span.  When {@link Layout#encode|encoding} we must have a value for\n * all variable-length fields, or we wouldn't be able to figure out\n * how much space to use for storage.  We can only identify the value\n * for a field when it has a {@link Layout#property|property}.  As\n * such, although a structure may contain both unnamed fields and\n * variable-length fields, it cannot contain an unnamed\n * variable-length field.\n *\n * @param {Layout[]} fields - initializer for {@link\n * Structure#fields|fields}.  An error is raised if this contains a\n * variable-length field for which a {@link Layout#property|property}\n * is not defined.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @param {Boolean} [decodePrefixes] - initializer for {@link\n * Structure#decodePrefixes|property}.\n *\n * @throws {Error} - if `fields` contains an unnamed variable-length\n * layout.\n *\n * @augments {Layout}\n */ class Structure extends Layout {\n    constructor(fields, property, decodePrefixes){\n        if (!(Array.isArray(fields) && fields.reduce((acc, v)=>acc && v instanceof Layout, true))) {\n            throw new TypeError(\"fields must be array of Layout instances\");\n        }\n        if (\"boolean\" === typeof property && undefined === decodePrefixes) {\n            decodePrefixes = property;\n            property = undefined;\n        }\n        /* Verify absence of unnamed variable-length fields. */ for (const fd of fields){\n            if (0 > fd.span && undefined === fd.property) {\n                throw new Error(\"fields cannot contain unnamed variable-length layout\");\n            }\n        }\n        let span = -1;\n        try {\n            span = fields.reduce((span, fd)=>span + fd.getSpan(), 0);\n        } catch (e) {\n        // ignore error\n        }\n        super(span, property);\n        /** The sequence of {@link Layout} values that comprise the\n         * structure.\n         *\n         * The individual elements need not be the same type, and may be\n         * either scalar or aggregate layouts.  If a member layout leaves\n         * its {@link Layout#property|property} undefined the\n         * corresponding region of the buffer associated with the element\n         * will not be mutated.\n         *\n         * @type {Layout[]} */ this.fields = fields;\n        /** Control behavior of {@link Layout#decode|decode()} given short\n         * buffers.\n         *\n         * In some situations a structure many be extended with additional\n         * fields over time, with older installations providing only a\n         * prefix of the full structure.  If this property is `true`\n         * decoding will accept those buffers and leave subsequent fields\n         * undefined, as long as the buffer ends at a field boundary.\n         * Defaults to `false`. */ this.decodePrefixes = !!decodePrefixes;\n    }\n    /** @override */ getSpan(b, offset = 0) {\n        if (0 <= this.span) {\n            return this.span;\n        }\n        let span = 0;\n        try {\n            span = this.fields.reduce((span, fd)=>{\n                const fsp = fd.getSpan(b, offset);\n                offset += fsp;\n                return span + fsp;\n            }, 0);\n        } catch (e) {\n            throw new RangeError(\"indeterminate span\");\n        }\n        return span;\n    }\n    /** @override */ decode(b, offset = 0) {\n        checkUint8Array(b);\n        const dest = this.makeDestinationObject();\n        for (const fd of this.fields){\n            if (undefined !== fd.property) {\n                dest[fd.property] = fd.decode(b, offset);\n            }\n            offset += fd.getSpan(b, offset);\n            if (this.decodePrefixes && b.length === offset) {\n                break;\n            }\n        }\n        return dest;\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Structure}.\n     *\n     * If `src` is missing a property for a member with a defined {@link\n     * Layout#property|property} the corresponding region of the buffer is\n     * left unmodified. */ encode(src, b, offset = 0) {\n        const firstOffset = offset;\n        let lastOffset = 0;\n        let lastWrote = 0;\n        for (const fd of this.fields){\n            let span = fd.span;\n            lastWrote = 0 < span ? span : 0;\n            if (undefined !== fd.property) {\n                const fv = src[fd.property];\n                if (undefined !== fv) {\n                    lastWrote = fd.encode(fv, b, offset);\n                    if (0 > span) {\n                        /* Read the as-encoded span, which is not necessarily the\n                         * same as what we wrote. */ span = fd.getSpan(b, offset);\n                    }\n                }\n            }\n            lastOffset = offset;\n            offset += span;\n        }\n        /* Use (lastOffset + lastWrote) instead of offset because the last\n         * item may have had a dynamic length and we don't want to include\n         * the padding between it and the end of the space reserved for\n         * it. */ return lastOffset + lastWrote - firstOffset;\n    }\n    /** @override */ fromArray(values) {\n        const dest = this.makeDestinationObject();\n        for (const fd of this.fields){\n            if (undefined !== fd.property && 0 < values.length) {\n                dest[fd.property] = values.shift();\n            }\n        }\n        return dest;\n    }\n    /**\n     * Get access to the layout of a given property.\n     *\n     * @param {String} property - the structure member of interest.\n     *\n     * @return {Layout} - the layout associated with `property`, or\n     * undefined if there is no such property.\n     */ layoutFor(property) {\n        if (\"string\" !== typeof property) {\n            throw new TypeError(\"property must be string\");\n        }\n        for (const fd of this.fields){\n            if (fd.property === property) {\n                return fd;\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Get the offset of a structure member.\n     *\n     * @param {String} property - the structure member of interest.\n     *\n     * @return {Number} - the offset in bytes to the start of `property`\n     * within the structure, or undefined if `property` is not a field\n     * within the structure.  If the property is a member but follows a\n     * variable-length structure member a negative number will be\n     * returned.\n     */ offsetOf(property) {\n        if (\"string\" !== typeof property) {\n            throw new TypeError(\"property must be string\");\n        }\n        let offset = 0;\n        for (const fd of this.fields){\n            if (fd.property === property) {\n                return offset;\n            }\n            if (0 > fd.span) {\n                offset = -1;\n            } else if (0 <= offset) {\n                offset += fd.span;\n            }\n        }\n        return undefined;\n    }\n}\nexports.Structure = Structure;\n/**\n * An object that can provide a {@link\n * Union#discriminator|discriminator} API for {@link Union}.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support the {@link\n * UnionDiscriminator#encode|encode} or {@link\n * UnionDiscriminator#decode|decode} functions.\n *\n * @param {string} [property] - Default for {@link\n * UnionDiscriminator#property|property}.\n *\n * @abstract\n */ class UnionDiscriminator {\n    constructor(property){\n        /** The {@link Layout#property|property} to be used when the\n         * discriminator is referenced in isolation (generally when {@link\n         * Union#decode|Union decode} cannot delegate to a specific\n         * variant). */ this.property = property;\n    }\n    /** Analog to {@link Layout#decode|Layout decode} for union discriminators.\n     *\n     * The implementation of this method need not reference the buffer if\n     * variant information is available through other means. */ decode(b, offset) {\n        throw new Error(\"UnionDiscriminator is abstract\");\n    }\n    /** Analog to {@link Layout#decode|Layout encode} for union discriminators.\n     *\n     * The implementation of this method need not store the value if\n     * variant information is maintained through other means. */ encode(src, b, offset) {\n        throw new Error(\"UnionDiscriminator is abstract\");\n    }\n}\nexports.UnionDiscriminator = UnionDiscriminator;\n/**\n * An object that can provide a {@link\n * UnionDiscriminator|discriminator API} for {@link Union} using an\n * unsigned integral {@link Layout} instance located either inside or\n * outside the union.\n *\n * @param {ExternalLayout} layout - initializes {@link\n * UnionLayoutDiscriminator#layout|layout}.  Must satisfy {@link\n * ExternalLayout#isCount|isCount()}.\n *\n * @param {string} [property] - Default for {@link\n * UnionDiscriminator#property|property}, superseding the property\n * from `layout`, but defaulting to `variant` if neither `property`\n * nor layout provide a property name.\n *\n * @augments {UnionDiscriminator}\n */ class UnionLayoutDiscriminator extends UnionDiscriminator {\n    constructor(layout, property){\n        if (!(layout instanceof ExternalLayout && layout.isCount())) {\n            throw new TypeError(\"layout must be an unsigned integer ExternalLayout\");\n        }\n        super(property || layout.property || \"variant\");\n        /** The {@link ExternalLayout} used to access the discriminator\n         * value. */ this.layout = layout;\n    }\n    /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */ decode(b, offset) {\n        return this.layout.decode(b, offset);\n    }\n    /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */ encode(src, b, offset) {\n        return this.layout.encode(src, b, offset);\n    }\n}\nexports.UnionLayoutDiscriminator = UnionLayoutDiscriminator;\n/**\n * Represent any number of span-compatible layouts.\n *\n * *Factory*: {@link module:Layout.union|union}\n *\n * If the union has a {@link Union#defaultLayout|default layout} that\n * layout must have a non-negative {@link Layout#span|span}.  The span\n * of a fixed-span union includes its {@link\n * Union#discriminator|discriminator} if the variant is a {@link\n * Union#usesPrefixDiscriminator|prefix of the union}, plus the span\n * of its {@link Union#defaultLayout|default layout}.\n *\n * If the union does not have a default layout then the encoded span\n * of the union depends on the encoded span of its variant (which may\n * be fixed or variable).\n *\n * {@link VariantLayout#layout|Variant layout}s are added through\n * {@link Union#addVariant|addVariant}.  If the union has a default\n * layout, the span of the {@link VariantLayout#layout|layout\n * contained by the variant} must not exceed the span of the {@link\n * Union#defaultLayout|default layout} (minus the span of a {@link\n * Union#usesPrefixDiscriminator|prefix disriminator}, if used).  The\n * span of the variant will equal the span of the union itself.\n *\n * The variant for a buffer can only be identified from the {@link\n * Union#discriminator|discriminator} {@link\n * UnionDiscriminator#property|property} (in the case of the {@link\n * Union#defaultLayout|default layout}), or by using {@link\n * Union#getVariant|getVariant} and examining the resulting {@link\n * VariantLayout} instance.\n *\n * A variant compatible with a JavaScript object can be identified\n * using {@link Union#getSourceVariant|getSourceVariant}.\n *\n * @param {(UnionDiscriminator|ExternalLayout|Layout)} discr - How to\n * identify the layout used to interpret the union contents.  The\n * parameter must be an instance of {@link UnionDiscriminator}, an\n * {@link ExternalLayout} that satisfies {@link\n * ExternalLayout#isCount|isCount()}, or {@link UInt} (or {@link\n * UIntBE}).  When a non-external layout element is passed the layout\n * appears at the start of the union.  In all cases the (synthesized)\n * {@link UnionDiscriminator} instance is recorded as {@link\n * Union#discriminator|discriminator}.\n *\n * @param {(Layout|null)} defaultLayout - initializer for {@link\n * Union#defaultLayout|defaultLayout}.  If absent defaults to `null`.\n * If `null` there is no default layout: the union has data-dependent\n * length and attempts to decode or encode unrecognized variants will\n * throw an exception.  A {@link Layout} instance must have a\n * non-negative {@link Layout#span|span}, and if it lacks a {@link\n * Layout#property|property} the {@link\n * Union#defaultLayout|defaultLayout} will be a {@link\n * Layout#replicate|replica} with property `content`.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class Union extends Layout {\n    constructor(discr, defaultLayout, property){\n        let discriminator;\n        if (discr instanceof UInt || discr instanceof UIntBE) {\n            discriminator = new UnionLayoutDiscriminator(new OffsetLayout(discr));\n        } else if (discr instanceof ExternalLayout && discr.isCount()) {\n            discriminator = new UnionLayoutDiscriminator(discr);\n        } else if (!(discr instanceof UnionDiscriminator)) {\n            throw new TypeError(\"discr must be a UnionDiscriminator \" + \"or an unsigned integer layout\");\n        } else {\n            discriminator = discr;\n        }\n        if (undefined === defaultLayout) {\n            defaultLayout = null;\n        }\n        if (!(null === defaultLayout || defaultLayout instanceof Layout)) {\n            throw new TypeError(\"defaultLayout must be null or a Layout\");\n        }\n        if (null !== defaultLayout) {\n            if (0 > defaultLayout.span) {\n                throw new Error(\"defaultLayout must have constant span\");\n            }\n            if (undefined === defaultLayout.property) {\n                defaultLayout = defaultLayout.replicate(\"content\");\n            }\n        }\n        /* The union span can be estimated only if there's a default\n         * layout.  The union spans its default layout, plus any prefix\n         * variant layout.  By construction both layouts, if present, have\n         * non-negative span. */ let span = -1;\n        if (defaultLayout) {\n            span = defaultLayout.span;\n            if (0 <= span && (discr instanceof UInt || discr instanceof UIntBE)) {\n                span += discriminator.layout.span;\n            }\n        }\n        super(span, property);\n        /** The interface for the discriminator value in isolation.\n         *\n         * This a {@link UnionDiscriminator} either passed to the\n         * constructor or synthesized from the `discr` constructor\n         * argument.  {@link\n         * Union#usesPrefixDiscriminator|usesPrefixDiscriminator} will be\n         * `true` iff the `discr` parameter was a non-offset {@link\n         * Layout} instance. */ this.discriminator = discriminator;\n        /** `true` if the {@link Union#discriminator|discriminator} is the\n         * first field in the union.\n         *\n         * If `false` the discriminator is obtained from somewhere\n         * else. */ this.usesPrefixDiscriminator = discr instanceof UInt || discr instanceof UIntBE;\n        /** The layout for non-discriminator content when the value of the\n         * discriminator is not recognized.\n         *\n         * This is the value passed to the constructor.  It is\n         * structurally equivalent to the second component of {@link\n         * Union#layout|layout} but may have a different property\n         * name. */ this.defaultLayout = defaultLayout;\n        /** A registry of allowed variants.\n         *\n         * The keys are unsigned integers which should be compatible with\n         * {@link Union.discriminator|discriminator}.  The property value\n         * is the corresponding {@link VariantLayout} instances assigned\n         * to this union by {@link Union#addVariant|addVariant}.\n         *\n         * **NOTE** The registry remains mutable so that variants can be\n         * {@link Union#addVariant|added} at any time.  Users should not\n         * manipulate the content of this property. */ this.registry = {};\n        /* Private variable used when invoking getSourceVariant */ let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);\n        /** Function to infer the variant selected by a source object.\n         *\n         * Defaults to {@link\n         * Union#defaultGetSourceVariant|defaultGetSourceVariant} but may\n         * be overridden using {@link\n         * Union#configGetSourceVariant|configGetSourceVariant}.\n         *\n         * @param {Object} src - as with {@link\n         * Union#defaultGetSourceVariant|defaultGetSourceVariant}.\n         *\n         * @returns {(undefined|VariantLayout)} The default variant\n         * (`undefined`) or first registered variant that uses a property\n         * available in `src`. */ this.getSourceVariant = function(src) {\n            return boundGetSourceVariant(src);\n        };\n        /** Function to override the implementation of {@link\n         * Union#getSourceVariant|getSourceVariant}.\n         *\n         * Use this if the desired variant cannot be identified using the\n         * algorithm of {@link\n         * Union#defaultGetSourceVariant|defaultGetSourceVariant}.\n         *\n         * **NOTE** The provided function will be invoked bound to this\n         * Union instance, providing local access to {@link\n         * Union#registry|registry}.\n         *\n         * @param {Function} gsv - a function that follows the API of\n         * {@link Union#defaultGetSourceVariant|defaultGetSourceVariant}. */ this.configGetSourceVariant = function(gsv) {\n            boundGetSourceVariant = gsv.bind(this);\n        };\n    }\n    /** @override */ getSpan(b, offset = 0) {\n        if (0 <= this.span) {\n            return this.span;\n        }\n        /* Default layouts always have non-negative span, so we don't have\n         * one and we have to recognize the variant which will in turn\n         * determine the span. */ const vlo = this.getVariant(b, offset);\n        if (!vlo) {\n            throw new Error(\"unable to determine span for unrecognized variant\");\n        }\n        return vlo.getSpan(b, offset);\n    }\n    /**\n     * Method to infer a registered Union variant compatible with `src`.\n     *\n     * The first satisfied rule in the following sequence defines the\n     * return value:\n     * * If `src` has properties matching the Union discriminator and\n     *   the default layout, `undefined` is returned regardless of the\n     *   value of the discriminator property (this ensures the default\n     *   layout will be used);\n     * * If `src` has a property matching the Union discriminator, the\n     *   value of the discriminator identifies a registered variant, and\n     *   either (a) the variant has no layout, or (b) `src` has the\n     *   variant's property, then the variant is returned (because the\n     *   source satisfies the constraints of the variant it identifies);\n     * * If `src` does not have a property matching the Union\n     *   discriminator, but does have a property matching a registered\n     *   variant, then the variant is returned (because the source\n     *   matches a variant without an explicit conflict);\n     * * An error is thrown (because we either can't identify a variant,\n     *   or we were explicitly told the variant but can't satisfy it).\n     *\n     * @param {Object} src - an object presumed to be compatible with\n     * the content of the Union.\n     *\n     * @return {(undefined|VariantLayout)} - as described above.\n     *\n     * @throws {Error} - if `src` cannot be associated with a default or\n     * registered variant.\n     */ defaultGetSourceVariant(src) {\n        if (Object.prototype.hasOwnProperty.call(src, this.discriminator.property)) {\n            if (this.defaultLayout && this.defaultLayout.property && Object.prototype.hasOwnProperty.call(src, this.defaultLayout.property)) {\n                return undefined;\n            }\n            const vlo = this.registry[src[this.discriminator.property]];\n            if (vlo && (!vlo.layout || vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property))) {\n                return vlo;\n            }\n        } else {\n            for(const tag in this.registry){\n                const vlo = this.registry[tag];\n                if (vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property)) {\n                    return vlo;\n                }\n            }\n        }\n        throw new Error(\"unable to infer src variant\");\n    }\n    /** Implement {@link Layout#decode|decode} for {@link Union}.\n     *\n     * If the variant is {@link Union#addVariant|registered} the return\n     * value is an instance of that variant, with no explicit\n     * discriminator.  Otherwise the {@link Union#defaultLayout|default\n     * layout} is used to decode the content. */ decode(b, offset = 0) {\n        let dest;\n        const dlo = this.discriminator;\n        const discr = dlo.decode(b, offset);\n        const clo = this.registry[discr];\n        if (undefined === clo) {\n            const defaultLayout = this.defaultLayout;\n            let contentOffset = 0;\n            if (this.usesPrefixDiscriminator) {\n                contentOffset = dlo.layout.span;\n            }\n            dest = this.makeDestinationObject();\n            dest[dlo.property] = discr;\n            // defaultLayout.property can be undefined, but this is allowed by buffer-layout\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            dest[defaultLayout.property] = defaultLayout.decode(b, offset + contentOffset);\n        } else {\n            dest = clo.decode(b, offset);\n        }\n        return dest;\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Union}.\n     *\n     * This API assumes the `src` object is consistent with the union's\n     * {@link Union#defaultLayout|default layout}.  To encode variants\n     * use the appropriate variant-specific {@link VariantLayout#encode}\n     * method. */ encode(src, b, offset = 0) {\n        const vlo = this.getSourceVariant(src);\n        if (undefined === vlo) {\n            const dlo = this.discriminator;\n            // this.defaultLayout is not undefined when vlo is undefined\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const clo = this.defaultLayout;\n            let contentOffset = 0;\n            if (this.usesPrefixDiscriminator) {\n                contentOffset = dlo.layout.span;\n            }\n            dlo.encode(src[dlo.property], b, offset);\n            // clo.property is not undefined when vlo is undefined\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            return contentOffset + clo.encode(src[clo.property], b, offset + contentOffset);\n        }\n        return vlo.encode(src, b, offset);\n    }\n    /** Register a new variant structure within a union.  The newly\n     * created variant is returned.\n     *\n     * @param {Number} variant - initializer for {@link\n     * VariantLayout#variant|variant}.\n     *\n     * @param {Layout} layout - initializer for {@link\n     * VariantLayout#layout|layout}.\n     *\n     * @param {String} property - initializer for {@link\n     * Layout#property|property}.\n     *\n     * @return {VariantLayout} */ addVariant(variant, layout, property) {\n        const rv = new VariantLayout(this, variant, layout, property);\n        this.registry[variant] = rv;\n        return rv;\n    }\n    /**\n     * Get the layout associated with a registered variant.\n     *\n     * If `vb` does not produce a registered variant the function returns\n     * `undefined`.\n     *\n     * @param {(Number|Uint8Array)} vb - either the variant number, or a\n     * buffer from which the discriminator is to be read.\n     *\n     * @param {Number} offset - offset into `vb` for the start of the\n     * union.  Used only when `vb` is an instance of {Uint8Array}.\n     *\n     * @return {({VariantLayout}|undefined)}\n     */ getVariant(vb, offset = 0) {\n        let variant;\n        if (vb instanceof Uint8Array) {\n            variant = this.discriminator.decode(vb, offset);\n        } else {\n            variant = vb;\n        }\n        return this.registry[variant];\n    }\n}\nexports.Union = Union;\n/**\n * Represent a specific variant within a containing union.\n *\n * **NOTE** The {@link Layout#span|span} of the variant may include\n * the span of the {@link Union#discriminator|discriminator} used to\n * identify it, but values read and written using the variant strictly\n * conform to the content of {@link VariantLayout#layout|layout}.\n *\n * **NOTE** User code should not invoke this constructor directly.  Use\n * the union {@link Union#addVariant|addVariant} helper method.\n *\n * @param {Union} union - initializer for {@link\n * VariantLayout#union|union}.\n *\n * @param {Number} variant - initializer for {@link\n * VariantLayout#variant|variant}.\n *\n * @param {Layout} [layout] - initializer for {@link\n * VariantLayout#layout|layout}.  If absent the variant carries no\n * data.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.  Unlike many other layouts, variant\n * layouts normally include a property name so they can be identified\n * within their containing {@link Union}.  The property identifier may\n * be absent only if `layout` is is absent.\n *\n * @augments {Layout}\n */ class VariantLayout extends Layout {\n    constructor(union, variant, layout, property){\n        if (!(union instanceof Union)) {\n            throw new TypeError(\"union must be a Union\");\n        }\n        if (!Number.isInteger(variant) || 0 > variant) {\n            throw new TypeError(\"variant must be a (non-negative) integer\");\n        }\n        if (\"string\" === typeof layout && undefined === property) {\n            property = layout;\n            layout = null;\n        }\n        if (layout) {\n            if (!(layout instanceof Layout)) {\n                throw new TypeError(\"layout must be a Layout\");\n            }\n            if (null !== union.defaultLayout && 0 <= layout.span && layout.span > union.defaultLayout.span) {\n                throw new Error(\"variant span exceeds span of containing union\");\n            }\n            if (\"string\" !== typeof property) {\n                throw new TypeError(\"variant must have a String property\");\n            }\n        }\n        let span = union.span;\n        if (0 > union.span) {\n            span = layout ? layout.span : 0;\n            if (0 <= span && union.usesPrefixDiscriminator) {\n                span += union.discriminator.layout.span;\n            }\n        }\n        super(span, property);\n        /** The {@link Union} to which this variant belongs. */ this.union = union;\n        /** The unsigned integral value identifying this variant within\n         * the {@link Union#discriminator|discriminator} of the containing\n         * union. */ this.variant = variant;\n        /** The {@link Layout} to be used when reading/writing the\n         * non-discriminator part of the {@link\n         * VariantLayout#union|union}.  If `null` the variant carries no\n         * data. */ this.layout = layout || null;\n    }\n    /** @override */ getSpan(b, offset = 0) {\n        if (0 <= this.span) {\n            /* Will be equal to the containing union span if that is not\n             * variable. */ return this.span;\n        }\n        let contentOffset = 0;\n        if (this.union.usesPrefixDiscriminator) {\n            contentOffset = this.union.discriminator.layout.span;\n        }\n        /* Span is defined solely by the variant (and prefix discriminator) */ let span = 0;\n        if (this.layout) {\n            span = this.layout.getSpan(b, offset + contentOffset);\n        }\n        return contentOffset + span;\n    }\n    /** @override */ decode(b, offset = 0) {\n        const dest = this.makeDestinationObject();\n        if (this !== this.union.getVariant(b, offset)) {\n            throw new Error(\"variant mismatch\");\n        }\n        let contentOffset = 0;\n        if (this.union.usesPrefixDiscriminator) {\n            contentOffset = this.union.discriminator.layout.span;\n        }\n        if (this.layout) {\n            dest[this.property] = this.layout.decode(b, offset + contentOffset);\n        } else if (this.property) {\n            dest[this.property] = true;\n        } else if (this.union.usesPrefixDiscriminator) {\n            dest[this.union.discriminator.property] = this.variant;\n        }\n        return dest;\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        let contentOffset = 0;\n        if (this.union.usesPrefixDiscriminator) {\n            contentOffset = this.union.discriminator.layout.span;\n        }\n        if (this.layout && !Object.prototype.hasOwnProperty.call(src, this.property)) {\n            throw new TypeError(\"variant lacks property \" + this.property);\n        }\n        this.union.discriminator.encode(this.variant, b, offset);\n        let span = contentOffset;\n        if (this.layout) {\n            this.layout.encode(src[this.property], b, offset + contentOffset);\n            span += this.layout.getSpan(b, offset + contentOffset);\n            if (0 <= this.union.span && span > this.union.span) {\n                throw new Error(\"encoded variant overruns containing union\");\n            }\n        }\n        return span;\n    }\n    /** Delegate {@link Layout#fromArray|fromArray} to {@link\n     * VariantLayout#layout|layout}. */ fromArray(values) {\n        if (this.layout) {\n            return this.layout.fromArray(values);\n        }\n        return undefined;\n    }\n}\nexports.VariantLayout = VariantLayout;\n/** JavaScript chose to define bitwise operations as operating on\n * signed 32-bit values in 2's complement form, meaning any integer\n * with bit 31 set is going to look negative.  For right shifts that's\n * not a problem, because `>>>` is a logical shift, but for every\n * other bitwise operator we have to compensate for possible negative\n * results. */ function fixBitwiseResult(v) {\n    if (0 > v) {\n        v += 0x100000000;\n    }\n    return v;\n}\n/**\n * Contain a sequence of bit fields as an unsigned integer.\n *\n * *Factory*: {@link module:Layout.bits|bits}\n *\n * This is a container element; within it there are {@link BitField}\n * instances that provide the extracted properties.  The container\n * simply defines the aggregate representation and its bit ordering.\n * The representation is an object containing properties with numeric\n * or {@link Boolean} values.\n *\n * {@link BitField}s are added with the {@link\n * BitStructure#addField|addField} and {@link\n * BitStructure#addBoolean|addBoolean} methods.\n\n * @param {Layout} word - initializer for {@link\n * BitStructure#word|word}.  The parameter must be an instance of\n * {@link UInt} (or {@link UIntBE}) that is no more than 4 bytes wide.\n *\n * @param {bool} [msb] - `true` if the bit numbering starts at the\n * most significant bit of the containing word; `false` (default) if\n * it starts at the least significant bit of the containing word.  If\n * the parameter at this position is a string and `property` is\n * `undefined` the value of this argument will instead be used as the\n * value of `property`.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class BitStructure extends Layout {\n    constructor(word, msb, property){\n        if (!(word instanceof UInt || word instanceof UIntBE)) {\n            throw new TypeError(\"word must be a UInt or UIntBE layout\");\n        }\n        if (\"string\" === typeof msb && undefined === property) {\n            property = msb;\n            msb = false;\n        }\n        if (4 < word.span) {\n            throw new RangeError(\"word cannot exceed 32 bits\");\n        }\n        super(word.span, property);\n        /** The layout used for the packed value.  {@link BitField}\n         * instances are packed sequentially depending on {@link\n         * BitStructure#msb|msb}. */ this.word = word;\n        /** Whether the bit sequences are packed starting at the most\n         * significant bit growing down (`true`), or the least significant\n         * bit growing up (`false`).\n         *\n         * **NOTE** Regardless of this value, the least significant bit of\n         * any {@link BitField} value is the least significant bit of the\n         * corresponding section of the packed value. */ this.msb = !!msb;\n        /** The sequence of {@link BitField} layouts that comprise the\n         * packed structure.\n         *\n         * **NOTE** The array remains mutable to allow fields to be {@link\n         * BitStructure#addField|added} after construction.  Users should\n         * not manipulate the content of this property.*/ this.fields = [];\n        /* Storage for the value.  Capture a variable instead of using an\n         * instance property because we don't want anything to change the\n         * value without going through the mutator. */ let value = 0;\n        this._packedSetValue = function(v) {\n            value = fixBitwiseResult(v);\n            return this;\n        };\n        this._packedGetValue = function() {\n            return value;\n        };\n    }\n    /** @override */ decode(b, offset = 0) {\n        const dest = this.makeDestinationObject();\n        const value = this.word.decode(b, offset);\n        this._packedSetValue(value);\n        for (const fd of this.fields){\n            if (undefined !== fd.property) {\n                dest[fd.property] = fd.decode(b);\n            }\n        }\n        return dest;\n    }\n    /** Implement {@link Layout#encode|encode} for {@link BitStructure}.\n     *\n     * If `src` is missing a property for a member with a defined {@link\n     * Layout#property|property} the corresponding region of the packed\n     * value is left unmodified.  Unused bits are also left unmodified. */ encode(src, b, offset = 0) {\n        const value = this.word.decode(b, offset);\n        this._packedSetValue(value);\n        for (const fd of this.fields){\n            if (undefined !== fd.property) {\n                const fv = src[fd.property];\n                if (undefined !== fv) {\n                    fd.encode(fv);\n                }\n            }\n        }\n        return this.word.encode(this._packedGetValue(), b, offset);\n    }\n    /** Register a new bitfield with a containing bit structure.  The\n     * resulting bitfield is returned.\n     *\n     * @param {Number} bits - initializer for {@link BitField#bits|bits}.\n     *\n     * @param {string} property - initializer for {@link\n     * Layout#property|property}.\n     *\n     * @return {BitField} */ addField(bits, property) {\n        const bf = new BitField(this, bits, property);\n        this.fields.push(bf);\n        return bf;\n    }\n    /** As with {@link BitStructure#addField|addField} for single-bit\n     * fields with `boolean` value representation.\n     *\n     * @param {string} property - initializer for {@link\n     * Layout#property|property}.\n     *\n     * @return {Boolean} */ // `Boolean` conflicts with the native primitive type\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    addBoolean(property) {\n        // This is my Boolean, not the Javascript one.\n        const bf = new Boolean(this, property);\n        this.fields.push(bf);\n        return bf;\n    }\n    /**\n     * Get access to the bit field for a given property.\n     *\n     * @param {String} property - the bit field of interest.\n     *\n     * @return {BitField} - the field associated with `property`, or\n     * undefined if there is no such property.\n     */ fieldFor(property) {\n        if (\"string\" !== typeof property) {\n            throw new TypeError(\"property must be string\");\n        }\n        for (const fd of this.fields){\n            if (fd.property === property) {\n                return fd;\n            }\n        }\n        return undefined;\n    }\n}\nexports.BitStructure = BitStructure;\n/**\n * Represent a sequence of bits within a {@link BitStructure}.\n *\n * All bit field values are represented as unsigned integers.\n *\n * **NOTE** User code should not invoke this constructor directly.\n * Use the container {@link BitStructure#addField|addField} helper\n * method.\n *\n * **NOTE** BitField instances are not instances of {@link Layout}\n * since {@link Layout#span|span} measures 8-bit units.\n *\n * @param {BitStructure} container - initializer for {@link\n * BitField#container|container}.\n *\n * @param {Number} bits - initializer for {@link BitField#bits|bits}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n */ class BitField {\n    constructor(container, bits, property){\n        if (!(container instanceof BitStructure)) {\n            throw new TypeError(\"container must be a BitStructure\");\n        }\n        if (!Number.isInteger(bits) || 0 >= bits) {\n            throw new TypeError(\"bits must be positive integer\");\n        }\n        const totalBits = 8 * container.span;\n        const usedBits = container.fields.reduce((sum, fd)=>sum + fd.bits, 0);\n        if (bits + usedBits > totalBits) {\n            throw new Error(\"bits too long for span remainder (\" + (totalBits - usedBits) + \" of \" + totalBits + \" remain)\");\n        }\n        /** The {@link BitStructure} instance to which this bit field\n         * belongs. */ this.container = container;\n        /** The span of this value in bits. */ this.bits = bits;\n        /** A mask of {@link BitField#bits|bits} bits isolating value bits\n         * that fit within the field.\n         *\n         * That is, it masks a value that has not yet been shifted into\n         * position within its containing packed integer. */ this.valueMask = (1 << bits) - 1;\n        if (32 === bits) {\n            this.valueMask = 0xFFFFFFFF;\n        }\n        /** The offset of the value within the containing packed unsigned\n         * integer.  The least significant bit of the packed value is at\n         * offset zero, regardless of bit ordering used. */ this.start = usedBits;\n        if (this.container.msb) {\n            this.start = totalBits - usedBits - bits;\n        }\n        /** A mask of {@link BitField#bits|bits} isolating the field value\n         * within the containing packed unsigned integer. */ this.wordMask = fixBitwiseResult(this.valueMask << this.start);\n        /** The property name used when this bitfield is represented in an\n         * Object.\n         *\n         * Intended to be functionally equivalent to {@link\n         * Layout#property}.\n         *\n         * If left undefined the corresponding span of bits will be\n         * treated as padding: it will not be mutated by {@link\n         * Layout#encode|encode} nor represented as a property in the\n         * decoded Object. */ this.property = property;\n    }\n    /** Store a value into the corresponding subsequence of the containing\n     * bit field. */ decode(b, offset) {\n        const word = this.container._packedGetValue();\n        const wordValue = fixBitwiseResult(word & this.wordMask);\n        const value = wordValue >>> this.start;\n        return value;\n    }\n    /** Store a value into the corresponding subsequence of the containing\n     * bit field.\n     *\n     * **NOTE** This is not a specialization of {@link\n     * Layout#encode|Layout.encode} and there is no return value. */ encode(value) {\n        if (\"number\" !== typeof value || !Number.isInteger(value) || value !== fixBitwiseResult(value & this.valueMask)) {\n            throw new TypeError(nameWithProperty(\"BitField.encode\", this) + \" value must be integer not exceeding \" + this.valueMask);\n        }\n        const word = this.container._packedGetValue();\n        const wordValue = fixBitwiseResult(value << this.start);\n        this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask) | wordValue);\n    }\n}\nexports.BitField = BitField;\n/**\n * Represent a single bit within a {@link BitStructure} as a\n * JavaScript boolean.\n *\n * **NOTE** User code should not invoke this constructor directly.\n * Use the container {@link BitStructure#addBoolean|addBoolean} helper\n * method.\n *\n * @param {BitStructure} container - initializer for {@link\n * BitField#container|container}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {BitField}\n */ /* eslint-disable no-extend-native */ class Boolean extends BitField {\n    constructor(container, property){\n        super(container, 1, property);\n    }\n    /** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.\n     *\n     * @returns {boolean} */ decode(b, offset) {\n        return !!super.decode(b, offset);\n    }\n    /** @override */ encode(value) {\n        if (\"boolean\" === typeof value) {\n            // BitField requires integer values\n            value = +value;\n        }\n        super.encode(value);\n    }\n}\nexports.Boolean = Boolean;\n/* eslint-enable no-extend-native */ /**\n * Contain a fixed-length block of arbitrary data, represented as a\n * Uint8Array.\n *\n * *Factory*: {@link module:Layout.blob|blob}\n *\n * @param {(Number|ExternalLayout)} length - initializes {@link\n * Blob#length|length}.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class Blob extends Layout {\n    constructor(length, property){\n        if (!(length instanceof ExternalLayout && length.isCount() || Number.isInteger(length) && 0 <= length)) {\n            throw new TypeError(\"length must be positive integer \" + \"or an unsigned integer ExternalLayout\");\n        }\n        let span = -1;\n        if (!(length instanceof ExternalLayout)) {\n            span = length;\n        }\n        super(span, property);\n        /** The number of bytes in the blob.\n         *\n         * This may be a non-negative integer, or an instance of {@link\n         * ExternalLayout} that satisfies {@link\n         * ExternalLayout#isCount|isCount()}. */ this.length = length;\n    }\n    /** @override */ getSpan(b, offset) {\n        let span = this.span;\n        if (0 > span) {\n            span = this.length.decode(b, offset);\n        }\n        return span;\n    }\n    /** @override */ decode(b, offset = 0) {\n        let span = this.span;\n        if (0 > span) {\n            span = this.length.decode(b, offset);\n        }\n        return uint8ArrayToBuffer(b).slice(offset, offset + span);\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Blob}.\n     *\n     * **NOTE** If {@link Layout#count|count} is an instance of {@link\n     * ExternalLayout} then the length of `src` will be encoded as the\n     * count after `src` is encoded. */ encode(src, b, offset) {\n        let span = this.length;\n        if (this.length instanceof ExternalLayout) {\n            span = src.length;\n        }\n        if (!(src instanceof Uint8Array && span === src.length)) {\n            throw new TypeError(nameWithProperty(\"Blob.encode\", this) + \" requires (length \" + span + \") Uint8Array as src\");\n        }\n        if (offset + span > b.length) {\n            throw new RangeError(\"encoding overruns Uint8Array\");\n        }\n        const srcBuffer = uint8ArrayToBuffer(src);\n        uint8ArrayToBuffer(b).write(srcBuffer.toString(\"hex\"), offset, span, \"hex\");\n        if (this.length instanceof ExternalLayout) {\n            this.length.encode(span, b, offset);\n        }\n        return span;\n    }\n}\nexports.Blob = Blob;\n/**\n * Contain a `NUL`-terminated UTF8 string.\n *\n * *Factory*: {@link module:Layout.cstr|cstr}\n *\n * **NOTE** Any UTF8 string that incorporates a zero-valued byte will\n * not be correctly decoded by this layout.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class CString extends Layout {\n    constructor(property){\n        super(-1, property);\n    }\n    /** @override */ getSpan(b, offset = 0) {\n        checkUint8Array(b);\n        let idx = offset;\n        while(idx < b.length && 0 !== b[idx]){\n            idx += 1;\n        }\n        return 1 + idx - offset;\n    }\n    /** @override */ decode(b, offset = 0) {\n        const span = this.getSpan(b, offset);\n        return uint8ArrayToBuffer(b).slice(offset, offset + span - 1).toString(\"utf-8\");\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        /* Must force this to a string, lest it be a number and the\n         * \"utf8-encoding\" below actually allocate a buffer of length\n         * src */ if (\"string\" !== typeof src) {\n            src = String(src);\n        }\n        const srcb = buffer_1.Buffer.from(src, \"utf8\");\n        const span = srcb.length;\n        if (offset + span > b.length) {\n            throw new RangeError(\"encoding overruns Buffer\");\n        }\n        const buffer = uint8ArrayToBuffer(b);\n        srcb.copy(buffer, offset);\n        buffer[offset + span] = 0;\n        return span + 1;\n    }\n}\nexports.CString = CString;\n/**\n * Contain a UTF8 string with implicit length.\n *\n * *Factory*: {@link module:Layout.utf8|utf8}\n *\n * **NOTE** Because the length is implicit in the size of the buffer\n * this layout should be used only in isolation, or in a situation\n * where the length can be expressed by operating on a slice of the\n * containing buffer.\n *\n * @param {Number} [maxSpan] - the maximum length allowed for encoded\n * string content.  If not provided there is no bound on the allowed\n * content.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class UTF8 extends Layout {\n    constructor(maxSpan, property){\n        if (\"string\" === typeof maxSpan && undefined === property) {\n            property = maxSpan;\n            maxSpan = undefined;\n        }\n        if (undefined === maxSpan) {\n            maxSpan = -1;\n        } else if (!Number.isInteger(maxSpan)) {\n            throw new TypeError(\"maxSpan must be an integer\");\n        }\n        super(-1, property);\n        /** The maximum span of the layout in bytes.\n         *\n         * Positive values are generally expected.  Zero is abnormal.\n         * Attempts to encode or decode a value that exceeds this length\n         * will throw a `RangeError`.\n         *\n         * A negative value indicates that there is no bound on the length\n         * of the content. */ this.maxSpan = maxSpan;\n    }\n    /** @override */ getSpan(b, offset = 0) {\n        checkUint8Array(b);\n        return b.length - offset;\n    }\n    /** @override */ decode(b, offset = 0) {\n        const span = this.getSpan(b, offset);\n        if (0 <= this.maxSpan && this.maxSpan < span) {\n            throw new RangeError(\"text length exceeds maxSpan\");\n        }\n        return uint8ArrayToBuffer(b).slice(offset, offset + span).toString(\"utf-8\");\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        /* Must force this to a string, lest it be a number and the\n         * \"utf8-encoding\" below actually allocate a buffer of length\n         * src */ if (\"string\" !== typeof src) {\n            src = String(src);\n        }\n        const srcb = buffer_1.Buffer.from(src, \"utf8\");\n        const span = srcb.length;\n        if (0 <= this.maxSpan && this.maxSpan < span) {\n            throw new RangeError(\"text length exceeds maxSpan\");\n        }\n        if (offset + span > b.length) {\n            throw new RangeError(\"encoding overruns Buffer\");\n        }\n        srcb.copy(uint8ArrayToBuffer(b), offset);\n        return span;\n    }\n}\nexports.UTF8 = UTF8;\n/**\n * Contain a constant value.\n *\n * This layout may be used in cases where a JavaScript value can be\n * inferred without an expression in the binary encoding.  An example\n * would be a {@link VariantLayout|variant layout} where the content\n * is implied by the union {@link Union#discriminator|discriminator}.\n *\n * @param {Object|Number|String} value - initializer for {@link\n * Constant#value|value}.  If the value is an object (or array) and\n * the application intends the object to remain unchanged regardless\n * of what is done to values decoded by this layout, the value should\n * be frozen prior passing it to this constructor.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class Constant extends Layout {\n    constructor(value, property){\n        super(0, property);\n        /** The value produced by this constant when the layout is {@link\n         * Constant#decode|decoded}.\n         *\n         * Any JavaScript value including `null` and `undefined` is\n         * permitted.\n         *\n         * **WARNING** If `value` passed in the constructor was not\n         * frozen, it is possible for users of decoded values to change\n         * the content of the value. */ this.value = value;\n    }\n    /** @override */ decode(b, offset) {\n        return this.value;\n    }\n    /** @override */ encode(src, b, offset) {\n        /* Constants take no space */ return 0;\n    }\n}\nexports.Constant = Constant;\n/** Factory for {@link GreedyCount}. */ exports.greedy = (elementSpan, property)=>new GreedyCount(elementSpan, property);\n/** Factory for {@link OffsetLayout}. */ exports.offset = (layout, offset, property)=>new OffsetLayout(layout, offset, property);\n/** Factory for {@link UInt|unsigned int layouts} spanning one\n * byte. */ exports.u8 = (property)=>new UInt(1, property);\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning two bytes. */ exports.u16 = (property)=>new UInt(2, property);\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning three bytes. */ exports.u24 = (property)=>new UInt(3, property);\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning four bytes. */ exports.u32 = (property)=>new UInt(4, property);\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning five bytes. */ exports.u40 = (property)=>new UInt(5, property);\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning six bytes. */ exports.u48 = (property)=>new UInt(6, property);\n/** Factory for {@link NearUInt64|little-endian unsigned int\n * layouts} interpreted as Numbers. */ exports.nu64 = (property)=>new NearUInt64(property);\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning two bytes. */ exports.u16be = (property)=>new UIntBE(2, property);\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning three bytes. */ exports.u24be = (property)=>new UIntBE(3, property);\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning four bytes. */ exports.u32be = (property)=>new UIntBE(4, property);\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning five bytes. */ exports.u40be = (property)=>new UIntBE(5, property);\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning six bytes. */ exports.u48be = (property)=>new UIntBE(6, property);\n/** Factory for {@link NearUInt64BE|big-endian unsigned int\n * layouts} interpreted as Numbers. */ exports.nu64be = (property)=>new NearUInt64BE(property);\n/** Factory for {@link Int|signed int layouts} spanning one\n * byte. */ exports.s8 = (property)=>new Int(1, property);\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning two bytes. */ exports.s16 = (property)=>new Int(2, property);\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning three bytes. */ exports.s24 = (property)=>new Int(3, property);\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning four bytes. */ exports.s32 = (property)=>new Int(4, property);\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning five bytes. */ exports.s40 = (property)=>new Int(5, property);\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning six bytes. */ exports.s48 = (property)=>new Int(6, property);\n/** Factory for {@link NearInt64|little-endian signed int layouts}\n * interpreted as Numbers. */ exports.ns64 = (property)=>new NearInt64(property);\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning two bytes. */ exports.s16be = (property)=>new IntBE(2, property);\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning three bytes. */ exports.s24be = (property)=>new IntBE(3, property);\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning four bytes. */ exports.s32be = (property)=>new IntBE(4, property);\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning five bytes. */ exports.s40be = (property)=>new IntBE(5, property);\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning six bytes. */ exports.s48be = (property)=>new IntBE(6, property);\n/** Factory for {@link NearInt64BE|big-endian signed int layouts}\n * interpreted as Numbers. */ exports.ns64be = (property)=>new NearInt64BE(property);\n/** Factory for {@link Float|little-endian 32-bit floating point} values. */ exports.f32 = (property)=>new Float(property);\n/** Factory for {@link FloatBE|big-endian 32-bit floating point} values. */ exports.f32be = (property)=>new FloatBE(property);\n/** Factory for {@link Double|little-endian 64-bit floating point} values. */ exports.f64 = (property)=>new Double(property);\n/** Factory for {@link DoubleBE|big-endian 64-bit floating point} values. */ exports.f64be = (property)=>new DoubleBE(property);\n/** Factory for {@link Structure} values. */ exports.struct = (fields, property, decodePrefixes)=>new Structure(fields, property, decodePrefixes);\n/** Factory for {@link BitStructure} values. */ exports.bits = (word, msb, property)=>new BitStructure(word, msb, property);\n/** Factory for {@link Sequence} values. */ exports.seq = (elementLayout, count, property)=>new Sequence(elementLayout, count, property);\n/** Factory for {@link Union} values. */ exports.union = (discr, defaultLayout, property)=>new Union(discr, defaultLayout, property);\n/** Factory for {@link UnionLayoutDiscriminator} values. */ exports.unionLayoutDiscriminator = (layout, property)=>new UnionLayoutDiscriminator(layout, property);\n/** Factory for {@link Blob} values. */ exports.blob = (length, property)=>new Blob(length, property);\n/** Factory for {@link CString} values. */ exports.cstr = (property)=>new CString(property);\n/** Factory for {@link UTF8} values. */ exports.utf8 = (maxSpan, property)=>new UTF8(maxSpan, property);\n/** Factory for {@link Constant} values. */ exports.constant = (value, property)=>new Constant(value, property); //# sourceMappingURL=Layout.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS9idWZmZXItbGF5b3V0L2xpYi9MYXlvdXQuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXFCQyxHQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQTJHQyxHQUNEO0FBQ0FBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxXQUFXLEdBQUdBLFVBQVUsR0FBR0EsY0FBYyxHQUFHQSxhQUFhLEdBQUdBLGFBQWEsR0FBR0EsYUFBYSxHQUFHQSxhQUFhLEdBQUdBLGFBQWEsR0FBR0EsWUFBWSxHQUFHQSxXQUFXLEdBQUdBLFdBQVcsR0FBR0EsV0FBVyxHQUFHQSxXQUFXLEdBQUdBLFdBQVcsR0FBR0EsVUFBVSxHQUFHQSxjQUFjLEdBQUdBLGNBQWMsR0FBR0EsZ0JBQWdCLEdBQUdBLFlBQVksR0FBR0EsZUFBZSxHQUFHQSxZQUFZLEdBQUdBLGVBQWUsR0FBR0EsZ0JBQWdCLEdBQUdBLG9CQUFvQixHQUFHQSxxQkFBcUIsR0FBR0EsYUFBYSxHQUFHQSxnQ0FBZ0MsR0FBR0EsMEJBQTBCLEdBQUdBLGlCQUFpQixHQUFHQSxnQkFBZ0IsR0FBR0EsZ0JBQWdCLEdBQUdBLGNBQWMsR0FBR0EsZUFBZSxHQUFHQSxhQUFhLEdBQUdBLG1CQUFtQixHQUFHQSxpQkFBaUIsR0FBR0Esb0JBQW9CLEdBQUdBLGtCQUFrQixHQUFHQSxhQUFhLEdBQUdBLFdBQVcsR0FBR0EsY0FBYyxHQUFHQSxZQUFZLEdBQUdBLG9CQUFvQixHQUFHQSxtQkFBbUIsR0FBR0Esc0JBQXNCLEdBQUdBLDZCQUE2QixHQUFHQSx3QkFBd0IsR0FBR0EsY0FBYyxHQUFHQSwwQkFBMEIsR0FBR0EsdUJBQXVCLEdBQUcsS0FBSztBQUN0N0JBLGdCQUFnQixH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QUFDekQseUNBQXlDLEdBQ3pDeEYsZ0JBQWdCLEdBQUksQ0FBQ0MsT0FBT3VGLFdBQWEsSUFBSXJFLFNBQVNsQixPQUFPdUYsV0FDN0Qsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xhdy13b3Jrcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL2J1ZmZlci1sYXlvdXQvbGliL0xheW91dC5qcz82N2RmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICpcbiAqIENvcHlyaWdodCAyMDE1LTIwMTggUGV0ZXIgQS4gQmlnb3RcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG4vKipcbiAqIFN1cHBvcnQgZm9yIHRyYW5zbGF0aW5nIGJldHdlZW4gVWludDhBcnJheSBpbnN0YW5jZXMgYW5kIEphdmFTY3JpcHRcbiAqIG5hdGl2ZSB0eXBlcy5cbiAqXG4gKiB7QGxpbmsgbW9kdWxlOkxheW91dH5MYXlvdXR8TGF5b3V0fSBpcyB0aGUgYmFzaXMgb2YgYSBjbGFzc1xuICogaGllcmFyY2h5IHRoYXQgYXNzb2NpYXRlcyBwcm9wZXJ0eSBuYW1lcyB3aXRoIHNlcXVlbmNlcyBvZiBlbmNvZGVkXG4gKiBieXRlcy5cbiAqXG4gKiBMYXlvdXRzIGFyZSBzdXBwb3J0ZWQgZm9yIHRoZXNlIHNjYWxhciAobnVtZXJpYykgdHlwZXM6XG4gKiAqIHtAbGluayBtb2R1bGU6TGF5b3V0flVJbnR8VW5zaWduZWQgaW50ZWdlcnMgaW4gbGl0dGxlLWVuZGlhblxuICogICBmb3JtYXR9IHdpdGgge0BsaW5rIG1vZHVsZTpMYXlvdXQudTh8OC1iaXR9LCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC51MTZ8MTYtYml0fSwge0BsaW5rIG1vZHVsZTpMYXlvdXQudTI0fDI0LWJpdH0sXG4gKiAgIHtAbGluayBtb2R1bGU6TGF5b3V0LnUzMnwzMi1iaXR9LCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC51NDB8NDAtYml0fSwgYW5kIHtAbGluayBtb2R1bGU6TGF5b3V0LnU0OHw0OC1iaXR9XG4gKiAgIHJlcHJlc2VudGF0aW9uIHJhbmdlcztcbiAqICoge0BsaW5rIG1vZHVsZTpMYXlvdXR+VUludEJFfFVuc2lnbmVkIGludGVnZXJzIGluIGJpZy1lbmRpYW5cbiAqICAgZm9ybWF0fSB3aXRoIHtAbGluayBtb2R1bGU6TGF5b3V0LnUxNmJlfDE2LWJpdH0sIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0LnUyNGJlfDI0LWJpdH0sIHtAbGluayBtb2R1bGU6TGF5b3V0LnUzMmJlfDMyLWJpdH0sXG4gKiAgIHtAbGluayBtb2R1bGU6TGF5b3V0LnU0MGJlfDQwLWJpdH0sIGFuZCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC51NDhiZXw0OC1iaXR9IHJlcHJlc2VudGF0aW9uIHJhbmdlcztcbiAqICoge0BsaW5rIG1vZHVsZTpMYXlvdXR+SW50fFNpZ25lZCBpbnRlZ2VycyBpbiBsaXR0bGUtZW5kaWFuXG4gKiAgIGZvcm1hdH0gd2l0aCB7QGxpbmsgbW9kdWxlOkxheW91dC5zOHw4LWJpdH0sIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0LnMxNnwxNi1iaXR9LCB7QGxpbmsgbW9kdWxlOkxheW91dC5zMjR8MjQtYml0fSxcbiAqICAge0BsaW5rIG1vZHVsZTpMYXlvdXQuczMyfDMyLWJpdH0sIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0LnM0MHw0MC1iaXR9LCBhbmQge0BsaW5rIG1vZHVsZTpMYXlvdXQuczQ4fDQ4LWJpdH1cbiAqICAgcmVwcmVzZW50YXRpb24gcmFuZ2VzO1xuICogKiB7QGxpbmsgbW9kdWxlOkxheW91dH5JbnRCRXxTaWduZWQgaW50ZWdlcnMgaW4gYmlnLWVuZGlhbiBmb3JtYXR9XG4gKiAgIHdpdGgge0BsaW5rIG1vZHVsZTpMYXlvdXQuczE2YmV8MTYtYml0fSwge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQuczI0YmV8MjQtYml0fSwge0BsaW5rIG1vZHVsZTpMYXlvdXQuczMyYmV8MzItYml0fSxcbiAqICAge0BsaW5rIG1vZHVsZTpMYXlvdXQuczQwYmV8NDAtYml0fSwgYW5kIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0LnM0OGJlfDQ4LWJpdH0gcmVwcmVzZW50YXRpb24gcmFuZ2VzO1xuICogKiA2NC1iaXQgaW50ZWdyYWwgdmFsdWVzIHRoYXQgZGVjb2RlIHRvIGFuIGV4YWN0IChpZiBtYWduaXR1ZGUgaXNcbiAqICAgbGVzcyB0aGFuIDJeNTMpIG9yIG5lYXJieSBpbnRlZ3JhbCBOdW1iZXIgaW4ge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQubnU2NHx1bnNpZ25lZCBsaXR0bGUtZW5kaWFufSwge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQubnU2NGJlfHVuc2lnbmVkIGJpZy1lbmRpYW59LCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC5uczY0fHNpZ25lZCBsaXR0bGUtZW5kaWFufSwgYW5kIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0Lm5zNjRiZXx1bnNpZ25lZCBiaWctZW5kaWFufSBlbmNvZGluZ3M7XG4gKiAqIDMyLWJpdCBmbG9hdGluZyBwb2ludCB2YWx1ZXMgd2l0aCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC5mMzJ8bGl0dGxlLWVuZGlhbn0gYW5kIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0LmYzMmJlfGJpZy1lbmRpYW59IHJlcHJlc2VudGF0aW9ucztcbiAqICogNjQtYml0IGZsb2F0aW5nIHBvaW50IHZhbHVlcyB3aXRoIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0LmY2NHxsaXR0bGUtZW5kaWFufSBhbmQge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQuZjY0YmV8YmlnLWVuZGlhbn0gcmVwcmVzZW50YXRpb25zO1xuICogKiB7QGxpbmsgbW9kdWxlOkxheW91dC5jb25zdHxDb25zdGFudHN9IHRoYXQgdGFrZSBubyBzcGFjZSBpbiB0aGVcbiAqICAgZW5jb2RlZCBleHByZXNzaW9uLlxuICpcbiAqIGFuZCBmb3IgdGhlc2UgYWdncmVnYXRlIHR5cGVzOlxuICogKiB7QGxpbmsgbW9kdWxlOkxheW91dC5zZXF8U2VxdWVuY2V9cyBvZiBpbnN0YW5jZXMgb2YgYSB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dH5MYXlvdXR8TGF5b3V0fSwgd2l0aCBKYXZhU2NyaXB0IHJlcHJlc2VudGF0aW9uIGFzXG4gKiAgIGFuIEFycmF5IGFuZCBjb25zdGFudCBvciBkYXRhLWRlcGVuZGVudCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dH5TZXF1ZW5jZSNjb3VudHxsZW5ndGh9O1xuICogKiB7QGxpbmsgbW9kdWxlOkxheW91dC5zdHJ1Y3R8U3RydWN0dXJlfXMgdGhhdCBhZ2dyZWdhdGUgYVxuICogICBoZXRlcm9nZW5lb3VzIHNlcXVlbmNlIG9mIHtAbGluayBtb2R1bGU6TGF5b3V0fkxheW91dHxMYXlvdXR9XG4gKiAgIGluc3RhbmNlcywgd2l0aCBKYXZhU2NyaXB0IHJlcHJlc2VudGF0aW9uIGFzIGFuIE9iamVjdDtcbiAqICoge0BsaW5rIG1vZHVsZTpMYXlvdXQudW5pb258VW5pb259cyB0aGF0IHN1cHBvcnQgbXVsdGlwbGUge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXR+VmFyaWFudExheW91dHx2YXJpYW50IGxheW91dHN9IG92ZXIgYSBmaXhlZFxuICogICAocGFkZGVkKSBvciB2YXJpYWJsZSAobm90IHBhZGRlZCkgc3BhbiBvZiBieXRlcywgdXNpbmcgYW5cbiAqICAgdW5zaWduZWQgaW50ZWdlciBhdCB0aGUgc3RhcnQgb2YgdGhlIGRhdGEgb3IgYSBzZXBhcmF0ZSB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC51bmlvbkxheW91dERpc2NyaW1pbmF0b3J8bGF5b3V0IGVsZW1lbnR9IHRvXG4gKiAgIGRldGVybWluZSB3aGljaCBsYXlvdXQgdG8gdXNlIHdoZW4gaW50ZXJwcmV0aW5nIHRoZSBidWZmZXJcbiAqICAgY29udGVudHM7XG4gKiAqIHtAbGluayBtb2R1bGU6TGF5b3V0LmJpdHN8Qml0U3RydWN0dXJlfXMgdGhhdCBjb250YWluIGEgc2VxdWVuY2VcbiAqICAgb2YgaW5kaXZpZHVhbCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dH5CaXRTdHJ1Y3R1cmUjYWRkRmllbGR8Qml0RmllbGR9cyBwYWNrZWQgaW50byBhbiA4LFxuICogICAxNiwgMjQsIG9yIDMyLWJpdCB1bnNpZ25lZCBpbnRlZ2VyIHN0YXJ0aW5nIGF0IHRoZSBsZWFzdC0gb3JcbiAqICAgbW9zdC1zaWduaWZpY2FudCBiaXQ7XG4gKiAqIHtAbGluayBtb2R1bGU6TGF5b3V0LmNzdHJ8QyBzdHJpbmdzfSBvZiB2YXJ5aW5nIGxlbmd0aDtcbiAqICoge0BsaW5rIG1vZHVsZTpMYXlvdXQuYmxvYnxCbG9ic30gb2YgZml4ZWQtIG9yIHZhcmlhYmxlLXtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0fkJsb2IjbGVuZ3RofGxlbmd0aH0gcmF3IGRhdGEuXG4gKlxuICogQWxsIHtAbGluayBtb2R1bGU6TGF5b3V0fkxheW91dHxMYXlvdXR9IGluc3RhbmNlcyBhcmUgaW1tdXRhYmxlXG4gKiBhZnRlciBjb25zdHJ1Y3Rpb24sIHRvIHByZXZlbnQgaW50ZXJuYWwgc3RhdGUgZnJvbSBiZWNvbWluZ1xuICogaW5jb25zaXN0ZW50LlxuICpcbiAqIEBsb2NhbCBMYXlvdXRcbiAqIEBsb2NhbCBFeHRlcm5hbExheW91dFxuICogQGxvY2FsIEdyZWVkeUNvdW50XG4gKiBAbG9jYWwgT2Zmc2V0TGF5b3V0XG4gKiBAbG9jYWwgVUludFxuICogQGxvY2FsIFVJbnRCRVxuICogQGxvY2FsIEludFxuICogQGxvY2FsIEludEJFXG4gKiBAbG9jYWwgTmVhclVJbnQ2NFxuICogQGxvY2FsIE5lYXJVSW50NjRCRVxuICogQGxvY2FsIE5lYXJJbnQ2NFxuICogQGxvY2FsIE5lYXJJbnQ2NEJFXG4gKiBAbG9jYWwgRmxvYXRcbiAqIEBsb2NhbCBGbG9hdEJFXG4gKiBAbG9jYWwgRG91YmxlXG4gKiBAbG9jYWwgRG91YmxlQkVcbiAqIEBsb2NhbCBTZXF1ZW5jZVxuICogQGxvY2FsIFN0cnVjdHVyZVxuICogQGxvY2FsIFVuaW9uRGlzY3JpbWluYXRvclxuICogQGxvY2FsIFVuaW9uTGF5b3V0RGlzY3JpbWluYXRvclxuICogQGxvY2FsIFVuaW9uXG4gKiBAbG9jYWwgVmFyaWFudExheW91dFxuICogQGxvY2FsIEJpdFN0cnVjdHVyZVxuICogQGxvY2FsIEJpdEZpZWxkXG4gKiBAbG9jYWwgQm9vbGVhblxuICogQGxvY2FsIEJsb2JcbiAqIEBsb2NhbCBDU3RyaW5nXG4gKiBAbG9jYWwgQ29uc3RhbnRcbiAqIEBsb2NhbCBiaW5kQ29uc3RydWN0b3JMYXlvdXRcbiAqIEBtb2R1bGUgTGF5b3V0XG4gKiBAbGljZW5zZSBNSVRcbiAqIEBhdXRob3IgUGV0ZXIgQS4gQmlnb3RcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9wYWJpZ290L2J1ZmZlci1sYXlvdXR8YnVmZmVyLWxheW91dCBvbiBHaXRIdWJ9XG4gKi9cbid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuczE2ID0gZXhwb3J0cy5zOCA9IGV4cG9ydHMubnU2NGJlID0gZXhwb3J0cy51NDhiZSA9IGV4cG9ydHMudTQwYmUgPSBleHBvcnRzLnUzMmJlID0gZXhwb3J0cy51MjRiZSA9IGV4cG9ydHMudTE2YmUgPSBleHBvcnRzLm51NjQgPSBleHBvcnRzLnU0OCA9IGV4cG9ydHMudTQwID0gZXhwb3J0cy51MzIgPSBleHBvcnRzLnUyNCA9IGV4cG9ydHMudTE2ID0gZXhwb3J0cy51OCA9IGV4cG9ydHMub2Zmc2V0ID0gZXhwb3J0cy5ncmVlZHkgPSBleHBvcnRzLkNvbnN0YW50ID0gZXhwb3J0cy5VVEY4ID0gZXhwb3J0cy5DU3RyaW5nID0gZXhwb3J0cy5CbG9iID0gZXhwb3J0cy5Cb29sZWFuID0gZXhwb3J0cy5CaXRGaWVsZCA9IGV4cG9ydHMuQml0U3RydWN0dXJlID0gZXhwb3J0cy5WYXJpYW50TGF5b3V0ID0gZXhwb3J0cy5VbmlvbiA9IGV4cG9ydHMuVW5pb25MYXlvdXREaXNjcmltaW5hdG9yID0gZXhwb3J0cy5VbmlvbkRpc2NyaW1pbmF0b3IgPSBleHBvcnRzLlN0cnVjdHVyZSA9IGV4cG9ydHMuU2VxdWVuY2UgPSBleHBvcnRzLkRvdWJsZUJFID0gZXhwb3J0cy5Eb3VibGUgPSBleHBvcnRzLkZsb2F0QkUgPSBleHBvcnRzLkZsb2F0ID0gZXhwb3J0cy5OZWFySW50NjRCRSA9IGV4cG9ydHMuTmVhckludDY0ID0gZXhwb3J0cy5OZWFyVUludDY0QkUgPSBleHBvcnRzLk5lYXJVSW50NjQgPSBleHBvcnRzLkludEJFID0gZXhwb3J0cy5JbnQgPSBleHBvcnRzLlVJbnRCRSA9IGV4cG9ydHMuVUludCA9IGV4cG9ydHMuT2Zmc2V0TGF5b3V0ID0gZXhwb3J0cy5HcmVlZHlDb3VudCA9IGV4cG9ydHMuRXh0ZXJuYWxMYXlvdXQgPSBleHBvcnRzLmJpbmRDb25zdHJ1Y3RvckxheW91dCA9IGV4cG9ydHMubmFtZVdpdGhQcm9wZXJ0eSA9IGV4cG9ydHMuTGF5b3V0ID0gZXhwb3J0cy51aW50OEFycmF5VG9CdWZmZXIgPSBleHBvcnRzLmNoZWNrVWludDhBcnJheSA9IHZvaWQgMDtcbmV4cG9ydHMuY29uc3RhbnQgPSBleHBvcnRzLnV0ZjggPSBleHBvcnRzLmNzdHIgPSBleHBvcnRzLmJsb2IgPSBleHBvcnRzLnVuaW9uTGF5b3V0RGlzY3JpbWluYXRvciA9IGV4cG9ydHMudW5pb24gPSBleHBvcnRzLnNlcSA9IGV4cG9ydHMuYml0cyA9IGV4cG9ydHMuc3RydWN0ID0gZXhwb3J0cy5mNjRiZSA9IGV4cG9ydHMuZjY0ID0gZXhwb3J0cy5mMzJiZSA9IGV4cG9ydHMuZjMyID0gZXhwb3J0cy5uczY0YmUgPSBleHBvcnRzLnM0OGJlID0gZXhwb3J0cy5zNDBiZSA9IGV4cG9ydHMuczMyYmUgPSBleHBvcnRzLnMyNGJlID0gZXhwb3J0cy5zMTZiZSA9IGV4cG9ydHMubnM2NCA9IGV4cG9ydHMuczQ4ID0gZXhwb3J0cy5zNDAgPSBleHBvcnRzLnMzMiA9IGV4cG9ydHMuczI0ID0gdm9pZCAwO1xuY29uc3QgYnVmZmVyXzEgPSByZXF1aXJlKFwiYnVmZmVyXCIpO1xuLyogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIFVpbnQ4QXJyYXkuXG4gKlxuICogQGlnbm9yZSAqL1xuZnVuY3Rpb24gY2hlY2tVaW50OEFycmF5KGIpIHtcbiAgICBpZiAoIShiIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYiBtdXN0IGJlIGEgVWludDhBcnJheScpO1xuICAgIH1cbn1cbmV4cG9ydHMuY2hlY2tVaW50OEFycmF5ID0gY2hlY2tVaW50OEFycmF5O1xuLyogQ3JlYXRlIGEgQnVmZmVyIGluc3RhbmNlIGZyb20gYSBVaW50OEFycmF5LlxuICpcbiAqIEBpZ25vcmUgKi9cbmZ1bmN0aW9uIHVpbnQ4QXJyYXlUb0J1ZmZlcihiKSB7XG4gICAgY2hlY2tVaW50OEFycmF5KGIpO1xuICAgIHJldHVybiBidWZmZXJfMS5CdWZmZXIuZnJvbShiLmJ1ZmZlciwgYi5ieXRlT2Zmc2V0LCBiLmxlbmd0aCk7XG59XG5leHBvcnRzLnVpbnQ4QXJyYXlUb0J1ZmZlciA9IHVpbnQ4QXJyYXlUb0J1ZmZlcjtcbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgbGF5b3V0IG9iamVjdHMuXG4gKlxuICogKipOT1RFKiogVGhpcyBpcyBhbiBhYnN0cmFjdCBiYXNlIGNsYXNzOyB5b3UgY2FuIGNyZWF0ZSBpbnN0YW5jZXNcbiAqIGlmIGl0IGFtdXNlcyB5b3UsIGJ1dCB0aGV5IHdvbid0IHN1cHBvcnQgdGhlIHtAbGlua1xuICogTGF5b3V0I2VuY29kZXxlbmNvZGV9IG9yIHtAbGluayBMYXlvdXQjZGVjb2RlfGRlY29kZX0gZnVuY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBzcGFuIC0gSW5pdGlhbGl6ZXIgZm9yIHtAbGluayBMYXlvdXQjc3BhbnxzcGFufS4gIFRoZVxuICogcGFyYW1ldGVyIG11c3QgYmUgYW4gaW50ZWdlcjsgYSBuZWdhdGl2ZSB2YWx1ZSBzaWduaWZpZXMgdGhhdCB0aGVcbiAqIHNwYW4gaXMge0BsaW5rIExheW91dCNnZXRTcGFufHZhbHVlLXNwZWNpZmljfS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIEluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGFic3RyYWN0XG4gKi9cbmNsYXNzIExheW91dCB7XG4gICAgY29uc3RydWN0b3Ioc3BhbiwgcHJvcGVydHkpIHtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHNwYW4pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzcGFuIG11c3QgYmUgYW4gaW50ZWdlcicpO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBUaGUgc3BhbiBvZiB0aGUgbGF5b3V0IGluIGJ5dGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBQb3NpdGl2ZSB2YWx1ZXMgYXJlIGdlbmVyYWxseSBleHBlY3RlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogWmVybyB3aWxsIG9ubHkgYXBwZWFyIGluIHtAbGluayBDb25zdGFudH1zIGFuZCBpbiB7QGxpbmtcbiAgICAgICAgICogU2VxdWVuY2V9cyB3aGVyZSB0aGUge0BsaW5rIFNlcXVlbmNlI2NvdW50fGNvdW50fSBpcyB6ZXJvLlxuICAgICAgICAgKlxuICAgICAgICAgKiBBIG5lZ2F0aXZlIHZhbHVlIGluZGljYXRlcyB0aGF0IHRoZSBzcGFuIGlzIHZhbHVlLXNwZWNpZmljLCBhbmRcbiAgICAgICAgICogbXVzdCBiZSBvYnRhaW5lZCB1c2luZyB7QGxpbmsgTGF5b3V0I2dldFNwYW58Z2V0U3Bhbn0uICovXG4gICAgICAgIHRoaXMuc3BhbiA9IHNwYW47XG4gICAgICAgIC8qKiBUaGUgcHJvcGVydHkgbmFtZSB1c2VkIHdoZW4gdGhpcyBsYXlvdXQgaXMgcmVwcmVzZW50ZWQgaW4gYW5cbiAgICAgICAgICogT2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBVc2VkIG9ubHkgZm9yIGxheW91dHMgdGhhdCB7QGxpbmsgTGF5b3V0I2RlY29kZXxkZWNvZGV9IHRvIE9iamVjdFxuICAgICAgICAgKiBpbnN0YW5jZXMuICBJZiBsZWZ0IHVuZGVmaW5lZCB0aGUgc3BhbiBvZiB0aGUgdW5uYW1lZCBsYXlvdXQgd2lsbFxuICAgICAgICAgKiBiZSB0cmVhdGVkIGFzIHBhZGRpbmc6IGl0IHdpbGwgbm90IGJlIG11dGF0ZWQgYnkge0BsaW5rXG4gICAgICAgICAqIExheW91dCNlbmNvZGV8ZW5jb2RlfSBub3IgcmVwcmVzZW50ZWQgYXMgYSBwcm9wZXJ0eSBpbiB0aGVcbiAgICAgICAgICogZGVjb2RlZCBPYmplY3QuICovXG4gICAgICAgIHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgICB9XG4gICAgLyoqIEZ1bmN0aW9uIHRvIGNyZWF0ZSBhbiBPYmplY3QgaW50byB3aGljaCBkZWNvZGVkIHByb3BlcnRpZXMgd2lsbFxuICAgICAqIGJlIHdyaXR0ZW4uXG4gICAgICpcbiAgICAgKiBVc2VkIG9ubHkgZm9yIGxheW91dHMgdGhhdCB7QGxpbmsgTGF5b3V0I2RlY29kZXxkZWNvZGV9IHRvIE9iamVjdFxuICAgICAqIGluc3RhbmNlcywgd2hpY2ggbWVhbnM6XG4gICAgICogKiB7QGxpbmsgU3RydWN0dXJlfVxuICAgICAqICoge0BsaW5rIFVuaW9ufVxuICAgICAqICoge0BsaW5rIFZhcmlhbnRMYXlvdXR9XG4gICAgICogKiB7QGxpbmsgQml0U3RydWN0dXJlfVxuICAgICAqXG4gICAgICogSWYgbGVmdCB1bmRlZmluZWQgdGhlIEphdmFTY3JpcHQgcmVwcmVzZW50YXRpb24gb2YgdGhlc2UgbGF5b3V0c1xuICAgICAqIHdpbGwgYmUgT2JqZWN0IGluc3RhbmNlcy5cbiAgICAgKlxuICAgICAqIFNlZSB7QGxpbmsgYmluZENvbnN0cnVjdG9yTGF5b3V0fS5cbiAgICAgKi9cbiAgICBtYWtlRGVzdGluYXRpb25PYmplY3QoKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBzcGFuIG9mIGEgc3BlY2lmaWMgaW5zdGFuY2Ugb2YgYSBsYXlvdXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGIgLSB0aGUgYnVmZmVyIHRoYXQgY29udGFpbnMgYW4gZW5jb2RlZCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb2Zmc2V0XSAtIHRoZSBvZmZzZXQgYXQgd2hpY2ggdGhlIGVuY29kZWQgaW5zdGFuY2VcbiAgICAgKiBzdGFydHMuICBJZiBhYnNlbnQgYSB6ZXJvIG9mZnNldCBpcyBpbmZlcnJlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gLSB0aGUgbnVtYmVyIG9mIGJ5dGVzIGNvdmVyZWQgYnkgdGhlIGxheW91dFxuICAgICAqIGluc3RhbmNlLiAgSWYgdGhpcyBtZXRob2QgaXMgbm90IG92ZXJyaWRkZW4gaW4gYSBzdWJjbGFzcyB0aGVcbiAgICAgKiBkZWZpbml0aW9uLXRpbWUgY29uc3RhbnQge0BsaW5rIExheW91dCNzcGFufHNwYW59IHdpbGwgYmVcbiAgICAgKiByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IC0gaWYgdGhlIGxlbmd0aCBvZiB0aGUgdmFsdWUgY2Fubm90IGJlXG4gICAgICogZGV0ZXJtaW5lZC5cbiAgICAgKi9cbiAgICBnZXRTcGFuKGIsIG9mZnNldCkge1xuICAgICAgICBpZiAoMCA+IHRoaXMuc3Bhbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZGV0ZXJtaW5hdGUgc3BhbicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNwYW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcGxpY2F0ZSB0aGUgbGF5b3V0IHVzaW5nIGEgbmV3IHByb3BlcnR5LlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBtdXN0IGJlIHVzZWQgdG8gZ2V0IGEgc3RydWN0dXJhbGx5LWVxdWl2YWxlbnQgbGF5b3V0XG4gICAgICogd2l0aCBhIGRpZmZlcmVudCBuYW1lIHNpbmNlIGFsbCB7QGxpbmsgTGF5b3V0fSBpbnN0YW5jZXMgYXJlXG4gICAgICogaW1tdXRhYmxlLlxuICAgICAqXG4gICAgICogKipOT1RFKiogVGhpcyBpcyBhIHNoYWxsb3cgY29weS4gIEFsbCBmaWVsZHMgZXhjZXB0IHtAbGlua1xuICAgICAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0gYXJlIHN0cmljdGx5IGVxdWFsIHRvIHRoZSBvcmlnaW4gbGF5b3V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IC0gdGhlIHZhbHVlIGZvciB7QGxpbmtcbiAgICAgKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9IGluIHRoZSByZXBsaWNhLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0xheW91dH0gLSB0aGUgY29weSB3aXRoIHtAbGluayBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9XG4gICAgICogc2V0IHRvIGBwcm9wZXJ0eWAuXG4gICAgICovXG4gICAgcmVwbGljYXRlKHByb3BlcnR5KSB7XG4gICAgICAgIGNvbnN0IHJ2ID0gT2JqZWN0LmNyZWF0ZSh0aGlzLmNvbnN0cnVjdG9yLnByb3RvdHlwZSk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24ocnYsIHRoaXMpO1xuICAgICAgICBydi5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICAgICAgICByZXR1cm4gcnY7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBvYmplY3QgZnJvbSBsYXlvdXQgcHJvcGVydGllcyBhbmQgYW4gYXJyYXkgb2YgdmFsdWVzLlxuICAgICAqXG4gICAgICogKipOT1RFKiogVGhpcyBmdW5jdGlvbiByZXR1cm5zIGB1bmRlZmluZWRgIGlmIGludm9rZWQgb24gYSBsYXlvdXRcbiAgICAgKiB0aGF0IGRvZXMgbm90IHJldHVybiBpdHMgdmFsdWUgYXMgYW4gT2JqZWN0LiAgT2JqZWN0cyBhcmVcbiAgICAgKiByZXR1cm5lZCBmb3IgdGhpbmdzIHRoYXQgYXJlIGEge0BsaW5rIFN0cnVjdHVyZX0sIHdoaWNoIGluY2x1ZGVzXG4gICAgICoge0BsaW5rIFZhcmlhbnRMYXlvdXR8dmFyaWFudCBsYXlvdXRzfSBpZiB0aGV5IGFyZSBzdHJ1Y3R1cmVzLCBhbmRcbiAgICAgKiBleGNsdWRlcyB7QGxpbmsgVW5pb259cy4gIElmIHlvdSB3YW50IHRoaXMgZmVhdHVyZSBmb3IgYSB1bmlvblxuICAgICAqIHlvdSBtdXN0IHVzZSB7QGxpbmsgVW5pb24uZ2V0VmFyaWFudHxnZXRWYXJpYW50fSB0byBzZWxlY3QgdGhlXG4gICAgICogZGVzaXJlZCBsYXlvdXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgLSBhbiBhcnJheSBvZiB2YWx1ZXMgdGhhdCBjb3JyZXNwb25kIHRvIHRoZVxuICAgICAqIGRlZmF1bHQgb3JkZXIgZm9yIHByb3BlcnRpZXMuICBBcyB3aXRoIHtAbGluayBMYXlvdXQjZGVjb2RlfGRlY29kZX1cbiAgICAgKiBsYXlvdXQgZWxlbWVudHMgdGhhdCBoYXZlIG5vIHByb3BlcnR5IG5hbWUgYXJlIHNraXBwZWQgd2hlblxuICAgICAqIGl0ZXJhdGluZyBvdmVyIHRoZSBhcnJheSB2YWx1ZXMuICBPbmx5IHRoZSB0b3AtbGV2ZWwgcHJvcGVydGllcyBhcmVcbiAgICAgKiBhc3NpZ25lZDsgYXJndW1lbnRzIGFyZSBub3QgYXNzaWduZWQgdG8gcHJvcGVydGllcyBvZiBjb250YWluZWRcbiAgICAgKiBsYXlvdXRzLiAgQW55IHVudXNlZCB2YWx1ZXMgYXJlIGlnbm9yZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHsoT2JqZWN0fHVuZGVmaW5lZCl9XG4gICAgICovXG4gICAgZnJvbUFycmF5KHZhbHVlcykge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmV4cG9ydHMuTGF5b3V0ID0gTGF5b3V0O1xuLyogUHJvdmlkZSB0ZXh0IHRoYXQgY2FycmllcyBhIG5hbWUgKHN1Y2ggYXMgZm9yIGEgZnVuY3Rpb24gdGhhdCB3aWxsXG4gKiBiZSB0aHJvd2luZyBhbiBlcnJvcikgYW5ub3RhdGVkIHdpdGggdGhlIHByb3BlcnR5IG9mIGEgZ2l2ZW4gbGF5b3V0XG4gKiAoc3VjaCBhcyBvbmUgZm9yIHdoaWNoIHRoZSB2YWx1ZSB3YXMgdW5hY2NlcHRhYmxlKS5cbiAqXG4gKiBAaWdub3JlICovXG5mdW5jdGlvbiBuYW1lV2l0aFByb3BlcnR5KG5hbWUsIGxvKSB7XG4gICAgaWYgKGxvLnByb3BlcnR5KSB7XG4gICAgICAgIHJldHVybiBuYW1lICsgJ1snICsgbG8ucHJvcGVydHkgKyAnXSc7XG4gICAgfVxuICAgIHJldHVybiBuYW1lO1xufVxuZXhwb3J0cy5uYW1lV2l0aFByb3BlcnR5ID0gbmFtZVdpdGhQcm9wZXJ0eTtcbi8qKlxuICogQXVnbWVudCBhIGNsYXNzIHNvIHRoYXQgaW5zdGFuY2VzIGNhbiBiZSBlbmNvZGVkL2RlY29kZWQgdXNpbmcgYVxuICogZ2l2ZW4gbGF5b3V0LlxuICpcbiAqIENhbGxpbmcgdGhpcyBmdW5jdGlvbiBjb3VwbGVzIGBDbGFzc2Agd2l0aCBgbGF5b3V0YCBpbiBzZXZlcmFsIHdheXM6XG4gKlxuICogKiBgQ2xhc3MubGF5b3V0X2AgYmVjb21lcyBhIHN0YXRpYyBtZW1iZXIgcHJvcGVydHkgZXF1YWwgdG8gYGxheW91dGA7XG4gKiAqIGBsYXlvdXQuYm91bmRDb25zdHJ1Y3Rvcl9gIGJlY29tZXMgYSBzdGF0aWMgbWVtYmVyIHByb3BlcnR5IGVxdWFsXG4gKiAgICB0byBgQ2xhc3NgO1xuICogKiBUaGUge0BsaW5rIExheW91dCNtYWtlRGVzdGluYXRpb25PYmplY3R8bWFrZURlc3RpbmF0aW9uT2JqZWN0KCl9XG4gKiAgIHByb3BlcnR5IG9mIGBsYXlvdXRgIGlzIHNldCB0byBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGBuZXdcbiAqICAgQ2xhc3MoKWA7XG4gKiAqIGBDbGFzcy5kZWNvZGUoYiwgb2Zmc2V0KWAgYmVjb21lcyBhIHN0YXRpYyBtZW1iZXIgZnVuY3Rpb24gdGhhdFxuICogICBkZWxlZ2F0ZXMgdG8ge0BsaW5rIExheW91dCNkZWNvZGV8bGF5b3V0LmRlY29kZX0uICBUaGVcbiAqICAgc3ludGhlc2l6ZWQgZnVuY3Rpb24gbWF5IGJlIGNhcHR1cmVkIGFuZCBleHRlbmRlZC5cbiAqICogYENsYXNzLnByb3RvdHlwZS5lbmNvZGUoYiwgb2Zmc2V0KWAgcHJvdmlkZXMgYW4gaW5zdGFuY2UgbWVtYmVyXG4gKiAgIGZ1bmN0aW9uIHRoYXQgZGVsZWdhdGVzIHRvIHtAbGluayBMYXlvdXQjZW5jb2RlfGxheW91dC5lbmNvZGV9XG4gKiAgIHdpdGggYHNyY2Agc2V0IHRvIGB0aGlzYC4gIFRoZSBzeW50aGVzaXplZCBmdW5jdGlvbiBtYXkgYmVcbiAqICAgY2FwdHVyZWQgYW5kIGV4dGVuZGVkLCBidXQgd2hlbiB0aGUgZXh0ZW5zaW9uIGlzIGludm9rZWQgYHRoaXNgXG4gKiAgIG11c3QgYmUgZXhwbGljaXRseSBib3VuZCB0byB0aGUgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtjbGFzc30gQ2xhc3MgLSBhIEphdmFTY3JpcHQgY2xhc3Mgd2l0aCBhIG51bGxhcnlcbiAqIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7TGF5b3V0fSBsYXlvdXQgLSB0aGUge0BsaW5rIExheW91dH0gaW5zdGFuY2UgdXNlZCB0byBlbmNvZGVcbiAqIGluc3RhbmNlcyBvZiBgQ2xhc3NgLlxuICovXG4vLyBgQ2xhc3NgIG11c3QgYmUgYSBjb25zdHJ1Y3RvciBGdW5jdGlvbiwgYnV0IHRoZSBhc3NpZ25tZW50IG9mIGEgYGxheW91dF9gIHByb3BlcnR5IHRvIGl0IG1ha2VzIGl0IGRpZmZpY3VsdCB0byB0eXBlXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LW1vZHVsZS1ib3VuZGFyeS10eXBlc1xuZnVuY3Rpb24gYmluZENvbnN0cnVjdG9yTGF5b3V0KENsYXNzLCBsYXlvdXQpIHtcbiAgICBpZiAoJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIENsYXNzKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NsYXNzIG11c3QgYmUgY29uc3RydWN0b3InKTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChDbGFzcywgJ2xheW91dF8nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NsYXNzIGlzIGFscmVhZHkgYm91bmQgdG8gYSBsYXlvdXQnKTtcbiAgICB9XG4gICAgaWYgKCEobGF5b3V0ICYmIChsYXlvdXQgaW5zdGFuY2VvZiBMYXlvdXQpKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdsYXlvdXQgbXVzdCBiZSBhIExheW91dCcpO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGxheW91dCwgJ2JvdW5kQ29uc3RydWN0b3JfJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsYXlvdXQgaXMgYWxyZWFkeSBib3VuZCB0byBhIGNvbnN0cnVjdG9yJyk7XG4gICAgfVxuICAgIENsYXNzLmxheW91dF8gPSBsYXlvdXQ7XG4gICAgbGF5b3V0LmJvdW5kQ29uc3RydWN0b3JfID0gQ2xhc3M7XG4gICAgbGF5b3V0Lm1ha2VEZXN0aW5hdGlvbk9iamVjdCA9ICgoKSA9PiBuZXcgQ2xhc3MoKSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENsYXNzLnByb3RvdHlwZSwgJ2VuY29kZScsIHtcbiAgICAgICAgdmFsdWUoYiwgb2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gbGF5b3V0LmVuY29kZSh0aGlzLCBiLCBvZmZzZXQpO1xuICAgICAgICB9LFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xhc3MsICdkZWNvZGUnLCB7XG4gICAgICAgIHZhbHVlKGIsIG9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIGxheW91dC5kZWNvZGUoYiwgb2Zmc2V0KTtcbiAgICAgICAgfSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgfSk7XG59XG5leHBvcnRzLmJpbmRDb25zdHJ1Y3RvckxheW91dCA9IGJpbmRDb25zdHJ1Y3RvckxheW91dDtcbi8qKlxuICogQW4gb2JqZWN0IHRoYXQgYmVoYXZlcyBsaWtlIGEgbGF5b3V0IGJ1dCBkb2VzIG5vdCBjb25zdW1lIHNwYWNlXG4gKiB3aXRoaW4gaXRzIGNvbnRhaW5pbmcgbGF5b3V0LlxuICpcbiAqIFRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgdG8gb2J0YWluIG1ldGFkYXRhIGFib3V0IGEgbWVtYmVyLCBzdWNoIGFzIGFcbiAqIHtAbGluayBPZmZzZXRMYXlvdXR9IHRoYXQgY2FuIHByb3ZpZGUgZGF0YSBhYm91dCBhIHtAbGlua1xuICogTGF5b3V0I2dldFNwYW58dmFsdWUtc3BlY2lmaWMgc3Bhbn0uXG4gKlxuICogKipOT1RFKiogVGhpcyBpcyBhbiBhYnN0cmFjdCBiYXNlIGNsYXNzOyB5b3UgY2FuIGNyZWF0ZSBpbnN0YW5jZXNcbiAqIGlmIGl0IGFtdXNlcyB5b3UsIGJ1dCB0aGV5IHdvbid0IHN1cHBvcnQge0BsaW5rXG4gKiBFeHRlcm5hbExheW91dCNpc0NvdW50fGlzQ291bnR9IG9yIG90aGVyIHtAbGluayBMYXlvdXR9IGZ1bmN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gc3BhbiAtIGluaXRpYWxpemVyIGZvciB7QGxpbmsgTGF5b3V0I3NwYW58c3Bhbn0uXG4gKiBUaGUgcGFyYW1ldGVyIGNhbiByYW5nZSBmcm9tIDEgdGhyb3VnaCA2LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBFeHRlcm5hbExheW91dCBleHRlbmRzIExheW91dCB7XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGB0cnVlYCBpZmYgdGhlIGV4dGVybmFsIGxheW91dCBkZWNvZGVzIHRvIGFuIHVuc2lnbmVkXG4gICAgICogaW50ZWdlciBsYXlvdXQuXG4gICAgICpcbiAgICAgKiBJbiB0aGF0IGNhc2UgaXQgY2FuIGJlIHVzZWQgYXMgdGhlIHNvdXJjZSBvZiB7QGxpbmtcbiAgICAgKiBTZXF1ZW5jZSNjb3VudHxTZXF1ZW5jZSBjb3VudHN9LCB7QGxpbmsgQmxvYiNsZW5ndGh8QmxvYiBsZW5ndGhzfSxcbiAgICAgKiBvciBhcyB7QGxpbmsgVW5pb25MYXlvdXREaXNjcmltaW5hdG9yI2xheW91dHxleHRlcm5hbCB1bmlvblxuICAgICAqIGRpc2NyaW1pbmF0b3JzfS5cbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIGlzQ291bnQoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXh0ZXJuYWxMYXlvdXQgaXMgYWJzdHJhY3QnKTtcbiAgICB9XG59XG5leHBvcnRzLkV4dGVybmFsTGF5b3V0ID0gRXh0ZXJuYWxMYXlvdXQ7XG4vKipcbiAqIEFuIHtAbGluayBFeHRlcm5hbExheW91dH0gdGhhdCBkZXRlcm1pbmVzIGl0cyB7QGxpbmtcbiAqIExheW91dCNkZWNvZGV8dmFsdWV9IGJhc2VkIG9uIG9mZnNldCBpbnRvIGFuZCBsZW5ndGggb2YgdGhlIGJ1ZmZlclxuICogb24gd2hpY2ggaXQgaXMgaW52b2tlZC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LmdyZWVkeXxncmVlZHl9XG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IFtlbGVtZW50U3Bhbl0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBHcmVlZHlDb3VudCNlbGVtZW50U3BhbnxlbGVtZW50U3Bhbn0uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7RXh0ZXJuYWxMYXlvdXR9XG4gKi9cbmNsYXNzIEdyZWVkeUNvdW50IGV4dGVuZHMgRXh0ZXJuYWxMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRTcGFuID0gMSwgcHJvcGVydHkpIHtcbiAgICAgICAgaWYgKCghTnVtYmVyLmlzSW50ZWdlcihlbGVtZW50U3BhbikpIHx8ICgwID49IGVsZW1lbnRTcGFuKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZWxlbWVudFNwYW4gbXVzdCBiZSBhIChwb3NpdGl2ZSkgaW50ZWdlcicpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKC0xLCBwcm9wZXJ0eSk7XG4gICAgICAgIC8qKiBUaGUgbGF5b3V0IGZvciBpbmRpdmlkdWFsIGVsZW1lbnRzIG9mIHRoZSBzZXF1ZW5jZS4gIFRoZSB2YWx1ZVxuICAgICAgICAgKiBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlci4gIElmIG5vdCBwcm92aWRlZCwgdGhlIHZhbHVlIHdpbGwgYmVcbiAgICAgICAgICogMS4gKi9cbiAgICAgICAgdGhpcy5lbGVtZW50U3BhbiA9IGVsZW1lbnRTcGFuO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgaXNDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjaGVja1VpbnQ4QXJyYXkoYik7XG4gICAgICAgIGNvbnN0IHJlbSA9IGIubGVuZ3RoIC0gb2Zmc2V0O1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihyZW0gLyB0aGlzLmVsZW1lbnRTcGFuKTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG59XG5leHBvcnRzLkdyZWVkeUNvdW50ID0gR3JlZWR5Q291bnQ7XG4vKipcbiAqIEFuIHtAbGluayBFeHRlcm5hbExheW91dH0gdGhhdCBzdXBwb3J0cyBhY2Nlc3NpbmcgYSB7QGxpbmsgTGF5b3V0fVxuICogYXQgYSBmaXhlZCBvZmZzZXQgZnJvbSB0aGUgc3RhcnQgb2YgYW5vdGhlciBMYXlvdXQuICBUaGUgb2Zmc2V0IG1heVxuICogYmUgYmVmb3JlLCB3aXRoaW4sIG9yIGFmdGVyIHRoZSBiYXNlIGxheW91dC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0Lm9mZnNldHxvZmZzZXR9XG4gKlxuICogQHBhcmFtIHtMYXlvdXR9IGxheW91dCAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIE9mZnNldExheW91dCNsYXlvdXR8bGF5b3V0fSwgbW9kdWxvIGBwcm9wZXJ0eWAuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvZmZzZXRdIC0gSW5pdGlhbGl6ZXMge0BsaW5rXG4gKiBPZmZzZXRMYXlvdXQjb2Zmc2V0fG9mZnNldH0uICBEZWZhdWx0cyB0byB6ZXJvLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gT3B0aW9uYWwgbmV3IHByb3BlcnR5IG5hbWUgZm9yIGFcbiAqIHtAbGluayBMYXlvdXQjcmVwbGljYXRlfCByZXBsaWNhfSBvZiBgbGF5b3V0YCB0byBiZSB1c2VkIGFzIHtAbGlua1xuICogT2Zmc2V0TGF5b3V0I2xheW91dHxsYXlvdXR9LiAgSWYgbm90IHByb3ZpZGVkIHRoZSBgbGF5b3V0YCBpcyB1c2VkXG4gKiB1bmNoYW5nZWQuXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIE9mZnNldExheW91dCBleHRlbmRzIEV4dGVybmFsTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3RvcihsYXlvdXQsIG9mZnNldCA9IDAsIHByb3BlcnR5KSB7XG4gICAgICAgIGlmICghKGxheW91dCBpbnN0YW5jZW9mIExheW91dCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2xheW91dCBtdXN0IGJlIGEgTGF5b3V0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG9mZnNldCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29mZnNldCBtdXN0IGJlIGludGVnZXIgb3IgdW5kZWZpbmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIobGF5b3V0LnNwYW4sIHByb3BlcnR5IHx8IGxheW91dC5wcm9wZXJ0eSk7XG4gICAgICAgIC8qKiBUaGUgc3Vib3JkaW5hdGVkIGxheW91dC4gKi9cbiAgICAgICAgdGhpcy5sYXlvdXQgPSBsYXlvdXQ7XG4gICAgICAgIC8qKiBUaGUgbG9jYXRpb24gb2Yge0BsaW5rIE9mZnNldExheW91dCNsYXlvdXR9IHJlbGF0aXZlIHRvIHRoZVxuICAgICAgICAgKiBzdGFydCBvZiBhbm90aGVyIGxheW91dC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIHZhbHVlIG1heSBiZSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSwgYnV0IGFuIGVycm9yIHdpbGwgdGhyb3duXG4gICAgICAgICAqIGlmIGF0IHRoZSBwb2ludCBvZiB1c2UgaXQgZ29lcyBvdXRzaWRlIHRoZSBzcGFuIG9mIHRoZSBVaW50OEFycmF5XG4gICAgICAgICAqIGJlaW5nIGFjY2Vzc2VkLiAgKi9cbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBpc0NvdW50KCkge1xuICAgICAgICByZXR1cm4gKCh0aGlzLmxheW91dCBpbnN0YW5jZW9mIFVJbnQpXG4gICAgICAgICAgICB8fCAodGhpcy5sYXlvdXQgaW5zdGFuY2VvZiBVSW50QkUpKTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxheW91dC5kZWNvZGUoYiwgb2Zmc2V0ICsgdGhpcy5vZmZzZXQpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXlvdXQuZW5jb2RlKHNyYywgYiwgb2Zmc2V0ICsgdGhpcy5vZmZzZXQpO1xuICAgIH1cbn1cbmV4cG9ydHMuT2Zmc2V0TGF5b3V0ID0gT2Zmc2V0TGF5b3V0O1xuLyoqXG4gKiBSZXByZXNlbnQgYW4gdW5zaWduZWQgaW50ZWdlciBpbiBsaXR0bGUtZW5kaWFuIGZvcm1hdC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LnU4fHU4fSwge0BsaW5rXG4gKiAgbW9kdWxlOkxheW91dC51MTZ8dTE2fSwge0BsaW5rIG1vZHVsZTpMYXlvdXQudTI0fHUyNH0sIHtAbGlua1xuICogIG1vZHVsZTpMYXlvdXQudTMyfHUzMn0sIHtAbGluayBtb2R1bGU6TGF5b3V0LnU0MHx1NDB9LCB7QGxpbmtcbiAqICBtb2R1bGU6TGF5b3V0LnU0OHx1NDh9XG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHNwYW4gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rIExheW91dCNzcGFufHNwYW59LlxuICogVGhlIHBhcmFtZXRlciBjYW4gcmFuZ2UgZnJvbSAxIHRocm91Z2ggNi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIFVJbnQgZXh0ZW5kcyBMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKHNwYW4sIHByb3BlcnR5KSB7XG4gICAgICAgIHN1cGVyKHNwYW4sIHByb3BlcnR5KTtcbiAgICAgICAgaWYgKDYgPCB0aGlzLnNwYW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzcGFuIG11c3Qgbm90IGV4Y2VlZCA2IGJ5dGVzJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHJldHVybiB1aW50OEFycmF5VG9CdWZmZXIoYikucmVhZFVJbnRMRShvZmZzZXQsIHRoaXMuc3Bhbik7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHVpbnQ4QXJyYXlUb0J1ZmZlcihiKS53cml0ZVVJbnRMRShzcmMsIG9mZnNldCwgdGhpcy5zcGFuKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BhbjtcbiAgICB9XG59XG5leHBvcnRzLlVJbnQgPSBVSW50O1xuLyoqXG4gKiBSZXByZXNlbnQgYW4gdW5zaWduZWQgaW50ZWdlciBpbiBiaWctZW5kaWFuIGZvcm1hdC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LnU4YmV8dThiZX0sIHtAbGlua1xuICogbW9kdWxlOkxheW91dC51MTZiZXx1MTZiZX0sIHtAbGluayBtb2R1bGU6TGF5b3V0LnUyNGJlfHUyNGJlfSxcbiAqIHtAbGluayBtb2R1bGU6TGF5b3V0LnUzMmJlfHUzMmJlfSwge0BsaW5rXG4gKiBtb2R1bGU6TGF5b3V0LnU0MGJlfHU0MGJlfSwge0BsaW5rIG1vZHVsZTpMYXlvdXQudTQ4YmV8dTQ4YmV9XG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHNwYW4gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rIExheW91dCNzcGFufHNwYW59LlxuICogVGhlIHBhcmFtZXRlciBjYW4gcmFuZ2UgZnJvbSAxIHRocm91Z2ggNi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIFVJbnRCRSBleHRlbmRzIExheW91dCB7XG4gICAgY29uc3RydWN0b3Ioc3BhbiwgcHJvcGVydHkpIHtcbiAgICAgICAgc3VwZXIoc3BhbiwgcHJvcGVydHkpO1xuICAgICAgICBpZiAoNiA8IHRoaXMuc3Bhbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NwYW4gbXVzdCBub3QgZXhjZWVkIDYgYnl0ZXMnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgcmV0dXJuIHVpbnQ4QXJyYXlUb0J1ZmZlcihiKS5yZWFkVUludEJFKG9mZnNldCwgdGhpcy5zcGFuKTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgdWludDhBcnJheVRvQnVmZmVyKGIpLndyaXRlVUludEJFKHNyYywgb2Zmc2V0LCB0aGlzLnNwYW4pO1xuICAgICAgICByZXR1cm4gdGhpcy5zcGFuO1xuICAgIH1cbn1cbmV4cG9ydHMuVUludEJFID0gVUludEJFO1xuLyoqXG4gKiBSZXByZXNlbnQgYSBzaWduZWQgaW50ZWdlciBpbiBsaXR0bGUtZW5kaWFuIGZvcm1hdC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LnM4fHM4fSwge0BsaW5rXG4gKiAgbW9kdWxlOkxheW91dC5zMTZ8czE2fSwge0BsaW5rIG1vZHVsZTpMYXlvdXQuczI0fHMyNH0sIHtAbGlua1xuICogIG1vZHVsZTpMYXlvdXQuczMyfHMzMn0sIHtAbGluayBtb2R1bGU6TGF5b3V0LnM0MHxzNDB9LCB7QGxpbmtcbiAqICBtb2R1bGU6TGF5b3V0LnM0OHxzNDh9XG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHNwYW4gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rIExheW91dCNzcGFufHNwYW59LlxuICogVGhlIHBhcmFtZXRlciBjYW4gcmFuZ2UgZnJvbSAxIHRocm91Z2ggNi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIEludCBleHRlbmRzIExheW91dCB7XG4gICAgY29uc3RydWN0b3Ioc3BhbiwgcHJvcGVydHkpIHtcbiAgICAgICAgc3VwZXIoc3BhbiwgcHJvcGVydHkpO1xuICAgICAgICBpZiAoNiA8IHRoaXMuc3Bhbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NwYW4gbXVzdCBub3QgZXhjZWVkIDYgYnl0ZXMnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgcmV0dXJuIHVpbnQ4QXJyYXlUb0J1ZmZlcihiKS5yZWFkSW50TEUob2Zmc2V0LCB0aGlzLnNwYW4pO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICB1aW50OEFycmF5VG9CdWZmZXIoYikud3JpdGVJbnRMRShzcmMsIG9mZnNldCwgdGhpcy5zcGFuKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BhbjtcbiAgICB9XG59XG5leHBvcnRzLkludCA9IEludDtcbi8qKlxuICogUmVwcmVzZW50IGEgc2lnbmVkIGludGVnZXIgaW4gYmlnLWVuZGlhbiBmb3JtYXQuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5zOGJlfHM4YmV9LCB7QGxpbmtcbiAqIG1vZHVsZTpMYXlvdXQuczE2YmV8czE2YmV9LCB7QGxpbmsgbW9kdWxlOkxheW91dC5zMjRiZXxzMjRiZX0sXG4gKiB7QGxpbmsgbW9kdWxlOkxheW91dC5zMzJiZXxzMzJiZX0sIHtAbGlua1xuICogbW9kdWxlOkxheW91dC5zNDBiZXxzNDBiZX0sIHtAbGluayBtb2R1bGU6TGF5b3V0LnM0OGJlfHM0OGJlfVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBzcGFuIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGluayBMYXlvdXQjc3BhbnxzcGFufS5cbiAqIFRoZSBwYXJhbWV0ZXIgY2FuIHJhbmdlIGZyb20gMSB0aHJvdWdoIDYuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBJbnRCRSBleHRlbmRzIExheW91dCB7XG4gICAgY29uc3RydWN0b3Ioc3BhbiwgcHJvcGVydHkpIHtcbiAgICAgICAgc3VwZXIoc3BhbiwgcHJvcGVydHkpO1xuICAgICAgICBpZiAoNiA8IHRoaXMuc3Bhbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NwYW4gbXVzdCBub3QgZXhjZWVkIDYgYnl0ZXMnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgcmV0dXJuIHVpbnQ4QXJyYXlUb0J1ZmZlcihiKS5yZWFkSW50QkUob2Zmc2V0LCB0aGlzLnNwYW4pO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICB1aW50OEFycmF5VG9CdWZmZXIoYikud3JpdGVJbnRCRShzcmMsIG9mZnNldCwgdGhpcy5zcGFuKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BhbjtcbiAgICB9XG59XG5leHBvcnRzLkludEJFID0gSW50QkU7XG5jb25zdCBWMkUzMiA9IE1hdGgucG93KDIsIDMyKTtcbi8qIFRydWUgbW9kdWx1cyBoaWdoIGFuZCBsb3cgMzItYml0IHdvcmRzLCB3aGVyZSBsb3cgd29yZCBpcyBhbHdheXNcbiAqIG5vbi1uZWdhdGl2ZS4gKi9cbmZ1bmN0aW9uIGRpdm1vZEludDY0KHNyYykge1xuICAgIGNvbnN0IGhpMzIgPSBNYXRoLmZsb29yKHNyYyAvIFYyRTMyKTtcbiAgICBjb25zdCBsbzMyID0gc3JjIC0gKGhpMzIgKiBWMkUzMik7XG4gICAgcmV0dXJuIHsgaGkzMiwgbG8zMiB9O1xufVxuLyogUmVjb25zdHJ1Y3QgTnVtYmVyIGZyb20gcXVvdGllbnQgYW5kIG5vbi1uZWdhdGl2ZSByZW1haW5kZXIgKi9cbmZ1bmN0aW9uIHJvdW5kZWRJbnQ2NChoaTMyLCBsbzMyKSB7XG4gICAgcmV0dXJuIGhpMzIgKiBWMkUzMiArIGxvMzI7XG59XG4vKipcbiAqIFJlcHJlc2VudCBhbiB1bnNpZ25lZCA2NC1iaXQgaW50ZWdlciBpbiBsaXR0bGUtZW5kaWFuIGZvcm1hdCB3aGVuXG4gKiBlbmNvZGVkIGFuZCBhcyBhIG5lYXIgaW50ZWdyYWwgSmF2YVNjcmlwdCBOdW1iZXIgd2hlbiBkZWNvZGVkLlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQubnU2NHxudTY0fVxuICpcbiAqICoqTk9URSoqIFZhbHVlcyB3aXRoIG1hZ25pdHVkZSBncmVhdGVyIHRoYW4gMl41MiBtYXkgbm90IGRlY29kZSB0b1xuICogdGhlIGV4YWN0IHZhbHVlIG9mIHRoZSBlbmNvZGVkIHJlcHJlc2VudGF0aW9uLlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBOZWFyVUludDY0IGV4dGVuZHMgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eSkge1xuICAgICAgICBzdXBlcig4LCBwcm9wZXJ0eSk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjb25zdCBidWZmZXIgPSB1aW50OEFycmF5VG9CdWZmZXIoYik7XG4gICAgICAgIGNvbnN0IGxvMzIgPSBidWZmZXIucmVhZFVJbnQzMkxFKG9mZnNldCk7XG4gICAgICAgIGNvbnN0IGhpMzIgPSBidWZmZXIucmVhZFVJbnQzMkxFKG9mZnNldCArIDQpO1xuICAgICAgICByZXR1cm4gcm91bmRlZEludDY0KGhpMzIsIGxvMzIpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjb25zdCBzcGxpdCA9IGRpdm1vZEludDY0KHNyYyk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHVpbnQ4QXJyYXlUb0J1ZmZlcihiKTtcbiAgICAgICAgYnVmZmVyLndyaXRlVUludDMyTEUoc3BsaXQubG8zMiwgb2Zmc2V0KTtcbiAgICAgICAgYnVmZmVyLndyaXRlVUludDMyTEUoc3BsaXQuaGkzMiwgb2Zmc2V0ICsgNCk7XG4gICAgICAgIHJldHVybiA4O1xuICAgIH1cbn1cbmV4cG9ydHMuTmVhclVJbnQ2NCA9IE5lYXJVSW50NjQ7XG4vKipcbiAqIFJlcHJlc2VudCBhbiB1bnNpZ25lZCA2NC1iaXQgaW50ZWdlciBpbiBiaWctZW5kaWFuIGZvcm1hdCB3aGVuXG4gKiBlbmNvZGVkIGFuZCBhcyBhIG5lYXIgaW50ZWdyYWwgSmF2YVNjcmlwdCBOdW1iZXIgd2hlbiBkZWNvZGVkLlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQubnU2NGJlfG51NjRiZX1cbiAqXG4gKiAqKk5PVEUqKiBWYWx1ZXMgd2l0aCBtYWduaXR1ZGUgZ3JlYXRlciB0aGFuIDJeNTIgbWF5IG5vdCBkZWNvZGUgdG9cbiAqIHRoZSBleGFjdCB2YWx1ZSBvZiB0aGUgZW5jb2RlZCByZXByZXNlbnRhdGlvbi5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgTmVhclVJbnQ2NEJFIGV4dGVuZHMgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eSkge1xuICAgICAgICBzdXBlcig4LCBwcm9wZXJ0eSk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjb25zdCBidWZmZXIgPSB1aW50OEFycmF5VG9CdWZmZXIoYik7XG4gICAgICAgIGNvbnN0IGhpMzIgPSBidWZmZXIucmVhZFVJbnQzMkJFKG9mZnNldCk7XG4gICAgICAgIGNvbnN0IGxvMzIgPSBidWZmZXIucmVhZFVJbnQzMkJFKG9mZnNldCArIDQpO1xuICAgICAgICByZXR1cm4gcm91bmRlZEludDY0KGhpMzIsIGxvMzIpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjb25zdCBzcGxpdCA9IGRpdm1vZEludDY0KHNyYyk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHVpbnQ4QXJyYXlUb0J1ZmZlcihiKTtcbiAgICAgICAgYnVmZmVyLndyaXRlVUludDMyQkUoc3BsaXQuaGkzMiwgb2Zmc2V0KTtcbiAgICAgICAgYnVmZmVyLndyaXRlVUludDMyQkUoc3BsaXQubG8zMiwgb2Zmc2V0ICsgNCk7XG4gICAgICAgIHJldHVybiA4O1xuICAgIH1cbn1cbmV4cG9ydHMuTmVhclVJbnQ2NEJFID0gTmVhclVJbnQ2NEJFO1xuLyoqXG4gKiBSZXByZXNlbnQgYSBzaWduZWQgNjQtYml0IGludGVnZXIgaW4gbGl0dGxlLWVuZGlhbiBmb3JtYXQgd2hlblxuICogZW5jb2RlZCBhbmQgYXMgYSBuZWFyIGludGVncmFsIEphdmFTY3JpcHQgTnVtYmVyIHdoZW4gZGVjb2RlZC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0Lm5zNjR8bnM2NH1cbiAqXG4gKiAqKk5PVEUqKiBWYWx1ZXMgd2l0aCBtYWduaXR1ZGUgZ3JlYXRlciB0aGFuIDJeNTIgbWF5IG5vdCBkZWNvZGUgdG9cbiAqIHRoZSBleGFjdCB2YWx1ZSBvZiB0aGUgZW5jb2RlZCByZXByZXNlbnRhdGlvbi5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgTmVhckludDY0IGV4dGVuZHMgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eSkge1xuICAgICAgICBzdXBlcig4LCBwcm9wZXJ0eSk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjb25zdCBidWZmZXIgPSB1aW50OEFycmF5VG9CdWZmZXIoYik7XG4gICAgICAgIGNvbnN0IGxvMzIgPSBidWZmZXIucmVhZFVJbnQzMkxFKG9mZnNldCk7XG4gICAgICAgIGNvbnN0IGhpMzIgPSBidWZmZXIucmVhZEludDMyTEUob2Zmc2V0ICsgNCk7XG4gICAgICAgIHJldHVybiByb3VuZGVkSW50NjQoaGkzMiwgbG8zMik7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNvbnN0IHNwbGl0ID0gZGl2bW9kSW50NjQoc3JjKTtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gdWludDhBcnJheVRvQnVmZmVyKGIpO1xuICAgICAgICBidWZmZXIud3JpdGVVSW50MzJMRShzcGxpdC5sbzMyLCBvZmZzZXQpO1xuICAgICAgICBidWZmZXIud3JpdGVJbnQzMkxFKHNwbGl0LmhpMzIsIG9mZnNldCArIDQpO1xuICAgICAgICByZXR1cm4gODtcbiAgICB9XG59XG5leHBvcnRzLk5lYXJJbnQ2NCA9IE5lYXJJbnQ2NDtcbi8qKlxuICogUmVwcmVzZW50IGEgc2lnbmVkIDY0LWJpdCBpbnRlZ2VyIGluIGJpZy1lbmRpYW4gZm9ybWF0IHdoZW5cbiAqIGVuY29kZWQgYW5kIGFzIGEgbmVhciBpbnRlZ3JhbCBKYXZhU2NyaXB0IE51bWJlciB3aGVuIGRlY29kZWQuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5uczY0YmV8bnM2NGJlfVxuICpcbiAqICoqTk9URSoqIFZhbHVlcyB3aXRoIG1hZ25pdHVkZSBncmVhdGVyIHRoYW4gMl41MiBtYXkgbm90IGRlY29kZSB0b1xuICogdGhlIGV4YWN0IHZhbHVlIG9mIHRoZSBlbmNvZGVkIHJlcHJlc2VudGF0aW9uLlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBOZWFySW50NjRCRSBleHRlbmRzIExheW91dCB7XG4gICAgY29uc3RydWN0b3IocHJvcGVydHkpIHtcbiAgICAgICAgc3VwZXIoOCwgcHJvcGVydHkpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gdWludDhBcnJheVRvQnVmZmVyKGIpO1xuICAgICAgICBjb25zdCBoaTMyID0gYnVmZmVyLnJlYWRJbnQzMkJFKG9mZnNldCk7XG4gICAgICAgIGNvbnN0IGxvMzIgPSBidWZmZXIucmVhZFVJbnQzMkJFKG9mZnNldCArIDQpO1xuICAgICAgICByZXR1cm4gcm91bmRlZEludDY0KGhpMzIsIGxvMzIpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjb25zdCBzcGxpdCA9IGRpdm1vZEludDY0KHNyYyk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHVpbnQ4QXJyYXlUb0J1ZmZlcihiKTtcbiAgICAgICAgYnVmZmVyLndyaXRlSW50MzJCRShzcGxpdC5oaTMyLCBvZmZzZXQpO1xuICAgICAgICBidWZmZXIud3JpdGVVSW50MzJCRShzcGxpdC5sbzMyLCBvZmZzZXQgKyA0KTtcbiAgICAgICAgcmV0dXJuIDg7XG4gICAgfVxufVxuZXhwb3J0cy5OZWFySW50NjRCRSA9IE5lYXJJbnQ2NEJFO1xuLyoqXG4gKiBSZXByZXNlbnQgYSAzMi1iaXQgZmxvYXRpbmcgcG9pbnQgbnVtYmVyIGluIGxpdHRsZS1lbmRpYW4gZm9ybWF0LlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQuZjMyfGYzMn1cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIEZsb2F0IGV4dGVuZHMgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eSkge1xuICAgICAgICBzdXBlcig0LCBwcm9wZXJ0eSk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICByZXR1cm4gdWludDhBcnJheVRvQnVmZmVyKGIpLnJlYWRGbG9hdExFKG9mZnNldCk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHVpbnQ4QXJyYXlUb0J1ZmZlcihiKS53cml0ZUZsb2F0TEUoc3JjLCBvZmZzZXQpO1xuICAgICAgICByZXR1cm4gNDtcbiAgICB9XG59XG5leHBvcnRzLkZsb2F0ID0gRmxvYXQ7XG4vKipcbiAqIFJlcHJlc2VudCBhIDMyLWJpdCBmbG9hdGluZyBwb2ludCBudW1iZXIgaW4gYmlnLWVuZGlhbiBmb3JtYXQuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5mMzJiZXxmMzJiZX1cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIEZsb2F0QkUgZXh0ZW5kcyBMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BlcnR5KSB7XG4gICAgICAgIHN1cGVyKDQsIHByb3BlcnR5KTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHJldHVybiB1aW50OEFycmF5VG9CdWZmZXIoYikucmVhZEZsb2F0QkUob2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgdWludDhBcnJheVRvQnVmZmVyKGIpLndyaXRlRmxvYXRCRShzcmMsIG9mZnNldCk7XG4gICAgICAgIHJldHVybiA0O1xuICAgIH1cbn1cbmV4cG9ydHMuRmxvYXRCRSA9IEZsb2F0QkU7XG4vKipcbiAqIFJlcHJlc2VudCBhIDY0LWJpdCBmbG9hdGluZyBwb2ludCBudW1iZXIgaW4gbGl0dGxlLWVuZGlhbiBmb3JtYXQuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5mNjR8ZjY0fVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgRG91YmxlIGV4dGVuZHMgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eSkge1xuICAgICAgICBzdXBlcig4LCBwcm9wZXJ0eSk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICByZXR1cm4gdWludDhBcnJheVRvQnVmZmVyKGIpLnJlYWREb3VibGVMRShvZmZzZXQpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICB1aW50OEFycmF5VG9CdWZmZXIoYikud3JpdGVEb3VibGVMRShzcmMsIG9mZnNldCk7XG4gICAgICAgIHJldHVybiA4O1xuICAgIH1cbn1cbmV4cG9ydHMuRG91YmxlID0gRG91YmxlO1xuLyoqXG4gKiBSZXByZXNlbnQgYSA2NC1iaXQgZmxvYXRpbmcgcG9pbnQgbnVtYmVyIGluIGJpZy1lbmRpYW4gZm9ybWF0LlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQuZjY0YmV8ZjY0YmV9XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBEb3VibGVCRSBleHRlbmRzIExheW91dCB7XG4gICAgY29uc3RydWN0b3IocHJvcGVydHkpIHtcbiAgICAgICAgc3VwZXIoOCwgcHJvcGVydHkpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgcmV0dXJuIHVpbnQ4QXJyYXlUb0J1ZmZlcihiKS5yZWFkRG91YmxlQkUob2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgdWludDhBcnJheVRvQnVmZmVyKGIpLndyaXRlRG91YmxlQkUoc3JjLCBvZmZzZXQpO1xuICAgICAgICByZXR1cm4gODtcbiAgICB9XG59XG5leHBvcnRzLkRvdWJsZUJFID0gRG91YmxlQkU7XG4vKipcbiAqIFJlcHJlc2VudCBhIGNvbnRpZ3VvdXMgc2VxdWVuY2Ugb2YgYSBzcGVjaWZpYyBsYXlvdXQgYXMgYW4gQXJyYXkuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5zZXF8c2VxfVxuICpcbiAqIEBwYXJhbSB7TGF5b3V0fSBlbGVtZW50TGF5b3V0IC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogU2VxdWVuY2UjZWxlbWVudExheW91dHxlbGVtZW50TGF5b3V0fS5cbiAqXG4gKiBAcGFyYW0geyhOdW1iZXJ8RXh0ZXJuYWxMYXlvdXQpfSBjb3VudCAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIFNlcXVlbmNlI2NvdW50fGNvdW50fS4gIFRoZSBwYXJhbWV0ZXIgbXVzdCBiZSBlaXRoZXIgYSBwb3NpdGl2ZVxuICogaW50ZWdlciBvciBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgRXh0ZXJuYWxMYXlvdXR9LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgU2VxdWVuY2UgZXh0ZW5kcyBMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRMYXlvdXQsIGNvdW50LCBwcm9wZXJ0eSkge1xuICAgICAgICBpZiAoIShlbGVtZW50TGF5b3V0IGluc3RhbmNlb2YgTGF5b3V0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZWxlbWVudExheW91dCBtdXN0IGJlIGEgTGF5b3V0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoKChjb3VudCBpbnN0YW5jZW9mIEV4dGVybmFsTGF5b3V0KSAmJiBjb3VudC5pc0NvdW50KCkpXG4gICAgICAgICAgICB8fCAoTnVtYmVyLmlzSW50ZWdlcihjb3VudCkgJiYgKDAgPD0gY291bnQpKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NvdW50IG11c3QgYmUgbm9uLW5lZ2F0aXZlIGludGVnZXIgJ1xuICAgICAgICAgICAgICAgICsgJ29yIGFuIHVuc2lnbmVkIGludGVnZXIgRXh0ZXJuYWxMYXlvdXQnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3BhbiA9IC0xO1xuICAgICAgICBpZiAoKCEoY291bnQgaW5zdGFuY2VvZiBFeHRlcm5hbExheW91dCkpXG4gICAgICAgICAgICAmJiAoMCA8IGVsZW1lbnRMYXlvdXQuc3BhbikpIHtcbiAgICAgICAgICAgIHNwYW4gPSBjb3VudCAqIGVsZW1lbnRMYXlvdXQuc3BhbjtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihzcGFuLCBwcm9wZXJ0eSk7XG4gICAgICAgIC8qKiBUaGUgbGF5b3V0IGZvciBpbmRpdmlkdWFsIGVsZW1lbnRzIG9mIHRoZSBzZXF1ZW5jZS4gKi9cbiAgICAgICAgdGhpcy5lbGVtZW50TGF5b3V0ID0gZWxlbWVudExheW91dDtcbiAgICAgICAgLyoqIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHNlcXVlbmNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIHdpbGwgYmUgZWl0aGVyIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIgb3IgYW4gaW5zdGFuY2Ugb2ZcbiAgICAgICAgICoge0BsaW5rIEV4dGVybmFsTGF5b3V0fSBmb3Igd2hpY2gge0BsaW5rXG4gICAgICAgICAqIEV4dGVybmFsTGF5b3V0I2lzQ291bnR8aXNDb3VudCgpfSBpcyBgdHJ1ZWAuICovXG4gICAgICAgIHRoaXMuY291bnQgPSBjb3VudDtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGdldFNwYW4oYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBpZiAoMCA8PSB0aGlzLnNwYW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNwYW47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNwYW4gPSAwO1xuICAgICAgICBsZXQgY291bnQgPSB0aGlzLmNvdW50O1xuICAgICAgICBpZiAoY291bnQgaW5zdGFuY2VvZiBFeHRlcm5hbExheW91dCkge1xuICAgICAgICAgICAgY291bnQgPSBjb3VudC5kZWNvZGUoYiwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoMCA8IHRoaXMuZWxlbWVudExheW91dC5zcGFuKSB7XG4gICAgICAgICAgICBzcGFuID0gY291bnQgKiB0aGlzLmVsZW1lbnRMYXlvdXQuc3BhbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBpZHggPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGlkeCA8IGNvdW50KSB7XG4gICAgICAgICAgICAgICAgc3BhbiArPSB0aGlzLmVsZW1lbnRMYXlvdXQuZ2V0U3BhbihiLCBvZmZzZXQgKyBzcGFuKTtcbiAgICAgICAgICAgICAgICArK2lkeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3BhbjtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNvbnN0IHJ2ID0gW107XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgbGV0IGNvdW50ID0gdGhpcy5jb3VudDtcbiAgICAgICAgaWYgKGNvdW50IGluc3RhbmNlb2YgRXh0ZXJuYWxMYXlvdXQpIHtcbiAgICAgICAgICAgIGNvdW50ID0gY291bnQuZGVjb2RlKGIsIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGkgPCBjb3VudCkge1xuICAgICAgICAgICAgcnYucHVzaCh0aGlzLmVsZW1lbnRMYXlvdXQuZGVjb2RlKGIsIG9mZnNldCkpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IHRoaXMuZWxlbWVudExheW91dC5nZXRTcGFuKGIsIG9mZnNldCk7XG4gICAgICAgICAgICBpICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ2O1xuICAgIH1cbiAgICAvKiogSW1wbGVtZW50IHtAbGluayBMYXlvdXQjZW5jb2RlfGVuY29kZX0gZm9yIHtAbGluayBTZXF1ZW5jZX0uXG4gICAgICpcbiAgICAgKiAqKk5PVEUqKiBJZiBgc3JjYCBpcyBzaG9ydGVyIHRoYW4ge0BsaW5rIFNlcXVlbmNlI2NvdW50fGNvdW50fSB0aGVuXG4gICAgICogdGhlIHVudXNlZCBzcGFjZSBpbiB0aGUgYnVmZmVyIGlzIGxlZnQgdW5jaGFuZ2VkLiAgSWYgYHNyY2AgaXNcbiAgICAgKiBsb25nZXIgdGhhbiB7QGxpbmsgU2VxdWVuY2UjY291bnR8Y291bnR9IHRoZSB1bm5lZWRlZCBlbGVtZW50cyBhcmVcbiAgICAgKiBpZ25vcmVkLlxuICAgICAqXG4gICAgICogKipOT1RFKiogSWYge0BsaW5rIExheW91dCNjb3VudHxjb3VudH0gaXMgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rXG4gICAgICogRXh0ZXJuYWxMYXlvdXR9IHRoZW4gdGhlIGxlbmd0aCBvZiBgc3JjYCB3aWxsIGJlIGVuY29kZWQgYXMgdGhlXG4gICAgICogY291bnQgYWZ0ZXIgYHNyY2AgaXMgZW5jb2RlZC4gKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNvbnN0IGVsbyA9IHRoaXMuZWxlbWVudExheW91dDtcbiAgICAgICAgY29uc3Qgc3BhbiA9IHNyYy5yZWR1Y2UoKHNwYW4sIHYpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBzcGFuICsgZWxvLmVuY29kZSh2LCBiLCBvZmZzZXQgKyBzcGFuKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICAgIGlmICh0aGlzLmNvdW50IGluc3RhbmNlb2YgRXh0ZXJuYWxMYXlvdXQpIHtcbiAgICAgICAgICAgIHRoaXMuY291bnQuZW5jb2RlKHNyYy5sZW5ndGgsIGIsIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgfVxufVxuZXhwb3J0cy5TZXF1ZW5jZSA9IFNlcXVlbmNlO1xuLyoqXG4gKiBSZXByZXNlbnQgYSBjb250aWd1b3VzIHNlcXVlbmNlIG9mIGFyYml0cmFyeSBsYXlvdXQgZWxlbWVudHMgYXMgYW5cbiAqIE9iamVjdC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LnN0cnVjdHxzdHJ1Y3R9XG4gKlxuICogKipOT1RFKiogVGhlIHtAbGluayBMYXlvdXQjc3BhbnxzcGFufSBvZiB0aGUgc3RydWN0dXJlIGlzIHZhcmlhYmxlXG4gKiBpZiBhbnkgbGF5b3V0IGluIHtAbGluayBTdHJ1Y3R1cmUjZmllbGRzfGZpZWxkc30gaGFzIGEgdmFyaWFibGVcbiAqIHNwYW4uICBXaGVuIHtAbGluayBMYXlvdXQjZW5jb2RlfGVuY29kaW5nfSB3ZSBtdXN0IGhhdmUgYSB2YWx1ZSBmb3JcbiAqIGFsbCB2YXJpYWJsZS1sZW5ndGggZmllbGRzLCBvciB3ZSB3b3VsZG4ndCBiZSBhYmxlIHRvIGZpZ3VyZSBvdXRcbiAqIGhvdyBtdWNoIHNwYWNlIHRvIHVzZSBmb3Igc3RvcmFnZS4gIFdlIGNhbiBvbmx5IGlkZW50aWZ5IHRoZSB2YWx1ZVxuICogZm9yIGEgZmllbGQgd2hlbiBpdCBoYXMgYSB7QGxpbmsgTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS4gIEFzXG4gKiBzdWNoLCBhbHRob3VnaCBhIHN0cnVjdHVyZSBtYXkgY29udGFpbiBib3RoIHVubmFtZWQgZmllbGRzIGFuZFxuICogdmFyaWFibGUtbGVuZ3RoIGZpZWxkcywgaXQgY2Fubm90IGNvbnRhaW4gYW4gdW5uYW1lZFxuICogdmFyaWFibGUtbGVuZ3RoIGZpZWxkLlxuICpcbiAqIEBwYXJhbSB7TGF5b3V0W119IGZpZWxkcyAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIFN0cnVjdHVyZSNmaWVsZHN8ZmllbGRzfS4gIEFuIGVycm9yIGlzIHJhaXNlZCBpZiB0aGlzIGNvbnRhaW5zIGFcbiAqIHZhcmlhYmxlLWxlbmd0aCBmaWVsZCBmb3Igd2hpY2ggYSB7QGxpbmsgTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fVxuICogaXMgbm90IGRlZmluZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2RlY29kZVByZWZpeGVzXSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIFN0cnVjdHVyZSNkZWNvZGVQcmVmaXhlc3xwcm9wZXJ0eX0uXG4gKlxuICogQHRocm93cyB7RXJyb3J9IC0gaWYgYGZpZWxkc2AgY29udGFpbnMgYW4gdW5uYW1lZCB2YXJpYWJsZS1sZW5ndGhcbiAqIGxheW91dC5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgU3RydWN0dXJlIGV4dGVuZHMgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMsIHByb3BlcnR5LCBkZWNvZGVQcmVmaXhlcykge1xuICAgICAgICBpZiAoIShBcnJheS5pc0FycmF5KGZpZWxkcylcbiAgICAgICAgICAgICYmIGZpZWxkcy5yZWR1Y2UoKGFjYywgdikgPT4gYWNjICYmICh2IGluc3RhbmNlb2YgTGF5b3V0KSwgdHJ1ZSkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdmaWVsZHMgbXVzdCBiZSBhcnJheSBvZiBMYXlvdXQgaW5zdGFuY2VzJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgnYm9vbGVhbicgPT09IHR5cGVvZiBwcm9wZXJ0eSlcbiAgICAgICAgICAgICYmICh1bmRlZmluZWQgPT09IGRlY29kZVByZWZpeGVzKSkge1xuICAgICAgICAgICAgZGVjb2RlUHJlZml4ZXMgPSBwcm9wZXJ0eTtcbiAgICAgICAgICAgIHByb3BlcnR5ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8qIFZlcmlmeSBhYnNlbmNlIG9mIHVubmFtZWQgdmFyaWFibGUtbGVuZ3RoIGZpZWxkcy4gKi9cbiAgICAgICAgZm9yIChjb25zdCBmZCBvZiBmaWVsZHMpIHtcbiAgICAgICAgICAgIGlmICgoMCA+IGZkLnNwYW4pXG4gICAgICAgICAgICAgICAgJiYgKHVuZGVmaW5lZCA9PT0gZmQucHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaWVsZHMgY2Fubm90IGNvbnRhaW4gdW5uYW1lZCB2YXJpYWJsZS1sZW5ndGggbGF5b3V0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNwYW4gPSAtMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNwYW4gPSBmaWVsZHMucmVkdWNlKChzcGFuLCBmZCkgPT4gc3BhbiArIGZkLmdldFNwYW4oKSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIGlnbm9yZSBlcnJvclxuICAgICAgICB9XG4gICAgICAgIHN1cGVyKHNwYW4sIHByb3BlcnR5KTtcbiAgICAgICAgLyoqIFRoZSBzZXF1ZW5jZSBvZiB7QGxpbmsgTGF5b3V0fSB2YWx1ZXMgdGhhdCBjb21wcmlzZSB0aGVcbiAgICAgICAgICogc3RydWN0dXJlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgaW5kaXZpZHVhbCBlbGVtZW50cyBuZWVkIG5vdCBiZSB0aGUgc2FtZSB0eXBlLCBhbmQgbWF5IGJlXG4gICAgICAgICAqIGVpdGhlciBzY2FsYXIgb3IgYWdncmVnYXRlIGxheW91dHMuICBJZiBhIG1lbWJlciBsYXlvdXQgbGVhdmVzXG4gICAgICAgICAqIGl0cyB7QGxpbmsgTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fSB1bmRlZmluZWQgdGhlXG4gICAgICAgICAqIGNvcnJlc3BvbmRpbmcgcmVnaW9uIG9mIHRoZSBidWZmZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBlbGVtZW50XG4gICAgICAgICAqIHdpbGwgbm90IGJlIG11dGF0ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtMYXlvdXRbXX0gKi9cbiAgICAgICAgdGhpcy5maWVsZHMgPSBmaWVsZHM7XG4gICAgICAgIC8qKiBDb250cm9sIGJlaGF2aW9yIG9mIHtAbGluayBMYXlvdXQjZGVjb2RlfGRlY29kZSgpfSBnaXZlbiBzaG9ydFxuICAgICAgICAgKiBidWZmZXJzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJbiBzb21lIHNpdHVhdGlvbnMgYSBzdHJ1Y3R1cmUgbWFueSBiZSBleHRlbmRlZCB3aXRoIGFkZGl0aW9uYWxcbiAgICAgICAgICogZmllbGRzIG92ZXIgdGltZSwgd2l0aCBvbGRlciBpbnN0YWxsYXRpb25zIHByb3ZpZGluZyBvbmx5IGFcbiAgICAgICAgICogcHJlZml4IG9mIHRoZSBmdWxsIHN0cnVjdHVyZS4gIElmIHRoaXMgcHJvcGVydHkgaXMgYHRydWVgXG4gICAgICAgICAqIGRlY29kaW5nIHdpbGwgYWNjZXB0IHRob3NlIGJ1ZmZlcnMgYW5kIGxlYXZlIHN1YnNlcXVlbnQgZmllbGRzXG4gICAgICAgICAqIHVuZGVmaW5lZCwgYXMgbG9uZyBhcyB0aGUgYnVmZmVyIGVuZHMgYXQgYSBmaWVsZCBib3VuZGFyeS5cbiAgICAgICAgICogRGVmYXVsdHMgdG8gYGZhbHNlYC4gKi9cbiAgICAgICAgdGhpcy5kZWNvZGVQcmVmaXhlcyA9ICEhZGVjb2RlUHJlZml4ZXM7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBnZXRTcGFuKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgaWYgKDAgPD0gdGhpcy5zcGFuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zcGFuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzcGFuID0gMDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNwYW4gPSB0aGlzLmZpZWxkcy5yZWR1Y2UoKHNwYW4sIGZkKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZnNwID0gZmQuZ2V0U3BhbihiLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSBmc3A7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNwYW4gKyBmc3A7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZGV0ZXJtaW5hdGUgc3BhbicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGFuO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgY2hlY2tVaW50OEFycmF5KGIpO1xuICAgICAgICBjb25zdCBkZXN0ID0gdGhpcy5tYWtlRGVzdGluYXRpb25PYmplY3QoKTtcbiAgICAgICAgZm9yIChjb25zdCBmZCBvZiB0aGlzLmZpZWxkcykge1xuICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCAhPT0gZmQucHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICBkZXN0W2ZkLnByb3BlcnR5XSA9IGZkLmRlY29kZShiLCBvZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ICs9IGZkLmdldFNwYW4oYiwgb2Zmc2V0KTtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlY29kZVByZWZpeGVzXG4gICAgICAgICAgICAgICAgJiYgKGIubGVuZ3RoID09PSBvZmZzZXQpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfVxuICAgIC8qKiBJbXBsZW1lbnQge0BsaW5rIExheW91dCNlbmNvZGV8ZW5jb2RlfSBmb3Ige0BsaW5rIFN0cnVjdHVyZX0uXG4gICAgICpcbiAgICAgKiBJZiBgc3JjYCBpcyBtaXNzaW5nIGEgcHJvcGVydHkgZm9yIGEgbWVtYmVyIHdpdGggYSBkZWZpbmVkIHtAbGlua1xuICAgICAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0gdGhlIGNvcnJlc3BvbmRpbmcgcmVnaW9uIG9mIHRoZSBidWZmZXIgaXNcbiAgICAgKiBsZWZ0IHVubW9kaWZpZWQuICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjb25zdCBmaXJzdE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgbGV0IGxhc3RPZmZzZXQgPSAwO1xuICAgICAgICBsZXQgbGFzdFdyb3RlID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBmZCBvZiB0aGlzLmZpZWxkcykge1xuICAgICAgICAgICAgbGV0IHNwYW4gPSBmZC5zcGFuO1xuICAgICAgICAgICAgbGFzdFdyb3RlID0gKDAgPCBzcGFuKSA/IHNwYW4gOiAwO1xuICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCAhPT0gZmQucHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmdiA9IHNyY1tmZC5wcm9wZXJ0eV07XG4gICAgICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCAhPT0gZnYpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFdyb3RlID0gZmQuZW5jb2RlKGZ2LCBiLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoMCA+IHNwYW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIFJlYWQgdGhlIGFzLWVuY29kZWQgc3Bhbiwgd2hpY2ggaXMgbm90IG5lY2Vzc2FyaWx5IHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICogc2FtZSBhcyB3aGF0IHdlIHdyb3RlLiAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgc3BhbiA9IGZkLmdldFNwYW4oYiwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICBvZmZzZXQgKz0gc3BhbjtcbiAgICAgICAgfVxuICAgICAgICAvKiBVc2UgKGxhc3RPZmZzZXQgKyBsYXN0V3JvdGUpIGluc3RlYWQgb2Ygb2Zmc2V0IGJlY2F1c2UgdGhlIGxhc3RcbiAgICAgICAgICogaXRlbSBtYXkgaGF2ZSBoYWQgYSBkeW5hbWljIGxlbmd0aCBhbmQgd2UgZG9uJ3Qgd2FudCB0byBpbmNsdWRlXG4gICAgICAgICAqIHRoZSBwYWRkaW5nIGJldHdlZW4gaXQgYW5kIHRoZSBlbmQgb2YgdGhlIHNwYWNlIHJlc2VydmVkIGZvclxuICAgICAgICAgKiBpdC4gKi9cbiAgICAgICAgcmV0dXJuIChsYXN0T2Zmc2V0ICsgbGFzdFdyb3RlKSAtIGZpcnN0T2Zmc2V0O1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZnJvbUFycmF5KHZhbHVlcykge1xuICAgICAgICBjb25zdCBkZXN0ID0gdGhpcy5tYWtlRGVzdGluYXRpb25PYmplY3QoKTtcbiAgICAgICAgZm9yIChjb25zdCBmZCBvZiB0aGlzLmZpZWxkcykge1xuICAgICAgICAgICAgaWYgKCh1bmRlZmluZWQgIT09IGZkLnByb3BlcnR5KVxuICAgICAgICAgICAgICAgICYmICgwIDwgdmFsdWVzLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICBkZXN0W2ZkLnByb3BlcnR5XSA9IHZhbHVlcy5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYWNjZXNzIHRvIHRoZSBsYXlvdXQgb2YgYSBnaXZlbiBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSAtIHRoZSBzdHJ1Y3R1cmUgbWVtYmVyIG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHJldHVybiB7TGF5b3V0fSAtIHRoZSBsYXlvdXQgYXNzb2NpYXRlZCB3aXRoIGBwcm9wZXJ0eWAsIG9yXG4gICAgICogdW5kZWZpbmVkIGlmIHRoZXJlIGlzIG5vIHN1Y2ggcHJvcGVydHkuXG4gICAgICovXG4gICAgbGF5b3V0Rm9yKHByb3BlcnR5KSB7XG4gICAgICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIHByb3BlcnR5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwcm9wZXJ0eSBtdXN0IGJlIHN0cmluZycpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZmQgb2YgdGhpcy5maWVsZHMpIHtcbiAgICAgICAgICAgIGlmIChmZC5wcm9wZXJ0eSA9PT0gcHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBvZmZzZXQgb2YgYSBzdHJ1Y3R1cmUgbWVtYmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IC0gdGhlIHN0cnVjdHVyZSBtZW1iZXIgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IC0gdGhlIG9mZnNldCBpbiBieXRlcyB0byB0aGUgc3RhcnQgb2YgYHByb3BlcnR5YFxuICAgICAqIHdpdGhpbiB0aGUgc3RydWN0dXJlLCBvciB1bmRlZmluZWQgaWYgYHByb3BlcnR5YCBpcyBub3QgYSBmaWVsZFxuICAgICAqIHdpdGhpbiB0aGUgc3RydWN0dXJlLiAgSWYgdGhlIHByb3BlcnR5IGlzIGEgbWVtYmVyIGJ1dCBmb2xsb3dzIGFcbiAgICAgKiB2YXJpYWJsZS1sZW5ndGggc3RydWN0dXJlIG1lbWJlciBhIG5lZ2F0aXZlIG51bWJlciB3aWxsIGJlXG4gICAgICogcmV0dXJuZWQuXG4gICAgICovXG4gICAgb2Zmc2V0T2YocHJvcGVydHkpIHtcbiAgICAgICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgcHJvcGVydHkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3Byb3BlcnR5IG11c3QgYmUgc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgZmQgb2YgdGhpcy5maWVsZHMpIHtcbiAgICAgICAgICAgIGlmIChmZC5wcm9wZXJ0eSA9PT0gcHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKDAgPiBmZC5zcGFuKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgwIDw9IG9mZnNldCkge1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSBmZC5zcGFuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZXhwb3J0cy5TdHJ1Y3R1cmUgPSBTdHJ1Y3R1cmU7XG4vKipcbiAqIEFuIG9iamVjdCB0aGF0IGNhbiBwcm92aWRlIGEge0BsaW5rXG4gKiBVbmlvbiNkaXNjcmltaW5hdG9yfGRpc2NyaW1pbmF0b3J9IEFQSSBmb3Ige0BsaW5rIFVuaW9ufS5cbiAqXG4gKiAqKk5PVEUqKiBUaGlzIGlzIGFuIGFic3RyYWN0IGJhc2UgY2xhc3M7IHlvdSBjYW4gY3JlYXRlIGluc3RhbmNlc1xuICogaWYgaXQgYW11c2VzIHlvdSwgYnV0IHRoZXkgd29uJ3Qgc3VwcG9ydCB0aGUge0BsaW5rXG4gKiBVbmlvbkRpc2NyaW1pbmF0b3IjZW5jb2RlfGVuY29kZX0gb3Ige0BsaW5rXG4gKiBVbmlvbkRpc2NyaW1pbmF0b3IjZGVjb2RlfGRlY29kZX0gZnVuY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gRGVmYXVsdCBmb3Ige0BsaW5rXG4gKiBVbmlvbkRpc2NyaW1pbmF0b3IjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhYnN0cmFjdFxuICovXG5jbGFzcyBVbmlvbkRpc2NyaW1pbmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKHByb3BlcnR5KSB7XG4gICAgICAgIC8qKiBUaGUge0BsaW5rIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0gdG8gYmUgdXNlZCB3aGVuIHRoZVxuICAgICAgICAgKiBkaXNjcmltaW5hdG9yIGlzIHJlZmVyZW5jZWQgaW4gaXNvbGF0aW9uIChnZW5lcmFsbHkgd2hlbiB7QGxpbmtcbiAgICAgICAgICogVW5pb24jZGVjb2RlfFVuaW9uIGRlY29kZX0gY2Fubm90IGRlbGVnYXRlIHRvIGEgc3BlY2lmaWNcbiAgICAgICAgICogdmFyaWFudCkuICovXG4gICAgICAgIHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgICB9XG4gICAgLyoqIEFuYWxvZyB0byB7QGxpbmsgTGF5b3V0I2RlY29kZXxMYXlvdXQgZGVjb2RlfSBmb3IgdW5pb24gZGlzY3JpbWluYXRvcnMuXG4gICAgICpcbiAgICAgKiBUaGUgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBtZXRob2QgbmVlZCBub3QgcmVmZXJlbmNlIHRoZSBidWZmZXIgaWZcbiAgICAgKiB2YXJpYW50IGluZm9ybWF0aW9uIGlzIGF2YWlsYWJsZSB0aHJvdWdoIG90aGVyIG1lYW5zLiAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmlvbkRpc2NyaW1pbmF0b3IgaXMgYWJzdHJhY3QnKTtcbiAgICB9XG4gICAgLyoqIEFuYWxvZyB0byB7QGxpbmsgTGF5b3V0I2RlY29kZXxMYXlvdXQgZW5jb2RlfSBmb3IgdW5pb24gZGlzY3JpbWluYXRvcnMuXG4gICAgICpcbiAgICAgKiBUaGUgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBtZXRob2QgbmVlZCBub3Qgc3RvcmUgdGhlIHZhbHVlIGlmXG4gICAgICogdmFyaWFudCBpbmZvcm1hdGlvbiBpcyBtYWludGFpbmVkIHRocm91Z2ggb3RoZXIgbWVhbnMuICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5pb25EaXNjcmltaW5hdG9yIGlzIGFic3RyYWN0Jyk7XG4gICAgfVxufVxuZXhwb3J0cy5VbmlvbkRpc2NyaW1pbmF0b3IgPSBVbmlvbkRpc2NyaW1pbmF0b3I7XG4vKipcbiAqIEFuIG9iamVjdCB0aGF0IGNhbiBwcm92aWRlIGEge0BsaW5rXG4gKiBVbmlvbkRpc2NyaW1pbmF0b3J8ZGlzY3JpbWluYXRvciBBUEl9IGZvciB7QGxpbmsgVW5pb259IHVzaW5nIGFuXG4gKiB1bnNpZ25lZCBpbnRlZ3JhbCB7QGxpbmsgTGF5b3V0fSBpbnN0YW5jZSBsb2NhdGVkIGVpdGhlciBpbnNpZGUgb3JcbiAqIG91dHNpZGUgdGhlIHVuaW9uLlxuICpcbiAqIEBwYXJhbSB7RXh0ZXJuYWxMYXlvdXR9IGxheW91dCAtIGluaXRpYWxpemVzIHtAbGlua1xuICogVW5pb25MYXlvdXREaXNjcmltaW5hdG9yI2xheW91dHxsYXlvdXR9LiAgTXVzdCBzYXRpc2Z5IHtAbGlua1xuICogRXh0ZXJuYWxMYXlvdXQjaXNDb3VudHxpc0NvdW50KCl9LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gRGVmYXVsdCBmb3Ige0BsaW5rXG4gKiBVbmlvbkRpc2NyaW1pbmF0b3IjcHJvcGVydHl8cHJvcGVydHl9LCBzdXBlcnNlZGluZyB0aGUgcHJvcGVydHlcbiAqIGZyb20gYGxheW91dGAsIGJ1dCBkZWZhdWx0aW5nIHRvIGB2YXJpYW50YCBpZiBuZWl0aGVyIGBwcm9wZXJ0eWBcbiAqIG5vciBsYXlvdXQgcHJvdmlkZSBhIHByb3BlcnR5IG5hbWUuXG4gKlxuICogQGF1Z21lbnRzIHtVbmlvbkRpc2NyaW1pbmF0b3J9XG4gKi9cbmNsYXNzIFVuaW9uTGF5b3V0RGlzY3JpbWluYXRvciBleHRlbmRzIFVuaW9uRGlzY3JpbWluYXRvciB7XG4gICAgY29uc3RydWN0b3IobGF5b3V0LCBwcm9wZXJ0eSkge1xuICAgICAgICBpZiAoISgobGF5b3V0IGluc3RhbmNlb2YgRXh0ZXJuYWxMYXlvdXQpXG4gICAgICAgICAgICAmJiBsYXlvdXQuaXNDb3VudCgpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbGF5b3V0IG11c3QgYmUgYW4gdW5zaWduZWQgaW50ZWdlciBFeHRlcm5hbExheW91dCcpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKHByb3BlcnR5IHx8IGxheW91dC5wcm9wZXJ0eSB8fCAndmFyaWFudCcpO1xuICAgICAgICAvKiogVGhlIHtAbGluayBFeHRlcm5hbExheW91dH0gdXNlZCB0byBhY2Nlc3MgdGhlIGRpc2NyaW1pbmF0b3JcbiAgICAgICAgICogdmFsdWUuICovXG4gICAgICAgIHRoaXMubGF5b3V0ID0gbGF5b3V0O1xuICAgIH1cbiAgICAvKiogRGVsZWdhdGUgZGVjb2RpbmcgdG8ge0BsaW5rIFVuaW9uTGF5b3V0RGlzY3JpbWluYXRvciNsYXlvdXR8bGF5b3V0fS4gKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxheW91dC5kZWNvZGUoYiwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqIERlbGVnYXRlIGVuY29kaW5nIHRvIHtAbGluayBVbmlvbkxheW91dERpc2NyaW1pbmF0b3IjbGF5b3V0fGxheW91dH0uICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxheW91dC5lbmNvZGUoc3JjLCBiLCBvZmZzZXQpO1xuICAgIH1cbn1cbmV4cG9ydHMuVW5pb25MYXlvdXREaXNjcmltaW5hdG9yID0gVW5pb25MYXlvdXREaXNjcmltaW5hdG9yO1xuLyoqXG4gKiBSZXByZXNlbnQgYW55IG51bWJlciBvZiBzcGFuLWNvbXBhdGlibGUgbGF5b3V0cy5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LnVuaW9ufHVuaW9ufVxuICpcbiAqIElmIHRoZSB1bmlvbiBoYXMgYSB7QGxpbmsgVW5pb24jZGVmYXVsdExheW91dHxkZWZhdWx0IGxheW91dH0gdGhhdFxuICogbGF5b3V0IG11c3QgaGF2ZSBhIG5vbi1uZWdhdGl2ZSB7QGxpbmsgTGF5b3V0I3NwYW58c3Bhbn0uICBUaGUgc3BhblxuICogb2YgYSBmaXhlZC1zcGFuIHVuaW9uIGluY2x1ZGVzIGl0cyB7QGxpbmtcbiAqIFVuaW9uI2Rpc2NyaW1pbmF0b3J8ZGlzY3JpbWluYXRvcn0gaWYgdGhlIHZhcmlhbnQgaXMgYSB7QGxpbmtcbiAqIFVuaW9uI3VzZXNQcmVmaXhEaXNjcmltaW5hdG9yfHByZWZpeCBvZiB0aGUgdW5pb259LCBwbHVzIHRoZSBzcGFuXG4gKiBvZiBpdHMge0BsaW5rIFVuaW9uI2RlZmF1bHRMYXlvdXR8ZGVmYXVsdCBsYXlvdXR9LlxuICpcbiAqIElmIHRoZSB1bmlvbiBkb2VzIG5vdCBoYXZlIGEgZGVmYXVsdCBsYXlvdXQgdGhlbiB0aGUgZW5jb2RlZCBzcGFuXG4gKiBvZiB0aGUgdW5pb24gZGVwZW5kcyBvbiB0aGUgZW5jb2RlZCBzcGFuIG9mIGl0cyB2YXJpYW50ICh3aGljaCBtYXlcbiAqIGJlIGZpeGVkIG9yIHZhcmlhYmxlKS5cbiAqXG4gKiB7QGxpbmsgVmFyaWFudExheW91dCNsYXlvdXR8VmFyaWFudCBsYXlvdXR9cyBhcmUgYWRkZWQgdGhyb3VnaFxuICoge0BsaW5rIFVuaW9uI2FkZFZhcmlhbnR8YWRkVmFyaWFudH0uICBJZiB0aGUgdW5pb24gaGFzIGEgZGVmYXVsdFxuICogbGF5b3V0LCB0aGUgc3BhbiBvZiB0aGUge0BsaW5rIFZhcmlhbnRMYXlvdXQjbGF5b3V0fGxheW91dFxuICogY29udGFpbmVkIGJ5IHRoZSB2YXJpYW50fSBtdXN0IG5vdCBleGNlZWQgdGhlIHNwYW4gb2YgdGhlIHtAbGlua1xuICogVW5pb24jZGVmYXVsdExheW91dHxkZWZhdWx0IGxheW91dH0gKG1pbnVzIHRoZSBzcGFuIG9mIGEge0BsaW5rXG4gKiBVbmlvbiN1c2VzUHJlZml4RGlzY3JpbWluYXRvcnxwcmVmaXggZGlzcmltaW5hdG9yfSwgaWYgdXNlZCkuICBUaGVcbiAqIHNwYW4gb2YgdGhlIHZhcmlhbnQgd2lsbCBlcXVhbCB0aGUgc3BhbiBvZiB0aGUgdW5pb24gaXRzZWxmLlxuICpcbiAqIFRoZSB2YXJpYW50IGZvciBhIGJ1ZmZlciBjYW4gb25seSBiZSBpZGVudGlmaWVkIGZyb20gdGhlIHtAbGlua1xuICogVW5pb24jZGlzY3JpbWluYXRvcnxkaXNjcmltaW5hdG9yfSB7QGxpbmtcbiAqIFVuaW9uRGlzY3JpbWluYXRvciNwcm9wZXJ0eXxwcm9wZXJ0eX0gKGluIHRoZSBjYXNlIG9mIHRoZSB7QGxpbmtcbiAqIFVuaW9uI2RlZmF1bHRMYXlvdXR8ZGVmYXVsdCBsYXlvdXR9KSwgb3IgYnkgdXNpbmcge0BsaW5rXG4gKiBVbmlvbiNnZXRWYXJpYW50fGdldFZhcmlhbnR9IGFuZCBleGFtaW5pbmcgdGhlIHJlc3VsdGluZyB7QGxpbmtcbiAqIFZhcmlhbnRMYXlvdXR9IGluc3RhbmNlLlxuICpcbiAqIEEgdmFyaWFudCBjb21wYXRpYmxlIHdpdGggYSBKYXZhU2NyaXB0IG9iamVjdCBjYW4gYmUgaWRlbnRpZmllZFxuICogdXNpbmcge0BsaW5rIFVuaW9uI2dldFNvdXJjZVZhcmlhbnR8Z2V0U291cmNlVmFyaWFudH0uXG4gKlxuICogQHBhcmFtIHsoVW5pb25EaXNjcmltaW5hdG9yfEV4dGVybmFsTGF5b3V0fExheW91dCl9IGRpc2NyIC0gSG93IHRvXG4gKiBpZGVudGlmeSB0aGUgbGF5b3V0IHVzZWQgdG8gaW50ZXJwcmV0IHRoZSB1bmlvbiBjb250ZW50cy4gIFRoZVxuICogcGFyYW1ldGVyIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rIFVuaW9uRGlzY3JpbWluYXRvcn0sIGFuXG4gKiB7QGxpbmsgRXh0ZXJuYWxMYXlvdXR9IHRoYXQgc2F0aXNmaWVzIHtAbGlua1xuICogRXh0ZXJuYWxMYXlvdXQjaXNDb3VudHxpc0NvdW50KCl9LCBvciB7QGxpbmsgVUludH0gKG9yIHtAbGlua1xuICogVUludEJFfSkuICBXaGVuIGEgbm9uLWV4dGVybmFsIGxheW91dCBlbGVtZW50IGlzIHBhc3NlZCB0aGUgbGF5b3V0XG4gKiBhcHBlYXJzIGF0IHRoZSBzdGFydCBvZiB0aGUgdW5pb24uICBJbiBhbGwgY2FzZXMgdGhlIChzeW50aGVzaXplZClcbiAqIHtAbGluayBVbmlvbkRpc2NyaW1pbmF0b3J9IGluc3RhbmNlIGlzIHJlY29yZGVkIGFzIHtAbGlua1xuICogVW5pb24jZGlzY3JpbWluYXRvcnxkaXNjcmltaW5hdG9yfS5cbiAqXG4gKiBAcGFyYW0geyhMYXlvdXR8bnVsbCl9IGRlZmF1bHRMYXlvdXQgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBVbmlvbiNkZWZhdWx0TGF5b3V0fGRlZmF1bHRMYXlvdXR9LiAgSWYgYWJzZW50IGRlZmF1bHRzIHRvIGBudWxsYC5cbiAqIElmIGBudWxsYCB0aGVyZSBpcyBubyBkZWZhdWx0IGxheW91dDogdGhlIHVuaW9uIGhhcyBkYXRhLWRlcGVuZGVudFxuICogbGVuZ3RoIGFuZCBhdHRlbXB0cyB0byBkZWNvZGUgb3IgZW5jb2RlIHVucmVjb2duaXplZCB2YXJpYW50cyB3aWxsXG4gKiB0aHJvdyBhbiBleGNlcHRpb24uICBBIHtAbGluayBMYXlvdXR9IGluc3RhbmNlIG11c3QgaGF2ZSBhXG4gKiBub24tbmVnYXRpdmUge0BsaW5rIExheW91dCNzcGFufHNwYW59LCBhbmQgaWYgaXQgbGFja3MgYSB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0gdGhlIHtAbGlua1xuICogVW5pb24jZGVmYXVsdExheW91dHxkZWZhdWx0TGF5b3V0fSB3aWxsIGJlIGEge0BsaW5rXG4gKiBMYXlvdXQjcmVwbGljYXRlfHJlcGxpY2F9IHdpdGggcHJvcGVydHkgYGNvbnRlbnRgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgVW5pb24gZXh0ZW5kcyBMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKGRpc2NyLCBkZWZhdWx0TGF5b3V0LCBwcm9wZXJ0eSkge1xuICAgICAgICBsZXQgZGlzY3JpbWluYXRvcjtcbiAgICAgICAgaWYgKChkaXNjciBpbnN0YW5jZW9mIFVJbnQpXG4gICAgICAgICAgICB8fCAoZGlzY3IgaW5zdGFuY2VvZiBVSW50QkUpKSB7XG4gICAgICAgICAgICBkaXNjcmltaW5hdG9yID0gbmV3IFVuaW9uTGF5b3V0RGlzY3JpbWluYXRvcihuZXcgT2Zmc2V0TGF5b3V0KGRpc2NyKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGRpc2NyIGluc3RhbmNlb2YgRXh0ZXJuYWxMYXlvdXQpXG4gICAgICAgICAgICAmJiBkaXNjci5pc0NvdW50KCkpIHtcbiAgICAgICAgICAgIGRpc2NyaW1pbmF0b3IgPSBuZXcgVW5pb25MYXlvdXREaXNjcmltaW5hdG9yKGRpc2NyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghKGRpc2NyIGluc3RhbmNlb2YgVW5pb25EaXNjcmltaW5hdG9yKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZGlzY3IgbXVzdCBiZSBhIFVuaW9uRGlzY3JpbWluYXRvciAnXG4gICAgICAgICAgICAgICAgKyAnb3IgYW4gdW5zaWduZWQgaW50ZWdlciBsYXlvdXQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRpc2NyaW1pbmF0b3IgPSBkaXNjcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5kZWZpbmVkID09PSBkZWZhdWx0TGF5b3V0KSB7XG4gICAgICAgICAgICBkZWZhdWx0TGF5b3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISgobnVsbCA9PT0gZGVmYXVsdExheW91dClcbiAgICAgICAgICAgIHx8IChkZWZhdWx0TGF5b3V0IGluc3RhbmNlb2YgTGF5b3V0KSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2RlZmF1bHRMYXlvdXQgbXVzdCBiZSBudWxsIG9yIGEgTGF5b3V0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG51bGwgIT09IGRlZmF1bHRMYXlvdXQpIHtcbiAgICAgICAgICAgIGlmICgwID4gZGVmYXVsdExheW91dC5zcGFuKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkZWZhdWx0TGF5b3V0IG11c3QgaGF2ZSBjb25zdGFudCBzcGFuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkID09PSBkZWZhdWx0TGF5b3V0LnByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdExheW91dCA9IGRlZmF1bHRMYXlvdXQucmVwbGljYXRlKCdjb250ZW50Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyogVGhlIHVuaW9uIHNwYW4gY2FuIGJlIGVzdGltYXRlZCBvbmx5IGlmIHRoZXJlJ3MgYSBkZWZhdWx0XG4gICAgICAgICAqIGxheW91dC4gIFRoZSB1bmlvbiBzcGFucyBpdHMgZGVmYXVsdCBsYXlvdXQsIHBsdXMgYW55IHByZWZpeFxuICAgICAgICAgKiB2YXJpYW50IGxheW91dC4gIEJ5IGNvbnN0cnVjdGlvbiBib3RoIGxheW91dHMsIGlmIHByZXNlbnQsIGhhdmVcbiAgICAgICAgICogbm9uLW5lZ2F0aXZlIHNwYW4uICovXG4gICAgICAgIGxldCBzcGFuID0gLTE7XG4gICAgICAgIGlmIChkZWZhdWx0TGF5b3V0KSB7XG4gICAgICAgICAgICBzcGFuID0gZGVmYXVsdExheW91dC5zcGFuO1xuICAgICAgICAgICAgaWYgKCgwIDw9IHNwYW4pICYmICgoZGlzY3IgaW5zdGFuY2VvZiBVSW50KVxuICAgICAgICAgICAgICAgIHx8IChkaXNjciBpbnN0YW5jZW9mIFVJbnRCRSkpKSB7XG4gICAgICAgICAgICAgICAgc3BhbiArPSBkaXNjcmltaW5hdG9yLmxheW91dC5zcGFuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN1cGVyKHNwYW4sIHByb3BlcnR5KTtcbiAgICAgICAgLyoqIFRoZSBpbnRlcmZhY2UgZm9yIHRoZSBkaXNjcmltaW5hdG9yIHZhbHVlIGluIGlzb2xhdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBhIHtAbGluayBVbmlvbkRpc2NyaW1pbmF0b3J9IGVpdGhlciBwYXNzZWQgdG8gdGhlXG4gICAgICAgICAqIGNvbnN0cnVjdG9yIG9yIHN5bnRoZXNpemVkIGZyb20gdGhlIGBkaXNjcmAgY29uc3RydWN0b3JcbiAgICAgICAgICogYXJndW1lbnQuICB7QGxpbmtcbiAgICAgICAgICogVW5pb24jdXNlc1ByZWZpeERpc2NyaW1pbmF0b3J8dXNlc1ByZWZpeERpc2NyaW1pbmF0b3J9IHdpbGwgYmVcbiAgICAgICAgICogYHRydWVgIGlmZiB0aGUgYGRpc2NyYCBwYXJhbWV0ZXIgd2FzIGEgbm9uLW9mZnNldCB7QGxpbmtcbiAgICAgICAgICogTGF5b3V0fSBpbnN0YW5jZS4gKi9cbiAgICAgICAgdGhpcy5kaXNjcmltaW5hdG9yID0gZGlzY3JpbWluYXRvcjtcbiAgICAgICAgLyoqIGB0cnVlYCBpZiB0aGUge0BsaW5rIFVuaW9uI2Rpc2NyaW1pbmF0b3J8ZGlzY3JpbWluYXRvcn0gaXMgdGhlXG4gICAgICAgICAqIGZpcnN0IGZpZWxkIGluIHRoZSB1bmlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgYGZhbHNlYCB0aGUgZGlzY3JpbWluYXRvciBpcyBvYnRhaW5lZCBmcm9tIHNvbWV3aGVyZVxuICAgICAgICAgKiBlbHNlLiAqL1xuICAgICAgICB0aGlzLnVzZXNQcmVmaXhEaXNjcmltaW5hdG9yID0gKGRpc2NyIGluc3RhbmNlb2YgVUludClcbiAgICAgICAgICAgIHx8IChkaXNjciBpbnN0YW5jZW9mIFVJbnRCRSk7XG4gICAgICAgIC8qKiBUaGUgbGF5b3V0IGZvciBub24tZGlzY3JpbWluYXRvciBjb250ZW50IHdoZW4gdGhlIHZhbHVlIG9mIHRoZVxuICAgICAgICAgKiBkaXNjcmltaW5hdG9yIGlzIG5vdCByZWNvZ25pemVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGlzIHRoZSB2YWx1ZSBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yLiAgSXQgaXNcbiAgICAgICAgICogc3RydWN0dXJhbGx5IGVxdWl2YWxlbnQgdG8gdGhlIHNlY29uZCBjb21wb25lbnQgb2Yge0BsaW5rXG4gICAgICAgICAqIFVuaW9uI2xheW91dHxsYXlvdXR9IGJ1dCBtYXkgaGF2ZSBhIGRpZmZlcmVudCBwcm9wZXJ0eVxuICAgICAgICAgKiBuYW1lLiAqL1xuICAgICAgICB0aGlzLmRlZmF1bHRMYXlvdXQgPSBkZWZhdWx0TGF5b3V0O1xuICAgICAgICAvKiogQSByZWdpc3RyeSBvZiBhbGxvd2VkIHZhcmlhbnRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUga2V5cyBhcmUgdW5zaWduZWQgaW50ZWdlcnMgd2hpY2ggc2hvdWxkIGJlIGNvbXBhdGlibGUgd2l0aFxuICAgICAgICAgKiB7QGxpbmsgVW5pb24uZGlzY3JpbWluYXRvcnxkaXNjcmltaW5hdG9yfS4gIFRoZSBwcm9wZXJ0eSB2YWx1ZVxuICAgICAgICAgKiBpcyB0aGUgY29ycmVzcG9uZGluZyB7QGxpbmsgVmFyaWFudExheW91dH0gaW5zdGFuY2VzIGFzc2lnbmVkXG4gICAgICAgICAqIHRvIHRoaXMgdW5pb24gYnkge0BsaW5rIFVuaW9uI2FkZFZhcmlhbnR8YWRkVmFyaWFudH0uXG4gICAgICAgICAqXG4gICAgICAgICAqICoqTk9URSoqIFRoZSByZWdpc3RyeSByZW1haW5zIG11dGFibGUgc28gdGhhdCB2YXJpYW50cyBjYW4gYmVcbiAgICAgICAgICoge0BsaW5rIFVuaW9uI2FkZFZhcmlhbnR8YWRkZWR9IGF0IGFueSB0aW1lLiAgVXNlcnMgc2hvdWxkIG5vdFxuICAgICAgICAgKiBtYW5pcHVsYXRlIHRoZSBjb250ZW50IG9mIHRoaXMgcHJvcGVydHkuICovXG4gICAgICAgIHRoaXMucmVnaXN0cnkgPSB7fTtcbiAgICAgICAgLyogUHJpdmF0ZSB2YXJpYWJsZSB1c2VkIHdoZW4gaW52b2tpbmcgZ2V0U291cmNlVmFyaWFudCAqL1xuICAgICAgICBsZXQgYm91bmRHZXRTb3VyY2VWYXJpYW50ID0gdGhpcy5kZWZhdWx0R2V0U291cmNlVmFyaWFudC5iaW5kKHRoaXMpO1xuICAgICAgICAvKiogRnVuY3Rpb24gdG8gaW5mZXIgdGhlIHZhcmlhbnQgc2VsZWN0ZWQgYnkgYSBzb3VyY2Ugb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBEZWZhdWx0cyB0byB7QGxpbmtcbiAgICAgICAgICogVW5pb24jZGVmYXVsdEdldFNvdXJjZVZhcmlhbnR8ZGVmYXVsdEdldFNvdXJjZVZhcmlhbnR9IGJ1dCBtYXlcbiAgICAgICAgICogYmUgb3ZlcnJpZGRlbiB1c2luZyB7QGxpbmtcbiAgICAgICAgICogVW5pb24jY29uZmlnR2V0U291cmNlVmFyaWFudHxjb25maWdHZXRTb3VyY2VWYXJpYW50fS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHNyYyAtIGFzIHdpdGgge0BsaW5rXG4gICAgICAgICAqIFVuaW9uI2RlZmF1bHRHZXRTb3VyY2VWYXJpYW50fGRlZmF1bHRHZXRTb3VyY2VWYXJpYW50fS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMgeyh1bmRlZmluZWR8VmFyaWFudExheW91dCl9IFRoZSBkZWZhdWx0IHZhcmlhbnRcbiAgICAgICAgICogKGB1bmRlZmluZWRgKSBvciBmaXJzdCByZWdpc3RlcmVkIHZhcmlhbnQgdGhhdCB1c2VzIGEgcHJvcGVydHlcbiAgICAgICAgICogYXZhaWxhYmxlIGluIGBzcmNgLiAqL1xuICAgICAgICB0aGlzLmdldFNvdXJjZVZhcmlhbnQgPSBmdW5jdGlvbiAoc3JjKSB7XG4gICAgICAgICAgICByZXR1cm4gYm91bmRHZXRTb3VyY2VWYXJpYW50KHNyYyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBGdW5jdGlvbiB0byBvdmVycmlkZSB0aGUgaW1wbGVtZW50YXRpb24gb2Yge0BsaW5rXG4gICAgICAgICAqIFVuaW9uI2dldFNvdXJjZVZhcmlhbnR8Z2V0U291cmNlVmFyaWFudH0uXG4gICAgICAgICAqXG4gICAgICAgICAqIFVzZSB0aGlzIGlmIHRoZSBkZXNpcmVkIHZhcmlhbnQgY2Fubm90IGJlIGlkZW50aWZpZWQgdXNpbmcgdGhlXG4gICAgICAgICAqIGFsZ29yaXRobSBvZiB7QGxpbmtcbiAgICAgICAgICogVW5pb24jZGVmYXVsdEdldFNvdXJjZVZhcmlhbnR8ZGVmYXVsdEdldFNvdXJjZVZhcmlhbnR9LlxuICAgICAgICAgKlxuICAgICAgICAgKiAqKk5PVEUqKiBUaGUgcHJvdmlkZWQgZnVuY3Rpb24gd2lsbCBiZSBpbnZva2VkIGJvdW5kIHRvIHRoaXNcbiAgICAgICAgICogVW5pb24gaW5zdGFuY2UsIHByb3ZpZGluZyBsb2NhbCBhY2Nlc3MgdG8ge0BsaW5rXG4gICAgICAgICAqIFVuaW9uI3JlZ2lzdHJ5fHJlZ2lzdHJ5fS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZ3N2IC0gYSBmdW5jdGlvbiB0aGF0IGZvbGxvd3MgdGhlIEFQSSBvZlxuICAgICAgICAgKiB7QGxpbmsgVW5pb24jZGVmYXVsdEdldFNvdXJjZVZhcmlhbnR8ZGVmYXVsdEdldFNvdXJjZVZhcmlhbnR9LiAqL1xuICAgICAgICB0aGlzLmNvbmZpZ0dldFNvdXJjZVZhcmlhbnQgPSBmdW5jdGlvbiAoZ3N2KSB7XG4gICAgICAgICAgICBib3VuZEdldFNvdXJjZVZhcmlhbnQgPSBnc3YuYmluZCh0aGlzKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGdldFNwYW4oYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBpZiAoMCA8PSB0aGlzLnNwYW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNwYW47XG4gICAgICAgIH1cbiAgICAgICAgLyogRGVmYXVsdCBsYXlvdXRzIGFsd2F5cyBoYXZlIG5vbi1uZWdhdGl2ZSBzcGFuLCBzbyB3ZSBkb24ndCBoYXZlXG4gICAgICAgICAqIG9uZSBhbmQgd2UgaGF2ZSB0byByZWNvZ25pemUgdGhlIHZhcmlhbnQgd2hpY2ggd2lsbCBpbiB0dXJuXG4gICAgICAgICAqIGRldGVybWluZSB0aGUgc3Bhbi4gKi9cbiAgICAgICAgY29uc3QgdmxvID0gdGhpcy5nZXRWYXJpYW50KGIsIG9mZnNldCk7XG4gICAgICAgIGlmICghdmxvKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuYWJsZSB0byBkZXRlcm1pbmUgc3BhbiBmb3IgdW5yZWNvZ25pemVkIHZhcmlhbnQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmxvLmdldFNwYW4oYiwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRvIGluZmVyIGEgcmVnaXN0ZXJlZCBVbmlvbiB2YXJpYW50IGNvbXBhdGlibGUgd2l0aCBgc3JjYC5cbiAgICAgKlxuICAgICAqIFRoZSBmaXJzdCBzYXRpc2ZpZWQgcnVsZSBpbiB0aGUgZm9sbG93aW5nIHNlcXVlbmNlIGRlZmluZXMgdGhlXG4gICAgICogcmV0dXJuIHZhbHVlOlxuICAgICAqICogSWYgYHNyY2AgaGFzIHByb3BlcnRpZXMgbWF0Y2hpbmcgdGhlIFVuaW9uIGRpc2NyaW1pbmF0b3IgYW5kXG4gICAgICogICB0aGUgZGVmYXVsdCBsYXlvdXQsIGB1bmRlZmluZWRgIGlzIHJldHVybmVkIHJlZ2FyZGxlc3Mgb2YgdGhlXG4gICAgICogICB2YWx1ZSBvZiB0aGUgZGlzY3JpbWluYXRvciBwcm9wZXJ0eSAodGhpcyBlbnN1cmVzIHRoZSBkZWZhdWx0XG4gICAgICogICBsYXlvdXQgd2lsbCBiZSB1c2VkKTtcbiAgICAgKiAqIElmIGBzcmNgIGhhcyBhIHByb3BlcnR5IG1hdGNoaW5nIHRoZSBVbmlvbiBkaXNjcmltaW5hdG9yLCB0aGVcbiAgICAgKiAgIHZhbHVlIG9mIHRoZSBkaXNjcmltaW5hdG9yIGlkZW50aWZpZXMgYSByZWdpc3RlcmVkIHZhcmlhbnQsIGFuZFxuICAgICAqICAgZWl0aGVyIChhKSB0aGUgdmFyaWFudCBoYXMgbm8gbGF5b3V0LCBvciAoYikgYHNyY2AgaGFzIHRoZVxuICAgICAqICAgdmFyaWFudCdzIHByb3BlcnR5LCB0aGVuIHRoZSB2YXJpYW50IGlzIHJldHVybmVkIChiZWNhdXNlIHRoZVxuICAgICAqICAgc291cmNlIHNhdGlzZmllcyB0aGUgY29uc3RyYWludHMgb2YgdGhlIHZhcmlhbnQgaXQgaWRlbnRpZmllcyk7XG4gICAgICogKiBJZiBgc3JjYCBkb2VzIG5vdCBoYXZlIGEgcHJvcGVydHkgbWF0Y2hpbmcgdGhlIFVuaW9uXG4gICAgICogICBkaXNjcmltaW5hdG9yLCBidXQgZG9lcyBoYXZlIGEgcHJvcGVydHkgbWF0Y2hpbmcgYSByZWdpc3RlcmVkXG4gICAgICogICB2YXJpYW50LCB0aGVuIHRoZSB2YXJpYW50IGlzIHJldHVybmVkIChiZWNhdXNlIHRoZSBzb3VyY2VcbiAgICAgKiAgIG1hdGNoZXMgYSB2YXJpYW50IHdpdGhvdXQgYW4gZXhwbGljaXQgY29uZmxpY3QpO1xuICAgICAqICogQW4gZXJyb3IgaXMgdGhyb3duIChiZWNhdXNlIHdlIGVpdGhlciBjYW4ndCBpZGVudGlmeSBhIHZhcmlhbnQsXG4gICAgICogICBvciB3ZSB3ZXJlIGV4cGxpY2l0bHkgdG9sZCB0aGUgdmFyaWFudCBidXQgY2FuJ3Qgc2F0aXNmeSBpdCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3JjIC0gYW4gb2JqZWN0IHByZXN1bWVkIHRvIGJlIGNvbXBhdGlibGUgd2l0aFxuICAgICAqIHRoZSBjb250ZW50IG9mIHRoZSBVbmlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm4geyh1bmRlZmluZWR8VmFyaWFudExheW91dCl9IC0gYXMgZGVzY3JpYmVkIGFib3ZlLlxuICAgICAqXG4gICAgICogQHRocm93cyB7RXJyb3J9IC0gaWYgYHNyY2AgY2Fubm90IGJlIGFzc29jaWF0ZWQgd2l0aCBhIGRlZmF1bHQgb3JcbiAgICAgKiByZWdpc3RlcmVkIHZhcmlhbnQuXG4gICAgICovXG4gICAgZGVmYXVsdEdldFNvdXJjZVZhcmlhbnQoc3JjKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc3JjLCB0aGlzLmRpc2NyaW1pbmF0b3IucHJvcGVydHkpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kZWZhdWx0TGF5b3V0ICYmIHRoaXMuZGVmYXVsdExheW91dC5wcm9wZXJ0eVxuICAgICAgICAgICAgICAgICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzcmMsIHRoaXMuZGVmYXVsdExheW91dC5wcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdmxvID0gdGhpcy5yZWdpc3RyeVtzcmNbdGhpcy5kaXNjcmltaW5hdG9yLnByb3BlcnR5XV07XG4gICAgICAgICAgICBpZiAodmxvXG4gICAgICAgICAgICAgICAgJiYgKCghdmxvLmxheW91dClcbiAgICAgICAgICAgICAgICAgICAgfHwgKHZsby5wcm9wZXJ0eSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc3JjLCB2bG8ucHJvcGVydHkpKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmxvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCB0YWcgaW4gdGhpcy5yZWdpc3RyeSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZsbyA9IHRoaXMucmVnaXN0cnlbdGFnXTtcbiAgICAgICAgICAgICAgICBpZiAodmxvLnByb3BlcnR5ICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzcmMsIHZsby5wcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZsbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmFibGUgdG8gaW5mZXIgc3JjIHZhcmlhbnQnKTtcbiAgICB9XG4gICAgLyoqIEltcGxlbWVudCB7QGxpbmsgTGF5b3V0I2RlY29kZXxkZWNvZGV9IGZvciB7QGxpbmsgVW5pb259LlxuICAgICAqXG4gICAgICogSWYgdGhlIHZhcmlhbnQgaXMge0BsaW5rIFVuaW9uI2FkZFZhcmlhbnR8cmVnaXN0ZXJlZH0gdGhlIHJldHVyblxuICAgICAqIHZhbHVlIGlzIGFuIGluc3RhbmNlIG9mIHRoYXQgdmFyaWFudCwgd2l0aCBubyBleHBsaWNpdFxuICAgICAqIGRpc2NyaW1pbmF0b3IuICBPdGhlcndpc2UgdGhlIHtAbGluayBVbmlvbiNkZWZhdWx0TGF5b3V0fGRlZmF1bHRcbiAgICAgKiBsYXlvdXR9IGlzIHVzZWQgdG8gZGVjb2RlIHRoZSBjb250ZW50LiAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGxldCBkZXN0O1xuICAgICAgICBjb25zdCBkbG8gPSB0aGlzLmRpc2NyaW1pbmF0b3I7XG4gICAgICAgIGNvbnN0IGRpc2NyID0gZGxvLmRlY29kZShiLCBvZmZzZXQpO1xuICAgICAgICBjb25zdCBjbG8gPSB0aGlzLnJlZ2lzdHJ5W2Rpc2NyXTtcbiAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gY2xvKSB7XG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0TGF5b3V0ID0gdGhpcy5kZWZhdWx0TGF5b3V0O1xuICAgICAgICAgICAgbGV0IGNvbnRlbnRPZmZzZXQgPSAwO1xuICAgICAgICAgICAgaWYgKHRoaXMudXNlc1ByZWZpeERpc2NyaW1pbmF0b3IpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50T2Zmc2V0ID0gZGxvLmxheW91dC5zcGFuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVzdCA9IHRoaXMubWFrZURlc3RpbmF0aW9uT2JqZWN0KCk7XG4gICAgICAgICAgICBkZXN0W2Rsby5wcm9wZXJ0eV0gPSBkaXNjcjtcbiAgICAgICAgICAgIC8vIGRlZmF1bHRMYXlvdXQucHJvcGVydHkgY2FuIGJlIHVuZGVmaW5lZCwgYnV0IHRoaXMgaXMgYWxsb3dlZCBieSBidWZmZXItbGF5b3V0XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgZGVzdFtkZWZhdWx0TGF5b3V0LnByb3BlcnR5XSA9IGRlZmF1bHRMYXlvdXQuZGVjb2RlKGIsIG9mZnNldCArIGNvbnRlbnRPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVzdCA9IGNsby5kZWNvZGUoYiwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9XG4gICAgLyoqIEltcGxlbWVudCB7QGxpbmsgTGF5b3V0I2VuY29kZXxlbmNvZGV9IGZvciB7QGxpbmsgVW5pb259LlxuICAgICAqXG4gICAgICogVGhpcyBBUEkgYXNzdW1lcyB0aGUgYHNyY2Agb2JqZWN0IGlzIGNvbnNpc3RlbnQgd2l0aCB0aGUgdW5pb24nc1xuICAgICAqIHtAbGluayBVbmlvbiNkZWZhdWx0TGF5b3V0fGRlZmF1bHQgbGF5b3V0fS4gIFRvIGVuY29kZSB2YXJpYW50c1xuICAgICAqIHVzZSB0aGUgYXBwcm9wcmlhdGUgdmFyaWFudC1zcGVjaWZpYyB7QGxpbmsgVmFyaWFudExheW91dCNlbmNvZGV9XG4gICAgICogbWV0aG9kLiAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgY29uc3QgdmxvID0gdGhpcy5nZXRTb3VyY2VWYXJpYW50KHNyYyk7XG4gICAgICAgIGlmICh1bmRlZmluZWQgPT09IHZsbykge1xuICAgICAgICAgICAgY29uc3QgZGxvID0gdGhpcy5kaXNjcmltaW5hdG9yO1xuICAgICAgICAgICAgLy8gdGhpcy5kZWZhdWx0TGF5b3V0IGlzIG5vdCB1bmRlZmluZWQgd2hlbiB2bG8gaXMgdW5kZWZpbmVkXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgY29uc3QgY2xvID0gdGhpcy5kZWZhdWx0TGF5b3V0O1xuICAgICAgICAgICAgbGV0IGNvbnRlbnRPZmZzZXQgPSAwO1xuICAgICAgICAgICAgaWYgKHRoaXMudXNlc1ByZWZpeERpc2NyaW1pbmF0b3IpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50T2Zmc2V0ID0gZGxvLmxheW91dC5zcGFuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGxvLmVuY29kZShzcmNbZGxvLnByb3BlcnR5XSwgYiwgb2Zmc2V0KTtcbiAgICAgICAgICAgIC8vIGNsby5wcm9wZXJ0eSBpcyBub3QgdW5kZWZpbmVkIHdoZW4gdmxvIGlzIHVuZGVmaW5lZFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgIHJldHVybiBjb250ZW50T2Zmc2V0ICsgY2xvLmVuY29kZShzcmNbY2xvLnByb3BlcnR5XSwgYiwgb2Zmc2V0ICsgY29udGVudE9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZsby5lbmNvZGUoc3JjLCBiLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKiogUmVnaXN0ZXIgYSBuZXcgdmFyaWFudCBzdHJ1Y3R1cmUgd2l0aGluIGEgdW5pb24uICBUaGUgbmV3bHlcbiAgICAgKiBjcmVhdGVkIHZhcmlhbnQgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFyaWFudCAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAgICAgKiBWYXJpYW50TGF5b3V0I3ZhcmlhbnR8dmFyaWFudH0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0xheW91dH0gbGF5b3V0IC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICAgICAqIFZhcmlhbnRMYXlvdXQjbGF5b3V0fGxheW91dH0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gICAgICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1ZhcmlhbnRMYXlvdXR9ICovXG4gICAgYWRkVmFyaWFudCh2YXJpYW50LCBsYXlvdXQsIHByb3BlcnR5KSB7XG4gICAgICAgIGNvbnN0IHJ2ID0gbmV3IFZhcmlhbnRMYXlvdXQodGhpcywgdmFyaWFudCwgbGF5b3V0LCBwcm9wZXJ0eSk7XG4gICAgICAgIHRoaXMucmVnaXN0cnlbdmFyaWFudF0gPSBydjtcbiAgICAgICAgcmV0dXJuIHJ2O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGxheW91dCBhc3NvY2lhdGVkIHdpdGggYSByZWdpc3RlcmVkIHZhcmlhbnQuXG4gICAgICpcbiAgICAgKiBJZiBgdmJgIGRvZXMgbm90IHByb2R1Y2UgYSByZWdpc3RlcmVkIHZhcmlhbnQgdGhlIGZ1bmN0aW9uIHJldHVybnNcbiAgICAgKiBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7KE51bWJlcnxVaW50OEFycmF5KX0gdmIgLSBlaXRoZXIgdGhlIHZhcmlhbnQgbnVtYmVyLCBvciBhXG4gICAgICogYnVmZmVyIGZyb20gd2hpY2ggdGhlIGRpc2NyaW1pbmF0b3IgaXMgdG8gYmUgcmVhZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgLSBvZmZzZXQgaW50byBgdmJgIGZvciB0aGUgc3RhcnQgb2YgdGhlXG4gICAgICogdW5pb24uICBVc2VkIG9ubHkgd2hlbiBgdmJgIGlzIGFuIGluc3RhbmNlIG9mIHtVaW50OEFycmF5fS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4geyh7VmFyaWFudExheW91dH18dW5kZWZpbmVkKX1cbiAgICAgKi9cbiAgICBnZXRWYXJpYW50KHZiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGxldCB2YXJpYW50O1xuICAgICAgICBpZiAodmIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICB2YXJpYW50ID0gdGhpcy5kaXNjcmltaW5hdG9yLmRlY29kZSh2Yiwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhcmlhbnQgPSB2YjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZWdpc3RyeVt2YXJpYW50XTtcbiAgICB9XG59XG5leHBvcnRzLlVuaW9uID0gVW5pb247XG4vKipcbiAqIFJlcHJlc2VudCBhIHNwZWNpZmljIHZhcmlhbnQgd2l0aGluIGEgY29udGFpbmluZyB1bmlvbi5cbiAqXG4gKiAqKk5PVEUqKiBUaGUge0BsaW5rIExheW91dCNzcGFufHNwYW59IG9mIHRoZSB2YXJpYW50IG1heSBpbmNsdWRlXG4gKiB0aGUgc3BhbiBvZiB0aGUge0BsaW5rIFVuaW9uI2Rpc2NyaW1pbmF0b3J8ZGlzY3JpbWluYXRvcn0gdXNlZCB0b1xuICogaWRlbnRpZnkgaXQsIGJ1dCB2YWx1ZXMgcmVhZCBhbmQgd3JpdHRlbiB1c2luZyB0aGUgdmFyaWFudCBzdHJpY3RseVxuICogY29uZm9ybSB0byB0aGUgY29udGVudCBvZiB7QGxpbmsgVmFyaWFudExheW91dCNsYXlvdXR8bGF5b3V0fS5cbiAqXG4gKiAqKk5PVEUqKiBVc2VyIGNvZGUgc2hvdWxkIG5vdCBpbnZva2UgdGhpcyBjb25zdHJ1Y3RvciBkaXJlY3RseS4gIFVzZVxuICogdGhlIHVuaW9uIHtAbGluayBVbmlvbiNhZGRWYXJpYW50fGFkZFZhcmlhbnR9IGhlbHBlciBtZXRob2QuXG4gKlxuICogQHBhcmFtIHtVbmlvbn0gdW5pb24gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBWYXJpYW50TGF5b3V0I3VuaW9ufHVuaW9ufS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gdmFyaWFudCAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIFZhcmlhbnRMYXlvdXQjdmFyaWFudHx2YXJpYW50fS5cbiAqXG4gKiBAcGFyYW0ge0xheW91dH0gW2xheW91dF0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBWYXJpYW50TGF5b3V0I2xheW91dHxsYXlvdXR9LiAgSWYgYWJzZW50IHRoZSB2YXJpYW50IGNhcnJpZXMgbm9cbiAqIGRhdGEuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LiAgVW5saWtlIG1hbnkgb3RoZXIgbGF5b3V0cywgdmFyaWFudFxuICogbGF5b3V0cyBub3JtYWxseSBpbmNsdWRlIGEgcHJvcGVydHkgbmFtZSBzbyB0aGV5IGNhbiBiZSBpZGVudGlmaWVkXG4gKiB3aXRoaW4gdGhlaXIgY29udGFpbmluZyB7QGxpbmsgVW5pb259LiAgVGhlIHByb3BlcnR5IGlkZW50aWZpZXIgbWF5XG4gKiBiZSBhYnNlbnQgb25seSBpZiBgbGF5b3V0YCBpcyBpcyBhYnNlbnQuXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIFZhcmlhbnRMYXlvdXQgZXh0ZW5kcyBMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKHVuaW9uLCB2YXJpYW50LCBsYXlvdXQsIHByb3BlcnR5KSB7XG4gICAgICAgIGlmICghKHVuaW9uIGluc3RhbmNlb2YgVW5pb24pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1bmlvbiBtdXN0IGJlIGEgVW5pb24nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKCFOdW1iZXIuaXNJbnRlZ2VyKHZhcmlhbnQpKSB8fCAoMCA+IHZhcmlhbnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YXJpYW50IG11c3QgYmUgYSAobm9uLW5lZ2F0aXZlKSBpbnRlZ2VyJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgnc3RyaW5nJyA9PT0gdHlwZW9mIGxheW91dClcbiAgICAgICAgICAgICYmICh1bmRlZmluZWQgPT09IHByb3BlcnR5KSkge1xuICAgICAgICAgICAgcHJvcGVydHkgPSBsYXlvdXQ7XG4gICAgICAgICAgICBsYXlvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXlvdXQpIHtcbiAgICAgICAgICAgIGlmICghKGxheW91dCBpbnN0YW5jZW9mIExheW91dCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdsYXlvdXQgbXVzdCBiZSBhIExheW91dCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChudWxsICE9PSB1bmlvbi5kZWZhdWx0TGF5b3V0KVxuICAgICAgICAgICAgICAgICYmICgwIDw9IGxheW91dC5zcGFuKVxuICAgICAgICAgICAgICAgICYmIChsYXlvdXQuc3BhbiA+IHVuaW9uLmRlZmF1bHRMYXlvdXQuc3BhbikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZhcmlhbnQgc3BhbiBleGNlZWRzIHNwYW4gb2YgY29udGFpbmluZyB1bmlvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgcHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YXJpYW50IG11c3QgaGF2ZSBhIFN0cmluZyBwcm9wZXJ0eScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBzcGFuID0gdW5pb24uc3BhbjtcbiAgICAgICAgaWYgKDAgPiB1bmlvbi5zcGFuKSB7XG4gICAgICAgICAgICBzcGFuID0gbGF5b3V0ID8gbGF5b3V0LnNwYW4gOiAwO1xuICAgICAgICAgICAgaWYgKCgwIDw9IHNwYW4pICYmIHVuaW9uLnVzZXNQcmVmaXhEaXNjcmltaW5hdG9yKSB7XG4gICAgICAgICAgICAgICAgc3BhbiArPSB1bmlvbi5kaXNjcmltaW5hdG9yLmxheW91dC5zcGFuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN1cGVyKHNwYW4sIHByb3BlcnR5KTtcbiAgICAgICAgLyoqIFRoZSB7QGxpbmsgVW5pb259IHRvIHdoaWNoIHRoaXMgdmFyaWFudCBiZWxvbmdzLiAqL1xuICAgICAgICB0aGlzLnVuaW9uID0gdW5pb247XG4gICAgICAgIC8qKiBUaGUgdW5zaWduZWQgaW50ZWdyYWwgdmFsdWUgaWRlbnRpZnlpbmcgdGhpcyB2YXJpYW50IHdpdGhpblxuICAgICAgICAgKiB0aGUge0BsaW5rIFVuaW9uI2Rpc2NyaW1pbmF0b3J8ZGlzY3JpbWluYXRvcn0gb2YgdGhlIGNvbnRhaW5pbmdcbiAgICAgICAgICogdW5pb24uICovXG4gICAgICAgIHRoaXMudmFyaWFudCA9IHZhcmlhbnQ7XG4gICAgICAgIC8qKiBUaGUge0BsaW5rIExheW91dH0gdG8gYmUgdXNlZCB3aGVuIHJlYWRpbmcvd3JpdGluZyB0aGVcbiAgICAgICAgICogbm9uLWRpc2NyaW1pbmF0b3IgcGFydCBvZiB0aGUge0BsaW5rXG4gICAgICAgICAqIFZhcmlhbnRMYXlvdXQjdW5pb258dW5pb259LiAgSWYgYG51bGxgIHRoZSB2YXJpYW50IGNhcnJpZXMgbm9cbiAgICAgICAgICogZGF0YS4gKi9cbiAgICAgICAgdGhpcy5sYXlvdXQgPSBsYXlvdXQgfHwgbnVsbDtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGdldFNwYW4oYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBpZiAoMCA8PSB0aGlzLnNwYW4pIHtcbiAgICAgICAgICAgIC8qIFdpbGwgYmUgZXF1YWwgdG8gdGhlIGNvbnRhaW5pbmcgdW5pb24gc3BhbiBpZiB0aGF0IGlzIG5vdFxuICAgICAgICAgICAgICogdmFyaWFibGUuICovXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zcGFuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb250ZW50T2Zmc2V0ID0gMDtcbiAgICAgICAgaWYgKHRoaXMudW5pb24udXNlc1ByZWZpeERpc2NyaW1pbmF0b3IpIHtcbiAgICAgICAgICAgIGNvbnRlbnRPZmZzZXQgPSB0aGlzLnVuaW9uLmRpc2NyaW1pbmF0b3IubGF5b3V0LnNwYW47XG4gICAgICAgIH1cbiAgICAgICAgLyogU3BhbiBpcyBkZWZpbmVkIHNvbGVseSBieSB0aGUgdmFyaWFudCAoYW5kIHByZWZpeCBkaXNjcmltaW5hdG9yKSAqL1xuICAgICAgICBsZXQgc3BhbiA9IDA7XG4gICAgICAgIGlmICh0aGlzLmxheW91dCkge1xuICAgICAgICAgICAgc3BhbiA9IHRoaXMubGF5b3V0LmdldFNwYW4oYiwgb2Zmc2V0ICsgY29udGVudE9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRlbnRPZmZzZXQgKyBzcGFuO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgY29uc3QgZGVzdCA9IHRoaXMubWFrZURlc3RpbmF0aW9uT2JqZWN0KCk7XG4gICAgICAgIGlmICh0aGlzICE9PSB0aGlzLnVuaW9uLmdldFZhcmlhbnQoYiwgb2Zmc2V0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd2YXJpYW50IG1pc21hdGNoJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvbnRlbnRPZmZzZXQgPSAwO1xuICAgICAgICBpZiAodGhpcy51bmlvbi51c2VzUHJlZml4RGlzY3JpbWluYXRvcikge1xuICAgICAgICAgICAgY29udGVudE9mZnNldCA9IHRoaXMudW5pb24uZGlzY3JpbWluYXRvci5sYXlvdXQuc3BhbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5sYXlvdXQpIHtcbiAgICAgICAgICAgIGRlc3RbdGhpcy5wcm9wZXJ0eV0gPSB0aGlzLmxheW91dC5kZWNvZGUoYiwgb2Zmc2V0ICsgY29udGVudE9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5wcm9wZXJ0eSkge1xuICAgICAgICAgICAgZGVzdFt0aGlzLnByb3BlcnR5XSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy51bmlvbi51c2VzUHJlZml4RGlzY3JpbWluYXRvcikge1xuICAgICAgICAgICAgZGVzdFt0aGlzLnVuaW9uLmRpc2NyaW1pbmF0b3IucHJvcGVydHldID0gdGhpcy52YXJpYW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBsZXQgY29udGVudE9mZnNldCA9IDA7XG4gICAgICAgIGlmICh0aGlzLnVuaW9uLnVzZXNQcmVmaXhEaXNjcmltaW5hdG9yKSB7XG4gICAgICAgICAgICBjb250ZW50T2Zmc2V0ID0gdGhpcy51bmlvbi5kaXNjcmltaW5hdG9yLmxheW91dC5zcGFuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxheW91dFxuICAgICAgICAgICAgJiYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc3JjLCB0aGlzLnByb3BlcnR5KSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhcmlhbnQgbGFja3MgcHJvcGVydHkgJyArIHRoaXMucHJvcGVydHkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudW5pb24uZGlzY3JpbWluYXRvci5lbmNvZGUodGhpcy52YXJpYW50LCBiLCBvZmZzZXQpO1xuICAgICAgICBsZXQgc3BhbiA9IGNvbnRlbnRPZmZzZXQ7XG4gICAgICAgIGlmICh0aGlzLmxheW91dCkge1xuICAgICAgICAgICAgdGhpcy5sYXlvdXQuZW5jb2RlKHNyY1t0aGlzLnByb3BlcnR5XSwgYiwgb2Zmc2V0ICsgY29udGVudE9mZnNldCk7XG4gICAgICAgICAgICBzcGFuICs9IHRoaXMubGF5b3V0LmdldFNwYW4oYiwgb2Zmc2V0ICsgY29udGVudE9mZnNldCk7XG4gICAgICAgICAgICBpZiAoKDAgPD0gdGhpcy51bmlvbi5zcGFuKVxuICAgICAgICAgICAgICAgICYmIChzcGFuID4gdGhpcy51bmlvbi5zcGFuKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZW5jb2RlZCB2YXJpYW50IG92ZXJydW5zIGNvbnRhaW5pbmcgdW5pb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3BhbjtcbiAgICB9XG4gICAgLyoqIERlbGVnYXRlIHtAbGluayBMYXlvdXQjZnJvbUFycmF5fGZyb21BcnJheX0gdG8ge0BsaW5rXG4gICAgICogVmFyaWFudExheW91dCNsYXlvdXR8bGF5b3V0fS4gKi9cbiAgICBmcm9tQXJyYXkodmFsdWVzKSB7XG4gICAgICAgIGlmICh0aGlzLmxheW91dCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGF5b3V0LmZyb21BcnJheSh2YWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZXhwb3J0cy5WYXJpYW50TGF5b3V0ID0gVmFyaWFudExheW91dDtcbi8qKiBKYXZhU2NyaXB0IGNob3NlIHRvIGRlZmluZSBiaXR3aXNlIG9wZXJhdGlvbnMgYXMgb3BlcmF0aW5nIG9uXG4gKiBzaWduZWQgMzItYml0IHZhbHVlcyBpbiAyJ3MgY29tcGxlbWVudCBmb3JtLCBtZWFuaW5nIGFueSBpbnRlZ2VyXG4gKiB3aXRoIGJpdCAzMSBzZXQgaXMgZ29pbmcgdG8gbG9vayBuZWdhdGl2ZS4gIEZvciByaWdodCBzaGlmdHMgdGhhdCdzXG4gKiBub3QgYSBwcm9ibGVtLCBiZWNhdXNlIGA+Pj5gIGlzIGEgbG9naWNhbCBzaGlmdCwgYnV0IGZvciBldmVyeVxuICogb3RoZXIgYml0d2lzZSBvcGVyYXRvciB3ZSBoYXZlIHRvIGNvbXBlbnNhdGUgZm9yIHBvc3NpYmxlIG5lZ2F0aXZlXG4gKiByZXN1bHRzLiAqL1xuZnVuY3Rpb24gZml4Qml0d2lzZVJlc3VsdCh2KSB7XG4gICAgaWYgKDAgPiB2KSB7XG4gICAgICAgIHYgKz0gMHgxMDAwMDAwMDA7XG4gICAgfVxuICAgIHJldHVybiB2O1xufVxuLyoqXG4gKiBDb250YWluIGEgc2VxdWVuY2Ugb2YgYml0IGZpZWxkcyBhcyBhbiB1bnNpZ25lZCBpbnRlZ2VyLlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQuYml0c3xiaXRzfVxuICpcbiAqIFRoaXMgaXMgYSBjb250YWluZXIgZWxlbWVudDsgd2l0aGluIGl0IHRoZXJlIGFyZSB7QGxpbmsgQml0RmllbGR9XG4gKiBpbnN0YW5jZXMgdGhhdCBwcm92aWRlIHRoZSBleHRyYWN0ZWQgcHJvcGVydGllcy4gIFRoZSBjb250YWluZXJcbiAqIHNpbXBseSBkZWZpbmVzIHRoZSBhZ2dyZWdhdGUgcmVwcmVzZW50YXRpb24gYW5kIGl0cyBiaXQgb3JkZXJpbmcuXG4gKiBUaGUgcmVwcmVzZW50YXRpb24gaXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgcHJvcGVydGllcyB3aXRoIG51bWVyaWNcbiAqIG9yIHtAbGluayBCb29sZWFufSB2YWx1ZXMuXG4gKlxuICoge0BsaW5rIEJpdEZpZWxkfXMgYXJlIGFkZGVkIHdpdGggdGhlIHtAbGlua1xuICogQml0U3RydWN0dXJlI2FkZEZpZWxkfGFkZEZpZWxkfSBhbmQge0BsaW5rXG4gKiBCaXRTdHJ1Y3R1cmUjYWRkQm9vbGVhbnxhZGRCb29sZWFufSBtZXRob2RzLlxuXG4gKiBAcGFyYW0ge0xheW91dH0gd29yZCAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIEJpdFN0cnVjdHVyZSN3b3JkfHdvcmR9LiAgVGhlIHBhcmFtZXRlciBtdXN0IGJlIGFuIGluc3RhbmNlIG9mXG4gKiB7QGxpbmsgVUludH0gKG9yIHtAbGluayBVSW50QkV9KSB0aGF0IGlzIG5vIG1vcmUgdGhhbiA0IGJ5dGVzIHdpZGUuXG4gKlxuICogQHBhcmFtIHtib29sfSBbbXNiXSAtIGB0cnVlYCBpZiB0aGUgYml0IG51bWJlcmluZyBzdGFydHMgYXQgdGhlXG4gKiBtb3N0IHNpZ25pZmljYW50IGJpdCBvZiB0aGUgY29udGFpbmluZyB3b3JkOyBgZmFsc2VgIChkZWZhdWx0KSBpZlxuICogaXQgc3RhcnRzIGF0IHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQgb2YgdGhlIGNvbnRhaW5pbmcgd29yZC4gIElmXG4gKiB0aGUgcGFyYW1ldGVyIGF0IHRoaXMgcG9zaXRpb24gaXMgYSBzdHJpbmcgYW5kIGBwcm9wZXJ0eWAgaXNcbiAqIGB1bmRlZmluZWRgIHRoZSB2YWx1ZSBvZiB0aGlzIGFyZ3VtZW50IHdpbGwgaW5zdGVhZCBiZSB1c2VkIGFzIHRoZVxuICogdmFsdWUgb2YgYHByb3BlcnR5YC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIEJpdFN0cnVjdHVyZSBleHRlbmRzIExheW91dCB7XG4gICAgY29uc3RydWN0b3Iod29yZCwgbXNiLCBwcm9wZXJ0eSkge1xuICAgICAgICBpZiAoISgod29yZCBpbnN0YW5jZW9mIFVJbnQpXG4gICAgICAgICAgICB8fCAod29yZCBpbnN0YW5jZW9mIFVJbnRCRSkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd3b3JkIG11c3QgYmUgYSBVSW50IG9yIFVJbnRCRSBsYXlvdXQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKCdzdHJpbmcnID09PSB0eXBlb2YgbXNiKVxuICAgICAgICAgICAgJiYgKHVuZGVmaW5lZCA9PT0gcHJvcGVydHkpKSB7XG4gICAgICAgICAgICBwcm9wZXJ0eSA9IG1zYjtcbiAgICAgICAgICAgIG1zYiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICg0IDwgd29yZC5zcGFuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignd29yZCBjYW5ub3QgZXhjZWVkIDMyIGJpdHMnKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcih3b3JkLnNwYW4sIHByb3BlcnR5KTtcbiAgICAgICAgLyoqIFRoZSBsYXlvdXQgdXNlZCBmb3IgdGhlIHBhY2tlZCB2YWx1ZS4gIHtAbGluayBCaXRGaWVsZH1cbiAgICAgICAgICogaW5zdGFuY2VzIGFyZSBwYWNrZWQgc2VxdWVudGlhbGx5IGRlcGVuZGluZyBvbiB7QGxpbmtcbiAgICAgICAgICogQml0U3RydWN0dXJlI21zYnxtc2J9LiAqL1xuICAgICAgICB0aGlzLndvcmQgPSB3b3JkO1xuICAgICAgICAvKiogV2hldGhlciB0aGUgYml0IHNlcXVlbmNlcyBhcmUgcGFja2VkIHN0YXJ0aW5nIGF0IHRoZSBtb3N0XG4gICAgICAgICAqIHNpZ25pZmljYW50IGJpdCBncm93aW5nIGRvd24gKGB0cnVlYCksIG9yIHRoZSBsZWFzdCBzaWduaWZpY2FudFxuICAgICAgICAgKiBiaXQgZ3Jvd2luZyB1cCAoYGZhbHNlYCkuXG4gICAgICAgICAqXG4gICAgICAgICAqICoqTk9URSoqIFJlZ2FyZGxlc3Mgb2YgdGhpcyB2YWx1ZSwgdGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdCBvZlxuICAgICAgICAgKiBhbnkge0BsaW5rIEJpdEZpZWxkfSB2YWx1ZSBpcyB0aGUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0IG9mIHRoZVxuICAgICAgICAgKiBjb3JyZXNwb25kaW5nIHNlY3Rpb24gb2YgdGhlIHBhY2tlZCB2YWx1ZS4gKi9cbiAgICAgICAgdGhpcy5tc2IgPSAhIW1zYjtcbiAgICAgICAgLyoqIFRoZSBzZXF1ZW5jZSBvZiB7QGxpbmsgQml0RmllbGR9IGxheW91dHMgdGhhdCBjb21wcmlzZSB0aGVcbiAgICAgICAgICogcGFja2VkIHN0cnVjdHVyZS5cbiAgICAgICAgICpcbiAgICAgICAgICogKipOT1RFKiogVGhlIGFycmF5IHJlbWFpbnMgbXV0YWJsZSB0byBhbGxvdyBmaWVsZHMgdG8gYmUge0BsaW5rXG4gICAgICAgICAqIEJpdFN0cnVjdHVyZSNhZGRGaWVsZHxhZGRlZH0gYWZ0ZXIgY29uc3RydWN0aW9uLiAgVXNlcnMgc2hvdWxkXG4gICAgICAgICAqIG5vdCBtYW5pcHVsYXRlIHRoZSBjb250ZW50IG9mIHRoaXMgcHJvcGVydHkuKi9cbiAgICAgICAgdGhpcy5maWVsZHMgPSBbXTtcbiAgICAgICAgLyogU3RvcmFnZSBmb3IgdGhlIHZhbHVlLiAgQ2FwdHVyZSBhIHZhcmlhYmxlIGluc3RlYWQgb2YgdXNpbmcgYW5cbiAgICAgICAgICogaW5zdGFuY2UgcHJvcGVydHkgYmVjYXVzZSB3ZSBkb24ndCB3YW50IGFueXRoaW5nIHRvIGNoYW5nZSB0aGVcbiAgICAgICAgICogdmFsdWUgd2l0aG91dCBnb2luZyB0aHJvdWdoIHRoZSBtdXRhdG9yLiAqL1xuICAgICAgICBsZXQgdmFsdWUgPSAwO1xuICAgICAgICB0aGlzLl9wYWNrZWRTZXRWYWx1ZSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGZpeEJpdHdpc2VSZXN1bHQodik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fcGFja2VkR2V0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjb25zdCBkZXN0ID0gdGhpcy5tYWtlRGVzdGluYXRpb25PYmplY3QoKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLndvcmQuZGVjb2RlKGIsIG9mZnNldCk7XG4gICAgICAgIHRoaXMuX3BhY2tlZFNldFZhbHVlKHZhbHVlKTtcbiAgICAgICAgZm9yIChjb25zdCBmZCBvZiB0aGlzLmZpZWxkcykge1xuICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCAhPT0gZmQucHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICBkZXN0W2ZkLnByb3BlcnR5XSA9IGZkLmRlY29kZShiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9XG4gICAgLyoqIEltcGxlbWVudCB7QGxpbmsgTGF5b3V0I2VuY29kZXxlbmNvZGV9IGZvciB7QGxpbmsgQml0U3RydWN0dXJlfS5cbiAgICAgKlxuICAgICAqIElmIGBzcmNgIGlzIG1pc3NpbmcgYSBwcm9wZXJ0eSBmb3IgYSBtZW1iZXIgd2l0aCBhIGRlZmluZWQge0BsaW5rXG4gICAgICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fSB0aGUgY29ycmVzcG9uZGluZyByZWdpb24gb2YgdGhlIHBhY2tlZFxuICAgICAqIHZhbHVlIGlzIGxlZnQgdW5tb2RpZmllZC4gIFVudXNlZCBiaXRzIGFyZSBhbHNvIGxlZnQgdW5tb2RpZmllZC4gKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy53b3JkLmRlY29kZShiLCBvZmZzZXQpO1xuICAgICAgICB0aGlzLl9wYWNrZWRTZXRWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIGZvciAoY29uc3QgZmQgb2YgdGhpcy5maWVsZHMpIHtcbiAgICAgICAgICAgIGlmICh1bmRlZmluZWQgIT09IGZkLnByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZnYgPSBzcmNbZmQucHJvcGVydHldO1xuICAgICAgICAgICAgICAgIGlmICh1bmRlZmluZWQgIT09IGZ2KSB7XG4gICAgICAgICAgICAgICAgICAgIGZkLmVuY29kZShmdik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLndvcmQuZW5jb2RlKHRoaXMuX3BhY2tlZEdldFZhbHVlKCksIGIsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKiBSZWdpc3RlciBhIG5ldyBiaXRmaWVsZCB3aXRoIGEgY29udGFpbmluZyBiaXQgc3RydWN0dXJlLiAgVGhlXG4gICAgICogcmVzdWx0aW5nIGJpdGZpZWxkIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGJpdHMgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rIEJpdEZpZWxkI2JpdHN8Yml0c30uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gICAgICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0JpdEZpZWxkfSAqL1xuICAgIGFkZEZpZWxkKGJpdHMsIHByb3BlcnR5KSB7XG4gICAgICAgIGNvbnN0IGJmID0gbmV3IEJpdEZpZWxkKHRoaXMsIGJpdHMsIHByb3BlcnR5KTtcbiAgICAgICAgdGhpcy5maWVsZHMucHVzaChiZik7XG4gICAgICAgIHJldHVybiBiZjtcbiAgICB9XG4gICAgLyoqIEFzIHdpdGgge0BsaW5rIEJpdFN0cnVjdHVyZSNhZGRGaWVsZHxhZGRGaWVsZH0gZm9yIHNpbmdsZS1iaXRcbiAgICAgKiBmaWVsZHMgd2l0aCBgYm9vbGVhbmAgdmFsdWUgcmVwcmVzZW50YXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gICAgICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICovXG4gICAgLy8gYEJvb2xlYW5gIGNvbmZsaWN0cyB3aXRoIHRoZSBuYXRpdmUgcHJpbWl0aXZlIHR5cGVcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuICAgIGFkZEJvb2xlYW4ocHJvcGVydHkpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBteSBCb29sZWFuLCBub3QgdGhlIEphdmFzY3JpcHQgb25lLlxuICAgICAgICBjb25zdCBiZiA9IG5ldyBCb29sZWFuKHRoaXMsIHByb3BlcnR5KTtcbiAgICAgICAgdGhpcy5maWVsZHMucHVzaChiZik7XG4gICAgICAgIHJldHVybiBiZjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFjY2VzcyB0byB0aGUgYml0IGZpZWxkIGZvciBhIGdpdmVuIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IC0gdGhlIGJpdCBmaWVsZCBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0JpdEZpZWxkfSAtIHRoZSBmaWVsZCBhc3NvY2lhdGVkIHdpdGggYHByb3BlcnR5YCwgb3JcbiAgICAgKiB1bmRlZmluZWQgaWYgdGhlcmUgaXMgbm8gc3VjaCBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICBmaWVsZEZvcihwcm9wZXJ0eSkge1xuICAgICAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBwcm9wZXJ0eSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncHJvcGVydHkgbXVzdCBiZSBzdHJpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGZkIG9mIHRoaXMuZmllbGRzKSB7XG4gICAgICAgICAgICBpZiAoZmQucHJvcGVydHkgPT09IHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZXhwb3J0cy5CaXRTdHJ1Y3R1cmUgPSBCaXRTdHJ1Y3R1cmU7XG4vKipcbiAqIFJlcHJlc2VudCBhIHNlcXVlbmNlIG9mIGJpdHMgd2l0aGluIGEge0BsaW5rIEJpdFN0cnVjdHVyZX0uXG4gKlxuICogQWxsIGJpdCBmaWVsZCB2YWx1ZXMgYXJlIHJlcHJlc2VudGVkIGFzIHVuc2lnbmVkIGludGVnZXJzLlxuICpcbiAqICoqTk9URSoqIFVzZXIgY29kZSBzaG91bGQgbm90IGludm9rZSB0aGlzIGNvbnN0cnVjdG9yIGRpcmVjdGx5LlxuICogVXNlIHRoZSBjb250YWluZXIge0BsaW5rIEJpdFN0cnVjdHVyZSNhZGRGaWVsZHxhZGRGaWVsZH0gaGVscGVyXG4gKiBtZXRob2QuXG4gKlxuICogKipOT1RFKiogQml0RmllbGQgaW5zdGFuY2VzIGFyZSBub3QgaW5zdGFuY2VzIG9mIHtAbGluayBMYXlvdXR9XG4gKiBzaW5jZSB7QGxpbmsgTGF5b3V0I3NwYW58c3Bhbn0gbWVhc3VyZXMgOC1iaXQgdW5pdHMuXG4gKlxuICogQHBhcmFtIHtCaXRTdHJ1Y3R1cmV9IGNvbnRhaW5lciAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIEJpdEZpZWxkI2NvbnRhaW5lcnxjb250YWluZXJ9LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBiaXRzIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGluayBCaXRGaWVsZCNiaXRzfGJpdHN9LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqL1xuY2xhc3MgQml0RmllbGQge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRhaW5lciwgYml0cywgcHJvcGVydHkpIHtcbiAgICAgICAgaWYgKCEoY29udGFpbmVyIGluc3RhbmNlb2YgQml0U3RydWN0dXJlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY29udGFpbmVyIG11c3QgYmUgYSBCaXRTdHJ1Y3R1cmUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKCFOdW1iZXIuaXNJbnRlZ2VyKGJpdHMpKSB8fCAoMCA+PSBiaXRzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYml0cyBtdXN0IGJlIHBvc2l0aXZlIGludGVnZXInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b3RhbEJpdHMgPSA4ICogY29udGFpbmVyLnNwYW47XG4gICAgICAgIGNvbnN0IHVzZWRCaXRzID0gY29udGFpbmVyLmZpZWxkcy5yZWR1Y2UoKHN1bSwgZmQpID0+IHN1bSArIGZkLmJpdHMsIDApO1xuICAgICAgICBpZiAoKGJpdHMgKyB1c2VkQml0cykgPiB0b3RhbEJpdHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYml0cyB0b28gbG9uZyBmb3Igc3BhbiByZW1haW5kZXIgKCdcbiAgICAgICAgICAgICAgICArICh0b3RhbEJpdHMgLSB1c2VkQml0cykgKyAnIG9mICdcbiAgICAgICAgICAgICAgICArIHRvdGFsQml0cyArICcgcmVtYWluKScpO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBUaGUge0BsaW5rIEJpdFN0cnVjdHVyZX0gaW5zdGFuY2UgdG8gd2hpY2ggdGhpcyBiaXQgZmllbGRcbiAgICAgICAgICogYmVsb25ncy4gKi9cbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgIC8qKiBUaGUgc3BhbiBvZiB0aGlzIHZhbHVlIGluIGJpdHMuICovXG4gICAgICAgIHRoaXMuYml0cyA9IGJpdHM7XG4gICAgICAgIC8qKiBBIG1hc2sgb2Yge0BsaW5rIEJpdEZpZWxkI2JpdHN8Yml0c30gYml0cyBpc29sYXRpbmcgdmFsdWUgYml0c1xuICAgICAgICAgKiB0aGF0IGZpdCB3aXRoaW4gdGhlIGZpZWxkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGF0IGlzLCBpdCBtYXNrcyBhIHZhbHVlIHRoYXQgaGFzIG5vdCB5ZXQgYmVlbiBzaGlmdGVkIGludG9cbiAgICAgICAgICogcG9zaXRpb24gd2l0aGluIGl0cyBjb250YWluaW5nIHBhY2tlZCBpbnRlZ2VyLiAqL1xuICAgICAgICB0aGlzLnZhbHVlTWFzayA9ICgxIDw8IGJpdHMpIC0gMTtcbiAgICAgICAgaWYgKDMyID09PSBiaXRzKSB7IC8vIHNoaWZ0ZWQgdmFsdWUgb3V0IG9mIHJhbmdlXG4gICAgICAgICAgICB0aGlzLnZhbHVlTWFzayA9IDB4RkZGRkZGRkY7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIFRoZSBvZmZzZXQgb2YgdGhlIHZhbHVlIHdpdGhpbiB0aGUgY29udGFpbmluZyBwYWNrZWQgdW5zaWduZWRcbiAgICAgICAgICogaW50ZWdlci4gIFRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQgb2YgdGhlIHBhY2tlZCB2YWx1ZSBpcyBhdFxuICAgICAgICAgKiBvZmZzZXQgemVybywgcmVnYXJkbGVzcyBvZiBiaXQgb3JkZXJpbmcgdXNlZC4gKi9cbiAgICAgICAgdGhpcy5zdGFydCA9IHVzZWRCaXRzO1xuICAgICAgICBpZiAodGhpcy5jb250YWluZXIubXNiKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ID0gdG90YWxCaXRzIC0gdXNlZEJpdHMgLSBiaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBBIG1hc2sgb2Yge0BsaW5rIEJpdEZpZWxkI2JpdHN8Yml0c30gaXNvbGF0aW5nIHRoZSBmaWVsZCB2YWx1ZVxuICAgICAgICAgKiB3aXRoaW4gdGhlIGNvbnRhaW5pbmcgcGFja2VkIHVuc2lnbmVkIGludGVnZXIuICovXG4gICAgICAgIHRoaXMud29yZE1hc2sgPSBmaXhCaXR3aXNlUmVzdWx0KHRoaXMudmFsdWVNYXNrIDw8IHRoaXMuc3RhcnQpO1xuICAgICAgICAvKiogVGhlIHByb3BlcnR5IG5hbWUgdXNlZCB3aGVuIHRoaXMgYml0ZmllbGQgaXMgcmVwcmVzZW50ZWQgaW4gYW5cbiAgICAgICAgICogT2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBJbnRlbmRlZCB0byBiZSBmdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byB7QGxpbmtcbiAgICAgICAgICogTGF5b3V0I3Byb3BlcnR5fS5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgbGVmdCB1bmRlZmluZWQgdGhlIGNvcnJlc3BvbmRpbmcgc3BhbiBvZiBiaXRzIHdpbGwgYmVcbiAgICAgICAgICogdHJlYXRlZCBhcyBwYWRkaW5nOiBpdCB3aWxsIG5vdCBiZSBtdXRhdGVkIGJ5IHtAbGlua1xuICAgICAgICAgKiBMYXlvdXQjZW5jb2RlfGVuY29kZX0gbm9yIHJlcHJlc2VudGVkIGFzIGEgcHJvcGVydHkgaW4gdGhlXG4gICAgICAgICAqIGRlY29kZWQgT2JqZWN0LiAqL1xuICAgICAgICB0aGlzLnByb3BlcnR5ID0gcHJvcGVydHk7XG4gICAgfVxuICAgIC8qKiBTdG9yZSBhIHZhbHVlIGludG8gdGhlIGNvcnJlc3BvbmRpbmcgc3Vic2VxdWVuY2Ugb2YgdGhlIGNvbnRhaW5pbmdcbiAgICAgKiBiaXQgZmllbGQuICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCkge1xuICAgICAgICBjb25zdCB3b3JkID0gdGhpcy5jb250YWluZXIuX3BhY2tlZEdldFZhbHVlKCk7XG4gICAgICAgIGNvbnN0IHdvcmRWYWx1ZSA9IGZpeEJpdHdpc2VSZXN1bHQod29yZCAmIHRoaXMud29yZE1hc2spO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHdvcmRWYWx1ZSA+Pj4gdGhpcy5zdGFydDtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICAvKiogU3RvcmUgYSB2YWx1ZSBpbnRvIHRoZSBjb3JyZXNwb25kaW5nIHN1YnNlcXVlbmNlIG9mIHRoZSBjb250YWluaW5nXG4gICAgICogYml0IGZpZWxkLlxuICAgICAqXG4gICAgICogKipOT1RFKiogVGhpcyBpcyBub3QgYSBzcGVjaWFsaXphdGlvbiBvZiB7QGxpbmtcbiAgICAgKiBMYXlvdXQjZW5jb2RlfExheW91dC5lbmNvZGV9IGFuZCB0aGVyZSBpcyBubyByZXR1cm4gdmFsdWUuICovXG4gICAgZW5jb2RlKHZhbHVlKSB7XG4gICAgICAgIGlmICgnbnVtYmVyJyAhPT0gdHlwZW9mIHZhbHVlXG4gICAgICAgICAgICB8fCAhTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSlcbiAgICAgICAgICAgIHx8ICh2YWx1ZSAhPT0gZml4Qml0d2lzZVJlc3VsdCh2YWx1ZSAmIHRoaXMudmFsdWVNYXNrKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IobmFtZVdpdGhQcm9wZXJ0eSgnQml0RmllbGQuZW5jb2RlJywgdGhpcylcbiAgICAgICAgICAgICAgICArICcgdmFsdWUgbXVzdCBiZSBpbnRlZ2VyIG5vdCBleGNlZWRpbmcgJyArIHRoaXMudmFsdWVNYXNrKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3b3JkID0gdGhpcy5jb250YWluZXIuX3BhY2tlZEdldFZhbHVlKCk7XG4gICAgICAgIGNvbnN0IHdvcmRWYWx1ZSA9IGZpeEJpdHdpc2VSZXN1bHQodmFsdWUgPDwgdGhpcy5zdGFydCk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLl9wYWNrZWRTZXRWYWx1ZShmaXhCaXR3aXNlUmVzdWx0KHdvcmQgJiB+dGhpcy53b3JkTWFzaylcbiAgICAgICAgICAgIHwgd29yZFZhbHVlKTtcbiAgICB9XG59XG5leHBvcnRzLkJpdEZpZWxkID0gQml0RmllbGQ7XG4vKipcbiAqIFJlcHJlc2VudCBhIHNpbmdsZSBiaXQgd2l0aGluIGEge0BsaW5rIEJpdFN0cnVjdHVyZX0gYXMgYVxuICogSmF2YVNjcmlwdCBib29sZWFuLlxuICpcbiAqICoqTk9URSoqIFVzZXIgY29kZSBzaG91bGQgbm90IGludm9rZSB0aGlzIGNvbnN0cnVjdG9yIGRpcmVjdGx5LlxuICogVXNlIHRoZSBjb250YWluZXIge0BsaW5rIEJpdFN0cnVjdHVyZSNhZGRCb29sZWFufGFkZEJvb2xlYW59IGhlbHBlclxuICogbWV0aG9kLlxuICpcbiAqIEBwYXJhbSB7Qml0U3RydWN0dXJlfSBjb250YWluZXIgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBCaXRGaWVsZCNjb250YWluZXJ8Y29udGFpbmVyfS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtCaXRGaWVsZH1cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tZXh0ZW5kLW5hdGl2ZSAqL1xuY2xhc3MgQm9vbGVhbiBleHRlbmRzIEJpdEZpZWxkIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXIsIHByb3BlcnR5KSB7XG4gICAgICAgIHN1cGVyKGNvbnRhaW5lciwgMSwgcHJvcGVydHkpO1xuICAgIH1cbiAgICAvKiogT3ZlcnJpZGUge0BsaW5rIEJpdEZpZWxkI2RlY29kZXxkZWNvZGV9IGZvciB7QGxpbmsgQm9vbGVhbnxCb29sZWFufS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuICEhc3VwZXIuZGVjb2RlKGIsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUodmFsdWUpIHtcbiAgICAgICAgaWYgKCdib29sZWFuJyA9PT0gdHlwZW9mIHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBCaXRGaWVsZCByZXF1aXJlcyBpbnRlZ2VyIHZhbHVlc1xuICAgICAgICAgICAgdmFsdWUgPSArdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuZW5jb2RlKHZhbHVlKTtcbiAgICB9XG59XG5leHBvcnRzLkJvb2xlYW4gPSBCb29sZWFuO1xuLyogZXNsaW50LWVuYWJsZSBuby1leHRlbmQtbmF0aXZlICovXG4vKipcbiAqIENvbnRhaW4gYSBmaXhlZC1sZW5ndGggYmxvY2sgb2YgYXJiaXRyYXJ5IGRhdGEsIHJlcHJlc2VudGVkIGFzIGFcbiAqIFVpbnQ4QXJyYXkuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5ibG9ifGJsb2J9XG4gKlxuICogQHBhcmFtIHsoTnVtYmVyfEV4dGVybmFsTGF5b3V0KX0gbGVuZ3RoIC0gaW5pdGlhbGl6ZXMge0BsaW5rXG4gKiBCbG9iI2xlbmd0aHxsZW5ndGh9LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgQmxvYiBleHRlbmRzIExheW91dCB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoLCBwcm9wZXJ0eSkge1xuICAgICAgICBpZiAoISgoKGxlbmd0aCBpbnN0YW5jZW9mIEV4dGVybmFsTGF5b3V0KSAmJiBsZW5ndGguaXNDb3VudCgpKVxuICAgICAgICAgICAgfHwgKE51bWJlci5pc0ludGVnZXIobGVuZ3RoKSAmJiAoMCA8PSBsZW5ndGgpKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2xlbmd0aCBtdXN0IGJlIHBvc2l0aXZlIGludGVnZXIgJ1xuICAgICAgICAgICAgICAgICsgJ29yIGFuIHVuc2lnbmVkIGludGVnZXIgRXh0ZXJuYWxMYXlvdXQnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3BhbiA9IC0xO1xuICAgICAgICBpZiAoIShsZW5ndGggaW5zdGFuY2VvZiBFeHRlcm5hbExheW91dCkpIHtcbiAgICAgICAgICAgIHNwYW4gPSBsZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoc3BhbiwgcHJvcGVydHkpO1xuICAgICAgICAvKiogVGhlIG51bWJlciBvZiBieXRlcyBpbiB0aGUgYmxvYi5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBtYXkgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlciwgb3IgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rXG4gICAgICAgICAqIEV4dGVybmFsTGF5b3V0fSB0aGF0IHNhdGlzZmllcyB7QGxpbmtcbiAgICAgICAgICogRXh0ZXJuYWxMYXlvdXQjaXNDb3VudHxpc0NvdW50KCl9LiAqL1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGdldFNwYW4oYiwgb2Zmc2V0KSB7XG4gICAgICAgIGxldCBzcGFuID0gdGhpcy5zcGFuO1xuICAgICAgICBpZiAoMCA+IHNwYW4pIHtcbiAgICAgICAgICAgIHNwYW4gPSB0aGlzLmxlbmd0aC5kZWNvZGUoYiwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3BhbjtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGxldCBzcGFuID0gdGhpcy5zcGFuO1xuICAgICAgICBpZiAoMCA+IHNwYW4pIHtcbiAgICAgICAgICAgIHNwYW4gPSB0aGlzLmxlbmd0aC5kZWNvZGUoYiwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdWludDhBcnJheVRvQnVmZmVyKGIpLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgc3Bhbik7XG4gICAgfVxuICAgIC8qKiBJbXBsZW1lbnQge0BsaW5rIExheW91dCNlbmNvZGV8ZW5jb2RlfSBmb3Ige0BsaW5rIEJsb2J9LlxuICAgICAqXG4gICAgICogKipOT1RFKiogSWYge0BsaW5rIExheW91dCNjb3VudHxjb3VudH0gaXMgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rXG4gICAgICogRXh0ZXJuYWxMYXlvdXR9IHRoZW4gdGhlIGxlbmd0aCBvZiBgc3JjYCB3aWxsIGJlIGVuY29kZWQgYXMgdGhlXG4gICAgICogY291bnQgYWZ0ZXIgYHNyY2AgaXMgZW5jb2RlZC4gKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQpIHtcbiAgICAgICAgbGV0IHNwYW4gPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoIGluc3RhbmNlb2YgRXh0ZXJuYWxMYXlvdXQpIHtcbiAgICAgICAgICAgIHNwYW4gPSBzcmMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHNyYyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgc3BhbiA9PT0gc3JjLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IobmFtZVdpdGhQcm9wZXJ0eSgnQmxvYi5lbmNvZGUnLCB0aGlzKVxuICAgICAgICAgICAgICAgICsgJyByZXF1aXJlcyAobGVuZ3RoICcgKyBzcGFuICsgJykgVWludDhBcnJheSBhcyBzcmMnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKG9mZnNldCArIHNwYW4pID4gYi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdlbmNvZGluZyBvdmVycnVucyBVaW50OEFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3JjQnVmZmVyID0gdWludDhBcnJheVRvQnVmZmVyKHNyYyk7XG4gICAgICAgIHVpbnQ4QXJyYXlUb0J1ZmZlcihiKS53cml0ZShzcmNCdWZmZXIudG9TdHJpbmcoJ2hleCcpLCBvZmZzZXQsIHNwYW4sICdoZXgnKTtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoIGluc3RhbmNlb2YgRXh0ZXJuYWxMYXlvdXQpIHtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoLmVuY29kZShzcGFuLCBiLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGFuO1xuICAgIH1cbn1cbmV4cG9ydHMuQmxvYiA9IEJsb2I7XG4vKipcbiAqIENvbnRhaW4gYSBgTlVMYC10ZXJtaW5hdGVkIFVURjggc3RyaW5nLlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQuY3N0cnxjc3RyfVxuICpcbiAqICoqTk9URSoqIEFueSBVVEY4IHN0cmluZyB0aGF0IGluY29ycG9yYXRlcyBhIHplcm8tdmFsdWVkIGJ5dGUgd2lsbFxuICogbm90IGJlIGNvcnJlY3RseSBkZWNvZGVkIGJ5IHRoaXMgbGF5b3V0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgQ1N0cmluZyBleHRlbmRzIExheW91dCB7XG4gICAgY29uc3RydWN0b3IocHJvcGVydHkpIHtcbiAgICAgICAgc3VwZXIoLTEsIHByb3BlcnR5KTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGdldFNwYW4oYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjaGVja1VpbnQ4QXJyYXkoYik7XG4gICAgICAgIGxldCBpZHggPSBvZmZzZXQ7XG4gICAgICAgIHdoaWxlICgoaWR4IDwgYi5sZW5ndGgpICYmICgwICE9PSBiW2lkeF0pKSB7XG4gICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMSArIGlkeCAtIG9mZnNldDtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNvbnN0IHNwYW4gPSB0aGlzLmdldFNwYW4oYiwgb2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIHVpbnQ4QXJyYXlUb0J1ZmZlcihiKS5zbGljZShvZmZzZXQsIG9mZnNldCArIHNwYW4gLSAxKS50b1N0cmluZygndXRmLTgnKTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgLyogTXVzdCBmb3JjZSB0aGlzIHRvIGEgc3RyaW5nLCBsZXN0IGl0IGJlIGEgbnVtYmVyIGFuZCB0aGVcbiAgICAgICAgICogXCJ1dGY4LWVuY29kaW5nXCIgYmVsb3cgYWN0dWFsbHkgYWxsb2NhdGUgYSBidWZmZXIgb2YgbGVuZ3RoXG4gICAgICAgICAqIHNyYyAqL1xuICAgICAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBzcmMpIHtcbiAgICAgICAgICAgIHNyYyA9IFN0cmluZyhzcmMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNyY2IgPSBidWZmZXJfMS5CdWZmZXIuZnJvbShzcmMsICd1dGY4Jyk7XG4gICAgICAgIGNvbnN0IHNwYW4gPSBzcmNiLmxlbmd0aDtcbiAgICAgICAgaWYgKChvZmZzZXQgKyBzcGFuKSA+IGIubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignZW5jb2Rpbmcgb3ZlcnJ1bnMgQnVmZmVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnVmZmVyID0gdWludDhBcnJheVRvQnVmZmVyKGIpO1xuICAgICAgICBzcmNiLmNvcHkoYnVmZmVyLCBvZmZzZXQpO1xuICAgICAgICBidWZmZXJbb2Zmc2V0ICsgc3Bhbl0gPSAwO1xuICAgICAgICByZXR1cm4gc3BhbiArIDE7XG4gICAgfVxufVxuZXhwb3J0cy5DU3RyaW5nID0gQ1N0cmluZztcbi8qKlxuICogQ29udGFpbiBhIFVURjggc3RyaW5nIHdpdGggaW1wbGljaXQgbGVuZ3RoLlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQudXRmOHx1dGY4fVxuICpcbiAqICoqTk9URSoqIEJlY2F1c2UgdGhlIGxlbmd0aCBpcyBpbXBsaWNpdCBpbiB0aGUgc2l6ZSBvZiB0aGUgYnVmZmVyXG4gKiB0aGlzIGxheW91dCBzaG91bGQgYmUgdXNlZCBvbmx5IGluIGlzb2xhdGlvbiwgb3IgaW4gYSBzaXR1YXRpb25cbiAqIHdoZXJlIHRoZSBsZW5ndGggY2FuIGJlIGV4cHJlc3NlZCBieSBvcGVyYXRpbmcgb24gYSBzbGljZSBvZiB0aGVcbiAqIGNvbnRhaW5pbmcgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBbbWF4U3Bhbl0gLSB0aGUgbWF4aW11bSBsZW5ndGggYWxsb3dlZCBmb3IgZW5jb2RlZFxuICogc3RyaW5nIGNvbnRlbnQuICBJZiBub3QgcHJvdmlkZWQgdGhlcmUgaXMgbm8gYm91bmQgb24gdGhlIGFsbG93ZWRcbiAqIGNvbnRlbnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBVVEY4IGV4dGVuZHMgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3RvcihtYXhTcGFuLCBwcm9wZXJ0eSkge1xuICAgICAgICBpZiAoKCdzdHJpbmcnID09PSB0eXBlb2YgbWF4U3BhbikgJiYgKHVuZGVmaW5lZCA9PT0gcHJvcGVydHkpKSB7XG4gICAgICAgICAgICBwcm9wZXJ0eSA9IG1heFNwYW47XG4gICAgICAgICAgICBtYXhTcGFuID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bmRlZmluZWQgPT09IG1heFNwYW4pIHtcbiAgICAgICAgICAgIG1heFNwYW4gPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghTnVtYmVyLmlzSW50ZWdlcihtYXhTcGFuKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWF4U3BhbiBtdXN0IGJlIGFuIGludGVnZXInKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcigtMSwgcHJvcGVydHkpO1xuICAgICAgICAvKiogVGhlIG1heGltdW0gc3BhbiBvZiB0aGUgbGF5b3V0IGluIGJ5dGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBQb3NpdGl2ZSB2YWx1ZXMgYXJlIGdlbmVyYWxseSBleHBlY3RlZC4gIFplcm8gaXMgYWJub3JtYWwuXG4gICAgICAgICAqIEF0dGVtcHRzIHRvIGVuY29kZSBvciBkZWNvZGUgYSB2YWx1ZSB0aGF0IGV4Y2VlZHMgdGhpcyBsZW5ndGhcbiAgICAgICAgICogd2lsbCB0aHJvdyBhIGBSYW5nZUVycm9yYC5cbiAgICAgICAgICpcbiAgICAgICAgICogQSBuZWdhdGl2ZSB2YWx1ZSBpbmRpY2F0ZXMgdGhhdCB0aGVyZSBpcyBubyBib3VuZCBvbiB0aGUgbGVuZ3RoXG4gICAgICAgICAqIG9mIHRoZSBjb250ZW50LiAqL1xuICAgICAgICB0aGlzLm1heFNwYW4gPSBtYXhTcGFuO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZ2V0U3BhbihiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNoZWNrVWludDhBcnJheShiKTtcbiAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gb2Zmc2V0O1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgY29uc3Qgc3BhbiA9IHRoaXMuZ2V0U3BhbihiLCBvZmZzZXQpO1xuICAgICAgICBpZiAoKDAgPD0gdGhpcy5tYXhTcGFuKVxuICAgICAgICAgICAgJiYgKHRoaXMubWF4U3BhbiA8IHNwYW4pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGV4dCBsZW5ndGggZXhjZWVkcyBtYXhTcGFuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVpbnQ4QXJyYXlUb0J1ZmZlcihiKS5zbGljZShvZmZzZXQsIG9mZnNldCArIHNwYW4pLnRvU3RyaW5nKCd1dGYtOCcpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICAvKiBNdXN0IGZvcmNlIHRoaXMgdG8gYSBzdHJpbmcsIGxlc3QgaXQgYmUgYSBudW1iZXIgYW5kIHRoZVxuICAgICAgICAgKiBcInV0ZjgtZW5jb2RpbmdcIiBiZWxvdyBhY3R1YWxseSBhbGxvY2F0ZSBhIGJ1ZmZlciBvZiBsZW5ndGhcbiAgICAgICAgICogc3JjICovXG4gICAgICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIHNyYykge1xuICAgICAgICAgICAgc3JjID0gU3RyaW5nKHNyYyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3JjYiA9IGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKHNyYywgJ3V0ZjgnKTtcbiAgICAgICAgY29uc3Qgc3BhbiA9IHNyY2IubGVuZ3RoO1xuICAgICAgICBpZiAoKDAgPD0gdGhpcy5tYXhTcGFuKVxuICAgICAgICAgICAgJiYgKHRoaXMubWF4U3BhbiA8IHNwYW4pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGV4dCBsZW5ndGggZXhjZWVkcyBtYXhTcGFuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChvZmZzZXQgKyBzcGFuKSA+IGIubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignZW5jb2Rpbmcgb3ZlcnJ1bnMgQnVmZmVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgc3JjYi5jb3B5KHVpbnQ4QXJyYXlUb0J1ZmZlcihiKSwgb2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgfVxufVxuZXhwb3J0cy5VVEY4ID0gVVRGODtcbi8qKlxuICogQ29udGFpbiBhIGNvbnN0YW50IHZhbHVlLlxuICpcbiAqIFRoaXMgbGF5b3V0IG1heSBiZSB1c2VkIGluIGNhc2VzIHdoZXJlIGEgSmF2YVNjcmlwdCB2YWx1ZSBjYW4gYmVcbiAqIGluZmVycmVkIHdpdGhvdXQgYW4gZXhwcmVzc2lvbiBpbiB0aGUgYmluYXJ5IGVuY29kaW5nLiAgQW4gZXhhbXBsZVxuICogd291bGQgYmUgYSB7QGxpbmsgVmFyaWFudExheW91dHx2YXJpYW50IGxheW91dH0gd2hlcmUgdGhlIGNvbnRlbnRcbiAqIGlzIGltcGxpZWQgYnkgdGhlIHVuaW9uIHtAbGluayBVbmlvbiNkaXNjcmltaW5hdG9yfGRpc2NyaW1pbmF0b3J9LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fE51bWJlcnxTdHJpbmd9IHZhbHVlIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogQ29uc3RhbnQjdmFsdWV8dmFsdWV9LiAgSWYgdGhlIHZhbHVlIGlzIGFuIG9iamVjdCAob3IgYXJyYXkpIGFuZFxuICogdGhlIGFwcGxpY2F0aW9uIGludGVuZHMgdGhlIG9iamVjdCB0byByZW1haW4gdW5jaGFuZ2VkIHJlZ2FyZGxlc3NcbiAqIG9mIHdoYXQgaXMgZG9uZSB0byB2YWx1ZXMgZGVjb2RlZCBieSB0aGlzIGxheW91dCwgdGhlIHZhbHVlIHNob3VsZFxuICogYmUgZnJvemVuIHByaW9yIHBhc3NpbmcgaXQgdG8gdGhpcyBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIENvbnN0YW50IGV4dGVuZHMgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgcHJvcGVydHkpIHtcbiAgICAgICAgc3VwZXIoMCwgcHJvcGVydHkpO1xuICAgICAgICAvKiogVGhlIHZhbHVlIHByb2R1Y2VkIGJ5IHRoaXMgY29uc3RhbnQgd2hlbiB0aGUgbGF5b3V0IGlzIHtAbGlua1xuICAgICAgICAgKiBDb25zdGFudCNkZWNvZGV8ZGVjb2RlZH0uXG4gICAgICAgICAqXG4gICAgICAgICAqIEFueSBKYXZhU2NyaXB0IHZhbHVlIGluY2x1ZGluZyBgbnVsbGAgYW5kIGB1bmRlZmluZWRgIGlzXG4gICAgICAgICAqIHBlcm1pdHRlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogKipXQVJOSU5HKiogSWYgYHZhbHVlYCBwYXNzZWQgaW4gdGhlIGNvbnN0cnVjdG9yIHdhcyBub3RcbiAgICAgICAgICogZnJvemVuLCBpdCBpcyBwb3NzaWJsZSBmb3IgdXNlcnMgb2YgZGVjb2RlZCB2YWx1ZXMgdG8gY2hhbmdlXG4gICAgICAgICAqIHRoZSBjb250ZW50IG9mIHRoZSB2YWx1ZS4gKi9cbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCkge1xuICAgICAgICAvKiBDb25zdGFudHMgdGFrZSBubyBzcGFjZSAqL1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG59XG5leHBvcnRzLkNvbnN0YW50ID0gQ29uc3RhbnQ7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEdyZWVkeUNvdW50fS4gKi9cbmV4cG9ydHMuZ3JlZWR5ID0gKChlbGVtZW50U3BhbiwgcHJvcGVydHkpID0+IG5ldyBHcmVlZHlDb3VudChlbGVtZW50U3BhbiwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgT2Zmc2V0TGF5b3V0fS4gKi9cbmV4cG9ydHMub2Zmc2V0ID0gKChsYXlvdXQsIG9mZnNldCwgcHJvcGVydHkpID0+IG5ldyBPZmZzZXRMYXlvdXQobGF5b3V0LCBvZmZzZXQsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVJbnR8dW5zaWduZWQgaW50IGxheW91dHN9IHNwYW5uaW5nIG9uZVxuICogYnl0ZS4gKi9cbmV4cG9ydHMudTggPSAoKHByb3BlcnR5KSA9PiBuZXcgVUludCgxLCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVSW50fGxpdHRsZS1lbmRpYW4gdW5zaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyB0d28gYnl0ZXMuICovXG5leHBvcnRzLnUxNiA9ICgocHJvcGVydHkpID0+IG5ldyBVSW50KDIsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVJbnR8bGl0dGxlLWVuZGlhbiB1bnNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIHRocmVlIGJ5dGVzLiAqL1xuZXhwb3J0cy51MjQgPSAoKHByb3BlcnR5KSA9PiBuZXcgVUludCgzLCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVSW50fGxpdHRsZS1lbmRpYW4gdW5zaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyBmb3VyIGJ5dGVzLiAqL1xuZXhwb3J0cy51MzIgPSAoKHByb3BlcnR5KSA9PiBuZXcgVUludCg0LCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVSW50fGxpdHRsZS1lbmRpYW4gdW5zaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyBmaXZlIGJ5dGVzLiAqL1xuZXhwb3J0cy51NDAgPSAoKHByb3BlcnR5KSA9PiBuZXcgVUludCg1LCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVSW50fGxpdHRsZS1lbmRpYW4gdW5zaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyBzaXggYnl0ZXMuICovXG5leHBvcnRzLnU0OCA9ICgocHJvcGVydHkpID0+IG5ldyBVSW50KDYsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIE5lYXJVSW50NjR8bGl0dGxlLWVuZGlhbiB1bnNpZ25lZCBpbnRcbiAqIGxheW91dHN9IGludGVycHJldGVkIGFzIE51bWJlcnMuICovXG5leHBvcnRzLm51NjQgPSAoKHByb3BlcnR5KSA9PiBuZXcgTmVhclVJbnQ2NChwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVSW50fGJpZy1lbmRpYW4gdW5zaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyB0d28gYnl0ZXMuICovXG5leHBvcnRzLnUxNmJlID0gKChwcm9wZXJ0eSkgPT4gbmV3IFVJbnRCRSgyLCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVSW50fGJpZy1lbmRpYW4gdW5zaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyB0aHJlZSBieXRlcy4gKi9cbmV4cG9ydHMudTI0YmUgPSAoKHByb3BlcnR5KSA9PiBuZXcgVUludEJFKDMsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVJbnR8YmlnLWVuZGlhbiB1bnNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIGZvdXIgYnl0ZXMuICovXG5leHBvcnRzLnUzMmJlID0gKChwcm9wZXJ0eSkgPT4gbmV3IFVJbnRCRSg0LCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVSW50fGJpZy1lbmRpYW4gdW5zaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyBmaXZlIGJ5dGVzLiAqL1xuZXhwb3J0cy51NDBiZSA9ICgocHJvcGVydHkpID0+IG5ldyBVSW50QkUoNSwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgVUludHxiaWctZW5kaWFuIHVuc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgc2l4IGJ5dGVzLiAqL1xuZXhwb3J0cy51NDhiZSA9ICgocHJvcGVydHkpID0+IG5ldyBVSW50QkUoNiwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgTmVhclVJbnQ2NEJFfGJpZy1lbmRpYW4gdW5zaWduZWQgaW50XG4gKiBsYXlvdXRzfSBpbnRlcnByZXRlZCBhcyBOdW1iZXJzLiAqL1xuZXhwb3J0cy5udTY0YmUgPSAoKHByb3BlcnR5KSA9PiBuZXcgTmVhclVJbnQ2NEJFKHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEludHxzaWduZWQgaW50IGxheW91dHN9IHNwYW5uaW5nIG9uZVxuICogYnl0ZS4gKi9cbmV4cG9ydHMuczggPSAoKHByb3BlcnR5KSA9PiBuZXcgSW50KDEsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEludHxsaXR0bGUtZW5kaWFuIHNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIHR3byBieXRlcy4gKi9cbmV4cG9ydHMuczE2ID0gKChwcm9wZXJ0eSkgPT4gbmV3IEludCgyLCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBJbnR8bGl0dGxlLWVuZGlhbiBzaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyB0aHJlZSBieXRlcy4gKi9cbmV4cG9ydHMuczI0ID0gKChwcm9wZXJ0eSkgPT4gbmV3IEludCgzLCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBJbnR8bGl0dGxlLWVuZGlhbiBzaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyBmb3VyIGJ5dGVzLiAqL1xuZXhwb3J0cy5zMzIgPSAoKHByb3BlcnR5KSA9PiBuZXcgSW50KDQsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEludHxsaXR0bGUtZW5kaWFuIHNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIGZpdmUgYnl0ZXMuICovXG5leHBvcnRzLnM0MCA9ICgocHJvcGVydHkpID0+IG5ldyBJbnQoNSwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgSW50fGxpdHRsZS1lbmRpYW4gc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgc2l4IGJ5dGVzLiAqL1xuZXhwb3J0cy5zNDggPSAoKHByb3BlcnR5KSA9PiBuZXcgSW50KDYsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIE5lYXJJbnQ2NHxsaXR0bGUtZW5kaWFuIHNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIGludGVycHJldGVkIGFzIE51bWJlcnMuICovXG5leHBvcnRzLm5zNjQgPSAoKHByb3BlcnR5KSA9PiBuZXcgTmVhckludDY0KHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEludHxiaWctZW5kaWFuIHNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIHR3byBieXRlcy4gKi9cbmV4cG9ydHMuczE2YmUgPSAoKHByb3BlcnR5KSA9PiBuZXcgSW50QkUoMiwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgSW50fGJpZy1lbmRpYW4gc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgdGhyZWUgYnl0ZXMuICovXG5leHBvcnRzLnMyNGJlID0gKChwcm9wZXJ0eSkgPT4gbmV3IEludEJFKDMsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEludHxiaWctZW5kaWFuIHNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIGZvdXIgYnl0ZXMuICovXG5leHBvcnRzLnMzMmJlID0gKChwcm9wZXJ0eSkgPT4gbmV3IEludEJFKDQsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEludHxiaWctZW5kaWFuIHNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIGZpdmUgYnl0ZXMuICovXG5leHBvcnRzLnM0MGJlID0gKChwcm9wZXJ0eSkgPT4gbmV3IEludEJFKDUsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEludHxiaWctZW5kaWFuIHNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIHNpeCBieXRlcy4gKi9cbmV4cG9ydHMuczQ4YmUgPSAoKHByb3BlcnR5KSA9PiBuZXcgSW50QkUoNiwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgTmVhckludDY0QkV8YmlnLWVuZGlhbiBzaWduZWQgaW50IGxheW91dHN9XG4gKiBpbnRlcnByZXRlZCBhcyBOdW1iZXJzLiAqL1xuZXhwb3J0cy5uczY0YmUgPSAoKHByb3BlcnR5KSA9PiBuZXcgTmVhckludDY0QkUocHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgRmxvYXR8bGl0dGxlLWVuZGlhbiAzMi1iaXQgZmxvYXRpbmcgcG9pbnR9IHZhbHVlcy4gKi9cbmV4cG9ydHMuZjMyID0gKChwcm9wZXJ0eSkgPT4gbmV3IEZsb2F0KHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEZsb2F0QkV8YmlnLWVuZGlhbiAzMi1iaXQgZmxvYXRpbmcgcG9pbnR9IHZhbHVlcy4gKi9cbmV4cG9ydHMuZjMyYmUgPSAoKHByb3BlcnR5KSA9PiBuZXcgRmxvYXRCRShwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBEb3VibGV8bGl0dGxlLWVuZGlhbiA2NC1iaXQgZmxvYXRpbmcgcG9pbnR9IHZhbHVlcy4gKi9cbmV4cG9ydHMuZjY0ID0gKChwcm9wZXJ0eSkgPT4gbmV3IERvdWJsZShwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBEb3VibGVCRXxiaWctZW5kaWFuIDY0LWJpdCBmbG9hdGluZyBwb2ludH0gdmFsdWVzLiAqL1xuZXhwb3J0cy5mNjRiZSA9ICgocHJvcGVydHkpID0+IG5ldyBEb3VibGVCRShwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBTdHJ1Y3R1cmV9IHZhbHVlcy4gKi9cbmV4cG9ydHMuc3RydWN0ID0gKChmaWVsZHMsIHByb3BlcnR5LCBkZWNvZGVQcmVmaXhlcykgPT4gbmV3IFN0cnVjdHVyZShmaWVsZHMsIHByb3BlcnR5LCBkZWNvZGVQcmVmaXhlcykpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBCaXRTdHJ1Y3R1cmV9IHZhbHVlcy4gKi9cbmV4cG9ydHMuYml0cyA9ICgod29yZCwgbXNiLCBwcm9wZXJ0eSkgPT4gbmV3IEJpdFN0cnVjdHVyZSh3b3JkLCBtc2IsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFNlcXVlbmNlfSB2YWx1ZXMuICovXG5leHBvcnRzLnNlcSA9ICgoZWxlbWVudExheW91dCwgY291bnQsIHByb3BlcnR5KSA9PiBuZXcgU2VxdWVuY2UoZWxlbWVudExheW91dCwgY291bnQsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVuaW9ufSB2YWx1ZXMuICovXG5leHBvcnRzLnVuaW9uID0gKChkaXNjciwgZGVmYXVsdExheW91dCwgcHJvcGVydHkpID0+IG5ldyBVbmlvbihkaXNjciwgZGVmYXVsdExheW91dCwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgVW5pb25MYXlvdXREaXNjcmltaW5hdG9yfSB2YWx1ZXMuICovXG5leHBvcnRzLnVuaW9uTGF5b3V0RGlzY3JpbWluYXRvciA9ICgobGF5b3V0LCBwcm9wZXJ0eSkgPT4gbmV3IFVuaW9uTGF5b3V0RGlzY3JpbWluYXRvcihsYXlvdXQsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEJsb2J9IHZhbHVlcy4gKi9cbmV4cG9ydHMuYmxvYiA9ICgobGVuZ3RoLCBwcm9wZXJ0eSkgPT4gbmV3IEJsb2IobGVuZ3RoLCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBDU3RyaW5nfSB2YWx1ZXMuICovXG5leHBvcnRzLmNzdHIgPSAoKHByb3BlcnR5KSA9PiBuZXcgQ1N0cmluZyhwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVVEY4fSB2YWx1ZXMuICovXG5leHBvcnRzLnV0ZjggPSAoKG1heFNwYW4sIHByb3BlcnR5KSA9PiBuZXcgVVRGOChtYXhTcGFuLCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBDb25zdGFudH0gdmFsdWVzLiAqL1xuZXhwb3J0cy5jb25zdGFudCA9ICgodmFsdWUsIHByb3BlcnR5KSA9PiBuZXcgQ29uc3RhbnQodmFsdWUsIHByb3BlcnR5KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MYXlvdXQuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiczE2IiwiczgiLCJudTY0YmUiLCJ1NDhiZSIsInU0MGJlIiwidTMyYmUiLCJ1MjRiZSIsInUxNmJlIiwibnU2NCIsInU0OCIsInU0MCIsInUzMiIsInUyNCIsInUxNiIsInU4Iiwib2Zmc2V0IiwiZ3JlZWR5IiwiQ29uc3RhbnQiLCJVVEY4IiwiQ1N0cmluZyIsIkJsb2IiLCJCb29sZWFuIiwiQml0RmllbGQiLCJCaXRTdHJ1Y3R1cmUiLCJWYXJpYW50TGF5b3V0IiwiVW5pb24iLCJVbmlvbkxheW91dERpc2NyaW1pbmF0b3IiLCJVbmlvbkRpc2NyaW1pbmF0b3IiLCJTdHJ1Y3R1cmUiLCJTZXF1ZW5jZSIsIkRvdWJsZUJFIiwiRG91YmxlIiwiRmxvYXRCRSIsIkZsb2F0IiwiTmVhckludDY0QkUiLCJOZWFySW50NjQiLCJOZWFyVUludDY0QkUiLCJOZWFyVUludDY0IiwiSW50QkUiLCJJbnQiLCJVSW50QkUiLCJVSW50IiwiT2Zmc2V0TGF5b3V0IiwiR3JlZWR5Q291bnQiLCJFeHRlcm5hbExheW91dCIsImJpbmRDb25zdHJ1Y3RvckxheW91dCIsIm5hbWVXaXRoUHJvcGVydHkiLCJMYXlvdXQiLCJ1aW50OEFycmF5VG9CdWZmZXIiLCJjaGVja1VpbnQ4QXJyYXkiLCJjb25zdGFudCIsInV0ZjgiLCJjc3RyIiwiYmxvYiIsInVuaW9uTGF5b3V0RGlzY3JpbWluYXRvciIsInVuaW9uIiwic2VxIiwiYml0cyIsInN0cnVjdCIsImY2NGJlIiwiZjY0IiwiZjMyYmUiLCJmMzIiLCJuczY0YmUiLCJzNDhiZSIsInM0MGJlIiwiczMyYmUiLCJzMjRiZSIsInMxNmJlIiwibnM2NCIsInM0OCIsInM0MCIsInMzMiIsInMyNCIsImJ1ZmZlcl8xIiwicmVxdWlyZSIsImIiLCJVaW50OEFycmF5IiwiVHlwZUVycm9yIiwiQnVmZmVyIiwiZnJvbSIsImJ1ZmZlciIsImJ5dGVPZmZzZXQiLCJsZW5ndGgiLCJjb25zdHJ1Y3RvciIsInNwYW4iLCJwcm9wZXJ0eSIsIk51bWJlciIsImlzSW50ZWdlciIsIm1ha2VEZXN0aW5hdGlvbk9iamVjdCIsImdldFNwYW4iLCJSYW5nZUVycm9yIiwicmVwbGljYXRlIiwicnYiLCJjcmVhdGUiLCJwcm90b3R5cGUiLCJhc3NpZ24iLCJmcm9tQXJyYXkiLCJ2YWx1ZXMiLCJ1bmRlZmluZWQiLCJuYW1lIiwibG8iLCJDbGFzcyIsImxheW91dCIsImhhc093blByb3BlcnR5IiwiY2FsbCIsIkVycm9yIiwibGF5b3V0XyIsImJvdW5kQ29uc3RydWN0b3JfIiwiZW5jb2RlIiwid3JpdGFibGUiLCJkZWNvZGUiLCJpc0NvdW50IiwiZWxlbWVudFNwYW4iLCJyZW0iLCJNYXRoIiwiZmxvb3IiLCJzcmMiLCJyZWFkVUludExFIiwid3JpdGVVSW50TEUiLCJyZWFkVUludEJFIiwid3JpdGVVSW50QkUiLCJyZWFkSW50TEUiLCJ3cml0ZUludExFIiwicmVhZEludEJFIiwid3JpdGVJbnRCRSIsIlYyRTMyIiwicG93IiwiZGl2bW9kSW50NjQiLCJoaTMyIiwibG8zMiIsInJvdW5kZWRJbnQ2NCIsInJlYWRVSW50MzJMRSIsInNwbGl0Iiwid3JpdGVVSW50MzJMRSIsInJlYWRVSW50MzJCRSIsIndyaXRlVUludDMyQkUiLCJyZWFkSW50MzJMRSIsIndyaXRlSW50MzJMRSIsInJlYWRJbnQzMkJFIiwid3JpdGVJbnQzMkJFIiwicmVhZEZsb2F0TEUiLCJ3cml0ZUZsb2F0TEUiLCJyZWFkRmxvYXRCRSIsIndyaXRlRmxvYXRCRSIsInJlYWREb3VibGVMRSIsIndyaXRlRG91YmxlTEUiLCJyZWFkRG91YmxlQkUiLCJ3cml0ZURvdWJsZUJFIiwiZWxlbWVudExheW91dCIsImNvdW50IiwiaWR4IiwiaSIsInB1c2giLCJlbG8iLCJyZWR1Y2UiLCJ2IiwiZmllbGRzIiwiZGVjb2RlUHJlZml4ZXMiLCJBcnJheSIsImlzQXJyYXkiLCJhY2MiLCJmZCIsImUiLCJmc3AiLCJkZXN0IiwiZmlyc3RPZmZzZXQiLCJsYXN0T2Zmc2V0IiwibGFzdFdyb3RlIiwiZnYiLCJzaGlmdCIsImxheW91dEZvciIsIm9mZnNldE9mIiwiZGlzY3IiLCJkZWZhdWx0TGF5b3V0IiwiZGlzY3JpbWluYXRvciIsInVzZXNQcmVmaXhEaXNjcmltaW5hdG9yIiwicmVnaXN0cnkiLCJib3VuZEdldFNvdXJjZVZhcmlhbnQiLCJkZWZhdWx0R2V0U291cmNlVmFyaWFudCIsImJpbmQiLCJnZXRTb3VyY2VWYXJpYW50IiwiY29uZmlnR2V0U291cmNlVmFyaWFudCIsImdzdiIsInZsbyIsImdldFZhcmlhbnQiLCJ0YWciLCJkbG8iLCJjbG8iLCJjb250ZW50T2Zmc2V0IiwiYWRkVmFyaWFudCIsInZhcmlhbnQiLCJ2YiIsImZpeEJpdHdpc2VSZXN1bHQiLCJ3b3JkIiwibXNiIiwiX3BhY2tlZFNldFZhbHVlIiwiX3BhY2tlZEdldFZhbHVlIiwiYWRkRmllbGQiLCJiZiIsImFkZEJvb2xlYW4iLCJmaWVsZEZvciIsImNvbnRhaW5lciIsInRvdGFsQml0cyIsInVzZWRCaXRzIiwic3VtIiwidmFsdWVNYXNrIiwic3RhcnQiLCJ3b3JkTWFzayIsIndvcmRWYWx1ZSIsInNsaWNlIiwic3JjQnVmZmVyIiwid3JpdGUiLCJ0b1N0cmluZyIsIlN0cmluZyIsInNyY2IiLCJjb3B5IiwibWF4U3BhbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/buffer-layout/lib/Layout.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/web3.js/lib/index.esm.js":
/*!*******************************************************!*\
  !*** ./node_modules/@solana/web3.js/lib/index.esm.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Account: () => (/* binding */ Account),\n/* harmony export */   AddressLookupTableAccount: () => (/* binding */ AddressLookupTableAccount),\n/* harmony export */   AddressLookupTableInstruction: () => (/* binding */ AddressLookupTableInstruction),\n/* harmony export */   AddressLookupTableProgram: () => (/* binding */ AddressLookupTableProgram),\n/* harmony export */   Authorized: () => (/* binding */ Authorized),\n/* harmony export */   BLOCKHASH_CACHE_TIMEOUT_MS: () => (/* binding */ BLOCKHASH_CACHE_TIMEOUT_MS),\n/* harmony export */   BPF_LOADER_DEPRECATED_PROGRAM_ID: () => (/* binding */ BPF_LOADER_DEPRECATED_PROGRAM_ID),\n/* harmony export */   BPF_LOADER_PROGRAM_ID: () => (/* binding */ BPF_LOADER_PROGRAM_ID),\n/* harmony export */   BpfLoader: () => (/* binding */ BpfLoader),\n/* harmony export */   COMPUTE_BUDGET_INSTRUCTION_LAYOUTS: () => (/* binding */ COMPUTE_BUDGET_INSTRUCTION_LAYOUTS),\n/* harmony export */   ComputeBudgetInstruction: () => (/* binding */ ComputeBudgetInstruction),\n/* harmony export */   ComputeBudgetProgram: () => (/* binding */ ComputeBudgetProgram),\n/* harmony export */   Connection: () => (/* binding */ Connection),\n/* harmony export */   Ed25519Program: () => (/* binding */ Ed25519Program),\n/* harmony export */   Enum: () => (/* binding */ Enum),\n/* harmony export */   EpochSchedule: () => (/* binding */ EpochSchedule),\n/* harmony export */   FeeCalculatorLayout: () => (/* binding */ FeeCalculatorLayout),\n/* harmony export */   Keypair: () => (/* binding */ Keypair),\n/* harmony export */   LAMPORTS_PER_SOL: () => (/* binding */ LAMPORTS_PER_SOL),\n/* harmony export */   LOOKUP_TABLE_INSTRUCTION_LAYOUTS: () => (/* binding */ LOOKUP_TABLE_INSTRUCTION_LAYOUTS),\n/* harmony export */   Loader: () => (/* binding */ Loader),\n/* harmony export */   Lockup: () => (/* binding */ Lockup),\n/* harmony export */   MAX_SEED_LENGTH: () => (/* binding */ MAX_SEED_LENGTH),\n/* harmony export */   Message: () => (/* binding */ Message),\n/* harmony export */   MessageAccountKeys: () => (/* binding */ MessageAccountKeys),\n/* harmony export */   MessageV0: () => (/* binding */ MessageV0),\n/* harmony export */   NONCE_ACCOUNT_LENGTH: () => (/* binding */ NONCE_ACCOUNT_LENGTH),\n/* harmony export */   NonceAccount: () => (/* binding */ NonceAccount),\n/* harmony export */   PACKET_DATA_SIZE: () => (/* binding */ PACKET_DATA_SIZE),\n/* harmony export */   PUBLIC_KEY_LENGTH: () => (/* binding */ PUBLIC_KEY_LENGTH),\n/* harmony export */   PublicKey: () => (/* binding */ PublicKey),\n/* harmony export */   SIGNATURE_LENGTH_IN_BYTES: () => (/* binding */ SIGNATURE_LENGTH_IN_BYTES),\n/* harmony export */   SOLANA_SCHEMA: () => (/* binding */ SOLANA_SCHEMA),\n/* harmony export */   STAKE_CONFIG_ID: () => (/* binding */ STAKE_CONFIG_ID),\n/* harmony export */   STAKE_INSTRUCTION_LAYOUTS: () => (/* binding */ STAKE_INSTRUCTION_LAYOUTS),\n/* harmony export */   SYSTEM_INSTRUCTION_LAYOUTS: () => (/* binding */ SYSTEM_INSTRUCTION_LAYOUTS),\n/* harmony export */   SYSVAR_CLOCK_PUBKEY: () => (/* binding */ SYSVAR_CLOCK_PUBKEY),\n/* harmony export */   SYSVAR_EPOCH_SCHEDULE_PUBKEY: () => (/* binding */ SYSVAR_EPOCH_SCHEDULE_PUBKEY),\n/* harmony export */   SYSVAR_INSTRUCTIONS_PUBKEY: () => (/* binding */ SYSVAR_INSTRUCTIONS_PUBKEY),\n/* harmony export */   SYSVAR_RECENT_BLOCKHASHES_PUBKEY: () => (/* binding */ SYSVAR_RECENT_BLOCKHASHES_PUBKEY),\n/* harmony export */   SYSVAR_RENT_PUBKEY: () => (/* binding */ SYSVAR_RENT_PUBKEY),\n/* harmony export */   SYSVAR_REWARDS_PUBKEY: () => (/* binding */ SYSVAR_REWARDS_PUBKEY),\n/* harmony export */   SYSVAR_SLOT_HASHES_PUBKEY: () => (/* binding */ SYSVAR_SLOT_HASHES_PUBKEY),\n/* harmony export */   SYSVAR_SLOT_HISTORY_PUBKEY: () => (/* binding */ SYSVAR_SLOT_HISTORY_PUBKEY),\n/* harmony export */   SYSVAR_STAKE_HISTORY_PUBKEY: () => (/* binding */ SYSVAR_STAKE_HISTORY_PUBKEY),\n/* harmony export */   Secp256k1Program: () => (/* binding */ Secp256k1Program),\n/* harmony export */   SendTransactionError: () => (/* binding */ SendTransactionError),\n/* harmony export */   SolanaJSONRPCError: () => (/* binding */ SolanaJSONRPCError),\n/* harmony export */   SolanaJSONRPCErrorCode: () => (/* binding */ SolanaJSONRPCErrorCode),\n/* harmony export */   StakeAuthorizationLayout: () => (/* binding */ StakeAuthorizationLayout),\n/* harmony export */   StakeInstruction: () => (/* binding */ StakeInstruction),\n/* harmony export */   StakeProgram: () => (/* binding */ StakeProgram),\n/* harmony export */   Struct: () => (/* binding */ Struct),\n/* harmony export */   SystemInstruction: () => (/* binding */ SystemInstruction),\n/* harmony export */   SystemProgram: () => (/* binding */ SystemProgram),\n/* harmony export */   Transaction: () => (/* binding */ Transaction),\n/* harmony export */   TransactionExpiredBlockheightExceededError: () => (/* binding */ TransactionExpiredBlockheightExceededError),\n/* harmony export */   TransactionExpiredNonceInvalidError: () => (/* binding */ TransactionExpiredNonceInvalidError),\n/* harmony export */   TransactionExpiredTimeoutError: () => (/* binding */ TransactionExpiredTimeoutError),\n/* harmony export */   TransactionInstruction: () => (/* binding */ TransactionInstruction),\n/* harmony export */   TransactionMessage: () => (/* binding */ TransactionMessage),\n/* harmony export */   TransactionStatus: () => (/* binding */ TransactionStatus),\n/* harmony export */   VALIDATOR_INFO_KEY: () => (/* binding */ VALIDATOR_INFO_KEY),\n/* harmony export */   VERSION_PREFIX_MASK: () => (/* binding */ VERSION_PREFIX_MASK),\n/* harmony export */   VOTE_PROGRAM_ID: () => (/* binding */ VOTE_PROGRAM_ID),\n/* harmony export */   ValidatorInfo: () => (/* binding */ ValidatorInfo),\n/* harmony export */   VersionedMessage: () => (/* binding */ VersionedMessage),\n/* harmony export */   VersionedTransaction: () => (/* binding */ VersionedTransaction),\n/* harmony export */   VoteAccount: () => (/* binding */ VoteAccount),\n/* harmony export */   VoteAuthorizationLayout: () => (/* binding */ VoteAuthorizationLayout),\n/* harmony export */   VoteInit: () => (/* binding */ VoteInit),\n/* harmony export */   VoteInstruction: () => (/* binding */ VoteInstruction),\n/* harmony export */   VoteProgram: () => (/* binding */ VoteProgram),\n/* harmony export */   clusterApiUrl: () => (/* binding */ clusterApiUrl),\n/* harmony export */   sendAndConfirmRawTransaction: () => (/* binding */ sendAndConfirmRawTransaction),\n/* harmony export */   sendAndConfirmTransaction: () => (/* binding */ sendAndConfirmTransaction)\n/* harmony export */ });\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! buffer */ \"buffer\");\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(buffer__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @noble/curves/ed25519 */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/ed25519.js\");\n/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/bn.js/lib/bn.js\");\n/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(bn_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var bs58__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! bs58 */ \"(ssr)/./node_modules/bs58/index.js\");\n/* harmony import */ var bs58__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(bs58__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var borsh__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! borsh */ \"(ssr)/./node_modules/borsh/lib/index.js\");\n/* harmony import */ var _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @solana/buffer-layout */ \"(ssr)/./node_modules/@solana/buffer-layout/lib/Layout.js\");\n/* harmony import */ var _solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @solana/codecs-numbers */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@solana/codecs-numbers/dist/index.node.mjs\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! util */ \"util\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! http */ \"http\");\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(http__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! https */ \"https\");\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(https__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var superstruct__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! superstruct */ \"(ssr)/./node_modules/superstruct/dist/index.mjs\");\n/* harmony import */ var jayson_lib_client_browser__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! jayson/lib/client/browser */ \"(ssr)/./node_modules/jayson/lib/client/browser/index.js\");\n/* harmony import */ var jayson_lib_client_browser__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(jayson_lib_client_browser__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! node-fetch */ \"(ssr)/./node_modules/node-fetch/lib/index.mjs\");\n/* harmony import */ var rpc_websockets__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! rpc-websockets */ \"(ssr)/./node_modules/rpc-websockets/dist/index.mjs\");\n/* harmony import */ var _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @noble/hashes/sha3 */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/sha3.js\");\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/secp256k1.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * A 64 byte secret key, the first 32 bytes of which is the\n * private scalar and the last 32 bytes is the public key.\n * Read more: https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/\n */ /**\n * Ed25519 Keypair\n */ const generatePrivateKey = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_11__.ed25519.utils.randomPrivateKey;\nconst generateKeypair = ()=>{\n    const privateScalar = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_11__.ed25519.utils.randomPrivateKey();\n    const publicKey = getPublicKey(privateScalar);\n    const secretKey = new Uint8Array(64);\n    secretKey.set(privateScalar);\n    secretKey.set(publicKey, 32);\n    return {\n        publicKey,\n        secretKey\n    };\n};\nconst getPublicKey = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_11__.ed25519.getPublicKey;\nfunction isOnCurve(publicKey) {\n    try {\n        _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_11__.ed25519.ExtendedPoint.fromHex(publicKey);\n        return true;\n    } catch  {\n        return false;\n    }\n}\nconst sign = (message, secretKey)=>_noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_11__.ed25519.sign(message, secretKey.slice(0, 32));\nconst verify = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_11__.ed25519.verify;\nconst toBuffer = (arr)=>{\n    if (buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.isBuffer(arr)) {\n        return arr;\n    } else if (arr instanceof Uint8Array) {\n        return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);\n    } else {\n        return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(arr);\n    }\n};\n// Class wrapping a plain object\nclass Struct {\n    constructor(properties){\n        Object.assign(this, properties);\n    }\n    encode() {\n        return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from((0,borsh__WEBPACK_IMPORTED_MODULE_3__.serialize)(SOLANA_SCHEMA, this));\n    }\n    static decode(data) {\n        return (0,borsh__WEBPACK_IMPORTED_MODULE_3__.deserialize)(SOLANA_SCHEMA, this, data);\n    }\n    static decodeUnchecked(data) {\n        return (0,borsh__WEBPACK_IMPORTED_MODULE_3__.deserializeUnchecked)(SOLANA_SCHEMA, this, data);\n    }\n}\n// Class representing a Rust-compatible enum, since enums are only strings or\n// numbers in pure JS\nclass Enum extends Struct {\n    constructor(properties){\n        super(properties);\n        this.enum = \"\";\n        if (Object.keys(properties).length !== 1) {\n            throw new Error(\"Enum can only take single value\");\n        }\n        Object.keys(properties).map((key)=>{\n            this.enum = key;\n        });\n    }\n}\nconst SOLANA_SCHEMA = new Map();\nvar _PublicKey;\n/**\n * Maximum length of derived pubkey seed\n */ const MAX_SEED_LENGTH = 32;\n/**\n * Size of public key in bytes\n */ const PUBLIC_KEY_LENGTH = 32;\n/**\n * Value to be converted into public key\n */ /**\n * JSON object representation of PublicKey class\n */ function isPublicKeyData(value) {\n    return value._bn !== undefined;\n}\n// local counter used by PublicKey.unique()\nlet uniquePublicKeyCounter = 1;\n/**\n * A public key\n */ class PublicKey extends Struct {\n    /**\n   * Create a new PublicKey object\n   * @param value ed25519 public key as buffer or base-58 encoded string\n   */ constructor(value){\n        super({});\n        /** @internal */ this._bn = void 0;\n        if (isPublicKeyData(value)) {\n            this._bn = value._bn;\n        } else {\n            if (typeof value === \"string\") {\n                // assume base 58 encoding by default\n                const decoded = bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(value);\n                if (decoded.length != PUBLIC_KEY_LENGTH) {\n                    throw new Error(`Invalid public key input`);\n                }\n                this._bn = new (bn_js__WEBPACK_IMPORTED_MODULE_1___default())(decoded);\n            } else {\n                this._bn = new (bn_js__WEBPACK_IMPORTED_MODULE_1___default())(value);\n            }\n            if (this._bn.byteLength() > PUBLIC_KEY_LENGTH) {\n                throw new Error(`Invalid public key input`);\n            }\n        }\n    }\n    /**\n   * Returns a unique PublicKey for tests and benchmarks using a counter\n   */ static unique() {\n        const key = new PublicKey(uniquePublicKeyCounter);\n        uniquePublicKeyCounter += 1;\n        return new PublicKey(key.toBuffer());\n    }\n    /**\n   * Default public key value. The base58-encoded string representation is all ones (as seen below)\n   * The underlying BN number is 32 bytes that are all zeros\n   */ /**\n   * Checks if two publicKeys are equal\n   */ equals(publicKey) {\n        return this._bn.eq(publicKey._bn);\n    }\n    /**\n   * Return the base-58 representation of the public key\n   */ toBase58() {\n        return bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(this.toBytes());\n    }\n    toJSON() {\n        return this.toBase58();\n    }\n    /**\n   * Return the byte array representation of the public key in big endian\n   */ toBytes() {\n        const buf = this.toBuffer();\n        return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);\n    }\n    /**\n   * Return the Buffer representation of the public key in big endian\n   */ toBuffer() {\n        const b = this._bn.toArrayLike(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer);\n        if (b.length === PUBLIC_KEY_LENGTH) {\n            return b;\n        }\n        const zeroPad = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(32);\n        b.copy(zeroPad, 32 - b.length);\n        return zeroPad;\n    }\n    get [Symbol.toStringTag]() {\n        return `PublicKey(${this.toString()})`;\n    }\n    /**\n   * Return the base-58 representation of the public key\n   */ toString() {\n        return this.toBase58();\n    }\n    /**\n   * Derive a public key from another key, a seed, and a program ID.\n   * The program ID will also serve as the owner of the public key, giving\n   * it permission to write data to the account.\n   */ /* eslint-disable require-await */ static async createWithSeed(fromPublicKey, seed, programId) {\n        const buffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.concat([\n            fromPublicKey.toBuffer(),\n            buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(seed),\n            programId.toBuffer()\n        ]);\n        const publicKeyBytes = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_12__.sha256)(buffer);\n        return new PublicKey(publicKeyBytes);\n    }\n    /**\n   * Derive a program address from seeds and a program ID.\n   */ /* eslint-disable require-await */ static createProgramAddressSync(seeds, programId) {\n        let buffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(0);\n        seeds.forEach(function(seed) {\n            if (seed.length > MAX_SEED_LENGTH) {\n                throw new TypeError(`Max seed length exceeded`);\n            }\n            buffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.concat([\n                buffer,\n                toBuffer(seed)\n            ]);\n        });\n        buffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.concat([\n            buffer,\n            programId.toBuffer(),\n            buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(\"ProgramDerivedAddress\")\n        ]);\n        const publicKeyBytes = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_12__.sha256)(buffer);\n        if (isOnCurve(publicKeyBytes)) {\n            throw new Error(`Invalid seeds, address must fall off the curve`);\n        }\n        return new PublicKey(publicKeyBytes);\n    }\n    /**\n   * Async version of createProgramAddressSync\n   * For backwards compatibility\n   *\n   * @deprecated Use {@link createProgramAddressSync} instead\n   */ /* eslint-disable require-await */ static async createProgramAddress(seeds, programId) {\n        return this.createProgramAddressSync(seeds, programId);\n    }\n    /**\n   * Find a valid program address\n   *\n   * Valid program addresses must fall off the ed25519 curve.  This function\n   * iterates a nonce until it finds one that when combined with the seeds\n   * results in a valid program address.\n   */ static findProgramAddressSync(seeds, programId) {\n        let nonce = 255;\n        let address;\n        while(nonce != 0){\n            try {\n                const seedsWithNonce = seeds.concat(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([\n                    nonce\n                ]));\n                address = this.createProgramAddressSync(seedsWithNonce, programId);\n            } catch (err) {\n                if (err instanceof TypeError) {\n                    throw err;\n                }\n                nonce--;\n                continue;\n            }\n            return [\n                address,\n                nonce\n            ];\n        }\n        throw new Error(`Unable to find a viable program address nonce`);\n    }\n    /**\n   * Async version of findProgramAddressSync\n   * For backwards compatibility\n   *\n   * @deprecated Use {@link findProgramAddressSync} instead\n   */ static async findProgramAddress(seeds, programId) {\n        return this.findProgramAddressSync(seeds, programId);\n    }\n    /**\n   * Check that a pubkey is on the ed25519 curve.\n   */ static isOnCurve(pubkeyData) {\n        const pubkey = new PublicKey(pubkeyData);\n        return isOnCurve(pubkey.toBytes());\n    }\n}\n_PublicKey = PublicKey;\nPublicKey.default = new _PublicKey(\"11111111111111111111111111111111\");\nSOLANA_SCHEMA.set(PublicKey, {\n    kind: \"struct\",\n    fields: [\n        [\n            \"_bn\",\n            \"u256\"\n        ]\n    ]\n});\n/**\n * An account key pair (public and secret keys).\n *\n * @deprecated since v1.10.0, please use {@link Keypair} instead.\n */ class Account {\n    /**\n   * Create a new Account object\n   *\n   * If the secretKey parameter is not provided a new key pair is randomly\n   * created for the account\n   *\n   * @param secretKey Secret key for the account\n   */ constructor(secretKey){\n        /** @internal */ this._publicKey = void 0;\n        /** @internal */ this._secretKey = void 0;\n        if (secretKey) {\n            const secretKeyBuffer = toBuffer(secretKey);\n            if (secretKey.length !== 64) {\n                throw new Error(\"bad secret key size\");\n            }\n            this._publicKey = secretKeyBuffer.slice(32, 64);\n            this._secretKey = secretKeyBuffer.slice(0, 32);\n        } else {\n            this._secretKey = toBuffer(generatePrivateKey());\n            this._publicKey = toBuffer(getPublicKey(this._secretKey));\n        }\n    }\n    /**\n   * The public key for this account\n   */ get publicKey() {\n        return new PublicKey(this._publicKey);\n    }\n    /**\n   * The **unencrypted** secret key for this account. The first 32 bytes\n   * is the private scalar and the last 32 bytes is the public key.\n   * Read more: https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/\n   */ get secretKey() {\n        return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.concat([\n            this._secretKey,\n            this._publicKey\n        ], 64);\n    }\n}\nconst BPF_LOADER_DEPRECATED_PROGRAM_ID = new PublicKey(\"BPFLoader1111111111111111111111111111111111\");\n/**\n * Maximum over-the-wire size of a Transaction\n *\n * 1280 is IPv6 minimum MTU\n * 40 bytes is the size of the IPv6 header\n * 8 bytes is the size of the fragment header\n */ const PACKET_DATA_SIZE = 1280 - 40 - 8;\nconst VERSION_PREFIX_MASK = 0x7f;\nconst SIGNATURE_LENGTH_IN_BYTES = 64;\nclass TransactionExpiredBlockheightExceededError extends Error {\n    constructor(signature){\n        super(`Signature ${signature} has expired: block height exceeded.`);\n        this.signature = void 0;\n        this.signature = signature;\n    }\n}\nObject.defineProperty(TransactionExpiredBlockheightExceededError.prototype, \"name\", {\n    value: \"TransactionExpiredBlockheightExceededError\"\n});\nclass TransactionExpiredTimeoutError extends Error {\n    constructor(signature, timeoutSeconds){\n        super(`Transaction was not confirmed in ${timeoutSeconds.toFixed(2)} seconds. It is ` + \"unknown if it succeeded or failed. Check signature \" + `${signature} using the Solana Explorer or CLI tools.`);\n        this.signature = void 0;\n        this.signature = signature;\n    }\n}\nObject.defineProperty(TransactionExpiredTimeoutError.prototype, \"name\", {\n    value: \"TransactionExpiredTimeoutError\"\n});\nclass TransactionExpiredNonceInvalidError extends Error {\n    constructor(signature){\n        super(`Signature ${signature} has expired: the nonce is no longer valid.`);\n        this.signature = void 0;\n        this.signature = signature;\n    }\n}\nObject.defineProperty(TransactionExpiredNonceInvalidError.prototype, \"name\", {\n    value: \"TransactionExpiredNonceInvalidError\"\n});\nclass MessageAccountKeys {\n    constructor(staticAccountKeys, accountKeysFromLookups){\n        this.staticAccountKeys = void 0;\n        this.accountKeysFromLookups = void 0;\n        this.staticAccountKeys = staticAccountKeys;\n        this.accountKeysFromLookups = accountKeysFromLookups;\n    }\n    keySegments() {\n        const keySegments = [\n            this.staticAccountKeys\n        ];\n        if (this.accountKeysFromLookups) {\n            keySegments.push(this.accountKeysFromLookups.writable);\n            keySegments.push(this.accountKeysFromLookups.readonly);\n        }\n        return keySegments;\n    }\n    get(index) {\n        for (const keySegment of this.keySegments()){\n            if (index < keySegment.length) {\n                return keySegment[index];\n            } else {\n                index -= keySegment.length;\n            }\n        }\n        return;\n    }\n    get length() {\n        return this.keySegments().flat().length;\n    }\n    compileInstructions(instructions) {\n        // Bail early if any account indexes would overflow a u8\n        const U8_MAX = 255;\n        if (this.length > U8_MAX + 1) {\n            throw new Error(\"Account index overflow encountered during compilation\");\n        }\n        const keyIndexMap = new Map();\n        this.keySegments().flat().forEach((key, index)=>{\n            keyIndexMap.set(key.toBase58(), index);\n        });\n        const findKeyIndex = (key)=>{\n            const keyIndex = keyIndexMap.get(key.toBase58());\n            if (keyIndex === undefined) throw new Error(\"Encountered an unknown instruction account key during compilation\");\n            return keyIndex;\n        };\n        return instructions.map((instruction)=>{\n            return {\n                programIdIndex: findKeyIndex(instruction.programId),\n                accountKeyIndexes: instruction.keys.map((meta)=>findKeyIndex(meta.pubkey)),\n                data: instruction.data\n            };\n        });\n    }\n}\n/**\n * Layout for a public key\n */ const publicKey = (property = \"publicKey\")=>{\n    return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(32, property);\n};\n/**\n * Layout for a signature\n */ const signature = (property = \"signature\")=>{\n    return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(64, property);\n};\n/**\n * Layout for a Rust String type\n */ const rustString = (property = \"string\")=>{\n    const rsl = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"length\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"lengthPadding\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(), -8), \"chars\")\n    ], property);\n    const _decode = rsl.decode.bind(rsl);\n    const _encode = rsl.encode.bind(rsl);\n    const rslShim = rsl;\n    rslShim.decode = (b, offset)=>{\n        const data = _decode(b, offset);\n        return data[\"chars\"].toString();\n    };\n    rslShim.encode = (str, b, offset)=>{\n        const data = {\n            chars: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(str, \"utf8\")\n        };\n        return _encode(data, b, offset);\n    };\n    rslShim.alloc = (str)=>{\n        return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32().span + _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32().span + buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(str, \"utf8\").length;\n    };\n    return rslShim;\n};\n/**\n * Layout for an Authorized object\n */ const authorized = (property = \"authorized\")=>{\n    return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        publicKey(\"staker\"),\n        publicKey(\"withdrawer\")\n    ], property);\n};\n/**\n * Layout for a Lockup object\n */ const lockup = (property = \"lockup\")=>{\n    return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"unixTimestamp\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"epoch\"),\n        publicKey(\"custodian\")\n    ], property);\n};\n/**\n *  Layout for a VoteInit object\n */ const voteInit = (property = \"voteInit\")=>{\n    return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        publicKey(\"nodePubkey\"),\n        publicKey(\"authorizedVoter\"),\n        publicKey(\"authorizedWithdrawer\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"commission\")\n    ], property);\n};\n/**\n *  Layout for a VoteAuthorizeWithSeedArgs object\n */ const voteAuthorizeWithSeedArgs = (property = \"voteAuthorizeWithSeedArgs\")=>{\n    return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"voteAuthorizationType\"),\n        publicKey(\"currentAuthorityDerivedKeyOwnerPubkey\"),\n        rustString(\"currentAuthorityDerivedKeySeed\"),\n        publicKey(\"newAuthorized\")\n    ], property);\n};\nfunction getAlloc(type, fields) {\n    const getItemAlloc = (item)=>{\n        if (item.span >= 0) {\n            return item.span;\n        } else if (typeof item.alloc === \"function\") {\n            return item.alloc(fields[item.property]);\n        } else if (\"count\" in item && \"elementLayout\" in item) {\n            const field = fields[item.property];\n            if (Array.isArray(field)) {\n                return field.length * getItemAlloc(item.elementLayout);\n            }\n        } else if (\"fields\" in item) {\n            // This is a `Structure` whose size needs to be recursively measured.\n            return getAlloc({\n                layout: item\n            }, fields[item.property]);\n        }\n        // Couldn't determine allocated size of layout\n        return 0;\n    };\n    let alloc = 0;\n    type.layout.fields.forEach((item)=>{\n        alloc += getItemAlloc(item);\n    });\n    return alloc;\n}\nfunction decodeLength(bytes) {\n    let len = 0;\n    let size = 0;\n    for(;;){\n        let elem = bytes.shift();\n        len |= (elem & 0x7f) << size * 7;\n        size += 1;\n        if ((elem & 0x80) === 0) {\n            break;\n        }\n    }\n    return len;\n}\nfunction encodeLength(bytes, len) {\n    let rem_len = len;\n    for(;;){\n        let elem = rem_len & 0x7f;\n        rem_len >>= 7;\n        if (rem_len == 0) {\n            bytes.push(elem);\n            break;\n        } else {\n            elem |= 0x80;\n            bytes.push(elem);\n        }\n    }\n}\nfunction assert(condition, message) {\n    if (!condition) {\n        throw new Error(message || \"Assertion failed\");\n    }\n}\nclass CompiledKeys {\n    constructor(payer, keyMetaMap){\n        this.payer = void 0;\n        this.keyMetaMap = void 0;\n        this.payer = payer;\n        this.keyMetaMap = keyMetaMap;\n    }\n    static compile(instructions, payer) {\n        const keyMetaMap = new Map();\n        const getOrInsertDefault = (pubkey)=>{\n            const address = pubkey.toBase58();\n            let keyMeta = keyMetaMap.get(address);\n            if (keyMeta === undefined) {\n                keyMeta = {\n                    isSigner: false,\n                    isWritable: false,\n                    isInvoked: false\n                };\n                keyMetaMap.set(address, keyMeta);\n            }\n            return keyMeta;\n        };\n        const payerKeyMeta = getOrInsertDefault(payer);\n        payerKeyMeta.isSigner = true;\n        payerKeyMeta.isWritable = true;\n        for (const ix of instructions){\n            getOrInsertDefault(ix.programId).isInvoked = true;\n            for (const accountMeta of ix.keys){\n                const keyMeta = getOrInsertDefault(accountMeta.pubkey);\n                keyMeta.isSigner ||= accountMeta.isSigner;\n                keyMeta.isWritable ||= accountMeta.isWritable;\n            }\n        }\n        return new CompiledKeys(payer, keyMetaMap);\n    }\n    getMessageComponents() {\n        const mapEntries = [\n            ...this.keyMetaMap.entries()\n        ];\n        assert(mapEntries.length <= 256, \"Max static account keys length exceeded\");\n        const writableSigners = mapEntries.filter(([, meta])=>meta.isSigner && meta.isWritable);\n        const readonlySigners = mapEntries.filter(([, meta])=>meta.isSigner && !meta.isWritable);\n        const writableNonSigners = mapEntries.filter(([, meta])=>!meta.isSigner && meta.isWritable);\n        const readonlyNonSigners = mapEntries.filter(([, meta])=>!meta.isSigner && !meta.isWritable);\n        const header = {\n            numRequiredSignatures: writableSigners.length + readonlySigners.length,\n            numReadonlySignedAccounts: readonlySigners.length,\n            numReadonlyUnsignedAccounts: readonlyNonSigners.length\n        };\n        // sanity checks\n        {\n            assert(writableSigners.length > 0, \"Expected at least one writable signer key\");\n            const [payerAddress] = writableSigners[0];\n            assert(payerAddress === this.payer.toBase58(), \"Expected first writable signer key to be the fee payer\");\n        }\n        const staticAccountKeys = [\n            ...writableSigners.map(([address])=>new PublicKey(address)),\n            ...readonlySigners.map(([address])=>new PublicKey(address)),\n            ...writableNonSigners.map(([address])=>new PublicKey(address)),\n            ...readonlyNonSigners.map(([address])=>new PublicKey(address))\n        ];\n        return [\n            header,\n            staticAccountKeys\n        ];\n    }\n    extractTableLookup(lookupTable) {\n        const [writableIndexes, drainedWritableKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta)=>!keyMeta.isSigner && !keyMeta.isInvoked && keyMeta.isWritable);\n        const [readonlyIndexes, drainedReadonlyKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta)=>!keyMeta.isSigner && !keyMeta.isInvoked && !keyMeta.isWritable);\n        // Don't extract lookup if no keys were found\n        if (writableIndexes.length === 0 && readonlyIndexes.length === 0) {\n            return;\n        }\n        return [\n            {\n                accountKey: lookupTable.key,\n                writableIndexes,\n                readonlyIndexes\n            },\n            {\n                writable: drainedWritableKeys,\n                readonly: drainedReadonlyKeys\n            }\n        ];\n    }\n    /** @internal */ drainKeysFoundInLookupTable(lookupTableEntries, keyMetaFilter) {\n        const lookupTableIndexes = new Array();\n        const drainedKeys = new Array();\n        for (const [address, keyMeta] of this.keyMetaMap.entries()){\n            if (keyMetaFilter(keyMeta)) {\n                const key = new PublicKey(address);\n                const lookupTableIndex = lookupTableEntries.findIndex((entry)=>entry.equals(key));\n                if (lookupTableIndex >= 0) {\n                    assert(lookupTableIndex < 256, \"Max lookup table index exceeded\");\n                    lookupTableIndexes.push(lookupTableIndex);\n                    drainedKeys.push(key);\n                    this.keyMetaMap.delete(address);\n                }\n            }\n        }\n        return [\n            lookupTableIndexes,\n            drainedKeys\n        ];\n    }\n}\nconst END_OF_BUFFER_ERROR_MESSAGE = \"Reached end of buffer unexpectedly\";\n/**\n * Delegates to `Array#shift`, but throws if the array is zero-length.\n */ function guardedShift(byteArray) {\n    if (byteArray.length === 0) {\n        throw new Error(END_OF_BUFFER_ERROR_MESSAGE);\n    }\n    return byteArray.shift();\n}\n/**\n * Delegates to `Array#splice`, but throws if the section being spliced out extends past the end of\n * the array.\n */ function guardedSplice(byteArray, ...args) {\n    const [start] = args;\n    if (args.length === 2 // Implies that `deleteCount` was supplied\n     ? start + (args[1] ?? 0) > byteArray.length : start >= byteArray.length) {\n        throw new Error(END_OF_BUFFER_ERROR_MESSAGE);\n    }\n    return byteArray.splice(...args);\n}\n/**\n * An instruction to execute by a program\n *\n * @property {number} programIdIndex\n * @property {number[]} accounts\n * @property {string} data\n */ /**\n * Message constructor arguments\n */ /**\n * List of instructions to be processed atomically\n */ class Message {\n    constructor(args){\n        this.header = void 0;\n        this.accountKeys = void 0;\n        this.recentBlockhash = void 0;\n        this.instructions = void 0;\n        this.indexToProgramIds = new Map();\n        this.header = args.header;\n        this.accountKeys = args.accountKeys.map((account)=>new PublicKey(account));\n        this.recentBlockhash = args.recentBlockhash;\n        this.instructions = args.instructions;\n        this.instructions.forEach((ix)=>this.indexToProgramIds.set(ix.programIdIndex, this.accountKeys[ix.programIdIndex]));\n    }\n    get version() {\n        return \"legacy\";\n    }\n    get staticAccountKeys() {\n        return this.accountKeys;\n    }\n    get compiledInstructions() {\n        return this.instructions.map((ix)=>({\n                programIdIndex: ix.programIdIndex,\n                accountKeyIndexes: ix.accounts,\n                data: bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(ix.data)\n            }));\n    }\n    get addressTableLookups() {\n        return [];\n    }\n    getAccountKeys() {\n        return new MessageAccountKeys(this.staticAccountKeys);\n    }\n    static compile(args) {\n        const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);\n        const [header, staticAccountKeys] = compiledKeys.getMessageComponents();\n        const accountKeys = new MessageAccountKeys(staticAccountKeys);\n        const instructions = accountKeys.compileInstructions(args.instructions).map((ix)=>({\n                programIdIndex: ix.programIdIndex,\n                accounts: ix.accountKeyIndexes,\n                data: bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(ix.data)\n            }));\n        return new Message({\n            header,\n            accountKeys: staticAccountKeys,\n            recentBlockhash: args.recentBlockhash,\n            instructions\n        });\n    }\n    isAccountSigner(index) {\n        return index < this.header.numRequiredSignatures;\n    }\n    isAccountWritable(index) {\n        const numSignedAccounts = this.header.numRequiredSignatures;\n        if (index >= this.header.numRequiredSignatures) {\n            const unsignedAccountIndex = index - numSignedAccounts;\n            const numUnsignedAccounts = this.accountKeys.length - numSignedAccounts;\n            const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;\n            return unsignedAccountIndex < numWritableUnsignedAccounts;\n        } else {\n            const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;\n            return index < numWritableSignedAccounts;\n        }\n    }\n    isProgramId(index) {\n        return this.indexToProgramIds.has(index);\n    }\n    programIds() {\n        return [\n            ...this.indexToProgramIds.values()\n        ];\n    }\n    nonProgramIds() {\n        return this.accountKeys.filter((_, index)=>!this.isProgramId(index));\n    }\n    serialize() {\n        const numKeys = this.accountKeys.length;\n        let keyCount = [];\n        encodeLength(keyCount, numKeys);\n        const instructions = this.instructions.map((instruction)=>{\n            const { accounts, programIdIndex } = instruction;\n            const data = Array.from(bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(instruction.data));\n            let keyIndicesCount = [];\n            encodeLength(keyIndicesCount, accounts.length);\n            let dataCount = [];\n            encodeLength(dataCount, data.length);\n            return {\n                programIdIndex,\n                keyIndicesCount: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(keyIndicesCount),\n                keyIndices: accounts,\n                dataLength: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(dataCount),\n                data\n            };\n        });\n        let instructionCount = [];\n        encodeLength(instructionCount, instructions.length);\n        let instructionBuffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(PACKET_DATA_SIZE);\n        buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(instructionCount).copy(instructionBuffer);\n        let instructionBufferLength = instructionCount.length;\n        instructions.forEach((instruction)=>{\n            const instructionLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"programIdIndex\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(instruction.keyIndicesCount.length, \"keyIndicesCount\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"keyIndex\"), instruction.keyIndices.length, \"keyIndices\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(instruction.dataLength.length, \"dataLength\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"userdatum\"), instruction.data.length, \"data\")\n            ]);\n            const length = instructionLayout.encode(instruction, instructionBuffer, instructionBufferLength);\n            instructionBufferLength += length;\n        });\n        instructionBuffer = instructionBuffer.slice(0, instructionBufferLength);\n        const signDataLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(1, \"numRequiredSignatures\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(1, \"numReadonlySignedAccounts\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(1, \"numReadonlyUnsignedAccounts\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(keyCount.length, \"keyCount\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(publicKey(\"key\"), numKeys, \"keys\"),\n            publicKey(\"recentBlockhash\")\n        ]);\n        const transaction = {\n            numRequiredSignatures: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([\n                this.header.numRequiredSignatures\n            ]),\n            numReadonlySignedAccounts: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([\n                this.header.numReadonlySignedAccounts\n            ]),\n            numReadonlyUnsignedAccounts: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([\n                this.header.numReadonlyUnsignedAccounts\n            ]),\n            keyCount: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(keyCount),\n            keys: this.accountKeys.map((key)=>toBuffer(key.toBytes())),\n            recentBlockhash: bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(this.recentBlockhash)\n        };\n        let signData = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(2048);\n        const length = signDataLayout.encode(transaction, signData);\n        instructionBuffer.copy(signData, length);\n        return signData.slice(0, length + instructionBuffer.length);\n    }\n    /**\n   * Decode a compiled message into a Message object.\n   */ static from(buffer) {\n        // Slice up wire data\n        let byteArray = [\n            ...buffer\n        ];\n        const numRequiredSignatures = guardedShift(byteArray);\n        if (numRequiredSignatures !== (numRequiredSignatures & VERSION_PREFIX_MASK)) {\n            throw new Error(\"Versioned messages must be deserialized with VersionedMessage.deserialize()\");\n        }\n        const numReadonlySignedAccounts = guardedShift(byteArray);\n        const numReadonlyUnsignedAccounts = guardedShift(byteArray);\n        const accountCount = decodeLength(byteArray);\n        let accountKeys = [];\n        for(let i = 0; i < accountCount; i++){\n            const account = guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH);\n            accountKeys.push(new PublicKey(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(account)));\n        }\n        const recentBlockhash = guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH);\n        const instructionCount = decodeLength(byteArray);\n        let instructions = [];\n        for(let i = 0; i < instructionCount; i++){\n            const programIdIndex = guardedShift(byteArray);\n            const accountCount = decodeLength(byteArray);\n            const accounts = guardedSplice(byteArray, 0, accountCount);\n            const dataLength = decodeLength(byteArray);\n            const dataSlice = guardedSplice(byteArray, 0, dataLength);\n            const data = bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(dataSlice));\n            instructions.push({\n                programIdIndex,\n                accounts,\n                data\n            });\n        }\n        const messageArgs = {\n            header: {\n                numRequiredSignatures,\n                numReadonlySignedAccounts,\n                numReadonlyUnsignedAccounts\n            },\n            recentBlockhash: bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(recentBlockhash)),\n            accountKeys,\n            instructions\n        };\n        return new Message(messageArgs);\n    }\n}\n/**\n * Message constructor arguments\n */ class MessageV0 {\n    constructor(args){\n        this.header = void 0;\n        this.staticAccountKeys = void 0;\n        this.recentBlockhash = void 0;\n        this.compiledInstructions = void 0;\n        this.addressTableLookups = void 0;\n        this.header = args.header;\n        this.staticAccountKeys = args.staticAccountKeys;\n        this.recentBlockhash = args.recentBlockhash;\n        this.compiledInstructions = args.compiledInstructions;\n        this.addressTableLookups = args.addressTableLookups;\n    }\n    get version() {\n        return 0;\n    }\n    get numAccountKeysFromLookups() {\n        let count = 0;\n        for (const lookup of this.addressTableLookups){\n            count += lookup.readonlyIndexes.length + lookup.writableIndexes.length;\n        }\n        return count;\n    }\n    getAccountKeys(args) {\n        let accountKeysFromLookups;\n        if (args && \"accountKeysFromLookups\" in args && args.accountKeysFromLookups) {\n            if (this.numAccountKeysFromLookups != args.accountKeysFromLookups.writable.length + args.accountKeysFromLookups.readonly.length) {\n                throw new Error(\"Failed to get account keys because of a mismatch in the number of account keys from lookups\");\n            }\n            accountKeysFromLookups = args.accountKeysFromLookups;\n        } else if (args && \"addressLookupTableAccounts\" in args && args.addressLookupTableAccounts) {\n            accountKeysFromLookups = this.resolveAddressTableLookups(args.addressLookupTableAccounts);\n        } else if (this.addressTableLookups.length > 0) {\n            throw new Error(\"Failed to get account keys because address table lookups were not resolved\");\n        }\n        return new MessageAccountKeys(this.staticAccountKeys, accountKeysFromLookups);\n    }\n    isAccountSigner(index) {\n        return index < this.header.numRequiredSignatures;\n    }\n    isAccountWritable(index) {\n        const numSignedAccounts = this.header.numRequiredSignatures;\n        const numStaticAccountKeys = this.staticAccountKeys.length;\n        if (index >= numStaticAccountKeys) {\n            const lookupAccountKeysIndex = index - numStaticAccountKeys;\n            const numWritableLookupAccountKeys = this.addressTableLookups.reduce((count, lookup)=>count + lookup.writableIndexes.length, 0);\n            return lookupAccountKeysIndex < numWritableLookupAccountKeys;\n        } else if (index >= this.header.numRequiredSignatures) {\n            const unsignedAccountIndex = index - numSignedAccounts;\n            const numUnsignedAccounts = numStaticAccountKeys - numSignedAccounts;\n            const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;\n            return unsignedAccountIndex < numWritableUnsignedAccounts;\n        } else {\n            const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;\n            return index < numWritableSignedAccounts;\n        }\n    }\n    resolveAddressTableLookups(addressLookupTableAccounts) {\n        const accountKeysFromLookups = {\n            writable: [],\n            readonly: []\n        };\n        for (const tableLookup of this.addressTableLookups){\n            const tableAccount = addressLookupTableAccounts.find((account)=>account.key.equals(tableLookup.accountKey));\n            if (!tableAccount) {\n                throw new Error(`Failed to find address lookup table account for table key ${tableLookup.accountKey.toBase58()}`);\n            }\n            for (const index of tableLookup.writableIndexes){\n                if (index < tableAccount.state.addresses.length) {\n                    accountKeysFromLookups.writable.push(tableAccount.state.addresses[index]);\n                } else {\n                    throw new Error(`Failed to find address for index ${index} in address lookup table ${tableLookup.accountKey.toBase58()}`);\n                }\n            }\n            for (const index of tableLookup.readonlyIndexes){\n                if (index < tableAccount.state.addresses.length) {\n                    accountKeysFromLookups.readonly.push(tableAccount.state.addresses[index]);\n                } else {\n                    throw new Error(`Failed to find address for index ${index} in address lookup table ${tableLookup.accountKey.toBase58()}`);\n                }\n            }\n        }\n        return accountKeysFromLookups;\n    }\n    static compile(args) {\n        const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);\n        const addressTableLookups = new Array();\n        const accountKeysFromLookups = {\n            writable: new Array(),\n            readonly: new Array()\n        };\n        const lookupTableAccounts = args.addressLookupTableAccounts || [];\n        for (const lookupTable of lookupTableAccounts){\n            const extractResult = compiledKeys.extractTableLookup(lookupTable);\n            if (extractResult !== undefined) {\n                const [addressTableLookup, { writable, readonly }] = extractResult;\n                addressTableLookups.push(addressTableLookup);\n                accountKeysFromLookups.writable.push(...writable);\n                accountKeysFromLookups.readonly.push(...readonly);\n            }\n        }\n        const [header, staticAccountKeys] = compiledKeys.getMessageComponents();\n        const accountKeys = new MessageAccountKeys(staticAccountKeys, accountKeysFromLookups);\n        const compiledInstructions = accountKeys.compileInstructions(args.instructions);\n        return new MessageV0({\n            header,\n            staticAccountKeys,\n            recentBlockhash: args.recentBlockhash,\n            compiledInstructions,\n            addressTableLookups\n        });\n    }\n    serialize() {\n        const encodedStaticAccountKeysLength = Array();\n        encodeLength(encodedStaticAccountKeysLength, this.staticAccountKeys.length);\n        const serializedInstructions = this.serializeInstructions();\n        const encodedInstructionsLength = Array();\n        encodeLength(encodedInstructionsLength, this.compiledInstructions.length);\n        const serializedAddressTableLookups = this.serializeAddressTableLookups();\n        const encodedAddressTableLookupsLength = Array();\n        encodeLength(encodedAddressTableLookupsLength, this.addressTableLookups.length);\n        const messageLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"prefix\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"numRequiredSignatures\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"numReadonlySignedAccounts\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"numReadonlyUnsignedAccounts\")\n            ], \"header\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedStaticAccountKeysLength.length, \"staticAccountKeysLength\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(publicKey(), this.staticAccountKeys.length, \"staticAccountKeys\"),\n            publicKey(\"recentBlockhash\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedInstructionsLength.length, \"instructionsLength\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(serializedInstructions.length, \"serializedInstructions\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedAddressTableLookupsLength.length, \"addressTableLookupsLength\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(serializedAddressTableLookups.length, \"serializedAddressTableLookups\")\n        ]);\n        const serializedMessage = new Uint8Array(PACKET_DATA_SIZE);\n        const MESSAGE_VERSION_0_PREFIX = 1 << 7;\n        const serializedMessageLength = messageLayout.encode({\n            prefix: MESSAGE_VERSION_0_PREFIX,\n            header: this.header,\n            staticAccountKeysLength: new Uint8Array(encodedStaticAccountKeysLength),\n            staticAccountKeys: this.staticAccountKeys.map((key)=>key.toBytes()),\n            recentBlockhash: bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(this.recentBlockhash),\n            instructionsLength: new Uint8Array(encodedInstructionsLength),\n            serializedInstructions,\n            addressTableLookupsLength: new Uint8Array(encodedAddressTableLookupsLength),\n            serializedAddressTableLookups\n        }, serializedMessage);\n        return serializedMessage.slice(0, serializedMessageLength);\n    }\n    serializeInstructions() {\n        let serializedLength = 0;\n        const serializedInstructions = new Uint8Array(PACKET_DATA_SIZE);\n        for (const instruction of this.compiledInstructions){\n            const encodedAccountKeyIndexesLength = Array();\n            encodeLength(encodedAccountKeyIndexesLength, instruction.accountKeyIndexes.length);\n            const encodedDataLength = Array();\n            encodeLength(encodedDataLength, instruction.data.length);\n            const instructionLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"programIdIndex\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedAccountKeyIndexesLength.length, \"encodedAccountKeyIndexesLength\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(), instruction.accountKeyIndexes.length, \"accountKeyIndexes\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedDataLength.length, \"encodedDataLength\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(instruction.data.length, \"data\")\n            ]);\n            serializedLength += instructionLayout.encode({\n                programIdIndex: instruction.programIdIndex,\n                encodedAccountKeyIndexesLength: new Uint8Array(encodedAccountKeyIndexesLength),\n                accountKeyIndexes: instruction.accountKeyIndexes,\n                encodedDataLength: new Uint8Array(encodedDataLength),\n                data: instruction.data\n            }, serializedInstructions, serializedLength);\n        }\n        return serializedInstructions.slice(0, serializedLength);\n    }\n    serializeAddressTableLookups() {\n        let serializedLength = 0;\n        const serializedAddressTableLookups = new Uint8Array(PACKET_DATA_SIZE);\n        for (const lookup of this.addressTableLookups){\n            const encodedWritableIndexesLength = Array();\n            encodeLength(encodedWritableIndexesLength, lookup.writableIndexes.length);\n            const encodedReadonlyIndexesLength = Array();\n            encodeLength(encodedReadonlyIndexesLength, lookup.readonlyIndexes.length);\n            const addressTableLookupLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n                publicKey(\"accountKey\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedWritableIndexesLength.length, \"encodedWritableIndexesLength\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(), lookup.writableIndexes.length, \"writableIndexes\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedReadonlyIndexesLength.length, \"encodedReadonlyIndexesLength\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(), lookup.readonlyIndexes.length, \"readonlyIndexes\")\n            ]);\n            serializedLength += addressTableLookupLayout.encode({\n                accountKey: lookup.accountKey.toBytes(),\n                encodedWritableIndexesLength: new Uint8Array(encodedWritableIndexesLength),\n                writableIndexes: lookup.writableIndexes,\n                encodedReadonlyIndexesLength: new Uint8Array(encodedReadonlyIndexesLength),\n                readonlyIndexes: lookup.readonlyIndexes\n            }, serializedAddressTableLookups, serializedLength);\n        }\n        return serializedAddressTableLookups.slice(0, serializedLength);\n    }\n    static deserialize(serializedMessage) {\n        let byteArray = [\n            ...serializedMessage\n        ];\n        const prefix = guardedShift(byteArray);\n        const maskedPrefix = prefix & VERSION_PREFIX_MASK;\n        assert(prefix !== maskedPrefix, `Expected versioned message but received legacy message`);\n        const version = maskedPrefix;\n        assert(version === 0, `Expected versioned message with version 0 but found version ${version}`);\n        const header = {\n            numRequiredSignatures: guardedShift(byteArray),\n            numReadonlySignedAccounts: guardedShift(byteArray),\n            numReadonlyUnsignedAccounts: guardedShift(byteArray)\n        };\n        const staticAccountKeys = [];\n        const staticAccountKeysLength = decodeLength(byteArray);\n        for(let i = 0; i < staticAccountKeysLength; i++){\n            staticAccountKeys.push(new PublicKey(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH)));\n        }\n        const recentBlockhash = bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));\n        const instructionCount = decodeLength(byteArray);\n        const compiledInstructions = [];\n        for(let i = 0; i < instructionCount; i++){\n            const programIdIndex = guardedShift(byteArray);\n            const accountKeyIndexesLength = decodeLength(byteArray);\n            const accountKeyIndexes = guardedSplice(byteArray, 0, accountKeyIndexesLength);\n            const dataLength = decodeLength(byteArray);\n            const data = new Uint8Array(guardedSplice(byteArray, 0, dataLength));\n            compiledInstructions.push({\n                programIdIndex,\n                accountKeyIndexes,\n                data\n            });\n        }\n        const addressTableLookupsCount = decodeLength(byteArray);\n        const addressTableLookups = [];\n        for(let i = 0; i < addressTableLookupsCount; i++){\n            const accountKey = new PublicKey(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));\n            const writableIndexesLength = decodeLength(byteArray);\n            const writableIndexes = guardedSplice(byteArray, 0, writableIndexesLength);\n            const readonlyIndexesLength = decodeLength(byteArray);\n            const readonlyIndexes = guardedSplice(byteArray, 0, readonlyIndexesLength);\n            addressTableLookups.push({\n                accountKey,\n                writableIndexes,\n                readonlyIndexes\n            });\n        }\n        return new MessageV0({\n            header,\n            staticAccountKeys,\n            recentBlockhash,\n            compiledInstructions,\n            addressTableLookups\n        });\n    }\n}\n// eslint-disable-next-line no-redeclare\nconst VersionedMessage = {\n    deserializeMessageVersion (serializedMessage) {\n        const prefix = serializedMessage[0];\n        const maskedPrefix = prefix & VERSION_PREFIX_MASK;\n        // if the highest bit of the prefix is not set, the message is not versioned\n        if (maskedPrefix === prefix) {\n            return \"legacy\";\n        }\n        // the lower 7 bits of the prefix indicate the message version\n        return maskedPrefix;\n    },\n    deserialize: (serializedMessage)=>{\n        const version = VersionedMessage.deserializeMessageVersion(serializedMessage);\n        if (version === \"legacy\") {\n            return Message.from(serializedMessage);\n        }\n        if (version === 0) {\n            return MessageV0.deserialize(serializedMessage);\n        } else {\n            throw new Error(`Transaction message version ${version} deserialization is not supported`);\n        }\n    }\n};\n/** @internal */ /**\n * Transaction signature as base-58 encoded string\n */ let TransactionStatus = /*#__PURE__*/ function(TransactionStatus) {\n    TransactionStatus[TransactionStatus[\"BLOCKHEIGHT_EXCEEDED\"] = 0] = \"BLOCKHEIGHT_EXCEEDED\";\n    TransactionStatus[TransactionStatus[\"PROCESSED\"] = 1] = \"PROCESSED\";\n    TransactionStatus[TransactionStatus[\"TIMED_OUT\"] = 2] = \"TIMED_OUT\";\n    TransactionStatus[TransactionStatus[\"NONCE_INVALID\"] = 3] = \"NONCE_INVALID\";\n    return TransactionStatus;\n}({});\n/**\n * Default (empty) signature\n */ const DEFAULT_SIGNATURE = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0);\n/**\n * Account metadata used to define instructions\n */ /**\n * List of TransactionInstruction object fields that may be initialized at construction\n */ /**\n * Configuration object for Transaction.serialize()\n */ /**\n * @internal\n */ /**\n * Transaction Instruction class\n */ class TransactionInstruction {\n    constructor(opts){\n        /**\n     * Public keys to include in this transaction\n     * Boolean represents whether this pubkey needs to sign the transaction\n     */ this.keys = void 0;\n        /**\n     * Program Id to execute\n     */ this.programId = void 0;\n        /**\n     * Program input\n     */ this.data = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(0);\n        this.programId = opts.programId;\n        this.keys = opts.keys;\n        if (opts.data) {\n            this.data = opts.data;\n        }\n    }\n    /**\n   * @internal\n   */ toJSON() {\n        return {\n            keys: this.keys.map(({ pubkey, isSigner, isWritable })=>({\n                    pubkey: pubkey.toJSON(),\n                    isSigner,\n                    isWritable\n                })),\n            programId: this.programId.toJSON(),\n            data: [\n                ...this.data\n            ]\n        };\n    }\n}\n/**\n * Pair of signature and corresponding public key\n */ /**\n * List of Transaction object fields that may be initialized at construction\n */ // For backward compatibility; an unfortunate consequence of being\n// forced to over-export types by the documentation generator.\n// See https://github.com/solana-labs/solana/pull/25820\n/**\n * Blockhash-based transactions have a lifetime that are defined by\n * the blockhash they include. Any transaction whose blockhash is\n * too old will be rejected.\n */ /**\n * Use these options to construct a durable nonce transaction.\n */ /**\n * Nonce information to be used to build an offline Transaction.\n */ /**\n * @internal\n */ /**\n * Transaction class\n */ class Transaction {\n    /**\n   * The first (payer) Transaction signature\n   *\n   * @returns {Buffer | null} Buffer of payer's signature\n   */ get signature() {\n        if (this.signatures.length > 0) {\n            return this.signatures[0].signature;\n        }\n        return null;\n    }\n    /**\n   * The transaction fee payer\n   */ // Construct a transaction with a blockhash and lastValidBlockHeight\n    // Construct a transaction using a durable nonce\n    /**\n   * @deprecated `TransactionCtorFields` has been deprecated and will be removed in a future version.\n   * Please supply a `TransactionBlockhashCtor` instead.\n   */ /**\n   * Construct an empty Transaction\n   */ constructor(opts){\n        /**\n     * Signatures for the transaction.  Typically created by invoking the\n     * `sign()` method\n     */ this.signatures = [];\n        this.feePayer = void 0;\n        /**\n     * The instructions to atomically execute\n     */ this.instructions = [];\n        /**\n     * A recent transaction id. Must be populated by the caller\n     */ this.recentBlockhash = void 0;\n        /**\n     * the last block chain can advance to before tx is declared expired\n     * */ this.lastValidBlockHeight = void 0;\n        /**\n     * Optional Nonce information. If populated, transaction will use a durable\n     * Nonce hash instead of a recentBlockhash. Must be populated by the caller\n     */ this.nonceInfo = void 0;\n        /**\n     * If this is a nonce transaction this represents the minimum slot from which\n     * to evaluate if the nonce has advanced when attempting to confirm the\n     * transaction. This protects against a case where the transaction confirmation\n     * logic loads the nonce account from an old slot and assumes the mismatch in\n     * nonce value implies that the nonce has been advanced.\n     */ this.minNonceContextSlot = void 0;\n        /**\n     * @internal\n     */ this._message = void 0;\n        /**\n     * @internal\n     */ this._json = void 0;\n        if (!opts) {\n            return;\n        }\n        if (opts.feePayer) {\n            this.feePayer = opts.feePayer;\n        }\n        if (opts.signatures) {\n            this.signatures = opts.signatures;\n        }\n        if (Object.prototype.hasOwnProperty.call(opts, \"nonceInfo\")) {\n            const { minContextSlot, nonceInfo } = opts;\n            this.minNonceContextSlot = minContextSlot;\n            this.nonceInfo = nonceInfo;\n        } else if (Object.prototype.hasOwnProperty.call(opts, \"lastValidBlockHeight\")) {\n            const { blockhash, lastValidBlockHeight } = opts;\n            this.recentBlockhash = blockhash;\n            this.lastValidBlockHeight = lastValidBlockHeight;\n        } else {\n            const { recentBlockhash, nonceInfo } = opts;\n            if (nonceInfo) {\n                this.nonceInfo = nonceInfo;\n            }\n            this.recentBlockhash = recentBlockhash;\n        }\n    }\n    /**\n   * @internal\n   */ toJSON() {\n        return {\n            recentBlockhash: this.recentBlockhash || null,\n            feePayer: this.feePayer ? this.feePayer.toJSON() : null,\n            nonceInfo: this.nonceInfo ? {\n                nonce: this.nonceInfo.nonce,\n                nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()\n            } : null,\n            instructions: this.instructions.map((instruction)=>instruction.toJSON()),\n            signers: this.signatures.map(({ publicKey })=>{\n                return publicKey.toJSON();\n            })\n        };\n    }\n    /**\n   * Add one or more instructions to this Transaction\n   *\n   * @param {Array< Transaction | TransactionInstruction | TransactionInstructionCtorFields >} items - Instructions to add to the Transaction\n   */ add(...items) {\n        if (items.length === 0) {\n            throw new Error(\"No instructions\");\n        }\n        items.forEach((item)=>{\n            if (\"instructions\" in item) {\n                this.instructions = this.instructions.concat(item.instructions);\n            } else if (\"data\" in item && \"programId\" in item && \"keys\" in item) {\n                this.instructions.push(item);\n            } else {\n                this.instructions.push(new TransactionInstruction(item));\n            }\n        });\n        return this;\n    }\n    /**\n   * Compile transaction data\n   */ compileMessage() {\n        if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json)) {\n            return this._message;\n        }\n        let recentBlockhash;\n        let instructions;\n        if (this.nonceInfo) {\n            recentBlockhash = this.nonceInfo.nonce;\n            if (this.instructions[0] != this.nonceInfo.nonceInstruction) {\n                instructions = [\n                    this.nonceInfo.nonceInstruction,\n                    ...this.instructions\n                ];\n            } else {\n                instructions = this.instructions;\n            }\n        } else {\n            recentBlockhash = this.recentBlockhash;\n            instructions = this.instructions;\n        }\n        if (!recentBlockhash) {\n            throw new Error(\"Transaction recentBlockhash required\");\n        }\n        if (instructions.length < 1) {\n            console.warn(\"No instructions provided\");\n        }\n        let feePayer;\n        if (this.feePayer) {\n            feePayer = this.feePayer;\n        } else if (this.signatures.length > 0 && this.signatures[0].publicKey) {\n            // Use implicit fee payer\n            feePayer = this.signatures[0].publicKey;\n        } else {\n            throw new Error(\"Transaction fee payer required\");\n        }\n        for(let i = 0; i < instructions.length; i++){\n            if (instructions[i].programId === undefined) {\n                throw new Error(`Transaction instruction index ${i} has undefined program id`);\n            }\n        }\n        const programIds = [];\n        const accountMetas = [];\n        instructions.forEach((instruction)=>{\n            instruction.keys.forEach((accountMeta)=>{\n                accountMetas.push({\n                    ...accountMeta\n                });\n            });\n            const programId = instruction.programId.toString();\n            if (!programIds.includes(programId)) {\n                programIds.push(programId);\n            }\n        });\n        // Append programID account metas\n        programIds.forEach((programId)=>{\n            accountMetas.push({\n                pubkey: new PublicKey(programId),\n                isSigner: false,\n                isWritable: false\n            });\n        });\n        // Cull duplicate account metas\n        const uniqueMetas = [];\n        accountMetas.forEach((accountMeta)=>{\n            const pubkeyString = accountMeta.pubkey.toString();\n            const uniqueIndex = uniqueMetas.findIndex((x)=>{\n                return x.pubkey.toString() === pubkeyString;\n            });\n            if (uniqueIndex > -1) {\n                uniqueMetas[uniqueIndex].isWritable = uniqueMetas[uniqueIndex].isWritable || accountMeta.isWritable;\n                uniqueMetas[uniqueIndex].isSigner = uniqueMetas[uniqueIndex].isSigner || accountMeta.isSigner;\n            } else {\n                uniqueMetas.push(accountMeta);\n            }\n        });\n        // Sort. Prioritizing first by signer, then by writable\n        uniqueMetas.sort(function(x, y) {\n            if (x.isSigner !== y.isSigner) {\n                // Signers always come before non-signers\n                return x.isSigner ? -1 : 1;\n            }\n            if (x.isWritable !== y.isWritable) {\n                // Writable accounts always come before read-only accounts\n                return x.isWritable ? -1 : 1;\n            }\n            // Otherwise, sort by pubkey, stringwise.\n            const options = {\n                localeMatcher: \"best fit\",\n                usage: \"sort\",\n                sensitivity: \"variant\",\n                ignorePunctuation: false,\n                numeric: false,\n                caseFirst: \"lower\"\n            };\n            return x.pubkey.toBase58().localeCompare(y.pubkey.toBase58(), \"en\", options);\n        });\n        // Move fee payer to the front\n        const feePayerIndex = uniqueMetas.findIndex((x)=>{\n            return x.pubkey.equals(feePayer);\n        });\n        if (feePayerIndex > -1) {\n            const [payerMeta] = uniqueMetas.splice(feePayerIndex, 1);\n            payerMeta.isSigner = true;\n            payerMeta.isWritable = true;\n            uniqueMetas.unshift(payerMeta);\n        } else {\n            uniqueMetas.unshift({\n                pubkey: feePayer,\n                isSigner: true,\n                isWritable: true\n            });\n        }\n        // Disallow unknown signers\n        for (const signature of this.signatures){\n            const uniqueIndex = uniqueMetas.findIndex((x)=>{\n                return x.pubkey.equals(signature.publicKey);\n            });\n            if (uniqueIndex > -1) {\n                if (!uniqueMetas[uniqueIndex].isSigner) {\n                    uniqueMetas[uniqueIndex].isSigner = true;\n                    console.warn(\"Transaction references a signature that is unnecessary, \" + \"only the fee payer and instruction signer accounts should sign a transaction. \" + \"This behavior is deprecated and will throw an error in the next major version release.\");\n                }\n            } else {\n                throw new Error(`unknown signer: ${signature.publicKey.toString()}`);\n            }\n        }\n        let numRequiredSignatures = 0;\n        let numReadonlySignedAccounts = 0;\n        let numReadonlyUnsignedAccounts = 0;\n        // Split out signing from non-signing keys and count header values\n        const signedKeys = [];\n        const unsignedKeys = [];\n        uniqueMetas.forEach(({ pubkey, isSigner, isWritable })=>{\n            if (isSigner) {\n                signedKeys.push(pubkey.toString());\n                numRequiredSignatures += 1;\n                if (!isWritable) {\n                    numReadonlySignedAccounts += 1;\n                }\n            } else {\n                unsignedKeys.push(pubkey.toString());\n                if (!isWritable) {\n                    numReadonlyUnsignedAccounts += 1;\n                }\n            }\n        });\n        const accountKeys = signedKeys.concat(unsignedKeys);\n        const compiledInstructions = instructions.map((instruction)=>{\n            const { data, programId } = instruction;\n            return {\n                programIdIndex: accountKeys.indexOf(programId.toString()),\n                accounts: instruction.keys.map((meta)=>accountKeys.indexOf(meta.pubkey.toString())),\n                data: bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(data)\n            };\n        });\n        compiledInstructions.forEach((instruction)=>{\n            assert(instruction.programIdIndex >= 0);\n            instruction.accounts.forEach((keyIndex)=>assert(keyIndex >= 0));\n        });\n        return new Message({\n            header: {\n                numRequiredSignatures,\n                numReadonlySignedAccounts,\n                numReadonlyUnsignedAccounts\n            },\n            accountKeys,\n            recentBlockhash,\n            instructions: compiledInstructions\n        });\n    }\n    /**\n   * @internal\n   */ _compile() {\n        const message = this.compileMessage();\n        const signedKeys = message.accountKeys.slice(0, message.header.numRequiredSignatures);\n        if (this.signatures.length === signedKeys.length) {\n            const valid = this.signatures.every((pair, index)=>{\n                return signedKeys[index].equals(pair.publicKey);\n            });\n            if (valid) return message;\n        }\n        this.signatures = signedKeys.map((publicKey)=>({\n                signature: null,\n                publicKey\n            }));\n        return message;\n    }\n    /**\n   * Get a buffer of the Transaction data that need to be covered by signatures\n   */ serializeMessage() {\n        return this._compile().serialize();\n    }\n    /**\n   * Get the estimated fee associated with a transaction\n   *\n   * @param {Connection} connection Connection to RPC Endpoint.\n   *\n   * @returns {Promise<number | null>} The estimated fee for the transaction\n   */ async getEstimatedFee(connection) {\n        return (await connection.getFeeForMessage(this.compileMessage())).value;\n    }\n    /**\n   * Specify the public keys which will be used to sign the Transaction.\n   * The first signer will be used as the transaction fee payer account.\n   *\n   * Signatures can be added with either `partialSign` or `addSignature`\n   *\n   * @deprecated Deprecated since v0.84.0. Only the fee payer needs to be\n   * specified and it can be set in the Transaction constructor or with the\n   * `feePayer` property.\n   */ setSigners(...signers) {\n        if (signers.length === 0) {\n            throw new Error(\"No signers\");\n        }\n        const seen = new Set();\n        this.signatures = signers.filter((publicKey)=>{\n            const key = publicKey.toString();\n            if (seen.has(key)) {\n                return false;\n            } else {\n                seen.add(key);\n                return true;\n            }\n        }).map((publicKey)=>({\n                signature: null,\n                publicKey\n            }));\n    }\n    /**\n   * Sign the Transaction with the specified signers. Multiple signatures may\n   * be applied to a Transaction. The first signature is considered \"primary\"\n   * and is used identify and confirm transactions.\n   *\n   * If the Transaction `feePayer` is not set, the first signer will be used\n   * as the transaction fee payer account.\n   *\n   * Transaction fields should not be modified after the first call to `sign`,\n   * as doing so may invalidate the signature and cause the Transaction to be\n   * rejected.\n   *\n   * The Transaction must be assigned a valid `recentBlockhash` before invoking this method\n   *\n   * @param {Array<Signer>} signers Array of signers that will sign the transaction\n   */ sign(...signers) {\n        if (signers.length === 0) {\n            throw new Error(\"No signers\");\n        }\n        // Dedupe signers\n        const seen = new Set();\n        const uniqueSigners = [];\n        for (const signer of signers){\n            const key = signer.publicKey.toString();\n            if (seen.has(key)) {\n                continue;\n            } else {\n                seen.add(key);\n                uniqueSigners.push(signer);\n            }\n        }\n        this.signatures = uniqueSigners.map((signer)=>({\n                signature: null,\n                publicKey: signer.publicKey\n            }));\n        const message = this._compile();\n        this._partialSign(message, ...uniqueSigners);\n    }\n    /**\n   * Partially sign a transaction with the specified accounts. All accounts must\n   * correspond to either the fee payer or a signer account in the transaction\n   * instructions.\n   *\n   * All the caveats from the `sign` method apply to `partialSign`\n   *\n   * @param {Array<Signer>} signers Array of signers that will sign the transaction\n   */ partialSign(...signers) {\n        if (signers.length === 0) {\n            throw new Error(\"No signers\");\n        }\n        // Dedupe signers\n        const seen = new Set();\n        const uniqueSigners = [];\n        for (const signer of signers){\n            const key = signer.publicKey.toString();\n            if (seen.has(key)) {\n                continue;\n            } else {\n                seen.add(key);\n                uniqueSigners.push(signer);\n            }\n        }\n        const message = this._compile();\n        this._partialSign(message, ...uniqueSigners);\n    }\n    /**\n   * @internal\n   */ _partialSign(message, ...signers) {\n        const signData = message.serialize();\n        signers.forEach((signer)=>{\n            const signature = sign(signData, signer.secretKey);\n            this._addSignature(signer.publicKey, toBuffer(signature));\n        });\n    }\n    /**\n   * Add an externally created signature to a transaction. The public key\n   * must correspond to either the fee payer or a signer account in the transaction\n   * instructions.\n   *\n   * @param {PublicKey} pubkey Public key that will be added to the transaction.\n   * @param {Buffer} signature An externally created signature to add to the transaction.\n   */ addSignature(pubkey, signature) {\n        this._compile(); // Ensure signatures array is populated\n        this._addSignature(pubkey, signature);\n    }\n    /**\n   * @internal\n   */ _addSignature(pubkey, signature) {\n        assert(signature.length === 64);\n        const index = this.signatures.findIndex((sigpair)=>pubkey.equals(sigpair.publicKey));\n        if (index < 0) {\n            throw new Error(`unknown signer: ${pubkey.toString()}`);\n        }\n        this.signatures[index].signature = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(signature);\n    }\n    /**\n   * Verify signatures of a Transaction\n   * Optional parameter specifies if we're expecting a fully signed Transaction or a partially signed one.\n   * If no boolean is provided, we expect a fully signed Transaction by default.\n   *\n   * @param {boolean} [requireAllSignatures=true] Require a fully signed Transaction\n   */ verifySignatures(requireAllSignatures = true) {\n        const signatureErrors = this._getMessageSignednessErrors(this.serializeMessage(), requireAllSignatures);\n        return !signatureErrors;\n    }\n    /**\n   * @internal\n   */ _getMessageSignednessErrors(message, requireAllSignatures) {\n        const errors = {};\n        for (const { signature, publicKey } of this.signatures){\n            if (signature === null) {\n                if (requireAllSignatures) {\n                    (errors.missing ||= []).push(publicKey);\n                }\n            } else {\n                if (!verify(signature, message, publicKey.toBytes())) {\n                    (errors.invalid ||= []).push(publicKey);\n                }\n            }\n        }\n        return errors.invalid || errors.missing ? errors : undefined;\n    }\n    /**\n   * Serialize the Transaction in the wire format.\n   *\n   * @param {Buffer} [config] Config of transaction.\n   *\n   * @returns {Buffer} Signature of transaction in wire format.\n   */ serialize(config) {\n        const { requireAllSignatures, verifySignatures } = Object.assign({\n            requireAllSignatures: true,\n            verifySignatures: true\n        }, config);\n        const signData = this.serializeMessage();\n        if (verifySignatures) {\n            const sigErrors = this._getMessageSignednessErrors(signData, requireAllSignatures);\n            if (sigErrors) {\n                let errorMessage = \"Signature verification failed.\";\n                if (sigErrors.invalid) {\n                    errorMessage += `\\nInvalid signature for public key${sigErrors.invalid.length === 1 ? \"\" : \"(s)\"} [\\`${sigErrors.invalid.map((p)=>p.toBase58()).join(\"`, `\")}\\`].`;\n                }\n                if (sigErrors.missing) {\n                    errorMessage += `\\nMissing signature for public key${sigErrors.missing.length === 1 ? \"\" : \"(s)\"} [\\`${sigErrors.missing.map((p)=>p.toBase58()).join(\"`, `\")}\\`].`;\n                }\n                throw new Error(errorMessage);\n            }\n        }\n        return this._serialize(signData);\n    }\n    /**\n   * @internal\n   */ _serialize(signData) {\n        const { signatures } = this;\n        const signatureCount = [];\n        encodeLength(signatureCount, signatures.length);\n        const transactionLength = signatureCount.length + signatures.length * 64 + signData.length;\n        const wireTransaction = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(transactionLength);\n        assert(signatures.length < 256);\n        buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(signatureCount).copy(wireTransaction, 0);\n        signatures.forEach(({ signature }, index)=>{\n            if (signature !== null) {\n                assert(signature.length === 64, `signature has invalid length`);\n                buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(signature).copy(wireTransaction, signatureCount.length + index * 64);\n            }\n        });\n        signData.copy(wireTransaction, signatureCount.length + signatures.length * 64);\n        assert(wireTransaction.length <= PACKET_DATA_SIZE, `Transaction too large: ${wireTransaction.length} > ${PACKET_DATA_SIZE}`);\n        return wireTransaction;\n    }\n    /**\n   * Deprecated method\n   * @internal\n   */ get keys() {\n        assert(this.instructions.length === 1);\n        return this.instructions[0].keys.map((keyObj)=>keyObj.pubkey);\n    }\n    /**\n   * Deprecated method\n   * @internal\n   */ get programId() {\n        assert(this.instructions.length === 1);\n        return this.instructions[0].programId;\n    }\n    /**\n   * Deprecated method\n   * @internal\n   */ get data() {\n        assert(this.instructions.length === 1);\n        return this.instructions[0].data;\n    }\n    /**\n   * Parse a wire transaction into a Transaction object.\n   *\n   * @param {Buffer | Uint8Array | Array<number>} buffer Signature of wire Transaction\n   *\n   * @returns {Transaction} Transaction associated with the signature\n   */ static from(buffer) {\n        // Slice up wire data\n        let byteArray = [\n            ...buffer\n        ];\n        const signatureCount = decodeLength(byteArray);\n        let signatures = [];\n        for(let i = 0; i < signatureCount; i++){\n            const signature = guardedSplice(byteArray, 0, SIGNATURE_LENGTH_IN_BYTES);\n            signatures.push(bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(signature)));\n        }\n        return Transaction.populate(Message.from(byteArray), signatures);\n    }\n    /**\n   * Populate Transaction object from message and signatures\n   *\n   * @param {Message} message Message of transaction\n   * @param {Array<string>} signatures List of signatures to assign to the transaction\n   *\n   * @returns {Transaction} The populated Transaction\n   */ static populate(message, signatures = []) {\n        const transaction = new Transaction();\n        transaction.recentBlockhash = message.recentBlockhash;\n        if (message.header.numRequiredSignatures > 0) {\n            transaction.feePayer = message.accountKeys[0];\n        }\n        signatures.forEach((signature, index)=>{\n            const sigPubkeyPair = {\n                signature: signature == bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(DEFAULT_SIGNATURE) ? null : bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(signature),\n                publicKey: message.accountKeys[index]\n            };\n            transaction.signatures.push(sigPubkeyPair);\n        });\n        message.instructions.forEach((instruction)=>{\n            const keys = instruction.accounts.map((account)=>{\n                const pubkey = message.accountKeys[account];\n                return {\n                    pubkey,\n                    isSigner: transaction.signatures.some((keyObj)=>keyObj.publicKey.toString() === pubkey.toString()) || message.isAccountSigner(account),\n                    isWritable: message.isAccountWritable(account)\n                };\n            });\n            transaction.instructions.push(new TransactionInstruction({\n                keys,\n                programId: message.accountKeys[instruction.programIdIndex],\n                data: bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(instruction.data)\n            }));\n        });\n        transaction._message = message;\n        transaction._json = transaction.toJSON();\n        return transaction;\n    }\n}\nclass TransactionMessage {\n    constructor(args){\n        this.payerKey = void 0;\n        this.instructions = void 0;\n        this.recentBlockhash = void 0;\n        this.payerKey = args.payerKey;\n        this.instructions = args.instructions;\n        this.recentBlockhash = args.recentBlockhash;\n    }\n    static decompile(message, args) {\n        const { header, compiledInstructions, recentBlockhash } = message;\n        const { numRequiredSignatures, numReadonlySignedAccounts, numReadonlyUnsignedAccounts } = header;\n        const numWritableSignedAccounts = numRequiredSignatures - numReadonlySignedAccounts;\n        assert(numWritableSignedAccounts > 0, \"Message header is invalid\");\n        const numWritableUnsignedAccounts = message.staticAccountKeys.length - numRequiredSignatures - numReadonlyUnsignedAccounts;\n        assert(numWritableUnsignedAccounts >= 0, \"Message header is invalid\");\n        const accountKeys = message.getAccountKeys(args);\n        const payerKey = accountKeys.get(0);\n        if (payerKey === undefined) {\n            throw new Error(\"Failed to decompile message because no account keys were found\");\n        }\n        const instructions = [];\n        for (const compiledIx of compiledInstructions){\n            const keys = [];\n            for (const keyIndex of compiledIx.accountKeyIndexes){\n                const pubkey = accountKeys.get(keyIndex);\n                if (pubkey === undefined) {\n                    throw new Error(`Failed to find key for account key index ${keyIndex}`);\n                }\n                const isSigner = keyIndex < numRequiredSignatures;\n                let isWritable;\n                if (isSigner) {\n                    isWritable = keyIndex < numWritableSignedAccounts;\n                } else if (keyIndex < accountKeys.staticAccountKeys.length) {\n                    isWritable = keyIndex - numRequiredSignatures < numWritableUnsignedAccounts;\n                } else {\n                    isWritable = keyIndex - accountKeys.staticAccountKeys.length < // accountKeysFromLookups cannot be undefined because we already found a pubkey for this index above\n                    accountKeys.accountKeysFromLookups.writable.length;\n                }\n                keys.push({\n                    pubkey,\n                    isSigner: keyIndex < header.numRequiredSignatures,\n                    isWritable\n                });\n            }\n            const programId = accountKeys.get(compiledIx.programIdIndex);\n            if (programId === undefined) {\n                throw new Error(`Failed to find program id for program id index ${compiledIx.programIdIndex}`);\n            }\n            instructions.push(new TransactionInstruction({\n                programId,\n                data: toBuffer(compiledIx.data),\n                keys\n            }));\n        }\n        return new TransactionMessage({\n            payerKey,\n            instructions,\n            recentBlockhash\n        });\n    }\n    compileToLegacyMessage() {\n        return Message.compile({\n            payerKey: this.payerKey,\n            recentBlockhash: this.recentBlockhash,\n            instructions: this.instructions\n        });\n    }\n    compileToV0Message(addressLookupTableAccounts) {\n        return MessageV0.compile({\n            payerKey: this.payerKey,\n            recentBlockhash: this.recentBlockhash,\n            instructions: this.instructions,\n            addressLookupTableAccounts\n        });\n    }\n}\n/**\n * Versioned transaction class\n */ class VersionedTransaction {\n    get version() {\n        return this.message.version;\n    }\n    constructor(message, signatures){\n        this.signatures = void 0;\n        this.message = void 0;\n        if (signatures !== undefined) {\n            assert(signatures.length === message.header.numRequiredSignatures, \"Expected signatures length to be equal to the number of required signatures\");\n            this.signatures = signatures;\n        } else {\n            const defaultSignatures = [];\n            for(let i = 0; i < message.header.numRequiredSignatures; i++){\n                defaultSignatures.push(new Uint8Array(SIGNATURE_LENGTH_IN_BYTES));\n            }\n            this.signatures = defaultSignatures;\n        }\n        this.message = message;\n    }\n    serialize() {\n        const serializedMessage = this.message.serialize();\n        const encodedSignaturesLength = Array();\n        encodeLength(encodedSignaturesLength, this.signatures.length);\n        const transactionLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedSignaturesLength.length, \"encodedSignaturesLength\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(signature(), this.signatures.length, \"signatures\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(serializedMessage.length, \"serializedMessage\")\n        ]);\n        const serializedTransaction = new Uint8Array(2048);\n        const serializedTransactionLength = transactionLayout.encode({\n            encodedSignaturesLength: new Uint8Array(encodedSignaturesLength),\n            signatures: this.signatures,\n            serializedMessage\n        }, serializedTransaction);\n        return serializedTransaction.slice(0, serializedTransactionLength);\n    }\n    static deserialize(serializedTransaction) {\n        let byteArray = [\n            ...serializedTransaction\n        ];\n        const signatures = [];\n        const signaturesLength = decodeLength(byteArray);\n        for(let i = 0; i < signaturesLength; i++){\n            signatures.push(new Uint8Array(guardedSplice(byteArray, 0, SIGNATURE_LENGTH_IN_BYTES)));\n        }\n        const message = VersionedMessage.deserialize(new Uint8Array(byteArray));\n        return new VersionedTransaction(message, signatures);\n    }\n    sign(signers) {\n        const messageData = this.message.serialize();\n        const signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);\n        for (const signer of signers){\n            const signerIndex = signerPubkeys.findIndex((pubkey)=>pubkey.equals(signer.publicKey));\n            assert(signerIndex >= 0, `Cannot sign with non signer key ${signer.publicKey.toBase58()}`);\n            this.signatures[signerIndex] = sign(messageData, signer.secretKey);\n        }\n    }\n    addSignature(publicKey, signature) {\n        assert(signature.byteLength === 64, \"Signature must be 64 bytes long\");\n        const signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);\n        const signerIndex = signerPubkeys.findIndex((pubkey)=>pubkey.equals(publicKey));\n        assert(signerIndex >= 0, `Can not add signature; \\`${publicKey.toBase58()}\\` is not required to sign this transaction`);\n        this.signatures[signerIndex] = signature;\n    }\n}\n// TODO: These constants should be removed in favor of reading them out of a\n// Syscall account\n/**\n * @internal\n */ const NUM_TICKS_PER_SECOND = 160;\n/**\n * @internal\n */ const DEFAULT_TICKS_PER_SLOT = 64;\n/**\n * @internal\n */ const NUM_SLOTS_PER_SECOND = NUM_TICKS_PER_SECOND / DEFAULT_TICKS_PER_SLOT;\n/**\n * @internal\n */ const MS_PER_SLOT = 1000 / NUM_SLOTS_PER_SECOND;\nconst SYSVAR_CLOCK_PUBKEY = new PublicKey(\"SysvarC1ock11111111111111111111111111111111\");\nconst SYSVAR_EPOCH_SCHEDULE_PUBKEY = new PublicKey(\"SysvarEpochSchedu1e111111111111111111111111\");\nconst SYSVAR_INSTRUCTIONS_PUBKEY = new PublicKey(\"Sysvar1nstructions1111111111111111111111111\");\nconst SYSVAR_RECENT_BLOCKHASHES_PUBKEY = new PublicKey(\"SysvarRecentB1ockHashes11111111111111111111\");\nconst SYSVAR_RENT_PUBKEY = new PublicKey(\"SysvarRent111111111111111111111111111111111\");\nconst SYSVAR_REWARDS_PUBKEY = new PublicKey(\"SysvarRewards111111111111111111111111111111\");\nconst SYSVAR_SLOT_HASHES_PUBKEY = new PublicKey(\"SysvarS1otHashes111111111111111111111111111\");\nconst SYSVAR_SLOT_HISTORY_PUBKEY = new PublicKey(\"SysvarS1otHistory11111111111111111111111111\");\nconst SYSVAR_STAKE_HISTORY_PUBKEY = new PublicKey(\"SysvarStakeHistory1111111111111111111111111\");\nclass SendTransactionError extends Error {\n    constructor({ action, signature, transactionMessage, logs }){\n        const maybeLogsOutput = logs ? `Logs: \\n${JSON.stringify(logs.slice(-10), null, 2)}. ` : \"\";\n        const guideText = \"\\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.\";\n        let message;\n        switch(action){\n            case \"send\":\n                message = `Transaction ${signature} resulted in an error. \\n` + `${transactionMessage}. ` + maybeLogsOutput + guideText;\n                break;\n            case \"simulate\":\n                message = `Simulation failed. \\nMessage: ${transactionMessage}. \\n` + maybeLogsOutput + guideText;\n                break;\n            default:\n                {\n                    message = `Unknown action '${((a)=>a)(action)}'`;\n                }\n        }\n        super(message);\n        this.signature = void 0;\n        this.transactionMessage = void 0;\n        this.transactionLogs = void 0;\n        this.signature = signature;\n        this.transactionMessage = transactionMessage;\n        this.transactionLogs = logs ? logs : undefined;\n    }\n    get transactionError() {\n        return {\n            message: this.transactionMessage,\n            logs: Array.isArray(this.transactionLogs) ? this.transactionLogs : undefined\n        };\n    }\n    /* @deprecated Use `await getLogs()` instead */ get logs() {\n        const cachedLogs = this.transactionLogs;\n        if (cachedLogs != null && typeof cachedLogs === \"object\" && \"then\" in cachedLogs) {\n            return undefined;\n        }\n        return cachedLogs;\n    }\n    async getLogs(connection) {\n        if (!Array.isArray(this.transactionLogs)) {\n            this.transactionLogs = new Promise((resolve, reject)=>{\n                connection.getTransaction(this.signature).then((tx)=>{\n                    if (tx && tx.meta && tx.meta.logMessages) {\n                        const logs = tx.meta.logMessages;\n                        this.transactionLogs = logs;\n                        resolve(logs);\n                    } else {\n                        reject(new Error(\"Log messages not found\"));\n                    }\n                }).catch(reject);\n            });\n        }\n        return await this.transactionLogs;\n    }\n}\n// Keep in sync with client/src/rpc_custom_errors.rs\n// Typescript `enums` thwart tree-shaking. See https://bargsten.org/jsts/enums/\nconst SolanaJSONRPCErrorCode = {\n    JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP: -32001,\n    JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE: -32002,\n    JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE: -32003,\n    JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE: -32004,\n    JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY: -32005,\n    JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE: -32006,\n    JSON_RPC_SERVER_ERROR_SLOT_SKIPPED: -32007,\n    JSON_RPC_SERVER_ERROR_NO_SNAPSHOT: -32008,\n    JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED: -32009,\n    JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX: -32010,\n    JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE: -32011,\n    JSON_RPC_SCAN_ERROR: -32012,\n    JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH: -32013,\n    JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET: -32014,\n    JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION: -32015,\n    JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED: -32016\n};\nclass SolanaJSONRPCError extends Error {\n    constructor({ code, message, data }, customMessage){\n        super(customMessage != null ? `${customMessage}: ${message}` : message);\n        this.code = void 0;\n        this.data = void 0;\n        this.code = code;\n        this.data = data;\n        this.name = \"SolanaJSONRPCError\";\n    }\n}\n/**\n * Sign, send and confirm a transaction.\n *\n * If `commitment` option is not specified, defaults to 'max' commitment.\n *\n * @param {Connection} connection\n * @param {Transaction} transaction\n * @param {Array<Signer>} signers\n * @param {ConfirmOptions} [options]\n * @returns {Promise<TransactionSignature>}\n */ async function sendAndConfirmTransaction(connection, transaction, signers, options) {\n    const sendOptions = options && {\n        skipPreflight: options.skipPreflight,\n        preflightCommitment: options.preflightCommitment || options.commitment,\n        maxRetries: options.maxRetries,\n        minContextSlot: options.minContextSlot\n    };\n    const signature = await connection.sendTransaction(transaction, signers, sendOptions);\n    let status;\n    if (transaction.recentBlockhash != null && transaction.lastValidBlockHeight != null) {\n        status = (await connection.confirmTransaction({\n            abortSignal: options?.abortSignal,\n            signature: signature,\n            blockhash: transaction.recentBlockhash,\n            lastValidBlockHeight: transaction.lastValidBlockHeight\n        }, options && options.commitment)).value;\n    } else if (transaction.minNonceContextSlot != null && transaction.nonceInfo != null) {\n        const { nonceInstruction } = transaction.nonceInfo;\n        const nonceAccountPubkey = nonceInstruction.keys[0].pubkey;\n        status = (await connection.confirmTransaction({\n            abortSignal: options?.abortSignal,\n            minContextSlot: transaction.minNonceContextSlot,\n            nonceAccountPubkey,\n            nonceValue: transaction.nonceInfo.nonce,\n            signature\n        }, options && options.commitment)).value;\n    } else {\n        if (options?.abortSignal != null) {\n            console.warn(\"sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was \" + \"supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` \" + \"or a combination of `nonceInfo` and `minNonceContextSlot` are abortable.\");\n        }\n        status = (await connection.confirmTransaction(signature, options && options.commitment)).value;\n    }\n    if (status.err) {\n        if (signature != null) {\n            throw new SendTransactionError({\n                action: \"send\",\n                signature: signature,\n                transactionMessage: `Status: (${JSON.stringify(status)})`\n            });\n        }\n        throw new Error(`Transaction ${signature} failed (${JSON.stringify(status)})`);\n    }\n    return signature;\n}\n// zzz\nfunction sleep(ms) {\n    return new Promise((resolve)=>setTimeout(resolve, ms));\n}\n/**\n * @internal\n */ /**\n * Populate a buffer of instruction data using an InstructionType\n * @internal\n */ function encodeData(type, fields) {\n    const allocLength = type.layout.span >= 0 ? type.layout.span : getAlloc(type, fields);\n    const data = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(allocLength);\n    const layoutFields = Object.assign({\n        instruction: type.index\n    }, fields);\n    type.layout.encode(layoutFields, data);\n    return data;\n}\n/**\n * Decode instruction data buffer using an InstructionType\n * @internal\n */ function decodeData$1(type, buffer) {\n    let data;\n    try {\n        data = type.layout.decode(buffer);\n    } catch (err) {\n        throw new Error(\"invalid instruction; \" + err);\n    }\n    if (data.instruction !== type.index) {\n        throw new Error(`invalid instruction; instruction index mismatch ${data.instruction} != ${type.index}`);\n    }\n    return data;\n}\n/**\n * https://github.com/solana-labs/solana/blob/90bedd7e067b5b8f3ddbb45da00a4e9cabb22c62/sdk/src/fee_calculator.rs#L7-L11\n *\n * @internal\n */ const FeeCalculatorLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"lamportsPerSignature\");\n/**\n * Calculator for transaction fees.\n *\n * @deprecated Deprecated since Solana v1.8.0.\n */ /**\n * See https://github.com/solana-labs/solana/blob/0ea2843ec9cdc517572b8e62c959f41b55cf4453/sdk/src/nonce_state.rs#L29-L32\n *\n * @internal\n */ const NonceAccountLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"version\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"state\"),\n    publicKey(\"authorizedPubkey\"),\n    publicKey(\"nonce\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        FeeCalculatorLayout\n    ], \"feeCalculator\")\n]);\nconst NONCE_ACCOUNT_LENGTH = NonceAccountLayout.span;\n/**\n * A durable nonce is a 32 byte value encoded as a base58 string.\n */ /**\n * NonceAccount class\n */ class NonceAccount {\n    /**\n   * @internal\n   */ constructor(args){\n        this.authorizedPubkey = void 0;\n        this.nonce = void 0;\n        this.feeCalculator = void 0;\n        this.authorizedPubkey = args.authorizedPubkey;\n        this.nonce = args.nonce;\n        this.feeCalculator = args.feeCalculator;\n    }\n    /**\n   * Deserialize NonceAccount from the account data.\n   *\n   * @param buffer account data\n   * @return NonceAccount\n   */ static fromAccountData(buffer) {\n        const nonceAccount = NonceAccountLayout.decode(toBuffer(buffer), 0);\n        return new NonceAccount({\n            authorizedPubkey: new PublicKey(nonceAccount.authorizedPubkey),\n            nonce: new PublicKey(nonceAccount.nonce).toString(),\n            feeCalculator: nonceAccount.feeCalculator\n        });\n    }\n}\nfunction u64(property) {\n    const layout = (0,_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob)(8 /* bytes */ , property);\n    const decode = layout.decode.bind(layout);\n    const encode = layout.encode.bind(layout);\n    const bigIntLayout = layout;\n    const codec = (0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_13__.getU64Codec)();\n    bigIntLayout.decode = (buffer, offset)=>{\n        const src = decode(buffer, offset);\n        return codec.decode(src);\n    };\n    bigIntLayout.encode = (bigInt, buffer, offset)=>{\n        const src = codec.encode(bigInt);\n        return encode(src, buffer, offset);\n    };\n    return bigIntLayout;\n}\n/**\n * Create account system transaction params\n */ /**\n * Transfer system transaction params\n */ /**\n * Assign system transaction params\n */ /**\n * Create account with seed system transaction params\n */ /**\n * Create nonce account system transaction params\n */ /**\n * Create nonce account with seed system transaction params\n */ /**\n * Initialize nonce account system instruction params\n */ /**\n * Advance nonce account system instruction params\n */ /**\n * Withdraw nonce account system transaction params\n */ /**\n * Authorize nonce account system transaction params\n */ /**\n * Allocate account system transaction params\n */ /**\n * Allocate account with seed system transaction params\n */ /**\n * Assign account with seed system transaction params\n */ /**\n * Transfer with seed system transaction params\n */ /** Decoded transfer system transaction instruction */ /** Decoded transferWithSeed system transaction instruction */ /**\n * System Instruction class\n */ class SystemInstruction {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Decode a system instruction and retrieve the instruction type.\n   */ static decodeInstructionType(instruction) {\n        this.checkProgramId(instruction.programId);\n        const instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\");\n        const typeIndex = instructionTypeLayout.decode(instruction.data);\n        let type;\n        for (const [ixType, layout] of Object.entries(SYSTEM_INSTRUCTION_LAYOUTS)){\n            if (layout.index == typeIndex) {\n                type = ixType;\n                break;\n            }\n        }\n        if (!type) {\n            throw new Error(\"Instruction type incorrect; not a SystemInstruction\");\n        }\n        return type;\n    }\n    /**\n   * Decode a create account system instruction and retrieve the instruction params.\n   */ static decodeCreateAccount(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 2);\n        const { lamports, space, programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Create, instruction.data);\n        return {\n            fromPubkey: instruction.keys[0].pubkey,\n            newAccountPubkey: instruction.keys[1].pubkey,\n            lamports,\n            space,\n            programId: new PublicKey(programId)\n        };\n    }\n    /**\n   * Decode a transfer system instruction and retrieve the instruction params.\n   */ static decodeTransfer(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 2);\n        const { lamports } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Transfer, instruction.data);\n        return {\n            fromPubkey: instruction.keys[0].pubkey,\n            toPubkey: instruction.keys[1].pubkey,\n            lamports\n        };\n    }\n    /**\n   * Decode a transfer with seed system instruction and retrieve the instruction params.\n   */ static decodeTransferWithSeed(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { lamports, seed, programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed, instruction.data);\n        return {\n            fromPubkey: instruction.keys[0].pubkey,\n            basePubkey: instruction.keys[1].pubkey,\n            toPubkey: instruction.keys[2].pubkey,\n            lamports,\n            seed,\n            programId: new PublicKey(programId)\n        };\n    }\n    /**\n   * Decode an allocate system instruction and retrieve the instruction params.\n   */ static decodeAllocate(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 1);\n        const { space } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Allocate, instruction.data);\n        return {\n            accountPubkey: instruction.keys[0].pubkey,\n            space\n        };\n    }\n    /**\n   * Decode an allocate with seed system instruction and retrieve the instruction params.\n   */ static decodeAllocateWithSeed(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 1);\n        const { base, seed, space, programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed, instruction.data);\n        return {\n            accountPubkey: instruction.keys[0].pubkey,\n            basePubkey: new PublicKey(base),\n            seed,\n            space,\n            programId: new PublicKey(programId)\n        };\n    }\n    /**\n   * Decode an assign system instruction and retrieve the instruction params.\n   */ static decodeAssign(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 1);\n        const { programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Assign, instruction.data);\n        return {\n            accountPubkey: instruction.keys[0].pubkey,\n            programId: new PublicKey(programId)\n        };\n    }\n    /**\n   * Decode an assign with seed system instruction and retrieve the instruction params.\n   */ static decodeAssignWithSeed(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 1);\n        const { base, seed, programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed, instruction.data);\n        return {\n            accountPubkey: instruction.keys[0].pubkey,\n            basePubkey: new PublicKey(base),\n            seed,\n            programId: new PublicKey(programId)\n        };\n    }\n    /**\n   * Decode a create account with seed system instruction and retrieve the instruction params.\n   */ static decodeCreateWithSeed(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 2);\n        const { base, seed, lamports, space, programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed, instruction.data);\n        return {\n            fromPubkey: instruction.keys[0].pubkey,\n            newAccountPubkey: instruction.keys[1].pubkey,\n            basePubkey: new PublicKey(base),\n            seed,\n            lamports,\n            space,\n            programId: new PublicKey(programId)\n        };\n    }\n    /**\n   * Decode a nonce initialize system instruction and retrieve the instruction params.\n   */ static decodeNonceInitialize(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { authorized } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount, instruction.data);\n        return {\n            noncePubkey: instruction.keys[0].pubkey,\n            authorizedPubkey: new PublicKey(authorized)\n        };\n    }\n    /**\n   * Decode a nonce advance system instruction and retrieve the instruction params.\n   */ static decodeNonceAdvance(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount, instruction.data);\n        return {\n            noncePubkey: instruction.keys[0].pubkey,\n            authorizedPubkey: instruction.keys[2].pubkey\n        };\n    }\n    /**\n   * Decode a nonce withdraw system instruction and retrieve the instruction params.\n   */ static decodeNonceWithdraw(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 5);\n        const { lamports } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount, instruction.data);\n        return {\n            noncePubkey: instruction.keys[0].pubkey,\n            toPubkey: instruction.keys[1].pubkey,\n            authorizedPubkey: instruction.keys[4].pubkey,\n            lamports\n        };\n    }\n    /**\n   * Decode a nonce authorize system instruction and retrieve the instruction params.\n   */ static decodeNonceAuthorize(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 2);\n        const { authorized } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount, instruction.data);\n        return {\n            noncePubkey: instruction.keys[0].pubkey,\n            authorizedPubkey: instruction.keys[1].pubkey,\n            newAuthorizedPubkey: new PublicKey(authorized)\n        };\n    }\n    /**\n   * @internal\n   */ static checkProgramId(programId) {\n        if (!programId.equals(SystemProgram.programId)) {\n            throw new Error(\"invalid instruction; programId is not SystemProgram\");\n        }\n    }\n    /**\n   * @internal\n   */ static checkKeyLength(keys, expectedLength) {\n        if (keys.length < expectedLength) {\n            throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);\n        }\n    }\n}\n/**\n * An enumeration of valid SystemInstructionType's\n */ /**\n * An enumeration of valid system InstructionType's\n * @internal\n */ const SYSTEM_INSTRUCTION_LAYOUTS = Object.freeze({\n    Create: {\n        index: 0,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"lamports\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"space\"),\n            publicKey(\"programId\")\n        ])\n    },\n    Assign: {\n        index: 1,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"programId\")\n        ])\n    },\n    Transfer: {\n        index: 2,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            u64(\"lamports\")\n        ])\n    },\n    CreateWithSeed: {\n        index: 3,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"base\"),\n            rustString(\"seed\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"lamports\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"space\"),\n            publicKey(\"programId\")\n        ])\n    },\n    AdvanceNonceAccount: {\n        index: 4,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    },\n    WithdrawNonceAccount: {\n        index: 5,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"lamports\")\n        ])\n    },\n    InitializeNonceAccount: {\n        index: 6,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"authorized\")\n        ])\n    },\n    AuthorizeNonceAccount: {\n        index: 7,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"authorized\")\n        ])\n    },\n    Allocate: {\n        index: 8,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"space\")\n        ])\n    },\n    AllocateWithSeed: {\n        index: 9,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"base\"),\n            rustString(\"seed\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"space\"),\n            publicKey(\"programId\")\n        ])\n    },\n    AssignWithSeed: {\n        index: 10,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"base\"),\n            rustString(\"seed\"),\n            publicKey(\"programId\")\n        ])\n    },\n    TransferWithSeed: {\n        index: 11,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            u64(\"lamports\"),\n            rustString(\"seed\"),\n            publicKey(\"programId\")\n        ])\n    },\n    UpgradeNonceAccount: {\n        index: 12,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    }\n});\n/**\n * Factory class for transactions to interact with the System program\n */ class SystemProgram {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Public key that identifies the System program\n   */ /**\n   * Generate a transaction instruction that creates a new account\n   */ static createAccount(params) {\n        const type = SYSTEM_INSTRUCTION_LAYOUTS.Create;\n        const data = encodeData(type, {\n            lamports: params.lamports,\n            space: params.space,\n            programId: toBuffer(params.programId.toBuffer())\n        });\n        return new TransactionInstruction({\n            keys: [\n                {\n                    pubkey: params.fromPubkey,\n                    isSigner: true,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.newAccountPubkey,\n                    isSigner: true,\n                    isWritable: true\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction instruction that transfers lamports from one account to another\n   */ static transfer(params) {\n        let data;\n        let keys;\n        if (\"basePubkey\" in params) {\n            const type = SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed;\n            data = encodeData(type, {\n                lamports: BigInt(params.lamports),\n                seed: params.seed,\n                programId: toBuffer(params.programId.toBuffer())\n            });\n            keys = [\n                {\n                    pubkey: params.fromPubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.basePubkey,\n                    isSigner: true,\n                    isWritable: false\n                },\n                {\n                    pubkey: params.toPubkey,\n                    isSigner: false,\n                    isWritable: true\n                }\n            ];\n        } else {\n            const type = SYSTEM_INSTRUCTION_LAYOUTS.Transfer;\n            data = encodeData(type, {\n                lamports: BigInt(params.lamports)\n            });\n            keys = [\n                {\n                    pubkey: params.fromPubkey,\n                    isSigner: true,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.toPubkey,\n                    isSigner: false,\n                    isWritable: true\n                }\n            ];\n        }\n        return new TransactionInstruction({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction instruction that assigns an account to a program\n   */ static assign(params) {\n        let data;\n        let keys;\n        if (\"basePubkey\" in params) {\n            const type = SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed;\n            data = encodeData(type, {\n                base: toBuffer(params.basePubkey.toBuffer()),\n                seed: params.seed,\n                programId: toBuffer(params.programId.toBuffer())\n            });\n            keys = [\n                {\n                    pubkey: params.accountPubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.basePubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ];\n        } else {\n            const type = SYSTEM_INSTRUCTION_LAYOUTS.Assign;\n            data = encodeData(type, {\n                programId: toBuffer(params.programId.toBuffer())\n            });\n            keys = [\n                {\n                    pubkey: params.accountPubkey,\n                    isSigner: true,\n                    isWritable: true\n                }\n            ];\n        }\n        return new TransactionInstruction({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction instruction that creates a new account at\n   *   an address generated with `from`, a seed, and programId\n   */ static createAccountWithSeed(params) {\n        const type = SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed;\n        const data = encodeData(type, {\n            base: toBuffer(params.basePubkey.toBuffer()),\n            seed: params.seed,\n            lamports: params.lamports,\n            space: params.space,\n            programId: toBuffer(params.programId.toBuffer())\n        });\n        let keys = [\n            {\n                pubkey: params.fromPubkey,\n                isSigner: true,\n                isWritable: true\n            },\n            {\n                pubkey: params.newAccountPubkey,\n                isSigner: false,\n                isWritable: true\n            }\n        ];\n        if (!params.basePubkey.equals(params.fromPubkey)) {\n            keys.push({\n                pubkey: params.basePubkey,\n                isSigner: true,\n                isWritable: false\n            });\n        }\n        return new TransactionInstruction({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction that creates a new Nonce account\n   */ static createNonceAccount(params) {\n        const transaction = new Transaction();\n        if (\"basePubkey\" in params && \"seed\" in params) {\n            transaction.add(SystemProgram.createAccountWithSeed({\n                fromPubkey: params.fromPubkey,\n                newAccountPubkey: params.noncePubkey,\n                basePubkey: params.basePubkey,\n                seed: params.seed,\n                lamports: params.lamports,\n                space: NONCE_ACCOUNT_LENGTH,\n                programId: this.programId\n            }));\n        } else {\n            transaction.add(SystemProgram.createAccount({\n                fromPubkey: params.fromPubkey,\n                newAccountPubkey: params.noncePubkey,\n                lamports: params.lamports,\n                space: NONCE_ACCOUNT_LENGTH,\n                programId: this.programId\n            }));\n        }\n        const initParams = {\n            noncePubkey: params.noncePubkey,\n            authorizedPubkey: params.authorizedPubkey\n        };\n        transaction.add(this.nonceInitialize(initParams));\n        return transaction;\n    }\n    /**\n   * Generate an instruction to initialize a Nonce account\n   */ static nonceInitialize(params) {\n        const type = SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount;\n        const data = encodeData(type, {\n            authorized: toBuffer(params.authorizedPubkey.toBuffer())\n        });\n        const instructionData = {\n            keys: [\n                {\n                    pubkey: params.noncePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: SYSVAR_RENT_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        };\n        return new TransactionInstruction(instructionData);\n    }\n    /**\n   * Generate an instruction to advance the nonce in a Nonce account\n   */ static nonceAdvance(params) {\n        const type = SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount;\n        const data = encodeData(type);\n        const instructionData = {\n            keys: [\n                {\n                    pubkey: params.noncePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: params.authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        };\n        return new TransactionInstruction(instructionData);\n    }\n    /**\n   * Generate a transaction instruction that withdraws lamports from a Nonce account\n   */ static nonceWithdraw(params) {\n        const type = SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount;\n        const data = encodeData(type, {\n            lamports: params.lamports\n        });\n        return new TransactionInstruction({\n            keys: [\n                {\n                    pubkey: params.noncePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.toPubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: SYSVAR_RENT_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: params.authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction instruction that authorizes a new PublicKey as the authority\n   * on a Nonce account.\n   */ static nonceAuthorize(params) {\n        const type = SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount;\n        const data = encodeData(type, {\n            authorized: toBuffer(params.newAuthorizedPubkey.toBuffer())\n        });\n        return new TransactionInstruction({\n            keys: [\n                {\n                    pubkey: params.noncePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction instruction that allocates space in an account without funding\n   */ static allocate(params) {\n        let data;\n        let keys;\n        if (\"basePubkey\" in params) {\n            const type = SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed;\n            data = encodeData(type, {\n                base: toBuffer(params.basePubkey.toBuffer()),\n                seed: params.seed,\n                space: params.space,\n                programId: toBuffer(params.programId.toBuffer())\n            });\n            keys = [\n                {\n                    pubkey: params.accountPubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.basePubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ];\n        } else {\n            const type = SYSTEM_INSTRUCTION_LAYOUTS.Allocate;\n            data = encodeData(type, {\n                space: params.space\n            });\n            keys = [\n                {\n                    pubkey: params.accountPubkey,\n                    isSigner: true,\n                    isWritable: true\n                }\n            ];\n        }\n        return new TransactionInstruction({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n}\nSystemProgram.programId = new PublicKey(\"11111111111111111111111111111111\");\n// Keep program chunks under PACKET_DATA_SIZE, leaving enough room for the\n// rest of the Transaction fields\n//\n// TODO: replace 300 with a proper constant for the size of the other\n// Transaction fields\nconst CHUNK_SIZE = PACKET_DATA_SIZE - 300;\n/**\n * Program loader interface\n */ class Loader {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Amount of program data placed in each load Transaction\n   */ /**\n   * Minimum number of signatures required to load a program not including\n   * retries\n   *\n   * Can be used to calculate transaction fees\n   */ static getMinNumSignatures(dataLength) {\n        return 2 * // Every transaction requires two signatures (payer + program)\n        (Math.ceil(dataLength / Loader.chunkSize) + 1 + // Add one for Create transaction\n        1 // Add one for Finalize transaction\n        );\n    }\n    /**\n   * Loads a generic program\n   *\n   * @param connection The connection to use\n   * @param payer System account that pays to load the program\n   * @param program Account to load the program into\n   * @param programId Public key that identifies the loader\n   * @param data Program octets\n   * @return true if program was loaded successfully, false if program was already loaded\n   */ static async load(connection, payer, program, programId, data) {\n        {\n            const balanceNeeded = await connection.getMinimumBalanceForRentExemption(data.length);\n            // Fetch program account info to check if it has already been created\n            const programInfo = await connection.getAccountInfo(program.publicKey, \"confirmed\");\n            let transaction = null;\n            if (programInfo !== null) {\n                if (programInfo.executable) {\n                    console.error(\"Program load failed, account is already executable\");\n                    return false;\n                }\n                if (programInfo.data.length !== data.length) {\n                    transaction = transaction || new Transaction();\n                    transaction.add(SystemProgram.allocate({\n                        accountPubkey: program.publicKey,\n                        space: data.length\n                    }));\n                }\n                if (!programInfo.owner.equals(programId)) {\n                    transaction = transaction || new Transaction();\n                    transaction.add(SystemProgram.assign({\n                        accountPubkey: program.publicKey,\n                        programId\n                    }));\n                }\n                if (programInfo.lamports < balanceNeeded) {\n                    transaction = transaction || new Transaction();\n                    transaction.add(SystemProgram.transfer({\n                        fromPubkey: payer.publicKey,\n                        toPubkey: program.publicKey,\n                        lamports: balanceNeeded - programInfo.lamports\n                    }));\n                }\n            } else {\n                transaction = new Transaction().add(SystemProgram.createAccount({\n                    fromPubkey: payer.publicKey,\n                    newAccountPubkey: program.publicKey,\n                    lamports: balanceNeeded > 0 ? balanceNeeded : 1,\n                    space: data.length,\n                    programId\n                }));\n            }\n            // If the account is already created correctly, skip this step\n            // and proceed directly to loading instructions\n            if (transaction !== null) {\n                await sendAndConfirmTransaction(connection, transaction, [\n                    payer,\n                    program\n                ], {\n                    commitment: \"confirmed\"\n                });\n            }\n        }\n        const dataLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"offset\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"bytesLength\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"bytesLengthPadding\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"byte\"), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(), -8), \"bytes\")\n        ]);\n        const chunkSize = Loader.chunkSize;\n        let offset = 0;\n        let array = data;\n        let transactions = [];\n        while(array.length > 0){\n            const bytes = array.slice(0, chunkSize);\n            const data = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(chunkSize + 16);\n            dataLayout.encode({\n                instruction: 0,\n                // Load instruction\n                offset,\n                bytes: bytes,\n                bytesLength: 0,\n                bytesLengthPadding: 0\n            }, data);\n            const transaction = new Transaction().add({\n                keys: [\n                    {\n                        pubkey: program.publicKey,\n                        isSigner: true,\n                        isWritable: true\n                    }\n                ],\n                programId,\n                data\n            });\n            transactions.push(sendAndConfirmTransaction(connection, transaction, [\n                payer,\n                program\n            ], {\n                commitment: \"confirmed\"\n            }));\n            // Delay between sends in an attempt to reduce rate limit errors\n            if (connection._rpcEndpoint.includes(\"solana.com\")) {\n                const REQUESTS_PER_SECOND = 4;\n                await sleep(1000 / REQUESTS_PER_SECOND);\n            }\n            offset += chunkSize;\n            array = array.slice(chunkSize);\n        }\n        await Promise.all(transactions);\n        // Finalize the account loaded with program data for execution\n        {\n            const dataLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n            ]);\n            const data = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(dataLayout.span);\n            dataLayout.encode({\n                instruction: 1 // Finalize instruction\n            }, data);\n            const transaction = new Transaction().add({\n                keys: [\n                    {\n                        pubkey: program.publicKey,\n                        isSigner: true,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: SYSVAR_RENT_PUBKEY,\n                        isSigner: false,\n                        isWritable: false\n                    }\n                ],\n                programId,\n                data\n            });\n            const deployCommitment = \"processed\";\n            const finalizeSignature = await connection.sendTransaction(transaction, [\n                payer,\n                program\n            ], {\n                preflightCommitment: deployCommitment\n            });\n            const { context, value } = await connection.confirmTransaction({\n                signature: finalizeSignature,\n                lastValidBlockHeight: transaction.lastValidBlockHeight,\n                blockhash: transaction.recentBlockhash\n            }, deployCommitment);\n            if (value.err) {\n                throw new Error(`Transaction ${finalizeSignature} failed (${JSON.stringify(value)})`);\n            }\n            // We prevent programs from being usable until the slot after their deployment.\n            // See https://github.com/solana-labs/solana/pull/29654\n            while(true // eslint-disable-line no-constant-condition\n            ){\n                try {\n                    const currentSlot = await connection.getSlot({\n                        commitment: deployCommitment\n                    });\n                    if (currentSlot > context.slot) {\n                        break;\n                    }\n                } catch  {\n                /* empty */ }\n                await new Promise((resolve)=>setTimeout(resolve, Math.round(MS_PER_SLOT / 2)));\n            }\n        }\n        // success\n        return true;\n    }\n}\nLoader.chunkSize = CHUNK_SIZE;\n/**\n * @deprecated Deprecated since Solana v1.17.20.\n */ const BPF_LOADER_PROGRAM_ID = new PublicKey(\"BPFLoader2111111111111111111111111111111111\");\n/**\n * Factory class for transactions to interact with a program loader\n *\n * @deprecated Deprecated since Solana v1.17.20.\n */ class BpfLoader {\n    /**\n   * Minimum number of signatures required to load a program not including\n   * retries\n   *\n   * Can be used to calculate transaction fees\n   */ static getMinNumSignatures(dataLength) {\n        return Loader.getMinNumSignatures(dataLength);\n    }\n    /**\n   * Load a SBF program\n   *\n   * @param connection The connection to use\n   * @param payer Account that will pay program loading fees\n   * @param program Account to load the program into\n   * @param elf The entire ELF containing the SBF program\n   * @param loaderProgramId The program id of the BPF loader to use\n   * @return true if program was loaded successfully, false if program was already loaded\n   */ static load(connection, payer, program, elf, loaderProgramId) {\n        return Loader.load(connection, payer, program, loaderProgramId, elf);\n    }\n}\nfunction getDefaultExportFromCjs(x) {\n    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x[\"default\"] : x;\n}\nvar agentkeepalive = {\n    exports: {}\n};\n/**\n * Helpers.\n */ var ms;\nvar hasRequiredMs;\nfunction requireMs() {\n    if (hasRequiredMs) return ms;\n    hasRequiredMs = 1;\n    var s = 1000;\n    var m = s * 60;\n    var h = m * 60;\n    var d = h * 24;\n    var w = d * 7;\n    var y = d * 365.25;\n    /**\n\t * Parse or format the given `val`.\n\t *\n\t * Options:\n\t *\n\t *  - `long` verbose formatting [false]\n\t *\n\t * @param {String|Number} val\n\t * @param {Object} [options]\n\t * @throws {Error} throw an error if val is not a non-empty string or a number\n\t * @return {String|Number}\n\t * @api public\n\t */ ms = function(val, options) {\n        options = options || {};\n        var type = typeof val;\n        if (type === \"string\" && val.length > 0) {\n            return parse(val);\n        } else if (type === \"number\" && isFinite(val)) {\n            return options.long ? fmtLong(val) : fmtShort(val);\n        }\n        throw new Error(\"val is not a non-empty string or a valid number. val=\" + JSON.stringify(val));\n    };\n    /**\n\t * Parse the given `str` and return milliseconds.\n\t *\n\t * @param {String} str\n\t * @return {Number}\n\t * @api private\n\t */ function parse(str) {\n        str = String(str);\n        if (str.length > 100) {\n            return;\n        }\n        var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);\n        if (!match) {\n            return;\n        }\n        var n = parseFloat(match[1]);\n        var type = (match[2] || \"ms\").toLowerCase();\n        switch(type){\n            case \"years\":\n            case \"year\":\n            case \"yrs\":\n            case \"yr\":\n            case \"y\":\n                return n * y;\n            case \"weeks\":\n            case \"week\":\n            case \"w\":\n                return n * w;\n            case \"days\":\n            case \"day\":\n            case \"d\":\n                return n * d;\n            case \"hours\":\n            case \"hour\":\n            case \"hrs\":\n            case \"hr\":\n            case \"h\":\n                return n * h;\n            case \"minutes\":\n            case \"minute\":\n            case \"mins\":\n            case \"min\":\n            case \"m\":\n                return n * m;\n            case \"seconds\":\n            case \"second\":\n            case \"secs\":\n            case \"sec\":\n            case \"s\":\n                return n * s;\n            case \"milliseconds\":\n            case \"millisecond\":\n            case \"msecs\":\n            case \"msec\":\n            case \"ms\":\n                return n;\n            default:\n                return undefined;\n        }\n    }\n    /**\n\t * Short format for `ms`.\n\t *\n\t * @param {Number} ms\n\t * @return {String}\n\t * @api private\n\t */ function fmtShort(ms) {\n        var msAbs = Math.abs(ms);\n        if (msAbs >= d) {\n            return Math.round(ms / d) + \"d\";\n        }\n        if (msAbs >= h) {\n            return Math.round(ms / h) + \"h\";\n        }\n        if (msAbs >= m) {\n            return Math.round(ms / m) + \"m\";\n        }\n        if (msAbs >= s) {\n            return Math.round(ms / s) + \"s\";\n        }\n        return ms + \"ms\";\n    }\n    /**\n\t * Long format for `ms`.\n\t *\n\t * @param {Number} ms\n\t * @return {String}\n\t * @api private\n\t */ function fmtLong(ms) {\n        var msAbs = Math.abs(ms);\n        if (msAbs >= d) {\n            return plural(ms, msAbs, d, \"day\");\n        }\n        if (msAbs >= h) {\n            return plural(ms, msAbs, h, \"hour\");\n        }\n        if (msAbs >= m) {\n            return plural(ms, msAbs, m, \"minute\");\n        }\n        if (msAbs >= s) {\n            return plural(ms, msAbs, s, \"second\");\n        }\n        return ms + \" ms\";\n    }\n    /**\n\t * Pluralization helper.\n\t */ function plural(ms, msAbs, n, name) {\n        var isPlural = msAbs >= n * 1.5;\n        return Math.round(ms / n) + \" \" + name + (isPlural ? \"s\" : \"\");\n    }\n    return ms;\n}\n/*!\n * humanize-ms - index.js\n * Copyright(c) 2014 dead_horse <dead_horse@qq.com>\n * MIT Licensed\n */ var humanizeMs;\nvar hasRequiredHumanizeMs;\nfunction requireHumanizeMs() {\n    if (hasRequiredHumanizeMs) return humanizeMs;\n    hasRequiredHumanizeMs = 1;\n    /**\n\t * Module dependencies.\n\t */ var util = (util__WEBPACK_IMPORTED_MODULE_5___default());\n    var ms = /*@__PURE__*/ requireMs();\n    humanizeMs = function(t) {\n        if (typeof t === \"number\") return t;\n        var r = ms(t);\n        if (r === undefined) {\n            var err = new Error(util.format(\"humanize-ms(%j) result undefined\", t));\n            console.warn(err.stack);\n        }\n        return r;\n    };\n    return humanizeMs;\n}\nvar constants;\nvar hasRequiredConstants;\nfunction requireConstants() {\n    if (hasRequiredConstants) return constants;\n    hasRequiredConstants = 1;\n    constants = {\n        // agent\n        CURRENT_ID: Symbol(\"agentkeepalive#currentId\"),\n        CREATE_ID: Symbol(\"agentkeepalive#createId\"),\n        INIT_SOCKET: Symbol(\"agentkeepalive#initSocket\"),\n        CREATE_HTTPS_CONNECTION: Symbol(\"agentkeepalive#createHttpsConnection\"),\n        // socket\n        SOCKET_CREATED_TIME: Symbol(\"agentkeepalive#socketCreatedTime\"),\n        SOCKET_NAME: Symbol(\"agentkeepalive#socketName\"),\n        SOCKET_REQUEST_COUNT: Symbol(\"agentkeepalive#socketRequestCount\"),\n        SOCKET_REQUEST_FINISHED_COUNT: Symbol(\"agentkeepalive#socketRequestFinishedCount\")\n    };\n    return constants;\n}\nvar agent;\nvar hasRequiredAgent;\nfunction requireAgent() {\n    if (hasRequiredAgent) return agent;\n    hasRequiredAgent = 1;\n    const OriginalAgent = (http__WEBPACK_IMPORTED_MODULE_6___default().Agent);\n    const ms = /*@__PURE__*/ requireHumanizeMs();\n    const debug = util__WEBPACK_IMPORTED_MODULE_5___default().debuglog(\"agentkeepalive\");\n    const { INIT_SOCKET, CURRENT_ID, CREATE_ID, SOCKET_CREATED_TIME, SOCKET_NAME, SOCKET_REQUEST_COUNT, SOCKET_REQUEST_FINISHED_COUNT } = /*@__PURE__*/ requireConstants();\n    // OriginalAgent come from\n    // - https://github.com/nodejs/node/blob/v8.12.0/lib/_http_agent.js\n    // - https://github.com/nodejs/node/blob/v10.12.0/lib/_http_agent.js\n    // node <= 10\n    let defaultTimeoutListenerCount = 1;\n    const majorVersion = parseInt(process.version.split(\".\", 1)[0].substring(1));\n    if (majorVersion >= 11 && majorVersion <= 12) {\n        defaultTimeoutListenerCount = 2;\n    } else if (majorVersion >= 13) {\n        defaultTimeoutListenerCount = 3;\n    }\n    function deprecate(message) {\n        console.log(\"[agentkeepalive:deprecated] %s\", message);\n    }\n    class Agent extends OriginalAgent {\n        constructor(options){\n            options = options || {};\n            options.keepAlive = options.keepAlive !== false;\n            // default is keep-alive and 4s free socket timeout\n            // see https://medium.com/ssense-tech/reduce-networking-errors-in-nodejs-23b4eb9f2d83\n            if (options.freeSocketTimeout === undefined) {\n                options.freeSocketTimeout = 4000;\n            }\n            // Legacy API: keepAliveTimeout should be rename to `freeSocketTimeout`\n            if (options.keepAliveTimeout) {\n                deprecate(\"options.keepAliveTimeout is deprecated, please use options.freeSocketTimeout instead\");\n                options.freeSocketTimeout = options.keepAliveTimeout;\n                delete options.keepAliveTimeout;\n            }\n            // Legacy API: freeSocketKeepAliveTimeout should be rename to `freeSocketTimeout`\n            if (options.freeSocketKeepAliveTimeout) {\n                deprecate(\"options.freeSocketKeepAliveTimeout is deprecated, please use options.freeSocketTimeout instead\");\n                options.freeSocketTimeout = options.freeSocketKeepAliveTimeout;\n                delete options.freeSocketKeepAliveTimeout;\n            }\n            // Sets the socket to timeout after timeout milliseconds of inactivity on the socket.\n            // By default is double free socket timeout.\n            if (options.timeout === undefined) {\n                // make sure socket default inactivity timeout >= 8s\n                options.timeout = Math.max(options.freeSocketTimeout * 2, 8000);\n            }\n            // support humanize format\n            options.timeout = ms(options.timeout);\n            options.freeSocketTimeout = ms(options.freeSocketTimeout);\n            options.socketActiveTTL = options.socketActiveTTL ? ms(options.socketActiveTTL) : 0;\n            super(options);\n            this[CURRENT_ID] = 0;\n            // create socket success counter\n            this.createSocketCount = 0;\n            this.createSocketCountLastCheck = 0;\n            this.createSocketErrorCount = 0;\n            this.createSocketErrorCountLastCheck = 0;\n            this.closeSocketCount = 0;\n            this.closeSocketCountLastCheck = 0;\n            // socket error event count\n            this.errorSocketCount = 0;\n            this.errorSocketCountLastCheck = 0;\n            // request finished counter\n            this.requestCount = 0;\n            this.requestCountLastCheck = 0;\n            // including free socket timeout counter\n            this.timeoutSocketCount = 0;\n            this.timeoutSocketCountLastCheck = 0;\n            this.on(\"free\", (socket)=>{\n                // https://github.com/nodejs/node/pull/32000\n                // Node.js native agent will check socket timeout eqs agent.options.timeout.\n                // Use the ttl or freeSocketTimeout to overwrite.\n                const timeout = this.calcSocketTimeout(socket);\n                if (timeout > 0 && socket.timeout !== timeout) {\n                    socket.setTimeout(timeout);\n                }\n            });\n        }\n        get freeSocketKeepAliveTimeout() {\n            deprecate(\"agent.freeSocketKeepAliveTimeout is deprecated, please use agent.options.freeSocketTimeout instead\");\n            return this.options.freeSocketTimeout;\n        }\n        get timeout() {\n            deprecate(\"agent.timeout is deprecated, please use agent.options.timeout instead\");\n            return this.options.timeout;\n        }\n        get socketActiveTTL() {\n            deprecate(\"agent.socketActiveTTL is deprecated, please use agent.options.socketActiveTTL instead\");\n            return this.options.socketActiveTTL;\n        }\n        calcSocketTimeout(socket) {\n            /**\n\t     * return <= 0: should free socket\n\t     * return > 0: should update socket timeout\n\t     * return undefined: not find custom timeout\n\t     */ let freeSocketTimeout = this.options.freeSocketTimeout;\n            const socketActiveTTL = this.options.socketActiveTTL;\n            if (socketActiveTTL) {\n                // check socketActiveTTL\n                const aliveTime = Date.now() - socket[SOCKET_CREATED_TIME];\n                const diff = socketActiveTTL - aliveTime;\n                if (diff <= 0) {\n                    return diff;\n                }\n                if (freeSocketTimeout && diff < freeSocketTimeout) {\n                    freeSocketTimeout = diff;\n                }\n            }\n            // set freeSocketTimeout\n            if (freeSocketTimeout) {\n                // set free keepalive timer\n                // try to use socket custom freeSocketTimeout first, support headers['keep-alive']\n                // https://github.com/node-modules/urllib/blob/b76053020923f4d99a1c93cf2e16e0c5ba10bacf/lib/urllib.js#L498\n                const customFreeSocketTimeout = socket.freeSocketTimeout || socket.freeSocketKeepAliveTimeout;\n                return customFreeSocketTimeout || freeSocketTimeout;\n            }\n        }\n        keepSocketAlive(socket) {\n            const result = super.keepSocketAlive(socket);\n            // should not keepAlive, do nothing\n            if (!result) return result;\n            const customTimeout = this.calcSocketTimeout(socket);\n            if (typeof customTimeout === \"undefined\") {\n                return true;\n            }\n            if (customTimeout <= 0) {\n                debug(\"%s(requests: %s, finished: %s) free but need to destroy by TTL, request count %s, diff is %s\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], customTimeout);\n                return false;\n            }\n            if (socket.timeout !== customTimeout) {\n                socket.setTimeout(customTimeout);\n            }\n            return true;\n        }\n        // only call on addRequest\n        reuseSocket(...args) {\n            // reuseSocket(socket, req)\n            super.reuseSocket(...args);\n            const socket = args[0];\n            const req = args[1];\n            req.reusedSocket = true;\n            const agentTimeout = this.options.timeout;\n            if (getSocketTimeout(socket) !== agentTimeout) {\n                // reset timeout before use\n                socket.setTimeout(agentTimeout);\n                debug(\"%s reset timeout to %sms\", socket[SOCKET_NAME], agentTimeout);\n            }\n            socket[SOCKET_REQUEST_COUNT]++;\n            debug(\"%s(requests: %s, finished: %s) reuse on addRequest, timeout %sms\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], getSocketTimeout(socket));\n        }\n        [CREATE_ID]() {\n            const id = this[CURRENT_ID]++;\n            if (this[CURRENT_ID] === Number.MAX_SAFE_INTEGER) this[CURRENT_ID] = 0;\n            return id;\n        }\n        [INIT_SOCKET](socket, options) {\n            // bugfix here.\n            // https on node 8, 10 won't set agent.options.timeout by default\n            // TODO: need to fix on node itself\n            if (options.timeout) {\n                const timeout = getSocketTimeout(socket);\n                if (!timeout) {\n                    socket.setTimeout(options.timeout);\n                }\n            }\n            if (this.options.keepAlive) {\n                // Disable Nagle's algorithm: http://blog.caustik.com/2012/04/08/scaling-node-js-to-100k-concurrent-connections/\n                // https://fengmk2.com/benchmark/nagle-algorithm-delayed-ack-mock.html\n                socket.setNoDelay(true);\n            }\n            this.createSocketCount++;\n            if (this.options.socketActiveTTL) {\n                socket[SOCKET_CREATED_TIME] = Date.now();\n            }\n            // don't show the hole '-----BEGIN CERTIFICATE----' key string\n            socket[SOCKET_NAME] = `sock[${this[CREATE_ID]()}#${options._agentKey}]`.split(\"-----BEGIN\", 1)[0];\n            socket[SOCKET_REQUEST_COUNT] = 1;\n            socket[SOCKET_REQUEST_FINISHED_COUNT] = 0;\n            installListeners(this, socket, options);\n        }\n        createConnection(options, oncreate) {\n            let called = false;\n            const onNewCreate = (err, socket)=>{\n                if (called) return;\n                called = true;\n                if (err) {\n                    this.createSocketErrorCount++;\n                    return oncreate(err);\n                }\n                this[INIT_SOCKET](socket, options);\n                oncreate(err, socket);\n            };\n            const newSocket = super.createConnection(options, onNewCreate);\n            if (newSocket) onNewCreate(null, newSocket);\n            return newSocket;\n        }\n        get statusChanged() {\n            const changed = this.createSocketCount !== this.createSocketCountLastCheck || this.createSocketErrorCount !== this.createSocketErrorCountLastCheck || this.closeSocketCount !== this.closeSocketCountLastCheck || this.errorSocketCount !== this.errorSocketCountLastCheck || this.timeoutSocketCount !== this.timeoutSocketCountLastCheck || this.requestCount !== this.requestCountLastCheck;\n            if (changed) {\n                this.createSocketCountLastCheck = this.createSocketCount;\n                this.createSocketErrorCountLastCheck = this.createSocketErrorCount;\n                this.closeSocketCountLastCheck = this.closeSocketCount;\n                this.errorSocketCountLastCheck = this.errorSocketCount;\n                this.timeoutSocketCountLastCheck = this.timeoutSocketCount;\n                this.requestCountLastCheck = this.requestCount;\n            }\n            return changed;\n        }\n        getCurrentStatus() {\n            return {\n                createSocketCount: this.createSocketCount,\n                createSocketErrorCount: this.createSocketErrorCount,\n                closeSocketCount: this.closeSocketCount,\n                errorSocketCount: this.errorSocketCount,\n                timeoutSocketCount: this.timeoutSocketCount,\n                requestCount: this.requestCount,\n                freeSockets: inspect(this.freeSockets),\n                sockets: inspect(this.sockets),\n                requests: inspect(this.requests)\n            };\n        }\n    }\n    // node 8 don't has timeout attribute on socket\n    // https://github.com/nodejs/node/pull/21204/files#diff-e6ef024c3775d787c38487a6309e491dR408\n    function getSocketTimeout(socket) {\n        return socket.timeout || socket._idleTimeout;\n    }\n    function installListeners(agent, socket, options) {\n        debug(\"%s create, timeout %sms\", socket[SOCKET_NAME], getSocketTimeout(socket));\n        // listener socket events: close, timeout, error, free\n        function onFree() {\n            // create and socket.emit('free') logic\n            // https://github.com/nodejs/node/blob/master/lib/_http_agent.js#L311\n            // no req on the socket, it should be the new socket\n            if (!socket._httpMessage && socket[SOCKET_REQUEST_COUNT] === 1) return;\n            socket[SOCKET_REQUEST_FINISHED_COUNT]++;\n            agent.requestCount++;\n            debug(\"%s(requests: %s, finished: %s) free\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT]);\n            // should reuse on pedding requests?\n            const name = agent.getName(options);\n            if (socket.writable && agent.requests[name] && agent.requests[name].length) {\n                // will be reuse on agent free listener\n                socket[SOCKET_REQUEST_COUNT]++;\n                debug(\"%s(requests: %s, finished: %s) will be reuse on agent free event\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT]);\n            }\n        }\n        socket.on(\"free\", onFree);\n        function onClose(isError) {\n            debug(\"%s(requests: %s, finished: %s) close, isError: %s\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], isError);\n            agent.closeSocketCount++;\n        }\n        socket.on(\"close\", onClose);\n        // start socket timeout handler\n        function onTimeout() {\n            // onTimeout and emitRequestTimeout(_http_client.js)\n            // https://github.com/nodejs/node/blob/v12.x/lib/_http_client.js#L711\n            const listenerCount = socket.listeners(\"timeout\").length;\n            // node <= 10, default listenerCount is 1, onTimeout\n            // 11 < node <= 12, default listenerCount is 2, onTimeout and emitRequestTimeout\n            // node >= 13, default listenerCount is 3, onTimeout,\n            //   onTimeout(https://github.com/nodejs/node/pull/32000/files#diff-5f7fb0850412c6be189faeddea6c5359R333)\n            //   and emitRequestTimeout\n            const timeout = getSocketTimeout(socket);\n            const req = socket._httpMessage;\n            const reqTimeoutListenerCount = req && req.listeners(\"timeout\").length || 0;\n            debug(\"%s(requests: %s, finished: %s) timeout after %sms, listeners %s, defaultTimeoutListenerCount %s, hasHttpRequest %s, HttpRequest timeoutListenerCount %s\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], timeout, listenerCount, defaultTimeoutListenerCount, !!req, reqTimeoutListenerCount);\n            if (debug.enabled) {\n                debug(\"timeout listeners: %s\", socket.listeners(\"timeout\").map((f)=>f.name).join(\", \"));\n            }\n            agent.timeoutSocketCount++;\n            const name = agent.getName(options);\n            if (agent.freeSockets[name] && agent.freeSockets[name].indexOf(socket) !== -1) {\n                // free socket timeout, destroy quietly\n                socket.destroy();\n                // Remove it from freeSockets list immediately to prevent new requests\n                // from being sent through this socket.\n                agent.removeSocket(socket, options);\n                debug(\"%s is free, destroy quietly\", socket[SOCKET_NAME]);\n            } else {\n                // if there is no any request socket timeout handler,\n                // agent need to handle socket timeout itself.\n                //\n                // custom request socket timeout handle logic must follow these rules:\n                //  1. Destroy socket first\n                //  2. Must emit socket 'agentRemove' event tell agent remove socket\n                //     from freeSockets list immediately.\n                //     Otherise you may be get 'socket hang up' error when reuse\n                //     free socket and timeout happen in the same time.\n                if (reqTimeoutListenerCount === 0) {\n                    const error = new Error(\"Socket timeout\");\n                    error.code = \"ERR_SOCKET_TIMEOUT\";\n                    error.timeout = timeout;\n                    // must manually call socket.end() or socket.destroy() to end the connection.\n                    // https://nodejs.org/dist/latest-v10.x/docs/api/net.html#net_socket_settimeout_timeout_callback\n                    socket.destroy(error);\n                    agent.removeSocket(socket, options);\n                    debug(\"%s destroy with timeout error\", socket[SOCKET_NAME]);\n                }\n            }\n        }\n        socket.on(\"timeout\", onTimeout);\n        function onError(err) {\n            const listenerCount = socket.listeners(\"error\").length;\n            debug(\"%s(requests: %s, finished: %s) error: %s, listenerCount: %s\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], err, listenerCount);\n            agent.errorSocketCount++;\n            if (listenerCount === 1) {\n                // if socket don't contain error event handler, don't catch it, emit it again\n                debug(\"%s emit uncaught error event\", socket[SOCKET_NAME]);\n                socket.removeListener(\"error\", onError);\n                socket.emit(\"error\", err);\n            }\n        }\n        socket.on(\"error\", onError);\n        function onRemove() {\n            debug(\"%s(requests: %s, finished: %s) agentRemove\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT]);\n            // We need this function for cases like HTTP 'upgrade'\n            // (defined by WebSockets) where we need to remove a socket from the\n            // pool because it'll be locked up indefinitely\n            socket.removeListener(\"close\", onClose);\n            socket.removeListener(\"error\", onError);\n            socket.removeListener(\"free\", onFree);\n            socket.removeListener(\"timeout\", onTimeout);\n            socket.removeListener(\"agentRemove\", onRemove);\n        }\n        socket.on(\"agentRemove\", onRemove);\n    }\n    agent = Agent;\n    function inspect(obj) {\n        const res = {};\n        for(const key in obj){\n            res[key] = obj[key].length;\n        }\n        return res;\n    }\n    return agent;\n}\nvar https_agent;\nvar hasRequiredHttps_agent;\nfunction requireHttps_agent() {\n    if (hasRequiredHttps_agent) return https_agent;\n    hasRequiredHttps_agent = 1;\n    const OriginalHttpsAgent = (https__WEBPACK_IMPORTED_MODULE_7___default().Agent);\n    const HttpAgent = /*@__PURE__*/ requireAgent();\n    const { INIT_SOCKET, CREATE_HTTPS_CONNECTION } = /*@__PURE__*/ requireConstants();\n    class HttpsAgent extends HttpAgent {\n        constructor(options){\n            super(options);\n            this.defaultPort = 443;\n            this.protocol = \"https:\";\n            this.maxCachedSessions = this.options.maxCachedSessions;\n            /* istanbul ignore next */ if (this.maxCachedSessions === undefined) {\n                this.maxCachedSessions = 100;\n            }\n            this._sessionCache = {\n                map: {},\n                list: []\n            };\n        }\n        createConnection(options, oncreate) {\n            const socket = this[CREATE_HTTPS_CONNECTION](options, oncreate);\n            this[INIT_SOCKET](socket, options);\n            return socket;\n        }\n    }\n    // https://github.com/nodejs/node/blob/master/lib/https.js#L89\n    HttpsAgent.prototype[CREATE_HTTPS_CONNECTION] = OriginalHttpsAgent.prototype.createConnection;\n    [\n        \"getName\",\n        \"_getSession\",\n        \"_cacheSession\",\n        // https://github.com/nodejs/node/pull/4982\n        \"_evictSession\"\n    ].forEach(function(method) {\n        /* istanbul ignore next */ if (typeof OriginalHttpsAgent.prototype[method] === \"function\") {\n            HttpsAgent.prototype[method] = OriginalHttpsAgent.prototype[method];\n        }\n    });\n    https_agent = HttpsAgent;\n    return https_agent;\n}\nvar hasRequiredAgentkeepalive;\nfunction requireAgentkeepalive() {\n    if (hasRequiredAgentkeepalive) return agentkeepalive.exports;\n    hasRequiredAgentkeepalive = 1;\n    agentkeepalive.exports = /*@__PURE__*/ requireAgent();\n    agentkeepalive.exports.HttpsAgent = /*@__PURE__*/ requireHttps_agent();\n    agentkeepalive.exports.constants = /*@__PURE__*/ requireConstants();\n    return agentkeepalive.exports;\n}\nvar agentkeepaliveExports = /*@__PURE__*/ requireAgentkeepalive();\nvar HttpKeepAliveAgent = /*@__PURE__*/ getDefaultExportFromCjs(agentkeepaliveExports);\nvar fastStableStringify$1;\nvar hasRequiredFastStableStringify;\nfunction requireFastStableStringify() {\n    if (hasRequiredFastStableStringify) return fastStableStringify$1;\n    hasRequiredFastStableStringify = 1;\n    var objToString = Object.prototype.toString;\n    var objKeys = Object.keys || function(obj) {\n        var keys = [];\n        for(var name in obj){\n            keys.push(name);\n        }\n        return keys;\n    };\n    function stringify(val, isArrayProp) {\n        var i, max, str, keys, key, propVal, toStr;\n        if (val === true) {\n            return \"true\";\n        }\n        if (val === false) {\n            return \"false\";\n        }\n        switch(typeof val){\n            case \"object\":\n                if (val === null) {\n                    return null;\n                } else if (val.toJSON && typeof val.toJSON === \"function\") {\n                    return stringify(val.toJSON(), isArrayProp);\n                } else {\n                    toStr = objToString.call(val);\n                    if (toStr === \"[object Array]\") {\n                        str = \"[\";\n                        max = val.length - 1;\n                        for(i = 0; i < max; i++){\n                            str += stringify(val[i], true) + \",\";\n                        }\n                        if (max > -1) {\n                            str += stringify(val[i], true);\n                        }\n                        return str + \"]\";\n                    } else if (toStr === \"[object Object]\") {\n                        // only object is left\n                        keys = objKeys(val).sort();\n                        max = keys.length;\n                        str = \"\";\n                        i = 0;\n                        while(i < max){\n                            key = keys[i];\n                            propVal = stringify(val[key], false);\n                            if (propVal !== undefined) {\n                                if (str) {\n                                    str += \",\";\n                                }\n                                str += JSON.stringify(key) + \":\" + propVal;\n                            }\n                            i++;\n                        }\n                        return \"{\" + str + \"}\";\n                    } else {\n                        return JSON.stringify(val);\n                    }\n                }\n            case \"function\":\n            case \"undefined\":\n                return isArrayProp ? null : undefined;\n            case \"string\":\n                return JSON.stringify(val);\n            default:\n                return isFinite(val) ? val : null;\n        }\n    }\n    fastStableStringify$1 = function(val) {\n        var returnVal = stringify(val, false);\n        if (returnVal !== undefined) {\n            return \"\" + returnVal;\n        }\n    };\n    return fastStableStringify$1;\n}\nvar fastStableStringifyExports = /*@__PURE__*/ requireFastStableStringify();\nvar fastStableStringify = /*@__PURE__*/ getDefaultExportFromCjs(fastStableStringifyExports);\nconst MINIMUM_SLOT_PER_EPOCH = 32;\n// Returns the number of trailing zeros in the binary representation of self.\nfunction trailingZeros(n) {\n    let trailingZeros = 0;\n    while(n > 1){\n        n /= 2;\n        trailingZeros++;\n    }\n    return trailingZeros;\n}\n// Returns the smallest power of two greater than or equal to n\nfunction nextPowerOfTwo(n) {\n    if (n === 0) return 1;\n    n--;\n    n |= n >> 1;\n    n |= n >> 2;\n    n |= n >> 4;\n    n |= n >> 8;\n    n |= n >> 16;\n    n |= n >> 32;\n    return n + 1;\n}\n/**\n * Epoch schedule\n * (see https://docs.solana.com/terminology#epoch)\n * Can be retrieved with the {@link Connection.getEpochSchedule} method\n */ class EpochSchedule {\n    constructor(slotsPerEpoch, leaderScheduleSlotOffset, warmup, firstNormalEpoch, firstNormalSlot){\n        /** The maximum number of slots in each epoch */ this.slotsPerEpoch = void 0;\n        /** The number of slots before beginning of an epoch to calculate a leader schedule for that epoch */ this.leaderScheduleSlotOffset = void 0;\n        /** Indicates whether epochs start short and grow */ this.warmup = void 0;\n        /** The first epoch with `slotsPerEpoch` slots */ this.firstNormalEpoch = void 0;\n        /** The first slot of `firstNormalEpoch` */ this.firstNormalSlot = void 0;\n        this.slotsPerEpoch = slotsPerEpoch;\n        this.leaderScheduleSlotOffset = leaderScheduleSlotOffset;\n        this.warmup = warmup;\n        this.firstNormalEpoch = firstNormalEpoch;\n        this.firstNormalSlot = firstNormalSlot;\n    }\n    getEpoch(slot) {\n        return this.getEpochAndSlotIndex(slot)[0];\n    }\n    getEpochAndSlotIndex(slot) {\n        if (slot < this.firstNormalSlot) {\n            const epoch = trailingZeros(nextPowerOfTwo(slot + MINIMUM_SLOT_PER_EPOCH + 1)) - trailingZeros(MINIMUM_SLOT_PER_EPOCH) - 1;\n            const epochLen = this.getSlotsInEpoch(epoch);\n            const slotIndex = slot - (epochLen - MINIMUM_SLOT_PER_EPOCH);\n            return [\n                epoch,\n                slotIndex\n            ];\n        } else {\n            const normalSlotIndex = slot - this.firstNormalSlot;\n            const normalEpochIndex = Math.floor(normalSlotIndex / this.slotsPerEpoch);\n            const epoch = this.firstNormalEpoch + normalEpochIndex;\n            const slotIndex = normalSlotIndex % this.slotsPerEpoch;\n            return [\n                epoch,\n                slotIndex\n            ];\n        }\n    }\n    getFirstSlotInEpoch(epoch) {\n        if (epoch <= this.firstNormalEpoch) {\n            return (Math.pow(2, epoch) - 1) * MINIMUM_SLOT_PER_EPOCH;\n        } else {\n            return (epoch - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot;\n        }\n    }\n    getLastSlotInEpoch(epoch) {\n        return this.getFirstSlotInEpoch(epoch) + this.getSlotsInEpoch(epoch) - 1;\n    }\n    getSlotsInEpoch(epoch) {\n        if (epoch < this.firstNormalEpoch) {\n            return Math.pow(2, epoch + trailingZeros(MINIMUM_SLOT_PER_EPOCH));\n        } else {\n            return this.slotsPerEpoch;\n        }\n    }\n}\nvar fetchImpl = typeof globalThis.fetch === \"function\" ? // The Fetch API is supported experimentally in Node 17.5+ and natively in Node 18+.\nglobalThis.fetch : // Otherwise use the polyfill.\nasync function(input, init) {\n    const processedInput = typeof input === \"string\" && input.slice(0, 2) === \"//\" ? \"https:\" + input : input;\n    return await node_fetch__WEBPACK_IMPORTED_MODULE_9__[\"default\"](processedInput, init);\n};\nclass RpcWebSocketClient extends rpc_websockets__WEBPACK_IMPORTED_MODULE_10__.CommonClient {\n    constructor(address, options, generate_request_id){\n        const webSocketFactory = (url)=>{\n            const rpc = (0,rpc_websockets__WEBPACK_IMPORTED_MODULE_10__.WebSocket)(url, {\n                autoconnect: true,\n                max_reconnects: 5,\n                reconnect: true,\n                reconnect_interval: 1000,\n                ...options\n            });\n            if (\"socket\" in rpc) {\n                this.underlyingSocket = rpc.socket;\n            } else {\n                this.underlyingSocket = rpc;\n            }\n            return rpc;\n        };\n        super(webSocketFactory, address, options, generate_request_id);\n        this.underlyingSocket = void 0;\n    }\n    call(...args) {\n        const readyState = this.underlyingSocket?.readyState;\n        if (readyState === 1 /* WebSocket.OPEN */ ) {\n            return super.call(...args);\n        }\n        return Promise.reject(new Error(\"Tried to call a JSON-RPC method `\" + args[0] + \"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was \" + readyState + \")\"));\n    }\n    notify(...args) {\n        const readyState = this.underlyingSocket?.readyState;\n        if (readyState === 1 /* WebSocket.OPEN */ ) {\n            return super.notify(...args);\n        }\n        return Promise.reject(new Error(\"Tried to send a JSON-RPC notification `\" + args[0] + \"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was \" + readyState + \")\"));\n    }\n}\n/**\n * @internal\n */ /**\n * Decode account data buffer using an AccountType\n * @internal\n */ function decodeData(type, data) {\n    let decoded;\n    try {\n        decoded = type.layout.decode(data);\n    } catch (err) {\n        throw new Error(\"invalid instruction; \" + err);\n    }\n    if (decoded.typeIndex !== type.index) {\n        throw new Error(`invalid account data; account type mismatch ${decoded.typeIndex} != ${type.index}`);\n    }\n    return decoded;\n}\n/// The serialized size of lookup table metadata\nconst LOOKUP_TABLE_META_SIZE = 56;\nclass AddressLookupTableAccount {\n    constructor(args){\n        this.key = void 0;\n        this.state = void 0;\n        this.key = args.key;\n        this.state = args.state;\n    }\n    isActive() {\n        const U64_MAX = BigInt(\"0xffffffffffffffff\");\n        return this.state.deactivationSlot === U64_MAX;\n    }\n    static deserialize(accountData) {\n        const meta = decodeData(LookupTableMetaLayout, accountData);\n        const serializedAddressesLen = accountData.length - LOOKUP_TABLE_META_SIZE;\n        assert(serializedAddressesLen >= 0, \"lookup table is invalid\");\n        assert(serializedAddressesLen % 32 === 0, \"lookup table is invalid\");\n        const numSerializedAddresses = serializedAddressesLen / 32;\n        const { addresses } = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(publicKey(), numSerializedAddresses, \"addresses\")\n        ]).decode(accountData.slice(LOOKUP_TABLE_META_SIZE));\n        return {\n            deactivationSlot: meta.deactivationSlot,\n            lastExtendedSlot: meta.lastExtendedSlot,\n            lastExtendedSlotStartIndex: meta.lastExtendedStartIndex,\n            authority: meta.authority.length !== 0 ? new PublicKey(meta.authority[0]) : undefined,\n            addresses: addresses.map((address)=>new PublicKey(address))\n        };\n    }\n}\nconst LookupTableMetaLayout = {\n    index: 1,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"typeIndex\"),\n        u64(\"deactivationSlot\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"lastExtendedSlot\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"lastExtendedStartIndex\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(),\n        // option\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(publicKey(), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(), -1), \"authority\")\n    ])\n};\nconst URL_RE = /^[^:]+:\\/\\/([^:[]+|\\[[^\\]]+\\])(:\\d+)?(.*)/i;\nfunction makeWebsocketUrl(endpoint) {\n    const matches = endpoint.match(URL_RE);\n    if (matches == null) {\n        throw TypeError(`Failed to validate endpoint URL \\`${endpoint}\\``);\n    }\n    const [_, // eslint-disable-line @typescript-eslint/no-unused-vars\n    hostish, portWithColon, rest] = matches;\n    const protocol = endpoint.startsWith(\"https:\") ? \"wss:\" : \"ws:\";\n    const startPort = portWithColon == null ? null : parseInt(portWithColon.slice(1), 10);\n    const websocketPort = // Only shift the port by +1 as a convention for ws(s) only if given endpoint\n    // is explicitly specifying the endpoint port (HTTP-based RPC), assuming\n    // we're directly trying to connect to agave-validator's ws listening port.\n    // When the endpoint omits the port, we're connecting to the protocol\n    // default ports: http(80) or https(443) and it's assumed we're behind a reverse\n    // proxy which manages WebSocket upgrade and backend port redirection.\n    startPort == null ? \"\" : `:${startPort + 1}`;\n    return `${protocol}//${hostish}${websocketPort}${rest}`;\n}\nconst PublicKeyFromString = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.coerce)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.instance)(PublicKey), (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(), (value)=>new PublicKey(value));\nconst RawAccountDataResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.tuple)([\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"base64\")\n]);\nconst BufferFromRawAccountData = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.coerce)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.instance)(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer), RawAccountDataResult, (value)=>buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value[0], \"base64\"));\n/**\n * Attempt to use a recent blockhash for up to 30 seconds\n * @internal\n */ const BLOCKHASH_CACHE_TIMEOUT_MS = 30 * 1000;\n/**\n * HACK.\n * Copied from rpc-websockets/dist/lib/client.\n * Otherwise, `yarn build` fails with:\n * https://gist.github.com/steveluscher/c057eca81d479ef705cdb53162f9971d\n */ /** @internal */ /** @internal */ /** @internal */ /** @internal */ /** @internal */ /**\n * @internal\n * Every subscription contains the args used to open the subscription with\n * the server, and a list of callers interested in notifications.\n */ /**\n * @internal\n * A subscription may be in various states of connectedness. Only when it is\n * fully connected will it have a server subscription id associated with it.\n * This id can be returned to the server to unsubscribe the client entirely.\n */ /**\n * A type that encapsulates a subscription's RPC method\n * names and notification (callback) signature.\n */ /**\n * @internal\n * Utility type that keeps tagged unions intact while omitting properties.\n */ /**\n * @internal\n * This type represents a single subscribable 'topic.' It's made up of:\n *\n * - The args used to open the subscription with the server,\n * - The state of the subscription, in terms of its connectedness, and\n * - The set of callbacks to call when the server publishes notifications\n *\n * This record gets indexed by `SubscriptionConfigHash` and is used to\n * set up subscriptions, fan out notifications, and track subscription state.\n */ /**\n * @internal\n */ /**\n * Extra contextual information for RPC responses\n */ /**\n * Options for sending transactions\n */ /**\n * Options for confirming transactions\n */ /**\n * Options for getConfirmedSignaturesForAddress2\n */ /**\n * Options for getSignaturesForAddress\n */ /**\n * RPC Response with extra contextual information\n */ /**\n * A strategy for confirming transactions that uses the last valid\n * block height for a given blockhash to check for transaction expiration.\n */ /**\n * A strategy for confirming durable nonce transactions.\n */ /**\n * Properties shared by all transaction confirmation strategies\n */ /**\n * This type represents all transaction confirmation strategies\n */ /* @internal */ function assertEndpointUrl(putativeUrl) {\n    if (/^https?:/.test(putativeUrl) === false) {\n        throw new TypeError(\"Endpoint URL must start with `http:` or `https:`.\");\n    }\n    return putativeUrl;\n}\n/** @internal */ function extractCommitmentFromConfig(commitmentOrConfig) {\n    let commitment;\n    let config;\n    if (typeof commitmentOrConfig === \"string\") {\n        commitment = commitmentOrConfig;\n    } else if (commitmentOrConfig) {\n        const { commitment: specifiedCommitment, ...specifiedConfig } = commitmentOrConfig;\n        commitment = specifiedCommitment;\n        config = specifiedConfig;\n    }\n    return {\n        commitment,\n        config\n    };\n}\n/**\n * @internal\n */ function applyDefaultMemcmpEncodingToFilters(filters) {\n    return filters.map((filter)=>\"memcmp\" in filter ? {\n            ...filter,\n            memcmp: {\n                ...filter.memcmp,\n                encoding: filter.memcmp.encoding ?? \"base58\"\n            }\n        } : filter);\n}\n/**\n * @internal\n */ function createRpcResult(result) {\n    return (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n            jsonrpc: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"2.0\"),\n            id: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n            result\n        }),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n            jsonrpc: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"2.0\"),\n            id: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n            error: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n                code: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.unknown)(),\n                message: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n                data: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.any)())\n            })\n        })\n    ]);\n}\nconst UnknownRpcResult = createRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.unknown)());\n/**\n * @internal\n */ function jsonRpcResult(schema) {\n    return (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.coerce)(createRpcResult(schema), UnknownRpcResult, (value)=>{\n        if (\"error\" in value) {\n            return value;\n        } else {\n            return {\n                ...value,\n                result: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(value.result, schema)\n            };\n        }\n    });\n}\n/**\n * @internal\n */ function jsonRpcResultAndContext(value) {\n    return jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        context: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n            slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n        }),\n        value\n    }));\n}\n/**\n * @internal\n */ function notificationResultAndContext(value) {\n    return (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        context: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n            slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n        }),\n        value\n    });\n}\n/**\n * @internal\n */ function versionedMessageFromResponse(version, response) {\n    if (version === 0) {\n        return new MessageV0({\n            header: response.header,\n            staticAccountKeys: response.accountKeys.map((accountKey)=>new PublicKey(accountKey)),\n            recentBlockhash: response.recentBlockhash,\n            compiledInstructions: response.instructions.map((ix)=>({\n                    programIdIndex: ix.programIdIndex,\n                    accountKeyIndexes: ix.accounts,\n                    data: bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(ix.data)\n                })),\n            addressTableLookups: response.addressTableLookups\n        });\n    } else {\n        return new Message(response);\n    }\n}\n/**\n * The level of commitment desired when querying state\n * <pre>\n *   'processed': Query the most recent block which has reached 1 confirmation by the connected node\n *   'confirmed': Query the most recent block which has reached 1 confirmation by the cluster\n *   'finalized': Query the most recent block which has been finalized by the cluster\n * </pre>\n */ // Deprecated as of v1.5.5\n/**\n * A subset of Commitment levels, which are at least optimistically confirmed\n * <pre>\n *   'confirmed': Query the most recent block which has reached 1 confirmation by the cluster\n *   'finalized': Query the most recent block which has been finalized by the cluster\n * </pre>\n */ /**\n * Filter for largest accounts query\n * <pre>\n *   'circulating':    Return the largest accounts that are part of the circulating supply\n *   'nonCirculating': Return the largest accounts that are not part of the circulating supply\n * </pre>\n */ /**\n * Configuration object for changing `getAccountInfo` query behavior\n */ /**\n * Configuration object for changing `getBalance` query behavior\n */ /**\n * Configuration object for changing `getBlock` query behavior\n */ /**\n * Configuration object for changing `getBlock` query behavior\n */ /**\n * Configuration object for changing `getStakeMinimumDelegation` query behavior\n */ /**\n * Configuration object for changing `getBlockHeight` query behavior\n */ /**\n * Configuration object for changing `getEpochInfo` query behavior\n */ /**\n * Configuration object for changing `getInflationReward` query behavior\n */ /**\n * Configuration object for changing `getLatestBlockhash` query behavior\n */ /**\n * Configuration object for changing `isBlockhashValid` query behavior\n */ /**\n * Configuration object for changing `getSlot` query behavior\n */ /**\n * Configuration object for changing `getSlotLeader` query behavior\n */ /**\n * Configuration object for changing `getTransaction` query behavior\n */ /**\n * Configuration object for changing `getTransaction` query behavior\n */ /**\n * Configuration object for changing `getLargestAccounts` query behavior\n */ /**\n * Configuration object for changing `getSupply` request behavior\n */ /**\n * Configuration object for changing query behavior\n */ /**\n * Information describing a cluster node\n */ /**\n * Information describing a vote account\n */ /**\n * A collection of cluster vote accounts\n */ /**\n * Network Inflation\n * (see https://docs.solana.com/implemented-proposals/ed_overview)\n */ const GetInflationGovernorResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    foundation: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    foundationTerm: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    initial: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    taper: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    terminal: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\n/**\n * The inflation reward for an epoch\n */ /**\n * Expected JSON RPC response for the \"getInflationReward\" message\n */ const GetInflationRewardResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    epoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    effectiveSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    amount: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    postBalance: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    commission: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()))\n}))));\n/**\n * Configuration object for changing `getRecentPrioritizationFees` query behavior\n */ /**\n * Expected JSON RPC response for the \"getRecentPrioritizationFees\" message\n */ const GetRecentPrioritizationFeesResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    prioritizationFee: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n}));\n/**\n * Expected JSON RPC response for the \"getInflationRate\" message\n */ const GetInflationRateResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    total: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    validator: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    foundation: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    epoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\n/**\n * Information about the current epoch\n */ const GetEpochInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    epoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    slotIndex: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    slotsInEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    absoluteSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    transactionCount: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n});\nconst GetEpochScheduleResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    slotsPerEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    leaderScheduleSlotOffset: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    warmup: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)(),\n    firstNormalEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    firstNormalSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\n/**\n * Leader schedule\n * (see https://docs.solana.com/terminology#leader-schedule)\n */ const GetLeaderScheduleResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.record)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(), (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()));\n/**\n * Transaction error or null\n */ const TransactionErrorResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({}),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()\n]));\n/**\n * Signature status for a transaction\n */ const SignatureStatusResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    err: TransactionErrorResult\n});\n/**\n * Transaction signature received notification\n */ const SignatureReceivedResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"receivedSignature\");\n/**\n * Version info for a node\n */ const VersionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    \"solana-core\": (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    \"feature-set\": (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n});\nconst ParsedInstructionStruct = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    program: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    programId: PublicKeyFromString,\n    parsed: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.unknown)()\n});\nconst PartiallyDecodedInstructionStruct = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    programId: PublicKeyFromString,\n    accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(PublicKeyFromString),\n    data: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()\n});\nconst SimulatedTransactionResponseStruct = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    err: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({}),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()\n    ])),\n    logs: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)())),\n    accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)(),\n        owner: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n        lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        data: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n        rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n    }))))),\n    unitsConsumed: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    returnData: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        programId: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n        data: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.tuple)([\n            (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n            (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"base64\")\n        ])\n    }))),\n    innerInstructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        index: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        instructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n            ParsedInstructionStruct,\n            PartiallyDecodedInstructionStruct\n        ]))\n    }))))\n}));\n/**\n * Metadata for a parsed confirmed transaction on the ledger\n *\n * @deprecated Deprecated since RPC v1.8.0. Please use {@link ParsedTransactionMeta} instead.\n */ /**\n * Collection of addresses loaded by a transaction using address table lookups\n */ /**\n * Metadata for a parsed transaction on the ledger\n */ /**\n * Metadata for a confirmed transaction on the ledger\n */ /**\n * A processed transaction from the RPC API\n */ /**\n * A processed transaction from the RPC API\n */ /**\n * A processed transaction message from the RPC API\n */ /**\n * A confirmed transaction on the ledger\n *\n * @deprecated Deprecated since RPC v1.8.0.\n */ /**\n * A partially decoded transaction instruction\n */ /**\n * A parsed transaction message account\n */ /**\n * A parsed transaction instruction\n */ /**\n * A parsed address table lookup\n */ /**\n * A parsed transaction message\n */ /**\n * A parsed transaction\n */ /**\n * A parsed and confirmed transaction on the ledger\n *\n * @deprecated Deprecated since RPC v1.8.0. Please use {@link ParsedTransactionWithMeta} instead.\n */ /**\n * A parsed transaction on the ledger with meta\n */ /**\n * A processed block fetched from the RPC API\n */ /**\n * A processed block fetched from the RPC API where the `transactionDetails` mode is `accounts`\n */ /**\n * A processed block fetched from the RPC API where the `transactionDetails` mode is `none`\n */ /**\n * A block with parsed transactions\n */ /**\n * A block with parsed transactions where the `transactionDetails` mode is `accounts`\n */ /**\n * A block with parsed transactions where the `transactionDetails` mode is `none`\n */ /**\n * A processed block fetched from the RPC API\n */ /**\n * A processed block fetched from the RPC API where the `transactionDetails` mode is `accounts`\n */ /**\n * A processed block fetched from the RPC API where the `transactionDetails` mode is `none`\n */ /**\n * A confirmed block on the ledger\n *\n * @deprecated Deprecated since RPC v1.8.0.\n */ /**\n * A Block on the ledger with signatures only\n */ /**\n * recent block production information\n */ /**\n * Expected JSON RPC response for the \"getBlockProduction\" message\n */ const BlockProductionResponseStruct = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    byIdentity: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.record)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(), (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())),\n    range: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        firstSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        lastSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n    })\n}));\n/**\n * A performance sample\n */ function createRpcClient(url, httpHeaders, customFetch, fetchMiddleware, disableRetryOnRateLimit, httpAgent) {\n    const fetch = customFetch ? customFetch : fetchImpl;\n    let agent;\n    {\n        if (httpAgent == null) {\n            {\n                const agentOptions = {\n                    // One second fewer than the Solana RPC's keepalive timeout.\n                    // Read more: https://github.com/solana-labs/solana/issues/27859#issuecomment-1340097889\n                    freeSocketTimeout: 19000,\n                    keepAlive: true,\n                    maxSockets: 25\n                };\n                if (url.startsWith(\"https:\")) {\n                    agent = new agentkeepaliveExports.HttpsAgent(agentOptions);\n                } else {\n                    agent = new HttpKeepAliveAgent(agentOptions);\n                }\n            }\n        } else {\n            if (httpAgent !== false) {\n                const isHttps = url.startsWith(\"https:\");\n                if (isHttps && !(httpAgent instanceof https__WEBPACK_IMPORTED_MODULE_7__.Agent)) {\n                    throw new Error(\"The endpoint `\" + url + \"` can only be paired with an `https.Agent`. You have, instead, supplied an \" + \"`http.Agent` through `httpAgent`.\");\n                } else if (!isHttps && httpAgent instanceof https__WEBPACK_IMPORTED_MODULE_7__.Agent) {\n                    throw new Error(\"The endpoint `\" + url + \"` can only be paired with an `http.Agent`. You have, instead, supplied an \" + \"`https.Agent` through `httpAgent`.\");\n                }\n                agent = httpAgent;\n            }\n        }\n    }\n    let fetchWithMiddleware;\n    if (fetchMiddleware) {\n        fetchWithMiddleware = async (info, init)=>{\n            const modifiedFetchArgs = await new Promise((resolve, reject)=>{\n                try {\n                    fetchMiddleware(info, init, (modifiedInfo, modifiedInit)=>resolve([\n                            modifiedInfo,\n                            modifiedInit\n                        ]));\n                } catch (error) {\n                    reject(error);\n                }\n            });\n            return await fetch(...modifiedFetchArgs);\n        };\n    }\n    const clientBrowser = new (jayson_lib_client_browser__WEBPACK_IMPORTED_MODULE_8___default())(async (request, callback)=>{\n        const options = {\n            method: \"POST\",\n            body: request,\n            agent,\n            headers: Object.assign({\n                \"Content-Type\": \"application/json\"\n            }, httpHeaders || {}, COMMON_HTTP_HEADERS)\n        };\n        try {\n            let too_many_requests_retries = 5;\n            let res;\n            let waitTime = 500;\n            for(;;){\n                if (fetchWithMiddleware) {\n                    res = await fetchWithMiddleware(url, options);\n                } else {\n                    res = await fetch(url, options);\n                }\n                if (res.status !== 429 /* Too many requests */ ) {\n                    break;\n                }\n                if (disableRetryOnRateLimit === true) {\n                    break;\n                }\n                too_many_requests_retries -= 1;\n                if (too_many_requests_retries === 0) {\n                    break;\n                }\n                console.error(`Server responded with ${res.status} ${res.statusText}.  Retrying after ${waitTime}ms delay...`);\n                await sleep(waitTime);\n                waitTime *= 2;\n            }\n            const text = await res.text();\n            if (res.ok) {\n                callback(null, text);\n            } else {\n                callback(new Error(`${res.status} ${res.statusText}: ${text}`));\n            }\n        } catch (err) {\n            if (err instanceof Error) callback(err);\n        }\n    }, {});\n    return clientBrowser;\n}\nfunction createRpcRequest(client) {\n    return (method, args)=>{\n        return new Promise((resolve, reject)=>{\n            client.request(method, args, (err, response)=>{\n                if (err) {\n                    reject(err);\n                    return;\n                }\n                resolve(response);\n            });\n        });\n    };\n}\nfunction createRpcBatchRequest(client) {\n    return (requests)=>{\n        return new Promise((resolve, reject)=>{\n            // Do nothing if requests is empty\n            if (requests.length === 0) resolve([]);\n            const batch = requests.map((params)=>{\n                return client.request(params.methodName, params.args);\n            });\n            client.request(batch, (err, response)=>{\n                if (err) {\n                    reject(err);\n                    return;\n                }\n                resolve(response);\n            });\n        });\n    };\n}\n/**\n * Expected JSON RPC response for the \"getInflationGovernor\" message\n */ const GetInflationGovernorRpcResult = jsonRpcResult(GetInflationGovernorResult);\n/**\n * Expected JSON RPC response for the \"getInflationRate\" message\n */ const GetInflationRateRpcResult = jsonRpcResult(GetInflationRateResult);\n/**\n * Expected JSON RPC response for the \"getRecentPrioritizationFees\" message\n */ const GetRecentPrioritizationFeesRpcResult = jsonRpcResult(GetRecentPrioritizationFeesResult);\n/**\n * Expected JSON RPC response for the \"getEpochInfo\" message\n */ const GetEpochInfoRpcResult = jsonRpcResult(GetEpochInfoResult);\n/**\n * Expected JSON RPC response for the \"getEpochSchedule\" message\n */ const GetEpochScheduleRpcResult = jsonRpcResult(GetEpochScheduleResult);\n/**\n * Expected JSON RPC response for the \"getLeaderSchedule\" message\n */ const GetLeaderScheduleRpcResult = jsonRpcResult(GetLeaderScheduleResult);\n/**\n * Expected JSON RPC response for the \"minimumLedgerSlot\" and \"getFirstAvailableBlock\" messages\n */ const SlotRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)());\n/**\n * Supply\n */ /**\n * Expected JSON RPC response for the \"getSupply\" message\n */ const GetSupplyRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    total: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    circulating: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    nonCirculating: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    nonCirculatingAccounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(PublicKeyFromString)\n}));\n/**\n * Token amount object which returns a token amount in different formats\n * for various client use cases.\n */ /**\n * Expected JSON RPC structure for token amounts\n */ const TokenAmountResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    amount: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    uiAmount: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    decimals: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    uiAmountString: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)())\n});\n/**\n * Token address and balance.\n */ /**\n * Expected JSON RPC response for the \"getTokenLargestAccounts\" message\n */ const GetTokenLargestAccountsResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    address: PublicKeyFromString,\n    amount: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    uiAmount: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    decimals: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    uiAmountString: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)())\n})));\n/**\n * Expected JSON RPC response for the \"getTokenAccountsByOwner\" message\n */ const GetTokenAccountsByOwner = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    pubkey: PublicKeyFromString,\n    account: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)(),\n        owner: PublicKeyFromString,\n        lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        data: BufferFromRawAccountData,\n        rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n    })\n})));\nconst ParsedAccountDataResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    program: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    parsed: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.unknown)(),\n    space: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\n/**\n * Expected JSON RPC response for the \"getTokenAccountsByOwner\" message with parsed data\n */ const GetParsedTokenAccountsByOwner = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    pubkey: PublicKeyFromString,\n    account: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)(),\n        owner: PublicKeyFromString,\n        lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        data: ParsedAccountDataResult,\n        rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n    })\n})));\n/**\n * Pair of an account address and its balance\n */ /**\n * Expected JSON RPC response for the \"getLargestAccounts\" message\n */ const GetLargestAccountsRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    address: PublicKeyFromString\n})));\n/**\n * @internal\n */ const AccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)(),\n    owner: PublicKeyFromString,\n    lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    data: BufferFromRawAccountData,\n    rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\n/**\n * @internal\n */ const KeyedAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    pubkey: PublicKeyFromString,\n    account: AccountInfoResult\n});\nconst ParsedOrRawAccountData = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.coerce)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.instance)(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer),\n    ParsedAccountDataResult\n]), (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n    RawAccountDataResult,\n    ParsedAccountDataResult\n]), (value)=>{\n    if (Array.isArray(value)) {\n        return (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(value, BufferFromRawAccountData);\n    } else {\n        return value;\n    }\n});\n/**\n * @internal\n */ const ParsedAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)(),\n    owner: PublicKeyFromString,\n    lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    data: ParsedOrRawAccountData,\n    rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\nconst KeyedParsedAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    pubkey: PublicKeyFromString,\n    account: ParsedAccountInfoResult\n});\n/**\n * @internal\n */ const StakeActivationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    state: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"active\"),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"inactive\"),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"activating\"),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"deactivating\")\n    ]),\n    active: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    inactive: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\n/**\n * Expected JSON RPC response for the \"getConfirmedSignaturesForAddress2\" message\n */ const GetConfirmedSignaturesForAddress2RpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    signature: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    err: TransactionErrorResult,\n    memo: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()))\n})));\n/**\n * Expected JSON RPC response for the \"getSignaturesForAddress\" message\n */ const GetSignaturesForAddressRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    signature: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    err: TransactionErrorResult,\n    memo: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()))\n})));\n/***\n * Expected JSON RPC response for the \"accountNotification\" message\n */ const AccountNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    result: notificationResultAndContext(AccountInfoResult)\n});\n/**\n * @internal\n */ const ProgramAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    pubkey: PublicKeyFromString,\n    account: AccountInfoResult\n});\n/***\n * Expected JSON RPC response for the \"programNotification\" message\n */ const ProgramAccountNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    result: notificationResultAndContext(ProgramAccountInfoResult)\n});\n/**\n * @internal\n */ const SlotInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    parent: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    root: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\n/**\n * Expected JSON RPC response for the \"slotNotification\" message\n */ const SlotNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    result: SlotInfoResult\n});\n/**\n * Slot updates which can be used for tracking the live progress of a cluster.\n * - `\"firstShredReceived\"`: connected node received the first shred of a block.\n * Indicates that a new block that is being produced.\n * - `\"completed\"`: connected node has received all shreds of a block. Indicates\n * a block was recently produced.\n * - `\"optimisticConfirmation\"`: block was optimistically confirmed by the\n * cluster. It is not guaranteed that an optimistic confirmation notification\n * will be sent for every finalized blocks.\n * - `\"root\"`: the connected node rooted this block.\n * - `\"createdBank\"`: the connected node has started validating this block.\n * - `\"frozen\"`: the connected node has validated this block.\n * - `\"dead\"`: the connected node failed to validate this block.\n */ /**\n * @internal\n */ const SlotUpdateResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        type: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n            (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"firstShredReceived\"),\n            (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"completed\"),\n            (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"optimisticConfirmation\"),\n            (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"root\")\n        ]),\n        slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        timestamp: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n    }),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        type: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"createdBank\"),\n        parent: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        timestamp: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n    }),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        type: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"frozen\"),\n        slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        timestamp: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        stats: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n            numTransactionEntries: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n            numSuccessfulTransactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n            numFailedTransactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n            maxTransactionsPerEntry: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n        })\n    }),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        type: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"dead\"),\n        slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        timestamp: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        err: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()\n    })\n]);\n/**\n * Expected JSON RPC response for the \"slotsUpdatesNotification\" message\n */ const SlotUpdateNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    result: SlotUpdateResult\n});\n/**\n * Expected JSON RPC response for the \"signatureNotification\" message\n */ const SignatureNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    result: notificationResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n        SignatureStatusResult,\n        SignatureReceivedResult\n    ]))\n});\n/**\n * Expected JSON RPC response for the \"rootNotification\" message\n */ const RootNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    result: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\nconst ContactInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    pubkey: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    gossip: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    tpu: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    rpc: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    version: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)())\n});\nconst VoteAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    votePubkey: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    nodePubkey: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    activatedStake: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    epochVoteAccount: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)(),\n    epochCredits: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.tuple)([\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n    ])),\n    commission: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    lastVote: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    rootSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n});\n/**\n * Expected JSON RPC response for the \"getVoteAccounts\" message\n */ const GetVoteAccounts = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    current: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(VoteAccountInfoResult),\n    delinquent: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(VoteAccountInfoResult)\n}));\nconst ConfirmationStatus = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"processed\"),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"confirmed\"),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"finalized\")\n]);\nconst SignatureStatusResponse = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    confirmations: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    err: TransactionErrorResult,\n    confirmationStatus: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)(ConfirmationStatus)\n});\n/**\n * Expected JSON RPC response for the \"getSignatureStatuses\" message\n */ const GetSignatureStatusesRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(SignatureStatusResponse)));\n/**\n * Expected JSON RPC response for the \"getMinimumBalanceForRentExemption\" message\n */ const GetMinimumBalanceForRentExemptionRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)());\nconst AddressTableLookupStruct = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    accountKey: PublicKeyFromString,\n    writableIndexes: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    readonlyIndexes: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n});\nconst ConfirmedTransactionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    signatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    message: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        accountKeys: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n        header: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n            numRequiredSignatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n            numReadonlySignedAccounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n            numReadonlyUnsignedAccounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n        }),\n        instructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n            accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n            data: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n            programIdIndex: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n        })),\n        recentBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n        addressTableLookups: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(AddressTableLookupStruct))\n    })\n});\nconst AnnotatedAccountKey = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    pubkey: PublicKeyFromString,\n    signer: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)(),\n    writable: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)(),\n    source: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"transaction\"),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"lookupTable\")\n    ]))\n});\nconst ConfirmedTransactionAccountsModeResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    accountKeys: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(AnnotatedAccountKey),\n    signatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)())\n});\nconst ParsedInstructionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    parsed: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.unknown)(),\n    program: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    programId: PublicKeyFromString\n});\nconst RawInstructionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(PublicKeyFromString),\n    data: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    programId: PublicKeyFromString\n});\nconst InstructionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n    RawInstructionResult,\n    ParsedInstructionResult\n]);\nconst UnknownInstructionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        parsed: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.unknown)(),\n        program: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n        programId: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()\n    }),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n        data: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n        programId: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()\n    })\n]);\nconst ParsedOrRawInstruction = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.coerce)(InstructionResult, UnknownInstructionResult, (value)=>{\n    if (\"accounts\" in value) {\n        return (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(value, RawInstructionResult);\n    } else {\n        return (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(value, ParsedInstructionResult);\n    }\n});\n/**\n * @internal\n */ const ParsedConfirmedTransactionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    signatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    message: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        accountKeys: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(AnnotatedAccountKey),\n        instructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(ParsedOrRawInstruction),\n        recentBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n        addressTableLookups: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(AddressTableLookupStruct)))\n    })\n});\nconst TokenBalanceResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    accountIndex: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    mint: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    owner: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    programId: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    uiTokenAmount: TokenAmountResult\n});\nconst LoadedAddressesResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    writable: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(PublicKeyFromString),\n    readonly: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(PublicKeyFromString)\n});\n/**\n * @internal\n */ const ConfirmedTransactionMetaResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    err: TransactionErrorResult,\n    fee: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    innerInstructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        index: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        instructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n            accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n            data: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n            programIdIndex: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n        }))\n    })))),\n    preBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    postBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    logMessages: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()))),\n    preTokenBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(TokenBalanceResult))),\n    postTokenBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(TokenBalanceResult))),\n    loadedAddresses: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)(LoadedAddressesResult),\n    computeUnitsConsumed: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    costUnits: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n});\n/**\n * @internal\n */ const ParsedConfirmedTransactionMetaResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    err: TransactionErrorResult,\n    fee: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    innerInstructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        index: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n        instructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(ParsedOrRawInstruction)\n    })))),\n    preBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    postBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    logMessages: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()))),\n    preTokenBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(TokenBalanceResult))),\n    postTokenBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(TokenBalanceResult))),\n    loadedAddresses: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)(LoadedAddressesResult),\n    computeUnitsConsumed: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    costUnits: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n});\nconst TransactionVersionStruct = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.union)([\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(0),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.literal)(\"legacy\")\n]);\n/** @internal */ const RewardsResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    pubkey: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    postBalance: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    rewardType: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    commission: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()))\n});\n/**\n * Expected JSON RPC response for the \"getBlock\" message\n */ const GetBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        transaction: ConfirmedTransactionResult,\n        meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(ConfirmedTransactionMetaResult),\n        version: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)(TransactionVersionStruct)\n    })),\n    rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(RewardsResult)),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n})));\n/**\n * Expected JSON RPC response for the \"getBlock\" message when `transactionDetails` is `none`\n */ const GetNoneModeBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(RewardsResult)),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n})));\n/**\n * Expected JSON RPC response for the \"getBlock\" message when `transactionDetails` is `accounts`\n */ const GetAccountsModeBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        transaction: ConfirmedTransactionAccountsModeResult,\n        meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(ConfirmedTransactionMetaResult),\n        version: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)(TransactionVersionStruct)\n    })),\n    rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(RewardsResult)),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n})));\n/**\n * Expected parsed JSON RPC response for the \"getBlock\" message\n */ const GetParsedBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        transaction: ParsedConfirmedTransactionResult,\n        meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(ParsedConfirmedTransactionMetaResult),\n        version: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)(TransactionVersionStruct)\n    })),\n    rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(RewardsResult)),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n})));\n/**\n * Expected parsed JSON RPC response for the \"getBlock\" message  when `transactionDetails` is `accounts`\n */ const GetParsedAccountsModeBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        transaction: ConfirmedTransactionAccountsModeResult,\n        meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(ParsedConfirmedTransactionMetaResult),\n        version: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)(TransactionVersionStruct)\n    })),\n    rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(RewardsResult)),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n})));\n/**\n * Expected parsed JSON RPC response for the \"getBlock\" message  when `transactionDetails` is `none`\n */ const GetParsedNoneModeBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(RewardsResult)),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()),\n    blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n})));\n/**\n * Expected JSON RPC response for the \"getConfirmedBlock\" message\n *\n * @deprecated Deprecated since RPC v1.8.0. Please use {@link GetBlockRpcResult} instead.\n */ const GetConfirmedBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        transaction: ConfirmedTransactionResult,\n        meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(ConfirmedTransactionMetaResult)\n    })),\n    rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(RewardsResult)),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n})));\n/**\n * Expected JSON RPC response for the \"getBlock\" message\n */ const GetBlockSignaturesRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    signatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())\n})));\n/**\n * Expected JSON RPC response for the \"getTransaction\" message\n */ const GetTransactionRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(ConfirmedTransactionMetaResult),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())),\n    transaction: ConfirmedTransactionResult,\n    version: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)(TransactionVersionStruct)\n})));\n/**\n * Expected parsed JSON RPC response for the \"getTransaction\" message\n */ const GetParsedTransactionRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    transaction: ParsedConfirmedTransactionResult,\n    meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(ParsedConfirmedTransactionMetaResult),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())),\n    version: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)(TransactionVersionStruct)\n})));\n/**\n * Expected JSON RPC response for the \"getLatestBlockhash\" message\n */ const GetLatestBlockhashRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    lastValidBlockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n}));\n/**\n * Expected JSON RPC response for the \"isBlockhashValid\" message\n */ const IsBlockhashValidRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.boolean)());\nconst PerfSampleResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    numTransactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    numSlots: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)(),\n    samplePeriodSecs: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\n/*\n * Expected JSON RPC response for \"getRecentPerformanceSamples\" message\n */ const GetRecentPerformanceSamplesRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(PerfSampleResult));\n/**\n * Expected JSON RPC response for the \"getFeeCalculatorForBlockhash\" message\n */ const GetFeeCalculatorRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    feeCalculator: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n        lamportsPerSignature: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n    })\n})));\n/**\n * Expected JSON RPC response for the \"requestAirdrop\" message\n */ const RequestAirdropRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)());\n/**\n * Expected JSON RPC response for the \"sendTransaction\" message\n */ const SendTransactionRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)());\n/**\n * Information about the latest slot being processed by a node\n */ /**\n * Parsed account data\n */ /**\n * Stake Activation data\n */ /**\n * Data slice argument for getProgramAccounts\n */ /**\n * Memory comparison filter for getProgramAccounts\n */ /**\n * Data size comparison filter for getProgramAccounts\n */ /**\n * A filter object for getProgramAccounts\n */ /**\n * Configuration object for getProgramAccounts requests\n */ /**\n * Configuration object for getParsedProgramAccounts\n */ /**\n * Configuration object for getMultipleAccounts\n */ /**\n * Configuration object for `getStakeActivation`\n */ /**\n * Configuration object for `getStakeActivation`\n */ /**\n * Configuration object for `getStakeActivation`\n */ /**\n * Configuration object for `getNonce`\n */ /**\n * Configuration object for `getNonceAndContext`\n */ /**\n * Information describing an account\n */ /**\n * Account information identified by pubkey\n */ /**\n * Callback function for account change notifications\n */ /**\n * Callback function for program account change notifications\n */ /**\n * Callback function for slot change notifications\n */ /**\n * Callback function for slot update notifications\n */ /**\n * Callback function for signature status notifications\n */ /**\n * Signature status notification with transaction result\n */ /**\n * Signature received notification\n */ /**\n * Callback function for signature notifications\n */ /**\n * Signature subscription options\n */ /**\n * Callback function for root change notifications\n */ /**\n * @internal\n */ const LogsResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    err: TransactionErrorResult,\n    logs: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    signature: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()\n});\n/**\n * Logs result.\n */ /**\n * Expected JSON RPC response for the \"logsNotification\" message.\n */ const LogsNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    result: notificationResultAndContext(LogsResult),\n    subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()\n});\n/**\n * Filter for log subscriptions.\n */ /**\n * Callback function for log notifications.\n */ /**\n * Signature result\n */ /**\n * Transaction error\n */ /**\n * Transaction confirmation status\n * <pre>\n *   'processed': Transaction landed in a block which has reached 1 confirmation by the connected node\n *   'confirmed': Transaction landed in a block which has reached 1 confirmation by the cluster\n *   'finalized': Transaction landed in a block which has been finalized by the cluster\n * </pre>\n */ /**\n * Signature status\n */ /**\n * A confirmed signature with its status\n */ /**\n * An object defining headers to be passed to the RPC server\n */ /**\n * The type of the JavaScript `fetch()` API\n */ /**\n * A callback used to augment the outgoing HTTP request\n */ /**\n * Configuration for instantiating a Connection\n */ /** @internal */ const COMMON_HTTP_HEADERS = {\n    \"solana-client\": `js/${\"1.0.0-maintenance\"}`\n};\n/**\n * A connection to a fullnode JSON RPC endpoint\n */ class Connection {\n    /**\n   * Establish a JSON RPC connection\n   *\n   * @param endpoint URL to the fullnode JSON RPC endpoint\n   * @param commitmentOrConfig optional default commitment level or optional ConnectionConfig configuration object\n   */ constructor(endpoint, _commitmentOrConfig){\n        /** @internal */ this._commitment = void 0;\n        /** @internal */ this._confirmTransactionInitialTimeout = void 0;\n        /** @internal */ this._rpcEndpoint = void 0;\n        /** @internal */ this._rpcWsEndpoint = void 0;\n        /** @internal */ this._rpcClient = void 0;\n        /** @internal */ this._rpcRequest = void 0;\n        /** @internal */ this._rpcBatchRequest = void 0;\n        /** @internal */ this._rpcWebSocket = void 0;\n        /** @internal */ this._rpcWebSocketConnected = false;\n        /** @internal */ this._rpcWebSocketHeartbeat = null;\n        /** @internal */ this._rpcWebSocketIdleTimeout = null;\n        /** @internal\n     * A number that we increment every time an active connection closes.\n     * Used to determine whether the same socket connection that was open\n     * when an async operation started is the same one that's active when\n     * its continuation fires.\n     *\n     */ this._rpcWebSocketGeneration = 0;\n        /** @internal */ this._disableBlockhashCaching = false;\n        /** @internal */ this._pollingBlockhash = false;\n        /** @internal */ this._blockhashInfo = {\n            latestBlockhash: null,\n            lastFetch: 0,\n            transactionSignatures: [],\n            simulatedSignatures: []\n        };\n        /** @internal */ this._nextClientSubscriptionId = 0;\n        /** @internal */ this._subscriptionDisposeFunctionsByClientSubscriptionId = {};\n        /** @internal */ this._subscriptionHashByClientSubscriptionId = {};\n        /** @internal */ this._subscriptionStateChangeCallbacksByHash = {};\n        /** @internal */ this._subscriptionCallbacksByServerSubscriptionId = {};\n        /** @internal */ this._subscriptionsByHash = {};\n        /**\n     * Special case.\n     * After a signature is processed, RPCs automatically dispose of the\n     * subscription on the server side. We need to track which of these\n     * subscriptions have been disposed in such a way, so that we know\n     * whether the client is dealing with a not-yet-processed signature\n     * (in which case we must tear down the server subscription) or an\n     * already-processed signature (in which case the client can simply\n     * clear out the subscription locally without telling the server).\n     *\n     * NOTE: There is a proposal to eliminate this special case, here:\n     * https://github.com/solana-labs/solana/issues/18892\n     */ /** @internal */ this._subscriptionsAutoDisposedByRpc = new Set();\n        /*\n     * Returns the current block height of the node\n     */ this.getBlockHeight = (()=>{\n            const requestPromises = {};\n            return async (commitmentOrConfig)=>{\n                const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n                const args = this._buildArgs([], commitment, undefined /* encoding */ , config);\n                const requestHash = fastStableStringify(args);\n                requestPromises[requestHash] = requestPromises[requestHash] ?? (async ()=>{\n                    try {\n                        const unsafeRes = await this._rpcRequest(\"getBlockHeight\", args);\n                        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()));\n                        if (\"error\" in res) {\n                            throw new SolanaJSONRPCError(res.error, \"failed to get block height information\");\n                        }\n                        return res.result;\n                    } finally{\n                        delete requestPromises[requestHash];\n                    }\n                })();\n                return await requestPromises[requestHash];\n            };\n        })();\n        let wsEndpoint;\n        let httpHeaders;\n        let fetch;\n        let fetchMiddleware;\n        let disableRetryOnRateLimit;\n        let httpAgent;\n        if (_commitmentOrConfig && typeof _commitmentOrConfig === \"string\") {\n            this._commitment = _commitmentOrConfig;\n        } else if (_commitmentOrConfig) {\n            this._commitment = _commitmentOrConfig.commitment;\n            this._confirmTransactionInitialTimeout = _commitmentOrConfig.confirmTransactionInitialTimeout;\n            wsEndpoint = _commitmentOrConfig.wsEndpoint;\n            httpHeaders = _commitmentOrConfig.httpHeaders;\n            fetch = _commitmentOrConfig.fetch;\n            fetchMiddleware = _commitmentOrConfig.fetchMiddleware;\n            disableRetryOnRateLimit = _commitmentOrConfig.disableRetryOnRateLimit;\n            httpAgent = _commitmentOrConfig.httpAgent;\n        }\n        this._rpcEndpoint = assertEndpointUrl(endpoint);\n        this._rpcWsEndpoint = wsEndpoint || makeWebsocketUrl(endpoint);\n        this._rpcClient = createRpcClient(endpoint, httpHeaders, fetch, fetchMiddleware, disableRetryOnRateLimit, httpAgent);\n        this._rpcRequest = createRpcRequest(this._rpcClient);\n        this._rpcBatchRequest = createRpcBatchRequest(this._rpcClient);\n        this._rpcWebSocket = new RpcWebSocketClient(this._rpcWsEndpoint, {\n            autoconnect: false,\n            max_reconnects: Infinity\n        });\n        this._rpcWebSocket.on(\"open\", this._wsOnOpen.bind(this));\n        this._rpcWebSocket.on(\"error\", this._wsOnError.bind(this));\n        this._rpcWebSocket.on(\"close\", this._wsOnClose.bind(this));\n        this._rpcWebSocket.on(\"accountNotification\", this._wsOnAccountNotification.bind(this));\n        this._rpcWebSocket.on(\"programNotification\", this._wsOnProgramAccountNotification.bind(this));\n        this._rpcWebSocket.on(\"slotNotification\", this._wsOnSlotNotification.bind(this));\n        this._rpcWebSocket.on(\"slotsUpdatesNotification\", this._wsOnSlotUpdatesNotification.bind(this));\n        this._rpcWebSocket.on(\"signatureNotification\", this._wsOnSignatureNotification.bind(this));\n        this._rpcWebSocket.on(\"rootNotification\", this._wsOnRootNotification.bind(this));\n        this._rpcWebSocket.on(\"logsNotification\", this._wsOnLogsNotification.bind(this));\n    }\n    /**\n   * The default commitment used for requests\n   */ get commitment() {\n        return this._commitment;\n    }\n    /**\n   * The RPC endpoint\n   */ get rpcEndpoint() {\n        return this._rpcEndpoint;\n    }\n    /**\n   * Fetch the balance for the specified public key, return with context\n   */ async getBalanceAndContext(publicKey, commitmentOrConfig) {\n        /** @internal */ const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([\n            publicKey.toBase58()\n        ], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getBalance\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get balance for ${publicKey.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the balance for the specified public key\n   */ async getBalance(publicKey, commitmentOrConfig) {\n        return await this.getBalanceAndContext(publicKey, commitmentOrConfig).then((x)=>x.value).catch((e)=>{\n            throw new Error(\"failed to get balance of account \" + publicKey.toBase58() + \": \" + e);\n        });\n    }\n    /**\n   * Fetch the estimated production time of a block\n   */ async getBlockTime(slot) {\n        const unsafeRes = await this._rpcRequest(\"getBlockTime\", [\n            slot\n        ]);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get block time for slot ${slot}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the lowest slot that the node has information about in its ledger.\n   * This value may increase over time if the node is configured to purge older ledger data\n   */ async getMinimumLedgerSlot() {\n        const unsafeRes = await this._rpcRequest(\"minimumLedgerSlot\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get minimum ledger slot\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the slot of the lowest confirmed block that has not been purged from the ledger\n   */ async getFirstAvailableBlock() {\n        const unsafeRes = await this._rpcRequest(\"getFirstAvailableBlock\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, SlotRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get first available block\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch information about the current supply\n   */ async getSupply(config) {\n        let configArg = {};\n        if (typeof config === \"string\") {\n            configArg = {\n                commitment: config\n            };\n        } else if (config) {\n            configArg = {\n                ...config,\n                commitment: config && config.commitment || this.commitment\n            };\n        } else {\n            configArg = {\n                commitment: this.commitment\n            };\n        }\n        const unsafeRes = await this._rpcRequest(\"getSupply\", [\n            configArg\n        ]);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetSupplyRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get supply\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current supply of a token mint\n   */ async getTokenSupply(tokenMintAddress, commitment) {\n        const args = this._buildArgs([\n            tokenMintAddress.toBase58()\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getTokenSupply\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get token supply\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current balance of a token account\n   */ async getTokenAccountBalance(tokenAddress, commitment) {\n        const args = this._buildArgs([\n            tokenAddress.toBase58()\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getTokenAccountBalance\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get token account balance\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch all the token accounts owned by the specified account\n   *\n   * @return {Promise<RpcResponseAndContext<GetProgramAccountsResponse>}\n   */ async getTokenAccountsByOwner(ownerAddress, filter, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        let _args = [\n            ownerAddress.toBase58()\n        ];\n        if (\"mint\" in filter) {\n            _args.push({\n                mint: filter.mint.toBase58()\n            });\n        } else {\n            _args.push({\n                programId: filter.programId.toBase58()\n            });\n        }\n        const args = this._buildArgs(_args, commitment, \"base64\", config);\n        const unsafeRes = await this._rpcRequest(\"getTokenAccountsByOwner\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetTokenAccountsByOwner);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch parsed token accounts owned by the specified account\n   *\n   * @return {Promise<RpcResponseAndContext<Array<{pubkey: PublicKey, account: AccountInfo<ParsedAccountData>}>>>}\n   */ async getParsedTokenAccountsByOwner(ownerAddress, filter, commitment) {\n        let _args = [\n            ownerAddress.toBase58()\n        ];\n        if (\"mint\" in filter) {\n            _args.push({\n                mint: filter.mint.toBase58()\n            });\n        } else {\n            _args.push({\n                programId: filter.programId.toBase58()\n            });\n        }\n        const args = this._buildArgs(_args, commitment, \"jsonParsed\");\n        const unsafeRes = await this._rpcRequest(\"getTokenAccountsByOwner\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetParsedTokenAccountsByOwner);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the 20 largest accounts with their current balances\n   */ async getLargestAccounts(config) {\n        const arg = {\n            ...config,\n            commitment: config && config.commitment || this.commitment\n        };\n        const args = arg.filter || arg.commitment ? [\n            arg\n        ] : [];\n        const unsafeRes = await this._rpcRequest(\"getLargestAccounts\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetLargestAccountsRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get largest accounts\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the 20 largest token accounts with their current balances\n   * for a given mint.\n   */ async getTokenLargestAccounts(mintAddress, commitment) {\n        const args = this._buildArgs([\n            mintAddress.toBase58()\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getTokenLargestAccounts\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetTokenLargestAccountsResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get token largest accounts\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch all the account info for the specified public key, return with context\n   */ async getAccountInfoAndContext(publicKey, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([\n            publicKey.toBase58()\n        ], commitment, \"base64\", config);\n        const unsafeRes = await this._rpcRequest(\"getAccountInfo\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(AccountInfoResult)));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get info about account ${publicKey.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch parsed account info for the specified public key\n   */ async getParsedAccountInfo(publicKey, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([\n            publicKey.toBase58()\n        ], commitment, \"jsonParsed\", config);\n        const unsafeRes = await this._rpcRequest(\"getAccountInfo\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(ParsedAccountInfoResult)));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get info about account ${publicKey.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch all the account info for the specified public key\n   */ async getAccountInfo(publicKey, commitmentOrConfig) {\n        try {\n            const res = await this.getAccountInfoAndContext(publicKey, commitmentOrConfig);\n            return res.value;\n        } catch (e) {\n            throw new Error(\"failed to get info about account \" + publicKey.toBase58() + \": \" + e);\n        }\n    }\n    /**\n   * Fetch all the account info for multiple accounts specified by an array of public keys, return with context\n   */ async getMultipleParsedAccounts(publicKeys, rawConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(rawConfig);\n        const keys = publicKeys.map((key)=>key.toBase58());\n        const args = this._buildArgs([\n            keys\n        ], commitment, \"jsonParsed\", config);\n        const unsafeRes = await this._rpcRequest(\"getMultipleAccounts\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(ParsedAccountInfoResult))));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get info for accounts ${keys}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch all the account info for multiple accounts specified by an array of public keys, return with context\n   */ async getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const keys = publicKeys.map((key)=>key.toBase58());\n        const args = this._buildArgs([\n            keys\n        ], commitment, \"base64\", config);\n        const unsafeRes = await this._rpcRequest(\"getMultipleAccounts\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)(AccountInfoResult))));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get info for accounts ${keys}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch all the account info for multiple accounts specified by an array of public keys\n   */ async getMultipleAccountsInfo(publicKeys, commitmentOrConfig) {\n        const res = await this.getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig);\n        return res.value;\n    }\n    /**\n   * Returns epoch activation information for a stake account that has been delegated\n   *\n   * @deprecated Deprecated since RPC v1.18; will be removed in a future version.\n   */ async getStakeActivation(publicKey, commitmentOrConfig, epoch) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([\n            publicKey.toBase58()\n        ], commitment, undefined /* encoding */ , {\n            ...config,\n            epoch: epoch != null ? epoch : config?.epoch\n        });\n        const unsafeRes = await this._rpcRequest(\"getStakeActivation\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult(StakeActivationResult));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get Stake Activation ${publicKey.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch all the accounts owned by the specified program id\n   *\n   * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer>}>>}\n   */ // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    async getProgramAccounts(programId, configOrCommitment) {\n        const { commitment, config } = extractCommitmentFromConfig(configOrCommitment);\n        const { encoding, ...configWithoutEncoding } = config || {};\n        const args = this._buildArgs([\n            programId.toBase58()\n        ], commitment, encoding || \"base64\", {\n            ...configWithoutEncoding,\n            ...configWithoutEncoding.filters ? {\n                filters: applyDefaultMemcmpEncodingToFilters(configWithoutEncoding.filters)\n            } : null\n        });\n        const unsafeRes = await this._rpcRequest(\"getProgramAccounts\", args);\n        const baseSchema = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(KeyedAccountInfoResult);\n        const res = configWithoutEncoding.withContext === true ? (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext(baseSchema)) : (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult(baseSchema));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch and parse all the accounts owned by the specified program id\n   *\n   * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer | ParsedAccountData>}>>}\n   */ async getParsedProgramAccounts(programId, configOrCommitment) {\n        const { commitment, config } = extractCommitmentFromConfig(configOrCommitment);\n        const args = this._buildArgs([\n            programId.toBase58()\n        ], commitment, \"jsonParsed\", config);\n        const unsafeRes = await this._rpcRequest(\"getProgramAccounts\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(KeyedParsedAccountInfoResult)));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);\n        }\n        return res.result;\n    }\n    /** @deprecated Instead, call `confirmTransaction` and pass in {@link TransactionConfirmationStrategy} */ // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    async confirmTransaction(strategy, commitment) {\n        let rawSignature;\n        if (typeof strategy == \"string\") {\n            rawSignature = strategy;\n        } else {\n            const config = strategy;\n            if (config.abortSignal?.aborted) {\n                return Promise.reject(config.abortSignal.reason);\n            }\n            rawSignature = config.signature;\n        }\n        let decodedSignature;\n        try {\n            decodedSignature = bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(rawSignature);\n        } catch (err) {\n            throw new Error(\"signature must be base58 encoded: \" + rawSignature);\n        }\n        assert(decodedSignature.length === 64, \"signature has invalid length\");\n        if (typeof strategy === \"string\") {\n            return await this.confirmTransactionUsingLegacyTimeoutStrategy({\n                commitment: commitment || this.commitment,\n                signature: rawSignature\n            });\n        } else if (\"lastValidBlockHeight\" in strategy) {\n            return await this.confirmTransactionUsingBlockHeightExceedanceStrategy({\n                commitment: commitment || this.commitment,\n                strategy\n            });\n        } else {\n            return await this.confirmTransactionUsingDurableNonceStrategy({\n                commitment: commitment || this.commitment,\n                strategy\n            });\n        }\n    }\n    getCancellationPromise(signal) {\n        return new Promise((_, reject)=>{\n            if (signal == null) {\n                return;\n            }\n            if (signal.aborted) {\n                reject(signal.reason);\n            } else {\n                signal.addEventListener(\"abort\", ()=>{\n                    reject(signal.reason);\n                });\n            }\n        });\n    }\n    getTransactionConfirmationPromise({ commitment, signature }) {\n        let signatureSubscriptionId;\n        let disposeSignatureSubscriptionStateChangeObserver;\n        let done = false;\n        const confirmationPromise = new Promise((resolve, reject)=>{\n            try {\n                signatureSubscriptionId = this.onSignature(signature, (result, context)=>{\n                    signatureSubscriptionId = undefined;\n                    const response = {\n                        context,\n                        value: result\n                    };\n                    resolve({\n                        __type: TransactionStatus.PROCESSED,\n                        response\n                    });\n                }, commitment);\n                const subscriptionSetupPromise = new Promise((resolveSubscriptionSetup)=>{\n                    if (signatureSubscriptionId == null) {\n                        resolveSubscriptionSetup();\n                    } else {\n                        disposeSignatureSubscriptionStateChangeObserver = this._onSubscriptionStateChange(signatureSubscriptionId, (nextState)=>{\n                            if (nextState === \"subscribed\") {\n                                resolveSubscriptionSetup();\n                            }\n                        });\n                    }\n                });\n                (async ()=>{\n                    await subscriptionSetupPromise;\n                    if (done) return;\n                    const response = await this.getSignatureStatus(signature);\n                    if (done) return;\n                    if (response == null) {\n                        return;\n                    }\n                    const { context, value } = response;\n                    if (value == null) {\n                        return;\n                    }\n                    if (value?.err) {\n                        reject(value.err);\n                    } else {\n                        switch(commitment){\n                            case \"confirmed\":\n                            case \"single\":\n                            case \"singleGossip\":\n                                {\n                                    if (value.confirmationStatus === \"processed\") {\n                                        return;\n                                    }\n                                    break;\n                                }\n                            case \"finalized\":\n                            case \"max\":\n                            case \"root\":\n                                {\n                                    if (value.confirmationStatus === \"processed\" || value.confirmationStatus === \"confirmed\") {\n                                        return;\n                                    }\n                                    break;\n                                }\n                            // exhaust enums to ensure full coverage\n                            case \"processed\":\n                            case \"recent\":\n                        }\n                        done = true;\n                        resolve({\n                            __type: TransactionStatus.PROCESSED,\n                            response: {\n                                context,\n                                value\n                            }\n                        });\n                    }\n                })();\n            } catch (err) {\n                reject(err);\n            }\n        });\n        const abortConfirmation = ()=>{\n            if (disposeSignatureSubscriptionStateChangeObserver) {\n                disposeSignatureSubscriptionStateChangeObserver();\n                disposeSignatureSubscriptionStateChangeObserver = undefined;\n            }\n            if (signatureSubscriptionId != null) {\n                this.removeSignatureListener(signatureSubscriptionId);\n                signatureSubscriptionId = undefined;\n            }\n        };\n        return {\n            abortConfirmation,\n            confirmationPromise\n        };\n    }\n    async confirmTransactionUsingBlockHeightExceedanceStrategy({ commitment, strategy: { abortSignal, lastValidBlockHeight, signature } }) {\n        let done = false;\n        const expiryPromise = new Promise((resolve)=>{\n            const checkBlockHeight = async ()=>{\n                try {\n                    const blockHeight = await this.getBlockHeight(commitment);\n                    return blockHeight;\n                } catch (_e) {\n                    return -1;\n                }\n            };\n            (async ()=>{\n                let currentBlockHeight = await checkBlockHeight();\n                if (done) return;\n                while(currentBlockHeight <= lastValidBlockHeight){\n                    await sleep(1000);\n                    if (done) return;\n                    currentBlockHeight = await checkBlockHeight();\n                    if (done) return;\n                }\n                resolve({\n                    __type: TransactionStatus.BLOCKHEIGHT_EXCEEDED\n                });\n            })();\n        });\n        const { abortConfirmation, confirmationPromise } = this.getTransactionConfirmationPromise({\n            commitment,\n            signature\n        });\n        const cancellationPromise = this.getCancellationPromise(abortSignal);\n        let result;\n        try {\n            const outcome = await Promise.race([\n                cancellationPromise,\n                confirmationPromise,\n                expiryPromise\n            ]);\n            if (outcome.__type === TransactionStatus.PROCESSED) {\n                result = outcome.response;\n            } else {\n                throw new TransactionExpiredBlockheightExceededError(signature);\n            }\n        } finally{\n            done = true;\n            abortConfirmation();\n        }\n        return result;\n    }\n    async confirmTransactionUsingDurableNonceStrategy({ commitment, strategy: { abortSignal, minContextSlot, nonceAccountPubkey, nonceValue, signature } }) {\n        let done = false;\n        const expiryPromise = new Promise((resolve)=>{\n            let currentNonceValue = nonceValue;\n            let lastCheckedSlot = null;\n            const getCurrentNonceValue = async ()=>{\n                try {\n                    const { context, value: nonceAccount } = await this.getNonceAndContext(nonceAccountPubkey, {\n                        commitment,\n                        minContextSlot\n                    });\n                    lastCheckedSlot = context.slot;\n                    return nonceAccount?.nonce;\n                } catch (e) {\n                    // If for whatever reason we can't reach/read the nonce\n                    // account, just keep using the last-known value.\n                    return currentNonceValue;\n                }\n            };\n            (async ()=>{\n                currentNonceValue = await getCurrentNonceValue();\n                if (done) return;\n                while(true // eslint-disable-line no-constant-condition\n                ){\n                    if (nonceValue !== currentNonceValue) {\n                        resolve({\n                            __type: TransactionStatus.NONCE_INVALID,\n                            slotInWhichNonceDidAdvance: lastCheckedSlot\n                        });\n                        return;\n                    }\n                    await sleep(2000);\n                    if (done) return;\n                    currentNonceValue = await getCurrentNonceValue();\n                    if (done) return;\n                }\n            })();\n        });\n        const { abortConfirmation, confirmationPromise } = this.getTransactionConfirmationPromise({\n            commitment,\n            signature\n        });\n        const cancellationPromise = this.getCancellationPromise(abortSignal);\n        let result;\n        try {\n            const outcome = await Promise.race([\n                cancellationPromise,\n                confirmationPromise,\n                expiryPromise\n            ]);\n            if (outcome.__type === TransactionStatus.PROCESSED) {\n                result = outcome.response;\n            } else {\n                // Double check that the transaction is indeed unconfirmed.\n                let signatureStatus;\n                while(true // eslint-disable-line no-constant-condition\n                ){\n                    const status = await this.getSignatureStatus(signature);\n                    if (status == null) {\n                        break;\n                    }\n                    if (status.context.slot < (outcome.slotInWhichNonceDidAdvance ?? minContextSlot)) {\n                        await sleep(400);\n                        continue;\n                    }\n                    signatureStatus = status;\n                    break;\n                }\n                if (signatureStatus?.value) {\n                    const commitmentForStatus = commitment || \"finalized\";\n                    const { confirmationStatus } = signatureStatus.value;\n                    switch(commitmentForStatus){\n                        case \"processed\":\n                        case \"recent\":\n                            if (confirmationStatus !== \"processed\" && confirmationStatus !== \"confirmed\" && confirmationStatus !== \"finalized\") {\n                                throw new TransactionExpiredNonceInvalidError(signature);\n                            }\n                            break;\n                        case \"confirmed\":\n                        case \"single\":\n                        case \"singleGossip\":\n                            if (confirmationStatus !== \"confirmed\" && confirmationStatus !== \"finalized\") {\n                                throw new TransactionExpiredNonceInvalidError(signature);\n                            }\n                            break;\n                        case \"finalized\":\n                        case \"max\":\n                        case \"root\":\n                            if (confirmationStatus !== \"finalized\") {\n                                throw new TransactionExpiredNonceInvalidError(signature);\n                            }\n                            break;\n                        default:\n                            // Exhaustive switch.\n                            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                            ((_)=>{})(commitmentForStatus);\n                    }\n                    result = {\n                        context: signatureStatus.context,\n                        value: {\n                            err: signatureStatus.value.err\n                        }\n                    };\n                } else {\n                    throw new TransactionExpiredNonceInvalidError(signature);\n                }\n            }\n        } finally{\n            done = true;\n            abortConfirmation();\n        }\n        return result;\n    }\n    async confirmTransactionUsingLegacyTimeoutStrategy({ commitment, signature }) {\n        let timeoutId;\n        const expiryPromise = new Promise((resolve)=>{\n            let timeoutMs = this._confirmTransactionInitialTimeout || 60 * 1000;\n            switch(commitment){\n                case \"processed\":\n                case \"recent\":\n                case \"single\":\n                case \"confirmed\":\n                case \"singleGossip\":\n                    {\n                        timeoutMs = this._confirmTransactionInitialTimeout || 30 * 1000;\n                        break;\n                    }\n            }\n            timeoutId = setTimeout(()=>resolve({\n                    __type: TransactionStatus.TIMED_OUT,\n                    timeoutMs\n                }), timeoutMs);\n        });\n        const { abortConfirmation, confirmationPromise } = this.getTransactionConfirmationPromise({\n            commitment,\n            signature\n        });\n        let result;\n        try {\n            const outcome = await Promise.race([\n                confirmationPromise,\n                expiryPromise\n            ]);\n            if (outcome.__type === TransactionStatus.PROCESSED) {\n                result = outcome.response;\n            } else {\n                throw new TransactionExpiredTimeoutError(signature, outcome.timeoutMs / 1000);\n            }\n        } finally{\n            clearTimeout(timeoutId);\n            abortConfirmation();\n        }\n        return result;\n    }\n    /**\n   * Return the list of nodes that are currently participating in the cluster\n   */ async getClusterNodes() {\n        const unsafeRes = await this._rpcRequest(\"getClusterNodes\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(ContactInfoResult)));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get cluster nodes\");\n        }\n        return res.result;\n    }\n    /**\n   * Return the list of nodes that are currently participating in the cluster\n   */ async getVoteAccounts(commitment) {\n        const args = this._buildArgs([], commitment);\n        const unsafeRes = await this._rpcRequest(\"getVoteAccounts\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetVoteAccounts);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get vote accounts\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current slot that the node is processing\n   */ async getSlot(commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getSlot\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get slot\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current slot leader of the cluster\n   */ async getSlotLeader(commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getSlotLeader\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get slot leader\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch `limit` number of slot leaders starting from `startSlot`\n   *\n   * @param startSlot fetch slot leaders starting from this slot\n   * @param limit number of slot leaders to return\n   */ async getSlotLeaders(startSlot, limit) {\n        const args = [\n            startSlot,\n            limit\n        ];\n        const unsafeRes = await this._rpcRequest(\"getSlotLeaders\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)(PublicKeyFromString)));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get slot leaders\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current status of a signature\n   */ async getSignatureStatus(signature, config) {\n        const { context, value: values } = await this.getSignatureStatuses([\n            signature\n        ], config);\n        assert(values.length === 1);\n        const value = values[0];\n        return {\n            context,\n            value\n        };\n    }\n    /**\n   * Fetch the current statuses of a batch of signatures\n   */ async getSignatureStatuses(signatures, config) {\n        const params = [\n            signatures\n        ];\n        if (config) {\n            params.push(config);\n        }\n        const unsafeRes = await this._rpcRequest(\"getSignatureStatuses\", params);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetSignatureStatusesRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get signature status\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current transaction count of the cluster\n   */ async getTransactionCount(commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getTransactionCount\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get transaction count\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current total currency supply of the cluster in lamports\n   *\n   * @deprecated Deprecated since RPC v1.2.8. Please use {@link getSupply} instead.\n   */ async getTotalSupply(commitment) {\n        const result = await this.getSupply({\n            commitment,\n            excludeNonCirculatingAccountsList: true\n        });\n        return result.value.total;\n    }\n    /**\n   * Fetch the cluster InflationGovernor parameters\n   */ async getInflationGovernor(commitment) {\n        const args = this._buildArgs([], commitment);\n        const unsafeRes = await this._rpcRequest(\"getInflationGovernor\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetInflationGovernorRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get inflation\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the inflation reward for a list of addresses for an epoch\n   */ async getInflationReward(addresses, epoch, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([\n            addresses.map((pubkey)=>pubkey.toBase58())\n        ], commitment, undefined /* encoding */ , {\n            ...config,\n            epoch: epoch != null ? epoch : config?.epoch\n        });\n        const unsafeRes = await this._rpcRequest(\"getInflationReward\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetInflationRewardResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get inflation reward\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the specific inflation values for the current epoch\n   */ async getInflationRate() {\n        const unsafeRes = await this._rpcRequest(\"getInflationRate\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetInflationRateRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get inflation rate\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the Epoch Info parameters\n   */ async getEpochInfo(commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getEpochInfo\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetEpochInfoRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get epoch info\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the Epoch Schedule parameters\n   */ async getEpochSchedule() {\n        const unsafeRes = await this._rpcRequest(\"getEpochSchedule\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetEpochScheduleRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get epoch schedule\");\n        }\n        const epochSchedule = res.result;\n        return new EpochSchedule(epochSchedule.slotsPerEpoch, epochSchedule.leaderScheduleSlotOffset, epochSchedule.warmup, epochSchedule.firstNormalEpoch, epochSchedule.firstNormalSlot);\n    }\n    /**\n   * Fetch the leader schedule for the current epoch\n   * @return {Promise<RpcResponseAndContext<LeaderSchedule>>}\n   */ async getLeaderSchedule() {\n        const unsafeRes = await this._rpcRequest(\"getLeaderSchedule\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetLeaderScheduleRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get leader schedule\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the minimum balance needed to exempt an account of `dataLength`\n   * size from rent\n   */ async getMinimumBalanceForRentExemption(dataLength, commitment) {\n        const args = this._buildArgs([\n            dataLength\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getMinimumBalanceForRentExemption\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetMinimumBalanceForRentExemptionRpcResult);\n        if (\"error\" in res) {\n            console.warn(\"Unable to fetch minimum balance for rent exemption\");\n            return 0;\n        }\n        return res.result;\n    }\n    /**\n   * Fetch a recent blockhash from the cluster, return with context\n   * @return {Promise<RpcResponseAndContext<{blockhash: Blockhash, feeCalculator: FeeCalculator}>>}\n   *\n   * @deprecated Deprecated since RPC v1.9.0. Please use {@link getLatestBlockhash} instead.\n   */ async getRecentBlockhashAndContext(commitment) {\n        const { context, value: { blockhash } } = await this.getLatestBlockhashAndContext(commitment);\n        const feeCalculator = {\n            get lamportsPerSignature () {\n                throw new Error(\"The capability to fetch `lamportsPerSignature` using the `getRecentBlockhash` API is \" + \"no longer offered by the network. Use the `getFeeForMessage` API to obtain the fee \" + \"for a given message.\");\n            },\n            toJSON () {\n                return {};\n            }\n        };\n        return {\n            context,\n            value: {\n                blockhash,\n                feeCalculator\n            }\n        };\n    }\n    /**\n   * Fetch recent performance samples\n   * @return {Promise<Array<PerfSample>>}\n   */ async getRecentPerformanceSamples(limit) {\n        const unsafeRes = await this._rpcRequest(\"getRecentPerformanceSamples\", limit ? [\n            limit\n        ] : []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetRecentPerformanceSamplesRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get recent performance samples\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the fee calculator for a recent blockhash from the cluster, return with context\n   *\n   * @deprecated Deprecated since RPC v1.9.0. Please use {@link getFeeForMessage} instead.\n   */ async getFeeCalculatorForBlockhash(blockhash, commitment) {\n        const args = this._buildArgs([\n            blockhash\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getFeeCalculatorForBlockhash\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetFeeCalculatorRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get fee calculator\");\n        }\n        const { context, value } = res.result;\n        return {\n            context,\n            value: value !== null ? value.feeCalculator : null\n        };\n    }\n    /**\n   * Fetch the fee for a message from the cluster, return with context\n   */ async getFeeForMessage(message, commitment) {\n        const wireMessage = toBuffer(message.serialize()).toString(\"base64\");\n        const args = this._buildArgs([\n            wireMessage\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getFeeForMessage\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get fee for message\");\n        }\n        if (res.result === null) {\n            throw new Error(\"invalid blockhash\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch a list of prioritization fees from recent blocks.\n   */ async getRecentPrioritizationFees(config) {\n        const accounts = config?.lockedWritableAccounts?.map((key)=>key.toBase58());\n        const args = accounts?.length ? [\n            accounts\n        ] : [];\n        const unsafeRes = await this._rpcRequest(\"getRecentPrioritizationFees\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetRecentPrioritizationFeesRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get recent prioritization fees\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch a recent blockhash from the cluster\n   * @return {Promise<{blockhash: Blockhash, feeCalculator: FeeCalculator}>}\n   *\n   * @deprecated Deprecated since RPC v1.8.0. Please use {@link getLatestBlockhash} instead.\n   */ async getRecentBlockhash(commitment) {\n        try {\n            const res = await this.getRecentBlockhashAndContext(commitment);\n            return res.value;\n        } catch (e) {\n            throw new Error(\"failed to get recent blockhash: \" + e);\n        }\n    }\n    /**\n   * Fetch the latest blockhash from the cluster\n   * @return {Promise<BlockhashWithExpiryBlockHeight>}\n   */ async getLatestBlockhash(commitmentOrConfig) {\n        try {\n            const res = await this.getLatestBlockhashAndContext(commitmentOrConfig);\n            return res.value;\n        } catch (e) {\n            throw new Error(\"failed to get recent blockhash: \" + e);\n        }\n    }\n    /**\n   * Fetch the latest blockhash from the cluster\n   * @return {Promise<BlockhashWithExpiryBlockHeight>}\n   */ async getLatestBlockhashAndContext(commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getLatestBlockhash\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetLatestBlockhashRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get latest blockhash\");\n        }\n        return res.result;\n    }\n    /**\n   * Returns whether a blockhash is still valid or not\n   */ async isBlockhashValid(blockhash, rawConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(rawConfig);\n        const args = this._buildArgs([\n            blockhash\n        ], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"isBlockhashValid\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, IsBlockhashValidRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to determine if the blockhash `\" + blockhash + \"`is valid\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the node version\n   */ async getVersion() {\n        const unsafeRes = await this._rpcRequest(\"getVersion\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult(VersionResult));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get version\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the genesis hash\n   */ async getGenesisHash() {\n        const unsafeRes = await this._rpcRequest(\"getGenesisHash\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get genesis hash\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch a processed block from the cluster.\n   *\n   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by\n   * setting the `maxSupportedTransactionVersion` property.\n   */ /**\n   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by\n   * setting the `maxSupportedTransactionVersion` property.\n   */ // eslint-disable-next-line no-dupe-class-members\n    /**\n   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by\n   * setting the `maxSupportedTransactionVersion` property.\n   */ // eslint-disable-next-line no-dupe-class-members\n    /**\n   * Fetch a processed block from the cluster.\n   */ // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    /**\n   * Fetch a processed block from the cluster.\n   */ // eslint-disable-next-line no-dupe-class-members\n    async getBlock(slot, rawConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(rawConfig);\n        const args = this._buildArgsAtLeastConfirmed([\n            slot\n        ], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getBlock\", args);\n        try {\n            switch(config?.transactionDetails){\n                case \"accounts\":\n                    {\n                        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetAccountsModeBlockRpcResult);\n                        if (\"error\" in res) {\n                            throw res.error;\n                        }\n                        return res.result;\n                    }\n                case \"none\":\n                    {\n                        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetNoneModeBlockRpcResult);\n                        if (\"error\" in res) {\n                            throw res.error;\n                        }\n                        return res.result;\n                    }\n                default:\n                    {\n                        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetBlockRpcResult);\n                        if (\"error\" in res) {\n                            throw res.error;\n                        }\n                        const { result } = res;\n                        return result ? {\n                            ...result,\n                            transactions: result.transactions.map(({ transaction, meta, version })=>({\n                                    meta,\n                                    transaction: {\n                                        ...transaction,\n                                        message: versionedMessageFromResponse(version, transaction.message)\n                                    },\n                                    version\n                                }))\n                        } : null;\n                    }\n            }\n        } catch (e) {\n            throw new SolanaJSONRPCError(e, \"failed to get confirmed block\");\n        }\n    }\n    /**\n   * Fetch parsed transaction details for a confirmed or finalized block\n   */ // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    async getParsedBlock(slot, rawConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(rawConfig);\n        const args = this._buildArgsAtLeastConfirmed([\n            slot\n        ], commitment, \"jsonParsed\", config);\n        const unsafeRes = await this._rpcRequest(\"getBlock\", args);\n        try {\n            switch(config?.transactionDetails){\n                case \"accounts\":\n                    {\n                        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetParsedAccountsModeBlockRpcResult);\n                        if (\"error\" in res) {\n                            throw res.error;\n                        }\n                        return res.result;\n                    }\n                case \"none\":\n                    {\n                        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetParsedNoneModeBlockRpcResult);\n                        if (\"error\" in res) {\n                            throw res.error;\n                        }\n                        return res.result;\n                    }\n                default:\n                    {\n                        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetParsedBlockRpcResult);\n                        if (\"error\" in res) {\n                            throw res.error;\n                        }\n                        return res.result;\n                    }\n            }\n        } catch (e) {\n            throw new SolanaJSONRPCError(e, \"failed to get block\");\n        }\n    }\n    /*\n   * Returns recent block production information from the current or previous epoch\n   */ async getBlockProduction(configOrCommitment) {\n        let extra;\n        let commitment;\n        if (typeof configOrCommitment === \"string\") {\n            commitment = configOrCommitment;\n        } else if (configOrCommitment) {\n            const { commitment: c, ...rest } = configOrCommitment;\n            commitment = c;\n            extra = rest;\n        }\n        const args = this._buildArgs([], commitment, \"base64\", extra);\n        const unsafeRes = await this._rpcRequest(\"getBlockProduction\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, BlockProductionResponseStruct);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get block production information\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch a confirmed or finalized transaction from the cluster.\n   *\n   * @deprecated Instead, call `getTransaction` using a\n   * `GetVersionedTransactionConfig` by setting the\n   * `maxSupportedTransactionVersion` property.\n   */ /**\n   * Fetch a confirmed or finalized transaction from the cluster.\n   */ // eslint-disable-next-line no-dupe-class-members\n    /**\n   * Fetch a confirmed or finalized transaction from the cluster.\n   */ // eslint-disable-next-line no-dupe-class-members\n    async getTransaction(signature, rawConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(rawConfig);\n        const args = this._buildArgsAtLeastConfirmed([\n            signature\n        ], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getTransaction\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetTransactionRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get transaction\");\n        }\n        const result = res.result;\n        if (!result) return result;\n        return {\n            ...result,\n            transaction: {\n                ...result.transaction,\n                message: versionedMessageFromResponse(result.version, result.transaction.message)\n            }\n        };\n    }\n    /**\n   * Fetch parsed transaction details for a confirmed or finalized transaction\n   */ async getParsedTransaction(signature, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgsAtLeastConfirmed([\n            signature\n        ], commitment, \"jsonParsed\", config);\n        const unsafeRes = await this._rpcRequest(\"getTransaction\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetParsedTransactionRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get transaction\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch parsed transaction details for a batch of confirmed transactions\n   */ async getParsedTransactions(signatures, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const batch = signatures.map((signature)=>{\n            const args = this._buildArgsAtLeastConfirmed([\n                signature\n            ], commitment, \"jsonParsed\", config);\n            return {\n                methodName: \"getTransaction\",\n                args\n            };\n        });\n        const unsafeRes = await this._rpcBatchRequest(batch);\n        const res = unsafeRes.map((unsafeRes)=>{\n            const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetParsedTransactionRpcResult);\n            if (\"error\" in res) {\n                throw new SolanaJSONRPCError(res.error, \"failed to get transactions\");\n            }\n            return res.result;\n        });\n        return res;\n    }\n    /**\n   * Fetch transaction details for a batch of confirmed transactions.\n   * Similar to {@link getParsedTransactions} but returns a {@link TransactionResponse}.\n   *\n   * @deprecated Instead, call `getTransactions` using a\n   * `GetVersionedTransactionConfig` by setting the\n   * `maxSupportedTransactionVersion` property.\n   */ /**\n   * Fetch transaction details for a batch of confirmed transactions.\n   * Similar to {@link getParsedTransactions} but returns a {@link\n   * VersionedTransactionResponse}.\n   */ // eslint-disable-next-line no-dupe-class-members\n    /**\n   * Fetch transaction details for a batch of confirmed transactions.\n   * Similar to {@link getParsedTransactions} but returns a {@link\n   * VersionedTransactionResponse}.\n   */ // eslint-disable-next-line no-dupe-class-members\n    async getTransactions(signatures, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const batch = signatures.map((signature)=>{\n            const args = this._buildArgsAtLeastConfirmed([\n                signature\n            ], commitment, undefined /* encoding */ , config);\n            return {\n                methodName: \"getTransaction\",\n                args\n            };\n        });\n        const unsafeRes = await this._rpcBatchRequest(batch);\n        const res = unsafeRes.map((unsafeRes)=>{\n            const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetTransactionRpcResult);\n            if (\"error\" in res) {\n                throw new SolanaJSONRPCError(res.error, \"failed to get transactions\");\n            }\n            const result = res.result;\n            if (!result) return result;\n            return {\n                ...result,\n                transaction: {\n                    ...result.transaction,\n                    message: versionedMessageFromResponse(result.version, result.transaction.message)\n                }\n            };\n        });\n        return res;\n    }\n    /**\n   * Fetch a list of Transactions and transaction statuses from the cluster\n   * for a confirmed block.\n   *\n   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getBlock} instead.\n   */ async getConfirmedBlock(slot, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            slot\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getBlock\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetConfirmedBlockRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get confirmed block\");\n        }\n        const result = res.result;\n        if (!result) {\n            throw new Error(\"Confirmed block \" + slot + \" not found\");\n        }\n        const block = {\n            ...result,\n            transactions: result.transactions.map(({ transaction, meta })=>{\n                const message = new Message(transaction.message);\n                return {\n                    meta,\n                    transaction: {\n                        ...transaction,\n                        message\n                    }\n                };\n            })\n        };\n        return {\n            ...block,\n            transactions: block.transactions.map(({ transaction, meta })=>{\n                return {\n                    meta,\n                    transaction: Transaction.populate(transaction.message, transaction.signatures)\n                };\n            })\n        };\n    }\n    /**\n   * Fetch confirmed blocks between two slots\n   */ async getBlocks(startSlot, endSlot, commitment) {\n        const args = this._buildArgsAtLeastConfirmed(endSlot !== undefined ? [\n            startSlot,\n            endSlot\n        ] : [\n            startSlot\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getBlocks\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)())));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get blocks\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch a list of Signatures from the cluster for a block, excluding rewards\n   */ async getBlockSignatures(slot, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            slot\n        ], commitment, undefined, {\n            transactionDetails: \"signatures\",\n            rewards: false\n        });\n        const unsafeRes = await this._rpcRequest(\"getBlock\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetBlockSignaturesRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get block\");\n        }\n        const result = res.result;\n        if (!result) {\n            throw new Error(\"Block \" + slot + \" not found\");\n        }\n        return result;\n    }\n    /**\n   * Fetch a list of Signatures from the cluster for a confirmed block, excluding rewards\n   *\n   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getBlockSignatures} instead.\n   */ async getConfirmedBlockSignatures(slot, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            slot\n        ], commitment, undefined, {\n            transactionDetails: \"signatures\",\n            rewards: false\n        });\n        const unsafeRes = await this._rpcRequest(\"getBlock\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetBlockSignaturesRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get confirmed block\");\n        }\n        const result = res.result;\n        if (!result) {\n            throw new Error(\"Confirmed block \" + slot + \" not found\");\n        }\n        return result;\n    }\n    /**\n   * Fetch a transaction details for a confirmed transaction\n   *\n   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getTransaction} instead.\n   */ async getConfirmedTransaction(signature, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            signature\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getTransaction\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetTransactionRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get transaction\");\n        }\n        const result = res.result;\n        if (!result) return result;\n        const message = new Message(result.transaction.message);\n        const signatures = result.transaction.signatures;\n        return {\n            ...result,\n            transaction: Transaction.populate(message, signatures)\n        };\n    }\n    /**\n   * Fetch parsed transaction details for a confirmed transaction\n   *\n   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getParsedTransaction} instead.\n   */ async getParsedConfirmedTransaction(signature, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            signature\n        ], commitment, \"jsonParsed\");\n        const unsafeRes = await this._rpcRequest(\"getTransaction\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetParsedTransactionRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get confirmed transaction\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch parsed transaction details for a batch of confirmed transactions\n   *\n   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getParsedTransactions} instead.\n   */ async getParsedConfirmedTransactions(signatures, commitment) {\n        const batch = signatures.map((signature)=>{\n            const args = this._buildArgsAtLeastConfirmed([\n                signature\n            ], commitment, \"jsonParsed\");\n            return {\n                methodName: \"getTransaction\",\n                args\n            };\n        });\n        const unsafeRes = await this._rpcBatchRequest(batch);\n        const res = unsafeRes.map((unsafeRes)=>{\n            const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetParsedTransactionRpcResult);\n            if (\"error\" in res) {\n                throw new SolanaJSONRPCError(res.error, \"failed to get confirmed transactions\");\n            }\n            return res.result;\n        });\n        return res;\n    }\n    /**\n   * Fetch a list of all the confirmed signatures for transactions involving an address\n   * within a specified slot range. Max range allowed is 10,000 slots.\n   *\n   * @deprecated Deprecated since RPC v1.3. Please use {@link getConfirmedSignaturesForAddress2} instead.\n   *\n   * @param address queried address\n   * @param startSlot start slot, inclusive\n   * @param endSlot end slot, inclusive\n   */ async getConfirmedSignaturesForAddress(address, startSlot, endSlot) {\n        let options = {};\n        let firstAvailableBlock = await this.getFirstAvailableBlock();\n        while(!(\"until\" in options)){\n            startSlot--;\n            if (startSlot <= 0 || startSlot < firstAvailableBlock) {\n                break;\n            }\n            try {\n                const block = await this.getConfirmedBlockSignatures(startSlot, \"finalized\");\n                if (block.signatures.length > 0) {\n                    options.until = block.signatures[block.signatures.length - 1].toString();\n                }\n            } catch (err) {\n                if (err instanceof Error && err.message.includes(\"skipped\")) {\n                    continue;\n                } else {\n                    throw err;\n                }\n            }\n        }\n        let highestConfirmedRoot = await this.getSlot(\"finalized\");\n        while(!(\"before\" in options)){\n            endSlot++;\n            if (endSlot > highestConfirmedRoot) {\n                break;\n            }\n            try {\n                const block = await this.getConfirmedBlockSignatures(endSlot);\n                if (block.signatures.length > 0) {\n                    options.before = block.signatures[block.signatures.length - 1].toString();\n                }\n            } catch (err) {\n                if (err instanceof Error && err.message.includes(\"skipped\")) {\n                    continue;\n                } else {\n                    throw err;\n                }\n            }\n        }\n        const confirmedSignatureInfo = await this.getConfirmedSignaturesForAddress2(address, options);\n        return confirmedSignatureInfo.map((info)=>info.signature);\n    }\n    /**\n   * Returns confirmed signatures for transactions involving an\n   * address backwards in time from the provided signature or most recent confirmed block\n   *\n   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getSignaturesForAddress} instead.\n   */ async getConfirmedSignaturesForAddress2(address, options, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            address.toBase58()\n        ], commitment, undefined, options);\n        const unsafeRes = await this._rpcRequest(\"getConfirmedSignaturesForAddress2\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetConfirmedSignaturesForAddress2RpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get confirmed signatures for address\");\n        }\n        return res.result;\n    }\n    /**\n   * Returns confirmed signatures for transactions involving an\n   * address backwards in time from the provided signature or most recent confirmed block\n   *\n   *\n   * @param address queried address\n   * @param options\n   */ async getSignaturesForAddress(address, options, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            address.toBase58()\n        ], commitment, undefined, options);\n        const unsafeRes = await this._rpcRequest(\"getSignaturesForAddress\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, GetSignaturesForAddressRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get signatures for address\");\n        }\n        return res.result;\n    }\n    async getAddressLookupTable(accountKey, config) {\n        const { context, value: accountInfo } = await this.getAccountInfoAndContext(accountKey, config);\n        let value = null;\n        if (accountInfo !== null) {\n            value = new AddressLookupTableAccount({\n                key: accountKey,\n                state: AddressLookupTableAccount.deserialize(accountInfo.data)\n            });\n        }\n        return {\n            context,\n            value\n        };\n    }\n    /**\n   * Fetch the contents of a Nonce account from the cluster, return with context\n   */ async getNonceAndContext(nonceAccount, commitmentOrConfig) {\n        const { context, value: accountInfo } = await this.getAccountInfoAndContext(nonceAccount, commitmentOrConfig);\n        let value = null;\n        if (accountInfo !== null) {\n            value = NonceAccount.fromAccountData(accountInfo.data);\n        }\n        return {\n            context,\n            value\n        };\n    }\n    /**\n   * Fetch the contents of a Nonce account from the cluster\n   */ async getNonce(nonceAccount, commitmentOrConfig) {\n        return await this.getNonceAndContext(nonceAccount, commitmentOrConfig).then((x)=>x.value).catch((e)=>{\n            throw new Error(\"failed to get nonce for account \" + nonceAccount.toBase58() + \": \" + e);\n        });\n    }\n    /**\n   * Request an allocation of lamports to the specified address\n   *\n   * ```typescript\n   * import { Connection, PublicKey, LAMPORTS_PER_SOL } from \"@solana/web3.js\";\n   *\n   * (async () => {\n   *   const connection = new Connection(\"https://api.testnet.solana.com\", \"confirmed\");\n   *   const myAddress = new PublicKey(\"2nr1bHFT86W9tGnyvmYW4vcHKsQB3sVQfnddasz4kExM\");\n   *   const signature = await connection.requestAirdrop(myAddress, LAMPORTS_PER_SOL);\n   *   await connection.confirmTransaction(signature);\n   * })();\n   * ```\n   */ async requestAirdrop(to, lamports) {\n        const unsafeRes = await this._rpcRequest(\"requestAirdrop\", [\n            to.toBase58(),\n            lamports\n        ]);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, RequestAirdropRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `airdrop to ${to.toBase58()} failed`);\n        }\n        return res.result;\n    }\n    /**\n   * @internal\n   */ async _blockhashWithExpiryBlockHeight(disableCache) {\n        if (!disableCache) {\n            // Wait for polling to finish\n            while(this._pollingBlockhash){\n                await sleep(100);\n            }\n            const timeSinceFetch = Date.now() - this._blockhashInfo.lastFetch;\n            const expired = timeSinceFetch >= BLOCKHASH_CACHE_TIMEOUT_MS;\n            if (this._blockhashInfo.latestBlockhash !== null && !expired) {\n                return this._blockhashInfo.latestBlockhash;\n            }\n        }\n        return await this._pollNewBlockhash();\n    }\n    /**\n   * @internal\n   */ async _pollNewBlockhash() {\n        this._pollingBlockhash = true;\n        try {\n            const startTime = Date.now();\n            const cachedLatestBlockhash = this._blockhashInfo.latestBlockhash;\n            const cachedBlockhash = cachedLatestBlockhash ? cachedLatestBlockhash.blockhash : null;\n            for(let i = 0; i < 50; i++){\n                const latestBlockhash = await this.getLatestBlockhash(\"finalized\");\n                if (cachedBlockhash !== latestBlockhash.blockhash) {\n                    this._blockhashInfo = {\n                        latestBlockhash,\n                        lastFetch: Date.now(),\n                        transactionSignatures: [],\n                        simulatedSignatures: []\n                    };\n                    return latestBlockhash;\n                }\n                // Sleep for approximately half a slot\n                await sleep(MS_PER_SLOT / 2);\n            }\n            throw new Error(`Unable to obtain a new blockhash after ${Date.now() - startTime}ms`);\n        } finally{\n            this._pollingBlockhash = false;\n        }\n    }\n    /**\n   * get the stake minimum delegation\n   */ async getStakeMinimumDelegation(config) {\n        const { commitment, config: configArg } = extractCommitmentFromConfig(config);\n        const args = this._buildArgs([], commitment, \"base64\", configArg);\n        const unsafeRes = await this._rpcRequest(\"getStakeMinimumDelegation\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.number)()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get stake minimum delegation`);\n        }\n        return res.result;\n    }\n    /**\n   * Simulate a transaction\n   *\n   * @deprecated Instead, call {@link simulateTransaction} with {@link\n   * VersionedTransaction} and {@link SimulateTransactionConfig} parameters\n   */ /**\n   * Simulate a transaction\n   */ // eslint-disable-next-line no-dupe-class-members\n    /**\n   * Simulate a transaction\n   */ // eslint-disable-next-line no-dupe-class-members\n    async simulateTransaction(transactionOrMessage, configOrSigners, includeAccounts) {\n        if (\"message\" in transactionOrMessage) {\n            const versionedTx = transactionOrMessage;\n            const wireTransaction = versionedTx.serialize();\n            const encodedTransaction = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(wireTransaction).toString(\"base64\");\n            if (Array.isArray(configOrSigners) || includeAccounts !== undefined) {\n                throw new Error(\"Invalid arguments\");\n            }\n            const config = configOrSigners || {};\n            config.encoding = \"base64\";\n            if (!(\"commitment\" in config)) {\n                config.commitment = this.commitment;\n            }\n            if (configOrSigners && typeof configOrSigners === \"object\" && \"innerInstructions\" in configOrSigners) {\n                config.innerInstructions = configOrSigners.innerInstructions;\n            }\n            const args = [\n                encodedTransaction,\n                config\n            ];\n            const unsafeRes = await this._rpcRequest(\"simulateTransaction\", args);\n            const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, SimulatedTransactionResponseStruct);\n            if (\"error\" in res) {\n                throw new Error(\"failed to simulate transaction: \" + res.error.message);\n            }\n            return res.result;\n        }\n        let transaction;\n        if (transactionOrMessage instanceof Transaction) {\n            let originalTx = transactionOrMessage;\n            transaction = new Transaction();\n            transaction.feePayer = originalTx.feePayer;\n            transaction.instructions = transactionOrMessage.instructions;\n            transaction.nonceInfo = originalTx.nonceInfo;\n            transaction.signatures = originalTx.signatures;\n        } else {\n            transaction = Transaction.populate(transactionOrMessage);\n            // HACK: this function relies on mutating the populated transaction\n            transaction._message = transaction._json = undefined;\n        }\n        if (configOrSigners !== undefined && !Array.isArray(configOrSigners)) {\n            throw new Error(\"Invalid arguments\");\n        }\n        const signers = configOrSigners;\n        if (transaction.nonceInfo && signers) {\n            transaction.sign(...signers);\n        } else {\n            let disableCache = this._disableBlockhashCaching;\n            for(;;){\n                const latestBlockhash = await this._blockhashWithExpiryBlockHeight(disableCache);\n                transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;\n                transaction.recentBlockhash = latestBlockhash.blockhash;\n                if (!signers) break;\n                transaction.sign(...signers);\n                if (!transaction.signature) {\n                    throw new Error(\"!signature\"); // should never happen\n                }\n                const signature = transaction.signature.toString(\"base64\");\n                if (!this._blockhashInfo.simulatedSignatures.includes(signature) && !this._blockhashInfo.transactionSignatures.includes(signature)) {\n                    // The signature of this transaction has not been seen before with the\n                    // current recentBlockhash, all done. Let's break\n                    this._blockhashInfo.simulatedSignatures.push(signature);\n                    break;\n                } else {\n                    // This transaction would be treated as duplicate (its derived signature\n                    // matched to one of already recorded signatures).\n                    // So, we must fetch a new blockhash for a different signature by disabling\n                    // our cache not to wait for the cache expiration (BLOCKHASH_CACHE_TIMEOUT_MS).\n                    disableCache = true;\n                }\n            }\n        }\n        const message = transaction._compile();\n        const signData = message.serialize();\n        const wireTransaction = transaction._serialize(signData);\n        const encodedTransaction = wireTransaction.toString(\"base64\");\n        const config = {\n            encoding: \"base64\",\n            commitment: this.commitment\n        };\n        if (includeAccounts) {\n            const addresses = (Array.isArray(includeAccounts) ? includeAccounts : message.nonProgramIds()).map((key)=>key.toBase58());\n            config[\"accounts\"] = {\n                encoding: \"base64\",\n                addresses\n            };\n        }\n        if (signers) {\n            config.sigVerify = true;\n        }\n        if (configOrSigners && typeof configOrSigners === \"object\" && \"innerInstructions\" in configOrSigners) {\n            config.innerInstructions = configOrSigners.innerInstructions;\n        }\n        const args = [\n            encodedTransaction,\n            config\n        ];\n        const unsafeRes = await this._rpcRequest(\"simulateTransaction\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, SimulatedTransactionResponseStruct);\n        if (\"error\" in res) {\n            let logs;\n            if (\"data\" in res.error) {\n                logs = res.error.data.logs;\n                if (logs && Array.isArray(logs)) {\n                    const traceIndent = \"\\n    \";\n                    const logTrace = traceIndent + logs.join(traceIndent);\n                    console.error(res.error.message, logTrace);\n                }\n            }\n            throw new SendTransactionError({\n                action: \"simulate\",\n                signature: \"\",\n                transactionMessage: res.error.message,\n                logs: logs\n            });\n        }\n        return res.result;\n    }\n    /**\n   * Sign and send a transaction\n   *\n   * @deprecated Instead, call {@link sendTransaction} with a {@link\n   * VersionedTransaction}\n   */ /**\n   * Send a signed transaction\n   */ // eslint-disable-next-line no-dupe-class-members\n    /**\n   * Sign and send a transaction\n   */ // eslint-disable-next-line no-dupe-class-members\n    async sendTransaction(transaction, signersOrOptions, options) {\n        if (\"version\" in transaction) {\n            if (signersOrOptions && Array.isArray(signersOrOptions)) {\n                throw new Error(\"Invalid arguments\");\n            }\n            const wireTransaction = transaction.serialize();\n            return await this.sendRawTransaction(wireTransaction, signersOrOptions);\n        }\n        if (signersOrOptions === undefined || !Array.isArray(signersOrOptions)) {\n            throw new Error(\"Invalid arguments\");\n        }\n        const signers = signersOrOptions;\n        if (transaction.nonceInfo) {\n            transaction.sign(...signers);\n        } else {\n            let disableCache = this._disableBlockhashCaching;\n            for(;;){\n                const latestBlockhash = await this._blockhashWithExpiryBlockHeight(disableCache);\n                transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;\n                transaction.recentBlockhash = latestBlockhash.blockhash;\n                transaction.sign(...signers);\n                if (!transaction.signature) {\n                    throw new Error(\"!signature\"); // should never happen\n                }\n                const signature = transaction.signature.toString(\"base64\");\n                if (!this._blockhashInfo.transactionSignatures.includes(signature)) {\n                    // The signature of this transaction has not been seen before with the\n                    // current recentBlockhash, all done. Let's break\n                    this._blockhashInfo.transactionSignatures.push(signature);\n                    break;\n                } else {\n                    // This transaction would be treated as duplicate (its derived signature\n                    // matched to one of already recorded signatures).\n                    // So, we must fetch a new blockhash for a different signature by disabling\n                    // our cache not to wait for the cache expiration (BLOCKHASH_CACHE_TIMEOUT_MS).\n                    disableCache = true;\n                }\n            }\n        }\n        const wireTransaction = transaction.serialize();\n        return await this.sendRawTransaction(wireTransaction, options);\n    }\n    /**\n   * Send a transaction that has already been signed and serialized into the\n   * wire format\n   */ async sendRawTransaction(rawTransaction, options) {\n        const encodedTransaction = toBuffer(rawTransaction).toString(\"base64\");\n        const result = await this.sendEncodedTransaction(encodedTransaction, options);\n        return result;\n    }\n    /**\n   * Send a transaction that has already been signed, serialized into the\n   * wire format, and encoded as a base64 string\n   */ async sendEncodedTransaction(encodedTransaction, options) {\n        const config = {\n            encoding: \"base64\"\n        };\n        const skipPreflight = options && options.skipPreflight;\n        const preflightCommitment = skipPreflight === true ? \"processed\" // FIXME Remove when https://github.com/anza-xyz/agave/pull/483 is deployed.\n         : options && options.preflightCommitment || this.commitment;\n        if (options && options.maxRetries != null) {\n            config.maxRetries = options.maxRetries;\n        }\n        if (options && options.minContextSlot != null) {\n            config.minContextSlot = options.minContextSlot;\n        }\n        if (skipPreflight) {\n            config.skipPreflight = skipPreflight;\n        }\n        if (preflightCommitment) {\n            config.preflightCommitment = preflightCommitment;\n        }\n        const args = [\n            encodedTransaction,\n            config\n        ];\n        const unsafeRes = await this._rpcRequest(\"sendTransaction\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(unsafeRes, SendTransactionRpcResult);\n        if (\"error\" in res) {\n            let logs = undefined;\n            if (\"data\" in res.error) {\n                logs = res.error.data.logs;\n            }\n            throw new SendTransactionError({\n                action: skipPreflight ? \"send\" : \"simulate\",\n                signature: \"\",\n                transactionMessage: res.error.message,\n                logs: logs\n            });\n        }\n        return res.result;\n    }\n    /**\n   * @internal\n   */ _wsOnOpen() {\n        this._rpcWebSocketConnected = true;\n        this._rpcWebSocketHeartbeat = setInterval(()=>{\n            // Ping server every 5s to prevent idle timeouts\n            (async ()=>{\n                try {\n                    await this._rpcWebSocket.notify(\"ping\");\n                // eslint-disable-next-line no-empty\n                } catch  {}\n            })();\n        }, 5000);\n        this._updateSubscriptions();\n    }\n    /**\n   * @internal\n   */ _wsOnError(err) {\n        this._rpcWebSocketConnected = false;\n        console.error(\"ws error:\", err.message);\n    }\n    /**\n   * @internal\n   */ _wsOnClose(code) {\n        this._rpcWebSocketConnected = false;\n        this._rpcWebSocketGeneration = (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER;\n        if (this._rpcWebSocketIdleTimeout) {\n            clearTimeout(this._rpcWebSocketIdleTimeout);\n            this._rpcWebSocketIdleTimeout = null;\n        }\n        if (this._rpcWebSocketHeartbeat) {\n            clearInterval(this._rpcWebSocketHeartbeat);\n            this._rpcWebSocketHeartbeat = null;\n        }\n        if (code === 1000) {\n            // explicit close, check if any subscriptions have been made since close\n            this._updateSubscriptions();\n            return;\n        }\n        // implicit close, prepare subscriptions for auto-reconnect\n        this._subscriptionCallbacksByServerSubscriptionId = {};\n        Object.entries(this._subscriptionsByHash).forEach(([hash, subscription])=>{\n            this._setSubscription(hash, {\n                ...subscription,\n                state: \"pending\"\n            });\n        });\n    }\n    /**\n   * @internal\n   */ _setSubscription(hash, nextSubscription) {\n        const prevState = this._subscriptionsByHash[hash]?.state;\n        this._subscriptionsByHash[hash] = nextSubscription;\n        if (prevState !== nextSubscription.state) {\n            const stateChangeCallbacks = this._subscriptionStateChangeCallbacksByHash[hash];\n            if (stateChangeCallbacks) {\n                stateChangeCallbacks.forEach((cb)=>{\n                    try {\n                        cb(nextSubscription.state);\n                    // eslint-disable-next-line no-empty\n                    } catch  {}\n                });\n            }\n        }\n    }\n    /**\n   * @internal\n   */ _onSubscriptionStateChange(clientSubscriptionId, callback) {\n        const hash = this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];\n        if (hash == null) {\n            return ()=>{};\n        }\n        const stateChangeCallbacks = this._subscriptionStateChangeCallbacksByHash[hash] ||= new Set();\n        stateChangeCallbacks.add(callback);\n        return ()=>{\n            stateChangeCallbacks.delete(callback);\n            if (stateChangeCallbacks.size === 0) {\n                delete this._subscriptionStateChangeCallbacksByHash[hash];\n            }\n        };\n    }\n    /**\n   * @internal\n   */ async _updateSubscriptions() {\n        if (Object.keys(this._subscriptionsByHash).length === 0) {\n            if (this._rpcWebSocketConnected) {\n                this._rpcWebSocketConnected = false;\n                this._rpcWebSocketIdleTimeout = setTimeout(()=>{\n                    this._rpcWebSocketIdleTimeout = null;\n                    try {\n                        this._rpcWebSocket.close();\n                    } catch (err) {\n                        // swallow error if socket has already been closed.\n                        if (err instanceof Error) {\n                            console.log(`Error when closing socket connection: ${err.message}`);\n                        }\n                    }\n                }, 500);\n            }\n            return;\n        }\n        if (this._rpcWebSocketIdleTimeout !== null) {\n            clearTimeout(this._rpcWebSocketIdleTimeout);\n            this._rpcWebSocketIdleTimeout = null;\n            this._rpcWebSocketConnected = true;\n        }\n        if (!this._rpcWebSocketConnected) {\n            this._rpcWebSocket.connect();\n            return;\n        }\n        const activeWebSocketGeneration = this._rpcWebSocketGeneration;\n        const isCurrentConnectionStillActive = ()=>{\n            return activeWebSocketGeneration === this._rpcWebSocketGeneration;\n        };\n        await Promise.all(// Don't be tempted to change this to `Object.entries`. We call\n        // `_updateSubscriptions` recursively when processing the state,\n        // so it's important that we look up the *current* version of\n        // each subscription, every time we process a hash.\n        Object.keys(this._subscriptionsByHash).map(async (hash)=>{\n            const subscription = this._subscriptionsByHash[hash];\n            if (subscription === undefined) {\n                // This entry has since been deleted. Skip.\n                return;\n            }\n            switch(subscription.state){\n                case \"pending\":\n                case \"unsubscribed\":\n                    if (subscription.callbacks.size === 0) {\n                        /**\n             * You can end up here when:\n             *\n             * - a subscription has recently unsubscribed\n             *   without having new callbacks added to it\n             *   while the unsubscribe was in flight, or\n             * - when a pending subscription has its\n             *   listeners removed before a request was\n             *   sent to the server.\n             *\n             * Being that nobody is interested in this\n             * subscription any longer, delete it.\n             */ delete this._subscriptionsByHash[hash];\n                        if (subscription.state === \"unsubscribed\") {\n                            delete this._subscriptionCallbacksByServerSubscriptionId[subscription.serverSubscriptionId];\n                        }\n                        await this._updateSubscriptions();\n                        return;\n                    }\n                    await (async ()=>{\n                        const { args, method } = subscription;\n                        try {\n                            this._setSubscription(hash, {\n                                ...subscription,\n                                state: \"subscribing\"\n                            });\n                            const serverSubscriptionId = await this._rpcWebSocket.call(method, args);\n                            this._setSubscription(hash, {\n                                ...subscription,\n                                serverSubscriptionId,\n                                state: \"subscribed\"\n                            });\n                            this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId] = subscription.callbacks;\n                            await this._updateSubscriptions();\n                        } catch (e) {\n                            console.error(`Received ${e instanceof Error ? \"\" : \"JSON-RPC \"}error calling \\`${method}\\``, {\n                                args,\n                                error: e\n                            });\n                            if (!isCurrentConnectionStillActive()) {\n                                return;\n                            }\n                            // TODO: Maybe add an 'errored' state or a retry limit?\n                            this._setSubscription(hash, {\n                                ...subscription,\n                                state: \"pending\"\n                            });\n                            await this._updateSubscriptions();\n                        }\n                    })();\n                    break;\n                case \"subscribed\":\n                    if (subscription.callbacks.size === 0) {\n                        // By the time we successfully set up a subscription\n                        // with the server, the client stopped caring about it.\n                        // Tear it down now.\n                        await (async ()=>{\n                            const { serverSubscriptionId, unsubscribeMethod } = subscription;\n                            if (this._subscriptionsAutoDisposedByRpc.has(serverSubscriptionId)) {\n                                /**\n                 * Special case.\n                 * If we're dealing with a subscription that has been auto-\n                 * disposed by the RPC, then we can skip the RPC call to\n                 * tear down the subscription here.\n                 *\n                 * NOTE: There is a proposal to eliminate this special case, here:\n                 * https://github.com/solana-labs/solana/issues/18892\n                 */ this._subscriptionsAutoDisposedByRpc.delete(serverSubscriptionId);\n                            } else {\n                                this._setSubscription(hash, {\n                                    ...subscription,\n                                    state: \"unsubscribing\"\n                                });\n                                this._setSubscription(hash, {\n                                    ...subscription,\n                                    state: \"unsubscribing\"\n                                });\n                                try {\n                                    await this._rpcWebSocket.call(unsubscribeMethod, [\n                                        serverSubscriptionId\n                                    ]);\n                                } catch (e) {\n                                    if (e instanceof Error) {\n                                        console.error(`${unsubscribeMethod} error:`, e.message);\n                                    }\n                                    if (!isCurrentConnectionStillActive()) {\n                                        return;\n                                    }\n                                    // TODO: Maybe add an 'errored' state or a retry limit?\n                                    this._setSubscription(hash, {\n                                        ...subscription,\n                                        state: \"subscribed\"\n                                    });\n                                    await this._updateSubscriptions();\n                                    return;\n                                }\n                            }\n                            this._setSubscription(hash, {\n                                ...subscription,\n                                state: \"unsubscribed\"\n                            });\n                            await this._updateSubscriptions();\n                        })();\n                    }\n                    break;\n            }\n        }));\n    }\n    /**\n   * @internal\n   */ _handleServerNotification(serverSubscriptionId, callbackArgs) {\n        const callbacks = this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId];\n        if (callbacks === undefined) {\n            return;\n        }\n        callbacks.forEach((cb)=>{\n            try {\n                cb(// I failed to find a way to convince TypeScript that `cb` is of type\n                // `TCallback` which is certainly compatible with `Parameters<TCallback>`.\n                // See https://github.com/microsoft/TypeScript/issues/47615\n                // @ts-ignore\n                ...callbackArgs);\n            } catch (e) {\n                console.error(e);\n            }\n        });\n    }\n    /**\n   * @internal\n   */ _wsOnAccountNotification(notification) {\n        const { result, subscription } = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(notification, AccountNotificationResult);\n        this._handleServerNotification(subscription, [\n            result.value,\n            result.context\n        ]);\n    }\n    /**\n   * @internal\n   */ _makeSubscription(subscriptionConfig, /**\n   * When preparing `args` for a call to `_makeSubscription`, be sure\n   * to carefully apply a default `commitment` property, if necessary.\n   *\n   * - If the user supplied a `commitment` use that.\n   * - Otherwise, if the `Connection::commitment` is set, use that.\n   * - Otherwise, set it to the RPC server default: `finalized`.\n   *\n   * This is extremely important to ensure that these two fundamentally\n   * identical subscriptions produce the same identifying hash:\n   *\n   * - A subscription made without specifying a commitment.\n   * - A subscription made where the commitment specified is the same\n   *   as the default applied to the subscription above.\n   *\n   * Example; these two subscriptions must produce the same hash:\n   *\n   * - An `accountSubscribe` subscription for `'PUBKEY'`\n   * - An `accountSubscribe` subscription for `'PUBKEY'` with commitment\n   *   `'finalized'`.\n   *\n   * See the 'making a subscription with defaulted params omitted' test\n   * in `connection-subscriptions.ts` for more.\n   */ args) {\n        const clientSubscriptionId = this._nextClientSubscriptionId++;\n        const hash = fastStableStringify([\n            subscriptionConfig.method,\n            args\n        ]);\n        const existingSubscription = this._subscriptionsByHash[hash];\n        if (existingSubscription === undefined) {\n            this._subscriptionsByHash[hash] = {\n                ...subscriptionConfig,\n                args,\n                callbacks: new Set([\n                    subscriptionConfig.callback\n                ]),\n                state: \"pending\"\n            };\n        } else {\n            existingSubscription.callbacks.add(subscriptionConfig.callback);\n        }\n        this._subscriptionHashByClientSubscriptionId[clientSubscriptionId] = hash;\n        this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId] = async ()=>{\n            delete this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];\n            delete this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];\n            const subscription = this._subscriptionsByHash[hash];\n            assert(subscription !== undefined, `Could not find a \\`Subscription\\` when tearing down client subscription #${clientSubscriptionId}`);\n            subscription.callbacks.delete(subscriptionConfig.callback);\n            await this._updateSubscriptions();\n        };\n        this._updateSubscriptions();\n        return clientSubscriptionId;\n    }\n    /**\n   * Register a callback to be invoked whenever the specified account changes\n   *\n   * @param publicKey Public key of the account to monitor\n   * @param callback Function to invoke whenever the account is changed\n   * @param config\n   * @return subscription id\n   */ /** @deprecated Instead, pass in an {@link AccountSubscriptionConfig} */ // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    onAccountChange(publicKey, callback, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([\n            publicKey.toBase58()\n        ], commitment || this._commitment || \"finalized\", // Apply connection/server default.\n        \"base64\", config);\n        return this._makeSubscription({\n            callback,\n            method: \"accountSubscribe\",\n            unsubscribeMethod: \"accountUnsubscribe\"\n        }, args);\n    }\n    /**\n   * Deregister an account notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */ async removeAccountChangeListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"account change\");\n    }\n    /**\n   * @internal\n   */ _wsOnProgramAccountNotification(notification) {\n        const { result, subscription } = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(notification, ProgramAccountNotificationResult);\n        this._handleServerNotification(subscription, [\n            {\n                accountId: result.value.pubkey,\n                accountInfo: result.value.account\n            },\n            result.context\n        ]);\n    }\n    /**\n   * Register a callback to be invoked whenever accounts owned by the\n   * specified program change\n   *\n   * @param programId Public key of the program to monitor\n   * @param callback Function to invoke whenever the account is changed\n   * @param config\n   * @return subscription id\n   */ /** @deprecated Instead, pass in a {@link ProgramAccountSubscriptionConfig} */ // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    onProgramAccountChange(programId, callback, commitmentOrConfig, maybeFilters) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([\n            programId.toBase58()\n        ], commitment || this._commitment || \"finalized\", // Apply connection/server default.\n        \"base64\" /* encoding */ , config ? config : maybeFilters ? {\n            filters: applyDefaultMemcmpEncodingToFilters(maybeFilters)\n        } : undefined /* extra */ );\n        return this._makeSubscription({\n            callback,\n            method: \"programSubscribe\",\n            unsubscribeMethod: \"programUnsubscribe\"\n        }, args);\n    }\n    /**\n   * Deregister an account notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */ async removeProgramAccountChangeListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"program account change\");\n    }\n    /**\n   * Registers a callback to be invoked whenever logs are emitted.\n   */ onLogs(filter, callback, commitment) {\n        const args = this._buildArgs([\n            typeof filter === \"object\" ? {\n                mentions: [\n                    filter.toString()\n                ]\n            } : filter\n        ], commitment || this._commitment || \"finalized\" // Apply connection/server default.\n        );\n        return this._makeSubscription({\n            callback,\n            method: \"logsSubscribe\",\n            unsubscribeMethod: \"logsUnsubscribe\"\n        }, args);\n    }\n    /**\n   * Deregister a logs callback.\n   *\n   * @param clientSubscriptionId client subscription id to deregister.\n   */ async removeOnLogsListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"logs\");\n    }\n    /**\n   * @internal\n   */ _wsOnLogsNotification(notification) {\n        const { result, subscription } = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(notification, LogsNotificationResult);\n        this._handleServerNotification(subscription, [\n            result.value,\n            result.context\n        ]);\n    }\n    /**\n   * @internal\n   */ _wsOnSlotNotification(notification) {\n        const { result, subscription } = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(notification, SlotNotificationResult);\n        this._handleServerNotification(subscription, [\n            result\n        ]);\n    }\n    /**\n   * Register a callback to be invoked upon slot changes\n   *\n   * @param callback Function to invoke whenever the slot changes\n   * @return subscription id\n   */ onSlotChange(callback) {\n        return this._makeSubscription({\n            callback,\n            method: \"slotSubscribe\",\n            unsubscribeMethod: \"slotUnsubscribe\"\n        }, []);\n    }\n    /**\n   * Deregister a slot notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */ async removeSlotChangeListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"slot change\");\n    }\n    /**\n   * @internal\n   */ _wsOnSlotUpdatesNotification(notification) {\n        const { result, subscription } = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(notification, SlotUpdateNotificationResult);\n        this._handleServerNotification(subscription, [\n            result\n        ]);\n    }\n    /**\n   * Register a callback to be invoked upon slot updates. {@link SlotUpdate}'s\n   * may be useful to track live progress of a cluster.\n   *\n   * @param callback Function to invoke whenever the slot updates\n   * @return subscription id\n   */ onSlotUpdate(callback) {\n        return this._makeSubscription({\n            callback,\n            method: \"slotsUpdatesSubscribe\",\n            unsubscribeMethod: \"slotsUpdatesUnsubscribe\"\n        }, []);\n    }\n    /**\n   * Deregister a slot update notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */ async removeSlotUpdateListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"slot update\");\n    }\n    /**\n   * @internal\n   */ async _unsubscribeClientSubscription(clientSubscriptionId, subscriptionName) {\n        const dispose = this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];\n        if (dispose) {\n            await dispose();\n        } else {\n            console.warn(\"Ignored unsubscribe request because an active subscription with id \" + `\\`${clientSubscriptionId}\\` for '${subscriptionName}' events ` + \"could not be found.\");\n        }\n    }\n    _buildArgs(args, override, encoding, extra) {\n        const commitment = override || this._commitment;\n        if (commitment || encoding || extra) {\n            let options = {};\n            if (encoding) {\n                options.encoding = encoding;\n            }\n            if (commitment) {\n                options.commitment = commitment;\n            }\n            if (extra) {\n                options = Object.assign(options, extra);\n            }\n            args.push(options);\n        }\n        return args;\n    }\n    /**\n   * @internal\n   */ _buildArgsAtLeastConfirmed(args, override, encoding, extra) {\n        const commitment = override || this._commitment;\n        if (commitment && ![\n            \"confirmed\",\n            \"finalized\"\n        ].includes(commitment)) {\n            throw new Error(\"Using Connection with default commitment: `\" + this._commitment + \"`, but method requires at least `confirmed`\");\n        }\n        return this._buildArgs(args, override, encoding, extra);\n    }\n    /**\n   * @internal\n   */ _wsOnSignatureNotification(notification) {\n        const { result, subscription } = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(notification, SignatureNotificationResult);\n        if (result.value !== \"receivedSignature\") {\n            /**\n       * Special case.\n       * After a signature is processed, RPCs automatically dispose of the\n       * subscription on the server side. We need to track which of these\n       * subscriptions have been disposed in such a way, so that we know\n       * whether the client is dealing with a not-yet-processed signature\n       * (in which case we must tear down the server subscription) or an\n       * already-processed signature (in which case the client can simply\n       * clear out the subscription locally without telling the server).\n       *\n       * NOTE: There is a proposal to eliminate this special case, here:\n       * https://github.com/solana-labs/solana/issues/18892\n       */ this._subscriptionsAutoDisposedByRpc.add(subscription);\n        }\n        this._handleServerNotification(subscription, result.value === \"receivedSignature\" ? [\n            {\n                type: \"received\"\n            },\n            result.context\n        ] : [\n            {\n                type: \"status\",\n                result: result.value\n            },\n            result.context\n        ]);\n    }\n    /**\n   * Register a callback to be invoked upon signature updates\n   *\n   * @param signature Transaction signature string in base 58\n   * @param callback Function to invoke on signature notifications\n   * @param commitment Specify the commitment level signature must reach before notification\n   * @return subscription id\n   */ onSignature(signature, callback, commitment) {\n        const args = this._buildArgs([\n            signature\n        ], commitment || this._commitment || \"finalized\" // Apply connection/server default.\n        );\n        const clientSubscriptionId = this._makeSubscription({\n            callback: (notification, context)=>{\n                if (notification.type === \"status\") {\n                    callback(notification.result, context);\n                    // Signatures subscriptions are auto-removed by the RPC service\n                    // so no need to explicitly send an unsubscribe message.\n                    try {\n                        this.removeSignatureListener(clientSubscriptionId);\n                    // eslint-disable-next-line no-empty\n                    } catch (_err) {\n                    // Already removed.\n                    }\n                }\n            },\n            method: \"signatureSubscribe\",\n            unsubscribeMethod: \"signatureUnsubscribe\"\n        }, args);\n        return clientSubscriptionId;\n    }\n    /**\n   * Register a callback to be invoked when a transaction is\n   * received and/or processed.\n   *\n   * @param signature Transaction signature string in base 58\n   * @param callback Function to invoke on signature notifications\n   * @param options Enable received notifications and set the commitment\n   *   level that signature must reach before notification\n   * @return subscription id\n   */ onSignatureWithOptions(signature, callback, options) {\n        const { commitment, ...extra } = {\n            ...options,\n            commitment: options && options.commitment || this._commitment || \"finalized\" // Apply connection/server default.\n        };\n        const args = this._buildArgs([\n            signature\n        ], commitment, undefined /* encoding */ , extra);\n        const clientSubscriptionId = this._makeSubscription({\n            callback: (notification, context)=>{\n                callback(notification, context);\n                // Signatures subscriptions are auto-removed by the RPC service\n                // so no need to explicitly send an unsubscribe message.\n                try {\n                    this.removeSignatureListener(clientSubscriptionId);\n                // eslint-disable-next-line no-empty\n                } catch (_err) {\n                // Already removed.\n                }\n            },\n            method: \"signatureSubscribe\",\n            unsubscribeMethod: \"signatureUnsubscribe\"\n        }, args);\n        return clientSubscriptionId;\n    }\n    /**\n   * Deregister a signature notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */ async removeSignatureListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"signature result\");\n    }\n    /**\n   * @internal\n   */ _wsOnRootNotification(notification) {\n        const { result, subscription } = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.create)(notification, RootNotificationResult);\n        this._handleServerNotification(subscription, [\n            result\n        ]);\n    }\n    /**\n   * Register a callback to be invoked upon root changes\n   *\n   * @param callback Function to invoke whenever the root changes\n   * @return subscription id\n   */ onRootChange(callback) {\n        return this._makeSubscription({\n            callback,\n            method: \"rootSubscribe\",\n            unsubscribeMethod: \"rootUnsubscribe\"\n        }, []);\n    }\n    /**\n   * Deregister a root notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */ async removeRootChangeListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"root change\");\n    }\n}\n/**\n * Keypair signer interface\n */ /**\n * An account keypair used for signing transactions.\n */ class Keypair {\n    /**\n   * Create a new keypair instance.\n   * Generate random keypair if no {@link Ed25519Keypair} is provided.\n   *\n   * @param {Ed25519Keypair} keypair ed25519 keypair\n   */ constructor(keypair){\n        this._keypair = void 0;\n        this._keypair = keypair ?? generateKeypair();\n    }\n    /**\n   * Generate a new random keypair\n   *\n   * @returns {Keypair} Keypair\n   */ static generate() {\n        return new Keypair(generateKeypair());\n    }\n    /**\n   * Create a keypair from a raw secret key byte array.\n   *\n   * This method should only be used to recreate a keypair from a previously\n   * generated secret key. Generating keypairs from a random seed should be done\n   * with the {@link Keypair.fromSeed} method.\n   *\n   * @throws error if the provided secret key is invalid and validation is not skipped.\n   *\n   * @param secretKey secret key byte array\n   * @param options skip secret key validation\n   *\n   * @returns {Keypair} Keypair\n   */ static fromSecretKey(secretKey, options) {\n        if (secretKey.byteLength !== 64) {\n            throw new Error(\"bad secret key size\");\n        }\n        const publicKey = secretKey.slice(32, 64);\n        if (!options || !options.skipValidation) {\n            const privateScalar = secretKey.slice(0, 32);\n            const computedPublicKey = getPublicKey(privateScalar);\n            for(let ii = 0; ii < 32; ii++){\n                if (publicKey[ii] !== computedPublicKey[ii]) {\n                    throw new Error(\"provided secretKey is invalid\");\n                }\n            }\n        }\n        return new Keypair({\n            publicKey,\n            secretKey\n        });\n    }\n    /**\n   * Generate a keypair from a 32 byte seed.\n   *\n   * @param seed seed byte array\n   *\n   * @returns {Keypair} Keypair\n   */ static fromSeed(seed) {\n        const publicKey = getPublicKey(seed);\n        const secretKey = new Uint8Array(64);\n        secretKey.set(seed);\n        secretKey.set(publicKey, 32);\n        return new Keypair({\n            publicKey,\n            secretKey\n        });\n    }\n    /**\n   * The public key for this keypair\n   *\n   * @returns {PublicKey} PublicKey\n   */ get publicKey() {\n        return new PublicKey(this._keypair.publicKey);\n    }\n    /**\n   * The raw secret key for this keypair\n   * @returns {Uint8Array} Secret key in an array of Uint8 bytes\n   */ get secretKey() {\n        return new Uint8Array(this._keypair.secretKey);\n    }\n}\n/**\n * An enumeration of valid LookupTableInstructionType's\n */ /**\n * An enumeration of valid address lookup table InstructionType's\n * @internal\n */ const LOOKUP_TABLE_INSTRUCTION_LAYOUTS = Object.freeze({\n    CreateLookupTable: {\n        index: 0,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            u64(\"recentSlot\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"bumpSeed\")\n        ])\n    },\n    FreezeLookupTable: {\n        index: 1,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    },\n    ExtendLookupTable: {\n        index: 2,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            u64(),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(publicKey(), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(), -8), \"addresses\")\n        ])\n    },\n    DeactivateLookupTable: {\n        index: 3,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    },\n    CloseLookupTable: {\n        index: 4,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    }\n});\nclass AddressLookupTableInstruction {\n    /**\n   * @internal\n   */ constructor(){}\n    static decodeInstructionType(instruction) {\n        this.checkProgramId(instruction.programId);\n        const instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\");\n        const index = instructionTypeLayout.decode(instruction.data);\n        let type;\n        for (const [layoutType, layout] of Object.entries(LOOKUP_TABLE_INSTRUCTION_LAYOUTS)){\n            if (layout.index == index) {\n                type = layoutType;\n                break;\n            }\n        }\n        if (!type) {\n            throw new Error(\"Invalid Instruction. Should be a LookupTable Instruction\");\n        }\n        return type;\n    }\n    static decodeCreateLookupTable(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeysLength(instruction.keys, 4);\n        const { recentSlot } = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable, instruction.data);\n        return {\n            authority: instruction.keys[1].pubkey,\n            payer: instruction.keys[2].pubkey,\n            recentSlot: Number(recentSlot)\n        };\n    }\n    static decodeExtendLookupTable(instruction) {\n        this.checkProgramId(instruction.programId);\n        if (instruction.keys.length < 2) {\n            throw new Error(`invalid instruction; found ${instruction.keys.length} keys, expected at least 2`);\n        }\n        const { addresses } = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable, instruction.data);\n        return {\n            lookupTable: instruction.keys[0].pubkey,\n            authority: instruction.keys[1].pubkey,\n            payer: instruction.keys.length > 2 ? instruction.keys[2].pubkey : undefined,\n            addresses: addresses.map((buffer)=>new PublicKey(buffer))\n        };\n    }\n    static decodeCloseLookupTable(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeysLength(instruction.keys, 3);\n        return {\n            lookupTable: instruction.keys[0].pubkey,\n            authority: instruction.keys[1].pubkey,\n            recipient: instruction.keys[2].pubkey\n        };\n    }\n    static decodeFreezeLookupTable(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeysLength(instruction.keys, 2);\n        return {\n            lookupTable: instruction.keys[0].pubkey,\n            authority: instruction.keys[1].pubkey\n        };\n    }\n    static decodeDeactivateLookupTable(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeysLength(instruction.keys, 2);\n        return {\n            lookupTable: instruction.keys[0].pubkey,\n            authority: instruction.keys[1].pubkey\n        };\n    }\n    /**\n   * @internal\n   */ static checkProgramId(programId) {\n        if (!programId.equals(AddressLookupTableProgram.programId)) {\n            throw new Error(\"invalid instruction; programId is not AddressLookupTable Program\");\n        }\n    }\n    /**\n   * @internal\n   */ static checkKeysLength(keys, expectedLength) {\n        if (keys.length < expectedLength) {\n            throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);\n        }\n    }\n}\nclass AddressLookupTableProgram {\n    /**\n   * @internal\n   */ constructor(){}\n    static createLookupTable(params) {\n        const [lookupTableAddress, bumpSeed] = PublicKey.findProgramAddressSync([\n            params.authority.toBuffer(),\n            (0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_13__.getU64Encoder)().encode(params.recentSlot)\n        ], this.programId);\n        const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable;\n        const data = encodeData(type, {\n            recentSlot: BigInt(params.recentSlot),\n            bumpSeed: bumpSeed\n        });\n        const keys = [\n            {\n                pubkey: lookupTableAddress,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: params.authority,\n                isSigner: true,\n                isWritable: false\n            },\n            {\n                pubkey: params.payer,\n                isSigner: true,\n                isWritable: true\n            },\n            {\n                pubkey: SystemProgram.programId,\n                isSigner: false,\n                isWritable: false\n            }\n        ];\n        return [\n            new TransactionInstruction({\n                programId: this.programId,\n                keys: keys,\n                data: data\n            }),\n            lookupTableAddress\n        ];\n    }\n    static freezeLookupTable(params) {\n        const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.FreezeLookupTable;\n        const data = encodeData(type);\n        const keys = [\n            {\n                pubkey: params.lookupTable,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: params.authority,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        return new TransactionInstruction({\n            programId: this.programId,\n            keys: keys,\n            data: data\n        });\n    }\n    static extendLookupTable(params) {\n        const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable;\n        const data = encodeData(type, {\n            addresses: params.addresses.map((addr)=>addr.toBytes())\n        });\n        const keys = [\n            {\n                pubkey: params.lookupTable,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: params.authority,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        if (params.payer) {\n            keys.push({\n                pubkey: params.payer,\n                isSigner: true,\n                isWritable: true\n            }, {\n                pubkey: SystemProgram.programId,\n                isSigner: false,\n                isWritable: false\n            });\n        }\n        return new TransactionInstruction({\n            programId: this.programId,\n            keys: keys,\n            data: data\n        });\n    }\n    static deactivateLookupTable(params) {\n        const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.DeactivateLookupTable;\n        const data = encodeData(type);\n        const keys = [\n            {\n                pubkey: params.lookupTable,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: params.authority,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        return new TransactionInstruction({\n            programId: this.programId,\n            keys: keys,\n            data: data\n        });\n    }\n    static closeLookupTable(params) {\n        const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CloseLookupTable;\n        const data = encodeData(type);\n        const keys = [\n            {\n                pubkey: params.lookupTable,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: params.authority,\n                isSigner: true,\n                isWritable: false\n            },\n            {\n                pubkey: params.recipient,\n                isSigner: false,\n                isWritable: true\n            }\n        ];\n        return new TransactionInstruction({\n            programId: this.programId,\n            keys: keys,\n            data: data\n        });\n    }\n}\nAddressLookupTableProgram.programId = new PublicKey(\"AddressLookupTab1e1111111111111111111111111\");\n/**\n * Compute Budget Instruction class\n */ class ComputeBudgetInstruction {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Decode a compute budget instruction and retrieve the instruction type.\n   */ static decodeInstructionType(instruction) {\n        this.checkProgramId(instruction.programId);\n        const instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"instruction\");\n        const typeIndex = instructionTypeLayout.decode(instruction.data);\n        let type;\n        for (const [ixType, layout] of Object.entries(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS)){\n            if (layout.index == typeIndex) {\n                type = ixType;\n                break;\n            }\n        }\n        if (!type) {\n            throw new Error(\"Instruction type incorrect; not a ComputeBudgetInstruction\");\n        }\n        return type;\n    }\n    /**\n   * Decode request units compute budget instruction and retrieve the instruction params.\n   */ static decodeRequestUnits(instruction) {\n        this.checkProgramId(instruction.programId);\n        const { units, additionalFee } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits, instruction.data);\n        return {\n            units,\n            additionalFee\n        };\n    }\n    /**\n   * Decode request heap frame compute budget instruction and retrieve the instruction params.\n   */ static decodeRequestHeapFrame(instruction) {\n        this.checkProgramId(instruction.programId);\n        const { bytes } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame, instruction.data);\n        return {\n            bytes\n        };\n    }\n    /**\n   * Decode set compute unit limit compute budget instruction and retrieve the instruction params.\n   */ static decodeSetComputeUnitLimit(instruction) {\n        this.checkProgramId(instruction.programId);\n        const { units } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit, instruction.data);\n        return {\n            units\n        };\n    }\n    /**\n   * Decode set compute unit price compute budget instruction and retrieve the instruction params.\n   */ static decodeSetComputeUnitPrice(instruction) {\n        this.checkProgramId(instruction.programId);\n        const { microLamports } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice, instruction.data);\n        return {\n            microLamports\n        };\n    }\n    /**\n   * @internal\n   */ static checkProgramId(programId) {\n        if (!programId.equals(ComputeBudgetProgram.programId)) {\n            throw new Error(\"invalid instruction; programId is not ComputeBudgetProgram\");\n        }\n    }\n}\n/**\n * An enumeration of valid ComputeBudgetInstructionType's\n */ /**\n * Request units instruction params\n */ /**\n * Request heap frame instruction params\n */ /**\n * Set compute unit limit instruction params\n */ /**\n * Set compute unit price instruction params\n */ /**\n * An enumeration of valid ComputeBudget InstructionType's\n * @internal\n */ const COMPUTE_BUDGET_INSTRUCTION_LAYOUTS = Object.freeze({\n    RequestUnits: {\n        index: 0,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"units\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"additionalFee\")\n        ])\n    },\n    RequestHeapFrame: {\n        index: 1,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"bytes\")\n        ])\n    },\n    SetComputeUnitLimit: {\n        index: 2,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"units\")\n        ])\n    },\n    SetComputeUnitPrice: {\n        index: 3,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"instruction\"),\n            u64(\"microLamports\")\n        ])\n    }\n});\n/**\n * Factory class for transaction instructions to interact with the Compute Budget program\n */ class ComputeBudgetProgram {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Public key that identifies the Compute Budget program\n   */ /**\n   * @deprecated Instead, call {@link setComputeUnitLimit} and/or {@link setComputeUnitPrice}\n   */ static requestUnits(params) {\n        const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits;\n        const data = encodeData(type, params);\n        return new TransactionInstruction({\n            keys: [],\n            programId: this.programId,\n            data\n        });\n    }\n    static requestHeapFrame(params) {\n        const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame;\n        const data = encodeData(type, params);\n        return new TransactionInstruction({\n            keys: [],\n            programId: this.programId,\n            data\n        });\n    }\n    static setComputeUnitLimit(params) {\n        const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit;\n        const data = encodeData(type, params);\n        return new TransactionInstruction({\n            keys: [],\n            programId: this.programId,\n            data\n        });\n    }\n    static setComputeUnitPrice(params) {\n        const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice;\n        const data = encodeData(type, {\n            microLamports: BigInt(params.microLamports)\n        });\n        return new TransactionInstruction({\n            keys: [],\n            programId: this.programId,\n            data\n        });\n    }\n}\nComputeBudgetProgram.programId = new PublicKey(\"ComputeBudget111111111111111111111111111111\");\nconst PRIVATE_KEY_BYTES$1 = 64;\nconst PUBLIC_KEY_BYTES$1 = 32;\nconst SIGNATURE_BYTES = 64;\n/**\n * Params for creating an ed25519 instruction using a public key\n */ /**\n * Params for creating an ed25519 instruction using a private key\n */ const ED25519_INSTRUCTION_LAYOUT = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"numSignatures\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"padding\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"signatureOffset\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"signatureInstructionIndex\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"publicKeyOffset\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"publicKeyInstructionIndex\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"messageDataOffset\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"messageDataSize\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"messageInstructionIndex\")\n]);\nclass Ed25519Program {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Public key that identifies the ed25519 program\n   */ /**\n   * Create an ed25519 instruction with a public key and signature. The\n   * public key must be a buffer that is 32 bytes long, and the signature\n   * must be a buffer of 64 bytes.\n   */ static createInstructionWithPublicKey(params) {\n        const { publicKey, message, signature, instructionIndex } = params;\n        assert(publicKey.length === PUBLIC_KEY_BYTES$1, `Public Key must be ${PUBLIC_KEY_BYTES$1} bytes but received ${publicKey.length} bytes`);\n        assert(signature.length === SIGNATURE_BYTES, `Signature must be ${SIGNATURE_BYTES} bytes but received ${signature.length} bytes`);\n        const publicKeyOffset = ED25519_INSTRUCTION_LAYOUT.span;\n        const signatureOffset = publicKeyOffset + publicKey.length;\n        const messageDataOffset = signatureOffset + signature.length;\n        const numSignatures = 1;\n        const instructionData = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(messageDataOffset + message.length);\n        const index = instructionIndex == null ? 0xffff // An index of `u16::MAX` makes it default to the current instruction.\n         : instructionIndex;\n        ED25519_INSTRUCTION_LAYOUT.encode({\n            numSignatures,\n            padding: 0,\n            signatureOffset,\n            signatureInstructionIndex: index,\n            publicKeyOffset,\n            publicKeyInstructionIndex: index,\n            messageDataOffset,\n            messageDataSize: message.length,\n            messageInstructionIndex: index\n        }, instructionData);\n        instructionData.fill(publicKey, publicKeyOffset);\n        instructionData.fill(signature, signatureOffset);\n        instructionData.fill(message, messageDataOffset);\n        return new TransactionInstruction({\n            keys: [],\n            programId: Ed25519Program.programId,\n            data: instructionData\n        });\n    }\n    /**\n   * Create an ed25519 instruction with a private key. The private key\n   * must be a buffer that is 64 bytes long.\n   */ static createInstructionWithPrivateKey(params) {\n        const { privateKey, message, instructionIndex } = params;\n        assert(privateKey.length === PRIVATE_KEY_BYTES$1, `Private key must be ${PRIVATE_KEY_BYTES$1} bytes but received ${privateKey.length} bytes`);\n        try {\n            const keypair = Keypair.fromSecretKey(privateKey);\n            const publicKey = keypair.publicKey.toBytes();\n            const signature = sign(message, keypair.secretKey);\n            return this.createInstructionWithPublicKey({\n                publicKey,\n                message,\n                signature,\n                instructionIndex\n            });\n        } catch (error) {\n            throw new Error(`Error creating instruction; ${error}`);\n        }\n    }\n}\nEd25519Program.programId = new PublicKey(\"Ed25519SigVerify111111111111111111111111111\");\nconst ecdsaSign = (msgHash, privKey)=>{\n    const signature = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_15__.secp256k1.sign(msgHash, privKey);\n    return [\n        signature.toCompactRawBytes(),\n        signature.recovery\n    ];\n};\n_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_15__.secp256k1.utils.isValidPrivateKey;\nconst publicKeyCreate = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_15__.secp256k1.getPublicKey;\nconst PRIVATE_KEY_BYTES = 32;\nconst ETHEREUM_ADDRESS_BYTES = 20;\nconst PUBLIC_KEY_BYTES = 64;\nconst SIGNATURE_OFFSETS_SERIALIZED_SIZE = 11;\n/**\n * Params for creating an secp256k1 instruction using a public key\n */ /**\n * Params for creating an secp256k1 instruction using an Ethereum address\n */ /**\n * Params for creating an secp256k1 instruction using a private key\n */ const SECP256K1_INSTRUCTION_LAYOUT = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"numSignatures\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"signatureOffset\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"signatureInstructionIndex\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"ethAddressOffset\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"ethAddressInstructionIndex\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"messageDataOffset\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"messageDataSize\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"messageInstructionIndex\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(20, \"ethAddress\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(64, \"signature\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"recoveryId\")\n]);\nclass Secp256k1Program {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Public key that identifies the secp256k1 program\n   */ /**\n   * Construct an Ethereum address from a secp256k1 public key buffer.\n   * @param {Buffer} publicKey a 64 byte secp256k1 public key buffer\n   */ static publicKeyToEthAddress(publicKey) {\n        assert(publicKey.length === PUBLIC_KEY_BYTES, `Public key must be ${PUBLIC_KEY_BYTES} bytes but received ${publicKey.length} bytes`);\n        try {\n            return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from((0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_16__.keccak_256)(toBuffer(publicKey))).slice(-ETHEREUM_ADDRESS_BYTES);\n        } catch (error) {\n            throw new Error(`Error constructing Ethereum address: ${error}`);\n        }\n    }\n    /**\n   * Create an secp256k1 instruction with a public key. The public key\n   * must be a buffer that is 64 bytes long.\n   */ static createInstructionWithPublicKey(params) {\n        const { publicKey, message, signature, recoveryId, instructionIndex } = params;\n        return Secp256k1Program.createInstructionWithEthAddress({\n            ethAddress: Secp256k1Program.publicKeyToEthAddress(publicKey),\n            message,\n            signature,\n            recoveryId,\n            instructionIndex\n        });\n    }\n    /**\n   * Create an secp256k1 instruction with an Ethereum address. The address\n   * must be a hex string or a buffer that is 20 bytes long.\n   */ static createInstructionWithEthAddress(params) {\n        const { ethAddress: rawAddress, message, signature, recoveryId, instructionIndex = 0 } = params;\n        let ethAddress;\n        if (typeof rawAddress === \"string\") {\n            if (rawAddress.startsWith(\"0x\")) {\n                ethAddress = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(rawAddress.substr(2), \"hex\");\n            } else {\n                ethAddress = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(rawAddress, \"hex\");\n            }\n        } else {\n            ethAddress = rawAddress;\n        }\n        assert(ethAddress.length === ETHEREUM_ADDRESS_BYTES, `Address must be ${ETHEREUM_ADDRESS_BYTES} bytes but received ${ethAddress.length} bytes`);\n        const dataStart = 1 + SIGNATURE_OFFSETS_SERIALIZED_SIZE;\n        const ethAddressOffset = dataStart;\n        const signatureOffset = dataStart + ethAddress.length;\n        const messageDataOffset = signatureOffset + signature.length + 1;\n        const numSignatures = 1;\n        const instructionData = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(SECP256K1_INSTRUCTION_LAYOUT.span + message.length);\n        SECP256K1_INSTRUCTION_LAYOUT.encode({\n            numSignatures,\n            signatureOffset,\n            signatureInstructionIndex: instructionIndex,\n            ethAddressOffset,\n            ethAddressInstructionIndex: instructionIndex,\n            messageDataOffset,\n            messageDataSize: message.length,\n            messageInstructionIndex: instructionIndex,\n            signature: toBuffer(signature),\n            ethAddress: toBuffer(ethAddress),\n            recoveryId\n        }, instructionData);\n        instructionData.fill(toBuffer(message), SECP256K1_INSTRUCTION_LAYOUT.span);\n        return new TransactionInstruction({\n            keys: [],\n            programId: Secp256k1Program.programId,\n            data: instructionData\n        });\n    }\n    /**\n   * Create an secp256k1 instruction with a private key. The private key\n   * must be a buffer that is 32 bytes long.\n   */ static createInstructionWithPrivateKey(params) {\n        const { privateKey: pkey, message, instructionIndex } = params;\n        assert(pkey.length === PRIVATE_KEY_BYTES, `Private key must be ${PRIVATE_KEY_BYTES} bytes but received ${pkey.length} bytes`);\n        try {\n            const privateKey = toBuffer(pkey);\n            const publicKey = publicKeyCreate(privateKey, false).slice(1); // throw away leading byte\n            const messageHash = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from((0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_16__.keccak_256)(toBuffer(message)));\n            const [signature, recoveryId] = ecdsaSign(messageHash, privateKey);\n            return this.createInstructionWithPublicKey({\n                publicKey,\n                message,\n                signature,\n                recoveryId,\n                instructionIndex\n            });\n        } catch (error) {\n            throw new Error(`Error creating instruction; ${error}`);\n        }\n    }\n}\nSecp256k1Program.programId = new PublicKey(\"KeccakSecp256k11111111111111111111111111111\");\nvar _Lockup;\n/**\n * Address of the stake config account which configures the rate\n * of stake warmup and cooldown as well as the slashing penalty.\n */ const STAKE_CONFIG_ID = new PublicKey(\"StakeConfig11111111111111111111111111111111\");\n/**\n * Stake account authority info\n */ class Authorized {\n    /**\n   * Create a new Authorized object\n   * @param staker the stake authority\n   * @param withdrawer the withdraw authority\n   */ constructor(staker, withdrawer){\n        /** stake authority */ this.staker = void 0;\n        /** withdraw authority */ this.withdrawer = void 0;\n        this.staker = staker;\n        this.withdrawer = withdrawer;\n    }\n}\n/**\n * Stake account lockup info\n */ class Lockup {\n    /**\n   * Create a new Lockup object\n   */ constructor(unixTimestamp, epoch, custodian){\n        /** Unix timestamp of lockup expiration */ this.unixTimestamp = void 0;\n        /** Epoch of lockup expiration */ this.epoch = void 0;\n        /** Lockup custodian authority */ this.custodian = void 0;\n        this.unixTimestamp = unixTimestamp;\n        this.epoch = epoch;\n        this.custodian = custodian;\n    }\n}\n_Lockup = Lockup;\nLockup.default = new _Lockup(0, 0, PublicKey.default);\n/**\n * Create stake account transaction params\n */ /**\n * Create stake account with seed transaction params\n */ /**\n * Initialize stake instruction params\n */ /**\n * Delegate stake instruction params\n */ /**\n * Authorize stake instruction params\n */ /**\n * Authorize stake instruction params using a derived key\n */ /**\n * Split stake instruction params\n */ /**\n * Split with seed transaction params\n */ /**\n * Withdraw stake instruction params\n */ /**\n * Deactivate stake instruction params\n */ /**\n * Merge stake instruction params\n */ /**\n * Stake Instruction class\n */ class StakeInstruction {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Decode a stake instruction and retrieve the instruction type.\n   */ static decodeInstructionType(instruction) {\n        this.checkProgramId(instruction.programId);\n        const instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\");\n        const typeIndex = instructionTypeLayout.decode(instruction.data);\n        let type;\n        for (const [ixType, layout] of Object.entries(STAKE_INSTRUCTION_LAYOUTS)){\n            if (layout.index == typeIndex) {\n                type = ixType;\n                break;\n            }\n        }\n        if (!type) {\n            throw new Error(\"Instruction type incorrect; not a StakeInstruction\");\n        }\n        return type;\n    }\n    /**\n   * Decode a initialize stake instruction and retrieve the instruction params.\n   */ static decodeInitialize(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 2);\n        const { authorized, lockup } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Initialize, instruction.data);\n        return {\n            stakePubkey: instruction.keys[0].pubkey,\n            authorized: new Authorized(new PublicKey(authorized.staker), new PublicKey(authorized.withdrawer)),\n            lockup: new Lockup(lockup.unixTimestamp, lockup.epoch, new PublicKey(lockup.custodian))\n        };\n    }\n    /**\n   * Decode a delegate stake instruction and retrieve the instruction params.\n   */ static decodeDelegate(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 6);\n        decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Delegate, instruction.data);\n        return {\n            stakePubkey: instruction.keys[0].pubkey,\n            votePubkey: instruction.keys[1].pubkey,\n            authorizedPubkey: instruction.keys[5].pubkey\n        };\n    }\n    /**\n   * Decode an authorize stake instruction and retrieve the instruction params.\n   */ static decodeAuthorize(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { newAuthorized, stakeAuthorizationType } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Authorize, instruction.data);\n        const o = {\n            stakePubkey: instruction.keys[0].pubkey,\n            authorizedPubkey: instruction.keys[2].pubkey,\n            newAuthorizedPubkey: new PublicKey(newAuthorized),\n            stakeAuthorizationType: {\n                index: stakeAuthorizationType\n            }\n        };\n        if (instruction.keys.length > 3) {\n            o.custodianPubkey = instruction.keys[3].pubkey;\n        }\n        return o;\n    }\n    /**\n   * Decode an authorize-with-seed stake instruction and retrieve the instruction params.\n   */ static decodeAuthorizeWithSeed(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 2);\n        const { newAuthorized, stakeAuthorizationType, authoritySeed, authorityOwner } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, instruction.data);\n        const o = {\n            stakePubkey: instruction.keys[0].pubkey,\n            authorityBase: instruction.keys[1].pubkey,\n            authoritySeed: authoritySeed,\n            authorityOwner: new PublicKey(authorityOwner),\n            newAuthorizedPubkey: new PublicKey(newAuthorized),\n            stakeAuthorizationType: {\n                index: stakeAuthorizationType\n            }\n        };\n        if (instruction.keys.length > 3) {\n            o.custodianPubkey = instruction.keys[3].pubkey;\n        }\n        return o;\n    }\n    /**\n   * Decode a split stake instruction and retrieve the instruction params.\n   */ static decodeSplit(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { lamports } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Split, instruction.data);\n        return {\n            stakePubkey: instruction.keys[0].pubkey,\n            splitStakePubkey: instruction.keys[1].pubkey,\n            authorizedPubkey: instruction.keys[2].pubkey,\n            lamports\n        };\n    }\n    /**\n   * Decode a merge stake instruction and retrieve the instruction params.\n   */ static decodeMerge(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Merge, instruction.data);\n        return {\n            stakePubkey: instruction.keys[0].pubkey,\n            sourceStakePubKey: instruction.keys[1].pubkey,\n            authorizedPubkey: instruction.keys[4].pubkey\n        };\n    }\n    /**\n   * Decode a withdraw stake instruction and retrieve the instruction params.\n   */ static decodeWithdraw(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 5);\n        const { lamports } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data);\n        const o = {\n            stakePubkey: instruction.keys[0].pubkey,\n            toPubkey: instruction.keys[1].pubkey,\n            authorizedPubkey: instruction.keys[4].pubkey,\n            lamports\n        };\n        if (instruction.keys.length > 5) {\n            o.custodianPubkey = instruction.keys[5].pubkey;\n        }\n        return o;\n    }\n    /**\n   * Decode a deactivate stake instruction and retrieve the instruction params.\n   */ static decodeDeactivate(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Deactivate, instruction.data);\n        return {\n            stakePubkey: instruction.keys[0].pubkey,\n            authorizedPubkey: instruction.keys[2].pubkey\n        };\n    }\n    /**\n   * @internal\n   */ static checkProgramId(programId) {\n        if (!programId.equals(StakeProgram.programId)) {\n            throw new Error(\"invalid instruction; programId is not StakeProgram\");\n        }\n    }\n    /**\n   * @internal\n   */ static checkKeyLength(keys, expectedLength) {\n        if (keys.length < expectedLength) {\n            throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);\n        }\n    }\n}\n/**\n * An enumeration of valid StakeInstructionType's\n */ /**\n * An enumeration of valid stake InstructionType's\n * @internal\n */ const STAKE_INSTRUCTION_LAYOUTS = Object.freeze({\n    Initialize: {\n        index: 0,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            authorized(),\n            lockup()\n        ])\n    },\n    Authorize: {\n        index: 1,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"newAuthorized\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"stakeAuthorizationType\")\n        ])\n    },\n    Delegate: {\n        index: 2,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    },\n    Split: {\n        index: 3,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"lamports\")\n        ])\n    },\n    Withdraw: {\n        index: 4,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"lamports\")\n        ])\n    },\n    Deactivate: {\n        index: 5,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    },\n    Merge: {\n        index: 7,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    },\n    AuthorizeWithSeed: {\n        index: 8,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"newAuthorized\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"stakeAuthorizationType\"),\n            rustString(\"authoritySeed\"),\n            publicKey(\"authorityOwner\")\n        ])\n    }\n});\n/**\n * Stake authorization type\n */ /**\n * An enumeration of valid StakeAuthorizationLayout's\n */ const StakeAuthorizationLayout = Object.freeze({\n    Staker: {\n        index: 0\n    },\n    Withdrawer: {\n        index: 1\n    }\n});\n/**\n * Factory class for transactions to interact with the Stake program\n */ class StakeProgram {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Public key that identifies the Stake program\n   */ /**\n   * Generate an Initialize instruction to add to a Stake Create transaction\n   */ static initialize(params) {\n        const { stakePubkey, authorized, lockup: maybeLockup } = params;\n        const lockup = maybeLockup || Lockup.default;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Initialize;\n        const data = encodeData(type, {\n            authorized: {\n                staker: toBuffer(authorized.staker.toBuffer()),\n                withdrawer: toBuffer(authorized.withdrawer.toBuffer())\n            },\n            lockup: {\n                unixTimestamp: lockup.unixTimestamp,\n                epoch: lockup.epoch,\n                custodian: toBuffer(lockup.custodian.toBuffer())\n            }\n        });\n        const instructionData = {\n            keys: [\n                {\n                    pubkey: stakePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_RENT_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        };\n        return new TransactionInstruction(instructionData);\n    }\n    /**\n   * Generate a Transaction that creates a new Stake account at\n   *   an address generated with `from`, a seed, and the Stake programId\n   */ static createAccountWithSeed(params) {\n        const transaction = new Transaction();\n        transaction.add(SystemProgram.createAccountWithSeed({\n            fromPubkey: params.fromPubkey,\n            newAccountPubkey: params.stakePubkey,\n            basePubkey: params.basePubkey,\n            seed: params.seed,\n            lamports: params.lamports,\n            space: this.space,\n            programId: this.programId\n        }));\n        const { stakePubkey, authorized, lockup } = params;\n        return transaction.add(this.initialize({\n            stakePubkey,\n            authorized,\n            lockup\n        }));\n    }\n    /**\n   * Generate a Transaction that creates a new Stake account\n   */ static createAccount(params) {\n        const transaction = new Transaction();\n        transaction.add(SystemProgram.createAccount({\n            fromPubkey: params.fromPubkey,\n            newAccountPubkey: params.stakePubkey,\n            lamports: params.lamports,\n            space: this.space,\n            programId: this.programId\n        }));\n        const { stakePubkey, authorized, lockup } = params;\n        return transaction.add(this.initialize({\n            stakePubkey,\n            authorized,\n            lockup\n        }));\n    }\n    /**\n   * Generate a Transaction that delegates Stake tokens to a validator\n   * Vote PublicKey. This transaction can also be used to redelegate Stake\n   * to a new validator Vote PublicKey.\n   */ static delegate(params) {\n        const { stakePubkey, authorizedPubkey, votePubkey } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Delegate;\n        const data = encodeData(type);\n        return new Transaction().add({\n            keys: [\n                {\n                    pubkey: stakePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: votePubkey,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: SYSVAR_CLOCK_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: STAKE_CONFIG_ID,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a Transaction that authorizes a new PublicKey as Staker\n   * or Withdrawer on the Stake account.\n   */ static authorize(params) {\n        const { stakePubkey, authorizedPubkey, newAuthorizedPubkey, stakeAuthorizationType, custodianPubkey } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Authorize;\n        const data = encodeData(type, {\n            newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n            stakeAuthorizationType: stakeAuthorizationType.index\n        });\n        const keys = [\n            {\n                pubkey: stakePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: SYSVAR_CLOCK_PUBKEY,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: authorizedPubkey,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        if (custodianPubkey) {\n            keys.push({\n                pubkey: custodianPubkey,\n                isSigner: true,\n                isWritable: false\n            });\n        }\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a Transaction that authorizes a new PublicKey as Staker\n   * or Withdrawer on the Stake account.\n   */ static authorizeWithSeed(params) {\n        const { stakePubkey, authorityBase, authoritySeed, authorityOwner, newAuthorizedPubkey, stakeAuthorizationType, custodianPubkey } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;\n        const data = encodeData(type, {\n            newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n            stakeAuthorizationType: stakeAuthorizationType.index,\n            authoritySeed: authoritySeed,\n            authorityOwner: toBuffer(authorityOwner.toBuffer())\n        });\n        const keys = [\n            {\n                pubkey: stakePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: authorityBase,\n                isSigner: true,\n                isWritable: false\n            },\n            {\n                pubkey: SYSVAR_CLOCK_PUBKEY,\n                isSigner: false,\n                isWritable: false\n            }\n        ];\n        if (custodianPubkey) {\n            keys.push({\n                pubkey: custodianPubkey,\n                isSigner: true,\n                isWritable: false\n            });\n        }\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * @internal\n   */ static splitInstruction(params) {\n        const { stakePubkey, authorizedPubkey, splitStakePubkey, lamports } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Split;\n        const data = encodeData(type, {\n            lamports\n        });\n        return new TransactionInstruction({\n            keys: [\n                {\n                    pubkey: stakePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: splitStakePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a Transaction that splits Stake tokens into another stake account\n   */ static split(params, // Compute the cost of allocating the new stake account in lamports\n    rentExemptReserve) {\n        const transaction = new Transaction();\n        transaction.add(SystemProgram.createAccount({\n            fromPubkey: params.authorizedPubkey,\n            newAccountPubkey: params.splitStakePubkey,\n            lamports: rentExemptReserve,\n            space: this.space,\n            programId: this.programId\n        }));\n        return transaction.add(this.splitInstruction(params));\n    }\n    /**\n   * Generate a Transaction that splits Stake tokens into another account\n   * derived from a base public key and seed\n   */ static splitWithSeed(params, // If this stake account is new, compute the cost of allocating it in lamports\n    rentExemptReserve) {\n        const { stakePubkey, authorizedPubkey, splitStakePubkey, basePubkey, seed, lamports } = params;\n        const transaction = new Transaction();\n        transaction.add(SystemProgram.allocate({\n            accountPubkey: splitStakePubkey,\n            basePubkey,\n            seed,\n            space: this.space,\n            programId: this.programId\n        }));\n        if (rentExemptReserve && rentExemptReserve > 0) {\n            transaction.add(SystemProgram.transfer({\n                fromPubkey: params.authorizedPubkey,\n                toPubkey: splitStakePubkey,\n                lamports: rentExemptReserve\n            }));\n        }\n        return transaction.add(this.splitInstruction({\n            stakePubkey,\n            authorizedPubkey,\n            splitStakePubkey,\n            lamports\n        }));\n    }\n    /**\n   * Generate a Transaction that merges Stake accounts.\n   */ static merge(params) {\n        const { stakePubkey, sourceStakePubKey, authorizedPubkey } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Merge;\n        const data = encodeData(type);\n        return new Transaction().add({\n            keys: [\n                {\n                    pubkey: stakePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: sourceStakePubKey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_CLOCK_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a Transaction that withdraws deactivated Stake tokens.\n   */ static withdraw(params) {\n        const { stakePubkey, authorizedPubkey, toPubkey, lamports, custodianPubkey } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Withdraw;\n        const data = encodeData(type, {\n            lamports\n        });\n        const keys = [\n            {\n                pubkey: stakePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: toPubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: SYSVAR_CLOCK_PUBKEY,\n                isSigner: false,\n                isWritable: false\n            },\n            {\n                pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,\n                isSigner: false,\n                isWritable: false\n            },\n            {\n                pubkey: authorizedPubkey,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        if (custodianPubkey) {\n            keys.push({\n                pubkey: custodianPubkey,\n                isSigner: true,\n                isWritable: false\n            });\n        }\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a Transaction that deactivates Stake tokens.\n   */ static deactivate(params) {\n        const { stakePubkey, authorizedPubkey } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Deactivate;\n        const data = encodeData(type);\n        return new Transaction().add({\n            keys: [\n                {\n                    pubkey: stakePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_CLOCK_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n}\nStakeProgram.programId = new PublicKey(\"Stake11111111111111111111111111111111111111\");\n/**\n * Max space of a Stake account\n *\n * This is generated from the solana-stake-program StakeState struct as\n * `StakeStateV2::size_of()`:\n * https://docs.rs/solana-stake-program/latest/solana_stake_program/stake_state/enum.StakeStateV2.html\n */ StakeProgram.space = 200;\n/**\n * Vote account info\n */ class VoteInit {\n    /** [0, 100] */ constructor(nodePubkey, authorizedVoter, authorizedWithdrawer, commission){\n        this.nodePubkey = void 0;\n        this.authorizedVoter = void 0;\n        this.authorizedWithdrawer = void 0;\n        this.commission = void 0;\n        this.nodePubkey = nodePubkey;\n        this.authorizedVoter = authorizedVoter;\n        this.authorizedWithdrawer = authorizedWithdrawer;\n        this.commission = commission;\n    }\n}\n/**\n * Create vote account transaction params\n */ /**\n * InitializeAccount instruction params\n */ /**\n * Authorize instruction params\n */ /**\n * AuthorizeWithSeed instruction params\n */ /**\n * Withdraw from vote account transaction params\n */ /**\n * Update validator identity (node pubkey) vote account instruction params.\n */ /**\n * Vote Instruction class\n */ class VoteInstruction {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Decode a vote instruction and retrieve the instruction type.\n   */ static decodeInstructionType(instruction) {\n        this.checkProgramId(instruction.programId);\n        const instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\");\n        const typeIndex = instructionTypeLayout.decode(instruction.data);\n        let type;\n        for (const [ixType, layout] of Object.entries(VOTE_INSTRUCTION_LAYOUTS)){\n            if (layout.index == typeIndex) {\n                type = ixType;\n                break;\n            }\n        }\n        if (!type) {\n            throw new Error(\"Instruction type incorrect; not a VoteInstruction\");\n        }\n        return type;\n    }\n    /**\n   * Decode an initialize vote instruction and retrieve the instruction params.\n   */ static decodeInitializeAccount(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 4);\n        const { voteInit } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.InitializeAccount, instruction.data);\n        return {\n            votePubkey: instruction.keys[0].pubkey,\n            nodePubkey: instruction.keys[3].pubkey,\n            voteInit: new VoteInit(new PublicKey(voteInit.nodePubkey), new PublicKey(voteInit.authorizedVoter), new PublicKey(voteInit.authorizedWithdrawer), voteInit.commission)\n        };\n    }\n    /**\n   * Decode an authorize instruction and retrieve the instruction params.\n   */ static decodeAuthorize(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { newAuthorized, voteAuthorizationType } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Authorize, instruction.data);\n        return {\n            votePubkey: instruction.keys[0].pubkey,\n            authorizedPubkey: instruction.keys[2].pubkey,\n            newAuthorizedPubkey: new PublicKey(newAuthorized),\n            voteAuthorizationType: {\n                index: voteAuthorizationType\n            }\n        };\n    }\n    /**\n   * Decode an authorize instruction and retrieve the instruction params.\n   */ static decodeAuthorizeWithSeed(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { voteAuthorizeWithSeedArgs: { currentAuthorityDerivedKeyOwnerPubkey, currentAuthorityDerivedKeySeed, newAuthorized, voteAuthorizationType } } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, instruction.data);\n        return {\n            currentAuthorityDerivedKeyBasePubkey: instruction.keys[2].pubkey,\n            currentAuthorityDerivedKeyOwnerPubkey: new PublicKey(currentAuthorityDerivedKeyOwnerPubkey),\n            currentAuthorityDerivedKeySeed: currentAuthorityDerivedKeySeed,\n            newAuthorizedPubkey: new PublicKey(newAuthorized),\n            voteAuthorizationType: {\n                index: voteAuthorizationType\n            },\n            votePubkey: instruction.keys[0].pubkey\n        };\n    }\n    /**\n   * Decode a withdraw instruction and retrieve the instruction params.\n   */ static decodeWithdraw(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { lamports } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data);\n        return {\n            votePubkey: instruction.keys[0].pubkey,\n            authorizedWithdrawerPubkey: instruction.keys[2].pubkey,\n            lamports,\n            toPubkey: instruction.keys[1].pubkey\n        };\n    }\n    /**\n   * @internal\n   */ static checkProgramId(programId) {\n        if (!programId.equals(VoteProgram.programId)) {\n            throw new Error(\"invalid instruction; programId is not VoteProgram\");\n        }\n    }\n    /**\n   * @internal\n   */ static checkKeyLength(keys, expectedLength) {\n        if (keys.length < expectedLength) {\n            throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);\n        }\n    }\n}\n/**\n * An enumeration of valid VoteInstructionType's\n */ /** @internal */ const VOTE_INSTRUCTION_LAYOUTS = Object.freeze({\n    InitializeAccount: {\n        index: 0,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            voteInit()\n        ])\n    },\n    Authorize: {\n        index: 1,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"newAuthorized\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"voteAuthorizationType\")\n        ])\n    },\n    Withdraw: {\n        index: 3,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"lamports\")\n        ])\n    },\n    UpdateValidatorIdentity: {\n        index: 4,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    },\n    AuthorizeWithSeed: {\n        index: 10,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            voteAuthorizeWithSeedArgs()\n        ])\n    }\n});\n/**\n * VoteAuthorize type\n */ /**\n * An enumeration of valid VoteAuthorization layouts.\n */ const VoteAuthorizationLayout = Object.freeze({\n    Voter: {\n        index: 0\n    },\n    Withdrawer: {\n        index: 1\n    }\n});\n/**\n * Factory class for transactions to interact with the Vote program\n */ class VoteProgram {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Public key that identifies the Vote program\n   */ /**\n   * Generate an Initialize instruction.\n   */ static initializeAccount(params) {\n        const { votePubkey, nodePubkey, voteInit } = params;\n        const type = VOTE_INSTRUCTION_LAYOUTS.InitializeAccount;\n        const data = encodeData(type, {\n            voteInit: {\n                nodePubkey: toBuffer(voteInit.nodePubkey.toBuffer()),\n                authorizedVoter: toBuffer(voteInit.authorizedVoter.toBuffer()),\n                authorizedWithdrawer: toBuffer(voteInit.authorizedWithdrawer.toBuffer()),\n                commission: voteInit.commission\n            }\n        });\n        const instructionData = {\n            keys: [\n                {\n                    pubkey: votePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_RENT_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: SYSVAR_CLOCK_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: nodePubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        };\n        return new TransactionInstruction(instructionData);\n    }\n    /**\n   * Generate a transaction that creates a new Vote account.\n   */ static createAccount(params) {\n        const transaction = new Transaction();\n        transaction.add(SystemProgram.createAccount({\n            fromPubkey: params.fromPubkey,\n            newAccountPubkey: params.votePubkey,\n            lamports: params.lamports,\n            space: this.space,\n            programId: this.programId\n        }));\n        return transaction.add(this.initializeAccount({\n            votePubkey: params.votePubkey,\n            nodePubkey: params.voteInit.nodePubkey,\n            voteInit: params.voteInit\n        }));\n    }\n    /**\n   * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account.\n   */ static authorize(params) {\n        const { votePubkey, authorizedPubkey, newAuthorizedPubkey, voteAuthorizationType } = params;\n        const type = VOTE_INSTRUCTION_LAYOUTS.Authorize;\n        const data = encodeData(type, {\n            newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n            voteAuthorizationType: voteAuthorizationType.index\n        });\n        const keys = [\n            {\n                pubkey: votePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: SYSVAR_CLOCK_PUBKEY,\n                isSigner: false,\n                isWritable: false\n            },\n            {\n                pubkey: authorizedPubkey,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account\n   * where the current Voter or Withdrawer authority is a derived key.\n   */ static authorizeWithSeed(params) {\n        const { currentAuthorityDerivedKeyBasePubkey, currentAuthorityDerivedKeyOwnerPubkey, currentAuthorityDerivedKeySeed, newAuthorizedPubkey, voteAuthorizationType, votePubkey } = params;\n        const type = VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;\n        const data = encodeData(type, {\n            voteAuthorizeWithSeedArgs: {\n                currentAuthorityDerivedKeyOwnerPubkey: toBuffer(currentAuthorityDerivedKeyOwnerPubkey.toBuffer()),\n                currentAuthorityDerivedKeySeed: currentAuthorityDerivedKeySeed,\n                newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n                voteAuthorizationType: voteAuthorizationType.index\n            }\n        });\n        const keys = [\n            {\n                pubkey: votePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: SYSVAR_CLOCK_PUBKEY,\n                isSigner: false,\n                isWritable: false\n            },\n            {\n                pubkey: currentAuthorityDerivedKeyBasePubkey,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction to withdraw from a Vote account.\n   */ static withdraw(params) {\n        const { votePubkey, authorizedWithdrawerPubkey, lamports, toPubkey } = params;\n        const type = VOTE_INSTRUCTION_LAYOUTS.Withdraw;\n        const data = encodeData(type, {\n            lamports\n        });\n        const keys = [\n            {\n                pubkey: votePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: toPubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: authorizedWithdrawerPubkey,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction to withdraw safely from a Vote account.\n   *\n   * This function was created as a safeguard for vote accounts running validators, `safeWithdraw`\n   * checks that the withdraw amount will not exceed the specified balance while leaving enough left\n   * to cover rent. If you wish to close the vote account by withdrawing the full amount, call the\n   * `withdraw` method directly.\n   */ static safeWithdraw(params, currentVoteAccountBalance, rentExemptMinimum) {\n        if (params.lamports > currentVoteAccountBalance - rentExemptMinimum) {\n            throw new Error(\"Withdraw will leave vote account with insufficient funds.\");\n        }\n        return VoteProgram.withdraw(params);\n    }\n    /**\n   * Generate a transaction to update the validator identity (node pubkey) of a Vote account.\n   */ static updateValidatorIdentity(params) {\n        const { votePubkey, authorizedWithdrawerPubkey, nodePubkey } = params;\n        const type = VOTE_INSTRUCTION_LAYOUTS.UpdateValidatorIdentity;\n        const data = encodeData(type);\n        const keys = [\n            {\n                pubkey: votePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: nodePubkey,\n                isSigner: true,\n                isWritable: false\n            },\n            {\n                pubkey: authorizedWithdrawerPubkey,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n}\nVoteProgram.programId = new PublicKey(\"Vote111111111111111111111111111111111111111\");\n/**\n * Max space of a Vote account\n *\n * This is generated from the solana-vote-program VoteState struct as\n * `VoteState::size_of()`:\n * https://docs.rs/solana-vote-program/1.9.5/solana_vote_program/vote_state/struct.VoteState.html#method.size_of\n *\n * KEEP IN SYNC WITH `VoteState::size_of()` in https://github.com/solana-labs/solana/blob/a474cb24b9238f5edcc982f65c0b37d4a1046f7e/sdk/program/src/vote/state/mod.rs#L340-L342\n */ VoteProgram.space = 3762;\nconst VALIDATOR_INFO_KEY = new PublicKey(\"Va1idator1nfo111111111111111111111111111111\");\n/**\n * @internal\n */ /**\n * Info used to identity validators.\n */ const InfoString = (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.type)({\n    name: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)(),\n    website: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    details: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    iconUrl: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)()),\n    keybaseUsername: (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_14__.string)())\n});\n/**\n * ValidatorInfo class\n */ class ValidatorInfo {\n    /**\n   * Construct a valid ValidatorInfo\n   *\n   * @param key validator public key\n   * @param info validator information\n   */ constructor(key, info){\n        /**\n     * validator public key\n     */ this.key = void 0;\n        /**\n     * validator information\n     */ this.info = void 0;\n        this.key = key;\n        this.info = info;\n    }\n    /**\n   * Deserialize ValidatorInfo from the config account data. Exactly two config\n   * keys are required in the data.\n   *\n   * @param buffer config account data\n   * @return null if info was not found\n   */ static fromConfigData(buffer) {\n        let byteArray = [\n            ...buffer\n        ];\n        const configKeyCount = decodeLength(byteArray);\n        if (configKeyCount !== 2) return null;\n        const configKeys = [];\n        for(let i = 0; i < 2; i++){\n            const publicKey = new PublicKey(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));\n            const isSigner = guardedShift(byteArray) === 1;\n            configKeys.push({\n                publicKey,\n                isSigner\n            });\n        }\n        if (configKeys[0].publicKey.equals(VALIDATOR_INFO_KEY)) {\n            if (configKeys[1].isSigner) {\n                const rawInfo = rustString().decode(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(byteArray));\n                const info = JSON.parse(rawInfo);\n                (0,superstruct__WEBPACK_IMPORTED_MODULE_14__.assert)(info, InfoString);\n                return new ValidatorInfo(configKeys[1].publicKey, info);\n            }\n        }\n        return null;\n    }\n}\nconst VOTE_PROGRAM_ID = new PublicKey(\"Vote111111111111111111111111111111111111111\");\n/**\n * History of how many credits earned by the end of each epoch\n */ /**\n * See https://github.com/solana-labs/solana/blob/8a12ed029cfa38d4a45400916c2463fb82bbec8c/programs/vote_api/src/vote_state.rs#L68-L88\n *\n * @internal\n */ const VoteAccountLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n    publicKey(\"nodePubkey\"),\n    publicKey(\"authorizedWithdrawer\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"commission\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(),\n    // votes.length\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"slot\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"confirmationCount\")\n    ]), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(), -8), \"votes\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"rootSlotValid\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"rootSlot\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(),\n    // authorizedVoters.length\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"epoch\"),\n        publicKey(\"authorizedVoter\")\n    ]), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(), -8), \"authorizedVoters\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            publicKey(\"authorizedPubkey\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"epochOfLastAuthorizedSwitch\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"targetEpoch\")\n        ]), 32, \"buf\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"idx\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"isEmpty\")\n    ], \"priorVoters\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(),\n    // epochCredits.length\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"epoch\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"credits\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"prevCredits\")\n    ]), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(), -8), \"epochCredits\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"slot\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"timestamp\")\n    ], \"lastTimestamp\")\n]);\n/**\n * VoteAccount class\n */ class VoteAccount {\n    /**\n   * @internal\n   */ constructor(args){\n        this.nodePubkey = void 0;\n        this.authorizedWithdrawer = void 0;\n        this.commission = void 0;\n        this.rootSlot = void 0;\n        this.votes = void 0;\n        this.authorizedVoters = void 0;\n        this.priorVoters = void 0;\n        this.epochCredits = void 0;\n        this.lastTimestamp = void 0;\n        this.nodePubkey = args.nodePubkey;\n        this.authorizedWithdrawer = args.authorizedWithdrawer;\n        this.commission = args.commission;\n        this.rootSlot = args.rootSlot;\n        this.votes = args.votes;\n        this.authorizedVoters = args.authorizedVoters;\n        this.priorVoters = args.priorVoters;\n        this.epochCredits = args.epochCredits;\n        this.lastTimestamp = args.lastTimestamp;\n    }\n    /**\n   * Deserialize VoteAccount from the account data.\n   *\n   * @param buffer account data\n   * @return VoteAccount\n   */ static fromAccountData(buffer) {\n        const versionOffset = 4;\n        const va = VoteAccountLayout.decode(toBuffer(buffer), versionOffset);\n        let rootSlot = va.rootSlot;\n        if (!va.rootSlotValid) {\n            rootSlot = null;\n        }\n        return new VoteAccount({\n            nodePubkey: new PublicKey(va.nodePubkey),\n            authorizedWithdrawer: new PublicKey(va.authorizedWithdrawer),\n            commission: va.commission,\n            votes: va.votes,\n            rootSlot,\n            authorizedVoters: va.authorizedVoters.map(parseAuthorizedVoter),\n            priorVoters: getPriorVoters(va.priorVoters),\n            epochCredits: va.epochCredits,\n            lastTimestamp: va.lastTimestamp\n        });\n    }\n}\nfunction parseAuthorizedVoter({ authorizedVoter, epoch }) {\n    return {\n        epoch,\n        authorizedVoter: new PublicKey(authorizedVoter)\n    };\n}\nfunction parsePriorVoters({ authorizedPubkey, epochOfLastAuthorizedSwitch, targetEpoch }) {\n    return {\n        authorizedPubkey: new PublicKey(authorizedPubkey),\n        epochOfLastAuthorizedSwitch,\n        targetEpoch\n    };\n}\nfunction getPriorVoters({ buf, idx, isEmpty }) {\n    if (isEmpty) {\n        return [];\n    }\n    return [\n        ...buf.slice(idx + 1).map(parsePriorVoters),\n        ...buf.slice(0, idx).map(parsePriorVoters)\n    ];\n}\nconst endpoint = {\n    http: {\n        devnet: \"http://api.devnet.solana.com\",\n        testnet: \"http://api.testnet.solana.com\",\n        \"mainnet-beta\": \"http://api.mainnet-beta.solana.com/\"\n    },\n    https: {\n        devnet: \"https://api.devnet.solana.com\",\n        testnet: \"https://api.testnet.solana.com\",\n        \"mainnet-beta\": \"https://api.mainnet-beta.solana.com/\"\n    }\n};\n/**\n * Retrieves the RPC API URL for the specified cluster\n * @param {Cluster} [cluster=\"devnet\"] - The cluster name of the RPC API URL to use. Possible options: 'devnet' | 'testnet' | 'mainnet-beta'\n * @param {boolean} [tls=\"http\"] - Use TLS when connecting to cluster.\n *\n * @returns {string} URL string of the RPC endpoint\n */ function clusterApiUrl(cluster, tls) {\n    const key = tls === false ? \"http\" : \"https\";\n    if (!cluster) {\n        return endpoint[key][\"devnet\"];\n    }\n    const url = endpoint[key][cluster];\n    if (!url) {\n        throw new Error(`Unknown ${key} cluster: ${cluster}`);\n    }\n    return url;\n}\n/**\n * Send and confirm a raw transaction\n *\n * If `commitment` option is not specified, defaults to 'max' commitment.\n *\n * @param {Connection} connection\n * @param {Buffer} rawTransaction\n * @param {TransactionConfirmationStrategy} confirmationStrategy\n * @param {ConfirmOptions} [options]\n * @returns {Promise<TransactionSignature>}\n */ /**\n * @deprecated Calling `sendAndConfirmRawTransaction()` without a `confirmationStrategy`\n * is no longer supported and will be removed in a future version.\n */ // eslint-disable-next-line no-redeclare\n// eslint-disable-next-line no-redeclare\nasync function sendAndConfirmRawTransaction(connection, rawTransaction, confirmationStrategyOrConfirmOptions, maybeConfirmOptions) {\n    let confirmationStrategy;\n    let options;\n    if (confirmationStrategyOrConfirmOptions && Object.prototype.hasOwnProperty.call(confirmationStrategyOrConfirmOptions, \"lastValidBlockHeight\")) {\n        confirmationStrategy = confirmationStrategyOrConfirmOptions;\n        options = maybeConfirmOptions;\n    } else if (confirmationStrategyOrConfirmOptions && Object.prototype.hasOwnProperty.call(confirmationStrategyOrConfirmOptions, \"nonceValue\")) {\n        confirmationStrategy = confirmationStrategyOrConfirmOptions;\n        options = maybeConfirmOptions;\n    } else {\n        options = confirmationStrategyOrConfirmOptions;\n    }\n    const sendOptions = options && {\n        skipPreflight: options.skipPreflight,\n        preflightCommitment: options.preflightCommitment || options.commitment,\n        minContextSlot: options.minContextSlot\n    };\n    const signature = await connection.sendRawTransaction(rawTransaction, sendOptions);\n    const commitment = options && options.commitment;\n    const confirmationPromise = confirmationStrategy ? connection.confirmTransaction(confirmationStrategy, commitment) : connection.confirmTransaction(signature, commitment);\n    const status = (await confirmationPromise).value;\n    if (status.err) {\n        if (signature != null) {\n            throw new SendTransactionError({\n                action: sendOptions?.skipPreflight ? \"send\" : \"simulate\",\n                signature: signature,\n                transactionMessage: `Status: (${JSON.stringify(status)})`\n            });\n        }\n        throw new Error(`Raw transaction ${signature} failed (${JSON.stringify(status)})`);\n    }\n    return signature;\n}\n/**\n * There are 1-billion lamports in one SOL\n */ const LAMPORTS_PER_SOL = 1000000000;\n //# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL2xpYi9pbmRleC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFnQztBQUNnQjtBQUN6QjtBQUNDO0FBQ3NCO0FBQ3VCO0FBQ2Y7QUFDVDtBQUN1QjtBQUN0QztBQUNFO0FBQ1k7QUFDc0k7QUFDaEk7QUFDVjtBQUNpQjtBQUNUO0FBQ0k7QUFFcEQ7Ozs7Q0FJQyxHQUVEOztDQUVDLEdBRUQsTUFBTXdDLHFCQUFxQnZDLDJEQUFPQSxDQUFDd0MsS0FBSyxDQUFDQyxnQkFBZ0I7QUFDekQsTUFBTUMsa0JBQWtCO0lBQ3RCLE1BQU1DLGdCQUFnQjNDLDJEQUFPQSxDQUFDd0MsS0FBSyxDQUFDQyxnQkFBZ0I7SUFDcEQsTUFBTUcsWUFBWUMsYUFBYUY7SUFDL0IsTUFBTUcsWUFBWSxJQUFJQyxXQUFXO0lBQ2pDRCxVQUFVRSxHQUFHLENBQUNMO0lBQ2RHLFVBQVVFLEdBQUcsQ0FBQ0osV0FBVztJQUN6QixPQUFPO1FBQ0xBO1FBQ0FFO0lBQ0Y7QUFDRjtBQUNBLE1BQU1ELGVBQWU3QywyREFBT0EsQ0FBQzZDLFlBQVk7QUFDekMsU0FBU0ksVUFBVUwsU0FBUztJQUMxQixJQUFJO1FBQ0Y1QywyREFBT0EsQ0FBQ2tELGFBQWEsQ0FBQ0MsT0FBTyxDQUFDUDtRQUM5QixPQUFPO0lBQ1QsRUFBRSxPQUFNO1FBQ04sT0FBTztJQUNUO0FBQ0Y7QUFDQSxNQUFNUSxPQUFPLENBQUNDLFNBQVNQLFlBQWM5QywyREFBT0EsQ0FBQ29ELElBQUksQ0FBQ0MsU0FBU1AsVUFBVVEsS0FBSyxDQUFDLEdBQUc7QUFDOUUsTUFBTUMsU0FBU3ZELDJEQUFPQSxDQUFDdUQsTUFBTTtBQUU3QixNQUFNQyxXQUFXQyxDQUFBQTtJQUNmLElBQUkxRCww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QVdBO2dCQUNYNlQsb0JBQW9CLENBQUMsU0FBUyxFQUFFOUYsS0FBS0MsU0FBUyxDQUFDMEksUUFBUSxDQUFDLENBQUM7WUFDM0Q7UUFDRjtRQUNBLE1BQU0sSUFBSXRhLE1BQU0sQ0FBQyxnQkFBZ0IsRUFBRTRELFVBQVUsU0FBUyxFQUFFK04sS0FBS0MsU0FBUyxDQUFDMEksUUFBUSxDQUFDLENBQUM7SUFDbkY7SUFDQSxPQUFPMVc7QUFDVDtBQUVBOztDQUVDLEdBQ0QsTUFBTXMyQyxtQkFBbUI7QUFFNmdELENBQ3RpRCxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGF3LXdvcmtzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2ViMy5qcy9saWIvaW5kZXguZXNtLmpzPzhmYTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQnVmZmVyIH0gZnJvbSAnYnVmZmVyJztcbmltcG9ydCB7IGVkMjU1MTkgfSBmcm9tICdAbm9ibGUvY3VydmVzL2VkMjU1MTknO1xuaW1wb3J0IEJOIGZyb20gJ2JuLmpzJztcbmltcG9ydCBiczU4IGZyb20gJ2JzNTgnO1xuaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGEyNTYnO1xuaW1wb3J0IHsgc2VyaWFsaXplLCBkZXNlcmlhbGl6ZSwgZGVzZXJpYWxpemVVbmNoZWNrZWQgfSBmcm9tICdib3JzaCc7XG5pbXBvcnQgKiBhcyBCdWZmZXJMYXlvdXQgZnJvbSAnQHNvbGFuYS9idWZmZXItbGF5b3V0JztcbmltcG9ydCB7IGJsb2IgfSBmcm9tICdAc29sYW5hL2J1ZmZlci1sYXlvdXQnO1xuaW1wb3J0IHsgZ2V0VTY0Q29kZWMsIGdldFU2NEVuY29kZXIgfSBmcm9tICdAc29sYW5hL2NvZGVjcy1udW1iZXJzJztcbmltcG9ydCByZXF1aXJlJCQwIGZyb20gJ3V0aWwnO1xuaW1wb3J0IHJlcXVpcmUkJDAkMSBmcm9tICdodHRwJztcbmltcG9ydCByZXF1aXJlJCQwJDIsIHsgQWdlbnQgfSBmcm9tICdodHRwcyc7XG5pbXBvcnQgeyBjb2VyY2UsIGluc3RhbmNlLCBzdHJpbmcsIHR1cGxlLCBsaXRlcmFsLCB1bmtub3duLCB0eXBlLCBudW1iZXIsIGFycmF5LCBudWxsYWJsZSwgb3B0aW9uYWwsIGJvb2xlYW4sIHJlY29yZCwgdW5pb24sIGNyZWF0ZSwgYW55LCBhc3NlcnQgYXMgYXNzZXJ0JDEgfSBmcm9tICdzdXBlcnN0cnVjdCc7XG5pbXBvcnQgUnBjQ2xpZW50IGZyb20gJ2pheXNvbi9saWIvY2xpZW50L2Jyb3dzZXInO1xuaW1wb3J0ICogYXMgbm9kZUZldGNoIGZyb20gJ25vZGUtZmV0Y2gnO1xuaW1wb3J0IHsgQ29tbW9uQ2xpZW50LCBXZWJTb2NrZXQgfSBmcm9tICdycGMtd2Vic29ja2V0cyc7XG5pbXBvcnQgeyBrZWNjYWtfMjU2IH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGEzJztcbmltcG9ydCB7IHNlY3AyNTZrMSB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxJztcblxuLyoqXG4gKiBBIDY0IGJ5dGUgc2VjcmV0IGtleSwgdGhlIGZpcnN0IDMyIGJ5dGVzIG9mIHdoaWNoIGlzIHRoZVxuICogcHJpdmF0ZSBzY2FsYXIgYW5kIHRoZSBsYXN0IDMyIGJ5dGVzIGlzIHRoZSBwdWJsaWMga2V5LlxuICogUmVhZCBtb3JlOiBodHRwczovL2Jsb2cubW96aWxsYS5vcmcvd2FybmVyLzIwMTEvMTEvMjkvZWQyNTUxOS1rZXlzL1xuICovXG5cbi8qKlxuICogRWQyNTUxOSBLZXlwYWlyXG4gKi9cblxuY29uc3QgZ2VuZXJhdGVQcml2YXRlS2V5ID0gZWQyNTUxOS51dGlscy5yYW5kb21Qcml2YXRlS2V5O1xuY29uc3QgZ2VuZXJhdGVLZXlwYWlyID0gKCkgPT4ge1xuICBjb25zdCBwcml2YXRlU2NhbGFyID0gZWQyNTUxOS51dGlscy5yYW5kb21Qcml2YXRlS2V5KCk7XG4gIGNvbnN0IHB1YmxpY0tleSA9IGdldFB1YmxpY0tleShwcml2YXRlU2NhbGFyKTtcbiAgY29uc3Qgc2VjcmV0S2V5ID0gbmV3IFVpbnQ4QXJyYXkoNjQpO1xuICBzZWNyZXRLZXkuc2V0KHByaXZhdGVTY2FsYXIpO1xuICBzZWNyZXRLZXkuc2V0KHB1YmxpY0tleSwgMzIpO1xuICByZXR1cm4ge1xuICAgIHB1YmxpY0tleSxcbiAgICBzZWNyZXRLZXlcbiAgfTtcbn07XG5jb25zdCBnZXRQdWJsaWNLZXkgPSBlZDI1NTE5LmdldFB1YmxpY0tleTtcbmZ1bmN0aW9uIGlzT25DdXJ2ZShwdWJsaWNLZXkpIHtcbiAgdHJ5IHtcbiAgICBlZDI1NTE5LkV4dGVuZGVkUG9pbnQuZnJvbUhleChwdWJsaWNLZXkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmNvbnN0IHNpZ24gPSAobWVzc2FnZSwgc2VjcmV0S2V5KSA9PiBlZDI1NTE5LnNpZ24obWVzc2FnZSwgc2VjcmV0S2V5LnNsaWNlKDAsIDMyKSk7XG5jb25zdCB2ZXJpZnkgPSBlZDI1NTE5LnZlcmlmeTtcblxuY29uc3QgdG9CdWZmZXIgPSBhcnIgPT4ge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGFycikpIHtcbiAgICByZXR1cm4gYXJyO1xuICB9IGVsc2UgaWYgKGFyciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oYXJyKTtcbiAgfVxufTtcblxuLy8gQ2xhc3Mgd3JhcHBpbmcgYSBwbGFpbiBvYmplY3RcbmNsYXNzIFN0cnVjdCB7XG4gIGNvbnN0cnVjdG9yKHByb3BlcnRpZXMpIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIHByb3BlcnRpZXMpO1xuICB9XG4gIGVuY29kZSgpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oc2VyaWFsaXplKFNPTEFOQV9TQ0hFTUEsIHRoaXMpKTtcbiAgfVxuICBzdGF0aWMgZGVjb2RlKGRhdGEpIHtcbiAgICByZXR1cm4gZGVzZXJpYWxpemUoU09MQU5BX1NDSEVNQSwgdGhpcywgZGF0YSk7XG4gIH1cbiAgc3RhdGljIGRlY29kZVVuY2hlY2tlZChkYXRhKSB7XG4gICAgcmV0dXJuIGRlc2VyaWFsaXplVW5jaGVja2VkKFNPTEFOQV9TQ0hFTUEsIHRoaXMsIGRhdGEpO1xuICB9XG59XG5cbi8vIENsYXNzIHJlcHJlc2VudGluZyBhIFJ1c3QtY29tcGF0aWJsZSBlbnVtLCBzaW5jZSBlbnVtcyBhcmUgb25seSBzdHJpbmdzIG9yXG4vLyBudW1iZXJzIGluIHB1cmUgSlNcbmNsYXNzIEVudW0gZXh0ZW5kcyBTdHJ1Y3Qge1xuICBjb25zdHJ1Y3Rvcihwcm9wZXJ0aWVzKSB7XG4gICAgc3VwZXIocHJvcGVydGllcyk7XG4gICAgdGhpcy5lbnVtID0gJyc7XG4gICAgaWYgKE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbnVtIGNhbiBvbmx5IHRha2Ugc2luZ2xlIHZhbHVlJyk7XG4gICAgfVxuICAgIE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLm1hcChrZXkgPT4ge1xuICAgICAgdGhpcy5lbnVtID0ga2V5O1xuICAgIH0pO1xuICB9XG59XG5jb25zdCBTT0xBTkFfU0NIRU1BID0gbmV3IE1hcCgpO1xuXG52YXIgX1B1YmxpY0tleTtcblxuLyoqXG4gKiBNYXhpbXVtIGxlbmd0aCBvZiBkZXJpdmVkIHB1YmtleSBzZWVkXG4gKi9cbmNvbnN0IE1BWF9TRUVEX0xFTkdUSCA9IDMyO1xuXG4vKipcbiAqIFNpemUgb2YgcHVibGljIGtleSBpbiBieXRlc1xuICovXG5jb25zdCBQVUJMSUNfS0VZX0xFTkdUSCA9IDMyO1xuXG4vKipcbiAqIFZhbHVlIHRvIGJlIGNvbnZlcnRlZCBpbnRvIHB1YmxpYyBrZXlcbiAqL1xuXG4vKipcbiAqIEpTT04gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIFB1YmxpY0tleSBjbGFzc1xuICovXG5cbmZ1bmN0aW9uIGlzUHVibGljS2V5RGF0YSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUuX2JuICE9PSB1bmRlZmluZWQ7XG59XG5cbi8vIGxvY2FsIGNvdW50ZXIgdXNlZCBieSBQdWJsaWNLZXkudW5pcXVlKClcbmxldCB1bmlxdWVQdWJsaWNLZXlDb3VudGVyID0gMTtcblxuLyoqXG4gKiBBIHB1YmxpYyBrZXlcbiAqL1xuY2xhc3MgUHVibGljS2V5IGV4dGVuZHMgU3RydWN0IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBQdWJsaWNLZXkgb2JqZWN0XG4gICAqIEBwYXJhbSB2YWx1ZSBlZDI1NTE5IHB1YmxpYyBrZXkgYXMgYnVmZmVyIG9yIGJhc2UtNTggZW5jb2RlZCBzdHJpbmdcbiAgICovXG4gIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgc3VwZXIoe30pO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9ibiA9IHZvaWQgMDtcbiAgICBpZiAoaXNQdWJsaWNLZXlEYXRhKHZhbHVlKSkge1xuICAgICAgdGhpcy5fYm4gPSB2YWx1ZS5fYm47XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIGFzc3VtZSBiYXNlIDU4IGVuY29kaW5nIGJ5IGRlZmF1bHRcbiAgICAgICAgY29uc3QgZGVjb2RlZCA9IGJzNTguZGVjb2RlKHZhbHVlKTtcbiAgICAgICAgaWYgKGRlY29kZWQubGVuZ3RoICE9IFBVQkxJQ19LRVlfTEVOR1RIKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHB1YmxpYyBrZXkgaW5wdXRgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9ibiA9IG5ldyBCTihkZWNvZGVkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2JuID0gbmV3IEJOKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9ibi5ieXRlTGVuZ3RoKCkgPiBQVUJMSUNfS0VZX0xFTkdUSCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcHVibGljIGtleSBpbnB1dGApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdW5pcXVlIFB1YmxpY0tleSBmb3IgdGVzdHMgYW5kIGJlbmNobWFya3MgdXNpbmcgYSBjb3VudGVyXG4gICAqL1xuICBzdGF0aWMgdW5pcXVlKCkge1xuICAgIGNvbnN0IGtleSA9IG5ldyBQdWJsaWNLZXkodW5pcXVlUHVibGljS2V5Q291bnRlcik7XG4gICAgdW5pcXVlUHVibGljS2V5Q291bnRlciArPSAxO1xuICAgIHJldHVybiBuZXcgUHVibGljS2V5KGtleS50b0J1ZmZlcigpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZhdWx0IHB1YmxpYyBrZXkgdmFsdWUuIFRoZSBiYXNlNTgtZW5jb2RlZCBzdHJpbmcgcmVwcmVzZW50YXRpb24gaXMgYWxsIG9uZXMgKGFzIHNlZW4gYmVsb3cpXG4gICAqIFRoZSB1bmRlcmx5aW5nIEJOIG51bWJlciBpcyAzMiBieXRlcyB0aGF0IGFyZSBhbGwgemVyb3NcbiAgICovXG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0d28gcHVibGljS2V5cyBhcmUgZXF1YWxcbiAgICovXG4gIGVxdWFscyhwdWJsaWNLZXkpIHtcbiAgICByZXR1cm4gdGhpcy5fYm4uZXEocHVibGljS2V5Ll9ibik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBiYXNlLTU4IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwdWJsaWMga2V5XG4gICAqL1xuICB0b0Jhc2U1OCgpIHtcbiAgICByZXR1cm4gYnM1OC5lbmNvZGUodGhpcy50b0J5dGVzKCkpO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50b0Jhc2U1OCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgYnl0ZSBhcnJheSByZXByZXNlbnRhdGlvbiBvZiB0aGUgcHVibGljIGtleSBpbiBiaWcgZW5kaWFuXG4gICAqL1xuICB0b0J5dGVzKCkge1xuICAgIGNvbnN0IGJ1ZiA9IHRoaXMudG9CdWZmZXIoKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmLmJ1ZmZlciwgYnVmLmJ5dGVPZmZzZXQsIGJ1Zi5ieXRlTGVuZ3RoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIEJ1ZmZlciByZXByZXNlbnRhdGlvbiBvZiB0aGUgcHVibGljIGtleSBpbiBiaWcgZW5kaWFuXG4gICAqL1xuICB0b0J1ZmZlcigpIHtcbiAgICBjb25zdCBiID0gdGhpcy5fYm4udG9BcnJheUxpa2UoQnVmZmVyKTtcbiAgICBpZiAoYi5sZW5ndGggPT09IFBVQkxJQ19LRVlfTEVOR1RIKSB7XG4gICAgICByZXR1cm4gYjtcbiAgICB9XG4gICAgY29uc3QgemVyb1BhZCA9IEJ1ZmZlci5hbGxvYygzMik7XG4gICAgYi5jb3B5KHplcm9QYWQsIDMyIC0gYi5sZW5ndGgpO1xuICAgIHJldHVybiB6ZXJvUGFkO1xuICB9XG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICByZXR1cm4gYFB1YmxpY0tleSgke3RoaXMudG9TdHJpbmcoKX0pYDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGJhc2UtNTggcmVwcmVzZW50YXRpb24gb2YgdGhlIHB1YmxpYyBrZXlcbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnRvQmFzZTU4KCk7XG4gIH1cblxuICAvKipcbiAgICogRGVyaXZlIGEgcHVibGljIGtleSBmcm9tIGFub3RoZXIga2V5LCBhIHNlZWQsIGFuZCBhIHByb2dyYW0gSUQuXG4gICAqIFRoZSBwcm9ncmFtIElEIHdpbGwgYWxzbyBzZXJ2ZSBhcyB0aGUgb3duZXIgb2YgdGhlIHB1YmxpYyBrZXksIGdpdmluZ1xuICAgKiBpdCBwZXJtaXNzaW9uIHRvIHdyaXRlIGRhdGEgdG8gdGhlIGFjY291bnQuXG4gICAqL1xuICAvKiBlc2xpbnQtZGlzYWJsZSByZXF1aXJlLWF3YWl0ICovXG4gIHN0YXRpYyBhc3luYyBjcmVhdGVXaXRoU2VlZChmcm9tUHVibGljS2V5LCBzZWVkLCBwcm9ncmFtSWQpIHtcbiAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuY29uY2F0KFtmcm9tUHVibGljS2V5LnRvQnVmZmVyKCksIEJ1ZmZlci5mcm9tKHNlZWQpLCBwcm9ncmFtSWQudG9CdWZmZXIoKV0pO1xuICAgIGNvbnN0IHB1YmxpY0tleUJ5dGVzID0gc2hhMjU2KGJ1ZmZlcik7XG4gICAgcmV0dXJuIG5ldyBQdWJsaWNLZXkocHVibGljS2V5Qnl0ZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcml2ZSBhIHByb2dyYW0gYWRkcmVzcyBmcm9tIHNlZWRzIGFuZCBhIHByb2dyYW0gSUQuXG4gICAqL1xuICAvKiBlc2xpbnQtZGlzYWJsZSByZXF1aXJlLWF3YWl0ICovXG4gIHN0YXRpYyBjcmVhdGVQcm9ncmFtQWRkcmVzc1N5bmMoc2VlZHMsIHByb2dyYW1JZCkge1xuICAgIGxldCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMCk7XG4gICAgc2VlZHMuZm9yRWFjaChmdW5jdGlvbiAoc2VlZCkge1xuICAgICAgaWYgKHNlZWQubGVuZ3RoID4gTUFYX1NFRURfTEVOR1RIKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE1heCBzZWVkIGxlbmd0aCBleGNlZWRlZGApO1xuICAgICAgfVxuICAgICAgYnVmZmVyID0gQnVmZmVyLmNvbmNhdChbYnVmZmVyLCB0b0J1ZmZlcihzZWVkKV0pO1xuICAgIH0pO1xuICAgIGJ1ZmZlciA9IEJ1ZmZlci5jb25jYXQoW2J1ZmZlciwgcHJvZ3JhbUlkLnRvQnVmZmVyKCksIEJ1ZmZlci5mcm9tKCdQcm9ncmFtRGVyaXZlZEFkZHJlc3MnKV0pO1xuICAgIGNvbnN0IHB1YmxpY0tleUJ5dGVzID0gc2hhMjU2KGJ1ZmZlcik7XG4gICAgaWYgKGlzT25DdXJ2ZShwdWJsaWNLZXlCeXRlcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzZWVkcywgYWRkcmVzcyBtdXN0IGZhbGwgb2ZmIHRoZSBjdXJ2ZWApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFB1YmxpY0tleShwdWJsaWNLZXlCeXRlcyk7XG4gIH1cblxuICAvKipcbiAgICogQXN5bmMgdmVyc2lvbiBvZiBjcmVhdGVQcm9ncmFtQWRkcmVzc1N5bmNcbiAgICogRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgY3JlYXRlUHJvZ3JhbUFkZHJlc3NTeW5jfSBpbnN0ZWFkXG4gICAqL1xuICAvKiBlc2xpbnQtZGlzYWJsZSByZXF1aXJlLWF3YWl0ICovXG4gIHN0YXRpYyBhc3luYyBjcmVhdGVQcm9ncmFtQWRkcmVzcyhzZWVkcywgcHJvZ3JhbUlkKSB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlUHJvZ3JhbUFkZHJlc3NTeW5jKHNlZWRzLCBwcm9ncmFtSWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgYSB2YWxpZCBwcm9ncmFtIGFkZHJlc3NcbiAgICpcbiAgICogVmFsaWQgcHJvZ3JhbSBhZGRyZXNzZXMgbXVzdCBmYWxsIG9mZiB0aGUgZWQyNTUxOSBjdXJ2ZS4gIFRoaXMgZnVuY3Rpb25cbiAgICogaXRlcmF0ZXMgYSBub25jZSB1bnRpbCBpdCBmaW5kcyBvbmUgdGhhdCB3aGVuIGNvbWJpbmVkIHdpdGggdGhlIHNlZWRzXG4gICAqIHJlc3VsdHMgaW4gYSB2YWxpZCBwcm9ncmFtIGFkZHJlc3MuXG4gICAqL1xuICBzdGF0aWMgZmluZFByb2dyYW1BZGRyZXNzU3luYyhzZWVkcywgcHJvZ3JhbUlkKSB7XG4gICAgbGV0IG5vbmNlID0gMjU1O1xuICAgIGxldCBhZGRyZXNzO1xuICAgIHdoaWxlIChub25jZSAhPSAwKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBzZWVkc1dpdGhOb25jZSA9IHNlZWRzLmNvbmNhdChCdWZmZXIuZnJvbShbbm9uY2VdKSk7XG4gICAgICAgIGFkZHJlc3MgPSB0aGlzLmNyZWF0ZVByb2dyYW1BZGRyZXNzU3luYyhzZWVkc1dpdGhOb25jZSwgcHJvZ3JhbUlkKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgVHlwZUVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIG5vbmNlLS07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFthZGRyZXNzLCBub25jZV07XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGZpbmQgYSB2aWFibGUgcHJvZ3JhbSBhZGRyZXNzIG5vbmNlYCk7XG4gIH1cblxuICAvKipcbiAgICogQXN5bmMgdmVyc2lvbiBvZiBmaW5kUHJvZ3JhbUFkZHJlc3NTeW5jXG4gICAqIEZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIGZpbmRQcm9ncmFtQWRkcmVzc1N5bmN9IGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBhc3luYyBmaW5kUHJvZ3JhbUFkZHJlc3Moc2VlZHMsIHByb2dyYW1JZCkge1xuICAgIHJldHVybiB0aGlzLmZpbmRQcm9ncmFtQWRkcmVzc1N5bmMoc2VlZHMsIHByb2dyYW1JZCk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgdGhhdCBhIHB1YmtleSBpcyBvbiB0aGUgZWQyNTUxOSBjdXJ2ZS5cbiAgICovXG4gIHN0YXRpYyBpc09uQ3VydmUocHVia2V5RGF0YSkge1xuICAgIGNvbnN0IHB1YmtleSA9IG5ldyBQdWJsaWNLZXkocHVia2V5RGF0YSk7XG4gICAgcmV0dXJuIGlzT25DdXJ2ZShwdWJrZXkudG9CeXRlcygpKTtcbiAgfVxufVxuX1B1YmxpY0tleSA9IFB1YmxpY0tleTtcblB1YmxpY0tleS5kZWZhdWx0ID0gbmV3IF9QdWJsaWNLZXkoJzExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5TT0xBTkFfU0NIRU1BLnNldChQdWJsaWNLZXksIHtcbiAga2luZDogJ3N0cnVjdCcsXG4gIGZpZWxkczogW1snX2JuJywgJ3UyNTYnXV1cbn0pO1xuXG4vKipcbiAqIEFuIGFjY291bnQga2V5IHBhaXIgKHB1YmxpYyBhbmQgc2VjcmV0IGtleXMpLlxuICpcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHYxLjEwLjAsIHBsZWFzZSB1c2Uge0BsaW5rIEtleXBhaXJ9IGluc3RlYWQuXG4gKi9cbmNsYXNzIEFjY291bnQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IEFjY291bnQgb2JqZWN0XG4gICAqXG4gICAqIElmIHRoZSBzZWNyZXRLZXkgcGFyYW1ldGVyIGlzIG5vdCBwcm92aWRlZCBhIG5ldyBrZXkgcGFpciBpcyByYW5kb21seVxuICAgKiBjcmVhdGVkIGZvciB0aGUgYWNjb3VudFxuICAgKlxuICAgKiBAcGFyYW0gc2VjcmV0S2V5IFNlY3JldCBrZXkgZm9yIHRoZSBhY2NvdW50XG4gICAqL1xuICBjb25zdHJ1Y3RvcihzZWNyZXRLZXkpIHtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fcHVibGljS2V5ID0gdm9pZCAwO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9zZWNyZXRLZXkgPSB2b2lkIDA7XG4gICAgaWYgKHNlY3JldEtleSkge1xuICAgICAgY29uc3Qgc2VjcmV0S2V5QnVmZmVyID0gdG9CdWZmZXIoc2VjcmV0S2V5KTtcbiAgICAgIGlmIChzZWNyZXRLZXkubGVuZ3RoICE9PSA2NCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBzZWNyZXQga2V5IHNpemUnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3B1YmxpY0tleSA9IHNlY3JldEtleUJ1ZmZlci5zbGljZSgzMiwgNjQpO1xuICAgICAgdGhpcy5fc2VjcmV0S2V5ID0gc2VjcmV0S2V5QnVmZmVyLnNsaWNlKDAsIDMyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc2VjcmV0S2V5ID0gdG9CdWZmZXIoZ2VuZXJhdGVQcml2YXRlS2V5KCkpO1xuICAgICAgdGhpcy5fcHVibGljS2V5ID0gdG9CdWZmZXIoZ2V0UHVibGljS2V5KHRoaXMuX3NlY3JldEtleSkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgcHVibGljIGtleSBmb3IgdGhpcyBhY2NvdW50XG4gICAqL1xuICBnZXQgcHVibGljS2V5KCkge1xuICAgIHJldHVybiBuZXcgUHVibGljS2V5KHRoaXMuX3B1YmxpY0tleSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlICoqdW5lbmNyeXB0ZWQqKiBzZWNyZXQga2V5IGZvciB0aGlzIGFjY291bnQuIFRoZSBmaXJzdCAzMiBieXRlc1xuICAgKiBpcyB0aGUgcHJpdmF0ZSBzY2FsYXIgYW5kIHRoZSBsYXN0IDMyIGJ5dGVzIGlzIHRoZSBwdWJsaWMga2V5LlxuICAgKiBSZWFkIG1vcmU6IGh0dHBzOi8vYmxvZy5tb3ppbGxhLm9yZy93YXJuZXIvMjAxMS8xMS8yOS9lZDI1NTE5LWtleXMvXG4gICAqL1xuICBnZXQgc2VjcmV0S2V5KCkge1xuICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFt0aGlzLl9zZWNyZXRLZXksIHRoaXMuX3B1YmxpY0tleV0sIDY0KTtcbiAgfVxufVxuXG5jb25zdCBCUEZfTE9BREVSX0RFUFJFQ0FURURfUFJPR1JBTV9JRCA9IG5ldyBQdWJsaWNLZXkoJ0JQRkxvYWRlcjExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcblxuLyoqXG4gKiBNYXhpbXVtIG92ZXItdGhlLXdpcmUgc2l6ZSBvZiBhIFRyYW5zYWN0aW9uXG4gKlxuICogMTI4MCBpcyBJUHY2IG1pbmltdW0gTVRVXG4gKiA0MCBieXRlcyBpcyB0aGUgc2l6ZSBvZiB0aGUgSVB2NiBoZWFkZXJcbiAqIDggYnl0ZXMgaXMgdGhlIHNpemUgb2YgdGhlIGZyYWdtZW50IGhlYWRlclxuICovXG5jb25zdCBQQUNLRVRfREFUQV9TSVpFID0gMTI4MCAtIDQwIC0gODtcbmNvbnN0IFZFUlNJT05fUFJFRklYX01BU0sgPSAweDdmO1xuY29uc3QgU0lHTkFUVVJFX0xFTkdUSF9JTl9CWVRFUyA9IDY0O1xuXG5jbGFzcyBUcmFuc2FjdGlvbkV4cGlyZWRCbG9ja2hlaWdodEV4Y2VlZGVkRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHNpZ25hdHVyZSkge1xuICAgIHN1cGVyKGBTaWduYXR1cmUgJHtzaWduYXR1cmV9IGhhcyBleHBpcmVkOiBibG9jayBoZWlnaHQgZXhjZWVkZWQuYCk7XG4gICAgdGhpcy5zaWduYXR1cmUgPSB2b2lkIDA7XG4gICAgdGhpcy5zaWduYXR1cmUgPSBzaWduYXR1cmU7XG4gIH1cbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFuc2FjdGlvbkV4cGlyZWRCbG9ja2hlaWdodEV4Y2VlZGVkRXJyb3IucHJvdG90eXBlLCAnbmFtZScsIHtcbiAgdmFsdWU6ICdUcmFuc2FjdGlvbkV4cGlyZWRCbG9ja2hlaWdodEV4Y2VlZGVkRXJyb3InXG59KTtcbmNsYXNzIFRyYW5zYWN0aW9uRXhwaXJlZFRpbWVvdXRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3Ioc2lnbmF0dXJlLCB0aW1lb3V0U2Vjb25kcykge1xuICAgIHN1cGVyKGBUcmFuc2FjdGlvbiB3YXMgbm90IGNvbmZpcm1lZCBpbiAke3RpbWVvdXRTZWNvbmRzLnRvRml4ZWQoMil9IHNlY29uZHMuIEl0IGlzIGAgKyAndW5rbm93biBpZiBpdCBzdWNjZWVkZWQgb3IgZmFpbGVkLiBDaGVjayBzaWduYXR1cmUgJyArIGAke3NpZ25hdHVyZX0gdXNpbmcgdGhlIFNvbGFuYSBFeHBsb3JlciBvciBDTEkgdG9vbHMuYCk7XG4gICAgdGhpcy5zaWduYXR1cmUgPSB2b2lkIDA7XG4gICAgdGhpcy5zaWduYXR1cmUgPSBzaWduYXR1cmU7XG4gIH1cbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFuc2FjdGlvbkV4cGlyZWRUaW1lb3V0RXJyb3IucHJvdG90eXBlLCAnbmFtZScsIHtcbiAgdmFsdWU6ICdUcmFuc2FjdGlvbkV4cGlyZWRUaW1lb3V0RXJyb3InXG59KTtcbmNsYXNzIFRyYW5zYWN0aW9uRXhwaXJlZE5vbmNlSW52YWxpZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihzaWduYXR1cmUpIHtcbiAgICBzdXBlcihgU2lnbmF0dXJlICR7c2lnbmF0dXJlfSBoYXMgZXhwaXJlZDogdGhlIG5vbmNlIGlzIG5vIGxvbmdlciB2YWxpZC5gKTtcbiAgICB0aGlzLnNpZ25hdHVyZSA9IHZvaWQgMDtcbiAgICB0aGlzLnNpZ25hdHVyZSA9IHNpZ25hdHVyZTtcbiAgfVxufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyYW5zYWN0aW9uRXhwaXJlZE5vbmNlSW52YWxpZEVycm9yLnByb3RvdHlwZSwgJ25hbWUnLCB7XG4gIHZhbHVlOiAnVHJhbnNhY3Rpb25FeHBpcmVkTm9uY2VJbnZhbGlkRXJyb3InXG59KTtcblxuY2xhc3MgTWVzc2FnZUFjY291bnRLZXlzIHtcbiAgY29uc3RydWN0b3Ioc3RhdGljQWNjb3VudEtleXMsIGFjY291bnRLZXlzRnJvbUxvb2t1cHMpIHtcbiAgICB0aGlzLnN0YXRpY0FjY291bnRLZXlzID0gdm9pZCAwO1xuICAgIHRoaXMuYWNjb3VudEtleXNGcm9tTG9va3VwcyA9IHZvaWQgMDtcbiAgICB0aGlzLnN0YXRpY0FjY291bnRLZXlzID0gc3RhdGljQWNjb3VudEtleXM7XG4gICAgdGhpcy5hY2NvdW50S2V5c0Zyb21Mb29rdXBzID0gYWNjb3VudEtleXNGcm9tTG9va3VwcztcbiAgfVxuICBrZXlTZWdtZW50cygpIHtcbiAgICBjb25zdCBrZXlTZWdtZW50cyA9IFt0aGlzLnN0YXRpY0FjY291bnRLZXlzXTtcbiAgICBpZiAodGhpcy5hY2NvdW50S2V5c0Zyb21Mb29rdXBzKSB7XG4gICAgICBrZXlTZWdtZW50cy5wdXNoKHRoaXMuYWNjb3VudEtleXNGcm9tTG9va3Vwcy53cml0YWJsZSk7XG4gICAgICBrZXlTZWdtZW50cy5wdXNoKHRoaXMuYWNjb3VudEtleXNGcm9tTG9va3Vwcy5yZWFkb25seSk7XG4gICAgfVxuICAgIHJldHVybiBrZXlTZWdtZW50cztcbiAgfVxuICBnZXQoaW5kZXgpIHtcbiAgICBmb3IgKGNvbnN0IGtleVNlZ21lbnQgb2YgdGhpcy5rZXlTZWdtZW50cygpKSB7XG4gICAgICBpZiAoaW5kZXggPCBrZXlTZWdtZW50Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4ga2V5U2VnbWVudFtpbmRleF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmRleCAtPSBrZXlTZWdtZW50Lmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIGdldCBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMua2V5U2VnbWVudHMoKS5mbGF0KCkubGVuZ3RoO1xuICB9XG4gIGNvbXBpbGVJbnN0cnVjdGlvbnMoaW5zdHJ1Y3Rpb25zKSB7XG4gICAgLy8gQmFpbCBlYXJseSBpZiBhbnkgYWNjb3VudCBpbmRleGVzIHdvdWxkIG92ZXJmbG93IGEgdThcbiAgICBjb25zdCBVOF9NQVggPSAyNTU7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gVThfTUFYICsgMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBY2NvdW50IGluZGV4IG92ZXJmbG93IGVuY291bnRlcmVkIGR1cmluZyBjb21waWxhdGlvbicpO1xuICAgIH1cbiAgICBjb25zdCBrZXlJbmRleE1hcCA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmtleVNlZ21lbnRzKCkuZmxhdCgpLmZvckVhY2goKGtleSwgaW5kZXgpID0+IHtcbiAgICAgIGtleUluZGV4TWFwLnNldChrZXkudG9CYXNlNTgoKSwgaW5kZXgpO1xuICAgIH0pO1xuICAgIGNvbnN0IGZpbmRLZXlJbmRleCA9IGtleSA9PiB7XG4gICAgICBjb25zdCBrZXlJbmRleCA9IGtleUluZGV4TWFwLmdldChrZXkudG9CYXNlNTgoKSk7XG4gICAgICBpZiAoa2V5SW5kZXggPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKCdFbmNvdW50ZXJlZCBhbiB1bmtub3duIGluc3RydWN0aW9uIGFjY291bnQga2V5IGR1cmluZyBjb21waWxhdGlvbicpO1xuICAgICAgcmV0dXJuIGtleUluZGV4O1xuICAgIH07XG4gICAgcmV0dXJuIGluc3RydWN0aW9ucy5tYXAoaW5zdHJ1Y3Rpb24gPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJvZ3JhbUlkSW5kZXg6IGZpbmRLZXlJbmRleChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpLFxuICAgICAgICBhY2NvdW50S2V5SW5kZXhlczogaW5zdHJ1Y3Rpb24ua2V5cy5tYXAobWV0YSA9PiBmaW5kS2V5SW5kZXgobWV0YS5wdWJrZXkpKSxcbiAgICAgICAgZGF0YTogaW5zdHJ1Y3Rpb24uZGF0YVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIExheW91dCBmb3IgYSBwdWJsaWMga2V5XG4gKi9cbmNvbnN0IHB1YmxpY0tleSA9IChwcm9wZXJ0eSA9ICdwdWJsaWNLZXknKSA9PiB7XG4gIHJldHVybiBCdWZmZXJMYXlvdXQuYmxvYigzMiwgcHJvcGVydHkpO1xufTtcblxuLyoqXG4gKiBMYXlvdXQgZm9yIGEgc2lnbmF0dXJlXG4gKi9cbmNvbnN0IHNpZ25hdHVyZSA9IChwcm9wZXJ0eSA9ICdzaWduYXR1cmUnKSA9PiB7XG4gIHJldHVybiBCdWZmZXJMYXlvdXQuYmxvYig2NCwgcHJvcGVydHkpO1xufTtcbi8qKlxuICogTGF5b3V0IGZvciBhIFJ1c3QgU3RyaW5nIHR5cGVcbiAqL1xuY29uc3QgcnVzdFN0cmluZyA9IChwcm9wZXJ0eSA9ICdzdHJpbmcnKSA9PiB7XG4gIGNvbnN0IHJzbCA9IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2xlbmd0aCcpLCBCdWZmZXJMYXlvdXQudTMyKCdsZW5ndGhQYWRkaW5nJyksIEJ1ZmZlckxheW91dC5ibG9iKEJ1ZmZlckxheW91dC5vZmZzZXQoQnVmZmVyTGF5b3V0LnUzMigpLCAtOCksICdjaGFycycpXSwgcHJvcGVydHkpO1xuICBjb25zdCBfZGVjb2RlID0gcnNsLmRlY29kZS5iaW5kKHJzbCk7XG4gIGNvbnN0IF9lbmNvZGUgPSByc2wuZW5jb2RlLmJpbmQocnNsKTtcbiAgY29uc3QgcnNsU2hpbSA9IHJzbDtcbiAgcnNsU2hpbS5kZWNvZGUgPSAoYiwgb2Zmc2V0KSA9PiB7XG4gICAgY29uc3QgZGF0YSA9IF9kZWNvZGUoYiwgb2Zmc2V0KTtcbiAgICByZXR1cm4gZGF0YVsnY2hhcnMnXS50b1N0cmluZygpO1xuICB9O1xuICByc2xTaGltLmVuY29kZSA9IChzdHIsIGIsIG9mZnNldCkgPT4ge1xuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICBjaGFyczogQnVmZmVyLmZyb20oc3RyLCAndXRmOCcpXG4gICAgfTtcbiAgICByZXR1cm4gX2VuY29kZShkYXRhLCBiLCBvZmZzZXQpO1xuICB9O1xuICByc2xTaGltLmFsbG9jID0gc3RyID0+IHtcbiAgICByZXR1cm4gQnVmZmVyTGF5b3V0LnUzMigpLnNwYW4gKyBCdWZmZXJMYXlvdXQudTMyKCkuc3BhbiArIEJ1ZmZlci5mcm9tKHN0ciwgJ3V0ZjgnKS5sZW5ndGg7XG4gIH07XG4gIHJldHVybiByc2xTaGltO1xufTtcblxuLyoqXG4gKiBMYXlvdXQgZm9yIGFuIEF1dGhvcml6ZWQgb2JqZWN0XG4gKi9cbmNvbnN0IGF1dGhvcml6ZWQgPSAocHJvcGVydHkgPSAnYXV0aG9yaXplZCcpID0+IHtcbiAgcmV0dXJuIEJ1ZmZlckxheW91dC5zdHJ1Y3QoW3B1YmxpY0tleSgnc3Rha2VyJyksIHB1YmxpY0tleSgnd2l0aGRyYXdlcicpXSwgcHJvcGVydHkpO1xufTtcblxuLyoqXG4gKiBMYXlvdXQgZm9yIGEgTG9ja3VwIG9iamVjdFxuICovXG5jb25zdCBsb2NrdXAgPSAocHJvcGVydHkgPSAnbG9ja3VwJykgPT4ge1xuICByZXR1cm4gQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0Lm5zNjQoJ3VuaXhUaW1lc3RhbXAnKSwgQnVmZmVyTGF5b3V0Lm5zNjQoJ2Vwb2NoJyksIHB1YmxpY0tleSgnY3VzdG9kaWFuJyldLCBwcm9wZXJ0eSk7XG59O1xuXG4vKipcbiAqICBMYXlvdXQgZm9yIGEgVm90ZUluaXQgb2JqZWN0XG4gKi9cbmNvbnN0IHZvdGVJbml0ID0gKHByb3BlcnR5ID0gJ3ZvdGVJbml0JykgPT4ge1xuICByZXR1cm4gQnVmZmVyTGF5b3V0LnN0cnVjdChbcHVibGljS2V5KCdub2RlUHVia2V5JyksIHB1YmxpY0tleSgnYXV0aG9yaXplZFZvdGVyJyksIHB1YmxpY0tleSgnYXV0aG9yaXplZFdpdGhkcmF3ZXInKSwgQnVmZmVyTGF5b3V0LnU4KCdjb21taXNzaW9uJyldLCBwcm9wZXJ0eSk7XG59O1xuXG4vKipcbiAqICBMYXlvdXQgZm9yIGEgVm90ZUF1dGhvcml6ZVdpdGhTZWVkQXJncyBvYmplY3RcbiAqL1xuY29uc3Qgdm90ZUF1dGhvcml6ZVdpdGhTZWVkQXJncyA9IChwcm9wZXJ0eSA9ICd2b3RlQXV0aG9yaXplV2l0aFNlZWRBcmdzJykgPT4ge1xuICByZXR1cm4gQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMigndm90ZUF1dGhvcml6YXRpb25UeXBlJyksIHB1YmxpY0tleSgnY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlPd25lclB1YmtleScpLCBydXN0U3RyaW5nKCdjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleVNlZWQnKSwgcHVibGljS2V5KCduZXdBdXRob3JpemVkJyldLCBwcm9wZXJ0eSk7XG59O1xuZnVuY3Rpb24gZ2V0QWxsb2ModHlwZSwgZmllbGRzKSB7XG4gIGNvbnN0IGdldEl0ZW1BbGxvYyA9IGl0ZW0gPT4ge1xuICAgIGlmIChpdGVtLnNwYW4gPj0gMCkge1xuICAgICAgcmV0dXJuIGl0ZW0uc3BhbjtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBpdGVtLmFsbG9jID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gaXRlbS5hbGxvYyhmaWVsZHNbaXRlbS5wcm9wZXJ0eV0pO1xuICAgIH0gZWxzZSBpZiAoJ2NvdW50JyBpbiBpdGVtICYmICdlbGVtZW50TGF5b3V0JyBpbiBpdGVtKSB7XG4gICAgICBjb25zdCBmaWVsZCA9IGZpZWxkc1tpdGVtLnByb3BlcnR5XTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGZpZWxkKSkge1xuICAgICAgICByZXR1cm4gZmllbGQubGVuZ3RoICogZ2V0SXRlbUFsbG9jKGl0ZW0uZWxlbWVudExheW91dCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgnZmllbGRzJyBpbiBpdGVtKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgYFN0cnVjdHVyZWAgd2hvc2Ugc2l6ZSBuZWVkcyB0byBiZSByZWN1cnNpdmVseSBtZWFzdXJlZC5cbiAgICAgIHJldHVybiBnZXRBbGxvYyh7XG4gICAgICAgIGxheW91dDogaXRlbVxuICAgICAgfSwgZmllbGRzW2l0ZW0ucHJvcGVydHldKTtcbiAgICB9XG4gICAgLy8gQ291bGRuJ3QgZGV0ZXJtaW5lIGFsbG9jYXRlZCBzaXplIG9mIGxheW91dFxuICAgIHJldHVybiAwO1xuICB9O1xuICBsZXQgYWxsb2MgPSAwO1xuICB0eXBlLmxheW91dC5maWVsZHMuZm9yRWFjaChpdGVtID0+IHtcbiAgICBhbGxvYyArPSBnZXRJdGVtQWxsb2MoaXRlbSk7XG4gIH0pO1xuICByZXR1cm4gYWxsb2M7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUxlbmd0aChieXRlcykge1xuICBsZXQgbGVuID0gMDtcbiAgbGV0IHNpemUgPSAwO1xuICBmb3IgKDs7KSB7XG4gICAgbGV0IGVsZW0gPSBieXRlcy5zaGlmdCgpO1xuICAgIGxlbiB8PSAoZWxlbSAmIDB4N2YpIDw8IHNpemUgKiA3O1xuICAgIHNpemUgKz0gMTtcbiAgICBpZiAoKGVsZW0gJiAweDgwKSA9PT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBsZW47XG59XG5mdW5jdGlvbiBlbmNvZGVMZW5ndGgoYnl0ZXMsIGxlbikge1xuICBsZXQgcmVtX2xlbiA9IGxlbjtcbiAgZm9yICg7Oykge1xuICAgIGxldCBlbGVtID0gcmVtX2xlbiAmIDB4N2Y7XG4gICAgcmVtX2xlbiA+Pj0gNztcbiAgICBpZiAocmVtX2xlbiA9PSAwKSB7XG4gICAgICBieXRlcy5wdXNoKGVsZW0pO1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW0gfD0gMHg4MDtcbiAgICAgIGJ5dGVzLnB1c2goZWxlbSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydCAoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UgfHwgJ0Fzc2VydGlvbiBmYWlsZWQnKTtcbiAgfVxufVxuXG5jbGFzcyBDb21waWxlZEtleXMge1xuICBjb25zdHJ1Y3RvcihwYXllciwga2V5TWV0YU1hcCkge1xuICAgIHRoaXMucGF5ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5rZXlNZXRhTWFwID0gdm9pZCAwO1xuICAgIHRoaXMucGF5ZXIgPSBwYXllcjtcbiAgICB0aGlzLmtleU1ldGFNYXAgPSBrZXlNZXRhTWFwO1xuICB9XG4gIHN0YXRpYyBjb21waWxlKGluc3RydWN0aW9ucywgcGF5ZXIpIHtcbiAgICBjb25zdCBrZXlNZXRhTWFwID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGdldE9ySW5zZXJ0RGVmYXVsdCA9IHB1YmtleSA9PiB7XG4gICAgICBjb25zdCBhZGRyZXNzID0gcHVia2V5LnRvQmFzZTU4KCk7XG4gICAgICBsZXQga2V5TWV0YSA9IGtleU1ldGFNYXAuZ2V0KGFkZHJlc3MpO1xuICAgICAgaWYgKGtleU1ldGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBrZXlNZXRhID0ge1xuICAgICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICBpc0ludm9rZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIGtleU1ldGFNYXAuc2V0KGFkZHJlc3MsIGtleU1ldGEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGtleU1ldGE7XG4gICAgfTtcbiAgICBjb25zdCBwYXllcktleU1ldGEgPSBnZXRPckluc2VydERlZmF1bHQocGF5ZXIpO1xuICAgIHBheWVyS2V5TWV0YS5pc1NpZ25lciA9IHRydWU7XG4gICAgcGF5ZXJLZXlNZXRhLmlzV3JpdGFibGUgPSB0cnVlO1xuICAgIGZvciAoY29uc3QgaXggb2YgaW5zdHJ1Y3Rpb25zKSB7XG4gICAgICBnZXRPckluc2VydERlZmF1bHQoaXgucHJvZ3JhbUlkKS5pc0ludm9rZWQgPSB0cnVlO1xuICAgICAgZm9yIChjb25zdCBhY2NvdW50TWV0YSBvZiBpeC5rZXlzKSB7XG4gICAgICAgIGNvbnN0IGtleU1ldGEgPSBnZXRPckluc2VydERlZmF1bHQoYWNjb3VudE1ldGEucHVia2V5KTtcbiAgICAgICAga2V5TWV0YS5pc1NpZ25lciB8fD0gYWNjb3VudE1ldGEuaXNTaWduZXI7XG4gICAgICAgIGtleU1ldGEuaXNXcml0YWJsZSB8fD0gYWNjb3VudE1ldGEuaXNXcml0YWJsZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBDb21waWxlZEtleXMocGF5ZXIsIGtleU1ldGFNYXApO1xuICB9XG4gIGdldE1lc3NhZ2VDb21wb25lbnRzKCkge1xuICAgIGNvbnN0IG1hcEVudHJpZXMgPSBbLi4udGhpcy5rZXlNZXRhTWFwLmVudHJpZXMoKV07XG4gICAgYXNzZXJ0KG1hcEVudHJpZXMubGVuZ3RoIDw9IDI1NiwgJ01heCBzdGF0aWMgYWNjb3VudCBrZXlzIGxlbmd0aCBleGNlZWRlZCcpO1xuICAgIGNvbnN0IHdyaXRhYmxlU2lnbmVycyA9IG1hcEVudHJpZXMuZmlsdGVyKChbLCBtZXRhXSkgPT4gbWV0YS5pc1NpZ25lciAmJiBtZXRhLmlzV3JpdGFibGUpO1xuICAgIGNvbnN0IHJlYWRvbmx5U2lnbmVycyA9IG1hcEVudHJpZXMuZmlsdGVyKChbLCBtZXRhXSkgPT4gbWV0YS5pc1NpZ25lciAmJiAhbWV0YS5pc1dyaXRhYmxlKTtcbiAgICBjb25zdCB3cml0YWJsZU5vblNpZ25lcnMgPSBtYXBFbnRyaWVzLmZpbHRlcigoWywgbWV0YV0pID0+ICFtZXRhLmlzU2lnbmVyICYmIG1ldGEuaXNXcml0YWJsZSk7XG4gICAgY29uc3QgcmVhZG9ubHlOb25TaWduZXJzID0gbWFwRW50cmllcy5maWx0ZXIoKFssIG1ldGFdKSA9PiAhbWV0YS5pc1NpZ25lciAmJiAhbWV0YS5pc1dyaXRhYmxlKTtcbiAgICBjb25zdCBoZWFkZXIgPSB7XG4gICAgICBudW1SZXF1aXJlZFNpZ25hdHVyZXM6IHdyaXRhYmxlU2lnbmVycy5sZW5ndGggKyByZWFkb25seVNpZ25lcnMubGVuZ3RoLFxuICAgICAgbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50czogcmVhZG9ubHlTaWduZXJzLmxlbmd0aCxcbiAgICAgIG51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50czogcmVhZG9ubHlOb25TaWduZXJzLmxlbmd0aFxuICAgIH07XG5cbiAgICAvLyBzYW5pdHkgY2hlY2tzXG4gICAge1xuICAgICAgYXNzZXJ0KHdyaXRhYmxlU2lnbmVycy5sZW5ndGggPiAwLCAnRXhwZWN0ZWQgYXQgbGVhc3Qgb25lIHdyaXRhYmxlIHNpZ25lciBrZXknKTtcbiAgICAgIGNvbnN0IFtwYXllckFkZHJlc3NdID0gd3JpdGFibGVTaWduZXJzWzBdO1xuICAgICAgYXNzZXJ0KHBheWVyQWRkcmVzcyA9PT0gdGhpcy5wYXllci50b0Jhc2U1OCgpLCAnRXhwZWN0ZWQgZmlyc3Qgd3JpdGFibGUgc2lnbmVyIGtleSB0byBiZSB0aGUgZmVlIHBheWVyJyk7XG4gICAgfVxuICAgIGNvbnN0IHN0YXRpY0FjY291bnRLZXlzID0gWy4uLndyaXRhYmxlU2lnbmVycy5tYXAoKFthZGRyZXNzXSkgPT4gbmV3IFB1YmxpY0tleShhZGRyZXNzKSksIC4uLnJlYWRvbmx5U2lnbmVycy5tYXAoKFthZGRyZXNzXSkgPT4gbmV3IFB1YmxpY0tleShhZGRyZXNzKSksIC4uLndyaXRhYmxlTm9uU2lnbmVycy5tYXAoKFthZGRyZXNzXSkgPT4gbmV3IFB1YmxpY0tleShhZGRyZXNzKSksIC4uLnJlYWRvbmx5Tm9uU2lnbmVycy5tYXAoKFthZGRyZXNzXSkgPT4gbmV3IFB1YmxpY0tleShhZGRyZXNzKSldO1xuICAgIHJldHVybiBbaGVhZGVyLCBzdGF0aWNBY2NvdW50S2V5c107XG4gIH1cbiAgZXh0cmFjdFRhYmxlTG9va3VwKGxvb2t1cFRhYmxlKSB7XG4gICAgY29uc3QgW3dyaXRhYmxlSW5kZXhlcywgZHJhaW5lZFdyaXRhYmxlS2V5c10gPSB0aGlzLmRyYWluS2V5c0ZvdW5kSW5Mb29rdXBUYWJsZShsb29rdXBUYWJsZS5zdGF0ZS5hZGRyZXNzZXMsIGtleU1ldGEgPT4gIWtleU1ldGEuaXNTaWduZXIgJiYgIWtleU1ldGEuaXNJbnZva2VkICYmIGtleU1ldGEuaXNXcml0YWJsZSk7XG4gICAgY29uc3QgW3JlYWRvbmx5SW5kZXhlcywgZHJhaW5lZFJlYWRvbmx5S2V5c10gPSB0aGlzLmRyYWluS2V5c0ZvdW5kSW5Mb29rdXBUYWJsZShsb29rdXBUYWJsZS5zdGF0ZS5hZGRyZXNzZXMsIGtleU1ldGEgPT4gIWtleU1ldGEuaXNTaWduZXIgJiYgIWtleU1ldGEuaXNJbnZva2VkICYmICFrZXlNZXRhLmlzV3JpdGFibGUpO1xuXG4gICAgLy8gRG9uJ3QgZXh0cmFjdCBsb29rdXAgaWYgbm8ga2V5cyB3ZXJlIGZvdW5kXG4gICAgaWYgKHdyaXRhYmxlSW5kZXhlcy5sZW5ndGggPT09IDAgJiYgcmVhZG9ubHlJbmRleGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gW3tcbiAgICAgIGFjY291bnRLZXk6IGxvb2t1cFRhYmxlLmtleSxcbiAgICAgIHdyaXRhYmxlSW5kZXhlcyxcbiAgICAgIHJlYWRvbmx5SW5kZXhlc1xuICAgIH0sIHtcbiAgICAgIHdyaXRhYmxlOiBkcmFpbmVkV3JpdGFibGVLZXlzLFxuICAgICAgcmVhZG9ubHk6IGRyYWluZWRSZWFkb25seUtleXNcbiAgICB9XTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZHJhaW5LZXlzRm91bmRJbkxvb2t1cFRhYmxlKGxvb2t1cFRhYmxlRW50cmllcywga2V5TWV0YUZpbHRlcikge1xuICAgIGNvbnN0IGxvb2t1cFRhYmxlSW5kZXhlcyA9IG5ldyBBcnJheSgpO1xuICAgIGNvbnN0IGRyYWluZWRLZXlzID0gbmV3IEFycmF5KCk7XG4gICAgZm9yIChjb25zdCBbYWRkcmVzcywga2V5TWV0YV0gb2YgdGhpcy5rZXlNZXRhTWFwLmVudHJpZXMoKSkge1xuICAgICAgaWYgKGtleU1ldGFGaWx0ZXIoa2V5TWV0YSkpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gbmV3IFB1YmxpY0tleShhZGRyZXNzKTtcbiAgICAgICAgY29uc3QgbG9va3VwVGFibGVJbmRleCA9IGxvb2t1cFRhYmxlRW50cmllcy5maW5kSW5kZXgoZW50cnkgPT4gZW50cnkuZXF1YWxzKGtleSkpO1xuICAgICAgICBpZiAobG9va3VwVGFibGVJbmRleCA+PSAwKSB7XG4gICAgICAgICAgYXNzZXJ0KGxvb2t1cFRhYmxlSW5kZXggPCAyNTYsICdNYXggbG9va3VwIHRhYmxlIGluZGV4IGV4Y2VlZGVkJyk7XG4gICAgICAgICAgbG9va3VwVGFibGVJbmRleGVzLnB1c2gobG9va3VwVGFibGVJbmRleCk7XG4gICAgICAgICAgZHJhaW5lZEtleXMucHVzaChrZXkpO1xuICAgICAgICAgIHRoaXMua2V5TWV0YU1hcC5kZWxldGUoYWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtsb29rdXBUYWJsZUluZGV4ZXMsIGRyYWluZWRLZXlzXTtcbiAgfVxufVxuXG5jb25zdCBFTkRfT0ZfQlVGRkVSX0VSUk9SX01FU1NBR0UgPSAnUmVhY2hlZCBlbmQgb2YgYnVmZmVyIHVuZXhwZWN0ZWRseSc7XG5cbi8qKlxuICogRGVsZWdhdGVzIHRvIGBBcnJheSNzaGlmdGAsIGJ1dCB0aHJvd3MgaWYgdGhlIGFycmF5IGlzIHplcm8tbGVuZ3RoLlxuICovXG5mdW5jdGlvbiBndWFyZGVkU2hpZnQoYnl0ZUFycmF5KSB7XG4gIGlmIChieXRlQXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKEVORF9PRl9CVUZGRVJfRVJST1JfTUVTU0FHRSk7XG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheS5zaGlmdCgpO1xufVxuXG4vKipcbiAqIERlbGVnYXRlcyB0byBgQXJyYXkjc3BsaWNlYCwgYnV0IHRocm93cyBpZiB0aGUgc2VjdGlvbiBiZWluZyBzcGxpY2VkIG91dCBleHRlbmRzIHBhc3QgdGhlIGVuZCBvZlxuICogdGhlIGFycmF5LlxuICovXG5mdW5jdGlvbiBndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgLi4uYXJncykge1xuICBjb25zdCBbc3RhcnRdID0gYXJncztcbiAgaWYgKGFyZ3MubGVuZ3RoID09PSAyIC8vIEltcGxpZXMgdGhhdCBgZGVsZXRlQ291bnRgIHdhcyBzdXBwbGllZFxuICA/IHN0YXJ0ICsgKGFyZ3NbMV0gPz8gMCkgPiBieXRlQXJyYXkubGVuZ3RoIDogc3RhcnQgPj0gYnl0ZUFycmF5Lmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihFTkRfT0ZfQlVGRkVSX0VSUk9SX01FU1NBR0UpO1xuICB9XG4gIHJldHVybiBieXRlQXJyYXkuc3BsaWNlKC4uLmFyZ3MpO1xufVxuXG4vKipcbiAqIEFuIGluc3RydWN0aW9uIHRvIGV4ZWN1dGUgYnkgYSBwcm9ncmFtXG4gKlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHByb2dyYW1JZEluZGV4XG4gKiBAcHJvcGVydHkge251bWJlcltdfSBhY2NvdW50c1xuICogQHByb3BlcnR5IHtzdHJpbmd9IGRhdGFcbiAqL1xuXG4vKipcbiAqIE1lc3NhZ2UgY29uc3RydWN0b3IgYXJndW1lbnRzXG4gKi9cblxuLyoqXG4gKiBMaXN0IG9mIGluc3RydWN0aW9ucyB0byBiZSBwcm9jZXNzZWQgYXRvbWljYWxseVxuICovXG5jbGFzcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoYXJncykge1xuICAgIHRoaXMuaGVhZGVyID0gdm9pZCAwO1xuICAgIHRoaXMuYWNjb3VudEtleXMgPSB2b2lkIDA7XG4gICAgdGhpcy5yZWNlbnRCbG9ja2hhc2ggPSB2b2lkIDA7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMgPSB2b2lkIDA7XG4gICAgdGhpcy5pbmRleFRvUHJvZ3JhbUlkcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmhlYWRlciA9IGFyZ3MuaGVhZGVyO1xuICAgIHRoaXMuYWNjb3VudEtleXMgPSBhcmdzLmFjY291bnRLZXlzLm1hcChhY2NvdW50ID0+IG5ldyBQdWJsaWNLZXkoYWNjb3VudCkpO1xuICAgIHRoaXMucmVjZW50QmxvY2toYXNoID0gYXJncy5yZWNlbnRCbG9ja2hhc2g7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMgPSBhcmdzLmluc3RydWN0aW9ucztcbiAgICB0aGlzLmluc3RydWN0aW9ucy5mb3JFYWNoKGl4ID0+IHRoaXMuaW5kZXhUb1Byb2dyYW1JZHMuc2V0KGl4LnByb2dyYW1JZEluZGV4LCB0aGlzLmFjY291bnRLZXlzW2l4LnByb2dyYW1JZEluZGV4XSkpO1xuICB9XG4gIGdldCB2ZXJzaW9uKCkge1xuICAgIHJldHVybiAnbGVnYWN5JztcbiAgfVxuICBnZXQgc3RhdGljQWNjb3VudEtleXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWNjb3VudEtleXM7XG4gIH1cbiAgZ2V0IGNvbXBpbGVkSW5zdHJ1Y3Rpb25zKCkge1xuICAgIHJldHVybiB0aGlzLmluc3RydWN0aW9ucy5tYXAoaXggPT4gKHtcbiAgICAgIHByb2dyYW1JZEluZGV4OiBpeC5wcm9ncmFtSWRJbmRleCxcbiAgICAgIGFjY291bnRLZXlJbmRleGVzOiBpeC5hY2NvdW50cyxcbiAgICAgIGRhdGE6IGJzNTguZGVjb2RlKGl4LmRhdGEpXG4gICAgfSkpO1xuICB9XG4gIGdldCBhZGRyZXNzVGFibGVMb29rdXBzKCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBnZXRBY2NvdW50S2V5cygpIHtcbiAgICByZXR1cm4gbmV3IE1lc3NhZ2VBY2NvdW50S2V5cyh0aGlzLnN0YXRpY0FjY291bnRLZXlzKTtcbiAgfVxuICBzdGF0aWMgY29tcGlsZShhcmdzKSB7XG4gICAgY29uc3QgY29tcGlsZWRLZXlzID0gQ29tcGlsZWRLZXlzLmNvbXBpbGUoYXJncy5pbnN0cnVjdGlvbnMsIGFyZ3MucGF5ZXJLZXkpO1xuICAgIGNvbnN0IFtoZWFkZXIsIHN0YXRpY0FjY291bnRLZXlzXSA9IGNvbXBpbGVkS2V5cy5nZXRNZXNzYWdlQ29tcG9uZW50cygpO1xuICAgIGNvbnN0IGFjY291bnRLZXlzID0gbmV3IE1lc3NhZ2VBY2NvdW50S2V5cyhzdGF0aWNBY2NvdW50S2V5cyk7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25zID0gYWNjb3VudEtleXMuY29tcGlsZUluc3RydWN0aW9ucyhhcmdzLmluc3RydWN0aW9ucykubWFwKGl4ID0+ICh7XG4gICAgICBwcm9ncmFtSWRJbmRleDogaXgucHJvZ3JhbUlkSW5kZXgsXG4gICAgICBhY2NvdW50czogaXguYWNjb3VudEtleUluZGV4ZXMsXG4gICAgICBkYXRhOiBiczU4LmVuY29kZShpeC5kYXRhKVxuICAgIH0pKTtcbiAgICByZXR1cm4gbmV3IE1lc3NhZ2Uoe1xuICAgICAgaGVhZGVyLFxuICAgICAgYWNjb3VudEtleXM6IHN0YXRpY0FjY291bnRLZXlzLFxuICAgICAgcmVjZW50QmxvY2toYXNoOiBhcmdzLnJlY2VudEJsb2NraGFzaCxcbiAgICAgIGluc3RydWN0aW9uc1xuICAgIH0pO1xuICB9XG4gIGlzQWNjb3VudFNpZ25lcihpbmRleCkge1xuICAgIHJldHVybiBpbmRleCA8IHRoaXMuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcztcbiAgfVxuICBpc0FjY291bnRXcml0YWJsZShpbmRleCkge1xuICAgIGNvbnN0IG51bVNpZ25lZEFjY291bnRzID0gdGhpcy5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzO1xuICAgIGlmIChpbmRleCA+PSB0aGlzLmhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXMpIHtcbiAgICAgIGNvbnN0IHVuc2lnbmVkQWNjb3VudEluZGV4ID0gaW5kZXggLSBudW1TaWduZWRBY2NvdW50cztcbiAgICAgIGNvbnN0IG51bVVuc2lnbmVkQWNjb3VudHMgPSB0aGlzLmFjY291bnRLZXlzLmxlbmd0aCAtIG51bVNpZ25lZEFjY291bnRzO1xuICAgICAgY29uc3QgbnVtV3JpdGFibGVVbnNpZ25lZEFjY291bnRzID0gbnVtVW5zaWduZWRBY2NvdW50cyAtIHRoaXMuaGVhZGVyLm51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50cztcbiAgICAgIHJldHVybiB1bnNpZ25lZEFjY291bnRJbmRleCA8IG51bVdyaXRhYmxlVW5zaWduZWRBY2NvdW50cztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbnVtV3JpdGFibGVTaWduZWRBY2NvdW50cyA9IG51bVNpZ25lZEFjY291bnRzIC0gdGhpcy5oZWFkZXIubnVtUmVhZG9ubHlTaWduZWRBY2NvdW50cztcbiAgICAgIHJldHVybiBpbmRleCA8IG51bVdyaXRhYmxlU2lnbmVkQWNjb3VudHM7XG4gICAgfVxuICB9XG4gIGlzUHJvZ3JhbUlkKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuaW5kZXhUb1Byb2dyYW1JZHMuaGFzKGluZGV4KTtcbiAgfVxuICBwcm9ncmFtSWRzKCkge1xuICAgIHJldHVybiBbLi4udGhpcy5pbmRleFRvUHJvZ3JhbUlkcy52YWx1ZXMoKV07XG4gIH1cbiAgbm9uUHJvZ3JhbUlkcygpIHtcbiAgICByZXR1cm4gdGhpcy5hY2NvdW50S2V5cy5maWx0ZXIoKF8sIGluZGV4KSA9PiAhdGhpcy5pc1Byb2dyYW1JZChpbmRleCkpO1xuICB9XG4gIHNlcmlhbGl6ZSgpIHtcbiAgICBjb25zdCBudW1LZXlzID0gdGhpcy5hY2NvdW50S2V5cy5sZW5ndGg7XG4gICAgbGV0IGtleUNvdW50ID0gW107XG4gICAgZW5jb2RlTGVuZ3RoKGtleUNvdW50LCBudW1LZXlzKTtcbiAgICBjb25zdCBpbnN0cnVjdGlvbnMgPSB0aGlzLmluc3RydWN0aW9ucy5tYXAoaW5zdHJ1Y3Rpb24gPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBhY2NvdW50cyxcbiAgICAgICAgcHJvZ3JhbUlkSW5kZXhcbiAgICAgIH0gPSBpbnN0cnVjdGlvbjtcbiAgICAgIGNvbnN0IGRhdGEgPSBBcnJheS5mcm9tKGJzNTguZGVjb2RlKGluc3RydWN0aW9uLmRhdGEpKTtcbiAgICAgIGxldCBrZXlJbmRpY2VzQ291bnQgPSBbXTtcbiAgICAgIGVuY29kZUxlbmd0aChrZXlJbmRpY2VzQ291bnQsIGFjY291bnRzLmxlbmd0aCk7XG4gICAgICBsZXQgZGF0YUNvdW50ID0gW107XG4gICAgICBlbmNvZGVMZW5ndGgoZGF0YUNvdW50LCBkYXRhLmxlbmd0aCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcm9ncmFtSWRJbmRleCxcbiAgICAgICAga2V5SW5kaWNlc0NvdW50OiBCdWZmZXIuZnJvbShrZXlJbmRpY2VzQ291bnQpLFxuICAgICAgICBrZXlJbmRpY2VzOiBhY2NvdW50cyxcbiAgICAgICAgZGF0YUxlbmd0aDogQnVmZmVyLmZyb20oZGF0YUNvdW50KSxcbiAgICAgICAgZGF0YVxuICAgICAgfTtcbiAgICB9KTtcbiAgICBsZXQgaW5zdHJ1Y3Rpb25Db3VudCA9IFtdO1xuICAgIGVuY29kZUxlbmd0aChpbnN0cnVjdGlvbkNvdW50LCBpbnN0cnVjdGlvbnMubGVuZ3RoKTtcbiAgICBsZXQgaW5zdHJ1Y3Rpb25CdWZmZXIgPSBCdWZmZXIuYWxsb2MoUEFDS0VUX0RBVEFfU0laRSk7XG4gICAgQnVmZmVyLmZyb20oaW5zdHJ1Y3Rpb25Db3VudCkuY29weShpbnN0cnVjdGlvbkJ1ZmZlcik7XG4gICAgbGV0IGluc3RydWN0aW9uQnVmZmVyTGVuZ3RoID0gaW5zdHJ1Y3Rpb25Db3VudC5sZW5ndGg7XG4gICAgaW5zdHJ1Y3Rpb25zLmZvckVhY2goaW5zdHJ1Y3Rpb24gPT4ge1xuICAgICAgY29uc3QgaW5zdHJ1Y3Rpb25MYXlvdXQgPSBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTgoJ3Byb2dyYW1JZEluZGV4JyksIEJ1ZmZlckxheW91dC5ibG9iKGluc3RydWN0aW9uLmtleUluZGljZXNDb3VudC5sZW5ndGgsICdrZXlJbmRpY2VzQ291bnQnKSwgQnVmZmVyTGF5b3V0LnNlcShCdWZmZXJMYXlvdXQudTgoJ2tleUluZGV4JyksIGluc3RydWN0aW9uLmtleUluZGljZXMubGVuZ3RoLCAna2V5SW5kaWNlcycpLCBCdWZmZXJMYXlvdXQuYmxvYihpbnN0cnVjdGlvbi5kYXRhTGVuZ3RoLmxlbmd0aCwgJ2RhdGFMZW5ndGgnKSwgQnVmZmVyTGF5b3V0LnNlcShCdWZmZXJMYXlvdXQudTgoJ3VzZXJkYXR1bScpLCBpbnN0cnVjdGlvbi5kYXRhLmxlbmd0aCwgJ2RhdGEnKV0pO1xuICAgICAgY29uc3QgbGVuZ3RoID0gaW5zdHJ1Y3Rpb25MYXlvdXQuZW5jb2RlKGluc3RydWN0aW9uLCBpbnN0cnVjdGlvbkJ1ZmZlciwgaW5zdHJ1Y3Rpb25CdWZmZXJMZW5ndGgpO1xuICAgICAgaW5zdHJ1Y3Rpb25CdWZmZXJMZW5ndGggKz0gbGVuZ3RoO1xuICAgIH0pO1xuICAgIGluc3RydWN0aW9uQnVmZmVyID0gaW5zdHJ1Y3Rpb25CdWZmZXIuc2xpY2UoMCwgaW5zdHJ1Y3Rpb25CdWZmZXJMZW5ndGgpO1xuICAgIGNvbnN0IHNpZ25EYXRhTGF5b3V0ID0gQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LmJsb2IoMSwgJ251bVJlcXVpcmVkU2lnbmF0dXJlcycpLCBCdWZmZXJMYXlvdXQuYmxvYigxLCAnbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50cycpLCBCdWZmZXJMYXlvdXQuYmxvYigxLCAnbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzJyksIEJ1ZmZlckxheW91dC5ibG9iKGtleUNvdW50Lmxlbmd0aCwgJ2tleUNvdW50JyksIEJ1ZmZlckxheW91dC5zZXEocHVibGljS2V5KCdrZXknKSwgbnVtS2V5cywgJ2tleXMnKSwgcHVibGljS2V5KCdyZWNlbnRCbG9ja2hhc2gnKV0pO1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0ge1xuICAgICAgbnVtUmVxdWlyZWRTaWduYXR1cmVzOiBCdWZmZXIuZnJvbShbdGhpcy5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzXSksXG4gICAgICBudW1SZWFkb25seVNpZ25lZEFjY291bnRzOiBCdWZmZXIuZnJvbShbdGhpcy5oZWFkZXIubnVtUmVhZG9ubHlTaWduZWRBY2NvdW50c10pLFxuICAgICAgbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzOiBCdWZmZXIuZnJvbShbdGhpcy5oZWFkZXIubnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzXSksXG4gICAgICBrZXlDb3VudDogQnVmZmVyLmZyb20oa2V5Q291bnQpLFxuICAgICAga2V5czogdGhpcy5hY2NvdW50S2V5cy5tYXAoa2V5ID0+IHRvQnVmZmVyKGtleS50b0J5dGVzKCkpKSxcbiAgICAgIHJlY2VudEJsb2NraGFzaDogYnM1OC5kZWNvZGUodGhpcy5yZWNlbnRCbG9ja2hhc2gpXG4gICAgfTtcbiAgICBsZXQgc2lnbkRhdGEgPSBCdWZmZXIuYWxsb2MoMjA0OCk7XG4gICAgY29uc3QgbGVuZ3RoID0gc2lnbkRhdGFMYXlvdXQuZW5jb2RlKHRyYW5zYWN0aW9uLCBzaWduRGF0YSk7XG4gICAgaW5zdHJ1Y3Rpb25CdWZmZXIuY29weShzaWduRGF0YSwgbGVuZ3RoKTtcbiAgICByZXR1cm4gc2lnbkRhdGEuc2xpY2UoMCwgbGVuZ3RoICsgaW5zdHJ1Y3Rpb25CdWZmZXIubGVuZ3RoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBjb21waWxlZCBtZXNzYWdlIGludG8gYSBNZXNzYWdlIG9iamVjdC5cbiAgICovXG4gIHN0YXRpYyBmcm9tKGJ1ZmZlcikge1xuICAgIC8vIFNsaWNlIHVwIHdpcmUgZGF0YVxuICAgIGxldCBieXRlQXJyYXkgPSBbLi4uYnVmZmVyXTtcbiAgICBjb25zdCBudW1SZXF1aXJlZFNpZ25hdHVyZXMgPSBndWFyZGVkU2hpZnQoYnl0ZUFycmF5KTtcbiAgICBpZiAobnVtUmVxdWlyZWRTaWduYXR1cmVzICE9PSAobnVtUmVxdWlyZWRTaWduYXR1cmVzICYgVkVSU0lPTl9QUkVGSVhfTUFTSykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVmVyc2lvbmVkIG1lc3NhZ2VzIG11c3QgYmUgZGVzZXJpYWxpemVkIHdpdGggVmVyc2lvbmVkTWVzc2FnZS5kZXNlcmlhbGl6ZSgpJyk7XG4gICAgfVxuICAgIGNvbnN0IG51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHMgPSBndWFyZGVkU2hpZnQoYnl0ZUFycmF5KTtcbiAgICBjb25zdCBudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHMgPSBndWFyZGVkU2hpZnQoYnl0ZUFycmF5KTtcbiAgICBjb25zdCBhY2NvdW50Q291bnQgPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICBsZXQgYWNjb3VudEtleXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFjY291bnRDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBhY2NvdW50ID0gZ3VhcmRlZFNwbGljZShieXRlQXJyYXksIDAsIFBVQkxJQ19LRVlfTEVOR1RIKTtcbiAgICAgIGFjY291bnRLZXlzLnB1c2gobmV3IFB1YmxpY0tleShCdWZmZXIuZnJvbShhY2NvdW50KSkpO1xuICAgIH1cbiAgICBjb25zdCByZWNlbnRCbG9ja2hhc2ggPSBndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgUFVCTElDX0tFWV9MRU5HVEgpO1xuICAgIGNvbnN0IGluc3RydWN0aW9uQ291bnQgPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICBsZXQgaW5zdHJ1Y3Rpb25zID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnN0cnVjdGlvbkNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHByb2dyYW1JZEluZGV4ID0gZ3VhcmRlZFNoaWZ0KGJ5dGVBcnJheSk7XG4gICAgICBjb25zdCBhY2NvdW50Q291bnQgPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICAgIGNvbnN0IGFjY291bnRzID0gZ3VhcmRlZFNwbGljZShieXRlQXJyYXksIDAsIGFjY291bnRDb3VudCk7XG4gICAgICBjb25zdCBkYXRhTGVuZ3RoID0gZGVjb2RlTGVuZ3RoKGJ5dGVBcnJheSk7XG4gICAgICBjb25zdCBkYXRhU2xpY2UgPSBndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgZGF0YUxlbmd0aCk7XG4gICAgICBjb25zdCBkYXRhID0gYnM1OC5lbmNvZGUoQnVmZmVyLmZyb20oZGF0YVNsaWNlKSk7XG4gICAgICBpbnN0cnVjdGlvbnMucHVzaCh7XG4gICAgICAgIHByb2dyYW1JZEluZGV4LFxuICAgICAgICBhY2NvdW50cyxcbiAgICAgICAgZGF0YVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IG1lc3NhZ2VBcmdzID0ge1xuICAgICAgaGVhZGVyOiB7XG4gICAgICAgIG51bVJlcXVpcmVkU2lnbmF0dXJlcyxcbiAgICAgICAgbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50cyxcbiAgICAgICAgbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzXG4gICAgICB9LFxuICAgICAgcmVjZW50QmxvY2toYXNoOiBiczU4LmVuY29kZShCdWZmZXIuZnJvbShyZWNlbnRCbG9ja2hhc2gpKSxcbiAgICAgIGFjY291bnRLZXlzLFxuICAgICAgaW5zdHJ1Y3Rpb25zXG4gICAgfTtcbiAgICByZXR1cm4gbmV3IE1lc3NhZ2UobWVzc2FnZUFyZ3MpO1xuICB9XG59XG5cbi8qKlxuICogTWVzc2FnZSBjb25zdHJ1Y3RvciBhcmd1bWVudHNcbiAqL1xuXG5jbGFzcyBNZXNzYWdlVjAge1xuICBjb25zdHJ1Y3RvcihhcmdzKSB7XG4gICAgdGhpcy5oZWFkZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5zdGF0aWNBY2NvdW50S2V5cyA9IHZvaWQgMDtcbiAgICB0aGlzLnJlY2VudEJsb2NraGFzaCA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbXBpbGVkSW5zdHJ1Y3Rpb25zID0gdm9pZCAwO1xuICAgIHRoaXMuYWRkcmVzc1RhYmxlTG9va3VwcyA9IHZvaWQgMDtcbiAgICB0aGlzLmhlYWRlciA9IGFyZ3MuaGVhZGVyO1xuICAgIHRoaXMuc3RhdGljQWNjb3VudEtleXMgPSBhcmdzLnN0YXRpY0FjY291bnRLZXlzO1xuICAgIHRoaXMucmVjZW50QmxvY2toYXNoID0gYXJncy5yZWNlbnRCbG9ja2hhc2g7XG4gICAgdGhpcy5jb21waWxlZEluc3RydWN0aW9ucyA9IGFyZ3MuY29tcGlsZWRJbnN0cnVjdGlvbnM7XG4gICAgdGhpcy5hZGRyZXNzVGFibGVMb29rdXBzID0gYXJncy5hZGRyZXNzVGFibGVMb29rdXBzO1xuICB9XG4gIGdldCB2ZXJzaW9uKCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGdldCBudW1BY2NvdW50S2V5c0Zyb21Mb29rdXBzKCkge1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgZm9yIChjb25zdCBsb29rdXAgb2YgdGhpcy5hZGRyZXNzVGFibGVMb29rdXBzKSB7XG4gICAgICBjb3VudCArPSBsb29rdXAucmVhZG9ubHlJbmRleGVzLmxlbmd0aCArIGxvb2t1cC53cml0YWJsZUluZGV4ZXMubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gY291bnQ7XG4gIH1cbiAgZ2V0QWNjb3VudEtleXMoYXJncykge1xuICAgIGxldCBhY2NvdW50S2V5c0Zyb21Mb29rdXBzO1xuICAgIGlmIChhcmdzICYmICdhY2NvdW50S2V5c0Zyb21Mb29rdXBzJyBpbiBhcmdzICYmIGFyZ3MuYWNjb3VudEtleXNGcm9tTG9va3Vwcykge1xuICAgICAgaWYgKHRoaXMubnVtQWNjb3VudEtleXNGcm9tTG9va3VwcyAhPSBhcmdzLmFjY291bnRLZXlzRnJvbUxvb2t1cHMud3JpdGFibGUubGVuZ3RoICsgYXJncy5hY2NvdW50S2V5c0Zyb21Mb29rdXBzLnJlYWRvbmx5Lmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBnZXQgYWNjb3VudCBrZXlzIGJlY2F1c2Ugb2YgYSBtaXNtYXRjaCBpbiB0aGUgbnVtYmVyIG9mIGFjY291bnQga2V5cyBmcm9tIGxvb2t1cHMnKTtcbiAgICAgIH1cbiAgICAgIGFjY291bnRLZXlzRnJvbUxvb2t1cHMgPSBhcmdzLmFjY291bnRLZXlzRnJvbUxvb2t1cHM7XG4gICAgfSBlbHNlIGlmIChhcmdzICYmICdhZGRyZXNzTG9va3VwVGFibGVBY2NvdW50cycgaW4gYXJncyAmJiBhcmdzLmFkZHJlc3NMb29rdXBUYWJsZUFjY291bnRzKSB7XG4gICAgICBhY2NvdW50S2V5c0Zyb21Mb29rdXBzID0gdGhpcy5yZXNvbHZlQWRkcmVzc1RhYmxlTG9va3VwcyhhcmdzLmFkZHJlc3NMb29rdXBUYWJsZUFjY291bnRzKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuYWRkcmVzc1RhYmxlTG9va3Vwcy5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBnZXQgYWNjb3VudCBrZXlzIGJlY2F1c2UgYWRkcmVzcyB0YWJsZSBsb29rdXBzIHdlcmUgbm90IHJlc29sdmVkJyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTWVzc2FnZUFjY291bnRLZXlzKHRoaXMuc3RhdGljQWNjb3VudEtleXMsIGFjY291bnRLZXlzRnJvbUxvb2t1cHMpO1xuICB9XG4gIGlzQWNjb3VudFNpZ25lcihpbmRleCkge1xuICAgIHJldHVybiBpbmRleCA8IHRoaXMuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcztcbiAgfVxuICBpc0FjY291bnRXcml0YWJsZShpbmRleCkge1xuICAgIGNvbnN0IG51bVNpZ25lZEFjY291bnRzID0gdGhpcy5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzO1xuICAgIGNvbnN0IG51bVN0YXRpY0FjY291bnRLZXlzID0gdGhpcy5zdGF0aWNBY2NvdW50S2V5cy5sZW5ndGg7XG4gICAgaWYgKGluZGV4ID49IG51bVN0YXRpY0FjY291bnRLZXlzKSB7XG4gICAgICBjb25zdCBsb29rdXBBY2NvdW50S2V5c0luZGV4ID0gaW5kZXggLSBudW1TdGF0aWNBY2NvdW50S2V5cztcbiAgICAgIGNvbnN0IG51bVdyaXRhYmxlTG9va3VwQWNjb3VudEtleXMgPSB0aGlzLmFkZHJlc3NUYWJsZUxvb2t1cHMucmVkdWNlKChjb3VudCwgbG9va3VwKSA9PiBjb3VudCArIGxvb2t1cC53cml0YWJsZUluZGV4ZXMubGVuZ3RoLCAwKTtcbiAgICAgIHJldHVybiBsb29rdXBBY2NvdW50S2V5c0luZGV4IDwgbnVtV3JpdGFibGVMb29rdXBBY2NvdW50S2V5cztcbiAgICB9IGVsc2UgaWYgKGluZGV4ID49IHRoaXMuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcykge1xuICAgICAgY29uc3QgdW5zaWduZWRBY2NvdW50SW5kZXggPSBpbmRleCAtIG51bVNpZ25lZEFjY291bnRzO1xuICAgICAgY29uc3QgbnVtVW5zaWduZWRBY2NvdW50cyA9IG51bVN0YXRpY0FjY291bnRLZXlzIC0gbnVtU2lnbmVkQWNjb3VudHM7XG4gICAgICBjb25zdCBudW1Xcml0YWJsZVVuc2lnbmVkQWNjb3VudHMgPSBudW1VbnNpZ25lZEFjY291bnRzIC0gdGhpcy5oZWFkZXIubnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzO1xuICAgICAgcmV0dXJuIHVuc2lnbmVkQWNjb3VudEluZGV4IDwgbnVtV3JpdGFibGVVbnNpZ25lZEFjY291bnRzO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBudW1Xcml0YWJsZVNpZ25lZEFjY291bnRzID0gbnVtU2lnbmVkQWNjb3VudHMgLSB0aGlzLmhlYWRlci5udW1SZWFkb25seVNpZ25lZEFjY291bnRzO1xuICAgICAgcmV0dXJuIGluZGV4IDwgbnVtV3JpdGFibGVTaWduZWRBY2NvdW50cztcbiAgICB9XG4gIH1cbiAgcmVzb2x2ZUFkZHJlc3NUYWJsZUxvb2t1cHMoYWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudHMpIHtcbiAgICBjb25zdCBhY2NvdW50S2V5c0Zyb21Mb29rdXBzID0ge1xuICAgICAgd3JpdGFibGU6IFtdLFxuICAgICAgcmVhZG9ubHk6IFtdXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IHRhYmxlTG9va3VwIG9mIHRoaXMuYWRkcmVzc1RhYmxlTG9va3Vwcykge1xuICAgICAgY29uc3QgdGFibGVBY2NvdW50ID0gYWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudHMuZmluZChhY2NvdW50ID0+IGFjY291bnQua2V5LmVxdWFscyh0YWJsZUxvb2t1cC5hY2NvdW50S2V5KSk7XG4gICAgICBpZiAoIXRhYmxlQWNjb3VudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmaW5kIGFkZHJlc3MgbG9va3VwIHRhYmxlIGFjY291bnQgZm9yIHRhYmxlIGtleSAke3RhYmxlTG9va3VwLmFjY291bnRLZXkudG9CYXNlNTgoKX1gKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgaW5kZXggb2YgdGFibGVMb29rdXAud3JpdGFibGVJbmRleGVzKSB7XG4gICAgICAgIGlmIChpbmRleCA8IHRhYmxlQWNjb3VudC5zdGF0ZS5hZGRyZXNzZXMubGVuZ3RoKSB7XG4gICAgICAgICAgYWNjb3VudEtleXNGcm9tTG9va3Vwcy53cml0YWJsZS5wdXNoKHRhYmxlQWNjb3VudC5zdGF0ZS5hZGRyZXNzZXNbaW5kZXhdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmaW5kIGFkZHJlc3MgZm9yIGluZGV4ICR7aW5kZXh9IGluIGFkZHJlc3MgbG9va3VwIHRhYmxlICR7dGFibGVMb29rdXAuYWNjb3VudEtleS50b0Jhc2U1OCgpfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGluZGV4IG9mIHRhYmxlTG9va3VwLnJlYWRvbmx5SW5kZXhlcykge1xuICAgICAgICBpZiAoaW5kZXggPCB0YWJsZUFjY291bnQuc3RhdGUuYWRkcmVzc2VzLmxlbmd0aCkge1xuICAgICAgICAgIGFjY291bnRLZXlzRnJvbUxvb2t1cHMucmVhZG9ubHkucHVzaCh0YWJsZUFjY291bnQuc3RhdGUuYWRkcmVzc2VzW2luZGV4XSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmluZCBhZGRyZXNzIGZvciBpbmRleCAke2luZGV4fSBpbiBhZGRyZXNzIGxvb2t1cCB0YWJsZSAke3RhYmxlTG9va3VwLmFjY291bnRLZXkudG9CYXNlNTgoKX1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYWNjb3VudEtleXNGcm9tTG9va3VwcztcbiAgfVxuICBzdGF0aWMgY29tcGlsZShhcmdzKSB7XG4gICAgY29uc3QgY29tcGlsZWRLZXlzID0gQ29tcGlsZWRLZXlzLmNvbXBpbGUoYXJncy5pbnN0cnVjdGlvbnMsIGFyZ3MucGF5ZXJLZXkpO1xuICAgIGNvbnN0IGFkZHJlc3NUYWJsZUxvb2t1cHMgPSBuZXcgQXJyYXkoKTtcbiAgICBjb25zdCBhY2NvdW50S2V5c0Zyb21Mb29rdXBzID0ge1xuICAgICAgd3JpdGFibGU6IG5ldyBBcnJheSgpLFxuICAgICAgcmVhZG9ubHk6IG5ldyBBcnJheSgpXG4gICAgfTtcbiAgICBjb25zdCBsb29rdXBUYWJsZUFjY291bnRzID0gYXJncy5hZGRyZXNzTG9va3VwVGFibGVBY2NvdW50cyB8fCBbXTtcbiAgICBmb3IgKGNvbnN0IGxvb2t1cFRhYmxlIG9mIGxvb2t1cFRhYmxlQWNjb3VudHMpIHtcbiAgICAgIGNvbnN0IGV4dHJhY3RSZXN1bHQgPSBjb21waWxlZEtleXMuZXh0cmFjdFRhYmxlTG9va3VwKGxvb2t1cFRhYmxlKTtcbiAgICAgIGlmIChleHRyYWN0UmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgW2FkZHJlc3NUYWJsZUxvb2t1cCwge1xuICAgICAgICAgIHdyaXRhYmxlLFxuICAgICAgICAgIHJlYWRvbmx5XG4gICAgICAgIH1dID0gZXh0cmFjdFJlc3VsdDtcbiAgICAgICAgYWRkcmVzc1RhYmxlTG9va3Vwcy5wdXNoKGFkZHJlc3NUYWJsZUxvb2t1cCk7XG4gICAgICAgIGFjY291bnRLZXlzRnJvbUxvb2t1cHMud3JpdGFibGUucHVzaCguLi53cml0YWJsZSk7XG4gICAgICAgIGFjY291bnRLZXlzRnJvbUxvb2t1cHMucmVhZG9ubHkucHVzaCguLi5yZWFkb25seSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IFtoZWFkZXIsIHN0YXRpY0FjY291bnRLZXlzXSA9IGNvbXBpbGVkS2V5cy5nZXRNZXNzYWdlQ29tcG9uZW50cygpO1xuICAgIGNvbnN0IGFjY291bnRLZXlzID0gbmV3IE1lc3NhZ2VBY2NvdW50S2V5cyhzdGF0aWNBY2NvdW50S2V5cywgYWNjb3VudEtleXNGcm9tTG9va3Vwcyk7XG4gICAgY29uc3QgY29tcGlsZWRJbnN0cnVjdGlvbnMgPSBhY2NvdW50S2V5cy5jb21waWxlSW5zdHJ1Y3Rpb25zKGFyZ3MuaW5zdHJ1Y3Rpb25zKTtcbiAgICByZXR1cm4gbmV3IE1lc3NhZ2VWMCh7XG4gICAgICBoZWFkZXIsXG4gICAgICBzdGF0aWNBY2NvdW50S2V5cyxcbiAgICAgIHJlY2VudEJsb2NraGFzaDogYXJncy5yZWNlbnRCbG9ja2hhc2gsXG4gICAgICBjb21waWxlZEluc3RydWN0aW9ucyxcbiAgICAgIGFkZHJlc3NUYWJsZUxvb2t1cHNcbiAgICB9KTtcbiAgfVxuICBzZXJpYWxpemUoKSB7XG4gICAgY29uc3QgZW5jb2RlZFN0YXRpY0FjY291bnRLZXlzTGVuZ3RoID0gQXJyYXkoKTtcbiAgICBlbmNvZGVMZW5ndGgoZW5jb2RlZFN0YXRpY0FjY291bnRLZXlzTGVuZ3RoLCB0aGlzLnN0YXRpY0FjY291bnRLZXlzLmxlbmd0aCk7XG4gICAgY29uc3Qgc2VyaWFsaXplZEluc3RydWN0aW9ucyA9IHRoaXMuc2VyaWFsaXplSW5zdHJ1Y3Rpb25zKCk7XG4gICAgY29uc3QgZW5jb2RlZEluc3RydWN0aW9uc0xlbmd0aCA9IEFycmF5KCk7XG4gICAgZW5jb2RlTGVuZ3RoKGVuY29kZWRJbnN0cnVjdGlvbnNMZW5ndGgsIHRoaXMuY29tcGlsZWRJbnN0cnVjdGlvbnMubGVuZ3RoKTtcbiAgICBjb25zdCBzZXJpYWxpemVkQWRkcmVzc1RhYmxlTG9va3VwcyA9IHRoaXMuc2VyaWFsaXplQWRkcmVzc1RhYmxlTG9va3VwcygpO1xuICAgIGNvbnN0IGVuY29kZWRBZGRyZXNzVGFibGVMb29rdXBzTGVuZ3RoID0gQXJyYXkoKTtcbiAgICBlbmNvZGVMZW5ndGgoZW5jb2RlZEFkZHJlc3NUYWJsZUxvb2t1cHNMZW5ndGgsIHRoaXMuYWRkcmVzc1RhYmxlTG9va3Vwcy5sZW5ndGgpO1xuICAgIGNvbnN0IG1lc3NhZ2VMYXlvdXQgPSBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTgoJ3ByZWZpeCcpLCBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTgoJ251bVJlcXVpcmVkU2lnbmF0dXJlcycpLCBCdWZmZXJMYXlvdXQudTgoJ251bVJlYWRvbmx5U2lnbmVkQWNjb3VudHMnKSwgQnVmZmVyTGF5b3V0LnU4KCdudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHMnKV0sICdoZWFkZXInKSwgQnVmZmVyTGF5b3V0LmJsb2IoZW5jb2RlZFN0YXRpY0FjY291bnRLZXlzTGVuZ3RoLmxlbmd0aCwgJ3N0YXRpY0FjY291bnRLZXlzTGVuZ3RoJyksIEJ1ZmZlckxheW91dC5zZXEocHVibGljS2V5KCksIHRoaXMuc3RhdGljQWNjb3VudEtleXMubGVuZ3RoLCAnc3RhdGljQWNjb3VudEtleXMnKSwgcHVibGljS2V5KCdyZWNlbnRCbG9ja2hhc2gnKSwgQnVmZmVyTGF5b3V0LmJsb2IoZW5jb2RlZEluc3RydWN0aW9uc0xlbmd0aC5sZW5ndGgsICdpbnN0cnVjdGlvbnNMZW5ndGgnKSwgQnVmZmVyTGF5b3V0LmJsb2Ioc2VyaWFsaXplZEluc3RydWN0aW9ucy5sZW5ndGgsICdzZXJpYWxpemVkSW5zdHJ1Y3Rpb25zJyksIEJ1ZmZlckxheW91dC5ibG9iKGVuY29kZWRBZGRyZXNzVGFibGVMb29rdXBzTGVuZ3RoLmxlbmd0aCwgJ2FkZHJlc3NUYWJsZUxvb2t1cHNMZW5ndGgnKSwgQnVmZmVyTGF5b3V0LmJsb2Ioc2VyaWFsaXplZEFkZHJlc3NUYWJsZUxvb2t1cHMubGVuZ3RoLCAnc2VyaWFsaXplZEFkZHJlc3NUYWJsZUxvb2t1cHMnKV0pO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRNZXNzYWdlID0gbmV3IFVpbnQ4QXJyYXkoUEFDS0VUX0RBVEFfU0laRSk7XG4gICAgY29uc3QgTUVTU0FHRV9WRVJTSU9OXzBfUFJFRklYID0gMSA8PCA3O1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRNZXNzYWdlTGVuZ3RoID0gbWVzc2FnZUxheW91dC5lbmNvZGUoe1xuICAgICAgcHJlZml4OiBNRVNTQUdFX1ZFUlNJT05fMF9QUkVGSVgsXG4gICAgICBoZWFkZXI6IHRoaXMuaGVhZGVyLFxuICAgICAgc3RhdGljQWNjb3VudEtleXNMZW5ndGg6IG5ldyBVaW50OEFycmF5KGVuY29kZWRTdGF0aWNBY2NvdW50S2V5c0xlbmd0aCksXG4gICAgICBzdGF0aWNBY2NvdW50S2V5czogdGhpcy5zdGF0aWNBY2NvdW50S2V5cy5tYXAoa2V5ID0+IGtleS50b0J5dGVzKCkpLFxuICAgICAgcmVjZW50QmxvY2toYXNoOiBiczU4LmRlY29kZSh0aGlzLnJlY2VudEJsb2NraGFzaCksXG4gICAgICBpbnN0cnVjdGlvbnNMZW5ndGg6IG5ldyBVaW50OEFycmF5KGVuY29kZWRJbnN0cnVjdGlvbnNMZW5ndGgpLFxuICAgICAgc2VyaWFsaXplZEluc3RydWN0aW9ucyxcbiAgICAgIGFkZHJlc3NUYWJsZUxvb2t1cHNMZW5ndGg6IG5ldyBVaW50OEFycmF5KGVuY29kZWRBZGRyZXNzVGFibGVMb29rdXBzTGVuZ3RoKSxcbiAgICAgIHNlcmlhbGl6ZWRBZGRyZXNzVGFibGVMb29rdXBzXG4gICAgfSwgc2VyaWFsaXplZE1lc3NhZ2UpO1xuICAgIHJldHVybiBzZXJpYWxpemVkTWVzc2FnZS5zbGljZSgwLCBzZXJpYWxpemVkTWVzc2FnZUxlbmd0aCk7XG4gIH1cbiAgc2VyaWFsaXplSW5zdHJ1Y3Rpb25zKCkge1xuICAgIGxldCBzZXJpYWxpemVkTGVuZ3RoID0gMDtcbiAgICBjb25zdCBzZXJpYWxpemVkSW5zdHJ1Y3Rpb25zID0gbmV3IFVpbnQ4QXJyYXkoUEFDS0VUX0RBVEFfU0laRSk7XG4gICAgZm9yIChjb25zdCBpbnN0cnVjdGlvbiBvZiB0aGlzLmNvbXBpbGVkSW5zdHJ1Y3Rpb25zKSB7XG4gICAgICBjb25zdCBlbmNvZGVkQWNjb3VudEtleUluZGV4ZXNMZW5ndGggPSBBcnJheSgpO1xuICAgICAgZW5jb2RlTGVuZ3RoKGVuY29kZWRBY2NvdW50S2V5SW5kZXhlc0xlbmd0aCwgaW5zdHJ1Y3Rpb24uYWNjb3VudEtleUluZGV4ZXMubGVuZ3RoKTtcbiAgICAgIGNvbnN0IGVuY29kZWREYXRhTGVuZ3RoID0gQXJyYXkoKTtcbiAgICAgIGVuY29kZUxlbmd0aChlbmNvZGVkRGF0YUxlbmd0aCwgaW5zdHJ1Y3Rpb24uZGF0YS5sZW5ndGgpO1xuICAgICAgY29uc3QgaW5zdHJ1Y3Rpb25MYXlvdXQgPSBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTgoJ3Byb2dyYW1JZEluZGV4JyksIEJ1ZmZlckxheW91dC5ibG9iKGVuY29kZWRBY2NvdW50S2V5SW5kZXhlc0xlbmd0aC5sZW5ndGgsICdlbmNvZGVkQWNjb3VudEtleUluZGV4ZXNMZW5ndGgnKSwgQnVmZmVyTGF5b3V0LnNlcShCdWZmZXJMYXlvdXQudTgoKSwgaW5zdHJ1Y3Rpb24uYWNjb3VudEtleUluZGV4ZXMubGVuZ3RoLCAnYWNjb3VudEtleUluZGV4ZXMnKSwgQnVmZmVyTGF5b3V0LmJsb2IoZW5jb2RlZERhdGFMZW5ndGgubGVuZ3RoLCAnZW5jb2RlZERhdGFMZW5ndGgnKSwgQnVmZmVyTGF5b3V0LmJsb2IoaW5zdHJ1Y3Rpb24uZGF0YS5sZW5ndGgsICdkYXRhJyldKTtcbiAgICAgIHNlcmlhbGl6ZWRMZW5ndGggKz0gaW5zdHJ1Y3Rpb25MYXlvdXQuZW5jb2RlKHtcbiAgICAgICAgcHJvZ3JhbUlkSW5kZXg6IGluc3RydWN0aW9uLnByb2dyYW1JZEluZGV4LFxuICAgICAgICBlbmNvZGVkQWNjb3VudEtleUluZGV4ZXNMZW5ndGg6IG5ldyBVaW50OEFycmF5KGVuY29kZWRBY2NvdW50S2V5SW5kZXhlc0xlbmd0aCksXG4gICAgICAgIGFjY291bnRLZXlJbmRleGVzOiBpbnN0cnVjdGlvbi5hY2NvdW50S2V5SW5kZXhlcyxcbiAgICAgICAgZW5jb2RlZERhdGFMZW5ndGg6IG5ldyBVaW50OEFycmF5KGVuY29kZWREYXRhTGVuZ3RoKSxcbiAgICAgICAgZGF0YTogaW5zdHJ1Y3Rpb24uZGF0YVxuICAgICAgfSwgc2VyaWFsaXplZEluc3RydWN0aW9ucywgc2VyaWFsaXplZExlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiBzZXJpYWxpemVkSW5zdHJ1Y3Rpb25zLnNsaWNlKDAsIHNlcmlhbGl6ZWRMZW5ndGgpO1xuICB9XG4gIHNlcmlhbGl6ZUFkZHJlc3NUYWJsZUxvb2t1cHMoKSB7XG4gICAgbGV0IHNlcmlhbGl6ZWRMZW5ndGggPSAwO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRBZGRyZXNzVGFibGVMb29rdXBzID0gbmV3IFVpbnQ4QXJyYXkoUEFDS0VUX0RBVEFfU0laRSk7XG4gICAgZm9yIChjb25zdCBsb29rdXAgb2YgdGhpcy5hZGRyZXNzVGFibGVMb29rdXBzKSB7XG4gICAgICBjb25zdCBlbmNvZGVkV3JpdGFibGVJbmRleGVzTGVuZ3RoID0gQXJyYXkoKTtcbiAgICAgIGVuY29kZUxlbmd0aChlbmNvZGVkV3JpdGFibGVJbmRleGVzTGVuZ3RoLCBsb29rdXAud3JpdGFibGVJbmRleGVzLmxlbmd0aCk7XG4gICAgICBjb25zdCBlbmNvZGVkUmVhZG9ubHlJbmRleGVzTGVuZ3RoID0gQXJyYXkoKTtcbiAgICAgIGVuY29kZUxlbmd0aChlbmNvZGVkUmVhZG9ubHlJbmRleGVzTGVuZ3RoLCBsb29rdXAucmVhZG9ubHlJbmRleGVzLmxlbmd0aCk7XG4gICAgICBjb25zdCBhZGRyZXNzVGFibGVMb29rdXBMYXlvdXQgPSBCdWZmZXJMYXlvdXQuc3RydWN0KFtwdWJsaWNLZXkoJ2FjY291bnRLZXknKSwgQnVmZmVyTGF5b3V0LmJsb2IoZW5jb2RlZFdyaXRhYmxlSW5kZXhlc0xlbmd0aC5sZW5ndGgsICdlbmNvZGVkV3JpdGFibGVJbmRleGVzTGVuZ3RoJyksIEJ1ZmZlckxheW91dC5zZXEoQnVmZmVyTGF5b3V0LnU4KCksIGxvb2t1cC53cml0YWJsZUluZGV4ZXMubGVuZ3RoLCAnd3JpdGFibGVJbmRleGVzJyksIEJ1ZmZlckxheW91dC5ibG9iKGVuY29kZWRSZWFkb25seUluZGV4ZXNMZW5ndGgubGVuZ3RoLCAnZW5jb2RlZFJlYWRvbmx5SW5kZXhlc0xlbmd0aCcpLCBCdWZmZXJMYXlvdXQuc2VxKEJ1ZmZlckxheW91dC51OCgpLCBsb29rdXAucmVhZG9ubHlJbmRleGVzLmxlbmd0aCwgJ3JlYWRvbmx5SW5kZXhlcycpXSk7XG4gICAgICBzZXJpYWxpemVkTGVuZ3RoICs9IGFkZHJlc3NUYWJsZUxvb2t1cExheW91dC5lbmNvZGUoe1xuICAgICAgICBhY2NvdW50S2V5OiBsb29rdXAuYWNjb3VudEtleS50b0J5dGVzKCksXG4gICAgICAgIGVuY29kZWRXcml0YWJsZUluZGV4ZXNMZW5ndGg6IG5ldyBVaW50OEFycmF5KGVuY29kZWRXcml0YWJsZUluZGV4ZXNMZW5ndGgpLFxuICAgICAgICB3cml0YWJsZUluZGV4ZXM6IGxvb2t1cC53cml0YWJsZUluZGV4ZXMsXG4gICAgICAgIGVuY29kZWRSZWFkb25seUluZGV4ZXNMZW5ndGg6IG5ldyBVaW50OEFycmF5KGVuY29kZWRSZWFkb25seUluZGV4ZXNMZW5ndGgpLFxuICAgICAgICByZWFkb25seUluZGV4ZXM6IGxvb2t1cC5yZWFkb25seUluZGV4ZXNcbiAgICAgIH0sIHNlcmlhbGl6ZWRBZGRyZXNzVGFibGVMb29rdXBzLCBzZXJpYWxpemVkTGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWRBZGRyZXNzVGFibGVMb29rdXBzLnNsaWNlKDAsIHNlcmlhbGl6ZWRMZW5ndGgpO1xuICB9XG4gIHN0YXRpYyBkZXNlcmlhbGl6ZShzZXJpYWxpemVkTWVzc2FnZSkge1xuICAgIGxldCBieXRlQXJyYXkgPSBbLi4uc2VyaWFsaXplZE1lc3NhZ2VdO1xuICAgIGNvbnN0IHByZWZpeCA9IGd1YXJkZWRTaGlmdChieXRlQXJyYXkpO1xuICAgIGNvbnN0IG1hc2tlZFByZWZpeCA9IHByZWZpeCAmIFZFUlNJT05fUFJFRklYX01BU0s7XG4gICAgYXNzZXJ0KHByZWZpeCAhPT0gbWFza2VkUHJlZml4LCBgRXhwZWN0ZWQgdmVyc2lvbmVkIG1lc3NhZ2UgYnV0IHJlY2VpdmVkIGxlZ2FjeSBtZXNzYWdlYCk7XG4gICAgY29uc3QgdmVyc2lvbiA9IG1hc2tlZFByZWZpeDtcbiAgICBhc3NlcnQodmVyc2lvbiA9PT0gMCwgYEV4cGVjdGVkIHZlcnNpb25lZCBtZXNzYWdlIHdpdGggdmVyc2lvbiAwIGJ1dCBmb3VuZCB2ZXJzaW9uICR7dmVyc2lvbn1gKTtcbiAgICBjb25zdCBoZWFkZXIgPSB7XG4gICAgICBudW1SZXF1aXJlZFNpZ25hdHVyZXM6IGd1YXJkZWRTaGlmdChieXRlQXJyYXkpLFxuICAgICAgbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50czogZ3VhcmRlZFNoaWZ0KGJ5dGVBcnJheSksXG4gICAgICBudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHM6IGd1YXJkZWRTaGlmdChieXRlQXJyYXkpXG4gICAgfTtcbiAgICBjb25zdCBzdGF0aWNBY2NvdW50S2V5cyA9IFtdO1xuICAgIGNvbnN0IHN0YXRpY0FjY291bnRLZXlzTGVuZ3RoID0gZGVjb2RlTGVuZ3RoKGJ5dGVBcnJheSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0aWNBY2NvdW50S2V5c0xlbmd0aDsgaSsrKSB7XG4gICAgICBzdGF0aWNBY2NvdW50S2V5cy5wdXNoKG5ldyBQdWJsaWNLZXkoZ3VhcmRlZFNwbGljZShieXRlQXJyYXksIDAsIFBVQkxJQ19LRVlfTEVOR1RIKSkpO1xuICAgIH1cbiAgICBjb25zdCByZWNlbnRCbG9ja2hhc2ggPSBiczU4LmVuY29kZShndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgUFVCTElDX0tFWV9MRU5HVEgpKTtcbiAgICBjb25zdCBpbnN0cnVjdGlvbkNvdW50ID0gZGVjb2RlTGVuZ3RoKGJ5dGVBcnJheSk7XG4gICAgY29uc3QgY29tcGlsZWRJbnN0cnVjdGlvbnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluc3RydWN0aW9uQ291bnQ7IGkrKykge1xuICAgICAgY29uc3QgcHJvZ3JhbUlkSW5kZXggPSBndWFyZGVkU2hpZnQoYnl0ZUFycmF5KTtcbiAgICAgIGNvbnN0IGFjY291bnRLZXlJbmRleGVzTGVuZ3RoID0gZGVjb2RlTGVuZ3RoKGJ5dGVBcnJheSk7XG4gICAgICBjb25zdCBhY2NvdW50S2V5SW5kZXhlcyA9IGd1YXJkZWRTcGxpY2UoYnl0ZUFycmF5LCAwLCBhY2NvdW50S2V5SW5kZXhlc0xlbmd0aCk7XG4gICAgICBjb25zdCBkYXRhTGVuZ3RoID0gZGVjb2RlTGVuZ3RoKGJ5dGVBcnJheSk7XG4gICAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoZ3VhcmRlZFNwbGljZShieXRlQXJyYXksIDAsIGRhdGFMZW5ndGgpKTtcbiAgICAgIGNvbXBpbGVkSW5zdHJ1Y3Rpb25zLnB1c2goe1xuICAgICAgICBwcm9ncmFtSWRJbmRleCxcbiAgICAgICAgYWNjb3VudEtleUluZGV4ZXMsXG4gICAgICAgIGRhdGFcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBhZGRyZXNzVGFibGVMb29rdXBzQ291bnQgPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICBjb25zdCBhZGRyZXNzVGFibGVMb29rdXBzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhZGRyZXNzVGFibGVMb29rdXBzQ291bnQ7IGkrKykge1xuICAgICAgY29uc3QgYWNjb3VudEtleSA9IG5ldyBQdWJsaWNLZXkoZ3VhcmRlZFNwbGljZShieXRlQXJyYXksIDAsIFBVQkxJQ19LRVlfTEVOR1RIKSk7XG4gICAgICBjb25zdCB3cml0YWJsZUluZGV4ZXNMZW5ndGggPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICAgIGNvbnN0IHdyaXRhYmxlSW5kZXhlcyA9IGd1YXJkZWRTcGxpY2UoYnl0ZUFycmF5LCAwLCB3cml0YWJsZUluZGV4ZXNMZW5ndGgpO1xuICAgICAgY29uc3QgcmVhZG9ubHlJbmRleGVzTGVuZ3RoID0gZGVjb2RlTGVuZ3RoKGJ5dGVBcnJheSk7XG4gICAgICBjb25zdCByZWFkb25seUluZGV4ZXMgPSBndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgcmVhZG9ubHlJbmRleGVzTGVuZ3RoKTtcbiAgICAgIGFkZHJlc3NUYWJsZUxvb2t1cHMucHVzaCh7XG4gICAgICAgIGFjY291bnRLZXksXG4gICAgICAgIHdyaXRhYmxlSW5kZXhlcyxcbiAgICAgICAgcmVhZG9ubHlJbmRleGVzXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBNZXNzYWdlVjAoe1xuICAgICAgaGVhZGVyLFxuICAgICAgc3RhdGljQWNjb3VudEtleXMsXG4gICAgICByZWNlbnRCbG9ja2hhc2gsXG4gICAgICBjb21waWxlZEluc3RydWN0aW9ucyxcbiAgICAgIGFkZHJlc3NUYWJsZUxvb2t1cHNcbiAgICB9KTtcbiAgfVxufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5jb25zdCBWZXJzaW9uZWRNZXNzYWdlID0ge1xuICBkZXNlcmlhbGl6ZU1lc3NhZ2VWZXJzaW9uKHNlcmlhbGl6ZWRNZXNzYWdlKSB7XG4gICAgY29uc3QgcHJlZml4ID0gc2VyaWFsaXplZE1lc3NhZ2VbMF07XG4gICAgY29uc3QgbWFza2VkUHJlZml4ID0gcHJlZml4ICYgVkVSU0lPTl9QUkVGSVhfTUFTSztcblxuICAgIC8vIGlmIHRoZSBoaWdoZXN0IGJpdCBvZiB0aGUgcHJlZml4IGlzIG5vdCBzZXQsIHRoZSBtZXNzYWdlIGlzIG5vdCB2ZXJzaW9uZWRcbiAgICBpZiAobWFza2VkUHJlZml4ID09PSBwcmVmaXgpIHtcbiAgICAgIHJldHVybiAnbGVnYWN5JztcbiAgICB9XG5cbiAgICAvLyB0aGUgbG93ZXIgNyBiaXRzIG9mIHRoZSBwcmVmaXggaW5kaWNhdGUgdGhlIG1lc3NhZ2UgdmVyc2lvblxuICAgIHJldHVybiBtYXNrZWRQcmVmaXg7XG4gIH0sXG4gIGRlc2VyaWFsaXplOiBzZXJpYWxpemVkTWVzc2FnZSA9PiB7XG4gICAgY29uc3QgdmVyc2lvbiA9IFZlcnNpb25lZE1lc3NhZ2UuZGVzZXJpYWxpemVNZXNzYWdlVmVyc2lvbihzZXJpYWxpemVkTWVzc2FnZSk7XG4gICAgaWYgKHZlcnNpb24gPT09ICdsZWdhY3knKSB7XG4gICAgICByZXR1cm4gTWVzc2FnZS5mcm9tKHNlcmlhbGl6ZWRNZXNzYWdlKTtcbiAgICB9XG4gICAgaWYgKHZlcnNpb24gPT09IDApIHtcbiAgICAgIHJldHVybiBNZXNzYWdlVjAuZGVzZXJpYWxpemUoc2VyaWFsaXplZE1lc3NhZ2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRyYW5zYWN0aW9uIG1lc3NhZ2UgdmVyc2lvbiAke3ZlcnNpb259IGRlc2VyaWFsaXphdGlvbiBpcyBub3Qgc3VwcG9ydGVkYCk7XG4gICAgfVxuICB9XG59O1xuXG4vKiogQGludGVybmFsICovXG5cbi8qKlxuICogVHJhbnNhY3Rpb24gc2lnbmF0dXJlIGFzIGJhc2UtNTggZW5jb2RlZCBzdHJpbmdcbiAqL1xuXG5sZXQgVHJhbnNhY3Rpb25TdGF0dXMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKFRyYW5zYWN0aW9uU3RhdHVzKSB7XG4gIFRyYW5zYWN0aW9uU3RhdHVzW1RyYW5zYWN0aW9uU3RhdHVzW1wiQkxPQ0tIRUlHSFRfRVhDRUVERURcIl0gPSAwXSA9IFwiQkxPQ0tIRUlHSFRfRVhDRUVERURcIjtcbiAgVHJhbnNhY3Rpb25TdGF0dXNbVHJhbnNhY3Rpb25TdGF0dXNbXCJQUk9DRVNTRURcIl0gPSAxXSA9IFwiUFJPQ0VTU0VEXCI7XG4gIFRyYW5zYWN0aW9uU3RhdHVzW1RyYW5zYWN0aW9uU3RhdHVzW1wiVElNRURfT1VUXCJdID0gMl0gPSBcIlRJTUVEX09VVFwiO1xuICBUcmFuc2FjdGlvblN0YXR1c1tUcmFuc2FjdGlvblN0YXR1c1tcIk5PTkNFX0lOVkFMSURcIl0gPSAzXSA9IFwiTk9OQ0VfSU5WQUxJRFwiO1xuICByZXR1cm4gVHJhbnNhY3Rpb25TdGF0dXM7XG59KHt9KTtcblxuLyoqXG4gKiBEZWZhdWx0IChlbXB0eSkgc2lnbmF0dXJlXG4gKi9cbmNvbnN0IERFRkFVTFRfU0lHTkFUVVJFID0gQnVmZmVyLmFsbG9jKFNJR05BVFVSRV9MRU5HVEhfSU5fQllURVMpLmZpbGwoMCk7XG5cbi8qKlxuICogQWNjb3VudCBtZXRhZGF0YSB1c2VkIHRvIGRlZmluZSBpbnN0cnVjdGlvbnNcbiAqL1xuXG4vKipcbiAqIExpc3Qgb2YgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbiBvYmplY3QgZmllbGRzIHRoYXQgbWF5IGJlIGluaXRpYWxpemVkIGF0IGNvbnN0cnVjdGlvblxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIFRyYW5zYWN0aW9uLnNlcmlhbGl6ZSgpXG4gKi9cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG4vKipcbiAqIFRyYW5zYWN0aW9uIEluc3RydWN0aW9uIGNsYXNzXG4gKi9cbmNsYXNzIFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24ge1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgLyoqXG4gICAgICogUHVibGljIGtleXMgdG8gaW5jbHVkZSBpbiB0aGlzIHRyYW5zYWN0aW9uXG4gICAgICogQm9vbGVhbiByZXByZXNlbnRzIHdoZXRoZXIgdGhpcyBwdWJrZXkgbmVlZHMgdG8gc2lnbiB0aGUgdHJhbnNhY3Rpb25cbiAgICAgKi9cbiAgICB0aGlzLmtleXMgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogUHJvZ3JhbSBJZCB0byBleGVjdXRlXG4gICAgICovXG4gICAgdGhpcy5wcm9ncmFtSWQgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogUHJvZ3JhbSBpbnB1dFxuICAgICAqL1xuICAgIHRoaXMuZGF0YSA9IEJ1ZmZlci5hbGxvYygwKTtcbiAgICB0aGlzLnByb2dyYW1JZCA9IG9wdHMucHJvZ3JhbUlkO1xuICAgIHRoaXMua2V5cyA9IG9wdHMua2V5cztcbiAgICBpZiAob3B0cy5kYXRhKSB7XG4gICAgICB0aGlzLmRhdGEgPSBvcHRzLmRhdGE7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBrZXlzOiB0aGlzLmtleXMubWFwKCh7XG4gICAgICAgIHB1YmtleSxcbiAgICAgICAgaXNTaWduZXIsXG4gICAgICAgIGlzV3JpdGFibGVcbiAgICAgIH0pID0+ICh7XG4gICAgICAgIHB1YmtleTogcHVia2V5LnRvSlNPTigpLFxuICAgICAgICBpc1NpZ25lcixcbiAgICAgICAgaXNXcml0YWJsZVxuICAgICAgfSkpLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZC50b0pTT04oKSxcbiAgICAgIGRhdGE6IFsuLi50aGlzLmRhdGFdXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFBhaXIgb2Ygc2lnbmF0dXJlIGFuZCBjb3JyZXNwb25kaW5nIHB1YmxpYyBrZXlcbiAqL1xuXG4vKipcbiAqIExpc3Qgb2YgVHJhbnNhY3Rpb24gb2JqZWN0IGZpZWxkcyB0aGF0IG1heSBiZSBpbml0aWFsaXplZCBhdCBjb25zdHJ1Y3Rpb25cbiAqL1xuXG4vLyBGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eTsgYW4gdW5mb3J0dW5hdGUgY29uc2VxdWVuY2Ugb2YgYmVpbmdcbi8vIGZvcmNlZCB0byBvdmVyLWV4cG9ydCB0eXBlcyBieSB0aGUgZG9jdW1lbnRhdGlvbiBnZW5lcmF0b3IuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3NvbGFuYS1sYWJzL3NvbGFuYS9wdWxsLzI1ODIwXG5cbi8qKlxuICogQmxvY2toYXNoLWJhc2VkIHRyYW5zYWN0aW9ucyBoYXZlIGEgbGlmZXRpbWUgdGhhdCBhcmUgZGVmaW5lZCBieVxuICogdGhlIGJsb2NraGFzaCB0aGV5IGluY2x1ZGUuIEFueSB0cmFuc2FjdGlvbiB3aG9zZSBibG9ja2hhc2ggaXNcbiAqIHRvbyBvbGQgd2lsbCBiZSByZWplY3RlZC5cbiAqL1xuXG4vKipcbiAqIFVzZSB0aGVzZSBvcHRpb25zIHRvIGNvbnN0cnVjdCBhIGR1cmFibGUgbm9uY2UgdHJhbnNhY3Rpb24uXG4gKi9cblxuLyoqXG4gKiBOb25jZSBpbmZvcm1hdGlvbiB0byBiZSB1c2VkIHRvIGJ1aWxkIGFuIG9mZmxpbmUgVHJhbnNhY3Rpb24uXG4gKi9cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG4vKipcbiAqIFRyYW5zYWN0aW9uIGNsYXNzXG4gKi9cbmNsYXNzIFRyYW5zYWN0aW9uIHtcbiAgLyoqXG4gICAqIFRoZSBmaXJzdCAocGF5ZXIpIFRyYW5zYWN0aW9uIHNpZ25hdHVyZVxuICAgKlxuICAgKiBAcmV0dXJucyB7QnVmZmVyIHwgbnVsbH0gQnVmZmVyIG9mIHBheWVyJ3Mgc2lnbmF0dXJlXG4gICAqL1xuICBnZXQgc2lnbmF0dXJlKCkge1xuICAgIGlmICh0aGlzLnNpZ25hdHVyZXMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2lnbmF0dXJlc1swXS5zaWduYXR1cmU7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0cmFuc2FjdGlvbiBmZWUgcGF5ZXJcbiAgICovXG5cbiAgLy8gQ29uc3RydWN0IGEgdHJhbnNhY3Rpb24gd2l0aCBhIGJsb2NraGFzaCBhbmQgbGFzdFZhbGlkQmxvY2tIZWlnaHRcblxuICAvLyBDb25zdHJ1Y3QgYSB0cmFuc2FjdGlvbiB1c2luZyBhIGR1cmFibGUgbm9uY2VcblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgYFRyYW5zYWN0aW9uQ3RvckZpZWxkc2AgaGFzIGJlZW4gZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uXG4gICAqIFBsZWFzZSBzdXBwbHkgYSBgVHJhbnNhY3Rpb25CbG9ja2hhc2hDdG9yYCBpbnN0ZWFkLlxuICAgKi9cblxuICAvKipcbiAgICogQ29uc3RydWN0IGFuIGVtcHR5IFRyYW5zYWN0aW9uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgLyoqXG4gICAgICogU2lnbmF0dXJlcyBmb3IgdGhlIHRyYW5zYWN0aW9uLiAgVHlwaWNhbGx5IGNyZWF0ZWQgYnkgaW52b2tpbmcgdGhlXG4gICAgICogYHNpZ24oKWAgbWV0aG9kXG4gICAgICovXG4gICAgdGhpcy5zaWduYXR1cmVzID0gW107XG4gICAgdGhpcy5mZWVQYXllciA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBUaGUgaW5zdHJ1Y3Rpb25zIHRvIGF0b21pY2FsbHkgZXhlY3V0ZVxuICAgICAqL1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zID0gW107XG4gICAgLyoqXG4gICAgICogQSByZWNlbnQgdHJhbnNhY3Rpb24gaWQuIE11c3QgYmUgcG9wdWxhdGVkIGJ5IHRoZSBjYWxsZXJcbiAgICAgKi9cbiAgICB0aGlzLnJlY2VudEJsb2NraGFzaCA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiB0aGUgbGFzdCBibG9jayBjaGFpbiBjYW4gYWR2YW5jZSB0byBiZWZvcmUgdHggaXMgZGVjbGFyZWQgZXhwaXJlZFxuICAgICAqICovXG4gICAgdGhpcy5sYXN0VmFsaWRCbG9ja0hlaWdodCA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBPcHRpb25hbCBOb25jZSBpbmZvcm1hdGlvbi4gSWYgcG9wdWxhdGVkLCB0cmFuc2FjdGlvbiB3aWxsIHVzZSBhIGR1cmFibGVcbiAgICAgKiBOb25jZSBoYXNoIGluc3RlYWQgb2YgYSByZWNlbnRCbG9ja2hhc2guIE11c3QgYmUgcG9wdWxhdGVkIGJ5IHRoZSBjYWxsZXJcbiAgICAgKi9cbiAgICB0aGlzLm5vbmNlSW5mbyA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBJZiB0aGlzIGlzIGEgbm9uY2UgdHJhbnNhY3Rpb24gdGhpcyByZXByZXNlbnRzIHRoZSBtaW5pbXVtIHNsb3QgZnJvbSB3aGljaFxuICAgICAqIHRvIGV2YWx1YXRlIGlmIHRoZSBub25jZSBoYXMgYWR2YW5jZWQgd2hlbiBhdHRlbXB0aW5nIHRvIGNvbmZpcm0gdGhlXG4gICAgICogdHJhbnNhY3Rpb24uIFRoaXMgcHJvdGVjdHMgYWdhaW5zdCBhIGNhc2Ugd2hlcmUgdGhlIHRyYW5zYWN0aW9uIGNvbmZpcm1hdGlvblxuICAgICAqIGxvZ2ljIGxvYWRzIHRoZSBub25jZSBhY2NvdW50IGZyb20gYW4gb2xkIHNsb3QgYW5kIGFzc3VtZXMgdGhlIG1pc21hdGNoIGluXG4gICAgICogbm9uY2UgdmFsdWUgaW1wbGllcyB0aGF0IHRoZSBub25jZSBoYXMgYmVlbiBhZHZhbmNlZC5cbiAgICAgKi9cbiAgICB0aGlzLm1pbk5vbmNlQ29udGV4dFNsb3QgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5fbWVzc2FnZSA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLl9qc29uID0gdm9pZCAwO1xuICAgIGlmICghb3B0cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAob3B0cy5mZWVQYXllcikge1xuICAgICAgdGhpcy5mZWVQYXllciA9IG9wdHMuZmVlUGF5ZXI7XG4gICAgfVxuICAgIGlmIChvcHRzLnNpZ25hdHVyZXMpIHtcbiAgICAgIHRoaXMuc2lnbmF0dXJlcyA9IG9wdHMuc2lnbmF0dXJlcztcbiAgICB9XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRzLCAnbm9uY2VJbmZvJykpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbWluQ29udGV4dFNsb3QsXG4gICAgICAgIG5vbmNlSW5mb1xuICAgICAgfSA9IG9wdHM7XG4gICAgICB0aGlzLm1pbk5vbmNlQ29udGV4dFNsb3QgPSBtaW5Db250ZXh0U2xvdDtcbiAgICAgIHRoaXMubm9uY2VJbmZvID0gbm9uY2VJbmZvO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdHMsICdsYXN0VmFsaWRCbG9ja0hlaWdodCcpKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGJsb2NraGFzaCxcbiAgICAgICAgbGFzdFZhbGlkQmxvY2tIZWlnaHRcbiAgICAgIH0gPSBvcHRzO1xuICAgICAgdGhpcy5yZWNlbnRCbG9ja2hhc2ggPSBibG9ja2hhc2g7XG4gICAgICB0aGlzLmxhc3RWYWxpZEJsb2NrSGVpZ2h0ID0gbGFzdFZhbGlkQmxvY2tIZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmVjZW50QmxvY2toYXNoLFxuICAgICAgICBub25jZUluZm9cbiAgICAgIH0gPSBvcHRzO1xuICAgICAgaWYgKG5vbmNlSW5mbykge1xuICAgICAgICB0aGlzLm5vbmNlSW5mbyA9IG5vbmNlSW5mbztcbiAgICAgIH1cbiAgICAgIHRoaXMucmVjZW50QmxvY2toYXNoID0gcmVjZW50QmxvY2toYXNoO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVjZW50QmxvY2toYXNoOiB0aGlzLnJlY2VudEJsb2NraGFzaCB8fCBudWxsLFxuICAgICAgZmVlUGF5ZXI6IHRoaXMuZmVlUGF5ZXIgPyB0aGlzLmZlZVBheWVyLnRvSlNPTigpIDogbnVsbCxcbiAgICAgIG5vbmNlSW5mbzogdGhpcy5ub25jZUluZm8gPyB7XG4gICAgICAgIG5vbmNlOiB0aGlzLm5vbmNlSW5mby5ub25jZSxcbiAgICAgICAgbm9uY2VJbnN0cnVjdGlvbjogdGhpcy5ub25jZUluZm8ubm9uY2VJbnN0cnVjdGlvbi50b0pTT04oKVxuICAgICAgfSA6IG51bGwsXG4gICAgICBpbnN0cnVjdGlvbnM6IHRoaXMuaW5zdHJ1Y3Rpb25zLm1hcChpbnN0cnVjdGlvbiA9PiBpbnN0cnVjdGlvbi50b0pTT04oKSksXG4gICAgICBzaWduZXJzOiB0aGlzLnNpZ25hdHVyZXMubWFwKCh7XG4gICAgICAgIHB1YmxpY0tleVxuICAgICAgfSkgPT4ge1xuICAgICAgICByZXR1cm4gcHVibGljS2V5LnRvSlNPTigpO1xuICAgICAgfSlcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBvbmUgb3IgbW9yZSBpbnN0cnVjdGlvbnMgdG8gdGhpcyBUcmFuc2FjdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PCBUcmFuc2FjdGlvbiB8IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24gfCBUcmFuc2FjdGlvbkluc3RydWN0aW9uQ3RvckZpZWxkcyA+fSBpdGVtcyAtIEluc3RydWN0aW9ucyB0byBhZGQgdG8gdGhlIFRyYW5zYWN0aW9uXG4gICAqL1xuICBhZGQoLi4uaXRlbXMpIHtcbiAgICBpZiAoaXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGluc3RydWN0aW9ucycpO1xuICAgIH1cbiAgICBpdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgaWYgKCdpbnN0cnVjdGlvbnMnIGluIGl0ZW0pIHtcbiAgICAgICAgdGhpcy5pbnN0cnVjdGlvbnMgPSB0aGlzLmluc3RydWN0aW9ucy5jb25jYXQoaXRlbS5pbnN0cnVjdGlvbnMpO1xuICAgICAgfSBlbHNlIGlmICgnZGF0YScgaW4gaXRlbSAmJiAncHJvZ3JhbUlkJyBpbiBpdGVtICYmICdrZXlzJyBpbiBpdGVtKSB7XG4gICAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goaXRlbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKGl0ZW0pKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21waWxlIHRyYW5zYWN0aW9uIGRhdGFcbiAgICovXG4gIGNvbXBpbGVNZXNzYWdlKCkge1xuICAgIGlmICh0aGlzLl9tZXNzYWdlICYmIEpTT04uc3RyaW5naWZ5KHRoaXMudG9KU09OKCkpID09PSBKU09OLnN0cmluZ2lmeSh0aGlzLl9qc29uKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX21lc3NhZ2U7XG4gICAgfVxuICAgIGxldCByZWNlbnRCbG9ja2hhc2g7XG4gICAgbGV0IGluc3RydWN0aW9ucztcbiAgICBpZiAodGhpcy5ub25jZUluZm8pIHtcbiAgICAgIHJlY2VudEJsb2NraGFzaCA9IHRoaXMubm9uY2VJbmZvLm5vbmNlO1xuICAgICAgaWYgKHRoaXMuaW5zdHJ1Y3Rpb25zWzBdICE9IHRoaXMubm9uY2VJbmZvLm5vbmNlSW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgaW5zdHJ1Y3Rpb25zID0gW3RoaXMubm9uY2VJbmZvLm5vbmNlSW5zdHJ1Y3Rpb24sIC4uLnRoaXMuaW5zdHJ1Y3Rpb25zXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluc3RydWN0aW9ucyA9IHRoaXMuaW5zdHJ1Y3Rpb25zO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZWNlbnRCbG9ja2hhc2ggPSB0aGlzLnJlY2VudEJsb2NraGFzaDtcbiAgICAgIGluc3RydWN0aW9ucyA9IHRoaXMuaW5zdHJ1Y3Rpb25zO1xuICAgIH1cbiAgICBpZiAoIXJlY2VudEJsb2NraGFzaCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc2FjdGlvbiByZWNlbnRCbG9ja2hhc2ggcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgaWYgKGluc3RydWN0aW9ucy5sZW5ndGggPCAxKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ05vIGluc3RydWN0aW9ucyBwcm92aWRlZCcpO1xuICAgIH1cbiAgICBsZXQgZmVlUGF5ZXI7XG4gICAgaWYgKHRoaXMuZmVlUGF5ZXIpIHtcbiAgICAgIGZlZVBheWVyID0gdGhpcy5mZWVQYXllcjtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc2lnbmF0dXJlcy5sZW5ndGggPiAwICYmIHRoaXMuc2lnbmF0dXJlc1swXS5wdWJsaWNLZXkpIHtcbiAgICAgIC8vIFVzZSBpbXBsaWNpdCBmZWUgcGF5ZXJcbiAgICAgIGZlZVBheWVyID0gdGhpcy5zaWduYXR1cmVzWzBdLnB1YmxpY0tleTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc2FjdGlvbiBmZWUgcGF5ZXIgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnN0cnVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChpbnN0cnVjdGlvbnNbaV0ucHJvZ3JhbUlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUcmFuc2FjdGlvbiBpbnN0cnVjdGlvbiBpbmRleCAke2l9IGhhcyB1bmRlZmluZWQgcHJvZ3JhbSBpZGApO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBwcm9ncmFtSWRzID0gW107XG4gICAgY29uc3QgYWNjb3VudE1ldGFzID0gW107XG4gICAgaW5zdHJ1Y3Rpb25zLmZvckVhY2goaW5zdHJ1Y3Rpb24gPT4ge1xuICAgICAgaW5zdHJ1Y3Rpb24ua2V5cy5mb3JFYWNoKGFjY291bnRNZXRhID0+IHtcbiAgICAgICAgYWNjb3VudE1ldGFzLnB1c2goe1xuICAgICAgICAgIC4uLmFjY291bnRNZXRhXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBwcm9ncmFtSWQgPSBpbnN0cnVjdGlvbi5wcm9ncmFtSWQudG9TdHJpbmcoKTtcbiAgICAgIGlmICghcHJvZ3JhbUlkcy5pbmNsdWRlcyhwcm9ncmFtSWQpKSB7XG4gICAgICAgIHByb2dyYW1JZHMucHVzaChwcm9ncmFtSWQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQXBwZW5kIHByb2dyYW1JRCBhY2NvdW50IG1ldGFzXG4gICAgcHJvZ3JhbUlkcy5mb3JFYWNoKHByb2dyYW1JZCA9PiB7XG4gICAgICBhY2NvdW50TWV0YXMucHVzaCh7XG4gICAgICAgIHB1YmtleTogbmV3IFB1YmxpY0tleShwcm9ncmFtSWQpLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIEN1bGwgZHVwbGljYXRlIGFjY291bnQgbWV0YXNcbiAgICBjb25zdCB1bmlxdWVNZXRhcyA9IFtdO1xuICAgIGFjY291bnRNZXRhcy5mb3JFYWNoKGFjY291bnRNZXRhID0+IHtcbiAgICAgIGNvbnN0IHB1YmtleVN0cmluZyA9IGFjY291bnRNZXRhLnB1YmtleS50b1N0cmluZygpO1xuICAgICAgY29uc3QgdW5pcXVlSW5kZXggPSB1bmlxdWVNZXRhcy5maW5kSW5kZXgoeCA9PiB7XG4gICAgICAgIHJldHVybiB4LnB1YmtleS50b1N0cmluZygpID09PSBwdWJrZXlTdHJpbmc7XG4gICAgICB9KTtcbiAgICAgIGlmICh1bmlxdWVJbmRleCA+IC0xKSB7XG4gICAgICAgIHVuaXF1ZU1ldGFzW3VuaXF1ZUluZGV4XS5pc1dyaXRhYmxlID0gdW5pcXVlTWV0YXNbdW5pcXVlSW5kZXhdLmlzV3JpdGFibGUgfHwgYWNjb3VudE1ldGEuaXNXcml0YWJsZTtcbiAgICAgICAgdW5pcXVlTWV0YXNbdW5pcXVlSW5kZXhdLmlzU2lnbmVyID0gdW5pcXVlTWV0YXNbdW5pcXVlSW5kZXhdLmlzU2lnbmVyIHx8IGFjY291bnRNZXRhLmlzU2lnbmVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdW5pcXVlTWV0YXMucHVzaChhY2NvdW50TWV0YSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBTb3J0LiBQcmlvcml0aXppbmcgZmlyc3QgYnkgc2lnbmVyLCB0aGVuIGJ5IHdyaXRhYmxlXG4gICAgdW5pcXVlTWV0YXMuc29ydChmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgaWYgKHguaXNTaWduZXIgIT09IHkuaXNTaWduZXIpIHtcbiAgICAgICAgLy8gU2lnbmVycyBhbHdheXMgY29tZSBiZWZvcmUgbm9uLXNpZ25lcnNcbiAgICAgICAgcmV0dXJuIHguaXNTaWduZXIgPyAtMSA6IDE7XG4gICAgICB9XG4gICAgICBpZiAoeC5pc1dyaXRhYmxlICE9PSB5LmlzV3JpdGFibGUpIHtcbiAgICAgICAgLy8gV3JpdGFibGUgYWNjb3VudHMgYWx3YXlzIGNvbWUgYmVmb3JlIHJlYWQtb25seSBhY2NvdW50c1xuICAgICAgICByZXR1cm4geC5pc1dyaXRhYmxlID8gLTEgOiAxO1xuICAgICAgfVxuICAgICAgLy8gT3RoZXJ3aXNlLCBzb3J0IGJ5IHB1YmtleSwgc3RyaW5nd2lzZS5cbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIGxvY2FsZU1hdGNoZXI6ICdiZXN0IGZpdCcsXG4gICAgICAgIHVzYWdlOiAnc29ydCcsXG4gICAgICAgIHNlbnNpdGl2aXR5OiAndmFyaWFudCcsXG4gICAgICAgIGlnbm9yZVB1bmN0dWF0aW9uOiBmYWxzZSxcbiAgICAgICAgbnVtZXJpYzogZmFsc2UsXG4gICAgICAgIGNhc2VGaXJzdDogJ2xvd2VyJ1xuICAgICAgfTtcbiAgICAgIHJldHVybiB4LnB1YmtleS50b0Jhc2U1OCgpLmxvY2FsZUNvbXBhcmUoeS5wdWJrZXkudG9CYXNlNTgoKSwgJ2VuJywgb3B0aW9ucyk7XG4gICAgfSk7XG5cbiAgICAvLyBNb3ZlIGZlZSBwYXllciB0byB0aGUgZnJvbnRcbiAgICBjb25zdCBmZWVQYXllckluZGV4ID0gdW5pcXVlTWV0YXMuZmluZEluZGV4KHggPT4ge1xuICAgICAgcmV0dXJuIHgucHVia2V5LmVxdWFscyhmZWVQYXllcik7XG4gICAgfSk7XG4gICAgaWYgKGZlZVBheWVySW5kZXggPiAtMSkge1xuICAgICAgY29uc3QgW3BheWVyTWV0YV0gPSB1bmlxdWVNZXRhcy5zcGxpY2UoZmVlUGF5ZXJJbmRleCwgMSk7XG4gICAgICBwYXllck1ldGEuaXNTaWduZXIgPSB0cnVlO1xuICAgICAgcGF5ZXJNZXRhLmlzV3JpdGFibGUgPSB0cnVlO1xuICAgICAgdW5pcXVlTWV0YXMudW5zaGlmdChwYXllck1ldGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1bmlxdWVNZXRhcy51bnNoaWZ0KHtcbiAgICAgICAgcHVia2V5OiBmZWVQYXllcixcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIERpc2FsbG93IHVua25vd24gc2lnbmVyc1xuICAgIGZvciAoY29uc3Qgc2lnbmF0dXJlIG9mIHRoaXMuc2lnbmF0dXJlcykge1xuICAgICAgY29uc3QgdW5pcXVlSW5kZXggPSB1bmlxdWVNZXRhcy5maW5kSW5kZXgoeCA9PiB7XG4gICAgICAgIHJldHVybiB4LnB1YmtleS5lcXVhbHMoc2lnbmF0dXJlLnB1YmxpY0tleSk7XG4gICAgICB9KTtcbiAgICAgIGlmICh1bmlxdWVJbmRleCA+IC0xKSB7XG4gICAgICAgIGlmICghdW5pcXVlTWV0YXNbdW5pcXVlSW5kZXhdLmlzU2lnbmVyKSB7XG4gICAgICAgICAgdW5pcXVlTWV0YXNbdW5pcXVlSW5kZXhdLmlzU2lnbmVyID0gdHJ1ZTtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1RyYW5zYWN0aW9uIHJlZmVyZW5jZXMgYSBzaWduYXR1cmUgdGhhdCBpcyB1bm5lY2Vzc2FyeSwgJyArICdvbmx5IHRoZSBmZWUgcGF5ZXIgYW5kIGluc3RydWN0aW9uIHNpZ25lciBhY2NvdW50cyBzaG91bGQgc2lnbiBhIHRyYW5zYWN0aW9uLiAnICsgJ1RoaXMgYmVoYXZpb3IgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCB0aHJvdyBhbiBlcnJvciBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIHJlbGVhc2UuJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biBzaWduZXI6ICR7c2lnbmF0dXJlLnB1YmxpY0tleS50b1N0cmluZygpfWApO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgbnVtUmVxdWlyZWRTaWduYXR1cmVzID0gMDtcbiAgICBsZXQgbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50cyA9IDA7XG4gICAgbGV0IG51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50cyA9IDA7XG5cbiAgICAvLyBTcGxpdCBvdXQgc2lnbmluZyBmcm9tIG5vbi1zaWduaW5nIGtleXMgYW5kIGNvdW50IGhlYWRlciB2YWx1ZXNcbiAgICBjb25zdCBzaWduZWRLZXlzID0gW107XG4gICAgY29uc3QgdW5zaWduZWRLZXlzID0gW107XG4gICAgdW5pcXVlTWV0YXMuZm9yRWFjaCgoe1xuICAgICAgcHVia2V5LFxuICAgICAgaXNTaWduZXIsXG4gICAgICBpc1dyaXRhYmxlXG4gICAgfSkgPT4ge1xuICAgICAgaWYgKGlzU2lnbmVyKSB7XG4gICAgICAgIHNpZ25lZEtleXMucHVzaChwdWJrZXkudG9TdHJpbmcoKSk7XG4gICAgICAgIG51bVJlcXVpcmVkU2lnbmF0dXJlcyArPSAxO1xuICAgICAgICBpZiAoIWlzV3JpdGFibGUpIHtcbiAgICAgICAgICBudW1SZWFkb25seVNpZ25lZEFjY291bnRzICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVuc2lnbmVkS2V5cy5wdXNoKHB1YmtleS50b1N0cmluZygpKTtcbiAgICAgICAgaWYgKCFpc1dyaXRhYmxlKSB7XG4gICAgICAgICAgbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBhY2NvdW50S2V5cyA9IHNpZ25lZEtleXMuY29uY2F0KHVuc2lnbmVkS2V5cyk7XG4gICAgY29uc3QgY29tcGlsZWRJbnN0cnVjdGlvbnMgPSBpbnN0cnVjdGlvbnMubWFwKGluc3RydWN0aW9uID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGF0YSxcbiAgICAgICAgcHJvZ3JhbUlkXG4gICAgICB9ID0gaW5zdHJ1Y3Rpb247XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcm9ncmFtSWRJbmRleDogYWNjb3VudEtleXMuaW5kZXhPZihwcm9ncmFtSWQudG9TdHJpbmcoKSksXG4gICAgICAgIGFjY291bnRzOiBpbnN0cnVjdGlvbi5rZXlzLm1hcChtZXRhID0+IGFjY291bnRLZXlzLmluZGV4T2YobWV0YS5wdWJrZXkudG9TdHJpbmcoKSkpLFxuICAgICAgICBkYXRhOiBiczU4LmVuY29kZShkYXRhKVxuICAgICAgfTtcbiAgICB9KTtcbiAgICBjb21waWxlZEluc3RydWN0aW9ucy5mb3JFYWNoKGluc3RydWN0aW9uID0+IHtcbiAgICAgIGFzc2VydChpbnN0cnVjdGlvbi5wcm9ncmFtSWRJbmRleCA+PSAwKTtcbiAgICAgIGluc3RydWN0aW9uLmFjY291bnRzLmZvckVhY2goa2V5SW5kZXggPT4gYXNzZXJ0KGtleUluZGV4ID49IDApKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IE1lc3NhZ2Uoe1xuICAgICAgaGVhZGVyOiB7XG4gICAgICAgIG51bVJlcXVpcmVkU2lnbmF0dXJlcyxcbiAgICAgICAgbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50cyxcbiAgICAgICAgbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzXG4gICAgICB9LFxuICAgICAgYWNjb3VudEtleXMsXG4gICAgICByZWNlbnRCbG9ja2hhc2gsXG4gICAgICBpbnN0cnVjdGlvbnM6IGNvbXBpbGVkSW5zdHJ1Y3Rpb25zXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfY29tcGlsZSgpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5jb21waWxlTWVzc2FnZSgpO1xuICAgIGNvbnN0IHNpZ25lZEtleXMgPSBtZXNzYWdlLmFjY291bnRLZXlzLnNsaWNlKDAsIG1lc3NhZ2UuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcyk7XG4gICAgaWYgKHRoaXMuc2lnbmF0dXJlcy5sZW5ndGggPT09IHNpZ25lZEtleXMubGVuZ3RoKSB7XG4gICAgICBjb25zdCB2YWxpZCA9IHRoaXMuc2lnbmF0dXJlcy5ldmVyeSgocGFpciwgaW5kZXgpID0+IHtcbiAgICAgICAgcmV0dXJuIHNpZ25lZEtleXNbaW5kZXhdLmVxdWFscyhwYWlyLnB1YmxpY0tleSk7XG4gICAgICB9KTtcbiAgICAgIGlmICh2YWxpZCkgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIHRoaXMuc2lnbmF0dXJlcyA9IHNpZ25lZEtleXMubWFwKHB1YmxpY0tleSA9PiAoe1xuICAgICAgc2lnbmF0dXJlOiBudWxsLFxuICAgICAgcHVibGljS2V5XG4gICAgfSkpO1xuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIGJ1ZmZlciBvZiB0aGUgVHJhbnNhY3Rpb24gZGF0YSB0aGF0IG5lZWQgdG8gYmUgY292ZXJlZCBieSBzaWduYXR1cmVzXG4gICAqL1xuICBzZXJpYWxpemVNZXNzYWdlKCkge1xuICAgIHJldHVybiB0aGlzLl9jb21waWxlKCkuc2VyaWFsaXplKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBlc3RpbWF0ZWQgZmVlIGFzc29jaWF0ZWQgd2l0aCBhIHRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7Q29ubmVjdGlvbn0gY29ubmVjdGlvbiBDb25uZWN0aW9uIHRvIFJQQyBFbmRwb2ludC5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8bnVtYmVyIHwgbnVsbD59IFRoZSBlc3RpbWF0ZWQgZmVlIGZvciB0aGUgdHJhbnNhY3Rpb25cbiAgICovXG4gIGFzeW5jIGdldEVzdGltYXRlZEZlZShjb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuIChhd2FpdCBjb25uZWN0aW9uLmdldEZlZUZvck1lc3NhZ2UodGhpcy5jb21waWxlTWVzc2FnZSgpKSkudmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogU3BlY2lmeSB0aGUgcHVibGljIGtleXMgd2hpY2ggd2lsbCBiZSB1c2VkIHRvIHNpZ24gdGhlIFRyYW5zYWN0aW9uLlxuICAgKiBUaGUgZmlyc3Qgc2lnbmVyIHdpbGwgYmUgdXNlZCBhcyB0aGUgdHJhbnNhY3Rpb24gZmVlIHBheWVyIGFjY291bnQuXG4gICAqXG4gICAqIFNpZ25hdHVyZXMgY2FuIGJlIGFkZGVkIHdpdGggZWl0aGVyIGBwYXJ0aWFsU2lnbmAgb3IgYGFkZFNpZ25hdHVyZWBcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSB2MC44NC4wLiBPbmx5IHRoZSBmZWUgcGF5ZXIgbmVlZHMgdG8gYmVcbiAgICogc3BlY2lmaWVkIGFuZCBpdCBjYW4gYmUgc2V0IGluIHRoZSBUcmFuc2FjdGlvbiBjb25zdHJ1Y3RvciBvciB3aXRoIHRoZVxuICAgKiBgZmVlUGF5ZXJgIHByb3BlcnR5LlxuICAgKi9cbiAgc2V0U2lnbmVycyguLi5zaWduZXJzKSB7XG4gICAgaWYgKHNpZ25lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHNpZ25lcnMnKTtcbiAgICB9XG4gICAgY29uc3Qgc2VlbiA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLnNpZ25hdHVyZXMgPSBzaWduZXJzLmZpbHRlcihwdWJsaWNLZXkgPT4ge1xuICAgICAgY29uc3Qga2V5ID0gcHVibGljS2V5LnRvU3RyaW5nKCk7XG4gICAgICBpZiAoc2Vlbi5oYXMoa2V5KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWVuLmFkZChrZXkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KS5tYXAocHVibGljS2V5ID0+ICh7XG4gICAgICBzaWduYXR1cmU6IG51bGwsXG4gICAgICBwdWJsaWNLZXlcbiAgICB9KSk7XG4gIH1cblxuICAvKipcbiAgICogU2lnbiB0aGUgVHJhbnNhY3Rpb24gd2l0aCB0aGUgc3BlY2lmaWVkIHNpZ25lcnMuIE11bHRpcGxlIHNpZ25hdHVyZXMgbWF5XG4gICAqIGJlIGFwcGxpZWQgdG8gYSBUcmFuc2FjdGlvbi4gVGhlIGZpcnN0IHNpZ25hdHVyZSBpcyBjb25zaWRlcmVkIFwicHJpbWFyeVwiXG4gICAqIGFuZCBpcyB1c2VkIGlkZW50aWZ5IGFuZCBjb25maXJtIHRyYW5zYWN0aW9ucy5cbiAgICpcbiAgICogSWYgdGhlIFRyYW5zYWN0aW9uIGBmZWVQYXllcmAgaXMgbm90IHNldCwgdGhlIGZpcnN0IHNpZ25lciB3aWxsIGJlIHVzZWRcbiAgICogYXMgdGhlIHRyYW5zYWN0aW9uIGZlZSBwYXllciBhY2NvdW50LlxuICAgKlxuICAgKiBUcmFuc2FjdGlvbiBmaWVsZHMgc2hvdWxkIG5vdCBiZSBtb2RpZmllZCBhZnRlciB0aGUgZmlyc3QgY2FsbCB0byBgc2lnbmAsXG4gICAqIGFzIGRvaW5nIHNvIG1heSBpbnZhbGlkYXRlIHRoZSBzaWduYXR1cmUgYW5kIGNhdXNlIHRoZSBUcmFuc2FjdGlvbiB0byBiZVxuICAgKiByZWplY3RlZC5cbiAgICpcbiAgICogVGhlIFRyYW5zYWN0aW9uIG11c3QgYmUgYXNzaWduZWQgYSB2YWxpZCBgcmVjZW50QmxvY2toYXNoYCBiZWZvcmUgaW52b2tpbmcgdGhpcyBtZXRob2RcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxTaWduZXI+fSBzaWduZXJzIEFycmF5IG9mIHNpZ25lcnMgdGhhdCB3aWxsIHNpZ24gdGhlIHRyYW5zYWN0aW9uXG4gICAqL1xuICBzaWduKC4uLnNpZ25lcnMpIHtcbiAgICBpZiAoc2lnbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc2lnbmVycycpO1xuICAgIH1cblxuICAgIC8vIERlZHVwZSBzaWduZXJzXG4gICAgY29uc3Qgc2VlbiA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCB1bmlxdWVTaWduZXJzID0gW107XG4gICAgZm9yIChjb25zdCBzaWduZXIgb2Ygc2lnbmVycykge1xuICAgICAgY29uc3Qga2V5ID0gc2lnbmVyLnB1YmxpY0tleS50b1N0cmluZygpO1xuICAgICAgaWYgKHNlZW4uaGFzKGtleSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWVuLmFkZChrZXkpO1xuICAgICAgICB1bmlxdWVTaWduZXJzLnB1c2goc2lnbmVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5zaWduYXR1cmVzID0gdW5pcXVlU2lnbmVycy5tYXAoc2lnbmVyID0+ICh7XG4gICAgICBzaWduYXR1cmU6IG51bGwsXG4gICAgICBwdWJsaWNLZXk6IHNpZ25lci5wdWJsaWNLZXlcbiAgICB9KSk7XG4gICAgY29uc3QgbWVzc2FnZSA9IHRoaXMuX2NvbXBpbGUoKTtcbiAgICB0aGlzLl9wYXJ0aWFsU2lnbihtZXNzYWdlLCAuLi51bmlxdWVTaWduZXJzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJ0aWFsbHkgc2lnbiBhIHRyYW5zYWN0aW9uIHdpdGggdGhlIHNwZWNpZmllZCBhY2NvdW50cy4gQWxsIGFjY291bnRzIG11c3RcbiAgICogY29ycmVzcG9uZCB0byBlaXRoZXIgdGhlIGZlZSBwYXllciBvciBhIHNpZ25lciBhY2NvdW50IGluIHRoZSB0cmFuc2FjdGlvblxuICAgKiBpbnN0cnVjdGlvbnMuXG4gICAqXG4gICAqIEFsbCB0aGUgY2F2ZWF0cyBmcm9tIHRoZSBgc2lnbmAgbWV0aG9kIGFwcGx5IHRvIGBwYXJ0aWFsU2lnbmBcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxTaWduZXI+fSBzaWduZXJzIEFycmF5IG9mIHNpZ25lcnMgdGhhdCB3aWxsIHNpZ24gdGhlIHRyYW5zYWN0aW9uXG4gICAqL1xuICBwYXJ0aWFsU2lnbiguLi5zaWduZXJzKSB7XG4gICAgaWYgKHNpZ25lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHNpZ25lcnMnKTtcbiAgICB9XG5cbiAgICAvLyBEZWR1cGUgc2lnbmVyc1xuICAgIGNvbnN0IHNlZW4gPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgdW5pcXVlU2lnbmVycyA9IFtdO1xuICAgIGZvciAoY29uc3Qgc2lnbmVyIG9mIHNpZ25lcnMpIHtcbiAgICAgIGNvbnN0IGtleSA9IHNpZ25lci5wdWJsaWNLZXkudG9TdHJpbmcoKTtcbiAgICAgIGlmIChzZWVuLmhhcyhrZXkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2Vlbi5hZGQoa2V5KTtcbiAgICAgICAgdW5pcXVlU2lnbmVycy5wdXNoKHNpZ25lcik7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG1lc3NhZ2UgPSB0aGlzLl9jb21waWxlKCk7XG4gICAgdGhpcy5fcGFydGlhbFNpZ24obWVzc2FnZSwgLi4udW5pcXVlU2lnbmVycyk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfcGFydGlhbFNpZ24obWVzc2FnZSwgLi4uc2lnbmVycykge1xuICAgIGNvbnN0IHNpZ25EYXRhID0gbWVzc2FnZS5zZXJpYWxpemUoKTtcbiAgICBzaWduZXJzLmZvckVhY2goc2lnbmVyID0+IHtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHNpZ24oc2lnbkRhdGEsIHNpZ25lci5zZWNyZXRLZXkpO1xuICAgICAgdGhpcy5fYWRkU2lnbmF0dXJlKHNpZ25lci5wdWJsaWNLZXksIHRvQnVmZmVyKHNpZ25hdHVyZSkpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhbiBleHRlcm5hbGx5IGNyZWF0ZWQgc2lnbmF0dXJlIHRvIGEgdHJhbnNhY3Rpb24uIFRoZSBwdWJsaWMga2V5XG4gICAqIG11c3QgY29ycmVzcG9uZCB0byBlaXRoZXIgdGhlIGZlZSBwYXllciBvciBhIHNpZ25lciBhY2NvdW50IGluIHRoZSB0cmFuc2FjdGlvblxuICAgKiBpbnN0cnVjdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7UHVibGljS2V5fSBwdWJrZXkgUHVibGljIGtleSB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIHRyYW5zYWN0aW9uLlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gc2lnbmF0dXJlIEFuIGV4dGVybmFsbHkgY3JlYXRlZCBzaWduYXR1cmUgdG8gYWRkIHRvIHRoZSB0cmFuc2FjdGlvbi5cbiAgICovXG4gIGFkZFNpZ25hdHVyZShwdWJrZXksIHNpZ25hdHVyZSkge1xuICAgIHRoaXMuX2NvbXBpbGUoKTsgLy8gRW5zdXJlIHNpZ25hdHVyZXMgYXJyYXkgaXMgcG9wdWxhdGVkXG4gICAgdGhpcy5fYWRkU2lnbmF0dXJlKHB1YmtleSwgc2lnbmF0dXJlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9hZGRTaWduYXR1cmUocHVia2V5LCBzaWduYXR1cmUpIHtcbiAgICBhc3NlcnQoc2lnbmF0dXJlLmxlbmd0aCA9PT0gNjQpO1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5zaWduYXR1cmVzLmZpbmRJbmRleChzaWdwYWlyID0+IHB1YmtleS5lcXVhbHMoc2lncGFpci5wdWJsaWNLZXkpKTtcbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gc2lnbmVyOiAke3B1YmtleS50b1N0cmluZygpfWApO1xuICAgIH1cbiAgICB0aGlzLnNpZ25hdHVyZXNbaW5kZXhdLnNpZ25hdHVyZSA9IEJ1ZmZlci5mcm9tKHNpZ25hdHVyZSk7XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZ5IHNpZ25hdHVyZXMgb2YgYSBUcmFuc2FjdGlvblxuICAgKiBPcHRpb25hbCBwYXJhbWV0ZXIgc3BlY2lmaWVzIGlmIHdlJ3JlIGV4cGVjdGluZyBhIGZ1bGx5IHNpZ25lZCBUcmFuc2FjdGlvbiBvciBhIHBhcnRpYWxseSBzaWduZWQgb25lLlxuICAgKiBJZiBubyBib29sZWFuIGlzIHByb3ZpZGVkLCB3ZSBleHBlY3QgYSBmdWxseSBzaWduZWQgVHJhbnNhY3Rpb24gYnkgZGVmYXVsdC5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbcmVxdWlyZUFsbFNpZ25hdHVyZXM9dHJ1ZV0gUmVxdWlyZSBhIGZ1bGx5IHNpZ25lZCBUcmFuc2FjdGlvblxuICAgKi9cbiAgdmVyaWZ5U2lnbmF0dXJlcyhyZXF1aXJlQWxsU2lnbmF0dXJlcyA9IHRydWUpIHtcbiAgICBjb25zdCBzaWduYXR1cmVFcnJvcnMgPSB0aGlzLl9nZXRNZXNzYWdlU2lnbmVkbmVzc0Vycm9ycyh0aGlzLnNlcmlhbGl6ZU1lc3NhZ2UoKSwgcmVxdWlyZUFsbFNpZ25hdHVyZXMpO1xuICAgIHJldHVybiAhc2lnbmF0dXJlRXJyb3JzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2dldE1lc3NhZ2VTaWduZWRuZXNzRXJyb3JzKG1lc3NhZ2UsIHJlcXVpcmVBbGxTaWduYXR1cmVzKSB7XG4gICAgY29uc3QgZXJyb3JzID0ge307XG4gICAgZm9yIChjb25zdCB7XG4gICAgICBzaWduYXR1cmUsXG4gICAgICBwdWJsaWNLZXlcbiAgICB9IG9mIHRoaXMuc2lnbmF0dXJlcykge1xuICAgICAgaWYgKHNpZ25hdHVyZSA9PT0gbnVsbCkge1xuICAgICAgICBpZiAocmVxdWlyZUFsbFNpZ25hdHVyZXMpIHtcbiAgICAgICAgICAoZXJyb3JzLm1pc3NpbmcgfHw9IFtdKS5wdXNoKHB1YmxpY0tleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghdmVyaWZ5KHNpZ25hdHVyZSwgbWVzc2FnZSwgcHVibGljS2V5LnRvQnl0ZXMoKSkpIHtcbiAgICAgICAgICAoZXJyb3JzLmludmFsaWQgfHw9IFtdKS5wdXNoKHB1YmxpY0tleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVycm9ycy5pbnZhbGlkIHx8IGVycm9ycy5taXNzaW5nID8gZXJyb3JzIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZSB0aGUgVHJhbnNhY3Rpb24gaW4gdGhlIHdpcmUgZm9ybWF0LlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gW2NvbmZpZ10gQ29uZmlnIG9mIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJucyB7QnVmZmVyfSBTaWduYXR1cmUgb2YgdHJhbnNhY3Rpb24gaW4gd2lyZSBmb3JtYXQuXG4gICAqL1xuICBzZXJpYWxpemUoY29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVxdWlyZUFsbFNpZ25hdHVyZXMsXG4gICAgICB2ZXJpZnlTaWduYXR1cmVzXG4gICAgfSA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgcmVxdWlyZUFsbFNpZ25hdHVyZXM6IHRydWUsXG4gICAgICB2ZXJpZnlTaWduYXR1cmVzOiB0cnVlXG4gICAgfSwgY29uZmlnKTtcbiAgICBjb25zdCBzaWduRGF0YSA9IHRoaXMuc2VyaWFsaXplTWVzc2FnZSgpO1xuICAgIGlmICh2ZXJpZnlTaWduYXR1cmVzKSB7XG4gICAgICBjb25zdCBzaWdFcnJvcnMgPSB0aGlzLl9nZXRNZXNzYWdlU2lnbmVkbmVzc0Vycm9ycyhzaWduRGF0YSwgcmVxdWlyZUFsbFNpZ25hdHVyZXMpO1xuICAgICAgaWYgKHNpZ0Vycm9ycykge1xuICAgICAgICBsZXQgZXJyb3JNZXNzYWdlID0gJ1NpZ25hdHVyZSB2ZXJpZmljYXRpb24gZmFpbGVkLic7XG4gICAgICAgIGlmIChzaWdFcnJvcnMuaW52YWxpZCkge1xuICAgICAgICAgIGVycm9yTWVzc2FnZSArPSBgXFxuSW52YWxpZCBzaWduYXR1cmUgZm9yIHB1YmxpYyBrZXkke3NpZ0Vycm9ycy5pbnZhbGlkLmxlbmd0aCA9PT0gMSA/ICcnIDogJyhzKSd9IFtcXGAke3NpZ0Vycm9ycy5pbnZhbGlkLm1hcChwID0+IHAudG9CYXNlNTgoKSkuam9pbignYCwgYCcpfVxcYF0uYDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2lnRXJyb3JzLm1pc3NpbmcpIHtcbiAgICAgICAgICBlcnJvck1lc3NhZ2UgKz0gYFxcbk1pc3Npbmcgc2lnbmF0dXJlIGZvciBwdWJsaWMga2V5JHtzaWdFcnJvcnMubWlzc2luZy5sZW5ndGggPT09IDEgPyAnJyA6ICcocyknfSBbXFxgJHtzaWdFcnJvcnMubWlzc2luZy5tYXAocCA9PiBwLnRvQmFzZTU4KCkpLmpvaW4oJ2AsIGAnKX1cXGBdLmA7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zZXJpYWxpemUoc2lnbkRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3NlcmlhbGl6ZShzaWduRGF0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHNpZ25hdHVyZXNcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBzaWduYXR1cmVDb3VudCA9IFtdO1xuICAgIGVuY29kZUxlbmd0aChzaWduYXR1cmVDb3VudCwgc2lnbmF0dXJlcy5sZW5ndGgpO1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uTGVuZ3RoID0gc2lnbmF0dXJlQ291bnQubGVuZ3RoICsgc2lnbmF0dXJlcy5sZW5ndGggKiA2NCArIHNpZ25EYXRhLmxlbmd0aDtcbiAgICBjb25zdCB3aXJlVHJhbnNhY3Rpb24gPSBCdWZmZXIuYWxsb2ModHJhbnNhY3Rpb25MZW5ndGgpO1xuICAgIGFzc2VydChzaWduYXR1cmVzLmxlbmd0aCA8IDI1Nik7XG4gICAgQnVmZmVyLmZyb20oc2lnbmF0dXJlQ291bnQpLmNvcHkod2lyZVRyYW5zYWN0aW9uLCAwKTtcbiAgICBzaWduYXR1cmVzLmZvckVhY2goKHtcbiAgICAgIHNpZ25hdHVyZVxuICAgIH0sIGluZGV4KSA9PiB7XG4gICAgICBpZiAoc2lnbmF0dXJlICE9PSBudWxsKSB7XG4gICAgICAgIGFzc2VydChzaWduYXR1cmUubGVuZ3RoID09PSA2NCwgYHNpZ25hdHVyZSBoYXMgaW52YWxpZCBsZW5ndGhgKTtcbiAgICAgICAgQnVmZmVyLmZyb20oc2lnbmF0dXJlKS5jb3B5KHdpcmVUcmFuc2FjdGlvbiwgc2lnbmF0dXJlQ291bnQubGVuZ3RoICsgaW5kZXggKiA2NCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgc2lnbkRhdGEuY29weSh3aXJlVHJhbnNhY3Rpb24sIHNpZ25hdHVyZUNvdW50Lmxlbmd0aCArIHNpZ25hdHVyZXMubGVuZ3RoICogNjQpO1xuICAgIGFzc2VydCh3aXJlVHJhbnNhY3Rpb24ubGVuZ3RoIDw9IFBBQ0tFVF9EQVRBX1NJWkUsIGBUcmFuc2FjdGlvbiB0b28gbGFyZ2U6ICR7d2lyZVRyYW5zYWN0aW9uLmxlbmd0aH0gPiAke1BBQ0tFVF9EQVRBX1NJWkV9YCk7XG4gICAgcmV0dXJuIHdpcmVUcmFuc2FjdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXByZWNhdGVkIG1ldGhvZFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldCBrZXlzKCkge1xuICAgIGFzc2VydCh0aGlzLmluc3RydWN0aW9ucy5sZW5ndGggPT09IDEpO1xuICAgIHJldHVybiB0aGlzLmluc3RydWN0aW9uc1swXS5rZXlzLm1hcChrZXlPYmogPT4ga2V5T2JqLnB1YmtleSk7XG4gIH1cblxuICAvKipcbiAgICogRGVwcmVjYXRlZCBtZXRob2RcbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXQgcHJvZ3JhbUlkKCkge1xuICAgIGFzc2VydCh0aGlzLmluc3RydWN0aW9ucy5sZW5ndGggPT09IDEpO1xuICAgIHJldHVybiB0aGlzLmluc3RydWN0aW9uc1swXS5wcm9ncmFtSWQ7XG4gIH1cblxuICAvKipcbiAgICogRGVwcmVjYXRlZCBtZXRob2RcbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXQgZGF0YSgpIHtcbiAgICBhc3NlcnQodGhpcy5pbnN0cnVjdGlvbnMubGVuZ3RoID09PSAxKTtcbiAgICByZXR1cm4gdGhpcy5pbnN0cnVjdGlvbnNbMF0uZGF0YTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBhIHdpcmUgdHJhbnNhY3Rpb24gaW50byBhIFRyYW5zYWN0aW9uIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXIgfCBVaW50OEFycmF5IHwgQXJyYXk8bnVtYmVyPn0gYnVmZmVyIFNpZ25hdHVyZSBvZiB3aXJlIFRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvbn0gVHJhbnNhY3Rpb24gYXNzb2NpYXRlZCB3aXRoIHRoZSBzaWduYXR1cmVcbiAgICovXG4gIHN0YXRpYyBmcm9tKGJ1ZmZlcikge1xuICAgIC8vIFNsaWNlIHVwIHdpcmUgZGF0YVxuICAgIGxldCBieXRlQXJyYXkgPSBbLi4uYnVmZmVyXTtcbiAgICBjb25zdCBzaWduYXR1cmVDb3VudCA9IGRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgIGxldCBzaWduYXR1cmVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaWduYXR1cmVDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgU0lHTkFUVVJFX0xFTkdUSF9JTl9CWVRFUyk7XG4gICAgICBzaWduYXR1cmVzLnB1c2goYnM1OC5lbmNvZGUoQnVmZmVyLmZyb20oc2lnbmF0dXJlKSkpO1xuICAgIH1cbiAgICByZXR1cm4gVHJhbnNhY3Rpb24ucG9wdWxhdGUoTWVzc2FnZS5mcm9tKGJ5dGVBcnJheSksIHNpZ25hdHVyZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBvcHVsYXRlIFRyYW5zYWN0aW9uIG9iamVjdCBmcm9tIG1lc3NhZ2UgYW5kIHNpZ25hdHVyZXNcbiAgICpcbiAgICogQHBhcmFtIHtNZXNzYWdlfSBtZXNzYWdlIE1lc3NhZ2Ugb2YgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBzaWduYXR1cmVzIExpc3Qgb2Ygc2lnbmF0dXJlcyB0byBhc3NpZ24gdG8gdGhlIHRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvbn0gVGhlIHBvcHVsYXRlZCBUcmFuc2FjdGlvblxuICAgKi9cbiAgc3RhdGljIHBvcHVsYXRlKG1lc3NhZ2UsIHNpZ25hdHVyZXMgPSBbXSkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgdHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoID0gbWVzc2FnZS5yZWNlbnRCbG9ja2hhc2g7XG4gICAgaWYgKG1lc3NhZ2UuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcyA+IDApIHtcbiAgICAgIHRyYW5zYWN0aW9uLmZlZVBheWVyID0gbWVzc2FnZS5hY2NvdW50S2V5c1swXTtcbiAgICB9XG4gICAgc2lnbmF0dXJlcy5mb3JFYWNoKChzaWduYXR1cmUsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBzaWdQdWJrZXlQYWlyID0ge1xuICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZSA9PSBiczU4LmVuY29kZShERUZBVUxUX1NJR05BVFVSRSkgPyBudWxsIDogYnM1OC5kZWNvZGUoc2lnbmF0dXJlKSxcbiAgICAgICAgcHVibGljS2V5OiBtZXNzYWdlLmFjY291bnRLZXlzW2luZGV4XVxuICAgICAgfTtcbiAgICAgIHRyYW5zYWN0aW9uLnNpZ25hdHVyZXMucHVzaChzaWdQdWJrZXlQYWlyKTtcbiAgICB9KTtcbiAgICBtZXNzYWdlLmluc3RydWN0aW9ucy5mb3JFYWNoKGluc3RydWN0aW9uID0+IHtcbiAgICAgIGNvbnN0IGtleXMgPSBpbnN0cnVjdGlvbi5hY2NvdW50cy5tYXAoYWNjb3VudCA9PiB7XG4gICAgICAgIGNvbnN0IHB1YmtleSA9IG1lc3NhZ2UuYWNjb3VudEtleXNbYWNjb3VudF07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcHVia2V5LFxuICAgICAgICAgIGlzU2lnbmVyOiB0cmFuc2FjdGlvbi5zaWduYXR1cmVzLnNvbWUoa2V5T2JqID0+IGtleU9iai5wdWJsaWNLZXkudG9TdHJpbmcoKSA9PT0gcHVia2V5LnRvU3RyaW5nKCkpIHx8IG1lc3NhZ2UuaXNBY2NvdW50U2lnbmVyKGFjY291bnQpLFxuICAgICAgICAgIGlzV3JpdGFibGU6IG1lc3NhZ2UuaXNBY2NvdW50V3JpdGFibGUoYWNjb3VudClcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgdHJhbnNhY3Rpb24uaW5zdHJ1Y3Rpb25zLnB1c2gobmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAgICBrZXlzLFxuICAgICAgICBwcm9ncmFtSWQ6IG1lc3NhZ2UuYWNjb3VudEtleXNbaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkSW5kZXhdLFxuICAgICAgICBkYXRhOiBiczU4LmRlY29kZShpbnN0cnVjdGlvbi5kYXRhKVxuICAgICAgfSkpO1xuICAgIH0pO1xuICAgIHRyYW5zYWN0aW9uLl9tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0cmFuc2FjdGlvbi5fanNvbiA9IHRyYW5zYWN0aW9uLnRvSlNPTigpO1xuICAgIHJldHVybiB0cmFuc2FjdGlvbjtcbiAgfVxufVxuXG5jbGFzcyBUcmFuc2FjdGlvbk1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihhcmdzKSB7XG4gICAgdGhpcy5wYXllcktleSA9IHZvaWQgMDtcbiAgICB0aGlzLmluc3RydWN0aW9ucyA9IHZvaWQgMDtcbiAgICB0aGlzLnJlY2VudEJsb2NraGFzaCA9IHZvaWQgMDtcbiAgICB0aGlzLnBheWVyS2V5ID0gYXJncy5wYXllcktleTtcbiAgICB0aGlzLmluc3RydWN0aW9ucyA9IGFyZ3MuaW5zdHJ1Y3Rpb25zO1xuICAgIHRoaXMucmVjZW50QmxvY2toYXNoID0gYXJncy5yZWNlbnRCbG9ja2hhc2g7XG4gIH1cbiAgc3RhdGljIGRlY29tcGlsZShtZXNzYWdlLCBhcmdzKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGVhZGVyLFxuICAgICAgY29tcGlsZWRJbnN0cnVjdGlvbnMsXG4gICAgICByZWNlbnRCbG9ja2hhc2hcbiAgICB9ID0gbWVzc2FnZTtcbiAgICBjb25zdCB7XG4gICAgICBudW1SZXF1aXJlZFNpZ25hdHVyZXMsXG4gICAgICBudW1SZWFkb25seVNpZ25lZEFjY291bnRzLFxuICAgICAgbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzXG4gICAgfSA9IGhlYWRlcjtcbiAgICBjb25zdCBudW1Xcml0YWJsZVNpZ25lZEFjY291bnRzID0gbnVtUmVxdWlyZWRTaWduYXR1cmVzIC0gbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50cztcbiAgICBhc3NlcnQobnVtV3JpdGFibGVTaWduZWRBY2NvdW50cyA+IDAsICdNZXNzYWdlIGhlYWRlciBpcyBpbnZhbGlkJyk7XG4gICAgY29uc3QgbnVtV3JpdGFibGVVbnNpZ25lZEFjY291bnRzID0gbWVzc2FnZS5zdGF0aWNBY2NvdW50S2V5cy5sZW5ndGggLSBudW1SZXF1aXJlZFNpZ25hdHVyZXMgLSBudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHM7XG4gICAgYXNzZXJ0KG51bVdyaXRhYmxlVW5zaWduZWRBY2NvdW50cyA+PSAwLCAnTWVzc2FnZSBoZWFkZXIgaXMgaW52YWxpZCcpO1xuICAgIGNvbnN0IGFjY291bnRLZXlzID0gbWVzc2FnZS5nZXRBY2NvdW50S2V5cyhhcmdzKTtcbiAgICBjb25zdCBwYXllcktleSA9IGFjY291bnRLZXlzLmdldCgwKTtcbiAgICBpZiAocGF5ZXJLZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZGVjb21waWxlIG1lc3NhZ2UgYmVjYXVzZSBubyBhY2NvdW50IGtleXMgd2VyZSBmb3VuZCcpO1xuICAgIH1cbiAgICBjb25zdCBpbnN0cnVjdGlvbnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGNvbXBpbGVkSXggb2YgY29tcGlsZWRJbnN0cnVjdGlvbnMpIHtcbiAgICAgIGNvbnN0IGtleXMgPSBbXTtcbiAgICAgIGZvciAoY29uc3Qga2V5SW5kZXggb2YgY29tcGlsZWRJeC5hY2NvdW50S2V5SW5kZXhlcykge1xuICAgICAgICBjb25zdCBwdWJrZXkgPSBhY2NvdW50S2V5cy5nZXQoa2V5SW5kZXgpO1xuICAgICAgICBpZiAocHVia2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmaW5kIGtleSBmb3IgYWNjb3VudCBrZXkgaW5kZXggJHtrZXlJbmRleH1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc1NpZ25lciA9IGtleUluZGV4IDwgbnVtUmVxdWlyZWRTaWduYXR1cmVzO1xuICAgICAgICBsZXQgaXNXcml0YWJsZTtcbiAgICAgICAgaWYgKGlzU2lnbmVyKSB7XG4gICAgICAgICAgaXNXcml0YWJsZSA9IGtleUluZGV4IDwgbnVtV3JpdGFibGVTaWduZWRBY2NvdW50cztcbiAgICAgICAgfSBlbHNlIGlmIChrZXlJbmRleCA8IGFjY291bnRLZXlzLnN0YXRpY0FjY291bnRLZXlzLmxlbmd0aCkge1xuICAgICAgICAgIGlzV3JpdGFibGUgPSBrZXlJbmRleCAtIG51bVJlcXVpcmVkU2lnbmF0dXJlcyA8IG51bVdyaXRhYmxlVW5zaWduZWRBY2NvdW50cztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpc1dyaXRhYmxlID0ga2V5SW5kZXggLSBhY2NvdW50S2V5cy5zdGF0aWNBY2NvdW50S2V5cy5sZW5ndGggPFxuICAgICAgICAgIC8vIGFjY291bnRLZXlzRnJvbUxvb2t1cHMgY2Fubm90IGJlIHVuZGVmaW5lZCBiZWNhdXNlIHdlIGFscmVhZHkgZm91bmQgYSBwdWJrZXkgZm9yIHRoaXMgaW5kZXggYWJvdmVcbiAgICAgICAgICBhY2NvdW50S2V5cy5hY2NvdW50S2V5c0Zyb21Mb29rdXBzLndyaXRhYmxlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBrZXlzLnB1c2goe1xuICAgICAgICAgIHB1YmtleSxcbiAgICAgICAgICBpc1NpZ25lcjoga2V5SW5kZXggPCBoZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzLFxuICAgICAgICAgIGlzV3JpdGFibGVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCBwcm9ncmFtSWQgPSBhY2NvdW50S2V5cy5nZXQoY29tcGlsZWRJeC5wcm9ncmFtSWRJbmRleCk7XG4gICAgICBpZiAocHJvZ3JhbUlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmluZCBwcm9ncmFtIGlkIGZvciBwcm9ncmFtIGlkIGluZGV4ICR7Y29tcGlsZWRJeC5wcm9ncmFtSWRJbmRleH1gKTtcbiAgICAgIH1cbiAgICAgIGluc3RydWN0aW9ucy5wdXNoKG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgICAgcHJvZ3JhbUlkLFxuICAgICAgICBkYXRhOiB0b0J1ZmZlcihjb21waWxlZEl4LmRhdGEpLFxuICAgICAgICBrZXlzXG4gICAgICB9KSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25NZXNzYWdlKHtcbiAgICAgIHBheWVyS2V5LFxuICAgICAgaW5zdHJ1Y3Rpb25zLFxuICAgICAgcmVjZW50QmxvY2toYXNoXG4gICAgfSk7XG4gIH1cbiAgY29tcGlsZVRvTGVnYWN5TWVzc2FnZSgpIHtcbiAgICByZXR1cm4gTWVzc2FnZS5jb21waWxlKHtcbiAgICAgIHBheWVyS2V5OiB0aGlzLnBheWVyS2V5LFxuICAgICAgcmVjZW50QmxvY2toYXNoOiB0aGlzLnJlY2VudEJsb2NraGFzaCxcbiAgICAgIGluc3RydWN0aW9uczogdGhpcy5pbnN0cnVjdGlvbnNcbiAgICB9KTtcbiAgfVxuICBjb21waWxlVG9WME1lc3NhZ2UoYWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudHMpIHtcbiAgICByZXR1cm4gTWVzc2FnZVYwLmNvbXBpbGUoe1xuICAgICAgcGF5ZXJLZXk6IHRoaXMucGF5ZXJLZXksXG4gICAgICByZWNlbnRCbG9ja2hhc2g6IHRoaXMucmVjZW50QmxvY2toYXNoLFxuICAgICAgaW5zdHJ1Y3Rpb25zOiB0aGlzLmluc3RydWN0aW9ucyxcbiAgICAgIGFkZHJlc3NMb29rdXBUYWJsZUFjY291bnRzXG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBWZXJzaW9uZWQgdHJhbnNhY3Rpb24gY2xhc3NcbiAqL1xuY2xhc3MgVmVyc2lvbmVkVHJhbnNhY3Rpb24ge1xuICBnZXQgdmVyc2lvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlLnZlcnNpb247XG4gIH1cbiAgY29uc3RydWN0b3IobWVzc2FnZSwgc2lnbmF0dXJlcykge1xuICAgIHRoaXMuc2lnbmF0dXJlcyA9IHZvaWQgMDtcbiAgICB0aGlzLm1lc3NhZ2UgPSB2b2lkIDA7XG4gICAgaWYgKHNpZ25hdHVyZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYXNzZXJ0KHNpZ25hdHVyZXMubGVuZ3RoID09PSBtZXNzYWdlLmhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXMsICdFeHBlY3RlZCBzaWduYXR1cmVzIGxlbmd0aCB0byBiZSBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIHJlcXVpcmVkIHNpZ25hdHVyZXMnKTtcbiAgICAgIHRoaXMuc2lnbmF0dXJlcyA9IHNpZ25hdHVyZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGRlZmF1bHRTaWduYXR1cmVzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lc3NhZ2UuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlczsgaSsrKSB7XG4gICAgICAgIGRlZmF1bHRTaWduYXR1cmVzLnB1c2gobmV3IFVpbnQ4QXJyYXkoU0lHTkFUVVJFX0xFTkdUSF9JTl9CWVRFUykpO1xuICAgICAgfVxuICAgICAgdGhpcy5zaWduYXR1cmVzID0gZGVmYXVsdFNpZ25hdHVyZXM7XG4gICAgfVxuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIH1cbiAgc2VyaWFsaXplKCkge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRNZXNzYWdlID0gdGhpcy5tZXNzYWdlLnNlcmlhbGl6ZSgpO1xuICAgIGNvbnN0IGVuY29kZWRTaWduYXR1cmVzTGVuZ3RoID0gQXJyYXkoKTtcbiAgICBlbmNvZGVMZW5ndGgoZW5jb2RlZFNpZ25hdHVyZXNMZW5ndGgsIHRoaXMuc2lnbmF0dXJlcy5sZW5ndGgpO1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uTGF5b3V0ID0gQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LmJsb2IoZW5jb2RlZFNpZ25hdHVyZXNMZW5ndGgubGVuZ3RoLCAnZW5jb2RlZFNpZ25hdHVyZXNMZW5ndGgnKSwgQnVmZmVyTGF5b3V0LnNlcShzaWduYXR1cmUoKSwgdGhpcy5zaWduYXR1cmVzLmxlbmd0aCwgJ3NpZ25hdHVyZXMnKSwgQnVmZmVyTGF5b3V0LmJsb2Ioc2VyaWFsaXplZE1lc3NhZ2UubGVuZ3RoLCAnc2VyaWFsaXplZE1lc3NhZ2UnKV0pO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRUcmFuc2FjdGlvbiA9IG5ldyBVaW50OEFycmF5KDIwNDgpO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRUcmFuc2FjdGlvbkxlbmd0aCA9IHRyYW5zYWN0aW9uTGF5b3V0LmVuY29kZSh7XG4gICAgICBlbmNvZGVkU2lnbmF0dXJlc0xlbmd0aDogbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZFNpZ25hdHVyZXNMZW5ndGgpLFxuICAgICAgc2lnbmF0dXJlczogdGhpcy5zaWduYXR1cmVzLFxuICAgICAgc2VyaWFsaXplZE1lc3NhZ2VcbiAgICB9LCBzZXJpYWxpemVkVHJhbnNhY3Rpb24pO1xuICAgIHJldHVybiBzZXJpYWxpemVkVHJhbnNhY3Rpb24uc2xpY2UoMCwgc2VyaWFsaXplZFRyYW5zYWN0aW9uTGVuZ3RoKTtcbiAgfVxuICBzdGF0aWMgZGVzZXJpYWxpemUoc2VyaWFsaXplZFRyYW5zYWN0aW9uKSB7XG4gICAgbGV0IGJ5dGVBcnJheSA9IFsuLi5zZXJpYWxpemVkVHJhbnNhY3Rpb25dO1xuICAgIGNvbnN0IHNpZ25hdHVyZXMgPSBbXTtcbiAgICBjb25zdCBzaWduYXR1cmVzTGVuZ3RoID0gZGVjb2RlTGVuZ3RoKGJ5dGVBcnJheSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaWduYXR1cmVzTGVuZ3RoOyBpKyspIHtcbiAgICAgIHNpZ25hdHVyZXMucHVzaChuZXcgVWludDhBcnJheShndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgU0lHTkFUVVJFX0xFTkdUSF9JTl9CWVRFUykpKTtcbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZSA9IFZlcnNpb25lZE1lc3NhZ2UuZGVzZXJpYWxpemUobmV3IFVpbnQ4QXJyYXkoYnl0ZUFycmF5KSk7XG4gICAgcmV0dXJuIG5ldyBWZXJzaW9uZWRUcmFuc2FjdGlvbihtZXNzYWdlLCBzaWduYXR1cmVzKTtcbiAgfVxuICBzaWduKHNpZ25lcnMpIHtcbiAgICBjb25zdCBtZXNzYWdlRGF0YSA9IHRoaXMubWVzc2FnZS5zZXJpYWxpemUoKTtcbiAgICBjb25zdCBzaWduZXJQdWJrZXlzID0gdGhpcy5tZXNzYWdlLnN0YXRpY0FjY291bnRLZXlzLnNsaWNlKDAsIHRoaXMubWVzc2FnZS5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzKTtcbiAgICBmb3IgKGNvbnN0IHNpZ25lciBvZiBzaWduZXJzKSB7XG4gICAgICBjb25zdCBzaWduZXJJbmRleCA9IHNpZ25lclB1YmtleXMuZmluZEluZGV4KHB1YmtleSA9PiBwdWJrZXkuZXF1YWxzKHNpZ25lci5wdWJsaWNLZXkpKTtcbiAgICAgIGFzc2VydChzaWduZXJJbmRleCA+PSAwLCBgQ2Fubm90IHNpZ24gd2l0aCBub24gc2lnbmVyIGtleSAke3NpZ25lci5wdWJsaWNLZXkudG9CYXNlNTgoKX1gKTtcbiAgICAgIHRoaXMuc2lnbmF0dXJlc1tzaWduZXJJbmRleF0gPSBzaWduKG1lc3NhZ2VEYXRhLCBzaWduZXIuc2VjcmV0S2V5KTtcbiAgICB9XG4gIH1cbiAgYWRkU2lnbmF0dXJlKHB1YmxpY0tleSwgc2lnbmF0dXJlKSB7XG4gICAgYXNzZXJ0KHNpZ25hdHVyZS5ieXRlTGVuZ3RoID09PSA2NCwgJ1NpZ25hdHVyZSBtdXN0IGJlIDY0IGJ5dGVzIGxvbmcnKTtcbiAgICBjb25zdCBzaWduZXJQdWJrZXlzID0gdGhpcy5tZXNzYWdlLnN0YXRpY0FjY291bnRLZXlzLnNsaWNlKDAsIHRoaXMubWVzc2FnZS5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzKTtcbiAgICBjb25zdCBzaWduZXJJbmRleCA9IHNpZ25lclB1YmtleXMuZmluZEluZGV4KHB1YmtleSA9PiBwdWJrZXkuZXF1YWxzKHB1YmxpY0tleSkpO1xuICAgIGFzc2VydChzaWduZXJJbmRleCA+PSAwLCBgQ2FuIG5vdCBhZGQgc2lnbmF0dXJlOyBcXGAke3B1YmxpY0tleS50b0Jhc2U1OCgpfVxcYCBpcyBub3QgcmVxdWlyZWQgdG8gc2lnbiB0aGlzIHRyYW5zYWN0aW9uYCk7XG4gICAgdGhpcy5zaWduYXR1cmVzW3NpZ25lckluZGV4XSA9IHNpZ25hdHVyZTtcbiAgfVxufVxuXG4vLyBUT0RPOiBUaGVzZSBjb25zdGFudHMgc2hvdWxkIGJlIHJlbW92ZWQgaW4gZmF2b3Igb2YgcmVhZGluZyB0aGVtIG91dCBvZiBhXG4vLyBTeXNjYWxsIGFjY291bnRcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgTlVNX1RJQ0tTX1BFUl9TRUNPTkQgPSAxNjA7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IERFRkFVTFRfVElDS1NfUEVSX1NMT1QgPSA2NDtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgTlVNX1NMT1RTX1BFUl9TRUNPTkQgPSBOVU1fVElDS1NfUEVSX1NFQ09ORCAvIERFRkFVTFRfVElDS1NfUEVSX1NMT1Q7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IE1TX1BFUl9TTE9UID0gMTAwMCAvIE5VTV9TTE9UU19QRVJfU0VDT05EO1xuXG5jb25zdCBTWVNWQVJfQ0xPQ0tfUFVCS0VZID0gbmV3IFB1YmxpY0tleSgnU3lzdmFyQzFvY2sxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuY29uc3QgU1lTVkFSX0VQT0NIX1NDSEVEVUxFX1BVQktFWSA9IG5ldyBQdWJsaWNLZXkoJ1N5c3ZhckVwb2NoU2NoZWR1MWUxMTExMTExMTExMTExMTExMTExMTExMTEnKTtcbmNvbnN0IFNZU1ZBUl9JTlNUUlVDVElPTlNfUFVCS0VZID0gbmV3IFB1YmxpY0tleSgnU3lzdmFyMW5zdHJ1Y3Rpb25zMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuY29uc3QgU1lTVkFSX1JFQ0VOVF9CTE9DS0hBU0hFU19QVUJLRVkgPSBuZXcgUHVibGljS2V5KCdTeXN2YXJSZWNlbnRCMW9ja0hhc2hlczExMTExMTExMTExMTExMTExMTExJyk7XG5jb25zdCBTWVNWQVJfUkVOVF9QVUJLRVkgPSBuZXcgUHVibGljS2V5KCdTeXN2YXJSZW50MTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5jb25zdCBTWVNWQVJfUkVXQVJEU19QVUJLRVkgPSBuZXcgUHVibGljS2V5KCdTeXN2YXJSZXdhcmRzMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5jb25zdCBTWVNWQVJfU0xPVF9IQVNIRVNfUFVCS0VZID0gbmV3IFB1YmxpY0tleSgnU3lzdmFyUzFvdEhhc2hlczExMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuY29uc3QgU1lTVkFSX1NMT1RfSElTVE9SWV9QVUJLRVkgPSBuZXcgUHVibGljS2V5KCdTeXN2YXJTMW90SGlzdG9yeTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5jb25zdCBTWVNWQVJfU1RBS0VfSElTVE9SWV9QVUJLRVkgPSBuZXcgUHVibGljS2V5KCdTeXN2YXJTdGFrZUhpc3RvcnkxMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5cbmNsYXNzIFNlbmRUcmFuc2FjdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgYWN0aW9uLFxuICAgIHNpZ25hdHVyZSxcbiAgICB0cmFuc2FjdGlvbk1lc3NhZ2UsXG4gICAgbG9nc1xuICB9KSB7XG4gICAgY29uc3QgbWF5YmVMb2dzT3V0cHV0ID0gbG9ncyA/IGBMb2dzOiBcXG4ke0pTT04uc3RyaW5naWZ5KGxvZ3Muc2xpY2UoLTEwKSwgbnVsbCwgMil9LiBgIDogJyc7XG4gICAgY29uc3QgZ3VpZGVUZXh0ID0gJ1xcbkNhdGNoIHRoZSBgU2VuZFRyYW5zYWN0aW9uRXJyb3JgIGFuZCBjYWxsIGBnZXRMb2dzKClgIG9uIGl0IGZvciBmdWxsIGRldGFpbHMuJztcbiAgICBsZXQgbWVzc2FnZTtcbiAgICBzd2l0Y2ggKGFjdGlvbikge1xuICAgICAgY2FzZSAnc2VuZCc6XG4gICAgICAgIG1lc3NhZ2UgPSBgVHJhbnNhY3Rpb24gJHtzaWduYXR1cmV9IHJlc3VsdGVkIGluIGFuIGVycm9yLiBcXG5gICsgYCR7dHJhbnNhY3Rpb25NZXNzYWdlfS4gYCArIG1heWJlTG9nc091dHB1dCArIGd1aWRlVGV4dDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzaW11bGF0ZSc6XG4gICAgICAgIG1lc3NhZ2UgPSBgU2ltdWxhdGlvbiBmYWlsZWQuIFxcbk1lc3NhZ2U6ICR7dHJhbnNhY3Rpb25NZXNzYWdlfS4gXFxuYCArIG1heWJlTG9nc091dHB1dCArIGd1aWRlVGV4dDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgbWVzc2FnZSA9IGBVbmtub3duIGFjdGlvbiAnJHsoYSA9PiBhKShhY3Rpb24pfSdgO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuc2lnbmF0dXJlID0gdm9pZCAwO1xuICAgIHRoaXMudHJhbnNhY3Rpb25NZXNzYWdlID0gdm9pZCAwO1xuICAgIHRoaXMudHJhbnNhY3Rpb25Mb2dzID0gdm9pZCAwO1xuICAgIHRoaXMuc2lnbmF0dXJlID0gc2lnbmF0dXJlO1xuICAgIHRoaXMudHJhbnNhY3Rpb25NZXNzYWdlID0gdHJhbnNhY3Rpb25NZXNzYWdlO1xuICAgIHRoaXMudHJhbnNhY3Rpb25Mb2dzID0gbG9ncyA/IGxvZ3MgOiB1bmRlZmluZWQ7XG4gIH1cbiAgZ2V0IHRyYW5zYWN0aW9uRXJyb3IoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1lc3NhZ2U6IHRoaXMudHJhbnNhY3Rpb25NZXNzYWdlLFxuICAgICAgbG9nczogQXJyYXkuaXNBcnJheSh0aGlzLnRyYW5zYWN0aW9uTG9ncykgPyB0aGlzLnRyYW5zYWN0aW9uTG9ncyA6IHVuZGVmaW5lZFxuICAgIH07XG4gIH1cblxuICAvKiBAZGVwcmVjYXRlZCBVc2UgYGF3YWl0IGdldExvZ3MoKWAgaW5zdGVhZCAqL1xuICBnZXQgbG9ncygpIHtcbiAgICBjb25zdCBjYWNoZWRMb2dzID0gdGhpcy50cmFuc2FjdGlvbkxvZ3M7XG4gICAgaWYgKGNhY2hlZExvZ3MgIT0gbnVsbCAmJiB0eXBlb2YgY2FjaGVkTG9ncyA9PT0gJ29iamVjdCcgJiYgJ3RoZW4nIGluIGNhY2hlZExvZ3MpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZWRMb2dzO1xuICB9XG4gIGFzeW5jIGdldExvZ3MoY29ubmVjdGlvbikge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0aGlzLnRyYW5zYWN0aW9uTG9ncykpIHtcbiAgICAgIHRoaXMudHJhbnNhY3Rpb25Mb2dzID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25uZWN0aW9uLmdldFRyYW5zYWN0aW9uKHRoaXMuc2lnbmF0dXJlKS50aGVuKHR4ID0+IHtcbiAgICAgICAgICBpZiAodHggJiYgdHgubWV0YSAmJiB0eC5tZXRhLmxvZ01lc3NhZ2VzKSB7XG4gICAgICAgICAgICBjb25zdCBsb2dzID0gdHgubWV0YS5sb2dNZXNzYWdlcztcbiAgICAgICAgICAgIHRoaXMudHJhbnNhY3Rpb25Mb2dzID0gbG9ncztcbiAgICAgICAgICAgIHJlc29sdmUobG9ncyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0xvZyBtZXNzYWdlcyBub3QgZm91bmQnKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zYWN0aW9uTG9ncztcbiAgfVxufVxuXG4vLyBLZWVwIGluIHN5bmMgd2l0aCBjbGllbnQvc3JjL3JwY19jdXN0b21fZXJyb3JzLnJzXG4vLyBUeXBlc2NyaXB0IGBlbnVtc2AgdGh3YXJ0IHRyZWUtc2hha2luZy4gU2VlIGh0dHBzOi8vYmFyZ3N0ZW4ub3JnL2pzdHMvZW51bXMvXG5jb25zdCBTb2xhbmFKU09OUlBDRXJyb3JDb2RlID0ge1xuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfQkxPQ0tfQ0xFQU5FRF9VUDogLTMyMDAxLFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfU0VORF9UUkFOU0FDVElPTl9QUkVGTElHSFRfRkFJTFVSRTogLTMyMDAyLFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fU0lHTkFUVVJFX1ZFUklGSUNBVElPTl9GQUlMVVJFOiAtMzIwMDMsXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9CTE9DS19OT1RfQVZBSUxBQkxFOiAtMzIwMDQsXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9OT0RFX1VOSEVBTFRIWTogLTMyMDA1LFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fUFJFQ09NUElMRV9WRVJJRklDQVRJT05fRkFJTFVSRTogLTMyMDA2LFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfU0xPVF9TS0lQUEVEOiAtMzIwMDcsXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9OT19TTkFQU0hPVDogLTMyMDA4LFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfTE9OR19URVJNX1NUT1JBR0VfU0xPVF9TS0lQUEVEOiAtMzIwMDksXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9LRVlfRVhDTFVERURfRlJPTV9TRUNPTkRBUllfSU5ERVg6IC0zMjAxMCxcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX0hJU1RPUllfTk9UX0FWQUlMQUJMRTogLTMyMDExLFxuICBKU09OX1JQQ19TQ0FOX0VSUk9SOiAtMzIwMTIsXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9TSUdOQVRVUkVfTEVOX01JU01BVENIOiAtMzIwMTMsXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9CTE9DS19TVEFUVVNfTk9UX0FWQUlMQUJMRV9ZRVQ6IC0zMjAxNCxcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX1VOU1VQUE9SVEVEX1RSQU5TQUNUSU9OX1ZFUlNJT046IC0zMjAxNSxcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX01JTl9DT05URVhUX1NMT1RfTk9UX1JFQUNIRUQ6IC0zMjAxNlxufTtcbmNsYXNzIFNvbGFuYUpTT05SUENFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGNvZGUsXG4gICAgbWVzc2FnZSxcbiAgICBkYXRhXG4gIH0sIGN1c3RvbU1lc3NhZ2UpIHtcbiAgICBzdXBlcihjdXN0b21NZXNzYWdlICE9IG51bGwgPyBgJHtjdXN0b21NZXNzYWdlfTogJHttZXNzYWdlfWAgOiBtZXNzYWdlKTtcbiAgICB0aGlzLmNvZGUgPSB2b2lkIDA7XG4gICAgdGhpcy5kYXRhID0gdm9pZCAwO1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLm5hbWUgPSAnU29sYW5hSlNPTlJQQ0Vycm9yJztcbiAgfVxufVxuXG4vKipcbiAqIFNpZ24sIHNlbmQgYW5kIGNvbmZpcm0gYSB0cmFuc2FjdGlvbi5cbiAqXG4gKiBJZiBgY29tbWl0bWVudGAgb3B0aW9uIGlzIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvICdtYXgnIGNvbW1pdG1lbnQuXG4gKlxuICogQHBhcmFtIHtDb25uZWN0aW9ufSBjb25uZWN0aW9uXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtBcnJheTxTaWduZXI+fSBzaWduZXJzXG4gKiBAcGFyYW0ge0NvbmZpcm1PcHRpb25zfSBbb3B0aW9uc11cbiAqIEByZXR1cm5zIHtQcm9taXNlPFRyYW5zYWN0aW9uU2lnbmF0dXJlPn1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gc2VuZEFuZENvbmZpcm1UcmFuc2FjdGlvbihjb25uZWN0aW9uLCB0cmFuc2FjdGlvbiwgc2lnbmVycywgb3B0aW9ucykge1xuICBjb25zdCBzZW5kT3B0aW9ucyA9IG9wdGlvbnMgJiYge1xuICAgIHNraXBQcmVmbGlnaHQ6IG9wdGlvbnMuc2tpcFByZWZsaWdodCxcbiAgICBwcmVmbGlnaHRDb21taXRtZW50OiBvcHRpb25zLnByZWZsaWdodENvbW1pdG1lbnQgfHwgb3B0aW9ucy5jb21taXRtZW50LFxuICAgIG1heFJldHJpZXM6IG9wdGlvbnMubWF4UmV0cmllcyxcbiAgICBtaW5Db250ZXh0U2xvdDogb3B0aW9ucy5taW5Db250ZXh0U2xvdFxuICB9O1xuICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBjb25uZWN0aW9uLnNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgc2lnbmVycywgc2VuZE9wdGlvbnMpO1xuICBsZXQgc3RhdHVzO1xuICBpZiAodHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoICE9IG51bGwgJiYgdHJhbnNhY3Rpb24ubGFzdFZhbGlkQmxvY2tIZWlnaHQgIT0gbnVsbCkge1xuICAgIHN0YXR1cyA9IChhd2FpdCBjb25uZWN0aW9uLmNvbmZpcm1UcmFuc2FjdGlvbih7XG4gICAgICBhYm9ydFNpZ25hbDogb3B0aW9ucz8uYWJvcnRTaWduYWwsXG4gICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZSxcbiAgICAgIGJsb2NraGFzaDogdHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoLFxuICAgICAgbGFzdFZhbGlkQmxvY2tIZWlnaHQ6IHRyYW5zYWN0aW9uLmxhc3RWYWxpZEJsb2NrSGVpZ2h0XG4gICAgfSwgb3B0aW9ucyAmJiBvcHRpb25zLmNvbW1pdG1lbnQpKS52YWx1ZTtcbiAgfSBlbHNlIGlmICh0cmFuc2FjdGlvbi5taW5Ob25jZUNvbnRleHRTbG90ICE9IG51bGwgJiYgdHJhbnNhY3Rpb24ubm9uY2VJbmZvICE9IG51bGwpIHtcbiAgICBjb25zdCB7XG4gICAgICBub25jZUluc3RydWN0aW9uXG4gICAgfSA9IHRyYW5zYWN0aW9uLm5vbmNlSW5mbztcbiAgICBjb25zdCBub25jZUFjY291bnRQdWJrZXkgPSBub25jZUluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5O1xuICAgIHN0YXR1cyA9IChhd2FpdCBjb25uZWN0aW9uLmNvbmZpcm1UcmFuc2FjdGlvbih7XG4gICAgICBhYm9ydFNpZ25hbDogb3B0aW9ucz8uYWJvcnRTaWduYWwsXG4gICAgICBtaW5Db250ZXh0U2xvdDogdHJhbnNhY3Rpb24ubWluTm9uY2VDb250ZXh0U2xvdCxcbiAgICAgIG5vbmNlQWNjb3VudFB1YmtleSxcbiAgICAgIG5vbmNlVmFsdWU6IHRyYW5zYWN0aW9uLm5vbmNlSW5mby5ub25jZSxcbiAgICAgIHNpZ25hdHVyZVxuICAgIH0sIG9wdGlvbnMgJiYgb3B0aW9ucy5jb21taXRtZW50KSkudmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgaWYgKG9wdGlvbnM/LmFib3J0U2lnbmFsICE9IG51bGwpIHtcbiAgICAgIGNvbnNvbGUud2Fybignc2VuZEFuZENvbmZpcm1UcmFuc2FjdGlvbigpOiBBIHRyYW5zYWN0aW9uIHdpdGggYSBkZXByZWNhdGVkIGNvbmZpcm1hdGlvbiBzdHJhdGVneSB3YXMgJyArICdzdXBwbGllZCBhbG9uZyB3aXRoIGFuIGBhYm9ydFNpZ25hbGAuIE9ubHkgdHJhbnNhY3Rpb25zIGhhdmluZyBgbGFzdFZhbGlkQmxvY2tIZWlnaHRgICcgKyAnb3IgYSBjb21iaW5hdGlvbiBvZiBgbm9uY2VJbmZvYCBhbmQgYG1pbk5vbmNlQ29udGV4dFNsb3RgIGFyZSBhYm9ydGFibGUuJyk7XG4gICAgfVxuICAgIHN0YXR1cyA9IChhd2FpdCBjb25uZWN0aW9uLmNvbmZpcm1UcmFuc2FjdGlvbihzaWduYXR1cmUsIG9wdGlvbnMgJiYgb3B0aW9ucy5jb21taXRtZW50KSkudmFsdWU7XG4gIH1cbiAgaWYgKHN0YXR1cy5lcnIpIHtcbiAgICBpZiAoc2lnbmF0dXJlICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBTZW5kVHJhbnNhY3Rpb25FcnJvcih7XG4gICAgICAgIGFjdGlvbjogJ3NlbmQnLFxuICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZSxcbiAgICAgICAgdHJhbnNhY3Rpb25NZXNzYWdlOiBgU3RhdHVzOiAoJHtKU09OLnN0cmluZ2lmeShzdGF0dXMpfSlgXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUcmFuc2FjdGlvbiAke3NpZ25hdHVyZX0gZmFpbGVkICgke0pTT04uc3RyaW5naWZ5KHN0YXR1cyl9KWApO1xuICB9XG4gIHJldHVybiBzaWduYXR1cmU7XG59XG5cbi8vIHp6elxuZnVuY3Rpb24gc2xlZXAobXMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBtcykpO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5cbi8qKlxuICogUG9wdWxhdGUgYSBidWZmZXIgb2YgaW5zdHJ1Y3Rpb24gZGF0YSB1c2luZyBhbiBJbnN0cnVjdGlvblR5cGVcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBlbmNvZGVEYXRhKHR5cGUsIGZpZWxkcykge1xuICBjb25zdCBhbGxvY0xlbmd0aCA9IHR5cGUubGF5b3V0LnNwYW4gPj0gMCA/IHR5cGUubGF5b3V0LnNwYW4gOiBnZXRBbGxvYyh0eXBlLCBmaWVsZHMpO1xuICBjb25zdCBkYXRhID0gQnVmZmVyLmFsbG9jKGFsbG9jTGVuZ3RoKTtcbiAgY29uc3QgbGF5b3V0RmllbGRzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgaW5zdHJ1Y3Rpb246IHR5cGUuaW5kZXhcbiAgfSwgZmllbGRzKTtcbiAgdHlwZS5sYXlvdXQuZW5jb2RlKGxheW91dEZpZWxkcywgZGF0YSk7XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIERlY29kZSBpbnN0cnVjdGlvbiBkYXRhIGJ1ZmZlciB1c2luZyBhbiBJbnN0cnVjdGlvblR5cGVcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBkZWNvZGVEYXRhJDEodHlwZSwgYnVmZmVyKSB7XG4gIGxldCBkYXRhO1xuICB0cnkge1xuICAgIGRhdGEgPSB0eXBlLmxheW91dC5kZWNvZGUoYnVmZmVyKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGluc3RydWN0aW9uOyAnICsgZXJyKTtcbiAgfVxuICBpZiAoZGF0YS5pbnN0cnVjdGlvbiAhPT0gdHlwZS5pbmRleCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBpbnN0cnVjdGlvbjsgaW5zdHJ1Y3Rpb24gaW5kZXggbWlzbWF0Y2ggJHtkYXRhLmluc3RydWN0aW9ufSAhPSAke3R5cGUuaW5kZXh9YCk7XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3NvbGFuYS1sYWJzL3NvbGFuYS9ibG9iLzkwYmVkZDdlMDY3YjViOGYzZGRiYjQ1ZGEwMGE0ZTljYWJiMjJjNjIvc2RrL3NyYy9mZWVfY2FsY3VsYXRvci5ycyNMNy1MMTFcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgRmVlQ2FsY3VsYXRvckxheW91dCA9IEJ1ZmZlckxheW91dC5udTY0KCdsYW1wb3J0c1BlclNpZ25hdHVyZScpO1xuXG4vKipcbiAqIENhbGN1bGF0b3IgZm9yIHRyYW5zYWN0aW9uIGZlZXMuXG4gKlxuICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBTb2xhbmEgdjEuOC4wLlxuICovXG5cbi8qKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2xhbmEtbGFicy9zb2xhbmEvYmxvYi8wZWEyODQzZWM5Y2RjNTE3NTcyYjhlNjJjOTU5ZjQxYjU1Y2Y0NDUzL3Nkay9zcmMvbm9uY2Vfc3RhdGUucnMjTDI5LUwzMlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBOb25jZUFjY291bnRMYXlvdXQgPSBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCd2ZXJzaW9uJyksIEJ1ZmZlckxheW91dC51MzIoJ3N0YXRlJyksIHB1YmxpY0tleSgnYXV0aG9yaXplZFB1YmtleScpLCBwdWJsaWNLZXkoJ25vbmNlJyksIEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0ZlZUNhbGN1bGF0b3JMYXlvdXRdLCAnZmVlQ2FsY3VsYXRvcicpXSk7XG5jb25zdCBOT05DRV9BQ0NPVU5UX0xFTkdUSCA9IE5vbmNlQWNjb3VudExheW91dC5zcGFuO1xuXG4vKipcbiAqIEEgZHVyYWJsZSBub25jZSBpcyBhIDMyIGJ5dGUgdmFsdWUgZW5jb2RlZCBhcyBhIGJhc2U1OCBzdHJpbmcuXG4gKi9cblxuLyoqXG4gKiBOb25jZUFjY291bnQgY2xhc3NcbiAqL1xuY2xhc3MgTm9uY2VBY2NvdW50IHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoYXJncykge1xuICAgIHRoaXMuYXV0aG9yaXplZFB1YmtleSA9IHZvaWQgMDtcbiAgICB0aGlzLm5vbmNlID0gdm9pZCAwO1xuICAgIHRoaXMuZmVlQ2FsY3VsYXRvciA9IHZvaWQgMDtcbiAgICB0aGlzLmF1dGhvcml6ZWRQdWJrZXkgPSBhcmdzLmF1dGhvcml6ZWRQdWJrZXk7XG4gICAgdGhpcy5ub25jZSA9IGFyZ3Mubm9uY2U7XG4gICAgdGhpcy5mZWVDYWxjdWxhdG9yID0gYXJncy5mZWVDYWxjdWxhdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIERlc2VyaWFsaXplIE5vbmNlQWNjb3VudCBmcm9tIHRoZSBhY2NvdW50IGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSBidWZmZXIgYWNjb3VudCBkYXRhXG4gICAqIEByZXR1cm4gTm9uY2VBY2NvdW50XG4gICAqL1xuICBzdGF0aWMgZnJvbUFjY291bnREYXRhKGJ1ZmZlcikge1xuICAgIGNvbnN0IG5vbmNlQWNjb3VudCA9IE5vbmNlQWNjb3VudExheW91dC5kZWNvZGUodG9CdWZmZXIoYnVmZmVyKSwgMCk7XG4gICAgcmV0dXJuIG5ldyBOb25jZUFjY291bnQoe1xuICAgICAgYXV0aG9yaXplZFB1YmtleTogbmV3IFB1YmxpY0tleShub25jZUFjY291bnQuYXV0aG9yaXplZFB1YmtleSksXG4gICAgICBub25jZTogbmV3IFB1YmxpY0tleShub25jZUFjY291bnQubm9uY2UpLnRvU3RyaW5nKCksXG4gICAgICBmZWVDYWxjdWxhdG9yOiBub25jZUFjY291bnQuZmVlQ2FsY3VsYXRvclxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHU2NChwcm9wZXJ0eSkge1xuICBjb25zdCBsYXlvdXQgPSBibG9iKDggLyogYnl0ZXMgKi8sIHByb3BlcnR5KTtcbiAgY29uc3QgZGVjb2RlID0gbGF5b3V0LmRlY29kZS5iaW5kKGxheW91dCk7XG4gIGNvbnN0IGVuY29kZSA9IGxheW91dC5lbmNvZGUuYmluZChsYXlvdXQpO1xuICBjb25zdCBiaWdJbnRMYXlvdXQgPSBsYXlvdXQ7XG4gIGNvbnN0IGNvZGVjID0gZ2V0VTY0Q29kZWMoKTtcbiAgYmlnSW50TGF5b3V0LmRlY29kZSA9IChidWZmZXIsIG9mZnNldCkgPT4ge1xuICAgIGNvbnN0IHNyYyA9IGRlY29kZShidWZmZXIsIG9mZnNldCk7XG4gICAgcmV0dXJuIGNvZGVjLmRlY29kZShzcmMpO1xuICB9O1xuICBiaWdJbnRMYXlvdXQuZW5jb2RlID0gKGJpZ0ludCwgYnVmZmVyLCBvZmZzZXQpID0+IHtcbiAgICBjb25zdCBzcmMgPSBjb2RlYy5lbmNvZGUoYmlnSW50KTtcbiAgICByZXR1cm4gZW5jb2RlKHNyYywgYnVmZmVyLCBvZmZzZXQpO1xuICB9O1xuICByZXR1cm4gYmlnSW50TGF5b3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhY2NvdW50IHN5c3RlbSB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIFRyYW5zZmVyIHN5c3RlbSB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIEFzc2lnbiBzeXN0ZW0gdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBDcmVhdGUgYWNjb3VudCB3aXRoIHNlZWQgc3lzdGVtIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogQ3JlYXRlIG5vbmNlIGFjY291bnQgc3lzdGVtIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogQ3JlYXRlIG5vbmNlIGFjY291bnQgd2l0aCBzZWVkIHN5c3RlbSB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIEluaXRpYWxpemUgbm9uY2UgYWNjb3VudCBzeXN0ZW0gaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBBZHZhbmNlIG5vbmNlIGFjY291bnQgc3lzdGVtIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogV2l0aGRyYXcgbm9uY2UgYWNjb3VudCBzeXN0ZW0gdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBBdXRob3JpemUgbm9uY2UgYWNjb3VudCBzeXN0ZW0gdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBBbGxvY2F0ZSBhY2NvdW50IHN5c3RlbSB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIEFsbG9jYXRlIGFjY291bnQgd2l0aCBzZWVkIHN5c3RlbSB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIEFzc2lnbiBhY2NvdW50IHdpdGggc2VlZCBzeXN0ZW0gdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBUcmFuc2ZlciB3aXRoIHNlZWQgc3lzdGVtIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKiBEZWNvZGVkIHRyYW5zZmVyIHN5c3RlbSB0cmFuc2FjdGlvbiBpbnN0cnVjdGlvbiAqL1xuXG4vKiogRGVjb2RlZCB0cmFuc2ZlcldpdGhTZWVkIHN5c3RlbSB0cmFuc2FjdGlvbiBpbnN0cnVjdGlvbiAqL1xuXG4vKipcbiAqIFN5c3RlbSBJbnN0cnVjdGlvbiBjbGFzc1xuICovXG5jbGFzcyBTeXN0ZW1JbnN0cnVjdGlvbiB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge31cblxuICAvKipcbiAgICogRGVjb2RlIGEgc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gdHlwZS5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVJbnN0cnVjdGlvblR5cGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25UeXBlTGF5b3V0ID0gQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKTtcbiAgICBjb25zdCB0eXBlSW5kZXggPSBpbnN0cnVjdGlvblR5cGVMYXlvdXQuZGVjb2RlKGluc3RydWN0aW9uLmRhdGEpO1xuICAgIGxldCB0eXBlO1xuICAgIGZvciAoY29uc3QgW2l4VHlwZSwgbGF5b3V0XSBvZiBPYmplY3QuZW50cmllcyhTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUykpIHtcbiAgICAgIGlmIChsYXlvdXQuaW5kZXggPT0gdHlwZUluZGV4KSB7XG4gICAgICAgIHR5cGUgPSBpeFR5cGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5zdHJ1Y3Rpb24gdHlwZSBpbmNvcnJlY3Q7IG5vdCBhIFN5c3RlbUluc3RydWN0aW9uJyk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIGNyZWF0ZSBhY2NvdW50IHN5c3RlbSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVDcmVhdGVBY2NvdW50KGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMik7XG4gICAgY29uc3Qge1xuICAgICAgbGFtcG9ydHMsXG4gICAgICBzcGFjZSxcbiAgICAgIHByb2dyYW1JZFxuICAgIH0gPSBkZWNvZGVEYXRhJDEoU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQ3JlYXRlLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgZnJvbVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBuZXdBY2NvdW50UHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICAgIGxhbXBvcnRzLFxuICAgICAgc3BhY2UsXG4gICAgICBwcm9ncmFtSWQ6IG5ldyBQdWJsaWNLZXkocHJvZ3JhbUlkKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgdHJhbnNmZXIgc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZVRyYW5zZmVyKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMik7XG4gICAgY29uc3Qge1xuICAgICAgbGFtcG9ydHNcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLlRyYW5zZmVyLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgZnJvbVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICB0b1B1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICBsYW1wb3J0c1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgdHJhbnNmZXIgd2l0aCBzZWVkIHN5c3RlbSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVUcmFuc2ZlcldpdGhTZWVkKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMyk7XG4gICAgY29uc3Qge1xuICAgICAgbGFtcG9ydHMsXG4gICAgICBzZWVkLFxuICAgICAgcHJvZ3JhbUlkXG4gICAgfSA9IGRlY29kZURhdGEkMShTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5UcmFuc2ZlcldpdGhTZWVkLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgZnJvbVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBiYXNlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICAgIHRvUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzJdLnB1YmtleSxcbiAgICAgIGxhbXBvcnRzLFxuICAgICAgc2VlZCxcbiAgICAgIHByb2dyYW1JZDogbmV3IFB1YmxpY0tleShwcm9ncmFtSWQpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYW4gYWxsb2NhdGUgc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZUFsbG9jYXRlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMSk7XG4gICAgY29uc3Qge1xuICAgICAgc3BhY2VcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkFsbG9jYXRlLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgYWNjb3VudFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBzcGFjZVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGFuIGFsbG9jYXRlIHdpdGggc2VlZCBzeXN0ZW0gaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlQWxsb2NhdGVXaXRoU2VlZChpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDEpO1xuICAgIGNvbnN0IHtcbiAgICAgIGJhc2UsXG4gICAgICBzZWVkLFxuICAgICAgc3BhY2UsXG4gICAgICBwcm9ncmFtSWRcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkFsbG9jYXRlV2l0aFNlZWQsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBhY2NvdW50UHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGJhc2VQdWJrZXk6IG5ldyBQdWJsaWNLZXkoYmFzZSksXG4gICAgICBzZWVkLFxuICAgICAgc3BhY2UsXG4gICAgICBwcm9ncmFtSWQ6IG5ldyBQdWJsaWNLZXkocHJvZ3JhbUlkKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGFuIGFzc2lnbiBzeXN0ZW0gaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlQXNzaWduKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMSk7XG4gICAgY29uc3Qge1xuICAgICAgcHJvZ3JhbUlkXG4gICAgfSA9IGRlY29kZURhdGEkMShTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5Bc3NpZ24sIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBhY2NvdW50UHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIHByb2dyYW1JZDogbmV3IFB1YmxpY0tleShwcm9ncmFtSWQpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYW4gYXNzaWduIHdpdGggc2VlZCBzeXN0ZW0gaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlQXNzaWduV2l0aFNlZWQoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAxKTtcbiAgICBjb25zdCB7XG4gICAgICBiYXNlLFxuICAgICAgc2VlZCxcbiAgICAgIHByb2dyYW1JZFxuICAgIH0gPSBkZWNvZGVEYXRhJDEoU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXNzaWduV2l0aFNlZWQsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBhY2NvdW50UHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGJhc2VQdWJrZXk6IG5ldyBQdWJsaWNLZXkoYmFzZSksXG4gICAgICBzZWVkLFxuICAgICAgcHJvZ3JhbUlkOiBuZXcgUHVibGljS2V5KHByb2dyYW1JZClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIGNyZWF0ZSBhY2NvdW50IHdpdGggc2VlZCBzeXN0ZW0gaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlQ3JlYXRlV2l0aFNlZWQoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAyKTtcbiAgICBjb25zdCB7XG4gICAgICBiYXNlLFxuICAgICAgc2VlZCxcbiAgICAgIGxhbXBvcnRzLFxuICAgICAgc3BhY2UsXG4gICAgICBwcm9ncmFtSWRcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkNyZWF0ZVdpdGhTZWVkLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgZnJvbVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBuZXdBY2NvdW50UHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICAgIGJhc2VQdWJrZXk6IG5ldyBQdWJsaWNLZXkoYmFzZSksXG4gICAgICBzZWVkLFxuICAgICAgbGFtcG9ydHMsXG4gICAgICBzcGFjZSxcbiAgICAgIHByb2dyYW1JZDogbmV3IFB1YmxpY0tleShwcm9ncmFtSWQpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBub25jZSBpbml0aWFsaXplIHN5c3RlbSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVOb25jZUluaXRpYWxpemUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAzKTtcbiAgICBjb25zdCB7XG4gICAgICBhdXRob3JpemVkXG4gICAgfSA9IGRlY29kZURhdGEkMShTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5Jbml0aWFsaXplTm9uY2VBY2NvdW50LCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgbm9uY2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleTogbmV3IFB1YmxpY0tleShhdXRob3JpemVkKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgbm9uY2UgYWR2YW5jZSBzeXN0ZW0gaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlTm9uY2VBZHZhbmNlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMyk7XG4gICAgZGVjb2RlRGF0YSQxKFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkFkdmFuY2VOb25jZUFjY291bnQsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBub25jZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzJdLnB1YmtleVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgbm9uY2Ugd2l0aGRyYXcgc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZU5vbmNlV2l0aGRyYXcoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCA1KTtcbiAgICBjb25zdCB7XG4gICAgICBsYW1wb3J0c1xuICAgIH0gPSBkZWNvZGVEYXRhJDEoU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuV2l0aGRyYXdOb25jZUFjY291bnQsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBub25jZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICB0b1B1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzRdLnB1YmtleSxcbiAgICAgIGxhbXBvcnRzXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBub25jZSBhdXRob3JpemUgc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZU5vbmNlQXV0aG9yaXplKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMik7XG4gICAgY29uc3Qge1xuICAgICAgYXV0aG9yaXplZFxuICAgIH0gPSBkZWNvZGVEYXRhJDEoU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXV0aG9yaXplTm9uY2VBY2NvdW50LCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgbm9uY2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICBuZXdBdXRob3JpemVkUHVia2V5OiBuZXcgUHVibGljS2V5KGF1dGhvcml6ZWQpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHN0YXRpYyBjaGVja1Byb2dyYW1JZChwcm9ncmFtSWQpIHtcbiAgICBpZiAoIXByb2dyYW1JZC5lcXVhbHMoU3lzdGVtUHJvZ3JhbS5wcm9ncmFtSWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5zdHJ1Y3Rpb247IHByb2dyYW1JZCBpcyBub3QgU3lzdGVtUHJvZ3JhbScpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHN0YXRpYyBjaGVja0tleUxlbmd0aChrZXlzLCBleHBlY3RlZExlbmd0aCkge1xuICAgIGlmIChrZXlzLmxlbmd0aCA8IGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgaW5zdHJ1Y3Rpb247IGZvdW5kICR7a2V5cy5sZW5ndGh9IGtleXMsIGV4cGVjdGVkIGF0IGxlYXN0ICR7ZXhwZWN0ZWRMZW5ndGh9YCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQW4gZW51bWVyYXRpb24gb2YgdmFsaWQgU3lzdGVtSW5zdHJ1Y3Rpb25UeXBlJ3NcbiAqL1xuXG4vKipcbiAqIEFuIGVudW1lcmF0aW9uIG9mIHZhbGlkIHN5c3RlbSBJbnN0cnVjdGlvblR5cGUnc1xuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTID0gT2JqZWN0LmZyZWV6ZSh7XG4gIENyZWF0ZToge1xuICAgIGluZGV4OiAwLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgQnVmZmVyTGF5b3V0Lm5zNjQoJ2xhbXBvcnRzJyksIEJ1ZmZlckxheW91dC5uczY0KCdzcGFjZScpLCBwdWJsaWNLZXkoJ3Byb2dyYW1JZCcpXSlcbiAgfSxcbiAgQXNzaWduOiB7XG4gICAgaW5kZXg6IDEsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBwdWJsaWNLZXkoJ3Byb2dyYW1JZCcpXSlcbiAgfSxcbiAgVHJhbnNmZXI6IHtcbiAgICBpbmRleDogMixcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIHU2NCgnbGFtcG9ydHMnKV0pXG4gIH0sXG4gIENyZWF0ZVdpdGhTZWVkOiB7XG4gICAgaW5kZXg6IDMsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBwdWJsaWNLZXkoJ2Jhc2UnKSwgcnVzdFN0cmluZygnc2VlZCcpLCBCdWZmZXJMYXlvdXQubnM2NCgnbGFtcG9ydHMnKSwgQnVmZmVyTGF5b3V0Lm5zNjQoJ3NwYWNlJyksIHB1YmxpY0tleSgncHJvZ3JhbUlkJyldKVxuICB9LFxuICBBZHZhbmNlTm9uY2VBY2NvdW50OiB7XG4gICAgaW5kZXg6IDQsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpXSlcbiAgfSxcbiAgV2l0aGRyYXdOb25jZUFjY291bnQ6IHtcbiAgICBpbmRleDogNSxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIEJ1ZmZlckxheW91dC5uczY0KCdsYW1wb3J0cycpXSlcbiAgfSxcbiAgSW5pdGlhbGl6ZU5vbmNlQWNjb3VudDoge1xuICAgIGluZGV4OiA2LFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgcHVibGljS2V5KCdhdXRob3JpemVkJyldKVxuICB9LFxuICBBdXRob3JpemVOb25jZUFjY291bnQ6IHtcbiAgICBpbmRleDogNyxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIHB1YmxpY0tleSgnYXV0aG9yaXplZCcpXSlcbiAgfSxcbiAgQWxsb2NhdGU6IHtcbiAgICBpbmRleDogOCxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIEJ1ZmZlckxheW91dC5uczY0KCdzcGFjZScpXSlcbiAgfSxcbiAgQWxsb2NhdGVXaXRoU2VlZDoge1xuICAgIGluZGV4OiA5LFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgcHVibGljS2V5KCdiYXNlJyksIHJ1c3RTdHJpbmcoJ3NlZWQnKSwgQnVmZmVyTGF5b3V0Lm5zNjQoJ3NwYWNlJyksIHB1YmxpY0tleSgncHJvZ3JhbUlkJyldKVxuICB9LFxuICBBc3NpZ25XaXRoU2VlZDoge1xuICAgIGluZGV4OiAxMCxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIHB1YmxpY0tleSgnYmFzZScpLCBydXN0U3RyaW5nKCdzZWVkJyksIHB1YmxpY0tleSgncHJvZ3JhbUlkJyldKVxuICB9LFxuICBUcmFuc2ZlcldpdGhTZWVkOiB7XG4gICAgaW5kZXg6IDExLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgdTY0KCdsYW1wb3J0cycpLCBydXN0U3RyaW5nKCdzZWVkJyksIHB1YmxpY0tleSgncHJvZ3JhbUlkJyldKVxuICB9LFxuICBVcGdyYWRlTm9uY2VBY2NvdW50OiB7XG4gICAgaW5kZXg6IDEyLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKV0pXG4gIH1cbn0pO1xuXG4vKipcbiAqIEZhY3RvcnkgY2xhc3MgZm9yIHRyYW5zYWN0aW9ucyB0byBpbnRlcmFjdCB3aXRoIHRoZSBTeXN0ZW0gcHJvZ3JhbVxuICovXG5jbGFzcyBTeXN0ZW1Qcm9ncmFtIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7fVxuXG4gIC8qKlxuICAgKiBQdWJsaWMga2V5IHRoYXQgaWRlbnRpZmllcyB0aGUgU3lzdGVtIHByb2dyYW1cbiAgICovXG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhbnNhY3Rpb24gaW5zdHJ1Y3Rpb24gdGhhdCBjcmVhdGVzIGEgbmV3IGFjY291bnRcbiAgICovXG4gIHN0YXRpYyBjcmVhdGVBY2NvdW50KHBhcmFtcykge1xuICAgIGNvbnN0IHR5cGUgPSBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5DcmVhdGU7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgbGFtcG9ydHM6IHBhcmFtcy5sYW1wb3J0cyxcbiAgICAgIHNwYWNlOiBwYXJhbXMuc3BhY2UsXG4gICAgICBwcm9ncmFtSWQ6IHRvQnVmZmVyKHBhcmFtcy5wcm9ncmFtSWQudG9CdWZmZXIoKSlcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5czogW3tcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuZnJvbVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBwYXJhbXMubmV3QWNjb3VudFB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH1dLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIGluc3RydWN0aW9uIHRoYXQgdHJhbnNmZXJzIGxhbXBvcnRzIGZyb20gb25lIGFjY291bnQgdG8gYW5vdGhlclxuICAgKi9cbiAgc3RhdGljIHRyYW5zZmVyKHBhcmFtcykge1xuICAgIGxldCBkYXRhO1xuICAgIGxldCBrZXlzO1xuICAgIGlmICgnYmFzZVB1YmtleScgaW4gcGFyYW1zKSB7XG4gICAgICBjb25zdCB0eXBlID0gU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuVHJhbnNmZXJXaXRoU2VlZDtcbiAgICAgIGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgICAgbGFtcG9ydHM6IEJpZ0ludChwYXJhbXMubGFtcG9ydHMpLFxuICAgICAgICBzZWVkOiBwYXJhbXMuc2VlZCxcbiAgICAgICAgcHJvZ3JhbUlkOiB0b0J1ZmZlcihwYXJhbXMucHJvZ3JhbUlkLnRvQnVmZmVyKCkpXG4gICAgICB9KTtcbiAgICAgIGtleXMgPSBbe1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5mcm9tUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuYmFzZVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLnRvUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH1dO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0eXBlID0gU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuVHJhbnNmZXI7XG4gICAgICBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICAgIGxhbXBvcnRzOiBCaWdJbnQocGFyYW1zLmxhbXBvcnRzKVxuICAgICAgfSk7XG4gICAgICBrZXlzID0gW3tcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuZnJvbVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBwYXJhbXMudG9QdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfV07XG4gICAgfVxuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBrZXlzLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIGluc3RydWN0aW9uIHRoYXQgYXNzaWducyBhbiBhY2NvdW50IHRvIGEgcHJvZ3JhbVxuICAgKi9cbiAgc3RhdGljIGFzc2lnbihwYXJhbXMpIHtcbiAgICBsZXQgZGF0YTtcbiAgICBsZXQga2V5cztcbiAgICBpZiAoJ2Jhc2VQdWJrZXknIGluIHBhcmFtcykge1xuICAgICAgY29uc3QgdHlwZSA9IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkFzc2lnbldpdGhTZWVkO1xuICAgICAgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgICBiYXNlOiB0b0J1ZmZlcihwYXJhbXMuYmFzZVB1YmtleS50b0J1ZmZlcigpKSxcbiAgICAgICAgc2VlZDogcGFyYW1zLnNlZWQsXG4gICAgICAgIHByb2dyYW1JZDogdG9CdWZmZXIocGFyYW1zLnByb2dyYW1JZC50b0J1ZmZlcigpKVxuICAgICAgfSk7XG4gICAgICBrZXlzID0gW3tcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuYWNjb3VudFB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLmJhc2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5Bc3NpZ247XG4gICAgICBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICAgIHByb2dyYW1JZDogdG9CdWZmZXIocGFyYW1zLnByb2dyYW1JZC50b0J1ZmZlcigpKVxuICAgICAgfSk7XG4gICAgICBrZXlzID0gW3tcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuYWNjb3VudFB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH1dO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5cyxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiBpbnN0cnVjdGlvbiB0aGF0IGNyZWF0ZXMgYSBuZXcgYWNjb3VudCBhdFxuICAgKiAgIGFuIGFkZHJlc3MgZ2VuZXJhdGVkIHdpdGggYGZyb21gLCBhIHNlZWQsIGFuZCBwcm9ncmFtSWRcbiAgICovXG4gIHN0YXRpYyBjcmVhdGVBY2NvdW50V2l0aFNlZWQocGFyYW1zKSB7XG4gICAgY29uc3QgdHlwZSA9IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkNyZWF0ZVdpdGhTZWVkO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIGJhc2U6IHRvQnVmZmVyKHBhcmFtcy5iYXNlUHVia2V5LnRvQnVmZmVyKCkpLFxuICAgICAgc2VlZDogcGFyYW1zLnNlZWQsXG4gICAgICBsYW1wb3J0czogcGFyYW1zLmxhbXBvcnRzLFxuICAgICAgc3BhY2U6IHBhcmFtcy5zcGFjZSxcbiAgICAgIHByb2dyYW1JZDogdG9CdWZmZXIocGFyYW1zLnByb2dyYW1JZC50b0J1ZmZlcigpKVxuICAgIH0pO1xuICAgIGxldCBrZXlzID0gW3tcbiAgICAgIHB1YmtleTogcGFyYW1zLmZyb21QdWJrZXksXG4gICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IHBhcmFtcy5uZXdBY2NvdW50UHVia2V5LFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH1dO1xuICAgIGlmICghcGFyYW1zLmJhc2VQdWJrZXkuZXF1YWxzKHBhcmFtcy5mcm9tUHVia2V5KSkge1xuICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuYmFzZVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhbnNhY3Rpb24gdGhhdCBjcmVhdGVzIGEgbmV3IE5vbmNlIGFjY291bnRcbiAgICovXG4gIHN0YXRpYyBjcmVhdGVOb25jZUFjY291bnQocGFyYW1zKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICBpZiAoJ2Jhc2VQdWJrZXknIGluIHBhcmFtcyAmJiAnc2VlZCcgaW4gcGFyYW1zKSB7XG4gICAgICB0cmFuc2FjdGlvbi5hZGQoU3lzdGVtUHJvZ3JhbS5jcmVhdGVBY2NvdW50V2l0aFNlZWQoe1xuICAgICAgICBmcm9tUHVia2V5OiBwYXJhbXMuZnJvbVB1YmtleSxcbiAgICAgICAgbmV3QWNjb3VudFB1YmtleTogcGFyYW1zLm5vbmNlUHVia2V5LFxuICAgICAgICBiYXNlUHVia2V5OiBwYXJhbXMuYmFzZVB1YmtleSxcbiAgICAgICAgc2VlZDogcGFyYW1zLnNlZWQsXG4gICAgICAgIGxhbXBvcnRzOiBwYXJhbXMubGFtcG9ydHMsXG4gICAgICAgIHNwYWNlOiBOT05DRV9BQ0NPVU5UX0xFTkdUSCxcbiAgICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZFxuICAgICAgfSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmFuc2FjdGlvbi5hZGQoU3lzdGVtUHJvZ3JhbS5jcmVhdGVBY2NvdW50KHtcbiAgICAgICAgZnJvbVB1YmtleTogcGFyYW1zLmZyb21QdWJrZXksXG4gICAgICAgIG5ld0FjY291bnRQdWJrZXk6IHBhcmFtcy5ub25jZVB1YmtleSxcbiAgICAgICAgbGFtcG9ydHM6IHBhcmFtcy5sYW1wb3J0cyxcbiAgICAgICAgc3BhY2U6IE5PTkNFX0FDQ09VTlRfTEVOR1RILFxuICAgICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkXG4gICAgICB9KSk7XG4gICAgfVxuICAgIGNvbnN0IGluaXRQYXJhbXMgPSB7XG4gICAgICBub25jZVB1YmtleTogcGFyYW1zLm5vbmNlUHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleTogcGFyYW1zLmF1dGhvcml6ZWRQdWJrZXlcbiAgICB9O1xuICAgIHRyYW5zYWN0aW9uLmFkZCh0aGlzLm5vbmNlSW5pdGlhbGl6ZShpbml0UGFyYW1zKSk7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGFuIGluc3RydWN0aW9uIHRvIGluaXRpYWxpemUgYSBOb25jZSBhY2NvdW50XG4gICAqL1xuICBzdGF0aWMgbm9uY2VJbml0aWFsaXplKHBhcmFtcykge1xuICAgIGNvbnN0IHR5cGUgPSBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5Jbml0aWFsaXplTm9uY2VBY2NvdW50O1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIGF1dGhvcml6ZWQ6IHRvQnVmZmVyKHBhcmFtcy5hdXRob3JpemVkUHVia2V5LnRvQnVmZmVyKCkpXG4gICAgfSk7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25EYXRhID0ge1xuICAgICAga2V5czogW3tcbiAgICAgICAgcHVia2V5OiBwYXJhbXMubm9uY2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IFNZU1ZBUl9SRUNFTlRfQkxPQ0tIQVNIRVNfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1lTVkFSX1JFTlRfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9XSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb25EYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhbiBpbnN0cnVjdGlvbiB0byBhZHZhbmNlIHRoZSBub25jZSBpbiBhIE5vbmNlIGFjY291bnRcbiAgICovXG4gIHN0YXRpYyBub25jZUFkdmFuY2UocGFyYW1zKSB7XG4gICAgY29uc3QgdHlwZSA9IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkFkdmFuY2VOb25jZUFjY291bnQ7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSk7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25EYXRhID0ge1xuICAgICAga2V5czogW3tcbiAgICAgICAgcHVia2V5OiBwYXJhbXMubm9uY2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IFNZU1ZBUl9SRUNFTlRfQkxPQ0tIQVNIRVNfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLmF1dGhvcml6ZWRQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfV0sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH07XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKGluc3RydWN0aW9uRGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiBpbnN0cnVjdGlvbiB0aGF0IHdpdGhkcmF3cyBsYW1wb3J0cyBmcm9tIGEgTm9uY2UgYWNjb3VudFxuICAgKi9cbiAgc3RhdGljIG5vbmNlV2l0aGRyYXcocGFyYW1zKSB7XG4gICAgY29uc3QgdHlwZSA9IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLldpdGhkcmF3Tm9uY2VBY2NvdW50O1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIGxhbXBvcnRzOiBwYXJhbXMubGFtcG9ydHNcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5czogW3tcbiAgICAgICAgcHVia2V5OiBwYXJhbXMubm9uY2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy50b1B1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1lTVkFSX1JFQ0VOVF9CTE9DS0hBU0hFU19QVUJLRVksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBTWVNWQVJfUkVOVF9QVUJLRVksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuYXV0aG9yaXplZFB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9XSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiBpbnN0cnVjdGlvbiB0aGF0IGF1dGhvcml6ZXMgYSBuZXcgUHVibGljS2V5IGFzIHRoZSBhdXRob3JpdHlcbiAgICogb24gYSBOb25jZSBhY2NvdW50LlxuICAgKi9cbiAgc3RhdGljIG5vbmNlQXV0aG9yaXplKHBhcmFtcykge1xuICAgIGNvbnN0IHR5cGUgPSBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5BdXRob3JpemVOb25jZUFjY291bnQ7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgYXV0aG9yaXplZDogdG9CdWZmZXIocGFyYW1zLm5ld0F1dGhvcml6ZWRQdWJrZXkudG9CdWZmZXIoKSlcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5czogW3tcbiAgICAgICAgcHVia2V5OiBwYXJhbXMubm9uY2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5hdXRob3JpemVkUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH1dLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIGluc3RydWN0aW9uIHRoYXQgYWxsb2NhdGVzIHNwYWNlIGluIGFuIGFjY291bnQgd2l0aG91dCBmdW5kaW5nXG4gICAqL1xuICBzdGF0aWMgYWxsb2NhdGUocGFyYW1zKSB7XG4gICAgbGV0IGRhdGE7XG4gICAgbGV0IGtleXM7XG4gICAgaWYgKCdiYXNlUHVia2V5JyBpbiBwYXJhbXMpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5BbGxvY2F0ZVdpdGhTZWVkO1xuICAgICAgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgICBiYXNlOiB0b0J1ZmZlcihwYXJhbXMuYmFzZVB1YmtleS50b0J1ZmZlcigpKSxcbiAgICAgICAgc2VlZDogcGFyYW1zLnNlZWQsXG4gICAgICAgIHNwYWNlOiBwYXJhbXMuc3BhY2UsXG4gICAgICAgIHByb2dyYW1JZDogdG9CdWZmZXIocGFyYW1zLnByb2dyYW1JZC50b0J1ZmZlcigpKVxuICAgICAgfSk7XG4gICAgICBrZXlzID0gW3tcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuYWNjb3VudFB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLmJhc2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5BbGxvY2F0ZTtcbiAgICAgIGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgICAgc3BhY2U6IHBhcmFtcy5zcGFjZVxuICAgICAgfSk7XG4gICAgICBrZXlzID0gW3tcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuYWNjb3VudFB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH1dO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5cyxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cbn1cblN5c3RlbVByb2dyYW0ucHJvZ3JhbUlkID0gbmV3IFB1YmxpY0tleSgnMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcblxuLy8gS2VlcCBwcm9ncmFtIGNodW5rcyB1bmRlciBQQUNLRVRfREFUQV9TSVpFLCBsZWF2aW5nIGVub3VnaCByb29tIGZvciB0aGVcbi8vIHJlc3Qgb2YgdGhlIFRyYW5zYWN0aW9uIGZpZWxkc1xuLy9cbi8vIFRPRE86IHJlcGxhY2UgMzAwIHdpdGggYSBwcm9wZXIgY29uc3RhbnQgZm9yIHRoZSBzaXplIG9mIHRoZSBvdGhlclxuLy8gVHJhbnNhY3Rpb24gZmllbGRzXG5jb25zdCBDSFVOS19TSVpFID0gUEFDS0VUX0RBVEFfU0laRSAtIDMwMDtcblxuLyoqXG4gKiBQcm9ncmFtIGxvYWRlciBpbnRlcmZhY2VcbiAqL1xuY2xhc3MgTG9hZGVyIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7fVxuXG4gIC8qKlxuICAgKiBBbW91bnQgb2YgcHJvZ3JhbSBkYXRhIHBsYWNlZCBpbiBlYWNoIGxvYWQgVHJhbnNhY3Rpb25cbiAgICovXG5cbiAgLyoqXG4gICAqIE1pbmltdW0gbnVtYmVyIG9mIHNpZ25hdHVyZXMgcmVxdWlyZWQgdG8gbG9hZCBhIHByb2dyYW0gbm90IGluY2x1ZGluZ1xuICAgKiByZXRyaWVzXG4gICAqXG4gICAqIENhbiBiZSB1c2VkIHRvIGNhbGN1bGF0ZSB0cmFuc2FjdGlvbiBmZWVzXG4gICAqL1xuICBzdGF0aWMgZ2V0TWluTnVtU2lnbmF0dXJlcyhkYXRhTGVuZ3RoKSB7XG4gICAgcmV0dXJuIDIgKiAoXG4gICAgLy8gRXZlcnkgdHJhbnNhY3Rpb24gcmVxdWlyZXMgdHdvIHNpZ25hdHVyZXMgKHBheWVyICsgcHJvZ3JhbSlcbiAgICBNYXRoLmNlaWwoZGF0YUxlbmd0aCAvIExvYWRlci5jaHVua1NpemUpICsgMSArXG4gICAgLy8gQWRkIG9uZSBmb3IgQ3JlYXRlIHRyYW5zYWN0aW9uXG4gICAgMSkgLy8gQWRkIG9uZSBmb3IgRmluYWxpemUgdHJhbnNhY3Rpb25cbiAgICA7XG4gIH1cblxuICAvKipcbiAgICogTG9hZHMgYSBnZW5lcmljIHByb2dyYW1cbiAgICpcbiAgICogQHBhcmFtIGNvbm5lY3Rpb24gVGhlIGNvbm5lY3Rpb24gdG8gdXNlXG4gICAqIEBwYXJhbSBwYXllciBTeXN0ZW0gYWNjb3VudCB0aGF0IHBheXMgdG8gbG9hZCB0aGUgcHJvZ3JhbVxuICAgKiBAcGFyYW0gcHJvZ3JhbSBBY2NvdW50IHRvIGxvYWQgdGhlIHByb2dyYW0gaW50b1xuICAgKiBAcGFyYW0gcHJvZ3JhbUlkIFB1YmxpYyBrZXkgdGhhdCBpZGVudGlmaWVzIHRoZSBsb2FkZXJcbiAgICogQHBhcmFtIGRhdGEgUHJvZ3JhbSBvY3RldHNcbiAgICogQHJldHVybiB0cnVlIGlmIHByb2dyYW0gd2FzIGxvYWRlZCBzdWNjZXNzZnVsbHksIGZhbHNlIGlmIHByb2dyYW0gd2FzIGFscmVhZHkgbG9hZGVkXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgbG9hZChjb25uZWN0aW9uLCBwYXllciwgcHJvZ3JhbSwgcHJvZ3JhbUlkLCBkYXRhKSB7XG4gICAge1xuICAgICAgY29uc3QgYmFsYW5jZU5lZWRlZCA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0TWluaW11bUJhbGFuY2VGb3JSZW50RXhlbXB0aW9uKGRhdGEubGVuZ3RoKTtcblxuICAgICAgLy8gRmV0Y2ggcHJvZ3JhbSBhY2NvdW50IGluZm8gdG8gY2hlY2sgaWYgaXQgaGFzIGFscmVhZHkgYmVlbiBjcmVhdGVkXG4gICAgICBjb25zdCBwcm9ncmFtSW5mbyA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0QWNjb3VudEluZm8ocHJvZ3JhbS5wdWJsaWNLZXksICdjb25maXJtZWQnKTtcbiAgICAgIGxldCB0cmFuc2FjdGlvbiA9IG51bGw7XG4gICAgICBpZiAocHJvZ3JhbUluZm8gIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHByb2dyYW1JbmZvLmV4ZWN1dGFibGUpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdQcm9ncmFtIGxvYWQgZmFpbGVkLCBhY2NvdW50IGlzIGFscmVhZHkgZXhlY3V0YWJsZScpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvZ3JhbUluZm8uZGF0YS5sZW5ndGggIT09IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgdHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbiB8fCBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICAgICAgICB0cmFuc2FjdGlvbi5hZGQoU3lzdGVtUHJvZ3JhbS5hbGxvY2F0ZSh7XG4gICAgICAgICAgICBhY2NvdW50UHVia2V5OiBwcm9ncmFtLnB1YmxpY0tleSxcbiAgICAgICAgICAgIHNwYWNlOiBkYXRhLmxlbmd0aFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXByb2dyYW1JbmZvLm93bmVyLmVxdWFscyhwcm9ncmFtSWQpKSB7XG4gICAgICAgICAgdHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbiB8fCBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICAgICAgICB0cmFuc2FjdGlvbi5hZGQoU3lzdGVtUHJvZ3JhbS5hc3NpZ24oe1xuICAgICAgICAgICAgYWNjb3VudFB1YmtleTogcHJvZ3JhbS5wdWJsaWNLZXksXG4gICAgICAgICAgICBwcm9ncmFtSWRcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2dyYW1JbmZvLmxhbXBvcnRzIDwgYmFsYW5jZU5lZWRlZCkge1xuICAgICAgICAgIHRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb24gfHwgbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgICAgICAgdHJhbnNhY3Rpb24uYWRkKFN5c3RlbVByb2dyYW0udHJhbnNmZXIoe1xuICAgICAgICAgICAgZnJvbVB1YmtleTogcGF5ZXIucHVibGljS2V5LFxuICAgICAgICAgICAgdG9QdWJrZXk6IHByb2dyYW0ucHVibGljS2V5LFxuICAgICAgICAgICAgbGFtcG9ydHM6IGJhbGFuY2VOZWVkZWQgLSBwcm9ncmFtSW5mby5sYW1wb3J0c1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoU3lzdGVtUHJvZ3JhbS5jcmVhdGVBY2NvdW50KHtcbiAgICAgICAgICBmcm9tUHVia2V5OiBwYXllci5wdWJsaWNLZXksXG4gICAgICAgICAgbmV3QWNjb3VudFB1YmtleTogcHJvZ3JhbS5wdWJsaWNLZXksXG4gICAgICAgICAgbGFtcG9ydHM6IGJhbGFuY2VOZWVkZWQgPiAwID8gYmFsYW5jZU5lZWRlZCA6IDEsXG4gICAgICAgICAgc3BhY2U6IGRhdGEubGVuZ3RoLFxuICAgICAgICAgIHByb2dyYW1JZFxuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBhY2NvdW50IGlzIGFscmVhZHkgY3JlYXRlZCBjb3JyZWN0bHksIHNraXAgdGhpcyBzdGVwXG4gICAgICAvLyBhbmQgcHJvY2VlZCBkaXJlY3RseSB0byBsb2FkaW5nIGluc3RydWN0aW9uc1xuICAgICAgaWYgKHRyYW5zYWN0aW9uICE9PSBudWxsKSB7XG4gICAgICAgIGF3YWl0IHNlbmRBbmRDb25maXJtVHJhbnNhY3Rpb24oY29ubmVjdGlvbiwgdHJhbnNhY3Rpb24sIFtwYXllciwgcHJvZ3JhbV0sIHtcbiAgICAgICAgICBjb21taXRtZW50OiAnY29uZmlybWVkJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZGF0YUxheW91dCA9IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIEJ1ZmZlckxheW91dC51MzIoJ29mZnNldCcpLCBCdWZmZXJMYXlvdXQudTMyKCdieXRlc0xlbmd0aCcpLCBCdWZmZXJMYXlvdXQudTMyKCdieXRlc0xlbmd0aFBhZGRpbmcnKSwgQnVmZmVyTGF5b3V0LnNlcShCdWZmZXJMYXlvdXQudTgoJ2J5dGUnKSwgQnVmZmVyTGF5b3V0Lm9mZnNldChCdWZmZXJMYXlvdXQudTMyKCksIC04KSwgJ2J5dGVzJyldKTtcbiAgICBjb25zdCBjaHVua1NpemUgPSBMb2FkZXIuY2h1bmtTaXplO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGxldCBhcnJheSA9IGRhdGE7XG4gICAgbGV0IHRyYW5zYWN0aW9ucyA9IFtdO1xuICAgIHdoaWxlIChhcnJheS5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBieXRlcyA9IGFycmF5LnNsaWNlKDAsIGNodW5rU2l6ZSk7XG4gICAgICBjb25zdCBkYXRhID0gQnVmZmVyLmFsbG9jKGNodW5rU2l6ZSArIDE2KTtcbiAgICAgIGRhdGFMYXlvdXQuZW5jb2RlKHtcbiAgICAgICAgaW5zdHJ1Y3Rpb246IDAsXG4gICAgICAgIC8vIExvYWQgaW5zdHJ1Y3Rpb25cbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICBieXRlczogYnl0ZXMsXG4gICAgICAgIGJ5dGVzTGVuZ3RoOiAwLFxuICAgICAgICBieXRlc0xlbmd0aFBhZGRpbmc6IDBcbiAgICAgIH0sIGRhdGEpO1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoe1xuICAgICAgICBrZXlzOiBbe1xuICAgICAgICAgIHB1YmtleTogcHJvZ3JhbS5wdWJsaWNLZXksXG4gICAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgICB9XSxcbiAgICAgICAgcHJvZ3JhbUlkLFxuICAgICAgICBkYXRhXG4gICAgICB9KTtcbiAgICAgIHRyYW5zYWN0aW9ucy5wdXNoKHNlbmRBbmRDb25maXJtVHJhbnNhY3Rpb24oY29ubmVjdGlvbiwgdHJhbnNhY3Rpb24sIFtwYXllciwgcHJvZ3JhbV0sIHtcbiAgICAgICAgY29tbWl0bWVudDogJ2NvbmZpcm1lZCdcbiAgICAgIH0pKTtcblxuICAgICAgLy8gRGVsYXkgYmV0d2VlbiBzZW5kcyBpbiBhbiBhdHRlbXB0IHRvIHJlZHVjZSByYXRlIGxpbWl0IGVycm9yc1xuICAgICAgaWYgKGNvbm5lY3Rpb24uX3JwY0VuZHBvaW50LmluY2x1ZGVzKCdzb2xhbmEuY29tJykpIHtcbiAgICAgICAgY29uc3QgUkVRVUVTVFNfUEVSX1NFQ09ORCA9IDQ7XG4gICAgICAgIGF3YWl0IHNsZWVwKDEwMDAgLyBSRVFVRVNUU19QRVJfU0VDT05EKTtcbiAgICAgIH1cbiAgICAgIG9mZnNldCArPSBjaHVua1NpemU7XG4gICAgICBhcnJheSA9IGFycmF5LnNsaWNlKGNodW5rU2l6ZSk7XG4gICAgfVxuICAgIGF3YWl0IFByb21pc2UuYWxsKHRyYW5zYWN0aW9ucyk7XG5cbiAgICAvLyBGaW5hbGl6ZSB0aGUgYWNjb3VudCBsb2FkZWQgd2l0aCBwcm9ncmFtIGRhdGEgZm9yIGV4ZWN1dGlvblxuICAgIHtcbiAgICAgIGNvbnN0IGRhdGFMYXlvdXQgPSBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpXSk7XG4gICAgICBjb25zdCBkYXRhID0gQnVmZmVyLmFsbG9jKGRhdGFMYXlvdXQuc3Bhbik7XG4gICAgICBkYXRhTGF5b3V0LmVuY29kZSh7XG4gICAgICAgIGluc3RydWN0aW9uOiAxIC8vIEZpbmFsaXplIGluc3RydWN0aW9uXG4gICAgICB9LCBkYXRhKTtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgICAga2V5czogW3tcbiAgICAgICAgICBwdWJrZXk6IHByb2dyYW0ucHVibGljS2V5LFxuICAgICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgICAgfSwge1xuICAgICAgICAgIHB1YmtleTogU1lTVkFSX1JFTlRfUFVCS0VZLFxuICAgICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgICB9XSxcbiAgICAgICAgcHJvZ3JhbUlkLFxuICAgICAgICBkYXRhXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGRlcGxveUNvbW1pdG1lbnQgPSAncHJvY2Vzc2VkJztcbiAgICAgIGNvbnN0IGZpbmFsaXplU2lnbmF0dXJlID0gYXdhaXQgY29ubmVjdGlvbi5zZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIFtwYXllciwgcHJvZ3JhbV0sIHtcbiAgICAgICAgcHJlZmxpZ2h0Q29tbWl0bWVudDogZGVwbG95Q29tbWl0bWVudFxuICAgICAgfSk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIHZhbHVlXG4gICAgICB9ID0gYXdhaXQgY29ubmVjdGlvbi5jb25maXJtVHJhbnNhY3Rpb24oe1xuICAgICAgICBzaWduYXR1cmU6IGZpbmFsaXplU2lnbmF0dXJlLFxuICAgICAgICBsYXN0VmFsaWRCbG9ja0hlaWdodDogdHJhbnNhY3Rpb24ubGFzdFZhbGlkQmxvY2tIZWlnaHQsXG4gICAgICAgIGJsb2NraGFzaDogdHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoXG4gICAgICB9LCBkZXBsb3lDb21taXRtZW50KTtcbiAgICAgIGlmICh2YWx1ZS5lcnIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUcmFuc2FjdGlvbiAke2ZpbmFsaXplU2lnbmF0dXJlfSBmYWlsZWQgKCR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfSlgKTtcbiAgICAgIH1cbiAgICAgIC8vIFdlIHByZXZlbnQgcHJvZ3JhbXMgZnJvbSBiZWluZyB1c2FibGUgdW50aWwgdGhlIHNsb3QgYWZ0ZXIgdGhlaXIgZGVwbG95bWVudC5cbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vc29sYW5hLWxhYnMvc29sYW5hL3B1bGwvMjk2NTRcbiAgICAgIHdoaWxlICh0cnVlIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gICAgICApIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBjdXJyZW50U2xvdCA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0U2xvdCh7XG4gICAgICAgICAgICBjb21taXRtZW50OiBkZXBsb3lDb21taXRtZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGN1cnJlbnRTbG90ID4gY29udGV4dC5zbG90KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIC8qIGVtcHR5ICovXG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIE1hdGgucm91bmQoTVNfUEVSX1NMT1QgLyAyKSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHN1Y2Nlc3NcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuTG9hZGVyLmNodW5rU2l6ZSA9IENIVU5LX1NJWkU7XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBTb2xhbmEgdjEuMTcuMjAuXG4gKi9cbmNvbnN0IEJQRl9MT0FERVJfUFJPR1JBTV9JRCA9IG5ldyBQdWJsaWNLZXkoJ0JQRkxvYWRlcjIxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcblxuLyoqXG4gKiBGYWN0b3J5IGNsYXNzIGZvciB0cmFuc2FjdGlvbnMgdG8gaW50ZXJhY3Qgd2l0aCBhIHByb2dyYW0gbG9hZGVyXG4gKlxuICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBTb2xhbmEgdjEuMTcuMjAuXG4gKi9cbmNsYXNzIEJwZkxvYWRlciB7XG4gIC8qKlxuICAgKiBNaW5pbXVtIG51bWJlciBvZiBzaWduYXR1cmVzIHJlcXVpcmVkIHRvIGxvYWQgYSBwcm9ncmFtIG5vdCBpbmNsdWRpbmdcbiAgICogcmV0cmllc1xuICAgKlxuICAgKiBDYW4gYmUgdXNlZCB0byBjYWxjdWxhdGUgdHJhbnNhY3Rpb24gZmVlc1xuICAgKi9cbiAgc3RhdGljIGdldE1pbk51bVNpZ25hdHVyZXMoZGF0YUxlbmd0aCkge1xuICAgIHJldHVybiBMb2FkZXIuZ2V0TWluTnVtU2lnbmF0dXJlcyhkYXRhTGVuZ3RoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIGEgU0JGIHByb2dyYW1cbiAgICpcbiAgICogQHBhcmFtIGNvbm5lY3Rpb24gVGhlIGNvbm5lY3Rpb24gdG8gdXNlXG4gICAqIEBwYXJhbSBwYXllciBBY2NvdW50IHRoYXQgd2lsbCBwYXkgcHJvZ3JhbSBsb2FkaW5nIGZlZXNcbiAgICogQHBhcmFtIHByb2dyYW0gQWNjb3VudCB0byBsb2FkIHRoZSBwcm9ncmFtIGludG9cbiAgICogQHBhcmFtIGVsZiBUaGUgZW50aXJlIEVMRiBjb250YWluaW5nIHRoZSBTQkYgcHJvZ3JhbVxuICAgKiBAcGFyYW0gbG9hZGVyUHJvZ3JhbUlkIFRoZSBwcm9ncmFtIGlkIG9mIHRoZSBCUEYgbG9hZGVyIHRvIHVzZVxuICAgKiBAcmV0dXJuIHRydWUgaWYgcHJvZ3JhbSB3YXMgbG9hZGVkIHN1Y2Nlc3NmdWxseSwgZmFsc2UgaWYgcHJvZ3JhbSB3YXMgYWxyZWFkeSBsb2FkZWRcbiAgICovXG4gIHN0YXRpYyBsb2FkKGNvbm5lY3Rpb24sIHBheWVyLCBwcm9ncmFtLCBlbGYsIGxvYWRlclByb2dyYW1JZCkge1xuICAgIHJldHVybiBMb2FkZXIubG9hZChjb25uZWN0aW9uLCBwYXllciwgcHJvZ3JhbSwgbG9hZGVyUHJvZ3JhbUlkLCBlbGYpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRFeHBvcnRGcm9tQ2pzICh4KSB7XG5cdHJldHVybiB4ICYmIHguX19lc01vZHVsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ2RlZmF1bHQnKSA/IHhbJ2RlZmF1bHQnXSA6IHg7XG59XG5cbnZhciBhZ2VudGtlZXBhbGl2ZSA9IHtleHBvcnRzOiB7fX07XG5cbi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgbXM7XG52YXIgaGFzUmVxdWlyZWRNcztcblxuZnVuY3Rpb24gcmVxdWlyZU1zICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkTXMpIHJldHVybiBtcztcblx0aGFzUmVxdWlyZWRNcyA9IDE7XG5cdHZhciBzID0gMTAwMDtcblx0dmFyIG0gPSBzICogNjA7XG5cdHZhciBoID0gbSAqIDYwO1xuXHR2YXIgZCA9IGggKiAyNDtcblx0dmFyIHcgPSBkICogNztcblx0dmFyIHkgPSBkICogMzY1LjI1O1xuXG5cdC8qKlxuXHQgKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuXHQgKlxuXHQgKiBPcHRpb25zOlxuXHQgKlxuXHQgKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcblx0ICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuXHQgKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcblx0ICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0bXMgPSBmdW5jdGlvbiAodmFsLCBvcHRpb25zKSB7XG5cdCAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdCAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuXHQgIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuXHQgICAgcmV0dXJuIHBhcnNlKHZhbCk7XG5cdCAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh2YWwpKSB7XG5cdCAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcblx0ICB9XG5cdCAgdGhyb3cgbmV3IEVycm9yKFxuXHQgICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG5cdCAgICAgIEpTT04uc3RyaW5naWZ5KHZhbClcblx0ICApO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0ZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG5cdCAgc3RyID0gU3RyaW5nKHN0cik7XG5cdCAgaWYgKHN0ci5sZW5ndGggPiAxMDApIHtcblx0ICAgIHJldHVybjtcblx0ICB9XG5cdCAgdmFyIG1hdGNoID0gL14oLT8oPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHdlZWtzP3x3fHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKFxuXHQgICAgc3RyXG5cdCAgKTtcblx0ICBpZiAoIW1hdGNoKSB7XG5cdCAgICByZXR1cm47XG5cdCAgfVxuXHQgIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG5cdCAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcblx0ICBzd2l0Y2ggKHR5cGUpIHtcblx0ICAgIGNhc2UgJ3llYXJzJzpcblx0ICAgIGNhc2UgJ3llYXInOlxuXHQgICAgY2FzZSAneXJzJzpcblx0ICAgIGNhc2UgJ3lyJzpcblx0ICAgIGNhc2UgJ3knOlxuXHQgICAgICByZXR1cm4gbiAqIHk7XG5cdCAgICBjYXNlICd3ZWVrcyc6XG5cdCAgICBjYXNlICd3ZWVrJzpcblx0ICAgIGNhc2UgJ3cnOlxuXHQgICAgICByZXR1cm4gbiAqIHc7XG5cdCAgICBjYXNlICdkYXlzJzpcblx0ICAgIGNhc2UgJ2RheSc6XG5cdCAgICBjYXNlICdkJzpcblx0ICAgICAgcmV0dXJuIG4gKiBkO1xuXHQgICAgY2FzZSAnaG91cnMnOlxuXHQgICAgY2FzZSAnaG91cic6XG5cdCAgICBjYXNlICdocnMnOlxuXHQgICAgY2FzZSAnaHInOlxuXHQgICAgY2FzZSAnaCc6XG5cdCAgICAgIHJldHVybiBuICogaDtcblx0ICAgIGNhc2UgJ21pbnV0ZXMnOlxuXHQgICAgY2FzZSAnbWludXRlJzpcblx0ICAgIGNhc2UgJ21pbnMnOlxuXHQgICAgY2FzZSAnbWluJzpcblx0ICAgIGNhc2UgJ20nOlxuXHQgICAgICByZXR1cm4gbiAqIG07XG5cdCAgICBjYXNlICdzZWNvbmRzJzpcblx0ICAgIGNhc2UgJ3NlY29uZCc6XG5cdCAgICBjYXNlICdzZWNzJzpcblx0ICAgIGNhc2UgJ3NlYyc6XG5cdCAgICBjYXNlICdzJzpcblx0ICAgICAgcmV0dXJuIG4gKiBzO1xuXHQgICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcblx0ICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcblx0ICAgIGNhc2UgJ21zZWNzJzpcblx0ICAgIGNhc2UgJ21zZWMnOlxuXHQgICAgY2FzZSAnbXMnOlxuXHQgICAgICByZXR1cm4gbjtcblx0ICAgIGRlZmF1bHQ6XG5cdCAgICAgIHJldHVybiB1bmRlZmluZWQ7XG5cdCAgfVxuXHR9XG5cblx0LyoqXG5cdCAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cblx0ICpcblx0ICogQHBhcmFtIHtOdW1iZXJ9IG1zXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG5cdCAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuXHQgIGlmIChtc0FicyA+PSBkKSB7XG5cdCAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuXHQgIH1cblx0ICBpZiAobXNBYnMgPj0gaCkge1xuXHQgICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcblx0ICB9XG5cdCAgaWYgKG1zQWJzID49IG0pIHtcblx0ICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG5cdCAgfVxuXHQgIGlmIChtc0FicyA+PSBzKSB7XG5cdCAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuXHQgIH1cblx0ICByZXR1cm4gbXMgKyAnbXMnO1xuXHR9XG5cblx0LyoqXG5cdCAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuXHQgKlxuXHQgKiBAcGFyYW0ge051bWJlcn0gbXNcblx0ICogQHJldHVybiB7U3RyaW5nfVxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0ZnVuY3Rpb24gZm10TG9uZyhtcykge1xuXHQgIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcblx0ICBpZiAobXNBYnMgPj0gZCkge1xuXHQgICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGQsICdkYXknKTtcblx0ICB9XG5cdCAgaWYgKG1zQWJzID49IGgpIHtcblx0ICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBoLCAnaG91cicpO1xuXHQgIH1cblx0ICBpZiAobXNBYnMgPj0gbSkge1xuXHQgICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIG0sICdtaW51dGUnKTtcblx0ICB9XG5cdCAgaWYgKG1zQWJzID49IHMpIHtcblx0ICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBzLCAnc2Vjb25kJyk7XG5cdCAgfVxuXHQgIHJldHVybiBtcyArICcgbXMnO1xuXHR9XG5cblx0LyoqXG5cdCAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuXHQgKi9cblxuXHRmdW5jdGlvbiBwbHVyYWwobXMsIG1zQWJzLCBuLCBuYW1lKSB7XG5cdCAgdmFyIGlzUGx1cmFsID0gbXNBYnMgPj0gbiAqIDEuNTtcblx0ICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG4pICsgJyAnICsgbmFtZSArIChpc1BsdXJhbCA/ICdzJyA6ICcnKTtcblx0fVxuXHRyZXR1cm4gbXM7XG59XG5cbi8qIVxuICogaHVtYW5pemUtbXMgLSBpbmRleC5qc1xuICogQ29weXJpZ2h0KGMpIDIwMTQgZGVhZF9ob3JzZSA8ZGVhZF9ob3JzZUBxcS5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG52YXIgaHVtYW5pemVNcztcbnZhciBoYXNSZXF1aXJlZEh1bWFuaXplTXM7XG5cbmZ1bmN0aW9uIHJlcXVpcmVIdW1hbml6ZU1zICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkSHVtYW5pemVNcykgcmV0dXJuIGh1bWFuaXplTXM7XG5cdGhhc1JlcXVpcmVkSHVtYW5pemVNcyA9IDE7XG5cblx0LyoqXG5cdCAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG5cdCAqL1xuXG5cdHZhciB1dGlsID0gcmVxdWlyZSQkMDtcblx0dmFyIG1zID0gLypAX19QVVJFX18qLyByZXF1aXJlTXMoKTtcblxuXHRodW1hbml6ZU1zID0gZnVuY3Rpb24gKHQpIHtcblx0ICBpZiAodHlwZW9mIHQgPT09ICdudW1iZXInKSByZXR1cm4gdDtcblx0ICB2YXIgciA9IG1zKHQpO1xuXHQgIGlmIChyID09PSB1bmRlZmluZWQpIHtcblx0ICAgIHZhciBlcnIgPSBuZXcgRXJyb3IodXRpbC5mb3JtYXQoJ2h1bWFuaXplLW1zKCVqKSByZXN1bHQgdW5kZWZpbmVkJywgdCkpO1xuXHQgICAgY29uc29sZS53YXJuKGVyci5zdGFjayk7XG5cdCAgfVxuXHQgIHJldHVybiByO1xuXHR9O1xuXHRyZXR1cm4gaHVtYW5pemVNcztcbn1cblxudmFyIGNvbnN0YW50cztcbnZhciBoYXNSZXF1aXJlZENvbnN0YW50cztcblxuZnVuY3Rpb24gcmVxdWlyZUNvbnN0YW50cyAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZENvbnN0YW50cykgcmV0dXJuIGNvbnN0YW50cztcblx0aGFzUmVxdWlyZWRDb25zdGFudHMgPSAxO1xuXG5cdGNvbnN0YW50cyA9IHtcblx0ICAvLyBhZ2VudFxuXHQgIENVUlJFTlRfSUQ6IFN5bWJvbCgnYWdlbnRrZWVwYWxpdmUjY3VycmVudElkJyksXG5cdCAgQ1JFQVRFX0lEOiBTeW1ib2woJ2FnZW50a2VlcGFsaXZlI2NyZWF0ZUlkJyksXG5cdCAgSU5JVF9TT0NLRVQ6IFN5bWJvbCgnYWdlbnRrZWVwYWxpdmUjaW5pdFNvY2tldCcpLFxuXHQgIENSRUFURV9IVFRQU19DT05ORUNUSU9OOiBTeW1ib2woJ2FnZW50a2VlcGFsaXZlI2NyZWF0ZUh0dHBzQ29ubmVjdGlvbicpLFxuXHQgIC8vIHNvY2tldFxuXHQgIFNPQ0tFVF9DUkVBVEVEX1RJTUU6IFN5bWJvbCgnYWdlbnRrZWVwYWxpdmUjc29ja2V0Q3JlYXRlZFRpbWUnKSxcblx0ICBTT0NLRVRfTkFNRTogU3ltYm9sKCdhZ2VudGtlZXBhbGl2ZSNzb2NrZXROYW1lJyksXG5cdCAgU09DS0VUX1JFUVVFU1RfQ09VTlQ6IFN5bWJvbCgnYWdlbnRrZWVwYWxpdmUjc29ja2V0UmVxdWVzdENvdW50JyksXG5cdCAgU09DS0VUX1JFUVVFU1RfRklOSVNIRURfQ09VTlQ6IFN5bWJvbCgnYWdlbnRrZWVwYWxpdmUjc29ja2V0UmVxdWVzdEZpbmlzaGVkQ291bnQnKSxcblx0fTtcblx0cmV0dXJuIGNvbnN0YW50cztcbn1cblxudmFyIGFnZW50O1xudmFyIGhhc1JlcXVpcmVkQWdlbnQ7XG5cbmZ1bmN0aW9uIHJlcXVpcmVBZ2VudCAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZEFnZW50KSByZXR1cm4gYWdlbnQ7XG5cdGhhc1JlcXVpcmVkQWdlbnQgPSAxO1xuXG5cdGNvbnN0IE9yaWdpbmFsQWdlbnQgPSByZXF1aXJlJCQwJDEuQWdlbnQ7XG5cdGNvbnN0IG1zID0gLypAX19QVVJFX18qLyByZXF1aXJlSHVtYW5pemVNcygpO1xuXHRjb25zdCBkZWJ1ZyA9IHJlcXVpcmUkJDAuZGVidWdsb2coJ2FnZW50a2VlcGFsaXZlJyk7XG5cdGNvbnN0IHtcblx0ICBJTklUX1NPQ0tFVCxcblx0ICBDVVJSRU5UX0lELFxuXHQgIENSRUFURV9JRCxcblx0ICBTT0NLRVRfQ1JFQVRFRF9USU1FLFxuXHQgIFNPQ0tFVF9OQU1FLFxuXHQgIFNPQ0tFVF9SRVFVRVNUX0NPVU5ULFxuXHQgIFNPQ0tFVF9SRVFVRVNUX0ZJTklTSEVEX0NPVU5ULFxuXHR9ID0gLypAX19QVVJFX18qLyByZXF1aXJlQ29uc3RhbnRzKCk7XG5cblx0Ly8gT3JpZ2luYWxBZ2VudCBjb21lIGZyb21cblx0Ly8gLSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi92OC4xMi4wL2xpYi9faHR0cF9hZ2VudC5qc1xuXHQvLyAtIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL3YxMC4xMi4wL2xpYi9faHR0cF9hZ2VudC5qc1xuXG5cdC8vIG5vZGUgPD0gMTBcblx0bGV0IGRlZmF1bHRUaW1lb3V0TGlzdGVuZXJDb3VudCA9IDE7XG5cdGNvbnN0IG1ham9yVmVyc2lvbiA9IHBhcnNlSW50KHByb2Nlc3MudmVyc2lvbi5zcGxpdCgnLicsIDEpWzBdLnN1YnN0cmluZygxKSk7XG5cdGlmIChtYWpvclZlcnNpb24gPj0gMTEgJiYgbWFqb3JWZXJzaW9uIDw9IDEyKSB7XG5cdCAgZGVmYXVsdFRpbWVvdXRMaXN0ZW5lckNvdW50ID0gMjtcblx0fSBlbHNlIGlmIChtYWpvclZlcnNpb24gPj0gMTMpIHtcblx0ICBkZWZhdWx0VGltZW91dExpc3RlbmVyQ291bnQgPSAzO1xuXHR9XG5cblx0ZnVuY3Rpb24gZGVwcmVjYXRlKG1lc3NhZ2UpIHtcblx0ICBjb25zb2xlLmxvZygnW2FnZW50a2VlcGFsaXZlOmRlcHJlY2F0ZWRdICVzJywgbWVzc2FnZSk7XG5cdH1cblxuXHRjbGFzcyBBZ2VudCBleHRlbmRzIE9yaWdpbmFsQWdlbnQge1xuXHQgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcblx0ICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHQgICAgb3B0aW9ucy5rZWVwQWxpdmUgPSBvcHRpb25zLmtlZXBBbGl2ZSAhPT0gZmFsc2U7XG5cdCAgICAvLyBkZWZhdWx0IGlzIGtlZXAtYWxpdmUgYW5kIDRzIGZyZWUgc29ja2V0IHRpbWVvdXRcblx0ICAgIC8vIHNlZSBodHRwczovL21lZGl1bS5jb20vc3NlbnNlLXRlY2gvcmVkdWNlLW5ldHdvcmtpbmctZXJyb3JzLWluLW5vZGVqcy0yM2I0ZWI5ZjJkODNcblx0ICAgIGlmIChvcHRpb25zLmZyZWVTb2NrZXRUaW1lb3V0ID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgb3B0aW9ucy5mcmVlU29ja2V0VGltZW91dCA9IDQwMDA7XG5cdCAgICB9XG5cdCAgICAvLyBMZWdhY3kgQVBJOiBrZWVwQWxpdmVUaW1lb3V0IHNob3VsZCBiZSByZW5hbWUgdG8gYGZyZWVTb2NrZXRUaW1lb3V0YFxuXHQgICAgaWYgKG9wdGlvbnMua2VlcEFsaXZlVGltZW91dCkge1xuXHQgICAgICBkZXByZWNhdGUoJ29wdGlvbnMua2VlcEFsaXZlVGltZW91dCBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIG9wdGlvbnMuZnJlZVNvY2tldFRpbWVvdXQgaW5zdGVhZCcpO1xuXHQgICAgICBvcHRpb25zLmZyZWVTb2NrZXRUaW1lb3V0ID0gb3B0aW9ucy5rZWVwQWxpdmVUaW1lb3V0O1xuXHQgICAgICBkZWxldGUgb3B0aW9ucy5rZWVwQWxpdmVUaW1lb3V0O1xuXHQgICAgfVxuXHQgICAgLy8gTGVnYWN5IEFQSTogZnJlZVNvY2tldEtlZXBBbGl2ZVRpbWVvdXQgc2hvdWxkIGJlIHJlbmFtZSB0byBgZnJlZVNvY2tldFRpbWVvdXRgXG5cdCAgICBpZiAob3B0aW9ucy5mcmVlU29ja2V0S2VlcEFsaXZlVGltZW91dCkge1xuXHQgICAgICBkZXByZWNhdGUoJ29wdGlvbnMuZnJlZVNvY2tldEtlZXBBbGl2ZVRpbWVvdXQgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBvcHRpb25zLmZyZWVTb2NrZXRUaW1lb3V0IGluc3RlYWQnKTtcblx0ICAgICAgb3B0aW9ucy5mcmVlU29ja2V0VGltZW91dCA9IG9wdGlvbnMuZnJlZVNvY2tldEtlZXBBbGl2ZVRpbWVvdXQ7XG5cdCAgICAgIGRlbGV0ZSBvcHRpb25zLmZyZWVTb2NrZXRLZWVwQWxpdmVUaW1lb3V0O1xuXHQgICAgfVxuXG5cdCAgICAvLyBTZXRzIHRoZSBzb2NrZXQgdG8gdGltZW91dCBhZnRlciB0aW1lb3V0IG1pbGxpc2Vjb25kcyBvZiBpbmFjdGl2aXR5IG9uIHRoZSBzb2NrZXQuXG5cdCAgICAvLyBCeSBkZWZhdWx0IGlzIGRvdWJsZSBmcmVlIHNvY2tldCB0aW1lb3V0LlxuXHQgICAgaWYgKG9wdGlvbnMudGltZW91dCA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgIC8vIG1ha2Ugc3VyZSBzb2NrZXQgZGVmYXVsdCBpbmFjdGl2aXR5IHRpbWVvdXQgPj0gOHNcblx0ICAgICAgb3B0aW9ucy50aW1lb3V0ID0gTWF0aC5tYXgob3B0aW9ucy5mcmVlU29ja2V0VGltZW91dCAqIDIsIDgwMDApO1xuXHQgICAgfVxuXG5cdCAgICAvLyBzdXBwb3J0IGh1bWFuaXplIGZvcm1hdFxuXHQgICAgb3B0aW9ucy50aW1lb3V0ID0gbXMob3B0aW9ucy50aW1lb3V0KTtcblx0ICAgIG9wdGlvbnMuZnJlZVNvY2tldFRpbWVvdXQgPSBtcyhvcHRpb25zLmZyZWVTb2NrZXRUaW1lb3V0KTtcblx0ICAgIG9wdGlvbnMuc29ja2V0QWN0aXZlVFRMID0gb3B0aW9ucy5zb2NrZXRBY3RpdmVUVEwgPyBtcyhvcHRpb25zLnNvY2tldEFjdGl2ZVRUTCkgOiAwO1xuXG5cdCAgICBzdXBlcihvcHRpb25zKTtcblxuXHQgICAgdGhpc1tDVVJSRU5UX0lEXSA9IDA7XG5cblx0ICAgIC8vIGNyZWF0ZSBzb2NrZXQgc3VjY2VzcyBjb3VudGVyXG5cdCAgICB0aGlzLmNyZWF0ZVNvY2tldENvdW50ID0gMDtcblx0ICAgIHRoaXMuY3JlYXRlU29ja2V0Q291bnRMYXN0Q2hlY2sgPSAwO1xuXG5cdCAgICB0aGlzLmNyZWF0ZVNvY2tldEVycm9yQ291bnQgPSAwO1xuXHQgICAgdGhpcy5jcmVhdGVTb2NrZXRFcnJvckNvdW50TGFzdENoZWNrID0gMDtcblxuXHQgICAgdGhpcy5jbG9zZVNvY2tldENvdW50ID0gMDtcblx0ICAgIHRoaXMuY2xvc2VTb2NrZXRDb3VudExhc3RDaGVjayA9IDA7XG5cblx0ICAgIC8vIHNvY2tldCBlcnJvciBldmVudCBjb3VudFxuXHQgICAgdGhpcy5lcnJvclNvY2tldENvdW50ID0gMDtcblx0ICAgIHRoaXMuZXJyb3JTb2NrZXRDb3VudExhc3RDaGVjayA9IDA7XG5cblx0ICAgIC8vIHJlcXVlc3QgZmluaXNoZWQgY291bnRlclxuXHQgICAgdGhpcy5yZXF1ZXN0Q291bnQgPSAwO1xuXHQgICAgdGhpcy5yZXF1ZXN0Q291bnRMYXN0Q2hlY2sgPSAwO1xuXG5cdCAgICAvLyBpbmNsdWRpbmcgZnJlZSBzb2NrZXQgdGltZW91dCBjb3VudGVyXG5cdCAgICB0aGlzLnRpbWVvdXRTb2NrZXRDb3VudCA9IDA7XG5cdCAgICB0aGlzLnRpbWVvdXRTb2NrZXRDb3VudExhc3RDaGVjayA9IDA7XG5cblx0ICAgIHRoaXMub24oJ2ZyZWUnLCBzb2NrZXQgPT4ge1xuXHQgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvcHVsbC8zMjAwMFxuXHQgICAgICAvLyBOb2RlLmpzIG5hdGl2ZSBhZ2VudCB3aWxsIGNoZWNrIHNvY2tldCB0aW1lb3V0IGVxcyBhZ2VudC5vcHRpb25zLnRpbWVvdXQuXG5cdCAgICAgIC8vIFVzZSB0aGUgdHRsIG9yIGZyZWVTb2NrZXRUaW1lb3V0IHRvIG92ZXJ3cml0ZS5cblx0ICAgICAgY29uc3QgdGltZW91dCA9IHRoaXMuY2FsY1NvY2tldFRpbWVvdXQoc29ja2V0KTtcblx0ICAgICAgaWYgKHRpbWVvdXQgPiAwICYmIHNvY2tldC50aW1lb3V0ICE9PSB0aW1lb3V0KSB7XG5cdCAgICAgICAgc29ja2V0LnNldFRpbWVvdXQodGltZW91dCk7XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXHQgIH1cblxuXHQgIGdldCBmcmVlU29ja2V0S2VlcEFsaXZlVGltZW91dCgpIHtcblx0ICAgIGRlcHJlY2F0ZSgnYWdlbnQuZnJlZVNvY2tldEtlZXBBbGl2ZVRpbWVvdXQgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBhZ2VudC5vcHRpb25zLmZyZWVTb2NrZXRUaW1lb3V0IGluc3RlYWQnKTtcblx0ICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZnJlZVNvY2tldFRpbWVvdXQ7XG5cdCAgfVxuXG5cdCAgZ2V0IHRpbWVvdXQoKSB7XG5cdCAgICBkZXByZWNhdGUoJ2FnZW50LnRpbWVvdXQgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBhZ2VudC5vcHRpb25zLnRpbWVvdXQgaW5zdGVhZCcpO1xuXHQgICAgcmV0dXJuIHRoaXMub3B0aW9ucy50aW1lb3V0O1xuXHQgIH1cblxuXHQgIGdldCBzb2NrZXRBY3RpdmVUVEwoKSB7XG5cdCAgICBkZXByZWNhdGUoJ2FnZW50LnNvY2tldEFjdGl2ZVRUTCBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIGFnZW50Lm9wdGlvbnMuc29ja2V0QWN0aXZlVFRMIGluc3RlYWQnKTtcblx0ICAgIHJldHVybiB0aGlzLm9wdGlvbnMuc29ja2V0QWN0aXZlVFRMO1xuXHQgIH1cblxuXHQgIGNhbGNTb2NrZXRUaW1lb3V0KHNvY2tldCkge1xuXHQgICAgLyoqXG5cdCAgICAgKiByZXR1cm4gPD0gMDogc2hvdWxkIGZyZWUgc29ja2V0XG5cdCAgICAgKiByZXR1cm4gPiAwOiBzaG91bGQgdXBkYXRlIHNvY2tldCB0aW1lb3V0XG5cdCAgICAgKiByZXR1cm4gdW5kZWZpbmVkOiBub3QgZmluZCBjdXN0b20gdGltZW91dFxuXHQgICAgICovXG5cdCAgICBsZXQgZnJlZVNvY2tldFRpbWVvdXQgPSB0aGlzLm9wdGlvbnMuZnJlZVNvY2tldFRpbWVvdXQ7XG5cdCAgICBjb25zdCBzb2NrZXRBY3RpdmVUVEwgPSB0aGlzLm9wdGlvbnMuc29ja2V0QWN0aXZlVFRMO1xuXHQgICAgaWYgKHNvY2tldEFjdGl2ZVRUTCkge1xuXHQgICAgICAvLyBjaGVjayBzb2NrZXRBY3RpdmVUVExcblx0ICAgICAgY29uc3QgYWxpdmVUaW1lID0gRGF0ZS5ub3coKSAtIHNvY2tldFtTT0NLRVRfQ1JFQVRFRF9USU1FXTtcblx0ICAgICAgY29uc3QgZGlmZiA9IHNvY2tldEFjdGl2ZVRUTCAtIGFsaXZlVGltZTtcblx0ICAgICAgaWYgKGRpZmYgPD0gMCkge1xuXHQgICAgICAgIHJldHVybiBkaWZmO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChmcmVlU29ja2V0VGltZW91dCAmJiBkaWZmIDwgZnJlZVNvY2tldFRpbWVvdXQpIHtcblx0ICAgICAgICBmcmVlU29ja2V0VGltZW91dCA9IGRpZmY7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIC8vIHNldCBmcmVlU29ja2V0VGltZW91dFxuXHQgICAgaWYgKGZyZWVTb2NrZXRUaW1lb3V0KSB7XG5cdCAgICAgIC8vIHNldCBmcmVlIGtlZXBhbGl2ZSB0aW1lclxuXHQgICAgICAvLyB0cnkgdG8gdXNlIHNvY2tldCBjdXN0b20gZnJlZVNvY2tldFRpbWVvdXQgZmlyc3QsIHN1cHBvcnQgaGVhZGVyc1sna2VlcC1hbGl2ZSddXG5cdCAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlLW1vZHVsZXMvdXJsbGliL2Jsb2IvYjc2MDUzMDIwOTIzZjRkOTlhMWM5M2NmMmUxNmUwYzViYTEwYmFjZi9saWIvdXJsbGliLmpzI0w0OThcblx0ICAgICAgY29uc3QgY3VzdG9tRnJlZVNvY2tldFRpbWVvdXQgPSBzb2NrZXQuZnJlZVNvY2tldFRpbWVvdXQgfHwgc29ja2V0LmZyZWVTb2NrZXRLZWVwQWxpdmVUaW1lb3V0O1xuXHQgICAgICByZXR1cm4gY3VzdG9tRnJlZVNvY2tldFRpbWVvdXQgfHwgZnJlZVNvY2tldFRpbWVvdXQ7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAga2VlcFNvY2tldEFsaXZlKHNvY2tldCkge1xuXHQgICAgY29uc3QgcmVzdWx0ID0gc3VwZXIua2VlcFNvY2tldEFsaXZlKHNvY2tldCk7XG5cdCAgICAvLyBzaG91bGQgbm90IGtlZXBBbGl2ZSwgZG8gbm90aGluZ1xuXHQgICAgaWYgKCFyZXN1bHQpIHJldHVybiByZXN1bHQ7XG5cblx0ICAgIGNvbnN0IGN1c3RvbVRpbWVvdXQgPSB0aGlzLmNhbGNTb2NrZXRUaW1lb3V0KHNvY2tldCk7XG5cdCAgICBpZiAodHlwZW9mIGN1c3RvbVRpbWVvdXQgPT09ICd1bmRlZmluZWQnKSB7XG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXHQgICAgaWYgKGN1c3RvbVRpbWVvdXQgPD0gMCkge1xuXHQgICAgICBkZWJ1ZygnJXMocmVxdWVzdHM6ICVzLCBmaW5pc2hlZDogJXMpIGZyZWUgYnV0IG5lZWQgdG8gZGVzdHJveSBieSBUVEwsIHJlcXVlc3QgY291bnQgJXMsIGRpZmYgaXMgJXMnLFxuXHQgICAgICAgIHNvY2tldFtTT0NLRVRfTkFNRV0sIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9DT1VOVF0sIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9GSU5JU0hFRF9DT1VOVF0sIGN1c3RvbVRpbWVvdXQpO1xuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdCAgICBpZiAoc29ja2V0LnRpbWVvdXQgIT09IGN1c3RvbVRpbWVvdXQpIHtcblx0ICAgICAgc29ja2V0LnNldFRpbWVvdXQoY3VzdG9tVGltZW91dCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdHJ1ZTtcblx0ICB9XG5cblx0ICAvLyBvbmx5IGNhbGwgb24gYWRkUmVxdWVzdFxuXHQgIHJldXNlU29ja2V0KC4uLmFyZ3MpIHtcblx0ICAgIC8vIHJldXNlU29ja2V0KHNvY2tldCwgcmVxKVxuXHQgICAgc3VwZXIucmV1c2VTb2NrZXQoLi4uYXJncyk7XG5cdCAgICBjb25zdCBzb2NrZXQgPSBhcmdzWzBdO1xuXHQgICAgY29uc3QgcmVxID0gYXJnc1sxXTtcblx0ICAgIHJlcS5yZXVzZWRTb2NrZXQgPSB0cnVlO1xuXHQgICAgY29uc3QgYWdlbnRUaW1lb3V0ID0gdGhpcy5vcHRpb25zLnRpbWVvdXQ7XG5cdCAgICBpZiAoZ2V0U29ja2V0VGltZW91dChzb2NrZXQpICE9PSBhZ2VudFRpbWVvdXQpIHtcblx0ICAgICAgLy8gcmVzZXQgdGltZW91dCBiZWZvcmUgdXNlXG5cdCAgICAgIHNvY2tldC5zZXRUaW1lb3V0KGFnZW50VGltZW91dCk7XG5cdCAgICAgIGRlYnVnKCclcyByZXNldCB0aW1lb3V0IHRvICVzbXMnLCBzb2NrZXRbU09DS0VUX05BTUVdLCBhZ2VudFRpbWVvdXQpO1xuXHQgICAgfVxuXHQgICAgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0NPVU5UXSsrO1xuXHQgICAgZGVidWcoJyVzKHJlcXVlc3RzOiAlcywgZmluaXNoZWQ6ICVzKSByZXVzZSBvbiBhZGRSZXF1ZXN0LCB0aW1lb3V0ICVzbXMnLFxuXHQgICAgICBzb2NrZXRbU09DS0VUX05BTUVdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfQ09VTlRdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfRklOSVNIRURfQ09VTlRdLFxuXHQgICAgICBnZXRTb2NrZXRUaW1lb3V0KHNvY2tldCkpO1xuXHQgIH1cblxuXHQgIFtDUkVBVEVfSURdKCkge1xuXHQgICAgY29uc3QgaWQgPSB0aGlzW0NVUlJFTlRfSURdKys7XG5cdCAgICBpZiAodGhpc1tDVVJSRU5UX0lEXSA9PT0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHRoaXNbQ1VSUkVOVF9JRF0gPSAwO1xuXHQgICAgcmV0dXJuIGlkO1xuXHQgIH1cblxuXHQgIFtJTklUX1NPQ0tFVF0oc29ja2V0LCBvcHRpb25zKSB7XG5cdCAgICAvLyBidWdmaXggaGVyZS5cblx0ICAgIC8vIGh0dHBzIG9uIG5vZGUgOCwgMTAgd29uJ3Qgc2V0IGFnZW50Lm9wdGlvbnMudGltZW91dCBieSBkZWZhdWx0XG5cdCAgICAvLyBUT0RPOiBuZWVkIHRvIGZpeCBvbiBub2RlIGl0c2VsZlxuXHQgICAgaWYgKG9wdGlvbnMudGltZW91dCkge1xuXHQgICAgICBjb25zdCB0aW1lb3V0ID0gZ2V0U29ja2V0VGltZW91dChzb2NrZXQpO1xuXHQgICAgICBpZiAoIXRpbWVvdXQpIHtcblx0ICAgICAgICBzb2NrZXQuc2V0VGltZW91dChvcHRpb25zLnRpbWVvdXQpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGlmICh0aGlzLm9wdGlvbnMua2VlcEFsaXZlKSB7XG5cdCAgICAgIC8vIERpc2FibGUgTmFnbGUncyBhbGdvcml0aG06IGh0dHA6Ly9ibG9nLmNhdXN0aWsuY29tLzIwMTIvMDQvMDgvc2NhbGluZy1ub2RlLWpzLXRvLTEwMGstY29uY3VycmVudC1jb25uZWN0aW9ucy9cblx0ICAgICAgLy8gaHR0cHM6Ly9mZW5nbWsyLmNvbS9iZW5jaG1hcmsvbmFnbGUtYWxnb3JpdGhtLWRlbGF5ZWQtYWNrLW1vY2suaHRtbFxuXHQgICAgICBzb2NrZXQuc2V0Tm9EZWxheSh0cnVlKTtcblx0ICAgIH1cblx0ICAgIHRoaXMuY3JlYXRlU29ja2V0Q291bnQrKztcblx0ICAgIGlmICh0aGlzLm9wdGlvbnMuc29ja2V0QWN0aXZlVFRMKSB7XG5cdCAgICAgIHNvY2tldFtTT0NLRVRfQ1JFQVRFRF9USU1FXSA9IERhdGUubm93KCk7XG5cdCAgICB9XG5cdCAgICAvLyBkb24ndCBzaG93IHRoZSBob2xlICctLS0tLUJFR0lOIENFUlRJRklDQVRFLS0tLScga2V5IHN0cmluZ1xuXHQgICAgc29ja2V0W1NPQ0tFVF9OQU1FXSA9IGBzb2NrWyR7dGhpc1tDUkVBVEVfSURdKCl9IyR7b3B0aW9ucy5fYWdlbnRLZXl9XWAuc3BsaXQoJy0tLS0tQkVHSU4nLCAxKVswXTtcblx0ICAgIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9DT1VOVF0gPSAxO1xuXHQgICAgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0ZJTklTSEVEX0NPVU5UXSA9IDA7XG5cdCAgICBpbnN0YWxsTGlzdGVuZXJzKHRoaXMsIHNvY2tldCwgb3B0aW9ucyk7XG5cdCAgfVxuXG5cdCAgY3JlYXRlQ29ubmVjdGlvbihvcHRpb25zLCBvbmNyZWF0ZSkge1xuXHQgICAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuXHQgICAgY29uc3Qgb25OZXdDcmVhdGUgPSAoZXJyLCBzb2NrZXQpID0+IHtcblx0ICAgICAgaWYgKGNhbGxlZCkgcmV0dXJuO1xuXHQgICAgICBjYWxsZWQgPSB0cnVlO1xuXG5cdCAgICAgIGlmIChlcnIpIHtcblx0ICAgICAgICB0aGlzLmNyZWF0ZVNvY2tldEVycm9yQ291bnQrKztcblx0ICAgICAgICByZXR1cm4gb25jcmVhdGUoZXJyKTtcblx0ICAgICAgfVxuXHQgICAgICB0aGlzW0lOSVRfU09DS0VUXShzb2NrZXQsIG9wdGlvbnMpO1xuXHQgICAgICBvbmNyZWF0ZShlcnIsIHNvY2tldCk7XG5cdCAgICB9O1xuXG5cdCAgICBjb25zdCBuZXdTb2NrZXQgPSBzdXBlci5jcmVhdGVDb25uZWN0aW9uKG9wdGlvbnMsIG9uTmV3Q3JlYXRlKTtcblx0ICAgIGlmIChuZXdTb2NrZXQpIG9uTmV3Q3JlYXRlKG51bGwsIG5ld1NvY2tldCk7XG5cdCAgICByZXR1cm4gbmV3U29ja2V0O1xuXHQgIH1cblxuXHQgIGdldCBzdGF0dXNDaGFuZ2VkKCkge1xuXHQgICAgY29uc3QgY2hhbmdlZCA9IHRoaXMuY3JlYXRlU29ja2V0Q291bnQgIT09IHRoaXMuY3JlYXRlU29ja2V0Q291bnRMYXN0Q2hlY2sgfHxcblx0ICAgICAgdGhpcy5jcmVhdGVTb2NrZXRFcnJvckNvdW50ICE9PSB0aGlzLmNyZWF0ZVNvY2tldEVycm9yQ291bnRMYXN0Q2hlY2sgfHxcblx0ICAgICAgdGhpcy5jbG9zZVNvY2tldENvdW50ICE9PSB0aGlzLmNsb3NlU29ja2V0Q291bnRMYXN0Q2hlY2sgfHxcblx0ICAgICAgdGhpcy5lcnJvclNvY2tldENvdW50ICE9PSB0aGlzLmVycm9yU29ja2V0Q291bnRMYXN0Q2hlY2sgfHxcblx0ICAgICAgdGhpcy50aW1lb3V0U29ja2V0Q291bnQgIT09IHRoaXMudGltZW91dFNvY2tldENvdW50TGFzdENoZWNrIHx8XG5cdCAgICAgIHRoaXMucmVxdWVzdENvdW50ICE9PSB0aGlzLnJlcXVlc3RDb3VudExhc3RDaGVjaztcblx0ICAgIGlmIChjaGFuZ2VkKSB7XG5cdCAgICAgIHRoaXMuY3JlYXRlU29ja2V0Q291bnRMYXN0Q2hlY2sgPSB0aGlzLmNyZWF0ZVNvY2tldENvdW50O1xuXHQgICAgICB0aGlzLmNyZWF0ZVNvY2tldEVycm9yQ291bnRMYXN0Q2hlY2sgPSB0aGlzLmNyZWF0ZVNvY2tldEVycm9yQ291bnQ7XG5cdCAgICAgIHRoaXMuY2xvc2VTb2NrZXRDb3VudExhc3RDaGVjayA9IHRoaXMuY2xvc2VTb2NrZXRDb3VudDtcblx0ICAgICAgdGhpcy5lcnJvclNvY2tldENvdW50TGFzdENoZWNrID0gdGhpcy5lcnJvclNvY2tldENvdW50O1xuXHQgICAgICB0aGlzLnRpbWVvdXRTb2NrZXRDb3VudExhc3RDaGVjayA9IHRoaXMudGltZW91dFNvY2tldENvdW50O1xuXHQgICAgICB0aGlzLnJlcXVlc3RDb3VudExhc3RDaGVjayA9IHRoaXMucmVxdWVzdENvdW50O1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGNoYW5nZWQ7XG5cdCAgfVxuXG5cdCAgZ2V0Q3VycmVudFN0YXR1cygpIHtcblx0ICAgIHJldHVybiB7XG5cdCAgICAgIGNyZWF0ZVNvY2tldENvdW50OiB0aGlzLmNyZWF0ZVNvY2tldENvdW50LFxuXHQgICAgICBjcmVhdGVTb2NrZXRFcnJvckNvdW50OiB0aGlzLmNyZWF0ZVNvY2tldEVycm9yQ291bnQsXG5cdCAgICAgIGNsb3NlU29ja2V0Q291bnQ6IHRoaXMuY2xvc2VTb2NrZXRDb3VudCxcblx0ICAgICAgZXJyb3JTb2NrZXRDb3VudDogdGhpcy5lcnJvclNvY2tldENvdW50LFxuXHQgICAgICB0aW1lb3V0U29ja2V0Q291bnQ6IHRoaXMudGltZW91dFNvY2tldENvdW50LFxuXHQgICAgICByZXF1ZXN0Q291bnQ6IHRoaXMucmVxdWVzdENvdW50LFxuXHQgICAgICBmcmVlU29ja2V0czogaW5zcGVjdCh0aGlzLmZyZWVTb2NrZXRzKSxcblx0ICAgICAgc29ja2V0czogaW5zcGVjdCh0aGlzLnNvY2tldHMpLFxuXHQgICAgICByZXF1ZXN0czogaW5zcGVjdCh0aGlzLnJlcXVlc3RzKSxcblx0ICAgIH07XG5cdCAgfVxuXHR9XG5cblx0Ly8gbm9kZSA4IGRvbid0IGhhcyB0aW1lb3V0IGF0dHJpYnV0ZSBvbiBzb2NrZXRcblx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL3B1bGwvMjEyMDQvZmlsZXMjZGlmZi1lNmVmMDI0YzM3NzVkNzg3YzM4NDg3YTYzMDllNDkxZFI0MDhcblx0ZnVuY3Rpb24gZ2V0U29ja2V0VGltZW91dChzb2NrZXQpIHtcblx0ICByZXR1cm4gc29ja2V0LnRpbWVvdXQgfHwgc29ja2V0Ll9pZGxlVGltZW91dDtcblx0fVxuXG5cdGZ1bmN0aW9uIGluc3RhbGxMaXN0ZW5lcnMoYWdlbnQsIHNvY2tldCwgb3B0aW9ucykge1xuXHQgIGRlYnVnKCclcyBjcmVhdGUsIHRpbWVvdXQgJXNtcycsIHNvY2tldFtTT0NLRVRfTkFNRV0sIGdldFNvY2tldFRpbWVvdXQoc29ja2V0KSk7XG5cblx0ICAvLyBsaXN0ZW5lciBzb2NrZXQgZXZlbnRzOiBjbG9zZSwgdGltZW91dCwgZXJyb3IsIGZyZWVcblx0ICBmdW5jdGlvbiBvbkZyZWUoKSB7XG5cdCAgICAvLyBjcmVhdGUgYW5kIHNvY2tldC5lbWl0KCdmcmVlJykgbG9naWNcblx0ICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL21hc3Rlci9saWIvX2h0dHBfYWdlbnQuanMjTDMxMVxuXHQgICAgLy8gbm8gcmVxIG9uIHRoZSBzb2NrZXQsIGl0IHNob3VsZCBiZSB0aGUgbmV3IHNvY2tldFxuXHQgICAgaWYgKCFzb2NrZXQuX2h0dHBNZXNzYWdlICYmIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9DT1VOVF0gPT09IDEpIHJldHVybjtcblxuXHQgICAgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0ZJTklTSEVEX0NPVU5UXSsrO1xuXHQgICAgYWdlbnQucmVxdWVzdENvdW50Kys7XG5cdCAgICBkZWJ1ZygnJXMocmVxdWVzdHM6ICVzLCBmaW5pc2hlZDogJXMpIGZyZWUnLFxuXHQgICAgICBzb2NrZXRbU09DS0VUX05BTUVdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfQ09VTlRdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfRklOSVNIRURfQ09VTlRdKTtcblxuXHQgICAgLy8gc2hvdWxkIHJldXNlIG9uIHBlZGRpbmcgcmVxdWVzdHM/XG5cdCAgICBjb25zdCBuYW1lID0gYWdlbnQuZ2V0TmFtZShvcHRpb25zKTtcblx0ICAgIGlmIChzb2NrZXQud3JpdGFibGUgJiYgYWdlbnQucmVxdWVzdHNbbmFtZV0gJiYgYWdlbnQucmVxdWVzdHNbbmFtZV0ubGVuZ3RoKSB7XG5cdCAgICAgIC8vIHdpbGwgYmUgcmV1c2Ugb24gYWdlbnQgZnJlZSBsaXN0ZW5lclxuXHQgICAgICBzb2NrZXRbU09DS0VUX1JFUVVFU1RfQ09VTlRdKys7XG5cdCAgICAgIGRlYnVnKCclcyhyZXF1ZXN0czogJXMsIGZpbmlzaGVkOiAlcykgd2lsbCBiZSByZXVzZSBvbiBhZ2VudCBmcmVlIGV2ZW50Jyxcblx0ICAgICAgICBzb2NrZXRbU09DS0VUX05BTUVdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfQ09VTlRdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfRklOSVNIRURfQ09VTlRdKTtcblx0ICAgIH1cblx0ICB9XG5cdCAgc29ja2V0Lm9uKCdmcmVlJywgb25GcmVlKTtcblxuXHQgIGZ1bmN0aW9uIG9uQ2xvc2UoaXNFcnJvcikge1xuXHQgICAgZGVidWcoJyVzKHJlcXVlc3RzOiAlcywgZmluaXNoZWQ6ICVzKSBjbG9zZSwgaXNFcnJvcjogJXMnLFxuXHQgICAgICBzb2NrZXRbU09DS0VUX05BTUVdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfQ09VTlRdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfRklOSVNIRURfQ09VTlRdLCBpc0Vycm9yKTtcblx0ICAgIGFnZW50LmNsb3NlU29ja2V0Q291bnQrKztcblx0ICB9XG5cdCAgc29ja2V0Lm9uKCdjbG9zZScsIG9uQ2xvc2UpO1xuXG5cdCAgLy8gc3RhcnQgc29ja2V0IHRpbWVvdXQgaGFuZGxlclxuXHQgIGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcblx0ICAgIC8vIG9uVGltZW91dCBhbmQgZW1pdFJlcXVlc3RUaW1lb3V0KF9odHRwX2NsaWVudC5qcylcblx0ICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL3YxMi54L2xpYi9faHR0cF9jbGllbnQuanMjTDcxMVxuXHQgICAgY29uc3QgbGlzdGVuZXJDb3VudCA9IHNvY2tldC5saXN0ZW5lcnMoJ3RpbWVvdXQnKS5sZW5ndGg7XG5cdCAgICAvLyBub2RlIDw9IDEwLCBkZWZhdWx0IGxpc3RlbmVyQ291bnQgaXMgMSwgb25UaW1lb3V0XG5cdCAgICAvLyAxMSA8IG5vZGUgPD0gMTIsIGRlZmF1bHQgbGlzdGVuZXJDb3VudCBpcyAyLCBvblRpbWVvdXQgYW5kIGVtaXRSZXF1ZXN0VGltZW91dFxuXHQgICAgLy8gbm9kZSA+PSAxMywgZGVmYXVsdCBsaXN0ZW5lckNvdW50IGlzIDMsIG9uVGltZW91dCxcblx0ICAgIC8vICAgb25UaW1lb3V0KGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9wdWxsLzMyMDAwL2ZpbGVzI2RpZmYtNWY3ZmIwODUwNDEyYzZiZTE4OWZhZWRkZWE2YzUzNTlSMzMzKVxuXHQgICAgLy8gICBhbmQgZW1pdFJlcXVlc3RUaW1lb3V0XG5cdCAgICBjb25zdCB0aW1lb3V0ID0gZ2V0U29ja2V0VGltZW91dChzb2NrZXQpO1xuXHQgICAgY29uc3QgcmVxID0gc29ja2V0Ll9odHRwTWVzc2FnZTtcblx0ICAgIGNvbnN0IHJlcVRpbWVvdXRMaXN0ZW5lckNvdW50ID0gcmVxICYmIHJlcS5saXN0ZW5lcnMoJ3RpbWVvdXQnKS5sZW5ndGggfHwgMDtcblx0ICAgIGRlYnVnKCclcyhyZXF1ZXN0czogJXMsIGZpbmlzaGVkOiAlcykgdGltZW91dCBhZnRlciAlc21zLCBsaXN0ZW5lcnMgJXMsIGRlZmF1bHRUaW1lb3V0TGlzdGVuZXJDb3VudCAlcywgaGFzSHR0cFJlcXVlc3QgJXMsIEh0dHBSZXF1ZXN0IHRpbWVvdXRMaXN0ZW5lckNvdW50ICVzJyxcblx0ICAgICAgc29ja2V0W1NPQ0tFVF9OQU1FXSwgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0NPVU5UXSwgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0ZJTklTSEVEX0NPVU5UXSxcblx0ICAgICAgdGltZW91dCwgbGlzdGVuZXJDb3VudCwgZGVmYXVsdFRpbWVvdXRMaXN0ZW5lckNvdW50LCAhIXJlcSwgcmVxVGltZW91dExpc3RlbmVyQ291bnQpO1xuXHQgICAgaWYgKGRlYnVnLmVuYWJsZWQpIHtcblx0ICAgICAgZGVidWcoJ3RpbWVvdXQgbGlzdGVuZXJzOiAlcycsIHNvY2tldC5saXN0ZW5lcnMoJ3RpbWVvdXQnKS5tYXAoZiA9PiBmLm5hbWUpLmpvaW4oJywgJykpO1xuXHQgICAgfVxuXHQgICAgYWdlbnQudGltZW91dFNvY2tldENvdW50Kys7XG5cdCAgICBjb25zdCBuYW1lID0gYWdlbnQuZ2V0TmFtZShvcHRpb25zKTtcblx0ICAgIGlmIChhZ2VudC5mcmVlU29ja2V0c1tuYW1lXSAmJiBhZ2VudC5mcmVlU29ja2V0c1tuYW1lXS5pbmRleE9mKHNvY2tldCkgIT09IC0xKSB7XG5cdCAgICAgIC8vIGZyZWUgc29ja2V0IHRpbWVvdXQsIGRlc3Ryb3kgcXVpZXRseVxuXHQgICAgICBzb2NrZXQuZGVzdHJveSgpO1xuXHQgICAgICAvLyBSZW1vdmUgaXQgZnJvbSBmcmVlU29ja2V0cyBsaXN0IGltbWVkaWF0ZWx5IHRvIHByZXZlbnQgbmV3IHJlcXVlc3RzXG5cdCAgICAgIC8vIGZyb20gYmVpbmcgc2VudCB0aHJvdWdoIHRoaXMgc29ja2V0LlxuXHQgICAgICBhZ2VudC5yZW1vdmVTb2NrZXQoc29ja2V0LCBvcHRpb25zKTtcblx0ICAgICAgZGVidWcoJyVzIGlzIGZyZWUsIGRlc3Ryb3kgcXVpZXRseScsIHNvY2tldFtTT0NLRVRfTkFNRV0pO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gYW55IHJlcXVlc3Qgc29ja2V0IHRpbWVvdXQgaGFuZGxlcixcblx0ICAgICAgLy8gYWdlbnQgbmVlZCB0byBoYW5kbGUgc29ja2V0IHRpbWVvdXQgaXRzZWxmLlxuXHQgICAgICAvL1xuXHQgICAgICAvLyBjdXN0b20gcmVxdWVzdCBzb2NrZXQgdGltZW91dCBoYW5kbGUgbG9naWMgbXVzdCBmb2xsb3cgdGhlc2UgcnVsZXM6XG5cdCAgICAgIC8vICAxLiBEZXN0cm95IHNvY2tldCBmaXJzdFxuXHQgICAgICAvLyAgMi4gTXVzdCBlbWl0IHNvY2tldCAnYWdlbnRSZW1vdmUnIGV2ZW50IHRlbGwgYWdlbnQgcmVtb3ZlIHNvY2tldFxuXHQgICAgICAvLyAgICAgZnJvbSBmcmVlU29ja2V0cyBsaXN0IGltbWVkaWF0ZWx5LlxuXHQgICAgICAvLyAgICAgT3RoZXJpc2UgeW91IG1heSBiZSBnZXQgJ3NvY2tldCBoYW5nIHVwJyBlcnJvciB3aGVuIHJldXNlXG5cdCAgICAgIC8vICAgICBmcmVlIHNvY2tldCBhbmQgdGltZW91dCBoYXBwZW4gaW4gdGhlIHNhbWUgdGltZS5cblx0ICAgICAgaWYgKHJlcVRpbWVvdXRMaXN0ZW5lckNvdW50ID09PSAwKSB7XG5cdCAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ1NvY2tldCB0aW1lb3V0Jyk7XG5cdCAgICAgICAgZXJyb3IuY29kZSA9ICdFUlJfU09DS0VUX1RJTUVPVVQnO1xuXHQgICAgICAgIGVycm9yLnRpbWVvdXQgPSB0aW1lb3V0O1xuXHQgICAgICAgIC8vIG11c3QgbWFudWFsbHkgY2FsbCBzb2NrZXQuZW5kKCkgb3Igc29ja2V0LmRlc3Ryb3koKSB0byBlbmQgdGhlIGNvbm5lY3Rpb24uXG5cdCAgICAgICAgLy8gaHR0cHM6Ly9ub2RlanMub3JnL2Rpc3QvbGF0ZXN0LXYxMC54L2RvY3MvYXBpL25ldC5odG1sI25ldF9zb2NrZXRfc2V0dGltZW91dF90aW1lb3V0X2NhbGxiYWNrXG5cdCAgICAgICAgc29ja2V0LmRlc3Ryb3koZXJyb3IpO1xuXHQgICAgICAgIGFnZW50LnJlbW92ZVNvY2tldChzb2NrZXQsIG9wdGlvbnMpO1xuXHQgICAgICAgIGRlYnVnKCclcyBkZXN0cm95IHdpdGggdGltZW91dCBlcnJvcicsIHNvY2tldFtTT0NLRVRfTkFNRV0pO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXHQgIHNvY2tldC5vbigndGltZW91dCcsIG9uVGltZW91dCk7XG5cblx0ICBmdW5jdGlvbiBvbkVycm9yKGVycikge1xuXHQgICAgY29uc3QgbGlzdGVuZXJDb3VudCA9IHNvY2tldC5saXN0ZW5lcnMoJ2Vycm9yJykubGVuZ3RoO1xuXHQgICAgZGVidWcoJyVzKHJlcXVlc3RzOiAlcywgZmluaXNoZWQ6ICVzKSBlcnJvcjogJXMsIGxpc3RlbmVyQ291bnQ6ICVzJyxcblx0ICAgICAgc29ja2V0W1NPQ0tFVF9OQU1FXSwgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0NPVU5UXSwgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0ZJTklTSEVEX0NPVU5UXSxcblx0ICAgICAgZXJyLCBsaXN0ZW5lckNvdW50KTtcblx0ICAgIGFnZW50LmVycm9yU29ja2V0Q291bnQrKztcblx0ICAgIGlmIChsaXN0ZW5lckNvdW50ID09PSAxKSB7XG5cdCAgICAgIC8vIGlmIHNvY2tldCBkb24ndCBjb250YWluIGVycm9yIGV2ZW50IGhhbmRsZXIsIGRvbid0IGNhdGNoIGl0LCBlbWl0IGl0IGFnYWluXG5cdCAgICAgIGRlYnVnKCclcyBlbWl0IHVuY2F1Z2h0IGVycm9yIGV2ZW50Jywgc29ja2V0W1NPQ0tFVF9OQU1FXSk7XG5cdCAgICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcblx0ICAgICAgc29ja2V0LmVtaXQoJ2Vycm9yJywgZXJyKTtcblx0ICAgIH1cblx0ICB9XG5cdCAgc29ja2V0Lm9uKCdlcnJvcicsIG9uRXJyb3IpO1xuXG5cdCAgZnVuY3Rpb24gb25SZW1vdmUoKSB7XG5cdCAgICBkZWJ1ZygnJXMocmVxdWVzdHM6ICVzLCBmaW5pc2hlZDogJXMpIGFnZW50UmVtb3ZlJyxcblx0ICAgICAgc29ja2V0W1NPQ0tFVF9OQU1FXSxcblx0ICAgICAgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0NPVU5UXSwgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0ZJTklTSEVEX0NPVU5UXSk7XG5cdCAgICAvLyBXZSBuZWVkIHRoaXMgZnVuY3Rpb24gZm9yIGNhc2VzIGxpa2UgSFRUUCAndXBncmFkZSdcblx0ICAgIC8vIChkZWZpbmVkIGJ5IFdlYlNvY2tldHMpIHdoZXJlIHdlIG5lZWQgdG8gcmVtb3ZlIGEgc29ja2V0IGZyb20gdGhlXG5cdCAgICAvLyBwb29sIGJlY2F1c2UgaXQnbGwgYmUgbG9ja2VkIHVwIGluZGVmaW5pdGVseVxuXHQgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uQ2xvc2UpO1xuXHQgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpO1xuXHQgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdmcmVlJywgb25GcmVlKTtcblx0ICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcigndGltZW91dCcsIG9uVGltZW91dCk7XG5cdCAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2FnZW50UmVtb3ZlJywgb25SZW1vdmUpO1xuXHQgIH1cblx0ICBzb2NrZXQub24oJ2FnZW50UmVtb3ZlJywgb25SZW1vdmUpO1xuXHR9XG5cblx0YWdlbnQgPSBBZ2VudDtcblxuXHRmdW5jdGlvbiBpbnNwZWN0KG9iaikge1xuXHQgIGNvbnN0IHJlcyA9IHt9O1xuXHQgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuXHQgICAgcmVzW2tleV0gPSBvYmpba2V5XS5sZW5ndGg7XG5cdCAgfVxuXHQgIHJldHVybiByZXM7XG5cdH1cblx0cmV0dXJuIGFnZW50O1xufVxuXG52YXIgaHR0cHNfYWdlbnQ7XG52YXIgaGFzUmVxdWlyZWRIdHRwc19hZ2VudDtcblxuZnVuY3Rpb24gcmVxdWlyZUh0dHBzX2FnZW50ICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkSHR0cHNfYWdlbnQpIHJldHVybiBodHRwc19hZ2VudDtcblx0aGFzUmVxdWlyZWRIdHRwc19hZ2VudCA9IDE7XG5cblx0Y29uc3QgT3JpZ2luYWxIdHRwc0FnZW50ID0gcmVxdWlyZSQkMCQyLkFnZW50O1xuXHRjb25zdCBIdHRwQWdlbnQgPSAvKkBfX1BVUkVfXyovIHJlcXVpcmVBZ2VudCgpO1xuXHRjb25zdCB7XG5cdCAgSU5JVF9TT0NLRVQsXG5cdCAgQ1JFQVRFX0hUVFBTX0NPTk5FQ1RJT04sXG5cdH0gPSAvKkBfX1BVUkVfXyovIHJlcXVpcmVDb25zdGFudHMoKTtcblxuXHRjbGFzcyBIdHRwc0FnZW50IGV4dGVuZHMgSHR0cEFnZW50IHtcblx0ICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG5cdCAgICBzdXBlcihvcHRpb25zKTtcblxuXHQgICAgdGhpcy5kZWZhdWx0UG9ydCA9IDQ0Mztcblx0ICAgIHRoaXMucHJvdG9jb2wgPSAnaHR0cHM6Jztcblx0ICAgIHRoaXMubWF4Q2FjaGVkU2Vzc2lvbnMgPSB0aGlzLm9wdGlvbnMubWF4Q2FjaGVkU2Vzc2lvbnM7XG5cdCAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXHQgICAgaWYgKHRoaXMubWF4Q2FjaGVkU2Vzc2lvbnMgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICB0aGlzLm1heENhY2hlZFNlc3Npb25zID0gMTAwO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLl9zZXNzaW9uQ2FjaGUgPSB7XG5cdCAgICAgIG1hcDoge30sXG5cdCAgICAgIGxpc3Q6IFtdLFxuXHQgICAgfTtcblx0ICB9XG5cblx0ICBjcmVhdGVDb25uZWN0aW9uKG9wdGlvbnMsIG9uY3JlYXRlKSB7XG5cdCAgICBjb25zdCBzb2NrZXQgPSB0aGlzW0NSRUFURV9IVFRQU19DT05ORUNUSU9OXShvcHRpb25zLCBvbmNyZWF0ZSk7XG5cdCAgICB0aGlzW0lOSVRfU09DS0VUXShzb2NrZXQsIG9wdGlvbnMpO1xuXHQgICAgcmV0dXJuIHNvY2tldDtcblx0ICB9XG5cdH1cblxuXHQvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi9tYXN0ZXIvbGliL2h0dHBzLmpzI0w4OVxuXHRIdHRwc0FnZW50LnByb3RvdHlwZVtDUkVBVEVfSFRUUFNfQ09OTkVDVElPTl0gPSBPcmlnaW5hbEh0dHBzQWdlbnQucHJvdG90eXBlLmNyZWF0ZUNvbm5lY3Rpb247XG5cblx0W1xuXHQgICdnZXROYW1lJyxcblx0ICAnX2dldFNlc3Npb24nLFxuXHQgICdfY2FjaGVTZXNzaW9uJyxcblx0ICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvcHVsbC80OTgyXG5cdCAgJ19ldmljdFNlc3Npb24nLFxuXHRdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG5cdCAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0ICBpZiAodHlwZW9mIE9yaWdpbmFsSHR0cHNBZ2VudC5wcm90b3R5cGVbbWV0aG9kXSA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgSHR0cHNBZ2VudC5wcm90b3R5cGVbbWV0aG9kXSA9IE9yaWdpbmFsSHR0cHNBZ2VudC5wcm90b3R5cGVbbWV0aG9kXTtcblx0ICB9XG5cdH0pO1xuXG5cdGh0dHBzX2FnZW50ID0gSHR0cHNBZ2VudDtcblx0cmV0dXJuIGh0dHBzX2FnZW50O1xufVxuXG52YXIgaGFzUmVxdWlyZWRBZ2VudGtlZXBhbGl2ZTtcblxuZnVuY3Rpb24gcmVxdWlyZUFnZW50a2VlcGFsaXZlICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkQWdlbnRrZWVwYWxpdmUpIHJldHVybiBhZ2VudGtlZXBhbGl2ZS5leHBvcnRzO1xuXHRoYXNSZXF1aXJlZEFnZW50a2VlcGFsaXZlID0gMTtcblxuXHRhZ2VudGtlZXBhbGl2ZS5leHBvcnRzID0gLypAX19QVVJFX18qLyByZXF1aXJlQWdlbnQoKTtcblx0YWdlbnRrZWVwYWxpdmUuZXhwb3J0cy5IdHRwc0FnZW50ID0gLypAX19QVVJFX18qLyByZXF1aXJlSHR0cHNfYWdlbnQoKTtcblx0YWdlbnRrZWVwYWxpdmUuZXhwb3J0cy5jb25zdGFudHMgPSAvKkBfX1BVUkVfXyovIHJlcXVpcmVDb25zdGFudHMoKTtcblx0cmV0dXJuIGFnZW50a2VlcGFsaXZlLmV4cG9ydHM7XG59XG5cbnZhciBhZ2VudGtlZXBhbGl2ZUV4cG9ydHMgPSAvKkBfX1BVUkVfXyovIHJlcXVpcmVBZ2VudGtlZXBhbGl2ZSgpO1xudmFyIEh0dHBLZWVwQWxpdmVBZ2VudCA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhhZ2VudGtlZXBhbGl2ZUV4cG9ydHMpO1xuXG52YXIgZmFzdFN0YWJsZVN0cmluZ2lmeSQxO1xudmFyIGhhc1JlcXVpcmVkRmFzdFN0YWJsZVN0cmluZ2lmeTtcblxuZnVuY3Rpb24gcmVxdWlyZUZhc3RTdGFibGVTdHJpbmdpZnkgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRGYXN0U3RhYmxlU3RyaW5naWZ5KSByZXR1cm4gZmFzdFN0YWJsZVN0cmluZ2lmeSQxO1xuXHRoYXNSZXF1aXJlZEZhc3RTdGFibGVTdHJpbmdpZnkgPSAxO1xuXHR2YXIgb2JqVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXHR2YXIgb2JqS2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uKG9iaikge1xuXHRcdFx0dmFyIGtleXMgPSBbXTtcblx0XHRcdGZvciAodmFyIG5hbWUgaW4gb2JqKSB7XG5cdFx0XHRcdGtleXMucHVzaChuYW1lKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBrZXlzO1xuXHRcdH07XG5cblx0ZnVuY3Rpb24gc3RyaW5naWZ5KHZhbCwgaXNBcnJheVByb3ApIHtcblx0XHR2YXIgaSwgbWF4LCBzdHIsIGtleXMsIGtleSwgcHJvcFZhbCwgdG9TdHI7XG5cdFx0aWYgKHZhbCA9PT0gdHJ1ZSkge1xuXHRcdFx0cmV0dXJuIFwidHJ1ZVwiO1xuXHRcdH1cblx0XHRpZiAodmFsID09PSBmYWxzZSkge1xuXHRcdFx0cmV0dXJuIFwiZmFsc2VcIjtcblx0XHR9XG5cdFx0c3dpdGNoICh0eXBlb2YgdmFsKSB7XG5cdFx0XHRjYXNlIFwib2JqZWN0XCI6XG5cdFx0XHRcdGlmICh2YWwgPT09IG51bGwpIHtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fSBlbHNlIGlmICh2YWwudG9KU09OICYmIHR5cGVvZiB2YWwudG9KU09OID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHRyZXR1cm4gc3RyaW5naWZ5KHZhbC50b0pTT04oKSwgaXNBcnJheVByb3ApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRvU3RyID0gb2JqVG9TdHJpbmcuY2FsbCh2YWwpO1xuXHRcdFx0XHRcdGlmICh0b1N0ciA9PT0gXCJbb2JqZWN0IEFycmF5XVwiKSB7XG5cdFx0XHRcdFx0XHRzdHIgPSAnWyc7XG5cdFx0XHRcdFx0XHRtYXggPSB2YWwubGVuZ3RoIC0gMTtcblx0XHRcdFx0XHRcdGZvcihpID0gMDsgaSA8IG1heDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdHN0ciArPSBzdHJpbmdpZnkodmFsW2ldLCB0cnVlKSArICcsJztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChtYXggPiAtMSkge1xuXHRcdFx0XHRcdFx0XHRzdHIgKz0gc3RyaW5naWZ5KHZhbFtpXSwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXR1cm4gc3RyICsgJ10nO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodG9TdHIgPT09IFwiW29iamVjdCBPYmplY3RdXCIpIHtcblx0XHRcdFx0XHRcdC8vIG9ubHkgb2JqZWN0IGlzIGxlZnRcblx0XHRcdFx0XHRcdGtleXMgPSBvYmpLZXlzKHZhbCkuc29ydCgpO1xuXHRcdFx0XHRcdFx0bWF4ID0ga2V5cy5sZW5ndGg7XG5cdFx0XHRcdFx0XHRzdHIgPSBcIlwiO1xuXHRcdFx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdFx0XHR3aGlsZSAoaSA8IG1heCkge1xuXHRcdFx0XHRcdFx0XHRrZXkgPSBrZXlzW2ldO1xuXHRcdFx0XHRcdFx0XHRwcm9wVmFsID0gc3RyaW5naWZ5KHZhbFtrZXldLCBmYWxzZSk7XG5cdFx0XHRcdFx0XHRcdGlmIChwcm9wVmFsICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoc3RyKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzdHIgKz0gJywnO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRzdHIgKz0gSlNPTi5zdHJpbmdpZnkoa2V5KSArICc6JyArIHByb3BWYWw7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aSsrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmV0dXJuICd7JyArIHN0ciArICd9Jztcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRjYXNlIFwiZnVuY3Rpb25cIjpcblx0XHRcdGNhc2UgXCJ1bmRlZmluZWRcIjpcblx0XHRcdFx0cmV0dXJuIGlzQXJyYXlQcm9wID8gbnVsbCA6IHVuZGVmaW5lZDtcblx0XHRcdGNhc2UgXCJzdHJpbmdcIjpcblx0XHRcdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbCk7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gaXNGaW5pdGUodmFsKSA/IHZhbCA6IG51bGw7XG5cdFx0fVxuXHR9XG5cblx0ZmFzdFN0YWJsZVN0cmluZ2lmeSQxID0gZnVuY3Rpb24odmFsKSB7XG5cdFx0dmFyIHJldHVyblZhbCA9IHN0cmluZ2lmeSh2YWwsIGZhbHNlKTtcblx0XHRpZiAocmV0dXJuVmFsICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiAnJysgcmV0dXJuVmFsO1xuXHRcdH1cblx0fTtcblx0cmV0dXJuIGZhc3RTdGFibGVTdHJpbmdpZnkkMTtcbn1cblxudmFyIGZhc3RTdGFibGVTdHJpbmdpZnlFeHBvcnRzID0gLypAX19QVVJFX18qLyByZXF1aXJlRmFzdFN0YWJsZVN0cmluZ2lmeSgpO1xudmFyIGZhc3RTdGFibGVTdHJpbmdpZnkgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoZmFzdFN0YWJsZVN0cmluZ2lmeUV4cG9ydHMpO1xuXG5jb25zdCBNSU5JTVVNX1NMT1RfUEVSX0VQT0NIID0gMzI7XG5cbi8vIFJldHVybnMgdGhlIG51bWJlciBvZiB0cmFpbGluZyB6ZXJvcyBpbiB0aGUgYmluYXJ5IHJlcHJlc2VudGF0aW9uIG9mIHNlbGYuXG5mdW5jdGlvbiB0cmFpbGluZ1plcm9zKG4pIHtcbiAgbGV0IHRyYWlsaW5nWmVyb3MgPSAwO1xuICB3aGlsZSAobiA+IDEpIHtcbiAgICBuIC89IDI7XG4gICAgdHJhaWxpbmdaZXJvcysrO1xuICB9XG4gIHJldHVybiB0cmFpbGluZ1plcm9zO1xufVxuXG4vLyBSZXR1cm5zIHRoZSBzbWFsbGVzdCBwb3dlciBvZiB0d28gZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIG5cbmZ1bmN0aW9uIG5leHRQb3dlck9mVHdvKG4pIHtcbiAgaWYgKG4gPT09IDApIHJldHVybiAxO1xuICBuLS07XG4gIG4gfD0gbiA+PiAxO1xuICBuIHw9IG4gPj4gMjtcbiAgbiB8PSBuID4+IDQ7XG4gIG4gfD0gbiA+PiA4O1xuICBuIHw9IG4gPj4gMTY7XG4gIG4gfD0gbiA+PiAzMjtcbiAgcmV0dXJuIG4gKyAxO1xufVxuXG4vKipcbiAqIEVwb2NoIHNjaGVkdWxlXG4gKiAoc2VlIGh0dHBzOi8vZG9jcy5zb2xhbmEuY29tL3Rlcm1pbm9sb2d5I2Vwb2NoKVxuICogQ2FuIGJlIHJldHJpZXZlZCB3aXRoIHRoZSB7QGxpbmsgQ29ubmVjdGlvbi5nZXRFcG9jaFNjaGVkdWxlfSBtZXRob2RcbiAqL1xuY2xhc3MgRXBvY2hTY2hlZHVsZSB7XG4gIGNvbnN0cnVjdG9yKHNsb3RzUGVyRXBvY2gsIGxlYWRlclNjaGVkdWxlU2xvdE9mZnNldCwgd2FybXVwLCBmaXJzdE5vcm1hbEVwb2NoLCBmaXJzdE5vcm1hbFNsb3QpIHtcbiAgICAvKiogVGhlIG1heGltdW0gbnVtYmVyIG9mIHNsb3RzIGluIGVhY2ggZXBvY2ggKi9cbiAgICB0aGlzLnNsb3RzUGVyRXBvY2ggPSB2b2lkIDA7XG4gICAgLyoqIFRoZSBudW1iZXIgb2Ygc2xvdHMgYmVmb3JlIGJlZ2lubmluZyBvZiBhbiBlcG9jaCB0byBjYWxjdWxhdGUgYSBsZWFkZXIgc2NoZWR1bGUgZm9yIHRoYXQgZXBvY2ggKi9cbiAgICB0aGlzLmxlYWRlclNjaGVkdWxlU2xvdE9mZnNldCA9IHZvaWQgMDtcbiAgICAvKiogSW5kaWNhdGVzIHdoZXRoZXIgZXBvY2hzIHN0YXJ0IHNob3J0IGFuZCBncm93ICovXG4gICAgdGhpcy53YXJtdXAgPSB2b2lkIDA7XG4gICAgLyoqIFRoZSBmaXJzdCBlcG9jaCB3aXRoIGBzbG90c1BlckVwb2NoYCBzbG90cyAqL1xuICAgIHRoaXMuZmlyc3ROb3JtYWxFcG9jaCA9IHZvaWQgMDtcbiAgICAvKiogVGhlIGZpcnN0IHNsb3Qgb2YgYGZpcnN0Tm9ybWFsRXBvY2hgICovXG4gICAgdGhpcy5maXJzdE5vcm1hbFNsb3QgPSB2b2lkIDA7XG4gICAgdGhpcy5zbG90c1BlckVwb2NoID0gc2xvdHNQZXJFcG9jaDtcbiAgICB0aGlzLmxlYWRlclNjaGVkdWxlU2xvdE9mZnNldCA9IGxlYWRlclNjaGVkdWxlU2xvdE9mZnNldDtcbiAgICB0aGlzLndhcm11cCA9IHdhcm11cDtcbiAgICB0aGlzLmZpcnN0Tm9ybWFsRXBvY2ggPSBmaXJzdE5vcm1hbEVwb2NoO1xuICAgIHRoaXMuZmlyc3ROb3JtYWxTbG90ID0gZmlyc3ROb3JtYWxTbG90O1xuICB9XG4gIGdldEVwb2NoKHNsb3QpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRFcG9jaEFuZFNsb3RJbmRleChzbG90KVswXTtcbiAgfVxuICBnZXRFcG9jaEFuZFNsb3RJbmRleChzbG90KSB7XG4gICAgaWYgKHNsb3QgPCB0aGlzLmZpcnN0Tm9ybWFsU2xvdCkge1xuICAgICAgY29uc3QgZXBvY2ggPSB0cmFpbGluZ1plcm9zKG5leHRQb3dlck9mVHdvKHNsb3QgKyBNSU5JTVVNX1NMT1RfUEVSX0VQT0NIICsgMSkpIC0gdHJhaWxpbmdaZXJvcyhNSU5JTVVNX1NMT1RfUEVSX0VQT0NIKSAtIDE7XG4gICAgICBjb25zdCBlcG9jaExlbiA9IHRoaXMuZ2V0U2xvdHNJbkVwb2NoKGVwb2NoKTtcbiAgICAgIGNvbnN0IHNsb3RJbmRleCA9IHNsb3QgLSAoZXBvY2hMZW4gLSBNSU5JTVVNX1NMT1RfUEVSX0VQT0NIKTtcbiAgICAgIHJldHVybiBbZXBvY2gsIHNsb3RJbmRleF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG5vcm1hbFNsb3RJbmRleCA9IHNsb3QgLSB0aGlzLmZpcnN0Tm9ybWFsU2xvdDtcbiAgICAgIGNvbnN0IG5vcm1hbEVwb2NoSW5kZXggPSBNYXRoLmZsb29yKG5vcm1hbFNsb3RJbmRleCAvIHRoaXMuc2xvdHNQZXJFcG9jaCk7XG4gICAgICBjb25zdCBlcG9jaCA9IHRoaXMuZmlyc3ROb3JtYWxFcG9jaCArIG5vcm1hbEVwb2NoSW5kZXg7XG4gICAgICBjb25zdCBzbG90SW5kZXggPSBub3JtYWxTbG90SW5kZXggJSB0aGlzLnNsb3RzUGVyRXBvY2g7XG4gICAgICByZXR1cm4gW2Vwb2NoLCBzbG90SW5kZXhdO1xuICAgIH1cbiAgfVxuICBnZXRGaXJzdFNsb3RJbkVwb2NoKGVwb2NoKSB7XG4gICAgaWYgKGVwb2NoIDw9IHRoaXMuZmlyc3ROb3JtYWxFcG9jaCkge1xuICAgICAgcmV0dXJuIChNYXRoLnBvdygyLCBlcG9jaCkgLSAxKSAqIE1JTklNVU1fU0xPVF9QRVJfRVBPQ0g7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoZXBvY2ggLSB0aGlzLmZpcnN0Tm9ybWFsRXBvY2gpICogdGhpcy5zbG90c1BlckVwb2NoICsgdGhpcy5maXJzdE5vcm1hbFNsb3Q7XG4gICAgfVxuICB9XG4gIGdldExhc3RTbG90SW5FcG9jaChlcG9jaCkge1xuICAgIHJldHVybiB0aGlzLmdldEZpcnN0U2xvdEluRXBvY2goZXBvY2gpICsgdGhpcy5nZXRTbG90c0luRXBvY2goZXBvY2gpIC0gMTtcbiAgfVxuICBnZXRTbG90c0luRXBvY2goZXBvY2gpIHtcbiAgICBpZiAoZXBvY2ggPCB0aGlzLmZpcnN0Tm9ybWFsRXBvY2gpIHtcbiAgICAgIHJldHVybiBNYXRoLnBvdygyLCBlcG9jaCArIHRyYWlsaW5nWmVyb3MoTUlOSU1VTV9TTE9UX1BFUl9FUE9DSCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5zbG90c1BlckVwb2NoO1xuICAgIH1cbiAgfVxufVxuXG52YXIgZmV0Y2hJbXBsID0gdHlwZW9mIGdsb2JhbFRoaXMuZmV0Y2ggPT09ICdmdW5jdGlvbicgP1xuLy8gVGhlIEZldGNoIEFQSSBpcyBzdXBwb3J0ZWQgZXhwZXJpbWVudGFsbHkgaW4gTm9kZSAxNy41KyBhbmQgbmF0aXZlbHkgaW4gTm9kZSAxOCsuXG5nbG9iYWxUaGlzLmZldGNoIDpcbi8vIE90aGVyd2lzZSB1c2UgdGhlIHBvbHlmaWxsLlxuYXN5bmMgZnVuY3Rpb24gKGlucHV0LCBpbml0KSB7XG4gIGNvbnN0IHByb2Nlc3NlZElucHV0ID0gdHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJyAmJiBpbnB1dC5zbGljZSgwLCAyKSA9PT0gJy8vJyA/ICdodHRwczonICsgaW5wdXQgOiBpbnB1dDtcbiAgcmV0dXJuIGF3YWl0IG5vZGVGZXRjaC5kZWZhdWx0KHByb2Nlc3NlZElucHV0LCBpbml0KTtcbn07XG5cbmNsYXNzIFJwY1dlYlNvY2tldENsaWVudCBleHRlbmRzIENvbW1vbkNsaWVudCB7XG4gIGNvbnN0cnVjdG9yKGFkZHJlc3MsIG9wdGlvbnMsIGdlbmVyYXRlX3JlcXVlc3RfaWQpIHtcbiAgICBjb25zdCB3ZWJTb2NrZXRGYWN0b3J5ID0gdXJsID0+IHtcbiAgICAgIGNvbnN0IHJwYyA9IFdlYlNvY2tldCh1cmwsIHtcbiAgICAgICAgYXV0b2Nvbm5lY3Q6IHRydWUsXG4gICAgICAgIG1heF9yZWNvbm5lY3RzOiA1LFxuICAgICAgICByZWNvbm5lY3Q6IHRydWUsXG4gICAgICAgIHJlY29ubmVjdF9pbnRlcnZhbDogMTAwMCxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSk7XG4gICAgICBpZiAoJ3NvY2tldCcgaW4gcnBjKSB7XG4gICAgICAgIHRoaXMudW5kZXJseWluZ1NvY2tldCA9IHJwYy5zb2NrZXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnVuZGVybHlpbmdTb2NrZXQgPSBycGM7XG4gICAgICB9XG4gICAgICByZXR1cm4gcnBjO1xuICAgIH07XG4gICAgc3VwZXIod2ViU29ja2V0RmFjdG9yeSwgYWRkcmVzcywgb3B0aW9ucywgZ2VuZXJhdGVfcmVxdWVzdF9pZCk7XG4gICAgdGhpcy51bmRlcmx5aW5nU29ja2V0ID0gdm9pZCAwO1xuICB9XG4gIGNhbGwoLi4uYXJncykge1xuICAgIGNvbnN0IHJlYWR5U3RhdGUgPSB0aGlzLnVuZGVybHlpbmdTb2NrZXQ/LnJlYWR5U3RhdGU7XG4gICAgaWYgKHJlYWR5U3RhdGUgPT09IDEgLyogV2ViU29ja2V0Lk9QRU4gKi8pIHtcbiAgICAgIHJldHVybiBzdXBlci5jYWxsKC4uLmFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdUcmllZCB0byBjYWxsIGEgSlNPTi1SUEMgbWV0aG9kIGAnICsgYXJnc1swXSArICdgIGJ1dCB0aGUgc29ja2V0IHdhcyBub3QgYENPTk5FQ1RJTkdgIG9yIGBPUEVOYCAoYHJlYWR5U3RhdGVgIHdhcyAnICsgcmVhZHlTdGF0ZSArICcpJykpO1xuICB9XG4gIG5vdGlmeSguLi5hcmdzKSB7XG4gICAgY29uc3QgcmVhZHlTdGF0ZSA9IHRoaXMudW5kZXJseWluZ1NvY2tldD8ucmVhZHlTdGF0ZTtcbiAgICBpZiAocmVhZHlTdGF0ZSA9PT0gMSAvKiBXZWJTb2NrZXQuT1BFTiAqLykge1xuICAgICAgcmV0dXJuIHN1cGVyLm5vdGlmeSguLi5hcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignVHJpZWQgdG8gc2VuZCBhIEpTT04tUlBDIG5vdGlmaWNhdGlvbiBgJyArIGFyZ3NbMF0gKyAnYCBidXQgdGhlIHNvY2tldCB3YXMgbm90IGBDT05ORUNUSU5HYCBvciBgT1BFTmAgKGByZWFkeVN0YXRlYCB3YXMgJyArIHJlYWR5U3RhdGUgKyAnKScpKTtcbiAgfVxufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5cbi8qKlxuICogRGVjb2RlIGFjY291bnQgZGF0YSBidWZmZXIgdXNpbmcgYW4gQWNjb3VudFR5cGVcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBkZWNvZGVEYXRhKHR5cGUsIGRhdGEpIHtcbiAgbGV0IGRlY29kZWQ7XG4gIHRyeSB7XG4gICAgZGVjb2RlZCA9IHR5cGUubGF5b3V0LmRlY29kZShkYXRhKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGluc3RydWN0aW9uOyAnICsgZXJyKTtcbiAgfVxuICBpZiAoZGVjb2RlZC50eXBlSW5kZXggIT09IHR5cGUuaW5kZXgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgYWNjb3VudCBkYXRhOyBhY2NvdW50IHR5cGUgbWlzbWF0Y2ggJHtkZWNvZGVkLnR5cGVJbmRleH0gIT0gJHt0eXBlLmluZGV4fWApO1xuICB9XG4gIHJldHVybiBkZWNvZGVkO1xufVxuXG4vLy8gVGhlIHNlcmlhbGl6ZWQgc2l6ZSBvZiBsb29rdXAgdGFibGUgbWV0YWRhdGFcbmNvbnN0IExPT0tVUF9UQUJMRV9NRVRBX1NJWkUgPSA1NjtcbmNsYXNzIEFkZHJlc3NMb29rdXBUYWJsZUFjY291bnQge1xuICBjb25zdHJ1Y3RvcihhcmdzKSB7XG4gICAgdGhpcy5rZXkgPSB2b2lkIDA7XG4gICAgdGhpcy5zdGF0ZSA9IHZvaWQgMDtcbiAgICB0aGlzLmtleSA9IGFyZ3Mua2V5O1xuICAgIHRoaXMuc3RhdGUgPSBhcmdzLnN0YXRlO1xuICB9XG4gIGlzQWN0aXZlKCkge1xuICAgIGNvbnN0IFU2NF9NQVggPSBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZicpO1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmRlYWN0aXZhdGlvblNsb3QgPT09IFU2NF9NQVg7XG4gIH1cbiAgc3RhdGljIGRlc2VyaWFsaXplKGFjY291bnREYXRhKSB7XG4gICAgY29uc3QgbWV0YSA9IGRlY29kZURhdGEoTG9va3VwVGFibGVNZXRhTGF5b3V0LCBhY2NvdW50RGF0YSk7XG4gICAgY29uc3Qgc2VyaWFsaXplZEFkZHJlc3Nlc0xlbiA9IGFjY291bnREYXRhLmxlbmd0aCAtIExPT0tVUF9UQUJMRV9NRVRBX1NJWkU7XG4gICAgYXNzZXJ0KHNlcmlhbGl6ZWRBZGRyZXNzZXNMZW4gPj0gMCwgJ2xvb2t1cCB0YWJsZSBpcyBpbnZhbGlkJyk7XG4gICAgYXNzZXJ0KHNlcmlhbGl6ZWRBZGRyZXNzZXNMZW4gJSAzMiA9PT0gMCwgJ2xvb2t1cCB0YWJsZSBpcyBpbnZhbGlkJyk7XG4gICAgY29uc3QgbnVtU2VyaWFsaXplZEFkZHJlc3NlcyA9IHNlcmlhbGl6ZWRBZGRyZXNzZXNMZW4gLyAzMjtcbiAgICBjb25zdCB7XG4gICAgICBhZGRyZXNzZXNcbiAgICB9ID0gQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnNlcShwdWJsaWNLZXkoKSwgbnVtU2VyaWFsaXplZEFkZHJlc3NlcywgJ2FkZHJlc3NlcycpXSkuZGVjb2RlKGFjY291bnREYXRhLnNsaWNlKExPT0tVUF9UQUJMRV9NRVRBX1NJWkUpKTtcbiAgICByZXR1cm4ge1xuICAgICAgZGVhY3RpdmF0aW9uU2xvdDogbWV0YS5kZWFjdGl2YXRpb25TbG90LFxuICAgICAgbGFzdEV4dGVuZGVkU2xvdDogbWV0YS5sYXN0RXh0ZW5kZWRTbG90LFxuICAgICAgbGFzdEV4dGVuZGVkU2xvdFN0YXJ0SW5kZXg6IG1ldGEubGFzdEV4dGVuZGVkU3RhcnRJbmRleCxcbiAgICAgIGF1dGhvcml0eTogbWV0YS5hdXRob3JpdHkubGVuZ3RoICE9PSAwID8gbmV3IFB1YmxpY0tleShtZXRhLmF1dGhvcml0eVswXSkgOiB1bmRlZmluZWQsXG4gICAgICBhZGRyZXNzZXM6IGFkZHJlc3Nlcy5tYXAoYWRkcmVzcyA9PiBuZXcgUHVibGljS2V5KGFkZHJlc3MpKVxuICAgIH07XG4gIH1cbn1cbmNvbnN0IExvb2t1cFRhYmxlTWV0YUxheW91dCA9IHtcbiAgaW5kZXg6IDEsXG4gIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMigndHlwZUluZGV4JyksIHU2NCgnZGVhY3RpdmF0aW9uU2xvdCcpLCBCdWZmZXJMYXlvdXQubnU2NCgnbGFzdEV4dGVuZGVkU2xvdCcpLCBCdWZmZXJMYXlvdXQudTgoJ2xhc3RFeHRlbmRlZFN0YXJ0SW5kZXgnKSwgQnVmZmVyTGF5b3V0LnU4KCksXG4gIC8vIG9wdGlvblxuICBCdWZmZXJMYXlvdXQuc2VxKHB1YmxpY0tleSgpLCBCdWZmZXJMYXlvdXQub2Zmc2V0KEJ1ZmZlckxheW91dC51OCgpLCAtMSksICdhdXRob3JpdHknKV0pXG59O1xuXG5jb25zdCBVUkxfUkUgPSAvXlteOl0rOlxcL1xcLyhbXjpbXSt8XFxbW15cXF1dK1xcXSkoOlxcZCspPyguKikvaTtcbmZ1bmN0aW9uIG1ha2VXZWJzb2NrZXRVcmwoZW5kcG9pbnQpIHtcbiAgY29uc3QgbWF0Y2hlcyA9IGVuZHBvaW50Lm1hdGNoKFVSTF9SRSk7XG4gIGlmIChtYXRjaGVzID09IG51bGwpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoYEZhaWxlZCB0byB2YWxpZGF0ZSBlbmRwb2ludCBVUkwgXFxgJHtlbmRwb2ludH1cXGBgKTtcbiAgfVxuICBjb25zdCBbXyxcbiAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgaG9zdGlzaCwgcG9ydFdpdGhDb2xvbiwgcmVzdF0gPSBtYXRjaGVzO1xuICBjb25zdCBwcm90b2NvbCA9IGVuZHBvaW50LnN0YXJ0c1dpdGgoJ2h0dHBzOicpID8gJ3dzczonIDogJ3dzOic7XG4gIGNvbnN0IHN0YXJ0UG9ydCA9IHBvcnRXaXRoQ29sb24gPT0gbnVsbCA/IG51bGwgOiBwYXJzZUludChwb3J0V2l0aENvbG9uLnNsaWNlKDEpLCAxMCk7XG4gIGNvbnN0IHdlYnNvY2tldFBvcnQgPVxuICAvLyBPbmx5IHNoaWZ0IHRoZSBwb3J0IGJ5ICsxIGFzIGEgY29udmVudGlvbiBmb3Igd3Mocykgb25seSBpZiBnaXZlbiBlbmRwb2ludFxuICAvLyBpcyBleHBsaWNpdGx5IHNwZWNpZnlpbmcgdGhlIGVuZHBvaW50IHBvcnQgKEhUVFAtYmFzZWQgUlBDKSwgYXNzdW1pbmdcbiAgLy8gd2UncmUgZGlyZWN0bHkgdHJ5aW5nIHRvIGNvbm5lY3QgdG8gYWdhdmUtdmFsaWRhdG9yJ3Mgd3MgbGlzdGVuaW5nIHBvcnQuXG4gIC8vIFdoZW4gdGhlIGVuZHBvaW50IG9taXRzIHRoZSBwb3J0LCB3ZSdyZSBjb25uZWN0aW5nIHRvIHRoZSBwcm90b2NvbFxuICAvLyBkZWZhdWx0IHBvcnRzOiBodHRwKDgwKSBvciBodHRwcyg0NDMpIGFuZCBpdCdzIGFzc3VtZWQgd2UncmUgYmVoaW5kIGEgcmV2ZXJzZVxuICAvLyBwcm94eSB3aGljaCBtYW5hZ2VzIFdlYlNvY2tldCB1cGdyYWRlIGFuZCBiYWNrZW5kIHBvcnQgcmVkaXJlY3Rpb24uXG4gIHN0YXJ0UG9ydCA9PSBudWxsID8gJycgOiBgOiR7c3RhcnRQb3J0ICsgMX1gO1xuICByZXR1cm4gYCR7cHJvdG9jb2x9Ly8ke2hvc3Rpc2h9JHt3ZWJzb2NrZXRQb3J0fSR7cmVzdH1gO1xufVxuXG5jb25zdCBQdWJsaWNLZXlGcm9tU3RyaW5nID0gY29lcmNlKGluc3RhbmNlKFB1YmxpY0tleSksIHN0cmluZygpLCB2YWx1ZSA9PiBuZXcgUHVibGljS2V5KHZhbHVlKSk7XG5jb25zdCBSYXdBY2NvdW50RGF0YVJlc3VsdCA9IHR1cGxlKFtzdHJpbmcoKSwgbGl0ZXJhbCgnYmFzZTY0JyldKTtcbmNvbnN0IEJ1ZmZlckZyb21SYXdBY2NvdW50RGF0YSA9IGNvZXJjZShpbnN0YW5jZShCdWZmZXIpLCBSYXdBY2NvdW50RGF0YVJlc3VsdCwgdmFsdWUgPT4gQnVmZmVyLmZyb20odmFsdWVbMF0sICdiYXNlNjQnKSk7XG5cbi8qKlxuICogQXR0ZW1wdCB0byB1c2UgYSByZWNlbnQgYmxvY2toYXNoIGZvciB1cCB0byAzMCBzZWNvbmRzXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgQkxPQ0tIQVNIX0NBQ0hFX1RJTUVPVVRfTVMgPSAzMCAqIDEwMDA7XG5cbi8qKlxuICogSEFDSy5cbiAqIENvcGllZCBmcm9tIHJwYy13ZWJzb2NrZXRzL2Rpc3QvbGliL2NsaWVudC5cbiAqIE90aGVyd2lzZSwgYHlhcm4gYnVpbGRgIGZhaWxzIHdpdGg6XG4gKiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9zdGV2ZWx1c2NoZXIvYzA1N2VjYTgxZDQ3OWVmNzA1Y2RiNTMxNjJmOTk3MWRcbiAqL1xuXG4vKiogQGludGVybmFsICovXG4vKiogQGludGVybmFsICovXG4vKiogQGludGVybmFsICovXG4vKiogQGludGVybmFsICovXG5cbi8qKiBAaW50ZXJuYWwgKi9cbi8qKlxuICogQGludGVybmFsXG4gKiBFdmVyeSBzdWJzY3JpcHRpb24gY29udGFpbnMgdGhlIGFyZ3MgdXNlZCB0byBvcGVuIHRoZSBzdWJzY3JpcHRpb24gd2l0aFxuICogdGhlIHNlcnZlciwgYW5kIGEgbGlzdCBvZiBjYWxsZXJzIGludGVyZXN0ZWQgaW4gbm90aWZpY2F0aW9ucy5cbiAqL1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICogQSBzdWJzY3JpcHRpb24gbWF5IGJlIGluIHZhcmlvdXMgc3RhdGVzIG9mIGNvbm5lY3RlZG5lc3MuIE9ubHkgd2hlbiBpdCBpc1xuICogZnVsbHkgY29ubmVjdGVkIHdpbGwgaXQgaGF2ZSBhIHNlcnZlciBzdWJzY3JpcHRpb24gaWQgYXNzb2NpYXRlZCB3aXRoIGl0LlxuICogVGhpcyBpZCBjYW4gYmUgcmV0dXJuZWQgdG8gdGhlIHNlcnZlciB0byB1bnN1YnNjcmliZSB0aGUgY2xpZW50IGVudGlyZWx5LlxuICovXG5cbi8qKlxuICogQSB0eXBlIHRoYXQgZW5jYXBzdWxhdGVzIGEgc3Vic2NyaXB0aW9uJ3MgUlBDIG1ldGhvZFxuICogbmFtZXMgYW5kIG5vdGlmaWNhdGlvbiAoY2FsbGJhY2spIHNpZ25hdHVyZS5cbiAqL1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICogVXRpbGl0eSB0eXBlIHRoYXQga2VlcHMgdGFnZ2VkIHVuaW9ucyBpbnRhY3Qgd2hpbGUgb21pdHRpbmcgcHJvcGVydGllcy5cbiAqL1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICogVGhpcyB0eXBlIHJlcHJlc2VudHMgYSBzaW5nbGUgc3Vic2NyaWJhYmxlICd0b3BpYy4nIEl0J3MgbWFkZSB1cCBvZjpcbiAqXG4gKiAtIFRoZSBhcmdzIHVzZWQgdG8gb3BlbiB0aGUgc3Vic2NyaXB0aW9uIHdpdGggdGhlIHNlcnZlcixcbiAqIC0gVGhlIHN0YXRlIG9mIHRoZSBzdWJzY3JpcHRpb24sIGluIHRlcm1zIG9mIGl0cyBjb25uZWN0ZWRuZXNzLCBhbmRcbiAqIC0gVGhlIHNldCBvZiBjYWxsYmFja3MgdG8gY2FsbCB3aGVuIHRoZSBzZXJ2ZXIgcHVibGlzaGVzIG5vdGlmaWNhdGlvbnNcbiAqXG4gKiBUaGlzIHJlY29yZCBnZXRzIGluZGV4ZWQgYnkgYFN1YnNjcmlwdGlvbkNvbmZpZ0hhc2hgIGFuZCBpcyB1c2VkIHRvXG4gKiBzZXQgdXAgc3Vic2NyaXB0aW9ucywgZmFuIG91dCBub3RpZmljYXRpb25zLCBhbmQgdHJhY2sgc3Vic2NyaXB0aW9uIHN0YXRlLlxuICovXG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cblxuLyoqXG4gKiBFeHRyYSBjb250ZXh0dWFsIGluZm9ybWF0aW9uIGZvciBSUEMgcmVzcG9uc2VzXG4gKi9cblxuLyoqXG4gKiBPcHRpb25zIGZvciBzZW5kaW5nIHRyYW5zYWN0aW9uc1xuICovXG5cbi8qKlxuICogT3B0aW9ucyBmb3IgY29uZmlybWluZyB0cmFuc2FjdGlvbnNcbiAqL1xuXG4vKipcbiAqIE9wdGlvbnMgZm9yIGdldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzMlxuICovXG5cbi8qKlxuICogT3B0aW9ucyBmb3IgZ2V0U2lnbmF0dXJlc0ZvckFkZHJlc3NcbiAqL1xuXG4vKipcbiAqIFJQQyBSZXNwb25zZSB3aXRoIGV4dHJhIGNvbnRleHR1YWwgaW5mb3JtYXRpb25cbiAqL1xuXG4vKipcbiAqIEEgc3RyYXRlZ3kgZm9yIGNvbmZpcm1pbmcgdHJhbnNhY3Rpb25zIHRoYXQgdXNlcyB0aGUgbGFzdCB2YWxpZFxuICogYmxvY2sgaGVpZ2h0IGZvciBhIGdpdmVuIGJsb2NraGFzaCB0byBjaGVjayBmb3IgdHJhbnNhY3Rpb24gZXhwaXJhdGlvbi5cbiAqL1xuXG4vKipcbiAqIEEgc3RyYXRlZ3kgZm9yIGNvbmZpcm1pbmcgZHVyYWJsZSBub25jZSB0cmFuc2FjdGlvbnMuXG4gKi9cblxuLyoqXG4gKiBQcm9wZXJ0aWVzIHNoYXJlZCBieSBhbGwgdHJhbnNhY3Rpb24gY29uZmlybWF0aW9uIHN0cmF0ZWdpZXNcbiAqL1xuXG4vKipcbiAqIFRoaXMgdHlwZSByZXByZXNlbnRzIGFsbCB0cmFuc2FjdGlvbiBjb25maXJtYXRpb24gc3RyYXRlZ2llc1xuICovXG5cbi8qIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gYXNzZXJ0RW5kcG9pbnRVcmwocHV0YXRpdmVVcmwpIHtcbiAgaWYgKC9eaHR0cHM/Oi8udGVzdChwdXRhdGl2ZVVybCkgPT09IGZhbHNlKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRW5kcG9pbnQgVVJMIG11c3Qgc3RhcnQgd2l0aCBgaHR0cDpgIG9yIGBodHRwczpgLicpO1xuICB9XG4gIHJldHVybiBwdXRhdGl2ZVVybDtcbn1cblxuLyoqIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZykge1xuICBsZXQgY29tbWl0bWVudDtcbiAgbGV0IGNvbmZpZztcbiAgaWYgKHR5cGVvZiBjb21taXRtZW50T3JDb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgY29tbWl0bWVudCA9IGNvbW1pdG1lbnRPckNvbmZpZztcbiAgfSBlbHNlIGlmIChjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50OiBzcGVjaWZpZWRDb21taXRtZW50LFxuICAgICAgLi4uc3BlY2lmaWVkQ29uZmlnXG4gICAgfSA9IGNvbW1pdG1lbnRPckNvbmZpZztcbiAgICBjb21taXRtZW50ID0gc3BlY2lmaWVkQ29tbWl0bWVudDtcbiAgICBjb25maWcgPSBzcGVjaWZpZWRDb25maWc7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBjb21taXRtZW50LFxuICAgIGNvbmZpZ1xuICB9O1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBhcHBseURlZmF1bHRNZW1jbXBFbmNvZGluZ1RvRmlsdGVycyhmaWx0ZXJzKSB7XG4gIHJldHVybiBmaWx0ZXJzLm1hcChmaWx0ZXIgPT4gJ21lbWNtcCcgaW4gZmlsdGVyID8ge1xuICAgIC4uLmZpbHRlcixcbiAgICBtZW1jbXA6IHtcbiAgICAgIC4uLmZpbHRlci5tZW1jbXAsXG4gICAgICBlbmNvZGluZzogZmlsdGVyLm1lbWNtcC5lbmNvZGluZyA/PyAnYmFzZTU4J1xuICAgIH1cbiAgfSA6IGZpbHRlcik7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJwY1Jlc3VsdChyZXN1bHQpIHtcbiAgcmV0dXJuIHVuaW9uKFt0eXBlKHtcbiAgICBqc29ucnBjOiBsaXRlcmFsKCcyLjAnKSxcbiAgICBpZDogc3RyaW5nKCksXG4gICAgcmVzdWx0XG4gIH0pLCB0eXBlKHtcbiAgICBqc29ucnBjOiBsaXRlcmFsKCcyLjAnKSxcbiAgICBpZDogc3RyaW5nKCksXG4gICAgZXJyb3I6IHR5cGUoe1xuICAgICAgY29kZTogdW5rbm93bigpLFxuICAgICAgbWVzc2FnZTogc3RyaW5nKCksXG4gICAgICBkYXRhOiBvcHRpb25hbChhbnkoKSlcbiAgICB9KVxuICB9KV0pO1xufVxuY29uc3QgVW5rbm93blJwY1Jlc3VsdCA9IGNyZWF0ZVJwY1Jlc3VsdCh1bmtub3duKCkpO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBqc29uUnBjUmVzdWx0KHNjaGVtYSkge1xuICByZXR1cm4gY29lcmNlKGNyZWF0ZVJwY1Jlc3VsdChzY2hlbWEpLCBVbmtub3duUnBjUmVzdWx0LCB2YWx1ZSA9PiB7XG4gICAgaWYgKCdlcnJvcicgaW4gdmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4udmFsdWUsXG4gICAgICAgIHJlc3VsdDogY3JlYXRlKHZhbHVlLnJlc3VsdCwgc2NoZW1hKVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBqc29uUnBjUmVzdWx0QW5kQ29udGV4dCh2YWx1ZSkge1xuICByZXR1cm4ganNvblJwY1Jlc3VsdCh0eXBlKHtcbiAgICBjb250ZXh0OiB0eXBlKHtcbiAgICAgIHNsb3Q6IG51bWJlcigpXG4gICAgfSksXG4gICAgdmFsdWVcbiAgfSkpO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBub3RpZmljYXRpb25SZXN1bHRBbmRDb250ZXh0KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlKHtcbiAgICBjb250ZXh0OiB0eXBlKHtcbiAgICAgIHNsb3Q6IG51bWJlcigpXG4gICAgfSksXG4gICAgdmFsdWVcbiAgfSk7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHZlcnNpb25lZE1lc3NhZ2VGcm9tUmVzcG9uc2UodmVyc2lvbiwgcmVzcG9uc2UpIHtcbiAgaWYgKHZlcnNpb24gPT09IDApIHtcbiAgICByZXR1cm4gbmV3IE1lc3NhZ2VWMCh7XG4gICAgICBoZWFkZXI6IHJlc3BvbnNlLmhlYWRlcixcbiAgICAgIHN0YXRpY0FjY291bnRLZXlzOiByZXNwb25zZS5hY2NvdW50S2V5cy5tYXAoYWNjb3VudEtleSA9PiBuZXcgUHVibGljS2V5KGFjY291bnRLZXkpKSxcbiAgICAgIHJlY2VudEJsb2NraGFzaDogcmVzcG9uc2UucmVjZW50QmxvY2toYXNoLFxuICAgICAgY29tcGlsZWRJbnN0cnVjdGlvbnM6IHJlc3BvbnNlLmluc3RydWN0aW9ucy5tYXAoaXggPT4gKHtcbiAgICAgICAgcHJvZ3JhbUlkSW5kZXg6IGl4LnByb2dyYW1JZEluZGV4LFxuICAgICAgICBhY2NvdW50S2V5SW5kZXhlczogaXguYWNjb3VudHMsXG4gICAgICAgIGRhdGE6IGJzNTguZGVjb2RlKGl4LmRhdGEpXG4gICAgICB9KSksXG4gICAgICBhZGRyZXNzVGFibGVMb29rdXBzOiByZXNwb25zZS5hZGRyZXNzVGFibGVMb29rdXBzXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBNZXNzYWdlKHJlc3BvbnNlKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBsZXZlbCBvZiBjb21taXRtZW50IGRlc2lyZWQgd2hlbiBxdWVyeWluZyBzdGF0ZVxuICogPHByZT5cbiAqICAgJ3Byb2Nlc3NlZCc6IFF1ZXJ5IHRoZSBtb3N0IHJlY2VudCBibG9jayB3aGljaCBoYXMgcmVhY2hlZCAxIGNvbmZpcm1hdGlvbiBieSB0aGUgY29ubmVjdGVkIG5vZGVcbiAqICAgJ2NvbmZpcm1lZCc6IFF1ZXJ5IHRoZSBtb3N0IHJlY2VudCBibG9jayB3aGljaCBoYXMgcmVhY2hlZCAxIGNvbmZpcm1hdGlvbiBieSB0aGUgY2x1c3RlclxuICogICAnZmluYWxpemVkJzogUXVlcnkgdGhlIG1vc3QgcmVjZW50IGJsb2NrIHdoaWNoIGhhcyBiZWVuIGZpbmFsaXplZCBieSB0aGUgY2x1c3RlclxuICogPC9wcmU+XG4gKi9cblxuLy8gRGVwcmVjYXRlZCBhcyBvZiB2MS41LjVcblxuLyoqXG4gKiBBIHN1YnNldCBvZiBDb21taXRtZW50IGxldmVscywgd2hpY2ggYXJlIGF0IGxlYXN0IG9wdGltaXN0aWNhbGx5IGNvbmZpcm1lZFxuICogPHByZT5cbiAqICAgJ2NvbmZpcm1lZCc6IFF1ZXJ5IHRoZSBtb3N0IHJlY2VudCBibG9jayB3aGljaCBoYXMgcmVhY2hlZCAxIGNvbmZpcm1hdGlvbiBieSB0aGUgY2x1c3RlclxuICogICAnZmluYWxpemVkJzogUXVlcnkgdGhlIG1vc3QgcmVjZW50IGJsb2NrIHdoaWNoIGhhcyBiZWVuIGZpbmFsaXplZCBieSB0aGUgY2x1c3RlclxuICogPC9wcmU+XG4gKi9cblxuLyoqXG4gKiBGaWx0ZXIgZm9yIGxhcmdlc3QgYWNjb3VudHMgcXVlcnlcbiAqIDxwcmU+XG4gKiAgICdjaXJjdWxhdGluZyc6ICAgIFJldHVybiB0aGUgbGFyZ2VzdCBhY2NvdW50cyB0aGF0IGFyZSBwYXJ0IG9mIHRoZSBjaXJjdWxhdGluZyBzdXBwbHlcbiAqICAgJ25vbkNpcmN1bGF0aW5nJzogUmV0dXJuIHRoZSBsYXJnZXN0IGFjY291bnRzIHRoYXQgYXJlIG5vdCBwYXJ0IG9mIHRoZSBjaXJjdWxhdGluZyBzdXBwbHlcbiAqIDwvcHJlPlxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRBY2NvdW50SW5mb2AgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0QmFsYW5jZWAgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0QmxvY2tgIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldEJsb2NrYCBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRTdGFrZU1pbmltdW1EZWxlZ2F0aW9uYCBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRCbG9ja0hlaWdodGAgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0RXBvY2hJbmZvYCBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRJbmZsYXRpb25SZXdhcmRgIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldExhdGVzdEJsb2NraGFzaGAgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgaXNCbG9ja2hhc2hWYWxpZGAgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0U2xvdGAgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0U2xvdExlYWRlcmAgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0VHJhbnNhY3Rpb25gIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldFRyYW5zYWN0aW9uYCBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRMYXJnZXN0QWNjb3VudHNgIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldFN1cHBseWAgcmVxdWVzdCBiZWhhdmlvclxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBJbmZvcm1hdGlvbiBkZXNjcmliaW5nIGEgY2x1c3RlciBub2RlXG4gKi9cblxuLyoqXG4gKiBJbmZvcm1hdGlvbiBkZXNjcmliaW5nIGEgdm90ZSBhY2NvdW50XG4gKi9cblxuLyoqXG4gKiBBIGNvbGxlY3Rpb24gb2YgY2x1c3RlciB2b3RlIGFjY291bnRzXG4gKi9cblxuLyoqXG4gKiBOZXR3b3JrIEluZmxhdGlvblxuICogKHNlZSBodHRwczovL2RvY3Muc29sYW5hLmNvbS9pbXBsZW1lbnRlZC1wcm9wb3NhbHMvZWRfb3ZlcnZpZXcpXG4gKi9cblxuY29uc3QgR2V0SW5mbGF0aW9uR292ZXJub3JSZXN1bHQgPSB0eXBlKHtcbiAgZm91bmRhdGlvbjogbnVtYmVyKCksXG4gIGZvdW5kYXRpb25UZXJtOiBudW1iZXIoKSxcbiAgaW5pdGlhbDogbnVtYmVyKCksXG4gIHRhcGVyOiBudW1iZXIoKSxcbiAgdGVybWluYWw6IG51bWJlcigpXG59KTtcblxuLyoqXG4gKiBUaGUgaW5mbGF0aW9uIHJld2FyZCBmb3IgYW4gZXBvY2hcbiAqL1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRJbmZsYXRpb25SZXdhcmRcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldEluZmxhdGlvblJld2FyZFJlc3VsdCA9IGpzb25ScGNSZXN1bHQoYXJyYXkobnVsbGFibGUodHlwZSh7XG4gIGVwb2NoOiBudW1iZXIoKSxcbiAgZWZmZWN0aXZlU2xvdDogbnVtYmVyKCksXG4gIGFtb3VudDogbnVtYmVyKCksXG4gIHBvc3RCYWxhbmNlOiBudW1iZXIoKSxcbiAgY29tbWlzc2lvbjogb3B0aW9uYWwobnVsbGFibGUobnVtYmVyKCkpKVxufSkpKSk7XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRSZWNlbnRQcmlvcml0aXphdGlvbkZlZXNgIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0UmVjZW50UHJpb3JpdGl6YXRpb25GZWVzXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRSZWNlbnRQcmlvcml0aXphdGlvbkZlZXNSZXN1bHQgPSBhcnJheSh0eXBlKHtcbiAgc2xvdDogbnVtYmVyKCksXG4gIHByaW9yaXRpemF0aW9uRmVlOiBudW1iZXIoKVxufSkpO1xuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0SW5mbGF0aW9uUmF0ZVwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0SW5mbGF0aW9uUmF0ZVJlc3VsdCA9IHR5cGUoe1xuICB0b3RhbDogbnVtYmVyKCksXG4gIHZhbGlkYXRvcjogbnVtYmVyKCksXG4gIGZvdW5kYXRpb246IG51bWJlcigpLFxuICBlcG9jaDogbnVtYmVyKClcbn0pO1xuXG4vKipcbiAqIEluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50IGVwb2NoXG4gKi9cblxuY29uc3QgR2V0RXBvY2hJbmZvUmVzdWx0ID0gdHlwZSh7XG4gIGVwb2NoOiBudW1iZXIoKSxcbiAgc2xvdEluZGV4OiBudW1iZXIoKSxcbiAgc2xvdHNJbkVwb2NoOiBudW1iZXIoKSxcbiAgYWJzb2x1dGVTbG90OiBudW1iZXIoKSxcbiAgYmxvY2tIZWlnaHQ6IG9wdGlvbmFsKG51bWJlcigpKSxcbiAgdHJhbnNhY3Rpb25Db3VudDogb3B0aW9uYWwobnVtYmVyKCkpXG59KTtcbmNvbnN0IEdldEVwb2NoU2NoZWR1bGVSZXN1bHQgPSB0eXBlKHtcbiAgc2xvdHNQZXJFcG9jaDogbnVtYmVyKCksXG4gIGxlYWRlclNjaGVkdWxlU2xvdE9mZnNldDogbnVtYmVyKCksXG4gIHdhcm11cDogYm9vbGVhbigpLFxuICBmaXJzdE5vcm1hbEVwb2NoOiBudW1iZXIoKSxcbiAgZmlyc3ROb3JtYWxTbG90OiBudW1iZXIoKVxufSk7XG5cbi8qKlxuICogTGVhZGVyIHNjaGVkdWxlXG4gKiAoc2VlIGh0dHBzOi8vZG9jcy5zb2xhbmEuY29tL3Rlcm1pbm9sb2d5I2xlYWRlci1zY2hlZHVsZSlcbiAqL1xuXG5jb25zdCBHZXRMZWFkZXJTY2hlZHVsZVJlc3VsdCA9IHJlY29yZChzdHJpbmcoKSwgYXJyYXkobnVtYmVyKCkpKTtcblxuLyoqXG4gKiBUcmFuc2FjdGlvbiBlcnJvciBvciBudWxsXG4gKi9cbmNvbnN0IFRyYW5zYWN0aW9uRXJyb3JSZXN1bHQgPSBudWxsYWJsZSh1bmlvbihbdHlwZSh7fSksIHN0cmluZygpXSkpO1xuXG4vKipcbiAqIFNpZ25hdHVyZSBzdGF0dXMgZm9yIGEgdHJhbnNhY3Rpb25cbiAqL1xuY29uc3QgU2lnbmF0dXJlU3RhdHVzUmVzdWx0ID0gdHlwZSh7XG4gIGVycjogVHJhbnNhY3Rpb25FcnJvclJlc3VsdFxufSk7XG5cbi8qKlxuICogVHJhbnNhY3Rpb24gc2lnbmF0dXJlIHJlY2VpdmVkIG5vdGlmaWNhdGlvblxuICovXG5jb25zdCBTaWduYXR1cmVSZWNlaXZlZFJlc3VsdCA9IGxpdGVyYWwoJ3JlY2VpdmVkU2lnbmF0dXJlJyk7XG5cbi8qKlxuICogVmVyc2lvbiBpbmZvIGZvciBhIG5vZGVcbiAqL1xuXG5jb25zdCBWZXJzaW9uUmVzdWx0ID0gdHlwZSh7XG4gICdzb2xhbmEtY29yZSc6IHN0cmluZygpLFxuICAnZmVhdHVyZS1zZXQnOiBvcHRpb25hbChudW1iZXIoKSlcbn0pO1xuY29uc3QgUGFyc2VkSW5zdHJ1Y3Rpb25TdHJ1Y3QgPSB0eXBlKHtcbiAgcHJvZ3JhbTogc3RyaW5nKCksXG4gIHByb2dyYW1JZDogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgcGFyc2VkOiB1bmtub3duKClcbn0pO1xuY29uc3QgUGFydGlhbGx5RGVjb2RlZEluc3RydWN0aW9uU3RydWN0ID0gdHlwZSh7XG4gIHByb2dyYW1JZDogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgYWNjb3VudHM6IGFycmF5KFB1YmxpY0tleUZyb21TdHJpbmcpLFxuICBkYXRhOiBzdHJpbmcoKVxufSk7XG5jb25zdCBTaW11bGF0ZWRUcmFuc2FjdGlvblJlc3BvbnNlU3RydWN0ID0ganNvblJwY1Jlc3VsdEFuZENvbnRleHQodHlwZSh7XG4gIGVycjogbnVsbGFibGUodW5pb24oW3R5cGUoe30pLCBzdHJpbmcoKV0pKSxcbiAgbG9nczogbnVsbGFibGUoYXJyYXkoc3RyaW5nKCkpKSxcbiAgYWNjb3VudHM6IG9wdGlvbmFsKG51bGxhYmxlKGFycmF5KG51bGxhYmxlKHR5cGUoe1xuICAgIGV4ZWN1dGFibGU6IGJvb2xlYW4oKSxcbiAgICBvd25lcjogc3RyaW5nKCksXG4gICAgbGFtcG9ydHM6IG51bWJlcigpLFxuICAgIGRhdGE6IGFycmF5KHN0cmluZygpKSxcbiAgICByZW50RXBvY2g6IG9wdGlvbmFsKG51bWJlcigpKVxuICB9KSkpKSksXG4gIHVuaXRzQ29uc3VtZWQ6IG9wdGlvbmFsKG51bWJlcigpKSxcbiAgcmV0dXJuRGF0YTogb3B0aW9uYWwobnVsbGFibGUodHlwZSh7XG4gICAgcHJvZ3JhbUlkOiBzdHJpbmcoKSxcbiAgICBkYXRhOiB0dXBsZShbc3RyaW5nKCksIGxpdGVyYWwoJ2Jhc2U2NCcpXSlcbiAgfSkpKSxcbiAgaW5uZXJJbnN0cnVjdGlvbnM6IG9wdGlvbmFsKG51bGxhYmxlKGFycmF5KHR5cGUoe1xuICAgIGluZGV4OiBudW1iZXIoKSxcbiAgICBpbnN0cnVjdGlvbnM6IGFycmF5KHVuaW9uKFtQYXJzZWRJbnN0cnVjdGlvblN0cnVjdCwgUGFydGlhbGx5RGVjb2RlZEluc3RydWN0aW9uU3RydWN0XSkpXG4gIH0pKSkpXG59KSk7XG5cbi8qKlxuICogTWV0YWRhdGEgZm9yIGEgcGFyc2VkIGNvbmZpcm1lZCB0cmFuc2FjdGlvbiBvbiB0aGUgbGVkZ2VyXG4gKlxuICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBSUEMgdjEuOC4wLiBQbGVhc2UgdXNlIHtAbGluayBQYXJzZWRUcmFuc2FjdGlvbk1ldGF9IGluc3RlYWQuXG4gKi9cblxuLyoqXG4gKiBDb2xsZWN0aW9uIG9mIGFkZHJlc3NlcyBsb2FkZWQgYnkgYSB0cmFuc2FjdGlvbiB1c2luZyBhZGRyZXNzIHRhYmxlIGxvb2t1cHNcbiAqL1xuXG4vKipcbiAqIE1ldGFkYXRhIGZvciBhIHBhcnNlZCB0cmFuc2FjdGlvbiBvbiB0aGUgbGVkZ2VyXG4gKi9cblxuLyoqXG4gKiBNZXRhZGF0YSBmb3IgYSBjb25maXJtZWQgdHJhbnNhY3Rpb24gb24gdGhlIGxlZGdlclxuICovXG5cbi8qKlxuICogQSBwcm9jZXNzZWQgdHJhbnNhY3Rpb24gZnJvbSB0aGUgUlBDIEFQSVxuICovXG5cbi8qKlxuICogQSBwcm9jZXNzZWQgdHJhbnNhY3Rpb24gZnJvbSB0aGUgUlBDIEFQSVxuICovXG5cbi8qKlxuICogQSBwcm9jZXNzZWQgdHJhbnNhY3Rpb24gbWVzc2FnZSBmcm9tIHRoZSBSUEMgQVBJXG4gKi9cblxuLyoqXG4gKiBBIGNvbmZpcm1lZCB0cmFuc2FjdGlvbiBvbiB0aGUgbGVkZ2VyXG4gKlxuICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBSUEMgdjEuOC4wLlxuICovXG5cbi8qKlxuICogQSBwYXJ0aWFsbHkgZGVjb2RlZCB0cmFuc2FjdGlvbiBpbnN0cnVjdGlvblxuICovXG5cbi8qKlxuICogQSBwYXJzZWQgdHJhbnNhY3Rpb24gbWVzc2FnZSBhY2NvdW50XG4gKi9cblxuLyoqXG4gKiBBIHBhcnNlZCB0cmFuc2FjdGlvbiBpbnN0cnVjdGlvblxuICovXG5cbi8qKlxuICogQSBwYXJzZWQgYWRkcmVzcyB0YWJsZSBsb29rdXBcbiAqL1xuXG4vKipcbiAqIEEgcGFyc2VkIHRyYW5zYWN0aW9uIG1lc3NhZ2VcbiAqL1xuXG4vKipcbiAqIEEgcGFyc2VkIHRyYW5zYWN0aW9uXG4gKi9cblxuLyoqXG4gKiBBIHBhcnNlZCBhbmQgY29uZmlybWVkIHRyYW5zYWN0aW9uIG9uIHRoZSBsZWRnZXJcbiAqXG4gKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFJQQyB2MS44LjAuIFBsZWFzZSB1c2Uge0BsaW5rIFBhcnNlZFRyYW5zYWN0aW9uV2l0aE1ldGF9IGluc3RlYWQuXG4gKi9cblxuLyoqXG4gKiBBIHBhcnNlZCB0cmFuc2FjdGlvbiBvbiB0aGUgbGVkZ2VyIHdpdGggbWV0YVxuICovXG5cbi8qKlxuICogQSBwcm9jZXNzZWQgYmxvY2sgZmV0Y2hlZCBmcm9tIHRoZSBSUEMgQVBJXG4gKi9cblxuLyoqXG4gKiBBIHByb2Nlc3NlZCBibG9jayBmZXRjaGVkIGZyb20gdGhlIFJQQyBBUEkgd2hlcmUgdGhlIGB0cmFuc2FjdGlvbkRldGFpbHNgIG1vZGUgaXMgYGFjY291bnRzYFxuICovXG5cbi8qKlxuICogQSBwcm9jZXNzZWQgYmxvY2sgZmV0Y2hlZCBmcm9tIHRoZSBSUEMgQVBJIHdoZXJlIHRoZSBgdHJhbnNhY3Rpb25EZXRhaWxzYCBtb2RlIGlzIGBub25lYFxuICovXG5cbi8qKlxuICogQSBibG9jayB3aXRoIHBhcnNlZCB0cmFuc2FjdGlvbnNcbiAqL1xuXG4vKipcbiAqIEEgYmxvY2sgd2l0aCBwYXJzZWQgdHJhbnNhY3Rpb25zIHdoZXJlIHRoZSBgdHJhbnNhY3Rpb25EZXRhaWxzYCBtb2RlIGlzIGBhY2NvdW50c2BcbiAqL1xuXG4vKipcbiAqIEEgYmxvY2sgd2l0aCBwYXJzZWQgdHJhbnNhY3Rpb25zIHdoZXJlIHRoZSBgdHJhbnNhY3Rpb25EZXRhaWxzYCBtb2RlIGlzIGBub25lYFxuICovXG5cbi8qKlxuICogQSBwcm9jZXNzZWQgYmxvY2sgZmV0Y2hlZCBmcm9tIHRoZSBSUEMgQVBJXG4gKi9cblxuLyoqXG4gKiBBIHByb2Nlc3NlZCBibG9jayBmZXRjaGVkIGZyb20gdGhlIFJQQyBBUEkgd2hlcmUgdGhlIGB0cmFuc2FjdGlvbkRldGFpbHNgIG1vZGUgaXMgYGFjY291bnRzYFxuICovXG5cbi8qKlxuICogQSBwcm9jZXNzZWQgYmxvY2sgZmV0Y2hlZCBmcm9tIHRoZSBSUEMgQVBJIHdoZXJlIHRoZSBgdHJhbnNhY3Rpb25EZXRhaWxzYCBtb2RlIGlzIGBub25lYFxuICovXG5cbi8qKlxuICogQSBjb25maXJtZWQgYmxvY2sgb24gdGhlIGxlZGdlclxuICpcbiAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgUlBDIHYxLjguMC5cbiAqL1xuXG4vKipcbiAqIEEgQmxvY2sgb24gdGhlIGxlZGdlciB3aXRoIHNpZ25hdHVyZXMgb25seVxuICovXG5cbi8qKlxuICogcmVjZW50IGJsb2NrIHByb2R1Y3Rpb24gaW5mb3JtYXRpb25cbiAqL1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRCbG9ja1Byb2R1Y3Rpb25cIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEJsb2NrUHJvZHVjdGlvblJlc3BvbnNlU3RydWN0ID0ganNvblJwY1Jlc3VsdEFuZENvbnRleHQodHlwZSh7XG4gIGJ5SWRlbnRpdHk6IHJlY29yZChzdHJpbmcoKSwgYXJyYXkobnVtYmVyKCkpKSxcbiAgcmFuZ2U6IHR5cGUoe1xuICAgIGZpcnN0U2xvdDogbnVtYmVyKCksXG4gICAgbGFzdFNsb3Q6IG51bWJlcigpXG4gIH0pXG59KSk7XG5cbi8qKlxuICogQSBwZXJmb3JtYW5jZSBzYW1wbGVcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVScGNDbGllbnQodXJsLCBodHRwSGVhZGVycywgY3VzdG9tRmV0Y2gsIGZldGNoTWlkZGxld2FyZSwgZGlzYWJsZVJldHJ5T25SYXRlTGltaXQsIGh0dHBBZ2VudCkge1xuICBjb25zdCBmZXRjaCA9IGN1c3RvbUZldGNoID8gY3VzdG9tRmV0Y2ggOiBmZXRjaEltcGw7XG4gIGxldCBhZ2VudDtcbiAge1xuICAgIGlmIChodHRwQWdlbnQgPT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICBjb25zdCBhZ2VudE9wdGlvbnMgPSB7XG4gICAgICAgICAgLy8gT25lIHNlY29uZCBmZXdlciB0aGFuIHRoZSBTb2xhbmEgUlBDJ3Mga2VlcGFsaXZlIHRpbWVvdXQuXG4gICAgICAgICAgLy8gUmVhZCBtb3JlOiBodHRwczovL2dpdGh1Yi5jb20vc29sYW5hLWxhYnMvc29sYW5hL2lzc3Vlcy8yNzg1OSNpc3N1ZWNvbW1lbnQtMTM0MDA5Nzg4OVxuICAgICAgICAgIGZyZWVTb2NrZXRUaW1lb3V0OiAxOTAwMCxcbiAgICAgICAgICBrZWVwQWxpdmU6IHRydWUsXG4gICAgICAgICAgbWF4U29ja2V0czogMjVcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHVybC5zdGFydHNXaXRoKCdodHRwczonKSkge1xuICAgICAgICAgIGFnZW50ID0gbmV3IGFnZW50a2VlcGFsaXZlRXhwb3J0cy5IdHRwc0FnZW50KGFnZW50T3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWdlbnQgPSBuZXcgSHR0cEtlZXBBbGl2ZUFnZW50KGFnZW50T3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGh0dHBBZ2VudCAhPT0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgaXNIdHRwcyA9IHVybC5zdGFydHNXaXRoKCdodHRwczonKTtcbiAgICAgICAgaWYgKGlzSHR0cHMgJiYgIShodHRwQWdlbnQgaW5zdGFuY2VvZiBBZ2VudCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBlbmRwb2ludCBgJyArIHVybCArICdgIGNhbiBvbmx5IGJlIHBhaXJlZCB3aXRoIGFuIGBodHRwcy5BZ2VudGAuIFlvdSBoYXZlLCBpbnN0ZWFkLCBzdXBwbGllZCBhbiAnICsgJ2BodHRwLkFnZW50YCB0aHJvdWdoIGBodHRwQWdlbnRgLicpO1xuICAgICAgICB9IGVsc2UgaWYgKCFpc0h0dHBzICYmIGh0dHBBZ2VudCBpbnN0YW5jZW9mIEFnZW50KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZW5kcG9pbnQgYCcgKyB1cmwgKyAnYCBjYW4gb25seSBiZSBwYWlyZWQgd2l0aCBhbiBgaHR0cC5BZ2VudGAuIFlvdSBoYXZlLCBpbnN0ZWFkLCBzdXBwbGllZCBhbiAnICsgJ2BodHRwcy5BZ2VudGAgdGhyb3VnaCBgaHR0cEFnZW50YC4nKTtcbiAgICAgICAgfVxuICAgICAgICBhZ2VudCA9IGh0dHBBZ2VudDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbGV0IGZldGNoV2l0aE1pZGRsZXdhcmU7XG4gIGlmIChmZXRjaE1pZGRsZXdhcmUpIHtcbiAgICBmZXRjaFdpdGhNaWRkbGV3YXJlID0gYXN5bmMgKGluZm8sIGluaXQpID0+IHtcbiAgICAgIGNvbnN0IG1vZGlmaWVkRmV0Y2hBcmdzID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZldGNoTWlkZGxld2FyZShpbmZvLCBpbml0LCAobW9kaWZpZWRJbmZvLCBtb2RpZmllZEluaXQpID0+IHJlc29sdmUoW21vZGlmaWVkSW5mbywgbW9kaWZpZWRJbml0XSkpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGF3YWl0IGZldGNoKC4uLm1vZGlmaWVkRmV0Y2hBcmdzKTtcbiAgICB9O1xuICB9XG4gIGNvbnN0IGNsaWVudEJyb3dzZXIgPSBuZXcgUnBjQ2xpZW50KGFzeW5jIChyZXF1ZXN0LCBjYWxsYmFjaykgPT4ge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGJvZHk6IHJlcXVlc3QsXG4gICAgICBhZ2VudCxcbiAgICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICB9LCBodHRwSGVhZGVycyB8fCB7fSwgQ09NTU9OX0hUVFBfSEVBREVSUylcbiAgICB9O1xuICAgIHRyeSB7XG4gICAgICBsZXQgdG9vX21hbnlfcmVxdWVzdHNfcmV0cmllcyA9IDU7XG4gICAgICBsZXQgcmVzO1xuICAgICAgbGV0IHdhaXRUaW1lID0gNTAwO1xuICAgICAgZm9yICg7Oykge1xuICAgICAgICBpZiAoZmV0Y2hXaXRoTWlkZGxld2FyZSkge1xuICAgICAgICAgIHJlcyA9IGF3YWl0IGZldGNoV2l0aE1pZGRsZXdhcmUodXJsLCBvcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXMgPSBhd2FpdCBmZXRjaCh1cmwsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXMuc3RhdHVzICE9PSA0MjkgLyogVG9vIG1hbnkgcmVxdWVzdHMgKi8pIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlzYWJsZVJldHJ5T25SYXRlTGltaXQgPT09IHRydWUpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0b29fbWFueV9yZXF1ZXN0c19yZXRyaWVzIC09IDE7XG4gICAgICAgIGlmICh0b29fbWFueV9yZXF1ZXN0c19yZXRyaWVzID09PSAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5lcnJvcihgU2VydmVyIHJlc3BvbmRlZCB3aXRoICR7cmVzLnN0YXR1c30gJHtyZXMuc3RhdHVzVGV4dH0uICBSZXRyeWluZyBhZnRlciAke3dhaXRUaW1lfW1zIGRlbGF5Li4uYCk7XG4gICAgICAgIGF3YWl0IHNsZWVwKHdhaXRUaW1lKTtcbiAgICAgICAgd2FpdFRpbWUgKj0gMjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgaWYgKHJlcy5vaykge1xuICAgICAgICBjYWxsYmFjayhudWxsLCB0ZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcihgJHtyZXMuc3RhdHVzfSAke3Jlcy5zdGF0dXNUZXh0fTogJHt0ZXh0fWApKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikgY2FsbGJhY2soZXJyKTtcbiAgICB9XG4gIH0sIHt9KTtcbiAgcmV0dXJuIGNsaWVudEJyb3dzZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVScGNSZXF1ZXN0KGNsaWVudCkge1xuICByZXR1cm4gKG1ldGhvZCwgYXJncykgPT4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjbGllbnQucmVxdWVzdChtZXRob2QsIGFyZ3MsIChlcnIsIHJlc3BvbnNlKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJwY0JhdGNoUmVxdWVzdChjbGllbnQpIHtcbiAgcmV0dXJuIHJlcXVlc3RzID0+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgLy8gRG8gbm90aGluZyBpZiByZXF1ZXN0cyBpcyBlbXB0eVxuICAgICAgaWYgKHJlcXVlc3RzLmxlbmd0aCA9PT0gMCkgcmVzb2x2ZShbXSk7XG4gICAgICBjb25zdCBiYXRjaCA9IHJlcXVlc3RzLm1hcChwYXJhbXMgPT4ge1xuICAgICAgICByZXR1cm4gY2xpZW50LnJlcXVlc3QocGFyYW1zLm1ldGhvZE5hbWUsIHBhcmFtcy5hcmdzKTtcbiAgICAgIH0pO1xuICAgICAgY2xpZW50LnJlcXVlc3QoYmF0Y2gsIChlcnIsIHJlc3BvbnNlKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbn1cblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0SW5mbGF0aW9uR292ZXJub3JcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldEluZmxhdGlvbkdvdmVybm9yUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChHZXRJbmZsYXRpb25Hb3Zlcm5vclJlc3VsdCk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEluZmxhdGlvblJhdGVcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldEluZmxhdGlvblJhdGVScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KEdldEluZmxhdGlvblJhdGVSZXN1bHQpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRSZWNlbnRQcmlvcml0aXphdGlvbkZlZXNcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldFJlY2VudFByaW9yaXRpemF0aW9uRmVlc1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoR2V0UmVjZW50UHJpb3JpdGl6YXRpb25GZWVzUmVzdWx0KTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0RXBvY2hJbmZvXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRFcG9jaEluZm9ScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KEdldEVwb2NoSW5mb1Jlc3VsdCk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEVwb2NoU2NoZWR1bGVcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldEVwb2NoU2NoZWR1bGVScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KEdldEVwb2NoU2NoZWR1bGVSZXN1bHQpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRMZWFkZXJTY2hlZHVsZVwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0TGVhZGVyU2NoZWR1bGVScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KEdldExlYWRlclNjaGVkdWxlUmVzdWx0KTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwibWluaW11bUxlZGdlclNsb3RcIiBhbmQgXCJnZXRGaXJzdEF2YWlsYWJsZUJsb2NrXCIgbWVzc2FnZXNcbiAqL1xuY29uc3QgU2xvdFJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQobnVtYmVyKCkpO1xuXG4vKipcbiAqIFN1cHBseVxuICovXG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFN1cHBseVwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0U3VwcGx5UnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdEFuZENvbnRleHQodHlwZSh7XG4gIHRvdGFsOiBudW1iZXIoKSxcbiAgY2lyY3VsYXRpbmc6IG51bWJlcigpLFxuICBub25DaXJjdWxhdGluZzogbnVtYmVyKCksXG4gIG5vbkNpcmN1bGF0aW5nQWNjb3VudHM6IGFycmF5KFB1YmxpY0tleUZyb21TdHJpbmcpXG59KSk7XG5cbi8qKlxuICogVG9rZW4gYW1vdW50IG9iamVjdCB3aGljaCByZXR1cm5zIGEgdG9rZW4gYW1vdW50IGluIGRpZmZlcmVudCBmb3JtYXRzXG4gKiBmb3IgdmFyaW91cyBjbGllbnQgdXNlIGNhc2VzLlxuICovXG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgc3RydWN0dXJlIGZvciB0b2tlbiBhbW91bnRzXG4gKi9cbmNvbnN0IFRva2VuQW1vdW50UmVzdWx0ID0gdHlwZSh7XG4gIGFtb3VudDogc3RyaW5nKCksXG4gIHVpQW1vdW50OiBudWxsYWJsZShudW1iZXIoKSksXG4gIGRlY2ltYWxzOiBudW1iZXIoKSxcbiAgdWlBbW91bnRTdHJpbmc6IG9wdGlvbmFsKHN0cmluZygpKVxufSk7XG5cbi8qKlxuICogVG9rZW4gYWRkcmVzcyBhbmQgYmFsYW5jZS5cbiAqL1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRUb2tlbkxhcmdlc3RBY2NvdW50c1wiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0VG9rZW5MYXJnZXN0QWNjb3VudHNSZXN1bHQgPSBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChhcnJheSh0eXBlKHtcbiAgYWRkcmVzczogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgYW1vdW50OiBzdHJpbmcoKSxcbiAgdWlBbW91bnQ6IG51bGxhYmxlKG51bWJlcigpKSxcbiAgZGVjaW1hbHM6IG51bWJlcigpLFxuICB1aUFtb3VudFN0cmluZzogb3B0aW9uYWwoc3RyaW5nKCkpXG59KSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRUb2tlbkFjY291bnRzQnlPd25lclwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0VG9rZW5BY2NvdW50c0J5T3duZXIgPSBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChhcnJheSh0eXBlKHtcbiAgcHVia2V5OiBQdWJsaWNLZXlGcm9tU3RyaW5nLFxuICBhY2NvdW50OiB0eXBlKHtcbiAgICBleGVjdXRhYmxlOiBib29sZWFuKCksXG4gICAgb3duZXI6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gICAgbGFtcG9ydHM6IG51bWJlcigpLFxuICAgIGRhdGE6IEJ1ZmZlckZyb21SYXdBY2NvdW50RGF0YSxcbiAgICByZW50RXBvY2g6IG51bWJlcigpXG4gIH0pXG59KSkpO1xuY29uc3QgUGFyc2VkQWNjb3VudERhdGFSZXN1bHQgPSB0eXBlKHtcbiAgcHJvZ3JhbTogc3RyaW5nKCksXG4gIHBhcnNlZDogdW5rbm93bigpLFxuICBzcGFjZTogbnVtYmVyKClcbn0pO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRUb2tlbkFjY291bnRzQnlPd25lclwiIG1lc3NhZ2Ugd2l0aCBwYXJzZWQgZGF0YVxuICovXG5jb25zdCBHZXRQYXJzZWRUb2tlbkFjY291bnRzQnlPd25lciA9IGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KGFycmF5KHR5cGUoe1xuICBwdWJrZXk6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gIGFjY291bnQ6IHR5cGUoe1xuICAgIGV4ZWN1dGFibGU6IGJvb2xlYW4oKSxcbiAgICBvd25lcjogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgICBsYW1wb3J0czogbnVtYmVyKCksXG4gICAgZGF0YTogUGFyc2VkQWNjb3VudERhdGFSZXN1bHQsXG4gICAgcmVudEVwb2NoOiBudW1iZXIoKVxuICB9KVxufSkpKTtcblxuLyoqXG4gKiBQYWlyIG9mIGFuIGFjY291bnQgYWRkcmVzcyBhbmQgaXRzIGJhbGFuY2VcbiAqL1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRMYXJnZXN0QWNjb3VudHNcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldExhcmdlc3RBY2NvdW50c1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KGFycmF5KHR5cGUoe1xuICBsYW1wb3J0czogbnVtYmVyKCksXG4gIGFkZHJlc3M6IFB1YmxpY0tleUZyb21TdHJpbmdcbn0pKSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IEFjY291bnRJbmZvUmVzdWx0ID0gdHlwZSh7XG4gIGV4ZWN1dGFibGU6IGJvb2xlYW4oKSxcbiAgb3duZXI6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gIGxhbXBvcnRzOiBudW1iZXIoKSxcbiAgZGF0YTogQnVmZmVyRnJvbVJhd0FjY291bnREYXRhLFxuICByZW50RXBvY2g6IG51bWJlcigpXG59KTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgS2V5ZWRBY2NvdW50SW5mb1Jlc3VsdCA9IHR5cGUoe1xuICBwdWJrZXk6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gIGFjY291bnQ6IEFjY291bnRJbmZvUmVzdWx0XG59KTtcbmNvbnN0IFBhcnNlZE9yUmF3QWNjb3VudERhdGEgPSBjb2VyY2UodW5pb24oW2luc3RhbmNlKEJ1ZmZlciksIFBhcnNlZEFjY291bnREYXRhUmVzdWx0XSksIHVuaW9uKFtSYXdBY2NvdW50RGF0YVJlc3VsdCwgUGFyc2VkQWNjb3VudERhdGFSZXN1bHRdKSwgdmFsdWUgPT4ge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gY3JlYXRlKHZhbHVlLCBCdWZmZXJGcm9tUmF3QWNjb3VudERhdGEpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFBhcnNlZEFjY291bnRJbmZvUmVzdWx0ID0gdHlwZSh7XG4gIGV4ZWN1dGFibGU6IGJvb2xlYW4oKSxcbiAgb3duZXI6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gIGxhbXBvcnRzOiBudW1iZXIoKSxcbiAgZGF0YTogUGFyc2VkT3JSYXdBY2NvdW50RGF0YSxcbiAgcmVudEVwb2NoOiBudW1iZXIoKVxufSk7XG5jb25zdCBLZXllZFBhcnNlZEFjY291bnRJbmZvUmVzdWx0ID0gdHlwZSh7XG4gIHB1YmtleTogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgYWNjb3VudDogUGFyc2VkQWNjb3VudEluZm9SZXN1bHRcbn0pO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBTdGFrZUFjdGl2YXRpb25SZXN1bHQgPSB0eXBlKHtcbiAgc3RhdGU6IHVuaW9uKFtsaXRlcmFsKCdhY3RpdmUnKSwgbGl0ZXJhbCgnaW5hY3RpdmUnKSwgbGl0ZXJhbCgnYWN0aXZhdGluZycpLCBsaXRlcmFsKCdkZWFjdGl2YXRpbmcnKV0pLFxuICBhY3RpdmU6IG51bWJlcigpLFxuICBpbmFjdGl2ZTogbnVtYmVyKClcbn0pO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRDb25maXJtZWRTaWduYXR1cmVzRm9yQWRkcmVzczJcIiBtZXNzYWdlXG4gKi9cblxuY29uc3QgR2V0Q29uZmlybWVkU2lnbmF0dXJlc0ZvckFkZHJlc3MyUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChhcnJheSh0eXBlKHtcbiAgc2lnbmF0dXJlOiBzdHJpbmcoKSxcbiAgc2xvdDogbnVtYmVyKCksXG4gIGVycjogVHJhbnNhY3Rpb25FcnJvclJlc3VsdCxcbiAgbWVtbzogbnVsbGFibGUoc3RyaW5nKCkpLFxuICBibG9ja1RpbWU6IG9wdGlvbmFsKG51bGxhYmxlKG51bWJlcigpKSlcbn0pKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFNpZ25hdHVyZXNGb3JBZGRyZXNzXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRTaWduYXR1cmVzRm9yQWRkcmVzc1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoYXJyYXkodHlwZSh7XG4gIHNpZ25hdHVyZTogc3RyaW5nKCksXG4gIHNsb3Q6IG51bWJlcigpLFxuICBlcnI6IFRyYW5zYWN0aW9uRXJyb3JSZXN1bHQsXG4gIG1lbW86IG51bGxhYmxlKHN0cmluZygpKSxcbiAgYmxvY2tUaW1lOiBvcHRpb25hbChudWxsYWJsZShudW1iZXIoKSkpXG59KSkpO1xuXG4vKioqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiYWNjb3VudE5vdGlmaWNhdGlvblwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgQWNjb3VudE5vdGlmaWNhdGlvblJlc3VsdCA9IHR5cGUoe1xuICBzdWJzY3JpcHRpb246IG51bWJlcigpLFxuICByZXN1bHQ6IG5vdGlmaWNhdGlvblJlc3VsdEFuZENvbnRleHQoQWNjb3VudEluZm9SZXN1bHQpXG59KTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgUHJvZ3JhbUFjY291bnRJbmZvUmVzdWx0ID0gdHlwZSh7XG4gIHB1YmtleTogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgYWNjb3VudDogQWNjb3VudEluZm9SZXN1bHRcbn0pO1xuXG4vKioqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwicHJvZ3JhbU5vdGlmaWNhdGlvblwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgUHJvZ3JhbUFjY291bnROb3RpZmljYXRpb25SZXN1bHQgPSB0eXBlKHtcbiAgc3Vic2NyaXB0aW9uOiBudW1iZXIoKSxcbiAgcmVzdWx0OiBub3RpZmljYXRpb25SZXN1bHRBbmRDb250ZXh0KFByb2dyYW1BY2NvdW50SW5mb1Jlc3VsdClcbn0pO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBTbG90SW5mb1Jlc3VsdCA9IHR5cGUoe1xuICBwYXJlbnQ6IG51bWJlcigpLFxuICBzbG90OiBudW1iZXIoKSxcbiAgcm9vdDogbnVtYmVyKClcbn0pO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJzbG90Tm90aWZpY2F0aW9uXCIgbWVzc2FnZVxuICovXG5jb25zdCBTbG90Tm90aWZpY2F0aW9uUmVzdWx0ID0gdHlwZSh7XG4gIHN1YnNjcmlwdGlvbjogbnVtYmVyKCksXG4gIHJlc3VsdDogU2xvdEluZm9SZXN1bHRcbn0pO1xuXG4vKipcbiAqIFNsb3QgdXBkYXRlcyB3aGljaCBjYW4gYmUgdXNlZCBmb3IgdHJhY2tpbmcgdGhlIGxpdmUgcHJvZ3Jlc3Mgb2YgYSBjbHVzdGVyLlxuICogLSBgXCJmaXJzdFNocmVkUmVjZWl2ZWRcImA6IGNvbm5lY3RlZCBub2RlIHJlY2VpdmVkIHRoZSBmaXJzdCBzaHJlZCBvZiBhIGJsb2NrLlxuICogSW5kaWNhdGVzIHRoYXQgYSBuZXcgYmxvY2sgdGhhdCBpcyBiZWluZyBwcm9kdWNlZC5cbiAqIC0gYFwiY29tcGxldGVkXCJgOiBjb25uZWN0ZWQgbm9kZSBoYXMgcmVjZWl2ZWQgYWxsIHNocmVkcyBvZiBhIGJsb2NrLiBJbmRpY2F0ZXNcbiAqIGEgYmxvY2sgd2FzIHJlY2VudGx5IHByb2R1Y2VkLlxuICogLSBgXCJvcHRpbWlzdGljQ29uZmlybWF0aW9uXCJgOiBibG9jayB3YXMgb3B0aW1pc3RpY2FsbHkgY29uZmlybWVkIGJ5IHRoZVxuICogY2x1c3Rlci4gSXQgaXMgbm90IGd1YXJhbnRlZWQgdGhhdCBhbiBvcHRpbWlzdGljIGNvbmZpcm1hdGlvbiBub3RpZmljYXRpb25cbiAqIHdpbGwgYmUgc2VudCBmb3IgZXZlcnkgZmluYWxpemVkIGJsb2Nrcy5cbiAqIC0gYFwicm9vdFwiYDogdGhlIGNvbm5lY3RlZCBub2RlIHJvb3RlZCB0aGlzIGJsb2NrLlxuICogLSBgXCJjcmVhdGVkQmFua1wiYDogdGhlIGNvbm5lY3RlZCBub2RlIGhhcyBzdGFydGVkIHZhbGlkYXRpbmcgdGhpcyBibG9jay5cbiAqIC0gYFwiZnJvemVuXCJgOiB0aGUgY29ubmVjdGVkIG5vZGUgaGFzIHZhbGlkYXRlZCB0aGlzIGJsb2NrLlxuICogLSBgXCJkZWFkXCJgOiB0aGUgY29ubmVjdGVkIG5vZGUgZmFpbGVkIHRvIHZhbGlkYXRlIHRoaXMgYmxvY2suXG4gKi9cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgU2xvdFVwZGF0ZVJlc3VsdCA9IHVuaW9uKFt0eXBlKHtcbiAgdHlwZTogdW5pb24oW2xpdGVyYWwoJ2ZpcnN0U2hyZWRSZWNlaXZlZCcpLCBsaXRlcmFsKCdjb21wbGV0ZWQnKSwgbGl0ZXJhbCgnb3B0aW1pc3RpY0NvbmZpcm1hdGlvbicpLCBsaXRlcmFsKCdyb290JyldKSxcbiAgc2xvdDogbnVtYmVyKCksXG4gIHRpbWVzdGFtcDogbnVtYmVyKClcbn0pLCB0eXBlKHtcbiAgdHlwZTogbGl0ZXJhbCgnY3JlYXRlZEJhbmsnKSxcbiAgcGFyZW50OiBudW1iZXIoKSxcbiAgc2xvdDogbnVtYmVyKCksXG4gIHRpbWVzdGFtcDogbnVtYmVyKClcbn0pLCB0eXBlKHtcbiAgdHlwZTogbGl0ZXJhbCgnZnJvemVuJyksXG4gIHNsb3Q6IG51bWJlcigpLFxuICB0aW1lc3RhbXA6IG51bWJlcigpLFxuICBzdGF0czogdHlwZSh7XG4gICAgbnVtVHJhbnNhY3Rpb25FbnRyaWVzOiBudW1iZXIoKSxcbiAgICBudW1TdWNjZXNzZnVsVHJhbnNhY3Rpb25zOiBudW1iZXIoKSxcbiAgICBudW1GYWlsZWRUcmFuc2FjdGlvbnM6IG51bWJlcigpLFxuICAgIG1heFRyYW5zYWN0aW9uc1BlckVudHJ5OiBudW1iZXIoKVxuICB9KVxufSksIHR5cGUoe1xuICB0eXBlOiBsaXRlcmFsKCdkZWFkJyksXG4gIHNsb3Q6IG51bWJlcigpLFxuICB0aW1lc3RhbXA6IG51bWJlcigpLFxuICBlcnI6IHN0cmluZygpXG59KV0pO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJzbG90c1VwZGF0ZXNOb3RpZmljYXRpb25cIiBtZXNzYWdlXG4gKi9cbmNvbnN0IFNsb3RVcGRhdGVOb3RpZmljYXRpb25SZXN1bHQgPSB0eXBlKHtcbiAgc3Vic2NyaXB0aW9uOiBudW1iZXIoKSxcbiAgcmVzdWx0OiBTbG90VXBkYXRlUmVzdWx0XG59KTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwic2lnbmF0dXJlTm90aWZpY2F0aW9uXCIgbWVzc2FnZVxuICovXG5jb25zdCBTaWduYXR1cmVOb3RpZmljYXRpb25SZXN1bHQgPSB0eXBlKHtcbiAgc3Vic2NyaXB0aW9uOiBudW1iZXIoKSxcbiAgcmVzdWx0OiBub3RpZmljYXRpb25SZXN1bHRBbmRDb250ZXh0KHVuaW9uKFtTaWduYXR1cmVTdGF0dXNSZXN1bHQsIFNpZ25hdHVyZVJlY2VpdmVkUmVzdWx0XSkpXG59KTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwicm9vdE5vdGlmaWNhdGlvblwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgUm9vdE5vdGlmaWNhdGlvblJlc3VsdCA9IHR5cGUoe1xuICBzdWJzY3JpcHRpb246IG51bWJlcigpLFxuICByZXN1bHQ6IG51bWJlcigpXG59KTtcbmNvbnN0IENvbnRhY3RJbmZvUmVzdWx0ID0gdHlwZSh7XG4gIHB1YmtleTogc3RyaW5nKCksXG4gIGdvc3NpcDogbnVsbGFibGUoc3RyaW5nKCkpLFxuICB0cHU6IG51bGxhYmxlKHN0cmluZygpKSxcbiAgcnBjOiBudWxsYWJsZShzdHJpbmcoKSksXG4gIHZlcnNpb246IG51bGxhYmxlKHN0cmluZygpKVxufSk7XG5jb25zdCBWb3RlQWNjb3VudEluZm9SZXN1bHQgPSB0eXBlKHtcbiAgdm90ZVB1YmtleTogc3RyaW5nKCksXG4gIG5vZGVQdWJrZXk6IHN0cmluZygpLFxuICBhY3RpdmF0ZWRTdGFrZTogbnVtYmVyKCksXG4gIGVwb2NoVm90ZUFjY291bnQ6IGJvb2xlYW4oKSxcbiAgZXBvY2hDcmVkaXRzOiBhcnJheSh0dXBsZShbbnVtYmVyKCksIG51bWJlcigpLCBudW1iZXIoKV0pKSxcbiAgY29tbWlzc2lvbjogbnVtYmVyKCksXG4gIGxhc3RWb3RlOiBudW1iZXIoKSxcbiAgcm9vdFNsb3Q6IG51bGxhYmxlKG51bWJlcigpKVxufSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFZvdGVBY2NvdW50c1wiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0Vm90ZUFjY291bnRzID0ganNvblJwY1Jlc3VsdCh0eXBlKHtcbiAgY3VycmVudDogYXJyYXkoVm90ZUFjY291bnRJbmZvUmVzdWx0KSxcbiAgZGVsaW5xdWVudDogYXJyYXkoVm90ZUFjY291bnRJbmZvUmVzdWx0KVxufSkpO1xuY29uc3QgQ29uZmlybWF0aW9uU3RhdHVzID0gdW5pb24oW2xpdGVyYWwoJ3Byb2Nlc3NlZCcpLCBsaXRlcmFsKCdjb25maXJtZWQnKSwgbGl0ZXJhbCgnZmluYWxpemVkJyldKTtcbmNvbnN0IFNpZ25hdHVyZVN0YXR1c1Jlc3BvbnNlID0gdHlwZSh7XG4gIHNsb3Q6IG51bWJlcigpLFxuICBjb25maXJtYXRpb25zOiBudWxsYWJsZShudW1iZXIoKSksXG4gIGVycjogVHJhbnNhY3Rpb25FcnJvclJlc3VsdCxcbiAgY29uZmlybWF0aW9uU3RhdHVzOiBvcHRpb25hbChDb25maXJtYXRpb25TdGF0dXMpXG59KTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0U2lnbmF0dXJlU3RhdHVzZXNcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldFNpZ25hdHVyZVN0YXR1c2VzUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdEFuZENvbnRleHQoYXJyYXkobnVsbGFibGUoU2lnbmF0dXJlU3RhdHVzUmVzcG9uc2UpKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldE1pbmltdW1CYWxhbmNlRm9yUmVudEV4ZW1wdGlvblwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0TWluaW11bUJhbGFuY2VGb3JSZW50RXhlbXB0aW9uUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChudW1iZXIoKSk7XG5jb25zdCBBZGRyZXNzVGFibGVMb29rdXBTdHJ1Y3QgPSB0eXBlKHtcbiAgYWNjb3VudEtleTogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgd3JpdGFibGVJbmRleGVzOiBhcnJheShudW1iZXIoKSksXG4gIHJlYWRvbmx5SW5kZXhlczogYXJyYXkobnVtYmVyKCkpXG59KTtcbmNvbnN0IENvbmZpcm1lZFRyYW5zYWN0aW9uUmVzdWx0ID0gdHlwZSh7XG4gIHNpZ25hdHVyZXM6IGFycmF5KHN0cmluZygpKSxcbiAgbWVzc2FnZTogdHlwZSh7XG4gICAgYWNjb3VudEtleXM6IGFycmF5KHN0cmluZygpKSxcbiAgICBoZWFkZXI6IHR5cGUoe1xuICAgICAgbnVtUmVxdWlyZWRTaWduYXR1cmVzOiBudW1iZXIoKSxcbiAgICAgIG51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHM6IG51bWJlcigpLFxuICAgICAgbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzOiBudW1iZXIoKVxuICAgIH0pLFxuICAgIGluc3RydWN0aW9uczogYXJyYXkodHlwZSh7XG4gICAgICBhY2NvdW50czogYXJyYXkobnVtYmVyKCkpLFxuICAgICAgZGF0YTogc3RyaW5nKCksXG4gICAgICBwcm9ncmFtSWRJbmRleDogbnVtYmVyKClcbiAgICB9KSksXG4gICAgcmVjZW50QmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgICBhZGRyZXNzVGFibGVMb29rdXBzOiBvcHRpb25hbChhcnJheShBZGRyZXNzVGFibGVMb29rdXBTdHJ1Y3QpKVxuICB9KVxufSk7XG5jb25zdCBBbm5vdGF0ZWRBY2NvdW50S2V5ID0gdHlwZSh7XG4gIHB1YmtleTogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgc2lnbmVyOiBib29sZWFuKCksXG4gIHdyaXRhYmxlOiBib29sZWFuKCksXG4gIHNvdXJjZTogb3B0aW9uYWwodW5pb24oW2xpdGVyYWwoJ3RyYW5zYWN0aW9uJyksIGxpdGVyYWwoJ2xvb2t1cFRhYmxlJyldKSlcbn0pO1xuY29uc3QgQ29uZmlybWVkVHJhbnNhY3Rpb25BY2NvdW50c01vZGVSZXN1bHQgPSB0eXBlKHtcbiAgYWNjb3VudEtleXM6IGFycmF5KEFubm90YXRlZEFjY291bnRLZXkpLFxuICBzaWduYXR1cmVzOiBhcnJheShzdHJpbmcoKSlcbn0pO1xuY29uc3QgUGFyc2VkSW5zdHJ1Y3Rpb25SZXN1bHQgPSB0eXBlKHtcbiAgcGFyc2VkOiB1bmtub3duKCksXG4gIHByb2dyYW06IHN0cmluZygpLFxuICBwcm9ncmFtSWQ6IFB1YmxpY0tleUZyb21TdHJpbmdcbn0pO1xuY29uc3QgUmF3SW5zdHJ1Y3Rpb25SZXN1bHQgPSB0eXBlKHtcbiAgYWNjb3VudHM6IGFycmF5KFB1YmxpY0tleUZyb21TdHJpbmcpLFxuICBkYXRhOiBzdHJpbmcoKSxcbiAgcHJvZ3JhbUlkOiBQdWJsaWNLZXlGcm9tU3RyaW5nXG59KTtcbmNvbnN0IEluc3RydWN0aW9uUmVzdWx0ID0gdW5pb24oW1Jhd0luc3RydWN0aW9uUmVzdWx0LCBQYXJzZWRJbnN0cnVjdGlvblJlc3VsdF0pO1xuY29uc3QgVW5rbm93bkluc3RydWN0aW9uUmVzdWx0ID0gdW5pb24oW3R5cGUoe1xuICBwYXJzZWQ6IHVua25vd24oKSxcbiAgcHJvZ3JhbTogc3RyaW5nKCksXG4gIHByb2dyYW1JZDogc3RyaW5nKClcbn0pLCB0eXBlKHtcbiAgYWNjb3VudHM6IGFycmF5KHN0cmluZygpKSxcbiAgZGF0YTogc3RyaW5nKCksXG4gIHByb2dyYW1JZDogc3RyaW5nKClcbn0pXSk7XG5jb25zdCBQYXJzZWRPclJhd0luc3RydWN0aW9uID0gY29lcmNlKEluc3RydWN0aW9uUmVzdWx0LCBVbmtub3duSW5zdHJ1Y3Rpb25SZXN1bHQsIHZhbHVlID0+IHtcbiAgaWYgKCdhY2NvdW50cycgaW4gdmFsdWUpIHtcbiAgICByZXR1cm4gY3JlYXRlKHZhbHVlLCBSYXdJbnN0cnVjdGlvblJlc3VsdCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNyZWF0ZSh2YWx1ZSwgUGFyc2VkSW5zdHJ1Y3Rpb25SZXN1bHQpO1xuICB9XG59KTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgUGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb25SZXN1bHQgPSB0eXBlKHtcbiAgc2lnbmF0dXJlczogYXJyYXkoc3RyaW5nKCkpLFxuICBtZXNzYWdlOiB0eXBlKHtcbiAgICBhY2NvdW50S2V5czogYXJyYXkoQW5ub3RhdGVkQWNjb3VudEtleSksXG4gICAgaW5zdHJ1Y3Rpb25zOiBhcnJheShQYXJzZWRPclJhd0luc3RydWN0aW9uKSxcbiAgICByZWNlbnRCbG9ja2hhc2g6IHN0cmluZygpLFxuICAgIGFkZHJlc3NUYWJsZUxvb2t1cHM6IG9wdGlvbmFsKG51bGxhYmxlKGFycmF5KEFkZHJlc3NUYWJsZUxvb2t1cFN0cnVjdCkpKVxuICB9KVxufSk7XG5jb25zdCBUb2tlbkJhbGFuY2VSZXN1bHQgPSB0eXBlKHtcbiAgYWNjb3VudEluZGV4OiBudW1iZXIoKSxcbiAgbWludDogc3RyaW5nKCksXG4gIG93bmVyOiBvcHRpb25hbChzdHJpbmcoKSksXG4gIHByb2dyYW1JZDogb3B0aW9uYWwoc3RyaW5nKCkpLFxuICB1aVRva2VuQW1vdW50OiBUb2tlbkFtb3VudFJlc3VsdFxufSk7XG5jb25zdCBMb2FkZWRBZGRyZXNzZXNSZXN1bHQgPSB0eXBlKHtcbiAgd3JpdGFibGU6IGFycmF5KFB1YmxpY0tleUZyb21TdHJpbmcpLFxuICByZWFkb25seTogYXJyYXkoUHVibGljS2V5RnJvbVN0cmluZylcbn0pO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBDb25maXJtZWRUcmFuc2FjdGlvbk1ldGFSZXN1bHQgPSB0eXBlKHtcbiAgZXJyOiBUcmFuc2FjdGlvbkVycm9yUmVzdWx0LFxuICBmZWU6IG51bWJlcigpLFxuICBpbm5lckluc3RydWN0aW9uczogb3B0aW9uYWwobnVsbGFibGUoYXJyYXkodHlwZSh7XG4gICAgaW5kZXg6IG51bWJlcigpLFxuICAgIGluc3RydWN0aW9uczogYXJyYXkodHlwZSh7XG4gICAgICBhY2NvdW50czogYXJyYXkobnVtYmVyKCkpLFxuICAgICAgZGF0YTogc3RyaW5nKCksXG4gICAgICBwcm9ncmFtSWRJbmRleDogbnVtYmVyKClcbiAgICB9KSlcbiAgfSkpKSksXG4gIHByZUJhbGFuY2VzOiBhcnJheShudW1iZXIoKSksXG4gIHBvc3RCYWxhbmNlczogYXJyYXkobnVtYmVyKCkpLFxuICBsb2dNZXNzYWdlczogb3B0aW9uYWwobnVsbGFibGUoYXJyYXkoc3RyaW5nKCkpKSksXG4gIHByZVRva2VuQmFsYW5jZXM6IG9wdGlvbmFsKG51bGxhYmxlKGFycmF5KFRva2VuQmFsYW5jZVJlc3VsdCkpKSxcbiAgcG9zdFRva2VuQmFsYW5jZXM6IG9wdGlvbmFsKG51bGxhYmxlKGFycmF5KFRva2VuQmFsYW5jZVJlc3VsdCkpKSxcbiAgbG9hZGVkQWRkcmVzc2VzOiBvcHRpb25hbChMb2FkZWRBZGRyZXNzZXNSZXN1bHQpLFxuICBjb21wdXRlVW5pdHNDb25zdW1lZDogb3B0aW9uYWwobnVtYmVyKCkpLFxuICBjb3N0VW5pdHM6IG9wdGlvbmFsKG51bWJlcigpKVxufSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9uTWV0YVJlc3VsdCA9IHR5cGUoe1xuICBlcnI6IFRyYW5zYWN0aW9uRXJyb3JSZXN1bHQsXG4gIGZlZTogbnVtYmVyKCksXG4gIGlubmVySW5zdHJ1Y3Rpb25zOiBvcHRpb25hbChudWxsYWJsZShhcnJheSh0eXBlKHtcbiAgICBpbmRleDogbnVtYmVyKCksXG4gICAgaW5zdHJ1Y3Rpb25zOiBhcnJheShQYXJzZWRPclJhd0luc3RydWN0aW9uKVxuICB9KSkpKSxcbiAgcHJlQmFsYW5jZXM6IGFycmF5KG51bWJlcigpKSxcbiAgcG9zdEJhbGFuY2VzOiBhcnJheShudW1iZXIoKSksXG4gIGxvZ01lc3NhZ2VzOiBvcHRpb25hbChudWxsYWJsZShhcnJheShzdHJpbmcoKSkpKSxcbiAgcHJlVG9rZW5CYWxhbmNlczogb3B0aW9uYWwobnVsbGFibGUoYXJyYXkoVG9rZW5CYWxhbmNlUmVzdWx0KSkpLFxuICBwb3N0VG9rZW5CYWxhbmNlczogb3B0aW9uYWwobnVsbGFibGUoYXJyYXkoVG9rZW5CYWxhbmNlUmVzdWx0KSkpLFxuICBsb2FkZWRBZGRyZXNzZXM6IG9wdGlvbmFsKExvYWRlZEFkZHJlc3Nlc1Jlc3VsdCksXG4gIGNvbXB1dGVVbml0c0NvbnN1bWVkOiBvcHRpb25hbChudW1iZXIoKSksXG4gIGNvc3RVbml0czogb3B0aW9uYWwobnVtYmVyKCkpXG59KTtcbmNvbnN0IFRyYW5zYWN0aW9uVmVyc2lvblN0cnVjdCA9IHVuaW9uKFtsaXRlcmFsKDApLCBsaXRlcmFsKCdsZWdhY3knKV0pO1xuXG4vKiogQGludGVybmFsICovXG5jb25zdCBSZXdhcmRzUmVzdWx0ID0gdHlwZSh7XG4gIHB1YmtleTogc3RyaW5nKCksXG4gIGxhbXBvcnRzOiBudW1iZXIoKSxcbiAgcG9zdEJhbGFuY2U6IG51bGxhYmxlKG51bWJlcigpKSxcbiAgcmV3YXJkVHlwZTogbnVsbGFibGUoc3RyaW5nKCkpLFxuICBjb21taXNzaW9uOiBvcHRpb25hbChudWxsYWJsZShudW1iZXIoKSkpXG59KTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0QmxvY2tcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldEJsb2NrUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChudWxsYWJsZSh0eXBlKHtcbiAgYmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgcHJldmlvdXNCbG9ja2hhc2g6IHN0cmluZygpLFxuICBwYXJlbnRTbG90OiBudW1iZXIoKSxcbiAgdHJhbnNhY3Rpb25zOiBhcnJheSh0eXBlKHtcbiAgICB0cmFuc2FjdGlvbjogQ29uZmlybWVkVHJhbnNhY3Rpb25SZXN1bHQsXG4gICAgbWV0YTogbnVsbGFibGUoQ29uZmlybWVkVHJhbnNhY3Rpb25NZXRhUmVzdWx0KSxcbiAgICB2ZXJzaW9uOiBvcHRpb25hbChUcmFuc2FjdGlvblZlcnNpb25TdHJ1Y3QpXG4gIH0pKSxcbiAgcmV3YXJkczogb3B0aW9uYWwoYXJyYXkoUmV3YXJkc1Jlc3VsdCkpLFxuICBibG9ja1RpbWU6IG51bGxhYmxlKG51bWJlcigpKSxcbiAgYmxvY2tIZWlnaHQ6IG51bGxhYmxlKG51bWJlcigpKVxufSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0QmxvY2tcIiBtZXNzYWdlIHdoZW4gYHRyYW5zYWN0aW9uRGV0YWlsc2AgaXMgYG5vbmVgXG4gKi9cbmNvbnN0IEdldE5vbmVNb2RlQmxvY2tScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KG51bGxhYmxlKHR5cGUoe1xuICBibG9ja2hhc2g6IHN0cmluZygpLFxuICBwcmV2aW91c0Jsb2NraGFzaDogc3RyaW5nKCksXG4gIHBhcmVudFNsb3Q6IG51bWJlcigpLFxuICByZXdhcmRzOiBvcHRpb25hbChhcnJheShSZXdhcmRzUmVzdWx0KSksXG4gIGJsb2NrVGltZTogbnVsbGFibGUobnVtYmVyKCkpLFxuICBibG9ja0hlaWdodDogbnVsbGFibGUobnVtYmVyKCkpXG59KSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRCbG9ja1wiIG1lc3NhZ2Ugd2hlbiBgdHJhbnNhY3Rpb25EZXRhaWxzYCBpcyBgYWNjb3VudHNgXG4gKi9cbmNvbnN0IEdldEFjY291bnRzTW9kZUJsb2NrUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChudWxsYWJsZSh0eXBlKHtcbiAgYmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgcHJldmlvdXNCbG9ja2hhc2g6IHN0cmluZygpLFxuICBwYXJlbnRTbG90OiBudW1iZXIoKSxcbiAgdHJhbnNhY3Rpb25zOiBhcnJheSh0eXBlKHtcbiAgICB0cmFuc2FjdGlvbjogQ29uZmlybWVkVHJhbnNhY3Rpb25BY2NvdW50c01vZGVSZXN1bHQsXG4gICAgbWV0YTogbnVsbGFibGUoQ29uZmlybWVkVHJhbnNhY3Rpb25NZXRhUmVzdWx0KSxcbiAgICB2ZXJzaW9uOiBvcHRpb25hbChUcmFuc2FjdGlvblZlcnNpb25TdHJ1Y3QpXG4gIH0pKSxcbiAgcmV3YXJkczogb3B0aW9uYWwoYXJyYXkoUmV3YXJkc1Jlc3VsdCkpLFxuICBibG9ja1RpbWU6IG51bGxhYmxlKG51bWJlcigpKSxcbiAgYmxvY2tIZWlnaHQ6IG51bGxhYmxlKG51bWJlcigpKVxufSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBwYXJzZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEJsb2NrXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRQYXJzZWRCbG9ja1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQobnVsbGFibGUodHlwZSh7XG4gIGJsb2NraGFzaDogc3RyaW5nKCksXG4gIHByZXZpb3VzQmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgcGFyZW50U2xvdDogbnVtYmVyKCksXG4gIHRyYW5zYWN0aW9uczogYXJyYXkodHlwZSh7XG4gICAgdHJhbnNhY3Rpb246IFBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9uUmVzdWx0LFxuICAgIG1ldGE6IG51bGxhYmxlKFBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9uTWV0YVJlc3VsdCksXG4gICAgdmVyc2lvbjogb3B0aW9uYWwoVHJhbnNhY3Rpb25WZXJzaW9uU3RydWN0KVxuICB9KSksXG4gIHJld2FyZHM6IG9wdGlvbmFsKGFycmF5KFJld2FyZHNSZXN1bHQpKSxcbiAgYmxvY2tUaW1lOiBudWxsYWJsZShudW1iZXIoKSksXG4gIGJsb2NrSGVpZ2h0OiBudWxsYWJsZShudW1iZXIoKSlcbn0pKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgcGFyc2VkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRCbG9ja1wiIG1lc3NhZ2UgIHdoZW4gYHRyYW5zYWN0aW9uRGV0YWlsc2AgaXMgYGFjY291bnRzYFxuICovXG5jb25zdCBHZXRQYXJzZWRBY2NvdW50c01vZGVCbG9ja1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQobnVsbGFibGUodHlwZSh7XG4gIGJsb2NraGFzaDogc3RyaW5nKCksXG4gIHByZXZpb3VzQmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgcGFyZW50U2xvdDogbnVtYmVyKCksXG4gIHRyYW5zYWN0aW9uczogYXJyYXkodHlwZSh7XG4gICAgdHJhbnNhY3Rpb246IENvbmZpcm1lZFRyYW5zYWN0aW9uQWNjb3VudHNNb2RlUmVzdWx0LFxuICAgIG1ldGE6IG51bGxhYmxlKFBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9uTWV0YVJlc3VsdCksXG4gICAgdmVyc2lvbjogb3B0aW9uYWwoVHJhbnNhY3Rpb25WZXJzaW9uU3RydWN0KVxuICB9KSksXG4gIHJld2FyZHM6IG9wdGlvbmFsKGFycmF5KFJld2FyZHNSZXN1bHQpKSxcbiAgYmxvY2tUaW1lOiBudWxsYWJsZShudW1iZXIoKSksXG4gIGJsb2NrSGVpZ2h0OiBudWxsYWJsZShudW1iZXIoKSlcbn0pKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgcGFyc2VkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRCbG9ja1wiIG1lc3NhZ2UgIHdoZW4gYHRyYW5zYWN0aW9uRGV0YWlsc2AgaXMgYG5vbmVgXG4gKi9cbmNvbnN0IEdldFBhcnNlZE5vbmVNb2RlQmxvY2tScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KG51bGxhYmxlKHR5cGUoe1xuICBibG9ja2hhc2g6IHN0cmluZygpLFxuICBwcmV2aW91c0Jsb2NraGFzaDogc3RyaW5nKCksXG4gIHBhcmVudFNsb3Q6IG51bWJlcigpLFxuICByZXdhcmRzOiBvcHRpb25hbChhcnJheShSZXdhcmRzUmVzdWx0KSksXG4gIGJsb2NrVGltZTogbnVsbGFibGUobnVtYmVyKCkpLFxuICBibG9ja0hlaWdodDogbnVsbGFibGUobnVtYmVyKCkpXG59KSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRDb25maXJtZWRCbG9ja1wiIG1lc3NhZ2VcbiAqXG4gKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFJQQyB2MS44LjAuIFBsZWFzZSB1c2Uge0BsaW5rIEdldEJsb2NrUnBjUmVzdWx0fSBpbnN0ZWFkLlxuICovXG5jb25zdCBHZXRDb25maXJtZWRCbG9ja1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQobnVsbGFibGUodHlwZSh7XG4gIGJsb2NraGFzaDogc3RyaW5nKCksXG4gIHByZXZpb3VzQmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgcGFyZW50U2xvdDogbnVtYmVyKCksXG4gIHRyYW5zYWN0aW9uczogYXJyYXkodHlwZSh7XG4gICAgdHJhbnNhY3Rpb246IENvbmZpcm1lZFRyYW5zYWN0aW9uUmVzdWx0LFxuICAgIG1ldGE6IG51bGxhYmxlKENvbmZpcm1lZFRyYW5zYWN0aW9uTWV0YVJlc3VsdClcbiAgfSkpLFxuICByZXdhcmRzOiBvcHRpb25hbChhcnJheShSZXdhcmRzUmVzdWx0KSksXG4gIGJsb2NrVGltZTogbnVsbGFibGUobnVtYmVyKCkpXG59KSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRCbG9ja1wiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0QmxvY2tTaWduYXR1cmVzUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChudWxsYWJsZSh0eXBlKHtcbiAgYmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgcHJldmlvdXNCbG9ja2hhc2g6IHN0cmluZygpLFxuICBwYXJlbnRTbG90OiBudW1iZXIoKSxcbiAgc2lnbmF0dXJlczogYXJyYXkoc3RyaW5nKCkpLFxuICBibG9ja1RpbWU6IG51bGxhYmxlKG51bWJlcigpKVxufSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0VHJhbnNhY3Rpb25cIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldFRyYW5zYWN0aW9uUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChudWxsYWJsZSh0eXBlKHtcbiAgc2xvdDogbnVtYmVyKCksXG4gIG1ldGE6IG51bGxhYmxlKENvbmZpcm1lZFRyYW5zYWN0aW9uTWV0YVJlc3VsdCksXG4gIGJsb2NrVGltZTogb3B0aW9uYWwobnVsbGFibGUobnVtYmVyKCkpKSxcbiAgdHJhbnNhY3Rpb246IENvbmZpcm1lZFRyYW5zYWN0aW9uUmVzdWx0LFxuICB2ZXJzaW9uOiBvcHRpb25hbChUcmFuc2FjdGlvblZlcnNpb25TdHJ1Y3QpXG59KSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIHBhcnNlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0VHJhbnNhY3Rpb25cIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldFBhcnNlZFRyYW5zYWN0aW9uUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChudWxsYWJsZSh0eXBlKHtcbiAgc2xvdDogbnVtYmVyKCksXG4gIHRyYW5zYWN0aW9uOiBQYXJzZWRDb25maXJtZWRUcmFuc2FjdGlvblJlc3VsdCxcbiAgbWV0YTogbnVsbGFibGUoUGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb25NZXRhUmVzdWx0KSxcbiAgYmxvY2tUaW1lOiBvcHRpb25hbChudWxsYWJsZShudW1iZXIoKSkpLFxuICB2ZXJzaW9uOiBvcHRpb25hbChUcmFuc2FjdGlvblZlcnNpb25TdHJ1Y3QpXG59KSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRMYXRlc3RCbG9ja2hhc2hcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldExhdGVzdEJsb2NraGFzaFJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KHR5cGUoe1xuICBibG9ja2hhc2g6IHN0cmluZygpLFxuICBsYXN0VmFsaWRCbG9ja0hlaWdodDogbnVtYmVyKClcbn0pKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiaXNCbG9ja2hhc2hWYWxpZFwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgSXNCbG9ja2hhc2hWYWxpZFJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KGJvb2xlYW4oKSk7XG5jb25zdCBQZXJmU2FtcGxlUmVzdWx0ID0gdHlwZSh7XG4gIHNsb3Q6IG51bWJlcigpLFxuICBudW1UcmFuc2FjdGlvbnM6IG51bWJlcigpLFxuICBudW1TbG90czogbnVtYmVyKCksXG4gIHNhbXBsZVBlcmlvZFNlY3M6IG51bWJlcigpXG59KTtcblxuLypcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciBcImdldFJlY2VudFBlcmZvcm1hbmNlU2FtcGxlc1wiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0UmVjZW50UGVyZm9ybWFuY2VTYW1wbGVzUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChhcnJheShQZXJmU2FtcGxlUmVzdWx0KSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEZlZUNhbGN1bGF0b3JGb3JCbG9ja2hhc2hcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldEZlZUNhbGN1bGF0b3JScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChudWxsYWJsZSh0eXBlKHtcbiAgZmVlQ2FsY3VsYXRvcjogdHlwZSh7XG4gICAgbGFtcG9ydHNQZXJTaWduYXR1cmU6IG51bWJlcigpXG4gIH0pXG59KSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJyZXF1ZXN0QWlyZHJvcFwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgUmVxdWVzdEFpcmRyb3BScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KHN0cmluZygpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwic2VuZFRyYW5zYWN0aW9uXCIgbWVzc2FnZVxuICovXG5jb25zdCBTZW5kVHJhbnNhY3Rpb25ScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KHN0cmluZygpKTtcblxuLyoqXG4gKiBJbmZvcm1hdGlvbiBhYm91dCB0aGUgbGF0ZXN0IHNsb3QgYmVpbmcgcHJvY2Vzc2VkIGJ5IGEgbm9kZVxuICovXG5cbi8qKlxuICogUGFyc2VkIGFjY291bnQgZGF0YVxuICovXG5cbi8qKlxuICogU3Rha2UgQWN0aXZhdGlvbiBkYXRhXG4gKi9cblxuLyoqXG4gKiBEYXRhIHNsaWNlIGFyZ3VtZW50IGZvciBnZXRQcm9ncmFtQWNjb3VudHNcbiAqL1xuXG4vKipcbiAqIE1lbW9yeSBjb21wYXJpc29uIGZpbHRlciBmb3IgZ2V0UHJvZ3JhbUFjY291bnRzXG4gKi9cblxuLyoqXG4gKiBEYXRhIHNpemUgY29tcGFyaXNvbiBmaWx0ZXIgZm9yIGdldFByb2dyYW1BY2NvdW50c1xuICovXG5cbi8qKlxuICogQSBmaWx0ZXIgb2JqZWN0IGZvciBnZXRQcm9ncmFtQWNjb3VudHNcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBnZXRQcm9ncmFtQWNjb3VudHMgcmVxdWVzdHNcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBnZXRQYXJzZWRQcm9ncmFtQWNjb3VudHNcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBnZXRNdWx0aXBsZUFjY291bnRzXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgYGdldFN0YWtlQWN0aXZhdGlvbmBcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBgZ2V0U3Rha2VBY3RpdmF0aW9uYFxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGBnZXRTdGFrZUFjdGl2YXRpb25gXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgYGdldE5vbmNlYFxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGBnZXROb25jZUFuZENvbnRleHRgXG4gKi9cblxuLyoqXG4gKiBJbmZvcm1hdGlvbiBkZXNjcmliaW5nIGFuIGFjY291bnRcbiAqL1xuXG4vKipcbiAqIEFjY291bnQgaW5mb3JtYXRpb24gaWRlbnRpZmllZCBieSBwdWJrZXlcbiAqL1xuXG4vKipcbiAqIENhbGxiYWNrIGZ1bmN0aW9uIGZvciBhY2NvdW50IGNoYW5nZSBub3RpZmljYXRpb25zXG4gKi9cblxuLyoqXG4gKiBDYWxsYmFjayBmdW5jdGlvbiBmb3IgcHJvZ3JhbSBhY2NvdW50IGNoYW5nZSBub3RpZmljYXRpb25zXG4gKi9cblxuLyoqXG4gKiBDYWxsYmFjayBmdW5jdGlvbiBmb3Igc2xvdCBjaGFuZ2Ugbm90aWZpY2F0aW9uc1xuICovXG5cbi8qKlxuICogQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIHNsb3QgdXBkYXRlIG5vdGlmaWNhdGlvbnNcbiAqL1xuXG4vKipcbiAqIENhbGxiYWNrIGZ1bmN0aW9uIGZvciBzaWduYXR1cmUgc3RhdHVzIG5vdGlmaWNhdGlvbnNcbiAqL1xuXG4vKipcbiAqIFNpZ25hdHVyZSBzdGF0dXMgbm90aWZpY2F0aW9uIHdpdGggdHJhbnNhY3Rpb24gcmVzdWx0XG4gKi9cblxuLyoqXG4gKiBTaWduYXR1cmUgcmVjZWl2ZWQgbm90aWZpY2F0aW9uXG4gKi9cblxuLyoqXG4gKiBDYWxsYmFjayBmdW5jdGlvbiBmb3Igc2lnbmF0dXJlIG5vdGlmaWNhdGlvbnNcbiAqL1xuXG4vKipcbiAqIFNpZ25hdHVyZSBzdWJzY3JpcHRpb24gb3B0aW9uc1xuICovXG5cbi8qKlxuICogQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIHJvb3QgY2hhbmdlIG5vdGlmaWNhdGlvbnNcbiAqL1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBMb2dzUmVzdWx0ID0gdHlwZSh7XG4gIGVycjogVHJhbnNhY3Rpb25FcnJvclJlc3VsdCxcbiAgbG9nczogYXJyYXkoc3RyaW5nKCkpLFxuICBzaWduYXR1cmU6IHN0cmluZygpXG59KTtcblxuLyoqXG4gKiBMb2dzIHJlc3VsdC5cbiAqL1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJsb2dzTm90aWZpY2F0aW9uXCIgbWVzc2FnZS5cbiAqL1xuY29uc3QgTG9nc05vdGlmaWNhdGlvblJlc3VsdCA9IHR5cGUoe1xuICByZXN1bHQ6IG5vdGlmaWNhdGlvblJlc3VsdEFuZENvbnRleHQoTG9nc1Jlc3VsdCksXG4gIHN1YnNjcmlwdGlvbjogbnVtYmVyKClcbn0pO1xuXG4vKipcbiAqIEZpbHRlciBmb3IgbG9nIHN1YnNjcmlwdGlvbnMuXG4gKi9cblxuLyoqXG4gKiBDYWxsYmFjayBmdW5jdGlvbiBmb3IgbG9nIG5vdGlmaWNhdGlvbnMuXG4gKi9cblxuLyoqXG4gKiBTaWduYXR1cmUgcmVzdWx0XG4gKi9cblxuLyoqXG4gKiBUcmFuc2FjdGlvbiBlcnJvclxuICovXG5cbi8qKlxuICogVHJhbnNhY3Rpb24gY29uZmlybWF0aW9uIHN0YXR1c1xuICogPHByZT5cbiAqICAgJ3Byb2Nlc3NlZCc6IFRyYW5zYWN0aW9uIGxhbmRlZCBpbiBhIGJsb2NrIHdoaWNoIGhhcyByZWFjaGVkIDEgY29uZmlybWF0aW9uIGJ5IHRoZSBjb25uZWN0ZWQgbm9kZVxuICogICAnY29uZmlybWVkJzogVHJhbnNhY3Rpb24gbGFuZGVkIGluIGEgYmxvY2sgd2hpY2ggaGFzIHJlYWNoZWQgMSBjb25maXJtYXRpb24gYnkgdGhlIGNsdXN0ZXJcbiAqICAgJ2ZpbmFsaXplZCc6IFRyYW5zYWN0aW9uIGxhbmRlZCBpbiBhIGJsb2NrIHdoaWNoIGhhcyBiZWVuIGZpbmFsaXplZCBieSB0aGUgY2x1c3RlclxuICogPC9wcmU+XG4gKi9cblxuLyoqXG4gKiBTaWduYXR1cmUgc3RhdHVzXG4gKi9cblxuLyoqXG4gKiBBIGNvbmZpcm1lZCBzaWduYXR1cmUgd2l0aCBpdHMgc3RhdHVzXG4gKi9cblxuLyoqXG4gKiBBbiBvYmplY3QgZGVmaW5pbmcgaGVhZGVycyB0byBiZSBwYXNzZWQgdG8gdGhlIFJQQyBzZXJ2ZXJcbiAqL1xuXG4vKipcbiAqIFRoZSB0eXBlIG9mIHRoZSBKYXZhU2NyaXB0IGBmZXRjaCgpYCBBUElcbiAqL1xuXG4vKipcbiAqIEEgY2FsbGJhY2sgdXNlZCB0byBhdWdtZW50IHRoZSBvdXRnb2luZyBIVFRQIHJlcXVlc3RcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gZm9yIGluc3RhbnRpYXRpbmcgYSBDb25uZWN0aW9uXG4gKi9cblxuLyoqIEBpbnRlcm5hbCAqL1xuY29uc3QgQ09NTU9OX0hUVFBfSEVBREVSUyA9IHtcbiAgJ3NvbGFuYS1jbGllbnQnOiBganMvJHtcIjEuMC4wLW1haW50ZW5hbmNlXCJ9YFxufTtcblxuLyoqXG4gKiBBIGNvbm5lY3Rpb24gdG8gYSBmdWxsbm9kZSBKU09OIFJQQyBlbmRwb2ludFxuICovXG5jbGFzcyBDb25uZWN0aW9uIHtcbiAgLyoqXG4gICAqIEVzdGFibGlzaCBhIEpTT04gUlBDIGNvbm5lY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIGVuZHBvaW50IFVSTCB0byB0aGUgZnVsbG5vZGUgSlNPTiBSUEMgZW5kcG9pbnRcbiAgICogQHBhcmFtIGNvbW1pdG1lbnRPckNvbmZpZyBvcHRpb25hbCBkZWZhdWx0IGNvbW1pdG1lbnQgbGV2ZWwgb3Igb3B0aW9uYWwgQ29ubmVjdGlvbkNvbmZpZyBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgKi9cbiAgY29uc3RydWN0b3IoZW5kcG9pbnQsIF9jb21taXRtZW50T3JDb25maWcpIHtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fY29tbWl0bWVudCA9IHZvaWQgMDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fY29uZmlybVRyYW5zYWN0aW9uSW5pdGlhbFRpbWVvdXQgPSB2b2lkIDA7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3JwY0VuZHBvaW50ID0gdm9pZCAwO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9ycGNXc0VuZHBvaW50ID0gdm9pZCAwO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9ycGNDbGllbnQgPSB2b2lkIDA7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3JwY1JlcXVlc3QgPSB2b2lkIDA7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3JwY0JhdGNoUmVxdWVzdCA9IHZvaWQgMDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fcnBjV2ViU29ja2V0ID0gdm9pZCAwO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9ycGNXZWJTb2NrZXRDb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fcnBjV2ViU29ja2V0SGVhcnRiZWF0ID0gbnVsbDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fcnBjV2ViU29ja2V0SWRsZVRpbWVvdXQgPSBudWxsO1xuICAgIC8qKiBAaW50ZXJuYWxcbiAgICAgKiBBIG51bWJlciB0aGF0IHdlIGluY3JlbWVudCBldmVyeSB0aW1lIGFuIGFjdGl2ZSBjb25uZWN0aW9uIGNsb3Nlcy5cbiAgICAgKiBVc2VkIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZSBzYW1lIHNvY2tldCBjb25uZWN0aW9uIHRoYXQgd2FzIG9wZW5cbiAgICAgKiB3aGVuIGFuIGFzeW5jIG9wZXJhdGlvbiBzdGFydGVkIGlzIHRoZSBzYW1lIG9uZSB0aGF0J3MgYWN0aXZlIHdoZW5cbiAgICAgKiBpdHMgY29udGludWF0aW9uIGZpcmVzLlxuICAgICAqXG4gICAgICovXG4gICAgdGhpcy5fcnBjV2ViU29ja2V0R2VuZXJhdGlvbiA9IDA7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX2Rpc2FibGVCbG9ja2hhc2hDYWNoaW5nID0gZmFsc2U7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3BvbGxpbmdCbG9ja2hhc2ggPSBmYWxzZTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fYmxvY2toYXNoSW5mbyA9IHtcbiAgICAgIGxhdGVzdEJsb2NraGFzaDogbnVsbCxcbiAgICAgIGxhc3RGZXRjaDogMCxcbiAgICAgIHRyYW5zYWN0aW9uU2lnbmF0dXJlczogW10sXG4gICAgICBzaW11bGF0ZWRTaWduYXR1cmVzOiBbXVxuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX25leHRDbGllbnRTdWJzY3JpcHRpb25JZCA9IDA7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbkRpc3Bvc2VGdW5jdGlvbnNCeUNsaWVudFN1YnNjcmlwdGlvbklkID0ge307XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbkhhc2hCeUNsaWVudFN1YnNjcmlwdGlvbklkID0ge307XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvblN0YXRlQ2hhbmdlQ2FsbGJhY2tzQnlIYXNoID0ge307XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbkNhbGxiYWNrc0J5U2VydmVyU3Vic2NyaXB0aW9uSWQgPSB7fTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uc0J5SGFzaCA9IHt9O1xuICAgIC8qKlxuICAgICAqIFNwZWNpYWwgY2FzZS5cbiAgICAgKiBBZnRlciBhIHNpZ25hdHVyZSBpcyBwcm9jZXNzZWQsIFJQQ3MgYXV0b21hdGljYWxseSBkaXNwb3NlIG9mIHRoZVxuICAgICAqIHN1YnNjcmlwdGlvbiBvbiB0aGUgc2VydmVyIHNpZGUuIFdlIG5lZWQgdG8gdHJhY2sgd2hpY2ggb2YgdGhlc2VcbiAgICAgKiBzdWJzY3JpcHRpb25zIGhhdmUgYmVlbiBkaXNwb3NlZCBpbiBzdWNoIGEgd2F5LCBzbyB0aGF0IHdlIGtub3dcbiAgICAgKiB3aGV0aGVyIHRoZSBjbGllbnQgaXMgZGVhbGluZyB3aXRoIGEgbm90LXlldC1wcm9jZXNzZWQgc2lnbmF0dXJlXG4gICAgICogKGluIHdoaWNoIGNhc2Ugd2UgbXVzdCB0ZWFyIGRvd24gdGhlIHNlcnZlciBzdWJzY3JpcHRpb24pIG9yIGFuXG4gICAgICogYWxyZWFkeS1wcm9jZXNzZWQgc2lnbmF0dXJlIChpbiB3aGljaCBjYXNlIHRoZSBjbGllbnQgY2FuIHNpbXBseVxuICAgICAqIGNsZWFyIG91dCB0aGUgc3Vic2NyaXB0aW9uIGxvY2FsbHkgd2l0aG91dCB0ZWxsaW5nIHRoZSBzZXJ2ZXIpLlxuICAgICAqXG4gICAgICogTk9URTogVGhlcmUgaXMgYSBwcm9wb3NhbCB0byBlbGltaW5hdGUgdGhpcyBzcGVjaWFsIGNhc2UsIGhlcmU6XG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL3NvbGFuYS1sYWJzL3NvbGFuYS9pc3N1ZXMvMTg4OTJcbiAgICAgKi9cbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uc0F1dG9EaXNwb3NlZEJ5UnBjID0gbmV3IFNldCgpO1xuICAgIC8qXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBibG9jayBoZWlnaHQgb2YgdGhlIG5vZGVcbiAgICAgKi9cbiAgICB0aGlzLmdldEJsb2NrSGVpZ2h0ID0gKCgpID0+IHtcbiAgICAgIGNvbnN0IHJlcXVlc3RQcm9taXNlcyA9IHt9O1xuICAgICAgcmV0dXJuIGFzeW5jIGNvbW1pdG1lbnRPckNvbmZpZyA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBjb21taXRtZW50LFxuICAgICAgICAgIGNvbmZpZ1xuICAgICAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW10sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLywgY29uZmlnKTtcbiAgICAgICAgY29uc3QgcmVxdWVzdEhhc2ggPSBmYXN0U3RhYmxlU3RyaW5naWZ5KGFyZ3MpO1xuICAgICAgICByZXF1ZXN0UHJvbWlzZXNbcmVxdWVzdEhhc2hdID0gcmVxdWVzdFByb21pc2VzW3JlcXVlc3RIYXNoXSA/PyAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRCbG9ja0hlaWdodCcsIGFyZ3MpO1xuICAgICAgICAgICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdChudW1iZXIoKSkpO1xuICAgICAgICAgICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBibG9jayBoZWlnaHQgaW5mb3JtYXRpb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXMucmVzdWx0O1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBkZWxldGUgcmVxdWVzdFByb21pc2VzW3JlcXVlc3RIYXNoXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCByZXF1ZXN0UHJvbWlzZXNbcmVxdWVzdEhhc2hdO1xuICAgICAgfTtcbiAgICB9KSgpO1xuICAgIGxldCB3c0VuZHBvaW50O1xuICAgIGxldCBodHRwSGVhZGVycztcbiAgICBsZXQgZmV0Y2g7XG4gICAgbGV0IGZldGNoTWlkZGxld2FyZTtcbiAgICBsZXQgZGlzYWJsZVJldHJ5T25SYXRlTGltaXQ7XG4gICAgbGV0IGh0dHBBZ2VudDtcbiAgICBpZiAoX2NvbW1pdG1lbnRPckNvbmZpZyAmJiB0eXBlb2YgX2NvbW1pdG1lbnRPckNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuX2NvbW1pdG1lbnQgPSBfY29tbWl0bWVudE9yQ29uZmlnO1xuICAgIH0gZWxzZSBpZiAoX2NvbW1pdG1lbnRPckNvbmZpZykge1xuICAgICAgdGhpcy5fY29tbWl0bWVudCA9IF9jb21taXRtZW50T3JDb25maWcuY29tbWl0bWVudDtcbiAgICAgIHRoaXMuX2NvbmZpcm1UcmFuc2FjdGlvbkluaXRpYWxUaW1lb3V0ID0gX2NvbW1pdG1lbnRPckNvbmZpZy5jb25maXJtVHJhbnNhY3Rpb25Jbml0aWFsVGltZW91dDtcbiAgICAgIHdzRW5kcG9pbnQgPSBfY29tbWl0bWVudE9yQ29uZmlnLndzRW5kcG9pbnQ7XG4gICAgICBodHRwSGVhZGVycyA9IF9jb21taXRtZW50T3JDb25maWcuaHR0cEhlYWRlcnM7XG4gICAgICBmZXRjaCA9IF9jb21taXRtZW50T3JDb25maWcuZmV0Y2g7XG4gICAgICBmZXRjaE1pZGRsZXdhcmUgPSBfY29tbWl0bWVudE9yQ29uZmlnLmZldGNoTWlkZGxld2FyZTtcbiAgICAgIGRpc2FibGVSZXRyeU9uUmF0ZUxpbWl0ID0gX2NvbW1pdG1lbnRPckNvbmZpZy5kaXNhYmxlUmV0cnlPblJhdGVMaW1pdDtcbiAgICAgIGh0dHBBZ2VudCA9IF9jb21taXRtZW50T3JDb25maWcuaHR0cEFnZW50O1xuICAgIH1cbiAgICB0aGlzLl9ycGNFbmRwb2ludCA9IGFzc2VydEVuZHBvaW50VXJsKGVuZHBvaW50KTtcbiAgICB0aGlzLl9ycGNXc0VuZHBvaW50ID0gd3NFbmRwb2ludCB8fCBtYWtlV2Vic29ja2V0VXJsKGVuZHBvaW50KTtcbiAgICB0aGlzLl9ycGNDbGllbnQgPSBjcmVhdGVScGNDbGllbnQoZW5kcG9pbnQsIGh0dHBIZWFkZXJzLCBmZXRjaCwgZmV0Y2hNaWRkbGV3YXJlLCBkaXNhYmxlUmV0cnlPblJhdGVMaW1pdCwgaHR0cEFnZW50KTtcbiAgICB0aGlzLl9ycGNSZXF1ZXN0ID0gY3JlYXRlUnBjUmVxdWVzdCh0aGlzLl9ycGNDbGllbnQpO1xuICAgIHRoaXMuX3JwY0JhdGNoUmVxdWVzdCA9IGNyZWF0ZVJwY0JhdGNoUmVxdWVzdCh0aGlzLl9ycGNDbGllbnQpO1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldCA9IG5ldyBScGNXZWJTb2NrZXRDbGllbnQodGhpcy5fcnBjV3NFbmRwb2ludCwge1xuICAgICAgYXV0b2Nvbm5lY3Q6IGZhbHNlLFxuICAgICAgbWF4X3JlY29ubmVjdHM6IEluZmluaXR5XG4gICAgfSk7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Lm9uKCdvcGVuJywgdGhpcy5fd3NPbk9wZW4uYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Lm9uKCdlcnJvcicsIHRoaXMuX3dzT25FcnJvci5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXQub24oJ2Nsb3NlJywgdGhpcy5fd3NPbkNsb3NlLmJpbmQodGhpcykpO1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldC5vbignYWNjb3VudE5vdGlmaWNhdGlvbicsIHRoaXMuX3dzT25BY2NvdW50Tm90aWZpY2F0aW9uLmJpbmQodGhpcykpO1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldC5vbigncHJvZ3JhbU5vdGlmaWNhdGlvbicsIHRoaXMuX3dzT25Qcm9ncmFtQWNjb3VudE5vdGlmaWNhdGlvbi5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXQub24oJ3Nsb3ROb3RpZmljYXRpb24nLCB0aGlzLl93c09uU2xvdE5vdGlmaWNhdGlvbi5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXQub24oJ3Nsb3RzVXBkYXRlc05vdGlmaWNhdGlvbicsIHRoaXMuX3dzT25TbG90VXBkYXRlc05vdGlmaWNhdGlvbi5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXQub24oJ3NpZ25hdHVyZU5vdGlmaWNhdGlvbicsIHRoaXMuX3dzT25TaWduYXR1cmVOb3RpZmljYXRpb24uYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Lm9uKCdyb290Tm90aWZpY2F0aW9uJywgdGhpcy5fd3NPblJvb3ROb3RpZmljYXRpb24uYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Lm9uKCdsb2dzTm90aWZpY2F0aW9uJywgdGhpcy5fd3NPbkxvZ3NOb3RpZmljYXRpb24uYmluZCh0aGlzKSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgY29tbWl0bWVudCB1c2VkIGZvciByZXF1ZXN0c1xuICAgKi9cbiAgZ2V0IGNvbW1pdG1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbW1pdG1lbnQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIFJQQyBlbmRwb2ludFxuICAgKi9cbiAgZ2V0IHJwY0VuZHBvaW50KCkge1xuICAgIHJldHVybiB0aGlzLl9ycGNFbmRwb2ludDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgYmFsYW5jZSBmb3IgdGhlIHNwZWNpZmllZCBwdWJsaWMga2V5LCByZXR1cm4gd2l0aCBjb250ZXh0XG4gICAqL1xuICBhc3luYyBnZXRCYWxhbmNlQW5kQ29udGV4dChwdWJsaWNLZXksIGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3B1YmxpY0tleS50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEJhbGFuY2UnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChudW1iZXIoKSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsIGBmYWlsZWQgdG8gZ2V0IGJhbGFuY2UgZm9yICR7cHVibGljS2V5LnRvQmFzZTU4KCl9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBiYWxhbmNlIGZvciB0aGUgc3BlY2lmaWVkIHB1YmxpYyBrZXlcbiAgICovXG4gIGFzeW5jIGdldEJhbGFuY2UocHVibGljS2V5LCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRCYWxhbmNlQW5kQ29udGV4dChwdWJsaWNLZXksIGNvbW1pdG1lbnRPckNvbmZpZykudGhlbih4ID0+IHgudmFsdWUpLmNhdGNoKGUgPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdmYWlsZWQgdG8gZ2V0IGJhbGFuY2Ugb2YgYWNjb3VudCAnICsgcHVibGljS2V5LnRvQmFzZTU4KCkgKyAnOiAnICsgZSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGVzdGltYXRlZCBwcm9kdWN0aW9uIHRpbWUgb2YgYSBibG9ja1xuICAgKi9cbiAgYXN5bmMgZ2V0QmxvY2tUaW1lKHNsb3QpIHtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRCbG9ja1RpbWUnLCBbc2xvdF0pO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQobnVsbGFibGUobnVtYmVyKCkpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgYGZhaWxlZCB0byBnZXQgYmxvY2sgdGltZSBmb3Igc2xvdCAke3Nsb3R9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBsb3dlc3Qgc2xvdCB0aGF0IHRoZSBub2RlIGhhcyBpbmZvcm1hdGlvbiBhYm91dCBpbiBpdHMgbGVkZ2VyLlxuICAgKiBUaGlzIHZhbHVlIG1heSBpbmNyZWFzZSBvdmVyIHRpbWUgaWYgdGhlIG5vZGUgaXMgY29uZmlndXJlZCB0byBwdXJnZSBvbGRlciBsZWRnZXIgZGF0YVxuICAgKi9cbiAgYXN5bmMgZ2V0TWluaW11bUxlZGdlclNsb3QoKSB7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnbWluaW11bUxlZGdlclNsb3QnLCBbXSk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdChudW1iZXIoKSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IG1pbmltdW0gbGVkZ2VyIHNsb3QnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIHNsb3Qgb2YgdGhlIGxvd2VzdCBjb25maXJtZWQgYmxvY2sgdGhhdCBoYXMgbm90IGJlZW4gcHVyZ2VkIGZyb20gdGhlIGxlZGdlclxuICAgKi9cbiAgYXN5bmMgZ2V0Rmlyc3RBdmFpbGFibGVCbG9jaygpIHtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRGaXJzdEF2YWlsYWJsZUJsb2NrJywgW10pO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIFNsb3RScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGZpcnN0IGF2YWlsYWJsZSBibG9jaycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY3VycmVudCBzdXBwbHlcbiAgICovXG4gIGFzeW5jIGdldFN1cHBseShjb25maWcpIHtcbiAgICBsZXQgY29uZmlnQXJnID0ge307XG4gICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25maWdBcmcgPSB7XG4gICAgICAgIGNvbW1pdG1lbnQ6IGNvbmZpZ1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGNvbmZpZykge1xuICAgICAgY29uZmlnQXJnID0ge1xuICAgICAgICAuLi5jb25maWcsXG4gICAgICAgIGNvbW1pdG1lbnQ6IGNvbmZpZyAmJiBjb25maWcuY29tbWl0bWVudCB8fCB0aGlzLmNvbW1pdG1lbnRcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbmZpZ0FyZyA9IHtcbiAgICAgICAgY29tbWl0bWVudDogdGhpcy5jb21taXRtZW50XG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRTdXBwbHknLCBbY29uZmlnQXJnXSk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0U3VwcGx5UnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBzdXBwbHknKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGN1cnJlbnQgc3VwcGx5IG9mIGEgdG9rZW4gbWludFxuICAgKi9cbiAgYXN5bmMgZ2V0VG9rZW5TdXBwbHkodG9rZW5NaW50QWRkcmVzcywgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3Rva2VuTWludEFkZHJlc3MudG9CYXNlNTgoKV0sIGNvbW1pdG1lbnQpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFRva2VuU3VwcGx5JywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdEFuZENvbnRleHQoVG9rZW5BbW91bnRSZXN1bHQpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCB0b2tlbiBzdXBwbHknKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGN1cnJlbnQgYmFsYW5jZSBvZiBhIHRva2VuIGFjY291bnRcbiAgICovXG4gIGFzeW5jIGdldFRva2VuQWNjb3VudEJhbGFuY2UodG9rZW5BZGRyZXNzLCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbdG9rZW5BZGRyZXNzLnRvQmFzZTU4KCldLCBjb21taXRtZW50KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRUb2tlbkFjY291bnRCYWxhbmNlJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdEFuZENvbnRleHQoVG9rZW5BbW91bnRSZXN1bHQpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCB0b2tlbiBhY2NvdW50IGJhbGFuY2UnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYWxsIHRoZSB0b2tlbiBhY2NvdW50cyBvd25lZCBieSB0aGUgc3BlY2lmaWVkIGFjY291bnRcbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZTxScGNSZXNwb25zZUFuZENvbnRleHQ8R2V0UHJvZ3JhbUFjY291bnRzUmVzcG9uc2U+fVxuICAgKi9cbiAgYXN5bmMgZ2V0VG9rZW5BY2NvdW50c0J5T3duZXIob3duZXJBZGRyZXNzLCBmaWx0ZXIsIGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgbGV0IF9hcmdzID0gW293bmVyQWRkcmVzcy50b0Jhc2U1OCgpXTtcbiAgICBpZiAoJ21pbnQnIGluIGZpbHRlcikge1xuICAgICAgX2FyZ3MucHVzaCh7XG4gICAgICAgIG1pbnQ6IGZpbHRlci5taW50LnRvQmFzZTU4KClcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBfYXJncy5wdXNoKHtcbiAgICAgICAgcHJvZ3JhbUlkOiBmaWx0ZXIucHJvZ3JhbUlkLnRvQmFzZTU4KClcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKF9hcmdzLCBjb21taXRtZW50LCAnYmFzZTY0JywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRUb2tlbkFjY291bnRzQnlPd25lcicsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFRva2VuQWNjb3VudHNCeU93bmVyKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCBgZmFpbGVkIHRvIGdldCB0b2tlbiBhY2NvdW50cyBvd25lZCBieSBhY2NvdW50ICR7b3duZXJBZGRyZXNzLnRvQmFzZTU4KCl9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHBhcnNlZCB0b2tlbiBhY2NvdW50cyBvd25lZCBieSB0aGUgc3BlY2lmaWVkIGFjY291bnRcbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZTxScGNSZXNwb25zZUFuZENvbnRleHQ8QXJyYXk8e3B1YmtleTogUHVibGljS2V5LCBhY2NvdW50OiBBY2NvdW50SW5mbzxQYXJzZWRBY2NvdW50RGF0YT59Pj4+fVxuICAgKi9cbiAgYXN5bmMgZ2V0UGFyc2VkVG9rZW5BY2NvdW50c0J5T3duZXIob3duZXJBZGRyZXNzLCBmaWx0ZXIsIGNvbW1pdG1lbnQpIHtcbiAgICBsZXQgX2FyZ3MgPSBbb3duZXJBZGRyZXNzLnRvQmFzZTU4KCldO1xuICAgIGlmICgnbWludCcgaW4gZmlsdGVyKSB7XG4gICAgICBfYXJncy5wdXNoKHtcbiAgICAgICAgbWludDogZmlsdGVyLm1pbnQudG9CYXNlNTgoKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9hcmdzLnB1c2goe1xuICAgICAgICBwcm9ncmFtSWQ6IGZpbHRlci5wcm9ncmFtSWQudG9CYXNlNTgoKVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoX2FyZ3MsIGNvbW1pdG1lbnQsICdqc29uUGFyc2VkJyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0VG9rZW5BY2NvdW50c0J5T3duZXInLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRQYXJzZWRUb2tlbkFjY291bnRzQnlPd25lcik7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgYGZhaWxlZCB0byBnZXQgdG9rZW4gYWNjb3VudHMgb3duZWQgYnkgYWNjb3VudCAke293bmVyQWRkcmVzcy50b0Jhc2U1OCgpfWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgMjAgbGFyZ2VzdCBhY2NvdW50cyB3aXRoIHRoZWlyIGN1cnJlbnQgYmFsYW5jZXNcbiAgICovXG4gIGFzeW5jIGdldExhcmdlc3RBY2NvdW50cyhjb25maWcpIHtcbiAgICBjb25zdCBhcmcgPSB7XG4gICAgICAuLi5jb25maWcsXG4gICAgICBjb21taXRtZW50OiBjb25maWcgJiYgY29uZmlnLmNvbW1pdG1lbnQgfHwgdGhpcy5jb21taXRtZW50XG4gICAgfTtcbiAgICBjb25zdCBhcmdzID0gYXJnLmZpbHRlciB8fCBhcmcuY29tbWl0bWVudCA/IFthcmddIDogW107XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0TGFyZ2VzdEFjY291bnRzJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0TGFyZ2VzdEFjY291bnRzUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBsYXJnZXN0IGFjY291bnRzJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSAyMCBsYXJnZXN0IHRva2VuIGFjY291bnRzIHdpdGggdGhlaXIgY3VycmVudCBiYWxhbmNlc1xuICAgKiBmb3IgYSBnaXZlbiBtaW50LlxuICAgKi9cbiAgYXN5bmMgZ2V0VG9rZW5MYXJnZXN0QWNjb3VudHMobWludEFkZHJlc3MsIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFttaW50QWRkcmVzcy50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0VG9rZW5MYXJnZXN0QWNjb3VudHMnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRUb2tlbkxhcmdlc3RBY2NvdW50c1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgdG9rZW4gbGFyZ2VzdCBhY2NvdW50cycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhbGwgdGhlIGFjY291bnQgaW5mbyBmb3IgdGhlIHNwZWNpZmllZCBwdWJsaWMga2V5LCByZXR1cm4gd2l0aCBjb250ZXh0XG4gICAqL1xuICBhc3luYyBnZXRBY2NvdW50SW5mb0FuZENvbnRleHQocHVibGljS2V5LCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3B1YmxpY0tleS50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCwgJ2Jhc2U2NCcsIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0QWNjb3VudEluZm8nLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChudWxsYWJsZShBY2NvdW50SW5mb1Jlc3VsdCkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCBgZmFpbGVkIHRvIGdldCBpbmZvIGFib3V0IGFjY291bnQgJHtwdWJsaWNLZXkudG9CYXNlNTgoKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggcGFyc2VkIGFjY291bnQgaW5mbyBmb3IgdGhlIHNwZWNpZmllZCBwdWJsaWMga2V5XG4gICAqL1xuICBhc3luYyBnZXRQYXJzZWRBY2NvdW50SW5mbyhwdWJsaWNLZXksIGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbcHVibGljS2V5LnRvQmFzZTU4KCldLCBjb21taXRtZW50LCAnanNvblBhcnNlZCcsIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0QWNjb3VudEluZm8nLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChudWxsYWJsZShQYXJzZWRBY2NvdW50SW5mb1Jlc3VsdCkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCBgZmFpbGVkIHRvIGdldCBpbmZvIGFib3V0IGFjY291bnQgJHtwdWJsaWNLZXkudG9CYXNlNTgoKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYWxsIHRoZSBhY2NvdW50IGluZm8gZm9yIHRoZSBzcGVjaWZpZWQgcHVibGljIGtleVxuICAgKi9cbiAgYXN5bmMgZ2V0QWNjb3VudEluZm8ocHVibGljS2V5LCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5nZXRBY2NvdW50SW5mb0FuZENvbnRleHQocHVibGljS2V5LCBjb21taXRtZW50T3JDb25maWcpO1xuICAgICAgcmV0dXJuIHJlcy52YWx1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZhaWxlZCB0byBnZXQgaW5mbyBhYm91dCBhY2NvdW50ICcgKyBwdWJsaWNLZXkudG9CYXNlNTgoKSArICc6ICcgKyBlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYWxsIHRoZSBhY2NvdW50IGluZm8gZm9yIG11bHRpcGxlIGFjY291bnRzIHNwZWNpZmllZCBieSBhbiBhcnJheSBvZiBwdWJsaWMga2V5cywgcmV0dXJuIHdpdGggY29udGV4dFxuICAgKi9cbiAgYXN5bmMgZ2V0TXVsdGlwbGVQYXJzZWRBY2NvdW50cyhwdWJsaWNLZXlzLCByYXdDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhyYXdDb25maWcpO1xuICAgIGNvbnN0IGtleXMgPSBwdWJsaWNLZXlzLm1hcChrZXkgPT4ga2V5LnRvQmFzZTU4KCkpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW2tleXNdLCBjb21taXRtZW50LCAnanNvblBhcnNlZCcsIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0TXVsdGlwbGVBY2NvdW50cycsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KGFycmF5KG51bGxhYmxlKFBhcnNlZEFjY291bnRJbmZvUmVzdWx0KSkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCBgZmFpbGVkIHRvIGdldCBpbmZvIGZvciBhY2NvdW50cyAke2tleXN9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGFsbCB0aGUgYWNjb3VudCBpbmZvIGZvciBtdWx0aXBsZSBhY2NvdW50cyBzcGVjaWZpZWQgYnkgYW4gYXJyYXkgb2YgcHVibGljIGtleXMsIHJldHVybiB3aXRoIGNvbnRleHRcbiAgICovXG4gIGFzeW5jIGdldE11bHRpcGxlQWNjb3VudHNJbmZvQW5kQ29udGV4dChwdWJsaWNLZXlzLCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGtleXMgPSBwdWJsaWNLZXlzLm1hcChrZXkgPT4ga2V5LnRvQmFzZTU4KCkpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW2tleXNdLCBjb21taXRtZW50LCAnYmFzZTY0JywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRNdWx0aXBsZUFjY291bnRzJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdEFuZENvbnRleHQoYXJyYXkobnVsbGFibGUoQWNjb3VudEluZm9SZXN1bHQpKSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsIGBmYWlsZWQgdG8gZ2V0IGluZm8gZm9yIGFjY291bnRzICR7a2V5c31gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYWxsIHRoZSBhY2NvdW50IGluZm8gZm9yIG11bHRpcGxlIGFjY291bnRzIHNwZWNpZmllZCBieSBhbiBhcnJheSBvZiBwdWJsaWMga2V5c1xuICAgKi9cbiAgYXN5bmMgZ2V0TXVsdGlwbGVBY2NvdW50c0luZm8ocHVibGljS2V5cywgY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5nZXRNdWx0aXBsZUFjY291bnRzSW5mb0FuZENvbnRleHQocHVibGljS2V5cywgY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICByZXR1cm4gcmVzLnZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZXBvY2ggYWN0aXZhdGlvbiBpbmZvcm1hdGlvbiBmb3IgYSBzdGFrZSBhY2NvdW50IHRoYXQgaGFzIGJlZW4gZGVsZWdhdGVkXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgUlBDIHYxLjE4OyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbi5cbiAgICovXG4gIGFzeW5jIGdldFN0YWtlQWN0aXZhdGlvbihwdWJsaWNLZXksIGNvbW1pdG1lbnRPckNvbmZpZywgZXBvY2gpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3B1YmxpY0tleS50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLCB7XG4gICAgICAuLi5jb25maWcsXG4gICAgICBlcG9jaDogZXBvY2ggIT0gbnVsbCA/IGVwb2NoIDogY29uZmlnPy5lcG9jaFxuICAgIH0pO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFN0YWtlQWN0aXZhdGlvbicsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQoU3Rha2VBY3RpdmF0aW9uUmVzdWx0KSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgYGZhaWxlZCB0byBnZXQgU3Rha2UgQWN0aXZhdGlvbiAke3B1YmxpY0tleS50b0Jhc2U1OCgpfWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhbGwgdGhlIGFjY291bnRzIG93bmVkIGJ5IHRoZSBzcGVjaWZpZWQgcHJvZ3JhbSBpZFxuICAgKlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5PHtwdWJrZXk6IFB1YmxpY0tleSwgYWNjb3VudDogQWNjb3VudEluZm88QnVmZmVyPn0+Pn1cbiAgICovXG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcbiAgYXN5bmMgZ2V0UHJvZ3JhbUFjY291bnRzKHByb2dyYW1JZCwgY29uZmlnT3JDb21taXRtZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29uZmlnT3JDb21taXRtZW50KTtcbiAgICBjb25zdCB7XG4gICAgICBlbmNvZGluZyxcbiAgICAgIC4uLmNvbmZpZ1dpdGhvdXRFbmNvZGluZ1xuICAgIH0gPSBjb25maWcgfHwge307XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbcHJvZ3JhbUlkLnRvQmFzZTU4KCldLCBjb21taXRtZW50LCBlbmNvZGluZyB8fCAnYmFzZTY0Jywge1xuICAgICAgLi4uY29uZmlnV2l0aG91dEVuY29kaW5nLFxuICAgICAgLi4uKGNvbmZpZ1dpdGhvdXRFbmNvZGluZy5maWx0ZXJzID8ge1xuICAgICAgICBmaWx0ZXJzOiBhcHBseURlZmF1bHRNZW1jbXBFbmNvZGluZ1RvRmlsdGVycyhjb25maWdXaXRob3V0RW5jb2RpbmcuZmlsdGVycylcbiAgICAgIH0gOiBudWxsKVxuICAgIH0pO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFByb2dyYW1BY2NvdW50cycsIGFyZ3MpO1xuICAgIGNvbnN0IGJhc2VTY2hlbWEgPSBhcnJheShLZXllZEFjY291bnRJbmZvUmVzdWx0KTtcbiAgICBjb25zdCByZXMgPSBjb25maWdXaXRob3V0RW5jb2Rpbmcud2l0aENvbnRleHQgPT09IHRydWUgPyBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChiYXNlU2NoZW1hKSkgOiBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KGJhc2VTY2hlbWEpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCBgZmFpbGVkIHRvIGdldCBhY2NvdW50cyBvd25lZCBieSBwcm9ncmFtICR7cHJvZ3JhbUlkLnRvQmFzZTU4KCl9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGFuZCBwYXJzZSBhbGwgdGhlIGFjY291bnRzIG93bmVkIGJ5IHRoZSBzcGVjaWZpZWQgcHJvZ3JhbSBpZFxuICAgKlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5PHtwdWJrZXk6IFB1YmxpY0tleSwgYWNjb3VudDogQWNjb3VudEluZm88QnVmZmVyIHwgUGFyc2VkQWNjb3VudERhdGE+fT4+fVxuICAgKi9cbiAgYXN5bmMgZ2V0UGFyc2VkUHJvZ3JhbUFjY291bnRzKHByb2dyYW1JZCwgY29uZmlnT3JDb21taXRtZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29uZmlnT3JDb21taXRtZW50KTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtwcm9ncmFtSWQudG9CYXNlNTgoKV0sIGNvbW1pdG1lbnQsICdqc29uUGFyc2VkJywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRQcm9ncmFtQWNjb3VudHMnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KGFycmF5KEtleWVkUGFyc2VkQWNjb3VudEluZm9SZXN1bHQpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgYGZhaWxlZCB0byBnZXQgYWNjb3VudHMgb3duZWQgYnkgcHJvZ3JhbSAke3Byb2dyYW1JZC50b0Jhc2U1OCgpfWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKiBAZGVwcmVjYXRlZCBJbnN0ZWFkLCBjYWxsIGBjb25maXJtVHJhbnNhY3Rpb25gIGFuZCBwYXNzIGluIHtAbGluayBUcmFuc2FjdGlvbkNvbmZpcm1hdGlvblN0cmF0ZWd5fSAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuICBhc3luYyBjb25maXJtVHJhbnNhY3Rpb24oc3RyYXRlZ3ksIGNvbW1pdG1lbnQpIHtcbiAgICBsZXQgcmF3U2lnbmF0dXJlO1xuICAgIGlmICh0eXBlb2Ygc3RyYXRlZ3kgPT0gJ3N0cmluZycpIHtcbiAgICAgIHJhd1NpZ25hdHVyZSA9IHN0cmF0ZWd5O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjb25maWcgPSBzdHJhdGVneTtcbiAgICAgIGlmIChjb25maWcuYWJvcnRTaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGNvbmZpZy5hYm9ydFNpZ25hbC5yZWFzb24pO1xuICAgICAgfVxuICAgICAgcmF3U2lnbmF0dXJlID0gY29uZmlnLnNpZ25hdHVyZTtcbiAgICB9XG4gICAgbGV0IGRlY29kZWRTaWduYXR1cmU7XG4gICAgdHJ5IHtcbiAgICAgIGRlY29kZWRTaWduYXR1cmUgPSBiczU4LmRlY29kZShyYXdTaWduYXR1cmUpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduYXR1cmUgbXVzdCBiZSBiYXNlNTggZW5jb2RlZDogJyArIHJhd1NpZ25hdHVyZSk7XG4gICAgfVxuICAgIGFzc2VydChkZWNvZGVkU2lnbmF0dXJlLmxlbmd0aCA9PT0gNjQsICdzaWduYXR1cmUgaGFzIGludmFsaWQgbGVuZ3RoJyk7XG4gICAgaWYgKHR5cGVvZiBzdHJhdGVneSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNvbmZpcm1UcmFuc2FjdGlvblVzaW5nTGVnYWN5VGltZW91dFN0cmF0ZWd5KHtcbiAgICAgICAgY29tbWl0bWVudDogY29tbWl0bWVudCB8fCB0aGlzLmNvbW1pdG1lbnQsXG4gICAgICAgIHNpZ25hdHVyZTogcmF3U2lnbmF0dXJlXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCdsYXN0VmFsaWRCbG9ja0hlaWdodCcgaW4gc3RyYXRlZ3kpIHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNvbmZpcm1UcmFuc2FjdGlvblVzaW5nQmxvY2tIZWlnaHRFeGNlZWRhbmNlU3RyYXRlZ3koe1xuICAgICAgICBjb21taXRtZW50OiBjb21taXRtZW50IHx8IHRoaXMuY29tbWl0bWVudCxcbiAgICAgICAgc3RyYXRlZ3lcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5jb25maXJtVHJhbnNhY3Rpb25Vc2luZ0R1cmFibGVOb25jZVN0cmF0ZWd5KHtcbiAgICAgICAgY29tbWl0bWVudDogY29tbWl0bWVudCB8fCB0aGlzLmNvbW1pdG1lbnQsXG4gICAgICAgIHN0cmF0ZWd5XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZ2V0Q2FuY2VsbGF0aW9uUHJvbWlzZShzaWduYWwpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKHNpZ25hbCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICByZWplY3Qoc2lnbmFsLnJlYXNvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiB7XG4gICAgICAgICAgcmVqZWN0KHNpZ25hbC5yZWFzb24pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBnZXRUcmFuc2FjdGlvbkNvbmZpcm1hdGlvblByb21pc2Uoe1xuICAgIGNvbW1pdG1lbnQsXG4gICAgc2lnbmF0dXJlXG4gIH0pIHtcbiAgICBsZXQgc2lnbmF0dXJlU3Vic2NyaXB0aW9uSWQ7XG4gICAgbGV0IGRpc3Bvc2VTaWduYXR1cmVTdWJzY3JpcHRpb25TdGF0ZUNoYW5nZU9ic2VydmVyO1xuICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgY29uc3QgY29uZmlybWF0aW9uUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNpZ25hdHVyZVN1YnNjcmlwdGlvbklkID0gdGhpcy5vblNpZ25hdHVyZShzaWduYXR1cmUsIChyZXN1bHQsIGNvbnRleHQpID0+IHtcbiAgICAgICAgICBzaWduYXR1cmVTdWJzY3JpcHRpb25JZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHtcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICB2YWx1ZTogcmVzdWx0XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgIF9fdHlwZTogVHJhbnNhY3Rpb25TdGF0dXMuUFJPQ0VTU0VELFxuICAgICAgICAgICAgcmVzcG9uc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgY29tbWl0bWVudCk7XG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvblNldHVwUHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmVTdWJzY3JpcHRpb25TZXR1cCA9PiB7XG4gICAgICAgICAgaWYgKHNpZ25hdHVyZVN1YnNjcmlwdGlvbklkID09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc29sdmVTdWJzY3JpcHRpb25TZXR1cCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaXNwb3NlU2lnbmF0dXJlU3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2VPYnNlcnZlciA9IHRoaXMuX29uU3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2Uoc2lnbmF0dXJlU3Vic2NyaXB0aW9uSWQsIG5leHRTdGF0ZSA9PiB7XG4gICAgICAgICAgICAgIGlmIChuZXh0U3RhdGUgPT09ICdzdWJzY3JpYmVkJykge1xuICAgICAgICAgICAgICAgIHJlc29sdmVTdWJzY3JpcHRpb25TZXR1cCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGF3YWl0IHN1YnNjcmlwdGlvblNldHVwUHJvbWlzZTtcbiAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5nZXRTaWduYXR1cmVTdGF0dXMoc2lnbmF0dXJlKTtcbiAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICAgIGlmIChyZXNwb25zZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH0gPSByZXNwb25zZTtcbiAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsdWU/LmVycikge1xuICAgICAgICAgICAgcmVqZWN0KHZhbHVlLmVycik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN3aXRjaCAoY29tbWl0bWVudCkge1xuICAgICAgICAgICAgICBjYXNlICdjb25maXJtZWQnOlxuICAgICAgICAgICAgICBjYXNlICdzaW5nbGUnOlxuICAgICAgICAgICAgICBjYXNlICdzaW5nbGVHb3NzaXAnOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5jb25maXJtYXRpb25TdGF0dXMgPT09ICdwcm9jZXNzZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSAnZmluYWxpemVkJzpcbiAgICAgICAgICAgICAgY2FzZSAnbWF4JzpcbiAgICAgICAgICAgICAgY2FzZSAncm9vdCc6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLmNvbmZpcm1hdGlvblN0YXR1cyA9PT0gJ3Byb2Nlc3NlZCcgfHwgdmFsdWUuY29uZmlybWF0aW9uU3RhdHVzID09PSAnY29uZmlybWVkJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIGV4aGF1c3QgZW51bXMgdG8gZW5zdXJlIGZ1bGwgY292ZXJhZ2VcbiAgICAgICAgICAgICAgY2FzZSAncHJvY2Vzc2VkJzpcbiAgICAgICAgICAgICAgY2FzZSAncmVjZW50JzpcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgIF9fdHlwZTogVHJhbnNhY3Rpb25TdGF0dXMuUFJPQ0VTU0VELFxuICAgICAgICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGFib3J0Q29uZmlybWF0aW9uID0gKCkgPT4ge1xuICAgICAgaWYgKGRpc3Bvc2VTaWduYXR1cmVTdWJzY3JpcHRpb25TdGF0ZUNoYW5nZU9ic2VydmVyKSB7XG4gICAgICAgIGRpc3Bvc2VTaWduYXR1cmVTdWJzY3JpcHRpb25TdGF0ZUNoYW5nZU9ic2VydmVyKCk7XG4gICAgICAgIGRpc3Bvc2VTaWduYXR1cmVTdWJzY3JpcHRpb25TdGF0ZUNoYW5nZU9ic2VydmVyID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKHNpZ25hdHVyZVN1YnNjcmlwdGlvbklkICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVTaWduYXR1cmVMaXN0ZW5lcihzaWduYXR1cmVTdWJzY3JpcHRpb25JZCk7XG4gICAgICAgIHNpZ25hdHVyZVN1YnNjcmlwdGlvbklkID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIGFib3J0Q29uZmlybWF0aW9uLFxuICAgICAgY29uZmlybWF0aW9uUHJvbWlzZVxuICAgIH07XG4gIH1cbiAgYXN5bmMgY29uZmlybVRyYW5zYWN0aW9uVXNpbmdCbG9ja0hlaWdodEV4Y2VlZGFuY2VTdHJhdGVneSh7XG4gICAgY29tbWl0bWVudCxcbiAgICBzdHJhdGVneToge1xuICAgICAgYWJvcnRTaWduYWwsXG4gICAgICBsYXN0VmFsaWRCbG9ja0hlaWdodCxcbiAgICAgIHNpZ25hdHVyZVxuICAgIH1cbiAgfSkge1xuICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgY29uc3QgZXhwaXJ5UHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgY29uc3QgY2hlY2tCbG9ja0hlaWdodCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBibG9ja0hlaWdodCA9IGF3YWl0IHRoaXMuZ2V0QmxvY2tIZWlnaHQoY29tbWl0bWVudCk7XG4gICAgICAgICAgcmV0dXJuIGJsb2NrSGVpZ2h0O1xuICAgICAgICB9IGNhdGNoIChfZSkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgIGxldCBjdXJyZW50QmxvY2tIZWlnaHQgPSBhd2FpdCBjaGVja0Jsb2NrSGVpZ2h0KCk7XG4gICAgICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgICAgIHdoaWxlIChjdXJyZW50QmxvY2tIZWlnaHQgPD0gbGFzdFZhbGlkQmxvY2tIZWlnaHQpIHtcbiAgICAgICAgICBhd2FpdCBzbGVlcCgxMDAwKTtcbiAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICAgIGN1cnJlbnRCbG9ja0hlaWdodCA9IGF3YWl0IGNoZWNrQmxvY2tIZWlnaHQoKTtcbiAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgIF9fdHlwZTogVHJhbnNhY3Rpb25TdGF0dXMuQkxPQ0tIRUlHSFRfRVhDRUVERURcbiAgICAgICAgfSk7XG4gICAgICB9KSgpO1xuICAgIH0pO1xuICAgIGNvbnN0IHtcbiAgICAgIGFib3J0Q29uZmlybWF0aW9uLFxuICAgICAgY29uZmlybWF0aW9uUHJvbWlzZVxuICAgIH0gPSB0aGlzLmdldFRyYW5zYWN0aW9uQ29uZmlybWF0aW9uUHJvbWlzZSh7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgc2lnbmF0dXJlXG4gICAgfSk7XG4gICAgY29uc3QgY2FuY2VsbGF0aW9uUHJvbWlzZSA9IHRoaXMuZ2V0Q2FuY2VsbGF0aW9uUHJvbWlzZShhYm9ydFNpZ25hbCk7XG4gICAgbGV0IHJlc3VsdDtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgb3V0Y29tZSA9IGF3YWl0IFByb21pc2UucmFjZShbY2FuY2VsbGF0aW9uUHJvbWlzZSwgY29uZmlybWF0aW9uUHJvbWlzZSwgZXhwaXJ5UHJvbWlzZV0pO1xuICAgICAgaWYgKG91dGNvbWUuX190eXBlID09PSBUcmFuc2FjdGlvblN0YXR1cy5QUk9DRVNTRUQpIHtcbiAgICAgICAgcmVzdWx0ID0gb3V0Y29tZS5yZXNwb25zZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBUcmFuc2FjdGlvbkV4cGlyZWRCbG9ja2hlaWdodEV4Y2VlZGVkRXJyb3Ioc2lnbmF0dXJlKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgZG9uZSA9IHRydWU7XG4gICAgICBhYm9ydENvbmZpcm1hdGlvbigpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGFzeW5jIGNvbmZpcm1UcmFuc2FjdGlvblVzaW5nRHVyYWJsZU5vbmNlU3RyYXRlZ3koe1xuICAgIGNvbW1pdG1lbnQsXG4gICAgc3RyYXRlZ3k6IHtcbiAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgbWluQ29udGV4dFNsb3QsXG4gICAgICBub25jZUFjY291bnRQdWJrZXksXG4gICAgICBub25jZVZhbHVlLFxuICAgICAgc2lnbmF0dXJlXG4gICAgfVxuICB9KSB7XG4gICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICBjb25zdCBleHBpcnlQcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBsZXQgY3VycmVudE5vbmNlVmFsdWUgPSBub25jZVZhbHVlO1xuICAgICAgbGV0IGxhc3RDaGVja2VkU2xvdCA9IG51bGw7XG4gICAgICBjb25zdCBnZXRDdXJyZW50Tm9uY2VWYWx1ZSA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgdmFsdWU6IG5vbmNlQWNjb3VudFxuICAgICAgICAgIH0gPSBhd2FpdCB0aGlzLmdldE5vbmNlQW5kQ29udGV4dChub25jZUFjY291bnRQdWJrZXksIHtcbiAgICAgICAgICAgIGNvbW1pdG1lbnQsXG4gICAgICAgICAgICBtaW5Db250ZXh0U2xvdFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGxhc3RDaGVja2VkU2xvdCA9IGNvbnRleHQuc2xvdDtcbiAgICAgICAgICByZXR1cm4gbm9uY2VBY2NvdW50Py5ub25jZTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIElmIGZvciB3aGF0ZXZlciByZWFzb24gd2UgY2FuJ3QgcmVhY2gvcmVhZCB0aGUgbm9uY2VcbiAgICAgICAgICAvLyBhY2NvdW50LCBqdXN0IGtlZXAgdXNpbmcgdGhlIGxhc3Qta25vd24gdmFsdWUuXG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnROb25jZVZhbHVlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgY3VycmVudE5vbmNlVmFsdWUgPSBhd2FpdCBnZXRDdXJyZW50Tm9uY2VWYWx1ZSgpO1xuICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICB3aGlsZSAodHJ1ZSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgICAgICApIHtcbiAgICAgICAgICBpZiAobm9uY2VWYWx1ZSAhPT0gY3VycmVudE5vbmNlVmFsdWUpIHtcbiAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICBfX3R5cGU6IFRyYW5zYWN0aW9uU3RhdHVzLk5PTkNFX0lOVkFMSUQsXG4gICAgICAgICAgICAgIHNsb3RJbldoaWNoTm9uY2VEaWRBZHZhbmNlOiBsYXN0Q2hlY2tlZFNsb3RcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhd2FpdCBzbGVlcCgyMDAwKTtcbiAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICAgIGN1cnJlbnROb25jZVZhbHVlID0gYXdhaXQgZ2V0Q3VycmVudE5vbmNlVmFsdWUoKTtcbiAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9KSgpO1xuICAgIH0pO1xuICAgIGNvbnN0IHtcbiAgICAgIGFib3J0Q29uZmlybWF0aW9uLFxuICAgICAgY29uZmlybWF0aW9uUHJvbWlzZVxuICAgIH0gPSB0aGlzLmdldFRyYW5zYWN0aW9uQ29uZmlybWF0aW9uUHJvbWlzZSh7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgc2lnbmF0dXJlXG4gICAgfSk7XG4gICAgY29uc3QgY2FuY2VsbGF0aW9uUHJvbWlzZSA9IHRoaXMuZ2V0Q2FuY2VsbGF0aW9uUHJvbWlzZShhYm9ydFNpZ25hbCk7XG4gICAgbGV0IHJlc3VsdDtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgb3V0Y29tZSA9IGF3YWl0IFByb21pc2UucmFjZShbY2FuY2VsbGF0aW9uUHJvbWlzZSwgY29uZmlybWF0aW9uUHJvbWlzZSwgZXhwaXJ5UHJvbWlzZV0pO1xuICAgICAgaWYgKG91dGNvbWUuX190eXBlID09PSBUcmFuc2FjdGlvblN0YXR1cy5QUk9DRVNTRUQpIHtcbiAgICAgICAgcmVzdWx0ID0gb3V0Y29tZS5yZXNwb25zZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIERvdWJsZSBjaGVjayB0aGF0IHRoZSB0cmFuc2FjdGlvbiBpcyBpbmRlZWQgdW5jb25maXJtZWQuXG4gICAgICAgIGxldCBzaWduYXR1cmVTdGF0dXM7XG4gICAgICAgIHdoaWxlICh0cnVlIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IGF3YWl0IHRoaXMuZ2V0U2lnbmF0dXJlU3RhdHVzKHNpZ25hdHVyZSk7XG4gICAgICAgICAgaWYgKHN0YXR1cyA9PSBudWxsKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXR1cy5jb250ZXh0LnNsb3QgPCAob3V0Y29tZS5zbG90SW5XaGljaE5vbmNlRGlkQWR2YW5jZSA/PyBtaW5Db250ZXh0U2xvdCkpIHtcbiAgICAgICAgICAgIGF3YWl0IHNsZWVwKDQwMCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2lnbmF0dXJlU3RhdHVzID0gc3RhdHVzO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaWduYXR1cmVTdGF0dXM/LnZhbHVlKSB7XG4gICAgICAgICAgY29uc3QgY29tbWl0bWVudEZvclN0YXR1cyA9IGNvbW1pdG1lbnQgfHwgJ2ZpbmFsaXplZCc7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgY29uZmlybWF0aW9uU3RhdHVzXG4gICAgICAgICAgfSA9IHNpZ25hdHVyZVN0YXR1cy52YWx1ZTtcbiAgICAgICAgICBzd2l0Y2ggKGNvbW1pdG1lbnRGb3JTdGF0dXMpIHtcbiAgICAgICAgICAgIGNhc2UgJ3Byb2Nlc3NlZCc6XG4gICAgICAgICAgICBjYXNlICdyZWNlbnQnOlxuICAgICAgICAgICAgICBpZiAoY29uZmlybWF0aW9uU3RhdHVzICE9PSAncHJvY2Vzc2VkJyAmJiBjb25maXJtYXRpb25TdGF0dXMgIT09ICdjb25maXJtZWQnICYmIGNvbmZpcm1hdGlvblN0YXR1cyAhPT0gJ2ZpbmFsaXplZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHJhbnNhY3Rpb25FeHBpcmVkTm9uY2VJbnZhbGlkRXJyb3Ioc2lnbmF0dXJlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NvbmZpcm1lZCc6XG4gICAgICAgICAgICBjYXNlICdzaW5nbGUnOlxuICAgICAgICAgICAgY2FzZSAnc2luZ2xlR29zc2lwJzpcbiAgICAgICAgICAgICAgaWYgKGNvbmZpcm1hdGlvblN0YXR1cyAhPT0gJ2NvbmZpcm1lZCcgJiYgY29uZmlybWF0aW9uU3RhdHVzICE9PSAnZmluYWxpemVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUcmFuc2FjdGlvbkV4cGlyZWROb25jZUludmFsaWRFcnJvcihzaWduYXR1cmUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZmluYWxpemVkJzpcbiAgICAgICAgICAgIGNhc2UgJ21heCc6XG4gICAgICAgICAgICBjYXNlICdyb290JzpcbiAgICAgICAgICAgICAgaWYgKGNvbmZpcm1hdGlvblN0YXR1cyAhPT0gJ2ZpbmFsaXplZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHJhbnNhY3Rpb25FeHBpcmVkTm9uY2VJbnZhbGlkRXJyb3Ioc2lnbmF0dXJlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIC8vIEV4aGF1c3RpdmUgc3dpdGNoLlxuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgICAgICAgICAgIChfID0+IHt9KShjb21taXRtZW50Rm9yU3RhdHVzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgICAgY29udGV4dDogc2lnbmF0dXJlU3RhdHVzLmNvbnRleHQsXG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICBlcnI6IHNpZ25hdHVyZVN0YXR1cy52YWx1ZS5lcnJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBUcmFuc2FjdGlvbkV4cGlyZWROb25jZUludmFsaWRFcnJvcihzaWduYXR1cmUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgYWJvcnRDb25maXJtYXRpb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBhc3luYyBjb25maXJtVHJhbnNhY3Rpb25Vc2luZ0xlZ2FjeVRpbWVvdXRTdHJhdGVneSh7XG4gICAgY29tbWl0bWVudCxcbiAgICBzaWduYXR1cmVcbiAgfSkge1xuICAgIGxldCB0aW1lb3V0SWQ7XG4gICAgY29uc3QgZXhwaXJ5UHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgbGV0IHRpbWVvdXRNcyA9IHRoaXMuX2NvbmZpcm1UcmFuc2FjdGlvbkluaXRpYWxUaW1lb3V0IHx8IDYwICogMTAwMDtcbiAgICAgIHN3aXRjaCAoY29tbWl0bWVudCkge1xuICAgICAgICBjYXNlICdwcm9jZXNzZWQnOlxuICAgICAgICBjYXNlICdyZWNlbnQnOlxuICAgICAgICBjYXNlICdzaW5nbGUnOlxuICAgICAgICBjYXNlICdjb25maXJtZWQnOlxuICAgICAgICBjYXNlICdzaW5nbGVHb3NzaXAnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRpbWVvdXRNcyA9IHRoaXMuX2NvbmZpcm1UcmFuc2FjdGlvbkluaXRpYWxUaW1lb3V0IHx8IDMwICogMTAwMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4gcmVzb2x2ZSh7XG4gICAgICAgIF9fdHlwZTogVHJhbnNhY3Rpb25TdGF0dXMuVElNRURfT1VULFxuICAgICAgICB0aW1lb3V0TXNcbiAgICAgIH0pLCB0aW1lb3V0TXMpO1xuICAgIH0pO1xuICAgIGNvbnN0IHtcbiAgICAgIGFib3J0Q29uZmlybWF0aW9uLFxuICAgICAgY29uZmlybWF0aW9uUHJvbWlzZVxuICAgIH0gPSB0aGlzLmdldFRyYW5zYWN0aW9uQ29uZmlybWF0aW9uUHJvbWlzZSh7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgc2lnbmF0dXJlXG4gICAgfSk7XG4gICAgbGV0IHJlc3VsdDtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgb3V0Y29tZSA9IGF3YWl0IFByb21pc2UucmFjZShbY29uZmlybWF0aW9uUHJvbWlzZSwgZXhwaXJ5UHJvbWlzZV0pO1xuICAgICAgaWYgKG91dGNvbWUuX190eXBlID09PSBUcmFuc2FjdGlvblN0YXR1cy5QUk9DRVNTRUQpIHtcbiAgICAgICAgcmVzdWx0ID0gb3V0Y29tZS5yZXNwb25zZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBUcmFuc2FjdGlvbkV4cGlyZWRUaW1lb3V0RXJyb3Ioc2lnbmF0dXJlLCBvdXRjb21lLnRpbWVvdXRNcyAvIDEwMDApO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgIGFib3J0Q29uZmlybWF0aW9uKCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBsaXN0IG9mIG5vZGVzIHRoYXQgYXJlIGN1cnJlbnRseSBwYXJ0aWNpcGF0aW5nIGluIHRoZSBjbHVzdGVyXG4gICAqL1xuICBhc3luYyBnZXRDbHVzdGVyTm9kZXMoKSB7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0Q2x1c3Rlck5vZGVzJywgW10pO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQoYXJyYXkoQ29udGFjdEluZm9SZXN1bHQpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgY2x1c3RlciBub2RlcycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGxpc3Qgb2Ygbm9kZXMgdGhhdCBhcmUgY3VycmVudGx5IHBhcnRpY2lwYXRpbmcgaW4gdGhlIGNsdXN0ZXJcbiAgICovXG4gIGFzeW5jIGdldFZvdGVBY2NvdW50cyhjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbXSwgY29tbWl0bWVudCk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0Vm90ZUFjY291bnRzJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0Vm90ZUFjY291bnRzKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCB2b3RlIGFjY291bnRzJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBjdXJyZW50IHNsb3QgdGhhdCB0aGUgbm9kZSBpcyBwcm9jZXNzaW5nXG4gICAqL1xuICBhc3luYyBnZXRTbG90KGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFNsb3QnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KG51bWJlcigpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgc2xvdCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgY3VycmVudCBzbG90IGxlYWRlciBvZiB0aGUgY2x1c3RlclxuICAgKi9cbiAgYXN5bmMgZ2V0U2xvdExlYWRlcihjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW10sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRTbG90TGVhZGVyJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdChzdHJpbmcoKSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHNsb3QgbGVhZGVyJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGBsaW1pdGAgbnVtYmVyIG9mIHNsb3QgbGVhZGVycyBzdGFydGluZyBmcm9tIGBzdGFydFNsb3RgXG4gICAqXG4gICAqIEBwYXJhbSBzdGFydFNsb3QgZmV0Y2ggc2xvdCBsZWFkZXJzIHN0YXJ0aW5nIGZyb20gdGhpcyBzbG90XG4gICAqIEBwYXJhbSBsaW1pdCBudW1iZXIgb2Ygc2xvdCBsZWFkZXJzIHRvIHJldHVyblxuICAgKi9cbiAgYXN5bmMgZ2V0U2xvdExlYWRlcnMoc3RhcnRTbG90LCBsaW1pdCkge1xuICAgIGNvbnN0IGFyZ3MgPSBbc3RhcnRTbG90LCBsaW1pdF07XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0U2xvdExlYWRlcnMnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KGFycmF5KFB1YmxpY0tleUZyb21TdHJpbmcpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgc2xvdCBsZWFkZXJzJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBjdXJyZW50IHN0YXR1cyBvZiBhIHNpZ25hdHVyZVxuICAgKi9cbiAgYXN5bmMgZ2V0U2lnbmF0dXJlU3RhdHVzKHNpZ25hdHVyZSwgY29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29udGV4dCxcbiAgICAgIHZhbHVlOiB2YWx1ZXNcbiAgICB9ID0gYXdhaXQgdGhpcy5nZXRTaWduYXR1cmVTdGF0dXNlcyhbc2lnbmF0dXJlXSwgY29uZmlnKTtcbiAgICBhc3NlcnQodmFsdWVzLmxlbmd0aCA9PT0gMSk7XG4gICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRleHQsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGN1cnJlbnQgc3RhdHVzZXMgb2YgYSBiYXRjaCBvZiBzaWduYXR1cmVzXG4gICAqL1xuICBhc3luYyBnZXRTaWduYXR1cmVTdGF0dXNlcyhzaWduYXR1cmVzLCBjb25maWcpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBbc2lnbmF0dXJlc107XG4gICAgaWYgKGNvbmZpZykge1xuICAgICAgcGFyYW1zLnB1c2goY29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0U2lnbmF0dXJlU3RhdHVzZXMnLCBwYXJhbXMpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFNpZ25hdHVyZVN0YXR1c2VzUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBzaWduYXR1cmUgc3RhdHVzJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBjdXJyZW50IHRyYW5zYWN0aW9uIGNvdW50IG9mIHRoZSBjbHVzdGVyXG4gICAqL1xuICBhc3luYyBnZXRUcmFuc2FjdGlvbkNvdW50KGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFRyYW5zYWN0aW9uQ291bnQnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KG51bWJlcigpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgdHJhbnNhY3Rpb24gY291bnQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGN1cnJlbnQgdG90YWwgY3VycmVuY3kgc3VwcGx5IG9mIHRoZSBjbHVzdGVyIGluIGxhbXBvcnRzXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgUlBDIHYxLjIuOC4gUGxlYXNlIHVzZSB7QGxpbmsgZ2V0U3VwcGx5fSBpbnN0ZWFkLlxuICAgKi9cbiAgYXN5bmMgZ2V0VG90YWxTdXBwbHkoY29tbWl0bWVudCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuZ2V0U3VwcGx5KHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBleGNsdWRlTm9uQ2lyY3VsYXRpbmdBY2NvdW50c0xpc3Q6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0LnZhbHVlLnRvdGFsO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBjbHVzdGVyIEluZmxhdGlvbkdvdmVybm9yIHBhcmFtZXRlcnNcbiAgICovXG4gIGFzeW5jIGdldEluZmxhdGlvbkdvdmVybm9yKGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtdLCBjb21taXRtZW50KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRJbmZsYXRpb25Hb3Zlcm5vcicsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldEluZmxhdGlvbkdvdmVybm9yUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBpbmZsYXRpb24nKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGluZmxhdGlvbiByZXdhcmQgZm9yIGEgbGlzdCBvZiBhZGRyZXNzZXMgZm9yIGFuIGVwb2NoXG4gICAqL1xuICBhc3luYyBnZXRJbmZsYXRpb25SZXdhcmQoYWRkcmVzc2VzLCBlcG9jaCwgY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFthZGRyZXNzZXMubWFwKHB1YmtleSA9PiBwdWJrZXkudG9CYXNlNTgoKSldLCBjb21taXRtZW50LCB1bmRlZmluZWQgLyogZW5jb2RpbmcgKi8sIHtcbiAgICAgIC4uLmNvbmZpZyxcbiAgICAgIGVwb2NoOiBlcG9jaCAhPSBudWxsID8gZXBvY2ggOiBjb25maWc/LmVwb2NoXG4gICAgfSk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0SW5mbGF0aW9uUmV3YXJkJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0SW5mbGF0aW9uUmV3YXJkUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBpbmZsYXRpb24gcmV3YXJkJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBzcGVjaWZpYyBpbmZsYXRpb24gdmFsdWVzIGZvciB0aGUgY3VycmVudCBlcG9jaFxuICAgKi9cbiAgYXN5bmMgZ2V0SW5mbGF0aW9uUmF0ZSgpIHtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRJbmZsYXRpb25SYXRlJywgW10pO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldEluZmxhdGlvblJhdGVScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGluZmxhdGlvbiByYXRlJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBFcG9jaCBJbmZvIHBhcmFtZXRlcnNcbiAgICovXG4gIGFzeW5jIGdldEVwb2NoSW5mbyhjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW10sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRFcG9jaEluZm8nLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRFcG9jaEluZm9ScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGVwb2NoIGluZm8nKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIEVwb2NoIFNjaGVkdWxlIHBhcmFtZXRlcnNcbiAgICovXG4gIGFzeW5jIGdldEVwb2NoU2NoZWR1bGUoKSB7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0RXBvY2hTY2hlZHVsZScsIFtdKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRFcG9jaFNjaGVkdWxlUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBlcG9jaCBzY2hlZHVsZScpO1xuICAgIH1cbiAgICBjb25zdCBlcG9jaFNjaGVkdWxlID0gcmVzLnJlc3VsdDtcbiAgICByZXR1cm4gbmV3IEVwb2NoU2NoZWR1bGUoZXBvY2hTY2hlZHVsZS5zbG90c1BlckVwb2NoLCBlcG9jaFNjaGVkdWxlLmxlYWRlclNjaGVkdWxlU2xvdE9mZnNldCwgZXBvY2hTY2hlZHVsZS53YXJtdXAsIGVwb2NoU2NoZWR1bGUuZmlyc3ROb3JtYWxFcG9jaCwgZXBvY2hTY2hlZHVsZS5maXJzdE5vcm1hbFNsb3QpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBsZWFkZXIgc2NoZWR1bGUgZm9yIHRoZSBjdXJyZW50IGVwb2NoXG4gICAqIEByZXR1cm4ge1Byb21pc2U8UnBjUmVzcG9uc2VBbmRDb250ZXh0PExlYWRlclNjaGVkdWxlPj59XG4gICAqL1xuICBhc3luYyBnZXRMZWFkZXJTY2hlZHVsZSgpIHtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRMZWFkZXJTY2hlZHVsZScsIFtdKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRMZWFkZXJTY2hlZHVsZVJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgbGVhZGVyIHNjaGVkdWxlJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBtaW5pbXVtIGJhbGFuY2UgbmVlZGVkIHRvIGV4ZW1wdCBhbiBhY2NvdW50IG9mIGBkYXRhTGVuZ3RoYFxuICAgKiBzaXplIGZyb20gcmVudFxuICAgKi9cbiAgYXN5bmMgZ2V0TWluaW11bUJhbGFuY2VGb3JSZW50RXhlbXB0aW9uKGRhdGFMZW5ndGgsIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtkYXRhTGVuZ3RoXSwgY29tbWl0bWVudCk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0TWluaW11bUJhbGFuY2VGb3JSZW50RXhlbXB0aW9uJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0TWluaW11bUJhbGFuY2VGb3JSZW50RXhlbXB0aW9uUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIGNvbnNvbGUud2FybignVW5hYmxlIHRvIGZldGNoIG1pbmltdW0gYmFsYW5jZSBmb3IgcmVudCBleGVtcHRpb24nKTtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhIHJlY2VudCBibG9ja2hhc2ggZnJvbSB0aGUgY2x1c3RlciwgcmV0dXJuIHdpdGggY29udGV4dFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPFJwY1Jlc3BvbnNlQW5kQ29udGV4dDx7YmxvY2toYXNoOiBCbG9ja2hhc2gsIGZlZUNhbGN1bGF0b3I6IEZlZUNhbGN1bGF0b3J9Pj59XG4gICAqXG4gICAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgUlBDIHYxLjkuMC4gUGxlYXNlIHVzZSB7QGxpbmsgZ2V0TGF0ZXN0QmxvY2toYXNofSBpbnN0ZWFkLlxuICAgKi9cbiAgYXN5bmMgZ2V0UmVjZW50QmxvY2toYXNoQW5kQ29udGV4dChjb21taXRtZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgY29udGV4dCxcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIGJsb2NraGFzaFxuICAgICAgfVxuICAgIH0gPSBhd2FpdCB0aGlzLmdldExhdGVzdEJsb2NraGFzaEFuZENvbnRleHQoY29tbWl0bWVudCk7XG4gICAgY29uc3QgZmVlQ2FsY3VsYXRvciA9IHtcbiAgICAgIGdldCBsYW1wb3J0c1BlclNpZ25hdHVyZSgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgY2FwYWJpbGl0eSB0byBmZXRjaCBgbGFtcG9ydHNQZXJTaWduYXR1cmVgIHVzaW5nIHRoZSBgZ2V0UmVjZW50QmxvY2toYXNoYCBBUEkgaXMgJyArICdubyBsb25nZXIgb2ZmZXJlZCBieSB0aGUgbmV0d29yay4gVXNlIHRoZSBgZ2V0RmVlRm9yTWVzc2FnZWAgQVBJIHRvIG9idGFpbiB0aGUgZmVlICcgKyAnZm9yIGEgZ2l2ZW4gbWVzc2FnZS4nKTtcbiAgICAgIH0sXG4gICAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICBjb250ZXh0LFxuICAgICAgdmFsdWU6IHtcbiAgICAgICAgYmxvY2toYXNoLFxuICAgICAgICBmZWVDYWxjdWxhdG9yXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCByZWNlbnQgcGVyZm9ybWFuY2Ugc2FtcGxlc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5PFBlcmZTYW1wbGU+Pn1cbiAgICovXG4gIGFzeW5jIGdldFJlY2VudFBlcmZvcm1hbmNlU2FtcGxlcyhsaW1pdCkge1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFJlY2VudFBlcmZvcm1hbmNlU2FtcGxlcycsIGxpbWl0ID8gW2xpbWl0XSA6IFtdKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRSZWNlbnRQZXJmb3JtYW5jZVNhbXBsZXNScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHJlY2VudCBwZXJmb3JtYW5jZSBzYW1wbGVzJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBmZWUgY2FsY3VsYXRvciBmb3IgYSByZWNlbnQgYmxvY2toYXNoIGZyb20gdGhlIGNsdXN0ZXIsIHJldHVybiB3aXRoIGNvbnRleHRcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBSUEMgdjEuOS4wLiBQbGVhc2UgdXNlIHtAbGluayBnZXRGZWVGb3JNZXNzYWdlfSBpbnN0ZWFkLlxuICAgKi9cbiAgYXN5bmMgZ2V0RmVlQ2FsY3VsYXRvckZvckJsb2NraGFzaChibG9ja2hhc2gsIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtibG9ja2hhc2hdLCBjb21taXRtZW50KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRGZWVDYWxjdWxhdG9yRm9yQmxvY2toYXNoJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0RmVlQ2FsY3VsYXRvclJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgZmVlIGNhbGN1bGF0b3InKTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgY29udGV4dCxcbiAgICAgIHZhbHVlXG4gICAgfSA9IHJlcy5yZXN1bHQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRleHQsXG4gICAgICB2YWx1ZTogdmFsdWUgIT09IG51bGwgPyB2YWx1ZS5mZWVDYWxjdWxhdG9yIDogbnVsbFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGZlZSBmb3IgYSBtZXNzYWdlIGZyb20gdGhlIGNsdXN0ZXIsIHJldHVybiB3aXRoIGNvbnRleHRcbiAgICovXG4gIGFzeW5jIGdldEZlZUZvck1lc3NhZ2UobWVzc2FnZSwgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IHdpcmVNZXNzYWdlID0gdG9CdWZmZXIobWVzc2FnZS5zZXJpYWxpemUoKSkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3dpcmVNZXNzYWdlXSwgY29tbWl0bWVudCk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0RmVlRm9yTWVzc2FnZScsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KG51bGxhYmxlKG51bWJlcigpKSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGZlZSBmb3IgbWVzc2FnZScpO1xuICAgIH1cbiAgICBpZiAocmVzLnJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGJsb2NraGFzaCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhIGxpc3Qgb2YgcHJpb3JpdGl6YXRpb24gZmVlcyBmcm9tIHJlY2VudCBibG9ja3MuXG4gICAqL1xuICBhc3luYyBnZXRSZWNlbnRQcmlvcml0aXphdGlvbkZlZXMoY29uZmlnKSB7XG4gICAgY29uc3QgYWNjb3VudHMgPSBjb25maWc/LmxvY2tlZFdyaXRhYmxlQWNjb3VudHM/Lm1hcChrZXkgPT4ga2V5LnRvQmFzZTU4KCkpO1xuICAgIGNvbnN0IGFyZ3MgPSBhY2NvdW50cz8ubGVuZ3RoID8gW2FjY291bnRzXSA6IFtdO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFJlY2VudFByaW9yaXRpemF0aW9uRmVlcycsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFJlY2VudFByaW9yaXRpemF0aW9uRmVlc1JwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgcmVjZW50IHByaW9yaXRpemF0aW9uIGZlZXMnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoIGEgcmVjZW50IGJsb2NraGFzaCBmcm9tIHRoZSBjbHVzdGVyXG4gICAqIEByZXR1cm4ge1Byb21pc2U8e2Jsb2NraGFzaDogQmxvY2toYXNoLCBmZWVDYWxjdWxhdG9yOiBGZWVDYWxjdWxhdG9yfT59XG4gICAqXG4gICAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgUlBDIHYxLjguMC4gUGxlYXNlIHVzZSB7QGxpbmsgZ2V0TGF0ZXN0QmxvY2toYXNofSBpbnN0ZWFkLlxuICAgKi9cbiAgYXN5bmMgZ2V0UmVjZW50QmxvY2toYXNoKGNvbW1pdG1lbnQpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5nZXRSZWNlbnRCbG9ja2hhc2hBbmRDb250ZXh0KGNvbW1pdG1lbnQpO1xuICAgICAgcmV0dXJuIHJlcy52YWx1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZhaWxlZCB0byBnZXQgcmVjZW50IGJsb2NraGFzaDogJyArIGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgbGF0ZXN0IGJsb2NraGFzaCBmcm9tIHRoZSBjbHVzdGVyXG4gICAqIEByZXR1cm4ge1Byb21pc2U8QmxvY2toYXNoV2l0aEV4cGlyeUJsb2NrSGVpZ2h0Pn1cbiAgICovXG4gIGFzeW5jIGdldExhdGVzdEJsb2NraGFzaChjb21taXRtZW50T3JDb25maWcpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5nZXRMYXRlc3RCbG9ja2hhc2hBbmRDb250ZXh0KGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgICByZXR1cm4gcmVzLnZhbHVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZmFpbGVkIHRvIGdldCByZWNlbnQgYmxvY2toYXNoOiAnICsgZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBsYXRlc3QgYmxvY2toYXNoIGZyb20gdGhlIGNsdXN0ZXJcbiAgICogQHJldHVybiB7UHJvbWlzZTxCbG9ja2hhc2hXaXRoRXhwaXJ5QmxvY2tIZWlnaHQ+fVxuICAgKi9cbiAgYXN5bmMgZ2V0TGF0ZXN0QmxvY2toYXNoQW5kQ29udGV4dChjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW10sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRMYXRlc3RCbG9ja2hhc2gnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRMYXRlc3RCbG9ja2hhc2hScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGxhdGVzdCBibG9ja2hhc2gnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIGEgYmxvY2toYXNoIGlzIHN0aWxsIHZhbGlkIG9yIG5vdFxuICAgKi9cbiAgYXN5bmMgaXNCbG9ja2hhc2hWYWxpZChibG9ja2hhc2gsIHJhd0NvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKHJhd0NvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbYmxvY2toYXNoXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2lzQmxvY2toYXNoVmFsaWQnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBJc0Jsb2NraGFzaFZhbGlkUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGRldGVybWluZSBpZiB0aGUgYmxvY2toYXNoIGAnICsgYmxvY2toYXNoICsgJ2BpcyB2YWxpZCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgbm9kZSB2ZXJzaW9uXG4gICAqL1xuICBhc3luYyBnZXRWZXJzaW9uKCkge1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFZlcnNpb24nLCBbXSk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdChWZXJzaW9uUmVzdWx0KSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgdmVyc2lvbicpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgZ2VuZXNpcyBoYXNoXG4gICAqL1xuICBhc3luYyBnZXRHZW5lc2lzSGFzaCgpIHtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRHZW5lc2lzSGFzaCcsIFtdKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KHN0cmluZygpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgZ2VuZXNpcyBoYXNoJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGEgcHJvY2Vzc2VkIGJsb2NrIGZyb20gdGhlIGNsdXN0ZXIuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIEluc3RlYWQsIGNhbGwgYGdldEJsb2NrYCB1c2luZyBhIGBHZXRWZXJzaW9uZWRCbG9ja0NvbmZpZ2AgYnlcbiAgICogc2V0dGluZyB0aGUgYG1heFN1cHBvcnRlZFRyYW5zYWN0aW9uVmVyc2lvbmAgcHJvcGVydHkuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBJbnN0ZWFkLCBjYWxsIGBnZXRCbG9ja2AgdXNpbmcgYSBgR2V0VmVyc2lvbmVkQmxvY2tDb25maWdgIGJ5XG4gICAqIHNldHRpbmcgdGhlIGBtYXhTdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb25gIHByb3BlcnR5LlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBJbnN0ZWFkLCBjYWxsIGBnZXRCbG9ja2AgdXNpbmcgYSBgR2V0VmVyc2lvbmVkQmxvY2tDb25maWdgIGJ5XG4gICAqIHNldHRpbmcgdGhlIGBtYXhTdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb25gIHByb3BlcnR5LlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuXG4gIC8qKlxuICAgKiBGZXRjaCBhIHByb2Nlc3NlZCBibG9jayBmcm9tIHRoZSBjbHVzdGVyLlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG5cbiAgLyoqXG4gICAqIEZldGNoIGEgcHJvY2Vzc2VkIGJsb2NrIGZyb20gdGhlIGNsdXN0ZXIuXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG4gIGFzeW5jIGdldEJsb2NrKHNsb3QsIHJhd0NvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKHJhd0NvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoW3Nsb3RdLCBjb21taXRtZW50LCB1bmRlZmluZWQgLyogZW5jb2RpbmcgKi8sIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0QmxvY2snLCBhcmdzKTtcbiAgICB0cnkge1xuICAgICAgc3dpdGNoIChjb25maWc/LnRyYW5zYWN0aW9uRGV0YWlscykge1xuICAgICAgICBjYXNlICdhY2NvdW50cyc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0QWNjb3VudHNNb2RlQmxvY2tScGNSZXN1bHQpO1xuICAgICAgICAgICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICAgICAgICAgIHRocm93IHJlcy5lcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXMucmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnbm9uZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0Tm9uZU1vZGVCbG9ja1JwY1Jlc3VsdCk7XG4gICAgICAgICAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgICAgICAgICAgdGhyb3cgcmVzLmVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldEJsb2NrUnBjUmVzdWx0KTtcbiAgICAgICAgICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgICAgICAgICB0aHJvdyByZXMuZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIHJlc3VsdFxuICAgICAgICAgICAgfSA9IHJlcztcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgPyB7XG4gICAgICAgICAgICAgIC4uLnJlc3VsdCxcbiAgICAgICAgICAgICAgdHJhbnNhY3Rpb25zOiByZXN1bHQudHJhbnNhY3Rpb25zLm1hcCgoe1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgICAgIG1ldGEsXG4gICAgICAgICAgICAgICAgdmVyc2lvblxuICAgICAgICAgICAgICB9KSA9PiAoe1xuICAgICAgICAgICAgICAgIG1ldGEsXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IHtcbiAgICAgICAgICAgICAgICAgIC4uLnRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogdmVyc2lvbmVkTWVzc2FnZUZyb21SZXNwb25zZSh2ZXJzaW9uLCB0cmFuc2FjdGlvbi5tZXNzYWdlKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdmVyc2lvblxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIH0gOiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKGUsICdmYWlsZWQgdG8gZ2V0IGNvbmZpcm1lZCBibG9jaycpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBwYXJzZWQgdHJhbnNhY3Rpb24gZGV0YWlscyBmb3IgYSBjb25maXJtZWQgb3IgZmluYWxpemVkIGJsb2NrXG4gICAqL1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuICBhc3luYyBnZXRQYXJzZWRCbG9jayhzbG90LCByYXdDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhyYXdDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFtzbG90XSwgY29tbWl0bWVudCwgJ2pzb25QYXJzZWQnLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEJsb2NrJywgYXJncyk7XG4gICAgdHJ5IHtcbiAgICAgIHN3aXRjaCAoY29uZmlnPy50cmFuc2FjdGlvbkRldGFpbHMpIHtcbiAgICAgICAgY2FzZSAnYWNjb3VudHMnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFBhcnNlZEFjY291bnRzTW9kZUJsb2NrUnBjUmVzdWx0KTtcbiAgICAgICAgICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgICAgICAgICB0aHJvdyByZXMuZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ25vbmUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFBhcnNlZE5vbmVNb2RlQmxvY2tScGNSZXN1bHQpO1xuICAgICAgICAgICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICAgICAgICAgIHRocm93IHJlcy5lcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXMucmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRQYXJzZWRCbG9ja1JwY1Jlc3VsdCk7XG4gICAgICAgICAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgICAgICAgICAgdGhyb3cgcmVzLmVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IoZSwgJ2ZhaWxlZCB0byBnZXQgYmxvY2snKTtcbiAgICB9XG4gIH1cbiAgLypcbiAgICogUmV0dXJucyByZWNlbnQgYmxvY2sgcHJvZHVjdGlvbiBpbmZvcm1hdGlvbiBmcm9tIHRoZSBjdXJyZW50IG9yIHByZXZpb3VzIGVwb2NoXG4gICAqL1xuICBhc3luYyBnZXRCbG9ja1Byb2R1Y3Rpb24oY29uZmlnT3JDb21taXRtZW50KSB7XG4gICAgbGV0IGV4dHJhO1xuICAgIGxldCBjb21taXRtZW50O1xuICAgIGlmICh0eXBlb2YgY29uZmlnT3JDb21taXRtZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgY29tbWl0bWVudCA9IGNvbmZpZ09yQ29tbWl0bWVudDtcbiAgICB9IGVsc2UgaWYgKGNvbmZpZ09yQ29tbWl0bWVudCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjb21taXRtZW50OiBjLFxuICAgICAgICAuLi5yZXN0XG4gICAgICB9ID0gY29uZmlnT3JDb21taXRtZW50O1xuICAgICAgY29tbWl0bWVudCA9IGM7XG4gICAgICBleHRyYSA9IHJlc3Q7XG4gICAgfVxuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW10sIGNvbW1pdG1lbnQsICdiYXNlNjQnLCBleHRyYSk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0QmxvY2tQcm9kdWN0aW9uJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgQmxvY2tQcm9kdWN0aW9uUmVzcG9uc2VTdHJ1Y3QpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGJsb2NrIHByb2R1Y3Rpb24gaW5mb3JtYXRpb24nKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYSBjb25maXJtZWQgb3IgZmluYWxpemVkIHRyYW5zYWN0aW9uIGZyb20gdGhlIGNsdXN0ZXIuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIEluc3RlYWQsIGNhbGwgYGdldFRyYW5zYWN0aW9uYCB1c2luZyBhXG4gICAqIGBHZXRWZXJzaW9uZWRUcmFuc2FjdGlvbkNvbmZpZ2AgYnkgc2V0dGluZyB0aGVcbiAgICogYG1heFN1cHBvcnRlZFRyYW5zYWN0aW9uVmVyc2lvbmAgcHJvcGVydHkuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBGZXRjaCBhIGNvbmZpcm1lZCBvciBmaW5hbGl6ZWQgdHJhbnNhY3Rpb24gZnJvbSB0aGUgY2x1c3Rlci5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcblxuICAvKipcbiAgICogRmV0Y2ggYSBjb25maXJtZWQgb3IgZmluYWxpemVkIHRyYW5zYWN0aW9uIGZyb20gdGhlIGNsdXN0ZXIuXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG4gIGFzeW5jIGdldFRyYW5zYWN0aW9uKHNpZ25hdHVyZSwgcmF3Q29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcocmF3Q29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChbc2lnbmF0dXJlXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFRyYW5zYWN0aW9uJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0VHJhbnNhY3Rpb25ScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHRyYW5zYWN0aW9uJyk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHJlcy5yZXN1bHQ7XG4gICAgaWYgKCFyZXN1bHQpIHJldHVybiByZXN1bHQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnJlc3VsdCxcbiAgICAgIHRyYW5zYWN0aW9uOiB7XG4gICAgICAgIC4uLnJlc3VsdC50cmFuc2FjdGlvbixcbiAgICAgICAgbWVzc2FnZTogdmVyc2lvbmVkTWVzc2FnZUZyb21SZXNwb25zZShyZXN1bHQudmVyc2lvbiwgcmVzdWx0LnRyYW5zYWN0aW9uLm1lc3NhZ2UpXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBwYXJzZWQgdHJhbnNhY3Rpb24gZGV0YWlscyBmb3IgYSBjb25maXJtZWQgb3IgZmluYWxpemVkIHRyYW5zYWN0aW9uXG4gICAqL1xuICBhc3luYyBnZXRQYXJzZWRUcmFuc2FjdGlvbihzaWduYXR1cmUsIGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoW3NpZ25hdHVyZV0sIGNvbW1pdG1lbnQsICdqc29uUGFyc2VkJywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRUcmFuc2FjdGlvbicsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFBhcnNlZFRyYW5zYWN0aW9uUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCB0cmFuc2FjdGlvbicpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBwYXJzZWQgdHJhbnNhY3Rpb24gZGV0YWlscyBmb3IgYSBiYXRjaCBvZiBjb25maXJtZWQgdHJhbnNhY3Rpb25zXG4gICAqL1xuICBhc3luYyBnZXRQYXJzZWRUcmFuc2FjdGlvbnMoc2lnbmF0dXJlcywgY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBiYXRjaCA9IHNpZ25hdHVyZXMubWFwKHNpZ25hdHVyZSA9PiB7XG4gICAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChbc2lnbmF0dXJlXSwgY29tbWl0bWVudCwgJ2pzb25QYXJzZWQnLCBjb25maWcpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWV0aG9kTmFtZTogJ2dldFRyYW5zYWN0aW9uJyxcbiAgICAgICAgYXJnc1xuICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNCYXRjaFJlcXVlc3QoYmF0Y2gpO1xuICAgIGNvbnN0IHJlcyA9IHVuc2FmZVJlcy5tYXAodW5zYWZlUmVzID0+IHtcbiAgICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFBhcnNlZFRyYW5zYWN0aW9uUnBjUmVzdWx0KTtcbiAgICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgdHJhbnNhY3Rpb25zJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRyYW5zYWN0aW9uIGRldGFpbHMgZm9yIGEgYmF0Y2ggb2YgY29uZmlybWVkIHRyYW5zYWN0aW9ucy5cbiAgICogU2ltaWxhciB0byB7QGxpbmsgZ2V0UGFyc2VkVHJhbnNhY3Rpb25zfSBidXQgcmV0dXJucyBhIHtAbGluayBUcmFuc2FjdGlvblJlc3BvbnNlfS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgSW5zdGVhZCwgY2FsbCBgZ2V0VHJhbnNhY3Rpb25zYCB1c2luZyBhXG4gICAqIGBHZXRWZXJzaW9uZWRUcmFuc2FjdGlvbkNvbmZpZ2AgYnkgc2V0dGluZyB0aGVcbiAgICogYG1heFN1cHBvcnRlZFRyYW5zYWN0aW9uVmVyc2lvbmAgcHJvcGVydHkuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBGZXRjaCB0cmFuc2FjdGlvbiBkZXRhaWxzIGZvciBhIGJhdGNoIG9mIGNvbmZpcm1lZCB0cmFuc2FjdGlvbnMuXG4gICAqIFNpbWlsYXIgdG8ge0BsaW5rIGdldFBhcnNlZFRyYW5zYWN0aW9uc30gYnV0IHJldHVybnMgYSB7QGxpbmtcbiAgICogVmVyc2lvbmVkVHJhbnNhY3Rpb25SZXNwb25zZX0uXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG5cbiAgLyoqXG4gICAqIEZldGNoIHRyYW5zYWN0aW9uIGRldGFpbHMgZm9yIGEgYmF0Y2ggb2YgY29uZmlybWVkIHRyYW5zYWN0aW9ucy5cbiAgICogU2ltaWxhciB0byB7QGxpbmsgZ2V0UGFyc2VkVHJhbnNhY3Rpb25zfSBidXQgcmV0dXJucyBhIHtAbGlua1xuICAgKiBWZXJzaW9uZWRUcmFuc2FjdGlvblJlc3BvbnNlfS5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcbiAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25zKHNpZ25hdHVyZXMsIGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgY29uc3QgYmF0Y2ggPSBzaWduYXR1cmVzLm1hcChzaWduYXR1cmUgPT4ge1xuICAgICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoW3NpZ25hdHVyZV0sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLywgY29uZmlnKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1ldGhvZE5hbWU6ICdnZXRUcmFuc2FjdGlvbicsXG4gICAgICAgIGFyZ3NcbiAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjQmF0Y2hSZXF1ZXN0KGJhdGNoKTtcbiAgICBjb25zdCByZXMgPSB1bnNhZmVSZXMubWFwKHVuc2FmZVJlcyA9PiB7XG4gICAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRUcmFuc2FjdGlvblJwY1Jlc3VsdCk7XG4gICAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHRyYW5zYWN0aW9ucycpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gcmVzLnJlc3VsdDtcbiAgICAgIGlmICghcmVzdWx0KSByZXR1cm4gcmVzdWx0O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucmVzdWx0LFxuICAgICAgICB0cmFuc2FjdGlvbjoge1xuICAgICAgICAgIC4uLnJlc3VsdC50cmFuc2FjdGlvbixcbiAgICAgICAgICBtZXNzYWdlOiB2ZXJzaW9uZWRNZXNzYWdlRnJvbVJlc3BvbnNlKHJlc3VsdC52ZXJzaW9uLCByZXN1bHQudHJhbnNhY3Rpb24ubWVzc2FnZSlcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGEgbGlzdCBvZiBUcmFuc2FjdGlvbnMgYW5kIHRyYW5zYWN0aW9uIHN0YXR1c2VzIGZyb20gdGhlIGNsdXN0ZXJcbiAgICogZm9yIGEgY29uZmlybWVkIGJsb2NrLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFJQQyB2MS43LjAuIFBsZWFzZSB1c2Uge0BsaW5rIGdldEJsb2NrfSBpbnN0ZWFkLlxuICAgKi9cbiAgYXN5bmMgZ2V0Q29uZmlybWVkQmxvY2soc2xvdCwgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFtzbG90XSwgY29tbWl0bWVudCk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0QmxvY2snLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRDb25maXJtZWRCbG9ja1JwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgY29uZmlybWVkIGJsb2NrJyk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHJlcy5yZXN1bHQ7XG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ29uZmlybWVkIGJsb2NrICcgKyBzbG90ICsgJyBub3QgZm91bmQnKTtcbiAgICB9XG4gICAgY29uc3QgYmxvY2sgPSB7XG4gICAgICAuLi5yZXN1bHQsXG4gICAgICB0cmFuc2FjdGlvbnM6IHJlc3VsdC50cmFuc2FjdGlvbnMubWFwKCh7XG4gICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgICBtZXRhXG4gICAgICB9KSA9PiB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBuZXcgTWVzc2FnZSh0cmFuc2FjdGlvbi5tZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtZXRhLFxuICAgICAgICAgIHRyYW5zYWN0aW9uOiB7XG4gICAgICAgICAgICAuLi50cmFuc2FjdGlvbixcbiAgICAgICAgICAgIG1lc3NhZ2VcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KVxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmJsb2NrLFxuICAgICAgdHJhbnNhY3Rpb25zOiBibG9jay50cmFuc2FjdGlvbnMubWFwKCh7XG4gICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgICBtZXRhXG4gICAgICB9KSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbWV0YSxcbiAgICAgICAgICB0cmFuc2FjdGlvbjogVHJhbnNhY3Rpb24ucG9wdWxhdGUodHJhbnNhY3Rpb24ubWVzc2FnZSwgdHJhbnNhY3Rpb24uc2lnbmF0dXJlcylcbiAgICAgICAgfTtcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBjb25maXJtZWQgYmxvY2tzIGJldHdlZW4gdHdvIHNsb3RzXG4gICAqL1xuICBhc3luYyBnZXRCbG9ja3Moc3RhcnRTbG90LCBlbmRTbG90LCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoZW5kU2xvdCAhPT0gdW5kZWZpbmVkID8gW3N0YXJ0U2xvdCwgZW5kU2xvdF0gOiBbc3RhcnRTbG90XSwgY29tbWl0bWVudCk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0QmxvY2tzJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdChhcnJheShudW1iZXIoKSkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBibG9ja3MnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYSBsaXN0IG9mIFNpZ25hdHVyZXMgZnJvbSB0aGUgY2x1c3RlciBmb3IgYSBibG9jaywgZXhjbHVkaW5nIHJld2FyZHNcbiAgICovXG4gIGFzeW5jIGdldEJsb2NrU2lnbmF0dXJlcyhzbG90LCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoW3Nsb3RdLCBjb21taXRtZW50LCB1bmRlZmluZWQsIHtcbiAgICAgIHRyYW5zYWN0aW9uRGV0YWlsczogJ3NpZ25hdHVyZXMnLFxuICAgICAgcmV3YXJkczogZmFsc2VcbiAgICB9KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRCbG9jaycsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldEJsb2NrU2lnbmF0dXJlc1JwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgYmxvY2snKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gcmVzLnJlc3VsdDtcbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdCbG9jayAnICsgc2xvdCArICcgbm90IGZvdW5kJyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYSBsaXN0IG9mIFNpZ25hdHVyZXMgZnJvbSB0aGUgY2x1c3RlciBmb3IgYSBjb25maXJtZWQgYmxvY2ssIGV4Y2x1ZGluZyByZXdhcmRzXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgUlBDIHYxLjcuMC4gUGxlYXNlIHVzZSB7QGxpbmsgZ2V0QmxvY2tTaWduYXR1cmVzfSBpbnN0ZWFkLlxuICAgKi9cbiAgYXN5bmMgZ2V0Q29uZmlybWVkQmxvY2tTaWduYXR1cmVzKHNsb3QsIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChbc2xvdF0sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCwge1xuICAgICAgdHJhbnNhY3Rpb25EZXRhaWxzOiAnc2lnbmF0dXJlcycsXG4gICAgICByZXdhcmRzOiBmYWxzZVxuICAgIH0pO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEJsb2NrJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0QmxvY2tTaWduYXR1cmVzUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBjb25maXJtZWQgYmxvY2snKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gcmVzLnJlc3VsdDtcbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb25maXJtZWQgYmxvY2sgJyArIHNsb3QgKyAnIG5vdCBmb3VuZCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGEgdHJhbnNhY3Rpb24gZGV0YWlscyBmb3IgYSBjb25maXJtZWQgdHJhbnNhY3Rpb25cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBSUEMgdjEuNy4wLiBQbGVhc2UgdXNlIHtAbGluayBnZXRUcmFuc2FjdGlvbn0gaW5zdGVhZC5cbiAgICovXG4gIGFzeW5jIGdldENvbmZpcm1lZFRyYW5zYWN0aW9uKHNpZ25hdHVyZSwgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFtzaWduYXR1cmVdLCBjb21taXRtZW50KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRUcmFuc2FjdGlvbicsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFRyYW5zYWN0aW9uUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCB0cmFuc2FjdGlvbicpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSByZXMucmVzdWx0O1xuICAgIGlmICghcmVzdWx0KSByZXR1cm4gcmVzdWx0O1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBuZXcgTWVzc2FnZShyZXN1bHQudHJhbnNhY3Rpb24ubWVzc2FnZSk7XG4gICAgY29uc3Qgc2lnbmF0dXJlcyA9IHJlc3VsdC50cmFuc2FjdGlvbi5zaWduYXR1cmVzO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5yZXN1bHQsXG4gICAgICB0cmFuc2FjdGlvbjogVHJhbnNhY3Rpb24ucG9wdWxhdGUobWVzc2FnZSwgc2lnbmF0dXJlcylcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHBhcnNlZCB0cmFuc2FjdGlvbiBkZXRhaWxzIGZvciBhIGNvbmZpcm1lZCB0cmFuc2FjdGlvblxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFJQQyB2MS43LjAuIFBsZWFzZSB1c2Uge0BsaW5rIGdldFBhcnNlZFRyYW5zYWN0aW9ufSBpbnN0ZWFkLlxuICAgKi9cbiAgYXN5bmMgZ2V0UGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb24oc2lnbmF0dXJlLCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoW3NpZ25hdHVyZV0sIGNvbW1pdG1lbnQsICdqc29uUGFyc2VkJyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0VHJhbnNhY3Rpb24nLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRQYXJzZWRUcmFuc2FjdGlvblJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgY29uZmlybWVkIHRyYW5zYWN0aW9uJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHBhcnNlZCB0cmFuc2FjdGlvbiBkZXRhaWxzIGZvciBhIGJhdGNoIG9mIGNvbmZpcm1lZCB0cmFuc2FjdGlvbnNcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBSUEMgdjEuNy4wLiBQbGVhc2UgdXNlIHtAbGluayBnZXRQYXJzZWRUcmFuc2FjdGlvbnN9IGluc3RlYWQuXG4gICAqL1xuICBhc3luYyBnZXRQYXJzZWRDb25maXJtZWRUcmFuc2FjdGlvbnMoc2lnbmF0dXJlcywgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGJhdGNoID0gc2lnbmF0dXJlcy5tYXAoc2lnbmF0dXJlID0+IHtcbiAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFtzaWduYXR1cmVdLCBjb21taXRtZW50LCAnanNvblBhcnNlZCcpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWV0aG9kTmFtZTogJ2dldFRyYW5zYWN0aW9uJyxcbiAgICAgICAgYXJnc1xuICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNCYXRjaFJlcXVlc3QoYmF0Y2gpO1xuICAgIGNvbnN0IHJlcyA9IHVuc2FmZVJlcy5tYXAodW5zYWZlUmVzID0+IHtcbiAgICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFBhcnNlZFRyYW5zYWN0aW9uUnBjUmVzdWx0KTtcbiAgICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgY29uZmlybWVkIHRyYW5zYWN0aW9ucycpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhIGxpc3Qgb2YgYWxsIHRoZSBjb25maXJtZWQgc2lnbmF0dXJlcyBmb3IgdHJhbnNhY3Rpb25zIGludm9sdmluZyBhbiBhZGRyZXNzXG4gICAqIHdpdGhpbiBhIHNwZWNpZmllZCBzbG90IHJhbmdlLiBNYXggcmFuZ2UgYWxsb3dlZCBpcyAxMCwwMDAgc2xvdHMuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgUlBDIHYxLjMuIFBsZWFzZSB1c2Uge0BsaW5rIGdldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzMn0gaW5zdGVhZC5cbiAgICpcbiAgICogQHBhcmFtIGFkZHJlc3MgcXVlcmllZCBhZGRyZXNzXG4gICAqIEBwYXJhbSBzdGFydFNsb3Qgc3RhcnQgc2xvdCwgaW5jbHVzaXZlXG4gICAqIEBwYXJhbSBlbmRTbG90IGVuZCBzbG90LCBpbmNsdXNpdmVcbiAgICovXG4gIGFzeW5jIGdldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzKGFkZHJlc3MsIHN0YXJ0U2xvdCwgZW5kU2xvdCkge1xuICAgIGxldCBvcHRpb25zID0ge307XG4gICAgbGV0IGZpcnN0QXZhaWxhYmxlQmxvY2sgPSBhd2FpdCB0aGlzLmdldEZpcnN0QXZhaWxhYmxlQmxvY2soKTtcbiAgICB3aGlsZSAoISgndW50aWwnIGluIG9wdGlvbnMpKSB7XG4gICAgICBzdGFydFNsb3QtLTtcbiAgICAgIGlmIChzdGFydFNsb3QgPD0gMCB8fCBzdGFydFNsb3QgPCBmaXJzdEF2YWlsYWJsZUJsb2NrKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYmxvY2sgPSBhd2FpdCB0aGlzLmdldENvbmZpcm1lZEJsb2NrU2lnbmF0dXJlcyhzdGFydFNsb3QsICdmaW5hbGl6ZWQnKTtcbiAgICAgICAgaWYgKGJsb2NrLnNpZ25hdHVyZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIG9wdGlvbnMudW50aWwgPSBibG9jay5zaWduYXR1cmVzW2Jsb2NrLnNpZ25hdHVyZXMubGVuZ3RoIC0gMV0udG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnIubWVzc2FnZS5pbmNsdWRlcygnc2tpcHBlZCcpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBoaWdoZXN0Q29uZmlybWVkUm9vdCA9IGF3YWl0IHRoaXMuZ2V0U2xvdCgnZmluYWxpemVkJyk7XG4gICAgd2hpbGUgKCEoJ2JlZm9yZScgaW4gb3B0aW9ucykpIHtcbiAgICAgIGVuZFNsb3QrKztcbiAgICAgIGlmIChlbmRTbG90ID4gaGlnaGVzdENvbmZpcm1lZFJvb3QpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBibG9jayA9IGF3YWl0IHRoaXMuZ2V0Q29uZmlybWVkQmxvY2tTaWduYXR1cmVzKGVuZFNsb3QpO1xuICAgICAgICBpZiAoYmxvY2suc2lnbmF0dXJlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgb3B0aW9ucy5iZWZvcmUgPSBibG9jay5zaWduYXR1cmVzW2Jsb2NrLnNpZ25hdHVyZXMubGVuZ3RoIC0gMV0udG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnIubWVzc2FnZS5pbmNsdWRlcygnc2tpcHBlZCcpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNvbmZpcm1lZFNpZ25hdHVyZUluZm8gPSBhd2FpdCB0aGlzLmdldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzMihhZGRyZXNzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gY29uZmlybWVkU2lnbmF0dXJlSW5mby5tYXAoaW5mbyA9PiBpbmZvLnNpZ25hdHVyZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBjb25maXJtZWQgc2lnbmF0dXJlcyBmb3IgdHJhbnNhY3Rpb25zIGludm9sdmluZyBhblxuICAgKiBhZGRyZXNzIGJhY2t3YXJkcyBpbiB0aW1lIGZyb20gdGhlIHByb3ZpZGVkIHNpZ25hdHVyZSBvciBtb3N0IHJlY2VudCBjb25maXJtZWQgYmxvY2tcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBSUEMgdjEuNy4wLiBQbGVhc2UgdXNlIHtAbGluayBnZXRTaWduYXR1cmVzRm9yQWRkcmVzc30gaW5zdGVhZC5cbiAgICovXG4gIGFzeW5jIGdldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzMihhZGRyZXNzLCBvcHRpb25zLCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoW2FkZHJlc3MudG9CYXNlNTgoKV0sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCwgb3B0aW9ucyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0Q29uZmlybWVkU2lnbmF0dXJlc0ZvckFkZHJlc3MyJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0Q29uZmlybWVkU2lnbmF0dXJlc0ZvckFkZHJlc3MyUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBjb25maXJtZWQgc2lnbmF0dXJlcyBmb3IgYWRkcmVzcycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGNvbmZpcm1lZCBzaWduYXR1cmVzIGZvciB0cmFuc2FjdGlvbnMgaW52b2x2aW5nIGFuXG4gICAqIGFkZHJlc3MgYmFja3dhcmRzIGluIHRpbWUgZnJvbSB0aGUgcHJvdmlkZWQgc2lnbmF0dXJlIG9yIG1vc3QgcmVjZW50IGNvbmZpcm1lZCBibG9ja1xuICAgKlxuICAgKlxuICAgKiBAcGFyYW0gYWRkcmVzcyBxdWVyaWVkIGFkZHJlc3NcbiAgICogQHBhcmFtIG9wdGlvbnNcbiAgICovXG4gIGFzeW5jIGdldFNpZ25hdHVyZXNGb3JBZGRyZXNzKGFkZHJlc3MsIG9wdGlvbnMsIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChbYWRkcmVzcy50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkLCBvcHRpb25zKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRTaWduYXR1cmVzRm9yQWRkcmVzcycsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFNpZ25hdHVyZXNGb3JBZGRyZXNzUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBzaWduYXR1cmVzIGZvciBhZGRyZXNzJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG4gIGFzeW5jIGdldEFkZHJlc3NMb29rdXBUYWJsZShhY2NvdW50S2V5LCBjb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb250ZXh0LFxuICAgICAgdmFsdWU6IGFjY291bnRJbmZvXG4gICAgfSA9IGF3YWl0IHRoaXMuZ2V0QWNjb3VudEluZm9BbmRDb250ZXh0KGFjY291bnRLZXksIGNvbmZpZyk7XG4gICAgbGV0IHZhbHVlID0gbnVsbDtcbiAgICBpZiAoYWNjb3VudEluZm8gIT09IG51bGwpIHtcbiAgICAgIHZhbHVlID0gbmV3IEFkZHJlc3NMb29rdXBUYWJsZUFjY291bnQoe1xuICAgICAgICBrZXk6IGFjY291bnRLZXksXG4gICAgICAgIHN0YXRlOiBBZGRyZXNzTG9va3VwVGFibGVBY2NvdW50LmRlc2VyaWFsaXplKGFjY291bnRJbmZvLmRhdGEpXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRleHQsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGNvbnRlbnRzIG9mIGEgTm9uY2UgYWNjb3VudCBmcm9tIHRoZSBjbHVzdGVyLCByZXR1cm4gd2l0aCBjb250ZXh0XG4gICAqL1xuICBhc3luYyBnZXROb25jZUFuZENvbnRleHQobm9uY2VBY2NvdW50LCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb250ZXh0LFxuICAgICAgdmFsdWU6IGFjY291bnRJbmZvXG4gICAgfSA9IGF3YWl0IHRoaXMuZ2V0QWNjb3VudEluZm9BbmRDb250ZXh0KG5vbmNlQWNjb3VudCwgY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBsZXQgdmFsdWUgPSBudWxsO1xuICAgIGlmIChhY2NvdW50SW5mbyAhPT0gbnVsbCkge1xuICAgICAgdmFsdWUgPSBOb25jZUFjY291bnQuZnJvbUFjY291bnREYXRhKGFjY291bnRJbmZvLmRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgY29udGV4dCxcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgY29udGVudHMgb2YgYSBOb25jZSBhY2NvdW50IGZyb20gdGhlIGNsdXN0ZXJcbiAgICovXG4gIGFzeW5jIGdldE5vbmNlKG5vbmNlQWNjb3VudCwgY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0Tm9uY2VBbmRDb250ZXh0KG5vbmNlQWNjb3VudCwgY29tbWl0bWVudE9yQ29uZmlnKS50aGVuKHggPT4geC52YWx1ZSkuY2F0Y2goZSA9PiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZhaWxlZCB0byBnZXQgbm9uY2UgZm9yIGFjY291bnQgJyArIG5vbmNlQWNjb3VudC50b0Jhc2U1OCgpICsgJzogJyArIGUpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgYW4gYWxsb2NhdGlvbiBvZiBsYW1wb3J0cyB0byB0aGUgc3BlY2lmaWVkIGFkZHJlc3NcbiAgICpcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBpbXBvcnQgeyBDb25uZWN0aW9uLCBQdWJsaWNLZXksIExBTVBPUlRTX1BFUl9TT0wgfSBmcm9tIFwiQHNvbGFuYS93ZWIzLmpzXCI7XG4gICAqXG4gICAqIChhc3luYyAoKSA9PiB7XG4gICAqICAgY29uc3QgY29ubmVjdGlvbiA9IG5ldyBDb25uZWN0aW9uKFwiaHR0cHM6Ly9hcGkudGVzdG5ldC5zb2xhbmEuY29tXCIsIFwiY29uZmlybWVkXCIpO1xuICAgKiAgIGNvbnN0IG15QWRkcmVzcyA9IG5ldyBQdWJsaWNLZXkoXCIybnIxYkhGVDg2Vzl0R255dm1ZVzR2Y0hLc1FCM3NWUWZuZGRhc3o0a0V4TVwiKTtcbiAgICogICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBjb25uZWN0aW9uLnJlcXVlc3RBaXJkcm9wKG15QWRkcmVzcywgTEFNUE9SVFNfUEVSX1NPTCk7XG4gICAqICAgYXdhaXQgY29ubmVjdGlvbi5jb25maXJtVHJhbnNhY3Rpb24oc2lnbmF0dXJlKTtcbiAgICogfSkoKTtcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyByZXF1ZXN0QWlyZHJvcCh0bywgbGFtcG9ydHMpIHtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdyZXF1ZXN0QWlyZHJvcCcsIFt0by50b0Jhc2U1OCgpLCBsYW1wb3J0c10pO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIFJlcXVlc3RBaXJkcm9wUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCBgYWlyZHJvcCB0byAke3RvLnRvQmFzZTU4KCl9IGZhaWxlZGApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGFzeW5jIF9ibG9ja2hhc2hXaXRoRXhwaXJ5QmxvY2tIZWlnaHQoZGlzYWJsZUNhY2hlKSB7XG4gICAgaWYgKCFkaXNhYmxlQ2FjaGUpIHtcbiAgICAgIC8vIFdhaXQgZm9yIHBvbGxpbmcgdG8gZmluaXNoXG4gICAgICB3aGlsZSAodGhpcy5fcG9sbGluZ0Jsb2NraGFzaCkge1xuICAgICAgICBhd2FpdCBzbGVlcCgxMDApO1xuICAgICAgfVxuICAgICAgY29uc3QgdGltZVNpbmNlRmV0Y2ggPSBEYXRlLm5vdygpIC0gdGhpcy5fYmxvY2toYXNoSW5mby5sYXN0RmV0Y2g7XG4gICAgICBjb25zdCBleHBpcmVkID0gdGltZVNpbmNlRmV0Y2ggPj0gQkxPQ0tIQVNIX0NBQ0hFX1RJTUVPVVRfTVM7XG4gICAgICBpZiAodGhpcy5fYmxvY2toYXNoSW5mby5sYXRlc3RCbG9ja2hhc2ggIT09IG51bGwgJiYgIWV4cGlyZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Jsb2NraGFzaEluZm8ubGF0ZXN0QmxvY2toYXNoO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5fcG9sbE5ld0Jsb2NraGFzaCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgYXN5bmMgX3BvbGxOZXdCbG9ja2hhc2goKSB7XG4gICAgdGhpcy5fcG9sbGluZ0Jsb2NraGFzaCA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICBjb25zdCBjYWNoZWRMYXRlc3RCbG9ja2hhc2ggPSB0aGlzLl9ibG9ja2hhc2hJbmZvLmxhdGVzdEJsb2NraGFzaDtcbiAgICAgIGNvbnN0IGNhY2hlZEJsb2NraGFzaCA9IGNhY2hlZExhdGVzdEJsb2NraGFzaCA/IGNhY2hlZExhdGVzdEJsb2NraGFzaC5ibG9ja2hhc2ggOiBudWxsO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1MDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGxhdGVzdEJsb2NraGFzaCA9IGF3YWl0IHRoaXMuZ2V0TGF0ZXN0QmxvY2toYXNoKCdmaW5hbGl6ZWQnKTtcbiAgICAgICAgaWYgKGNhY2hlZEJsb2NraGFzaCAhPT0gbGF0ZXN0QmxvY2toYXNoLmJsb2NraGFzaCkge1xuICAgICAgICAgIHRoaXMuX2Jsb2NraGFzaEluZm8gPSB7XG4gICAgICAgICAgICBsYXRlc3RCbG9ja2hhc2gsXG4gICAgICAgICAgICBsYXN0RmV0Y2g6IERhdGUubm93KCksXG4gICAgICAgICAgICB0cmFuc2FjdGlvblNpZ25hdHVyZXM6IFtdLFxuICAgICAgICAgICAgc2ltdWxhdGVkU2lnbmF0dXJlczogW11cbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiBsYXRlc3RCbG9ja2hhc2g7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTbGVlcCBmb3IgYXBwcm94aW1hdGVseSBoYWxmIGEgc2xvdFxuICAgICAgICBhd2FpdCBzbGVlcChNU19QRVJfU0xPVCAvIDIpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gb2J0YWluIGEgbmV3IGJsb2NraGFzaCBhZnRlciAke0RhdGUubm93KCkgLSBzdGFydFRpbWV9bXNgKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5fcG9sbGluZ0Jsb2NraGFzaCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgdGhlIHN0YWtlIG1pbmltdW0gZGVsZWdhdGlvblxuICAgKi9cbiAgYXN5bmMgZ2V0U3Rha2VNaW5pbXVtRGVsZWdhdGlvbihjb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnOiBjb25maWdBcmdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbXSwgY29tbWl0bWVudCwgJ2Jhc2U2NCcsIGNvbmZpZ0FyZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0U3Rha2VNaW5pbXVtRGVsZWdhdGlvbicsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KG51bWJlcigpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgYGZhaWxlZCB0byBnZXQgc3Rha2UgbWluaW11bSBkZWxlZ2F0aW9uYCk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFNpbXVsYXRlIGEgdHJhbnNhY3Rpb25cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgSW5zdGVhZCwgY2FsbCB7QGxpbmsgc2ltdWxhdGVUcmFuc2FjdGlvbn0gd2l0aCB7QGxpbmtcbiAgICogVmVyc2lvbmVkVHJhbnNhY3Rpb259IGFuZCB7QGxpbmsgU2ltdWxhdGVUcmFuc2FjdGlvbkNvbmZpZ30gcGFyYW1ldGVyc1xuICAgKi9cblxuICAvKipcbiAgICogU2ltdWxhdGUgYSB0cmFuc2FjdGlvblxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuXG4gIC8qKlxuICAgKiBTaW11bGF0ZSBhIHRyYW5zYWN0aW9uXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG4gIGFzeW5jIHNpbXVsYXRlVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25Pck1lc3NhZ2UsIGNvbmZpZ09yU2lnbmVycywgaW5jbHVkZUFjY291bnRzKSB7XG4gICAgaWYgKCdtZXNzYWdlJyBpbiB0cmFuc2FjdGlvbk9yTWVzc2FnZSkge1xuICAgICAgY29uc3QgdmVyc2lvbmVkVHggPSB0cmFuc2FjdGlvbk9yTWVzc2FnZTtcbiAgICAgIGNvbnN0IHdpcmVUcmFuc2FjdGlvbiA9IHZlcnNpb25lZFR4LnNlcmlhbGl6ZSgpO1xuICAgICAgY29uc3QgZW5jb2RlZFRyYW5zYWN0aW9uID0gQnVmZmVyLmZyb20od2lyZVRyYW5zYWN0aW9uKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShjb25maWdPclNpZ25lcnMpIHx8IGluY2x1ZGVBY2NvdW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbmZpZyA9IGNvbmZpZ09yU2lnbmVycyB8fCB7fTtcbiAgICAgIGNvbmZpZy5lbmNvZGluZyA9ICdiYXNlNjQnO1xuICAgICAgaWYgKCEoJ2NvbW1pdG1lbnQnIGluIGNvbmZpZykpIHtcbiAgICAgICAgY29uZmlnLmNvbW1pdG1lbnQgPSB0aGlzLmNvbW1pdG1lbnQ7XG4gICAgICB9XG4gICAgICBpZiAoY29uZmlnT3JTaWduZXJzICYmIHR5cGVvZiBjb25maWdPclNpZ25lcnMgPT09ICdvYmplY3QnICYmICdpbm5lckluc3RydWN0aW9ucycgaW4gY29uZmlnT3JTaWduZXJzKSB7XG4gICAgICAgIGNvbmZpZy5pbm5lckluc3RydWN0aW9ucyA9IGNvbmZpZ09yU2lnbmVycy5pbm5lckluc3RydWN0aW9ucztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFyZ3MgPSBbZW5jb2RlZFRyYW5zYWN0aW9uLCBjb25maWddO1xuICAgICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnc2ltdWxhdGVUcmFuc2FjdGlvbicsIGFyZ3MpO1xuICAgICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgU2ltdWxhdGVkVHJhbnNhY3Rpb25SZXNwb25zZVN0cnVjdCk7XG4gICAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmYWlsZWQgdG8gc2ltdWxhdGUgdHJhbnNhY3Rpb246ICcgKyByZXMuZXJyb3IubWVzc2FnZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgICB9XG4gICAgbGV0IHRyYW5zYWN0aW9uO1xuICAgIGlmICh0cmFuc2FjdGlvbk9yTWVzc2FnZSBpbnN0YW5jZW9mIFRyYW5zYWN0aW9uKSB7XG4gICAgICBsZXQgb3JpZ2luYWxUeCA9IHRyYW5zYWN0aW9uT3JNZXNzYWdlO1xuICAgICAgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICAgIHRyYW5zYWN0aW9uLmZlZVBheWVyID0gb3JpZ2luYWxUeC5mZWVQYXllcjtcbiAgICAgIHRyYW5zYWN0aW9uLmluc3RydWN0aW9ucyA9IHRyYW5zYWN0aW9uT3JNZXNzYWdlLmluc3RydWN0aW9ucztcbiAgICAgIHRyYW5zYWN0aW9uLm5vbmNlSW5mbyA9IG9yaWdpbmFsVHgubm9uY2VJbmZvO1xuICAgICAgdHJhbnNhY3Rpb24uc2lnbmF0dXJlcyA9IG9yaWdpbmFsVHguc2lnbmF0dXJlcztcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhbnNhY3Rpb24gPSBUcmFuc2FjdGlvbi5wb3B1bGF0ZSh0cmFuc2FjdGlvbk9yTWVzc2FnZSk7XG4gICAgICAvLyBIQUNLOiB0aGlzIGZ1bmN0aW9uIHJlbGllcyBvbiBtdXRhdGluZyB0aGUgcG9wdWxhdGVkIHRyYW5zYWN0aW9uXG4gICAgICB0cmFuc2FjdGlvbi5fbWVzc2FnZSA9IHRyYW5zYWN0aW9uLl9qc29uID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoY29uZmlnT3JTaWduZXJzICE9PSB1bmRlZmluZWQgJiYgIUFycmF5LmlzQXJyYXkoY29uZmlnT3JTaWduZXJzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cycpO1xuICAgIH1cbiAgICBjb25zdCBzaWduZXJzID0gY29uZmlnT3JTaWduZXJzO1xuICAgIGlmICh0cmFuc2FjdGlvbi5ub25jZUluZm8gJiYgc2lnbmVycykge1xuICAgICAgdHJhbnNhY3Rpb24uc2lnbiguLi5zaWduZXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGRpc2FibGVDYWNoZSA9IHRoaXMuX2Rpc2FibGVCbG9ja2hhc2hDYWNoaW5nO1xuICAgICAgZm9yICg7Oykge1xuICAgICAgICBjb25zdCBsYXRlc3RCbG9ja2hhc2ggPSBhd2FpdCB0aGlzLl9ibG9ja2hhc2hXaXRoRXhwaXJ5QmxvY2tIZWlnaHQoZGlzYWJsZUNhY2hlKTtcbiAgICAgICAgdHJhbnNhY3Rpb24ubGFzdFZhbGlkQmxvY2tIZWlnaHQgPSBsYXRlc3RCbG9ja2hhc2gubGFzdFZhbGlkQmxvY2tIZWlnaHQ7XG4gICAgICAgIHRyYW5zYWN0aW9uLnJlY2VudEJsb2NraGFzaCA9IGxhdGVzdEJsb2NraGFzaC5ibG9ja2hhc2g7XG4gICAgICAgIGlmICghc2lnbmVycykgYnJlYWs7XG4gICAgICAgIHRyYW5zYWN0aW9uLnNpZ24oLi4uc2lnbmVycyk7XG4gICAgICAgIGlmICghdHJhbnNhY3Rpb24uc2lnbmF0dXJlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCchc2lnbmF0dXJlJyk7IC8vIHNob3VsZCBuZXZlciBoYXBwZW5cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSB0cmFuc2FjdGlvbi5zaWduYXR1cmUudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgICAgICBpZiAoIXRoaXMuX2Jsb2NraGFzaEluZm8uc2ltdWxhdGVkU2lnbmF0dXJlcy5pbmNsdWRlcyhzaWduYXR1cmUpICYmICF0aGlzLl9ibG9ja2hhc2hJbmZvLnRyYW5zYWN0aW9uU2lnbmF0dXJlcy5pbmNsdWRlcyhzaWduYXR1cmUpKSB7XG4gICAgICAgICAgLy8gVGhlIHNpZ25hdHVyZSBvZiB0aGlzIHRyYW5zYWN0aW9uIGhhcyBub3QgYmVlbiBzZWVuIGJlZm9yZSB3aXRoIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgcmVjZW50QmxvY2toYXNoLCBhbGwgZG9uZS4gTGV0J3MgYnJlYWtcbiAgICAgICAgICB0aGlzLl9ibG9ja2hhc2hJbmZvLnNpbXVsYXRlZFNpZ25hdHVyZXMucHVzaChzaWduYXR1cmUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoaXMgdHJhbnNhY3Rpb24gd291bGQgYmUgdHJlYXRlZCBhcyBkdXBsaWNhdGUgKGl0cyBkZXJpdmVkIHNpZ25hdHVyZVxuICAgICAgICAgIC8vIG1hdGNoZWQgdG8gb25lIG9mIGFscmVhZHkgcmVjb3JkZWQgc2lnbmF0dXJlcykuXG4gICAgICAgICAgLy8gU28sIHdlIG11c3QgZmV0Y2ggYSBuZXcgYmxvY2toYXNoIGZvciBhIGRpZmZlcmVudCBzaWduYXR1cmUgYnkgZGlzYWJsaW5nXG4gICAgICAgICAgLy8gb3VyIGNhY2hlIG5vdCB0byB3YWl0IGZvciB0aGUgY2FjaGUgZXhwaXJhdGlvbiAoQkxPQ0tIQVNIX0NBQ0hFX1RJTUVPVVRfTVMpLlxuICAgICAgICAgIGRpc2FibGVDYWNoZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZSA9IHRyYW5zYWN0aW9uLl9jb21waWxlKCk7XG4gICAgY29uc3Qgc2lnbkRhdGEgPSBtZXNzYWdlLnNlcmlhbGl6ZSgpO1xuICAgIGNvbnN0IHdpcmVUcmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uLl9zZXJpYWxpemUoc2lnbkRhdGEpO1xuICAgIGNvbnN0IGVuY29kZWRUcmFuc2FjdGlvbiA9IHdpcmVUcmFuc2FjdGlvbi50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgZW5jb2Rpbmc6ICdiYXNlNjQnLFxuICAgICAgY29tbWl0bWVudDogdGhpcy5jb21taXRtZW50XG4gICAgfTtcbiAgICBpZiAoaW5jbHVkZUFjY291bnRzKSB7XG4gICAgICBjb25zdCBhZGRyZXNzZXMgPSAoQXJyYXkuaXNBcnJheShpbmNsdWRlQWNjb3VudHMpID8gaW5jbHVkZUFjY291bnRzIDogbWVzc2FnZS5ub25Qcm9ncmFtSWRzKCkpLm1hcChrZXkgPT4ga2V5LnRvQmFzZTU4KCkpO1xuICAgICAgY29uZmlnWydhY2NvdW50cyddID0ge1xuICAgICAgICBlbmNvZGluZzogJ2Jhc2U2NCcsXG4gICAgICAgIGFkZHJlc3Nlc1xuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHNpZ25lcnMpIHtcbiAgICAgIGNvbmZpZy5zaWdWZXJpZnkgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoY29uZmlnT3JTaWduZXJzICYmIHR5cGVvZiBjb25maWdPclNpZ25lcnMgPT09ICdvYmplY3QnICYmICdpbm5lckluc3RydWN0aW9ucycgaW4gY29uZmlnT3JTaWduZXJzKSB7XG4gICAgICBjb25maWcuaW5uZXJJbnN0cnVjdGlvbnMgPSBjb25maWdPclNpZ25lcnMuaW5uZXJJbnN0cnVjdGlvbnM7XG4gICAgfVxuICAgIGNvbnN0IGFyZ3MgPSBbZW5jb2RlZFRyYW5zYWN0aW9uLCBjb25maWddO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ3NpbXVsYXRlVHJhbnNhY3Rpb24nLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBTaW11bGF0ZWRUcmFuc2FjdGlvblJlc3BvbnNlU3RydWN0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIGxldCBsb2dzO1xuICAgICAgaWYgKCdkYXRhJyBpbiByZXMuZXJyb3IpIHtcbiAgICAgICAgbG9ncyA9IHJlcy5lcnJvci5kYXRhLmxvZ3M7XG4gICAgICAgIGlmIChsb2dzICYmIEFycmF5LmlzQXJyYXkobG9ncykpIHtcbiAgICAgICAgICBjb25zdCB0cmFjZUluZGVudCA9ICdcXG4gICAgJztcbiAgICAgICAgICBjb25zdCBsb2dUcmFjZSA9IHRyYWNlSW5kZW50ICsgbG9ncy5qb2luKHRyYWNlSW5kZW50KTtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKHJlcy5lcnJvci5tZXNzYWdlLCBsb2dUcmFjZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBTZW5kVHJhbnNhY3Rpb25FcnJvcih7XG4gICAgICAgIGFjdGlvbjogJ3NpbXVsYXRlJyxcbiAgICAgICAgc2lnbmF0dXJlOiAnJyxcbiAgICAgICAgdHJhbnNhY3Rpb25NZXNzYWdlOiByZXMuZXJyb3IubWVzc2FnZSxcbiAgICAgICAgbG9nczogbG9nc1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFNpZ24gYW5kIHNlbmQgYSB0cmFuc2FjdGlvblxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBJbnN0ZWFkLCBjYWxsIHtAbGluayBzZW5kVHJhbnNhY3Rpb259IHdpdGggYSB7QGxpbmtcbiAgICogVmVyc2lvbmVkVHJhbnNhY3Rpb259XG4gICAqL1xuXG4gIC8qKlxuICAgKiBTZW5kIGEgc2lnbmVkIHRyYW5zYWN0aW9uXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG5cbiAgLyoqXG4gICAqIFNpZ24gYW5kIHNlbmQgYSB0cmFuc2FjdGlvblxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuICBhc3luYyBzZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIHNpZ25lcnNPck9wdGlvbnMsIG9wdGlvbnMpIHtcbiAgICBpZiAoJ3ZlcnNpb24nIGluIHRyYW5zYWN0aW9uKSB7XG4gICAgICBpZiAoc2lnbmVyc09yT3B0aW9ucyAmJiBBcnJheS5pc0FycmF5KHNpZ25lcnNPck9wdGlvbnMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHdpcmVUcmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uLnNlcmlhbGl6ZSgpO1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VuZFJhd1RyYW5zYWN0aW9uKHdpcmVUcmFuc2FjdGlvbiwgc2lnbmVyc09yT3B0aW9ucyk7XG4gICAgfVxuICAgIGlmIChzaWduZXJzT3JPcHRpb25zID09PSB1bmRlZmluZWQgfHwgIUFycmF5LmlzQXJyYXkoc2lnbmVyc09yT3B0aW9ucykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMnKTtcbiAgICB9XG4gICAgY29uc3Qgc2lnbmVycyA9IHNpZ25lcnNPck9wdGlvbnM7XG4gICAgaWYgKHRyYW5zYWN0aW9uLm5vbmNlSW5mbykge1xuICAgICAgdHJhbnNhY3Rpb24uc2lnbiguLi5zaWduZXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGRpc2FibGVDYWNoZSA9IHRoaXMuX2Rpc2FibGVCbG9ja2hhc2hDYWNoaW5nO1xuICAgICAgZm9yICg7Oykge1xuICAgICAgICBjb25zdCBsYXRlc3RCbG9ja2hhc2ggPSBhd2FpdCB0aGlzLl9ibG9ja2hhc2hXaXRoRXhwaXJ5QmxvY2tIZWlnaHQoZGlzYWJsZUNhY2hlKTtcbiAgICAgICAgdHJhbnNhY3Rpb24ubGFzdFZhbGlkQmxvY2tIZWlnaHQgPSBsYXRlc3RCbG9ja2hhc2gubGFzdFZhbGlkQmxvY2tIZWlnaHQ7XG4gICAgICAgIHRyYW5zYWN0aW9uLnJlY2VudEJsb2NraGFzaCA9IGxhdGVzdEJsb2NraGFzaC5ibG9ja2hhc2g7XG4gICAgICAgIHRyYW5zYWN0aW9uLnNpZ24oLi4uc2lnbmVycyk7XG4gICAgICAgIGlmICghdHJhbnNhY3Rpb24uc2lnbmF0dXJlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCchc2lnbmF0dXJlJyk7IC8vIHNob3VsZCBuZXZlciBoYXBwZW5cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSB0cmFuc2FjdGlvbi5zaWduYXR1cmUudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgICAgICBpZiAoIXRoaXMuX2Jsb2NraGFzaEluZm8udHJhbnNhY3Rpb25TaWduYXR1cmVzLmluY2x1ZGVzKHNpZ25hdHVyZSkpIHtcbiAgICAgICAgICAvLyBUaGUgc2lnbmF0dXJlIG9mIHRoaXMgdHJhbnNhY3Rpb24gaGFzIG5vdCBiZWVuIHNlZW4gYmVmb3JlIHdpdGggdGhlXG4gICAgICAgICAgLy8gY3VycmVudCByZWNlbnRCbG9ja2hhc2gsIGFsbCBkb25lLiBMZXQncyBicmVha1xuICAgICAgICAgIHRoaXMuX2Jsb2NraGFzaEluZm8udHJhbnNhY3Rpb25TaWduYXR1cmVzLnB1c2goc2lnbmF0dXJlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUaGlzIHRyYW5zYWN0aW9uIHdvdWxkIGJlIHRyZWF0ZWQgYXMgZHVwbGljYXRlIChpdHMgZGVyaXZlZCBzaWduYXR1cmVcbiAgICAgICAgICAvLyBtYXRjaGVkIHRvIG9uZSBvZiBhbHJlYWR5IHJlY29yZGVkIHNpZ25hdHVyZXMpLlxuICAgICAgICAgIC8vIFNvLCB3ZSBtdXN0IGZldGNoIGEgbmV3IGJsb2NraGFzaCBmb3IgYSBkaWZmZXJlbnQgc2lnbmF0dXJlIGJ5IGRpc2FibGluZ1xuICAgICAgICAgIC8vIG91ciBjYWNoZSBub3QgdG8gd2FpdCBmb3IgdGhlIGNhY2hlIGV4cGlyYXRpb24gKEJMT0NLSEFTSF9DQUNIRV9USU1FT1VUX01TKS5cbiAgICAgICAgICBkaXNhYmxlQ2FjaGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHdpcmVUcmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uLnNlcmlhbGl6ZSgpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlbmRSYXdUcmFuc2FjdGlvbih3aXJlVHJhbnNhY3Rpb24sIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSB0cmFuc2FjdGlvbiB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gc2lnbmVkIGFuZCBzZXJpYWxpemVkIGludG8gdGhlXG4gICAqIHdpcmUgZm9ybWF0XG4gICAqL1xuICBhc3luYyBzZW5kUmF3VHJhbnNhY3Rpb24ocmF3VHJhbnNhY3Rpb24sIG9wdGlvbnMpIHtcbiAgICBjb25zdCBlbmNvZGVkVHJhbnNhY3Rpb24gPSB0b0J1ZmZlcihyYXdUcmFuc2FjdGlvbikudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuc2VuZEVuY29kZWRUcmFuc2FjdGlvbihlbmNvZGVkVHJhbnNhY3Rpb24sIG9wdGlvbnMpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIHRyYW5zYWN0aW9uIHRoYXQgaGFzIGFscmVhZHkgYmVlbiBzaWduZWQsIHNlcmlhbGl6ZWQgaW50byB0aGVcbiAgICogd2lyZSBmb3JtYXQsIGFuZCBlbmNvZGVkIGFzIGEgYmFzZTY0IHN0cmluZ1xuICAgKi9cbiAgYXN5bmMgc2VuZEVuY29kZWRUcmFuc2FjdGlvbihlbmNvZGVkVHJhbnNhY3Rpb24sIG9wdGlvbnMpIHtcbiAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICBlbmNvZGluZzogJ2Jhc2U2NCdcbiAgICB9O1xuICAgIGNvbnN0IHNraXBQcmVmbGlnaHQgPSBvcHRpb25zICYmIG9wdGlvbnMuc2tpcFByZWZsaWdodDtcbiAgICBjb25zdCBwcmVmbGlnaHRDb21taXRtZW50ID0gc2tpcFByZWZsaWdodCA9PT0gdHJ1ZSA/ICdwcm9jZXNzZWQnIC8vIEZJWE1FIFJlbW92ZSB3aGVuIGh0dHBzOi8vZ2l0aHViLmNvbS9hbnphLXh5ei9hZ2F2ZS9wdWxsLzQ4MyBpcyBkZXBsb3llZC5cbiAgICA6IG9wdGlvbnMgJiYgb3B0aW9ucy5wcmVmbGlnaHRDb21taXRtZW50IHx8IHRoaXMuY29tbWl0bWVudDtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm1heFJldHJpZXMgIT0gbnVsbCkge1xuICAgICAgY29uZmlnLm1heFJldHJpZXMgPSBvcHRpb25zLm1heFJldHJpZXM7XG4gICAgfVxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMubWluQ29udGV4dFNsb3QgIT0gbnVsbCkge1xuICAgICAgY29uZmlnLm1pbkNvbnRleHRTbG90ID0gb3B0aW9ucy5taW5Db250ZXh0U2xvdDtcbiAgICB9XG4gICAgaWYgKHNraXBQcmVmbGlnaHQpIHtcbiAgICAgIGNvbmZpZy5za2lwUHJlZmxpZ2h0ID0gc2tpcFByZWZsaWdodDtcbiAgICB9XG4gICAgaWYgKHByZWZsaWdodENvbW1pdG1lbnQpIHtcbiAgICAgIGNvbmZpZy5wcmVmbGlnaHRDb21taXRtZW50ID0gcHJlZmxpZ2h0Q29tbWl0bWVudDtcbiAgICB9XG4gICAgY29uc3QgYXJncyA9IFtlbmNvZGVkVHJhbnNhY3Rpb24sIGNvbmZpZ107XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnc2VuZFRyYW5zYWN0aW9uJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgU2VuZFRyYW5zYWN0aW9uUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIGxldCBsb2dzID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKCdkYXRhJyBpbiByZXMuZXJyb3IpIHtcbiAgICAgICAgbG9ncyA9IHJlcy5lcnJvci5kYXRhLmxvZ3M7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgU2VuZFRyYW5zYWN0aW9uRXJyb3Ioe1xuICAgICAgICBhY3Rpb246IHNraXBQcmVmbGlnaHQgPyAnc2VuZCcgOiAnc2ltdWxhdGUnLFxuICAgICAgICBzaWduYXR1cmU6ICcnLFxuICAgICAgICB0cmFuc2FjdGlvbk1lc3NhZ2U6IHJlcy5lcnJvci5tZXNzYWdlLFxuICAgICAgICBsb2dzOiBsb2dzXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfd3NPbk9wZW4oKSB7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Q29ubmVjdGVkID0gdHJ1ZTtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXRIZWFydGJlYXQgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAvLyBQaW5nIHNlcnZlciBldmVyeSA1cyB0byBwcmV2ZW50IGlkbGUgdGltZW91dHNcbiAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5fcnBjV2ViU29ja2V0Lm5vdGlmeSgncGluZycpO1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICAgICAgICB9IGNhdGNoIHt9XG4gICAgICB9KSgpO1xuICAgIH0sIDUwMDApO1xuICAgIHRoaXMuX3VwZGF0ZVN1YnNjcmlwdGlvbnMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF93c09uRXJyb3IoZXJyKSB7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Q29ubmVjdGVkID0gZmFsc2U7XG4gICAgY29uc29sZS5lcnJvcignd3MgZXJyb3I6JywgZXJyLm1lc3NhZ2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3dzT25DbG9zZShjb2RlKSB7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Q29ubmVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0R2VuZXJhdGlvbiA9ICh0aGlzLl9ycGNXZWJTb2NrZXRHZW5lcmF0aW9uICsgMSkgJSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICBpZiAodGhpcy5fcnBjV2ViU29ja2V0SWRsZVRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9ycGNXZWJTb2NrZXRJZGxlVGltZW91dCk7XG4gICAgICB0aGlzLl9ycGNXZWJTb2NrZXRJZGxlVGltZW91dCA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLl9ycGNXZWJTb2NrZXRIZWFydGJlYXQpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fcnBjV2ViU29ja2V0SGVhcnRiZWF0KTtcbiAgICAgIHRoaXMuX3JwY1dlYlNvY2tldEhlYXJ0YmVhdCA9IG51bGw7XG4gICAgfVxuICAgIGlmIChjb2RlID09PSAxMDAwKSB7XG4gICAgICAvLyBleHBsaWNpdCBjbG9zZSwgY2hlY2sgaWYgYW55IHN1YnNjcmlwdGlvbnMgaGF2ZSBiZWVuIG1hZGUgc2luY2UgY2xvc2VcbiAgICAgIHRoaXMuX3VwZGF0ZVN1YnNjcmlwdGlvbnMoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBpbXBsaWNpdCBjbG9zZSwgcHJlcGFyZSBzdWJzY3JpcHRpb25zIGZvciBhdXRvLXJlY29ubmVjdFxuICAgIHRoaXMuX3N1YnNjcmlwdGlvbkNhbGxiYWNrc0J5U2VydmVyU3Vic2NyaXB0aW9uSWQgPSB7fTtcbiAgICBPYmplY3QuZW50cmllcyh0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoKS5mb3JFYWNoKChbaGFzaCwgc3Vic2NyaXB0aW9uXSkgPT4ge1xuICAgICAgdGhpcy5fc2V0U3Vic2NyaXB0aW9uKGhhc2gsIHtcbiAgICAgICAgLi4uc3Vic2NyaXB0aW9uLFxuICAgICAgICBzdGF0ZTogJ3BlbmRpbmcnXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9zZXRTdWJzY3JpcHRpb24oaGFzaCwgbmV4dFN1YnNjcmlwdGlvbikge1xuICAgIGNvbnN0IHByZXZTdGF0ZSA9IHRoaXMuX3N1YnNjcmlwdGlvbnNCeUhhc2hbaGFzaF0/LnN0YXRlO1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnNCeUhhc2hbaGFzaF0gPSBuZXh0U3Vic2NyaXB0aW9uO1xuICAgIGlmIChwcmV2U3RhdGUgIT09IG5leHRTdWJzY3JpcHRpb24uc3RhdGUpIHtcbiAgICAgIGNvbnN0IHN0YXRlQ2hhbmdlQ2FsbGJhY2tzID0gdGhpcy5fc3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2VDYWxsYmFja3NCeUhhc2hbaGFzaF07XG4gICAgICBpZiAoc3RhdGVDaGFuZ2VDYWxsYmFja3MpIHtcbiAgICAgICAgc3RhdGVDaGFuZ2VDYWxsYmFja3MuZm9yRWFjaChjYiA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNiKG5leHRTdWJzY3JpcHRpb24uc3RhdGUpO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgICAgICAgfSBjYXRjaCB7fVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfb25TdWJzY3JpcHRpb25TdGF0ZUNoYW5nZShjbGllbnRTdWJzY3JpcHRpb25JZCwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBoYXNoID0gdGhpcy5fc3Vic2NyaXB0aW9uSGFzaEJ5Q2xpZW50U3Vic2NyaXB0aW9uSWRbY2xpZW50U3Vic2NyaXB0aW9uSWRdO1xuICAgIGlmIChoYXNoID09IG51bGwpIHtcbiAgICAgIHJldHVybiAoKSA9PiB7fTtcbiAgICB9XG4gICAgY29uc3Qgc3RhdGVDaGFuZ2VDYWxsYmFja3MgPSB0aGlzLl9zdWJzY3JpcHRpb25TdGF0ZUNoYW5nZUNhbGxiYWNrc0J5SGFzaFtoYXNoXSB8fD0gbmV3IFNldCgpO1xuICAgIHN0YXRlQ2hhbmdlQ2FsbGJhY2tzLmFkZChjYWxsYmFjayk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHN0YXRlQ2hhbmdlQ2FsbGJhY2tzLmRlbGV0ZShjYWxsYmFjayk7XG4gICAgICBpZiAoc3RhdGVDaGFuZ2VDYWxsYmFja3Muc2l6ZSA9PT0gMCkge1xuICAgICAgICBkZWxldGUgdGhpcy5fc3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2VDYWxsYmFja3NCeUhhc2hbaGFzaF07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGFzeW5jIF91cGRhdGVTdWJzY3JpcHRpb25zKCkge1xuICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmICh0aGlzLl9ycGNXZWJTb2NrZXRDb25uZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5fcnBjV2ViU29ja2V0Q29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3JwY1dlYlNvY2tldElkbGVUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fcnBjV2ViU29ja2V0SWRsZVRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl9ycGNXZWJTb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIC8vIHN3YWxsb3cgZXJyb3IgaWYgc29ja2V0IGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkLlxuICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBFcnJvciB3aGVuIGNsb3Npbmcgc29ja2V0IGNvbm5lY3Rpb246ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCA1MDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcnBjV2ViU29ja2V0SWRsZVRpbWVvdXQgIT09IG51bGwpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9ycGNXZWJTb2NrZXRJZGxlVGltZW91dCk7XG4gICAgICB0aGlzLl9ycGNXZWJTb2NrZXRJZGxlVGltZW91dCA9IG51bGw7XG4gICAgICB0aGlzLl9ycGNXZWJTb2NrZXRDb25uZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX3JwY1dlYlNvY2tldENvbm5lY3RlZCkge1xuICAgICAgdGhpcy5fcnBjV2ViU29ja2V0LmNvbm5lY3QoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYWN0aXZlV2ViU29ja2V0R2VuZXJhdGlvbiA9IHRoaXMuX3JwY1dlYlNvY2tldEdlbmVyYXRpb247XG4gICAgY29uc3QgaXNDdXJyZW50Q29ubmVjdGlvblN0aWxsQWN0aXZlID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIGFjdGl2ZVdlYlNvY2tldEdlbmVyYXRpb24gPT09IHRoaXMuX3JwY1dlYlNvY2tldEdlbmVyYXRpb247XG4gICAgfTtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAvLyBEb24ndCBiZSB0ZW1wdGVkIHRvIGNoYW5nZSB0aGlzIHRvIGBPYmplY3QuZW50cmllc2AuIFdlIGNhbGxcbiAgICAvLyBgX3VwZGF0ZVN1YnNjcmlwdGlvbnNgIHJlY3Vyc2l2ZWx5IHdoZW4gcHJvY2Vzc2luZyB0aGUgc3RhdGUsXG4gICAgLy8gc28gaXQncyBpbXBvcnRhbnQgdGhhdCB3ZSBsb29rIHVwIHRoZSAqY3VycmVudCogdmVyc2lvbiBvZlxuICAgIC8vIGVhY2ggc3Vic2NyaXB0aW9uLCBldmVyeSB0aW1lIHdlIHByb2Nlc3MgYSBoYXNoLlxuICAgIE9iamVjdC5rZXlzKHRoaXMuX3N1YnNjcmlwdGlvbnNCeUhhc2gpLm1hcChhc3luYyBoYXNoID0+IHtcbiAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHRoaXMuX3N1YnNjcmlwdGlvbnNCeUhhc2hbaGFzaF07XG4gICAgICBpZiAoc3Vic2NyaXB0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gVGhpcyBlbnRyeSBoYXMgc2luY2UgYmVlbiBkZWxldGVkLiBTa2lwLlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHN1YnNjcmlwdGlvbi5zdGF0ZSkge1xuICAgICAgICBjYXNlICdwZW5kaW5nJzpcbiAgICAgICAgY2FzZSAndW5zdWJzY3JpYmVkJzpcbiAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uLmNhbGxiYWNrcy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFlvdSBjYW4gZW5kIHVwIGhlcmUgd2hlbjpcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAtIGEgc3Vic2NyaXB0aW9uIGhhcyByZWNlbnRseSB1bnN1YnNjcmliZWRcbiAgICAgICAgICAgICAqICAgd2l0aG91dCBoYXZpbmcgbmV3IGNhbGxiYWNrcyBhZGRlZCB0byBpdFxuICAgICAgICAgICAgICogICB3aGlsZSB0aGUgdW5zdWJzY3JpYmUgd2FzIGluIGZsaWdodCwgb3JcbiAgICAgICAgICAgICAqIC0gd2hlbiBhIHBlbmRpbmcgc3Vic2NyaXB0aW9uIGhhcyBpdHNcbiAgICAgICAgICAgICAqICAgbGlzdGVuZXJzIHJlbW92ZWQgYmVmb3JlIGEgcmVxdWVzdCB3YXNcbiAgICAgICAgICAgICAqICAgc2VudCB0byB0aGUgc2VydmVyLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEJlaW5nIHRoYXQgbm9ib2R5IGlzIGludGVyZXN0ZWQgaW4gdGhpc1xuICAgICAgICAgICAgICogc3Vic2NyaXB0aW9uIGFueSBsb25nZXIsIGRlbGV0ZSBpdC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3N1YnNjcmlwdGlvbnNCeUhhc2hbaGFzaF07XG4gICAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uLnN0YXRlID09PSAndW5zdWJzY3JpYmVkJykge1xuICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fc3Vic2NyaXB0aW9uQ2FsbGJhY2tzQnlTZXJ2ZXJTdWJzY3JpcHRpb25JZFtzdWJzY3JpcHRpb24uc2VydmVyU3Vic2NyaXB0aW9uSWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5fdXBkYXRlU3Vic2NyaXB0aW9ucygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhd2FpdCAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgICBtZXRob2RcbiAgICAgICAgICAgIH0gPSBzdWJzY3JpcHRpb247XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB0aGlzLl9zZXRTdWJzY3JpcHRpb24oaGFzaCwge1xuICAgICAgICAgICAgICAgIC4uLnN1YnNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ3N1YnNjcmliaW5nJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY29uc3Qgc2VydmVyU3Vic2NyaXB0aW9uSWQgPSBhd2FpdCB0aGlzLl9ycGNXZWJTb2NrZXQuY2FsbChtZXRob2QsIGFyZ3MpO1xuICAgICAgICAgICAgICB0aGlzLl9zZXRTdWJzY3JpcHRpb24oaGFzaCwge1xuICAgICAgICAgICAgICAgIC4uLnN1YnNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICBzZXJ2ZXJTdWJzY3JpcHRpb25JZCxcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ3N1YnNjcmliZWQnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25DYWxsYmFja3NCeVNlcnZlclN1YnNjcmlwdGlvbklkW3NlcnZlclN1YnNjcmlwdGlvbklkXSA9IHN1YnNjcmlwdGlvbi5jYWxsYmFja3M7XG4gICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3VwZGF0ZVN1YnNjcmlwdGlvbnMoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgUmVjZWl2ZWQgJHtlIGluc3RhbmNlb2YgRXJyb3IgPyAnJyA6ICdKU09OLVJQQyAnfWVycm9yIGNhbGxpbmcgXFxgJHttZXRob2R9XFxgYCwge1xuICAgICAgICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmICghaXNDdXJyZW50Q29ubmVjdGlvblN0aWxsQWN0aXZlKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gVE9ETzogTWF5YmUgYWRkIGFuICdlcnJvcmVkJyBzdGF0ZSBvciBhIHJldHJ5IGxpbWl0P1xuICAgICAgICAgICAgICB0aGlzLl9zZXRTdWJzY3JpcHRpb24oaGFzaCwge1xuICAgICAgICAgICAgICAgIC4uLnN1YnNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ3BlbmRpbmcnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBhd2FpdCB0aGlzLl91cGRhdGVTdWJzY3JpcHRpb25zKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc3Vic2NyaWJlZCc6XG4gICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbi5jYWxsYmFja3Muc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgLy8gQnkgdGhlIHRpbWUgd2Ugc3VjY2Vzc2Z1bGx5IHNldCB1cCBhIHN1YnNjcmlwdGlvblxuICAgICAgICAgICAgLy8gd2l0aCB0aGUgc2VydmVyLCB0aGUgY2xpZW50IHN0b3BwZWQgY2FyaW5nIGFib3V0IGl0LlxuICAgICAgICAgICAgLy8gVGVhciBpdCBkb3duIG5vdy5cbiAgICAgICAgICAgIGF3YWl0IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICBzZXJ2ZXJTdWJzY3JpcHRpb25JZCxcbiAgICAgICAgICAgICAgICB1bnN1YnNjcmliZU1ldGhvZFxuICAgICAgICAgICAgICB9ID0gc3Vic2NyaXB0aW9uO1xuICAgICAgICAgICAgICBpZiAodGhpcy5fc3Vic2NyaXB0aW9uc0F1dG9EaXNwb3NlZEJ5UnBjLmhhcyhzZXJ2ZXJTdWJzY3JpcHRpb25JZCkpIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBTcGVjaWFsIGNhc2UuXG4gICAgICAgICAgICAgICAgICogSWYgd2UncmUgZGVhbGluZyB3aXRoIGEgc3Vic2NyaXB0aW9uIHRoYXQgaGFzIGJlZW4gYXV0by1cbiAgICAgICAgICAgICAgICAgKiBkaXNwb3NlZCBieSB0aGUgUlBDLCB0aGVuIHdlIGNhbiBza2lwIHRoZSBSUEMgY2FsbCB0b1xuICAgICAgICAgICAgICAgICAqIHRlYXIgZG93biB0aGUgc3Vic2NyaXB0aW9uIGhlcmUuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBOT1RFOiBUaGVyZSBpcyBhIHByb3Bvc2FsIHRvIGVsaW1pbmF0ZSB0aGlzIHNwZWNpYWwgY2FzZSwgaGVyZTpcbiAgICAgICAgICAgICAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vc29sYW5hLWxhYnMvc29sYW5hL2lzc3Vlcy8xODg5MlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnNBdXRvRGlzcG9zZWRCeVJwYy5kZWxldGUoc2VydmVyU3Vic2NyaXB0aW9uSWQpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldFN1YnNjcmlwdGlvbihoYXNoLCB7XG4gICAgICAgICAgICAgICAgICAuLi5zdWJzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICBzdGF0ZTogJ3Vuc3Vic2NyaWJpbmcnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0U3Vic2NyaXB0aW9uKGhhc2gsIHtcbiAgICAgICAgICAgICAgICAgIC4uLnN1YnNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgIHN0YXRlOiAndW5zdWJzY3JpYmluZydcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fcnBjV2ViU29ja2V0LmNhbGwodW5zdWJzY3JpYmVNZXRob2QsIFtzZXJ2ZXJTdWJzY3JpcHRpb25JZF0pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgJHt1bnN1YnNjcmliZU1ldGhvZH0gZXJyb3I6YCwgZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmICghaXNDdXJyZW50Q29ubmVjdGlvblN0aWxsQWN0aXZlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgLy8gVE9ETzogTWF5YmUgYWRkIGFuICdlcnJvcmVkJyBzdGF0ZSBvciBhIHJldHJ5IGxpbWl0P1xuICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0U3Vic2NyaXB0aW9uKGhhc2gsIHtcbiAgICAgICAgICAgICAgICAgICAgLi4uc3Vic2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZTogJ3N1YnNjcmliZWQnXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3VwZGF0ZVN1YnNjcmlwdGlvbnMoKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5fc2V0U3Vic2NyaXB0aW9uKGhhc2gsIHtcbiAgICAgICAgICAgICAgICAuLi5zdWJzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgc3RhdGU6ICd1bnN1YnNjcmliZWQnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBhd2FpdCB0aGlzLl91cGRhdGVTdWJzY3JpcHRpb25zKCk7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9KSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfaGFuZGxlU2VydmVyTm90aWZpY2F0aW9uKHNlcnZlclN1YnNjcmlwdGlvbklkLCBjYWxsYmFja0FyZ3MpIHtcbiAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzLl9zdWJzY3JpcHRpb25DYWxsYmFja3NCeVNlcnZlclN1YnNjcmlwdGlvbklkW3NlcnZlclN1YnNjcmlwdGlvbklkXTtcbiAgICBpZiAoY2FsbGJhY2tzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGJhY2tzLmZvckVhY2goY2IgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2IoXG4gICAgICAgIC8vIEkgZmFpbGVkIHRvIGZpbmQgYSB3YXkgdG8gY29udmluY2UgVHlwZVNjcmlwdCB0aGF0IGBjYmAgaXMgb2YgdHlwZVxuICAgICAgICAvLyBgVENhbGxiYWNrYCB3aGljaCBpcyBjZXJ0YWlubHkgY29tcGF0aWJsZSB3aXRoIGBQYXJhbWV0ZXJzPFRDYWxsYmFjaz5gLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy80NzYxNVxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIC4uLmNhbGxiYWNrQXJncyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfd3NPbkFjY291bnROb3RpZmljYXRpb24obm90aWZpY2F0aW9uKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVzdWx0LFxuICAgICAgc3Vic2NyaXB0aW9uXG4gICAgfSA9IGNyZWF0ZShub3RpZmljYXRpb24sIEFjY291bnROb3RpZmljYXRpb25SZXN1bHQpO1xuICAgIHRoaXMuX2hhbmRsZVNlcnZlck5vdGlmaWNhdGlvbihzdWJzY3JpcHRpb24sIFtyZXN1bHQudmFsdWUsIHJlc3VsdC5jb250ZXh0XSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfbWFrZVN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb25Db25maWcsXG4gIC8qKlxuICAgKiBXaGVuIHByZXBhcmluZyBgYXJnc2AgZm9yIGEgY2FsbCB0byBgX21ha2VTdWJzY3JpcHRpb25gLCBiZSBzdXJlXG4gICAqIHRvIGNhcmVmdWxseSBhcHBseSBhIGRlZmF1bHQgYGNvbW1pdG1lbnRgIHByb3BlcnR5LCBpZiBuZWNlc3NhcnkuXG4gICAqXG4gICAqIC0gSWYgdGhlIHVzZXIgc3VwcGxpZWQgYSBgY29tbWl0bWVudGAgdXNlIHRoYXQuXG4gICAqIC0gT3RoZXJ3aXNlLCBpZiB0aGUgYENvbm5lY3Rpb246OmNvbW1pdG1lbnRgIGlzIHNldCwgdXNlIHRoYXQuXG4gICAqIC0gT3RoZXJ3aXNlLCBzZXQgaXQgdG8gdGhlIFJQQyBzZXJ2ZXIgZGVmYXVsdDogYGZpbmFsaXplZGAuXG4gICAqXG4gICAqIFRoaXMgaXMgZXh0cmVtZWx5IGltcG9ydGFudCB0byBlbnN1cmUgdGhhdCB0aGVzZSB0d28gZnVuZGFtZW50YWxseVxuICAgKiBpZGVudGljYWwgc3Vic2NyaXB0aW9ucyBwcm9kdWNlIHRoZSBzYW1lIGlkZW50aWZ5aW5nIGhhc2g6XG4gICAqXG4gICAqIC0gQSBzdWJzY3JpcHRpb24gbWFkZSB3aXRob3V0IHNwZWNpZnlpbmcgYSBjb21taXRtZW50LlxuICAgKiAtIEEgc3Vic2NyaXB0aW9uIG1hZGUgd2hlcmUgdGhlIGNvbW1pdG1lbnQgc3BlY2lmaWVkIGlzIHRoZSBzYW1lXG4gICAqICAgYXMgdGhlIGRlZmF1bHQgYXBwbGllZCB0byB0aGUgc3Vic2NyaXB0aW9uIGFib3ZlLlxuICAgKlxuICAgKiBFeGFtcGxlOyB0aGVzZSB0d28gc3Vic2NyaXB0aW9ucyBtdXN0IHByb2R1Y2UgdGhlIHNhbWUgaGFzaDpcbiAgICpcbiAgICogLSBBbiBgYWNjb3VudFN1YnNjcmliZWAgc3Vic2NyaXB0aW9uIGZvciBgJ1BVQktFWSdgXG4gICAqIC0gQW4gYGFjY291bnRTdWJzY3JpYmVgIHN1YnNjcmlwdGlvbiBmb3IgYCdQVUJLRVknYCB3aXRoIGNvbW1pdG1lbnRcbiAgICogICBgJ2ZpbmFsaXplZCdgLlxuICAgKlxuICAgKiBTZWUgdGhlICdtYWtpbmcgYSBzdWJzY3JpcHRpb24gd2l0aCBkZWZhdWx0ZWQgcGFyYW1zIG9taXR0ZWQnIHRlc3RcbiAgICogaW4gYGNvbm5lY3Rpb24tc3Vic2NyaXB0aW9ucy50c2AgZm9yIG1vcmUuXG4gICAqL1xuICBhcmdzKSB7XG4gICAgY29uc3QgY2xpZW50U3Vic2NyaXB0aW9uSWQgPSB0aGlzLl9uZXh0Q2xpZW50U3Vic2NyaXB0aW9uSWQrKztcbiAgICBjb25zdCBoYXNoID0gZmFzdFN0YWJsZVN0cmluZ2lmeShbc3Vic2NyaXB0aW9uQ29uZmlnLm1ldGhvZCwgYXJnc10pO1xuICAgIGNvbnN0IGV4aXN0aW5nU3Vic2NyaXB0aW9uID0gdGhpcy5fc3Vic2NyaXB0aW9uc0J5SGFzaFtoYXNoXTtcbiAgICBpZiAoZXhpc3RpbmdTdWJzY3JpcHRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uc0J5SGFzaFtoYXNoXSA9IHtcbiAgICAgICAgLi4uc3Vic2NyaXB0aW9uQ29uZmlnLFxuICAgICAgICBhcmdzLFxuICAgICAgICBjYWxsYmFja3M6IG5ldyBTZXQoW3N1YnNjcmlwdGlvbkNvbmZpZy5jYWxsYmFja10pLFxuICAgICAgICBzdGF0ZTogJ3BlbmRpbmcnXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBleGlzdGluZ1N1YnNjcmlwdGlvbi5jYWxsYmFja3MuYWRkKHN1YnNjcmlwdGlvbkNvbmZpZy5jYWxsYmFjayk7XG4gICAgfVxuICAgIHRoaXMuX3N1YnNjcmlwdGlvbkhhc2hCeUNsaWVudFN1YnNjcmlwdGlvbklkW2NsaWVudFN1YnNjcmlwdGlvbklkXSA9IGhhc2g7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uRGlzcG9zZUZ1bmN0aW9uc0J5Q2xpZW50U3Vic2NyaXB0aW9uSWRbY2xpZW50U3Vic2NyaXB0aW9uSWRdID0gYXN5bmMgKCkgPT4ge1xuICAgICAgZGVsZXRlIHRoaXMuX3N1YnNjcmlwdGlvbkRpc3Bvc2VGdW5jdGlvbnNCeUNsaWVudFN1YnNjcmlwdGlvbklkW2NsaWVudFN1YnNjcmlwdGlvbklkXTtcbiAgICAgIGRlbGV0ZSB0aGlzLl9zdWJzY3JpcHRpb25IYXNoQnlDbGllbnRTdWJzY3JpcHRpb25JZFtjbGllbnRTdWJzY3JpcHRpb25JZF07XG4gICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSB0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoW2hhc2hdO1xuICAgICAgYXNzZXJ0KHN1YnNjcmlwdGlvbiAhPT0gdW5kZWZpbmVkLCBgQ291bGQgbm90IGZpbmQgYSBcXGBTdWJzY3JpcHRpb25cXGAgd2hlbiB0ZWFyaW5nIGRvd24gY2xpZW50IHN1YnNjcmlwdGlvbiAjJHtjbGllbnRTdWJzY3JpcHRpb25JZH1gKTtcbiAgICAgIHN1YnNjcmlwdGlvbi5jYWxsYmFja3MuZGVsZXRlKHN1YnNjcmlwdGlvbkNvbmZpZy5jYWxsYmFjayk7XG4gICAgICBhd2FpdCB0aGlzLl91cGRhdGVTdWJzY3JpcHRpb25zKCk7XG4gICAgfTtcbiAgICB0aGlzLl91cGRhdGVTdWJzY3JpcHRpb25zKCk7XG4gICAgcmV0dXJuIGNsaWVudFN1YnNjcmlwdGlvbklkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuZXZlciB0aGUgc3BlY2lmaWVkIGFjY291bnQgY2hhbmdlc1xuICAgKlxuICAgKiBAcGFyYW0gcHVibGljS2V5IFB1YmxpYyBrZXkgb2YgdGhlIGFjY291bnQgdG8gbW9uaXRvclxuICAgKiBAcGFyYW0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gaW52b2tlIHdoZW5ldmVyIHRoZSBhY2NvdW50IGlzIGNoYW5nZWRcbiAgICogQHBhcmFtIGNvbmZpZ1xuICAgKiBAcmV0dXJuIHN1YnNjcmlwdGlvbiBpZFxuICAgKi9cblxuICAvKiogQGRlcHJlY2F0ZWQgSW5zdGVhZCwgcGFzcyBpbiBhbiB7QGxpbmsgQWNjb3VudFN1YnNjcmlwdGlvbkNvbmZpZ30gKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcbiAgb25BY2NvdW50Q2hhbmdlKHB1YmxpY0tleSwgY2FsbGJhY2ssIGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbcHVibGljS2V5LnRvQmFzZTU4KCldLCBjb21taXRtZW50IHx8IHRoaXMuX2NvbW1pdG1lbnQgfHwgJ2ZpbmFsaXplZCcsXG4gICAgLy8gQXBwbHkgY29ubmVjdGlvbi9zZXJ2ZXIgZGVmYXVsdC5cbiAgICAnYmFzZTY0JywgY29uZmlnKTtcbiAgICByZXR1cm4gdGhpcy5fbWFrZVN1YnNjcmlwdGlvbih7XG4gICAgICBjYWxsYmFjayxcbiAgICAgIG1ldGhvZDogJ2FjY291bnRTdWJzY3JpYmUnLFxuICAgICAgdW5zdWJzY3JpYmVNZXRob2Q6ICdhY2NvdW50VW5zdWJzY3JpYmUnXG4gICAgfSwgYXJncyk7XG4gIH1cblxuICAvKipcbiAgICogRGVyZWdpc3RlciBhbiBhY2NvdW50IG5vdGlmaWNhdGlvbiBjYWxsYmFja1xuICAgKlxuICAgKiBAcGFyYW0gY2xpZW50U3Vic2NyaXB0aW9uSWQgY2xpZW50IHN1YnNjcmlwdGlvbiBpZCB0byBkZXJlZ2lzdGVyXG4gICAqL1xuICBhc3luYyByZW1vdmVBY2NvdW50Q2hhbmdlTGlzdGVuZXIoY2xpZW50U3Vic2NyaXB0aW9uSWQpIHtcbiAgICBhd2FpdCB0aGlzLl91bnN1YnNjcmliZUNsaWVudFN1YnNjcmlwdGlvbihjbGllbnRTdWJzY3JpcHRpb25JZCwgJ2FjY291bnQgY2hhbmdlJyk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfd3NPblByb2dyYW1BY2NvdW50Tm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbikge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlc3VsdCxcbiAgICAgIHN1YnNjcmlwdGlvblxuICAgIH0gPSBjcmVhdGUobm90aWZpY2F0aW9uLCBQcm9ncmFtQWNjb3VudE5vdGlmaWNhdGlvblJlc3VsdCk7XG4gICAgdGhpcy5faGFuZGxlU2VydmVyTm90aWZpY2F0aW9uKHN1YnNjcmlwdGlvbiwgW3tcbiAgICAgIGFjY291bnRJZDogcmVzdWx0LnZhbHVlLnB1YmtleSxcbiAgICAgIGFjY291bnRJbmZvOiByZXN1bHQudmFsdWUuYWNjb3VudFxuICAgIH0sIHJlc3VsdC5jb250ZXh0XSk7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBjYWxsYmFjayB0byBiZSBpbnZva2VkIHdoZW5ldmVyIGFjY291bnRzIG93bmVkIGJ5IHRoZVxuICAgKiBzcGVjaWZpZWQgcHJvZ3JhbSBjaGFuZ2VcbiAgICpcbiAgICogQHBhcmFtIHByb2dyYW1JZCBQdWJsaWMga2V5IG9mIHRoZSBwcm9ncmFtIHRvIG1vbml0b3JcbiAgICogQHBhcmFtIGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGludm9rZSB3aGVuZXZlciB0aGUgYWNjb3VudCBpcyBjaGFuZ2VkXG4gICAqIEBwYXJhbSBjb25maWdcbiAgICogQHJldHVybiBzdWJzY3JpcHRpb24gaWRcbiAgICovXG5cbiAgLyoqIEBkZXByZWNhdGVkIEluc3RlYWQsIHBhc3MgaW4gYSB7QGxpbmsgUHJvZ3JhbUFjY291bnRTdWJzY3JpcHRpb25Db25maWd9ICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG4gIG9uUHJvZ3JhbUFjY291bnRDaGFuZ2UocHJvZ3JhbUlkLCBjYWxsYmFjaywgY29tbWl0bWVudE9yQ29uZmlnLCBtYXliZUZpbHRlcnMpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3Byb2dyYW1JZC50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCB8fCB0aGlzLl9jb21taXRtZW50IHx8ICdmaW5hbGl6ZWQnLFxuICAgIC8vIEFwcGx5IGNvbm5lY3Rpb24vc2VydmVyIGRlZmF1bHQuXG4gICAgJ2Jhc2U2NCcgLyogZW5jb2RpbmcgKi8sIGNvbmZpZyA/IGNvbmZpZyA6IG1heWJlRmlsdGVycyA/IHtcbiAgICAgIGZpbHRlcnM6IGFwcGx5RGVmYXVsdE1lbWNtcEVuY29kaW5nVG9GaWx0ZXJzKG1heWJlRmlsdGVycylcbiAgICB9IDogdW5kZWZpbmVkIC8qIGV4dHJhICovKTtcbiAgICByZXR1cm4gdGhpcy5fbWFrZVN1YnNjcmlwdGlvbih7XG4gICAgICBjYWxsYmFjayxcbiAgICAgIG1ldGhvZDogJ3Byb2dyYW1TdWJzY3JpYmUnLFxuICAgICAgdW5zdWJzY3JpYmVNZXRob2Q6ICdwcm9ncmFtVW5zdWJzY3JpYmUnXG4gICAgfSwgYXJncyk7XG4gIH1cblxuICAvKipcbiAgICogRGVyZWdpc3RlciBhbiBhY2NvdW50IG5vdGlmaWNhdGlvbiBjYWxsYmFja1xuICAgKlxuICAgKiBAcGFyYW0gY2xpZW50U3Vic2NyaXB0aW9uSWQgY2xpZW50IHN1YnNjcmlwdGlvbiBpZCB0byBkZXJlZ2lzdGVyXG4gICAqL1xuICBhc3luYyByZW1vdmVQcm9ncmFtQWNjb3VudENoYW5nZUxpc3RlbmVyKGNsaWVudFN1YnNjcmlwdGlvbklkKSB7XG4gICAgYXdhaXQgdGhpcy5fdW5zdWJzY3JpYmVDbGllbnRTdWJzY3JpcHRpb24oY2xpZW50U3Vic2NyaXB0aW9uSWQsICdwcm9ncmFtIGFjY291bnQgY2hhbmdlJyk7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuZXZlciBsb2dzIGFyZSBlbWl0dGVkLlxuICAgKi9cbiAgb25Mb2dzKGZpbHRlciwgY2FsbGJhY2ssIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFt0eXBlb2YgZmlsdGVyID09PSAnb2JqZWN0JyA/IHtcbiAgICAgIG1lbnRpb25zOiBbZmlsdGVyLnRvU3RyaW5nKCldXG4gICAgfSA6IGZpbHRlcl0sIGNvbW1pdG1lbnQgfHwgdGhpcy5fY29tbWl0bWVudCB8fCAnZmluYWxpemVkJyAvLyBBcHBseSBjb25uZWN0aW9uL3NlcnZlciBkZWZhdWx0LlxuICAgICk7XG4gICAgcmV0dXJuIHRoaXMuX21ha2VTdWJzY3JpcHRpb24oe1xuICAgICAgY2FsbGJhY2ssXG4gICAgICBtZXRob2Q6ICdsb2dzU3Vic2NyaWJlJyxcbiAgICAgIHVuc3Vic2NyaWJlTWV0aG9kOiAnbG9nc1Vuc3Vic2NyaWJlJ1xuICAgIH0sIGFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXIgYSBsb2dzIGNhbGxiYWNrLlxuICAgKlxuICAgKiBAcGFyYW0gY2xpZW50U3Vic2NyaXB0aW9uSWQgY2xpZW50IHN1YnNjcmlwdGlvbiBpZCB0byBkZXJlZ2lzdGVyLlxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlT25Mb2dzTGlzdGVuZXIoY2xpZW50U3Vic2NyaXB0aW9uSWQpIHtcbiAgICBhd2FpdCB0aGlzLl91bnN1YnNjcmliZUNsaWVudFN1YnNjcmlwdGlvbihjbGllbnRTdWJzY3JpcHRpb25JZCwgJ2xvZ3MnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF93c09uTG9nc05vdGlmaWNhdGlvbihub3RpZmljYXRpb24pIHtcbiAgICBjb25zdCB7XG4gICAgICByZXN1bHQsXG4gICAgICBzdWJzY3JpcHRpb25cbiAgICB9ID0gY3JlYXRlKG5vdGlmaWNhdGlvbiwgTG9nc05vdGlmaWNhdGlvblJlc3VsdCk7XG4gICAgdGhpcy5faGFuZGxlU2VydmVyTm90aWZpY2F0aW9uKHN1YnNjcmlwdGlvbiwgW3Jlc3VsdC52YWx1ZSwgcmVzdWx0LmNvbnRleHRdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF93c09uU2xvdE5vdGlmaWNhdGlvbihub3RpZmljYXRpb24pIHtcbiAgICBjb25zdCB7XG4gICAgICByZXN1bHQsXG4gICAgICBzdWJzY3JpcHRpb25cbiAgICB9ID0gY3JlYXRlKG5vdGlmaWNhdGlvbiwgU2xvdE5vdGlmaWNhdGlvblJlc3VsdCk7XG4gICAgdGhpcy5faGFuZGxlU2VydmVyTm90aWZpY2F0aW9uKHN1YnNjcmlwdGlvbiwgW3Jlc3VsdF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB1cG9uIHNsb3QgY2hhbmdlc1xuICAgKlxuICAgKiBAcGFyYW0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gaW52b2tlIHdoZW5ldmVyIHRoZSBzbG90IGNoYW5nZXNcbiAgICogQHJldHVybiBzdWJzY3JpcHRpb24gaWRcbiAgICovXG4gIG9uU2xvdENoYW5nZShjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLl9tYWtlU3Vic2NyaXB0aW9uKHtcbiAgICAgIGNhbGxiYWNrLFxuICAgICAgbWV0aG9kOiAnc2xvdFN1YnNjcmliZScsXG4gICAgICB1bnN1YnNjcmliZU1ldGhvZDogJ3Nsb3RVbnN1YnNjcmliZSdcbiAgICB9LCBbXSAvKiBhcmdzICovKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVyIGEgc2xvdCBub3RpZmljYXRpb24gY2FsbGJhY2tcbiAgICpcbiAgICogQHBhcmFtIGNsaWVudFN1YnNjcmlwdGlvbklkIGNsaWVudCBzdWJzY3JpcHRpb24gaWQgdG8gZGVyZWdpc3RlclxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlU2xvdENoYW5nZUxpc3RlbmVyKGNsaWVudFN1YnNjcmlwdGlvbklkKSB7XG4gICAgYXdhaXQgdGhpcy5fdW5zdWJzY3JpYmVDbGllbnRTdWJzY3JpcHRpb24oY2xpZW50U3Vic2NyaXB0aW9uSWQsICdzbG90IGNoYW5nZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3dzT25TbG90VXBkYXRlc05vdGlmaWNhdGlvbihub3RpZmljYXRpb24pIHtcbiAgICBjb25zdCB7XG4gICAgICByZXN1bHQsXG4gICAgICBzdWJzY3JpcHRpb25cbiAgICB9ID0gY3JlYXRlKG5vdGlmaWNhdGlvbiwgU2xvdFVwZGF0ZU5vdGlmaWNhdGlvblJlc3VsdCk7XG4gICAgdGhpcy5faGFuZGxlU2VydmVyTm90aWZpY2F0aW9uKHN1YnNjcmlwdGlvbiwgW3Jlc3VsdF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB1cG9uIHNsb3QgdXBkYXRlcy4ge0BsaW5rIFNsb3RVcGRhdGV9J3NcbiAgICogbWF5IGJlIHVzZWZ1bCB0byB0cmFjayBsaXZlIHByb2dyZXNzIG9mIGEgY2x1c3Rlci5cbiAgICpcbiAgICogQHBhcmFtIGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGludm9rZSB3aGVuZXZlciB0aGUgc2xvdCB1cGRhdGVzXG4gICAqIEByZXR1cm4gc3Vic2NyaXB0aW9uIGlkXG4gICAqL1xuICBvblNsb3RVcGRhdGUoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5fbWFrZVN1YnNjcmlwdGlvbih7XG4gICAgICBjYWxsYmFjayxcbiAgICAgIG1ldGhvZDogJ3Nsb3RzVXBkYXRlc1N1YnNjcmliZScsXG4gICAgICB1bnN1YnNjcmliZU1ldGhvZDogJ3Nsb3RzVXBkYXRlc1Vuc3Vic2NyaWJlJ1xuICAgIH0sIFtdIC8qIGFyZ3MgKi8pO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXIgYSBzbG90IHVwZGF0ZSBub3RpZmljYXRpb24gY2FsbGJhY2tcbiAgICpcbiAgICogQHBhcmFtIGNsaWVudFN1YnNjcmlwdGlvbklkIGNsaWVudCBzdWJzY3JpcHRpb24gaWQgdG8gZGVyZWdpc3RlclxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlU2xvdFVwZGF0ZUxpc3RlbmVyKGNsaWVudFN1YnNjcmlwdGlvbklkKSB7XG4gICAgYXdhaXQgdGhpcy5fdW5zdWJzY3JpYmVDbGllbnRTdWJzY3JpcHRpb24oY2xpZW50U3Vic2NyaXB0aW9uSWQsICdzbG90IHVwZGF0ZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuICBhc3luYyBfdW5zdWJzY3JpYmVDbGllbnRTdWJzY3JpcHRpb24oY2xpZW50U3Vic2NyaXB0aW9uSWQsIHN1YnNjcmlwdGlvbk5hbWUpIHtcbiAgICBjb25zdCBkaXNwb3NlID0gdGhpcy5fc3Vic2NyaXB0aW9uRGlzcG9zZUZ1bmN0aW9uc0J5Q2xpZW50U3Vic2NyaXB0aW9uSWRbY2xpZW50U3Vic2NyaXB0aW9uSWRdO1xuICAgIGlmIChkaXNwb3NlKSB7XG4gICAgICBhd2FpdCBkaXNwb3NlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybignSWdub3JlZCB1bnN1YnNjcmliZSByZXF1ZXN0IGJlY2F1c2UgYW4gYWN0aXZlIHN1YnNjcmlwdGlvbiB3aXRoIGlkICcgKyBgXFxgJHtjbGllbnRTdWJzY3JpcHRpb25JZH1cXGAgZm9yICcke3N1YnNjcmlwdGlvbk5hbWV9JyBldmVudHMgYCArICdjb3VsZCBub3QgYmUgZm91bmQuJyk7XG4gICAgfVxuICB9XG4gIF9idWlsZEFyZ3MoYXJncywgb3ZlcnJpZGUsIGVuY29kaW5nLCBleHRyYSkge1xuICAgIGNvbnN0IGNvbW1pdG1lbnQgPSBvdmVycmlkZSB8fCB0aGlzLl9jb21taXRtZW50O1xuICAgIGlmIChjb21taXRtZW50IHx8IGVuY29kaW5nIHx8IGV4dHJhKSB7XG4gICAgICBsZXQgb3B0aW9ucyA9IHt9O1xuICAgICAgaWYgKGVuY29kaW5nKSB7XG4gICAgICAgIG9wdGlvbnMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgICAgIH1cbiAgICAgIGlmIChjb21taXRtZW50KSB7XG4gICAgICAgIG9wdGlvbnMuY29tbWl0bWVudCA9IGNvbW1pdG1lbnQ7XG4gICAgICB9XG4gICAgICBpZiAoZXh0cmEpIHtcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24ob3B0aW9ucywgZXh0cmEpO1xuICAgICAgfVxuICAgICAgYXJncy5wdXNoKG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gYXJncztcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKGFyZ3MsIG92ZXJyaWRlLCBlbmNvZGluZywgZXh0cmEpIHtcbiAgICBjb25zdCBjb21taXRtZW50ID0gb3ZlcnJpZGUgfHwgdGhpcy5fY29tbWl0bWVudDtcbiAgICBpZiAoY29tbWl0bWVudCAmJiAhWydjb25maXJtZWQnLCAnZmluYWxpemVkJ10uaW5jbHVkZXMoY29tbWl0bWVudCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVXNpbmcgQ29ubmVjdGlvbiB3aXRoIGRlZmF1bHQgY29tbWl0bWVudDogYCcgKyB0aGlzLl9jb21taXRtZW50ICsgJ2AsIGJ1dCBtZXRob2QgcmVxdWlyZXMgYXQgbGVhc3QgYGNvbmZpcm1lZGAnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2J1aWxkQXJncyhhcmdzLCBvdmVycmlkZSwgZW5jb2RpbmcsIGV4dHJhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF93c09uU2lnbmF0dXJlTm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbikge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlc3VsdCxcbiAgICAgIHN1YnNjcmlwdGlvblxuICAgIH0gPSBjcmVhdGUobm90aWZpY2F0aW9uLCBTaWduYXR1cmVOb3RpZmljYXRpb25SZXN1bHQpO1xuICAgIGlmIChyZXN1bHQudmFsdWUgIT09ICdyZWNlaXZlZFNpZ25hdHVyZScpIHtcbiAgICAgIC8qKlxuICAgICAgICogU3BlY2lhbCBjYXNlLlxuICAgICAgICogQWZ0ZXIgYSBzaWduYXR1cmUgaXMgcHJvY2Vzc2VkLCBSUENzIGF1dG9tYXRpY2FsbHkgZGlzcG9zZSBvZiB0aGVcbiAgICAgICAqIHN1YnNjcmlwdGlvbiBvbiB0aGUgc2VydmVyIHNpZGUuIFdlIG5lZWQgdG8gdHJhY2sgd2hpY2ggb2YgdGhlc2VcbiAgICAgICAqIHN1YnNjcmlwdGlvbnMgaGF2ZSBiZWVuIGRpc3Bvc2VkIGluIHN1Y2ggYSB3YXksIHNvIHRoYXQgd2Uga25vd1xuICAgICAgICogd2hldGhlciB0aGUgY2xpZW50IGlzIGRlYWxpbmcgd2l0aCBhIG5vdC15ZXQtcHJvY2Vzc2VkIHNpZ25hdHVyZVxuICAgICAgICogKGluIHdoaWNoIGNhc2Ugd2UgbXVzdCB0ZWFyIGRvd24gdGhlIHNlcnZlciBzdWJzY3JpcHRpb24pIG9yIGFuXG4gICAgICAgKiBhbHJlYWR5LXByb2Nlc3NlZCBzaWduYXR1cmUgKGluIHdoaWNoIGNhc2UgdGhlIGNsaWVudCBjYW4gc2ltcGx5XG4gICAgICAgKiBjbGVhciBvdXQgdGhlIHN1YnNjcmlwdGlvbiBsb2NhbGx5IHdpdGhvdXQgdGVsbGluZyB0aGUgc2VydmVyKS5cbiAgICAgICAqXG4gICAgICAgKiBOT1RFOiBUaGVyZSBpcyBhIHByb3Bvc2FsIHRvIGVsaW1pbmF0ZSB0aGlzIHNwZWNpYWwgY2FzZSwgaGVyZTpcbiAgICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2xhbmEtbGFicy9zb2xhbmEvaXNzdWVzLzE4ODkyXG4gICAgICAgKi9cbiAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnNBdXRvRGlzcG9zZWRCeVJwYy5hZGQoc3Vic2NyaXB0aW9uKTtcbiAgICB9XG4gICAgdGhpcy5faGFuZGxlU2VydmVyTm90aWZpY2F0aW9uKHN1YnNjcmlwdGlvbiwgcmVzdWx0LnZhbHVlID09PSAncmVjZWl2ZWRTaWduYXR1cmUnID8gW3tcbiAgICAgIHR5cGU6ICdyZWNlaXZlZCdcbiAgICB9LCByZXN1bHQuY29udGV4dF0gOiBbe1xuICAgICAgdHlwZTogJ3N0YXR1cycsXG4gICAgICByZXN1bHQ6IHJlc3VsdC52YWx1ZVxuICAgIH0sIHJlc3VsdC5jb250ZXh0XSk7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBjYWxsYmFjayB0byBiZSBpbnZva2VkIHVwb24gc2lnbmF0dXJlIHVwZGF0ZXNcbiAgICpcbiAgICogQHBhcmFtIHNpZ25hdHVyZSBUcmFuc2FjdGlvbiBzaWduYXR1cmUgc3RyaW5nIGluIGJhc2UgNThcbiAgICogQHBhcmFtIGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGludm9rZSBvbiBzaWduYXR1cmUgbm90aWZpY2F0aW9uc1xuICAgKiBAcGFyYW0gY29tbWl0bWVudCBTcGVjaWZ5IHRoZSBjb21taXRtZW50IGxldmVsIHNpZ25hdHVyZSBtdXN0IHJlYWNoIGJlZm9yZSBub3RpZmljYXRpb25cbiAgICogQHJldHVybiBzdWJzY3JpcHRpb24gaWRcbiAgICovXG4gIG9uU2lnbmF0dXJlKHNpZ25hdHVyZSwgY2FsbGJhY2ssIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtzaWduYXR1cmVdLCBjb21taXRtZW50IHx8IHRoaXMuX2NvbW1pdG1lbnQgfHwgJ2ZpbmFsaXplZCcgLy8gQXBwbHkgY29ubmVjdGlvbi9zZXJ2ZXIgZGVmYXVsdC5cbiAgICApO1xuICAgIGNvbnN0IGNsaWVudFN1YnNjcmlwdGlvbklkID0gdGhpcy5fbWFrZVN1YnNjcmlwdGlvbih7XG4gICAgICBjYWxsYmFjazogKG5vdGlmaWNhdGlvbiwgY29udGV4dCkgPT4ge1xuICAgICAgICBpZiAobm90aWZpY2F0aW9uLnR5cGUgPT09ICdzdGF0dXMnKSB7XG4gICAgICAgICAgY2FsbGJhY2sobm90aWZpY2F0aW9uLnJlc3VsdCwgY29udGV4dCk7XG4gICAgICAgICAgLy8gU2lnbmF0dXJlcyBzdWJzY3JpcHRpb25zIGFyZSBhdXRvLXJlbW92ZWQgYnkgdGhlIFJQQyBzZXJ2aWNlXG4gICAgICAgICAgLy8gc28gbm8gbmVlZCB0byBleHBsaWNpdGx5IHNlbmQgYW4gdW5zdWJzY3JpYmUgbWVzc2FnZS5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVTaWduYXR1cmVMaXN0ZW5lcihjbGllbnRTdWJzY3JpcHRpb25JZCk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgICAgICAgICB9IGNhdGNoIChfZXJyKSB7XG4gICAgICAgICAgICAvLyBBbHJlYWR5IHJlbW92ZWQuXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbWV0aG9kOiAnc2lnbmF0dXJlU3Vic2NyaWJlJyxcbiAgICAgIHVuc3Vic2NyaWJlTWV0aG9kOiAnc2lnbmF0dXJlVW5zdWJzY3JpYmUnXG4gICAgfSwgYXJncyk7XG4gICAgcmV0dXJuIGNsaWVudFN1YnNjcmlwdGlvbklkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuIGEgdHJhbnNhY3Rpb24gaXNcbiAgICogcmVjZWl2ZWQgYW5kL29yIHByb2Nlc3NlZC5cbiAgICpcbiAgICogQHBhcmFtIHNpZ25hdHVyZSBUcmFuc2FjdGlvbiBzaWduYXR1cmUgc3RyaW5nIGluIGJhc2UgNThcbiAgICogQHBhcmFtIGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGludm9rZSBvbiBzaWduYXR1cmUgbm90aWZpY2F0aW9uc1xuICAgKiBAcGFyYW0gb3B0aW9ucyBFbmFibGUgcmVjZWl2ZWQgbm90aWZpY2F0aW9ucyBhbmQgc2V0IHRoZSBjb21taXRtZW50XG4gICAqICAgbGV2ZWwgdGhhdCBzaWduYXR1cmUgbXVzdCByZWFjaCBiZWZvcmUgbm90aWZpY2F0aW9uXG4gICAqIEByZXR1cm4gc3Vic2NyaXB0aW9uIGlkXG4gICAqL1xuICBvblNpZ25hdHVyZVdpdGhPcHRpb25zKHNpZ25hdHVyZSwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgLi4uZXh0cmFcbiAgICB9ID0ge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGNvbW1pdG1lbnQ6IG9wdGlvbnMgJiYgb3B0aW9ucy5jb21taXRtZW50IHx8IHRoaXMuX2NvbW1pdG1lbnQgfHwgJ2ZpbmFsaXplZCcgLy8gQXBwbHkgY29ubmVjdGlvbi9zZXJ2ZXIgZGVmYXVsdC5cbiAgICB9O1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3NpZ25hdHVyZV0sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLywgZXh0cmEpO1xuICAgIGNvbnN0IGNsaWVudFN1YnNjcmlwdGlvbklkID0gdGhpcy5fbWFrZVN1YnNjcmlwdGlvbih7XG4gICAgICBjYWxsYmFjazogKG5vdGlmaWNhdGlvbiwgY29udGV4dCkgPT4ge1xuICAgICAgICBjYWxsYmFjayhub3RpZmljYXRpb24sIGNvbnRleHQpO1xuICAgICAgICAvLyBTaWduYXR1cmVzIHN1YnNjcmlwdGlvbnMgYXJlIGF1dG8tcmVtb3ZlZCBieSB0aGUgUlBDIHNlcnZpY2VcbiAgICAgICAgLy8gc28gbm8gbmVlZCB0byBleHBsaWNpdGx5IHNlbmQgYW4gdW5zdWJzY3JpYmUgbWVzc2FnZS5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLnJlbW92ZVNpZ25hdHVyZUxpc3RlbmVyKGNsaWVudFN1YnNjcmlwdGlvbklkKTtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgICAgICAgfSBjYXRjaCAoX2Vycikge1xuICAgICAgICAgIC8vIEFscmVhZHkgcmVtb3ZlZC5cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG1ldGhvZDogJ3NpZ25hdHVyZVN1YnNjcmliZScsXG4gICAgICB1bnN1YnNjcmliZU1ldGhvZDogJ3NpZ25hdHVyZVVuc3Vic2NyaWJlJ1xuICAgIH0sIGFyZ3MpO1xuICAgIHJldHVybiBjbGllbnRTdWJzY3JpcHRpb25JZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVyIGEgc2lnbmF0dXJlIG5vdGlmaWNhdGlvbiBjYWxsYmFja1xuICAgKlxuICAgKiBAcGFyYW0gY2xpZW50U3Vic2NyaXB0aW9uSWQgY2xpZW50IHN1YnNjcmlwdGlvbiBpZCB0byBkZXJlZ2lzdGVyXG4gICAqL1xuICBhc3luYyByZW1vdmVTaWduYXR1cmVMaXN0ZW5lcihjbGllbnRTdWJzY3JpcHRpb25JZCkge1xuICAgIGF3YWl0IHRoaXMuX3Vuc3Vic2NyaWJlQ2xpZW50U3Vic2NyaXB0aW9uKGNsaWVudFN1YnNjcmlwdGlvbklkLCAnc2lnbmF0dXJlIHJlc3VsdCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3dzT25Sb290Tm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbikge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlc3VsdCxcbiAgICAgIHN1YnNjcmlwdGlvblxuICAgIH0gPSBjcmVhdGUobm90aWZpY2F0aW9uLCBSb290Tm90aWZpY2F0aW9uUmVzdWx0KTtcbiAgICB0aGlzLl9oYW5kbGVTZXJ2ZXJOb3RpZmljYXRpb24oc3Vic2NyaXB0aW9uLCBbcmVzdWx0XSk7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBjYWxsYmFjayB0byBiZSBpbnZva2VkIHVwb24gcm9vdCBjaGFuZ2VzXG4gICAqXG4gICAqIEBwYXJhbSBjYWxsYmFjayBGdW5jdGlvbiB0byBpbnZva2Ugd2hlbmV2ZXIgdGhlIHJvb3QgY2hhbmdlc1xuICAgKiBAcmV0dXJuIHN1YnNjcmlwdGlvbiBpZFxuICAgKi9cbiAgb25Sb290Q2hhbmdlKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuX21ha2VTdWJzY3JpcHRpb24oe1xuICAgICAgY2FsbGJhY2ssXG4gICAgICBtZXRob2Q6ICdyb290U3Vic2NyaWJlJyxcbiAgICAgIHVuc3Vic2NyaWJlTWV0aG9kOiAncm9vdFVuc3Vic2NyaWJlJ1xuICAgIH0sIFtdIC8qIGFyZ3MgKi8pO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXIgYSByb290IG5vdGlmaWNhdGlvbiBjYWxsYmFja1xuICAgKlxuICAgKiBAcGFyYW0gY2xpZW50U3Vic2NyaXB0aW9uSWQgY2xpZW50IHN1YnNjcmlwdGlvbiBpZCB0byBkZXJlZ2lzdGVyXG4gICAqL1xuICBhc3luYyByZW1vdmVSb290Q2hhbmdlTGlzdGVuZXIoY2xpZW50U3Vic2NyaXB0aW9uSWQpIHtcbiAgICBhd2FpdCB0aGlzLl91bnN1YnNjcmliZUNsaWVudFN1YnNjcmlwdGlvbihjbGllbnRTdWJzY3JpcHRpb25JZCwgJ3Jvb3QgY2hhbmdlJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBLZXlwYWlyIHNpZ25lciBpbnRlcmZhY2VcbiAqL1xuXG4vKipcbiAqIEFuIGFjY291bnQga2V5cGFpciB1c2VkIGZvciBzaWduaW5nIHRyYW5zYWN0aW9ucy5cbiAqL1xuY2xhc3MgS2V5cGFpciB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcga2V5cGFpciBpbnN0YW5jZS5cbiAgICogR2VuZXJhdGUgcmFuZG9tIGtleXBhaXIgaWYgbm8ge0BsaW5rIEVkMjU1MTlLZXlwYWlyfSBpcyBwcm92aWRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtFZDI1NTE5S2V5cGFpcn0ga2V5cGFpciBlZDI1NTE5IGtleXBhaXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGtleXBhaXIpIHtcbiAgICB0aGlzLl9rZXlwYWlyID0gdm9pZCAwO1xuICAgIHRoaXMuX2tleXBhaXIgPSBrZXlwYWlyID8/IGdlbmVyYXRlS2V5cGFpcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgbmV3IHJhbmRvbSBrZXlwYWlyXG4gICAqXG4gICAqIEByZXR1cm5zIHtLZXlwYWlyfSBLZXlwYWlyXG4gICAqL1xuICBzdGF0aWMgZ2VuZXJhdGUoKSB7XG4gICAgcmV0dXJuIG5ldyBLZXlwYWlyKGdlbmVyYXRlS2V5cGFpcigpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBrZXlwYWlyIGZyb20gYSByYXcgc2VjcmV0IGtleSBieXRlIGFycmF5LlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSB1c2VkIHRvIHJlY3JlYXRlIGEga2V5cGFpciBmcm9tIGEgcHJldmlvdXNseVxuICAgKiBnZW5lcmF0ZWQgc2VjcmV0IGtleS4gR2VuZXJhdGluZyBrZXlwYWlycyBmcm9tIGEgcmFuZG9tIHNlZWQgc2hvdWxkIGJlIGRvbmVcbiAgICogd2l0aCB0aGUge0BsaW5rIEtleXBhaXIuZnJvbVNlZWR9IG1ldGhvZC5cbiAgICpcbiAgICogQHRocm93cyBlcnJvciBpZiB0aGUgcHJvdmlkZWQgc2VjcmV0IGtleSBpcyBpbnZhbGlkIGFuZCB2YWxpZGF0aW9uIGlzIG5vdCBza2lwcGVkLlxuICAgKlxuICAgKiBAcGFyYW0gc2VjcmV0S2V5IHNlY3JldCBrZXkgYnl0ZSBhcnJheVxuICAgKiBAcGFyYW0gb3B0aW9ucyBza2lwIHNlY3JldCBrZXkgdmFsaWRhdGlvblxuICAgKlxuICAgKiBAcmV0dXJucyB7S2V5cGFpcn0gS2V5cGFpclxuICAgKi9cbiAgc3RhdGljIGZyb21TZWNyZXRLZXkoc2VjcmV0S2V5LCBvcHRpb25zKSB7XG4gICAgaWYgKHNlY3JldEtleS5ieXRlTGVuZ3RoICE9PSA2NCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgc2VjcmV0IGtleSBzaXplJyk7XG4gICAgfVxuICAgIGNvbnN0IHB1YmxpY0tleSA9IHNlY3JldEtleS5zbGljZSgzMiwgNjQpO1xuICAgIGlmICghb3B0aW9ucyB8fCAhb3B0aW9ucy5za2lwVmFsaWRhdGlvbikge1xuICAgICAgY29uc3QgcHJpdmF0ZVNjYWxhciA9IHNlY3JldEtleS5zbGljZSgwLCAzMik7XG4gICAgICBjb25zdCBjb21wdXRlZFB1YmxpY0tleSA9IGdldFB1YmxpY0tleShwcml2YXRlU2NhbGFyKTtcbiAgICAgIGZvciAobGV0IGlpID0gMDsgaWkgPCAzMjsgaWkrKykge1xuICAgICAgICBpZiAocHVibGljS2V5W2lpXSAhPT0gY29tcHV0ZWRQdWJsaWNLZXlbaWldKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcm92aWRlZCBzZWNyZXRLZXkgaXMgaW52YWxpZCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgS2V5cGFpcih7XG4gICAgICBwdWJsaWNLZXksXG4gICAgICBzZWNyZXRLZXlcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIGtleXBhaXIgZnJvbSBhIDMyIGJ5dGUgc2VlZC5cbiAgICpcbiAgICogQHBhcmFtIHNlZWQgc2VlZCBieXRlIGFycmF5XG4gICAqXG4gICAqIEByZXR1cm5zIHtLZXlwYWlyfSBLZXlwYWlyXG4gICAqL1xuICBzdGF0aWMgZnJvbVNlZWQoc2VlZCkge1xuICAgIGNvbnN0IHB1YmxpY0tleSA9IGdldFB1YmxpY0tleShzZWVkKTtcbiAgICBjb25zdCBzZWNyZXRLZXkgPSBuZXcgVWludDhBcnJheSg2NCk7XG4gICAgc2VjcmV0S2V5LnNldChzZWVkKTtcbiAgICBzZWNyZXRLZXkuc2V0KHB1YmxpY0tleSwgMzIpO1xuICAgIHJldHVybiBuZXcgS2V5cGFpcih7XG4gICAgICBwdWJsaWNLZXksXG4gICAgICBzZWNyZXRLZXlcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgcHVibGljIGtleSBmb3IgdGhpcyBrZXlwYWlyXG4gICAqXG4gICAqIEByZXR1cm5zIHtQdWJsaWNLZXl9IFB1YmxpY0tleVxuICAgKi9cbiAgZ2V0IHB1YmxpY0tleSgpIHtcbiAgICByZXR1cm4gbmV3IFB1YmxpY0tleSh0aGlzLl9rZXlwYWlyLnB1YmxpY0tleSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHJhdyBzZWNyZXQga2V5IGZvciB0aGlzIGtleXBhaXJcbiAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9IFNlY3JldCBrZXkgaW4gYW4gYXJyYXkgb2YgVWludDggYnl0ZXNcbiAgICovXG4gIGdldCBzZWNyZXRLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHRoaXMuX2tleXBhaXIuc2VjcmV0S2V5KTtcbiAgfVxufVxuXG4vKipcbiAqIEFuIGVudW1lcmF0aW9uIG9mIHZhbGlkIExvb2t1cFRhYmxlSW5zdHJ1Y3Rpb25UeXBlJ3NcbiAqL1xuXG4vKipcbiAqIEFuIGVudW1lcmF0aW9uIG9mIHZhbGlkIGFkZHJlc3MgbG9va3VwIHRhYmxlIEluc3RydWN0aW9uVHlwZSdzXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgTE9PS1VQX1RBQkxFX0lOU1RSVUNUSU9OX0xBWU9VVFMgPSBPYmplY3QuZnJlZXplKHtcbiAgQ3JlYXRlTG9va3VwVGFibGU6IHtcbiAgICBpbmRleDogMCxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIHU2NCgncmVjZW50U2xvdCcpLCBCdWZmZXJMYXlvdXQudTgoJ2J1bXBTZWVkJyldKVxuICB9LFxuICBGcmVlemVMb29rdXBUYWJsZToge1xuICAgIGluZGV4OiAxLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKV0pXG4gIH0sXG4gIEV4dGVuZExvb2t1cFRhYmxlOiB7XG4gICAgaW5kZXg6IDIsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCB1NjQoKSwgQnVmZmVyTGF5b3V0LnNlcShwdWJsaWNLZXkoKSwgQnVmZmVyTGF5b3V0Lm9mZnNldChCdWZmZXJMYXlvdXQudTMyKCksIC04KSwgJ2FkZHJlc3NlcycpXSlcbiAgfSxcbiAgRGVhY3RpdmF0ZUxvb2t1cFRhYmxlOiB7XG4gICAgaW5kZXg6IDMsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpXSlcbiAgfSxcbiAgQ2xvc2VMb29rdXBUYWJsZToge1xuICAgIGluZGV4OiA0LFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKV0pXG4gIH1cbn0pO1xuY2xhc3MgQWRkcmVzc0xvb2t1cFRhYmxlSW5zdHJ1Y3Rpb24ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHt9XG4gIHN0YXRpYyBkZWNvZGVJbnN0cnVjdGlvblR5cGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25UeXBlTGF5b3V0ID0gQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKTtcbiAgICBjb25zdCBpbmRleCA9IGluc3RydWN0aW9uVHlwZUxheW91dC5kZWNvZGUoaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgbGV0IHR5cGU7XG4gICAgZm9yIChjb25zdCBbbGF5b3V0VHlwZSwgbGF5b3V0XSBvZiBPYmplY3QuZW50cmllcyhMT09LVVBfVEFCTEVfSU5TVFJVQ1RJT05fTEFZT1VUUykpIHtcbiAgICAgIGlmIChsYXlvdXQuaW5kZXggPT0gaW5kZXgpIHtcbiAgICAgICAgdHlwZSA9IGxheW91dFR5cGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBJbnN0cnVjdGlvbi4gU2hvdWxkIGJlIGEgTG9va3VwVGFibGUgSW5zdHJ1Y3Rpb24nKTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbiAgc3RhdGljIGRlY29kZUNyZWF0ZUxvb2t1cFRhYmxlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlzTGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDQpO1xuICAgIGNvbnN0IHtcbiAgICAgIHJlY2VudFNsb3RcbiAgICB9ID0gZGVjb2RlRGF0YSQxKExPT0tVUF9UQUJMRV9JTlNUUlVDVElPTl9MQVlPVVRTLkNyZWF0ZUxvb2t1cFRhYmxlLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgYXV0aG9yaXR5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICAgIHBheWVyOiBpbnN0cnVjdGlvbi5rZXlzWzJdLnB1YmtleSxcbiAgICAgIHJlY2VudFNsb3Q6IE51bWJlcihyZWNlbnRTbG90KVxuICAgIH07XG4gIH1cbiAgc3RhdGljIGRlY29kZUV4dGVuZExvb2t1cFRhYmxlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIGlmIChpbnN0cnVjdGlvbi5rZXlzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBpbnN0cnVjdGlvbjsgZm91bmQgJHtpbnN0cnVjdGlvbi5rZXlzLmxlbmd0aH0ga2V5cywgZXhwZWN0ZWQgYXQgbGVhc3QgMmApO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBhZGRyZXNzZXNcbiAgICB9ID0gZGVjb2RlRGF0YSQxKExPT0tVUF9UQUJMRV9JTlNUUlVDVElPTl9MQVlPVVRTLkV4dGVuZExvb2t1cFRhYmxlLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgbG9va3VwVGFibGU6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYXV0aG9yaXR5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICAgIHBheWVyOiBpbnN0cnVjdGlvbi5rZXlzLmxlbmd0aCA+IDIgPyBpbnN0cnVjdGlvbi5rZXlzWzJdLnB1YmtleSA6IHVuZGVmaW5lZCxcbiAgICAgIGFkZHJlc3NlczogYWRkcmVzc2VzLm1hcChidWZmZXIgPT4gbmV3IFB1YmxpY0tleShidWZmZXIpKVxuICAgIH07XG4gIH1cbiAgc3RhdGljIGRlY29kZUNsb3NlTG9va3VwVGFibGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleXNMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvb2t1cFRhYmxlOiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGF1dGhvcml0eTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICByZWNpcGllbnQ6IGluc3RydWN0aW9uLmtleXNbMl0ucHVia2V5XG4gICAgfTtcbiAgfVxuICBzdGF0aWMgZGVjb2RlRnJlZXplTG9va3VwVGFibGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleXNMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMik7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvb2t1cFRhYmxlOiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGF1dGhvcml0eTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXlcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBkZWNvZGVEZWFjdGl2YXRlTG9va3VwVGFibGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleXNMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMik7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvb2t1cFRhYmxlOiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGF1dGhvcml0eTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXlcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc3RhdGljIGNoZWNrUHJvZ3JhbUlkKHByb2dyYW1JZCkge1xuICAgIGlmICghcHJvZ3JhbUlkLmVxdWFscyhBZGRyZXNzTG9va3VwVGFibGVQcm9ncmFtLnByb2dyYW1JZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbnN0cnVjdGlvbjsgcHJvZ3JhbUlkIGlzIG5vdCBBZGRyZXNzTG9va3VwVGFibGUgUHJvZ3JhbScpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzdGF0aWMgY2hlY2tLZXlzTGVuZ3RoKGtleXMsIGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgaWYgKGtleXMubGVuZ3RoIDwgZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBpbnN0cnVjdGlvbjsgZm91bmQgJHtrZXlzLmxlbmd0aH0ga2V5cywgZXhwZWN0ZWQgYXQgbGVhc3QgJHtleHBlY3RlZExlbmd0aH1gKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIEFkZHJlc3NMb29rdXBUYWJsZVByb2dyYW0ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHt9XG4gIHN0YXRpYyBjcmVhdGVMb29rdXBUYWJsZShwYXJhbXMpIHtcbiAgICBjb25zdCBbbG9va3VwVGFibGVBZGRyZXNzLCBidW1wU2VlZF0gPSBQdWJsaWNLZXkuZmluZFByb2dyYW1BZGRyZXNzU3luYyhbcGFyYW1zLmF1dGhvcml0eS50b0J1ZmZlcigpLCBnZXRVNjRFbmNvZGVyKCkuZW5jb2RlKHBhcmFtcy5yZWNlbnRTbG90KV0sIHRoaXMucHJvZ3JhbUlkKTtcbiAgICBjb25zdCB0eXBlID0gTE9PS1VQX1RBQkxFX0lOU1RSVUNUSU9OX0xBWU9VVFMuQ3JlYXRlTG9va3VwVGFibGU7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgcmVjZW50U2xvdDogQmlnSW50KHBhcmFtcy5yZWNlbnRTbG90KSxcbiAgICAgIGJ1bXBTZWVkOiBidW1wU2VlZFxuICAgIH0pO1xuICAgIGNvbnN0IGtleXMgPSBbe1xuICAgICAgcHVia2V5OiBsb29rdXBUYWJsZUFkZHJlc3MsXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBwYXJhbXMuYXV0aG9yaXR5LFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogcGFyYW1zLnBheWVyLFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBTeXN0ZW1Qcm9ncmFtLnByb2dyYW1JZCxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfV07XG4gICAgcmV0dXJuIFtuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAga2V5czoga2V5cyxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KSwgbG9va3VwVGFibGVBZGRyZXNzXTtcbiAgfVxuICBzdGF0aWMgZnJlZXplTG9va3VwVGFibGUocGFyYW1zKSB7XG4gICAgY29uc3QgdHlwZSA9IExPT0tVUF9UQUJMRV9JTlNUUlVDVElPTl9MQVlPVVRTLkZyZWV6ZUxvb2t1cFRhYmxlO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUpO1xuICAgIGNvbnN0IGtleXMgPSBbe1xuICAgICAgcHVia2V5OiBwYXJhbXMubG9va3VwVGFibGUsXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBwYXJhbXMuYXV0aG9yaXR5LFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH1dO1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAga2V5czoga2V5cyxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZXh0ZW5kTG9va3VwVGFibGUocGFyYW1zKSB7XG4gICAgY29uc3QgdHlwZSA9IExPT0tVUF9UQUJMRV9JTlNUUlVDVElPTl9MQVlPVVRTLkV4dGVuZExvb2t1cFRhYmxlO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIGFkZHJlc3NlczogcGFyYW1zLmFkZHJlc3Nlcy5tYXAoYWRkciA9PiBhZGRyLnRvQnl0ZXMoKSlcbiAgICB9KTtcbiAgICBjb25zdCBrZXlzID0gW3tcbiAgICAgIHB1YmtleTogcGFyYW1zLmxvb2t1cFRhYmxlLFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogcGFyYW1zLmF1dGhvcml0eSxcbiAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9XTtcbiAgICBpZiAocGFyYW1zLnBheWVyKSB7XG4gICAgICBrZXlzLnB1c2goe1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5wYXllcixcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBTeXN0ZW1Qcm9ncmFtLnByb2dyYW1JZCxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAga2V5czoga2V5cyxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZGVhY3RpdmF0ZUxvb2t1cFRhYmxlKHBhcmFtcykge1xuICAgIGNvbnN0IHR5cGUgPSBMT09LVVBfVEFCTEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5EZWFjdGl2YXRlTG9va3VwVGFibGU7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSk7XG4gICAgY29uc3Qga2V5cyA9IFt7XG4gICAgICBwdWJrZXk6IHBhcmFtcy5sb29rdXBUYWJsZSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IHBhcmFtcy5hdXRob3JpdHksXG4gICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfV07XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBrZXlzOiBrZXlzLFxuICAgICAgZGF0YTogZGF0YVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBjbG9zZUxvb2t1cFRhYmxlKHBhcmFtcykge1xuICAgIGNvbnN0IHR5cGUgPSBMT09LVVBfVEFCTEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5DbG9zZUxvb2t1cFRhYmxlO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUpO1xuICAgIGNvbnN0IGtleXMgPSBbe1xuICAgICAgcHVia2V5OiBwYXJhbXMubG9va3VwVGFibGUsXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBwYXJhbXMuYXV0aG9yaXR5LFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogcGFyYW1zLnJlY2lwaWVudCxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9XTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGtleXM6IGtleXMsXG4gICAgICBkYXRhOiBkYXRhXG4gICAgfSk7XG4gIH1cbn1cbkFkZHJlc3NMb29rdXBUYWJsZVByb2dyYW0ucHJvZ3JhbUlkID0gbmV3IFB1YmxpY0tleSgnQWRkcmVzc0xvb2t1cFRhYjFlMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuXG4vKipcbiAqIENvbXB1dGUgQnVkZ2V0IEluc3RydWN0aW9uIGNsYXNzXG4gKi9cbmNsYXNzIENvbXB1dGVCdWRnZXRJbnN0cnVjdGlvbiB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge31cblxuICAvKipcbiAgICogRGVjb2RlIGEgY29tcHV0ZSBidWRnZXQgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiB0eXBlLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZUluc3RydWN0aW9uVHlwZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICBjb25zdCBpbnN0cnVjdGlvblR5cGVMYXlvdXQgPSBCdWZmZXJMYXlvdXQudTgoJ2luc3RydWN0aW9uJyk7XG4gICAgY29uc3QgdHlwZUluZGV4ID0gaW5zdHJ1Y3Rpb25UeXBlTGF5b3V0LmRlY29kZShpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICBsZXQgdHlwZTtcbiAgICBmb3IgKGNvbnN0IFtpeFR5cGUsIGxheW91dF0gb2YgT2JqZWN0LmVudHJpZXMoQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUykpIHtcbiAgICAgIGlmIChsYXlvdXQuaW5kZXggPT0gdHlwZUluZGV4KSB7XG4gICAgICAgIHR5cGUgPSBpeFR5cGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5zdHJ1Y3Rpb24gdHlwZSBpbmNvcnJlY3Q7IG5vdCBhIENvbXB1dGVCdWRnZXRJbnN0cnVjdGlvbicpO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgcmVxdWVzdCB1bml0cyBjb21wdXRlIGJ1ZGdldCBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVSZXF1ZXN0VW5pdHMoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgY29uc3Qge1xuICAgICAgdW5pdHMsXG4gICAgICBhZGRpdGlvbmFsRmVlXG4gICAgfSA9IGRlY29kZURhdGEkMShDT01QVVRFX0JVREdFVF9JTlNUUlVDVElPTl9MQVlPVVRTLlJlcXVlc3RVbml0cywgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVuaXRzLFxuICAgICAgYWRkaXRpb25hbEZlZVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIHJlcXVlc3QgaGVhcCBmcmFtZSBjb21wdXRlIGJ1ZGdldCBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVSZXF1ZXN0SGVhcEZyYW1lKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIGNvbnN0IHtcbiAgICAgIGJ5dGVzXG4gICAgfSA9IGRlY29kZURhdGEkMShDT01QVVRFX0JVREdFVF9JTlNUUlVDVElPTl9MQVlPVVRTLlJlcXVlc3RIZWFwRnJhbWUsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBieXRlc1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIHNldCBjb21wdXRlIHVuaXQgbGltaXQgY29tcHV0ZSBidWRnZXQgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlU2V0Q29tcHV0ZVVuaXRMaW1pdChpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICBjb25zdCB7XG4gICAgICB1bml0c1xuICAgIH0gPSBkZWNvZGVEYXRhJDEoQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUy5TZXRDb21wdXRlVW5pdExpbWl0LCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgdW5pdHNcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBzZXQgY29tcHV0ZSB1bml0IHByaWNlIGNvbXB1dGUgYnVkZ2V0IGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZVNldENvbXB1dGVVbml0UHJpY2UoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgY29uc3Qge1xuICAgICAgbWljcm9MYW1wb3J0c1xuICAgIH0gPSBkZWNvZGVEYXRhJDEoQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUy5TZXRDb21wdXRlVW5pdFByaWNlLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgbWljcm9MYW1wb3J0c1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzdGF0aWMgY2hlY2tQcm9ncmFtSWQocHJvZ3JhbUlkKSB7XG4gICAgaWYgKCFwcm9ncmFtSWQuZXF1YWxzKENvbXB1dGVCdWRnZXRQcm9ncmFtLnByb2dyYW1JZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbnN0cnVjdGlvbjsgcHJvZ3JhbUlkIGlzIG5vdCBDb21wdXRlQnVkZ2V0UHJvZ3JhbScpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFuIGVudW1lcmF0aW9uIG9mIHZhbGlkIENvbXB1dGVCdWRnZXRJbnN0cnVjdGlvblR5cGUnc1xuICovXG5cbi8qKlxuICogUmVxdWVzdCB1bml0cyBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIFJlcXVlc3QgaGVhcCBmcmFtZSBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIFNldCBjb21wdXRlIHVuaXQgbGltaXQgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBTZXQgY29tcHV0ZSB1bml0IHByaWNlIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogQW4gZW51bWVyYXRpb24gb2YgdmFsaWQgQ29tcHV0ZUJ1ZGdldCBJbnN0cnVjdGlvblR5cGUnc1xuICogQGludGVybmFsXG4gKi9cbmNvbnN0IENPTVBVVEVfQlVER0VUX0lOU1RSVUNUSU9OX0xBWU9VVFMgPSBPYmplY3QuZnJlZXplKHtcbiAgUmVxdWVzdFVuaXRzOiB7XG4gICAgaW5kZXg6IDAsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTgoJ2luc3RydWN0aW9uJyksIEJ1ZmZlckxheW91dC51MzIoJ3VuaXRzJyksIEJ1ZmZlckxheW91dC51MzIoJ2FkZGl0aW9uYWxGZWUnKV0pXG4gIH0sXG4gIFJlcXVlc3RIZWFwRnJhbWU6IHtcbiAgICBpbmRleDogMSxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51OCgnaW5zdHJ1Y3Rpb24nKSwgQnVmZmVyTGF5b3V0LnUzMignYnl0ZXMnKV0pXG4gIH0sXG4gIFNldENvbXB1dGVVbml0TGltaXQ6IHtcbiAgICBpbmRleDogMixcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51OCgnaW5zdHJ1Y3Rpb24nKSwgQnVmZmVyTGF5b3V0LnUzMigndW5pdHMnKV0pXG4gIH0sXG4gIFNldENvbXB1dGVVbml0UHJpY2U6IHtcbiAgICBpbmRleDogMyxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51OCgnaW5zdHJ1Y3Rpb24nKSwgdTY0KCdtaWNyb0xhbXBvcnRzJyldKVxuICB9XG59KTtcblxuLyoqXG4gKiBGYWN0b3J5IGNsYXNzIGZvciB0cmFuc2FjdGlvbiBpbnN0cnVjdGlvbnMgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgQ29tcHV0ZSBCdWRnZXQgcHJvZ3JhbVxuICovXG5jbGFzcyBDb21wdXRlQnVkZ2V0UHJvZ3JhbSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge31cblxuICAvKipcbiAgICogUHVibGljIGtleSB0aGF0IGlkZW50aWZpZXMgdGhlIENvbXB1dGUgQnVkZ2V0IHByb2dyYW1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIEluc3RlYWQsIGNhbGwge0BsaW5rIHNldENvbXB1dGVVbml0TGltaXR9IGFuZC9vciB7QGxpbmsgc2V0Q29tcHV0ZVVuaXRQcmljZX1cbiAgICovXG4gIHN0YXRpYyByZXF1ZXN0VW5pdHMocGFyYW1zKSB7XG4gICAgY29uc3QgdHlwZSA9IENPTVBVVEVfQlVER0VUX0lOU1RSVUNUSU9OX0xBWU9VVFMuUmVxdWVzdFVuaXRzO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHBhcmFtcyk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXM6IFtdLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgcmVxdWVzdEhlYXBGcmFtZShwYXJhbXMpIHtcbiAgICBjb25zdCB0eXBlID0gQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUy5SZXF1ZXN0SGVhcEZyYW1lO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHBhcmFtcyk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXM6IFtdLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgc2V0Q29tcHV0ZVVuaXRMaW1pdChwYXJhbXMpIHtcbiAgICBjb25zdCB0eXBlID0gQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUy5TZXRDb21wdXRlVW5pdExpbWl0O1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHBhcmFtcyk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXM6IFtdLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgc2V0Q29tcHV0ZVVuaXRQcmljZShwYXJhbXMpIHtcbiAgICBjb25zdCB0eXBlID0gQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUy5TZXRDb21wdXRlVW5pdFByaWNlO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIG1pY3JvTGFtcG9ydHM6IEJpZ0ludChwYXJhbXMubWljcm9MYW1wb3J0cylcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5czogW10sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG59XG5Db21wdXRlQnVkZ2V0UHJvZ3JhbS5wcm9ncmFtSWQgPSBuZXcgUHVibGljS2V5KCdDb21wdXRlQnVkZ2V0MTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5cbmNvbnN0IFBSSVZBVEVfS0VZX0JZVEVTJDEgPSA2NDtcbmNvbnN0IFBVQkxJQ19LRVlfQllURVMkMSA9IDMyO1xuY29uc3QgU0lHTkFUVVJFX0JZVEVTID0gNjQ7XG5cbi8qKlxuICogUGFyYW1zIGZvciBjcmVhdGluZyBhbiBlZDI1NTE5IGluc3RydWN0aW9uIHVzaW5nIGEgcHVibGljIGtleVxuICovXG5cbi8qKlxuICogUGFyYW1zIGZvciBjcmVhdGluZyBhbiBlZDI1NTE5IGluc3RydWN0aW9uIHVzaW5nIGEgcHJpdmF0ZSBrZXlcbiAqL1xuXG5jb25zdCBFRDI1NTE5X0lOU1RSVUNUSU9OX0xBWU9VVCA9IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51OCgnbnVtU2lnbmF0dXJlcycpLCBCdWZmZXJMYXlvdXQudTgoJ3BhZGRpbmcnKSwgQnVmZmVyTGF5b3V0LnUxNignc2lnbmF0dXJlT2Zmc2V0JyksIEJ1ZmZlckxheW91dC51MTYoJ3NpZ25hdHVyZUluc3RydWN0aW9uSW5kZXgnKSwgQnVmZmVyTGF5b3V0LnUxNigncHVibGljS2V5T2Zmc2V0JyksIEJ1ZmZlckxheW91dC51MTYoJ3B1YmxpY0tleUluc3RydWN0aW9uSW5kZXgnKSwgQnVmZmVyTGF5b3V0LnUxNignbWVzc2FnZURhdGFPZmZzZXQnKSwgQnVmZmVyTGF5b3V0LnUxNignbWVzc2FnZURhdGFTaXplJyksIEJ1ZmZlckxheW91dC51MTYoJ21lc3NhZ2VJbnN0cnVjdGlvbkluZGV4JyldKTtcbmNsYXNzIEVkMjU1MTlQcm9ncmFtIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7fVxuXG4gIC8qKlxuICAgKiBQdWJsaWMga2V5IHRoYXQgaWRlbnRpZmllcyB0aGUgZWQyNTUxOSBwcm9ncmFtXG4gICAqL1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gZWQyNTUxOSBpbnN0cnVjdGlvbiB3aXRoIGEgcHVibGljIGtleSBhbmQgc2lnbmF0dXJlLiBUaGVcbiAgICogcHVibGljIGtleSBtdXN0IGJlIGEgYnVmZmVyIHRoYXQgaXMgMzIgYnl0ZXMgbG9uZywgYW5kIHRoZSBzaWduYXR1cmVcbiAgICogbXVzdCBiZSBhIGJ1ZmZlciBvZiA2NCBieXRlcy5cbiAgICovXG4gIHN0YXRpYyBjcmVhdGVJbnN0cnVjdGlvbldpdGhQdWJsaWNLZXkocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgcHVibGljS2V5LFxuICAgICAgbWVzc2FnZSxcbiAgICAgIHNpZ25hdHVyZSxcbiAgICAgIGluc3RydWN0aW9uSW5kZXhcbiAgICB9ID0gcGFyYW1zO1xuICAgIGFzc2VydChwdWJsaWNLZXkubGVuZ3RoID09PSBQVUJMSUNfS0VZX0JZVEVTJDEsIGBQdWJsaWMgS2V5IG11c3QgYmUgJHtQVUJMSUNfS0VZX0JZVEVTJDF9IGJ5dGVzIGJ1dCByZWNlaXZlZCAke3B1YmxpY0tleS5sZW5ndGh9IGJ5dGVzYCk7XG4gICAgYXNzZXJ0KHNpZ25hdHVyZS5sZW5ndGggPT09IFNJR05BVFVSRV9CWVRFUywgYFNpZ25hdHVyZSBtdXN0IGJlICR7U0lHTkFUVVJFX0JZVEVTfSBieXRlcyBidXQgcmVjZWl2ZWQgJHtzaWduYXR1cmUubGVuZ3RofSBieXRlc2ApO1xuICAgIGNvbnN0IHB1YmxpY0tleU9mZnNldCA9IEVEMjU1MTlfSU5TVFJVQ1RJT05fTEFZT1VULnNwYW47XG4gICAgY29uc3Qgc2lnbmF0dXJlT2Zmc2V0ID0gcHVibGljS2V5T2Zmc2V0ICsgcHVibGljS2V5Lmxlbmd0aDtcbiAgICBjb25zdCBtZXNzYWdlRGF0YU9mZnNldCA9IHNpZ25hdHVyZU9mZnNldCArIHNpZ25hdHVyZS5sZW5ndGg7XG4gICAgY29uc3QgbnVtU2lnbmF0dXJlcyA9IDE7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25EYXRhID0gQnVmZmVyLmFsbG9jKG1lc3NhZ2VEYXRhT2Zmc2V0ICsgbWVzc2FnZS5sZW5ndGgpO1xuICAgIGNvbnN0IGluZGV4ID0gaW5zdHJ1Y3Rpb25JbmRleCA9PSBudWxsID8gMHhmZmZmIC8vIEFuIGluZGV4IG9mIGB1MTY6Ok1BWGAgbWFrZXMgaXQgZGVmYXVsdCB0byB0aGUgY3VycmVudCBpbnN0cnVjdGlvbi5cbiAgICA6IGluc3RydWN0aW9uSW5kZXg7XG4gICAgRUQyNTUxOV9JTlNUUlVDVElPTl9MQVlPVVQuZW5jb2RlKHtcbiAgICAgIG51bVNpZ25hdHVyZXMsXG4gICAgICBwYWRkaW5nOiAwLFxuICAgICAgc2lnbmF0dXJlT2Zmc2V0LFxuICAgICAgc2lnbmF0dXJlSW5zdHJ1Y3Rpb25JbmRleDogaW5kZXgsXG4gICAgICBwdWJsaWNLZXlPZmZzZXQsXG4gICAgICBwdWJsaWNLZXlJbnN0cnVjdGlvbkluZGV4OiBpbmRleCxcbiAgICAgIG1lc3NhZ2VEYXRhT2Zmc2V0LFxuICAgICAgbWVzc2FnZURhdGFTaXplOiBtZXNzYWdlLmxlbmd0aCxcbiAgICAgIG1lc3NhZ2VJbnN0cnVjdGlvbkluZGV4OiBpbmRleFxuICAgIH0sIGluc3RydWN0aW9uRGF0YSk7XG4gICAgaW5zdHJ1Y3Rpb25EYXRhLmZpbGwocHVibGljS2V5LCBwdWJsaWNLZXlPZmZzZXQpO1xuICAgIGluc3RydWN0aW9uRGF0YS5maWxsKHNpZ25hdHVyZSwgc2lnbmF0dXJlT2Zmc2V0KTtcbiAgICBpbnN0cnVjdGlvbkRhdGEuZmlsbChtZXNzYWdlLCBtZXNzYWdlRGF0YU9mZnNldCk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXM6IFtdLFxuICAgICAgcHJvZ3JhbUlkOiBFZDI1NTE5UHJvZ3JhbS5wcm9ncmFtSWQsXG4gICAgICBkYXRhOiBpbnN0cnVjdGlvbkRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gZWQyNTUxOSBpbnN0cnVjdGlvbiB3aXRoIGEgcHJpdmF0ZSBrZXkuIFRoZSBwcml2YXRlIGtleVxuICAgKiBtdXN0IGJlIGEgYnVmZmVyIHRoYXQgaXMgNjQgYnl0ZXMgbG9uZy5cbiAgICovXG4gIHN0YXRpYyBjcmVhdGVJbnN0cnVjdGlvbldpdGhQcml2YXRlS2V5KHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHByaXZhdGVLZXksXG4gICAgICBtZXNzYWdlLFxuICAgICAgaW5zdHJ1Y3Rpb25JbmRleFxuICAgIH0gPSBwYXJhbXM7XG4gICAgYXNzZXJ0KHByaXZhdGVLZXkubGVuZ3RoID09PSBQUklWQVRFX0tFWV9CWVRFUyQxLCBgUHJpdmF0ZSBrZXkgbXVzdCBiZSAke1BSSVZBVEVfS0VZX0JZVEVTJDF9IGJ5dGVzIGJ1dCByZWNlaXZlZCAke3ByaXZhdGVLZXkubGVuZ3RofSBieXRlc2ApO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBrZXlwYWlyID0gS2V5cGFpci5mcm9tU2VjcmV0S2V5KHByaXZhdGVLZXkpO1xuICAgICAgY29uc3QgcHVibGljS2V5ID0ga2V5cGFpci5wdWJsaWNLZXkudG9CeXRlcygpO1xuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gc2lnbihtZXNzYWdlLCBrZXlwYWlyLnNlY3JldEtleSk7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVJbnN0cnVjdGlvbldpdGhQdWJsaWNLZXkoe1xuICAgICAgICBwdWJsaWNLZXksXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgaW5zdHJ1Y3Rpb25JbmRleFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgY3JlYXRpbmcgaW5zdHJ1Y3Rpb247ICR7ZXJyb3J9YCk7XG4gICAgfVxuICB9XG59XG5FZDI1NTE5UHJvZ3JhbS5wcm9ncmFtSWQgPSBuZXcgUHVibGljS2V5KCdFZDI1NTE5U2lnVmVyaWZ5MTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5cbmNvbnN0IGVjZHNhU2lnbiA9IChtc2dIYXNoLCBwcml2S2V5KSA9PiB7XG4gIGNvbnN0IHNpZ25hdHVyZSA9IHNlY3AyNTZrMS5zaWduKG1zZ0hhc2gsIHByaXZLZXkpO1xuICByZXR1cm4gW3NpZ25hdHVyZS50b0NvbXBhY3RSYXdCeXRlcygpLCBzaWduYXR1cmUucmVjb3ZlcnldO1xufTtcbnNlY3AyNTZrMS51dGlscy5pc1ZhbGlkUHJpdmF0ZUtleTtcbmNvbnN0IHB1YmxpY0tleUNyZWF0ZSA9IHNlY3AyNTZrMS5nZXRQdWJsaWNLZXk7XG5cbmNvbnN0IFBSSVZBVEVfS0VZX0JZVEVTID0gMzI7XG5jb25zdCBFVEhFUkVVTV9BRERSRVNTX0JZVEVTID0gMjA7XG5jb25zdCBQVUJMSUNfS0VZX0JZVEVTID0gNjQ7XG5jb25zdCBTSUdOQVRVUkVfT0ZGU0VUU19TRVJJQUxJWkVEX1NJWkUgPSAxMTtcblxuLyoqXG4gKiBQYXJhbXMgZm9yIGNyZWF0aW5nIGFuIHNlY3AyNTZrMSBpbnN0cnVjdGlvbiB1c2luZyBhIHB1YmxpYyBrZXlcbiAqL1xuXG4vKipcbiAqIFBhcmFtcyBmb3IgY3JlYXRpbmcgYW4gc2VjcDI1NmsxIGluc3RydWN0aW9uIHVzaW5nIGFuIEV0aGVyZXVtIGFkZHJlc3NcbiAqL1xuXG4vKipcbiAqIFBhcmFtcyBmb3IgY3JlYXRpbmcgYW4gc2VjcDI1NmsxIGluc3RydWN0aW9uIHVzaW5nIGEgcHJpdmF0ZSBrZXlcbiAqL1xuXG5jb25zdCBTRUNQMjU2SzFfSU5TVFJVQ1RJT05fTEFZT1VUID0gQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnU4KCdudW1TaWduYXR1cmVzJyksIEJ1ZmZlckxheW91dC51MTYoJ3NpZ25hdHVyZU9mZnNldCcpLCBCdWZmZXJMYXlvdXQudTgoJ3NpZ25hdHVyZUluc3RydWN0aW9uSW5kZXgnKSwgQnVmZmVyTGF5b3V0LnUxNignZXRoQWRkcmVzc09mZnNldCcpLCBCdWZmZXJMYXlvdXQudTgoJ2V0aEFkZHJlc3NJbnN0cnVjdGlvbkluZGV4JyksIEJ1ZmZlckxheW91dC51MTYoJ21lc3NhZ2VEYXRhT2Zmc2V0JyksIEJ1ZmZlckxheW91dC51MTYoJ21lc3NhZ2VEYXRhU2l6ZScpLCBCdWZmZXJMYXlvdXQudTgoJ21lc3NhZ2VJbnN0cnVjdGlvbkluZGV4JyksIEJ1ZmZlckxheW91dC5ibG9iKDIwLCAnZXRoQWRkcmVzcycpLCBCdWZmZXJMYXlvdXQuYmxvYig2NCwgJ3NpZ25hdHVyZScpLCBCdWZmZXJMYXlvdXQudTgoJ3JlY292ZXJ5SWQnKV0pO1xuY2xhc3MgU2VjcDI1NmsxUHJvZ3JhbSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge31cblxuICAvKipcbiAgICogUHVibGljIGtleSB0aGF0IGlkZW50aWZpZXMgdGhlIHNlY3AyNTZrMSBwcm9ncmFtXG4gICAqL1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYW4gRXRoZXJldW0gYWRkcmVzcyBmcm9tIGEgc2VjcDI1NmsxIHB1YmxpYyBrZXkgYnVmZmVyLlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gcHVibGljS2V5IGEgNjQgYnl0ZSBzZWNwMjU2azEgcHVibGljIGtleSBidWZmZXJcbiAgICovXG4gIHN0YXRpYyBwdWJsaWNLZXlUb0V0aEFkZHJlc3MocHVibGljS2V5KSB7XG4gICAgYXNzZXJ0KHB1YmxpY0tleS5sZW5ndGggPT09IFBVQkxJQ19LRVlfQllURVMsIGBQdWJsaWMga2V5IG11c3QgYmUgJHtQVUJMSUNfS0VZX0JZVEVTfSBieXRlcyBidXQgcmVjZWl2ZWQgJHtwdWJsaWNLZXkubGVuZ3RofSBieXRlc2ApO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20oa2VjY2FrXzI1Nih0b0J1ZmZlcihwdWJsaWNLZXkpKSkuc2xpY2UoLUVUSEVSRVVNX0FERFJFU1NfQllURVMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGNvbnN0cnVjdGluZyBFdGhlcmV1bSBhZGRyZXNzOiAke2Vycm9yfWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gc2VjcDI1NmsxIGluc3RydWN0aW9uIHdpdGggYSBwdWJsaWMga2V5LiBUaGUgcHVibGljIGtleVxuICAgKiBtdXN0IGJlIGEgYnVmZmVyIHRoYXQgaXMgNjQgYnl0ZXMgbG9uZy5cbiAgICovXG4gIHN0YXRpYyBjcmVhdGVJbnN0cnVjdGlvbldpdGhQdWJsaWNLZXkocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgcHVibGljS2V5LFxuICAgICAgbWVzc2FnZSxcbiAgICAgIHNpZ25hdHVyZSxcbiAgICAgIHJlY292ZXJ5SWQsXG4gICAgICBpbnN0cnVjdGlvbkluZGV4XG4gICAgfSA9IHBhcmFtcztcbiAgICByZXR1cm4gU2VjcDI1NmsxUHJvZ3JhbS5jcmVhdGVJbnN0cnVjdGlvbldpdGhFdGhBZGRyZXNzKHtcbiAgICAgIGV0aEFkZHJlc3M6IFNlY3AyNTZrMVByb2dyYW0ucHVibGljS2V5VG9FdGhBZGRyZXNzKHB1YmxpY0tleSksXG4gICAgICBtZXNzYWdlLFxuICAgICAgc2lnbmF0dXJlLFxuICAgICAgcmVjb3ZlcnlJZCxcbiAgICAgIGluc3RydWN0aW9uSW5kZXhcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gc2VjcDI1NmsxIGluc3RydWN0aW9uIHdpdGggYW4gRXRoZXJldW0gYWRkcmVzcy4gVGhlIGFkZHJlc3NcbiAgICogbXVzdCBiZSBhIGhleCBzdHJpbmcgb3IgYSBidWZmZXIgdGhhdCBpcyAyMCBieXRlcyBsb25nLlxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUluc3RydWN0aW9uV2l0aEV0aEFkZHJlc3MocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgZXRoQWRkcmVzczogcmF3QWRkcmVzcyxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBzaWduYXR1cmUsXG4gICAgICByZWNvdmVyeUlkLFxuICAgICAgaW5zdHJ1Y3Rpb25JbmRleCA9IDBcbiAgICB9ID0gcGFyYW1zO1xuICAgIGxldCBldGhBZGRyZXNzO1xuICAgIGlmICh0eXBlb2YgcmF3QWRkcmVzcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChyYXdBZGRyZXNzLnN0YXJ0c1dpdGgoJzB4JykpIHtcbiAgICAgICAgZXRoQWRkcmVzcyA9IEJ1ZmZlci5mcm9tKHJhd0FkZHJlc3Muc3Vic3RyKDIpLCAnaGV4Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBldGhBZGRyZXNzID0gQnVmZmVyLmZyb20ocmF3QWRkcmVzcywgJ2hleCcpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBldGhBZGRyZXNzID0gcmF3QWRkcmVzcztcbiAgICB9XG4gICAgYXNzZXJ0KGV0aEFkZHJlc3MubGVuZ3RoID09PSBFVEhFUkVVTV9BRERSRVNTX0JZVEVTLCBgQWRkcmVzcyBtdXN0IGJlICR7RVRIRVJFVU1fQUREUkVTU19CWVRFU30gYnl0ZXMgYnV0IHJlY2VpdmVkICR7ZXRoQWRkcmVzcy5sZW5ndGh9IGJ5dGVzYCk7XG4gICAgY29uc3QgZGF0YVN0YXJ0ID0gMSArIFNJR05BVFVSRV9PRkZTRVRTX1NFUklBTElaRURfU0laRTtcbiAgICBjb25zdCBldGhBZGRyZXNzT2Zmc2V0ID0gZGF0YVN0YXJ0O1xuICAgIGNvbnN0IHNpZ25hdHVyZU9mZnNldCA9IGRhdGFTdGFydCArIGV0aEFkZHJlc3MubGVuZ3RoO1xuICAgIGNvbnN0IG1lc3NhZ2VEYXRhT2Zmc2V0ID0gc2lnbmF0dXJlT2Zmc2V0ICsgc2lnbmF0dXJlLmxlbmd0aCArIDE7XG4gICAgY29uc3QgbnVtU2lnbmF0dXJlcyA9IDE7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25EYXRhID0gQnVmZmVyLmFsbG9jKFNFQ1AyNTZLMV9JTlNUUlVDVElPTl9MQVlPVVQuc3BhbiArIG1lc3NhZ2UubGVuZ3RoKTtcbiAgICBTRUNQMjU2SzFfSU5TVFJVQ1RJT05fTEFZT1VULmVuY29kZSh7XG4gICAgICBudW1TaWduYXR1cmVzLFxuICAgICAgc2lnbmF0dXJlT2Zmc2V0LFxuICAgICAgc2lnbmF0dXJlSW5zdHJ1Y3Rpb25JbmRleDogaW5zdHJ1Y3Rpb25JbmRleCxcbiAgICAgIGV0aEFkZHJlc3NPZmZzZXQsXG4gICAgICBldGhBZGRyZXNzSW5zdHJ1Y3Rpb25JbmRleDogaW5zdHJ1Y3Rpb25JbmRleCxcbiAgICAgIG1lc3NhZ2VEYXRhT2Zmc2V0LFxuICAgICAgbWVzc2FnZURhdGFTaXplOiBtZXNzYWdlLmxlbmd0aCxcbiAgICAgIG1lc3NhZ2VJbnN0cnVjdGlvbkluZGV4OiBpbnN0cnVjdGlvbkluZGV4LFxuICAgICAgc2lnbmF0dXJlOiB0b0J1ZmZlcihzaWduYXR1cmUpLFxuICAgICAgZXRoQWRkcmVzczogdG9CdWZmZXIoZXRoQWRkcmVzcyksXG4gICAgICByZWNvdmVyeUlkXG4gICAgfSwgaW5zdHJ1Y3Rpb25EYXRhKTtcbiAgICBpbnN0cnVjdGlvbkRhdGEuZmlsbCh0b0J1ZmZlcihtZXNzYWdlKSwgU0VDUDI1NksxX0lOU1RSVUNUSU9OX0xBWU9VVC5zcGFuKTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5czogW10sXG4gICAgICBwcm9ncmFtSWQ6IFNlY3AyNTZrMVByb2dyYW0ucHJvZ3JhbUlkLFxuICAgICAgZGF0YTogaW5zdHJ1Y3Rpb25EYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIHNlY3AyNTZrMSBpbnN0cnVjdGlvbiB3aXRoIGEgcHJpdmF0ZSBrZXkuIFRoZSBwcml2YXRlIGtleVxuICAgKiBtdXN0IGJlIGEgYnVmZmVyIHRoYXQgaXMgMzIgYnl0ZXMgbG9uZy5cbiAgICovXG4gIHN0YXRpYyBjcmVhdGVJbnN0cnVjdGlvbldpdGhQcml2YXRlS2V5KHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHByaXZhdGVLZXk6IHBrZXksXG4gICAgICBtZXNzYWdlLFxuICAgICAgaW5zdHJ1Y3Rpb25JbmRleFxuICAgIH0gPSBwYXJhbXM7XG4gICAgYXNzZXJ0KHBrZXkubGVuZ3RoID09PSBQUklWQVRFX0tFWV9CWVRFUywgYFByaXZhdGUga2V5IG11c3QgYmUgJHtQUklWQVRFX0tFWV9CWVRFU30gYnl0ZXMgYnV0IHJlY2VpdmVkICR7cGtleS5sZW5ndGh9IGJ5dGVzYCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHByaXZhdGVLZXkgPSB0b0J1ZmZlcihwa2V5KTtcbiAgICAgIGNvbnN0IHB1YmxpY0tleSA9IHB1YmxpY0tleUNyZWF0ZShwcml2YXRlS2V5LCBmYWxzZSAvKiBpc0NvbXByZXNzZWQgKi8pLnNsaWNlKDEpOyAvLyB0aHJvdyBhd2F5IGxlYWRpbmcgYnl0ZVxuICAgICAgY29uc3QgbWVzc2FnZUhhc2ggPSBCdWZmZXIuZnJvbShrZWNjYWtfMjU2KHRvQnVmZmVyKG1lc3NhZ2UpKSk7XG4gICAgICBjb25zdCBbc2lnbmF0dXJlLCByZWNvdmVyeUlkXSA9IGVjZHNhU2lnbihtZXNzYWdlSGFzaCwgcHJpdmF0ZUtleSk7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVJbnN0cnVjdGlvbldpdGhQdWJsaWNLZXkoe1xuICAgICAgICBwdWJsaWNLZXksXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgcmVjb3ZlcnlJZCxcbiAgICAgICAgaW5zdHJ1Y3Rpb25JbmRleFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgY3JlYXRpbmcgaW5zdHJ1Y3Rpb247ICR7ZXJyb3J9YCk7XG4gICAgfVxuICB9XG59XG5TZWNwMjU2azFQcm9ncmFtLnByb2dyYW1JZCA9IG5ldyBQdWJsaWNLZXkoJ0tlY2Nha1NlY3AyNTZrMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcblxudmFyIF9Mb2NrdXA7XG5cbi8qKlxuICogQWRkcmVzcyBvZiB0aGUgc3Rha2UgY29uZmlnIGFjY291bnQgd2hpY2ggY29uZmlndXJlcyB0aGUgcmF0ZVxuICogb2Ygc3Rha2Ugd2FybXVwIGFuZCBjb29sZG93biBhcyB3ZWxsIGFzIHRoZSBzbGFzaGluZyBwZW5hbHR5LlxuICovXG5jb25zdCBTVEFLRV9DT05GSUdfSUQgPSBuZXcgUHVibGljS2V5KCdTdGFrZUNvbmZpZzExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5cbi8qKlxuICogU3Rha2UgYWNjb3VudCBhdXRob3JpdHkgaW5mb1xuICovXG5jbGFzcyBBdXRob3JpemVkIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBBdXRob3JpemVkIG9iamVjdFxuICAgKiBAcGFyYW0gc3Rha2VyIHRoZSBzdGFrZSBhdXRob3JpdHlcbiAgICogQHBhcmFtIHdpdGhkcmF3ZXIgdGhlIHdpdGhkcmF3IGF1dGhvcml0eVxuICAgKi9cbiAgY29uc3RydWN0b3Ioc3Rha2VyLCB3aXRoZHJhd2VyKSB7XG4gICAgLyoqIHN0YWtlIGF1dGhvcml0eSAqL1xuICAgIHRoaXMuc3Rha2VyID0gdm9pZCAwO1xuICAgIC8qKiB3aXRoZHJhdyBhdXRob3JpdHkgKi9cbiAgICB0aGlzLndpdGhkcmF3ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5zdGFrZXIgPSBzdGFrZXI7XG4gICAgdGhpcy53aXRoZHJhd2VyID0gd2l0aGRyYXdlcjtcbiAgfVxufVxuLyoqXG4gKiBTdGFrZSBhY2NvdW50IGxvY2t1cCBpbmZvXG4gKi9cbmNsYXNzIExvY2t1cCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgTG9ja3VwIG9iamVjdFxuICAgKi9cbiAgY29uc3RydWN0b3IodW5peFRpbWVzdGFtcCwgZXBvY2gsIGN1c3RvZGlhbikge1xuICAgIC8qKiBVbml4IHRpbWVzdGFtcCBvZiBsb2NrdXAgZXhwaXJhdGlvbiAqL1xuICAgIHRoaXMudW5peFRpbWVzdGFtcCA9IHZvaWQgMDtcbiAgICAvKiogRXBvY2ggb2YgbG9ja3VwIGV4cGlyYXRpb24gKi9cbiAgICB0aGlzLmVwb2NoID0gdm9pZCAwO1xuICAgIC8qKiBMb2NrdXAgY3VzdG9kaWFuIGF1dGhvcml0eSAqL1xuICAgIHRoaXMuY3VzdG9kaWFuID0gdm9pZCAwO1xuICAgIHRoaXMudW5peFRpbWVzdGFtcCA9IHVuaXhUaW1lc3RhbXA7XG4gICAgdGhpcy5lcG9jaCA9IGVwb2NoO1xuICAgIHRoaXMuY3VzdG9kaWFuID0gY3VzdG9kaWFuO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmF1bHQsIGluYWN0aXZlIExvY2t1cCB2YWx1ZVxuICAgKi9cbn1cbl9Mb2NrdXAgPSBMb2NrdXA7XG5Mb2NrdXAuZGVmYXVsdCA9IG5ldyBfTG9ja3VwKDAsIDAsIFB1YmxpY0tleS5kZWZhdWx0KTtcbi8qKlxuICogQ3JlYXRlIHN0YWtlIGFjY291bnQgdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cbi8qKlxuICogQ3JlYXRlIHN0YWtlIGFjY291bnQgd2l0aCBzZWVkIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG4vKipcbiAqIEluaXRpYWxpemUgc3Rha2UgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cbi8qKlxuICogRGVsZWdhdGUgc3Rha2UgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cbi8qKlxuICogQXV0aG9yaXplIHN0YWtlIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG4vKipcbiAqIEF1dGhvcml6ZSBzdGFrZSBpbnN0cnVjdGlvbiBwYXJhbXMgdXNpbmcgYSBkZXJpdmVkIGtleVxuICovXG4vKipcbiAqIFNwbGl0IHN0YWtlIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG4vKipcbiAqIFNwbGl0IHdpdGggc2VlZCB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuLyoqXG4gKiBXaXRoZHJhdyBzdGFrZSBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuLyoqXG4gKiBEZWFjdGl2YXRlIHN0YWtlIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG4vKipcbiAqIE1lcmdlIHN0YWtlIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG4vKipcbiAqIFN0YWtlIEluc3RydWN0aW9uIGNsYXNzXG4gKi9cbmNsYXNzIFN0YWtlSW5zdHJ1Y3Rpb24ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIHN0YWtlIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gdHlwZS5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVJbnN0cnVjdGlvblR5cGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25UeXBlTGF5b3V0ID0gQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKTtcbiAgICBjb25zdCB0eXBlSW5kZXggPSBpbnN0cnVjdGlvblR5cGVMYXlvdXQuZGVjb2RlKGluc3RydWN0aW9uLmRhdGEpO1xuICAgIGxldCB0eXBlO1xuICAgIGZvciAoY29uc3QgW2l4VHlwZSwgbGF5b3V0XSBvZiBPYmplY3QuZW50cmllcyhTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTKSkge1xuICAgICAgaWYgKGxheW91dC5pbmRleCA9PSB0eXBlSW5kZXgpIHtcbiAgICAgICAgdHlwZSA9IGl4VHlwZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnN0cnVjdGlvbiB0eXBlIGluY29ycmVjdDsgbm90IGEgU3Rha2VJbnN0cnVjdGlvbicpO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBpbml0aWFsaXplIHN0YWtlIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZUluaXRpYWxpemUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAyKTtcbiAgICBjb25zdCB7XG4gICAgICBhdXRob3JpemVkLFxuICAgICAgbG9ja3VwXG4gICAgfSA9IGRlY29kZURhdGEkMShTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLkluaXRpYWxpemUsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBzdGFrZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBhdXRob3JpemVkOiBuZXcgQXV0aG9yaXplZChuZXcgUHVibGljS2V5KGF1dGhvcml6ZWQuc3Rha2VyKSwgbmV3IFB1YmxpY0tleShhdXRob3JpemVkLndpdGhkcmF3ZXIpKSxcbiAgICAgIGxvY2t1cDogbmV3IExvY2t1cChsb2NrdXAudW5peFRpbWVzdGFtcCwgbG9ja3VwLmVwb2NoLCBuZXcgUHVibGljS2V5KGxvY2t1cC5jdXN0b2RpYW4pKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgZGVsZWdhdGUgc3Rha2UgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlRGVsZWdhdGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCA2KTtcbiAgICBkZWNvZGVEYXRhJDEoU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5EZWxlZ2F0ZSwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YWtlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIHZvdGVQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1s1XS5wdWJrZXlcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhbiBhdXRob3JpemUgc3Rha2UgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlQXV0aG9yaXplKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMyk7XG4gICAgY29uc3Qge1xuICAgICAgbmV3QXV0aG9yaXplZCxcbiAgICAgIHN0YWtlQXV0aG9yaXphdGlvblR5cGVcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXV0aG9yaXplLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICBjb25zdCBvID0ge1xuICAgICAgc3Rha2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1syXS5wdWJrZXksXG4gICAgICBuZXdBdXRob3JpemVkUHVia2V5OiBuZXcgUHVibGljS2V5KG5ld0F1dGhvcml6ZWQpLFxuICAgICAgc3Rha2VBdXRob3JpemF0aW9uVHlwZToge1xuICAgICAgICBpbmRleDogc3Rha2VBdXRob3JpemF0aW9uVHlwZVxuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGluc3RydWN0aW9uLmtleXMubGVuZ3RoID4gMykge1xuICAgICAgby5jdXN0b2RpYW5QdWJrZXkgPSBpbnN0cnVjdGlvbi5rZXlzWzNdLnB1YmtleTtcbiAgICB9XG4gICAgcmV0dXJuIG87XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGFuIGF1dGhvcml6ZS13aXRoLXNlZWQgc3Rha2UgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlQXV0aG9yaXplV2l0aFNlZWQoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAyKTtcbiAgICBjb25zdCB7XG4gICAgICBuZXdBdXRob3JpemVkLFxuICAgICAgc3Rha2VBdXRob3JpemF0aW9uVHlwZSxcbiAgICAgIGF1dGhvcml0eVNlZWQsXG4gICAgICBhdXRob3JpdHlPd25lclxuICAgIH0gPSBkZWNvZGVEYXRhJDEoU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5BdXRob3JpemVXaXRoU2VlZCwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgY29uc3QgbyA9IHtcbiAgICAgIHN0YWtlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGF1dGhvcml0eUJhc2U6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5LFxuICAgICAgYXV0aG9yaXR5U2VlZDogYXV0aG9yaXR5U2VlZCxcbiAgICAgIGF1dGhvcml0eU93bmVyOiBuZXcgUHVibGljS2V5KGF1dGhvcml0eU93bmVyKSxcbiAgICAgIG5ld0F1dGhvcml6ZWRQdWJrZXk6IG5ldyBQdWJsaWNLZXkobmV3QXV0aG9yaXplZCksXG4gICAgICBzdGFrZUF1dGhvcml6YXRpb25UeXBlOiB7XG4gICAgICAgIGluZGV4OiBzdGFrZUF1dGhvcml6YXRpb25UeXBlXG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoaW5zdHJ1Y3Rpb24ua2V5cy5sZW5ndGggPiAzKSB7XG4gICAgICBvLmN1c3RvZGlhblB1YmtleSA9IGluc3RydWN0aW9uLmtleXNbM10ucHVia2V5O1xuICAgIH1cbiAgICByZXR1cm4gbztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBzcGxpdCBzdGFrZSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVTcGxpdChpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDMpO1xuICAgIGNvbnN0IHtcbiAgICAgIGxhbXBvcnRzXG4gICAgfSA9IGRlY29kZURhdGEkMShTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLlNwbGl0LCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3Rha2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgc3BsaXRTdGFrZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzJdLnB1YmtleSxcbiAgICAgIGxhbXBvcnRzXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBtZXJnZSBzdGFrZSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVNZXJnZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDMpO1xuICAgIGRlY29kZURhdGEkMShTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLk1lcmdlLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3Rha2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgc291cmNlU3Rha2VQdWJLZXk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1s0XS5wdWJrZXlcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIHdpdGhkcmF3IHN0YWtlIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZVdpdGhkcmF3KGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgNSk7XG4gICAgY29uc3Qge1xuICAgICAgbGFtcG9ydHNcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuV2l0aGRyYXcsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIGNvbnN0IG8gPSB7XG4gICAgICBzdGFrZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICB0b1B1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzRdLnB1YmtleSxcbiAgICAgIGxhbXBvcnRzXG4gICAgfTtcbiAgICBpZiAoaW5zdHJ1Y3Rpb24ua2V5cy5sZW5ndGggPiA1KSB7XG4gICAgICBvLmN1c3RvZGlhblB1YmtleSA9IGluc3RydWN0aW9uLmtleXNbNV0ucHVia2V5O1xuICAgIH1cbiAgICByZXR1cm4gbztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBkZWFjdGl2YXRlIHN0YWtlIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZURlYWN0aXZhdGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAzKTtcbiAgICBkZWNvZGVEYXRhJDEoU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5EZWFjdGl2YXRlLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3Rha2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1syXS5wdWJrZXlcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc3RhdGljIGNoZWNrUHJvZ3JhbUlkKHByb2dyYW1JZCkge1xuICAgIGlmICghcHJvZ3JhbUlkLmVxdWFscyhTdGFrZVByb2dyYW0ucHJvZ3JhbUlkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGluc3RydWN0aW9uOyBwcm9ncmFtSWQgaXMgbm90IFN0YWtlUHJvZ3JhbScpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHN0YXRpYyBjaGVja0tleUxlbmd0aChrZXlzLCBleHBlY3RlZExlbmd0aCkge1xuICAgIGlmIChrZXlzLmxlbmd0aCA8IGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgaW5zdHJ1Y3Rpb247IGZvdW5kICR7a2V5cy5sZW5ndGh9IGtleXMsIGV4cGVjdGVkIGF0IGxlYXN0ICR7ZXhwZWN0ZWRMZW5ndGh9YCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQW4gZW51bWVyYXRpb24gb2YgdmFsaWQgU3Rha2VJbnN0cnVjdGlvblR5cGUnc1xuICovXG5cbi8qKlxuICogQW4gZW51bWVyYXRpb24gb2YgdmFsaWQgc3Rha2UgSW5zdHJ1Y3Rpb25UeXBlJ3NcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTID0gT2JqZWN0LmZyZWV6ZSh7XG4gIEluaXRpYWxpemU6IHtcbiAgICBpbmRleDogMCxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIGF1dGhvcml6ZWQoKSwgbG9ja3VwKCldKVxuICB9LFxuICBBdXRob3JpemU6IHtcbiAgICBpbmRleDogMSxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIHB1YmxpY0tleSgnbmV3QXV0aG9yaXplZCcpLCBCdWZmZXJMYXlvdXQudTMyKCdzdGFrZUF1dGhvcml6YXRpb25UeXBlJyldKVxuICB9LFxuICBEZWxlZ2F0ZToge1xuICAgIGluZGV4OiAyLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKV0pXG4gIH0sXG4gIFNwbGl0OiB7XG4gICAgaW5kZXg6IDMsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBCdWZmZXJMYXlvdXQubnM2NCgnbGFtcG9ydHMnKV0pXG4gIH0sXG4gIFdpdGhkcmF3OiB7XG4gICAgaW5kZXg6IDQsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBCdWZmZXJMYXlvdXQubnM2NCgnbGFtcG9ydHMnKV0pXG4gIH0sXG4gIERlYWN0aXZhdGU6IHtcbiAgICBpbmRleDogNSxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyldKVxuICB9LFxuICBNZXJnZToge1xuICAgIGluZGV4OiA3LFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKV0pXG4gIH0sXG4gIEF1dGhvcml6ZVdpdGhTZWVkOiB7XG4gICAgaW5kZXg6IDgsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBwdWJsaWNLZXkoJ25ld0F1dGhvcml6ZWQnKSwgQnVmZmVyTGF5b3V0LnUzMignc3Rha2VBdXRob3JpemF0aW9uVHlwZScpLCBydXN0U3RyaW5nKCdhdXRob3JpdHlTZWVkJyksIHB1YmxpY0tleSgnYXV0aG9yaXR5T3duZXInKV0pXG4gIH1cbn0pO1xuXG4vKipcbiAqIFN0YWtlIGF1dGhvcml6YXRpb24gdHlwZVxuICovXG5cbi8qKlxuICogQW4gZW51bWVyYXRpb24gb2YgdmFsaWQgU3Rha2VBdXRob3JpemF0aW9uTGF5b3V0J3NcbiAqL1xuY29uc3QgU3Rha2VBdXRob3JpemF0aW9uTGF5b3V0ID0gT2JqZWN0LmZyZWV6ZSh7XG4gIFN0YWtlcjoge1xuICAgIGluZGV4OiAwXG4gIH0sXG4gIFdpdGhkcmF3ZXI6IHtcbiAgICBpbmRleDogMVxuICB9XG59KTtcblxuLyoqXG4gKiBGYWN0b3J5IGNsYXNzIGZvciB0cmFuc2FjdGlvbnMgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgU3Rha2UgcHJvZ3JhbVxuICovXG5jbGFzcyBTdGFrZVByb2dyYW0ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBrZXkgdGhhdCBpZGVudGlmaWVzIHRoZSBTdGFrZSBwcm9ncmFtXG4gICAqL1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhbiBJbml0aWFsaXplIGluc3RydWN0aW9uIHRvIGFkZCB0byBhIFN0YWtlIENyZWF0ZSB0cmFuc2FjdGlvblxuICAgKi9cbiAgc3RhdGljIGluaXRpYWxpemUocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3Rha2VQdWJrZXksXG4gICAgICBhdXRob3JpemVkLFxuICAgICAgbG9ja3VwOiBtYXliZUxvY2t1cFxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgbG9ja3VwID0gbWF5YmVMb2NrdXAgfHwgTG9ja3VwLmRlZmF1bHQ7XG4gICAgY29uc3QgdHlwZSA9IFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuSW5pdGlhbGl6ZTtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICBhdXRob3JpemVkOiB7XG4gICAgICAgIHN0YWtlcjogdG9CdWZmZXIoYXV0aG9yaXplZC5zdGFrZXIudG9CdWZmZXIoKSksXG4gICAgICAgIHdpdGhkcmF3ZXI6IHRvQnVmZmVyKGF1dGhvcml6ZWQud2l0aGRyYXdlci50b0J1ZmZlcigpKVxuICAgICAgfSxcbiAgICAgIGxvY2t1cDoge1xuICAgICAgICB1bml4VGltZXN0YW1wOiBsb2NrdXAudW5peFRpbWVzdGFtcCxcbiAgICAgICAgZXBvY2g6IGxvY2t1cC5lcG9jaCxcbiAgICAgICAgY3VzdG9kaWFuOiB0b0J1ZmZlcihsb2NrdXAuY3VzdG9kaWFuLnRvQnVmZmVyKCkpXG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25EYXRhID0ge1xuICAgICAga2V5czogW3tcbiAgICAgICAgcHVia2V5OiBzdGFrZVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1lTVkFSX1JFTlRfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9XSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb25EYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIFRyYW5zYWN0aW9uIHRoYXQgY3JlYXRlcyBhIG5ldyBTdGFrZSBhY2NvdW50IGF0XG4gICAqICAgYW4gYWRkcmVzcyBnZW5lcmF0ZWQgd2l0aCBgZnJvbWAsIGEgc2VlZCwgYW5kIHRoZSBTdGFrZSBwcm9ncmFtSWRcbiAgICovXG4gIHN0YXRpYyBjcmVhdGVBY2NvdW50V2l0aFNlZWQocGFyYW1zKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICB0cmFuc2FjdGlvbi5hZGQoU3lzdGVtUHJvZ3JhbS5jcmVhdGVBY2NvdW50V2l0aFNlZWQoe1xuICAgICAgZnJvbVB1YmtleTogcGFyYW1zLmZyb21QdWJrZXksXG4gICAgICBuZXdBY2NvdW50UHVia2V5OiBwYXJhbXMuc3Rha2VQdWJrZXksXG4gICAgICBiYXNlUHVia2V5OiBwYXJhbXMuYmFzZVB1YmtleSxcbiAgICAgIHNlZWQ6IHBhcmFtcy5zZWVkLFxuICAgICAgbGFtcG9ydHM6IHBhcmFtcy5sYW1wb3J0cyxcbiAgICAgIHNwYWNlOiB0aGlzLnNwYWNlLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZFxuICAgIH0pKTtcbiAgICBjb25zdCB7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWQsXG4gICAgICBsb2NrdXBcbiAgICB9ID0gcGFyYW1zO1xuICAgIHJldHVybiB0cmFuc2FjdGlvbi5hZGQodGhpcy5pbml0aWFsaXplKHtcbiAgICAgIHN0YWtlUHVia2V5LFxuICAgICAgYXV0aG9yaXplZCxcbiAgICAgIGxvY2t1cFxuICAgIH0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIFRyYW5zYWN0aW9uIHRoYXQgY3JlYXRlcyBhIG5ldyBTdGFrZSBhY2NvdW50XG4gICAqL1xuICBzdGF0aWMgY3JlYXRlQWNjb3VudChwYXJhbXMpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpO1xuICAgIHRyYW5zYWN0aW9uLmFkZChTeXN0ZW1Qcm9ncmFtLmNyZWF0ZUFjY291bnQoe1xuICAgICAgZnJvbVB1YmtleTogcGFyYW1zLmZyb21QdWJrZXksXG4gICAgICBuZXdBY2NvdW50UHVia2V5OiBwYXJhbXMuc3Rha2VQdWJrZXksXG4gICAgICBsYW1wb3J0czogcGFyYW1zLmxhbXBvcnRzLFxuICAgICAgc3BhY2U6IHRoaXMuc3BhY2UsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkXG4gICAgfSkpO1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YWtlUHVia2V5LFxuICAgICAgYXV0aG9yaXplZCxcbiAgICAgIGxvY2t1cFxuICAgIH0gPSBwYXJhbXM7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uLmFkZCh0aGlzLmluaXRpYWxpemUoe1xuICAgICAgc3Rha2VQdWJrZXksXG4gICAgICBhdXRob3JpemVkLFxuICAgICAgbG9ja3VwXG4gICAgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgVHJhbnNhY3Rpb24gdGhhdCBkZWxlZ2F0ZXMgU3Rha2UgdG9rZW5zIHRvIGEgdmFsaWRhdG9yXG4gICAqIFZvdGUgUHVibGljS2V5LiBUaGlzIHRyYW5zYWN0aW9uIGNhbiBhbHNvIGJlIHVzZWQgdG8gcmVkZWxlZ2F0ZSBTdGFrZVxuICAgKiB0byBhIG5ldyB2YWxpZGF0b3IgVm90ZSBQdWJsaWNLZXkuXG4gICAqL1xuICBzdGF0aWMgZGVsZWdhdGUocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3Rha2VQdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5LFxuICAgICAgdm90ZVB1YmtleVxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHlwZSA9IFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuRGVsZWdhdGU7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbigpLmFkZCh7XG4gICAgICBrZXlzOiBbe1xuICAgICAgICBwdWJrZXk6IHN0YWtlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiB2b3RlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1lTVkFSX0NMT0NLX1BVQktFWSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IFNZU1ZBUl9TVEFLRV9ISVNUT1JZX1BVQktFWSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IFNUQUtFX0NPTkZJR19JRCxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfV0sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgVHJhbnNhY3Rpb24gdGhhdCBhdXRob3JpemVzIGEgbmV3IFB1YmxpY0tleSBhcyBTdGFrZXJcbiAgICogb3IgV2l0aGRyYXdlciBvbiB0aGUgU3Rha2UgYWNjb3VudC5cbiAgICovXG4gIHN0YXRpYyBhdXRob3JpemUocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3Rha2VQdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5LFxuICAgICAgbmV3QXV0aG9yaXplZFB1YmtleSxcbiAgICAgIHN0YWtlQXV0aG9yaXphdGlvblR5cGUsXG4gICAgICBjdXN0b2RpYW5QdWJrZXlcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHR5cGUgPSBTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLkF1dGhvcml6ZTtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICBuZXdBdXRob3JpemVkOiB0b0J1ZmZlcihuZXdBdXRob3JpemVkUHVia2V5LnRvQnVmZmVyKCkpLFxuICAgICAgc3Rha2VBdXRob3JpemF0aW9uVHlwZTogc3Rha2VBdXRob3JpemF0aW9uVHlwZS5pbmRleFxuICAgIH0pO1xuICAgIGNvbnN0IGtleXMgPSBbe1xuICAgICAgcHVia2V5OiBzdGFrZVB1YmtleSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IFNZU1ZBUl9DTE9DS19QVUJLRVksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBhdXRob3JpemVkUHVia2V5LFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH1dO1xuICAgIGlmIChjdXN0b2RpYW5QdWJrZXkpIHtcbiAgICAgIGtleXMucHVzaCh7XG4gICAgICAgIHB1YmtleTogY3VzdG9kaWFuUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgVHJhbnNhY3Rpb24gdGhhdCBhdXRob3JpemVzIGEgbmV3IFB1YmxpY0tleSBhcyBTdGFrZXJcbiAgICogb3IgV2l0aGRyYXdlciBvbiB0aGUgU3Rha2UgYWNjb3VudC5cbiAgICovXG4gIHN0YXRpYyBhdXRob3JpemVXaXRoU2VlZChwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIGF1dGhvcml0eUJhc2UsXG4gICAgICBhdXRob3JpdHlTZWVkLFxuICAgICAgYXV0aG9yaXR5T3duZXIsXG4gICAgICBuZXdBdXRob3JpemVkUHVia2V5LFxuICAgICAgc3Rha2VBdXRob3JpemF0aW9uVHlwZSxcbiAgICAgIGN1c3RvZGlhblB1YmtleVxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHlwZSA9IFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXV0aG9yaXplV2l0aFNlZWQ7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgbmV3QXV0aG9yaXplZDogdG9CdWZmZXIobmV3QXV0aG9yaXplZFB1YmtleS50b0J1ZmZlcigpKSxcbiAgICAgIHN0YWtlQXV0aG9yaXphdGlvblR5cGU6IHN0YWtlQXV0aG9yaXphdGlvblR5cGUuaW5kZXgsXG4gICAgICBhdXRob3JpdHlTZWVkOiBhdXRob3JpdHlTZWVkLFxuICAgICAgYXV0aG9yaXR5T3duZXI6IHRvQnVmZmVyKGF1dGhvcml0eU93bmVyLnRvQnVmZmVyKCkpXG4gICAgfSk7XG4gICAgY29uc3Qga2V5cyA9IFt7XG4gICAgICBwdWJrZXk6IHN0YWtlUHVia2V5LFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogYXV0aG9yaXR5QmFzZSxcbiAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IFNZU1ZBUl9DTE9DS19QVUJLRVksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH1dO1xuICAgIGlmIChjdXN0b2RpYW5QdWJrZXkpIHtcbiAgICAgIGtleXMucHVzaCh7XG4gICAgICAgIHB1YmtleTogY3VzdG9kaWFuUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc3RhdGljIHNwbGl0SW5zdHJ1Y3Rpb24ocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3Rha2VQdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5LFxuICAgICAgc3BsaXRTdGFrZVB1YmtleSxcbiAgICAgIGxhbXBvcnRzXG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCB0eXBlID0gU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5TcGxpdDtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICBsYW1wb3J0c1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBrZXlzOiBbe1xuICAgICAgICBwdWJrZXk6IHN0YWtlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBzcGxpdFN0YWtlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBhdXRob3JpemVkUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH1dLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIFRyYW5zYWN0aW9uIHRoYXQgc3BsaXRzIFN0YWtlIHRva2VucyBpbnRvIGFub3RoZXIgc3Rha2UgYWNjb3VudFxuICAgKi9cbiAgc3RhdGljIHNwbGl0KHBhcmFtcyxcbiAgLy8gQ29tcHV0ZSB0aGUgY29zdCBvZiBhbGxvY2F0aW5nIHRoZSBuZXcgc3Rha2UgYWNjb3VudCBpbiBsYW1wb3J0c1xuICByZW50RXhlbXB0UmVzZXJ2ZSkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgdHJhbnNhY3Rpb24uYWRkKFN5c3RlbVByb2dyYW0uY3JlYXRlQWNjb3VudCh7XG4gICAgICBmcm9tUHVia2V5OiBwYXJhbXMuYXV0aG9yaXplZFB1YmtleSxcbiAgICAgIG5ld0FjY291bnRQdWJrZXk6IHBhcmFtcy5zcGxpdFN0YWtlUHVia2V5LFxuICAgICAgbGFtcG9ydHM6IHJlbnRFeGVtcHRSZXNlcnZlLFxuICAgICAgc3BhY2U6IHRoaXMuc3BhY2UsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkXG4gICAgfSkpO1xuICAgIHJldHVybiB0cmFuc2FjdGlvbi5hZGQodGhpcy5zcGxpdEluc3RydWN0aW9uKHBhcmFtcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgVHJhbnNhY3Rpb24gdGhhdCBzcGxpdHMgU3Rha2UgdG9rZW5zIGludG8gYW5vdGhlciBhY2NvdW50XG4gICAqIGRlcml2ZWQgZnJvbSBhIGJhc2UgcHVibGljIGtleSBhbmQgc2VlZFxuICAgKi9cbiAgc3RhdGljIHNwbGl0V2l0aFNlZWQocGFyYW1zLFxuICAvLyBJZiB0aGlzIHN0YWtlIGFjY291bnQgaXMgbmV3LCBjb21wdXRlIHRoZSBjb3N0IG9mIGFsbG9jYXRpbmcgaXQgaW4gbGFtcG9ydHNcbiAgcmVudEV4ZW1wdFJlc2VydmUpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICBzcGxpdFN0YWtlUHVia2V5LFxuICAgICAgYmFzZVB1YmtleSxcbiAgICAgIHNlZWQsXG4gICAgICBsYW1wb3J0c1xuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICB0cmFuc2FjdGlvbi5hZGQoU3lzdGVtUHJvZ3JhbS5hbGxvY2F0ZSh7XG4gICAgICBhY2NvdW50UHVia2V5OiBzcGxpdFN0YWtlUHVia2V5LFxuICAgICAgYmFzZVB1YmtleSxcbiAgICAgIHNlZWQsXG4gICAgICBzcGFjZTogdGhpcy5zcGFjZSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWRcbiAgICB9KSk7XG4gICAgaWYgKHJlbnRFeGVtcHRSZXNlcnZlICYmIHJlbnRFeGVtcHRSZXNlcnZlID4gMCkge1xuICAgICAgdHJhbnNhY3Rpb24uYWRkKFN5c3RlbVByb2dyYW0udHJhbnNmZXIoe1xuICAgICAgICBmcm9tUHVia2V5OiBwYXJhbXMuYXV0aG9yaXplZFB1YmtleSxcbiAgICAgICAgdG9QdWJrZXk6IHNwbGl0U3Rha2VQdWJrZXksXG4gICAgICAgIGxhbXBvcnRzOiByZW50RXhlbXB0UmVzZXJ2ZVxuICAgICAgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNhY3Rpb24uYWRkKHRoaXMuc3BsaXRJbnN0cnVjdGlvbih7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICBzcGxpdFN0YWtlUHVia2V5LFxuICAgICAgbGFtcG9ydHNcbiAgICB9KSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBUcmFuc2FjdGlvbiB0aGF0IG1lcmdlcyBTdGFrZSBhY2NvdW50cy5cbiAgICovXG4gIHN0YXRpYyBtZXJnZShwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIHNvdXJjZVN0YWtlUHViS2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleVxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHlwZSA9IFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuTWVyZ2U7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbigpLmFkZCh7XG4gICAgICBrZXlzOiBbe1xuICAgICAgICBwdWJrZXk6IHN0YWtlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBzb3VyY2VTdGFrZVB1YktleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1lTVkFSX0NMT0NLX1BVQktFWSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IFNZU1ZBUl9TVEFLRV9ISVNUT1JZX1BVQktFWSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfV0sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgVHJhbnNhY3Rpb24gdGhhdCB3aXRoZHJhd3MgZGVhY3RpdmF0ZWQgU3Rha2UgdG9rZW5zLlxuICAgKi9cbiAgc3RhdGljIHdpdGhkcmF3KHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YWtlUHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleSxcbiAgICAgIHRvUHVia2V5LFxuICAgICAgbGFtcG9ydHMsXG4gICAgICBjdXN0b2RpYW5QdWJrZXlcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHR5cGUgPSBTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLldpdGhkcmF3O1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIGxhbXBvcnRzXG4gICAgfSk7XG4gICAgY29uc3Qga2V5cyA9IFt7XG4gICAgICBwdWJrZXk6IHN0YWtlUHVia2V5LFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogdG9QdWJrZXksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBTWVNWQVJfQ0xPQ0tfUFVCS0VZLFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IFNZU1ZBUl9TVEFLRV9ISVNUT1JZX1BVQktFWSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBhdXRob3JpemVkUHVia2V5LFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH1dO1xuICAgIGlmIChjdXN0b2RpYW5QdWJrZXkpIHtcbiAgICAgIGtleXMucHVzaCh7XG4gICAgICAgIHB1YmtleTogY3VzdG9kaWFuUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgVHJhbnNhY3Rpb24gdGhhdCBkZWFjdGl2YXRlcyBTdGFrZSB0b2tlbnMuXG4gICAqL1xuICBzdGF0aWMgZGVhY3RpdmF0ZShwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXlcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHR5cGUgPSBTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLkRlYWN0aXZhdGU7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbigpLmFkZCh7XG4gICAgICBrZXlzOiBbe1xuICAgICAgICBwdWJrZXk6IHN0YWtlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBTWVNWQVJfQ0xPQ0tfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogYXV0aG9yaXplZFB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9XSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cbn1cblN0YWtlUHJvZ3JhbS5wcm9ncmFtSWQgPSBuZXcgUHVibGljS2V5KCdTdGFrZTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG4vKipcbiAqIE1heCBzcGFjZSBvZiBhIFN0YWtlIGFjY291bnRcbiAqXG4gKiBUaGlzIGlzIGdlbmVyYXRlZCBmcm9tIHRoZSBzb2xhbmEtc3Rha2UtcHJvZ3JhbSBTdGFrZVN0YXRlIHN0cnVjdCBhc1xuICogYFN0YWtlU3RhdGVWMjo6c2l6ZV9vZigpYDpcbiAqIGh0dHBzOi8vZG9jcy5ycy9zb2xhbmEtc3Rha2UtcHJvZ3JhbS9sYXRlc3Qvc29sYW5hX3N0YWtlX3Byb2dyYW0vc3Rha2Vfc3RhdGUvZW51bS5TdGFrZVN0YXRlVjIuaHRtbFxuICovXG5TdGFrZVByb2dyYW0uc3BhY2UgPSAyMDA7XG5cbi8qKlxuICogVm90ZSBhY2NvdW50IGluZm9cbiAqL1xuY2xhc3MgVm90ZUluaXQge1xuICAvKiogWzAsIDEwMF0gKi9cblxuICBjb25zdHJ1Y3Rvcihub2RlUHVia2V5LCBhdXRob3JpemVkVm90ZXIsIGF1dGhvcml6ZWRXaXRoZHJhd2VyLCBjb21taXNzaW9uKSB7XG4gICAgdGhpcy5ub2RlUHVia2V5ID0gdm9pZCAwO1xuICAgIHRoaXMuYXV0aG9yaXplZFZvdGVyID0gdm9pZCAwO1xuICAgIHRoaXMuYXV0aG9yaXplZFdpdGhkcmF3ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5jb21taXNzaW9uID0gdm9pZCAwO1xuICAgIHRoaXMubm9kZVB1YmtleSA9IG5vZGVQdWJrZXk7XG4gICAgdGhpcy5hdXRob3JpemVkVm90ZXIgPSBhdXRob3JpemVkVm90ZXI7XG4gICAgdGhpcy5hdXRob3JpemVkV2l0aGRyYXdlciA9IGF1dGhvcml6ZWRXaXRoZHJhd2VyO1xuICAgIHRoaXMuY29tbWlzc2lvbiA9IGNvbW1pc3Npb247XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgdm90ZSBhY2NvdW50IHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogSW5pdGlhbGl6ZUFjY291bnQgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBBdXRob3JpemUgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBBdXRob3JpemVXaXRoU2VlZCBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIFdpdGhkcmF3IGZyb20gdm90ZSBhY2NvdW50IHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogVXBkYXRlIHZhbGlkYXRvciBpZGVudGl0eSAobm9kZSBwdWJrZXkpIHZvdGUgYWNjb3VudCBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gKi9cblxuLyoqXG4gKiBWb3RlIEluc3RydWN0aW9uIGNsYXNzXG4gKi9cbmNsYXNzIFZvdGVJbnN0cnVjdGlvbiB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge31cblxuICAvKipcbiAgICogRGVjb2RlIGEgdm90ZSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHR5cGUuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlSW5zdHJ1Y3Rpb25UeXBlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIGNvbnN0IGluc3RydWN0aW9uVHlwZUxheW91dCA9IEJ1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyk7XG4gICAgY29uc3QgdHlwZUluZGV4ID0gaW5zdHJ1Y3Rpb25UeXBlTGF5b3V0LmRlY29kZShpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICBsZXQgdHlwZTtcbiAgICBmb3IgKGNvbnN0IFtpeFR5cGUsIGxheW91dF0gb2YgT2JqZWN0LmVudHJpZXMoVk9URV9JTlNUUlVDVElPTl9MQVlPVVRTKSkge1xuICAgICAgaWYgKGxheW91dC5pbmRleCA9PSB0eXBlSW5kZXgpIHtcbiAgICAgICAgdHlwZSA9IGl4VHlwZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnN0cnVjdGlvbiB0eXBlIGluY29ycmVjdDsgbm90IGEgVm90ZUluc3RydWN0aW9uJyk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhbiBpbml0aWFsaXplIHZvdGUgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlSW5pdGlhbGl6ZUFjY291bnQoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCA0KTtcbiAgICBjb25zdCB7XG4gICAgICB2b3RlSW5pdFxuICAgIH0gPSBkZWNvZGVEYXRhJDEoVk9URV9JTlNUUlVDVElPTl9MQVlPVVRTLkluaXRpYWxpemVBY2NvdW50LCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgdm90ZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBub2RlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzNdLnB1YmtleSxcbiAgICAgIHZvdGVJbml0OiBuZXcgVm90ZUluaXQobmV3IFB1YmxpY0tleSh2b3RlSW5pdC5ub2RlUHVia2V5KSwgbmV3IFB1YmxpY0tleSh2b3RlSW5pdC5hdXRob3JpemVkVm90ZXIpLCBuZXcgUHVibGljS2V5KHZvdGVJbml0LmF1dGhvcml6ZWRXaXRoZHJhd2VyKSwgdm90ZUluaXQuY29tbWlzc2lvbilcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhbiBhdXRob3JpemUgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlQXV0aG9yaXplKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMyk7XG4gICAgY29uc3Qge1xuICAgICAgbmV3QXV0aG9yaXplZCxcbiAgICAgIHZvdGVBdXRob3JpemF0aW9uVHlwZVxuICAgIH0gPSBkZWNvZGVEYXRhJDEoVk9URV9JTlNUUlVDVElPTl9MQVlPVVRTLkF1dGhvcml6ZSwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZvdGVQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1syXS5wdWJrZXksXG4gICAgICBuZXdBdXRob3JpemVkUHVia2V5OiBuZXcgUHVibGljS2V5KG5ld0F1dGhvcml6ZWQpLFxuICAgICAgdm90ZUF1dGhvcml6YXRpb25UeXBlOiB7XG4gICAgICAgIGluZGV4OiB2b3RlQXV0aG9yaXphdGlvblR5cGVcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhbiBhdXRob3JpemUgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlQXV0aG9yaXplV2l0aFNlZWQoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAzKTtcbiAgICBjb25zdCB7XG4gICAgICB2b3RlQXV0aG9yaXplV2l0aFNlZWRBcmdzOiB7XG4gICAgICAgIGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5T3duZXJQdWJrZXksXG4gICAgICAgIGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5U2VlZCxcbiAgICAgICAgbmV3QXV0aG9yaXplZCxcbiAgICAgICAgdm90ZUF1dGhvcml6YXRpb25UeXBlXG4gICAgICB9XG4gICAgfSA9IGRlY29kZURhdGEkMShWT1RFX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXV0aG9yaXplV2l0aFNlZWQsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleUJhc2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMl0ucHVia2V5LFxuICAgICAgY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlPd25lclB1YmtleTogbmV3IFB1YmxpY0tleShjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleU93bmVyUHVia2V5KSxcbiAgICAgIGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5U2VlZDogY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlTZWVkLFxuICAgICAgbmV3QXV0aG9yaXplZFB1YmtleTogbmV3IFB1YmxpY0tleShuZXdBdXRob3JpemVkKSxcbiAgICAgIHZvdGVBdXRob3JpemF0aW9uVHlwZToge1xuICAgICAgICBpbmRleDogdm90ZUF1dGhvcml6YXRpb25UeXBlXG4gICAgICB9LFxuICAgICAgdm90ZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXlcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIHdpdGhkcmF3IGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZVdpdGhkcmF3KGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMyk7XG4gICAgY29uc3Qge1xuICAgICAgbGFtcG9ydHNcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFZPVEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5XaXRoZHJhdywgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZvdGVQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYXV0aG9yaXplZFdpdGhkcmF3ZXJQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMl0ucHVia2V5LFxuICAgICAgbGFtcG9ydHMsXG4gICAgICB0b1B1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXlcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc3RhdGljIGNoZWNrUHJvZ3JhbUlkKHByb2dyYW1JZCkge1xuICAgIGlmICghcHJvZ3JhbUlkLmVxdWFscyhWb3RlUHJvZ3JhbS5wcm9ncmFtSWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5zdHJ1Y3Rpb247IHByb2dyYW1JZCBpcyBub3QgVm90ZVByb2dyYW0nKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzdGF0aWMgY2hlY2tLZXlMZW5ndGgoa2V5cywgZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICBpZiAoa2V5cy5sZW5ndGggPCBleHBlY3RlZExlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGluc3RydWN0aW9uOyBmb3VuZCAke2tleXMubGVuZ3RofSBrZXlzLCBleHBlY3RlZCBhdCBsZWFzdCAke2V4cGVjdGVkTGVuZ3RofWApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFuIGVudW1lcmF0aW9uIG9mIHZhbGlkIFZvdGVJbnN0cnVjdGlvblR5cGUnc1xuICovXG5cbi8qKiBAaW50ZXJuYWwgKi9cblxuY29uc3QgVk9URV9JTlNUUlVDVElPTl9MQVlPVVRTID0gT2JqZWN0LmZyZWV6ZSh7XG4gIEluaXRpYWxpemVBY2NvdW50OiB7XG4gICAgaW5kZXg6IDAsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCB2b3RlSW5pdCgpXSlcbiAgfSxcbiAgQXV0aG9yaXplOiB7XG4gICAgaW5kZXg6IDEsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBwdWJsaWNLZXkoJ25ld0F1dGhvcml6ZWQnKSwgQnVmZmVyTGF5b3V0LnUzMigndm90ZUF1dGhvcml6YXRpb25UeXBlJyldKVxuICB9LFxuICBXaXRoZHJhdzoge1xuICAgIGluZGV4OiAzLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgQnVmZmVyTGF5b3V0Lm5zNjQoJ2xhbXBvcnRzJyldKVxuICB9LFxuICBVcGRhdGVWYWxpZGF0b3JJZGVudGl0eToge1xuICAgIGluZGV4OiA0LFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKV0pXG4gIH0sXG4gIEF1dGhvcml6ZVdpdGhTZWVkOiB7XG4gICAgaW5kZXg6IDEwLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgdm90ZUF1dGhvcml6ZVdpdGhTZWVkQXJncygpXSlcbiAgfVxufSk7XG5cbi8qKlxuICogVm90ZUF1dGhvcml6ZSB0eXBlXG4gKi9cblxuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiBvZiB2YWxpZCBWb3RlQXV0aG9yaXphdGlvbiBsYXlvdXRzLlxuICovXG5jb25zdCBWb3RlQXV0aG9yaXphdGlvbkxheW91dCA9IE9iamVjdC5mcmVlemUoe1xuICBWb3Rlcjoge1xuICAgIGluZGV4OiAwXG4gIH0sXG4gIFdpdGhkcmF3ZXI6IHtcbiAgICBpbmRleDogMVxuICB9XG59KTtcblxuLyoqXG4gKiBGYWN0b3J5IGNsYXNzIGZvciB0cmFuc2FjdGlvbnMgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgVm90ZSBwcm9ncmFtXG4gKi9cbmNsYXNzIFZvdGVQcm9ncmFtIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7fVxuXG4gIC8qKlxuICAgKiBQdWJsaWMga2V5IHRoYXQgaWRlbnRpZmllcyB0aGUgVm90ZSBwcm9ncmFtXG4gICAqL1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhbiBJbml0aWFsaXplIGluc3RydWN0aW9uLlxuICAgKi9cbiAgc3RhdGljIGluaXRpYWxpemVBY2NvdW50KHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHZvdGVQdWJrZXksXG4gICAgICBub2RlUHVia2V5LFxuICAgICAgdm90ZUluaXRcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHR5cGUgPSBWT1RFX0lOU1RSVUNUSU9OX0xBWU9VVFMuSW5pdGlhbGl6ZUFjY291bnQ7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgdm90ZUluaXQ6IHtcbiAgICAgICAgbm9kZVB1YmtleTogdG9CdWZmZXIodm90ZUluaXQubm9kZVB1YmtleS50b0J1ZmZlcigpKSxcbiAgICAgICAgYXV0aG9yaXplZFZvdGVyOiB0b0J1ZmZlcih2b3RlSW5pdC5hdXRob3JpemVkVm90ZXIudG9CdWZmZXIoKSksXG4gICAgICAgIGF1dGhvcml6ZWRXaXRoZHJhd2VyOiB0b0J1ZmZlcih2b3RlSW5pdC5hdXRob3JpemVkV2l0aGRyYXdlci50b0J1ZmZlcigpKSxcbiAgICAgICAgY29tbWlzc2lvbjogdm90ZUluaXQuY29tbWlzc2lvblxuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGluc3RydWN0aW9uRGF0YSA9IHtcbiAgICAgIGtleXM6IFt7XG4gICAgICAgIHB1YmtleTogdm90ZVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1lTVkFSX1JFTlRfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1lTVkFSX0NMT0NLX1BVQktFWSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IG5vZGVQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfV0sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH07XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKGluc3RydWN0aW9uRGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiB0aGF0IGNyZWF0ZXMgYSBuZXcgVm90ZSBhY2NvdW50LlxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUFjY291bnQocGFyYW1zKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICB0cmFuc2FjdGlvbi5hZGQoU3lzdGVtUHJvZ3JhbS5jcmVhdGVBY2NvdW50KHtcbiAgICAgIGZyb21QdWJrZXk6IHBhcmFtcy5mcm9tUHVia2V5LFxuICAgICAgbmV3QWNjb3VudFB1YmtleTogcGFyYW1zLnZvdGVQdWJrZXksXG4gICAgICBsYW1wb3J0czogcGFyYW1zLmxhbXBvcnRzLFxuICAgICAgc3BhY2U6IHRoaXMuc3BhY2UsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkXG4gICAgfSkpO1xuICAgIHJldHVybiB0cmFuc2FjdGlvbi5hZGQodGhpcy5pbml0aWFsaXplQWNjb3VudCh7XG4gICAgICB2b3RlUHVia2V5OiBwYXJhbXMudm90ZVB1YmtleSxcbiAgICAgIG5vZGVQdWJrZXk6IHBhcmFtcy52b3RlSW5pdC5ub2RlUHVia2V5LFxuICAgICAgdm90ZUluaXQ6IHBhcmFtcy52b3RlSW5pdFxuICAgIH0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIHRoYXQgYXV0aG9yaXplcyBhIG5ldyBWb3RlciBvciBXaXRoZHJhd2VyIG9uIHRoZSBWb3RlIGFjY291bnQuXG4gICAqL1xuICBzdGF0aWMgYXV0aG9yaXplKHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHZvdGVQdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5LFxuICAgICAgbmV3QXV0aG9yaXplZFB1YmtleSxcbiAgICAgIHZvdGVBdXRob3JpemF0aW9uVHlwZVxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHlwZSA9IFZPVEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5BdXRob3JpemU7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgbmV3QXV0aG9yaXplZDogdG9CdWZmZXIobmV3QXV0aG9yaXplZFB1YmtleS50b0J1ZmZlcigpKSxcbiAgICAgIHZvdGVBdXRob3JpemF0aW9uVHlwZTogdm90ZUF1dGhvcml6YXRpb25UeXBlLmluZGV4XG4gICAgfSk7XG4gICAgY29uc3Qga2V5cyA9IFt7XG4gICAgICBwdWJrZXk6IHZvdGVQdWJrZXksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBTWVNWQVJfQ0xPQ0tfUFVCS0VZLFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfV07XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbigpLmFkZCh7XG4gICAgICBrZXlzLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIHRoYXQgYXV0aG9yaXplcyBhIG5ldyBWb3RlciBvciBXaXRoZHJhd2VyIG9uIHRoZSBWb3RlIGFjY291bnRcbiAgICogd2hlcmUgdGhlIGN1cnJlbnQgVm90ZXIgb3IgV2l0aGRyYXdlciBhdXRob3JpdHkgaXMgYSBkZXJpdmVkIGtleS5cbiAgICovXG4gIHN0YXRpYyBhdXRob3JpemVXaXRoU2VlZChwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleUJhc2VQdWJrZXksXG4gICAgICBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleU93bmVyUHVia2V5LFxuICAgICAgY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlTZWVkLFxuICAgICAgbmV3QXV0aG9yaXplZFB1YmtleSxcbiAgICAgIHZvdGVBdXRob3JpemF0aW9uVHlwZSxcbiAgICAgIHZvdGVQdWJrZXlcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHR5cGUgPSBWT1RFX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXV0aG9yaXplV2l0aFNlZWQ7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgdm90ZUF1dGhvcml6ZVdpdGhTZWVkQXJnczoge1xuICAgICAgICBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleU93bmVyUHVia2V5OiB0b0J1ZmZlcihjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleU93bmVyUHVia2V5LnRvQnVmZmVyKCkpLFxuICAgICAgICBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleVNlZWQ6IGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5U2VlZCxcbiAgICAgICAgbmV3QXV0aG9yaXplZDogdG9CdWZmZXIobmV3QXV0aG9yaXplZFB1YmtleS50b0J1ZmZlcigpKSxcbiAgICAgICAgdm90ZUF1dGhvcml6YXRpb25UeXBlOiB2b3RlQXV0aG9yaXphdGlvblR5cGUuaW5kZXhcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBrZXlzID0gW3tcbiAgICAgIHB1YmtleTogdm90ZVB1YmtleSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IFNZU1ZBUl9DTE9DS19QVUJLRVksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlCYXNlUHVia2V5LFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH1dO1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoe1xuICAgICAga2V5cyxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiB0byB3aXRoZHJhdyBmcm9tIGEgVm90ZSBhY2NvdW50LlxuICAgKi9cbiAgc3RhdGljIHdpdGhkcmF3KHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHZvdGVQdWJrZXksXG4gICAgICBhdXRob3JpemVkV2l0aGRyYXdlclB1YmtleSxcbiAgICAgIGxhbXBvcnRzLFxuICAgICAgdG9QdWJrZXlcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHR5cGUgPSBWT1RFX0lOU1RSVUNUSU9OX0xBWU9VVFMuV2l0aGRyYXc7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgbGFtcG9ydHNcbiAgICB9KTtcbiAgICBjb25zdCBrZXlzID0gW3tcbiAgICAgIHB1YmtleTogdm90ZVB1YmtleSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IHRvUHVia2V5LFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogYXV0aG9yaXplZFdpdGhkcmF3ZXJQdWJrZXksXG4gICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfV07XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbigpLmFkZCh7XG4gICAgICBrZXlzLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIHRvIHdpdGhkcmF3IHNhZmVseSBmcm9tIGEgVm90ZSBhY2NvdW50LlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHdhcyBjcmVhdGVkIGFzIGEgc2FmZWd1YXJkIGZvciB2b3RlIGFjY291bnRzIHJ1bm5pbmcgdmFsaWRhdG9ycywgYHNhZmVXaXRoZHJhd2BcbiAgICogY2hlY2tzIHRoYXQgdGhlIHdpdGhkcmF3IGFtb3VudCB3aWxsIG5vdCBleGNlZWQgdGhlIHNwZWNpZmllZCBiYWxhbmNlIHdoaWxlIGxlYXZpbmcgZW5vdWdoIGxlZnRcbiAgICogdG8gY292ZXIgcmVudC4gSWYgeW91IHdpc2ggdG8gY2xvc2UgdGhlIHZvdGUgYWNjb3VudCBieSB3aXRoZHJhd2luZyB0aGUgZnVsbCBhbW91bnQsIGNhbGwgdGhlXG4gICAqIGB3aXRoZHJhd2AgbWV0aG9kIGRpcmVjdGx5LlxuICAgKi9cbiAgc3RhdGljIHNhZmVXaXRoZHJhdyhwYXJhbXMsIGN1cnJlbnRWb3RlQWNjb3VudEJhbGFuY2UsIHJlbnRFeGVtcHRNaW5pbXVtKSB7XG4gICAgaWYgKHBhcmFtcy5sYW1wb3J0cyA+IGN1cnJlbnRWb3RlQWNjb3VudEJhbGFuY2UgLSByZW50RXhlbXB0TWluaW11bSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXaXRoZHJhdyB3aWxsIGxlYXZlIHZvdGUgYWNjb3VudCB3aXRoIGluc3VmZmljaWVudCBmdW5kcy4nKTtcbiAgICB9XG4gICAgcmV0dXJuIFZvdGVQcm9ncmFtLndpdGhkcmF3KHBhcmFtcyk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiB0byB1cGRhdGUgdGhlIHZhbGlkYXRvciBpZGVudGl0eSAobm9kZSBwdWJrZXkpIG9mIGEgVm90ZSBhY2NvdW50LlxuICAgKi9cbiAgc3RhdGljIHVwZGF0ZVZhbGlkYXRvcklkZW50aXR5KHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHZvdGVQdWJrZXksXG4gICAgICBhdXRob3JpemVkV2l0aGRyYXdlclB1YmtleSxcbiAgICAgIG5vZGVQdWJrZXlcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHR5cGUgPSBWT1RFX0lOU1RSVUNUSU9OX0xBWU9VVFMuVXBkYXRlVmFsaWRhdG9ySWRlbnRpdHk7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSk7XG4gICAgY29uc3Qga2V5cyA9IFt7XG4gICAgICBwdWJrZXk6IHZvdGVQdWJrZXksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBub2RlUHVia2V5LFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogYXV0aG9yaXplZFdpdGhkcmF3ZXJQdWJrZXksXG4gICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfV07XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbigpLmFkZCh7XG4gICAgICBrZXlzLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxufVxuVm90ZVByb2dyYW0ucHJvZ3JhbUlkID0gbmV3IFB1YmxpY0tleSgnVm90ZTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuLyoqXG4gKiBNYXggc3BhY2Ugb2YgYSBWb3RlIGFjY291bnRcbiAqXG4gKiBUaGlzIGlzIGdlbmVyYXRlZCBmcm9tIHRoZSBzb2xhbmEtdm90ZS1wcm9ncmFtIFZvdGVTdGF0ZSBzdHJ1Y3QgYXNcbiAqIGBWb3RlU3RhdGU6OnNpemVfb2YoKWA6XG4gKiBodHRwczovL2RvY3MucnMvc29sYW5hLXZvdGUtcHJvZ3JhbS8xLjkuNS9zb2xhbmFfdm90ZV9wcm9ncmFtL3ZvdGVfc3RhdGUvc3RydWN0LlZvdGVTdGF0ZS5odG1sI21ldGhvZC5zaXplX29mXG4gKlxuICogS0VFUCBJTiBTWU5DIFdJVEggYFZvdGVTdGF0ZTo6c2l6ZV9vZigpYCBpbiBodHRwczovL2dpdGh1Yi5jb20vc29sYW5hLWxhYnMvc29sYW5hL2Jsb2IvYTQ3NGNiMjRiOTIzOGY1ZWRjYzk4MmY2NWMwYjM3ZDRhMTA0NmY3ZS9zZGsvcHJvZ3JhbS9zcmMvdm90ZS9zdGF0ZS9tb2QucnMjTDM0MC1MMzQyXG4gKi9cblZvdGVQcm9ncmFtLnNwYWNlID0gMzc2MjtcblxuY29uc3QgVkFMSURBVE9SX0lORk9fS0VZID0gbmV3IFB1YmxpY0tleSgnVmExaWRhdG9yMW5mbzExMTExMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5cbi8qKlxuICogSW5mbyB1c2VkIHRvIGlkZW50aXR5IHZhbGlkYXRvcnMuXG4gKi9cblxuY29uc3QgSW5mb1N0cmluZyA9IHR5cGUoe1xuICBuYW1lOiBzdHJpbmcoKSxcbiAgd2Vic2l0ZTogb3B0aW9uYWwoc3RyaW5nKCkpLFxuICBkZXRhaWxzOiBvcHRpb25hbChzdHJpbmcoKSksXG4gIGljb25Vcmw6IG9wdGlvbmFsKHN0cmluZygpKSxcbiAga2V5YmFzZVVzZXJuYW1lOiBvcHRpb25hbChzdHJpbmcoKSlcbn0pO1xuXG4vKipcbiAqIFZhbGlkYXRvckluZm8gY2xhc3NcbiAqL1xuY2xhc3MgVmFsaWRhdG9ySW5mbyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSB2YWxpZCBWYWxpZGF0b3JJbmZvXG4gICAqXG4gICAqIEBwYXJhbSBrZXkgdmFsaWRhdG9yIHB1YmxpYyBrZXlcbiAgICogQHBhcmFtIGluZm8gdmFsaWRhdG9yIGluZm9ybWF0aW9uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihrZXksIGluZm8pIHtcbiAgICAvKipcbiAgICAgKiB2YWxpZGF0b3IgcHVibGljIGtleVxuICAgICAqL1xuICAgIHRoaXMua2V5ID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIHZhbGlkYXRvciBpbmZvcm1hdGlvblxuICAgICAqL1xuICAgIHRoaXMuaW5mbyA9IHZvaWQgMDtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLmluZm8gPSBpbmZvO1xuICB9XG5cbiAgLyoqXG4gICAqIERlc2VyaWFsaXplIFZhbGlkYXRvckluZm8gZnJvbSB0aGUgY29uZmlnIGFjY291bnQgZGF0YS4gRXhhY3RseSB0d28gY29uZmlnXG4gICAqIGtleXMgYXJlIHJlcXVpcmVkIGluIHRoZSBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0gYnVmZmVyIGNvbmZpZyBhY2NvdW50IGRhdGFcbiAgICogQHJldHVybiBudWxsIGlmIGluZm8gd2FzIG5vdCBmb3VuZFxuICAgKi9cbiAgc3RhdGljIGZyb21Db25maWdEYXRhKGJ1ZmZlcikge1xuICAgIGxldCBieXRlQXJyYXkgPSBbLi4uYnVmZmVyXTtcbiAgICBjb25zdCBjb25maWdLZXlDb3VudCA9IGRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgIGlmIChjb25maWdLZXlDb3VudCAhPT0gMikgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgY29uZmlnS2V5cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjsgaSsrKSB7XG4gICAgICBjb25zdCBwdWJsaWNLZXkgPSBuZXcgUHVibGljS2V5KGd1YXJkZWRTcGxpY2UoYnl0ZUFycmF5LCAwLCBQVUJMSUNfS0VZX0xFTkdUSCkpO1xuICAgICAgY29uc3QgaXNTaWduZXIgPSBndWFyZGVkU2hpZnQoYnl0ZUFycmF5KSA9PT0gMTtcbiAgICAgIGNvbmZpZ0tleXMucHVzaCh7XG4gICAgICAgIHB1YmxpY0tleSxcbiAgICAgICAgaXNTaWduZXJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoY29uZmlnS2V5c1swXS5wdWJsaWNLZXkuZXF1YWxzKFZBTElEQVRPUl9JTkZPX0tFWSkpIHtcbiAgICAgIGlmIChjb25maWdLZXlzWzFdLmlzU2lnbmVyKSB7XG4gICAgICAgIGNvbnN0IHJhd0luZm8gPSBydXN0U3RyaW5nKCkuZGVjb2RlKEJ1ZmZlci5mcm9tKGJ5dGVBcnJheSkpO1xuICAgICAgICBjb25zdCBpbmZvID0gSlNPTi5wYXJzZShyYXdJbmZvKTtcbiAgICAgICAgYXNzZXJ0JDEoaW5mbywgSW5mb1N0cmluZyk7XG4gICAgICAgIHJldHVybiBuZXcgVmFsaWRhdG9ySW5mbyhjb25maWdLZXlzWzFdLnB1YmxpY0tleSwgaW5mbyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmNvbnN0IFZPVEVfUFJPR1JBTV9JRCA9IG5ldyBQdWJsaWNLZXkoJ1ZvdGUxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcblxuLyoqXG4gKiBIaXN0b3J5IG9mIGhvdyBtYW55IGNyZWRpdHMgZWFybmVkIGJ5IHRoZSBlbmQgb2YgZWFjaCBlcG9jaFxuICovXG5cbi8qKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2xhbmEtbGFicy9zb2xhbmEvYmxvYi84YTEyZWQwMjljZmEzOGQ0YTQ1NDAwOTE2YzI0NjNmYjgyYmJlYzhjL3Byb2dyYW1zL3ZvdGVfYXBpL3NyYy92b3RlX3N0YXRlLnJzI0w2OC1MODhcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgVm90ZUFjY291bnRMYXlvdXQgPSBCdWZmZXJMYXlvdXQuc3RydWN0KFtwdWJsaWNLZXkoJ25vZGVQdWJrZXknKSwgcHVibGljS2V5KCdhdXRob3JpemVkV2l0aGRyYXdlcicpLCBCdWZmZXJMYXlvdXQudTgoJ2NvbW1pc3Npb24nKSwgQnVmZmVyTGF5b3V0Lm51NjQoKSxcbi8vIHZvdGVzLmxlbmd0aFxuQnVmZmVyTGF5b3V0LnNlcShCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQubnU2NCgnc2xvdCcpLCBCdWZmZXJMYXlvdXQudTMyKCdjb25maXJtYXRpb25Db3VudCcpXSksIEJ1ZmZlckxheW91dC5vZmZzZXQoQnVmZmVyTGF5b3V0LnUzMigpLCAtOCksICd2b3RlcycpLCBCdWZmZXJMYXlvdXQudTgoJ3Jvb3RTbG90VmFsaWQnKSwgQnVmZmVyTGF5b3V0Lm51NjQoJ3Jvb3RTbG90JyksIEJ1ZmZlckxheW91dC5udTY0KCksXG4vLyBhdXRob3JpemVkVm90ZXJzLmxlbmd0aFxuQnVmZmVyTGF5b3V0LnNlcShCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQubnU2NCgnZXBvY2gnKSwgcHVibGljS2V5KCdhdXRob3JpemVkVm90ZXInKV0pLCBCdWZmZXJMYXlvdXQub2Zmc2V0KEJ1ZmZlckxheW91dC51MzIoKSwgLTgpLCAnYXV0aG9yaXplZFZvdGVycycpLCBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQuc2VxKEJ1ZmZlckxheW91dC5zdHJ1Y3QoW3B1YmxpY0tleSgnYXV0aG9yaXplZFB1YmtleScpLCBCdWZmZXJMYXlvdXQubnU2NCgnZXBvY2hPZkxhc3RBdXRob3JpemVkU3dpdGNoJyksIEJ1ZmZlckxheW91dC5udTY0KCd0YXJnZXRFcG9jaCcpXSksIDMyLCAnYnVmJyksIEJ1ZmZlckxheW91dC5udTY0KCdpZHgnKSwgQnVmZmVyTGF5b3V0LnU4KCdpc0VtcHR5JyldLCAncHJpb3JWb3RlcnMnKSwgQnVmZmVyTGF5b3V0Lm51NjQoKSxcbi8vIGVwb2NoQ3JlZGl0cy5sZW5ndGhcbkJ1ZmZlckxheW91dC5zZXEoQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0Lm51NjQoJ2Vwb2NoJyksIEJ1ZmZlckxheW91dC5udTY0KCdjcmVkaXRzJyksIEJ1ZmZlckxheW91dC5udTY0KCdwcmV2Q3JlZGl0cycpXSksIEJ1ZmZlckxheW91dC5vZmZzZXQoQnVmZmVyTGF5b3V0LnUzMigpLCAtOCksICdlcG9jaENyZWRpdHMnKSwgQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0Lm51NjQoJ3Nsb3QnKSwgQnVmZmVyTGF5b3V0Lm51NjQoJ3RpbWVzdGFtcCcpXSwgJ2xhc3RUaW1lc3RhbXAnKV0pO1xuLyoqXG4gKiBWb3RlQWNjb3VudCBjbGFzc1xuICovXG5jbGFzcyBWb3RlQWNjb3VudCB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICB0aGlzLm5vZGVQdWJrZXkgPSB2b2lkIDA7XG4gICAgdGhpcy5hdXRob3JpemVkV2l0aGRyYXdlciA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbW1pc3Npb24gPSB2b2lkIDA7XG4gICAgdGhpcy5yb290U2xvdCA9IHZvaWQgMDtcbiAgICB0aGlzLnZvdGVzID0gdm9pZCAwO1xuICAgIHRoaXMuYXV0aG9yaXplZFZvdGVycyA9IHZvaWQgMDtcbiAgICB0aGlzLnByaW9yVm90ZXJzID0gdm9pZCAwO1xuICAgIHRoaXMuZXBvY2hDcmVkaXRzID0gdm9pZCAwO1xuICAgIHRoaXMubGFzdFRpbWVzdGFtcCA9IHZvaWQgMDtcbiAgICB0aGlzLm5vZGVQdWJrZXkgPSBhcmdzLm5vZGVQdWJrZXk7XG4gICAgdGhpcy5hdXRob3JpemVkV2l0aGRyYXdlciA9IGFyZ3MuYXV0aG9yaXplZFdpdGhkcmF3ZXI7XG4gICAgdGhpcy5jb21taXNzaW9uID0gYXJncy5jb21taXNzaW9uO1xuICAgIHRoaXMucm9vdFNsb3QgPSBhcmdzLnJvb3RTbG90O1xuICAgIHRoaXMudm90ZXMgPSBhcmdzLnZvdGVzO1xuICAgIHRoaXMuYXV0aG9yaXplZFZvdGVycyA9IGFyZ3MuYXV0aG9yaXplZFZvdGVycztcbiAgICB0aGlzLnByaW9yVm90ZXJzID0gYXJncy5wcmlvclZvdGVycztcbiAgICB0aGlzLmVwb2NoQ3JlZGl0cyA9IGFyZ3MuZXBvY2hDcmVkaXRzO1xuICAgIHRoaXMubGFzdFRpbWVzdGFtcCA9IGFyZ3MubGFzdFRpbWVzdGFtcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXNlcmlhbGl6ZSBWb3RlQWNjb3VudCBmcm9tIHRoZSBhY2NvdW50IGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSBidWZmZXIgYWNjb3VudCBkYXRhXG4gICAqIEByZXR1cm4gVm90ZUFjY291bnRcbiAgICovXG4gIHN0YXRpYyBmcm9tQWNjb3VudERhdGEoYnVmZmVyKSB7XG4gICAgY29uc3QgdmVyc2lvbk9mZnNldCA9IDQ7XG4gICAgY29uc3QgdmEgPSBWb3RlQWNjb3VudExheW91dC5kZWNvZGUodG9CdWZmZXIoYnVmZmVyKSwgdmVyc2lvbk9mZnNldCk7XG4gICAgbGV0IHJvb3RTbG90ID0gdmEucm9vdFNsb3Q7XG4gICAgaWYgKCF2YS5yb290U2xvdFZhbGlkKSB7XG4gICAgICByb290U2xvdCA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVm90ZUFjY291bnQoe1xuICAgICAgbm9kZVB1YmtleTogbmV3IFB1YmxpY0tleSh2YS5ub2RlUHVia2V5KSxcbiAgICAgIGF1dGhvcml6ZWRXaXRoZHJhd2VyOiBuZXcgUHVibGljS2V5KHZhLmF1dGhvcml6ZWRXaXRoZHJhd2VyKSxcbiAgICAgIGNvbW1pc3Npb246IHZhLmNvbW1pc3Npb24sXG4gICAgICB2b3RlczogdmEudm90ZXMsXG4gICAgICByb290U2xvdCxcbiAgICAgIGF1dGhvcml6ZWRWb3RlcnM6IHZhLmF1dGhvcml6ZWRWb3RlcnMubWFwKHBhcnNlQXV0aG9yaXplZFZvdGVyKSxcbiAgICAgIHByaW9yVm90ZXJzOiBnZXRQcmlvclZvdGVycyh2YS5wcmlvclZvdGVycyksXG4gICAgICBlcG9jaENyZWRpdHM6IHZhLmVwb2NoQ3JlZGl0cyxcbiAgICAgIGxhc3RUaW1lc3RhbXA6IHZhLmxhc3RUaW1lc3RhbXBcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2VBdXRob3JpemVkVm90ZXIoe1xuICBhdXRob3JpemVkVm90ZXIsXG4gIGVwb2NoXG59KSB7XG4gIHJldHVybiB7XG4gICAgZXBvY2gsXG4gICAgYXV0aG9yaXplZFZvdGVyOiBuZXcgUHVibGljS2V5KGF1dGhvcml6ZWRWb3RlcilcbiAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlUHJpb3JWb3RlcnMoe1xuICBhdXRob3JpemVkUHVia2V5LFxuICBlcG9jaE9mTGFzdEF1dGhvcml6ZWRTd2l0Y2gsXG4gIHRhcmdldEVwb2NoXG59KSB7XG4gIHJldHVybiB7XG4gICAgYXV0aG9yaXplZFB1YmtleTogbmV3IFB1YmxpY0tleShhdXRob3JpemVkUHVia2V5KSxcbiAgICBlcG9jaE9mTGFzdEF1dGhvcml6ZWRTd2l0Y2gsXG4gICAgdGFyZ2V0RXBvY2hcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFByaW9yVm90ZXJzKHtcbiAgYnVmLFxuICBpZHgsXG4gIGlzRW1wdHlcbn0pIHtcbiAgaWYgKGlzRW1wdHkpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIFsuLi5idWYuc2xpY2UoaWR4ICsgMSkubWFwKHBhcnNlUHJpb3JWb3RlcnMpLCAuLi5idWYuc2xpY2UoMCwgaWR4KS5tYXAocGFyc2VQcmlvclZvdGVycyldO1xufVxuXG5jb25zdCBlbmRwb2ludCA9IHtcbiAgaHR0cDoge1xuICAgIGRldm5ldDogJ2h0dHA6Ly9hcGkuZGV2bmV0LnNvbGFuYS5jb20nLFxuICAgIHRlc3RuZXQ6ICdodHRwOi8vYXBpLnRlc3RuZXQuc29sYW5hLmNvbScsXG4gICAgJ21haW5uZXQtYmV0YSc6ICdodHRwOi8vYXBpLm1haW5uZXQtYmV0YS5zb2xhbmEuY29tLydcbiAgfSxcbiAgaHR0cHM6IHtcbiAgICBkZXZuZXQ6ICdodHRwczovL2FwaS5kZXZuZXQuc29sYW5hLmNvbScsXG4gICAgdGVzdG5ldDogJ2h0dHBzOi8vYXBpLnRlc3RuZXQuc29sYW5hLmNvbScsXG4gICAgJ21haW5uZXQtYmV0YSc6ICdodHRwczovL2FwaS5tYWlubmV0LWJldGEuc29sYW5hLmNvbS8nXG4gIH1cbn07XG4vKipcbiAqIFJldHJpZXZlcyB0aGUgUlBDIEFQSSBVUkwgZm9yIHRoZSBzcGVjaWZpZWQgY2x1c3RlclxuICogQHBhcmFtIHtDbHVzdGVyfSBbY2x1c3Rlcj1cImRldm5ldFwiXSAtIFRoZSBjbHVzdGVyIG5hbWUgb2YgdGhlIFJQQyBBUEkgVVJMIHRvIHVzZS4gUG9zc2libGUgb3B0aW9uczogJ2Rldm5ldCcgfCAndGVzdG5ldCcgfCAnbWFpbm5ldC1iZXRhJ1xuICogQHBhcmFtIHtib29sZWFufSBbdGxzPVwiaHR0cFwiXSAtIFVzZSBUTFMgd2hlbiBjb25uZWN0aW5nIHRvIGNsdXN0ZXIuXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gVVJMIHN0cmluZyBvZiB0aGUgUlBDIGVuZHBvaW50XG4gKi9cbmZ1bmN0aW9uIGNsdXN0ZXJBcGlVcmwoY2x1c3RlciwgdGxzKSB7XG4gIGNvbnN0IGtleSA9IHRscyA9PT0gZmFsc2UgPyAnaHR0cCcgOiAnaHR0cHMnO1xuICBpZiAoIWNsdXN0ZXIpIHtcbiAgICByZXR1cm4gZW5kcG9pbnRba2V5XVsnZGV2bmV0J107XG4gIH1cbiAgY29uc3QgdXJsID0gZW5kcG9pbnRba2V5XVtjbHVzdGVyXTtcbiAgaWYgKCF1cmwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gJHtrZXl9IGNsdXN0ZXI6ICR7Y2x1c3Rlcn1gKTtcbiAgfVxuICByZXR1cm4gdXJsO1xufVxuXG4vKipcbiAqIFNlbmQgYW5kIGNvbmZpcm0gYSByYXcgdHJhbnNhY3Rpb25cbiAqXG4gKiBJZiBgY29tbWl0bWVudGAgb3B0aW9uIGlzIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvICdtYXgnIGNvbW1pdG1lbnQuXG4gKlxuICogQHBhcmFtIHtDb25uZWN0aW9ufSBjb25uZWN0aW9uXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcmF3VHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb25Db25maXJtYXRpb25TdHJhdGVneX0gY29uZmlybWF0aW9uU3RyYXRlZ3lcbiAqIEBwYXJhbSB7Q29uZmlybU9wdGlvbnN9IFtvcHRpb25zXVxuICogQHJldHVybnMge1Byb21pc2U8VHJhbnNhY3Rpb25TaWduYXR1cmU+fVxuICovXG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgQ2FsbGluZyBgc2VuZEFuZENvbmZpcm1SYXdUcmFuc2FjdGlvbigpYCB3aXRob3V0IGEgYGNvbmZpcm1hdGlvblN0cmF0ZWd5YFxuICogaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuYXN5bmMgZnVuY3Rpb24gc2VuZEFuZENvbmZpcm1SYXdUcmFuc2FjdGlvbihjb25uZWN0aW9uLCByYXdUcmFuc2FjdGlvbiwgY29uZmlybWF0aW9uU3RyYXRlZ3lPckNvbmZpcm1PcHRpb25zLCBtYXliZUNvbmZpcm1PcHRpb25zKSB7XG4gIGxldCBjb25maXJtYXRpb25TdHJhdGVneTtcbiAgbGV0IG9wdGlvbnM7XG4gIGlmIChjb25maXJtYXRpb25TdHJhdGVneU9yQ29uZmlybU9wdGlvbnMgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpcm1hdGlvblN0cmF0ZWd5T3JDb25maXJtT3B0aW9ucywgJ2xhc3RWYWxpZEJsb2NrSGVpZ2h0JykpIHtcbiAgICBjb25maXJtYXRpb25TdHJhdGVneSA9IGNvbmZpcm1hdGlvblN0cmF0ZWd5T3JDb25maXJtT3B0aW9ucztcbiAgICBvcHRpb25zID0gbWF5YmVDb25maXJtT3B0aW9ucztcbiAgfSBlbHNlIGlmIChjb25maXJtYXRpb25TdHJhdGVneU9yQ29uZmlybU9wdGlvbnMgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpcm1hdGlvblN0cmF0ZWd5T3JDb25maXJtT3B0aW9ucywgJ25vbmNlVmFsdWUnKSkge1xuICAgIGNvbmZpcm1hdGlvblN0cmF0ZWd5ID0gY29uZmlybWF0aW9uU3RyYXRlZ3lPckNvbmZpcm1PcHRpb25zO1xuICAgIG9wdGlvbnMgPSBtYXliZUNvbmZpcm1PcHRpb25zO1xuICB9IGVsc2Uge1xuICAgIG9wdGlvbnMgPSBjb25maXJtYXRpb25TdHJhdGVneU9yQ29uZmlybU9wdGlvbnM7XG4gIH1cbiAgY29uc3Qgc2VuZE9wdGlvbnMgPSBvcHRpb25zICYmIHtcbiAgICBza2lwUHJlZmxpZ2h0OiBvcHRpb25zLnNraXBQcmVmbGlnaHQsXG4gICAgcHJlZmxpZ2h0Q29tbWl0bWVudDogb3B0aW9ucy5wcmVmbGlnaHRDb21taXRtZW50IHx8IG9wdGlvbnMuY29tbWl0bWVudCxcbiAgICBtaW5Db250ZXh0U2xvdDogb3B0aW9ucy5taW5Db250ZXh0U2xvdFxuICB9O1xuICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBjb25uZWN0aW9uLnNlbmRSYXdUcmFuc2FjdGlvbihyYXdUcmFuc2FjdGlvbiwgc2VuZE9wdGlvbnMpO1xuICBjb25zdCBjb21taXRtZW50ID0gb3B0aW9ucyAmJiBvcHRpb25zLmNvbW1pdG1lbnQ7XG4gIGNvbnN0IGNvbmZpcm1hdGlvblByb21pc2UgPSBjb25maXJtYXRpb25TdHJhdGVneSA/IGNvbm5lY3Rpb24uY29uZmlybVRyYW5zYWN0aW9uKGNvbmZpcm1hdGlvblN0cmF0ZWd5LCBjb21taXRtZW50KSA6IGNvbm5lY3Rpb24uY29uZmlybVRyYW5zYWN0aW9uKHNpZ25hdHVyZSwgY29tbWl0bWVudCk7XG4gIGNvbnN0IHN0YXR1cyA9IChhd2FpdCBjb25maXJtYXRpb25Qcm9taXNlKS52YWx1ZTtcbiAgaWYgKHN0YXR1cy5lcnIpIHtcbiAgICBpZiAoc2lnbmF0dXJlICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBTZW5kVHJhbnNhY3Rpb25FcnJvcih7XG4gICAgICAgIGFjdGlvbjogc2VuZE9wdGlvbnM/LnNraXBQcmVmbGlnaHQgPyAnc2VuZCcgOiAnc2ltdWxhdGUnLFxuICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZSxcbiAgICAgICAgdHJhbnNhY3Rpb25NZXNzYWdlOiBgU3RhdHVzOiAoJHtKU09OLnN0cmluZ2lmeShzdGF0dXMpfSlgXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBSYXcgdHJhbnNhY3Rpb24gJHtzaWduYXR1cmV9IGZhaWxlZCAoJHtKU09OLnN0cmluZ2lmeShzdGF0dXMpfSlgKTtcbiAgfVxuICByZXR1cm4gc2lnbmF0dXJlO1xufVxuXG4vKipcbiAqIFRoZXJlIGFyZSAxLWJpbGxpb24gbGFtcG9ydHMgaW4gb25lIFNPTFxuICovXG5jb25zdCBMQU1QT1JUU19QRVJfU09MID0gMTAwMDAwMDAwMDtcblxuZXhwb3J0IHsgQWNjb3VudCwgQWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudCwgQWRkcmVzc0xvb2t1cFRhYmxlSW5zdHJ1Y3Rpb24sIEFkZHJlc3NMb29rdXBUYWJsZVByb2dyYW0sIEF1dGhvcml6ZWQsIEJMT0NLSEFTSF9DQUNIRV9USU1FT1VUX01TLCBCUEZfTE9BREVSX0RFUFJFQ0FURURfUFJPR1JBTV9JRCwgQlBGX0xPQURFUl9QUk9HUkFNX0lELCBCcGZMb2FkZXIsIENPTVBVVEVfQlVER0VUX0lOU1RSVUNUSU9OX0xBWU9VVFMsIENvbXB1dGVCdWRnZXRJbnN0cnVjdGlvbiwgQ29tcHV0ZUJ1ZGdldFByb2dyYW0sIENvbm5lY3Rpb24sIEVkMjU1MTlQcm9ncmFtLCBFbnVtLCBFcG9jaFNjaGVkdWxlLCBGZWVDYWxjdWxhdG9yTGF5b3V0LCBLZXlwYWlyLCBMQU1QT1JUU19QRVJfU09MLCBMT09LVVBfVEFCTEVfSU5TVFJVQ1RJT05fTEFZT1VUUywgTG9hZGVyLCBMb2NrdXAsIE1BWF9TRUVEX0xFTkdUSCwgTWVzc2FnZSwgTWVzc2FnZUFjY291bnRLZXlzLCBNZXNzYWdlVjAsIE5PTkNFX0FDQ09VTlRfTEVOR1RILCBOb25jZUFjY291bnQsIFBBQ0tFVF9EQVRBX1NJWkUsIFBVQkxJQ19LRVlfTEVOR1RILCBQdWJsaWNLZXksIFNJR05BVFVSRV9MRU5HVEhfSU5fQllURVMsIFNPTEFOQV9TQ0hFTUEsIFNUQUtFX0NPTkZJR19JRCwgU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUywgU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMsIFNZU1ZBUl9DTE9DS19QVUJLRVksIFNZU1ZBUl9FUE9DSF9TQ0hFRFVMRV9QVUJLRVksIFNZU1ZBUl9JTlNUUlVDVElPTlNfUFVCS0VZLCBTWVNWQVJfUkVDRU5UX0JMT0NLSEFTSEVTX1BVQktFWSwgU1lTVkFSX1JFTlRfUFVCS0VZLCBTWVNWQVJfUkVXQVJEU19QVUJLRVksIFNZU1ZBUl9TTE9UX0hBU0hFU19QVUJLRVksIFNZU1ZBUl9TTE9UX0hJU1RPUllfUFVCS0VZLCBTWVNWQVJfU1RBS0VfSElTVE9SWV9QVUJLRVksIFNlY3AyNTZrMVByb2dyYW0sIFNlbmRUcmFuc2FjdGlvbkVycm9yLCBTb2xhbmFKU09OUlBDRXJyb3IsIFNvbGFuYUpTT05SUENFcnJvckNvZGUsIFN0YWtlQXV0aG9yaXphdGlvbkxheW91dCwgU3Rha2VJbnN0cnVjdGlvbiwgU3Rha2VQcm9ncmFtLCBTdHJ1Y3QsIFN5c3RlbUluc3RydWN0aW9uLCBTeXN0ZW1Qcm9ncmFtLCBUcmFuc2FjdGlvbiwgVHJhbnNhY3Rpb25FeHBpcmVkQmxvY2toZWlnaHRFeGNlZWRlZEVycm9yLCBUcmFuc2FjdGlvbkV4cGlyZWROb25jZUludmFsaWRFcnJvciwgVHJhbnNhY3Rpb25FeHBpcmVkVGltZW91dEVycm9yLCBUcmFuc2FjdGlvbkluc3RydWN0aW9uLCBUcmFuc2FjdGlvbk1lc3NhZ2UsIFRyYW5zYWN0aW9uU3RhdHVzLCBWQUxJREFUT1JfSU5GT19LRVksIFZFUlNJT05fUFJFRklYX01BU0ssIFZPVEVfUFJPR1JBTV9JRCwgVmFsaWRhdG9ySW5mbywgVmVyc2lvbmVkTWVzc2FnZSwgVmVyc2lvbmVkVHJhbnNhY3Rpb24sIFZvdGVBY2NvdW50LCBWb3RlQXV0aG9yaXphdGlvbkxheW91dCwgVm90ZUluaXQsIFZvdGVJbnN0cnVjdGlvbiwgVm90ZVByb2dyYW0sIGNsdXN0ZXJBcGlVcmwsIHNlbmRBbmRDb25maXJtUmF3VHJhbnNhY3Rpb24sIHNlbmRBbmRDb25maXJtVHJhbnNhY3Rpb24gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJCdWZmZXIiLCJlZDI1NTE5IiwiQk4iLCJiczU4Iiwic2hhMjU2Iiwic2VyaWFsaXplIiwiZGVzZXJpYWxpemUiLCJkZXNlcmlhbGl6ZVVuY2hlY2tlZCIsIkJ1ZmZlckxheW91dCIsImJsb2IiLCJnZXRVNjRDb2RlYyIsImdldFU2NEVuY29kZXIiLCJyZXF1aXJlJCQwIiwicmVxdWlyZSQkMCQxIiwicmVxdWlyZSQkMCQyIiwiQWdlbnQiLCJjb2VyY2UiLCJpbnN0YW5jZSIsInN0cmluZyIsInR1cGxlIiwibGl0ZXJhbCIsInVua25vd24iLCJ0eXBlIiwibnVtYmVyIiwiYXJyYXkiLCJudWxsYWJsZSIsIm9wdGlvbmFsIiwiYm9vbGVhbiIsInJlY29yZCIsInVuaW9uIiwiY3JlYXRlIiwiYW55IiwiYXNzZXJ0IiwiYXNzZXJ0JDEiLCJScGNDbGllbnQiLCJub2RlRmV0Y2giLCJDb21tb25DbGllbnQiLCJXZWJTb2NrZXQiLCJrZWNjYWtfMjU2Iiwic2VjcDI1NmsxIiwiZ2VuZXJhdGVQcml2YXRlS2V5IiwidXRpbHMiLCJyYW5kb21Qcml2YXRlS2V5IiwiZ2VuZXJhdGVLZXlwYWlyIiwicHJpdmF0ZVNjYWxhciIsInB1YmxpY0tleSIsImdldFB1YmxpY0tleSIsInNlY3JldEtleSIsIlVpbnQ4QXJyYXkiLCJzZXQiLCJpc09uQ3VydmUiLCJFeHRlbmRlZFBvaW50IiwiZnJvbUhleCIsInNpZ24iLCJtZXNzYWdlIiwic2xpY2UiLCJ2ZXJpZnkiLCJ0b0J1ZmZlciIsImFyciIsImlzQnVmZmVyIiwiZnJvbSIsImJ1ZmZlciIsImJ5dGVPZmZzZXQiLCJieXRlTGVuZ3RoIiwiU3RydWN0IiwiY29uc3RydWN0b3IiLCJwcm9wZXJ0aWVzIiwiT2JqZWN0IiwiYXNzaWduIiwiZW5jb2RlIiwiU09MQU5BX1NDSEVNQSIsImRlY29kZSIsImRhdGEiLCJkZWNvZGVVbmNoZWNrZWQiLCJFbnVtIiwiZW51bSIsImtleXMiLCJsZW5ndGgiLCJFcnJvciIsIm1hcCIsImtleSIsIk1hcCIsIl9QdWJsaWNLZXkiLCJNQVhfU0VFRF9MRU5HVEgiLCJQVUJMSUNfS0VZX0xFTkdUSCIsImlzUHVibGljS2V5RGF0YSIsInZhbHVlIiwiX2JuIiwidW5kZWZpbmVkIiwidW5pcXVlUHVibGljS2V5Q291bnRlciIsIlB1YmxpY0tleSIsImRlY29kZWQiLCJ1bmlxdWUiLCJlcXVhbHMiLCJlcSIsInRvQmFzZTU4IiwidG9CeXRlcyIsInRvSlNPTiIsImJ1ZiIsImIiLCJ0b0FycmF5TGlrZSIsInplcm9QYWQiLCJhbGxvYyIsImNvcHkiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsInRvU3RyaW5nIiwiY3JlYXRlV2l0aFNlZWQiLCJmcm9tUHVibGljS2V5Iiwic2VlZCIsInByb2dyYW1JZCIsImNvbmNhdCIsInB1YmxpY0tleUJ5dGVzIiwiY3JlYXRlUHJvZ3JhbUFkZHJlc3NTeW5jIiwic2VlZHMiLCJmb3JFYWNoIiwiVHlwZUVycm9yIiwiY3JlYXRlUHJvZ3JhbUFkZHJlc3MiLCJmaW5kUHJvZ3JhbUFkZHJlc3NTeW5jIiwibm9uY2UiLCJhZGRyZXNzIiwic2VlZHNXaXRoTm9uY2UiLCJlcnIiLCJmaW5kUHJvZ3JhbUFkZHJlc3MiLCJwdWJrZXlEYXRhIiwicHVia2V5IiwiZGVmYXVsdCIsImtpbmQiLCJmaWVsZHMiLCJBY2NvdW50IiwiX3B1YmxpY0tleSIsIl9zZWNyZXRLZXkiLCJzZWNyZXRLZXlCdWZmZXIiLCJCUEZfTE9BREVSX0RFUFJFQ0FURURfUFJPR1JBTV9JRCIsIlBBQ0tFVF9EQVRBX1NJWkUiLCJWRVJTSU9OX1BSRUZJWF9NQVNLIiwiU0lHTkFUVVJFX0xFTkdUSF9JTl9CWVRFUyIsIlRyYW5zYWN0aW9uRXhwaXJlZEJsb2NraGVpZ2h0RXhjZWVkZWRFcnJvciIsInNpZ25hdHVyZSIsImRlZmluZVByb3BlcnR5IiwicHJvdG90eXBlIiwiVHJhbnNhY3Rpb25FeHBpcmVkVGltZW91dEVycm9yIiwidGltZW91dFNlY29uZHMiLCJ0b0ZpeGVkIiwiVHJhbnNhY3Rpb25FeHBpcmVkTm9uY2VJbnZhbGlkRXJyb3IiLCJNZXNzYWdlQWNjb3VudEtleXMiLCJzdGF0aWNBY2NvdW50S2V5cyIsImFjY291bnRLZXlzRnJvbUxvb2t1cHMiLCJrZXlTZWdtZW50cyIsInB1c2giLCJ3cml0YWJsZSIsInJlYWRvbmx5IiwiZ2V0IiwiaW5kZXgiLCJrZXlTZWdtZW50IiwiZmxhdCIsImNvbXBpbGVJbnN0cnVjdGlvbnMiLCJpbnN0cnVjdGlvbnMiLCJVOF9NQVgiLCJrZXlJbmRleE1hcCIsImZpbmRLZXlJbmRleCIsImtleUluZGV4IiwiaW5zdHJ1Y3Rpb24iLCJwcm9ncmFtSWRJbmRleCIsImFjY291bnRLZXlJbmRleGVzIiwibWV0YSIsInByb3BlcnR5IiwicnVzdFN0cmluZyIsInJzbCIsInN0cnVjdCIsInUzMiIsIm9mZnNldCIsIl9kZWNvZGUiLCJiaW5kIiwiX2VuY29kZSIsInJzbFNoaW0iLCJzdHIiLCJjaGFycyIsInNwYW4iLCJhdXRob3JpemVkIiwibG9ja3VwIiwibnM2NCIsInZvdGVJbml0IiwidTgiLCJ2b3RlQXV0aG9yaXplV2l0aFNlZWRBcmdzIiwiZ2V0QWxsb2MiLCJnZXRJdGVtQWxsb2MiLCJpdGVtIiwiZmllbGQiLCJBcnJheSIsImlzQXJyYXkiLCJlbGVtZW50TGF5b3V0IiwibGF5b3V0IiwiZGVjb2RlTGVuZ3RoIiwiYnl0ZXMiLCJsZW4iLCJzaXplIiwiZWxlbSIsInNoaWZ0IiwiZW5jb2RlTGVuZ3RoIiwicmVtX2xlbiIsImNvbmRpdGlvbiIsIkNvbXBpbGVkS2V5cyIsInBheWVyIiwia2V5TWV0YU1hcCIsImNvbXBpbGUiLCJnZXRPckluc2VydERlZmF1bHQiLCJrZXlNZXRhIiwiaXNTaWduZXIiLCJpc1dyaXRhYmxlIiwiaXNJbnZva2VkIiwicGF5ZXJLZXlNZXRhIiwiaXgiLCJhY2NvdW50TWV0YSIsImdldE1lc3NhZ2VDb21wb25lbnRzIiwibWFwRW50cmllcyIsImVudHJpZXMiLCJ3cml0YWJsZVNpZ25lcnMiLCJmaWx0ZXIiLCJyZWFkb25seVNpZ25lcnMiLCJ3cml0YWJsZU5vblNpZ25lcnMiLCJyZWFkb25seU5vblNpZ25lcnMiLCJoZWFkZXIiLCJudW1SZXF1aXJlZFNpZ25hdHVyZXMiLCJudW1SZWFkb25seVNpZ25lZEFjY291bnRzIiwibnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzIiwicGF5ZXJBZGRyZXNzIiwiZXh0cmFjdFRhYmxlTG9va3VwIiwibG9va3VwVGFibGUiLCJ3cml0YWJsZUluZGV4ZXMiLCJkcmFpbmVkV3JpdGFibGVLZXlzIiwiZHJhaW5LZXlzRm91bmRJbkxvb2t1cFRhYmxlIiwic3RhdGUiLCJhZGRyZXNzZXMiLCJyZWFkb25seUluZGV4ZXMiLCJkcmFpbmVkUmVhZG9ubHlLZXlzIiwiYWNjb3VudEtleSIsImxvb2t1cFRhYmxlRW50cmllcyIsImtleU1ldGFGaWx0ZXIiLCJsb29rdXBUYWJsZUluZGV4ZXMiLCJkcmFpbmVkS2V5cyIsImxvb2t1cFRhYmxlSW5kZXgiLCJmaW5kSW5kZXgiLCJlbnRyeSIsImRlbGV0ZSIsIkVORF9PRl9CVUZGRVJfRVJST1JfTUVTU0FHRSIsImd1YXJkZWRTaGlmdCIsImJ5dGVBcnJheSIsImd1YXJkZWRTcGxpY2UiLCJhcmdzIiwic3RhcnQiLCJzcGxpY2UiLCJNZXNzYWdlIiwiYWNjb3VudEtleXMiLCJyZWNlbnRCbG9ja2hhc2giLCJpbmRleFRvUHJvZ3JhbUlkcyIsImFjY291bnQiLCJ2ZXJzaW9uIiwiY29tcGlsZWRJbnN0cnVjdGlvbnMiLCJhY2NvdW50cyIsImFkZHJlc3NUYWJsZUxvb2t1cHMiLCJnZXRBY2NvdW50S2V5cyIsImNvbXBpbGVkS2V5cyIsInBheWVyS2V5IiwiaXNBY2NvdW50U2lnbmVyIiwiaXNBY2NvdW50V3JpdGFibGUiLCJudW1TaWduZWRBY2NvdW50cyIsInVuc2lnbmVkQWNjb3VudEluZGV4IiwibnVtVW5zaWduZWRBY2NvdW50cyIsIm51bVdyaXRhYmxlVW5zaWduZWRBY2NvdW50cyIsIm51bVdyaXRhYmxlU2lnbmVkQWNjb3VudHMiLCJpc1Byb2dyYW1JZCIsImhhcyIsInByb2dyYW1JZHMiLCJ2YWx1ZXMiLCJub25Qcm9ncmFtSWRzIiwiXyIsIm51bUtleXMiLCJrZXlDb3VudCIsImtleUluZGljZXNDb3VudCIsImRhdGFDb3VudCIsImtleUluZGljZXMiLCJkYXRhTGVuZ3RoIiwiaW5zdHJ1Y3Rpb25Db3VudCIsImluc3RydWN0aW9uQnVmZmVyIiwiaW5zdHJ1Y3Rpb25CdWZmZXJMZW5ndGgiLCJpbnN0cnVjdGlvbkxheW91dCIsInNlcSIsInNpZ25EYXRhTGF5b3V0IiwidHJhbnNhY3Rpb24iLCJzaWduRGF0YSIsImFjY291bnRDb3VudCIsImkiLCJkYXRhU2xpY2UiLCJtZXNzYWdlQXJncyIsIk1lc3NhZ2VWMCIsIm51bUFjY291bnRLZXlzRnJvbUxvb2t1cHMiLCJjb3VudCIsImxvb2t1cCIsImFkZHJlc3NMb29rdXBUYWJsZUFjY291bnRzIiwicmVzb2x2ZUFkZHJlc3NUYWJsZUxvb2t1cHMiLCJudW1TdGF0aWNBY2NvdW50S2V5cyIsImxvb2t1cEFjY291bnRLZXlzSW5kZXgiLCJudW1Xcml0YWJsZUxvb2t1cEFjY291bnRLZXlzIiwicmVkdWNlIiwidGFibGVMb29rdXAiLCJ0YWJsZUFjY291bnQiLCJmaW5kIiwibG9va3VwVGFibGVBY2NvdW50cyIsImV4dHJhY3RSZXN1bHQiLCJhZGRyZXNzVGFibGVMb29rdXAiLCJlbmNvZGVkU3RhdGljQWNjb3VudEtleXNMZW5ndGgiLCJzZXJpYWxpemVkSW5zdHJ1Y3Rpb25zIiwic2VyaWFsaXplSW5zdHJ1Y3Rpb25zIiwiZW5jb2RlZEluc3RydWN0aW9uc0xlbmd0aCIsInNlcmlhbGl6ZWRBZGRyZXNzVGFibGVMb29rdXBzIiwic2VyaWFsaXplQWRkcmVzc1RhYmxlTG9va3VwcyIsImVuY29kZWRBZGRyZXNzVGFibGVMb29rdXBzTGVuZ3RoIiwibWVzc2FnZUxheW91dCIsInNlcmlhbGl6ZWRNZXNzYWdlIiwiTUVTU0FHRV9WRVJTSU9OXzBfUFJFRklYIiwic2VyaWFsaXplZE1lc3NhZ2VMZW5ndGgiLCJwcmVmaXgiLCJzdGF0aWNBY2NvdW50S2V5c0xlbmd0aCIsImluc3RydWN0aW9uc0xlbmd0aCIsImFkZHJlc3NUYWJsZUxvb2t1cHNMZW5ndGgiLCJzZXJpYWxpemVkTGVuZ3RoIiwiZW5jb2RlZEFjY291bnRLZXlJbmRleGVzTGVuZ3RoIiwiZW5jb2RlZERhdGFMZW5ndGgiLCJlbmNvZGVkV3JpdGFibGVJbmRleGVzTGVuZ3RoIiwiZW5jb2RlZFJlYWRvbmx5SW5kZXhlc0xlbmd0aCIsImFkZHJlc3NUYWJsZUxvb2t1cExheW91dCIsIm1hc2tlZFByZWZpeCIsImFjY291bnRLZXlJbmRleGVzTGVuZ3RoIiwiYWRkcmVzc1RhYmxlTG9va3Vwc0NvdW50Iiwid3JpdGFibGVJbmRleGVzTGVuZ3RoIiwicmVhZG9ubHlJbmRleGVzTGVuZ3RoIiwiVmVyc2lvbmVkTWVzc2FnZSIsImRlc2VyaWFsaXplTWVzc2FnZVZlcnNpb24iLCJUcmFuc2FjdGlvblN0YXR1cyIsIkRFRkFVTFRfU0lHTkFUVVJFIiwiZmlsbCIsIlRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24iLCJvcHRzIiwiVHJhbnNhY3Rpb24iLCJzaWduYXR1cmVzIiwiZmVlUGF5ZXIiLCJsYXN0VmFsaWRCbG9ja0hlaWdodCIsIm5vbmNlSW5mbyIsIm1pbk5vbmNlQ29udGV4dFNsb3QiLCJfbWVzc2FnZSIsIl9qc29uIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwibWluQ29udGV4dFNsb3QiLCJibG9ja2hhc2giLCJub25jZUluc3RydWN0aW9uIiwic2lnbmVycyIsImFkZCIsIml0ZW1zIiwiY29tcGlsZU1lc3NhZ2UiLCJKU09OIiwic3RyaW5naWZ5IiwiY29uc29sZSIsIndhcm4iLCJhY2NvdW50TWV0YXMiLCJpbmNsdWRlcyIsInVuaXF1ZU1ldGFzIiwicHVia2V5U3RyaW5nIiwidW5pcXVlSW5kZXgiLCJ4Iiwic29ydCIsInkiLCJvcHRpb25zIiwibG9jYWxlTWF0Y2hlciIsInVzYWdlIiwic2Vuc2l0aXZpdHkiLCJpZ25vcmVQdW5jdHVhdGlvbiIsIm51bWVyaWMiLCJjYXNlRmlyc3QiLCJsb2NhbGVDb21wYXJlIiwiZmVlUGF5ZXJJbmRleCIsInBheWVyTWV0YSIsInVuc2hpZnQiLCJzaWduZWRLZXlzIiwidW5zaWduZWRLZXlzIiwiaW5kZXhPZiIsIl9jb21waWxlIiwidmFsaWQiLCJldmVyeSIsInBhaXIiLCJzZXJpYWxpemVNZXNzYWdlIiwiZ2V0RXN0aW1hdGVkRmVlIiwiY29ubmVjdGlvbiIsImdldEZlZUZvck1lc3NhZ2UiLCJzZXRTaWduZXJzIiwic2VlbiIsIlNldCIsInVuaXF1ZVNpZ25lcnMiLCJzaWduZXIiLCJfcGFydGlhbFNpZ24iLCJwYXJ0aWFsU2lnbiIsIl9hZGRTaWduYXR1cmUiLCJhZGRTaWduYXR1cmUiLCJzaWdwYWlyIiwidmVyaWZ5U2lnbmF0dXJlcyIsInJlcXVpcmVBbGxTaWduYXR1cmVzIiwic2lnbmF0dXJlRXJyb3JzIiwiX2dldE1lc3NhZ2VTaWduZWRuZXNzRXJyb3JzIiwiZXJyb3JzIiwibWlzc2luZyIsImludmFsaWQiLCJjb25maWciLCJzaWdFcnJvcnMiLCJlcnJvck1lc3NhZ2UiLCJwIiwiam9pbiIsIl9zZXJpYWxpemUiLCJzaWduYXR1cmVDb3VudCIsInRyYW5zYWN0aW9uTGVuZ3RoIiwid2lyZVRyYW5zYWN0aW9uIiwia2V5T2JqIiwicG9wdWxhdGUiLCJzaWdQdWJrZXlQYWlyIiwic29tZSIsIlRyYW5zYWN0aW9uTWVzc2FnZSIsImRlY29tcGlsZSIsImNvbXBpbGVkSXgiLCJjb21waWxlVG9MZWdhY3lNZXNzYWdlIiwiY29tcGlsZVRvVjBNZXNzYWdlIiwiVmVyc2lvbmVkVHJhbnNhY3Rpb24iLCJkZWZhdWx0U2lnbmF0dXJlcyIsImVuY29kZWRTaWduYXR1cmVzTGVuZ3RoIiwidHJhbnNhY3Rpb25MYXlvdXQiLCJzZXJpYWxpemVkVHJhbnNhY3Rpb24iLCJzZXJpYWxpemVkVHJhbnNhY3Rpb25MZW5ndGgiLCJzaWduYXR1cmVzTGVuZ3RoIiwibWVzc2FnZURhdGEiLCJzaWduZXJQdWJrZXlzIiwic2lnbmVySW5kZXgiLCJOVU1fVElDS1NfUEVSX1NFQ09ORCIsIkRFRkFVTFRfVElDS1NfUEVSX1NMT1QiLCJOVU1fU0xPVFNfUEVSX1NFQ09ORCIsIk1TX1BFUl9TTE9UIiwiU1lTVkFSX0NMT0NLX1BVQktFWSIsIlNZU1ZBUl9FUE9DSF9TQ0hFRFVMRV9QVUJLRVkiLCJTWVNWQVJfSU5TVFJVQ1RJT05TX1BVQktFWSIsIlNZU1ZBUl9SRUNFTlRfQkxPQ0tIQVNIRVNfUFVCS0VZIiwiU1lTVkFSX1JFTlRfUFVCS0VZIiwiU1lTVkFSX1JFV0FSRFNfUFVCS0VZIiwiU1lTVkFSX1NMT1RfSEFTSEVTX1BVQktFWSIsIlNZU1ZBUl9TTE9UX0hJU1RPUllfUFVCS0VZIiwiU1lTVkFSX1NUQUtFX0hJU1RPUllfUFVCS0VZIiwiU2VuZFRyYW5zYWN0aW9uRXJyb3IiLCJhY3Rpb24iLCJ0cmFuc2FjdGlvbk1lc3NhZ2UiLCJsb2dzIiwibWF5YmVMb2dzT3V0cHV0IiwiZ3VpZGVUZXh0IiwiYSIsInRyYW5zYWN0aW9uTG9ncyIsInRyYW5zYWN0aW9uRXJyb3IiLCJjYWNoZWRMb2dzIiwiZ2V0TG9ncyIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiZ2V0VHJhbnNhY3Rpb24iLCJ0aGVuIiwidHgiLCJsb2dNZXNzYWdlcyIsImNhdGNoIiwiU29sYW5hSlNPTlJQQ0Vycm9yQ29kZSIsIkpTT05fUlBDX1NFUlZFUl9FUlJPUl9CTE9DS19DTEVBTkVEX1VQIiwiSlNPTl9SUENfU0VSVkVSX0VSUk9SX1NFTkRfVFJBTlNBQ1RJT05fUFJFRkxJR0hUX0ZBSUxVUkUiLCJKU09OX1JQQ19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fU0lHTkFUVVJFX1ZFUklGSUNBVElPTl9GQUlMVVJFIiwiSlNPTl9SUENfU0VSVkVSX0VSUk9SX0JMT0NLX05PVF9BVkFJTEFCTEUiLCJKU09OX1JQQ19TRVJWRVJfRVJST1JfTk9ERV9VTkhFQUxUSFkiLCJKU09OX1JQQ19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fUFJFQ09NUElMRV9WRVJJRklDQVRJT05fRkFJTFVSRSIsIkpTT05fUlBDX1NFUlZFUl9FUlJPUl9TTE9UX1NLSVBQRUQiLCJKU09OX1JQQ19TRVJWRVJfRVJST1JfTk9fU05BUFNIT1QiLCJKU09OX1JQQ19TRVJWRVJfRVJST1JfTE9OR19URVJNX1NUT1JBR0VfU0xPVF9TS0lQUEVEIiwiSlNPTl9SUENfU0VSVkVSX0VSUk9SX0tFWV9FWENMVURFRF9GUk9NX1NFQ09OREFSWV9JTkRFWCIsIkpTT05fUlBDX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9ISVNUT1JZX05PVF9BVkFJTEFCTEUiLCJKU09OX1JQQ19TQ0FOX0VSUk9SIiwiSlNPTl9SUENfU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX1NJR05BVFVSRV9MRU5fTUlTTUFUQ0giLCJKU09OX1JQQ19TRVJWRVJfRVJST1JfQkxPQ0tfU1RBVFVTX05PVF9BVkFJTEFCTEVfWUVUIiwiSlNPTl9SUENfU0VSVkVSX0VSUk9SX1VOU1VQUE9SVEVEX1RSQU5TQUNUSU9OX1ZFUlNJT04iLCJKU09OX1JQQ19TRVJWRVJfRVJST1JfTUlOX0NPTlRFWFRfU0xPVF9OT1RfUkVBQ0hFRCIsIlNvbGFuYUpTT05SUENFcnJvciIsImNvZGUiLCJjdXN0b21NZXNzYWdlIiwibmFtZSIsInNlbmRBbmRDb25maXJtVHJhbnNhY3Rpb24iLCJzZW5kT3B0aW9ucyIsInNraXBQcmVmbGlnaHQiLCJwcmVmbGlnaHRDb21taXRtZW50IiwiY29tbWl0bWVudCIsIm1heFJldHJpZXMiLCJzZW5kVHJhbnNhY3Rpb24iLCJzdGF0dXMiLCJjb25maXJtVHJhbnNhY3Rpb24iLCJhYm9ydFNpZ25hbCIsIm5vbmNlQWNjb3VudFB1YmtleSIsIm5vbmNlVmFsdWUiLCJzbGVlcCIsIm1zIiwic2V0VGltZW91dCIsImVuY29kZURhdGEiLCJhbGxvY0xlbmd0aCIsImxheW91dEZpZWxkcyIsImRlY29kZURhdGEkMSIsIkZlZUNhbGN1bGF0b3JMYXlvdXQiLCJudTY0IiwiTm9uY2VBY2NvdW50TGF5b3V0IiwiTk9OQ0VfQUNDT1VOVF9MRU5HVEgiLCJOb25jZUFjY291bnQiLCJhdXRob3JpemVkUHVia2V5IiwiZmVlQ2FsY3VsYXRvciIsImZyb21BY2NvdW50RGF0YSIsIm5vbmNlQWNjb3VudCIsInU2NCIsImJpZ0ludExheW91dCIsImNvZGVjIiwic3JjIiwiYmlnSW50IiwiU3lzdGVtSW5zdHJ1Y3Rpb24iLCJkZWNvZGVJbnN0cnVjdGlvblR5cGUiLCJjaGVja1Byb2dyYW1JZCIsImluc3RydWN0aW9uVHlwZUxheW91dCIsInR5cGVJbmRleCIsIml4VHlwZSIsIlNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTIiwiZGVjb2RlQ3JlYXRlQWNjb3VudCIsImNoZWNrS2V5TGVuZ3RoIiwibGFtcG9ydHMiLCJzcGFjZSIsIkNyZWF0ZSIsImZyb21QdWJrZXkiLCJuZXdBY2NvdW50UHVia2V5IiwiZGVjb2RlVHJhbnNmZXIiLCJUcmFuc2ZlciIsInRvUHVia2V5IiwiZGVjb2RlVHJhbnNmZXJXaXRoU2VlZCIsIlRyYW5zZmVyV2l0aFNlZWQiLCJiYXNlUHVia2V5IiwiZGVjb2RlQWxsb2NhdGUiLCJBbGxvY2F0ZSIsImFjY291bnRQdWJrZXkiLCJkZWNvZGVBbGxvY2F0ZVdpdGhTZWVkIiwiYmFzZSIsIkFsbG9jYXRlV2l0aFNlZWQiLCJkZWNvZGVBc3NpZ24iLCJBc3NpZ24iLCJkZWNvZGVBc3NpZ25XaXRoU2VlZCIsIkFzc2lnbldpdGhTZWVkIiwiZGVjb2RlQ3JlYXRlV2l0aFNlZWQiLCJDcmVhdGVXaXRoU2VlZCIsImRlY29kZU5vbmNlSW5pdGlhbGl6ZSIsIkluaXRpYWxpemVOb25jZUFjY291bnQiLCJub25jZVB1YmtleSIsImRlY29kZU5vbmNlQWR2YW5jZSIsIkFkdmFuY2VOb25jZUFjY291bnQiLCJkZWNvZGVOb25jZVdpdGhkcmF3IiwiV2l0aGRyYXdOb25jZUFjY291bnQiLCJkZWNvZGVOb25jZUF1dGhvcml6ZSIsIkF1dGhvcml6ZU5vbmNlQWNjb3VudCIsIm5ld0F1dGhvcml6ZWRQdWJrZXkiLCJTeXN0ZW1Qcm9ncmFtIiwiZXhwZWN0ZWRMZW5ndGgiLCJmcmVlemUiLCJVcGdyYWRlTm9uY2VBY2NvdW50IiwiY3JlYXRlQWNjb3VudCIsInBhcmFtcyIsInRyYW5zZmVyIiwiQmlnSW50IiwiY3JlYXRlQWNjb3VudFdpdGhTZWVkIiwiY3JlYXRlTm9uY2VBY2NvdW50IiwiaW5pdFBhcmFtcyIsIm5vbmNlSW5pdGlhbGl6ZSIsImluc3RydWN0aW9uRGF0YSIsIm5vbmNlQWR2YW5jZSIsIm5vbmNlV2l0aGRyYXciLCJub25jZUF1dGhvcml6ZSIsImFsbG9jYXRlIiwiQ0hVTktfU0laRSIsIkxvYWRlciIsImdldE1pbk51bVNpZ25hdHVyZXMiLCJNYXRoIiwiY2VpbCIsImNodW5rU2l6ZSIsImxvYWQiLCJwcm9ncmFtIiwiYmFsYW5jZU5lZWRlZCIsImdldE1pbmltdW1CYWxhbmNlRm9yUmVudEV4ZW1wdGlvbiIsInByb2dyYW1JbmZvIiwiZ2V0QWNjb3VudEluZm8iLCJleGVjdXRhYmxlIiwiZXJyb3IiLCJvd25lciIsImRhdGFMYXlvdXQiLCJ0cmFuc2FjdGlvbnMiLCJieXRlc0xlbmd0aCIsImJ5dGVzTGVuZ3RoUGFkZGluZyIsIl9ycGNFbmRwb2ludCIsIlJFUVVFU1RTX1BFUl9TRUNPTkQiLCJhbGwiLCJkZXBsb3lDb21taXRtZW50IiwiZmluYWxpemVTaWduYXR1cmUiLCJjb250ZXh0IiwiY3VycmVudFNsb3QiLCJnZXRTbG90Iiwic2xvdCIsInJvdW5kIiwiQlBGX0xPQURFUl9QUk9HUkFNX0lEIiwiQnBmTG9hZGVyIiwiZWxmIiwibG9hZGVyUHJvZ3JhbUlkIiwiZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMiLCJfX2VzTW9kdWxlIiwiYWdlbnRrZWVwYWxpdmUiLCJleHBvcnRzIiwiaGFzUmVxdWlyZWRNcyIsInJlcXVpcmVNcyIsInMiLCJtIiwiaCIsImQiLCJ3IiwidmFsIiwicGFyc2UiLCJpc0Zpbml0ZSIsImxvbmciLCJmbXRMb25nIiwiZm10U2hvcnQiLCJTdHJpbmciLCJtYXRjaCIsImV4ZWMiLCJuIiwicGFyc2VGbG9hdCIsInRvTG93ZXJDYXNlIiwibXNBYnMiLCJhYnMiLCJwbHVyYWwiLCJpc1BsdXJhbCIsImh1bWFuaXplTXMiLCJoYXNSZXF1aXJlZEh1bWFuaXplTXMiLCJyZXF1aXJlSHVtYW5pemVNcyIsInV0aWwiLCJ0IiwiciIsImZvcm1hdCIsInN0YWNrIiwiY29uc3RhbnRzIiwiaGFzUmVxdWlyZWRDb25zdGFudHMiLCJyZXF1aXJlQ29uc3RhbnRzIiwiQ1VSUkVOVF9JRCIsIkNSRUFURV9JRCIsIklOSVRfU09DS0VUIiwiQ1JFQVRFX0hUVFBTX0NPTk5FQ1RJT04iLCJTT0NLRVRfQ1JFQVRFRF9USU1FIiwiU09DS0VUX05BTUUiLCJTT0NLRVRfUkVRVUVTVF9DT1VOVCIsIlNPQ0tFVF9SRVFVRVNUX0ZJTklTSEVEX0NPVU5UIiwiYWdlbnQiLCJoYXNSZXF1aXJlZEFnZW50IiwicmVxdWlyZUFnZW50IiwiT3JpZ2luYWxBZ2VudCIsImRlYnVnIiwiZGVidWdsb2ciLCJkZWZhdWx0VGltZW91dExpc3RlbmVyQ291bnQiLCJtYWpvclZlcnNpb24iLCJwYXJzZUludCIsInByb2Nlc3MiLCJzcGxpdCIsInN1YnN0cmluZyIsImRlcHJlY2F0ZSIsImxvZyIsImtlZXBBbGl2ZSIsImZyZWVTb2NrZXRUaW1lb3V0Iiwia2VlcEFsaXZlVGltZW91dCIsImZyZWVTb2NrZXRLZWVwQWxpdmVUaW1lb3V0IiwidGltZW91dCIsIm1heCIsInNvY2tldEFjdGl2ZVRUTCIsImNyZWF0ZVNvY2tldENvdW50IiwiY3JlYXRlU29ja2V0Q291bnRMYXN0Q2hlY2siLCJjcmVhdGVTb2NrZXRFcnJvckNvdW50IiwiY3JlYXRlU29ja2V0RXJyb3JDb3VudExhc3RDaGVjayIsImNsb3NlU29ja2V0Q291bnQiLCJjbG9zZVNvY2tldENvdW50TGFzdENoZWNrIiwiZXJyb3JTb2NrZXRDb3VudCIsImVycm9yU29ja2V0Q291bnRMYXN0Q2hlY2siLCJyZXF1ZXN0Q291bnQiLCJyZXF1ZXN0Q291bnRMYXN0Q2hlY2siLCJ0aW1lb3V0U29ja2V0Q291bnQiLCJ0aW1lb3V0U29ja2V0Q291bnRMYXN0Q2hlY2siLCJvbiIsInNvY2tldCIsImNhbGNTb2NrZXRUaW1lb3V0IiwiYWxpdmVUaW1lIiwiRGF0ZSIsIm5vdyIsImRpZmYiLCJjdXN0b21GcmVlU29ja2V0VGltZW91dCIsImtlZXBTb2NrZXRBbGl2ZSIsInJlc3VsdCIsImN1c3RvbVRpbWVvdXQiLCJyZXVzZVNvY2tldCIsInJlcSIsInJldXNlZFNvY2tldCIsImFnZW50VGltZW91dCIsImdldFNvY2tldFRpbWVvdXQiLCJpZCIsIk51bWJlciIsIk1BWF9TQUZFX0lOVEVHRVIiLCJzZXROb0RlbGF5IiwiX2FnZW50S2V5IiwiaW5zdGFsbExpc3RlbmVycyIsImNyZWF0ZUNvbm5lY3Rpb24iLCJvbmNyZWF0ZSIsImNhbGxlZCIsIm9uTmV3Q3JlYXRlIiwibmV3U29ja2V0Iiwic3RhdHVzQ2hhbmdlZCIsImNoYW5nZWQiLCJnZXRDdXJyZW50U3RhdHVzIiwiZnJlZVNvY2tldHMiLCJpbnNwZWN0Iiwic29ja2V0cyIsInJlcXVlc3RzIiwiX2lkbGVUaW1lb3V0Iiwib25GcmVlIiwiX2h0dHBNZXNzYWdlIiwiZ2V0TmFtZSIsIm9uQ2xvc2UiLCJpc0Vycm9yIiwib25UaW1lb3V0IiwibGlzdGVuZXJDb3VudCIsImxpc3RlbmVycyIsInJlcVRpbWVvdXRMaXN0ZW5lckNvdW50IiwiZW5hYmxlZCIsImYiLCJkZXN0cm95IiwicmVtb3ZlU29ja2V0Iiwib25FcnJvciIsInJlbW92ZUxpc3RlbmVyIiwiZW1pdCIsIm9uUmVtb3ZlIiwib2JqIiwicmVzIiwiaHR0cHNfYWdlbnQiLCJoYXNSZXF1aXJlZEh0dHBzX2FnZW50IiwicmVxdWlyZUh0dHBzX2FnZW50IiwiT3JpZ2luYWxIdHRwc0FnZW50IiwiSHR0cEFnZW50IiwiSHR0cHNBZ2VudCIsImRlZmF1bHRQb3J0IiwicHJvdG9jb2wiLCJtYXhDYWNoZWRTZXNzaW9ucyIsIl9zZXNzaW9uQ2FjaGUiLCJsaXN0IiwibWV0aG9kIiwiaGFzUmVxdWlyZWRBZ2VudGtlZXBhbGl2ZSIsInJlcXVpcmVBZ2VudGtlZXBhbGl2ZSIsImFnZW50a2VlcGFsaXZlRXhwb3J0cyIsIkh0dHBLZWVwQWxpdmVBZ2VudCIsImZhc3RTdGFibGVTdHJpbmdpZnkkMSIsImhhc1JlcXVpcmVkRmFzdFN0YWJsZVN0cmluZ2lmeSIsInJlcXVpcmVGYXN0U3RhYmxlU3RyaW5naWZ5Iiwib2JqVG9TdHJpbmciLCJvYmpLZXlzIiwiaXNBcnJheVByb3AiLCJwcm9wVmFsIiwidG9TdHIiLCJyZXR1cm5WYWwiLCJmYXN0U3RhYmxlU3RyaW5naWZ5RXhwb3J0cyIsImZhc3RTdGFibGVTdHJpbmdpZnkiLCJNSU5JTVVNX1NMT1RfUEVSX0VQT0NIIiwidHJhaWxpbmdaZXJvcyIsIm5leHRQb3dlck9mVHdvIiwiRXBvY2hTY2hlZHVsZSIsInNsb3RzUGVyRXBvY2giLCJsZWFkZXJTY2hlZHVsZVNsb3RPZmZzZXQiLCJ3YXJtdXAiLCJmaXJzdE5vcm1hbEVwb2NoIiwiZmlyc3ROb3JtYWxTbG90IiwiZ2V0RXBvY2giLCJnZXRFcG9jaEFuZFNsb3RJbmRleCIsImVwb2NoIiwiZXBvY2hMZW4iLCJnZXRTbG90c0luRXBvY2giLCJzbG90SW5kZXgiLCJub3JtYWxTbG90SW5kZXgiLCJub3JtYWxFcG9jaEluZGV4IiwiZmxvb3IiLCJnZXRGaXJzdFNsb3RJbkVwb2NoIiwicG93IiwiZ2V0TGFzdFNsb3RJbkVwb2NoIiwiZmV0Y2hJbXBsIiwiZ2xvYmFsVGhpcyIsImZldGNoIiwiaW5wdXQiLCJpbml0IiwicHJvY2Vzc2VkSW5wdXQiLCJScGNXZWJTb2NrZXRDbGllbnQiLCJnZW5lcmF0ZV9yZXF1ZXN0X2lkIiwid2ViU29ja2V0RmFjdG9yeSIsInVybCIsInJwYyIsImF1dG9jb25uZWN0IiwibWF4X3JlY29ubmVjdHMiLCJyZWNvbm5lY3QiLCJyZWNvbm5lY3RfaW50ZXJ2YWwiLCJ1bmRlcmx5aW5nU29ja2V0IiwicmVhZHlTdGF0ZSIsIm5vdGlmeSIsImRlY29kZURhdGEiLCJMT09LVVBfVEFCTEVfTUVUQV9TSVpFIiwiQWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudCIsImlzQWN0aXZlIiwiVTY0X01BWCIsImRlYWN0aXZhdGlvblNsb3QiLCJhY2NvdW50RGF0YSIsIkxvb2t1cFRhYmxlTWV0YUxheW91dCIsInNlcmlhbGl6ZWRBZGRyZXNzZXNMZW4iLCJudW1TZXJpYWxpemVkQWRkcmVzc2VzIiwibGFzdEV4dGVuZGVkU2xvdCIsImxhc3RFeHRlbmRlZFNsb3RTdGFydEluZGV4IiwibGFzdEV4dGVuZGVkU3RhcnRJbmRleCIsImF1dGhvcml0eSIsIlVSTF9SRSIsIm1ha2VXZWJzb2NrZXRVcmwiLCJlbmRwb2ludCIsIm1hdGNoZXMiLCJob3N0aXNoIiwicG9ydFdpdGhDb2xvbiIsInJlc3QiLCJzdGFydHNXaXRoIiwic3RhcnRQb3J0Iiwid2Vic29ja2V0UG9ydCIsIlB1YmxpY0tleUZyb21TdHJpbmciLCJSYXdBY2NvdW50RGF0YVJlc3VsdCIsIkJ1ZmZlckZyb21SYXdBY2NvdW50RGF0YSIsIkJMT0NLSEFTSF9DQUNIRV9USU1FT1VUX01TIiwiYXNzZXJ0RW5kcG9pbnRVcmwiLCJwdXRhdGl2ZVVybCIsInRlc3QiLCJleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWciLCJjb21taXRtZW50T3JDb25maWciLCJzcGVjaWZpZWRDb21taXRtZW50Iiwic3BlY2lmaWVkQ29uZmlnIiwiYXBwbHlEZWZhdWx0TWVtY21wRW5jb2RpbmdUb0ZpbHRlcnMiLCJmaWx0ZXJzIiwibWVtY21wIiwiZW5jb2RpbmciLCJjcmVhdGVScGNSZXN1bHQiLCJqc29ucnBjIiwiVW5rbm93blJwY1Jlc3VsdCIsImpzb25ScGNSZXN1bHQiLCJzY2hlbWEiLCJqc29uUnBjUmVzdWx0QW5kQ29udGV4dCIsIm5vdGlmaWNhdGlvblJlc3VsdEFuZENvbnRleHQiLCJ2ZXJzaW9uZWRNZXNzYWdlRnJvbVJlc3BvbnNlIiwicmVzcG9uc2UiLCJHZXRJbmZsYXRpb25Hb3Zlcm5vclJlc3VsdCIsImZvdW5kYXRpb24iLCJmb3VuZGF0aW9uVGVybSIsImluaXRpYWwiLCJ0YXBlciIsInRlcm1pbmFsIiwiR2V0SW5mbGF0aW9uUmV3YXJkUmVzdWx0IiwiZWZmZWN0aXZlU2xvdCIsImFtb3VudCIsInBvc3RCYWxhbmNlIiwiY29tbWlzc2lvbiIsIkdldFJlY2VudFByaW9yaXRpemF0aW9uRmVlc1Jlc3VsdCIsInByaW9yaXRpemF0aW9uRmVlIiwiR2V0SW5mbGF0aW9uUmF0ZVJlc3VsdCIsInRvdGFsIiwidmFsaWRhdG9yIiwiR2V0RXBvY2hJbmZvUmVzdWx0Iiwic2xvdHNJbkVwb2NoIiwiYWJzb2x1dGVTbG90IiwiYmxvY2tIZWlnaHQiLCJ0cmFuc2FjdGlvbkNvdW50IiwiR2V0RXBvY2hTY2hlZHVsZVJlc3VsdCIsIkdldExlYWRlclNjaGVkdWxlUmVzdWx0IiwiVHJhbnNhY3Rpb25FcnJvclJlc3VsdCIsIlNpZ25hdHVyZVN0YXR1c1Jlc3VsdCIsIlNpZ25hdHVyZVJlY2VpdmVkUmVzdWx0IiwiVmVyc2lvblJlc3VsdCIsIlBhcnNlZEluc3RydWN0aW9uU3RydWN0IiwicGFyc2VkIiwiUGFydGlhbGx5RGVjb2RlZEluc3RydWN0aW9uU3RydWN0IiwiU2ltdWxhdGVkVHJhbnNhY3Rpb25SZXNwb25zZVN0cnVjdCIsInJlbnRFcG9jaCIsInVuaXRzQ29uc3VtZWQiLCJyZXR1cm5EYXRhIiwiaW5uZXJJbnN0cnVjdGlvbnMiLCJCbG9ja1Byb2R1Y3Rpb25SZXNwb25zZVN0cnVjdCIsImJ5SWRlbnRpdHkiLCJyYW5nZSIsImZpcnN0U2xvdCIsImxhc3RTbG90IiwiY3JlYXRlUnBjQ2xpZW50IiwiaHR0cEhlYWRlcnMiLCJjdXN0b21GZXRjaCIsImZldGNoTWlkZGxld2FyZSIsImRpc2FibGVSZXRyeU9uUmF0ZUxpbWl0IiwiaHR0cEFnZW50IiwiYWdlbnRPcHRpb25zIiwibWF4U29ja2V0cyIsImlzSHR0cHMiLCJmZXRjaFdpdGhNaWRkbGV3YXJlIiwiaW5mbyIsIm1vZGlmaWVkRmV0Y2hBcmdzIiwibW9kaWZpZWRJbmZvIiwibW9kaWZpZWRJbml0IiwiY2xpZW50QnJvd3NlciIsInJlcXVlc3QiLCJjYWxsYmFjayIsImJvZHkiLCJoZWFkZXJzIiwiQ09NTU9OX0hUVFBfSEVBREVSUyIsInRvb19tYW55X3JlcXVlc3RzX3JldHJpZXMiLCJ3YWl0VGltZSIsInN0YXR1c1RleHQiLCJ0ZXh0Iiwib2siLCJjcmVhdGVScGNSZXF1ZXN0IiwiY2xpZW50IiwiY3JlYXRlUnBjQmF0Y2hSZXF1ZXN0IiwiYmF0Y2giLCJtZXRob2ROYW1lIiwiR2V0SW5mbGF0aW9uR292ZXJub3JScGNSZXN1bHQiLCJHZXRJbmZsYXRpb25SYXRlUnBjUmVzdWx0IiwiR2V0UmVjZW50UHJpb3JpdGl6YXRpb25GZWVzUnBjUmVzdWx0IiwiR2V0RXBvY2hJbmZvUnBjUmVzdWx0IiwiR2V0RXBvY2hTY2hlZHVsZVJwY1Jlc3VsdCIsIkdldExlYWRlclNjaGVkdWxlUnBjUmVzdWx0IiwiU2xvdFJwY1Jlc3VsdCIsIkdldFN1cHBseVJwY1Jlc3VsdCIsImNpcmN1bGF0aW5nIiwibm9uQ2lyY3VsYXRpbmciLCJub25DaXJjdWxhdGluZ0FjY291bnRzIiwiVG9rZW5BbW91bnRSZXN1bHQiLCJ1aUFtb3VudCIsImRlY2ltYWxzIiwidWlBbW91bnRTdHJpbmciLCJHZXRUb2tlbkxhcmdlc3RBY2NvdW50c1Jlc3VsdCIsIkdldFRva2VuQWNjb3VudHNCeU93bmVyIiwiUGFyc2VkQWNjb3VudERhdGFSZXN1bHQiLCJHZXRQYXJzZWRUb2tlbkFjY291bnRzQnlPd25lciIsIkdldExhcmdlc3RBY2NvdW50c1JwY1Jlc3VsdCIsIkFjY291bnRJbmZvUmVzdWx0IiwiS2V5ZWRBY2NvdW50SW5mb1Jlc3VsdCIsIlBhcnNlZE9yUmF3QWNjb3VudERhdGEiLCJQYXJzZWRBY2NvdW50SW5mb1Jlc3VsdCIsIktleWVkUGFyc2VkQWNjb3VudEluZm9SZXN1bHQiLCJTdGFrZUFjdGl2YXRpb25SZXN1bHQiLCJhY3RpdmUiLCJpbmFjdGl2ZSIsIkdldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzMlJwY1Jlc3VsdCIsIm1lbW8iLCJibG9ja1RpbWUiLCJHZXRTaWduYXR1cmVzRm9yQWRkcmVzc1JwY1Jlc3VsdCIsIkFjY291bnROb3RpZmljYXRpb25SZXN1bHQiLCJzdWJzY3JpcHRpb24iLCJQcm9ncmFtQWNjb3VudEluZm9SZXN1bHQiLCJQcm9ncmFtQWNjb3VudE5vdGlmaWNhdGlvblJlc3VsdCIsIlNsb3RJbmZvUmVzdWx0IiwicGFyZW50Iiwicm9vdCIsIlNsb3ROb3RpZmljYXRpb25SZXN1bHQiLCJTbG90VXBkYXRlUmVzdWx0IiwidGltZXN0YW1wIiwic3RhdHMiLCJudW1UcmFuc2FjdGlvbkVudHJpZXMiLCJudW1TdWNjZXNzZnVsVHJhbnNhY3Rpb25zIiwibnVtRmFpbGVkVHJhbnNhY3Rpb25zIiwibWF4VHJhbnNhY3Rpb25zUGVyRW50cnkiLCJTbG90VXBkYXRlTm90aWZpY2F0aW9uUmVzdWx0IiwiU2lnbmF0dXJlTm90aWZpY2F0aW9uUmVzdWx0IiwiUm9vdE5vdGlmaWNhdGlvblJlc3VsdCIsIkNvbnRhY3RJbmZvUmVzdWx0IiwiZ29zc2lwIiwidHB1IiwiVm90ZUFjY291bnRJbmZvUmVzdWx0Iiwidm90ZVB1YmtleSIsIm5vZGVQdWJrZXkiLCJhY3RpdmF0ZWRTdGFrZSIsImVwb2NoVm90ZUFjY291bnQiLCJlcG9jaENyZWRpdHMiLCJsYXN0Vm90ZSIsInJvb3RTbG90IiwiR2V0Vm90ZUFjY291bnRzIiwiY3VycmVudCIsImRlbGlucXVlbnQiLCJDb25maXJtYXRpb25TdGF0dXMiLCJTaWduYXR1cmVTdGF0dXNSZXNwb25zZSIsImNvbmZpcm1hdGlvbnMiLCJjb25maXJtYXRpb25TdGF0dXMiLCJHZXRTaWduYXR1cmVTdGF0dXNlc1JwY1Jlc3VsdCIsIkdldE1pbmltdW1CYWxhbmNlRm9yUmVudEV4ZW1wdGlvblJwY1Jlc3VsdCIsIkFkZHJlc3NUYWJsZUxvb2t1cFN0cnVjdCIsIkNvbmZpcm1lZFRyYW5zYWN0aW9uUmVzdWx0IiwiQW5ub3RhdGVkQWNjb3VudEtleSIsInNvdXJjZSIsIkNvbmZpcm1lZFRyYW5zYWN0aW9uQWNjb3VudHNNb2RlUmVzdWx0IiwiUGFyc2VkSW5zdHJ1Y3Rpb25SZXN1bHQiLCJSYXdJbnN0cnVjdGlvblJlc3VsdCIsIkluc3RydWN0aW9uUmVzdWx0IiwiVW5rbm93bkluc3RydWN0aW9uUmVzdWx0IiwiUGFyc2VkT3JSYXdJbnN0cnVjdGlvbiIsIlBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9uUmVzdWx0IiwiVG9rZW5CYWxhbmNlUmVzdWx0IiwiYWNjb3VudEluZGV4IiwibWludCIsInVpVG9rZW5BbW91bnQiLCJMb2FkZWRBZGRyZXNzZXNSZXN1bHQiLCJDb25maXJtZWRUcmFuc2FjdGlvbk1ldGFSZXN1bHQiLCJmZWUiLCJwcmVCYWxhbmNlcyIsInBvc3RCYWxhbmNlcyIsInByZVRva2VuQmFsYW5jZXMiLCJwb3N0VG9rZW5CYWxhbmNlcyIsImxvYWRlZEFkZHJlc3NlcyIsImNvbXB1dGVVbml0c0NvbnN1bWVkIiwiY29zdFVuaXRzIiwiUGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb25NZXRhUmVzdWx0IiwiVHJhbnNhY3Rpb25WZXJzaW9uU3RydWN0IiwiUmV3YXJkc1Jlc3VsdCIsInJld2FyZFR5cGUiLCJHZXRCbG9ja1JwY1Jlc3VsdCIsInByZXZpb3VzQmxvY2toYXNoIiwicGFyZW50U2xvdCIsInJld2FyZHMiLCJHZXROb25lTW9kZUJsb2NrUnBjUmVzdWx0IiwiR2V0QWNjb3VudHNNb2RlQmxvY2tScGNSZXN1bHQiLCJHZXRQYXJzZWRCbG9ja1JwY1Jlc3VsdCIsIkdldFBhcnNlZEFjY291bnRzTW9kZUJsb2NrUnBjUmVzdWx0IiwiR2V0UGFyc2VkTm9uZU1vZGVCbG9ja1JwY1Jlc3VsdCIsIkdldENvbmZpcm1lZEJsb2NrUnBjUmVzdWx0IiwiR2V0QmxvY2tTaWduYXR1cmVzUnBjUmVzdWx0IiwiR2V0VHJhbnNhY3Rpb25ScGNSZXN1bHQiLCJHZXRQYXJzZWRUcmFuc2FjdGlvblJwY1Jlc3VsdCIsIkdldExhdGVzdEJsb2NraGFzaFJwY1Jlc3VsdCIsIklzQmxvY2toYXNoVmFsaWRScGNSZXN1bHQiLCJQZXJmU2FtcGxlUmVzdWx0IiwibnVtVHJhbnNhY3Rpb25zIiwibnVtU2xvdHMiLCJzYW1wbGVQZXJpb2RTZWNzIiwiR2V0UmVjZW50UGVyZm9ybWFuY2VTYW1wbGVzUnBjUmVzdWx0IiwiR2V0RmVlQ2FsY3VsYXRvclJwY1Jlc3VsdCIsImxhbXBvcnRzUGVyU2lnbmF0dXJlIiwiUmVxdWVzdEFpcmRyb3BScGNSZXN1bHQiLCJTZW5kVHJhbnNhY3Rpb25ScGNSZXN1bHQiLCJMb2dzUmVzdWx0IiwiTG9nc05vdGlmaWNhdGlvblJlc3VsdCIsIkNvbm5lY3Rpb24iLCJfY29tbWl0bWVudE9yQ29uZmlnIiwiX2NvbW1pdG1lbnQiLCJfY29uZmlybVRyYW5zYWN0aW9uSW5pdGlhbFRpbWVvdXQiLCJfcnBjV3NFbmRwb2ludCIsIl9ycGNDbGllbnQiLCJfcnBjUmVxdWVzdCIsIl9ycGNCYXRjaFJlcXVlc3QiLCJfcnBjV2ViU29ja2V0IiwiX3JwY1dlYlNvY2tldENvbm5lY3RlZCIsIl9ycGNXZWJTb2NrZXRIZWFydGJlYXQiLCJfcnBjV2ViU29ja2V0SWRsZVRpbWVvdXQiLCJfcnBjV2ViU29ja2V0R2VuZXJhdGlvbiIsIl9kaXNhYmxlQmxvY2toYXNoQ2FjaGluZyIsIl9wb2xsaW5nQmxvY2toYXNoIiwiX2Jsb2NraGFzaEluZm8iLCJsYXRlc3RCbG9ja2hhc2giLCJsYXN0RmV0Y2giLCJ0cmFuc2FjdGlvblNpZ25hdHVyZXMiLCJzaW11bGF0ZWRTaWduYXR1cmVzIiwiX25leHRDbGllbnRTdWJzY3JpcHRpb25JZCIsIl9zdWJzY3JpcHRpb25EaXNwb3NlRnVuY3Rpb25zQnlDbGllbnRTdWJzY3JpcHRpb25JZCIsIl9zdWJzY3JpcHRpb25IYXNoQnlDbGllbnRTdWJzY3JpcHRpb25JZCIsIl9zdWJzY3JpcHRpb25TdGF0ZUNoYW5nZUNhbGxiYWNrc0J5SGFzaCIsIl9zdWJzY3JpcHRpb25DYWxsYmFja3NCeVNlcnZlclN1YnNjcmlwdGlvbklkIiwiX3N1YnNjcmlwdGlvbnNCeUhhc2giLCJfc3Vic2NyaXB0aW9uc0F1dG9EaXNwb3NlZEJ5UnBjIiwiZ2V0QmxvY2tIZWlnaHQiLCJyZXF1ZXN0UHJvbWlzZXMiLCJfYnVpbGRBcmdzIiwicmVxdWVzdEhhc2giLCJ1bnNhZmVSZXMiLCJ3c0VuZHBvaW50IiwiY29uZmlybVRyYW5zYWN0aW9uSW5pdGlhbFRpbWVvdXQiLCJJbmZpbml0eSIsIl93c09uT3BlbiIsIl93c09uRXJyb3IiLCJfd3NPbkNsb3NlIiwiX3dzT25BY2NvdW50Tm90aWZpY2F0aW9uIiwiX3dzT25Qcm9ncmFtQWNjb3VudE5vdGlmaWNhdGlvbiIsIl93c09uU2xvdE5vdGlmaWNhdGlvbiIsIl93c09uU2xvdFVwZGF0ZXNOb3RpZmljYXRpb24iLCJfd3NPblNpZ25hdHVyZU5vdGlmaWNhdGlvbiIsIl93c09uUm9vdE5vdGlmaWNhdGlvbiIsIl93c09uTG9nc05vdGlmaWNhdGlvbiIsInJwY0VuZHBvaW50IiwiZ2V0QmFsYW5jZUFuZENvbnRleHQiLCJnZXRCYWxhbmNlIiwiZSIsImdldEJsb2NrVGltZSIsImdldE1pbmltdW1MZWRnZXJTbG90IiwiZ2V0Rmlyc3RBdmFpbGFibGVCbG9jayIsImdldFN1cHBseSIsImNvbmZpZ0FyZyIsImdldFRva2VuU3VwcGx5IiwidG9rZW5NaW50QWRkcmVzcyIsImdldFRva2VuQWNjb3VudEJhbGFuY2UiLCJ0b2tlbkFkZHJlc3MiLCJnZXRUb2tlbkFjY291bnRzQnlPd25lciIsIm93bmVyQWRkcmVzcyIsIl9hcmdzIiwiZ2V0UGFyc2VkVG9rZW5BY2NvdW50c0J5T3duZXIiLCJnZXRMYXJnZXN0QWNjb3VudHMiLCJhcmciLCJnZXRUb2tlbkxhcmdlc3RBY2NvdW50cyIsIm1pbnRBZGRyZXNzIiwiZ2V0QWNjb3VudEluZm9BbmRDb250ZXh0IiwiZ2V0UGFyc2VkQWNjb3VudEluZm8iLCJnZXRNdWx0aXBsZVBhcnNlZEFjY291bnRzIiwicHVibGljS2V5cyIsInJhd0NvbmZpZyIsImdldE11bHRpcGxlQWNjb3VudHNJbmZvQW5kQ29udGV4dCIsImdldE11bHRpcGxlQWNjb3VudHNJbmZvIiwiZ2V0U3Rha2VBY3RpdmF0aW9uIiwiZ2V0UHJvZ3JhbUFjY291bnRzIiwiY29uZmlnT3JDb21taXRtZW50IiwiY29uZmlnV2l0aG91dEVuY29kaW5nIiwiYmFzZVNjaGVtYSIsIndpdGhDb250ZXh0IiwiZ2V0UGFyc2VkUHJvZ3JhbUFjY291bnRzIiwic3RyYXRlZ3kiLCJyYXdTaWduYXR1cmUiLCJhYm9ydGVkIiwicmVhc29uIiwiZGVjb2RlZFNpZ25hdHVyZSIsImNvbmZpcm1UcmFuc2FjdGlvblVzaW5nTGVnYWN5VGltZW91dFN0cmF0ZWd5IiwiY29uZmlybVRyYW5zYWN0aW9uVXNpbmdCbG9ja0hlaWdodEV4Y2VlZGFuY2VTdHJhdGVneSIsImNvbmZpcm1UcmFuc2FjdGlvblVzaW5nRHVyYWJsZU5vbmNlU3RyYXRlZ3kiLCJnZXRDYW5jZWxsYXRpb25Qcm9taXNlIiwic2lnbmFsIiwiYWRkRXZlbnRMaXN0ZW5lciIsImdldFRyYW5zYWN0aW9uQ29uZmlybWF0aW9uUHJvbWlzZSIsInNpZ25hdHVyZVN1YnNjcmlwdGlvbklkIiwiZGlzcG9zZVNpZ25hdHVyZVN1YnNjcmlwdGlvblN0YXRlQ2hhbmdlT2JzZXJ2ZXIiLCJkb25lIiwiY29uZmlybWF0aW9uUHJvbWlzZSIsIm9uU2lnbmF0dXJlIiwiX190eXBlIiwiUFJPQ0VTU0VEIiwic3Vic2NyaXB0aW9uU2V0dXBQcm9taXNlIiwicmVzb2x2ZVN1YnNjcmlwdGlvblNldHVwIiwiX29uU3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2UiLCJuZXh0U3RhdGUiLCJnZXRTaWduYXR1cmVTdGF0dXMiLCJhYm9ydENvbmZpcm1hdGlvbiIsInJlbW92ZVNpZ25hdHVyZUxpc3RlbmVyIiwiZXhwaXJ5UHJvbWlzZSIsImNoZWNrQmxvY2tIZWlnaHQiLCJfZSIsImN1cnJlbnRCbG9ja0hlaWdodCIsIkJMT0NLSEVJR0hUX0VYQ0VFREVEIiwiY2FuY2VsbGF0aW9uUHJvbWlzZSIsIm91dGNvbWUiLCJyYWNlIiwiY3VycmVudE5vbmNlVmFsdWUiLCJsYXN0Q2hlY2tlZFNsb3QiLCJnZXRDdXJyZW50Tm9uY2VWYWx1ZSIsImdldE5vbmNlQW5kQ29udGV4dCIsIk5PTkNFX0lOVkFMSUQiLCJzbG90SW5XaGljaE5vbmNlRGlkQWR2YW5jZSIsInNpZ25hdHVyZVN0YXR1cyIsImNvbW1pdG1lbnRGb3JTdGF0dXMiLCJ0aW1lb3V0SWQiLCJ0aW1lb3V0TXMiLCJUSU1FRF9PVVQiLCJjbGVhclRpbWVvdXQiLCJnZXRDbHVzdGVyTm9kZXMiLCJnZXRWb3RlQWNjb3VudHMiLCJnZXRTbG90TGVhZGVyIiwiZ2V0U2xvdExlYWRlcnMiLCJzdGFydFNsb3QiLCJsaW1pdCIsImdldFNpZ25hdHVyZVN0YXR1c2VzIiwiZ2V0VHJhbnNhY3Rpb25Db3VudCIsImdldFRvdGFsU3VwcGx5IiwiZXhjbHVkZU5vbkNpcmN1bGF0aW5nQWNjb3VudHNMaXN0IiwiZ2V0SW5mbGF0aW9uR292ZXJub3IiLCJnZXRJbmZsYXRpb25SZXdhcmQiLCJnZXRJbmZsYXRpb25SYXRlIiwiZ2V0RXBvY2hJbmZvIiwiZ2V0RXBvY2hTY2hlZHVsZSIsImVwb2NoU2NoZWR1bGUiLCJnZXRMZWFkZXJTY2hlZHVsZSIsImdldFJlY2VudEJsb2NraGFzaEFuZENvbnRleHQiLCJnZXRMYXRlc3RCbG9ja2hhc2hBbmRDb250ZXh0IiwiZ2V0UmVjZW50UGVyZm9ybWFuY2VTYW1wbGVzIiwiZ2V0RmVlQ2FsY3VsYXRvckZvckJsb2NraGFzaCIsIndpcmVNZXNzYWdlIiwiZ2V0UmVjZW50UHJpb3JpdGl6YXRpb25GZWVzIiwibG9ja2VkV3JpdGFibGVBY2NvdW50cyIsImdldFJlY2VudEJsb2NraGFzaCIsImdldExhdGVzdEJsb2NraGFzaCIsImlzQmxvY2toYXNoVmFsaWQiLCJnZXRWZXJzaW9uIiwiZ2V0R2VuZXNpc0hhc2giLCJnZXRCbG9jayIsIl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkIiwidHJhbnNhY3Rpb25EZXRhaWxzIiwiZ2V0UGFyc2VkQmxvY2siLCJnZXRCbG9ja1Byb2R1Y3Rpb24iLCJleHRyYSIsImMiLCJnZXRQYXJzZWRUcmFuc2FjdGlvbiIsImdldFBhcnNlZFRyYW5zYWN0aW9ucyIsImdldFRyYW5zYWN0aW9ucyIsImdldENvbmZpcm1lZEJsb2NrIiwiYmxvY2siLCJnZXRCbG9ja3MiLCJlbmRTbG90IiwiZ2V0QmxvY2tTaWduYXR1cmVzIiwiZ2V0Q29uZmlybWVkQmxvY2tTaWduYXR1cmVzIiwiZ2V0Q29uZmlybWVkVHJhbnNhY3Rpb24iLCJnZXRQYXJzZWRDb25maXJtZWRUcmFuc2FjdGlvbiIsImdldFBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9ucyIsImdldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzIiwiZmlyc3RBdmFpbGFibGVCbG9jayIsInVudGlsIiwiaGlnaGVzdENvbmZpcm1lZFJvb3QiLCJiZWZvcmUiLCJjb25maXJtZWRTaWduYXR1cmVJbmZvIiwiZ2V0Q29uZmlybWVkU2lnbmF0dXJlc0ZvckFkZHJlc3MyIiwiZ2V0U2lnbmF0dXJlc0ZvckFkZHJlc3MiLCJnZXRBZGRyZXNzTG9va3VwVGFibGUiLCJhY2NvdW50SW5mbyIsImdldE5vbmNlIiwicmVxdWVzdEFpcmRyb3AiLCJ0byIsIl9ibG9ja2hhc2hXaXRoRXhwaXJ5QmxvY2tIZWlnaHQiLCJkaXNhYmxlQ2FjaGUiLCJ0aW1lU2luY2VGZXRjaCIsImV4cGlyZWQiLCJfcG9sbE5ld0Jsb2NraGFzaCIsInN0YXJ0VGltZSIsImNhY2hlZExhdGVzdEJsb2NraGFzaCIsImNhY2hlZEJsb2NraGFzaCIsImdldFN0YWtlTWluaW11bURlbGVnYXRpb24iLCJzaW11bGF0ZVRyYW5zYWN0aW9uIiwidHJhbnNhY3Rpb25Pck1lc3NhZ2UiLCJjb25maWdPclNpZ25lcnMiLCJpbmNsdWRlQWNjb3VudHMiLCJ2ZXJzaW9uZWRUeCIsImVuY29kZWRUcmFuc2FjdGlvbiIsIm9yaWdpbmFsVHgiLCJzaWdWZXJpZnkiLCJ0cmFjZUluZGVudCIsImxvZ1RyYWNlIiwic2lnbmVyc09yT3B0aW9ucyIsInNlbmRSYXdUcmFuc2FjdGlvbiIsInJhd1RyYW5zYWN0aW9uIiwic2VuZEVuY29kZWRUcmFuc2FjdGlvbiIsInNldEludGVydmFsIiwiX3VwZGF0ZVN1YnNjcmlwdGlvbnMiLCJjbGVhckludGVydmFsIiwiaGFzaCIsIl9zZXRTdWJzY3JpcHRpb24iLCJuZXh0U3Vic2NyaXB0aW9uIiwicHJldlN0YXRlIiwic3RhdGVDaGFuZ2VDYWxsYmFja3MiLCJjYiIsImNsaWVudFN1YnNjcmlwdGlvbklkIiwiY2xvc2UiLCJjb25uZWN0IiwiYWN0aXZlV2ViU29ja2V0R2VuZXJhdGlvbiIsImlzQ3VycmVudENvbm5lY3Rpb25TdGlsbEFjdGl2ZSIsImNhbGxiYWNrcyIsInNlcnZlclN1YnNjcmlwdGlvbklkIiwidW5zdWJzY3JpYmVNZXRob2QiLCJfaGFuZGxlU2VydmVyTm90aWZpY2F0aW9uIiwiY2FsbGJhY2tBcmdzIiwibm90aWZpY2F0aW9uIiwiX21ha2VTdWJzY3JpcHRpb24iLCJzdWJzY3JpcHRpb25Db25maWciLCJleGlzdGluZ1N1YnNjcmlwdGlvbiIsIm9uQWNjb3VudENoYW5nZSIsInJlbW92ZUFjY291bnRDaGFuZ2VMaXN0ZW5lciIsIl91bnN1YnNjcmliZUNsaWVudFN1YnNjcmlwdGlvbiIsImFjY291bnRJZCIsIm9uUHJvZ3JhbUFjY291bnRDaGFuZ2UiLCJtYXliZUZpbHRlcnMiLCJyZW1vdmVQcm9ncmFtQWNjb3VudENoYW5nZUxpc3RlbmVyIiwib25Mb2dzIiwibWVudGlvbnMiLCJyZW1vdmVPbkxvZ3NMaXN0ZW5lciIsIm9uU2xvdENoYW5nZSIsInJlbW92ZVNsb3RDaGFuZ2VMaXN0ZW5lciIsIm9uU2xvdFVwZGF0ZSIsInJlbW92ZVNsb3RVcGRhdGVMaXN0ZW5lciIsInN1YnNjcmlwdGlvbk5hbWUiLCJkaXNwb3NlIiwib3ZlcnJpZGUiLCJfZXJyIiwib25TaWduYXR1cmVXaXRoT3B0aW9ucyIsIm9uUm9vdENoYW5nZSIsInJlbW92ZVJvb3RDaGFuZ2VMaXN0ZW5lciIsIktleXBhaXIiLCJrZXlwYWlyIiwiX2tleXBhaXIiLCJnZW5lcmF0ZSIsImZyb21TZWNyZXRLZXkiLCJza2lwVmFsaWRhdGlvbiIsImNvbXB1dGVkUHVibGljS2V5IiwiaWkiLCJmcm9tU2VlZCIsIkxPT0tVUF9UQUJMRV9JTlNUUlVDVElPTl9MQVlPVVRTIiwiQ3JlYXRlTG9va3VwVGFibGUiLCJGcmVlemVMb29rdXBUYWJsZSIsIkV4dGVuZExvb2t1cFRhYmxlIiwiRGVhY3RpdmF0ZUxvb2t1cFRhYmxlIiwiQ2xvc2VMb29rdXBUYWJsZSIsIkFkZHJlc3NMb29rdXBUYWJsZUluc3RydWN0aW9uIiwibGF5b3V0VHlwZSIsImRlY29kZUNyZWF0ZUxvb2t1cFRhYmxlIiwiY2hlY2tLZXlzTGVuZ3RoIiwicmVjZW50U2xvdCIsImRlY29kZUV4dGVuZExvb2t1cFRhYmxlIiwiZGVjb2RlQ2xvc2VMb29rdXBUYWJsZSIsInJlY2lwaWVudCIsImRlY29kZUZyZWV6ZUxvb2t1cFRhYmxlIiwiZGVjb2RlRGVhY3RpdmF0ZUxvb2t1cFRhYmxlIiwiQWRkcmVzc0xvb2t1cFRhYmxlUHJvZ3JhbSIsImNyZWF0ZUxvb2t1cFRhYmxlIiwibG9va3VwVGFibGVBZGRyZXNzIiwiYnVtcFNlZWQiLCJmcmVlemVMb29rdXBUYWJsZSIsImV4dGVuZExvb2t1cFRhYmxlIiwiYWRkciIsImRlYWN0aXZhdGVMb29rdXBUYWJsZSIsImNsb3NlTG9va3VwVGFibGUiLCJDb21wdXRlQnVkZ2V0SW5zdHJ1Y3Rpb24iLCJDT01QVVRFX0JVREdFVF9JTlNUUlVDVElPTl9MQVlPVVRTIiwiZGVjb2RlUmVxdWVzdFVuaXRzIiwidW5pdHMiLCJhZGRpdGlvbmFsRmVlIiwiUmVxdWVzdFVuaXRzIiwiZGVjb2RlUmVxdWVzdEhlYXBGcmFtZSIsIlJlcXVlc3RIZWFwRnJhbWUiLCJkZWNvZGVTZXRDb21wdXRlVW5pdExpbWl0IiwiU2V0Q29tcHV0ZVVuaXRMaW1pdCIsImRlY29kZVNldENvbXB1dGVVbml0UHJpY2UiLCJtaWNyb0xhbXBvcnRzIiwiU2V0Q29tcHV0ZVVuaXRQcmljZSIsIkNvbXB1dGVCdWRnZXRQcm9ncmFtIiwicmVxdWVzdFVuaXRzIiwicmVxdWVzdEhlYXBGcmFtZSIsInNldENvbXB1dGVVbml0TGltaXQiLCJzZXRDb21wdXRlVW5pdFByaWNlIiwiUFJJVkFURV9LRVlfQllURVMkMSIsIlBVQkxJQ19LRVlfQllURVMkMSIsIlNJR05BVFVSRV9CWVRFUyIsIkVEMjU1MTlfSU5TVFJVQ1RJT05fTEFZT1VUIiwidTE2IiwiRWQyNTUxOVByb2dyYW0iLCJjcmVhdGVJbnN0cnVjdGlvbldpdGhQdWJsaWNLZXkiLCJpbnN0cnVjdGlvbkluZGV4IiwicHVibGljS2V5T2Zmc2V0Iiwic2lnbmF0dXJlT2Zmc2V0IiwibWVzc2FnZURhdGFPZmZzZXQiLCJudW1TaWduYXR1cmVzIiwicGFkZGluZyIsInNpZ25hdHVyZUluc3RydWN0aW9uSW5kZXgiLCJwdWJsaWNLZXlJbnN0cnVjdGlvbkluZGV4IiwibWVzc2FnZURhdGFTaXplIiwibWVzc2FnZUluc3RydWN0aW9uSW5kZXgiLCJjcmVhdGVJbnN0cnVjdGlvbldpdGhQcml2YXRlS2V5IiwicHJpdmF0ZUtleSIsImVjZHNhU2lnbiIsIm1zZ0hhc2giLCJwcml2S2V5IiwidG9Db21wYWN0UmF3Qnl0ZXMiLCJyZWNvdmVyeSIsImlzVmFsaWRQcml2YXRlS2V5IiwicHVibGljS2V5Q3JlYXRlIiwiUFJJVkFURV9LRVlfQllURVMiLCJFVEhFUkVVTV9BRERSRVNTX0JZVEVTIiwiUFVCTElDX0tFWV9CWVRFUyIsIlNJR05BVFVSRV9PRkZTRVRTX1NFUklBTElaRURfU0laRSIsIlNFQ1AyNTZLMV9JTlNUUlVDVElPTl9MQVlPVVQiLCJTZWNwMjU2azFQcm9ncmFtIiwicHVibGljS2V5VG9FdGhBZGRyZXNzIiwicmVjb3ZlcnlJZCIsImNyZWF0ZUluc3RydWN0aW9uV2l0aEV0aEFkZHJlc3MiLCJldGhBZGRyZXNzIiwicmF3QWRkcmVzcyIsInN1YnN0ciIsImRhdGFTdGFydCIsImV0aEFkZHJlc3NPZmZzZXQiLCJldGhBZGRyZXNzSW5zdHJ1Y3Rpb25JbmRleCIsInBrZXkiLCJtZXNzYWdlSGFzaCIsIl9Mb2NrdXAiLCJTVEFLRV9DT05GSUdfSUQiLCJBdXRob3JpemVkIiwic3Rha2VyIiwid2l0aGRyYXdlciIsIkxvY2t1cCIsInVuaXhUaW1lc3RhbXAiLCJjdXN0b2RpYW4iLCJTdGFrZUluc3RydWN0aW9uIiwiU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUyIsImRlY29kZUluaXRpYWxpemUiLCJJbml0aWFsaXplIiwic3Rha2VQdWJrZXkiLCJkZWNvZGVEZWxlZ2F0ZSIsIkRlbGVnYXRlIiwiZGVjb2RlQXV0aG9yaXplIiwibmV3QXV0aG9yaXplZCIsInN0YWtlQXV0aG9yaXphdGlvblR5cGUiLCJBdXRob3JpemUiLCJvIiwiY3VzdG9kaWFuUHVia2V5IiwiZGVjb2RlQXV0aG9yaXplV2l0aFNlZWQiLCJhdXRob3JpdHlTZWVkIiwiYXV0aG9yaXR5T3duZXIiLCJBdXRob3JpemVXaXRoU2VlZCIsImF1dGhvcml0eUJhc2UiLCJkZWNvZGVTcGxpdCIsIlNwbGl0Iiwic3BsaXRTdGFrZVB1YmtleSIsImRlY29kZU1lcmdlIiwiTWVyZ2UiLCJzb3VyY2VTdGFrZVB1YktleSIsImRlY29kZVdpdGhkcmF3IiwiV2l0aGRyYXciLCJkZWNvZGVEZWFjdGl2YXRlIiwiRGVhY3RpdmF0ZSIsIlN0YWtlUHJvZ3JhbSIsIlN0YWtlQXV0aG9yaXphdGlvbkxheW91dCIsIlN0YWtlciIsIldpdGhkcmF3ZXIiLCJpbml0aWFsaXplIiwibWF5YmVMb2NrdXAiLCJkZWxlZ2F0ZSIsImF1dGhvcml6ZSIsImF1dGhvcml6ZVdpdGhTZWVkIiwic3BsaXRJbnN0cnVjdGlvbiIsInJlbnRFeGVtcHRSZXNlcnZlIiwic3BsaXRXaXRoU2VlZCIsIm1lcmdlIiwid2l0aGRyYXciLCJkZWFjdGl2YXRlIiwiVm90ZUluaXQiLCJhdXRob3JpemVkVm90ZXIiLCJhdXRob3JpemVkV2l0aGRyYXdlciIsIlZvdGVJbnN0cnVjdGlvbiIsIlZPVEVfSU5TVFJVQ1RJT05fTEFZT1VUUyIsImRlY29kZUluaXRpYWxpemVBY2NvdW50IiwiSW5pdGlhbGl6ZUFjY291bnQiLCJ2b3RlQXV0aG9yaXphdGlvblR5cGUiLCJjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleU93bmVyUHVia2V5IiwiY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlTZWVkIiwiY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlCYXNlUHVia2V5IiwiYXV0aG9yaXplZFdpdGhkcmF3ZXJQdWJrZXkiLCJWb3RlUHJvZ3JhbSIsIlVwZGF0ZVZhbGlkYXRvcklkZW50aXR5IiwiVm90ZUF1dGhvcml6YXRpb25MYXlvdXQiLCJWb3RlciIsImluaXRpYWxpemVBY2NvdW50Iiwic2FmZVdpdGhkcmF3IiwiY3VycmVudFZvdGVBY2NvdW50QmFsYW5jZSIsInJlbnRFeGVtcHRNaW5pbXVtIiwidXBkYXRlVmFsaWRhdG9ySWRlbnRpdHkiLCJWQUxJREFUT1JfSU5GT19LRVkiLCJJbmZvU3RyaW5nIiwid2Vic2l0ZSIsImRldGFpbHMiLCJpY29uVXJsIiwia2V5YmFzZVVzZXJuYW1lIiwiVmFsaWRhdG9ySW5mbyIsImZyb21Db25maWdEYXRhIiwiY29uZmlnS2V5Q291bnQiLCJjb25maWdLZXlzIiwicmF3SW5mbyIsIlZPVEVfUFJPR1JBTV9JRCIsIlZvdGVBY2NvdW50TGF5b3V0IiwiVm90ZUFjY291bnQiLCJ2b3RlcyIsImF1dGhvcml6ZWRWb3RlcnMiLCJwcmlvclZvdGVycyIsImxhc3RUaW1lc3RhbXAiLCJ2ZXJzaW9uT2Zmc2V0IiwidmEiLCJyb290U2xvdFZhbGlkIiwicGFyc2VBdXRob3JpemVkVm90ZXIiLCJnZXRQcmlvclZvdGVycyIsInBhcnNlUHJpb3JWb3RlcnMiLCJlcG9jaE9mTGFzdEF1dGhvcml6ZWRTd2l0Y2giLCJ0YXJnZXRFcG9jaCIsImlkeCIsImlzRW1wdHkiLCJodHRwIiwiZGV2bmV0IiwidGVzdG5ldCIsImh0dHBzIiwiY2x1c3RlckFwaVVybCIsImNsdXN0ZXIiLCJ0bHMiLCJzZW5kQW5kQ29uZmlybVJhd1RyYW5zYWN0aW9uIiwiY29uZmlybWF0aW9uU3RyYXRlZ3lPckNvbmZpcm1PcHRpb25zIiwibWF5YmVDb25maXJtT3B0aW9ucyIsImNvbmZpcm1hdGlvblN0cmF0ZWd5IiwiTEFNUE9SVFNfUEVSX1NPTCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/web3.js/lib/index.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/accounts/dist/index.node.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@solana/accounts/dist/index.node.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BASE_ACCOUNT_SIZE: () => (/* binding */ BASE_ACCOUNT_SIZE),\n/* harmony export */   assertAccountDecoded: () => (/* binding */ assertAccountDecoded),\n/* harmony export */   assertAccountExists: () => (/* binding */ assertAccountExists),\n/* harmony export */   assertAccountsDecoded: () => (/* binding */ assertAccountsDecoded),\n/* harmony export */   assertAccountsExist: () => (/* binding */ assertAccountsExist),\n/* harmony export */   decodeAccount: () => (/* binding */ decodeAccount),\n/* harmony export */   fetchEncodedAccount: () => (/* binding */ fetchEncodedAccount),\n/* harmony export */   fetchEncodedAccounts: () => (/* binding */ fetchEncodedAccounts),\n/* harmony export */   fetchJsonParsedAccount: () => (/* binding */ fetchJsonParsedAccount),\n/* harmony export */   fetchJsonParsedAccounts: () => (/* binding */ fetchJsonParsedAccounts),\n/* harmony export */   parseBase58RpcAccount: () => (/* binding */ parseBase58RpcAccount),\n/* harmony export */   parseBase64RpcAccount: () => (/* binding */ parseBase64RpcAccount),\n/* harmony export */   parseJsonRpcAccount: () => (/* binding */ parseJsonRpcAccount)\n/* harmony export */ });\n/* harmony import */ var _solana_errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/errors */ \"(ssr)/./node_modules/@solana/errors/dist/index.node.mjs\");\n/* harmony import */ var _solana_codecs_strings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana/codecs-strings */ \"(ssr)/./node_modules/@solana/codecs-strings/dist/index.node.mjs\");\n\n\n// src/account.ts\nvar BASE_ACCOUNT_SIZE = 128;\nfunction decodeAccount(encodedAccount, decoder) {\n    try {\n        if (\"exists\" in encodedAccount && !encodedAccount.exists) {\n            return encodedAccount;\n        }\n        return Object.freeze({\n            ...encodedAccount,\n            data: decoder.decode(encodedAccount.data)\n        });\n    } catch  {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT, {\n            address: encodedAccount.address\n        });\n    }\n}\nfunction accountExists(account) {\n    return !(\"exists\" in account) || \"exists\" in account && account.exists;\n}\nfunction assertAccountDecoded(account) {\n    if (accountExists(account) && account.data instanceof Uint8Array) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT, {\n            address: account.address\n        });\n    }\n}\nfunction assertAccountsDecoded(accounts) {\n    const encoded = accounts.filter((a)=>accountExists(a) && a.data instanceof Uint8Array);\n    if (encoded.length > 0) {\n        const encodedAddresses = encoded.map((a)=>a.address);\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED, {\n            addresses: encodedAddresses\n        });\n    }\n}\nfunction parseBase64RpcAccount(address, rpcAccount) {\n    if (!rpcAccount) return Object.freeze({\n        address,\n        exists: false\n    });\n    const data = (0,_solana_codecs_strings__WEBPACK_IMPORTED_MODULE_1__.getBase64Encoder)().encode(rpcAccount.data[0]);\n    return Object.freeze({\n        ...parseBaseAccount(rpcAccount),\n        address,\n        data,\n        exists: true\n    });\n}\nfunction parseBase58RpcAccount(address, rpcAccount) {\n    if (!rpcAccount) return Object.freeze({\n        address,\n        exists: false\n    });\n    const data = (0,_solana_codecs_strings__WEBPACK_IMPORTED_MODULE_1__.getBase58Encoder)().encode(typeof rpcAccount.data === \"string\" ? rpcAccount.data : rpcAccount.data[0]);\n    return Object.freeze({\n        ...parseBaseAccount(rpcAccount),\n        address,\n        data,\n        exists: true\n    });\n}\nfunction parseJsonRpcAccount(address, rpcAccount) {\n    if (!rpcAccount) return Object.freeze({\n        address,\n        exists: false\n    });\n    const data = rpcAccount.data.parsed.info || {};\n    if (rpcAccount.data.program || rpcAccount.data.parsed.type) {\n        data.parsedAccountMeta = {\n            program: rpcAccount.data.program,\n            type: rpcAccount.data.parsed.type\n        };\n    }\n    return Object.freeze({\n        ...parseBaseAccount(rpcAccount),\n        address,\n        data,\n        exists: true\n    });\n}\nfunction parseBaseAccount(rpcAccount) {\n    return Object.freeze({\n        executable: rpcAccount.executable,\n        lamports: rpcAccount.lamports,\n        programAddress: rpcAccount.owner,\n        space: rpcAccount.space\n    });\n}\n// src/fetch-account.ts\nasync function fetchEncodedAccount(rpc, address, config = {}) {\n    const { abortSignal, ...rpcConfig } = config;\n    const response = await rpc.getAccountInfo(address, {\n        ...rpcConfig,\n        encoding: \"base64\"\n    }).send({\n        abortSignal\n    });\n    return parseBase64RpcAccount(address, response.value);\n}\nasync function fetchJsonParsedAccount(rpc, address, config = {}) {\n    const { abortSignal, ...rpcConfig } = config;\n    const { value: account } = await rpc.getAccountInfo(address, {\n        ...rpcConfig,\n        encoding: \"jsonParsed\"\n    }).send({\n        abortSignal\n    });\n    return !!account && typeof account === \"object\" && \"parsed\" in account.data ? parseJsonRpcAccount(address, account) : parseBase64RpcAccount(address, account);\n}\nasync function fetchEncodedAccounts(rpc, addresses, config = {}) {\n    const { abortSignal, ...rpcConfig } = config;\n    const response = await rpc.getMultipleAccounts(addresses, {\n        ...rpcConfig,\n        encoding: \"base64\"\n    }).send({\n        abortSignal\n    });\n    return response.value.map((account, index)=>parseBase64RpcAccount(addresses[index], account));\n}\nasync function fetchJsonParsedAccounts(rpc, addresses, config = {}) {\n    const { abortSignal, ...rpcConfig } = config;\n    const response = await rpc.getMultipleAccounts(addresses, {\n        ...rpcConfig,\n        encoding: \"jsonParsed\"\n    }).send({\n        abortSignal\n    });\n    return response.value.map((account, index)=>{\n        return !!account && typeof account === \"object\" && \"parsed\" in account.data ? parseJsonRpcAccount(addresses[index], account) : parseBase64RpcAccount(addresses[index], account);\n    });\n}\nfunction assertAccountExists(account) {\n    if (!account.exists) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND, {\n            address: account.address\n        });\n    }\n}\nfunction assertAccountsExist(accounts) {\n    const missingAccounts = accounts.filter((a)=>!a.exists);\n    if (missingAccounts.length > 0) {\n        const missingAddresses = missingAccounts.map((a)=>a.address);\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND, {\n            addresses: missingAddresses\n        });\n    }\n}\n //# sourceMappingURL=index.node.mjs.map\n //# sourceMappingURL=index.node.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS9hY2NvdW50cy9kaXN0L2luZGV4Lm5vZGUubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFpVDtBQUNyTztBQUU1RSxpQkFBaUI7QUFDakIsSUFBSVEsb0JBQW9CO0FBQ3hCLFNBQVNDLGNBQWNDLGNBQWMsRUFBRUMsT0FBTztJQUM1QyxJQUFJO1FBQ0YsSUFBSSxZQUFZRCxrQkFBa0IsQ0FBQ0EsZUFBZUUsTUFBTSxFQUFFO1lBQ3hELE9BQU9GO1FBQ1Q7UUFDQSxPQUFPRyxPQUFPQyxNQUFNLENBQUM7WUFBRSxHQUFHSixjQUFjO1lBQUVLLE1BQU1KLFFBQVFLLE1BQU0sQ0FBQ04sZUFBZUssSUFBSTtRQUFFO0lBQ3RGLEVBQUUsT0FBTTtRQUNOLE1BQU0sSUFBSWYsdURBQVdBLENBQUNDLDRGQUFnREEsRUFBRTtZQUN0RWdCLFNBQVNQLGVBQWVPLE9BQU87UUFDakM7SUFDRjtBQUNGO0FBQ0EsU0FBU0MsY0FBY0MsT0FBTztJQUM1QixPQUFPLENBQUUsYUFBWUEsT0FBTSxLQUFNLFlBQVlBLFdBQVdBLFFBQVFQLE1BQU07QUFDeEU7QUFDQSxTQUFTUSxxQkFBcUJELE9BQU87SUFDbkMsSUFBSUQsY0FBY0MsWUFBWUEsUUFBUUosSUFBSSxZQUFZTSxZQUFZO1FBQ2hFLE1BQU0sSUFBSXJCLHVEQUFXQSxDQUFDRSw0RkFBZ0RBLEVBQUU7WUFDdEVlLFNBQVNFLFFBQVFGLE9BQU87UUFDMUI7SUFDRjtBQUNGO0FBQ0EsU0FBU0ssc0JBQXNCQyxRQUFRO0lBQ3JDLE1BQU1DLFVBQVVELFNBQVNFLE1BQU0sQ0FBQyxDQUFDQyxJQUFNUixjQUFjUSxNQUFNQSxFQUFFWCxJQUFJLFlBQVlNO0lBQzdFLElBQUlHLFFBQVFHLE1BQU0sR0FBRyxHQUFHO1FBQ3RCLE1BQU1DLG1CQUFtQkosUUFBUUssR0FBRyxDQUFDLENBQUNILElBQU1BLEVBQUVULE9BQU87UUFDckQsTUFBTSxJQUFJakIsdURBQVdB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RjtBQUNBLFNBQVM4QyxvQkFBb0J4QyxRQUFRO0lBQ25DLE1BQU15QyxrQkFBa0J6QyxTQUFTRSxNQUFNLENBQUMsQ0FBQ0MsSUFBTSxDQUFDQSxFQUFFZCxNQUFNO0lBQ3hELElBQUlvRCxnQkFBZ0JyQyxNQUFNLEdBQUcsR0FBRztRQUM5QixNQUFNc0MsbUJBQW1CRCxnQkFBZ0JuQyxHQUFHLENBQUMsQ0FBQ0gsSUFBTUEsRUFBRVQsT0FBTztRQUM3RCxNQUFNLElBQUlqQix1REFBV0EsQ0FBQ0ssa0dBQXNEQSxFQUFFO1lBQUV5QixXQUFXbUM7UUFBaUI7SUFDOUc7QUFDRjtBQUVrUyxDQUNsUyx1Q0FBdUM7Q0FDdkMsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xhdy13b3Jrcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL2FjY291bnRzL2Rpc3QvaW5kZXgubm9kZS5tanM/ODM3NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTb2xhbmFFcnJvciwgU09MQU5BX0VSUk9SX19BQ0NPVU5UU19fRkFJTEVEX1RPX0RFQ09ERV9BQ0NPVU5ULCBTT0xBTkFfRVJST1JfX0FDQ09VTlRTX19FWFBFQ1RFRF9ERUNPREVEX0FDQ09VTlQsIFNPTEFOQV9FUlJPUl9fQUNDT1VOVFNfX0VYUEVDVEVEX0FMTF9BQ0NPVU5UU19UT19CRV9ERUNPREVELCBTT0xBTkFfRVJST1JfX0FDQ09VTlRTX19BQ0NPVU5UX05PVF9GT1VORCwgU09MQU5BX0VSUk9SX19BQ0NPVU5UU19fT05FX09SX01PUkVfQUNDT1VOVFNfTk9UX0ZPVU5EIH0gZnJvbSAnQHNvbGFuYS9lcnJvcnMnO1xuaW1wb3J0IHsgZ2V0QmFzZTY0RW5jb2RlciwgZ2V0QmFzZTU4RW5jb2RlciB9IGZyb20gJ0Bzb2xhbmEvY29kZWNzLXN0cmluZ3MnO1xuXG4vLyBzcmMvYWNjb3VudC50c1xudmFyIEJBU0VfQUNDT1VOVF9TSVpFID0gMTI4O1xuZnVuY3Rpb24gZGVjb2RlQWNjb3VudChlbmNvZGVkQWNjb3VudCwgZGVjb2Rlcikge1xuICB0cnkge1xuICAgIGlmIChcImV4aXN0c1wiIGluIGVuY29kZWRBY2NvdW50ICYmICFlbmNvZGVkQWNjb3VudC5leGlzdHMpIHtcbiAgICAgIHJldHVybiBlbmNvZGVkQWNjb3VudDtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyAuLi5lbmNvZGVkQWNjb3VudCwgZGF0YTogZGVjb2Rlci5kZWNvZGUoZW5jb2RlZEFjY291bnQuZGF0YSkgfSk7XG4gIH0gY2F0Y2gge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0FDQ09VTlRTX19GQUlMRURfVE9fREVDT0RFX0FDQ09VTlQsIHtcbiAgICAgIGFkZHJlc3M6IGVuY29kZWRBY2NvdW50LmFkZHJlc3NcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gYWNjb3VudEV4aXN0cyhhY2NvdW50KSB7XG4gIHJldHVybiAhKFwiZXhpc3RzXCIgaW4gYWNjb3VudCkgfHwgXCJleGlzdHNcIiBpbiBhY2NvdW50ICYmIGFjY291bnQuZXhpc3RzO1xufVxuZnVuY3Rpb24gYXNzZXJ0QWNjb3VudERlY29kZWQoYWNjb3VudCkge1xuICBpZiAoYWNjb3VudEV4aXN0cyhhY2NvdW50KSAmJiBhY2NvdW50LmRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQUNDT1VOVFNfX0VYUEVDVEVEX0RFQ09ERURfQUNDT1VOVCwge1xuICAgICAgYWRkcmVzczogYWNjb3VudC5hZGRyZXNzXG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGFzc2VydEFjY291bnRzRGVjb2RlZChhY2NvdW50cykge1xuICBjb25zdCBlbmNvZGVkID0gYWNjb3VudHMuZmlsdGVyKChhKSA9PiBhY2NvdW50RXhpc3RzKGEpICYmIGEuZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpO1xuICBpZiAoZW5jb2RlZC5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgZW5jb2RlZEFkZHJlc3NlcyA9IGVuY29kZWQubWFwKChhKSA9PiBhLmFkZHJlc3MpO1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0FDQ09VTlRTX19FWFBFQ1RFRF9BTExfQUNDT1VOVFNfVE9fQkVfREVDT0RFRCwge1xuICAgICAgYWRkcmVzc2VzOiBlbmNvZGVkQWRkcmVzc2VzXG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlQmFzZTY0UnBjQWNjb3VudChhZGRyZXNzLCBycGNBY2NvdW50KSB7XG4gIGlmICghcnBjQWNjb3VudCkgcmV0dXJuIE9iamVjdC5mcmVlemUoeyBhZGRyZXNzLCBleGlzdHM6IGZhbHNlIH0pO1xuICBjb25zdCBkYXRhID0gZ2V0QmFzZTY0RW5jb2RlcigpLmVuY29kZShycGNBY2NvdW50LmRhdGFbMF0pO1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IC4uLnBhcnNlQmFzZUFjY291bnQocnBjQWNjb3VudCksIGFkZHJlc3MsIGRhdGEsIGV4aXN0czogdHJ1ZSB9KTtcbn1cbmZ1bmN0aW9uIHBhcnNlQmFzZTU4UnBjQWNjb3VudChhZGRyZXNzLCBycGNBY2NvdW50KSB7XG4gIGlmICghcnBjQWNjb3VudCkgcmV0dXJuIE9iamVjdC5mcmVlemUoeyBhZGRyZXNzLCBleGlzdHM6IGZhbHNlIH0pO1xuICBjb25zdCBkYXRhID0gZ2V0QmFzZTU4RW5jb2RlcigpLmVuY29kZSh0eXBlb2YgcnBjQWNjb3VudC5kYXRhID09PSBcInN0cmluZ1wiID8gcnBjQWNjb3VudC5kYXRhIDogcnBjQWNjb3VudC5kYXRhWzBdKTtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyAuLi5wYXJzZUJhc2VBY2NvdW50KHJwY0FjY291bnQpLCBhZGRyZXNzLCBkYXRhLCBleGlzdHM6IHRydWUgfSk7XG59XG5mdW5jdGlvbiBwYXJzZUpzb25ScGNBY2NvdW50KGFkZHJlc3MsIHJwY0FjY291bnQpIHtcbiAgaWYgKCFycGNBY2NvdW50KSByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IGFkZHJlc3MsIGV4aXN0czogZmFsc2UgfSk7XG4gIGNvbnN0IGRhdGEgPSBycGNBY2NvdW50LmRhdGEucGFyc2VkLmluZm8gfHwge307XG4gIGlmIChycGNBY2NvdW50LmRhdGEucHJvZ3JhbSB8fCBycGNBY2NvdW50LmRhdGEucGFyc2VkLnR5cGUpIHtcbiAgICBkYXRhLnBhcnNlZEFjY291bnRNZXRhID0ge1xuICAgICAgcHJvZ3JhbTogcnBjQWNjb3VudC5kYXRhLnByb2dyYW0sXG4gICAgICB0eXBlOiBycGNBY2NvdW50LmRhdGEucGFyc2VkLnR5cGVcbiAgICB9O1xuICB9XG4gIHJldHVybiBPYmplY3QuZnJlZXplKHsgLi4ucGFyc2VCYXNlQWNjb3VudChycGNBY2NvdW50KSwgYWRkcmVzcywgZGF0YSwgZXhpc3RzOiB0cnVlIH0pO1xufVxuZnVuY3Rpb24gcGFyc2VCYXNlQWNjb3VudChycGNBY2NvdW50KSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICBleGVjdXRhYmxlOiBycGNBY2NvdW50LmV4ZWN1dGFibGUsXG4gICAgbGFtcG9ydHM6IHJwY0FjY291bnQubGFtcG9ydHMsXG4gICAgcHJvZ3JhbUFkZHJlc3M6IHJwY0FjY291bnQub3duZXIsXG4gICAgc3BhY2U6IHJwY0FjY291bnQuc3BhY2VcbiAgfSk7XG59XG5cbi8vIHNyYy9mZXRjaC1hY2NvdW50LnRzXG5hc3luYyBmdW5jdGlvbiBmZXRjaEVuY29kZWRBY2NvdW50KHJwYywgYWRkcmVzcywgY29uZmlnID0ge30pIHtcbiAgY29uc3QgeyBhYm9ydFNpZ25hbCwgLi4ucnBjQ29uZmlnIH0gPSBjb25maWc7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcnBjLmdldEFjY291bnRJbmZvKGFkZHJlc3MsIHsgLi4ucnBjQ29uZmlnLCBlbmNvZGluZzogXCJiYXNlNjRcIiB9KS5zZW5kKHsgYWJvcnRTaWduYWwgfSk7XG4gIHJldHVybiBwYXJzZUJhc2U2NFJwY0FjY291bnQoYWRkcmVzcywgcmVzcG9uc2UudmFsdWUpO1xufVxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hKc29uUGFyc2VkQWNjb3VudChycGMsIGFkZHJlc3MsIGNvbmZpZyA9IHt9KSB7XG4gIGNvbnN0IHsgYWJvcnRTaWduYWwsIC4uLnJwY0NvbmZpZyB9ID0gY29uZmlnO1xuICBjb25zdCB7IHZhbHVlOiBhY2NvdW50IH0gPSBhd2FpdCBycGMuZ2V0QWNjb3VudEluZm8oYWRkcmVzcywgeyAuLi5ycGNDb25maWcsIGVuY29kaW5nOiBcImpzb25QYXJzZWRcIiB9KS5zZW5kKHsgYWJvcnRTaWduYWwgfSk7XG4gIHJldHVybiAhIWFjY291bnQgJiYgdHlwZW9mIGFjY291bnQgPT09IFwib2JqZWN0XCIgJiYgXCJwYXJzZWRcIiBpbiBhY2NvdW50LmRhdGEgPyBwYXJzZUpzb25ScGNBY2NvdW50KGFkZHJlc3MsIGFjY291bnQpIDogcGFyc2VCYXNlNjRScGNBY2NvdW50KGFkZHJlc3MsIGFjY291bnQpO1xufVxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hFbmNvZGVkQWNjb3VudHMocnBjLCBhZGRyZXNzZXMsIGNvbmZpZyA9IHt9KSB7XG4gIGNvbnN0IHsgYWJvcnRTaWduYWwsIC4uLnJwY0NvbmZpZyB9ID0gY29uZmlnO1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJwYy5nZXRNdWx0aXBsZUFjY291bnRzKGFkZHJlc3NlcywgeyAuLi5ycGNDb25maWcsIGVuY29kaW5nOiBcImJhc2U2NFwiIH0pLnNlbmQoeyBhYm9ydFNpZ25hbCB9KTtcbiAgcmV0dXJuIHJlc3BvbnNlLnZhbHVlLm1hcCgoYWNjb3VudCwgaW5kZXgpID0+IHBhcnNlQmFzZTY0UnBjQWNjb3VudChhZGRyZXNzZXNbaW5kZXhdLCBhY2NvdW50KSk7XG59XG5hc3luYyBmdW5jdGlvbiBmZXRjaEpzb25QYXJzZWRBY2NvdW50cyhycGMsIGFkZHJlc3NlcywgY29uZmlnID0ge30pIHtcbiAgY29uc3QgeyBhYm9ydFNpZ25hbCwgLi4ucnBjQ29uZmlnIH0gPSBjb25maWc7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcnBjLmdldE11bHRpcGxlQWNjb3VudHMoYWRkcmVzc2VzLCB7IC4uLnJwY0NvbmZpZywgZW5jb2Rpbmc6IFwianNvblBhcnNlZFwiIH0pLnNlbmQoeyBhYm9ydFNpZ25hbCB9KTtcbiAgcmV0dXJuIHJlc3BvbnNlLnZhbHVlLm1hcCgoYWNjb3VudCwgaW5kZXgpID0+IHtcbiAgICByZXR1cm4gISFhY2NvdW50ICYmIHR5cGVvZiBhY2NvdW50ID09PSBcIm9iamVjdFwiICYmIFwicGFyc2VkXCIgaW4gYWNjb3VudC5kYXRhID8gcGFyc2VKc29uUnBjQWNjb3VudChhZGRyZXNzZXNbaW5kZXhdLCBhY2NvdW50KSA6IHBhcnNlQmFzZTY0UnBjQWNjb3VudChhZGRyZXNzZXNbaW5kZXhdLCBhY2NvdW50KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBhc3NlcnRBY2NvdW50RXhpc3RzKGFjY291bnQpIHtcbiAgaWYgKCFhY2NvdW50LmV4aXN0cykge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0FDQ09VTlRTX19BQ0NPVU5UX05PVF9GT1VORCwgeyBhZGRyZXNzOiBhY2NvdW50LmFkZHJlc3MgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGFzc2VydEFjY291bnRzRXhpc3QoYWNjb3VudHMpIHtcbiAgY29uc3QgbWlzc2luZ0FjY291bnRzID0gYWNjb3VudHMuZmlsdGVyKChhKSA9PiAhYS5leGlzdHMpO1xuICBpZiAobWlzc2luZ0FjY291bnRzLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBtaXNzaW5nQWRkcmVzc2VzID0gbWlzc2luZ0FjY291bnRzLm1hcCgoYSkgPT4gYS5hZGRyZXNzKTtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19BQ0NPVU5UU19fT05FX09SX01PUkVfQUNDT1VOVFNfTk9UX0ZPVU5ELCB7IGFkZHJlc3NlczogbWlzc2luZ0FkZHJlc3NlcyB9KTtcbiAgfVxufVxuXG5leHBvcnQgeyBCQVNFX0FDQ09VTlRfU0laRSwgYXNzZXJ0QWNjb3VudERlY29kZWQsIGFzc2VydEFjY291bnRFeGlzdHMsIGFzc2VydEFjY291bnRzRGVjb2RlZCwgYXNzZXJ0QWNjb3VudHNFeGlzdCwgZGVjb2RlQWNjb3VudCwgZmV0Y2hFbmNvZGVkQWNjb3VudCwgZmV0Y2hFbmNvZGVkQWNjb3VudHMsIGZldGNoSnNvblBhcnNlZEFjY291bnQsIGZldGNoSnNvblBhcnNlZEFjY291bnRzLCBwYXJzZUJhc2U1OFJwY0FjY291bnQsIHBhcnNlQmFzZTY0UnBjQWNjb3VudCwgcGFyc2VKc29uUnBjQWNjb3VudCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubm9kZS5tanMubWFwXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5ub2RlLm1qcy5tYXAiXSwibmFtZXMiOlsiU29sYW5hRXJyb3IiLCJTT0xBTkFfRVJST1JfX0FDQ09VTlRTX19GQUlMRURfVE9fREVDT0RFX0FDQ09VTlQiLCJTT0xBTkFfRVJST1JfX0FDQ09VTlRTX19FWFBFQ1RFRF9ERUNPREVEX0FDQ09VTlQiLCJTT0xBTkFfRVJST1JfX0FDQ09VTlRTX19FWFBFQ1RFRF9BTExfQUNDT1VOVFNfVE9fQkVfREVDT0RFRCIsIlNPTEFOQV9FUlJPUl9fQUNDT1VOVFNfX0FDQ09VTlRfTk9UX0ZPVU5EIiwiU09MQU5BX0VSUk9SX19BQ0NPVU5UU19fT05FX09SX01PUkVfQUNDT1VOVFNfTk9UX0ZPVU5EIiwiZ2V0QmFzZTY0RW5jb2RlciIsImdldEJhc2U1OEVuY29kZXIiLCJCQVNFX0FDQ09VTlRfU0laRSIsImRlY29kZUFjY291bnQiLCJlbmNvZGVkQWNjb3VudCIsImRlY29kZXIiLCJleGlzdHMiLCJPYmplY3QiLCJmcmVlemUiLCJkYXRhIiwiZGVjb2RlIiwiYWRkcmVzcyIsImFjY291bnRFeGlzdHMiLCJhY2NvdW50IiwiYXNzZXJ0QWNjb3VudERlY29kZWQiLCJVaW50OEFycmF5IiwiYXNzZXJ0QWNjb3VudHNEZWNvZGVkIiwiYWNjb3VudHMiLCJlbmNvZGVkIiwiZmlsdGVyIiwiYSIsImxlbmd0aCIsImVuY29kZWRBZGRyZXNzZXMiLCJtYXAiLCJhZGRyZXNzZXMiLCJwYXJzZUJhc2U2NFJwY0FjY291bnQiLCJycGNBY2NvdW50IiwiZW5jb2RlIiwicGFyc2VCYXNlQWNjb3VudCIsInBhcnNlQmFzZTU4UnBjQWNjb3VudCIsInBhcnNlSnNvblJwY0FjY291bnQiLCJwYXJzZWQiLCJpbmZvIiwicHJvZ3JhbSIsInR5cGUiLCJwYXJzZWRBY2NvdW50TWV0YSIsImV4ZWN1dGFibGUiLCJsYW1wb3J0cyIsInByb2dyYW1BZGRyZXNzIiwib3duZXIiLCJzcGFjZSIsImZldGNoRW5jb2RlZEFjY291bnQiLCJycGMiLCJjb25maWciLCJhYm9ydFNpZ25hbCIsInJwY0NvbmZpZyIsInJlc3BvbnNlIiwiZ2V0QWNjb3VudEluZm8iLCJlbmNvZGluZyIsInNlbmQiLCJ2YWx1ZSIsImZldGNoSnNvblBhcnNlZEFjY291bnQiLCJmZXRjaEVuY29kZWRBY2NvdW50cyIsImdldE11bHRpcGxlQWNjb3VudHMiLCJpbmRleCIsImZldGNoSnNvblBhcnNlZEFjY291bnRzIiwiYXNzZXJ0QWNjb3VudEV4aXN0cyIsImFzc2VydEFjY291bnRzRXhpc3QiLCJtaXNzaW5nQWNjb3VudHMiLCJtaXNzaW5nQWRkcmVzc2VzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/accounts/dist/index.node.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/addresses/dist/index.node.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@solana/addresses/dist/index.node.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   address: () => (/* binding */ address),\n/* harmony export */   assertIsAddress: () => (/* binding */ assertIsAddress),\n/* harmony export */   assertIsOffCurveAddress: () => (/* binding */ assertIsOffCurveAddress),\n/* harmony export */   assertIsProgramDerivedAddress: () => (/* binding */ assertIsProgramDerivedAddress),\n/* harmony export */   createAddressWithSeed: () => (/* binding */ createAddressWithSeed),\n/* harmony export */   getAddressCodec: () => (/* binding */ getAddressCodec),\n/* harmony export */   getAddressComparator: () => (/* binding */ getAddressComparator),\n/* harmony export */   getAddressDecoder: () => (/* binding */ getAddressDecoder),\n/* harmony export */   getAddressEncoder: () => (/* binding */ getAddressEncoder),\n/* harmony export */   getAddressFromPublicKey: () => (/* binding */ getAddressFromPublicKey),\n/* harmony export */   getProgramDerivedAddress: () => (/* binding */ getProgramDerivedAddress),\n/* harmony export */   getPublicKeyFromAddress: () => (/* binding */ getPublicKeyFromAddress),\n/* harmony export */   isAddress: () => (/* binding */ isAddress),\n/* harmony export */   isOffCurveAddress: () => (/* binding */ isOffCurveAddress),\n/* harmony export */   isProgramDerivedAddress: () => (/* binding */ isProgramDerivedAddress),\n/* harmony export */   offCurveAddress: () => (/* binding */ offCurveAddress)\n/* harmony export */ });\n/* harmony import */ var _solana_codecs_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @solana/codecs-core */ \"(ssr)/./node_modules/@solana/codecs-core/dist/index.node.mjs\");\n/* harmony import */ var _solana_codecs_strings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/codecs-strings */ \"(ssr)/./node_modules/@solana/codecs-strings/dist/index.node.mjs\");\n/* harmony import */ var _solana_errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana/errors */ \"(ssr)/./node_modules/@solana/errors/dist/index.node.mjs\");\n/* harmony import */ var _solana_assertions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @solana/assertions */ \"(ssr)/./node_modules/@solana/assertions/dist/index.node.mjs\");\n\n\n\n\n// src/address.ts\nvar memoizedBase58Encoder;\nvar memoizedBase58Decoder;\nfunction getMemoizedBase58Encoder() {\n    if (!memoizedBase58Encoder) memoizedBase58Encoder = (0,_solana_codecs_strings__WEBPACK_IMPORTED_MODULE_0__.getBase58Encoder)();\n    return memoizedBase58Encoder;\n}\nfunction getMemoizedBase58Decoder() {\n    if (!memoizedBase58Decoder) memoizedBase58Decoder = (0,_solana_codecs_strings__WEBPACK_IMPORTED_MODULE_0__.getBase58Decoder)();\n    return memoizedBase58Decoder;\n}\nfunction isAddress(putativeAddress) {\n    if (// Lowest address (32 bytes of zeroes)\n    putativeAddress.length < 32 || // Highest address (32 bytes of 255)\n    putativeAddress.length > 44) {\n        return false;\n    }\n    const base58Encoder = getMemoizedBase58Encoder();\n    try {\n        return base58Encoder.encode(putativeAddress).byteLength === 32;\n    } catch  {\n        return false;\n    }\n}\nfunction assertIsAddress(putativeAddress) {\n    if (// Lowest address (32 bytes of zeroes)\n    putativeAddress.length < 32 || // Highest address (32 bytes of 255)\n    putativeAddress.length > 44) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE, {\n            actualLength: putativeAddress.length\n        });\n    }\n    const base58Encoder = getMemoizedBase58Encoder();\n    const bytes = base58Encoder.encode(putativeAddress);\n    const numBytes = bytes.byteLength;\n    if (numBytes !== 32) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH, {\n            actualLength: numBytes\n        });\n    }\n}\nfunction address(putativeAddress) {\n    assertIsAddress(putativeAddress);\n    return putativeAddress;\n}\nfunction getAddressEncoder() {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_2__.transformEncoder)((0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_2__.fixEncoderSize)(getMemoizedBase58Encoder(), 32), (putativeAddress)=>address(putativeAddress));\n}\nfunction getAddressDecoder() {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_2__.fixDecoderSize)(getMemoizedBase58Decoder(), 32);\n}\nfunction getAddressCodec() {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_2__.combineCodec)(getAddressEncoder(), getAddressDecoder());\n}\nfunction getAddressComparator() {\n    return new Intl.Collator(\"en\", {\n        caseFirst: \"lower\",\n        ignorePunctuation: false,\n        localeMatcher: \"best fit\",\n        numeric: false,\n        sensitivity: \"variant\",\n        usage: \"sort\"\n    }).compare;\n}\n// src/vendor/noble/ed25519.ts\nvar D = 37095705934669439343138083508754565189542113879843219016388785533085940283555n;\nvar P = 57896044618658097711785492504343953926634992332820282019728792003956564819949n;\nvar RM1 = 19681161376707505956807079304988542015446066515923890162744021073123829784752n;\nfunction mod(a) {\n    const r = a % P;\n    return r >= 0n ? r : P + r;\n}\nfunction pow2(x, power) {\n    let r = x;\n    while(power-- > 0n){\n        r *= r;\n        r %= P;\n    }\n    return r;\n}\nfunction pow_2_252_3(x) {\n    const x2 = x * x % P;\n    const b2 = x2 * x % P;\n    const b4 = pow2(b2, 2n) * b2 % P;\n    const b5 = pow2(b4, 1n) * x % P;\n    const b10 = pow2(b5, 5n) * b5 % P;\n    const b20 = pow2(b10, 10n) * b10 % P;\n    const b40 = pow2(b20, 20n) * b20 % P;\n    const b80 = pow2(b40, 40n) * b40 % P;\n    const b160 = pow2(b80, 80n) * b80 % P;\n    const b240 = pow2(b160, 80n) * b80 % P;\n    const b250 = pow2(b240, 10n) * b10 % P;\n    const pow_p_5_8 = pow2(b250, 2n) * x % P;\n    return pow_p_5_8;\n}\nfunction uvRatio(u, v) {\n    const v3 = mod(v * v * v);\n    const v7 = mod(v3 * v3 * v);\n    const pow = pow_2_252_3(u * v7);\n    let x = mod(u * v3 * pow);\n    const vx2 = mod(v * x * x);\n    const root1 = x;\n    const root2 = mod(x * RM1);\n    const useRoot1 = vx2 === u;\n    const useRoot2 = vx2 === mod(-u);\n    const noRoot = vx2 === mod(-u * RM1);\n    if (useRoot1) x = root1;\n    if (useRoot2 || noRoot) x = root2;\n    if ((mod(x) & 1n) === 1n) x = mod(-x);\n    if (!useRoot1 && !useRoot2) {\n        return null;\n    }\n    return x;\n}\nfunction pointIsOnCurve(y, lastByte) {\n    const y2 = mod(y * y);\n    const u = mod(y2 - 1n);\n    const v = mod(D * y2 + 1n);\n    const x = uvRatio(u, v);\n    if (x === null) {\n        return false;\n    }\n    const isLastByteOdd = (lastByte & 128) !== 0;\n    if (x === 0n && isLastByteOdd) {\n        return false;\n    }\n    return true;\n}\n// src/curve-internal.ts\nfunction byteToHex(byte) {\n    const hexString = byte.toString(16);\n    if (hexString.length === 1) {\n        return `0${hexString}`;\n    } else {\n        return hexString;\n    }\n}\nfunction decompressPointBytes(bytes) {\n    const hexString = bytes.reduce((acc, byte, ii)=>`${byteToHex(ii === 31 ? byte & -129 : byte)}${acc}`, \"\");\n    const integerLiteralString = `0x${hexString}`;\n    return BigInt(integerLiteralString);\n}\nfunction compressedPointBytesAreOnCurve(bytes) {\n    if (bytes.byteLength !== 32) {\n        return false;\n    }\n    const y = decompressPointBytes(bytes);\n    return pointIsOnCurve(y, bytes[31]);\n}\n// src/curve.ts\nfunction isOffCurveAddress(putativeOffCurveAddress) {\n    const addressBytes = getAddressCodec().encode(putativeOffCurveAddress);\n    return compressedPointBytesAreOnCurve(addressBytes) === false;\n}\nfunction assertIsOffCurveAddress(putativeOffCurveAddress) {\n    if (!isOffCurveAddress(putativeOffCurveAddress)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS);\n    }\n}\nfunction offCurveAddress(putativeOffCurveAddress) {\n    assertIsOffCurveAddress(putativeOffCurveAddress);\n    return putativeOffCurveAddress;\n}\nfunction isProgramDerivedAddress(value) {\n    return Array.isArray(value) && value.length === 2 && typeof value[0] === \"string\" && typeof value[1] === \"number\" && value[1] >= 0 && value[1] <= 255 && isAddress(value[0]);\n}\nfunction assertIsProgramDerivedAddress(value) {\n    const validFormat = Array.isArray(value) && value.length === 2 && typeof value[0] === \"string\" && typeof value[1] === \"number\";\n    if (!validFormat) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__ADDRESSES__MALFORMED_PDA);\n    }\n    if (value[1] < 0 || value[1] > 255) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE, {\n            bump: value[1]\n        });\n    }\n    assertIsAddress(value[0]);\n}\nvar MAX_SEED_LENGTH = 32;\nvar MAX_SEEDS = 16;\nvar PDA_MARKER_BYTES = [\n    // The string 'ProgramDerivedAddress'\n    80,\n    114,\n    111,\n    103,\n    114,\n    97,\n    109,\n    68,\n    101,\n    114,\n    105,\n    118,\n    101,\n    100,\n    65,\n    100,\n    100,\n    114,\n    101,\n    115,\n    115\n];\nasync function createProgramDerivedAddress({ programAddress, seeds }) {\n    (0,_solana_assertions__WEBPACK_IMPORTED_MODULE_3__.assertDigestCapabilityIsAvailable)();\n    if (seeds.length > MAX_SEEDS) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED, {\n            actual: seeds.length,\n            maxSeeds: MAX_SEEDS\n        });\n    }\n    let textEncoder;\n    const seedBytes = seeds.reduce((acc, seed, ii)=>{\n        const bytes = typeof seed === \"string\" ? (textEncoder ||= new TextEncoder()).encode(seed) : seed;\n        if (bytes.byteLength > MAX_SEED_LENGTH) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED, {\n                actual: bytes.byteLength,\n                index: ii,\n                maxSeedLength: MAX_SEED_LENGTH\n            });\n        }\n        acc.push(...bytes);\n        return acc;\n    }, []);\n    const base58EncodedAddressCodec = getAddressCodec();\n    const programAddressBytes = base58EncodedAddressCodec.encode(programAddress);\n    const addressBytesBuffer = await crypto.subtle.digest(\"SHA-256\", new Uint8Array([\n        ...seedBytes,\n        ...programAddressBytes,\n        ...PDA_MARKER_BYTES\n    ]));\n    const addressBytes = new Uint8Array(addressBytesBuffer);\n    if (compressedPointBytesAreOnCurve(addressBytes)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE);\n    }\n    return base58EncodedAddressCodec.decode(addressBytes);\n}\nasync function getProgramDerivedAddress({ programAddress, seeds }) {\n    let bumpSeed = 255;\n    while(bumpSeed > 0){\n        try {\n            const address2 = await createProgramDerivedAddress({\n                programAddress,\n                seeds: [\n                    ...seeds,\n                    new Uint8Array([\n                        bumpSeed\n                    ])\n                ]\n            });\n            return [\n                address2,\n                bumpSeed\n            ];\n        } catch (e) {\n            if ((0,_solana_errors__WEBPACK_IMPORTED_MODULE_1__.isSolanaError)(e, _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE)) {\n                bumpSeed--;\n            } else {\n                throw e;\n            }\n        }\n    }\n    throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED);\n}\nasync function createAddressWithSeed({ baseAddress, programAddress, seed }) {\n    const { encode, decode } = getAddressCodec();\n    const seedBytes = typeof seed === \"string\" ? new TextEncoder().encode(seed) : seed;\n    if (seedBytes.byteLength > MAX_SEED_LENGTH) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED, {\n            actual: seedBytes.byteLength,\n            index: 0,\n            maxSeedLength: MAX_SEED_LENGTH\n        });\n    }\n    const programAddressBytes = encode(programAddress);\n    if (programAddressBytes.length >= PDA_MARKER_BYTES.length && (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_2__.bytesEqual)(programAddressBytes.slice(-PDA_MARKER_BYTES.length), new Uint8Array(PDA_MARKER_BYTES))) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER);\n    }\n    const addressBytesBuffer = await crypto.subtle.digest(\"SHA-256\", new Uint8Array([\n        ...encode(baseAddress),\n        ...seedBytes,\n        ...programAddressBytes\n    ]));\n    const addressBytes = new Uint8Array(addressBytesBuffer);\n    return decode(addressBytes);\n}\nasync function getAddressFromPublicKey(publicKey) {\n    (0,_solana_assertions__WEBPACK_IMPORTED_MODULE_3__.assertKeyExporterIsAvailable)();\n    if (publicKey.type !== \"public\" || publicKey.algorithm.name !== \"Ed25519\") {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY);\n    }\n    const publicKeyBytes = await crypto.subtle.exportKey(\"raw\", publicKey);\n    return getAddressDecoder().decode(new Uint8Array(publicKeyBytes));\n}\nasync function getPublicKeyFromAddress(address2) {\n    const addressBytes = getAddressEncoder().encode(address2);\n    return await crypto.subtle.importKey(\"raw\", addressBytes, {\n        name: \"Ed25519\"\n    }, true, [\n        \"verify\"\n    ]);\n}\n //# sourceMappingURL=index.node.mjs.map\n //# sourceMappingURL=index.node.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS9hZGRyZXNzZXMvZGlzdC9pbmRleC5ub2RlLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFpSDtBQUNyQztBQUNtakI7QUFDMWhCO0FBRXJHLGlCQUFpQjtBQUNqQixJQUFJc0I7QUFDSixJQUFJQztBQUNKLFNBQVNDO0lBQ1AsSUFBSSxDQUFDRix1QkFBdUJBLHdCQUF3QmpCLHdFQUFnQkE7SUFDcEUsT0FBT2lCO0FBQ1Q7QUFDQSxTQUFTRztJQUNQLElBQUksQ0FBQ0YsdUJBQXVCQSx3QkFBd0JqQix3RUFBZ0JBO0lBQ3BFLE9BQU9pQjtBQUNUO0FBQ0EsU0FBU0csVUFBVUMsZUFBZTtJQUNoQyxJQUNFLHNDQUFzQztJQUN0Q0EsZ0JBQWdCQyxNQUFNLEdBQUcsTUFBTSxvQ0FBb0M7SUFDbkVELGdCQUFnQkMsTUFBTSxHQUFHLElBQ3pCO1FBQ0EsT0FBTztJQUNUO0lBQ0EsTUFBTUMsZ0JBQWdCTDtJQUN0QixJQUFJO1FBQ0YsT0FBT0ssY0FBY0MsTUFBTSxDQUFDSCxpQkFBaUJJLFVBQVUsS0FBSztJQUM5RCxFQUFFLE9BQU07UUFDTixPQUFPO0lBQ1Q7QUFDRjtBQUNBLFNBQVNDLGdCQUFnQkwsZUFBZTtJQUN0QyxJQUNFLHNDQUFzQztJQUN0Q0EsZ0JBQWdCQyxNQUFNLEdBQUcsTUFBTSxvQ0FBb0M7SUFDbkVELGdCQUFnQkMsTUFBTSxHQUFHLElBQ3pCO1FBQ0EsTUFBTSxJQUFJckIsdURBQVdBLENBQUNDLCtGQUFtREEsRUFBRTtZQUN6RXlCLGNBQWNOLGdCQUFnQkMsTUFBTTtRQUN0QztJQUNGO0lBQ0EsTUFBTUMsZ0JBQWdCTDtJQUN0QixNQUFNVSxRQUFRTCxjQUFjQyxNQUFNLENBQUNIO0lBQ25DLE1BQU1RLFdBQVdELE1BQU1ILFVBQVU7SUFDakMsSUFBSUksYUFBYSxJQUFJO1FBQ25CLE1BQU0sSUFBSTVCLHVEQUFXQSxDQUFDRSx3RkFBNENBLEVBQUU7WUFDbEV3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LCtEQUFVQSxDQUFDNEgsb0JBQW9CYSxLQUFLLENBQUMsQ0FBQzNCLGlCQUFpQnRGLE1BQU0sR0FBRyxJQUFJeUcsV0FBV25CLG9CQUFvQjtRQUM5SixNQUFNLElBQUkzRyx1REFBV0EsQ0FBQ1UsNkZBQWlEQTtJQUN6RTtJQUNBLE1BQU1nSCxxQkFBcUIsTUFBTUMsT0FBT0MsTUFBTSxDQUFDQyxNQUFNLENBQ25ELFdBQ0EsSUFBSUMsV0FBVztXQUFJdkcsT0FBTzhHO1dBQWlCbkI7V0FBY087S0FBb0I7SUFFL0UsTUFBTTFCLGVBQWUsSUFBSStCLFdBQVdKO0lBQ3BDLE9BQU9LLE9BQU9oQztBQUNoQjtBQUNBLGVBQWV3Qyx3QkFBd0JDLFNBQVM7SUFDOUMzSCxnRkFBNEJBO0lBQzVCLElBQUkySCxVQUFVQyxJQUFJLEtBQUssWUFBWUQsVUFBVUUsU0FBUyxDQUFDQyxJQUFJLEtBQUssV0FBVztRQUN6RSxNQUFNLElBQUkzSSx1REFBV0EsQ0FBQ1csK0ZBQW1EQTtJQUMzRTtJQUNBLE1BQU1pSSxpQkFBaUIsTUFBTWpCLE9BQU9DLE1BQU0sQ0FBQ2lCLFNBQVMsQ0FBQyxPQUFPTDtJQUM1RCxPQUFPekcsb0JBQW9CZ0csTUFBTSxDQUFDLElBQUlELFdBQVdjO0FBQ25EO0FBQ0EsZUFBZUUsd0JBQXdCWixRQUFRO0lBQzdDLE1BQU1uQyxlQUFlakUsb0JBQW9CUCxNQUFNLENBQUMyRztJQUNoRCxPQUFPLE1BQU1QLE9BQU9DLE1BQU0sQ0FBQ21CLFNBQVMsQ0FBQyxPQUFPaEQsY0FBYztRQUFFNEMsTUFBTTtJQUFVLEdBQUcsTUFBTTtRQUFDO0tBQVM7QUFDakc7QUFFb1YsQ0FDcFYsdUNBQXVDO0NBQ3ZDLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsYXctd29ya3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS9hZGRyZXNzZXMvZGlzdC9pbmRleC5ub2RlLm1qcz9kMDg3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHRyYW5zZm9ybUVuY29kZXIsIGZpeEVuY29kZXJTaXplLCBmaXhEZWNvZGVyU2l6ZSwgY29tYmluZUNvZGVjLCBieXRlc0VxdWFsIH0gZnJvbSAnQHNvbGFuYS9jb2RlY3MtY29yZSc7XG5pbXBvcnQgeyBnZXRCYXNlNThFbmNvZGVyLCBnZXRCYXNlNThEZWNvZGVyIH0gZnJvbSAnQHNvbGFuYS9jb2RlY3Mtc3RyaW5ncyc7XG5pbXBvcnQgeyBTb2xhbmFFcnJvciwgU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX1NUUklOR19MRU5HVEhfT1VUX09GX1JBTkdFLCBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fSU5WQUxJRF9CWVRFX0xFTkdUSCwgU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX0lOVkFMSURfT0ZGX0NVUlZFX0FERFJFU1MsIFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19NQUxGT1JNRURfUERBLCBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fUERBX0JVTVBfU0VFRF9PVVRfT0ZfUkFOR0UsIGlzU29sYW5hRXJyb3IsIFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19JTlZBTElEX1NFRURTX1BPSU5UX09OX0NVUlZFLCBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fRkFJTEVEX1RPX0ZJTkRfVklBQkxFX1BEQV9CVU1QX1NFRUQsIFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19NQVhfUERBX1NFRURfTEVOR1RIX0VYQ0VFREVELCBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fUERBX0VORFNfV0lUSF9QREFfTUFSS0VSLCBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fSU5WQUxJRF9FRDI1NTE5X1BVQkxJQ19LRVksIFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19NQVhfTlVNQkVSX09GX1BEQV9TRUVEU19FWENFRURFRCB9IGZyb20gJ0Bzb2xhbmEvZXJyb3JzJztcbmltcG9ydCB7IGFzc2VydEtleUV4cG9ydGVySXNBdmFpbGFibGUsIGFzc2VydERpZ2VzdENhcGFiaWxpdHlJc0F2YWlsYWJsZSB9IGZyb20gJ0Bzb2xhbmEvYXNzZXJ0aW9ucyc7XG5cbi8vIHNyYy9hZGRyZXNzLnRzXG52YXIgbWVtb2l6ZWRCYXNlNThFbmNvZGVyO1xudmFyIG1lbW9pemVkQmFzZTU4RGVjb2RlcjtcbmZ1bmN0aW9uIGdldE1lbW9pemVkQmFzZTU4RW5jb2RlcigpIHtcbiAgaWYgKCFtZW1vaXplZEJhc2U1OEVuY29kZXIpIG1lbW9pemVkQmFzZTU4RW5jb2RlciA9IGdldEJhc2U1OEVuY29kZXIoKTtcbiAgcmV0dXJuIG1lbW9pemVkQmFzZTU4RW5jb2Rlcjtcbn1cbmZ1bmN0aW9uIGdldE1lbW9pemVkQmFzZTU4RGVjb2RlcigpIHtcbiAgaWYgKCFtZW1vaXplZEJhc2U1OERlY29kZXIpIG1lbW9pemVkQmFzZTU4RGVjb2RlciA9IGdldEJhc2U1OERlY29kZXIoKTtcbiAgcmV0dXJuIG1lbW9pemVkQmFzZTU4RGVjb2Rlcjtcbn1cbmZ1bmN0aW9uIGlzQWRkcmVzcyhwdXRhdGl2ZUFkZHJlc3MpIHtcbiAgaWYgKFxuICAgIC8vIExvd2VzdCBhZGRyZXNzICgzMiBieXRlcyBvZiB6ZXJvZXMpXG4gICAgcHV0YXRpdmVBZGRyZXNzLmxlbmd0aCA8IDMyIHx8IC8vIEhpZ2hlc3QgYWRkcmVzcyAoMzIgYnl0ZXMgb2YgMjU1KVxuICAgIHB1dGF0aXZlQWRkcmVzcy5sZW5ndGggPiA0NFxuICApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgYmFzZTU4RW5jb2RlciA9IGdldE1lbW9pemVkQmFzZTU4RW5jb2RlcigpO1xuICB0cnkge1xuICAgIHJldHVybiBiYXNlNThFbmNvZGVyLmVuY29kZShwdXRhdGl2ZUFkZHJlc3MpLmJ5dGVMZW5ndGggPT09IDMyO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIGFzc2VydElzQWRkcmVzcyhwdXRhdGl2ZUFkZHJlc3MpIHtcbiAgaWYgKFxuICAgIC8vIExvd2VzdCBhZGRyZXNzICgzMiBieXRlcyBvZiB6ZXJvZXMpXG4gICAgcHV0YXRpdmVBZGRyZXNzLmxlbmd0aCA8IDMyIHx8IC8vIEhpZ2hlc3QgYWRkcmVzcyAoMzIgYnl0ZXMgb2YgMjU1KVxuICAgIHB1dGF0aXZlQWRkcmVzcy5sZW5ndGggPiA0NFxuICApIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX1NUUklOR19MRU5HVEhfT1VUX09GX1JBTkdFLCB7XG4gICAgICBhY3R1YWxMZW5ndGg6IHB1dGF0aXZlQWRkcmVzcy5sZW5ndGhcbiAgICB9KTtcbiAgfVxuICBjb25zdCBiYXNlNThFbmNvZGVyID0gZ2V0TWVtb2l6ZWRCYXNlNThFbmNvZGVyKCk7XG4gIGNvbnN0IGJ5dGVzID0gYmFzZTU4RW5jb2Rlci5lbmNvZGUocHV0YXRpdmVBZGRyZXNzKTtcbiAgY29uc3QgbnVtQnl0ZXMgPSBieXRlcy5ieXRlTGVuZ3RoO1xuICBpZiAobnVtQnl0ZXMgIT09IDMyKSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19JTlZBTElEX0JZVEVfTEVOR1RILCB7XG4gICAgICBhY3R1YWxMZW5ndGg6IG51bUJ5dGVzXG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGFkZHJlc3MocHV0YXRpdmVBZGRyZXNzKSB7XG4gIGFzc2VydElzQWRkcmVzcyhwdXRhdGl2ZUFkZHJlc3MpO1xuICByZXR1cm4gcHV0YXRpdmVBZGRyZXNzO1xufVxuZnVuY3Rpb24gZ2V0QWRkcmVzc0VuY29kZXIoKSB7XG4gIHJldHVybiB0cmFuc2Zvcm1FbmNvZGVyKFxuICAgIGZpeEVuY29kZXJTaXplKGdldE1lbW9pemVkQmFzZTU4RW5jb2RlcigpLCAzMiksXG4gICAgKHB1dGF0aXZlQWRkcmVzcykgPT4gYWRkcmVzcyhwdXRhdGl2ZUFkZHJlc3MpXG4gICk7XG59XG5mdW5jdGlvbiBnZXRBZGRyZXNzRGVjb2RlcigpIHtcbiAgcmV0dXJuIGZpeERlY29kZXJTaXplKGdldE1lbW9pemVkQmFzZTU4RGVjb2RlcigpLCAzMik7XG59XG5mdW5jdGlvbiBnZXRBZGRyZXNzQ29kZWMoKSB7XG4gIHJldHVybiBjb21iaW5lQ29kZWMoZ2V0QWRkcmVzc0VuY29kZXIoKSwgZ2V0QWRkcmVzc0RlY29kZXIoKSk7XG59XG5mdW5jdGlvbiBnZXRBZGRyZXNzQ29tcGFyYXRvcigpIHtcbiAgcmV0dXJuIG5ldyBJbnRsLkNvbGxhdG9yKFwiZW5cIiwge1xuICAgIGNhc2VGaXJzdDogXCJsb3dlclwiLFxuICAgIGlnbm9yZVB1bmN0dWF0aW9uOiBmYWxzZSxcbiAgICBsb2NhbGVNYXRjaGVyOiBcImJlc3QgZml0XCIsXG4gICAgbnVtZXJpYzogZmFsc2UsXG4gICAgc2Vuc2l0aXZpdHk6IFwidmFyaWFudFwiLFxuICAgIHVzYWdlOiBcInNvcnRcIlxuICB9KS5jb21wYXJlO1xufVxuXG4vLyBzcmMvdmVuZG9yL25vYmxlL2VkMjU1MTkudHNcbnZhciBEID0gMzcwOTU3MDU5MzQ2Njk0MzkzNDMxMzgwODM1MDg3NTQ1NjUxODk1NDIxMTM4Nzk4NDMyMTkwMTYzODg3ODU1MzMwODU5NDAyODM1NTVuO1xudmFyIFAgPSA1Nzg5NjA0NDYxODY1ODA5NzcxMTc4NTQ5MjUwNDM0Mzk1MzkyNjYzNDk5MjMzMjgyMDI4MjAxOTcyODc5MjAwMzk1NjU2NDgxOTk0OW47XG52YXIgUk0xID0gMTk2ODExNjEzNzY3MDc1MDU5NTY4MDcwNzkzMDQ5ODg1NDIwMTU0NDYwNjY1MTU5MjM4OTAxNjI3NDQwMjEwNzMxMjM4Mjk3ODQ3NTJuO1xuZnVuY3Rpb24gbW9kKGEpIHtcbiAgY29uc3QgciA9IGEgJSBQO1xuICByZXR1cm4gciA+PSAwbiA/IHIgOiBQICsgcjtcbn1cbmZ1bmN0aW9uIHBvdzIoeCwgcG93ZXIpIHtcbiAgbGV0IHIgPSB4O1xuICB3aGlsZSAocG93ZXItLSA+IDBuKSB7XG4gICAgciAqPSByO1xuICAgIHIgJT0gUDtcbiAgfVxuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIHBvd18yXzI1Ml8zKHgpIHtcbiAgY29uc3QgeDIgPSB4ICogeCAlIFA7XG4gIGNvbnN0IGIyID0geDIgKiB4ICUgUDtcbiAgY29uc3QgYjQgPSBwb3cyKGIyLCAybikgKiBiMiAlIFA7XG4gIGNvbnN0IGI1ID0gcG93MihiNCwgMW4pICogeCAlIFA7XG4gIGNvbnN0IGIxMCA9IHBvdzIoYjUsIDVuKSAqIGI1ICUgUDtcbiAgY29uc3QgYjIwID0gcG93MihiMTAsIDEwbikgKiBiMTAgJSBQO1xuICBjb25zdCBiNDAgPSBwb3cyKGIyMCwgMjBuKSAqIGIyMCAlIFA7XG4gIGNvbnN0IGI4MCA9IHBvdzIoYjQwLCA0MG4pICogYjQwICUgUDtcbiAgY29uc3QgYjE2MCA9IHBvdzIoYjgwLCA4MG4pICogYjgwICUgUDtcbiAgY29uc3QgYjI0MCA9IHBvdzIoYjE2MCwgODBuKSAqIGI4MCAlIFA7XG4gIGNvbnN0IGIyNTAgPSBwb3cyKGIyNDAsIDEwbikgKiBiMTAgJSBQO1xuICBjb25zdCBwb3dfcF81XzggPSBwb3cyKGIyNTAsIDJuKSAqIHggJSBQO1xuICByZXR1cm4gcG93X3BfNV84O1xufVxuZnVuY3Rpb24gdXZSYXRpbyh1LCB2KSB7XG4gIGNvbnN0IHYzID0gbW9kKHYgKiB2ICogdik7XG4gIGNvbnN0IHY3ID0gbW9kKHYzICogdjMgKiB2KTtcbiAgY29uc3QgcG93ID0gcG93XzJfMjUyXzModSAqIHY3KTtcbiAgbGV0IHggPSBtb2QodSAqIHYzICogcG93KTtcbiAgY29uc3QgdngyID0gbW9kKHYgKiB4ICogeCk7XG4gIGNvbnN0IHJvb3QxID0geDtcbiAgY29uc3Qgcm9vdDIgPSBtb2QoeCAqIFJNMSk7XG4gIGNvbnN0IHVzZVJvb3QxID0gdngyID09PSB1O1xuICBjb25zdCB1c2VSb290MiA9IHZ4MiA9PT0gbW9kKC11KTtcbiAgY29uc3Qgbm9Sb290ID0gdngyID09PSBtb2QoLXUgKiBSTTEpO1xuICBpZiAodXNlUm9vdDEpIHggPSByb290MTtcbiAgaWYgKHVzZVJvb3QyIHx8IG5vUm9vdCkgeCA9IHJvb3QyO1xuICBpZiAoKG1vZCh4KSAmIDFuKSA9PT0gMW4pIHggPSBtb2QoLXgpO1xuICBpZiAoIXVzZVJvb3QxICYmICF1c2VSb290Mikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiB4O1xufVxuZnVuY3Rpb24gcG9pbnRJc09uQ3VydmUoeSwgbGFzdEJ5dGUpIHtcbiAgY29uc3QgeTIgPSBtb2QoeSAqIHkpO1xuICBjb25zdCB1ID0gbW9kKHkyIC0gMW4pO1xuICBjb25zdCB2ID0gbW9kKEQgKiB5MiArIDFuKTtcbiAgY29uc3QgeCA9IHV2UmF0aW8odSwgdik7XG4gIGlmICh4ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGlzTGFzdEJ5dGVPZGQgPSAobGFzdEJ5dGUgJiAxMjgpICE9PSAwO1xuICBpZiAoeCA9PT0gMG4gJiYgaXNMYXN0Qnl0ZU9kZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gc3JjL2N1cnZlLWludGVybmFsLnRzXG5mdW5jdGlvbiBieXRlVG9IZXgoYnl0ZSkge1xuICBjb25zdCBoZXhTdHJpbmcgPSBieXRlLnRvU3RyaW5nKDE2KTtcbiAgaWYgKGhleFN0cmluZy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gYDAke2hleFN0cmluZ31gO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBoZXhTdHJpbmc7XG4gIH1cbn1cbmZ1bmN0aW9uIGRlY29tcHJlc3NQb2ludEJ5dGVzKGJ5dGVzKSB7XG4gIGNvbnN0IGhleFN0cmluZyA9IGJ5dGVzLnJlZHVjZSgoYWNjLCBieXRlLCBpaSkgPT4gYCR7Ynl0ZVRvSGV4KGlpID09PSAzMSA/IGJ5dGUgJiAtMTI5IDogYnl0ZSl9JHthY2N9YCwgXCJcIik7XG4gIGNvbnN0IGludGVnZXJMaXRlcmFsU3RyaW5nID0gYDB4JHtoZXhTdHJpbmd9YDtcbiAgcmV0dXJuIEJpZ0ludChpbnRlZ2VyTGl0ZXJhbFN0cmluZyk7XG59XG5mdW5jdGlvbiBjb21wcmVzc2VkUG9pbnRCeXRlc0FyZU9uQ3VydmUoYnl0ZXMpIHtcbiAgaWYgKGJ5dGVzLmJ5dGVMZW5ndGggIT09IDMyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHkgPSBkZWNvbXByZXNzUG9pbnRCeXRlcyhieXRlcyk7XG4gIHJldHVybiBwb2ludElzT25DdXJ2ZSh5LCBieXRlc1szMV0pO1xufVxuXG4vLyBzcmMvY3VydmUudHNcbmZ1bmN0aW9uIGlzT2ZmQ3VydmVBZGRyZXNzKHB1dGF0aXZlT2ZmQ3VydmVBZGRyZXNzKSB7XG4gIGNvbnN0IGFkZHJlc3NCeXRlcyA9IGdldEFkZHJlc3NDb2RlYygpLmVuY29kZShwdXRhdGl2ZU9mZkN1cnZlQWRkcmVzcyk7XG4gIHJldHVybiBjb21wcmVzc2VkUG9pbnRCeXRlc0FyZU9uQ3VydmUoYWRkcmVzc0J5dGVzKSA9PT0gZmFsc2U7XG59XG5mdW5jdGlvbiBhc3NlcnRJc09mZkN1cnZlQWRkcmVzcyhwdXRhdGl2ZU9mZkN1cnZlQWRkcmVzcykge1xuICBpZiAoIWlzT2ZmQ3VydmVBZGRyZXNzKHB1dGF0aXZlT2ZmQ3VydmVBZGRyZXNzKSkge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fSU5WQUxJRF9PRkZfQ1VSVkVfQUREUkVTUyk7XG4gIH1cbn1cbmZ1bmN0aW9uIG9mZkN1cnZlQWRkcmVzcyhwdXRhdGl2ZU9mZkN1cnZlQWRkcmVzcykge1xuICBhc3NlcnRJc09mZkN1cnZlQWRkcmVzcyhwdXRhdGl2ZU9mZkN1cnZlQWRkcmVzcyk7XG4gIHJldHVybiBwdXRhdGl2ZU9mZkN1cnZlQWRkcmVzcztcbn1cbmZ1bmN0aW9uIGlzUHJvZ3JhbURlcml2ZWRBZGRyZXNzKHZhbHVlKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDIgJiYgdHlwZW9mIHZhbHVlWzBdID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiB2YWx1ZVsxXSA9PT0gXCJudW1iZXJcIiAmJiB2YWx1ZVsxXSA+PSAwICYmIHZhbHVlWzFdIDw9IDI1NSAmJiBpc0FkZHJlc3ModmFsdWVbMF0pO1xufVxuZnVuY3Rpb24gYXNzZXJ0SXNQcm9ncmFtRGVyaXZlZEFkZHJlc3ModmFsdWUpIHtcbiAgY29uc3QgdmFsaWRGb3JtYXQgPSBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDIgJiYgdHlwZW9mIHZhbHVlWzBdID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiB2YWx1ZVsxXSA9PT0gXCJudW1iZXJcIjtcbiAgaWYgKCF2YWxpZEZvcm1hdCkge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fTUFMRk9STUVEX1BEQSk7XG4gIH1cbiAgaWYgKHZhbHVlWzFdIDwgMCB8fCB2YWx1ZVsxXSA+IDI1NSkge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fUERBX0JVTVBfU0VFRF9PVVRfT0ZfUkFOR0UsIHtcbiAgICAgIGJ1bXA6IHZhbHVlWzFdXG4gICAgfSk7XG4gIH1cbiAgYXNzZXJ0SXNBZGRyZXNzKHZhbHVlWzBdKTtcbn1cbnZhciBNQVhfU0VFRF9MRU5HVEggPSAzMjtcbnZhciBNQVhfU0VFRFMgPSAxNjtcbnZhciBQREFfTUFSS0VSX0JZVEVTID0gW1xuICAvLyBUaGUgc3RyaW5nICdQcm9ncmFtRGVyaXZlZEFkZHJlc3MnXG4gIDgwLFxuICAxMTQsXG4gIDExMSxcbiAgMTAzLFxuICAxMTQsXG4gIDk3LFxuICAxMDksXG4gIDY4LFxuICAxMDEsXG4gIDExNCxcbiAgMTA1LFxuICAxMTgsXG4gIDEwMSxcbiAgMTAwLFxuICA2NSxcbiAgMTAwLFxuICAxMDAsXG4gIDExNCxcbiAgMTAxLFxuICAxMTUsXG4gIDExNVxuXTtcbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVByb2dyYW1EZXJpdmVkQWRkcmVzcyh7IHByb2dyYW1BZGRyZXNzLCBzZWVkcyB9KSB7XG4gIGFzc2VydERpZ2VzdENhcGFiaWxpdHlJc0F2YWlsYWJsZSgpO1xuICBpZiAoc2VlZHMubGVuZ3RoID4gTUFYX1NFRURTKSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19NQVhfTlVNQkVSX09GX1BEQV9TRUVEU19FWENFRURFRCwge1xuICAgICAgYWN0dWFsOiBzZWVkcy5sZW5ndGgsXG4gICAgICBtYXhTZWVkczogTUFYX1NFRURTXG4gICAgfSk7XG4gIH1cbiAgbGV0IHRleHRFbmNvZGVyO1xuICBjb25zdCBzZWVkQnl0ZXMgPSBzZWVkcy5yZWR1Y2UoKGFjYywgc2VlZCwgaWkpID0+IHtcbiAgICBjb25zdCBieXRlcyA9IHR5cGVvZiBzZWVkID09PSBcInN0cmluZ1wiID8gKHRleHRFbmNvZGVyIHx8PSBuZXcgVGV4dEVuY29kZXIoKSkuZW5jb2RlKHNlZWQpIDogc2VlZDtcbiAgICBpZiAoYnl0ZXMuYnl0ZUxlbmd0aCA+IE1BWF9TRUVEX0xFTkdUSCkge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19NQVhfUERBX1NFRURfTEVOR1RIX0VYQ0VFREVELCB7XG4gICAgICAgIGFjdHVhbDogYnl0ZXMuYnl0ZUxlbmd0aCxcbiAgICAgICAgaW5kZXg6IGlpLFxuICAgICAgICBtYXhTZWVkTGVuZ3RoOiBNQVhfU0VFRF9MRU5HVEhcbiAgICAgIH0pO1xuICAgIH1cbiAgICBhY2MucHVzaCguLi5ieXRlcyk7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwgW10pO1xuICBjb25zdCBiYXNlNThFbmNvZGVkQWRkcmVzc0NvZGVjID0gZ2V0QWRkcmVzc0NvZGVjKCk7XG4gIGNvbnN0IHByb2dyYW1BZGRyZXNzQnl0ZXMgPSBiYXNlNThFbmNvZGVkQWRkcmVzc0NvZGVjLmVuY29kZShwcm9ncmFtQWRkcmVzcyk7XG4gIGNvbnN0IGFkZHJlc3NCeXRlc0J1ZmZlciA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuZGlnZXN0KFxuICAgIFwiU0hBLTI1NlwiLFxuICAgIG5ldyBVaW50OEFycmF5KFsuLi5zZWVkQnl0ZXMsIC4uLnByb2dyYW1BZGRyZXNzQnl0ZXMsIC4uLlBEQV9NQVJLRVJfQllURVNdKVxuICApO1xuICBjb25zdCBhZGRyZXNzQnl0ZXMgPSBuZXcgVWludDhBcnJheShhZGRyZXNzQnl0ZXNCdWZmZXIpO1xuICBpZiAoY29tcHJlc3NlZFBvaW50Qnl0ZXNBcmVPbkN1cnZlKGFkZHJlc3NCeXRlcykpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX0lOVkFMSURfU0VFRFNfUE9JTlRfT05fQ1VSVkUpO1xuICB9XG4gIHJldHVybiBiYXNlNThFbmNvZGVkQWRkcmVzc0NvZGVjLmRlY29kZShhZGRyZXNzQnl0ZXMpO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0UHJvZ3JhbURlcml2ZWRBZGRyZXNzKHtcbiAgcHJvZ3JhbUFkZHJlc3MsXG4gIHNlZWRzXG59KSB7XG4gIGxldCBidW1wU2VlZCA9IDI1NTtcbiAgd2hpbGUgKGJ1bXBTZWVkID4gMCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBhZGRyZXNzMiA9IGF3YWl0IGNyZWF0ZVByb2dyYW1EZXJpdmVkQWRkcmVzcyh7XG4gICAgICAgIHByb2dyYW1BZGRyZXNzLFxuICAgICAgICBzZWVkczogWy4uLnNlZWRzLCBuZXcgVWludDhBcnJheShbYnVtcFNlZWRdKV1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFthZGRyZXNzMiwgYnVtcFNlZWRdO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChpc1NvbGFuYUVycm9yKGUsIFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19JTlZBTElEX1NFRURTX1BPSU5UX09OX0NVUlZFKSkge1xuICAgICAgICBidW1wU2VlZC0tO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19GQUlMRURfVE9fRklORF9WSUFCTEVfUERBX0JVTVBfU0VFRCk7XG59XG5hc3luYyBmdW5jdGlvbiBjcmVhdGVBZGRyZXNzV2l0aFNlZWQoeyBiYXNlQWRkcmVzcywgcHJvZ3JhbUFkZHJlc3MsIHNlZWQgfSkge1xuICBjb25zdCB7IGVuY29kZSwgZGVjb2RlIH0gPSBnZXRBZGRyZXNzQ29kZWMoKTtcbiAgY29uc3Qgc2VlZEJ5dGVzID0gdHlwZW9mIHNlZWQgPT09IFwic3RyaW5nXCIgPyBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc2VlZCkgOiBzZWVkO1xuICBpZiAoc2VlZEJ5dGVzLmJ5dGVMZW5ndGggPiBNQVhfU0VFRF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX01BWF9QREFfU0VFRF9MRU5HVEhfRVhDRUVERUQsIHtcbiAgICAgIGFjdHVhbDogc2VlZEJ5dGVzLmJ5dGVMZW5ndGgsXG4gICAgICBpbmRleDogMCxcbiAgICAgIG1heFNlZWRMZW5ndGg6IE1BWF9TRUVEX0xFTkdUSFxuICAgIH0pO1xuICB9XG4gIGNvbnN0IHByb2dyYW1BZGRyZXNzQnl0ZXMgPSBlbmNvZGUocHJvZ3JhbUFkZHJlc3MpO1xuICBpZiAocHJvZ3JhbUFkZHJlc3NCeXRlcy5sZW5ndGggPj0gUERBX01BUktFUl9CWVRFUy5sZW5ndGggJiYgYnl0ZXNFcXVhbChwcm9ncmFtQWRkcmVzc0J5dGVzLnNsaWNlKC1QREFfTUFSS0VSX0JZVEVTLmxlbmd0aCksIG5ldyBVaW50OEFycmF5KFBEQV9NQVJLRVJfQllURVMpKSkge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fUERBX0VORFNfV0lUSF9QREFfTUFSS0VSKTtcbiAgfVxuICBjb25zdCBhZGRyZXNzQnl0ZXNCdWZmZXIgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmRpZ2VzdChcbiAgICBcIlNIQS0yNTZcIixcbiAgICBuZXcgVWludDhBcnJheShbLi4uZW5jb2RlKGJhc2VBZGRyZXNzKSwgLi4uc2VlZEJ5dGVzLCAuLi5wcm9ncmFtQWRkcmVzc0J5dGVzXSlcbiAgKTtcbiAgY29uc3QgYWRkcmVzc0J5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYWRkcmVzc0J5dGVzQnVmZmVyKTtcbiAgcmV0dXJuIGRlY29kZShhZGRyZXNzQnl0ZXMpO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0QWRkcmVzc0Zyb21QdWJsaWNLZXkocHVibGljS2V5KSB7XG4gIGFzc2VydEtleUV4cG9ydGVySXNBdmFpbGFibGUoKTtcbiAgaWYgKHB1YmxpY0tleS50eXBlICE9PSBcInB1YmxpY1wiIHx8IHB1YmxpY0tleS5hbGdvcml0aG0ubmFtZSAhPT0gXCJFZDI1NTE5XCIpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX0lOVkFMSURfRUQyNTUxOV9QVUJMSUNfS0VZKTtcbiAgfVxuICBjb25zdCBwdWJsaWNLZXlCeXRlcyA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuZXhwb3J0S2V5KFwicmF3XCIsIHB1YmxpY0tleSk7XG4gIHJldHVybiBnZXRBZGRyZXNzRGVjb2RlcigpLmRlY29kZShuZXcgVWludDhBcnJheShwdWJsaWNLZXlCeXRlcykpO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0UHVibGljS2V5RnJvbUFkZHJlc3MoYWRkcmVzczIpIHtcbiAgY29uc3QgYWRkcmVzc0J5dGVzID0gZ2V0QWRkcmVzc0VuY29kZXIoKS5lbmNvZGUoYWRkcmVzczIpO1xuICByZXR1cm4gYXdhaXQgY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoXCJyYXdcIiwgYWRkcmVzc0J5dGVzLCB7IG5hbWU6IFwiRWQyNTUxOVwiIH0sIHRydWUsIFtcInZlcmlmeVwiXSk7XG59XG5cbmV4cG9ydCB7IGFkZHJlc3MsIGFzc2VydElzQWRkcmVzcywgYXNzZXJ0SXNPZmZDdXJ2ZUFkZHJlc3MsIGFzc2VydElzUHJvZ3JhbURlcml2ZWRBZGRyZXNzLCBjcmVhdGVBZGRyZXNzV2l0aFNlZWQsIGdldEFkZHJlc3NDb2RlYywgZ2V0QWRkcmVzc0NvbXBhcmF0b3IsIGdldEFkZHJlc3NEZWNvZGVyLCBnZXRBZGRyZXNzRW5jb2RlciwgZ2V0QWRkcmVzc0Zyb21QdWJsaWNLZXksIGdldFByb2dyYW1EZXJpdmVkQWRkcmVzcywgZ2V0UHVibGljS2V5RnJvbUFkZHJlc3MsIGlzQWRkcmVzcywgaXNPZmZDdXJ2ZUFkZHJlc3MsIGlzUHJvZ3JhbURlcml2ZWRBZGRyZXNzLCBvZmZDdXJ2ZUFkZHJlc3MgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm5vZGUubWpzLm1hcFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubm9kZS5tanMubWFwIl0sIm5hbWVzIjpbInRyYW5zZm9ybUVuY29kZXIiLCJmaXhFbmNvZGVyU2l6ZSIsImZpeERlY29kZXJTaXplIiwiY29tYmluZUNvZGVjIiwiYnl0ZXNFcXVhbCIsImdldEJhc2U1OEVuY29kZXIiLCJnZXRCYXNlNThEZWNvZGVyIiwiU29sYW5hRXJyb3IiLCJTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fU1RSSU5HX0xFTkdUSF9PVVRfT0ZfUkFOR0UiLCJTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fSU5WQUxJRF9CWVRFX0xFTkdUSCIsIlNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19JTlZBTElEX09GRl9DVVJWRV9BRERSRVNTIiwiU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX01BTEZPUk1FRF9QREEiLCJTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fUERBX0JVTVBfU0VFRF9PVVRfT0ZfUkFOR0UiLCJpc1NvbGFuYUVycm9yIiwiU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX0lOVkFMSURfU0VFRFNfUE9JTlRfT05fQ1VSVkUiLCJTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fRkFJTEVEX1RPX0ZJTkRfVklBQkxFX1BEQV9CVU1QX1NFRUQiLCJTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fTUFYX1BEQV9TRUVEX0xFTkdUSF9FWENFRURFRCIsIlNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19QREFfRU5EU19XSVRIX1BEQV9NQVJLRVIiLCJTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fSU5WQUxJRF9FRDI1NTE5X1BVQkxJQ19LRVkiLCJTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fTUFYX05VTUJFUl9PRl9QREFfU0VFRFNfRVhDRUVERUQiLCJhc3NlcnRLZXlFeHBvcnRlcklzQXZhaWxhYmxlIiwiYXNzZXJ0RGlnZXN0Q2FwYWJpbGl0eUlzQXZhaWxhYmxlIiwibWVtb2l6ZWRCYXNlNThFbmNvZGVyIiwibWVtb2l6ZWRCYXNlNThEZWNvZGVyIiwiZ2V0TWVtb2l6ZWRCYXNlNThFbmNvZGVyIiwiZ2V0TWVtb2l6ZWRCYXNlNThEZWNvZGVyIiwiaXNBZGRyZXNzIiwicHV0YXRpdmVBZGRyZXNzIiwibGVuZ3RoIiwiYmFzZTU4RW5jb2RlciIsImVuY29kZSIsImJ5dGVMZW5ndGgiLCJhc3NlcnRJc0FkZHJlc3MiLCJhY3R1YWxMZW5ndGgiLCJieXRlcyIsIm51bUJ5dGVzIiwiYWRkcmVzcyIsImdldEFkZHJlc3NFbmNvZGVyIiwiZ2V0QWRkcmVzc0RlY29kZXIiLCJnZXRBZGRyZXNzQ29kZWMiLCJnZXRBZGRyZXNzQ29tcGFyYXRvciIsIkludGwiLCJDb2xsYXRvciIsImNhc2VGaXJzdCIsImlnbm9yZVB1bmN0dWF0aW9uIiwibG9jYWxlTWF0Y2hlciIsIm51bWVyaWMiLCJzZW5zaXRpdml0eSIsInVzYWdlIiwiY29tcGFyZSIsIkQiLCJQIiwiUk0xIiwibW9kIiwiYSIsInIiLCJwb3cyIiwieCIsInBvd2VyIiwicG93XzJfMjUyXzMiLCJ4MiIsImIyIiwiYjQiLCJiNSIsImIxMCIsImIyMCIsImI0MCIsImI4MCIsImIxNjAiLCJiMjQwIiwiYjI1MCIsInBvd19wXzVfOCIsInV2UmF0aW8iLCJ1IiwidiIsInYzIiwidjciLCJwb3ciLCJ2eDIiLCJyb290MSIsInJvb3QyIiwidXNlUm9vdDEiLCJ1c2VSb290MiIsIm5vUm9vdCIsInBvaW50SXNPbkN1cnZlIiwieSIsImxhc3RCeXRlIiwieTIiLCJpc0xhc3RCeXRlT2RkIiwiYnl0ZVRvSGV4IiwiYnl0ZSIsImhleFN0cmluZyIsInRvU3RyaW5nIiwiZGVjb21wcmVzc1BvaW50Qnl0ZXMiLCJyZWR1Y2UiLCJhY2MiLCJpaSIsImludGVnZXJMaXRlcmFsU3RyaW5nIiwiQmlnSW50IiwiY29tcHJlc3NlZFBvaW50Qnl0ZXNBcmVPbkN1cnZlIiwiaXNPZmZDdXJ2ZUFkZHJlc3MiLCJwdXRhdGl2ZU9mZkN1cnZlQWRkcmVzcyIsImFkZHJlc3NCeXRlcyIsImFzc2VydElzT2ZmQ3VydmVBZGRyZXNzIiwib2ZmQ3VydmVBZGRyZXNzIiwiaXNQcm9ncmFtRGVyaXZlZEFkZHJlc3MiLCJ2YWx1ZSIsIkFycmF5IiwiaXNBcnJheSIsImFzc2VydElzUHJvZ3JhbURlcml2ZWRBZGRyZXNzIiwidmFsaWRGb3JtYXQiLCJidW1wIiwiTUFYX1NFRURfTEVOR1RIIiwiTUFYX1NFRURTIiwiUERBX01BUktFUl9CWVRFUyIsImNyZWF0ZVByb2dyYW1EZXJpdmVkQWRkcmVzcyIsInByb2dyYW1BZGRyZXNzIiwic2VlZHMiLCJhY3R1YWwiLCJtYXhTZWVkcyIsInRleHRFbmNvZGVyIiwic2VlZEJ5dGVzIiwic2VlZCIsIlRleHRFbmNvZGVyIiwiaW5kZXgiLCJtYXhTZWVkTGVuZ3RoIiwicHVzaCIsImJhc2U1OEVuY29kZWRBZGRyZXNzQ29kZWMiLCJwcm9ncmFtQWRkcmVzc0J5dGVzIiwiYWRkcmVzc0J5dGVzQnVmZmVyIiwiY3J5cHRvIiwic3VidGxlIiwiZGlnZXN0IiwiVWludDhBcnJheSIsImRlY29kZSIsImdldFByb2dyYW1EZXJpdmVkQWRkcmVzcyIsImJ1bXBTZWVkIiwiYWRkcmVzczIiLCJlIiwiY3JlYXRlQWRkcmVzc1dpdGhTZWVkIiwiYmFzZUFkZHJlc3MiLCJzbGljZSIsImdldEFkZHJlc3NGcm9tUHVibGljS2V5IiwicHVibGljS2V5IiwidHlwZSIsImFsZ29yaXRobSIsIm5hbWUiLCJwdWJsaWNLZXlCeXRlcyIsImV4cG9ydEtleSIsImdldFB1YmxpY0tleUZyb21BZGRyZXNzIiwiaW1wb3J0S2V5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/addresses/dist/index.node.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/assertions/dist/index.node.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@solana/assertions/dist/index.node.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertDigestCapabilityIsAvailable: () => (/* binding */ assertDigestCapabilityIsAvailable),\n/* harmony export */   assertKeyExporterIsAvailable: () => (/* binding */ assertKeyExporterIsAvailable),\n/* harmony export */   assertKeyGenerationIsAvailable: () => (/* binding */ assertKeyGenerationIsAvailable),\n/* harmony export */   assertPRNGIsAvailable: () => (/* binding */ assertPRNGIsAvailable),\n/* harmony export */   assertSigningCapabilityIsAvailable: () => (/* binding */ assertSigningCapabilityIsAvailable),\n/* harmony export */   assertVerificationCapabilityIsAvailable: () => (/* binding */ assertVerificationCapabilityIsAvailable)\n/* harmony export */ });\n/* harmony import */ var _solana_errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/errors */ \"(ssr)/./node_modules/@solana/errors/dist/index.node.mjs\");\n\n// src/crypto.ts\nfunction assertPRNGIsAvailable() {\n    if (typeof globalThis.crypto === \"undefined\" || typeof globalThis.crypto.getRandomValues !== \"function\") {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED);\n    }\n}\nvar cachedEd25519Decision;\nasync function isEd25519CurveSupported(subtle) {\n    if (cachedEd25519Decision === void 0) {\n        cachedEd25519Decision = new Promise((resolve)=>{\n            subtle.generateKey(\"Ed25519\", /* extractable */ false, [\n                \"sign\",\n                \"verify\"\n            ]).then(()=>{\n                resolve(cachedEd25519Decision = true);\n            }).catch(()=>{\n                resolve(cachedEd25519Decision = false);\n            });\n        });\n    }\n    if (typeof cachedEd25519Decision === \"boolean\") {\n        return cachedEd25519Decision;\n    } else {\n        return await cachedEd25519Decision;\n    }\n}\nfunction assertDigestCapabilityIsAvailable() {\n    if (typeof globalThis.crypto === \"undefined\" || typeof globalThis.crypto.subtle?.digest !== \"function\") {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED);\n    }\n}\nasync function assertKeyGenerationIsAvailable() {\n    if (typeof globalThis.crypto === \"undefined\" || typeof globalThis.crypto.subtle?.generateKey !== \"function\") {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED);\n    }\n    if (!await isEd25519CurveSupported(globalThis.crypto.subtle)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED);\n    }\n}\nfunction assertKeyExporterIsAvailable() {\n    if (typeof globalThis.crypto === \"undefined\" || typeof globalThis.crypto.subtle?.exportKey !== \"function\") {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED);\n    }\n}\nfunction assertSigningCapabilityIsAvailable() {\n    if (typeof globalThis.crypto === \"undefined\" || typeof globalThis.crypto.subtle?.sign !== \"function\") {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED);\n    }\n}\nfunction assertVerificationCapabilityIsAvailable() {\n    if (typeof globalThis.crypto === \"undefined\" || typeof globalThis.crypto.subtle?.verify !== \"function\") {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED);\n    }\n}\n //# sourceMappingURL=index.node.mjs.map\n //# sourceMappingURL=index.node.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS9hc3NlcnRpb25zL2Rpc3QvaW5kZXgubm9kZS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUEwYztBQUUxYyxnQkFBZ0I7QUFDaEIsU0FBU1E7SUFDUCxJQUFJLE9BQU9DLFdBQVdDLE1BQU0sS0FBSyxlQUFlLE9BQU9ELFdBQVdDLE1BQU0sQ0FBQ0MsZUFBZSxLQUFLLFlBQVk7UUFDdkcsTUFBTSxJQUFJWCx1REFBV0EsQ0FBQ0Msc0dBQTBEQTtJQUNsRjtBQUNGO0FBQ0EsSUFBSVc7QUFDSixlQUFlQyx3QkFBd0JDLE1BQU07SUFDM0MsSUFBSUYsMEJBQTBCLEtBQUssR0FBRztRQUNwQ0Esd0JBQXdCLElBQUlHLFFBQVEsQ0FBQ0M7WUFDbkNGLE9BQU9HLFdBQVcsQ0FDaEIsV0FDQSxlQUFlLEdBQ2YsT0FDQTtnQkFBQztnQkFBUTthQUFTLEVBQ2xCQyxJQUFJLENBQUM7Z0JBQ0xGLFFBQVFKLHdCQUF3QjtZQUNsQyxHQUFHTyxLQUFLLENBQUM7Z0JBQ1BILFFBQVFKLHdCQUF3QjtZQUNsQztRQUNGO0lBQ0Y7SUFDQSxJQUFJLE9BQU9BLDBCQUEwQixXQUFXO1FBQzlDLE9BQU9BO0lBQ1QsT0FBTztRQUNMLE9BQU8sTUFBTUE7SUFDZjtBQUNGO0FBQ0EsU0FBU1E7SUFDUCxJQUFJLE9BQU9YLFdBQVdDLE1BQU0sS0FBSyxlQUFlLE9BQU9ELFdBQVdDLE1BQU0sQ0FBQ0ksTUFBTSxFQUFFTyxXQUFXLFlBQVk7UUFDdEcsTUFBTSxJQUFJckIsdURBQVdBLENBQUNFLDZGQUFpREE7SUFDekU7QUFDRjtBQUNBLGVBQWVvQjtJQUNiLElBQUksT0FBT2IsV0FBV0MsTUFBTSxLQUFLLGVBQWUsT0FBT0QsV0FBV0MsTUFBTSxDQUFDSSxNQUFNLEVBQUVHLGdCQUFnQixZQUFZO1FBQzNHLE1BQU0sSUFBSWpCLHVEQUFXQSxDQUFDRyx3R0FBNERBO0lBQ3BGO0lBQ0EsSUFBSSxDQUFDLE1BQU1VLHdCQUF3QkosV0FBV0MsTUFBTSxDQUFDSSxNQUFNLEdBQUc7UUFDNUQsTUFBTSxJQUFJZCx1REFBV0EsQ0FBQ0ksd0dBQTREQTtJQUNwRjtBQUNGO0FBQ0EsU0FBU21CO0lBQ1AsSUFBSSxPQUFPZCxXQUFXQyxNQUFNLEtBQUssZUFBZSxPQUFPRCxXQUFXQyxNQUFNLENBQUNJLE1BQU0sRUFBRVUsY0FBYyxZQUFZO1FBQ3pHLE1BQU0sSUFBSXhCLHVEQUFXQSxDQUFDSyxzR0FBMERBO0lBQ2xGO0FBQ0Y7QUFDQSxTQUFTb0I7SUFDUCxJQUFJLE9BQU9oQixXQUFXQyxNQUFNLEtBQUssZUFBZSxPQUFPRCxXQUFXQyxNQUFNLENBQUNJLE1BQU0sRUFBRVksU0FBUyxZQUFZO1FBQ3BHLE1BQU0sSUFBSTFCLHVEQUFXQSxDQUFDTSxvR0FBd0RBO0lBQ2hGO0FBQ0Y7QUFDQSxTQUFTcUI7SUFDUCxJQUFJLE9BQU9sQixXQUFXQyxNQUFNLEtBQUssZUFBZSxPQUFPRCxXQUFXQyxNQUFNLENBQUNJLE1BQU0sRUFBRWMsV0FBVyxZQUFZO1FBQ3RHLE1BQU0sSUFBSTVCLHVEQUFXQSxDQUFDTyxzR0FBMERBO0lBQ2xGO0FBQ0Y7QUFFK00sQ0FDL00sdUNBQXVDO0NBQ3ZDLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsYXctd29ya3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS9hc3NlcnRpb25zL2Rpc3QvaW5kZXgubm9kZS5tanM/Y2Y2YyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTb2xhbmFFcnJvciwgU09MQU5BX0VSUk9SX19DUllQVE9fX1JBTkRPTV9WQUxVRVNfRlVOQ1RJT05fVU5JTVBMRU1FTlRFRCwgU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19ESUdFU1RfVU5JTVBMRU1FTlRFRCwgU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19HRU5FUkFURV9GVU5DVElPTl9VTklNUExFTUVOVEVELCBTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX0VEMjU1MTlfQUxHT1JJVEhNX1VOSU1QTEVNRU5URUQsIFNPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fRVhQT1JUX0ZVTkNUSU9OX1VOSU1QTEVNRU5URUQsIFNPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fU0lHTl9GVU5DVElPTl9VTklNUExFTUVOVEVELCBTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX1ZFUklGWV9GVU5DVElPTl9VTklNUExFTUVOVEVEIH0gZnJvbSAnQHNvbGFuYS9lcnJvcnMnO1xuXG4vLyBzcmMvY3J5cHRvLnRzXG5mdW5jdGlvbiBhc3NlcnRQUk5HSXNBdmFpbGFibGUoKSB7XG4gIGlmICh0eXBlb2YgZ2xvYmFsVGhpcy5jcnlwdG8gPT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIGdsb2JhbFRoaXMuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQ1JZUFRPX19SQU5ET01fVkFMVUVTX0ZVTkNUSU9OX1VOSU1QTEVNRU5URUQpO1xuICB9XG59XG52YXIgY2FjaGVkRWQyNTUxOURlY2lzaW9uO1xuYXN5bmMgZnVuY3Rpb24gaXNFZDI1NTE5Q3VydmVTdXBwb3J0ZWQoc3VidGxlKSB7XG4gIGlmIChjYWNoZWRFZDI1NTE5RGVjaXNpb24gPT09IHZvaWQgMCkge1xuICAgIGNhY2hlZEVkMjU1MTlEZWNpc2lvbiA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBzdWJ0bGUuZ2VuZXJhdGVLZXkoXG4gICAgICAgIFwiRWQyNTUxOVwiLFxuICAgICAgICAvKiBleHRyYWN0YWJsZSAqL1xuICAgICAgICBmYWxzZSxcbiAgICAgICAgW1wic2lnblwiLCBcInZlcmlmeVwiXVxuICAgICAgKS50aGVuKCgpID0+IHtcbiAgICAgICAgcmVzb2x2ZShjYWNoZWRFZDI1NTE5RGVjaXNpb24gPSB0cnVlKTtcbiAgICAgIH0pLmNhdGNoKCgpID0+IHtcbiAgICAgICAgcmVzb2x2ZShjYWNoZWRFZDI1NTE5RGVjaXNpb24gPSBmYWxzZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBpZiAodHlwZW9mIGNhY2hlZEVkMjU1MTlEZWNpc2lvbiA9PT0gXCJib29sZWFuXCIpIHtcbiAgICByZXR1cm4gY2FjaGVkRWQyNTUxOURlY2lzaW9uO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhd2FpdCBjYWNoZWRFZDI1NTE5RGVjaXNpb247XG4gIH1cbn1cbmZ1bmN0aW9uIGFzc2VydERpZ2VzdENhcGFiaWxpdHlJc0F2YWlsYWJsZSgpIHtcbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzLmNyeXB0byA9PT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2YgZ2xvYmFsVGhpcy5jcnlwdG8uc3VidGxlPy5kaWdlc3QgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX0RJR0VTVF9VTklNUExFTUVOVEVEKTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gYXNzZXJ0S2V5R2VuZXJhdGlvbklzQXZhaWxhYmxlKCkge1xuICBpZiAodHlwZW9mIGdsb2JhbFRoaXMuY3J5cHRvID09PSBcInVuZGVmaW5lZFwiIHx8IHR5cGVvZiBnbG9iYWxUaGlzLmNyeXB0by5zdWJ0bGU/LmdlbmVyYXRlS2V5ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19HRU5FUkFURV9GVU5DVElPTl9VTklNUExFTUVOVEVEKTtcbiAgfVxuICBpZiAoIWF3YWl0IGlzRWQyNTUxOUN1cnZlU3VwcG9ydGVkKGdsb2JhbFRoaXMuY3J5cHRvLnN1YnRsZSkpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19FRDI1NTE5X0FMR09SSVRITV9VTklNUExFTUVOVEVEKTtcbiAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0S2V5RXhwb3J0ZXJJc0F2YWlsYWJsZSgpIHtcbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzLmNyeXB0byA9PT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2YgZ2xvYmFsVGhpcy5jcnlwdG8uc3VidGxlPy5leHBvcnRLZXkgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX0VYUE9SVF9GVU5DVElPTl9VTklNUExFTUVOVEVEKTtcbiAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0U2lnbmluZ0NhcGFiaWxpdHlJc0F2YWlsYWJsZSgpIHtcbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzLmNyeXB0byA9PT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2YgZ2xvYmFsVGhpcy5jcnlwdG8uc3VidGxlPy5zaWduICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19TSUdOX0ZVTkNUSU9OX1VOSU1QTEVNRU5URUQpO1xuICB9XG59XG5mdW5jdGlvbiBhc3NlcnRWZXJpZmljYXRpb25DYXBhYmlsaXR5SXNBdmFpbGFibGUoKSB7XG4gIGlmICh0eXBlb2YgZ2xvYmFsVGhpcy5jcnlwdG8gPT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIGdsb2JhbFRoaXMuY3J5cHRvLnN1YnRsZT8udmVyaWZ5ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19WRVJJRllfRlVOQ1RJT05fVU5JTVBMRU1FTlRFRCk7XG4gIH1cbn1cblxuZXhwb3J0IHsgYXNzZXJ0RGlnZXN0Q2FwYWJpbGl0eUlzQXZhaWxhYmxlLCBhc3NlcnRLZXlFeHBvcnRlcklzQXZhaWxhYmxlLCBhc3NlcnRLZXlHZW5lcmF0aW9uSXNBdmFpbGFibGUsIGFzc2VydFBSTkdJc0F2YWlsYWJsZSwgYXNzZXJ0U2lnbmluZ0NhcGFiaWxpdHlJc0F2YWlsYWJsZSwgYXNzZXJ0VmVyaWZpY2F0aW9uQ2FwYWJpbGl0eUlzQXZhaWxhYmxlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5ub2RlLm1qcy5tYXBcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm5vZGUubWpzLm1hcCJdLCJuYW1lcyI6WyJTb2xhbmFFcnJvciIsIlNPTEFOQV9FUlJPUl9fQ1JZUFRPX19SQU5ET01fVkFMVUVTX0ZVTkNUSU9OX1VOSU1QTEVNRU5URUQiLCJTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX0RJR0VTVF9VTklNUExFTUVOVEVEIiwiU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19HRU5FUkFURV9GVU5DVElPTl9VTklNUExFTUVOVEVEIiwiU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19FRDI1NTE5X0FMR09SSVRITV9VTklNUExFTUVOVEVEIiwiU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19FWFBPUlRfRlVOQ1RJT05fVU5JTVBMRU1FTlRFRCIsIlNPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fU0lHTl9GVU5DVElPTl9VTklNUExFTUVOVEVEIiwiU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19WRVJJRllfRlVOQ1RJT05fVU5JTVBMRU1FTlRFRCIsImFzc2VydFBSTkdJc0F2YWlsYWJsZSIsImdsb2JhbFRoaXMiLCJjcnlwdG8iLCJnZXRSYW5kb21WYWx1ZXMiLCJjYWNoZWRFZDI1NTE5RGVjaXNpb24iLCJpc0VkMjU1MTlDdXJ2ZVN1cHBvcnRlZCIsInN1YnRsZSIsIlByb21pc2UiLCJyZXNvbHZlIiwiZ2VuZXJhdGVLZXkiLCJ0aGVuIiwiY2F0Y2giLCJhc3NlcnREaWdlc3RDYXBhYmlsaXR5SXNBdmFpbGFibGUiLCJkaWdlc3QiLCJhc3NlcnRLZXlHZW5lcmF0aW9uSXNBdmFpbGFibGUiLCJhc3NlcnRLZXlFeHBvcnRlcklzQXZhaWxhYmxlIiwiZXhwb3J0S2V5IiwiYXNzZXJ0U2lnbmluZ0NhcGFiaWxpdHlJc0F2YWlsYWJsZSIsInNpZ24iLCJhc3NlcnRWZXJpZmljYXRpb25DYXBhYmlsaXR5SXNBdmFpbGFibGUiLCJ2ZXJpZnkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/assertions/dist/index.node.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/codecs-core/dist/index.node.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@solana/codecs-core/dist/index.node.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addCodecSentinel: () => (/* binding */ addCodecSentinel),\n/* harmony export */   addCodecSizePrefix: () => (/* binding */ addCodecSizePrefix),\n/* harmony export */   addDecoderSentinel: () => (/* binding */ addDecoderSentinel),\n/* harmony export */   addDecoderSizePrefix: () => (/* binding */ addDecoderSizePrefix),\n/* harmony export */   addEncoderSentinel: () => (/* binding */ addEncoderSentinel),\n/* harmony export */   addEncoderSizePrefix: () => (/* binding */ addEncoderSizePrefix),\n/* harmony export */   assertByteArrayHasEnoughBytesForCodec: () => (/* binding */ assertByteArrayHasEnoughBytesForCodec),\n/* harmony export */   assertByteArrayIsNotEmptyForCodec: () => (/* binding */ assertByteArrayIsNotEmptyForCodec),\n/* harmony export */   assertByteArrayOffsetIsNotOutOfRange: () => (/* binding */ assertByteArrayOffsetIsNotOutOfRange),\n/* harmony export */   assertIsFixedSize: () => (/* binding */ assertIsFixedSize),\n/* harmony export */   assertIsVariableSize: () => (/* binding */ assertIsVariableSize),\n/* harmony export */   bytesEqual: () => (/* binding */ bytesEqual),\n/* harmony export */   combineCodec: () => (/* binding */ combineCodec),\n/* harmony export */   containsBytes: () => (/* binding */ containsBytes),\n/* harmony export */   createCodec: () => (/* binding */ createCodec),\n/* harmony export */   createDecoder: () => (/* binding */ createDecoder),\n/* harmony export */   createDecoderThatConsumesEntireByteArray: () => (/* binding */ createDecoderThatConsumesEntireByteArray),\n/* harmony export */   createEncoder: () => (/* binding */ createEncoder),\n/* harmony export */   fixBytes: () => (/* binding */ fixBytes),\n/* harmony export */   fixCodecSize: () => (/* binding */ fixCodecSize),\n/* harmony export */   fixDecoderSize: () => (/* binding */ fixDecoderSize),\n/* harmony export */   fixEncoderSize: () => (/* binding */ fixEncoderSize),\n/* harmony export */   getEncodedSize: () => (/* binding */ getEncodedSize),\n/* harmony export */   isFixedSize: () => (/* binding */ isFixedSize),\n/* harmony export */   isVariableSize: () => (/* binding */ isVariableSize),\n/* harmony export */   mergeBytes: () => (/* binding */ mergeBytes),\n/* harmony export */   offsetCodec: () => (/* binding */ offsetCodec),\n/* harmony export */   offsetDecoder: () => (/* binding */ offsetDecoder),\n/* harmony export */   offsetEncoder: () => (/* binding */ offsetEncoder),\n/* harmony export */   padBytes: () => (/* binding */ padBytes),\n/* harmony export */   padLeftCodec: () => (/* binding */ padLeftCodec),\n/* harmony export */   padLeftDecoder: () => (/* binding */ padLeftDecoder),\n/* harmony export */   padLeftEncoder: () => (/* binding */ padLeftEncoder),\n/* harmony export */   padRightCodec: () => (/* binding */ padRightCodec),\n/* harmony export */   padRightDecoder: () => (/* binding */ padRightDecoder),\n/* harmony export */   padRightEncoder: () => (/* binding */ padRightEncoder),\n/* harmony export */   resizeCodec: () => (/* binding */ resizeCodec),\n/* harmony export */   resizeDecoder: () => (/* binding */ resizeDecoder),\n/* harmony export */   resizeEncoder: () => (/* binding */ resizeEncoder),\n/* harmony export */   reverseCodec: () => (/* binding */ reverseCodec),\n/* harmony export */   reverseDecoder: () => (/* binding */ reverseDecoder),\n/* harmony export */   reverseEncoder: () => (/* binding */ reverseEncoder),\n/* harmony export */   toArrayBuffer: () => (/* binding */ toArrayBuffer),\n/* harmony export */   transformCodec: () => (/* binding */ transformCodec),\n/* harmony export */   transformDecoder: () => (/* binding */ transformDecoder),\n/* harmony export */   transformEncoder: () => (/* binding */ transformEncoder)\n/* harmony export */ });\n/* harmony import */ var _solana_errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/errors */ \"(ssr)/./node_modules/@solana/errors/dist/index.node.mjs\");\n\n// src/add-codec-sentinel.ts\n// src/bytes.ts\nvar mergeBytes = (byteArrays)=>{\n    const nonEmptyByteArrays = byteArrays.filter((arr)=>arr.length);\n    if (nonEmptyByteArrays.length === 0) {\n        return byteArrays.length ? byteArrays[0] : new Uint8Array();\n    }\n    if (nonEmptyByteArrays.length === 1) {\n        return nonEmptyByteArrays[0];\n    }\n    const totalLength = nonEmptyByteArrays.reduce((total, arr)=>total + arr.length, 0);\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    nonEmptyByteArrays.forEach((arr)=>{\n        result.set(arr, offset);\n        offset += arr.length;\n    });\n    return result;\n};\nfunction padBytes(bytes, length) {\n    if (bytes.length >= length) return bytes;\n    const paddedBytes = new Uint8Array(length).fill(0);\n    paddedBytes.set(bytes);\n    return paddedBytes;\n}\nvar fixBytes = (bytes, length)=>padBytes(bytes.length <= length ? bytes : bytes.slice(0, length), length);\nfunction containsBytes(data, bytes, offset) {\n    const slice = offset === 0 && data.length === bytes.length ? data : data.slice(offset, offset + bytes.length);\n    return bytesEqual(slice, bytes);\n}\nfunction bytesEqual(bytes1, bytes2) {\n    return bytes1.length === bytes2.length && bytes1.every((value, index)=>value === bytes2[index]);\n}\nfunction getEncodedSize(value, encoder) {\n    return \"fixedSize\" in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);\n}\nfunction createEncoder(encoder) {\n    return Object.freeze({\n        ...encoder,\n        encode: (value)=>{\n            const bytes = new Uint8Array(getEncodedSize(value, encoder));\n            encoder.write(value, bytes, 0);\n            return bytes;\n        }\n    });\n}\nfunction createDecoder(decoder) {\n    return Object.freeze({\n        ...decoder,\n        decode: (bytes, offset = 0)=>decoder.read(bytes, offset)[0]\n    });\n}\nfunction createCodec(codec) {\n    return Object.freeze({\n        ...codec,\n        decode: (bytes, offset = 0)=>codec.read(bytes, offset)[0],\n        encode: (value)=>{\n            const bytes = new Uint8Array(getEncodedSize(value, codec));\n            codec.write(value, bytes, 0);\n            return bytes;\n        }\n    });\n}\nfunction isFixedSize(codec) {\n    return \"fixedSize\" in codec && typeof codec.fixedSize === \"number\";\n}\nfunction assertIsFixedSize(codec) {\n    if (!isFixedSize(codec)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH);\n    }\n}\nfunction isVariableSize(codec) {\n    return !isFixedSize(codec);\n}\nfunction assertIsVariableSize(codec) {\n    if (!isVariableSize(codec)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH);\n    }\n}\nfunction combineCodec(encoder, decoder) {\n    if (isFixedSize(encoder) !== isFixedSize(decoder)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH);\n    }\n    if (isFixedSize(encoder) && isFixedSize(decoder) && encoder.fixedSize !== decoder.fixedSize) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, {\n            decoderFixedSize: decoder.fixedSize,\n            encoderFixedSize: encoder.fixedSize\n        });\n    }\n    if (!isFixedSize(encoder) && !isFixedSize(decoder) && encoder.maxSize !== decoder.maxSize) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, {\n            decoderMaxSize: decoder.maxSize,\n            encoderMaxSize: encoder.maxSize\n        });\n    }\n    return {\n        ...decoder,\n        ...encoder,\n        decode: decoder.decode,\n        encode: encoder.encode,\n        read: decoder.read,\n        write: encoder.write\n    };\n}\n// src/add-codec-sentinel.ts\nfunction addEncoderSentinel(encoder, sentinel) {\n    const write = (value, bytes, offset)=>{\n        const encoderBytes = encoder.encode(value);\n        if (findSentinelIndex(encoderBytes, sentinel) >= 0) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL, {\n                encodedBytes: encoderBytes,\n                hexEncodedBytes: hexBytes(encoderBytes),\n                hexSentinel: hexBytes(sentinel),\n                sentinel\n            });\n        }\n        bytes.set(encoderBytes, offset);\n        offset += encoderBytes.length;\n        bytes.set(sentinel, offset);\n        offset += sentinel.length;\n        return offset;\n    };\n    if (isFixedSize(encoder)) {\n        return createEncoder({\n            ...encoder,\n            fixedSize: encoder.fixedSize + sentinel.length,\n            write\n        });\n    }\n    return createEncoder({\n        ...encoder,\n        ...encoder.maxSize != null ? {\n            maxSize: encoder.maxSize + sentinel.length\n        } : {},\n        getSizeFromValue: (value)=>encoder.getSizeFromValue(value) + sentinel.length,\n        write\n    });\n}\nfunction addDecoderSentinel(decoder, sentinel) {\n    const read = (bytes, offset)=>{\n        const candidateBytes = offset === 0 ? bytes : bytes.slice(offset);\n        const sentinelIndex = findSentinelIndex(candidateBytes, sentinel);\n        if (sentinelIndex === -1) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES, {\n                decodedBytes: candidateBytes,\n                hexDecodedBytes: hexBytes(candidateBytes),\n                hexSentinel: hexBytes(sentinel),\n                sentinel\n            });\n        }\n        const preSentinelBytes = candidateBytes.slice(0, sentinelIndex);\n        return [\n            decoder.decode(preSentinelBytes),\n            offset + preSentinelBytes.length + sentinel.length\n        ];\n    };\n    if (isFixedSize(decoder)) {\n        return createDecoder({\n            ...decoder,\n            fixedSize: decoder.fixedSize + sentinel.length,\n            read\n        });\n    }\n    return createDecoder({\n        ...decoder,\n        ...decoder.maxSize != null ? {\n            maxSize: decoder.maxSize + sentinel.length\n        } : {},\n        read\n    });\n}\nfunction addCodecSentinel(codec, sentinel) {\n    return combineCodec(addEncoderSentinel(codec, sentinel), addDecoderSentinel(codec, sentinel));\n}\nfunction findSentinelIndex(bytes, sentinel) {\n    return bytes.findIndex((byte, index, arr)=>{\n        if (sentinel.length === 1) return byte === sentinel[0];\n        return containsBytes(arr, sentinel, index);\n    });\n}\nfunction hexBytes(bytes) {\n    return bytes.reduce((str, byte)=>str + byte.toString(16).padStart(2, \"0\"), \"\");\n}\nfunction assertByteArrayIsNotEmptyForCodec(codecDescription, bytes, offset = 0) {\n    if (bytes.length - offset <= 0) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, {\n            codecDescription\n        });\n    }\n}\nfunction assertByteArrayHasEnoughBytesForCodec(codecDescription, expected, bytes, offset = 0) {\n    const bytesLength = bytes.length - offset;\n    if (bytesLength < expected) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {\n            bytesLength,\n            codecDescription,\n            expected\n        });\n    }\n}\nfunction assertByteArrayOffsetIsNotOutOfRange(codecDescription, offset, bytesLength) {\n    if (offset < 0 || offset > bytesLength) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE, {\n            bytesLength,\n            codecDescription,\n            offset\n        });\n    }\n}\n// src/add-codec-size-prefix.ts\nfunction addEncoderSizePrefix(encoder, prefix) {\n    const write = (value, bytes, offset)=>{\n        const encoderBytes = encoder.encode(value);\n        offset = prefix.write(encoderBytes.length, bytes, offset);\n        bytes.set(encoderBytes, offset);\n        return offset + encoderBytes.length;\n    };\n    if (isFixedSize(prefix) && isFixedSize(encoder)) {\n        return createEncoder({\n            ...encoder,\n            fixedSize: prefix.fixedSize + encoder.fixedSize,\n            write\n        });\n    }\n    const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : prefix.maxSize ?? null;\n    const encoderMaxSize = isFixedSize(encoder) ? encoder.fixedSize : encoder.maxSize ?? null;\n    const maxSize = prefixMaxSize !== null && encoderMaxSize !== null ? prefixMaxSize + encoderMaxSize : null;\n    return createEncoder({\n        ...encoder,\n        ...maxSize !== null ? {\n            maxSize\n        } : {},\n        getSizeFromValue: (value)=>{\n            const encoderSize = getEncodedSize(value, encoder);\n            return getEncodedSize(encoderSize, prefix) + encoderSize;\n        },\n        write\n    });\n}\nfunction addDecoderSizePrefix(decoder, prefix) {\n    const read = (bytes, offset)=>{\n        const [bigintSize, decoderOffset] = prefix.read(bytes, offset);\n        const size = Number(bigintSize);\n        offset = decoderOffset;\n        if (offset > 0 || bytes.length > size) {\n            bytes = bytes.slice(offset, offset + size);\n        }\n        assertByteArrayHasEnoughBytesForCodec(\"addDecoderSizePrefix\", size, bytes);\n        return [\n            decoder.decode(bytes),\n            offset + size\n        ];\n    };\n    if (isFixedSize(prefix) && isFixedSize(decoder)) {\n        return createDecoder({\n            ...decoder,\n            fixedSize: prefix.fixedSize + decoder.fixedSize,\n            read\n        });\n    }\n    const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : prefix.maxSize ?? null;\n    const decoderMaxSize = isFixedSize(decoder) ? decoder.fixedSize : decoder.maxSize ?? null;\n    const maxSize = prefixMaxSize !== null && decoderMaxSize !== null ? prefixMaxSize + decoderMaxSize : null;\n    return createDecoder({\n        ...decoder,\n        ...maxSize !== null ? {\n            maxSize\n        } : {},\n        read\n    });\n}\nfunction addCodecSizePrefix(codec, prefix) {\n    return combineCodec(addEncoderSizePrefix(codec, prefix), addDecoderSizePrefix(codec, prefix));\n}\n// src/array-buffers.ts\nfunction toArrayBuffer(bytes, offset, length) {\n    const bytesOffset = bytes.byteOffset + (offset ?? 0);\n    const bytesLength = length ?? bytes.byteLength;\n    let buffer;\n    if (typeof SharedArrayBuffer === \"undefined\") {\n        buffer = bytes.buffer;\n    } else if (bytes.buffer instanceof SharedArrayBuffer) {\n        buffer = new ArrayBuffer(bytes.length);\n        new Uint8Array(buffer).set(new Uint8Array(bytes));\n    } else {\n        buffer = bytes.buffer;\n    }\n    return (bytesOffset === 0 || bytesOffset === -bytes.byteLength) && bytesLength === bytes.byteLength ? buffer : buffer.slice(bytesOffset, bytesOffset + bytesLength);\n}\nfunction createDecoderThatConsumesEntireByteArray(decoder) {\n    return createDecoder({\n        ...decoder,\n        read (bytes, offset) {\n            const [value, newOffset] = decoder.read(bytes, offset);\n            if (bytes.length > newOffset) {\n                throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY, {\n                    expectedLength: newOffset,\n                    numExcessBytes: bytes.length - newOffset\n                });\n            }\n            return [\n                value,\n                newOffset\n            ];\n        }\n    });\n}\n// src/fix-codec-size.ts\nfunction fixEncoderSize(encoder, fixedBytes) {\n    return createEncoder({\n        fixedSize: fixedBytes,\n        write: (value, bytes, offset)=>{\n            const variableByteArray = encoder.encode(value);\n            const fixedByteArray = variableByteArray.length > fixedBytes ? variableByteArray.slice(0, fixedBytes) : variableByteArray;\n            bytes.set(fixedByteArray, offset);\n            return offset + fixedBytes;\n        }\n    });\n}\nfunction fixDecoderSize(decoder, fixedBytes) {\n    return createDecoder({\n        fixedSize: fixedBytes,\n        read: (bytes, offset)=>{\n            assertByteArrayHasEnoughBytesForCodec(\"fixCodecSize\", fixedBytes, bytes, offset);\n            if (offset > 0 || bytes.length > fixedBytes) {\n                bytes = bytes.slice(offset, offset + fixedBytes);\n            }\n            if (isFixedSize(decoder)) {\n                bytes = fixBytes(bytes, decoder.fixedSize);\n            }\n            const [value] = decoder.read(bytes, 0);\n            return [\n                value,\n                offset + fixedBytes\n            ];\n        }\n    });\n}\nfunction fixCodecSize(codec, fixedBytes) {\n    return combineCodec(fixEncoderSize(codec, fixedBytes), fixDecoderSize(codec, fixedBytes));\n}\n// src/offset-codec.ts\nfunction offsetEncoder(encoder, config) {\n    return createEncoder({\n        ...encoder,\n        write: (value, bytes, preOffset)=>{\n            const wrapBytes = (offset)=>modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({\n                bytes,\n                preOffset,\n                wrapBytes\n            }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange(\"offsetEncoder\", newPreOffset, bytes.length);\n            const postOffset = encoder.write(value, bytes, newPreOffset);\n            const newPostOffset = config.postOffset ? config.postOffset({\n                bytes,\n                newPreOffset,\n                postOffset,\n                preOffset,\n                wrapBytes\n            }) : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange(\"offsetEncoder\", newPostOffset, bytes.length);\n            return newPostOffset;\n        }\n    });\n}\nfunction offsetDecoder(decoder, config) {\n    return createDecoder({\n        ...decoder,\n        read: (bytes, preOffset)=>{\n            const wrapBytes = (offset)=>modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({\n                bytes,\n                preOffset,\n                wrapBytes\n            }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange(\"offsetDecoder\", newPreOffset, bytes.length);\n            const [value, postOffset] = decoder.read(bytes, newPreOffset);\n            const newPostOffset = config.postOffset ? config.postOffset({\n                bytes,\n                newPreOffset,\n                postOffset,\n                preOffset,\n                wrapBytes\n            }) : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange(\"offsetDecoder\", newPostOffset, bytes.length);\n            return [\n                value,\n                newPostOffset\n            ];\n        }\n    });\n}\nfunction offsetCodec(codec, config) {\n    return combineCodec(offsetEncoder(codec, config), offsetDecoder(codec, config));\n}\nfunction modulo(dividend, divisor) {\n    if (divisor === 0) return 0;\n    return (dividend % divisor + divisor) % divisor;\n}\nfunction resizeEncoder(encoder, resize) {\n    if (isFixedSize(encoder)) {\n        const fixedSize = resize(encoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: \"resizeEncoder\"\n            });\n        }\n        return createEncoder({\n            ...encoder,\n            fixedSize\n        });\n    }\n    return createEncoder({\n        ...encoder,\n        getSizeFromValue: (value)=>{\n            const newSize = resize(encoder.getSizeFromValue(value));\n            if (newSize < 0) {\n                throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                    bytesLength: newSize,\n                    codecDescription: \"resizeEncoder\"\n                });\n            }\n            return newSize;\n        }\n    });\n}\nfunction resizeDecoder(decoder, resize) {\n    if (isFixedSize(decoder)) {\n        const fixedSize = resize(decoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: \"resizeDecoder\"\n            });\n        }\n        return createDecoder({\n            ...decoder,\n            fixedSize\n        });\n    }\n    return decoder;\n}\nfunction resizeCodec(codec, resize) {\n    return combineCodec(resizeEncoder(codec, resize), resizeDecoder(codec, resize));\n}\n// src/pad-codec.ts\nfunction padLeftEncoder(encoder, offset) {\n    return offsetEncoder(resizeEncoder(encoder, (size)=>size + offset), {\n        preOffset: ({ preOffset })=>preOffset + offset\n    });\n}\nfunction padRightEncoder(encoder, offset) {\n    return offsetEncoder(resizeEncoder(encoder, (size)=>size + offset), {\n        postOffset: ({ postOffset })=>postOffset + offset\n    });\n}\nfunction padLeftDecoder(decoder, offset) {\n    return offsetDecoder(resizeDecoder(decoder, (size)=>size + offset), {\n        preOffset: ({ preOffset })=>preOffset + offset\n    });\n}\nfunction padRightDecoder(decoder, offset) {\n    return offsetDecoder(resizeDecoder(decoder, (size)=>size + offset), {\n        postOffset: ({ postOffset })=>postOffset + offset\n    });\n}\nfunction padLeftCodec(codec, offset) {\n    return combineCodec(padLeftEncoder(codec, offset), padLeftDecoder(codec, offset));\n}\nfunction padRightCodec(codec, offset) {\n    return combineCodec(padRightEncoder(codec, offset), padRightDecoder(codec, offset));\n}\n// src/reverse-codec.ts\nfunction copySourceToTargetInReverse(source, target_WILL_MUTATE, sourceOffset, sourceLength, targetOffset = 0) {\n    while(sourceOffset < --sourceLength){\n        const leftValue = source[sourceOffset];\n        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceLength];\n        target_WILL_MUTATE[sourceLength + targetOffset] = leftValue;\n        sourceOffset++;\n    }\n    if (sourceOffset === sourceLength) {\n        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceOffset];\n    }\n}\nfunction reverseEncoder(encoder) {\n    assertIsFixedSize(encoder);\n    return createEncoder({\n        ...encoder,\n        write: (value, bytes, offset)=>{\n            const newOffset = encoder.write(value, bytes, offset);\n            copySourceToTargetInReverse(bytes, bytes, offset, offset + encoder.fixedSize);\n            return newOffset;\n        }\n    });\n}\nfunction reverseDecoder(decoder) {\n    assertIsFixedSize(decoder);\n    return createDecoder({\n        ...decoder,\n        read: (bytes, offset)=>{\n            const reversedBytes = bytes.slice();\n            copySourceToTargetInReverse(bytes, reversedBytes, offset, offset + decoder.fixedSize);\n            return decoder.read(reversedBytes, offset);\n        }\n    });\n}\nfunction reverseCodec(codec) {\n    return combineCodec(reverseEncoder(codec), reverseDecoder(codec));\n}\n// src/transform-codec.ts\nfunction transformEncoder(encoder, unmap) {\n    return createEncoder({\n        ...isVariableSize(encoder) ? {\n            ...encoder,\n            getSizeFromValue: (value)=>encoder.getSizeFromValue(unmap(value))\n        } : encoder,\n        write: (value, bytes, offset)=>encoder.write(unmap(value), bytes, offset)\n    });\n}\nfunction transformDecoder(decoder, map) {\n    return createDecoder({\n        ...decoder,\n        read: (bytes, offset)=>{\n            const [value, newOffset] = decoder.read(bytes, offset);\n            return [\n                map(value, bytes, offset),\n                newOffset\n            ];\n        }\n    });\n}\nfunction transformCodec(codec, unmap, map) {\n    return createCodec({\n        ...transformEncoder(codec, unmap),\n        read: map ? transformDecoder(codec, map).read : codec.read\n    });\n}\n //# sourceMappingURL=index.node.mjs.map\n //# sourceMappingURL=index.node.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS9jb2RlY3MtY29yZS9kaXN0L2luZGV4Lm5vZGUubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStyQjtBQUUvckIsNEJBQTRCO0FBRTVCLGVBQWU7QUFDZixJQUFJYSxhQUFhLENBQUNDO0lBQ2hCLE1BQU1DLHFCQUFxQkQsV0FBV0UsTUFBTSxDQUFDLENBQUNDLE1BQVFBLElBQUlDLE1BQU07SUFDaEUsSUFBSUgsbUJBQW1CRyxNQUFNLEtBQUssR0FBRztRQUNuQyxPQUFPSixXQUFXSSxNQUFNLEdBQUdKLFVBQVUsQ0FBQyxFQUFFLEdBQUcsSUFBSUs7SUFDakQ7SUFDQSxJQUFJSixtQkFBbUJHLE1BQU0sS0FBSyxHQUFHO1FBQ25DLE9BQU9ILGtCQUFrQixDQUFDLEVBQUU7SUFDOUI7SUFDQSxNQUFNSyxjQUFjTCxtQkFBbUJNLE1BQU0sQ0FBQyxDQUFDQyxPQUFPTCxNQUFRSyxRQUFRTCxJQUFJQyxNQUFNLEVBQUU7SUFDbEYsTUFBTUssU0FBUyxJQUFJSixXQUFXQztJQUM5QixJQUFJSSxTQUFTO0lBQ2JULG1CQUFtQlUsT0FBTyxDQUFDLENBQUNSO1FBQzFCTSxPQUFPRyxHQUFHLENBQUNULEtBQUtPO1FBQ2hCQSxVQUFVUCxJQUFJQyxNQUFNO0lBQ3RCO0lBQ0EsT0FBT0s7QUFDVDtBQUNBLFNBQVNJLFNBQVNDLEtBQUssRUFBRVYsTUFBTTtJQUM3QixJQUFJVSxNQUFNVixNQUFNLElBQUlBLFFBQVEsT0FBT1U7SUFDbkMsTUFBTUMsY0FBYyxJQUFJVixXQUFXRCxRQUFRWSxJQUFJLENBQUM7SUFDaERELFlBQVlILEdBQUcsQ0FBQ0U7SUFDaEIsT0FBT0M7QUFDVDtBQUNBLElBQUlFLFdBQVcsQ0FBQ0gsT0FBT1YsU0FBV1MsU0FBU0MsTUFBTVYsTUFBTSxJQUFJQSxTQUFTVSxRQUFRQSxNQUFNSSxLQUFLLENBQUMsR0FBR2Qs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a0IsUUFBUU8sS0FBSyxDQUFDeUcsTUFBTW5ILFFBQVFYLE9BQU9KO0lBQ3RFO0FBQ0Y7QUFDQSxTQUFTbUksaUJBQWlCeEcsT0FBTyxFQUFFeUcsR0FBRztJQUNwQyxPQUFPMUcsY0FBYztRQUNuQixHQUFHQyxPQUFPO1FBQ1ZFLE1BQU0sQ0FBQ3pCLE9BQU9KO1lBQ1osTUFBTSxDQUFDZSxPQUFPdUUsVUFBVSxHQUFHM0QsUUFBUUUsSUFBSSxDQUFDekIsT0FBT0o7WUFDL0MsT0FBTztnQkFBQ29JLElBQUlySCxPQUFPWCxPQUFPSjtnQkFBU3NGO2FBQVU7UUFDL0M7SUFDRjtBQUNGO0FBQ0EsU0FBUytDLGVBQWV0RyxLQUFLLEVBQUVtRyxLQUFLLEVBQUVFLEdBQUc7SUFDdkMsT0FBT3RHLFlBQVk7UUFDakIsR0FBR21HLGlCQUFpQmxHLE9BQU9tRyxNQUFNO1FBQ2pDckcsTUFBTXVHLE1BQU1ELGlCQUFpQnBHLE9BQU9xRyxLQUFLdkcsSUFBSSxHQUFHRSxNQUFNRixJQUFJO0lBQzVEO0FBQ0Y7QUFFNHpCLENBQzV6Qix1Q0FBdUM7Q0FDdkMsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xhdy13b3Jrcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL2NvZGVjcy1jb3JlL2Rpc3QvaW5kZXgubm9kZS5tanM/NTRkOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTb2xhbmFFcnJvciwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX0ZJWEVEX0xFTkdUSCwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX1ZBUklBQkxFX0xFTkdUSCwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9TSVpFX0NPTVBBVElCSUxJVFlfTUlTTUFUQ0gsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfRklYRURfU0laRV9NSVNNQVRDSCwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9NQVhfU0laRV9NSVNNQVRDSCwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0NBTk5PVF9ERUNPREVfRU1QVFlfQllURV9BUlJBWSwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfQllURV9MRU5HVEgsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19PRkZTRVRfT1VUX09GX1JBTkdFLCBTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfREVDT0RFUl9UT19DT05TVU1FX0VOVElSRV9CWVRFX0FSUkFZLCBTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfUE9TSVRJVkVfQllURV9MRU5HVEgsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19TRU5USU5FTF9NSVNTSU5HX0lOX0RFQ09ERURfQllURVMsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVEX0JZVEVTX01VU1RfTk9UX0lOQ0xVREVfU0VOVElORUwgfSBmcm9tICdAc29sYW5hL2Vycm9ycyc7XG5cbi8vIHNyYy9hZGQtY29kZWMtc2VudGluZWwudHNcblxuLy8gc3JjL2J5dGVzLnRzXG52YXIgbWVyZ2VCeXRlcyA9IChieXRlQXJyYXlzKSA9PiB7XG4gIGNvbnN0IG5vbkVtcHR5Qnl0ZUFycmF5cyA9IGJ5dGVBcnJheXMuZmlsdGVyKChhcnIpID0+IGFyci5sZW5ndGgpO1xuICBpZiAobm9uRW1wdHlCeXRlQXJyYXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBieXRlQXJyYXlzLmxlbmd0aCA/IGJ5dGVBcnJheXNbMF0gOiBuZXcgVWludDhBcnJheSgpO1xuICB9XG4gIGlmIChub25FbXB0eUJ5dGVBcnJheXMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIG5vbkVtcHR5Qnl0ZUFycmF5c1swXTtcbiAgfVxuICBjb25zdCB0b3RhbExlbmd0aCA9IG5vbkVtcHR5Qnl0ZUFycmF5cy5yZWR1Y2UoKHRvdGFsLCBhcnIpID0+IHRvdGFsICsgYXJyLmxlbmd0aCwgMCk7XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KHRvdGFsTGVuZ3RoKTtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIG5vbkVtcHR5Qnl0ZUFycmF5cy5mb3JFYWNoKChhcnIpID0+IHtcbiAgICByZXN1bHQuc2V0KGFyciwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gYXJyLmxlbmd0aDtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuZnVuY3Rpb24gcGFkQnl0ZXMoYnl0ZXMsIGxlbmd0aCkge1xuICBpZiAoYnl0ZXMubGVuZ3RoID49IGxlbmd0aCkgcmV0dXJuIGJ5dGVzO1xuICBjb25zdCBwYWRkZWRCeXRlcyA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCkuZmlsbCgwKTtcbiAgcGFkZGVkQnl0ZXMuc2V0KGJ5dGVzKTtcbiAgcmV0dXJuIHBhZGRlZEJ5dGVzO1xufVxudmFyIGZpeEJ5dGVzID0gKGJ5dGVzLCBsZW5ndGgpID0+IHBhZEJ5dGVzKGJ5dGVzLmxlbmd0aCA8PSBsZW5ndGggPyBieXRlcyA6IGJ5dGVzLnNsaWNlKDAsIGxlbmd0aCksIGxlbmd0aCk7XG5mdW5jdGlvbiBjb250YWluc0J5dGVzKGRhdGEsIGJ5dGVzLCBvZmZzZXQpIHtcbiAgY29uc3Qgc2xpY2UgPSBvZmZzZXQgPT09IDAgJiYgZGF0YS5sZW5ndGggPT09IGJ5dGVzLmxlbmd0aCA/IGRhdGEgOiBkYXRhLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgYnl0ZXMubGVuZ3RoKTtcbiAgcmV0dXJuIGJ5dGVzRXF1YWwoc2xpY2UsIGJ5dGVzKTtcbn1cbmZ1bmN0aW9uIGJ5dGVzRXF1YWwoYnl0ZXMxLCBieXRlczIpIHtcbiAgcmV0dXJuIGJ5dGVzMS5sZW5ndGggPT09IGJ5dGVzMi5sZW5ndGggJiYgYnl0ZXMxLmV2ZXJ5KCh2YWx1ZSwgaW5kZXgpID0+IHZhbHVlID09PSBieXRlczJbaW5kZXhdKTtcbn1cbmZ1bmN0aW9uIGdldEVuY29kZWRTaXplKHZhbHVlLCBlbmNvZGVyKSB7XG4gIHJldHVybiBcImZpeGVkU2l6ZVwiIGluIGVuY29kZXIgPyBlbmNvZGVyLmZpeGVkU2l6ZSA6IGVuY29kZXIuZ2V0U2l6ZUZyb21WYWx1ZSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVFbmNvZGVyKGVuY29kZXIpIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgIC4uLmVuY29kZXIsXG4gICAgZW5jb2RlOiAodmFsdWUpID0+IHtcbiAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoZ2V0RW5jb2RlZFNpemUodmFsdWUsIGVuY29kZXIpKTtcbiAgICAgIGVuY29kZXIud3JpdGUodmFsdWUsIGJ5dGVzLCAwKTtcbiAgICAgIHJldHVybiBieXRlcztcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlRGVjb2RlcihkZWNvZGVyKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAuLi5kZWNvZGVyLFxuICAgIGRlY29kZTogKGJ5dGVzLCBvZmZzZXQgPSAwKSA9PiBkZWNvZGVyLnJlYWQoYnl0ZXMsIG9mZnNldClbMF1cbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVDb2RlYyhjb2RlYykge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgLi4uY29kZWMsXG4gICAgZGVjb2RlOiAoYnl0ZXMsIG9mZnNldCA9IDApID0+IGNvZGVjLnJlYWQoYnl0ZXMsIG9mZnNldClbMF0sXG4gICAgZW5jb2RlOiAodmFsdWUpID0+IHtcbiAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoZ2V0RW5jb2RlZFNpemUodmFsdWUsIGNvZGVjKSk7XG4gICAgICBjb2RlYy53cml0ZSh2YWx1ZSwgYnl0ZXMsIDApO1xuICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBpc0ZpeGVkU2l6ZShjb2RlYykge1xuICByZXR1cm4gXCJmaXhlZFNpemVcIiBpbiBjb2RlYyAmJiB0eXBlb2YgY29kZWMuZml4ZWRTaXplID09PSBcIm51bWJlclwiO1xufVxuZnVuY3Rpb24gYXNzZXJ0SXNGaXhlZFNpemUoY29kZWMpIHtcbiAgaWYgKCFpc0ZpeGVkU2l6ZShjb2RlYykpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX0ZJWEVEX0xFTkdUSCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzVmFyaWFibGVTaXplKGNvZGVjKSB7XG4gIHJldHVybiAhaXNGaXhlZFNpemUoY29kZWMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0SXNWYXJpYWJsZVNpemUoY29kZWMpIHtcbiAgaWYgKCFpc1ZhcmlhYmxlU2l6ZShjb2RlYykpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX1ZBUklBQkxFX0xFTkdUSCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbWJpbmVDb2RlYyhlbmNvZGVyLCBkZWNvZGVyKSB7XG4gIGlmIChpc0ZpeGVkU2l6ZShlbmNvZGVyKSAhPT0gaXNGaXhlZFNpemUoZGVjb2RlcikpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9TSVpFX0NPTVBBVElCSUxJVFlfTUlTTUFUQ0gpO1xuICB9XG4gIGlmIChpc0ZpeGVkU2l6ZShlbmNvZGVyKSAmJiBpc0ZpeGVkU2l6ZShkZWNvZGVyKSAmJiBlbmNvZGVyLmZpeGVkU2l6ZSAhPT0gZGVjb2Rlci5maXhlZFNpemUpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9GSVhFRF9TSVpFX01JU01BVENILCB7XG4gICAgICBkZWNvZGVyRml4ZWRTaXplOiBkZWNvZGVyLmZpeGVkU2l6ZSxcbiAgICAgIGVuY29kZXJGaXhlZFNpemU6IGVuY29kZXIuZml4ZWRTaXplXG4gICAgfSk7XG4gIH1cbiAgaWYgKCFpc0ZpeGVkU2l6ZShlbmNvZGVyKSAmJiAhaXNGaXhlZFNpemUoZGVjb2RlcikgJiYgZW5jb2Rlci5tYXhTaXplICE9PSBkZWNvZGVyLm1heFNpemUpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9NQVhfU0laRV9NSVNNQVRDSCwge1xuICAgICAgZGVjb2Rlck1heFNpemU6IGRlY29kZXIubWF4U2l6ZSxcbiAgICAgIGVuY29kZXJNYXhTaXplOiBlbmNvZGVyLm1heFNpemVcbiAgICB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLmRlY29kZXIsXG4gICAgLi4uZW5jb2RlcixcbiAgICBkZWNvZGU6IGRlY29kZXIuZGVjb2RlLFxuICAgIGVuY29kZTogZW5jb2Rlci5lbmNvZGUsXG4gICAgcmVhZDogZGVjb2Rlci5yZWFkLFxuICAgIHdyaXRlOiBlbmNvZGVyLndyaXRlXG4gIH07XG59XG5cbi8vIHNyYy9hZGQtY29kZWMtc2VudGluZWwudHNcbmZ1bmN0aW9uIGFkZEVuY29kZXJTZW50aW5lbChlbmNvZGVyLCBzZW50aW5lbCkge1xuICBjb25zdCB3cml0ZSA9ICgodmFsdWUsIGJ5dGVzLCBvZmZzZXQpID0+IHtcbiAgICBjb25zdCBlbmNvZGVyQnl0ZXMgPSBlbmNvZGVyLmVuY29kZSh2YWx1ZSk7XG4gICAgaWYgKGZpbmRTZW50aW5lbEluZGV4KGVuY29kZXJCeXRlcywgc2VudGluZWwpID49IDApIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFRF9CWVRFU19NVVNUX05PVF9JTkNMVURFX1NFTlRJTkVMLCB7XG4gICAgICAgIGVuY29kZWRCeXRlczogZW5jb2RlckJ5dGVzLFxuICAgICAgICBoZXhFbmNvZGVkQnl0ZXM6IGhleEJ5dGVzKGVuY29kZXJCeXRlcyksXG4gICAgICAgIGhleFNlbnRpbmVsOiBoZXhCeXRlcyhzZW50aW5lbCksXG4gICAgICAgIHNlbnRpbmVsXG4gICAgICB9KTtcbiAgICB9XG4gICAgYnl0ZXMuc2V0KGVuY29kZXJCeXRlcywgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gZW5jb2RlckJ5dGVzLmxlbmd0aDtcbiAgICBieXRlcy5zZXQoc2VudGluZWwsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IHNlbnRpbmVsLmxlbmd0aDtcbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9KTtcbiAgaWYgKGlzRml4ZWRTaXplKGVuY29kZXIpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVuY29kZXIoeyAuLi5lbmNvZGVyLCBmaXhlZFNpemU6IGVuY29kZXIuZml4ZWRTaXplICsgc2VudGluZWwubGVuZ3RoLCB3cml0ZSB9KTtcbiAgfVxuICByZXR1cm4gY3JlYXRlRW5jb2Rlcih7XG4gICAgLi4uZW5jb2RlcixcbiAgICAuLi5lbmNvZGVyLm1heFNpemUgIT0gbnVsbCA/IHsgbWF4U2l6ZTogZW5jb2Rlci5tYXhTaXplICsgc2VudGluZWwubGVuZ3RoIH0gOiB7fSxcbiAgICBnZXRTaXplRnJvbVZhbHVlOiAodmFsdWUpID0+IGVuY29kZXIuZ2V0U2l6ZUZyb21WYWx1ZSh2YWx1ZSkgKyBzZW50aW5lbC5sZW5ndGgsXG4gICAgd3JpdGVcbiAgfSk7XG59XG5mdW5jdGlvbiBhZGREZWNvZGVyU2VudGluZWwoZGVjb2Rlciwgc2VudGluZWwpIHtcbiAgY29uc3QgcmVhZCA9ICgoYnl0ZXMsIG9mZnNldCkgPT4ge1xuICAgIGNvbnN0IGNhbmRpZGF0ZUJ5dGVzID0gb2Zmc2V0ID09PSAwID8gYnl0ZXMgOiBieXRlcy5zbGljZShvZmZzZXQpO1xuICAgIGNvbnN0IHNlbnRpbmVsSW5kZXggPSBmaW5kU2VudGluZWxJbmRleChjYW5kaWRhdGVCeXRlcywgc2VudGluZWwpO1xuICAgIGlmIChzZW50aW5lbEluZGV4ID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQ09ERUNTX19TRU5USU5FTF9NSVNTSU5HX0lOX0RFQ09ERURfQllURVMsIHtcbiAgICAgICAgZGVjb2RlZEJ5dGVzOiBjYW5kaWRhdGVCeXRlcyxcbiAgICAgICAgaGV4RGVjb2RlZEJ5dGVzOiBoZXhCeXRlcyhjYW5kaWRhdGVCeXRlcyksXG4gICAgICAgIGhleFNlbnRpbmVsOiBoZXhCeXRlcyhzZW50aW5lbCksXG4gICAgICAgIHNlbnRpbmVsXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgcHJlU2VudGluZWxCeXRlcyA9IGNhbmRpZGF0ZUJ5dGVzLnNsaWNlKDAsIHNlbnRpbmVsSW5kZXgpO1xuICAgIHJldHVybiBbZGVjb2Rlci5kZWNvZGUocHJlU2VudGluZWxCeXRlcyksIG9mZnNldCArIHByZVNlbnRpbmVsQnl0ZXMubGVuZ3RoICsgc2VudGluZWwubGVuZ3RoXTtcbiAgfSk7XG4gIGlmIChpc0ZpeGVkU2l6ZShkZWNvZGVyKSkge1xuICAgIHJldHVybiBjcmVhdGVEZWNvZGVyKHsgLi4uZGVjb2RlciwgZml4ZWRTaXplOiBkZWNvZGVyLmZpeGVkU2l6ZSArIHNlbnRpbmVsLmxlbmd0aCwgcmVhZCB9KTtcbiAgfVxuICByZXR1cm4gY3JlYXRlRGVjb2Rlcih7XG4gICAgLi4uZGVjb2RlcixcbiAgICAuLi5kZWNvZGVyLm1heFNpemUgIT0gbnVsbCA/IHsgbWF4U2l6ZTogZGVjb2Rlci5tYXhTaXplICsgc2VudGluZWwubGVuZ3RoIH0gOiB7fSxcbiAgICByZWFkXG4gIH0pO1xufVxuZnVuY3Rpb24gYWRkQ29kZWNTZW50aW5lbChjb2RlYywgc2VudGluZWwpIHtcbiAgcmV0dXJuIGNvbWJpbmVDb2RlYyhhZGRFbmNvZGVyU2VudGluZWwoY29kZWMsIHNlbnRpbmVsKSwgYWRkRGVjb2RlclNlbnRpbmVsKGNvZGVjLCBzZW50aW5lbCkpO1xufVxuZnVuY3Rpb24gZmluZFNlbnRpbmVsSW5kZXgoYnl0ZXMsIHNlbnRpbmVsKSB7XG4gIHJldHVybiBieXRlcy5maW5kSW5kZXgoKGJ5dGUsIGluZGV4LCBhcnIpID0+IHtcbiAgICBpZiAoc2VudGluZWwubGVuZ3RoID09PSAxKSByZXR1cm4gYnl0ZSA9PT0gc2VudGluZWxbMF07XG4gICAgcmV0dXJuIGNvbnRhaW5zQnl0ZXMoYXJyLCBzZW50aW5lbCwgaW5kZXgpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGhleEJ5dGVzKGJ5dGVzKSB7XG4gIHJldHVybiBieXRlcy5yZWR1Y2UoKHN0ciwgYnl0ZSkgPT4gc3RyICsgYnl0ZS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpLCBcIlwiKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEJ5dGVBcnJheUlzTm90RW1wdHlGb3JDb2RlYyhjb2RlY0Rlc2NyaXB0aW9uLCBieXRlcywgb2Zmc2V0ID0gMCkge1xuICBpZiAoYnl0ZXMubGVuZ3RoIC0gb2Zmc2V0IDw9IDApIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX0NBTk5PVF9ERUNPREVfRU1QVFlfQllURV9BUlJBWSwge1xuICAgICAgY29kZWNEZXNjcmlwdGlvblxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBhc3NlcnRCeXRlQXJyYXlIYXNFbm91Z2hCeXRlc0ZvckNvZGVjKGNvZGVjRGVzY3JpcHRpb24sIGV4cGVjdGVkLCBieXRlcywgb2Zmc2V0ID0gMCkge1xuICBjb25zdCBieXRlc0xlbmd0aCA9IGJ5dGVzLmxlbmd0aCAtIG9mZnNldDtcbiAgaWYgKGJ5dGVzTGVuZ3RoIDwgZXhwZWN0ZWQpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfQllURV9MRU5HVEgsIHtcbiAgICAgIGJ5dGVzTGVuZ3RoLFxuICAgICAgY29kZWNEZXNjcmlwdGlvbixcbiAgICAgIGV4cGVjdGVkXG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGFzc2VydEJ5dGVBcnJheU9mZnNldElzTm90T3V0T2ZSYW5nZShjb2RlY0Rlc2NyaXB0aW9uLCBvZmZzZXQsIGJ5dGVzTGVuZ3RoKSB7XG4gIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCA+IGJ5dGVzTGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQ09ERUNTX19PRkZTRVRfT1VUX09GX1JBTkdFLCB7XG4gICAgICBieXRlc0xlbmd0aCxcbiAgICAgIGNvZGVjRGVzY3JpcHRpb24sXG4gICAgICBvZmZzZXRcbiAgICB9KTtcbiAgfVxufVxuXG4vLyBzcmMvYWRkLWNvZGVjLXNpemUtcHJlZml4LnRzXG5mdW5jdGlvbiBhZGRFbmNvZGVyU2l6ZVByZWZpeChlbmNvZGVyLCBwcmVmaXgpIHtcbiAgY29uc3Qgd3JpdGUgPSAoKHZhbHVlLCBieXRlcywgb2Zmc2V0KSA9PiB7XG4gICAgY29uc3QgZW5jb2RlckJ5dGVzID0gZW5jb2Rlci5lbmNvZGUodmFsdWUpO1xuICAgIG9mZnNldCA9IHByZWZpeC53cml0ZShlbmNvZGVyQnl0ZXMubGVuZ3RoLCBieXRlcywgb2Zmc2V0KTtcbiAgICBieXRlcy5zZXQoZW5jb2RlckJ5dGVzLCBvZmZzZXQpO1xuICAgIHJldHVybiBvZmZzZXQgKyBlbmNvZGVyQnl0ZXMubGVuZ3RoO1xuICB9KTtcbiAgaWYgKGlzRml4ZWRTaXplKHByZWZpeCkgJiYgaXNGaXhlZFNpemUoZW5jb2RlcikpIHtcbiAgICByZXR1cm4gY3JlYXRlRW5jb2Rlcih7IC4uLmVuY29kZXIsIGZpeGVkU2l6ZTogcHJlZml4LmZpeGVkU2l6ZSArIGVuY29kZXIuZml4ZWRTaXplLCB3cml0ZSB9KTtcbiAgfVxuICBjb25zdCBwcmVmaXhNYXhTaXplID0gaXNGaXhlZFNpemUocHJlZml4KSA/IHByZWZpeC5maXhlZFNpemUgOiBwcmVmaXgubWF4U2l6ZSA/PyBudWxsO1xuICBjb25zdCBlbmNvZGVyTWF4U2l6ZSA9IGlzRml4ZWRTaXplKGVuY29kZXIpID8gZW5jb2Rlci5maXhlZFNpemUgOiBlbmNvZGVyLm1heFNpemUgPz8gbnVsbDtcbiAgY29uc3QgbWF4U2l6ZSA9IHByZWZpeE1heFNpemUgIT09IG51bGwgJiYgZW5jb2Rlck1heFNpemUgIT09IG51bGwgPyBwcmVmaXhNYXhTaXplICsgZW5jb2Rlck1heFNpemUgOiBudWxsO1xuICByZXR1cm4gY3JlYXRlRW5jb2Rlcih7XG4gICAgLi4uZW5jb2RlcixcbiAgICAuLi5tYXhTaXplICE9PSBudWxsID8geyBtYXhTaXplIH0gOiB7fSxcbiAgICBnZXRTaXplRnJvbVZhbHVlOiAodmFsdWUpID0+IHtcbiAgICAgIGNvbnN0IGVuY29kZXJTaXplID0gZ2V0RW5jb2RlZFNpemUodmFsdWUsIGVuY29kZXIpO1xuICAgICAgcmV0dXJuIGdldEVuY29kZWRTaXplKGVuY29kZXJTaXplLCBwcmVmaXgpICsgZW5jb2RlclNpemU7XG4gICAgfSxcbiAgICB3cml0ZVxuICB9KTtcbn1cbmZ1bmN0aW9uIGFkZERlY29kZXJTaXplUHJlZml4KGRlY29kZXIsIHByZWZpeCkge1xuICBjb25zdCByZWFkID0gKChieXRlcywgb2Zmc2V0KSA9PiB7XG4gICAgY29uc3QgW2JpZ2ludFNpemUsIGRlY29kZXJPZmZzZXRdID0gcHJlZml4LnJlYWQoYnl0ZXMsIG9mZnNldCk7XG4gICAgY29uc3Qgc2l6ZSA9IE51bWJlcihiaWdpbnRTaXplKTtcbiAgICBvZmZzZXQgPSBkZWNvZGVyT2Zmc2V0O1xuICAgIGlmIChvZmZzZXQgPiAwIHx8IGJ5dGVzLmxlbmd0aCA+IHNpemUpIHtcbiAgICAgIGJ5dGVzID0gYnl0ZXMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBzaXplKTtcbiAgICB9XG4gICAgYXNzZXJ0Qnl0ZUFycmF5SGFzRW5vdWdoQnl0ZXNGb3JDb2RlYyhcImFkZERlY29kZXJTaXplUHJlZml4XCIsIHNpemUsIGJ5dGVzKTtcbiAgICByZXR1cm4gW2RlY29kZXIuZGVjb2RlKGJ5dGVzKSwgb2Zmc2V0ICsgc2l6ZV07XG4gIH0pO1xuICBpZiAoaXNGaXhlZFNpemUocHJlZml4KSAmJiBpc0ZpeGVkU2l6ZShkZWNvZGVyKSkge1xuICAgIHJldHVybiBjcmVhdGVEZWNvZGVyKHsgLi4uZGVjb2RlciwgZml4ZWRTaXplOiBwcmVmaXguZml4ZWRTaXplICsgZGVjb2Rlci5maXhlZFNpemUsIHJlYWQgfSk7XG4gIH1cbiAgY29uc3QgcHJlZml4TWF4U2l6ZSA9IGlzRml4ZWRTaXplKHByZWZpeCkgPyBwcmVmaXguZml4ZWRTaXplIDogcHJlZml4Lm1heFNpemUgPz8gbnVsbDtcbiAgY29uc3QgZGVjb2Rlck1heFNpemUgPSBpc0ZpeGVkU2l6ZShkZWNvZGVyKSA/IGRlY29kZXIuZml4ZWRTaXplIDogZGVjb2Rlci5tYXhTaXplID8/IG51bGw7XG4gIGNvbnN0IG1heFNpemUgPSBwcmVmaXhNYXhTaXplICE9PSBudWxsICYmIGRlY29kZXJNYXhTaXplICE9PSBudWxsID8gcHJlZml4TWF4U2l6ZSArIGRlY29kZXJNYXhTaXplIDogbnVsbDtcbiAgcmV0dXJuIGNyZWF0ZURlY29kZXIoeyAuLi5kZWNvZGVyLCAuLi5tYXhTaXplICE9PSBudWxsID8geyBtYXhTaXplIH0gOiB7fSwgcmVhZCB9KTtcbn1cbmZ1bmN0aW9uIGFkZENvZGVjU2l6ZVByZWZpeChjb2RlYywgcHJlZml4KSB7XG4gIHJldHVybiBjb21iaW5lQ29kZWMoYWRkRW5jb2RlclNpemVQcmVmaXgoY29kZWMsIHByZWZpeCksIGFkZERlY29kZXJTaXplUHJlZml4KGNvZGVjLCBwcmVmaXgpKTtcbn1cblxuLy8gc3JjL2FycmF5LWJ1ZmZlcnMudHNcbmZ1bmN0aW9uIHRvQXJyYXlCdWZmZXIoYnl0ZXMsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGNvbnN0IGJ5dGVzT2Zmc2V0ID0gYnl0ZXMuYnl0ZU9mZnNldCArIChvZmZzZXQgPz8gMCk7XG4gIGNvbnN0IGJ5dGVzTGVuZ3RoID0gbGVuZ3RoID8/IGJ5dGVzLmJ5dGVMZW5ndGg7XG4gIGxldCBidWZmZXI7XG4gIGlmICh0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBidWZmZXIgPSBieXRlcy5idWZmZXI7XG4gIH0gZWxzZSBpZiAoYnl0ZXMuYnVmZmVyIGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXIpIHtcbiAgICBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnl0ZXMubGVuZ3RoKTtcbiAgICBuZXcgVWludDhBcnJheShidWZmZXIpLnNldChuZXcgVWludDhBcnJheShieXRlcykpO1xuICB9IGVsc2Uge1xuICAgIGJ1ZmZlciA9IGJ5dGVzLmJ1ZmZlcjtcbiAgfVxuICByZXR1cm4gKGJ5dGVzT2Zmc2V0ID09PSAwIHx8IGJ5dGVzT2Zmc2V0ID09PSAtYnl0ZXMuYnl0ZUxlbmd0aCkgJiYgYnl0ZXNMZW5ndGggPT09IGJ5dGVzLmJ5dGVMZW5ndGggPyBidWZmZXIgOiBidWZmZXIuc2xpY2UoYnl0ZXNPZmZzZXQsIGJ5dGVzT2Zmc2V0ICsgYnl0ZXNMZW5ndGgpO1xufVxuZnVuY3Rpb24gY3JlYXRlRGVjb2RlclRoYXRDb25zdW1lc0VudGlyZUJ5dGVBcnJheShkZWNvZGVyKSB7XG4gIHJldHVybiBjcmVhdGVEZWNvZGVyKHtcbiAgICAuLi5kZWNvZGVyLFxuICAgIHJlYWQoYnl0ZXMsIG9mZnNldCkge1xuICAgICAgY29uc3QgW3ZhbHVlLCBuZXdPZmZzZXRdID0gZGVjb2Rlci5yZWFkKGJ5dGVzLCBvZmZzZXQpO1xuICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA+IG5ld09mZnNldCkge1xuICAgICAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX0RFQ09ERVJfVE9fQ09OU1VNRV9FTlRJUkVfQllURV9BUlJBWSwge1xuICAgICAgICAgIGV4cGVjdGVkTGVuZ3RoOiBuZXdPZmZzZXQsXG4gICAgICAgICAgbnVtRXhjZXNzQnl0ZXM6IGJ5dGVzLmxlbmd0aCAtIG5ld09mZnNldFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbdmFsdWUsIG5ld09mZnNldF07XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL2ZpeC1jb2RlYy1zaXplLnRzXG5mdW5jdGlvbiBmaXhFbmNvZGVyU2l6ZShlbmNvZGVyLCBmaXhlZEJ5dGVzKSB7XG4gIHJldHVybiBjcmVhdGVFbmNvZGVyKHtcbiAgICBmaXhlZFNpemU6IGZpeGVkQnl0ZXMsXG4gICAgd3JpdGU6ICh2YWx1ZSwgYnl0ZXMsIG9mZnNldCkgPT4ge1xuICAgICAgY29uc3QgdmFyaWFibGVCeXRlQXJyYXkgPSBlbmNvZGVyLmVuY29kZSh2YWx1ZSk7XG4gICAgICBjb25zdCBmaXhlZEJ5dGVBcnJheSA9IHZhcmlhYmxlQnl0ZUFycmF5Lmxlbmd0aCA+IGZpeGVkQnl0ZXMgPyB2YXJpYWJsZUJ5dGVBcnJheS5zbGljZSgwLCBmaXhlZEJ5dGVzKSA6IHZhcmlhYmxlQnl0ZUFycmF5O1xuICAgICAgYnl0ZXMuc2V0KGZpeGVkQnl0ZUFycmF5LCBvZmZzZXQpO1xuICAgICAgcmV0dXJuIG9mZnNldCArIGZpeGVkQnl0ZXM7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGZpeERlY29kZXJTaXplKGRlY29kZXIsIGZpeGVkQnl0ZXMpIHtcbiAgcmV0dXJuIGNyZWF0ZURlY29kZXIoe1xuICAgIGZpeGVkU2l6ZTogZml4ZWRCeXRlcyxcbiAgICByZWFkOiAoYnl0ZXMsIG9mZnNldCkgPT4ge1xuICAgICAgYXNzZXJ0Qnl0ZUFycmF5SGFzRW5vdWdoQnl0ZXNGb3JDb2RlYyhcImZpeENvZGVjU2l6ZVwiLCBmaXhlZEJ5dGVzLCBieXRlcywgb2Zmc2V0KTtcbiAgICAgIGlmIChvZmZzZXQgPiAwIHx8IGJ5dGVzLmxlbmd0aCA+IGZpeGVkQnl0ZXMpIHtcbiAgICAgICAgYnl0ZXMgPSBieXRlcy5zbGljZShvZmZzZXQsIG9mZnNldCArIGZpeGVkQnl0ZXMpO1xuICAgICAgfVxuICAgICAgaWYgKGlzRml4ZWRTaXplKGRlY29kZXIpKSB7XG4gICAgICAgIGJ5dGVzID0gZml4Qnl0ZXMoYnl0ZXMsIGRlY29kZXIuZml4ZWRTaXplKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IFt2YWx1ZV0gPSBkZWNvZGVyLnJlYWQoYnl0ZXMsIDApO1xuICAgICAgcmV0dXJuIFt2YWx1ZSwgb2Zmc2V0ICsgZml4ZWRCeXRlc107XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGZpeENvZGVjU2l6ZShjb2RlYywgZml4ZWRCeXRlcykge1xuICByZXR1cm4gY29tYmluZUNvZGVjKGZpeEVuY29kZXJTaXplKGNvZGVjLCBmaXhlZEJ5dGVzKSwgZml4RGVjb2RlclNpemUoY29kZWMsIGZpeGVkQnl0ZXMpKTtcbn1cblxuLy8gc3JjL29mZnNldC1jb2RlYy50c1xuZnVuY3Rpb24gb2Zmc2V0RW5jb2RlcihlbmNvZGVyLCBjb25maWcpIHtcbiAgcmV0dXJuIGNyZWF0ZUVuY29kZXIoe1xuICAgIC4uLmVuY29kZXIsXG4gICAgd3JpdGU6ICh2YWx1ZSwgYnl0ZXMsIHByZU9mZnNldCkgPT4ge1xuICAgICAgY29uc3Qgd3JhcEJ5dGVzID0gKG9mZnNldCkgPT4gbW9kdWxvKG9mZnNldCwgYnl0ZXMubGVuZ3RoKTtcbiAgICAgIGNvbnN0IG5ld1ByZU9mZnNldCA9IGNvbmZpZy5wcmVPZmZzZXQgPyBjb25maWcucHJlT2Zmc2V0KHsgYnl0ZXMsIHByZU9mZnNldCwgd3JhcEJ5dGVzIH0pIDogcHJlT2Zmc2V0O1xuICAgICAgYXNzZXJ0Qnl0ZUFycmF5T2Zmc2V0SXNOb3RPdXRPZlJhbmdlKFwib2Zmc2V0RW5jb2RlclwiLCBuZXdQcmVPZmZzZXQsIGJ5dGVzLmxlbmd0aCk7XG4gICAgICBjb25zdCBwb3N0T2Zmc2V0ID0gZW5jb2Rlci53cml0ZSh2YWx1ZSwgYnl0ZXMsIG5ld1ByZU9mZnNldCk7XG4gICAgICBjb25zdCBuZXdQb3N0T2Zmc2V0ID0gY29uZmlnLnBvc3RPZmZzZXQgPyBjb25maWcucG9zdE9mZnNldCh7IGJ5dGVzLCBuZXdQcmVPZmZzZXQsIHBvc3RPZmZzZXQsIHByZU9mZnNldCwgd3JhcEJ5dGVzIH0pIDogcG9zdE9mZnNldDtcbiAgICAgIGFzc2VydEJ5dGVBcnJheU9mZnNldElzTm90T3V0T2ZSYW5nZShcIm9mZnNldEVuY29kZXJcIiwgbmV3UG9zdE9mZnNldCwgYnl0ZXMubGVuZ3RoKTtcbiAgICAgIHJldHVybiBuZXdQb3N0T2Zmc2V0O1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBvZmZzZXREZWNvZGVyKGRlY29kZXIsIGNvbmZpZykge1xuICByZXR1cm4gY3JlYXRlRGVjb2Rlcih7XG4gICAgLi4uZGVjb2RlcixcbiAgICByZWFkOiAoYnl0ZXMsIHByZU9mZnNldCkgPT4ge1xuICAgICAgY29uc3Qgd3JhcEJ5dGVzID0gKG9mZnNldCkgPT4gbW9kdWxvKG9mZnNldCwgYnl0ZXMubGVuZ3RoKTtcbiAgICAgIGNvbnN0IG5ld1ByZU9mZnNldCA9IGNvbmZpZy5wcmVPZmZzZXQgPyBjb25maWcucHJlT2Zmc2V0KHsgYnl0ZXMsIHByZU9mZnNldCwgd3JhcEJ5dGVzIH0pIDogcHJlT2Zmc2V0O1xuICAgICAgYXNzZXJ0Qnl0ZUFycmF5T2Zmc2V0SXNOb3RPdXRPZlJhbmdlKFwib2Zmc2V0RGVjb2RlclwiLCBuZXdQcmVPZmZzZXQsIGJ5dGVzLmxlbmd0aCk7XG4gICAgICBjb25zdCBbdmFsdWUsIHBvc3RPZmZzZXRdID0gZGVjb2Rlci5yZWFkKGJ5dGVzLCBuZXdQcmVPZmZzZXQpO1xuICAgICAgY29uc3QgbmV3UG9zdE9mZnNldCA9IGNvbmZpZy5wb3N0T2Zmc2V0ID8gY29uZmlnLnBvc3RPZmZzZXQoeyBieXRlcywgbmV3UHJlT2Zmc2V0LCBwb3N0T2Zmc2V0LCBwcmVPZmZzZXQsIHdyYXBCeXRlcyB9KSA6IHBvc3RPZmZzZXQ7XG4gICAgICBhc3NlcnRCeXRlQXJyYXlPZmZzZXRJc05vdE91dE9mUmFuZ2UoXCJvZmZzZXREZWNvZGVyXCIsIG5ld1Bvc3RPZmZzZXQsIGJ5dGVzLmxlbmd0aCk7XG4gICAgICByZXR1cm4gW3ZhbHVlLCBuZXdQb3N0T2Zmc2V0XTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gb2Zmc2V0Q29kZWMoY29kZWMsIGNvbmZpZykge1xuICByZXR1cm4gY29tYmluZUNvZGVjKG9mZnNldEVuY29kZXIoY29kZWMsIGNvbmZpZyksIG9mZnNldERlY29kZXIoY29kZWMsIGNvbmZpZykpO1xufVxuZnVuY3Rpb24gbW9kdWxvKGRpdmlkZW5kLCBkaXZpc29yKSB7XG4gIGlmIChkaXZpc29yID09PSAwKSByZXR1cm4gMDtcbiAgcmV0dXJuIChkaXZpZGVuZCAlIGRpdmlzb3IgKyBkaXZpc29yKSAlIGRpdmlzb3I7XG59XG5mdW5jdGlvbiByZXNpemVFbmNvZGVyKGVuY29kZXIsIHJlc2l6ZSkge1xuICBpZiAoaXNGaXhlZFNpemUoZW5jb2RlcikpIHtcbiAgICBjb25zdCBmaXhlZFNpemUgPSByZXNpemUoZW5jb2Rlci5maXhlZFNpemUpO1xuICAgIGlmIChmaXhlZFNpemUgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX1BPU0lUSVZFX0JZVEVfTEVOR1RILCB7XG4gICAgICAgIGJ5dGVzTGVuZ3RoOiBmaXhlZFNpemUsXG4gICAgICAgIGNvZGVjRGVzY3JpcHRpb246IFwicmVzaXplRW5jb2RlclwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUVuY29kZXIoeyAuLi5lbmNvZGVyLCBmaXhlZFNpemUgfSk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUVuY29kZXIoe1xuICAgIC4uLmVuY29kZXIsXG4gICAgZ2V0U2l6ZUZyb21WYWx1ZTogKHZhbHVlKSA9PiB7XG4gICAgICBjb25zdCBuZXdTaXplID0gcmVzaXplKGVuY29kZXIuZ2V0U2l6ZUZyb21WYWx1ZSh2YWx1ZSkpO1xuICAgICAgaWYgKG5ld1NpemUgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfUE9TSVRJVkVfQllURV9MRU5HVEgsIHtcbiAgICAgICAgICBieXRlc0xlbmd0aDogbmV3U2l6ZSxcbiAgICAgICAgICBjb2RlY0Rlc2NyaXB0aW9uOiBcInJlc2l6ZUVuY29kZXJcIlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdTaXplO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiByZXNpemVEZWNvZGVyKGRlY29kZXIsIHJlc2l6ZSkge1xuICBpZiAoaXNGaXhlZFNpemUoZGVjb2RlcikpIHtcbiAgICBjb25zdCBmaXhlZFNpemUgPSByZXNpemUoZGVjb2Rlci5maXhlZFNpemUpO1xuICAgIGlmIChmaXhlZFNpemUgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX1BPU0lUSVZFX0JZVEVfTEVOR1RILCB7XG4gICAgICAgIGJ5dGVzTGVuZ3RoOiBmaXhlZFNpemUsXG4gICAgICAgIGNvZGVjRGVzY3JpcHRpb246IFwicmVzaXplRGVjb2RlclwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZURlY29kZXIoeyAuLi5kZWNvZGVyLCBmaXhlZFNpemUgfSk7XG4gIH1cbiAgcmV0dXJuIGRlY29kZXI7XG59XG5mdW5jdGlvbiByZXNpemVDb2RlYyhjb2RlYywgcmVzaXplKSB7XG4gIHJldHVybiBjb21iaW5lQ29kZWMocmVzaXplRW5jb2Rlcihjb2RlYywgcmVzaXplKSwgcmVzaXplRGVjb2Rlcihjb2RlYywgcmVzaXplKSk7XG59XG5cbi8vIHNyYy9wYWQtY29kZWMudHNcbmZ1bmN0aW9uIHBhZExlZnRFbmNvZGVyKGVuY29kZXIsIG9mZnNldCkge1xuICByZXR1cm4gb2Zmc2V0RW5jb2RlcihcbiAgICByZXNpemVFbmNvZGVyKGVuY29kZXIsIChzaXplKSA9PiBzaXplICsgb2Zmc2V0KSxcbiAgICB7IHByZU9mZnNldDogKHsgcHJlT2Zmc2V0IH0pID0+IHByZU9mZnNldCArIG9mZnNldCB9XG4gICk7XG59XG5mdW5jdGlvbiBwYWRSaWdodEVuY29kZXIoZW5jb2Rlciwgb2Zmc2V0KSB7XG4gIHJldHVybiBvZmZzZXRFbmNvZGVyKFxuICAgIHJlc2l6ZUVuY29kZXIoZW5jb2RlciwgKHNpemUpID0+IHNpemUgKyBvZmZzZXQpLFxuICAgIHsgcG9zdE9mZnNldDogKHsgcG9zdE9mZnNldCB9KSA9PiBwb3N0T2Zmc2V0ICsgb2Zmc2V0IH1cbiAgKTtcbn1cbmZ1bmN0aW9uIHBhZExlZnREZWNvZGVyKGRlY29kZXIsIG9mZnNldCkge1xuICByZXR1cm4gb2Zmc2V0RGVjb2RlcihcbiAgICByZXNpemVEZWNvZGVyKGRlY29kZXIsIChzaXplKSA9PiBzaXplICsgb2Zmc2V0KSxcbiAgICB7IHByZU9mZnNldDogKHsgcHJlT2Zmc2V0IH0pID0+IHByZU9mZnNldCArIG9mZnNldCB9XG4gICk7XG59XG5mdW5jdGlvbiBwYWRSaWdodERlY29kZXIoZGVjb2Rlciwgb2Zmc2V0KSB7XG4gIHJldHVybiBvZmZzZXREZWNvZGVyKFxuICAgIHJlc2l6ZURlY29kZXIoZGVjb2RlciwgKHNpemUpID0+IHNpemUgKyBvZmZzZXQpLFxuICAgIHsgcG9zdE9mZnNldDogKHsgcG9zdE9mZnNldCB9KSA9PiBwb3N0T2Zmc2V0ICsgb2Zmc2V0IH1cbiAgKTtcbn1cbmZ1bmN0aW9uIHBhZExlZnRDb2RlYyhjb2RlYywgb2Zmc2V0KSB7XG4gIHJldHVybiBjb21iaW5lQ29kZWMocGFkTGVmdEVuY29kZXIoY29kZWMsIG9mZnNldCksIHBhZExlZnREZWNvZGVyKGNvZGVjLCBvZmZzZXQpKTtcbn1cbmZ1bmN0aW9uIHBhZFJpZ2h0Q29kZWMoY29kZWMsIG9mZnNldCkge1xuICByZXR1cm4gY29tYmluZUNvZGVjKHBhZFJpZ2h0RW5jb2Rlcihjb2RlYywgb2Zmc2V0KSwgcGFkUmlnaHREZWNvZGVyKGNvZGVjLCBvZmZzZXQpKTtcbn1cblxuLy8gc3JjL3JldmVyc2UtY29kZWMudHNcbmZ1bmN0aW9uIGNvcHlTb3VyY2VUb1RhcmdldEluUmV2ZXJzZShzb3VyY2UsIHRhcmdldF9XSUxMX01VVEFURSwgc291cmNlT2Zmc2V0LCBzb3VyY2VMZW5ndGgsIHRhcmdldE9mZnNldCA9IDApIHtcbiAgd2hpbGUgKHNvdXJjZU9mZnNldCA8IC0tc291cmNlTGVuZ3RoKSB7XG4gICAgY29uc3QgbGVmdFZhbHVlID0gc291cmNlW3NvdXJjZU9mZnNldF07XG4gICAgdGFyZ2V0X1dJTExfTVVUQVRFW3NvdXJjZU9mZnNldCArIHRhcmdldE9mZnNldF0gPSBzb3VyY2Vbc291cmNlTGVuZ3RoXTtcbiAgICB0YXJnZXRfV0lMTF9NVVRBVEVbc291cmNlTGVuZ3RoICsgdGFyZ2V0T2Zmc2V0XSA9IGxlZnRWYWx1ZTtcbiAgICBzb3VyY2VPZmZzZXQrKztcbiAgfVxuICBpZiAoc291cmNlT2Zmc2V0ID09PSBzb3VyY2VMZW5ndGgpIHtcbiAgICB0YXJnZXRfV0lMTF9NVVRBVEVbc291cmNlT2Zmc2V0ICsgdGFyZ2V0T2Zmc2V0XSA9IHNvdXJjZVtzb3VyY2VPZmZzZXRdO1xuICB9XG59XG5mdW5jdGlvbiByZXZlcnNlRW5jb2RlcihlbmNvZGVyKSB7XG4gIGFzc2VydElzRml4ZWRTaXplKGVuY29kZXIpO1xuICByZXR1cm4gY3JlYXRlRW5jb2Rlcih7XG4gICAgLi4uZW5jb2RlcixcbiAgICB3cml0ZTogKHZhbHVlLCBieXRlcywgb2Zmc2V0KSA9PiB7XG4gICAgICBjb25zdCBuZXdPZmZzZXQgPSBlbmNvZGVyLndyaXRlKHZhbHVlLCBieXRlcywgb2Zmc2V0KTtcbiAgICAgIGNvcHlTb3VyY2VUb1RhcmdldEluUmV2ZXJzZShcbiAgICAgICAgYnl0ZXMsXG4gICAgICAgIGJ5dGVzLFxuICAgICAgICBvZmZzZXQsXG4gICAgICAgIG9mZnNldCArIGVuY29kZXIuZml4ZWRTaXplXG4gICAgICApO1xuICAgICAgcmV0dXJuIG5ld09mZnNldDtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gcmV2ZXJzZURlY29kZXIoZGVjb2Rlcikge1xuICBhc3NlcnRJc0ZpeGVkU2l6ZShkZWNvZGVyKTtcbiAgcmV0dXJuIGNyZWF0ZURlY29kZXIoe1xuICAgIC4uLmRlY29kZXIsXG4gICAgcmVhZDogKGJ5dGVzLCBvZmZzZXQpID0+IHtcbiAgICAgIGNvbnN0IHJldmVyc2VkQnl0ZXMgPSBieXRlcy5zbGljZSgpO1xuICAgICAgY29weVNvdXJjZVRvVGFyZ2V0SW5SZXZlcnNlKFxuICAgICAgICBieXRlcyxcbiAgICAgICAgcmV2ZXJzZWRCeXRlcyxcbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICBvZmZzZXQgKyBkZWNvZGVyLmZpeGVkU2l6ZVxuICAgICAgKTtcbiAgICAgIHJldHVybiBkZWNvZGVyLnJlYWQocmV2ZXJzZWRCeXRlcywgb2Zmc2V0KTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gcmV2ZXJzZUNvZGVjKGNvZGVjKSB7XG4gIHJldHVybiBjb21iaW5lQ29kZWMocmV2ZXJzZUVuY29kZXIoY29kZWMpLCByZXZlcnNlRGVjb2Rlcihjb2RlYykpO1xufVxuXG4vLyBzcmMvdHJhbnNmb3JtLWNvZGVjLnRzXG5mdW5jdGlvbiB0cmFuc2Zvcm1FbmNvZGVyKGVuY29kZXIsIHVubWFwKSB7XG4gIHJldHVybiBjcmVhdGVFbmNvZGVyKHtcbiAgICAuLi5pc1ZhcmlhYmxlU2l6ZShlbmNvZGVyKSA/IHsgLi4uZW5jb2RlciwgZ2V0U2l6ZUZyb21WYWx1ZTogKHZhbHVlKSA9PiBlbmNvZGVyLmdldFNpemVGcm9tVmFsdWUodW5tYXAodmFsdWUpKSB9IDogZW5jb2RlcixcbiAgICB3cml0ZTogKHZhbHVlLCBieXRlcywgb2Zmc2V0KSA9PiBlbmNvZGVyLndyaXRlKHVubWFwKHZhbHVlKSwgYnl0ZXMsIG9mZnNldClcbiAgfSk7XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1EZWNvZGVyKGRlY29kZXIsIG1hcCkge1xuICByZXR1cm4gY3JlYXRlRGVjb2Rlcih7XG4gICAgLi4uZGVjb2RlcixcbiAgICByZWFkOiAoYnl0ZXMsIG9mZnNldCkgPT4ge1xuICAgICAgY29uc3QgW3ZhbHVlLCBuZXdPZmZzZXRdID0gZGVjb2Rlci5yZWFkKGJ5dGVzLCBvZmZzZXQpO1xuICAgICAgcmV0dXJuIFttYXAodmFsdWUsIGJ5dGVzLCBvZmZzZXQpLCBuZXdPZmZzZXRdO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1Db2RlYyhjb2RlYywgdW5tYXAsIG1hcCkge1xuICByZXR1cm4gY3JlYXRlQ29kZWMoe1xuICAgIC4uLnRyYW5zZm9ybUVuY29kZXIoY29kZWMsIHVubWFwKSxcbiAgICByZWFkOiBtYXAgPyB0cmFuc2Zvcm1EZWNvZGVyKGNvZGVjLCBtYXApLnJlYWQgOiBjb2RlYy5yZWFkXG4gIH0pO1xufVxuXG5leHBvcnQgeyBhZGRDb2RlY1NlbnRpbmVsLCBhZGRDb2RlY1NpemVQcmVmaXgsIGFkZERlY29kZXJTZW50aW5lbCwgYWRkRGVjb2RlclNpemVQcmVmaXgsIGFkZEVuY29kZXJTZW50aW5lbCwgYWRkRW5jb2RlclNpemVQcmVmaXgsIGFzc2VydEJ5dGVBcnJheUhhc0Vub3VnaEJ5dGVzRm9yQ29kZWMsIGFzc2VydEJ5dGVBcnJheUlzTm90RW1wdHlGb3JDb2RlYywgYXNzZXJ0Qnl0ZUFycmF5T2Zmc2V0SXNOb3RPdXRPZlJhbmdlLCBhc3NlcnRJc0ZpeGVkU2l6ZSwgYXNzZXJ0SXNWYXJpYWJsZVNpemUsIGJ5dGVzRXF1YWwsIGNvbWJpbmVDb2RlYywgY29udGFpbnNCeXRlcywgY3JlYXRlQ29kZWMsIGNyZWF0ZURlY29kZXIsIGNyZWF0ZURlY29kZXJUaGF0Q29uc3VtZXNFbnRpcmVCeXRlQXJyYXksIGNyZWF0ZUVuY29kZXIsIGZpeEJ5dGVzLCBmaXhDb2RlY1NpemUsIGZpeERlY29kZXJTaXplLCBmaXhFbmNvZGVyU2l6ZSwgZ2V0RW5jb2RlZFNpemUsIGlzRml4ZWRTaXplLCBpc1ZhcmlhYmxlU2l6ZSwgbWVyZ2VCeXRlcywgb2Zmc2V0Q29kZWMsIG9mZnNldERlY29kZXIsIG9mZnNldEVuY29kZXIsIHBhZEJ5dGVzLCBwYWRMZWZ0Q29kZWMsIHBhZExlZnREZWNvZGVyLCBwYWRMZWZ0RW5jb2RlciwgcGFkUmlnaHRDb2RlYywgcGFkUmlnaHREZWNvZGVyLCBwYWRSaWdodEVuY29kZXIsIHJlc2l6ZUNvZGVjLCByZXNpemVEZWNvZGVyLCByZXNpemVFbmNvZGVyLCByZXZlcnNlQ29kZWMsIHJldmVyc2VEZWNvZGVyLCByZXZlcnNlRW5jb2RlciwgdG9BcnJheUJ1ZmZlciwgdHJhbnNmb3JtQ29kZWMsIHRyYW5zZm9ybURlY29kZXIsIHRyYW5zZm9ybUVuY29kZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm5vZGUubWpzLm1hcFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubm9kZS5tanMubWFwIl0sIm5hbWVzIjpbIlNvbGFuYUVycm9yIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX0ZJWEVEX0xFTkdUSCIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9WQVJJQUJMRV9MRU5HVEgiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFUl9ERUNPREVSX1NJWkVfQ09NUEFUSUJJTElUWV9NSVNNQVRDSCIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfRklYRURfU0laRV9NSVNNQVRDSCIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfTUFYX1NJWkVfTUlTTUFUQ0giLCJTT0xBTkFfRVJST1JfX0NPREVDU19fQ0FOTk9UX0RFQ09ERV9FTVBUWV9CWVRFX0FSUkFZIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfQllURV9MRU5HVEgiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fT0ZGU0VUX09VVF9PRl9SQU5HRSIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9ERUNPREVSX1RPX0NPTlNVTUVfRU5USVJFX0JZVEVfQVJSQVkiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfUE9TSVRJVkVfQllURV9MRU5HVEgiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fU0VOVElORUxfTUlTU0lOR19JTl9ERUNPREVEX0JZVEVTIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERURfQllURVNfTVVTVF9OT1RfSU5DTFVERV9TRU5USU5FTCIsIm1lcmdlQnl0ZXMiLCJieXRlQXJyYXlzIiwibm9uRW1wdHlCeXRlQXJyYXlzIiwiZmlsdGVyIiwiYXJyIiwibGVuZ3RoIiwiVWludDhBcnJheSIsInRvdGFsTGVuZ3RoIiwicmVkdWNlIiwidG90YWwiLCJyZXN1bHQiLCJvZmZzZXQiLCJmb3JFYWNoIiwic2V0IiwicGFkQnl0ZXMiLCJieXRlcyIsInBhZGRlZEJ5dGVzIiwiZmlsbCIsImZpeEJ5dGVzIiwic2xpY2UiLCJjb250YWluc0J5dGVzIiwiZGF0YSIsImJ5dGVzRXF1YWwiLCJieXRlczEiLCJieXRlczIiLCJldmVyeSIsInZhbHVlIiwiaW5kZXgiLCJnZXRFbmNvZGVkU2l6ZSIsImVuY29kZXIiLCJmaXhlZFNpemUiLCJnZXRTaXplRnJvbVZhbHVlIiwiY3JlYXRlRW5jb2RlciIsIk9iamVjdCIsImZyZWV6ZSIsImVuY29kZSIsIndyaXRlIiwiY3JlYXRlRGVjb2RlciIsImRlY29kZXIiLCJkZWNvZGUiLCJyZWFkIiwiY3JlYXRlQ29kZWMiLCJjb2RlYyIsImlzRml4ZWRTaXplIiwiYXNzZXJ0SXNGaXhlZFNpemUiLCJpc1ZhcmlhYmxlU2l6ZSIsImFzc2VydElzVmFyaWFibGVTaXplIiwiY29tYmluZUNvZGVjIiwiZGVjb2RlckZpeGVkU2l6ZSIsImVuY29kZXJGaXhlZFNpemUiLCJtYXhTaXplIiwiZGVjb2Rlck1heFNpemUiLCJlbmNvZGVyTWF4U2l6ZSIsImFkZEVuY29kZXJTZW50aW5lbCIsInNlbnRpbmVsIiwiZW5jb2RlckJ5dGVzIiwiZmluZFNlbnRpbmVsSW5kZXgiLCJlbmNvZGVkQnl0ZXMiLCJoZXhFbmNvZGVkQnl0ZXMiLCJoZXhCeXRlcyIsImhleFNlbnRpbmVsIiwiYWRkRGVjb2RlclNlbnRpbmVsIiwiY2FuZGlkYXRlQnl0ZXMiLCJzZW50aW5lbEluZGV4IiwiZGVjb2RlZEJ5dGVzIiwiaGV4RGVjb2RlZEJ5dGVzIiwicHJlU2VudGluZWxCeXRlcyIsImFkZENvZGVjU2VudGluZWwiLCJmaW5kSW5kZXgiLCJieXRlIiwic3RyIiwidG9TdHJpbmciLCJwYWRTdGFydCIsImFzc2VydEJ5dGVBcnJheUlzTm90RW1wdHlGb3JDb2RlYyIsImNvZGVjRGVzY3JpcHRpb24iLCJhc3NlcnRCeXRlQXJyYXlIYXNFbm91Z2hCeXRlc0ZvckNvZGVjIiwiZXhwZWN0ZWQiLCJieXRlc0xlbmd0aCIsImFzc2VydEJ5dGVBcnJheU9mZnNldElzTm90T3V0T2ZSYW5nZSIsImFkZEVuY29kZXJTaXplUHJlZml4IiwicHJlZml4IiwicHJlZml4TWF4U2l6ZSIsImVuY29kZXJTaXplIiwiYWRkRGVjb2RlclNpemVQcmVmaXgiLCJiaWdpbnRTaXplIiwiZGVjb2Rlck9mZnNldCIsInNpemUiLCJOdW1iZXIiLCJhZGRDb2RlY1NpemVQcmVmaXgiLCJ0b0FycmF5QnVmZmVyIiwiYnl0ZXNPZmZzZXQiLCJieXRlT2Zmc2V0IiwiYnl0ZUxlbmd0aCIsImJ1ZmZlciIsIlNoYXJlZEFycmF5QnVmZmVyIiwiQXJyYXlCdWZmZXIiLCJjcmVhdGVEZWNvZGVyVGhhdENvbnN1bWVzRW50aXJlQnl0ZUFycmF5IiwibmV3T2Zmc2V0IiwiZXhwZWN0ZWRMZW5ndGgiLCJudW1FeGNlc3NCeXRlcyIsImZpeEVuY29kZXJTaXplIiwiZml4ZWRCeXRlcyIsInZhcmlhYmxlQnl0ZUFycmF5IiwiZml4ZWRCeXRlQXJyYXkiLCJmaXhEZWNvZGVyU2l6ZSIsImZpeENvZGVjU2l6ZSIsIm9mZnNldEVuY29kZXIiLCJjb25maWciLCJwcmVPZmZzZXQiLCJ3cmFwQnl0ZXMiLCJtb2R1bG8iLCJuZXdQcmVPZmZzZXQiLCJwb3N0T2Zmc2V0IiwibmV3UG9zdE9mZnNldCIsIm9mZnNldERlY29kZXIiLCJvZmZzZXRDb2RlYyIsImRpdmlkZW5kIiwiZGl2aXNvciIsInJlc2l6ZUVuY29kZXIiLCJyZXNpemUiLCJuZXdTaXplIiwicmVzaXplRGVjb2RlciIsInJlc2l6ZUNvZGVjIiwicGFkTGVmdEVuY29kZXIiLCJwYWRSaWdodEVuY29kZXIiLCJwYWRMZWZ0RGVjb2RlciIsInBhZFJpZ2h0RGVjb2RlciIsInBhZExlZnRDb2RlYyIsInBhZFJpZ2h0Q29kZWMiLCJjb3B5U291cmNlVG9UYXJnZXRJblJldmVyc2UiLCJzb3VyY2UiLCJ0YXJnZXRfV0lMTF9NVVRBVEUiLCJzb3VyY2VPZmZzZXQiLCJzb3VyY2VMZW5ndGgiLCJ0YXJnZXRPZmZzZXQiLCJsZWZ0VmFsdWUiLCJyZXZlcnNlRW5jb2RlciIsInJldmVyc2VEZWNvZGVyIiwicmV2ZXJzZWRCeXRlcyIsInJldmVyc2VDb2RlYyIsInRyYW5zZm9ybUVuY29kZXIiLCJ1bm1hcCIsInRyYW5zZm9ybURlY29kZXIiLCJtYXAiLCJ0cmFuc2Zvcm1Db2RlYyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/codecs-core/dist/index.node.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/codecs-data-structures/dist/index.node.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@solana/codecs-data-structures/dist/index.node.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertValidNumberOfItemsForCodec: () => (/* binding */ assertValidNumberOfItemsForCodec),\n/* harmony export */   getArrayCodec: () => (/* binding */ getArrayCodec),\n/* harmony export */   getArrayDecoder: () => (/* binding */ getArrayDecoder),\n/* harmony export */   getArrayEncoder: () => (/* binding */ getArrayEncoder),\n/* harmony export */   getBitArrayCodec: () => (/* binding */ getBitArrayCodec),\n/* harmony export */   getBitArrayDecoder: () => (/* binding */ getBitArrayDecoder),\n/* harmony export */   getBitArrayEncoder: () => (/* binding */ getBitArrayEncoder),\n/* harmony export */   getBooleanCodec: () => (/* binding */ getBooleanCodec),\n/* harmony export */   getBooleanDecoder: () => (/* binding */ getBooleanDecoder),\n/* harmony export */   getBooleanEncoder: () => (/* binding */ getBooleanEncoder),\n/* harmony export */   getBytesCodec: () => (/* binding */ getBytesCodec),\n/* harmony export */   getBytesDecoder: () => (/* binding */ getBytesDecoder),\n/* harmony export */   getBytesEncoder: () => (/* binding */ getBytesEncoder),\n/* harmony export */   getConstantCodec: () => (/* binding */ getConstantCodec),\n/* harmony export */   getConstantDecoder: () => (/* binding */ getConstantDecoder),\n/* harmony export */   getConstantEncoder: () => (/* binding */ getConstantEncoder),\n/* harmony export */   getDiscriminatedUnionCodec: () => (/* binding */ getDiscriminatedUnionCodec),\n/* harmony export */   getDiscriminatedUnionDecoder: () => (/* binding */ getDiscriminatedUnionDecoder),\n/* harmony export */   getDiscriminatedUnionEncoder: () => (/* binding */ getDiscriminatedUnionEncoder),\n/* harmony export */   getEnumCodec: () => (/* binding */ getEnumCodec),\n/* harmony export */   getEnumDecoder: () => (/* binding */ getEnumDecoder),\n/* harmony export */   getEnumEncoder: () => (/* binding */ getEnumEncoder),\n/* harmony export */   getHiddenPrefixCodec: () => (/* binding */ getHiddenPrefixCodec),\n/* harmony export */   getHiddenPrefixDecoder: () => (/* binding */ getHiddenPrefixDecoder),\n/* harmony export */   getHiddenPrefixEncoder: () => (/* binding */ getHiddenPrefixEncoder),\n/* harmony export */   getHiddenSuffixCodec: () => (/* binding */ getHiddenSuffixCodec),\n/* harmony export */   getHiddenSuffixDecoder: () => (/* binding */ getHiddenSuffixDecoder),\n/* harmony export */   getHiddenSuffixEncoder: () => (/* binding */ getHiddenSuffixEncoder),\n/* harmony export */   getLiteralUnionCodec: () => (/* binding */ getLiteralUnionCodec),\n/* harmony export */   getLiteralUnionDecoder: () => (/* binding */ getLiteralUnionDecoder),\n/* harmony export */   getLiteralUnionEncoder: () => (/* binding */ getLiteralUnionEncoder),\n/* harmony export */   getMapCodec: () => (/* binding */ getMapCodec),\n/* harmony export */   getMapDecoder: () => (/* binding */ getMapDecoder),\n/* harmony export */   getMapEncoder: () => (/* binding */ getMapEncoder),\n/* harmony export */   getNullableCodec: () => (/* binding */ getNullableCodec),\n/* harmony export */   getNullableDecoder: () => (/* binding */ getNullableDecoder),\n/* harmony export */   getNullableEncoder: () => (/* binding */ getNullableEncoder),\n/* harmony export */   getSetCodec: () => (/* binding */ getSetCodec),\n/* harmony export */   getSetDecoder: () => (/* binding */ getSetDecoder),\n/* harmony export */   getSetEncoder: () => (/* binding */ getSetEncoder),\n/* harmony export */   getStructCodec: () => (/* binding */ getStructCodec),\n/* harmony export */   getStructDecoder: () => (/* binding */ getStructDecoder),\n/* harmony export */   getStructEncoder: () => (/* binding */ getStructEncoder),\n/* harmony export */   getTupleCodec: () => (/* binding */ getTupleCodec),\n/* harmony export */   getTupleDecoder: () => (/* binding */ getTupleDecoder),\n/* harmony export */   getTupleEncoder: () => (/* binding */ getTupleEncoder),\n/* harmony export */   getUnionCodec: () => (/* binding */ getUnionCodec),\n/* harmony export */   getUnionDecoder: () => (/* binding */ getUnionDecoder),\n/* harmony export */   getUnionEncoder: () => (/* binding */ getUnionEncoder),\n/* harmony export */   getUnitCodec: () => (/* binding */ getUnitCodec),\n/* harmony export */   getUnitDecoder: () => (/* binding */ getUnitDecoder),\n/* harmony export */   getUnitEncoder: () => (/* binding */ getUnitEncoder)\n/* harmony export */ });\n/* harmony import */ var _solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana/codecs-core */ \"(ssr)/./node_modules/@solana/codecs-core/dist/index.node.mjs\");\n/* harmony import */ var _solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @solana/codecs-numbers */ \"(ssr)/./node_modules/@solana/codecs-numbers/dist/index.node.mjs\");\n/* harmony import */ var _solana_errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/errors */ \"(ssr)/./node_modules/@solana/errors/dist/index.node.mjs\");\n\n\n\n// src/array.ts\nfunction assertValidNumberOfItemsForCodec(codecDescription, expected, actual) {\n    if (expected !== actual) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, {\n            actual,\n            codecDescription,\n            expected\n        });\n    }\n}\nfunction maxCodecSizes(sizes) {\n    return sizes.reduce((all, size)=>all === null || size === null ? null : Math.max(all, size), 0);\n}\nfunction sumCodecSizes(sizes) {\n    return sizes.reduce((all, size)=>all === null || size === null ? null : all + size, 0);\n}\nfunction getFixedSize(codec) {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.isFixedSize)(codec) ? codec.fixedSize : null;\n}\nfunction getMaxSize(codec) {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.isFixedSize)(codec) ? codec.fixedSize : codec.maxSize ?? null;\n}\n// src/array.ts\nfunction getArrayEncoder(item, config = {}) {\n    const size = config.size ?? (0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_2__.getU32Encoder)();\n    const fixedSize = computeArrayLikeCodecSize(size, getFixedSize(item));\n    const maxSize = computeArrayLikeCodecSize(size, getMaxSize(item)) ?? void 0;\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.createEncoder)({\n        ...fixedSize !== null ? {\n            fixedSize\n        } : {\n            getSizeFromValue: (array)=>{\n                const prefixSize = typeof size === \"object\" ? (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.getEncodedSize)(array.length, size) : 0;\n                return prefixSize + [\n                    ...array\n                ].reduce((all, value)=>all + (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.getEncodedSize)(value, item), 0);\n            },\n            maxSize\n        },\n        write: (array, bytes, offset)=>{\n            if (typeof size === \"number\") {\n                assertValidNumberOfItemsForCodec(\"array\", size, array.length);\n            }\n            if (typeof size === \"object\") {\n                offset = size.write(array.length, bytes, offset);\n            }\n            array.forEach((value)=>{\n                offset = item.write(value, bytes, offset);\n            });\n            return offset;\n        }\n    });\n}\nfunction getArrayDecoder(item, config = {}) {\n    const size = config.size ?? (0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_2__.getU32Decoder)();\n    const itemSize = getFixedSize(item);\n    const fixedSize = computeArrayLikeCodecSize(size, itemSize);\n    const maxSize = computeArrayLikeCodecSize(size, getMaxSize(item)) ?? void 0;\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.createDecoder)({\n        ...fixedSize !== null ? {\n            fixedSize\n        } : {\n            maxSize\n        },\n        read: (bytes, offset)=>{\n            const array = [];\n            if (typeof size === \"object\" && bytes.slice(offset).length === 0) {\n                return [\n                    array,\n                    offset\n                ];\n            }\n            if (size === \"remainder\") {\n                while(offset < bytes.length){\n                    const [value, newOffset2] = item.read(bytes, offset);\n                    offset = newOffset2;\n                    array.push(value);\n                }\n                return [\n                    array,\n                    offset\n                ];\n            }\n            const [resolvedSize, newOffset] = typeof size === \"number\" ? [\n                size,\n                offset\n            ] : size.read(bytes, offset);\n            offset = newOffset;\n            for(let i = 0; i < resolvedSize; i += 1){\n                const [value, newOffset2] = item.read(bytes, offset);\n                offset = newOffset2;\n                array.push(value);\n            }\n            return [\n                array,\n                offset\n            ];\n        }\n    });\n}\nfunction getArrayCodec(item, config = {}) {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getArrayEncoder(item, config), getArrayDecoder(item, config));\n}\nfunction computeArrayLikeCodecSize(size, itemSize) {\n    if (typeof size !== \"number\") return null;\n    if (size === 0) return 0;\n    return itemSize === null ? null : itemSize * size;\n}\nfunction getBitArrayEncoder(size, config = {}) {\n    const parsedConfig = typeof config === \"boolean\" ? {\n        backward: config\n    } : config;\n    const backward = parsedConfig.backward ?? false;\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.createEncoder)({\n        fixedSize: size,\n        write (value, bytes, offset) {\n            const bytesToAdd = [];\n            for(let i = 0; i < size; i += 1){\n                let byte = 0;\n                for(let j = 0; j < 8; j += 1){\n                    const feature = Number(value[i * 8 + j] ?? 0);\n                    byte |= feature << (backward ? j : 7 - j);\n                }\n                if (backward) {\n                    bytesToAdd.unshift(byte);\n                } else {\n                    bytesToAdd.push(byte);\n                }\n            }\n            bytes.set(bytesToAdd, offset);\n            return size;\n        }\n    });\n}\nfunction getBitArrayDecoder(size, config = {}) {\n    const parsedConfig = typeof config === \"boolean\" ? {\n        backward: config\n    } : config;\n    const backward = parsedConfig.backward ?? false;\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.createDecoder)({\n        fixedSize: size,\n        read (bytes, offset) {\n            (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.assertByteArrayHasEnoughBytesForCodec)(\"bitArray\", size, bytes, offset);\n            const booleans = [];\n            let slice = bytes.slice(offset, offset + size);\n            slice = backward ? slice.reverse() : slice;\n            slice.forEach((byte)=>{\n                for(let i = 0; i < 8; i += 1){\n                    if (backward) {\n                        booleans.push(Boolean(byte & 1));\n                        byte >>= 1;\n                    } else {\n                        booleans.push(Boolean(byte & 128));\n                        byte <<= 1;\n                    }\n                }\n            });\n            return [\n                booleans,\n                offset + size\n            ];\n        }\n    });\n}\nfunction getBitArrayCodec(size, config = {}) {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getBitArrayEncoder(size, config), getBitArrayDecoder(size, config));\n}\nfunction getBooleanEncoder(config = {}) {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.transformEncoder)(config.size ?? (0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_2__.getU8Encoder)(), (value)=>value ? 1 : 0);\n}\nfunction getBooleanDecoder(config = {}) {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.transformDecoder)(config.size ?? (0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_2__.getU8Decoder)(), (value)=>Number(value) === 1);\n}\nfunction getBooleanCodec(config = {}) {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getBooleanEncoder(config), getBooleanDecoder(config));\n}\nfunction getBytesEncoder() {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.createEncoder)({\n        getSizeFromValue: (value)=>value.length,\n        write: (value, bytes, offset)=>{\n            bytes.set(value, offset);\n            return offset + value.length;\n        }\n    });\n}\nfunction getBytesDecoder() {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.createDecoder)({\n        read: (bytes, offset)=>{\n            const slice = bytes.slice(offset);\n            return [\n                slice,\n                offset + slice.length\n            ];\n        }\n    });\n}\nfunction getBytesCodec() {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getBytesEncoder(), getBytesDecoder());\n}\nvar getBase16Decoder = ()=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.createDecoder)({\n        read (bytes, offset) {\n            const value = bytes.slice(offset).reduce((str, byte)=>str + byte.toString(16).padStart(2, \"0\"), \"\");\n            return [\n                value,\n                bytes.length\n            ];\n        }\n    });\nfunction getConstantEncoder(constant) {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.createEncoder)({\n        fixedSize: constant.length,\n        write: (_, bytes, offset)=>{\n            bytes.set(constant, offset);\n            return offset + constant.length;\n        }\n    });\n}\nfunction getConstantDecoder(constant) {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.createDecoder)({\n        fixedSize: constant.length,\n        read: (bytes, offset)=>{\n            const base16 = getBase16Decoder();\n            if (!(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.containsBytes)(bytes, constant, offset)) {\n                throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__INVALID_CONSTANT, {\n                    constant,\n                    data: bytes,\n                    hexConstant: base16.decode(constant),\n                    hexData: base16.decode(bytes),\n                    offset\n                });\n            }\n            return [\n                void 0,\n                offset + constant.length\n            ];\n        }\n    });\n}\nfunction getConstantCodec(constant) {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getConstantEncoder(constant), getConstantDecoder(constant));\n}\nfunction getTupleEncoder(items) {\n    const fixedSize = sumCodecSizes(items.map(getFixedSize));\n    const maxSize = sumCodecSizes(items.map(getMaxSize)) ?? void 0;\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.createEncoder)({\n        ...fixedSize === null ? {\n            getSizeFromValue: (value)=>items.map((item, index)=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.getEncodedSize)(value[index], item)).reduce((all, one)=>all + one, 0),\n            maxSize\n        } : {\n            fixedSize\n        },\n        write: (value, bytes, offset)=>{\n            assertValidNumberOfItemsForCodec(\"tuple\", items.length, value.length);\n            items.forEach((item, index)=>{\n                offset = item.write(value[index], bytes, offset);\n            });\n            return offset;\n        }\n    });\n}\nfunction getTupleDecoder(items) {\n    const fixedSize = sumCodecSizes(items.map(getFixedSize));\n    const maxSize = sumCodecSizes(items.map(getMaxSize)) ?? void 0;\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.createDecoder)({\n        ...fixedSize === null ? {\n            maxSize\n        } : {\n            fixedSize\n        },\n        read: (bytes, offset)=>{\n            const values = [];\n            items.forEach((item)=>{\n                const [newValue, newOffset] = item.read(bytes, offset);\n                values.push(newValue);\n                offset = newOffset;\n            });\n            return [\n                values,\n                offset\n            ];\n        }\n    });\n}\nfunction getTupleCodec(items) {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getTupleEncoder(items), getTupleDecoder(items));\n}\nfunction getUnionEncoder(variants, getIndexFromValue) {\n    const fixedSize = getUnionFixedSize(variants);\n    const write = (variant, bytes, offset)=>{\n        const index = getIndexFromValue(variant);\n        assertValidVariantIndex(variants, index);\n        return variants[index].write(variant, bytes, offset);\n    };\n    if (fixedSize !== null) {\n        return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.createEncoder)({\n            fixedSize,\n            write\n        });\n    }\n    const maxSize = getUnionMaxSize(variants);\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.createEncoder)({\n        ...maxSize !== null ? {\n            maxSize\n        } : {},\n        getSizeFromValue: (variant)=>{\n            const index = getIndexFromValue(variant);\n            assertValidVariantIndex(variants, index);\n            return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.getEncodedSize)(variant, variants[index]);\n        },\n        write\n    });\n}\nfunction getUnionDecoder(variants, getIndexFromBytes) {\n    const fixedSize = getUnionFixedSize(variants);\n    const read = (bytes, offset)=>{\n        const index = getIndexFromBytes(bytes, offset);\n        assertValidVariantIndex(variants, index);\n        return variants[index].read(bytes, offset);\n    };\n    if (fixedSize !== null) {\n        return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.createDecoder)({\n            fixedSize,\n            read\n        });\n    }\n    const maxSize = getUnionMaxSize(variants);\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.createDecoder)({\n        ...maxSize !== null ? {\n            maxSize\n        } : {},\n        read\n    });\n}\nfunction getUnionCodec(variants, getIndexFromValue, getIndexFromBytes) {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getUnionEncoder(variants, getIndexFromValue), getUnionDecoder(variants, getIndexFromBytes));\n}\nfunction assertValidVariantIndex(variants, index) {\n    if (typeof variants[index] === \"undefined\") {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE, {\n            maxRange: variants.length - 1,\n            minRange: 0,\n            variant: index\n        });\n    }\n}\nfunction getUnionFixedSize(variants) {\n    if (variants.length === 0) return 0;\n    if (!(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.isFixedSize)(variants[0])) return null;\n    const variantSize = variants[0].fixedSize;\n    const sameSizedVariants = variants.every((variant)=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.isFixedSize)(variant) && variant.fixedSize === variantSize);\n    return sameSizedVariants ? variantSize : null;\n}\nfunction getUnionMaxSize(variants) {\n    return maxCodecSizes(variants.map((variant)=>getMaxSize(variant)));\n}\n// src/discriminated-union.ts\nfunction getDiscriminatedUnionEncoder(variants, config = {}) {\n    const discriminatorProperty = config.discriminator ?? \"__kind\";\n    const prefix = config.size ?? (0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_2__.getU8Encoder)();\n    return getUnionEncoder(variants.map(([, variant], index)=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.transformEncoder)(getTupleEncoder([\n            prefix,\n            variant\n        ]), (value)=>[\n                index,\n                value\n            ])), (value)=>getVariantDiscriminator(variants, value[discriminatorProperty]));\n}\nfunction getDiscriminatedUnionDecoder(variants, config = {}) {\n    const discriminatorProperty = config.discriminator ?? \"__kind\";\n    const prefix = config.size ?? (0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_2__.getU8Decoder)();\n    return getUnionDecoder(variants.map(([discriminator, variant])=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.transformDecoder)(getTupleDecoder([\n            prefix,\n            variant\n        ]), ([, value])=>({\n                [discriminatorProperty]: discriminator,\n                ...value\n            }))), (bytes, offset)=>Number(prefix.read(bytes, offset)[0]));\n}\nfunction getDiscriminatedUnionCodec(variants, config = {}) {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getDiscriminatedUnionEncoder(variants, config), getDiscriminatedUnionDecoder(variants, config));\n}\nfunction getVariantDiscriminator(variants, discriminatorValue) {\n    const discriminator = variants.findIndex(([key])=>discriminatorValue === key);\n    if (discriminator < 0) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT, {\n            value: discriminatorValue,\n            variants: variants.map(([key])=>key)\n        });\n    }\n    return discriminator;\n}\n// src/enum-helpers.ts\nfunction getEnumStats(constructor) {\n    const numericalValues = [\n        ...new Set(Object.values(constructor).filter((v)=>typeof v === \"number\"))\n    ].sort();\n    const enumRecord = Object.fromEntries(Object.entries(constructor).slice(numericalValues.length));\n    const enumKeys = Object.keys(enumRecord);\n    const enumValues = Object.values(enumRecord);\n    const stringValues = [\n        .../* @__PURE__ */ new Set([\n            ...enumKeys,\n            ...enumValues.filter((v)=>typeof v === \"string\")\n        ])\n    ];\n    return {\n        enumKeys,\n        enumRecord,\n        enumValues,\n        numericalValues,\n        stringValues\n    };\n}\nfunction getEnumIndexFromVariant({ enumKeys, enumValues, variant }) {\n    const valueIndex = findLastIndex(enumValues, (value)=>value === variant);\n    if (valueIndex >= 0) return valueIndex;\n    return enumKeys.findIndex((key)=>key === variant);\n}\nfunction getEnumIndexFromDiscriminator({ discriminator, enumKeys, enumValues, useValuesAsDiscriminators }) {\n    if (!useValuesAsDiscriminators) {\n        return discriminator >= 0 && discriminator < enumKeys.length ? discriminator : -1;\n    }\n    return findLastIndex(enumValues, (value)=>value === discriminator);\n}\nfunction findLastIndex(array, predicate) {\n    let l = array.length;\n    while(l--){\n        if (predicate(array[l], l, array)) return l;\n    }\n    return -1;\n}\nfunction formatNumericalValues(values) {\n    if (values.length === 0) return \"\";\n    let range = [\n        values[0],\n        values[0]\n    ];\n    const ranges = [];\n    for(let index = 1; index < values.length; index++){\n        const value = values[index];\n        if (range[1] + 1 === value) {\n            range[1] = value;\n        } else {\n            ranges.push(range[0] === range[1] ? `${range[0]}` : `${range[0]}-${range[1]}`);\n            range = [\n                value,\n                value\n            ];\n        }\n    }\n    ranges.push(range[0] === range[1] ? `${range[0]}` : `${range[0]}-${range[1]}`);\n    return ranges.join(\", \");\n}\n// src/enum.ts\nfunction getEnumEncoder(constructor, config = {}) {\n    const prefix = config.size ?? (0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_2__.getU8Encoder)();\n    const useValuesAsDiscriminators = config.useValuesAsDiscriminators ?? false;\n    const { enumKeys, enumValues, numericalValues, stringValues } = getEnumStats(constructor);\n    if (useValuesAsDiscriminators && enumValues.some((value)=>typeof value === \"string\")) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS, {\n            stringValues: enumValues.filter((v)=>typeof v === \"string\")\n        });\n    }\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.transformEncoder)(prefix, (variant)=>{\n        const index = getEnumIndexFromVariant({\n            enumKeys,\n            enumValues,\n            variant\n        });\n        if (index < 0) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT, {\n                formattedNumericalValues: formatNumericalValues(numericalValues),\n                numericalValues,\n                stringValues,\n                variant\n            });\n        }\n        return useValuesAsDiscriminators ? enumValues[index] : index;\n    });\n}\nfunction getEnumDecoder(constructor, config = {}) {\n    const prefix = config.size ?? (0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_2__.getU8Decoder)();\n    const useValuesAsDiscriminators = config.useValuesAsDiscriminators ?? false;\n    const { enumKeys, enumValues, numericalValues } = getEnumStats(constructor);\n    if (useValuesAsDiscriminators && enumValues.some((value)=>typeof value === \"string\")) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS, {\n            stringValues: enumValues.filter((v)=>typeof v === \"string\")\n        });\n    }\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.transformDecoder)(prefix, (value)=>{\n        const discriminator = Number(value);\n        const index = getEnumIndexFromDiscriminator({\n            discriminator,\n            enumKeys,\n            enumValues,\n            useValuesAsDiscriminators\n        });\n        if (index < 0) {\n            const validDiscriminators = useValuesAsDiscriminators ? numericalValues : [\n                ...Array(enumKeys.length).keys()\n            ];\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE, {\n                discriminator,\n                formattedValidDiscriminators: formatNumericalValues(validDiscriminators),\n                validDiscriminators\n            });\n        }\n        return enumValues[index];\n    });\n}\nfunction getEnumCodec(constructor, config = {}) {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getEnumEncoder(constructor, config), getEnumDecoder(constructor, config));\n}\nfunction getHiddenPrefixEncoder(encoder, prefixedEncoders) {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.transformEncoder)(getTupleEncoder([\n        ...prefixedEncoders,\n        encoder\n    ]), (value)=>[\n            ...prefixedEncoders.map(()=>void 0),\n            value\n        ]);\n}\nfunction getHiddenPrefixDecoder(decoder, prefixedDecoders) {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.transformDecoder)(getTupleDecoder([\n        ...prefixedDecoders,\n        decoder\n    ]), (tuple)=>tuple[tuple.length - 1]);\n}\nfunction getHiddenPrefixCodec(codec, prefixedCodecs) {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getHiddenPrefixEncoder(codec, prefixedCodecs), getHiddenPrefixDecoder(codec, prefixedCodecs));\n}\nfunction getHiddenSuffixEncoder(encoder, suffixedEncoders) {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.transformEncoder)(getTupleEncoder([\n        encoder,\n        ...suffixedEncoders\n    ]), (value)=>[\n            value,\n            ...suffixedEncoders.map(()=>void 0)\n        ]);\n}\nfunction getHiddenSuffixDecoder(decoder, suffixedDecoders) {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.transformDecoder)(getTupleDecoder([\n        decoder,\n        ...suffixedDecoders\n    ]), (tuple)=>tuple[0]);\n}\nfunction getHiddenSuffixCodec(codec, suffixedCodecs) {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getHiddenSuffixEncoder(codec, suffixedCodecs), getHiddenSuffixDecoder(codec, suffixedCodecs));\n}\nfunction getLiteralUnionEncoder(variants, config = {}) {\n    const discriminator = config.size ?? (0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_2__.getU8Encoder)();\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.transformEncoder)(discriminator, (variant)=>{\n        const index = variants.indexOf(variant);\n        if (index < 0) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT, {\n                value: variant,\n                variants\n            });\n        }\n        return index;\n    });\n}\nfunction getLiteralUnionDecoder(variants, config = {}) {\n    const discriminator = config.size ?? (0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_2__.getU8Decoder)();\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.transformDecoder)(discriminator, (index)=>{\n        if (index < 0 || index >= variants.length) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE, {\n                discriminator: index,\n                maxRange: variants.length - 1,\n                minRange: 0\n            });\n        }\n        return variants[Number(index)];\n    });\n}\nfunction getLiteralUnionCodec(variants, config = {}) {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getLiteralUnionEncoder(variants, config), getLiteralUnionDecoder(variants, config));\n}\nfunction getMapEncoder(key, value, config = {}) {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.transformEncoder)(getArrayEncoder(getTupleEncoder([\n        key,\n        value\n    ]), config), (map)=>[\n            ...map.entries()\n        ]);\n}\nfunction getMapDecoder(key, value, config = {}) {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.transformDecoder)(getArrayDecoder(getTupleDecoder([\n        key,\n        value\n    ]), config), (entries)=>new Map(entries));\n}\nfunction getMapCodec(key, value, config = {}) {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getMapEncoder(key, value, config), getMapDecoder(key, value, config));\n}\nfunction getUnitEncoder() {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.createEncoder)({\n        fixedSize: 0,\n        write: (_value, _bytes, offset)=>offset\n    });\n}\nfunction getUnitDecoder() {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.createDecoder)({\n        fixedSize: 0,\n        read: (_bytes, offset)=>[\n                void 0,\n                offset\n            ]\n    });\n}\nfunction getUnitCodec() {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getUnitEncoder(), getUnitDecoder());\n}\n// src/nullable.ts\nfunction getNullableEncoder(item, config = {}) {\n    const prefix = (()=>{\n        if (config.prefix === null) {\n            return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.transformEncoder)(getUnitEncoder(), (_boolean)=>void 0);\n        }\n        return getBooleanEncoder({\n            size: config.prefix ?? (0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_2__.getU8Encoder)()\n        });\n    })();\n    const noneValue = (()=>{\n        if (config.noneValue === \"zeroes\") {\n            (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.assertIsFixedSize)(item);\n            return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.fixEncoderSize)(getUnitEncoder(), item.fixedSize);\n        }\n        if (!config.noneValue) {\n            return getUnitEncoder();\n        }\n        return getConstantEncoder(config.noneValue);\n    })();\n    return getUnionEncoder([\n        (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.transformEncoder)(getTupleEncoder([\n            prefix,\n            noneValue\n        ]), (_value)=>[\n                false,\n                void 0\n            ]),\n        (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.transformEncoder)(getTupleEncoder([\n            prefix,\n            item\n        ]), (value)=>[\n                true,\n                value\n            ])\n    ], (variant)=>Number(variant !== null));\n}\nfunction getNullableDecoder(item, config = {}) {\n    const prefix = (()=>{\n        if (config.prefix === null) {\n            return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.transformDecoder)(getUnitDecoder(), ()=>false);\n        }\n        return getBooleanDecoder({\n            size: config.prefix ?? (0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_2__.getU8Decoder)()\n        });\n    })();\n    const noneValue = (()=>{\n        if (config.noneValue === \"zeroes\") {\n            (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.assertIsFixedSize)(item);\n            return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.fixDecoderSize)(getUnitDecoder(), item.fixedSize);\n        }\n        if (!config.noneValue) {\n            return getUnitDecoder();\n        }\n        return getConstantDecoder(config.noneValue);\n    })();\n    return getUnionDecoder([\n        (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.transformDecoder)(getTupleDecoder([\n            prefix,\n            noneValue\n        ]), ()=>null),\n        (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.transformDecoder)(getTupleDecoder([\n            prefix,\n            item\n        ]), ([, value])=>value)\n    ], (bytes, offset)=>{\n        if (config.prefix === null && !config.noneValue) {\n            return Number(offset < bytes.length);\n        }\n        if (config.prefix === null && config.noneValue != null) {\n            const zeroValue = config.noneValue === \"zeroes\" ? new Uint8Array(noneValue.fixedSize).fill(0) : config.noneValue;\n            return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.containsBytes)(bytes, zeroValue, offset) ? 0 : 1;\n        }\n        return Number(prefix.read(bytes, offset)[0]);\n    });\n}\nfunction getNullableCodec(item, config = {}) {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getNullableEncoder(item, config), getNullableDecoder(item, config));\n}\nfunction getSetEncoder(item, config = {}) {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.transformEncoder)(getArrayEncoder(item, config), (set)=>[\n            ...set\n        ]);\n}\nfunction getSetDecoder(item, config = {}) {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.transformDecoder)(getArrayDecoder(item, config), (entries)=>new Set(entries));\n}\nfunction getSetCodec(item, config = {}) {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getSetEncoder(item, config), getSetDecoder(item, config));\n}\nfunction getStructEncoder(fields) {\n    const fieldCodecs = fields.map(([, codec])=>codec);\n    const fixedSize = sumCodecSizes(fieldCodecs.map(getFixedSize));\n    const maxSize = sumCodecSizes(fieldCodecs.map(getMaxSize)) ?? void 0;\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.createEncoder)({\n        ...fixedSize === null ? {\n            getSizeFromValue: (value)=>fields.map(([key, codec])=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.getEncodedSize)(value[key], codec)).reduce((all, one)=>all + one, 0),\n            maxSize\n        } : {\n            fixedSize\n        },\n        write: (struct, bytes, offset)=>{\n            fields.forEach(([key, codec])=>{\n                offset = codec.write(struct[key], bytes, offset);\n            });\n            return offset;\n        }\n    });\n}\nfunction getStructDecoder(fields) {\n    const fieldCodecs = fields.map(([, codec])=>codec);\n    const fixedSize = sumCodecSizes(fieldCodecs.map(getFixedSize));\n    const maxSize = sumCodecSizes(fieldCodecs.map(getMaxSize)) ?? void 0;\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.createDecoder)({\n        ...fixedSize === null ? {\n            maxSize\n        } : {\n            fixedSize\n        },\n        read: (bytes, offset)=>{\n            const struct = {};\n            fields.forEach(([key, codec])=>{\n                const [value, newOffset] = codec.read(bytes, offset);\n                offset = newOffset;\n                struct[key] = value;\n            });\n            return [\n                struct,\n                offset\n            ];\n        }\n    });\n}\nfunction getStructCodec(fields) {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getStructEncoder(fields), getStructDecoder(fields));\n}\n //# sourceMappingURL=index.node.mjs.map\n //# sourceMappingURL=index.node.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS9jb2RlY3MtZGF0YS1zdHJ1Y3R1cmVzL2Rpc3QvaW5kZXgubm9kZS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEyUDtBQUN6SjtBQUMrYTtBQUVqaEIsZUFBZTtBQUNmLFNBQVMwQixpQ0FBaUNDLGdCQUFnQixFQUFFQyxRQUFRLEVBQUVDLE1BQU07SUFDMUUsSUFBSUQsYUFBYUMsUUFBUTtRQUN2QixNQUFNLElBQUliLHVEQUFXQSxDQUFDQyx5RkFBNkNBLEVBQUU7WUFDbkVZO1lBQ0FGO1lBQ0FDO1FBQ0Y7SUFDRjtBQUNGO0FBQ0EsU0FBU0UsY0FBY0MsS0FBSztJQUMxQixPQUFPQSxNQUFNQyxNQUFNLENBQ2pCLENBQUNDLEtBQUtDLE9BQVNELFFBQVEsUUFBUUMsU0FBUyxPQUFPLE9BQU9DLEtBQUtDLEdBQUcsQ0FBQ0gsS0FBS0MsT0FDcEU7QUFFSjtBQUNBLFNBQVNHLGNBQWNOLEtBQUs7SUFDMUIsT0FBT0EsTUFBTUMsTUFBTSxDQUFDLENBQUNDLEtBQUtDLE9BQVNELFFBQVEsUUFBUUMsU0FBUyxPQUFPLE9BQU9ELE1BQU1DLE1BQU07QUFDeEY7QUFDQSxTQUFTSSxhQUFhQyxLQUFLO0lBQ3pCLE9BQU8vQixnRUFBV0EsQ0FBQytCLFNBQVNBLE1BQU1DLFNBQVMsR0FBRztBQUNoRDtBQUNBLFNBQVNDLFdBQVdGLEtBQUs7SUFDdkIsT0FBTy9CLGdFQUFXQSxDQUFDK0IsU0FBU0EsTUFBTUMsU0FBUyxHQUFHRCxNQUFNRyxPQUFPLElBQUk7QUFDakU7QUFFQSxlQUFlO0FBQ2YsU0FBU0MsZ0JBQWdCQyxJQUFJLEVBQUVDLFNBQVMsQ0FBQyxDQUFDO0lBQ3hDLE1BQU1YLE9BQU9XLE9BQU9YLElBQUksSUFBSXRCLHFFQUFhQTtJQUN6QyxNQUFNNEIsWUFBWU0sMEJBQTBCWixNQUFNSSxhQUFhTTtJQUMvRCxN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QVlILGNBQWM2SyxZQUFZM0csR0FBRyxDQUFDakU7SUFDaEQsTUFBTUksVUFBVUwsY0FBYzZLLFlBQVkzRyxHQUFHLENBQUM5RCxnQkFBZ0IsS0FBSztJQUNuRSxPQUFPdkMsa0VBQWFBLENBQUM7UUFDbkIsR0FBR3NDLGNBQWMsT0FBTztZQUFFRTtRQUFRLElBQUk7WUFBRUY7UUFBVSxDQUFDO1FBQ25Ea0IsTUFBTSxDQUFDTCxPQUFPQztZQUNaLE1BQU02SixTQUFTLENBQUM7WUFDaEJGLE9BQU8xSixPQUFPLENBQUMsQ0FBQyxDQUFDK0UsS0FBSy9GLE1BQU07Z0JBQzFCLE1BQU0sQ0FBQ1ksT0FBT1ksVUFBVSxHQUFHeEIsTUFBTW1CLElBQUksQ0FBQ0wsT0FBT0M7Z0JBQzdDQSxTQUFTUztnQkFDVG9KLE1BQU0sQ0FBQzdFLElBQUksR0FBR25GO1lBQ2hCO1lBQ0EsT0FBTztnQkFBQ2dLO2dCQUFRN0o7YUFBTztRQUN6QjtJQUNGO0FBQ0Y7QUFDQSxTQUFTK0osZUFBZUosTUFBTTtJQUM1QixPQUFPOU0saUVBQVlBLENBQ2pCNk0saUJBQWlCQyxTQUNqQkcsaUJBQWlCSDtBQUVyQjtBQUVxK0IsQ0FDcitCLHVDQUF1QztDQUN2Qyx1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGF3LXdvcmtzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvY29kZWNzLWRhdGEtc3RydWN0dXJlcy9kaXN0L2luZGV4Lm5vZGUubWpzPzBiYTgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlRW5jb2RlciwgZ2V0RW5jb2RlZFNpemUsIGNyZWF0ZURlY29kZXIsIGNvbWJpbmVDb2RlYywgYXNzZXJ0Qnl0ZUFycmF5SGFzRW5vdWdoQnl0ZXNGb3JDb2RlYywgdHJhbnNmb3JtRW5jb2RlciwgdHJhbnNmb3JtRGVjb2RlciwgY29udGFpbnNCeXRlcywgaXNGaXhlZFNpemUsIGFzc2VydElzRml4ZWRTaXplLCBmaXhFbmNvZGVyU2l6ZSwgZml4RGVjb2RlclNpemUgfSBmcm9tICdAc29sYW5hL2NvZGVjcy1jb3JlJztcbmltcG9ydCB7IGdldFUzMkVuY29kZXIsIGdldFUzMkRlY29kZXIsIGdldFU4RW5jb2RlciwgZ2V0VThEZWNvZGVyIH0gZnJvbSAnQHNvbGFuYS9jb2RlY3MtbnVtYmVycyc7XG5pbXBvcnQgeyBTb2xhbmFFcnJvciwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfTlVNQkVSX09GX0lURU1TLCBTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9DT05TVEFOVCwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX1VOSU9OX1ZBUklBTlRfT1VUX09GX1JBTkdFLCBTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9ESVNDUklNSU5BVEVEX1VOSU9OX1ZBUklBTlQsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19DQU5OT1RfVVNFX0xFWElDQUxfVkFMVUVTX0FTX0VOVU1fRElTQ1JJTUlOQVRPUlMsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0VOVU1fVkFSSUFOVCwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOVU1fRElTQ1JJTUlOQVRPUl9PVVRfT0ZfUkFOR0UsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0xJVEVSQUxfVU5JT05fVkFSSUFOVCwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0xJVEVSQUxfVU5JT05fRElTQ1JJTUlOQVRPUl9PVVRfT0ZfUkFOR0UgfSBmcm9tICdAc29sYW5hL2Vycm9ycyc7XG5cbi8vIHNyYy9hcnJheS50c1xuZnVuY3Rpb24gYXNzZXJ0VmFsaWROdW1iZXJPZkl0ZW1zRm9yQ29kZWMoY29kZWNEZXNjcmlwdGlvbiwgZXhwZWN0ZWQsIGFjdHVhbCkge1xuICBpZiAoZXhwZWN0ZWQgIT09IGFjdHVhbCkge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9OVU1CRVJfT0ZfSVRFTVMsIHtcbiAgICAgIGFjdHVhbCxcbiAgICAgIGNvZGVjRGVzY3JpcHRpb24sXG4gICAgICBleHBlY3RlZFxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBtYXhDb2RlY1NpemVzKHNpemVzKSB7XG4gIHJldHVybiBzaXplcy5yZWR1Y2UoXG4gICAgKGFsbCwgc2l6ZSkgPT4gYWxsID09PSBudWxsIHx8IHNpemUgPT09IG51bGwgPyBudWxsIDogTWF0aC5tYXgoYWxsLCBzaXplKSxcbiAgICAwXG4gICk7XG59XG5mdW5jdGlvbiBzdW1Db2RlY1NpemVzKHNpemVzKSB7XG4gIHJldHVybiBzaXplcy5yZWR1Y2UoKGFsbCwgc2l6ZSkgPT4gYWxsID09PSBudWxsIHx8IHNpemUgPT09IG51bGwgPyBudWxsIDogYWxsICsgc2l6ZSwgMCk7XG59XG5mdW5jdGlvbiBnZXRGaXhlZFNpemUoY29kZWMpIHtcbiAgcmV0dXJuIGlzRml4ZWRTaXplKGNvZGVjKSA/IGNvZGVjLmZpeGVkU2l6ZSA6IG51bGw7XG59XG5mdW5jdGlvbiBnZXRNYXhTaXplKGNvZGVjKSB7XG4gIHJldHVybiBpc0ZpeGVkU2l6ZShjb2RlYykgPyBjb2RlYy5maXhlZFNpemUgOiBjb2RlYy5tYXhTaXplID8/IG51bGw7XG59XG5cbi8vIHNyYy9hcnJheS50c1xuZnVuY3Rpb24gZ2V0QXJyYXlFbmNvZGVyKGl0ZW0sIGNvbmZpZyA9IHt9KSB7XG4gIGNvbnN0IHNpemUgPSBjb25maWcuc2l6ZSA/PyBnZXRVMzJFbmNvZGVyKCk7XG4gIGNvbnN0IGZpeGVkU2l6ZSA9IGNvbXB1dGVBcnJheUxpa2VDb2RlY1NpemUoc2l6ZSwgZ2V0Rml4ZWRTaXplKGl0ZW0pKTtcbiAgY29uc3QgbWF4U2l6ZSA9IGNvbXB1dGVBcnJheUxpa2VDb2RlY1NpemUoc2l6ZSwgZ2V0TWF4U2l6ZShpdGVtKSkgPz8gdm9pZCAwO1xuICByZXR1cm4gY3JlYXRlRW5jb2Rlcih7XG4gICAgLi4uZml4ZWRTaXplICE9PSBudWxsID8geyBmaXhlZFNpemUgfSA6IHtcbiAgICAgIGdldFNpemVGcm9tVmFsdWU6IChhcnJheSkgPT4ge1xuICAgICAgICBjb25zdCBwcmVmaXhTaXplID0gdHlwZW9mIHNpemUgPT09IFwib2JqZWN0XCIgPyBnZXRFbmNvZGVkU2l6ZShhcnJheS5sZW5ndGgsIHNpemUpIDogMDtcbiAgICAgICAgcmV0dXJuIHByZWZpeFNpemUgKyBbLi4uYXJyYXldLnJlZHVjZSgoYWxsLCB2YWx1ZSkgPT4gYWxsICsgZ2V0RW5jb2RlZFNpemUodmFsdWUsIGl0ZW0pLCAwKTtcbiAgICAgIH0sXG4gICAgICBtYXhTaXplXG4gICAgfSxcbiAgICB3cml0ZTogKGFycmF5LCBieXRlcywgb2Zmc2V0KSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHNpemUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgYXNzZXJ0VmFsaWROdW1iZXJPZkl0ZW1zRm9yQ29kZWMoXCJhcnJheVwiLCBzaXplLCBhcnJheS5sZW5ndGgpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBzaXplID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIG9mZnNldCA9IHNpemUud3JpdGUoYXJyYXkubGVuZ3RoLCBieXRlcywgb2Zmc2V0KTtcbiAgICAgIH1cbiAgICAgIGFycmF5LmZvckVhY2goKHZhbHVlKSA9PiB7XG4gICAgICAgIG9mZnNldCA9IGl0ZW0ud3JpdGUodmFsdWUsIGJ5dGVzLCBvZmZzZXQpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRBcnJheURlY29kZXIoaXRlbSwgY29uZmlnID0ge30pIHtcbiAgY29uc3Qgc2l6ZSA9IGNvbmZpZy5zaXplID8/IGdldFUzMkRlY29kZXIoKTtcbiAgY29uc3QgaXRlbVNpemUgPSBnZXRGaXhlZFNpemUoaXRlbSk7XG4gIGNvbnN0IGZpeGVkU2l6ZSA9IGNvbXB1dGVBcnJheUxpa2VDb2RlY1NpemUoc2l6ZSwgaXRlbVNpemUpO1xuICBjb25zdCBtYXhTaXplID0gY29tcHV0ZUFycmF5TGlrZUNvZGVjU2l6ZShzaXplLCBnZXRNYXhTaXplKGl0ZW0pKSA/PyB2b2lkIDA7XG4gIHJldHVybiBjcmVhdGVEZWNvZGVyKHtcbiAgICAuLi5maXhlZFNpemUgIT09IG51bGwgPyB7IGZpeGVkU2l6ZSB9IDogeyBtYXhTaXplIH0sXG4gICAgcmVhZDogKGJ5dGVzLCBvZmZzZXQpID0+IHtcbiAgICAgIGNvbnN0IGFycmF5ID0gW107XG4gICAgICBpZiAodHlwZW9mIHNpemUgPT09IFwib2JqZWN0XCIgJiYgYnl0ZXMuc2xpY2Uob2Zmc2V0KS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFthcnJheSwgb2Zmc2V0XTtcbiAgICAgIH1cbiAgICAgIGlmIChzaXplID09PSBcInJlbWFpbmRlclwiKSB7XG4gICAgICAgIHdoaWxlIChvZmZzZXQgPCBieXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCBbdmFsdWUsIG5ld09mZnNldDJdID0gaXRlbS5yZWFkKGJ5dGVzLCBvZmZzZXQpO1xuICAgICAgICAgIG9mZnNldCA9IG5ld09mZnNldDI7XG4gICAgICAgICAgYXJyYXkucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFthcnJheSwgb2Zmc2V0XTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IFtyZXNvbHZlZFNpemUsIG5ld09mZnNldF0gPSB0eXBlb2Ygc2l6ZSA9PT0gXCJudW1iZXJcIiA/IFtzaXplLCBvZmZzZXRdIDogc2l6ZS5yZWFkKGJ5dGVzLCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ID0gbmV3T2Zmc2V0O1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXNvbHZlZFNpemU7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBbdmFsdWUsIG5ld09mZnNldDJdID0gaXRlbS5yZWFkKGJ5dGVzLCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgPSBuZXdPZmZzZXQyO1xuICAgICAgICBhcnJheS5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbYXJyYXksIG9mZnNldF07XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGdldEFycmF5Q29kZWMoaXRlbSwgY29uZmlnID0ge30pIHtcbiAgcmV0dXJuIGNvbWJpbmVDb2RlYyhnZXRBcnJheUVuY29kZXIoaXRlbSwgY29uZmlnKSwgZ2V0QXJyYXlEZWNvZGVyKGl0ZW0sIGNvbmZpZykpO1xufVxuZnVuY3Rpb24gY29tcHV0ZUFycmF5TGlrZUNvZGVjU2l6ZShzaXplLCBpdGVtU2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09IFwibnVtYmVyXCIpIHJldHVybiBudWxsO1xuICBpZiAoc2l6ZSA9PT0gMCkgcmV0dXJuIDA7XG4gIHJldHVybiBpdGVtU2l6ZSA9PT0gbnVsbCA/IG51bGwgOiBpdGVtU2l6ZSAqIHNpemU7XG59XG5mdW5jdGlvbiBnZXRCaXRBcnJheUVuY29kZXIoc2l6ZSwgY29uZmlnID0ge30pIHtcbiAgY29uc3QgcGFyc2VkQ29uZmlnID0gdHlwZW9mIGNvbmZpZyA9PT0gXCJib29sZWFuXCIgPyB7IGJhY2t3YXJkOiBjb25maWcgfSA6IGNvbmZpZztcbiAgY29uc3QgYmFja3dhcmQgPSBwYXJzZWRDb25maWcuYmFja3dhcmQgPz8gZmFsc2U7XG4gIHJldHVybiBjcmVhdGVFbmNvZGVyKHtcbiAgICBmaXhlZFNpemU6IHNpemUsXG4gICAgd3JpdGUodmFsdWUsIGJ5dGVzLCBvZmZzZXQpIHtcbiAgICAgIGNvbnN0IGJ5dGVzVG9BZGQgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSArPSAxKSB7XG4gICAgICAgIGxldCBieXRlID0gMDtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCA4OyBqICs9IDEpIHtcbiAgICAgICAgICBjb25zdCBmZWF0dXJlID0gTnVtYmVyKHZhbHVlW2kgKiA4ICsgal0gPz8gMCk7XG4gICAgICAgICAgYnl0ZSB8PSBmZWF0dXJlIDw8IChiYWNrd2FyZCA/IGogOiA3IC0gaik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJhY2t3YXJkKSB7XG4gICAgICAgICAgYnl0ZXNUb0FkZC51bnNoaWZ0KGJ5dGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJ5dGVzVG9BZGQucHVzaChieXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnl0ZXMuc2V0KGJ5dGVzVG9BZGQsIG9mZnNldCk7XG4gICAgICByZXR1cm4gc2l6ZTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0Qml0QXJyYXlEZWNvZGVyKHNpemUsIGNvbmZpZyA9IHt9KSB7XG4gIGNvbnN0IHBhcnNlZENvbmZpZyA9IHR5cGVvZiBjb25maWcgPT09IFwiYm9vbGVhblwiID8geyBiYWNrd2FyZDogY29uZmlnIH0gOiBjb25maWc7XG4gIGNvbnN0IGJhY2t3YXJkID0gcGFyc2VkQ29uZmlnLmJhY2t3YXJkID8/IGZhbHNlO1xuICByZXR1cm4gY3JlYXRlRGVjb2Rlcih7XG4gICAgZml4ZWRTaXplOiBzaXplLFxuICAgIHJlYWQoYnl0ZXMsIG9mZnNldCkge1xuICAgICAgYXNzZXJ0Qnl0ZUFycmF5SGFzRW5vdWdoQnl0ZXNGb3JDb2RlYyhcImJpdEFycmF5XCIsIHNpemUsIGJ5dGVzLCBvZmZzZXQpO1xuICAgICAgY29uc3QgYm9vbGVhbnMgPSBbXTtcbiAgICAgIGxldCBzbGljZSA9IGJ5dGVzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgc2l6ZSk7XG4gICAgICBzbGljZSA9IGJhY2t3YXJkID8gc2xpY2UucmV2ZXJzZSgpIDogc2xpY2U7XG4gICAgICBzbGljZS5mb3JFYWNoKChieXRlKSA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSArPSAxKSB7XG4gICAgICAgICAgaWYgKGJhY2t3YXJkKSB7XG4gICAgICAgICAgICBib29sZWFucy5wdXNoKEJvb2xlYW4oYnl0ZSAmIDEpKTtcbiAgICAgICAgICAgIGJ5dGUgPj49IDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJvb2xlYW5zLnB1c2goQm9vbGVhbihieXRlICYgMTI4KSk7XG4gICAgICAgICAgICBieXRlIDw8PSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gW2Jvb2xlYW5zLCBvZmZzZXQgKyBzaXplXTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0Qml0QXJyYXlDb2RlYyhzaXplLCBjb25maWcgPSB7fSkge1xuICByZXR1cm4gY29tYmluZUNvZGVjKGdldEJpdEFycmF5RW5jb2RlcihzaXplLCBjb25maWcpLCBnZXRCaXRBcnJheURlY29kZXIoc2l6ZSwgY29uZmlnKSk7XG59XG5mdW5jdGlvbiBnZXRCb29sZWFuRW5jb2Rlcihjb25maWcgPSB7fSkge1xuICByZXR1cm4gdHJhbnNmb3JtRW5jb2Rlcihjb25maWcuc2l6ZSA/PyBnZXRVOEVuY29kZXIoKSwgKHZhbHVlKSA9PiB2YWx1ZSA/IDEgOiAwKTtcbn1cbmZ1bmN0aW9uIGdldEJvb2xlYW5EZWNvZGVyKGNvbmZpZyA9IHt9KSB7XG4gIHJldHVybiB0cmFuc2Zvcm1EZWNvZGVyKGNvbmZpZy5zaXplID8/IGdldFU4RGVjb2RlcigpLCAodmFsdWUpID0+IE51bWJlcih2YWx1ZSkgPT09IDEpO1xufVxuZnVuY3Rpb24gZ2V0Qm9vbGVhbkNvZGVjKGNvbmZpZyA9IHt9KSB7XG4gIHJldHVybiBjb21iaW5lQ29kZWMoZ2V0Qm9vbGVhbkVuY29kZXIoY29uZmlnKSwgZ2V0Qm9vbGVhbkRlY29kZXIoY29uZmlnKSk7XG59XG5mdW5jdGlvbiBnZXRCeXRlc0VuY29kZXIoKSB7XG4gIHJldHVybiBjcmVhdGVFbmNvZGVyKHtcbiAgICBnZXRTaXplRnJvbVZhbHVlOiAodmFsdWUpID0+IHZhbHVlLmxlbmd0aCxcbiAgICB3cml0ZTogKHZhbHVlLCBieXRlcywgb2Zmc2V0KSA9PiB7XG4gICAgICBieXRlcy5zZXQodmFsdWUsIG9mZnNldCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ICsgdmFsdWUubGVuZ3RoO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRCeXRlc0RlY29kZXIoKSB7XG4gIHJldHVybiBjcmVhdGVEZWNvZGVyKHtcbiAgICByZWFkOiAoYnl0ZXMsIG9mZnNldCkgPT4ge1xuICAgICAgY29uc3Qgc2xpY2UgPSBieXRlcy5zbGljZShvZmZzZXQpO1xuICAgICAgcmV0dXJuIFtzbGljZSwgb2Zmc2V0ICsgc2xpY2UubGVuZ3RoXTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0Qnl0ZXNDb2RlYygpIHtcbiAgcmV0dXJuIGNvbWJpbmVDb2RlYyhnZXRCeXRlc0VuY29kZXIoKSwgZ2V0Qnl0ZXNEZWNvZGVyKCkpO1xufVxudmFyIGdldEJhc2UxNkRlY29kZXIgPSAoKSA9PiBjcmVhdGVEZWNvZGVyKHtcbiAgcmVhZChieXRlcywgb2Zmc2V0KSB7XG4gICAgY29uc3QgdmFsdWUgPSBieXRlcy5zbGljZShvZmZzZXQpLnJlZHVjZSgoc3RyLCBieXRlKSA9PiBzdHIgKyBieXRlLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIiksIFwiXCIpO1xuICAgIHJldHVybiBbdmFsdWUsIGJ5dGVzLmxlbmd0aF07XG4gIH1cbn0pO1xuZnVuY3Rpb24gZ2V0Q29uc3RhbnRFbmNvZGVyKGNvbnN0YW50KSB7XG4gIHJldHVybiBjcmVhdGVFbmNvZGVyKHtcbiAgICBmaXhlZFNpemU6IGNvbnN0YW50Lmxlbmd0aCxcbiAgICB3cml0ZTogKF8sIGJ5dGVzLCBvZmZzZXQpID0+IHtcbiAgICAgIGJ5dGVzLnNldChjb25zdGFudCwgb2Zmc2V0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgKyBjb25zdGFudC5sZW5ndGg7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGdldENvbnN0YW50RGVjb2Rlcihjb25zdGFudCkge1xuICByZXR1cm4gY3JlYXRlRGVjb2Rlcih7XG4gICAgZml4ZWRTaXplOiBjb25zdGFudC5sZW5ndGgsXG4gICAgcmVhZDogKGJ5dGVzLCBvZmZzZXQpID0+IHtcbiAgICAgIGNvbnN0IGJhc2UxNiA9IGdldEJhc2UxNkRlY29kZXIoKTtcbiAgICAgIGlmICghY29udGFpbnNCeXRlcyhieXRlcywgY29uc3RhbnQsIG9mZnNldCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0NPTlNUQU5ULCB7XG4gICAgICAgICAgY29uc3RhbnQsXG4gICAgICAgICAgZGF0YTogYnl0ZXMsXG4gICAgICAgICAgaGV4Q29uc3RhbnQ6IGJhc2UxNi5kZWNvZGUoY29uc3RhbnQpLFxuICAgICAgICAgIGhleERhdGE6IGJhc2UxNi5kZWNvZGUoYnl0ZXMpLFxuICAgICAgICAgIG9mZnNldFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbdm9pZCAwLCBvZmZzZXQgKyBjb25zdGFudC5sZW5ndGhdO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRDb25zdGFudENvZGVjKGNvbnN0YW50KSB7XG4gIHJldHVybiBjb21iaW5lQ29kZWMoZ2V0Q29uc3RhbnRFbmNvZGVyKGNvbnN0YW50KSwgZ2V0Q29uc3RhbnREZWNvZGVyKGNvbnN0YW50KSk7XG59XG5mdW5jdGlvbiBnZXRUdXBsZUVuY29kZXIoaXRlbXMpIHtcbiAgY29uc3QgZml4ZWRTaXplID0gc3VtQ29kZWNTaXplcyhpdGVtcy5tYXAoZ2V0Rml4ZWRTaXplKSk7XG4gIGNvbnN0IG1heFNpemUgPSBzdW1Db2RlY1NpemVzKGl0ZW1zLm1hcChnZXRNYXhTaXplKSkgPz8gdm9pZCAwO1xuICByZXR1cm4gY3JlYXRlRW5jb2Rlcih7XG4gICAgLi4uZml4ZWRTaXplID09PSBudWxsID8ge1xuICAgICAgZ2V0U2l6ZUZyb21WYWx1ZTogKHZhbHVlKSA9PiBpdGVtcy5tYXAoKGl0ZW0sIGluZGV4KSA9PiBnZXRFbmNvZGVkU2l6ZSh2YWx1ZVtpbmRleF0sIGl0ZW0pKS5yZWR1Y2UoKGFsbCwgb25lKSA9PiBhbGwgKyBvbmUsIDApLFxuICAgICAgbWF4U2l6ZVxuICAgIH0gOiB7IGZpeGVkU2l6ZSB9LFxuICAgIHdyaXRlOiAodmFsdWUsIGJ5dGVzLCBvZmZzZXQpID0+IHtcbiAgICAgIGFzc2VydFZhbGlkTnVtYmVyT2ZJdGVtc0ZvckNvZGVjKFwidHVwbGVcIiwgaXRlbXMubGVuZ3RoLCB2YWx1ZS5sZW5ndGgpO1xuICAgICAgaXRlbXMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgb2Zmc2V0ID0gaXRlbS53cml0ZSh2YWx1ZVtpbmRleF0sIGJ5dGVzLCBvZmZzZXQpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRUdXBsZURlY29kZXIoaXRlbXMpIHtcbiAgY29uc3QgZml4ZWRTaXplID0gc3VtQ29kZWNTaXplcyhpdGVtcy5tYXAoZ2V0Rml4ZWRTaXplKSk7XG4gIGNvbnN0IG1heFNpemUgPSBzdW1Db2RlY1NpemVzKGl0ZW1zLm1hcChnZXRNYXhTaXplKSkgPz8gdm9pZCAwO1xuICByZXR1cm4gY3JlYXRlRGVjb2Rlcih7XG4gICAgLi4uZml4ZWRTaXplID09PSBudWxsID8geyBtYXhTaXplIH0gOiB7IGZpeGVkU2l6ZSB9LFxuICAgIHJlYWQ6IChieXRlcywgb2Zmc2V0KSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICAgIGl0ZW1zLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgY29uc3QgW25ld1ZhbHVlLCBuZXdPZmZzZXRdID0gaXRlbS5yZWFkKGJ5dGVzLCBvZmZzZXQpO1xuICAgICAgICB2YWx1ZXMucHVzaChuZXdWYWx1ZSk7XG4gICAgICAgIG9mZnNldCA9IG5ld09mZnNldDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFt2YWx1ZXMsIG9mZnNldF07XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGdldFR1cGxlQ29kZWMoaXRlbXMpIHtcbiAgcmV0dXJuIGNvbWJpbmVDb2RlYyhcbiAgICBnZXRUdXBsZUVuY29kZXIoaXRlbXMpLFxuICAgIGdldFR1cGxlRGVjb2RlcihpdGVtcylcbiAgKTtcbn1cbmZ1bmN0aW9uIGdldFVuaW9uRW5jb2Rlcih2YXJpYW50cywgZ2V0SW5kZXhGcm9tVmFsdWUpIHtcbiAgY29uc3QgZml4ZWRTaXplID0gZ2V0VW5pb25GaXhlZFNpemUodmFyaWFudHMpO1xuICBjb25zdCB3cml0ZSA9ICh2YXJpYW50LCBieXRlcywgb2Zmc2V0KSA9PiB7XG4gICAgY29uc3QgaW5kZXggPSBnZXRJbmRleEZyb21WYWx1ZSh2YXJpYW50KTtcbiAgICBhc3NlcnRWYWxpZFZhcmlhbnRJbmRleCh2YXJpYW50cywgaW5kZXgpO1xuICAgIHJldHVybiB2YXJpYW50c1tpbmRleF0ud3JpdGUodmFyaWFudCwgYnl0ZXMsIG9mZnNldCk7XG4gIH07XG4gIGlmIChmaXhlZFNpemUgIT09IG51bGwpIHtcbiAgICByZXR1cm4gY3JlYXRlRW5jb2Rlcih7IGZpeGVkU2l6ZSwgd3JpdGUgfSk7XG4gIH1cbiAgY29uc3QgbWF4U2l6ZSA9IGdldFVuaW9uTWF4U2l6ZSh2YXJpYW50cyk7XG4gIHJldHVybiBjcmVhdGVFbmNvZGVyKHtcbiAgICAuLi5tYXhTaXplICE9PSBudWxsID8geyBtYXhTaXplIH0gOiB7fSxcbiAgICBnZXRTaXplRnJvbVZhbHVlOiAodmFyaWFudCkgPT4ge1xuICAgICAgY29uc3QgaW5kZXggPSBnZXRJbmRleEZyb21WYWx1ZSh2YXJpYW50KTtcbiAgICAgIGFzc2VydFZhbGlkVmFyaWFudEluZGV4KHZhcmlhbnRzLCBpbmRleCk7XG4gICAgICByZXR1cm4gZ2V0RW5jb2RlZFNpemUodmFyaWFudCwgdmFyaWFudHNbaW5kZXhdKTtcbiAgICB9LFxuICAgIHdyaXRlXG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0VW5pb25EZWNvZGVyKHZhcmlhbnRzLCBnZXRJbmRleEZyb21CeXRlcykge1xuICBjb25zdCBmaXhlZFNpemUgPSBnZXRVbmlvbkZpeGVkU2l6ZSh2YXJpYW50cyk7XG4gIGNvbnN0IHJlYWQgPSAoYnl0ZXMsIG9mZnNldCkgPT4ge1xuICAgIGNvbnN0IGluZGV4ID0gZ2V0SW5kZXhGcm9tQnl0ZXMoYnl0ZXMsIG9mZnNldCk7XG4gICAgYXNzZXJ0VmFsaWRWYXJpYW50SW5kZXgodmFyaWFudHMsIGluZGV4KTtcbiAgICByZXR1cm4gdmFyaWFudHNbaW5kZXhdLnJlYWQoYnl0ZXMsIG9mZnNldCk7XG4gIH07XG4gIGlmIChmaXhlZFNpemUgIT09IG51bGwpIHtcbiAgICByZXR1cm4gY3JlYXRlRGVjb2Rlcih7IGZpeGVkU2l6ZSwgcmVhZCB9KTtcbiAgfVxuICBjb25zdCBtYXhTaXplID0gZ2V0VW5pb25NYXhTaXplKHZhcmlhbnRzKTtcbiAgcmV0dXJuIGNyZWF0ZURlY29kZXIoeyAuLi5tYXhTaXplICE9PSBudWxsID8geyBtYXhTaXplIH0gOiB7fSwgcmVhZCB9KTtcbn1cbmZ1bmN0aW9uIGdldFVuaW9uQ29kZWModmFyaWFudHMsIGdldEluZGV4RnJvbVZhbHVlLCBnZXRJbmRleEZyb21CeXRlcykge1xuICByZXR1cm4gY29tYmluZUNvZGVjKFxuICAgIGdldFVuaW9uRW5jb2Rlcih2YXJpYW50cywgZ2V0SW5kZXhGcm9tVmFsdWUpLFxuICAgIGdldFVuaW9uRGVjb2Rlcih2YXJpYW50cywgZ2V0SW5kZXhGcm9tQnl0ZXMpXG4gICk7XG59XG5mdW5jdGlvbiBhc3NlcnRWYWxpZFZhcmlhbnRJbmRleCh2YXJpYW50cywgaW5kZXgpIHtcbiAgaWYgKHR5cGVvZiB2YXJpYW50c1tpbmRleF0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX1VOSU9OX1ZBUklBTlRfT1VUX09GX1JBTkdFLCB7XG4gICAgICBtYXhSYW5nZTogdmFyaWFudHMubGVuZ3RoIC0gMSxcbiAgICAgIG1pblJhbmdlOiAwLFxuICAgICAgdmFyaWFudDogaW5kZXhcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0VW5pb25GaXhlZFNpemUodmFyaWFudHMpIHtcbiAgaWYgKHZhcmlhbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDA7XG4gIGlmICghaXNGaXhlZFNpemUodmFyaWFudHNbMF0pKSByZXR1cm4gbnVsbDtcbiAgY29uc3QgdmFyaWFudFNpemUgPSB2YXJpYW50c1swXS5maXhlZFNpemU7XG4gIGNvbnN0IHNhbWVTaXplZFZhcmlhbnRzID0gdmFyaWFudHMuZXZlcnkoKHZhcmlhbnQpID0+IGlzRml4ZWRTaXplKHZhcmlhbnQpICYmIHZhcmlhbnQuZml4ZWRTaXplID09PSB2YXJpYW50U2l6ZSk7XG4gIHJldHVybiBzYW1lU2l6ZWRWYXJpYW50cyA/IHZhcmlhbnRTaXplIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGdldFVuaW9uTWF4U2l6ZSh2YXJpYW50cykge1xuICByZXR1cm4gbWF4Q29kZWNTaXplcyh2YXJpYW50cy5tYXAoKHZhcmlhbnQpID0+IGdldE1heFNpemUodmFyaWFudCkpKTtcbn1cblxuLy8gc3JjL2Rpc2NyaW1pbmF0ZWQtdW5pb24udHNcbmZ1bmN0aW9uIGdldERpc2NyaW1pbmF0ZWRVbmlvbkVuY29kZXIodmFyaWFudHMsIGNvbmZpZyA9IHt9KSB7XG4gIGNvbnN0IGRpc2NyaW1pbmF0b3JQcm9wZXJ0eSA9IGNvbmZpZy5kaXNjcmltaW5hdG9yID8/IFwiX19raW5kXCI7XG4gIGNvbnN0IHByZWZpeCA9IGNvbmZpZy5zaXplID8/IGdldFU4RW5jb2RlcigpO1xuICByZXR1cm4gZ2V0VW5pb25FbmNvZGVyKFxuICAgIHZhcmlhbnRzLm1hcChcbiAgICAgIChbLCB2YXJpYW50XSwgaW5kZXgpID0+IHRyYW5zZm9ybUVuY29kZXIoZ2V0VHVwbGVFbmNvZGVyKFtwcmVmaXgsIHZhcmlhbnRdKSwgKHZhbHVlKSA9PiBbaW5kZXgsIHZhbHVlXSlcbiAgICApLFxuICAgICh2YWx1ZSkgPT4gZ2V0VmFyaWFudERpc2NyaW1pbmF0b3IodmFyaWFudHMsIHZhbHVlW2Rpc2NyaW1pbmF0b3JQcm9wZXJ0eV0pXG4gICk7XG59XG5mdW5jdGlvbiBnZXREaXNjcmltaW5hdGVkVW5pb25EZWNvZGVyKHZhcmlhbnRzLCBjb25maWcgPSB7fSkge1xuICBjb25zdCBkaXNjcmltaW5hdG9yUHJvcGVydHkgPSBjb25maWcuZGlzY3JpbWluYXRvciA/PyBcIl9fa2luZFwiO1xuICBjb25zdCBwcmVmaXggPSBjb25maWcuc2l6ZSA/PyBnZXRVOERlY29kZXIoKTtcbiAgcmV0dXJuIGdldFVuaW9uRGVjb2RlcihcbiAgICB2YXJpYW50cy5tYXAoXG4gICAgICAoW2Rpc2NyaW1pbmF0b3IsIHZhcmlhbnRdKSA9PiB0cmFuc2Zvcm1EZWNvZGVyKGdldFR1cGxlRGVjb2RlcihbcHJlZml4LCB2YXJpYW50XSksIChbLCB2YWx1ZV0pID0+ICh7XG4gICAgICAgIFtkaXNjcmltaW5hdG9yUHJvcGVydHldOiBkaXNjcmltaW5hdG9yLFxuICAgICAgICAuLi52YWx1ZVxuICAgICAgfSkpXG4gICAgKSxcbiAgICAoYnl0ZXMsIG9mZnNldCkgPT4gTnVtYmVyKHByZWZpeC5yZWFkKGJ5dGVzLCBvZmZzZXQpWzBdKVxuICApO1xufVxuZnVuY3Rpb24gZ2V0RGlzY3JpbWluYXRlZFVuaW9uQ29kZWModmFyaWFudHMsIGNvbmZpZyA9IHt9KSB7XG4gIHJldHVybiBjb21iaW5lQ29kZWMoXG4gICAgZ2V0RGlzY3JpbWluYXRlZFVuaW9uRW5jb2Rlcih2YXJpYW50cywgY29uZmlnKSxcbiAgICBnZXREaXNjcmltaW5hdGVkVW5pb25EZWNvZGVyKHZhcmlhbnRzLCBjb25maWcpXG4gICk7XG59XG5mdW5jdGlvbiBnZXRWYXJpYW50RGlzY3JpbWluYXRvcih2YXJpYW50cywgZGlzY3JpbWluYXRvclZhbHVlKSB7XG4gIGNvbnN0IGRpc2NyaW1pbmF0b3IgPSB2YXJpYW50cy5maW5kSW5kZXgoKFtrZXldKSA9PiBkaXNjcmltaW5hdG9yVmFsdWUgPT09IGtleSk7XG4gIGlmIChkaXNjcmltaW5hdG9yIDwgMCkge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9ESVNDUklNSU5BVEVEX1VOSU9OX1ZBUklBTlQsIHtcbiAgICAgIHZhbHVlOiBkaXNjcmltaW5hdG9yVmFsdWUsXG4gICAgICB2YXJpYW50czogdmFyaWFudHMubWFwKChba2V5XSkgPT4ga2V5KVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBkaXNjcmltaW5hdG9yO1xufVxuXG4vLyBzcmMvZW51bS1oZWxwZXJzLnRzXG5mdW5jdGlvbiBnZXRFbnVtU3RhdHMoY29uc3RydWN0b3IpIHtcbiAgY29uc3QgbnVtZXJpY2FsVmFsdWVzID0gWy4uLm5ldyBTZXQoT2JqZWN0LnZhbHVlcyhjb25zdHJ1Y3RvcikuZmlsdGVyKCh2KSA9PiB0eXBlb2YgdiA9PT0gXCJudW1iZXJcIikpXS5zb3J0KCk7XG4gIGNvbnN0IGVudW1SZWNvcmQgPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoY29uc3RydWN0b3IpLnNsaWNlKG51bWVyaWNhbFZhbHVlcy5sZW5ndGgpKTtcbiAgY29uc3QgZW51bUtleXMgPSBPYmplY3Qua2V5cyhlbnVtUmVjb3JkKTtcbiAgY29uc3QgZW51bVZhbHVlcyA9IE9iamVjdC52YWx1ZXMoZW51bVJlY29yZCk7XG4gIGNvbnN0IHN0cmluZ1ZhbHVlcyA9IFtcbiAgICAuLi4vKiBAX19QVVJFX18gKi8gbmV3IFNldChbLi4uZW51bUtleXMsIC4uLmVudW1WYWx1ZXMuZmlsdGVyKCh2KSA9PiB0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIildKVxuICBdO1xuICByZXR1cm4geyBlbnVtS2V5cywgZW51bVJlY29yZCwgZW51bVZhbHVlcywgbnVtZXJpY2FsVmFsdWVzLCBzdHJpbmdWYWx1ZXMgfTtcbn1cbmZ1bmN0aW9uIGdldEVudW1JbmRleEZyb21WYXJpYW50KHtcbiAgZW51bUtleXMsXG4gIGVudW1WYWx1ZXMsXG4gIHZhcmlhbnRcbn0pIHtcbiAgY29uc3QgdmFsdWVJbmRleCA9IGZpbmRMYXN0SW5kZXgoZW51bVZhbHVlcywgKHZhbHVlKSA9PiB2YWx1ZSA9PT0gdmFyaWFudCk7XG4gIGlmICh2YWx1ZUluZGV4ID49IDApIHJldHVybiB2YWx1ZUluZGV4O1xuICByZXR1cm4gZW51bUtleXMuZmluZEluZGV4KChrZXkpID0+IGtleSA9PT0gdmFyaWFudCk7XG59XG5mdW5jdGlvbiBnZXRFbnVtSW5kZXhGcm9tRGlzY3JpbWluYXRvcih7XG4gIGRpc2NyaW1pbmF0b3IsXG4gIGVudW1LZXlzLFxuICBlbnVtVmFsdWVzLFxuICB1c2VWYWx1ZXNBc0Rpc2NyaW1pbmF0b3JzXG59KSB7XG4gIGlmICghdXNlVmFsdWVzQXNEaXNjcmltaW5hdG9ycykge1xuICAgIHJldHVybiBkaXNjcmltaW5hdG9yID49IDAgJiYgZGlzY3JpbWluYXRvciA8IGVudW1LZXlzLmxlbmd0aCA/IGRpc2NyaW1pbmF0b3IgOiAtMTtcbiAgfVxuICByZXR1cm4gZmluZExhc3RJbmRleChlbnVtVmFsdWVzLCAodmFsdWUpID0+IHZhbHVlID09PSBkaXNjcmltaW5hdG9yKTtcbn1cbmZ1bmN0aW9uIGZpbmRMYXN0SW5kZXgoYXJyYXksIHByZWRpY2F0ZSkge1xuICBsZXQgbCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGwtLSkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbbF0sIGwsIGFycmF5KSkgcmV0dXJuIGw7XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuZnVuY3Rpb24gZm9ybWF0TnVtZXJpY2FsVmFsdWVzKHZhbHVlcykge1xuICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIFwiXCI7XG4gIGxldCByYW5nZSA9IFt2YWx1ZXNbMF0sIHZhbHVlc1swXV07XG4gIGNvbnN0IHJhbmdlcyA9IFtdO1xuICBmb3IgKGxldCBpbmRleCA9IDE7IGluZGV4IDwgdmFsdWVzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW2luZGV4XTtcbiAgICBpZiAocmFuZ2VbMV0gKyAxID09PSB2YWx1ZSkge1xuICAgICAgcmFuZ2VbMV0gPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmFuZ2VzLnB1c2gocmFuZ2VbMF0gPT09IHJhbmdlWzFdID8gYCR7cmFuZ2VbMF19YCA6IGAke3JhbmdlWzBdfS0ke3JhbmdlWzFdfWApO1xuICAgICAgcmFuZ2UgPSBbdmFsdWUsIHZhbHVlXTtcbiAgICB9XG4gIH1cbiAgcmFuZ2VzLnB1c2gocmFuZ2VbMF0gPT09IHJhbmdlWzFdID8gYCR7cmFuZ2VbMF19YCA6IGAke3JhbmdlWzBdfS0ke3JhbmdlWzFdfWApO1xuICByZXR1cm4gcmFuZ2VzLmpvaW4oXCIsIFwiKTtcbn1cblxuLy8gc3JjL2VudW0udHNcbmZ1bmN0aW9uIGdldEVudW1FbmNvZGVyKGNvbnN0cnVjdG9yLCBjb25maWcgPSB7fSkge1xuICBjb25zdCBwcmVmaXggPSBjb25maWcuc2l6ZSA/PyBnZXRVOEVuY29kZXIoKTtcbiAgY29uc3QgdXNlVmFsdWVzQXNEaXNjcmltaW5hdG9ycyA9IGNvbmZpZy51c2VWYWx1ZXNBc0Rpc2NyaW1pbmF0b3JzID8/IGZhbHNlO1xuICBjb25zdCB7IGVudW1LZXlzLCBlbnVtVmFsdWVzLCBudW1lcmljYWxWYWx1ZXMsIHN0cmluZ1ZhbHVlcyB9ID0gZ2V0RW51bVN0YXRzKGNvbnN0cnVjdG9yKTtcbiAgaWYgKHVzZVZhbHVlc0FzRGlzY3JpbWluYXRvcnMgJiYgZW51bVZhbHVlcy5zb21lKCh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSkge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fQ0FOTk9UX1VTRV9MRVhJQ0FMX1ZBTFVFU19BU19FTlVNX0RJU0NSSU1JTkFUT1JTLCB7XG4gICAgICBzdHJpbmdWYWx1ZXM6IGVudW1WYWx1ZXMuZmlsdGVyKCh2KSA9PiB0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIilcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdHJhbnNmb3JtRW5jb2RlcihwcmVmaXgsICh2YXJpYW50KSA9PiB7XG4gICAgY29uc3QgaW5kZXggPSBnZXRFbnVtSW5kZXhGcm9tVmFyaWFudCh7IGVudW1LZXlzLCBlbnVtVmFsdWVzLCB2YXJpYW50IH0pO1xuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9FTlVNX1ZBUklBTlQsIHtcbiAgICAgICAgZm9ybWF0dGVkTnVtZXJpY2FsVmFsdWVzOiBmb3JtYXROdW1lcmljYWxWYWx1ZXMobnVtZXJpY2FsVmFsdWVzKSxcbiAgICAgICAgbnVtZXJpY2FsVmFsdWVzLFxuICAgICAgICBzdHJpbmdWYWx1ZXMsXG4gICAgICAgIHZhcmlhbnRcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdXNlVmFsdWVzQXNEaXNjcmltaW5hdG9ycyA/IGVudW1WYWx1ZXNbaW5kZXhdIDogaW5kZXg7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0RW51bURlY29kZXIoY29uc3RydWN0b3IsIGNvbmZpZyA9IHt9KSB7XG4gIGNvbnN0IHByZWZpeCA9IGNvbmZpZy5zaXplID8/IGdldFU4RGVjb2RlcigpO1xuICBjb25zdCB1c2VWYWx1ZXNBc0Rpc2NyaW1pbmF0b3JzID0gY29uZmlnLnVzZVZhbHVlc0FzRGlzY3JpbWluYXRvcnMgPz8gZmFsc2U7XG4gIGNvbnN0IHsgZW51bUtleXMsIGVudW1WYWx1ZXMsIG51bWVyaWNhbFZhbHVlcyB9ID0gZ2V0RW51bVN0YXRzKGNvbnN0cnVjdG9yKTtcbiAgaWYgKHVzZVZhbHVlc0FzRGlzY3JpbWluYXRvcnMgJiYgZW51bVZhbHVlcy5zb21lKCh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSkge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fQ0FOTk9UX1VTRV9MRVhJQ0FMX1ZBTFVFU19BU19FTlVNX0RJU0NSSU1JTkFUT1JTLCB7XG4gICAgICBzdHJpbmdWYWx1ZXM6IGVudW1WYWx1ZXMuZmlsdGVyKCh2KSA9PiB0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIilcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdHJhbnNmb3JtRGVjb2RlcihwcmVmaXgsICh2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IGRpc2NyaW1pbmF0b3IgPSBOdW1iZXIodmFsdWUpO1xuICAgIGNvbnN0IGluZGV4ID0gZ2V0RW51bUluZGV4RnJvbURpc2NyaW1pbmF0b3Ioe1xuICAgICAgZGlzY3JpbWluYXRvcixcbiAgICAgIGVudW1LZXlzLFxuICAgICAgZW51bVZhbHVlcyxcbiAgICAgIHVzZVZhbHVlc0FzRGlzY3JpbWluYXRvcnNcbiAgICB9KTtcbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICBjb25zdCB2YWxpZERpc2NyaW1pbmF0b3JzID0gdXNlVmFsdWVzQXNEaXNjcmltaW5hdG9ycyA/IG51bWVyaWNhbFZhbHVlcyA6IFsuLi5BcnJheShlbnVtS2V5cy5sZW5ndGgpLmtleXMoKV07XG4gICAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOVU1fRElTQ1JJTUlOQVRPUl9PVVRfT0ZfUkFOR0UsIHtcbiAgICAgICAgZGlzY3JpbWluYXRvcixcbiAgICAgICAgZm9ybWF0dGVkVmFsaWREaXNjcmltaW5hdG9yczogZm9ybWF0TnVtZXJpY2FsVmFsdWVzKHZhbGlkRGlzY3JpbWluYXRvcnMpLFxuICAgICAgICB2YWxpZERpc2NyaW1pbmF0b3JzXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGVudW1WYWx1ZXNbaW5kZXhdO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldEVudW1Db2RlYyhjb25zdHJ1Y3RvciwgY29uZmlnID0ge30pIHtcbiAgcmV0dXJuIGNvbWJpbmVDb2RlYyhnZXRFbnVtRW5jb2Rlcihjb25zdHJ1Y3RvciwgY29uZmlnKSwgZ2V0RW51bURlY29kZXIoY29uc3RydWN0b3IsIGNvbmZpZykpO1xufVxuZnVuY3Rpb24gZ2V0SGlkZGVuUHJlZml4RW5jb2RlcihlbmNvZGVyLCBwcmVmaXhlZEVuY29kZXJzKSB7XG4gIHJldHVybiB0cmFuc2Zvcm1FbmNvZGVyKFxuICAgIGdldFR1cGxlRW5jb2RlcihbLi4ucHJlZml4ZWRFbmNvZGVycywgZW5jb2Rlcl0pLFxuICAgICh2YWx1ZSkgPT4gWy4uLnByZWZpeGVkRW5jb2RlcnMubWFwKCgpID0+IHZvaWQgMCksIHZhbHVlXVxuICApO1xufVxuZnVuY3Rpb24gZ2V0SGlkZGVuUHJlZml4RGVjb2RlcihkZWNvZGVyLCBwcmVmaXhlZERlY29kZXJzKSB7XG4gIHJldHVybiB0cmFuc2Zvcm1EZWNvZGVyKFxuICAgIGdldFR1cGxlRGVjb2RlcihbLi4ucHJlZml4ZWREZWNvZGVycywgZGVjb2Rlcl0pLFxuICAgICh0dXBsZSkgPT4gdHVwbGVbdHVwbGUubGVuZ3RoIC0gMV1cbiAgKTtcbn1cbmZ1bmN0aW9uIGdldEhpZGRlblByZWZpeENvZGVjKGNvZGVjLCBwcmVmaXhlZENvZGVjcykge1xuICByZXR1cm4gY29tYmluZUNvZGVjKGdldEhpZGRlblByZWZpeEVuY29kZXIoY29kZWMsIHByZWZpeGVkQ29kZWNzKSwgZ2V0SGlkZGVuUHJlZml4RGVjb2Rlcihjb2RlYywgcHJlZml4ZWRDb2RlY3MpKTtcbn1cbmZ1bmN0aW9uIGdldEhpZGRlblN1ZmZpeEVuY29kZXIoZW5jb2Rlciwgc3VmZml4ZWRFbmNvZGVycykge1xuICByZXR1cm4gdHJhbnNmb3JtRW5jb2RlcihcbiAgICBnZXRUdXBsZUVuY29kZXIoW2VuY29kZXIsIC4uLnN1ZmZpeGVkRW5jb2RlcnNdKSxcbiAgICAodmFsdWUpID0+IFt2YWx1ZSwgLi4uc3VmZml4ZWRFbmNvZGVycy5tYXAoKCkgPT4gdm9pZCAwKV1cbiAgKTtcbn1cbmZ1bmN0aW9uIGdldEhpZGRlblN1ZmZpeERlY29kZXIoZGVjb2Rlciwgc3VmZml4ZWREZWNvZGVycykge1xuICByZXR1cm4gdHJhbnNmb3JtRGVjb2RlcihcbiAgICBnZXRUdXBsZURlY29kZXIoW2RlY29kZXIsIC4uLnN1ZmZpeGVkRGVjb2RlcnNdKSxcbiAgICAodHVwbGUpID0+IHR1cGxlWzBdXG4gICk7XG59XG5mdW5jdGlvbiBnZXRIaWRkZW5TdWZmaXhDb2RlYyhjb2RlYywgc3VmZml4ZWRDb2RlY3MpIHtcbiAgcmV0dXJuIGNvbWJpbmVDb2RlYyhnZXRIaWRkZW5TdWZmaXhFbmNvZGVyKGNvZGVjLCBzdWZmaXhlZENvZGVjcyksIGdldEhpZGRlblN1ZmZpeERlY29kZXIoY29kZWMsIHN1ZmZpeGVkQ29kZWNzKSk7XG59XG5mdW5jdGlvbiBnZXRMaXRlcmFsVW5pb25FbmNvZGVyKHZhcmlhbnRzLCBjb25maWcgPSB7fSkge1xuICBjb25zdCBkaXNjcmltaW5hdG9yID0gY29uZmlnLnNpemUgPz8gZ2V0VThFbmNvZGVyKCk7XG4gIHJldHVybiB0cmFuc2Zvcm1FbmNvZGVyKGRpc2NyaW1pbmF0b3IsICh2YXJpYW50KSA9PiB7XG4gICAgY29uc3QgaW5kZXggPSB2YXJpYW50cy5pbmRleE9mKHZhcmlhbnQpO1xuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9MSVRFUkFMX1VOSU9OX1ZBUklBTlQsIHtcbiAgICAgICAgdmFsdWU6IHZhcmlhbnQsXG4gICAgICAgIHZhcmlhbnRzXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldExpdGVyYWxVbmlvbkRlY29kZXIodmFyaWFudHMsIGNvbmZpZyA9IHt9KSB7XG4gIGNvbnN0IGRpc2NyaW1pbmF0b3IgPSBjb25maWcuc2l6ZSA/PyBnZXRVOERlY29kZXIoKTtcbiAgcmV0dXJuIHRyYW5zZm9ybURlY29kZXIoZGlzY3JpbWluYXRvciwgKGluZGV4KSA9PiB7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB2YXJpYW50cy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fTElURVJBTF9VTklPTl9ESVNDUklNSU5BVE9SX09VVF9PRl9SQU5HRSwge1xuICAgICAgICBkaXNjcmltaW5hdG9yOiBpbmRleCxcbiAgICAgICAgbWF4UmFuZ2U6IHZhcmlhbnRzLmxlbmd0aCAtIDEsXG4gICAgICAgIG1pblJhbmdlOiAwXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHZhcmlhbnRzW051bWJlcihpbmRleCldO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldExpdGVyYWxVbmlvbkNvZGVjKHZhcmlhbnRzLCBjb25maWcgPSB7fSkge1xuICByZXR1cm4gY29tYmluZUNvZGVjKGdldExpdGVyYWxVbmlvbkVuY29kZXIodmFyaWFudHMsIGNvbmZpZyksIGdldExpdGVyYWxVbmlvbkRlY29kZXIodmFyaWFudHMsIGNvbmZpZykpO1xufVxuZnVuY3Rpb24gZ2V0TWFwRW5jb2RlcihrZXksIHZhbHVlLCBjb25maWcgPSB7fSkge1xuICByZXR1cm4gdHJhbnNmb3JtRW5jb2RlcihcbiAgICBnZXRBcnJheUVuY29kZXIoZ2V0VHVwbGVFbmNvZGVyKFtrZXksIHZhbHVlXSksIGNvbmZpZyksXG4gICAgKG1hcCkgPT4gWy4uLm1hcC5lbnRyaWVzKCldXG4gICk7XG59XG5mdW5jdGlvbiBnZXRNYXBEZWNvZGVyKGtleSwgdmFsdWUsIGNvbmZpZyA9IHt9KSB7XG4gIHJldHVybiB0cmFuc2Zvcm1EZWNvZGVyKFxuICAgIGdldEFycmF5RGVjb2RlcihnZXRUdXBsZURlY29kZXIoW2tleSwgdmFsdWVdKSwgY29uZmlnKSxcbiAgICAoZW50cmllcykgPT4gbmV3IE1hcChlbnRyaWVzKVxuICApO1xufVxuZnVuY3Rpb24gZ2V0TWFwQ29kZWMoa2V5LCB2YWx1ZSwgY29uZmlnID0ge30pIHtcbiAgcmV0dXJuIGNvbWJpbmVDb2RlYyhnZXRNYXBFbmNvZGVyKGtleSwgdmFsdWUsIGNvbmZpZyksIGdldE1hcERlY29kZXIoa2V5LCB2YWx1ZSwgY29uZmlnKSk7XG59XG5mdW5jdGlvbiBnZXRVbml0RW5jb2RlcigpIHtcbiAgcmV0dXJuIGNyZWF0ZUVuY29kZXIoe1xuICAgIGZpeGVkU2l6ZTogMCxcbiAgICB3cml0ZTogKF92YWx1ZSwgX2J5dGVzLCBvZmZzZXQpID0+IG9mZnNldFxuICB9KTtcbn1cbmZ1bmN0aW9uIGdldFVuaXREZWNvZGVyKCkge1xuICByZXR1cm4gY3JlYXRlRGVjb2Rlcih7XG4gICAgZml4ZWRTaXplOiAwLFxuICAgIHJlYWQ6IChfYnl0ZXMsIG9mZnNldCkgPT4gW3ZvaWQgMCwgb2Zmc2V0XVxuICB9KTtcbn1cbmZ1bmN0aW9uIGdldFVuaXRDb2RlYygpIHtcbiAgcmV0dXJuIGNvbWJpbmVDb2RlYyhnZXRVbml0RW5jb2RlcigpLCBnZXRVbml0RGVjb2RlcigpKTtcbn1cblxuLy8gc3JjL251bGxhYmxlLnRzXG5mdW5jdGlvbiBnZXROdWxsYWJsZUVuY29kZXIoaXRlbSwgY29uZmlnID0ge30pIHtcbiAgY29uc3QgcHJlZml4ID0gKCgpID0+IHtcbiAgICBpZiAoY29uZmlnLnByZWZpeCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRyYW5zZm9ybUVuY29kZXIoZ2V0VW5pdEVuY29kZXIoKSwgKF9ib29sZWFuKSA9PiB2b2lkIDApO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0Qm9vbGVhbkVuY29kZXIoeyBzaXplOiBjb25maWcucHJlZml4ID8/IGdldFU4RW5jb2RlcigpIH0pO1xuICB9KSgpO1xuICBjb25zdCBub25lVmFsdWUgPSAoKCkgPT4ge1xuICAgIGlmIChjb25maWcubm9uZVZhbHVlID09PSBcInplcm9lc1wiKSB7XG4gICAgICBhc3NlcnRJc0ZpeGVkU2l6ZShpdGVtKTtcbiAgICAgIHJldHVybiBmaXhFbmNvZGVyU2l6ZShnZXRVbml0RW5jb2RlcigpLCBpdGVtLmZpeGVkU2l6ZSk7XG4gICAgfVxuICAgIGlmICghY29uZmlnLm5vbmVWYWx1ZSkge1xuICAgICAgcmV0dXJuIGdldFVuaXRFbmNvZGVyKCk7XG4gICAgfVxuICAgIHJldHVybiBnZXRDb25zdGFudEVuY29kZXIoY29uZmlnLm5vbmVWYWx1ZSk7XG4gIH0pKCk7XG4gIHJldHVybiBnZXRVbmlvbkVuY29kZXIoXG4gICAgW1xuICAgICAgdHJhbnNmb3JtRW5jb2RlcihnZXRUdXBsZUVuY29kZXIoW3ByZWZpeCwgbm9uZVZhbHVlXSksIChfdmFsdWUpID0+IFtcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHZvaWQgMFxuICAgICAgXSksXG4gICAgICB0cmFuc2Zvcm1FbmNvZGVyKGdldFR1cGxlRW5jb2RlcihbcHJlZml4LCBpdGVtXSksICh2YWx1ZSkgPT4gW3RydWUsIHZhbHVlXSlcbiAgICBdLFxuICAgICh2YXJpYW50KSA9PiBOdW1iZXIodmFyaWFudCAhPT0gbnVsbClcbiAgKTtcbn1cbmZ1bmN0aW9uIGdldE51bGxhYmxlRGVjb2RlcihpdGVtLCBjb25maWcgPSB7fSkge1xuICBjb25zdCBwcmVmaXggPSAoKCkgPT4ge1xuICAgIGlmIChjb25maWcucHJlZml4ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdHJhbnNmb3JtRGVjb2RlcihnZXRVbml0RGVjb2RlcigpLCAoKSA9PiBmYWxzZSk7XG4gICAgfVxuICAgIHJldHVybiBnZXRCb29sZWFuRGVjb2Rlcih7IHNpemU6IGNvbmZpZy5wcmVmaXggPz8gZ2V0VThEZWNvZGVyKCkgfSk7XG4gIH0pKCk7XG4gIGNvbnN0IG5vbmVWYWx1ZSA9ICgoKSA9PiB7XG4gICAgaWYgKGNvbmZpZy5ub25lVmFsdWUgPT09IFwiemVyb2VzXCIpIHtcbiAgICAgIGFzc2VydElzRml4ZWRTaXplKGl0ZW0pO1xuICAgICAgcmV0dXJuIGZpeERlY29kZXJTaXplKGdldFVuaXREZWNvZGVyKCksIGl0ZW0uZml4ZWRTaXplKTtcbiAgICB9XG4gICAgaWYgKCFjb25maWcubm9uZVZhbHVlKSB7XG4gICAgICByZXR1cm4gZ2V0VW5pdERlY29kZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIGdldENvbnN0YW50RGVjb2Rlcihjb25maWcubm9uZVZhbHVlKTtcbiAgfSkoKTtcbiAgcmV0dXJuIGdldFVuaW9uRGVjb2RlcihcbiAgICBbXG4gICAgICB0cmFuc2Zvcm1EZWNvZGVyKGdldFR1cGxlRGVjb2RlcihbcHJlZml4LCBub25lVmFsdWVdKSwgKCkgPT4gbnVsbCksXG4gICAgICB0cmFuc2Zvcm1EZWNvZGVyKGdldFR1cGxlRGVjb2RlcihbcHJlZml4LCBpdGVtXSksIChbLCB2YWx1ZV0pID0+IHZhbHVlKVxuICAgIF0sXG4gICAgKGJ5dGVzLCBvZmZzZXQpID0+IHtcbiAgICAgIGlmIChjb25maWcucHJlZml4ID09PSBudWxsICYmICFjb25maWcubm9uZVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBOdW1iZXIob2Zmc2V0IDwgYnl0ZXMubGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb25maWcucHJlZml4ID09PSBudWxsICYmIGNvbmZpZy5ub25lVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCB6ZXJvVmFsdWUgPSBjb25maWcubm9uZVZhbHVlID09PSBcInplcm9lc1wiID8gbmV3IFVpbnQ4QXJyYXkobm9uZVZhbHVlLmZpeGVkU2l6ZSkuZmlsbCgwKSA6IGNvbmZpZy5ub25lVmFsdWU7XG4gICAgICAgIHJldHVybiBjb250YWluc0J5dGVzKGJ5dGVzLCB6ZXJvVmFsdWUsIG9mZnNldCkgPyAwIDogMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBOdW1iZXIocHJlZml4LnJlYWQoYnl0ZXMsIG9mZnNldClbMF0pO1xuICAgIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIGdldE51bGxhYmxlQ29kZWMoaXRlbSwgY29uZmlnID0ge30pIHtcbiAgcmV0dXJuIGNvbWJpbmVDb2RlYyhcbiAgICBnZXROdWxsYWJsZUVuY29kZXIoaXRlbSwgY29uZmlnKSxcbiAgICBnZXROdWxsYWJsZURlY29kZXIoaXRlbSwgY29uZmlnKVxuICApO1xufVxuZnVuY3Rpb24gZ2V0U2V0RW5jb2RlcihpdGVtLCBjb25maWcgPSB7fSkge1xuICByZXR1cm4gdHJhbnNmb3JtRW5jb2RlcihnZXRBcnJheUVuY29kZXIoaXRlbSwgY29uZmlnKSwgKHNldCkgPT4gWy4uLnNldF0pO1xufVxuZnVuY3Rpb24gZ2V0U2V0RGVjb2RlcihpdGVtLCBjb25maWcgPSB7fSkge1xuICByZXR1cm4gdHJhbnNmb3JtRGVjb2RlcihnZXRBcnJheURlY29kZXIoaXRlbSwgY29uZmlnKSwgKGVudHJpZXMpID0+IG5ldyBTZXQoZW50cmllcykpO1xufVxuZnVuY3Rpb24gZ2V0U2V0Q29kZWMoaXRlbSwgY29uZmlnID0ge30pIHtcbiAgcmV0dXJuIGNvbWJpbmVDb2RlYyhnZXRTZXRFbmNvZGVyKGl0ZW0sIGNvbmZpZyksIGdldFNldERlY29kZXIoaXRlbSwgY29uZmlnKSk7XG59XG5mdW5jdGlvbiBnZXRTdHJ1Y3RFbmNvZGVyKGZpZWxkcykge1xuICBjb25zdCBmaWVsZENvZGVjcyA9IGZpZWxkcy5tYXAoKFssIGNvZGVjXSkgPT4gY29kZWMpO1xuICBjb25zdCBmaXhlZFNpemUgPSBzdW1Db2RlY1NpemVzKGZpZWxkQ29kZWNzLm1hcChnZXRGaXhlZFNpemUpKTtcbiAgY29uc3QgbWF4U2l6ZSA9IHN1bUNvZGVjU2l6ZXMoZmllbGRDb2RlY3MubWFwKGdldE1heFNpemUpKSA/PyB2b2lkIDA7XG4gIHJldHVybiBjcmVhdGVFbmNvZGVyKHtcbiAgICAuLi5maXhlZFNpemUgPT09IG51bGwgPyB7XG4gICAgICBnZXRTaXplRnJvbVZhbHVlOiAodmFsdWUpID0+IGZpZWxkcy5tYXAoKFtrZXksIGNvZGVjXSkgPT4gZ2V0RW5jb2RlZFNpemUodmFsdWVba2V5XSwgY29kZWMpKS5yZWR1Y2UoKGFsbCwgb25lKSA9PiBhbGwgKyBvbmUsIDApLFxuICAgICAgbWF4U2l6ZVxuICAgIH0gOiB7IGZpeGVkU2l6ZSB9LFxuICAgIHdyaXRlOiAoc3RydWN0LCBieXRlcywgb2Zmc2V0KSA9PiB7XG4gICAgICBmaWVsZHMuZm9yRWFjaCgoW2tleSwgY29kZWNdKSA9PiB7XG4gICAgICAgIG9mZnNldCA9IGNvZGVjLndyaXRlKHN0cnVjdFtrZXldLCBieXRlcywgb2Zmc2V0KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0U3RydWN0RGVjb2RlcihmaWVsZHMpIHtcbiAgY29uc3QgZmllbGRDb2RlY3MgPSBmaWVsZHMubWFwKChbLCBjb2RlY10pID0+IGNvZGVjKTtcbiAgY29uc3QgZml4ZWRTaXplID0gc3VtQ29kZWNTaXplcyhmaWVsZENvZGVjcy5tYXAoZ2V0Rml4ZWRTaXplKSk7XG4gIGNvbnN0IG1heFNpemUgPSBzdW1Db2RlY1NpemVzKGZpZWxkQ29kZWNzLm1hcChnZXRNYXhTaXplKSkgPz8gdm9pZCAwO1xuICByZXR1cm4gY3JlYXRlRGVjb2Rlcih7XG4gICAgLi4uZml4ZWRTaXplID09PSBudWxsID8geyBtYXhTaXplIH0gOiB7IGZpeGVkU2l6ZSB9LFxuICAgIHJlYWQ6IChieXRlcywgb2Zmc2V0KSA9PiB7XG4gICAgICBjb25zdCBzdHJ1Y3QgPSB7fTtcbiAgICAgIGZpZWxkcy5mb3JFYWNoKChba2V5LCBjb2RlY10pID0+IHtcbiAgICAgICAgY29uc3QgW3ZhbHVlLCBuZXdPZmZzZXRdID0gY29kZWMucmVhZChieXRlcywgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ID0gbmV3T2Zmc2V0O1xuICAgICAgICBzdHJ1Y3Rba2V5XSA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gW3N0cnVjdCwgb2Zmc2V0XTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0U3RydWN0Q29kZWMoZmllbGRzKSB7XG4gIHJldHVybiBjb21iaW5lQ29kZWMoXG4gICAgZ2V0U3RydWN0RW5jb2RlcihmaWVsZHMpLFxuICAgIGdldFN0cnVjdERlY29kZXIoZmllbGRzKVxuICApO1xufVxuXG5leHBvcnQgeyBhc3NlcnRWYWxpZE51bWJlck9mSXRlbXNGb3JDb2RlYywgZ2V0QXJyYXlDb2RlYywgZ2V0QXJyYXlEZWNvZGVyLCBnZXRBcnJheUVuY29kZXIsIGdldEJpdEFycmF5Q29kZWMsIGdldEJpdEFycmF5RGVjb2RlciwgZ2V0Qml0QXJyYXlFbmNvZGVyLCBnZXRCb29sZWFuQ29kZWMsIGdldEJvb2xlYW5EZWNvZGVyLCBnZXRCb29sZWFuRW5jb2RlciwgZ2V0Qnl0ZXNDb2RlYywgZ2V0Qnl0ZXNEZWNvZGVyLCBnZXRCeXRlc0VuY29kZXIsIGdldENvbnN0YW50Q29kZWMsIGdldENvbnN0YW50RGVjb2RlciwgZ2V0Q29uc3RhbnRFbmNvZGVyLCBnZXREaXNjcmltaW5hdGVkVW5pb25Db2RlYywgZ2V0RGlzY3JpbWluYXRlZFVuaW9uRGVjb2RlciwgZ2V0RGlzY3JpbWluYXRlZFVuaW9uRW5jb2RlciwgZ2V0RW51bUNvZGVjLCBnZXRFbnVtRGVjb2RlciwgZ2V0RW51bUVuY29kZXIsIGdldEhpZGRlblByZWZpeENvZGVjLCBnZXRIaWRkZW5QcmVmaXhEZWNvZGVyLCBnZXRIaWRkZW5QcmVmaXhFbmNvZGVyLCBnZXRIaWRkZW5TdWZmaXhDb2RlYywgZ2V0SGlkZGVuU3VmZml4RGVjb2RlciwgZ2V0SGlkZGVuU3VmZml4RW5jb2RlciwgZ2V0TGl0ZXJhbFVuaW9uQ29kZWMsIGdldExpdGVyYWxVbmlvbkRlY29kZXIsIGdldExpdGVyYWxVbmlvbkVuY29kZXIsIGdldE1hcENvZGVjLCBnZXRNYXBEZWNvZGVyLCBnZXRNYXBFbmNvZGVyLCBnZXROdWxsYWJsZUNvZGVjLCBnZXROdWxsYWJsZURlY29kZXIsIGdldE51bGxhYmxlRW5jb2RlciwgZ2V0U2V0Q29kZWMsIGdldFNldERlY29kZXIsIGdldFNldEVuY29kZXIsIGdldFN0cnVjdENvZGVjLCBnZXRTdHJ1Y3REZWNvZGVyLCBnZXRTdHJ1Y3RFbmNvZGVyLCBnZXRUdXBsZUNvZGVjLCBnZXRUdXBsZURlY29kZXIsIGdldFR1cGxlRW5jb2RlciwgZ2V0VW5pb25Db2RlYywgZ2V0VW5pb25EZWNvZGVyLCBnZXRVbmlvbkVuY29kZXIsIGdldFVuaXRDb2RlYywgZ2V0VW5pdERlY29kZXIsIGdldFVuaXRFbmNvZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5ub2RlLm1qcy5tYXBcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm5vZGUubWpzLm1hcCJdLCJuYW1lcyI6WyJjcmVhdGVFbmNvZGVyIiwiZ2V0RW5jb2RlZFNpemUiLCJjcmVhdGVEZWNvZGVyIiwiY29tYmluZUNvZGVjIiwiYXNzZXJ0Qnl0ZUFycmF5SGFzRW5vdWdoQnl0ZXNGb3JDb2RlYyIsInRyYW5zZm9ybUVuY29kZXIiLCJ0cmFuc2Zvcm1EZWNvZGVyIiwiY29udGFpbnNCeXRlcyIsImlzRml4ZWRTaXplIiwiYXNzZXJ0SXNGaXhlZFNpemUiLCJmaXhFbmNvZGVyU2l6ZSIsImZpeERlY29kZXJTaXplIiwiZ2V0VTMyRW5jb2RlciIsImdldFUzMkRlY29kZXIiLCJnZXRVOEVuY29kZXIiLCJnZXRVOERlY29kZXIiLCJTb2xhbmFFcnJvciIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX05VTUJFUl9PRl9JVEVNUyIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0NPTlNUQU5UIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX1VOSU9OX1ZBUklBTlRfT1VUX09GX1JBTkdFIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfRElTQ1JJTUlOQVRFRF9VTklPTl9WQVJJQU5UIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0NBTk5PVF9VU0VfTEVYSUNBTF9WQUxVRVNfQVNfRU5VTV9ESVNDUklNSU5BVE9SUyIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0VOVU1fVkFSSUFOVCIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTlVNX0RJU0NSSU1JTkFUT1JfT1VUX09GX1JBTkdFIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfTElURVJBTF9VTklPTl9WQVJJQU5UIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0xJVEVSQUxfVU5JT05fRElTQ1JJTUlOQVRPUl9PVVRfT0ZfUkFOR0UiLCJhc3NlcnRWYWxpZE51bWJlck9mSXRlbXNGb3JDb2RlYyIsImNvZGVjRGVzY3JpcHRpb24iLCJleHBlY3RlZCIsImFjdHVhbCIsIm1heENvZGVjU2l6ZXMiLCJzaXplcyIsInJlZHVjZSIsImFsbCIsInNpemUiLCJNYXRoIiwibWF4Iiwic3VtQ29kZWNTaXplcyIsImdldEZpeGVkU2l6ZSIsImNvZGVjIiwiZml4ZWRTaXplIiwiZ2V0TWF4U2l6ZSIsIm1heFNpemUiLCJnZXRBcnJheUVuY29kZXIiLCJpdGVtIiwiY29uZmlnIiwiY29tcHV0ZUFycmF5TGlrZUNvZGVjU2l6ZSIsImdldFNpemVGcm9tVmFsdWUiLCJhcnJheSIsInByZWZpeFNpemUiLCJsZW5ndGgiLCJ2YWx1ZSIsIndyaXRlIiwiYnl0ZXMiLCJvZmZzZXQiLCJmb3JFYWNoIiwiZ2V0QXJyYXlEZWNvZGVyIiwiaXRlbVNpemUiLCJyZWFkIiwic2xpY2UiLCJuZXdPZmZzZXQyIiwicHVzaCIsInJlc29sdmVkU2l6ZSIsIm5ld09mZnNldCIsImkiLCJnZXRBcnJheUNvZGVjIiwiZ2V0Qml0QXJyYXlFbmNvZGVyIiwicGFyc2VkQ29uZmlnIiwiYmFja3dhcmQiLCJieXRlc1RvQWRkIiwiYnl0ZSIsImoiLCJmZWF0dXJlIiwiTnVtYmVyIiwidW5zaGlmdCIsInNldCIsImdldEJpdEFycmF5RGVjb2RlciIsImJvb2xlYW5zIiwicmV2ZXJzZSIsIkJvb2xlYW4iLCJnZXRCaXRBcnJheUNvZGVjIiwiZ2V0Qm9vbGVhbkVuY29kZXIiLCJnZXRCb29sZWFuRGVjb2RlciIsImdldEJvb2xlYW5Db2RlYyIsImdldEJ5dGVzRW5jb2RlciIsImdldEJ5dGVzRGVjb2RlciIsImdldEJ5dGVzQ29kZWMiLCJnZXRCYXNlMTZEZWNvZGVyIiwic3RyIiwidG9TdHJpbmciLCJwYWRTdGFydCIsImdldENvbnN0YW50RW5jb2RlciIsImNvbnN0YW50IiwiXyIsImdldENvbnN0YW50RGVjb2RlciIsImJhc2UxNiIsImRhdGEiLCJoZXhDb25zdGFudCIsImRlY29kZSIsImhleERhdGEiLCJnZXRDb25zdGFudENvZGVjIiwiZ2V0VHVwbGVFbmNvZGVyIiwiaXRlbXMiLCJtYXAiLCJpbmRleCIsIm9uZSIsImdldFR1cGxlRGVjb2RlciIsInZhbHVlcyIsIm5ld1ZhbHVlIiwiZ2V0VHVwbGVDb2RlYyIsImdldFVuaW9uRW5jb2RlciIsInZhcmlhbnRzIiwiZ2V0SW5kZXhGcm9tVmFsdWUiLCJnZXRVbmlvbkZpeGVkU2l6ZSIsInZhcmlhbnQiLCJhc3NlcnRWYWxpZFZhcmlhbnRJbmRleCIsImdldFVuaW9uTWF4U2l6ZSIsImdldFVuaW9uRGVjb2RlciIsImdldEluZGV4RnJvbUJ5dGVzIiwiZ2V0VW5pb25Db2RlYyIsIm1heFJhbmdlIiwibWluUmFuZ2UiLCJ2YXJpYW50U2l6ZSIsInNhbWVTaXplZFZhcmlhbnRzIiwiZXZlcnkiLCJnZXREaXNjcmltaW5hdGVkVW5pb25FbmNvZGVyIiwiZGlzY3JpbWluYXRvclByb3BlcnR5IiwiZGlzY3JpbWluYXRvciIsInByZWZpeCIsImdldFZhcmlhbnREaXNjcmltaW5hdG9yIiwiZ2V0RGlzY3JpbWluYXRlZFVuaW9uRGVjb2RlciIsImdldERpc2NyaW1pbmF0ZWRVbmlvbkNvZGVjIiwiZGlzY3JpbWluYXRvclZhbHVlIiwiZmluZEluZGV4Iiwia2V5IiwiZ2V0RW51bVN0YXRzIiwiY29uc3RydWN0b3IiLCJudW1lcmljYWxWYWx1ZXMiLCJTZXQiLCJPYmplY3QiLCJmaWx0ZXIiLCJ2Iiwic29ydCIsImVudW1SZWNvcmQiLCJmcm9tRW50cmllcyIsImVudHJpZXMiLCJlbnVtS2V5cyIsImtleXMiLCJlbnVtVmFsdWVzIiwic3RyaW5nVmFsdWVzIiwiZ2V0RW51bUluZGV4RnJvbVZhcmlhbnQiLCJ2YWx1ZUluZGV4IiwiZmluZExhc3RJbmRleCIsImdldEVudW1JbmRleEZyb21EaXNjcmltaW5hdG9yIiwidXNlVmFsdWVzQXNEaXNjcmltaW5hdG9ycyIsInByZWRpY2F0ZSIsImwiLCJmb3JtYXROdW1lcmljYWxWYWx1ZXMiLCJyYW5nZSIsInJhbmdlcyIsImpvaW4iLCJnZXRFbnVtRW5jb2RlciIsInNvbWUiLCJmb3JtYXR0ZWROdW1lcmljYWxWYWx1ZXMiLCJnZXRFbnVtRGVjb2RlciIsInZhbGlkRGlzY3JpbWluYXRvcnMiLCJBcnJheSIsImZvcm1hdHRlZFZhbGlkRGlzY3JpbWluYXRvcnMiLCJnZXRFbnVtQ29kZWMiLCJnZXRIaWRkZW5QcmVmaXhFbmNvZGVyIiwiZW5jb2RlciIsInByZWZpeGVkRW5jb2RlcnMiLCJnZXRIaWRkZW5QcmVmaXhEZWNvZGVyIiwiZGVjb2RlciIsInByZWZpeGVkRGVjb2RlcnMiLCJ0dXBsZSIsImdldEhpZGRlblByZWZpeENvZGVjIiwicHJlZml4ZWRDb2RlY3MiLCJnZXRIaWRkZW5TdWZmaXhFbmNvZGVyIiwic3VmZml4ZWRFbmNvZGVycyIsImdldEhpZGRlblN1ZmZpeERlY29kZXIiLCJzdWZmaXhlZERlY29kZXJzIiwiZ2V0SGlkZGVuU3VmZml4Q29kZWMiLCJzdWZmaXhlZENvZGVjcyIsImdldExpdGVyYWxVbmlvbkVuY29kZXIiLCJpbmRleE9mIiwiZ2V0TGl0ZXJhbFVuaW9uRGVjb2RlciIsImdldExpdGVyYWxVbmlvbkNvZGVjIiwiZ2V0TWFwRW5jb2RlciIsImdldE1hcERlY29kZXIiLCJNYXAiLCJnZXRNYXBDb2RlYyIsImdldFVuaXRFbmNvZGVyIiwiX3ZhbHVlIiwiX2J5dGVzIiwiZ2V0VW5pdERlY29kZXIiLCJnZXRVbml0Q29kZWMiLCJnZXROdWxsYWJsZUVuY29kZXIiLCJfYm9vbGVhbiIsIm5vbmVWYWx1ZSIsImdldE51bGxhYmxlRGVjb2RlciIsInplcm9WYWx1ZSIsIlVpbnQ4QXJyYXkiLCJmaWxsIiwiZ2V0TnVsbGFibGVDb2RlYyIsImdldFNldEVuY29kZXIiLCJnZXRTZXREZWNvZGVyIiwiZ2V0U2V0Q29kZWMiLCJnZXRTdHJ1Y3RFbmNvZGVyIiwiZmllbGRzIiwiZmllbGRDb2RlY3MiLCJzdHJ1Y3QiLCJnZXRTdHJ1Y3REZWNvZGVyIiwiZ2V0U3RydWN0Q29kZWMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/codecs-data-structures/dist/index.node.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/codecs-numbers/dist/index.node.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@solana/codecs-numbers/dist/index.node.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Endian: () => (/* binding */ Endian),\n/* harmony export */   assertNumberIsBetweenForCodec: () => (/* binding */ assertNumberIsBetweenForCodec),\n/* harmony export */   getF32Codec: () => (/* binding */ getF32Codec),\n/* harmony export */   getF32Decoder: () => (/* binding */ getF32Decoder),\n/* harmony export */   getF32Encoder: () => (/* binding */ getF32Encoder),\n/* harmony export */   getF64Codec: () => (/* binding */ getF64Codec),\n/* harmony export */   getF64Decoder: () => (/* binding */ getF64Decoder),\n/* harmony export */   getF64Encoder: () => (/* binding */ getF64Encoder),\n/* harmony export */   getI128Codec: () => (/* binding */ getI128Codec),\n/* harmony export */   getI128Decoder: () => (/* binding */ getI128Decoder),\n/* harmony export */   getI128Encoder: () => (/* binding */ getI128Encoder),\n/* harmony export */   getI16Codec: () => (/* binding */ getI16Codec),\n/* harmony export */   getI16Decoder: () => (/* binding */ getI16Decoder),\n/* harmony export */   getI16Encoder: () => (/* binding */ getI16Encoder),\n/* harmony export */   getI32Codec: () => (/* binding */ getI32Codec),\n/* harmony export */   getI32Decoder: () => (/* binding */ getI32Decoder),\n/* harmony export */   getI32Encoder: () => (/* binding */ getI32Encoder),\n/* harmony export */   getI64Codec: () => (/* binding */ getI64Codec),\n/* harmony export */   getI64Decoder: () => (/* binding */ getI64Decoder),\n/* harmony export */   getI64Encoder: () => (/* binding */ getI64Encoder),\n/* harmony export */   getI8Codec: () => (/* binding */ getI8Codec),\n/* harmony export */   getI8Decoder: () => (/* binding */ getI8Decoder),\n/* harmony export */   getI8Encoder: () => (/* binding */ getI8Encoder),\n/* harmony export */   getShortU16Codec: () => (/* binding */ getShortU16Codec),\n/* harmony export */   getShortU16Decoder: () => (/* binding */ getShortU16Decoder),\n/* harmony export */   getShortU16Encoder: () => (/* binding */ getShortU16Encoder),\n/* harmony export */   getU128Codec: () => (/* binding */ getU128Codec),\n/* harmony export */   getU128Decoder: () => (/* binding */ getU128Decoder),\n/* harmony export */   getU128Encoder: () => (/* binding */ getU128Encoder),\n/* harmony export */   getU16Codec: () => (/* binding */ getU16Codec),\n/* harmony export */   getU16Decoder: () => (/* binding */ getU16Decoder),\n/* harmony export */   getU16Encoder: () => (/* binding */ getU16Encoder),\n/* harmony export */   getU32Codec: () => (/* binding */ getU32Codec),\n/* harmony export */   getU32Decoder: () => (/* binding */ getU32Decoder),\n/* harmony export */   getU32Encoder: () => (/* binding */ getU32Encoder),\n/* harmony export */   getU64Codec: () => (/* binding */ getU64Codec),\n/* harmony export */   getU64Decoder: () => (/* binding */ getU64Decoder),\n/* harmony export */   getU64Encoder: () => (/* binding */ getU64Encoder),\n/* harmony export */   getU8Codec: () => (/* binding */ getU8Codec),\n/* harmony export */   getU8Decoder: () => (/* binding */ getU8Decoder),\n/* harmony export */   getU8Encoder: () => (/* binding */ getU8Encoder)\n/* harmony export */ });\n/* harmony import */ var _solana_errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/errors */ \"(ssr)/./node_modules/@solana/errors/dist/index.node.mjs\");\n/* harmony import */ var _solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana/codecs-core */ \"(ssr)/./node_modules/@solana/codecs-core/dist/index.node.mjs\");\n\n\n// src/assertions.ts\nfunction assertNumberIsBetweenForCodec(codecDescription, min, max, value) {\n    if (value < min || value > max) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, {\n            codecDescription,\n            max,\n            min,\n            value\n        });\n    }\n}\n// src/common.ts\nvar Endian = /* @__PURE__ */ ((Endian2)=>{\n    Endian2[Endian2[\"Little\"] = 0] = \"Little\";\n    Endian2[Endian2[\"Big\"] = 1] = \"Big\";\n    return Endian2;\n})(Endian || {});\nfunction isLittleEndian(config) {\n    return config?.endian === 1 /* Big */  ? false : true;\n}\nfunction numberEncoderFactory(input) {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.createEncoder)({\n        fixedSize: input.size,\n        write (value, bytes, offset) {\n            if (input.range) {\n                assertNumberIsBetweenForCodec(input.name, input.range[0], input.range[1], value);\n            }\n            const arrayBuffer = new ArrayBuffer(input.size);\n            input.set(new DataView(arrayBuffer), value, isLittleEndian(input.config));\n            bytes.set(new Uint8Array(arrayBuffer), offset);\n            return offset + input.size;\n        }\n    });\n}\nfunction numberDecoderFactory(input) {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.createDecoder)({\n        fixedSize: input.size,\n        read (bytes, offset = 0) {\n            (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.assertByteArrayIsNotEmptyForCodec)(input.name, bytes, offset);\n            (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.assertByteArrayHasEnoughBytesForCodec)(input.name, input.size, bytes, offset);\n            const view = new DataView((0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.toArrayBuffer)(bytes, offset, input.size));\n            return [\n                input.get(view, isLittleEndian(input.config)),\n                offset + input.size\n            ];\n        }\n    });\n}\n// src/f32.ts\nvar getF32Encoder = (config = {})=>numberEncoderFactory({\n        config,\n        name: \"f32\",\n        set: (view, value, le)=>view.setFloat32(0, Number(value), le),\n        size: 4\n    });\nvar getF32Decoder = (config = {})=>numberDecoderFactory({\n        config,\n        get: (view, le)=>view.getFloat32(0, le),\n        name: \"f32\",\n        size: 4\n    });\nvar getF32Codec = (config = {})=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getF32Encoder(config), getF32Decoder(config));\nvar getF64Encoder = (config = {})=>numberEncoderFactory({\n        config,\n        name: \"f64\",\n        set: (view, value, le)=>view.setFloat64(0, Number(value), le),\n        size: 8\n    });\nvar getF64Decoder = (config = {})=>numberDecoderFactory({\n        config,\n        get: (view, le)=>view.getFloat64(0, le),\n        name: \"f64\",\n        size: 8\n    });\nvar getF64Codec = (config = {})=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getF64Encoder(config), getF64Decoder(config));\nvar getI128Encoder = (config = {})=>numberEncoderFactory({\n        config,\n        name: \"i128\",\n        range: [\n            -BigInt(\"0x7fffffffffffffffffffffffffffffff\") - 1n,\n            BigInt(\"0x7fffffffffffffffffffffffffffffff\")\n        ],\n        set: (view, value, le)=>{\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const rightMask = 0xffffffffffffffffn;\n            view.setBigInt64(leftOffset, BigInt(value) >> 64n, le);\n            view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);\n        },\n        size: 16\n    });\nvar getI128Decoder = (config = {})=>numberDecoderFactory({\n        config,\n        get: (view, le)=>{\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const left = view.getBigInt64(leftOffset, le);\n            const right = view.getBigUint64(rightOffset, le);\n            return (left << 64n) + right;\n        },\n        name: \"i128\",\n        size: 16\n    });\nvar getI128Codec = (config = {})=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getI128Encoder(config), getI128Decoder(config));\nvar getI16Encoder = (config = {})=>numberEncoderFactory({\n        config,\n        name: \"i16\",\n        range: [\n            -Number(\"0x7fff\") - 1,\n            Number(\"0x7fff\")\n        ],\n        set: (view, value, le)=>view.setInt16(0, Number(value), le),\n        size: 2\n    });\nvar getI16Decoder = (config = {})=>numberDecoderFactory({\n        config,\n        get: (view, le)=>view.getInt16(0, le),\n        name: \"i16\",\n        size: 2\n    });\nvar getI16Codec = (config = {})=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getI16Encoder(config), getI16Decoder(config));\nvar getI32Encoder = (config = {})=>numberEncoderFactory({\n        config,\n        name: \"i32\",\n        range: [\n            -Number(\"0x7fffffff\") - 1,\n            Number(\"0x7fffffff\")\n        ],\n        set: (view, value, le)=>view.setInt32(0, Number(value), le),\n        size: 4\n    });\nvar getI32Decoder = (config = {})=>numberDecoderFactory({\n        config,\n        get: (view, le)=>view.getInt32(0, le),\n        name: \"i32\",\n        size: 4\n    });\nvar getI32Codec = (config = {})=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getI32Encoder(config), getI32Decoder(config));\nvar getI64Encoder = (config = {})=>numberEncoderFactory({\n        config,\n        name: \"i64\",\n        range: [\n            -BigInt(\"0x7fffffffffffffff\") - 1n,\n            BigInt(\"0x7fffffffffffffff\")\n        ],\n        set: (view, value, le)=>view.setBigInt64(0, BigInt(value), le),\n        size: 8\n    });\nvar getI64Decoder = (config = {})=>numberDecoderFactory({\n        config,\n        get: (view, le)=>view.getBigInt64(0, le),\n        name: \"i64\",\n        size: 8\n    });\nvar getI64Codec = (config = {})=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getI64Encoder(config), getI64Decoder(config));\nvar getI8Encoder = ()=>numberEncoderFactory({\n        name: \"i8\",\n        range: [\n            -Number(\"0x7f\") - 1,\n            Number(\"0x7f\")\n        ],\n        set: (view, value)=>view.setInt8(0, Number(value)),\n        size: 1\n    });\nvar getI8Decoder = ()=>numberDecoderFactory({\n        get: (view)=>view.getInt8(0),\n        name: \"i8\",\n        size: 1\n    });\nvar getI8Codec = ()=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getI8Encoder(), getI8Decoder());\nvar getShortU16Encoder = ()=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.createEncoder)({\n        getSizeFromValue: (value)=>{\n            if (value <= 127) return 1;\n            if (value <= 16383) return 2;\n            return 3;\n        },\n        maxSize: 3,\n        write: (value, bytes, offset)=>{\n            assertNumberIsBetweenForCodec(\"shortU16\", 0, 65535, value);\n            const shortU16Bytes = [\n                0\n            ];\n            for(let ii = 0;; ii += 1){\n                const alignedValue = Number(value) >> ii * 7;\n                if (alignedValue === 0) {\n                    break;\n                }\n                const nextSevenBits = 127 & alignedValue;\n                shortU16Bytes[ii] = nextSevenBits;\n                if (ii > 0) {\n                    shortU16Bytes[ii - 1] |= 128;\n                }\n            }\n            bytes.set(shortU16Bytes, offset);\n            return offset + shortU16Bytes.length;\n        }\n    });\nvar getShortU16Decoder = ()=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.createDecoder)({\n        maxSize: 3,\n        read: (bytes, offset)=>{\n            let value = 0;\n            let byteCount = 0;\n            while(++byteCount){\n                const byteIndex = byteCount - 1;\n                const currentByte = bytes[offset + byteIndex];\n                const nextSevenBits = 127 & currentByte;\n                value |= nextSevenBits << byteIndex * 7;\n                if ((currentByte & 128) === 0) {\n                    break;\n                }\n            }\n            return [\n                value,\n                offset + byteCount\n            ];\n        }\n    });\nvar getShortU16Codec = ()=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getShortU16Encoder(), getShortU16Decoder());\nvar getU128Encoder = (config = {})=>numberEncoderFactory({\n        config,\n        name: \"u128\",\n        range: [\n            0n,\n            BigInt(\"0xffffffffffffffffffffffffffffffff\")\n        ],\n        set: (view, value, le)=>{\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const rightMask = 0xffffffffffffffffn;\n            view.setBigUint64(leftOffset, BigInt(value) >> 64n, le);\n            view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);\n        },\n        size: 16\n    });\nvar getU128Decoder = (config = {})=>numberDecoderFactory({\n        config,\n        get: (view, le)=>{\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const left = view.getBigUint64(leftOffset, le);\n            const right = view.getBigUint64(rightOffset, le);\n            return (left << 64n) + right;\n        },\n        name: \"u128\",\n        size: 16\n    });\nvar getU128Codec = (config = {})=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getU128Encoder(config), getU128Decoder(config));\nvar getU16Encoder = (config = {})=>numberEncoderFactory({\n        config,\n        name: \"u16\",\n        range: [\n            0,\n            Number(\"0xffff\")\n        ],\n        set: (view, value, le)=>view.setUint16(0, Number(value), le),\n        size: 2\n    });\nvar getU16Decoder = (config = {})=>numberDecoderFactory({\n        config,\n        get: (view, le)=>view.getUint16(0, le),\n        name: \"u16\",\n        size: 2\n    });\nvar getU16Codec = (config = {})=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getU16Encoder(config), getU16Decoder(config));\nvar getU32Encoder = (config = {})=>numberEncoderFactory({\n        config,\n        name: \"u32\",\n        range: [\n            0,\n            Number(\"0xffffffff\")\n        ],\n        set: (view, value, le)=>view.setUint32(0, Number(value), le),\n        size: 4\n    });\nvar getU32Decoder = (config = {})=>numberDecoderFactory({\n        config,\n        get: (view, le)=>view.getUint32(0, le),\n        name: \"u32\",\n        size: 4\n    });\nvar getU32Codec = (config = {})=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getU32Encoder(config), getU32Decoder(config));\nvar getU64Encoder = (config = {})=>numberEncoderFactory({\n        config,\n        name: \"u64\",\n        range: [\n            0n,\n            BigInt(\"0xffffffffffffffff\")\n        ],\n        set: (view, value, le)=>view.setBigUint64(0, BigInt(value), le),\n        size: 8\n    });\nvar getU64Decoder = (config = {})=>numberDecoderFactory({\n        config,\n        get: (view, le)=>view.getBigUint64(0, le),\n        name: \"u64\",\n        size: 8\n    });\nvar getU64Codec = (config = {})=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getU64Encoder(config), getU64Decoder(config));\nvar getU8Encoder = ()=>numberEncoderFactory({\n        name: \"u8\",\n        range: [\n            0,\n            Number(\"0xff\")\n        ],\n        set: (view, value)=>view.setUint8(0, Number(value)),\n        size: 1\n    });\nvar getU8Decoder = ()=>numberDecoderFactory({\n        get: (view)=>view.getUint8(0),\n        name: \"u8\",\n        size: 1\n    });\nvar getU8Codec = ()=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getU8Encoder(), getU8Decoder());\n //# sourceMappingURL=index.node.mjs.map\n //# sourceMappingURL=index.node.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS9jb2RlY3MtbnVtYmVycy9kaXN0L2luZGV4Lm5vZGUubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBd0Y7QUFDa0Y7QUFFMUssb0JBQW9CO0FBQ3BCLFNBQVNRLDhCQUE4QkMsZ0JBQWdCLEVBQUVDLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxLQUFLO0lBQ3RFLElBQUlBLFFBQVFGLE9BQU9FLFFBQVFELEtBQUs7UUFDOUIsTUFBTSxJQUFJWCx1REFBV0EsQ0FBQ0MscUZBQXlDQSxFQUFFO1lBQy9EUTtZQUNBRTtZQUNBRDtZQUNBRTtRQUNGO0lBQ0Y7QUFDRjtBQUVBLGdCQUFnQjtBQUNoQixJQUFJQyxTQUF5QixhQUFILEdBQUksRUFBQ0M7SUFDN0JBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLFNBQVMsR0FBRyxFQUFFLEdBQUc7SUFDakNBLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDLE1BQU0sR0FBRyxFQUFFLEdBQUc7SUFDOUIsT0FBT0E7QUFDVCxHQUFHRCxVQUFVLENBQUM7QUFDZCxTQUFTRSxlQUFlQyxNQUFNO0lBQzVCLE9BQU9BLFFBQVFDLFdBQVcsRUFBRSxPQUFPLE1BQUssUUFBUTtBQUNsRDtBQUNBLFNBQVNDLHFCQUFxQkMsS0FBSztJQUNqQyxPQUFPZixrRUFBYUEsQ0FBQztRQUNuQmdCLFdBQVdELE1BQU1FLElBQUk7UUFDckJDLE9BQU1WLEtBQUssRUFBRVcsS0FBSyxFQUFFQyxNQUFNO1lBQ3hCLElBQUlMLE1BQU1NLEtBQUssRUFBRTtnQkFDZmpCLDhCQUE4QlcsTUFBTU8sSUFBSSxFQUFFUCxNQUFNTSxLQUFLLENBQUMsRUFBRSxFQUFFTixNQUFNTSxLQUFLLENBQUMsRUFBRSxFQUFFYjtZQUM1RTtZQUNBLE1BQU1lLGNBQWMsSUFBSUMsWUFBWVQsTUFBTUUsSUFBSTtZQUM5Q0YsTUFBTVUsR0FBRyxDQUFDLElBQUlDLFNBQVNI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QyxjQUFFO1lBQUV3QixPQUFPO1NBQXNCO1FBQ3pDcEIsS0FBSyxDQUFDSyxNQUFNdEIsT0FBT3lCLEtBQU9ILEtBQUtvQixZQUFZLENBQUMsR0FBR0wsT0FBT3JDLFFBQVF5QjtRQUM5RGhCLE1BQU07SUFDUjtBQUNBLElBQUlxRixnQkFBZ0IsQ0FBQzFGLFNBQVMsQ0FBQyxDQUFDLEdBQUtnQixxQkFBcUI7UUFDeERoQjtRQUNBbUIsS0FBSyxDQUFDRCxNQUFNRyxLQUFPSCxLQUFLeUIsWUFBWSxDQUFDLEdBQUd0QjtRQUN4Q1gsTUFBTTtRQUNOTCxNQUFNO0lBQ1I7QUFDQSxJQUFJc0YsY0FBYyxDQUFDM0YsU0FBUyxDQUFDLENBQUMsR0FBS2QsaUVBQVlBLENBQUN1RyxjQUFjekYsU0FBUzBGLGNBQWMxRjtBQUNyRixJQUFJNEYsZUFBZSxJQUFNMUYscUJBQXFCO1FBQzVDUSxNQUFNO1FBQ05ELE9BQU87WUFBQztZQUFHYyxPQUFPO1NBQVE7UUFDMUJWLEtBQUssQ0FBQ0ssTUFBTXRCLFFBQVVzQixLQUFLMkUsUUFBUSxDQUFDLEdBQUd0RSxPQUFPM0I7UUFDOUNTLE1BQU07SUFDUjtBQUNBLElBQUl5RixlQUFlLElBQU05RSxxQkFBcUI7UUFDNUNHLEtBQUssQ0FBQ0QsT0FBU0EsS0FBSzZFLFFBQVEsQ0FBQztRQUM3QnJGLE1BQU07UUFDTkwsTUFBTTtJQUNSO0FBQ0EsSUFBSTJGLGFBQWEsSUFBTTlHLGlFQUFZQSxDQUFDMEcsZ0JBQWdCRTtBQUUyakIsQ0FDL21CLHVDQUF1QztDQUN2Qyx1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGF3LXdvcmtzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvY29kZWNzLW51bWJlcnMvZGlzdC9pbmRleC5ub2RlLm1qcz9kNzk2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNvbGFuYUVycm9yLCBTT0xBTkFfRVJST1JfX0NPREVDU19fTlVNQkVSX09VVF9PRl9SQU5HRSB9IGZyb20gJ0Bzb2xhbmEvZXJyb3JzJztcbmltcG9ydCB7IGNvbWJpbmVDb2RlYywgY3JlYXRlRGVjb2RlciwgY3JlYXRlRW5jb2RlciwgYXNzZXJ0Qnl0ZUFycmF5SXNOb3RFbXB0eUZvckNvZGVjLCBhc3NlcnRCeXRlQXJyYXlIYXNFbm91Z2hCeXRlc0ZvckNvZGVjLCB0b0FycmF5QnVmZmVyIH0gZnJvbSAnQHNvbGFuYS9jb2RlY3MtY29yZSc7XG5cbi8vIHNyYy9hc3NlcnRpb25zLnRzXG5mdW5jdGlvbiBhc3NlcnROdW1iZXJJc0JldHdlZW5Gb3JDb2RlYyhjb2RlY0Rlc2NyaXB0aW9uLCBtaW4sIG1heCwgdmFsdWUpIHtcbiAgaWYgKHZhbHVlIDwgbWluIHx8IHZhbHVlID4gbWF4KSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQ09ERUNTX19OVU1CRVJfT1VUX09GX1JBTkdFLCB7XG4gICAgICBjb2RlY0Rlc2NyaXB0aW9uLFxuICAgICAgbWF4LFxuICAgICAgbWluLFxuICAgICAgdmFsdWVcbiAgICB9KTtcbiAgfVxufVxuXG4vLyBzcmMvY29tbW9uLnRzXG52YXIgRW5kaWFuID0gLyogQF9fUFVSRV9fICovICgoRW5kaWFuMikgPT4ge1xuICBFbmRpYW4yW0VuZGlhbjJbXCJMaXR0bGVcIl0gPSAwXSA9IFwiTGl0dGxlXCI7XG4gIEVuZGlhbjJbRW5kaWFuMltcIkJpZ1wiXSA9IDFdID0gXCJCaWdcIjtcbiAgcmV0dXJuIEVuZGlhbjI7XG59KShFbmRpYW4gfHwge30pO1xuZnVuY3Rpb24gaXNMaXR0bGVFbmRpYW4oY29uZmlnKSB7XG4gIHJldHVybiBjb25maWc/LmVuZGlhbiA9PT0gMSAvKiBCaWcgKi8gPyBmYWxzZSA6IHRydWU7XG59XG5mdW5jdGlvbiBudW1iZXJFbmNvZGVyRmFjdG9yeShpbnB1dCkge1xuICByZXR1cm4gY3JlYXRlRW5jb2Rlcih7XG4gICAgZml4ZWRTaXplOiBpbnB1dC5zaXplLFxuICAgIHdyaXRlKHZhbHVlLCBieXRlcywgb2Zmc2V0KSB7XG4gICAgICBpZiAoaW5wdXQucmFuZ2UpIHtcbiAgICAgICAgYXNzZXJ0TnVtYmVySXNCZXR3ZWVuRm9yQ29kZWMoaW5wdXQubmFtZSwgaW5wdXQucmFuZ2VbMF0sIGlucHV0LnJhbmdlWzFdLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBhcnJheUJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihpbnB1dC5zaXplKTtcbiAgICAgIGlucHV0LnNldChuZXcgRGF0YVZpZXcoYXJyYXlCdWZmZXIpLCB2YWx1ZSwgaXNMaXR0bGVFbmRpYW4oaW5wdXQuY29uZmlnKSk7XG4gICAgICBieXRlcy5zZXQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpLCBvZmZzZXQpO1xuICAgICAgcmV0dXJuIG9mZnNldCArIGlucHV0LnNpemU7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIG51bWJlckRlY29kZXJGYWN0b3J5KGlucHV0KSB7XG4gIHJldHVybiBjcmVhdGVEZWNvZGVyKHtcbiAgICBmaXhlZFNpemU6IGlucHV0LnNpemUsXG4gICAgcmVhZChieXRlcywgb2Zmc2V0ID0gMCkge1xuICAgICAgYXNzZXJ0Qnl0ZUFycmF5SXNOb3RFbXB0eUZvckNvZGVjKGlucHV0Lm5hbWUsIGJ5dGVzLCBvZmZzZXQpO1xuICAgICAgYXNzZXJ0Qnl0ZUFycmF5SGFzRW5vdWdoQnl0ZXNGb3JDb2RlYyhpbnB1dC5uYW1lLCBpbnB1dC5zaXplLCBieXRlcywgb2Zmc2V0KTtcbiAgICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcodG9BcnJheUJ1ZmZlcihieXRlcywgb2Zmc2V0LCBpbnB1dC5zaXplKSk7XG4gICAgICByZXR1cm4gW2lucHV0LmdldCh2aWV3LCBpc0xpdHRsZUVuZGlhbihpbnB1dC5jb25maWcpKSwgb2Zmc2V0ICsgaW5wdXQuc2l6ZV07XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL2YzMi50c1xudmFyIGdldEYzMkVuY29kZXIgPSAoY29uZmlnID0ge30pID0+IG51bWJlckVuY29kZXJGYWN0b3J5KHtcbiAgY29uZmlnLFxuICBuYW1lOiBcImYzMlwiLFxuICBzZXQ6ICh2aWV3LCB2YWx1ZSwgbGUpID0+IHZpZXcuc2V0RmxvYXQzMigwLCBOdW1iZXIodmFsdWUpLCBsZSksXG4gIHNpemU6IDRcbn0pO1xudmFyIGdldEYzMkRlY29kZXIgPSAoY29uZmlnID0ge30pID0+IG51bWJlckRlY29kZXJGYWN0b3J5KHtcbiAgY29uZmlnLFxuICBnZXQ6ICh2aWV3LCBsZSkgPT4gdmlldy5nZXRGbG9hdDMyKDAsIGxlKSxcbiAgbmFtZTogXCJmMzJcIixcbiAgc2l6ZTogNFxufSk7XG52YXIgZ2V0RjMyQ29kZWMgPSAoY29uZmlnID0ge30pID0+IGNvbWJpbmVDb2RlYyhnZXRGMzJFbmNvZGVyKGNvbmZpZyksIGdldEYzMkRlY29kZXIoY29uZmlnKSk7XG52YXIgZ2V0RjY0RW5jb2RlciA9IChjb25maWcgPSB7fSkgPT4gbnVtYmVyRW5jb2RlckZhY3Rvcnkoe1xuICBjb25maWcsXG4gIG5hbWU6IFwiZjY0XCIsXG4gIHNldDogKHZpZXcsIHZhbHVlLCBsZSkgPT4gdmlldy5zZXRGbG9hdDY0KDAsIE51bWJlcih2YWx1ZSksIGxlKSxcbiAgc2l6ZTogOFxufSk7XG52YXIgZ2V0RjY0RGVjb2RlciA9IChjb25maWcgPSB7fSkgPT4gbnVtYmVyRGVjb2RlckZhY3Rvcnkoe1xuICBjb25maWcsXG4gIGdldDogKHZpZXcsIGxlKSA9PiB2aWV3LmdldEZsb2F0NjQoMCwgbGUpLFxuICBuYW1lOiBcImY2NFwiLFxuICBzaXplOiA4XG59KTtcbnZhciBnZXRGNjRDb2RlYyA9IChjb25maWcgPSB7fSkgPT4gY29tYmluZUNvZGVjKGdldEY2NEVuY29kZXIoY29uZmlnKSwgZ2V0RjY0RGVjb2Rlcihjb25maWcpKTtcbnZhciBnZXRJMTI4RW5jb2RlciA9IChjb25maWcgPSB7fSkgPT4gbnVtYmVyRW5jb2RlckZhY3Rvcnkoe1xuICBjb25maWcsXG4gIG5hbWU6IFwiaTEyOFwiLFxuICByYW5nZTogWy1CaWdJbnQoXCIweDdmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmXCIpIC0gMW4sIEJpZ0ludChcIjB4N2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZcIildLFxuICBzZXQ6ICh2aWV3LCB2YWx1ZSwgbGUpID0+IHtcbiAgICBjb25zdCBsZWZ0T2Zmc2V0ID0gbGUgPyA4IDogMDtcbiAgICBjb25zdCByaWdodE9mZnNldCA9IGxlID8gMCA6IDg7XG4gICAgY29uc3QgcmlnaHRNYXNrID0gMHhmZmZmZmZmZmZmZmZmZmZmbjtcbiAgICB2aWV3LnNldEJpZ0ludDY0KGxlZnRPZmZzZXQsIEJpZ0ludCh2YWx1ZSkgPj4gNjRuLCBsZSk7XG4gICAgdmlldy5zZXRCaWdVaW50NjQocmlnaHRPZmZzZXQsIEJpZ0ludCh2YWx1ZSkgJiByaWdodE1hc2ssIGxlKTtcbiAgfSxcbiAgc2l6ZTogMTZcbn0pO1xudmFyIGdldEkxMjhEZWNvZGVyID0gKGNvbmZpZyA9IHt9KSA9PiBudW1iZXJEZWNvZGVyRmFjdG9yeSh7XG4gIGNvbmZpZyxcbiAgZ2V0OiAodmlldywgbGUpID0+IHtcbiAgICBjb25zdCBsZWZ0T2Zmc2V0ID0gbGUgPyA4IDogMDtcbiAgICBjb25zdCByaWdodE9mZnNldCA9IGxlID8gMCA6IDg7XG4gICAgY29uc3QgbGVmdCA9IHZpZXcuZ2V0QmlnSW50NjQobGVmdE9mZnNldCwgbGUpO1xuICAgIGNvbnN0IHJpZ2h0ID0gdmlldy5nZXRCaWdVaW50NjQocmlnaHRPZmZzZXQsIGxlKTtcbiAgICByZXR1cm4gKGxlZnQgPDwgNjRuKSArIHJpZ2h0O1xuICB9LFxuICBuYW1lOiBcImkxMjhcIixcbiAgc2l6ZTogMTZcbn0pO1xudmFyIGdldEkxMjhDb2RlYyA9IChjb25maWcgPSB7fSkgPT4gY29tYmluZUNvZGVjKGdldEkxMjhFbmNvZGVyKGNvbmZpZyksIGdldEkxMjhEZWNvZGVyKGNvbmZpZykpO1xudmFyIGdldEkxNkVuY29kZXIgPSAoY29uZmlnID0ge30pID0+IG51bWJlckVuY29kZXJGYWN0b3J5KHtcbiAgY29uZmlnLFxuICBuYW1lOiBcImkxNlwiLFxuICByYW5nZTogWy1OdW1iZXIoXCIweDdmZmZcIikgLSAxLCBOdW1iZXIoXCIweDdmZmZcIildLFxuICBzZXQ6ICh2aWV3LCB2YWx1ZSwgbGUpID0+IHZpZXcuc2V0SW50MTYoMCwgTnVtYmVyKHZhbHVlKSwgbGUpLFxuICBzaXplOiAyXG59KTtcbnZhciBnZXRJMTZEZWNvZGVyID0gKGNvbmZpZyA9IHt9KSA9PiBudW1iZXJEZWNvZGVyRmFjdG9yeSh7XG4gIGNvbmZpZyxcbiAgZ2V0OiAodmlldywgbGUpID0+IHZpZXcuZ2V0SW50MTYoMCwgbGUpLFxuICBuYW1lOiBcImkxNlwiLFxuICBzaXplOiAyXG59KTtcbnZhciBnZXRJMTZDb2RlYyA9IChjb25maWcgPSB7fSkgPT4gY29tYmluZUNvZGVjKGdldEkxNkVuY29kZXIoY29uZmlnKSwgZ2V0STE2RGVjb2Rlcihjb25maWcpKTtcbnZhciBnZXRJMzJFbmNvZGVyID0gKGNvbmZpZyA9IHt9KSA9PiBudW1iZXJFbmNvZGVyRmFjdG9yeSh7XG4gIGNvbmZpZyxcbiAgbmFtZTogXCJpMzJcIixcbiAgcmFuZ2U6IFstTnVtYmVyKFwiMHg3ZmZmZmZmZlwiKSAtIDEsIE51bWJlcihcIjB4N2ZmZmZmZmZcIildLFxuICBzZXQ6ICh2aWV3LCB2YWx1ZSwgbGUpID0+IHZpZXcuc2V0SW50MzIoMCwgTnVtYmVyKHZhbHVlKSwgbGUpLFxuICBzaXplOiA0XG59KTtcbnZhciBnZXRJMzJEZWNvZGVyID0gKGNvbmZpZyA9IHt9KSA9PiBudW1iZXJEZWNvZGVyRmFjdG9yeSh7XG4gIGNvbmZpZyxcbiAgZ2V0OiAodmlldywgbGUpID0+IHZpZXcuZ2V0SW50MzIoMCwgbGUpLFxuICBuYW1lOiBcImkzMlwiLFxuICBzaXplOiA0XG59KTtcbnZhciBnZXRJMzJDb2RlYyA9IChjb25maWcgPSB7fSkgPT4gY29tYmluZUNvZGVjKGdldEkzMkVuY29kZXIoY29uZmlnKSwgZ2V0STMyRGVjb2Rlcihjb25maWcpKTtcbnZhciBnZXRJNjRFbmNvZGVyID0gKGNvbmZpZyA9IHt9KSA9PiBudW1iZXJFbmNvZGVyRmFjdG9yeSh7XG4gIGNvbmZpZyxcbiAgbmFtZTogXCJpNjRcIixcbiAgcmFuZ2U6IFstQmlnSW50KFwiMHg3ZmZmZmZmZmZmZmZmZmZmXCIpIC0gMW4sIEJpZ0ludChcIjB4N2ZmZmZmZmZmZmZmZmZmZlwiKV0sXG4gIHNldDogKHZpZXcsIHZhbHVlLCBsZSkgPT4gdmlldy5zZXRCaWdJbnQ2NCgwLCBCaWdJbnQodmFsdWUpLCBsZSksXG4gIHNpemU6IDhcbn0pO1xudmFyIGdldEk2NERlY29kZXIgPSAoY29uZmlnID0ge30pID0+IG51bWJlckRlY29kZXJGYWN0b3J5KHtcbiAgY29uZmlnLFxuICBnZXQ6ICh2aWV3LCBsZSkgPT4gdmlldy5nZXRCaWdJbnQ2NCgwLCBsZSksXG4gIG5hbWU6IFwiaTY0XCIsXG4gIHNpemU6IDhcbn0pO1xudmFyIGdldEk2NENvZGVjID0gKGNvbmZpZyA9IHt9KSA9PiBjb21iaW5lQ29kZWMoZ2V0STY0RW5jb2Rlcihjb25maWcpLCBnZXRJNjREZWNvZGVyKGNvbmZpZykpO1xudmFyIGdldEk4RW5jb2RlciA9ICgpID0+IG51bWJlckVuY29kZXJGYWN0b3J5KHtcbiAgbmFtZTogXCJpOFwiLFxuICByYW5nZTogWy1OdW1iZXIoXCIweDdmXCIpIC0gMSwgTnVtYmVyKFwiMHg3ZlwiKV0sXG4gIHNldDogKHZpZXcsIHZhbHVlKSA9PiB2aWV3LnNldEludDgoMCwgTnVtYmVyKHZhbHVlKSksXG4gIHNpemU6IDFcbn0pO1xudmFyIGdldEk4RGVjb2RlciA9ICgpID0+IG51bWJlckRlY29kZXJGYWN0b3J5KHtcbiAgZ2V0OiAodmlldykgPT4gdmlldy5nZXRJbnQ4KDApLFxuICBuYW1lOiBcImk4XCIsXG4gIHNpemU6IDFcbn0pO1xudmFyIGdldEk4Q29kZWMgPSAoKSA9PiBjb21iaW5lQ29kZWMoZ2V0SThFbmNvZGVyKCksIGdldEk4RGVjb2RlcigpKTtcbnZhciBnZXRTaG9ydFUxNkVuY29kZXIgPSAoKSA9PiBjcmVhdGVFbmNvZGVyKHtcbiAgZ2V0U2l6ZUZyb21WYWx1ZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlIDw9IDEyNykgcmV0dXJuIDE7XG4gICAgaWYgKHZhbHVlIDw9IDE2MzgzKSByZXR1cm4gMjtcbiAgICByZXR1cm4gMztcbiAgfSxcbiAgbWF4U2l6ZTogMyxcbiAgd3JpdGU6ICh2YWx1ZSwgYnl0ZXMsIG9mZnNldCkgPT4ge1xuICAgIGFzc2VydE51bWJlcklzQmV0d2VlbkZvckNvZGVjKFwic2hvcnRVMTZcIiwgMCwgNjU1MzUsIHZhbHVlKTtcbiAgICBjb25zdCBzaG9ydFUxNkJ5dGVzID0gWzBdO1xuICAgIGZvciAobGV0IGlpID0gMDsgOyBpaSArPSAxKSB7XG4gICAgICBjb25zdCBhbGlnbmVkVmFsdWUgPSBOdW1iZXIodmFsdWUpID4+IGlpICogNztcbiAgICAgIGlmIChhbGlnbmVkVmFsdWUgPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjb25zdCBuZXh0U2V2ZW5CaXRzID0gMTI3ICYgYWxpZ25lZFZhbHVlO1xuICAgICAgc2hvcnRVMTZCeXRlc1tpaV0gPSBuZXh0U2V2ZW5CaXRzO1xuICAgICAgaWYgKGlpID4gMCkge1xuICAgICAgICBzaG9ydFUxNkJ5dGVzW2lpIC0gMV0gfD0gMTI4O1xuICAgICAgfVxuICAgIH1cbiAgICBieXRlcy5zZXQoc2hvcnRVMTZCeXRlcywgb2Zmc2V0KTtcbiAgICByZXR1cm4gb2Zmc2V0ICsgc2hvcnRVMTZCeXRlcy5sZW5ndGg7XG4gIH1cbn0pO1xudmFyIGdldFNob3J0VTE2RGVjb2RlciA9ICgpID0+IGNyZWF0ZURlY29kZXIoe1xuICBtYXhTaXplOiAzLFxuICByZWFkOiAoYnl0ZXMsIG9mZnNldCkgPT4ge1xuICAgIGxldCB2YWx1ZSA9IDA7XG4gICAgbGV0IGJ5dGVDb3VudCA9IDA7XG4gICAgd2hpbGUgKCsrYnl0ZUNvdW50KSB7XG4gICAgICBjb25zdCBieXRlSW5kZXggPSBieXRlQ291bnQgLSAxO1xuICAgICAgY29uc3QgY3VycmVudEJ5dGUgPSBieXRlc1tvZmZzZXQgKyBieXRlSW5kZXhdO1xuICAgICAgY29uc3QgbmV4dFNldmVuQml0cyA9IDEyNyAmIGN1cnJlbnRCeXRlO1xuICAgICAgdmFsdWUgfD0gbmV4dFNldmVuQml0cyA8PCBieXRlSW5kZXggKiA3O1xuICAgICAgaWYgKChjdXJyZW50Qnl0ZSAmIDEyOCkgPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbdmFsdWUsIG9mZnNldCArIGJ5dGVDb3VudF07XG4gIH1cbn0pO1xudmFyIGdldFNob3J0VTE2Q29kZWMgPSAoKSA9PiBjb21iaW5lQ29kZWMoZ2V0U2hvcnRVMTZFbmNvZGVyKCksIGdldFNob3J0VTE2RGVjb2RlcigpKTtcbnZhciBnZXRVMTI4RW5jb2RlciA9IChjb25maWcgPSB7fSkgPT4gbnVtYmVyRW5jb2RlckZhY3Rvcnkoe1xuICBjb25maWcsXG4gIG5hbWU6IFwidTEyOFwiLFxuICByYW5nZTogWzBuLCBCaWdJbnQoXCIweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmXCIpXSxcbiAgc2V0OiAodmlldywgdmFsdWUsIGxlKSA9PiB7XG4gICAgY29uc3QgbGVmdE9mZnNldCA9IGxlID8gOCA6IDA7XG4gICAgY29uc3QgcmlnaHRPZmZzZXQgPSBsZSA/IDAgOiA4O1xuICAgIGNvbnN0IHJpZ2h0TWFzayA9IDB4ZmZmZmZmZmZmZmZmZmZmZm47XG4gICAgdmlldy5zZXRCaWdVaW50NjQobGVmdE9mZnNldCwgQmlnSW50KHZhbHVlKSA+PiA2NG4sIGxlKTtcbiAgICB2aWV3LnNldEJpZ1VpbnQ2NChyaWdodE9mZnNldCwgQmlnSW50KHZhbHVlKSAmIHJpZ2h0TWFzaywgbGUpO1xuICB9LFxuICBzaXplOiAxNlxufSk7XG52YXIgZ2V0VTEyOERlY29kZXIgPSAoY29uZmlnID0ge30pID0+IG51bWJlckRlY29kZXJGYWN0b3J5KHtcbiAgY29uZmlnLFxuICBnZXQ6ICh2aWV3LCBsZSkgPT4ge1xuICAgIGNvbnN0IGxlZnRPZmZzZXQgPSBsZSA/IDggOiAwO1xuICAgIGNvbnN0IHJpZ2h0T2Zmc2V0ID0gbGUgPyAwIDogODtcbiAgICBjb25zdCBsZWZ0ID0gdmlldy5nZXRCaWdVaW50NjQobGVmdE9mZnNldCwgbGUpO1xuICAgIGNvbnN0IHJpZ2h0ID0gdmlldy5nZXRCaWdVaW50NjQocmlnaHRPZmZzZXQsIGxlKTtcbiAgICByZXR1cm4gKGxlZnQgPDwgNjRuKSArIHJpZ2h0O1xuICB9LFxuICBuYW1lOiBcInUxMjhcIixcbiAgc2l6ZTogMTZcbn0pO1xudmFyIGdldFUxMjhDb2RlYyA9IChjb25maWcgPSB7fSkgPT4gY29tYmluZUNvZGVjKGdldFUxMjhFbmNvZGVyKGNvbmZpZyksIGdldFUxMjhEZWNvZGVyKGNvbmZpZykpO1xudmFyIGdldFUxNkVuY29kZXIgPSAoY29uZmlnID0ge30pID0+IG51bWJlckVuY29kZXJGYWN0b3J5KHtcbiAgY29uZmlnLFxuICBuYW1lOiBcInUxNlwiLFxuICByYW5nZTogWzAsIE51bWJlcihcIjB4ZmZmZlwiKV0sXG4gIHNldDogKHZpZXcsIHZhbHVlLCBsZSkgPT4gdmlldy5zZXRVaW50MTYoMCwgTnVtYmVyKHZhbHVlKSwgbGUpLFxuICBzaXplOiAyXG59KTtcbnZhciBnZXRVMTZEZWNvZGVyID0gKGNvbmZpZyA9IHt9KSA9PiBudW1iZXJEZWNvZGVyRmFjdG9yeSh7XG4gIGNvbmZpZyxcbiAgZ2V0OiAodmlldywgbGUpID0+IHZpZXcuZ2V0VWludDE2KDAsIGxlKSxcbiAgbmFtZTogXCJ1MTZcIixcbiAgc2l6ZTogMlxufSk7XG52YXIgZ2V0VTE2Q29kZWMgPSAoY29uZmlnID0ge30pID0+IGNvbWJpbmVDb2RlYyhnZXRVMTZFbmNvZGVyKGNvbmZpZyksIGdldFUxNkRlY29kZXIoY29uZmlnKSk7XG52YXIgZ2V0VTMyRW5jb2RlciA9IChjb25maWcgPSB7fSkgPT4gbnVtYmVyRW5jb2RlckZhY3Rvcnkoe1xuICBjb25maWcsXG4gIG5hbWU6IFwidTMyXCIsXG4gIHJhbmdlOiBbMCwgTnVtYmVyKFwiMHhmZmZmZmZmZlwiKV0sXG4gIHNldDogKHZpZXcsIHZhbHVlLCBsZSkgPT4gdmlldy5zZXRVaW50MzIoMCwgTnVtYmVyKHZhbHVlKSwgbGUpLFxuICBzaXplOiA0XG59KTtcbnZhciBnZXRVMzJEZWNvZGVyID0gKGNvbmZpZyA9IHt9KSA9PiBudW1iZXJEZWNvZGVyRmFjdG9yeSh7XG4gIGNvbmZpZyxcbiAgZ2V0OiAodmlldywgbGUpID0+IHZpZXcuZ2V0VWludDMyKDAsIGxlKSxcbiAgbmFtZTogXCJ1MzJcIixcbiAgc2l6ZTogNFxufSk7XG52YXIgZ2V0VTMyQ29kZWMgPSAoY29uZmlnID0ge30pID0+IGNvbWJpbmVDb2RlYyhnZXRVMzJFbmNvZGVyKGNvbmZpZyksIGdldFUzMkRlY29kZXIoY29uZmlnKSk7XG52YXIgZ2V0VTY0RW5jb2RlciA9IChjb25maWcgPSB7fSkgPT4gbnVtYmVyRW5jb2RlckZhY3Rvcnkoe1xuICBjb25maWcsXG4gIG5hbWU6IFwidTY0XCIsXG4gIHJhbmdlOiBbMG4sIEJpZ0ludChcIjB4ZmZmZmZmZmZmZmZmZmZmZlwiKV0sXG4gIHNldDogKHZpZXcsIHZhbHVlLCBsZSkgPT4gdmlldy5zZXRCaWdVaW50NjQoMCwgQmlnSW50KHZhbHVlKSwgbGUpLFxuICBzaXplOiA4XG59KTtcbnZhciBnZXRVNjREZWNvZGVyID0gKGNvbmZpZyA9IHt9KSA9PiBudW1iZXJEZWNvZGVyRmFjdG9yeSh7XG4gIGNvbmZpZyxcbiAgZ2V0OiAodmlldywgbGUpID0+IHZpZXcuZ2V0QmlnVWludDY0KDAsIGxlKSxcbiAgbmFtZTogXCJ1NjRcIixcbiAgc2l6ZTogOFxufSk7XG52YXIgZ2V0VTY0Q29kZWMgPSAoY29uZmlnID0ge30pID0+IGNvbWJpbmVDb2RlYyhnZXRVNjRFbmNvZGVyKGNvbmZpZyksIGdldFU2NERlY29kZXIoY29uZmlnKSk7XG52YXIgZ2V0VThFbmNvZGVyID0gKCkgPT4gbnVtYmVyRW5jb2RlckZhY3Rvcnkoe1xuICBuYW1lOiBcInU4XCIsXG4gIHJhbmdlOiBbMCwgTnVtYmVyKFwiMHhmZlwiKV0sXG4gIHNldDogKHZpZXcsIHZhbHVlKSA9PiB2aWV3LnNldFVpbnQ4KDAsIE51bWJlcih2YWx1ZSkpLFxuICBzaXplOiAxXG59KTtcbnZhciBnZXRVOERlY29kZXIgPSAoKSA9PiBudW1iZXJEZWNvZGVyRmFjdG9yeSh7XG4gIGdldDogKHZpZXcpID0+IHZpZXcuZ2V0VWludDgoMCksXG4gIG5hbWU6IFwidThcIixcbiAgc2l6ZTogMVxufSk7XG52YXIgZ2V0VThDb2RlYyA9ICgpID0+IGNvbWJpbmVDb2RlYyhnZXRVOEVuY29kZXIoKSwgZ2V0VThEZWNvZGVyKCkpO1xuXG5leHBvcnQgeyBFbmRpYW4sIGFzc2VydE51bWJlcklzQmV0d2VlbkZvckNvZGVjLCBnZXRGMzJDb2RlYywgZ2V0RjMyRGVjb2RlciwgZ2V0RjMyRW5jb2RlciwgZ2V0RjY0Q29kZWMsIGdldEY2NERlY29kZXIsIGdldEY2NEVuY29kZXIsIGdldEkxMjhDb2RlYywgZ2V0STEyOERlY29kZXIsIGdldEkxMjhFbmNvZGVyLCBnZXRJMTZDb2RlYywgZ2V0STE2RGVjb2RlciwgZ2V0STE2RW5jb2RlciwgZ2V0STMyQ29kZWMsIGdldEkzMkRlY29kZXIsIGdldEkzMkVuY29kZXIsIGdldEk2NENvZGVjLCBnZXRJNjREZWNvZGVyLCBnZXRJNjRFbmNvZGVyLCBnZXRJOENvZGVjLCBnZXRJOERlY29kZXIsIGdldEk4RW5jb2RlciwgZ2V0U2hvcnRVMTZDb2RlYywgZ2V0U2hvcnRVMTZEZWNvZGVyLCBnZXRTaG9ydFUxNkVuY29kZXIsIGdldFUxMjhDb2RlYywgZ2V0VTEyOERlY29kZXIsIGdldFUxMjhFbmNvZGVyLCBnZXRVMTZDb2RlYywgZ2V0VTE2RGVjb2RlciwgZ2V0VTE2RW5jb2RlciwgZ2V0VTMyQ29kZWMsIGdldFUzMkRlY29kZXIsIGdldFUzMkVuY29kZXIsIGdldFU2NENvZGVjLCBnZXRVNjREZWNvZGVyLCBnZXRVNjRFbmNvZGVyLCBnZXRVOENvZGVjLCBnZXRVOERlY29kZXIsIGdldFU4RW5jb2RlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubm9kZS5tanMubWFwXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5ub2RlLm1qcy5tYXAiXSwibmFtZXMiOlsiU29sYW5hRXJyb3IiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fTlVNQkVSX09VVF9PRl9SQU5HRSIsImNvbWJpbmVDb2RlYyIsImNyZWF0ZURlY29kZXIiLCJjcmVhdGVFbmNvZGVyIiwiYXNzZXJ0Qnl0ZUFycmF5SXNOb3RFbXB0eUZvckNvZGVjIiwiYXNzZXJ0Qnl0ZUFycmF5SGFzRW5vdWdoQnl0ZXNGb3JDb2RlYyIsInRvQXJyYXlCdWZmZXIiLCJhc3NlcnROdW1iZXJJc0JldHdlZW5Gb3JDb2RlYyIsImNvZGVjRGVzY3JpcHRpb24iLCJtaW4iLCJtYXgiLCJ2YWx1ZSIsIkVuZGlhbiIsIkVuZGlhbjIiLCJpc0xpdHRsZUVuZGlhbiIsImNvbmZpZyIsImVuZGlhbiIsIm51bWJlckVuY29kZXJGYWN0b3J5IiwiaW5wdXQiLCJmaXhlZFNpemUiLCJzaXplIiwid3JpdGUiLCJieXRlcyIsIm9mZnNldCIsInJhbmdlIiwibmFtZSIsImFycmF5QnVmZmVyIiwiQXJyYXlCdWZmZXIiLCJzZXQiLCJEYXRhVmlldyIsIlVpbnQ4QXJyYXkiLCJudW1iZXJEZWNvZGVyRmFjdG9yeSIsInJlYWQiLCJ2aWV3IiwiZ2V0IiwiZ2V0RjMyRW5jb2RlciIsImxlIiwic2V0RmxvYXQzMiIsIk51bWJlciIsImdldEYzMkRlY29kZXIiLCJnZXRGbG9hdDMyIiwiZ2V0RjMyQ29kZWMiLCJnZXRGNjRFbmNvZGVyIiwic2V0RmxvYXQ2NCIsImdldEY2NERlY29kZXIiLCJnZXRGbG9hdDY0IiwiZ2V0RjY0Q29kZWMiLCJnZXRJMTI4RW5jb2RlciIsIkJpZ0ludCIsImxlZnRPZmZzZXQiLCJyaWdodE9mZnNldCIsInJpZ2h0TWFzayIsInNldEJpZ0ludDY0Iiwic2V0QmlnVWludDY0IiwiZ2V0STEyOERlY29kZXIiLCJsZWZ0IiwiZ2V0QmlnSW50NjQiLCJyaWdodCIsImdldEJpZ1VpbnQ2NCIsImdldEkxMjhDb2RlYyIsImdldEkxNkVuY29kZXIiLCJzZXRJbnQxNiIsImdldEkxNkRlY29kZXIiLCJnZXRJbnQxNiIsImdldEkxNkNvZGVjIiwiZ2V0STMyRW5jb2RlciIsInNldEludDMyIiwiZ2V0STMyRGVjb2RlciIsImdldEludDMyIiwiZ2V0STMyQ29kZWMiLCJnZXRJNjRFbmNvZGVyIiwiZ2V0STY0RGVjb2RlciIsImdldEk2NENvZGVjIiwiZ2V0SThFbmNvZGVyIiwic2V0SW50OCIsImdldEk4RGVjb2RlciIsImdldEludDgiLCJnZXRJOENvZGVjIiwiZ2V0U2hvcnRVMTZFbmNvZGVyIiwiZ2V0U2l6ZUZyb21WYWx1ZSIsIm1heFNpemUiLCJzaG9ydFUxNkJ5dGVzIiwiaWkiLCJhbGlnbmVkVmFsdWUiLCJuZXh0U2V2ZW5CaXRzIiwibGVuZ3RoIiwiZ2V0U2hvcnRVMTZEZWNvZGVyIiwiYnl0ZUNvdW50IiwiYnl0ZUluZGV4IiwiY3VycmVudEJ5dGUiLCJnZXRTaG9ydFUxNkNvZGVjIiwiZ2V0VTEyOEVuY29kZXIiLCJnZXRVMTI4RGVjb2RlciIsImdldFUxMjhDb2RlYyIsImdldFUxNkVuY29kZXIiLCJzZXRVaW50MTYiLCJnZXRVMTZEZWNvZGVyIiwiZ2V0VWludDE2IiwiZ2V0VTE2Q29kZWMiLCJnZXRVMzJFbmNvZGVyIiwic2V0VWludDMyIiwiZ2V0VTMyRGVjb2RlciIsImdldFVpbnQzMiIsImdldFUzMkNvZGVjIiwiZ2V0VTY0RW5jb2RlciIsImdldFU2NERlY29kZXIiLCJnZXRVNjRDb2RlYyIsImdldFU4RW5jb2RlciIsInNldFVpbnQ4IiwiZ2V0VThEZWNvZGVyIiwiZ2V0VWludDgiLCJnZXRVOENvZGVjIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/codecs-numbers/dist/index.node.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/codecs-strings/dist/index.node.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@solana/codecs-strings/dist/index.node.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertValidBaseString: () => (/* binding */ assertValidBaseString),\n/* harmony export */   getBase10Codec: () => (/* binding */ getBase10Codec),\n/* harmony export */   getBase10Decoder: () => (/* binding */ getBase10Decoder),\n/* harmony export */   getBase10Encoder: () => (/* binding */ getBase10Encoder),\n/* harmony export */   getBase16Codec: () => (/* binding */ getBase16Codec),\n/* harmony export */   getBase16Decoder: () => (/* binding */ getBase16Decoder),\n/* harmony export */   getBase16Encoder: () => (/* binding */ getBase16Encoder),\n/* harmony export */   getBase58Codec: () => (/* binding */ getBase58Codec),\n/* harmony export */   getBase58Decoder: () => (/* binding */ getBase58Decoder),\n/* harmony export */   getBase58Encoder: () => (/* binding */ getBase58Encoder),\n/* harmony export */   getBase64Codec: () => (/* binding */ getBase64Codec),\n/* harmony export */   getBase64Decoder: () => (/* binding */ getBase64Decoder),\n/* harmony export */   getBase64Encoder: () => (/* binding */ getBase64Encoder),\n/* harmony export */   getBaseXCodec: () => (/* binding */ getBaseXCodec),\n/* harmony export */   getBaseXDecoder: () => (/* binding */ getBaseXDecoder),\n/* harmony export */   getBaseXEncoder: () => (/* binding */ getBaseXEncoder),\n/* harmony export */   getBaseXResliceCodec: () => (/* binding */ getBaseXResliceCodec),\n/* harmony export */   getBaseXResliceDecoder: () => (/* binding */ getBaseXResliceDecoder),\n/* harmony export */   getBaseXResliceEncoder: () => (/* binding */ getBaseXResliceEncoder),\n/* harmony export */   getUtf8Codec: () => (/* binding */ getUtf8Codec),\n/* harmony export */   getUtf8Decoder: () => (/* binding */ getUtf8Decoder),\n/* harmony export */   getUtf8Encoder: () => (/* binding */ getUtf8Encoder),\n/* harmony export */   padNullCharacters: () => (/* binding */ padNullCharacters),\n/* harmony export */   removeNullCharacters: () => (/* binding */ removeNullCharacters)\n/* harmony export */ });\n/* harmony import */ var _solana_errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/errors */ \"(ssr)/./node_modules/@solana/errors/dist/index.node.mjs\");\n/* harmony import */ var _solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana/codecs-core */ \"(ssr)/./node_modules/@solana/codecs-core/dist/index.node.mjs\");\n\n\n// src/assertions.ts\nfunction assertValidBaseString(alphabet4, testValue, givenValue = testValue) {\n    if (!testValue.match(new RegExp(`^[${alphabet4}]*$`))) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n            alphabet: alphabet4,\n            base: alphabet4.length,\n            value: givenValue\n        });\n    }\n}\nvar getBaseXEncoder = (alphabet4)=>{\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.createEncoder)({\n        getSizeFromValue: (value)=>{\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet4[0]);\n            if (!tailChars) return value.length;\n            const base10Number = getBigIntFromBaseX(tailChars, alphabet4);\n            return leadingZeroes.length + Math.ceil(base10Number.toString(16).length / 2);\n        },\n        write (value, bytes, offset) {\n            assertValidBaseString(alphabet4, value);\n            if (value === \"\") return offset;\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet4[0]);\n            if (!tailChars) {\n                bytes.set(new Uint8Array(leadingZeroes.length).fill(0), offset);\n                return offset + leadingZeroes.length;\n            }\n            let base10Number = getBigIntFromBaseX(tailChars, alphabet4);\n            const tailBytes = [];\n            while(base10Number > 0n){\n                tailBytes.unshift(Number(base10Number % 256n));\n                base10Number /= 256n;\n            }\n            const bytesToAdd = [\n                ...Array(leadingZeroes.length).fill(0),\n                ...tailBytes\n            ];\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        }\n    });\n};\nvar getBaseXDecoder = (alphabet4)=>{\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.createDecoder)({\n        read (rawBytes, offset) {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return [\n                \"\",\n                0\n            ];\n            let trailIndex = bytes.findIndex((n)=>n !== 0);\n            trailIndex = trailIndex === -1 ? bytes.length : trailIndex;\n            const leadingZeroes = alphabet4[0].repeat(trailIndex);\n            if (trailIndex === bytes.length) return [\n                leadingZeroes,\n                rawBytes.length\n            ];\n            const base10Number = bytes.slice(trailIndex).reduce((sum, byte)=>sum * 256n + BigInt(byte), 0n);\n            const tailChars = getBaseXFromBigInt(base10Number, alphabet4);\n            return [\n                leadingZeroes + tailChars,\n                rawBytes.length\n            ];\n        }\n    });\n};\nvar getBaseXCodec = (alphabet4)=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getBaseXEncoder(alphabet4), getBaseXDecoder(alphabet4));\nfunction partitionLeadingZeroes(value, zeroCharacter) {\n    const [leadingZeros, tailChars] = value.split(new RegExp(`((?!${zeroCharacter}).*)`));\n    return [\n        leadingZeros,\n        tailChars\n    ];\n}\nfunction getBigIntFromBaseX(value, alphabet4) {\n    const base = BigInt(alphabet4.length);\n    let sum = 0n;\n    for (const char of value){\n        sum *= base;\n        sum += BigInt(alphabet4.indexOf(char));\n    }\n    return sum;\n}\nfunction getBaseXFromBigInt(value, alphabet4) {\n    const base = BigInt(alphabet4.length);\n    const tailChars = [];\n    while(value > 0n){\n        tailChars.unshift(alphabet4[Number(value % base)]);\n        value /= base;\n    }\n    return tailChars.join(\"\");\n}\n// src/base10.ts\nvar alphabet = \"0123456789\";\nvar getBase10Encoder = ()=>getBaseXEncoder(alphabet);\nvar getBase10Decoder = ()=>getBaseXDecoder(alphabet);\nvar getBase10Codec = ()=>getBaseXCodec(alphabet);\nvar INVALID_STRING_ERROR_BASE_CONFIG = {\n    alphabet: \"0123456789abcdef\",\n    base: 16\n};\nfunction charCodeToBase16(char) {\n    if (char >= 48 /* ZERO */  && char <= 57 /* NINE */ ) return char - 48 /* ZERO */ ;\n    if (char >= 65 /* A_UP */  && char <= 70 /* F_UP */ ) return char - (65 /* A_UP */  - 10);\n    if (char >= 97 /* A_LO */  && char <= 102 /* F_LO */ ) return char - (97 /* A_LO */  - 10);\n}\nvar getBase16Encoder = ()=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.createEncoder)({\n        getSizeFromValue: (value)=>Math.ceil(value.length / 2),\n        write (value, bytes, offset) {\n            const len = value.length;\n            const al = len / 2;\n            if (len === 1) {\n                const c = value.charCodeAt(0);\n                const n = charCodeToBase16(c);\n                if (n === void 0) {\n                    throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value\n                    });\n                }\n                bytes.set([\n                    n\n                ], offset);\n                return 1 + offset;\n            }\n            const hexBytes = new Uint8Array(al);\n            for(let i = 0, j = 0; i < al; i++){\n                const c1 = value.charCodeAt(j++);\n                const c2 = value.charCodeAt(j++);\n                const n1 = charCodeToBase16(c1);\n                const n2 = charCodeToBase16(c2);\n                if (n1 === void 0 || n2 === void 0 && !Number.isNaN(c2)) {\n                    throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value\n                    });\n                }\n                hexBytes[i] = !Number.isNaN(c2) ? n1 << 4 | (n2 ?? 0) : n1;\n            }\n            bytes.set(hexBytes, offset);\n            return hexBytes.length + offset;\n        }\n    });\nvar getBase16Decoder = ()=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.createDecoder)({\n        read (bytes, offset) {\n            const value = bytes.slice(offset).reduce((str, byte)=>str + byte.toString(16).padStart(2, \"0\"), \"\");\n            return [\n                value,\n                bytes.length\n            ];\n        }\n    });\nvar getBase16Codec = ()=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getBase16Encoder(), getBase16Decoder());\n// src/base58.ts\nvar alphabet2 = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\nvar getBase58Encoder = ()=>getBaseXEncoder(alphabet2);\nvar getBase58Decoder = ()=>getBaseXDecoder(alphabet2);\nvar getBase58Codec = ()=>getBaseXCodec(alphabet2);\nvar getBaseXResliceEncoder = (alphabet4, bits)=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.createEncoder)({\n        getSizeFromValue: (value)=>Math.floor(value.length * bits / 8),\n        write (value, bytes, offset) {\n            assertValidBaseString(alphabet4, value);\n            if (value === \"\") return offset;\n            const charIndices = [\n                ...value\n            ].map((c)=>alphabet4.indexOf(c));\n            const reslicedBytes = reslice(charIndices, bits, 8, false);\n            bytes.set(reslicedBytes, offset);\n            return reslicedBytes.length + offset;\n        }\n    });\nvar getBaseXResliceDecoder = (alphabet4, bits)=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.createDecoder)({\n        read (rawBytes, offset = 0) {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return [\n                \"\",\n                rawBytes.length\n            ];\n            const charIndices = reslice([\n                ...bytes\n            ], 8, bits, true);\n            return [\n                charIndices.map((i)=>alphabet4[i]).join(\"\"),\n                rawBytes.length\n            ];\n        }\n    });\nvar getBaseXResliceCodec = (alphabet4, bits)=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getBaseXResliceEncoder(alphabet4, bits), getBaseXResliceDecoder(alphabet4, bits));\nfunction reslice(input, inputBits, outputBits, useRemainder) {\n    const output = [];\n    let accumulator = 0;\n    let bitsInAccumulator = 0;\n    const mask = (1 << outputBits) - 1;\n    for (const value of input){\n        accumulator = accumulator << inputBits | value;\n        bitsInAccumulator += inputBits;\n        while(bitsInAccumulator >= outputBits){\n            bitsInAccumulator -= outputBits;\n            output.push(accumulator >> bitsInAccumulator & mask);\n        }\n    }\n    if (useRemainder && bitsInAccumulator > 0) {\n        output.push(accumulator << outputBits - bitsInAccumulator & mask);\n    }\n    return output;\n}\n// src/base64.ts\nvar alphabet3 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nvar getBase64Encoder = ()=>{\n    {\n        return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.createEncoder)({\n            getSizeFromValue: (value)=>Buffer.from(value, \"base64\").length,\n            write (value, bytes, offset) {\n                assertValidBaseString(alphabet3, value.replace(/=/g, \"\"));\n                const buffer = Buffer.from(value, \"base64\");\n                bytes.set(buffer, offset);\n                return buffer.length + offset;\n            }\n        });\n    }\n};\nvar getBase64Decoder = ()=>{\n    {\n        return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.createDecoder)({\n            read: (bytes, offset = 0)=>[\n                    Buffer.from((0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.toArrayBuffer)(bytes), offset).toString(\"base64\"),\n                    bytes.length\n                ]\n        });\n    }\n};\nvar getBase64Codec = ()=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getBase64Encoder(), getBase64Decoder());\n// src/null-characters.ts\nvar removeNullCharacters = (value)=>// eslint-disable-next-line no-control-regex\n    value.replace(/\\u0000/g, \"\");\nvar padNullCharacters = (value, chars)=>value.padEnd(chars, \"\\x00\");\n// ../text-encoding-impl/dist/index.node.mjs\nvar e = globalThis.TextDecoder;\nvar o = globalThis.TextEncoder;\n// src/utf8.ts\nvar getUtf8Encoder = ()=>{\n    let textEncoder;\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.createEncoder)({\n        getSizeFromValue: (value)=>(textEncoder ||= new o()).encode(value).length,\n        write: (value, bytes, offset)=>{\n            const bytesToAdd = (textEncoder ||= new o()).encode(value);\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        }\n    });\n};\nvar getUtf8Decoder = ()=>{\n    let textDecoder;\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.createDecoder)({\n        read (bytes, offset) {\n            const value = (textDecoder ||= new e()).decode(bytes.slice(offset));\n            return [\n                removeNullCharacters(value),\n                bytes.length\n            ];\n        }\n    });\n};\nvar getUtf8Codec = ()=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getUtf8Encoder(), getUtf8Decoder());\n //# sourceMappingURL=index.node.mjs.map\n //# sourceMappingURL=index.node.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS9jb2RlY3Mtc3RyaW5ncy9kaXN0L2luZGV4Lm5vZGUubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTRGO0FBQ0k7QUFFaEcsb0JBQW9CO0FBQ3BCLFNBQVNNLHNCQUFzQkMsU0FBUyxFQUFFQyxTQUFTLEVBQUVDLGFBQWFELFNBQVM7SUFDekUsSUFBSSxDQUFDQSxVQUFVRSxLQUFLLENBQUMsSUFBSUMsT0FBTyxDQUFDLEVBQUUsRUFBRUosVUFBVSxHQUFHLENBQUMsSUFBSTtRQUNyRCxNQUFNLElBQUlQLHVEQUFXQSxDQUFDQyx5RkFBNkNBLEVBQUU7WUFDbkVXLFVBQVVMO1lBQ1ZNLE1BQU1OLFVBQVVPLE1BQU07WUFDdEJDLE9BQU9OO1FBQ1Q7SUFDRjtBQUNGO0FBQ0EsSUFBSU8sa0JBQWtCLENBQUNUO0lBQ3JCLE9BQU9ILGtFQUFhQSxDQUFDO1FBQ25CYSxrQkFBa0IsQ0FBQ0Y7WUFDakIsTUFBTSxDQUFDRyxlQUFlQyxVQUFVLEdBQUdDLHVCQUF1QkwsT0FBT1IsU0FBUyxDQUFDLEVBQUU7WUFDN0UsSUFBSSxDQUFDWSxXQUFXLE9BQU9KLE1BQU1ELE1BQU07WUFDbkMsTUFBTU8sZUFBZUMsbUJBQW1CSCxXQUFXWjtZQUNuRCxPQUFPVyxjQUFjSixNQUFNLEdBQUdTLEtBQUtDLElBQUksQ0FBQ0gsYUFBYUksUUFBUSxDQUFDLElBQUlYLE1BQU0sR0FBRztRQUM3RTtRQUNBWSxPQUFNWCxLQUFLLEVBQUVZLEtBQUssRUFBRUMsTUFBTTtZQUN4QnRCLHNCQUFzQkMsV0FBV1E7WUFDakMsSUFBSUEsVUFBVSxJQUFJLE9BQU9hO1lBQ3pCLE1BQU0sQ0FBQ1YsZUFBZUMsVUFBVSxHQUFHQyx1QkFBdUJMLE9BQU9SLFNBQVMsQ0FBQyxFQUFFO1lBQzdFLElBQUksQ0FBQ1ksV0FBVztnQkFDZFEsTUFBTUUsR0FBRyxDQUFDLElBQUlDLFdBQVdaLGNBQWNKLE1BQU0sRUFB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RCx5QkFBeUI7QUFDekIsSUFBSUUsdUJBQXVCLENBQUM5RixRQUMxQiw0Q0FBNEM7SUFDNUNBLE1BQU0wRixPQUFPLENBQUMsV0FBVztBQUUzQixJQUFJSyxvQkFBb0IsQ0FBQy9GLE9BQU9nRyxRQUFVaEcsTUFBTWlHLE1BQU0sQ0FBQ0QsT0FBTztBQUU5RCw0Q0FBNEM7QUFDNUMsSUFBSUUsSUFBSUMsV0FBV0MsV0FBVztBQUM5QixJQUFJQyxJQUFJRixXQUFXRyxXQUFXO0FBRTlCLGNBQWM7QUFDZCxJQUFJQyxpQkFBaUI7SUFDbkIsSUFBSUM7SUFDSixPQUFPbkgsa0VBQWFBLENBQUM7UUFDbkJhLGtCQUFrQixDQUFDRixRQUFVLENBQUN3RyxnQkFBZ0IsSUFBSUgsR0FBRSxFQUFHSSxNQUFNLENBQUN6RyxPQUFPRCxNQUFNO1FBQzNFWSxPQUFPLENBQUNYLE9BQU9ZLE9BQU9DO1lBQ3BCLE1BQU1PLGFBQWEsQ0FBQ29GLGdCQUFnQixJQUFJSCxHQUFFLEVBQUdJLE1BQU0sQ0FBQ3pHO1lBQ3BEWSxNQUFNRSxHQUFHLENBQUNNLFlBQVlQO1lBQ3RCLE9BQU9BLFNBQVNPLFdBQVdyQixNQUFNO1FBQ25DO0lBQ0Y7QUFDRjtBQUNBLElBQUkyRyxpQkFBaUI7SUFDbkIsSUFBSUM7SUFDSixPQUFPdkgsa0VBQWFBLENBQUM7UUFDbkJtQyxNQUFLWCxLQUFLLEVBQUVDLE1BQU07WUFDaEIsTUFBTWIsUUFBUSxDQUFDMkcsZ0JBQWdCLElBQUlULEdBQUUsRUFBR1UsTUFBTSxDQUFDaEcsTUFBTWEsS0FBSyxDQUFDWjtZQUMzRCxPQUFPO2dCQUFDaUYscUJBQXFCOUY7Z0JBQVFZLE1BQU1iLE1BQU07YUFBQztRQUNwRDtJQUNGO0FBQ0Y7QUFDQSxJQUFJOEcsZUFBZSxJQUFNMUgsaUVBQVlBLENBQUNvSCxrQkFBa0JHO0FBRXVZLENBQy9iLHVDQUF1QztDQUN2Qyx1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGF3LXdvcmtzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvY29kZWNzLXN0cmluZ3MvZGlzdC9pbmRleC5ub2RlLm1qcz8xYmU5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNvbGFuYUVycm9yLCBTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9TVFJJTkdfRk9SX0JBU0UgfSBmcm9tICdAc29sYW5hL2Vycm9ycyc7XG5pbXBvcnQgeyBjb21iaW5lQ29kZWMsIGNyZWF0ZURlY29kZXIsIGNyZWF0ZUVuY29kZXIsIHRvQXJyYXlCdWZmZXIgfSBmcm9tICdAc29sYW5hL2NvZGVjcy1jb3JlJztcblxuLy8gc3JjL2Fzc2VydGlvbnMudHNcbmZ1bmN0aW9uIGFzc2VydFZhbGlkQmFzZVN0cmluZyhhbHBoYWJldDQsIHRlc3RWYWx1ZSwgZ2l2ZW5WYWx1ZSA9IHRlc3RWYWx1ZSkge1xuICBpZiAoIXRlc3RWYWx1ZS5tYXRjaChuZXcgUmVnRXhwKGBeWyR7YWxwaGFiZXQ0fV0qJGApKSkge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9TVFJJTkdfRk9SX0JBU0UsIHtcbiAgICAgIGFscGhhYmV0OiBhbHBoYWJldDQsXG4gICAgICBiYXNlOiBhbHBoYWJldDQubGVuZ3RoLFxuICAgICAgdmFsdWU6IGdpdmVuVmFsdWVcbiAgICB9KTtcbiAgfVxufVxudmFyIGdldEJhc2VYRW5jb2RlciA9IChhbHBoYWJldDQpID0+IHtcbiAgcmV0dXJuIGNyZWF0ZUVuY29kZXIoe1xuICAgIGdldFNpemVGcm9tVmFsdWU6ICh2YWx1ZSkgPT4ge1xuICAgICAgY29uc3QgW2xlYWRpbmdaZXJvZXMsIHRhaWxDaGFyc10gPSBwYXJ0aXRpb25MZWFkaW5nWmVyb2VzKHZhbHVlLCBhbHBoYWJldDRbMF0pO1xuICAgICAgaWYgKCF0YWlsQ2hhcnMpIHJldHVybiB2YWx1ZS5sZW5ndGg7XG4gICAgICBjb25zdCBiYXNlMTBOdW1iZXIgPSBnZXRCaWdJbnRGcm9tQmFzZVgodGFpbENoYXJzLCBhbHBoYWJldDQpO1xuICAgICAgcmV0dXJuIGxlYWRpbmdaZXJvZXMubGVuZ3RoICsgTWF0aC5jZWlsKGJhc2UxME51bWJlci50b1N0cmluZygxNikubGVuZ3RoIC8gMik7XG4gICAgfSxcbiAgICB3cml0ZSh2YWx1ZSwgYnl0ZXMsIG9mZnNldCkge1xuICAgICAgYXNzZXJ0VmFsaWRCYXNlU3RyaW5nKGFscGhhYmV0NCwgdmFsdWUpO1xuICAgICAgaWYgKHZhbHVlID09PSBcIlwiKSByZXR1cm4gb2Zmc2V0O1xuICAgICAgY29uc3QgW2xlYWRpbmdaZXJvZXMsIHRhaWxDaGFyc10gPSBwYXJ0aXRpb25MZWFkaW5nWmVyb2VzKHZhbHVlLCBhbHBoYWJldDRbMF0pO1xuICAgICAgaWYgKCF0YWlsQ2hhcnMpIHtcbiAgICAgICAgYnl0ZXMuc2V0KG5ldyBVaW50OEFycmF5KGxlYWRpbmdaZXJvZXMubGVuZ3RoKS5maWxsKDApLCBvZmZzZXQpO1xuICAgICAgICByZXR1cm4gb2Zmc2V0ICsgbGVhZGluZ1plcm9lcy5sZW5ndGg7XG4gICAgICB9XG4gICAgICBsZXQgYmFzZTEwTnVtYmVyID0gZ2V0QmlnSW50RnJvbUJhc2VYKHRhaWxDaGFycywgYWxwaGFiZXQ0KTtcbiAgICAgIGNvbnN0IHRhaWxCeXRlcyA9IFtdO1xuICAgICAgd2hpbGUgKGJhc2UxME51bWJlciA+IDBuKSB7XG4gICAgICAgIHRhaWxCeXRlcy51bnNoaWZ0KE51bWJlcihiYXNlMTBOdW1iZXIgJSAyNTZuKSk7XG4gICAgICAgIGJhc2UxME51bWJlciAvPSAyNTZuO1xuICAgICAgfVxuICAgICAgY29uc3QgYnl0ZXNUb0FkZCA9IFsuLi5BcnJheShsZWFkaW5nWmVyb2VzLmxlbmd0aCkuZmlsbCgwKSwgLi4udGFpbEJ5dGVzXTtcbiAgICAgIGJ5dGVzLnNldChieXRlc1RvQWRkLCBvZmZzZXQpO1xuICAgICAgcmV0dXJuIG9mZnNldCArIGJ5dGVzVG9BZGQubGVuZ3RoO1xuICAgIH1cbiAgfSk7XG59O1xudmFyIGdldEJhc2VYRGVjb2RlciA9IChhbHBoYWJldDQpID0+IHtcbiAgcmV0dXJuIGNyZWF0ZURlY29kZXIoe1xuICAgIHJlYWQocmF3Qnl0ZXMsIG9mZnNldCkge1xuICAgICAgY29uc3QgYnl0ZXMgPSBvZmZzZXQgPT09IDAgPyByYXdCeXRlcyA6IHJhd0J5dGVzLnNsaWNlKG9mZnNldCk7XG4gICAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSAwKSByZXR1cm4gW1wiXCIsIDBdO1xuICAgICAgbGV0IHRyYWlsSW5kZXggPSBieXRlcy5maW5kSW5kZXgoKG4pID0+IG4gIT09IDApO1xuICAgICAgdHJhaWxJbmRleCA9IHRyYWlsSW5kZXggPT09IC0xID8gYnl0ZXMubGVuZ3RoIDogdHJhaWxJbmRleDtcbiAgICAgIGNvbnN0IGxlYWRpbmdaZXJvZXMgPSBhbHBoYWJldDRbMF0ucmVwZWF0KHRyYWlsSW5kZXgpO1xuICAgICAgaWYgKHRyYWlsSW5kZXggPT09IGJ5dGVzLmxlbmd0aCkgcmV0dXJuIFtsZWFkaW5nWmVyb2VzLCByYXdCeXRlcy5sZW5ndGhdO1xuICAgICAgY29uc3QgYmFzZTEwTnVtYmVyID0gYnl0ZXMuc2xpY2UodHJhaWxJbmRleCkucmVkdWNlKChzdW0sIGJ5dGUpID0+IHN1bSAqIDI1Nm4gKyBCaWdJbnQoYnl0ZSksIDBuKTtcbiAgICAgIGNvbnN0IHRhaWxDaGFycyA9IGdldEJhc2VYRnJvbUJpZ0ludChiYXNlMTBOdW1iZXIsIGFscGhhYmV0NCk7XG4gICAgICByZXR1cm4gW2xlYWRpbmdaZXJvZXMgKyB0YWlsQ2hhcnMsIHJhd0J5dGVzLmxlbmd0aF07XG4gICAgfVxuICB9KTtcbn07XG52YXIgZ2V0QmFzZVhDb2RlYyA9IChhbHBoYWJldDQpID0+IGNvbWJpbmVDb2RlYyhnZXRCYXNlWEVuY29kZXIoYWxwaGFiZXQ0KSwgZ2V0QmFzZVhEZWNvZGVyKGFscGhhYmV0NCkpO1xuZnVuY3Rpb24gcGFydGl0aW9uTGVhZGluZ1plcm9lcyh2YWx1ZSwgemVyb0NoYXJhY3Rlcikge1xuICBjb25zdCBbbGVhZGluZ1plcm9zLCB0YWlsQ2hhcnNdID0gdmFsdWUuc3BsaXQobmV3IFJlZ0V4cChgKCg/ISR7emVyb0NoYXJhY3Rlcn0pLiopYCkpO1xuICByZXR1cm4gW2xlYWRpbmdaZXJvcywgdGFpbENoYXJzXTtcbn1cbmZ1bmN0aW9uIGdldEJpZ0ludEZyb21CYXNlWCh2YWx1ZSwgYWxwaGFiZXQ0KSB7XG4gIGNvbnN0IGJhc2UgPSBCaWdJbnQoYWxwaGFiZXQ0Lmxlbmd0aCk7XG4gIGxldCBzdW0gPSAwbjtcbiAgZm9yIChjb25zdCBjaGFyIG9mIHZhbHVlKSB7XG4gICAgc3VtICo9IGJhc2U7XG4gICAgc3VtICs9IEJpZ0ludChhbHBoYWJldDQuaW5kZXhPZihjaGFyKSk7XG4gIH1cbiAgcmV0dXJuIHN1bTtcbn1cbmZ1bmN0aW9uIGdldEJhc2VYRnJvbUJpZ0ludCh2YWx1ZSwgYWxwaGFiZXQ0KSB7XG4gIGNvbnN0IGJhc2UgPSBCaWdJbnQoYWxwaGFiZXQ0Lmxlbmd0aCk7XG4gIGNvbnN0IHRhaWxDaGFycyA9IFtdO1xuICB3aGlsZSAodmFsdWUgPiAwbikge1xuICAgIHRhaWxDaGFycy51bnNoaWZ0KGFscGhhYmV0NFtOdW1iZXIodmFsdWUgJSBiYXNlKV0pO1xuICAgIHZhbHVlIC89IGJhc2U7XG4gIH1cbiAgcmV0dXJuIHRhaWxDaGFycy5qb2luKFwiXCIpO1xufVxuXG4vLyBzcmMvYmFzZTEwLnRzXG52YXIgYWxwaGFiZXQgPSBcIjAxMjM0NTY3ODlcIjtcbnZhciBnZXRCYXNlMTBFbmNvZGVyID0gKCkgPT4gZ2V0QmFzZVhFbmNvZGVyKGFscGhhYmV0KTtcbnZhciBnZXRCYXNlMTBEZWNvZGVyID0gKCkgPT4gZ2V0QmFzZVhEZWNvZGVyKGFscGhhYmV0KTtcbnZhciBnZXRCYXNlMTBDb2RlYyA9ICgpID0+IGdldEJhc2VYQ29kZWMoYWxwaGFiZXQpO1xudmFyIElOVkFMSURfU1RSSU5HX0VSUk9SX0JBU0VfQ09ORklHID0ge1xuICBhbHBoYWJldDogXCIwMTIzNDU2Nzg5YWJjZGVmXCIsXG4gIGJhc2U6IDE2XG59O1xuZnVuY3Rpb24gY2hhckNvZGVUb0Jhc2UxNihjaGFyKSB7XG4gIGlmIChjaGFyID49IDQ4IC8qIFpFUk8gKi8gJiYgY2hhciA8PSA1NyAvKiBOSU5FICovKSByZXR1cm4gY2hhciAtIDQ4IC8qIFpFUk8gKi87XG4gIGlmIChjaGFyID49IDY1IC8qIEFfVVAgKi8gJiYgY2hhciA8PSA3MCAvKiBGX1VQICovKSByZXR1cm4gY2hhciAtICg2NSAvKiBBX1VQICovIC0gMTApO1xuICBpZiAoY2hhciA+PSA5NyAvKiBBX0xPICovICYmIGNoYXIgPD0gMTAyIC8qIEZfTE8gKi8pIHJldHVybiBjaGFyIC0gKDk3IC8qIEFfTE8gKi8gLSAxMCk7XG59XG52YXIgZ2V0QmFzZTE2RW5jb2RlciA9ICgpID0+IGNyZWF0ZUVuY29kZXIoe1xuICBnZXRTaXplRnJvbVZhbHVlOiAodmFsdWUpID0+IE1hdGguY2VpbCh2YWx1ZS5sZW5ndGggLyAyKSxcbiAgd3JpdGUodmFsdWUsIGJ5dGVzLCBvZmZzZXQpIHtcbiAgICBjb25zdCBsZW4gPSB2YWx1ZS5sZW5ndGg7XG4gICAgY29uc3QgYWwgPSBsZW4gLyAyO1xuICAgIGlmIChsZW4gPT09IDEpIHtcbiAgICAgIGNvbnN0IGMgPSB2YWx1ZS5jaGFyQ29kZUF0KDApO1xuICAgICAgY29uc3QgbiA9IGNoYXJDb2RlVG9CYXNlMTYoYyk7XG4gICAgICBpZiAobiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9TVFJJTkdfRk9SX0JBU0UsIHtcbiAgICAgICAgICAuLi5JTlZBTElEX1NUUklOR19FUlJPUl9CQVNFX0NPTkZJRyxcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGJ5dGVzLnNldChbbl0sIG9mZnNldCk7XG4gICAgICByZXR1cm4gMSArIG9mZnNldDtcbiAgICB9XG4gICAgY29uc3QgaGV4Qnl0ZXMgPSBuZXcgVWludDhBcnJheShhbCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgYWw7IGkrKykge1xuICAgICAgY29uc3QgYzEgPSB2YWx1ZS5jaGFyQ29kZUF0KGorKyk7XG4gICAgICBjb25zdCBjMiA9IHZhbHVlLmNoYXJDb2RlQXQoaisrKTtcbiAgICAgIGNvbnN0IG4xID0gY2hhckNvZGVUb0Jhc2UxNihjMSk7XG4gICAgICBjb25zdCBuMiA9IGNoYXJDb2RlVG9CYXNlMTYoYzIpO1xuICAgICAgaWYgKG4xID09PSB2b2lkIDAgfHwgbjIgPT09IHZvaWQgMCAmJiAhTnVtYmVyLmlzTmFOKGMyKSkge1xuICAgICAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfU1RSSU5HX0ZPUl9CQVNFLCB7XG4gICAgICAgICAgLi4uSU5WQUxJRF9TVFJJTkdfRVJST1JfQkFTRV9DT05GSUcsXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBoZXhCeXRlc1tpXSA9ICFOdW1iZXIuaXNOYU4oYzIpID8gbjEgPDwgNCB8IChuMiA/PyAwKSA6IG4xO1xuICAgIH1cbiAgICBieXRlcy5zZXQoaGV4Qnl0ZXMsIG9mZnNldCk7XG4gICAgcmV0dXJuIGhleEJ5dGVzLmxlbmd0aCArIG9mZnNldDtcbiAgfVxufSk7XG52YXIgZ2V0QmFzZTE2RGVjb2RlciA9ICgpID0+IGNyZWF0ZURlY29kZXIoe1xuICByZWFkKGJ5dGVzLCBvZmZzZXQpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGJ5dGVzLnNsaWNlKG9mZnNldCkucmVkdWNlKChzdHIsIGJ5dGUpID0+IHN0ciArIGJ5dGUudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKSwgXCJcIik7XG4gICAgcmV0dXJuIFt2YWx1ZSwgYnl0ZXMubGVuZ3RoXTtcbiAgfVxufSk7XG52YXIgZ2V0QmFzZTE2Q29kZWMgPSAoKSA9PiBjb21iaW5lQ29kZWMoZ2V0QmFzZTE2RW5jb2RlcigpLCBnZXRCYXNlMTZEZWNvZGVyKCkpO1xuXG4vLyBzcmMvYmFzZTU4LnRzXG52YXIgYWxwaGFiZXQyID0gXCIxMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6XCI7XG52YXIgZ2V0QmFzZTU4RW5jb2RlciA9ICgpID0+IGdldEJhc2VYRW5jb2RlcihhbHBoYWJldDIpO1xudmFyIGdldEJhc2U1OERlY29kZXIgPSAoKSA9PiBnZXRCYXNlWERlY29kZXIoYWxwaGFiZXQyKTtcbnZhciBnZXRCYXNlNThDb2RlYyA9ICgpID0+IGdldEJhc2VYQ29kZWMoYWxwaGFiZXQyKTtcbnZhciBnZXRCYXNlWFJlc2xpY2VFbmNvZGVyID0gKGFscGhhYmV0NCwgYml0cykgPT4gY3JlYXRlRW5jb2Rlcih7XG4gIGdldFNpemVGcm9tVmFsdWU6ICh2YWx1ZSkgPT4gTWF0aC5mbG9vcih2YWx1ZS5sZW5ndGggKiBiaXRzIC8gOCksXG4gIHdyaXRlKHZhbHVlLCBieXRlcywgb2Zmc2V0KSB7XG4gICAgYXNzZXJ0VmFsaWRCYXNlU3RyaW5nKGFscGhhYmV0NCwgdmFsdWUpO1xuICAgIGlmICh2YWx1ZSA9PT0gXCJcIikgcmV0dXJuIG9mZnNldDtcbiAgICBjb25zdCBjaGFySW5kaWNlcyA9IFsuLi52YWx1ZV0ubWFwKChjKSA9PiBhbHBoYWJldDQuaW5kZXhPZihjKSk7XG4gICAgY29uc3QgcmVzbGljZWRCeXRlcyA9IHJlc2xpY2UoY2hhckluZGljZXMsIGJpdHMsIDgsIGZhbHNlKTtcbiAgICBieXRlcy5zZXQocmVzbGljZWRCeXRlcywgb2Zmc2V0KTtcbiAgICByZXR1cm4gcmVzbGljZWRCeXRlcy5sZW5ndGggKyBvZmZzZXQ7XG4gIH1cbn0pO1xudmFyIGdldEJhc2VYUmVzbGljZURlY29kZXIgPSAoYWxwaGFiZXQ0LCBiaXRzKSA9PiBjcmVhdGVEZWNvZGVyKHtcbiAgcmVhZChyYXdCeXRlcywgb2Zmc2V0ID0gMCkge1xuICAgIGNvbnN0IGJ5dGVzID0gb2Zmc2V0ID09PSAwID8gcmF3Qnl0ZXMgOiByYXdCeXRlcy5zbGljZShvZmZzZXQpO1xuICAgIGlmIChieXRlcy5sZW5ndGggPT09IDApIHJldHVybiBbXCJcIiwgcmF3Qnl0ZXMubGVuZ3RoXTtcbiAgICBjb25zdCBjaGFySW5kaWNlcyA9IHJlc2xpY2UoWy4uLmJ5dGVzXSwgOCwgYml0cywgdHJ1ZSk7XG4gICAgcmV0dXJuIFtjaGFySW5kaWNlcy5tYXAoKGkpID0+IGFscGhhYmV0NFtpXSkuam9pbihcIlwiKSwgcmF3Qnl0ZXMubGVuZ3RoXTtcbiAgfVxufSk7XG52YXIgZ2V0QmFzZVhSZXNsaWNlQ29kZWMgPSAoYWxwaGFiZXQ0LCBiaXRzKSA9PiBjb21iaW5lQ29kZWMoZ2V0QmFzZVhSZXNsaWNlRW5jb2RlcihhbHBoYWJldDQsIGJpdHMpLCBnZXRCYXNlWFJlc2xpY2VEZWNvZGVyKGFscGhhYmV0NCwgYml0cykpO1xuZnVuY3Rpb24gcmVzbGljZShpbnB1dCwgaW5wdXRCaXRzLCBvdXRwdXRCaXRzLCB1c2VSZW1haW5kZXIpIHtcbiAgY29uc3Qgb3V0cHV0ID0gW107XG4gIGxldCBhY2N1bXVsYXRvciA9IDA7XG4gIGxldCBiaXRzSW5BY2N1bXVsYXRvciA9IDA7XG4gIGNvbnN0IG1hc2sgPSAoMSA8PCBvdXRwdXRCaXRzKSAtIDE7XG4gIGZvciAoY29uc3QgdmFsdWUgb2YgaW5wdXQpIHtcbiAgICBhY2N1bXVsYXRvciA9IGFjY3VtdWxhdG9yIDw8IGlucHV0Qml0cyB8IHZhbHVlO1xuICAgIGJpdHNJbkFjY3VtdWxhdG9yICs9IGlucHV0Qml0cztcbiAgICB3aGlsZSAoYml0c0luQWNjdW11bGF0b3IgPj0gb3V0cHV0Qml0cykge1xuICAgICAgYml0c0luQWNjdW11bGF0b3IgLT0gb3V0cHV0Qml0cztcbiAgICAgIG91dHB1dC5wdXNoKGFjY3VtdWxhdG9yID4+IGJpdHNJbkFjY3VtdWxhdG9yICYgbWFzayk7XG4gICAgfVxuICB9XG4gIGlmICh1c2VSZW1haW5kZXIgJiYgYml0c0luQWNjdW11bGF0b3IgPiAwKSB7XG4gICAgb3V0cHV0LnB1c2goYWNjdW11bGF0b3IgPDwgb3V0cHV0Qml0cyAtIGJpdHNJbkFjY3VtdWxhdG9yICYgbWFzayk7XG4gIH1cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuLy8gc3JjL2Jhc2U2NC50c1xudmFyIGFscGhhYmV0MyA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiO1xudmFyIGdldEJhc2U2NEVuY29kZXIgPSAoKSA9PiB7XG4gIHtcbiAgICByZXR1cm4gY3JlYXRlRW5jb2Rlcih7XG4gICAgICBnZXRTaXplRnJvbVZhbHVlOiAodmFsdWUpID0+IEJ1ZmZlci5mcm9tKHZhbHVlLCBcImJhc2U2NFwiKS5sZW5ndGgsXG4gICAgICB3cml0ZSh2YWx1ZSwgYnl0ZXMsIG9mZnNldCkge1xuICAgICAgICBhc3NlcnRWYWxpZEJhc2VTdHJpbmcoYWxwaGFiZXQzLCB2YWx1ZS5yZXBsYWNlKC89L2csIFwiXCIpKTtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmZyb20odmFsdWUsIFwiYmFzZTY0XCIpO1xuICAgICAgICBieXRlcy5zZXQoYnVmZmVyLCBvZmZzZXQpO1xuICAgICAgICByZXR1cm4gYnVmZmVyLmxlbmd0aCArIG9mZnNldDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcbnZhciBnZXRCYXNlNjREZWNvZGVyID0gKCkgPT4ge1xuICB7XG4gICAgcmV0dXJuIGNyZWF0ZURlY29kZXIoe1xuICAgICAgcmVhZDogKGJ5dGVzLCBvZmZzZXQgPSAwKSA9PiBbQnVmZmVyLmZyb20odG9BcnJheUJ1ZmZlcihieXRlcyksIG9mZnNldCkudG9TdHJpbmcoXCJiYXNlNjRcIiksIGJ5dGVzLmxlbmd0aF1cbiAgICB9KTtcbiAgfVxufTtcbnZhciBnZXRCYXNlNjRDb2RlYyA9ICgpID0+IGNvbWJpbmVDb2RlYyhnZXRCYXNlNjRFbmNvZGVyKCksIGdldEJhc2U2NERlY29kZXIoKSk7XG5cbi8vIHNyYy9udWxsLWNoYXJhY3RlcnMudHNcbnZhciByZW1vdmVOdWxsQ2hhcmFjdGVycyA9ICh2YWx1ZSkgPT4gKFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleFxuICB2YWx1ZS5yZXBsYWNlKC9cXHUwMDAwL2csIFwiXCIpXG4pO1xudmFyIHBhZE51bGxDaGFyYWN0ZXJzID0gKHZhbHVlLCBjaGFycykgPT4gdmFsdWUucGFkRW5kKGNoYXJzLCBcIlxcMFwiKTtcblxuLy8gLi4vdGV4dC1lbmNvZGluZy1pbXBsL2Rpc3QvaW5kZXgubm9kZS5tanNcbnZhciBlID0gZ2xvYmFsVGhpcy5UZXh0RGVjb2RlcjtcbnZhciBvID0gZ2xvYmFsVGhpcy5UZXh0RW5jb2RlcjtcblxuLy8gc3JjL3V0ZjgudHNcbnZhciBnZXRVdGY4RW5jb2RlciA9ICgpID0+IHtcbiAgbGV0IHRleHRFbmNvZGVyO1xuICByZXR1cm4gY3JlYXRlRW5jb2Rlcih7XG4gICAgZ2V0U2l6ZUZyb21WYWx1ZTogKHZhbHVlKSA9PiAodGV4dEVuY29kZXIgfHw9IG5ldyBvKCkpLmVuY29kZSh2YWx1ZSkubGVuZ3RoLFxuICAgIHdyaXRlOiAodmFsdWUsIGJ5dGVzLCBvZmZzZXQpID0+IHtcbiAgICAgIGNvbnN0IGJ5dGVzVG9BZGQgPSAodGV4dEVuY29kZXIgfHw9IG5ldyBvKCkpLmVuY29kZSh2YWx1ZSk7XG4gICAgICBieXRlcy5zZXQoYnl0ZXNUb0FkZCwgb2Zmc2V0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgKyBieXRlc1RvQWRkLmxlbmd0aDtcbiAgICB9XG4gIH0pO1xufTtcbnZhciBnZXRVdGY4RGVjb2RlciA9ICgpID0+IHtcbiAgbGV0IHRleHREZWNvZGVyO1xuICByZXR1cm4gY3JlYXRlRGVjb2Rlcih7XG4gICAgcmVhZChieXRlcywgb2Zmc2V0KSB7XG4gICAgICBjb25zdCB2YWx1ZSA9ICh0ZXh0RGVjb2RlciB8fD0gbmV3IGUoKSkuZGVjb2RlKGJ5dGVzLnNsaWNlKG9mZnNldCkpO1xuICAgICAgcmV0dXJuIFtyZW1vdmVOdWxsQ2hhcmFjdGVycyh2YWx1ZSksIGJ5dGVzLmxlbmd0aF07XG4gICAgfVxuICB9KTtcbn07XG52YXIgZ2V0VXRmOENvZGVjID0gKCkgPT4gY29tYmluZUNvZGVjKGdldFV0ZjhFbmNvZGVyKCksIGdldFV0ZjhEZWNvZGVyKCkpO1xuXG5leHBvcnQgeyBhc3NlcnRWYWxpZEJhc2VTdHJpbmcsIGdldEJhc2UxMENvZGVjLCBnZXRCYXNlMTBEZWNvZGVyLCBnZXRCYXNlMTBFbmNvZGVyLCBnZXRCYXNlMTZDb2RlYywgZ2V0QmFzZTE2RGVjb2RlciwgZ2V0QmFzZTE2RW5jb2RlciwgZ2V0QmFzZTU4Q29kZWMsIGdldEJhc2U1OERlY29kZXIsIGdldEJhc2U1OEVuY29kZXIsIGdldEJhc2U2NENvZGVjLCBnZXRCYXNlNjREZWNvZGVyLCBnZXRCYXNlNjRFbmNvZGVyLCBnZXRCYXNlWENvZGVjLCBnZXRCYXNlWERlY29kZXIsIGdldEJhc2VYRW5jb2RlciwgZ2V0QmFzZVhSZXNsaWNlQ29kZWMsIGdldEJhc2VYUmVzbGljZURlY29kZXIsIGdldEJhc2VYUmVzbGljZUVuY29kZXIsIGdldFV0ZjhDb2RlYywgZ2V0VXRmOERlY29kZXIsIGdldFV0ZjhFbmNvZGVyLCBwYWROdWxsQ2hhcmFjdGVycywgcmVtb3ZlTnVsbENoYXJhY3RlcnMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm5vZGUubWpzLm1hcFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubm9kZS5tanMubWFwIl0sIm5hbWVzIjpbIlNvbGFuYUVycm9yIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfU1RSSU5HX0ZPUl9CQVNFIiwiY29tYmluZUNvZGVjIiwiY3JlYXRlRGVjb2RlciIsImNyZWF0ZUVuY29kZXIiLCJ0b0FycmF5QnVmZmVyIiwiYXNzZXJ0VmFsaWRCYXNlU3RyaW5nIiwiYWxwaGFiZXQ0IiwidGVzdFZhbHVlIiwiZ2l2ZW5WYWx1ZSIsIm1hdGNoIiwiUmVnRXhwIiwiYWxwaGFiZXQiLCJiYXNlIiwibGVuZ3RoIiwidmFsdWUiLCJnZXRCYXNlWEVuY29kZXIiLCJnZXRTaXplRnJvbVZhbHVlIiwibGVhZGluZ1plcm9lcyIsInRhaWxDaGFycyIsInBhcnRpdGlvbkxlYWRpbmdaZXJvZXMiLCJiYXNlMTBOdW1iZXIiLCJnZXRCaWdJbnRGcm9tQmFzZVgiLCJNYXRoIiwiY2VpbCIsInRvU3RyaW5nIiwid3JpdGUiLCJieXRlcyIsIm9mZnNldCIsInNldCIsIlVpbnQ4QXJyYXkiLCJmaWxsIiwidGFpbEJ5dGVzIiwidW5zaGlmdCIsIk51bWJlciIsImJ5dGVzVG9BZGQiLCJBcnJheSIsImdldEJhc2VYRGVjb2RlciIsInJlYWQiLCJyYXdCeXRlcyIsInNsaWNlIiwidHJhaWxJbmRleCIsImZpbmRJbmRleCIsIm4iLCJyZXBlYXQiLCJyZWR1Y2UiLCJzdW0iLCJieXRlIiwiQmlnSW50IiwiZ2V0QmFzZVhGcm9tQmlnSW50IiwiZ2V0QmFzZVhDb2RlYyIsInplcm9DaGFyYWN0ZXIiLCJsZWFkaW5nWmVyb3MiLCJzcGxpdCIsImNoYXIiLCJpbmRleE9mIiwiam9pbiIsImdldEJhc2UxMEVuY29kZXIiLCJnZXRCYXNlMTBEZWNvZGVyIiwiZ2V0QmFzZTEwQ29kZWMiLCJJTlZBTElEX1NUUklOR19FUlJPUl9CQVNFX0NPTkZJRyIsImNoYXJDb2RlVG9CYXNlMTYiLCJnZXRCYXNlMTZFbmNvZGVyIiwibGVuIiwiYWwiLCJjIiwiY2hhckNvZGVBdCIsImhleEJ5dGVzIiwiaSIsImoiLCJjMSIsImMyIiwibjEiLCJuMiIsImlzTmFOIiwiZ2V0QmFzZTE2RGVjb2RlciIsInN0ciIsInBhZFN0YXJ0IiwiZ2V0QmFzZTE2Q29kZWMiLCJhbHBoYWJldDIiLCJnZXRCYXNlNThFbmNvZGVyIiwiZ2V0QmFzZTU4RGVjb2RlciIsImdldEJhc2U1OENvZGVjIiwiZ2V0QmFzZVhSZXNsaWNlRW5jb2RlciIsImJpdHMiLCJmbG9vciIsImNoYXJJbmRpY2VzIiwibWFwIiwicmVzbGljZWRCeXRlcyIsInJlc2xpY2UiLCJnZXRCYXNlWFJlc2xpY2VEZWNvZGVyIiwiZ2V0QmFzZVhSZXNsaWNlQ29kZWMiLCJpbnB1dCIsImlucHV0Qml0cyIsIm91dHB1dEJpdHMiLCJ1c2VSZW1haW5kZXIiLCJvdXRwdXQiLCJhY2N1bXVsYXRvciIsImJpdHNJbkFjY3VtdWxhdG9yIiwibWFzayIsInB1c2giLCJhbHBoYWJldDMiLCJnZXRCYXNlNjRFbmNvZGVyIiwiQnVmZmVyIiwiZnJvbSIsInJlcGxhY2UiLCJidWZmZXIiLCJnZXRCYXNlNjREZWNvZGVyIiwiZ2V0QmFzZTY0Q29kZWMiLCJyZW1vdmVOdWxsQ2hhcmFjdGVycyIsInBhZE51bGxDaGFyYWN0ZXJzIiwiY2hhcnMiLCJwYWRFbmQiLCJlIiwiZ2xvYmFsVGhpcyIsIlRleHREZWNvZGVyIiwibyIsIlRleHRFbmNvZGVyIiwiZ2V0VXRmOEVuY29kZXIiLCJ0ZXh0RW5jb2RlciIsImVuY29kZSIsImdldFV0ZjhEZWNvZGVyIiwidGV4dERlY29kZXIiLCJkZWNvZGUiLCJnZXRVdGY4Q29kZWMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/codecs-strings/dist/index.node.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/errors/dist/index.node.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/@solana/errors/dist/index.node.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND: () => (/* binding */ SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND),\n/* harmony export */   SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED: () => (/* binding */ SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED),\n/* harmony export */   SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT: () => (/* binding */ SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT),\n/* harmony export */   SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT: () => (/* binding */ SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT),\n/* harmony export */   SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND: () => (/* binding */ SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED: () => (/* binding */ SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS: () => (/* binding */ SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH: () => (/* binding */ SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY: () => (/* binding */ SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS: () => (/* binding */ SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE: () => (/* binding */ SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__MALFORMED_PDA: () => (/* binding */ SOLANA_ERROR__ADDRESSES__MALFORMED_PDA),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED: () => (/* binding */ SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED: () => (/* binding */ SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER: () => (/* binding */ SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED: () => (/* binding */ SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED),\n/* harmony export */   SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY: () => (/* binding */ SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY),\n/* harmony export */   SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS: () => (/* binding */ SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS),\n/* harmony export */   SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL: () => (/* binding */ SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL),\n/* harmony export */   SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH: () => (/* binding */ SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH),\n/* harmony export */   SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH: () => (/* binding */ SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH),\n/* harmony export */   SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH: () => (/* binding */ SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH),\n/* harmony export */   SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY: () => (/* binding */ SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY),\n/* harmony export */   SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH: () => (/* binding */ SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH),\n/* harmony export */   SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH: () => (/* binding */ SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH),\n/* harmony export */   SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH: () => (/* binding */ SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH),\n/* harmony export */   SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE: () => (/* binding */ SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE),\n/* harmony export */   SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH: () => (/* binding */ SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH),\n/* harmony export */   SOLANA_ERROR__CODECS__INVALID_CONSTANT: () => (/* binding */ SOLANA_ERROR__CODECS__INVALID_CONSTANT),\n/* harmony export */   SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT: () => (/* binding */ SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT),\n/* harmony export */   SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT: () => (/* binding */ SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT),\n/* harmony export */   SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT: () => (/* binding */ SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT),\n/* harmony export */   SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS: () => (/* binding */ SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS),\n/* harmony export */   SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE: () => (/* binding */ SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE),\n/* harmony export */   SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES: () => (/* binding */ SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES),\n/* harmony export */   SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED: () => (/* binding */ SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_PLANS__EMPTY_INSTRUCTION_PLAN: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_PLANS__EMPTY_INSTRUCTION_PLAN),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_PLANS__EXPECTED_SUCCESSFUL_TRANSACTION_PLAN_RESULT: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_PLANS__EXPECTED_SUCCESSFUL_TRANSACTION_PLAN_RESULT),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_SINGLE_TRANSACTION_PLAN_RESULT_NOT_FOUND: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_SINGLE_TRANSACTION_PLAN_RESULT_NOT_FOUND),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_PLANS__NON_DIVISIBLE_TRANSACTION_PLANS_NOT_SUPPORTED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_PLANS__NON_DIVISIBLE_TRANSACTION_PLANS_NOT_SUPPORTED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_INSTRUCTION_PLAN: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_INSTRUCTION_PLAN),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS: () => (/* binding */ SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA: () => (/* binding */ SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH: () => (/* binding */ SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH),\n/* harmony export */   SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH: () => (/* binding */ SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH),\n/* harmony export */   SOLANA_ERROR__INVALID_NONCE: () => (/* binding */ SOLANA_ERROR__INVALID_NONCE),\n/* harmony export */   SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING: () => (/* binding */ SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING),\n/* harmony export */   SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED: () => (/* binding */ SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED),\n/* harmony export */   SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND: () => (/* binding */ SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND),\n/* harmony export */   SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND: () => (/* binding */ SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND),\n/* harmony export */   SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE: () => (/* binding */ SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE),\n/* harmony export */   SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING: () => (/* binding */ SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING),\n/* harmony export */   SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE: () => (/* binding */ SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR: () => (/* binding */ SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__INVALID_PARAMS: () => (/* binding */ SOLANA_ERROR__JSON_RPC__INVALID_PARAMS),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__INVALID_REQUEST: () => (/* binding */ SOLANA_ERROR__JSON_RPC__INVALID_REQUEST),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND: () => (/* binding */ SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__PARSE_ERROR: () => (/* binding */ SOLANA_ERROR__JSON_RPC__PARSE_ERROR),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SCAN_ERROR: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SCAN_ERROR),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_EPOCH_REWARDS_PERIOD_ACTIVE: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_EPOCH_REWARDS_PERIOD_ACTIVE),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_UNREACHABLE: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_UNREACHABLE),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_NOT_EPOCH_BOUNDARY: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_NOT_EPOCH_BOUNDARY),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION),\n/* harmony export */   SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH: () => (/* binding */ SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH),\n/* harmony export */   SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH: () => (/* binding */ SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH),\n/* harmony export */   SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH: () => (/* binding */ SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH),\n/* harmony export */   SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY: () => (/* binding */ SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY),\n/* harmony export */   SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__MALFORMED_BIGINT_STRING: () => (/* binding */ SOLANA_ERROR__MALFORMED_BIGINT_STRING),\n/* harmony export */   SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR: () => (/* binding */ SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR),\n/* harmony export */   SOLANA_ERROR__MALFORMED_NUMBER_STRING: () => (/* binding */ SOLANA_ERROR__MALFORMED_NUMBER_STRING),\n/* harmony export */   SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND: () => (/* binding */ SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND),\n/* harmony export */   SOLANA_ERROR__OFFCHAIN_MESSAGE__ADDRESSES_CANNOT_SIGN_OFFCHAIN_MESSAGE: () => (/* binding */ SOLANA_ERROR__OFFCHAIN_MESSAGE__ADDRESSES_CANNOT_SIGN_OFFCHAIN_MESSAGE),\n/* harmony export */   SOLANA_ERROR__OFFCHAIN_MESSAGE__APPLICATION_DOMAIN_STRING_LENGTH_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__OFFCHAIN_MESSAGE__APPLICATION_DOMAIN_STRING_LENGTH_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__OFFCHAIN_MESSAGE__ENVELOPE_SIGNERS_MISMATCH: () => (/* binding */ SOLANA_ERROR__OFFCHAIN_MESSAGE__ENVELOPE_SIGNERS_MISMATCH),\n/* harmony export */   SOLANA_ERROR__OFFCHAIN_MESSAGE__INVALID_APPLICATION_DOMAIN_BYTE_LENGTH: () => (/* binding */ SOLANA_ERROR__OFFCHAIN_MESSAGE__INVALID_APPLICATION_DOMAIN_BYTE_LENGTH),\n/* harmony export */   SOLANA_ERROR__OFFCHAIN_MESSAGE__MAXIMUM_LENGTH_EXCEEDED: () => (/* binding */ SOLANA_ERROR__OFFCHAIN_MESSAGE__MAXIMUM_LENGTH_EXCEEDED),\n/* harmony export */   SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_FORMAT_MISMATCH: () => (/* binding */ SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_FORMAT_MISMATCH),\n/* harmony export */   SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_LENGTH_MISMATCH: () => (/* binding */ SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_LENGTH_MISMATCH),\n/* harmony export */   SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY: () => (/* binding */ SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY),\n/* harmony export */   SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_ENVELOPE_SIGNATURES_CANNOT_BE_ZERO: () => (/* binding */ SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_ENVELOPE_SIGNATURES_CANNOT_BE_ZERO),\n/* harmony export */   SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO: () => (/* binding */ SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO),\n/* harmony export */   SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_SIGNATURES_MISMATCH: () => (/* binding */ SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_SIGNATURES_MISMATCH),\n/* harmony export */   SOLANA_ERROR__OFFCHAIN_MESSAGE__RESTRICTED_ASCII_BODY_CHARACTER_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__OFFCHAIN_MESSAGE__RESTRICTED_ASCII_BODY_CHARACTER_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_SORTED: () => (/* binding */ SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_SORTED),\n/* harmony export */   SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_UNIQUE: () => (/* binding */ SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_UNIQUE),\n/* harmony export */   SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURES_MISSING: () => (/* binding */ SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURES_MISSING),\n/* harmony export */   SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURE_VERIFICATION_FAILURE: () => (/* binding */ SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURE_VERIFICATION_FAILURE),\n/* harmony export */   SOLANA_ERROR__OFFCHAIN_MESSAGE__UNEXPECTED_VERSION: () => (/* binding */ SOLANA_ERROR__OFFCHAIN_MESSAGE__UNEXPECTED_VERSION),\n/* harmony export */   SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED: () => (/* binding */ SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED),\n/* harmony export */   SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN: () => (/* binding */ SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN),\n/* harmony export */   SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED: () => (/* binding */ SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED),\n/* harmony export */   SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED: () => (/* binding */ SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED),\n/* harmony export */   SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT: () => (/* binding */ SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT),\n/* harmony export */   SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID: () => (/* binding */ SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID),\n/* harmony export */   SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD: () => (/* binding */ SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD),\n/* harmony export */   SOLANA_ERROR__RPC__INTEGER_OVERFLOW: () => (/* binding */ SOLANA_ERROR__RPC__INTEGER_OVERFLOW),\n/* harmony export */   SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR: () => (/* binding */ SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR),\n/* harmony export */   SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN: () => (/* binding */ SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN),\n/* harmony export */   SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS: () => (/* binding */ SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS),\n/* harmony export */   SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER: () => (/* binding */ SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER),\n/* harmony export */   SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER: () => (/* binding */ SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER),\n/* harmony export */   SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER: () => (/* binding */ SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER),\n/* harmony export */   SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER: () => (/* binding */ SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER),\n/* harmony export */   SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER: () => (/* binding */ SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER),\n/* harmony export */   SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER: () => (/* binding */ SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER),\n/* harmony export */   SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER: () => (/* binding */ SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER),\n/* harmony export */   SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER: () => (/* binding */ SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER),\n/* harmony export */   SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS: () => (/* binding */ SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS),\n/* harmony export */   SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING: () => (/* binding */ SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING),\n/* harmony export */   SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED: () => (/* binding */ SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED),\n/* harmony export */   SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY: () => (/* binding */ SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY),\n/* harmony export */   SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED: () => (/* binding */ SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED),\n/* harmony export */   SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT: () => (/* binding */ SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT),\n/* harmony export */   SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED: () => (/* binding */ SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED),\n/* harmony export */   SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED: () => (/* binding */ SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED),\n/* harmony export */   SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED: () => (/* binding */ SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED),\n/* harmony export */   SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED: () => (/* binding */ SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED),\n/* harmony export */   SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED: () => (/* binding */ SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED),\n/* harmony export */   SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION: () => (/* binding */ SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING: () => (/* binding */ SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES: () => (/* binding */ SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT: () => (/* binding */ SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME: () => (/* binding */ SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME: () => (/* binding */ SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING: () => (/* binding */ SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING: () => (/* binding */ SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND: () => (/* binding */ SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT: () => (/* binding */ SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT: () => (/* binding */ SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING: () => (/* binding */ SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING: () => (/* binding */ SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE: () => (/* binding */ SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING: () => (/* binding */ SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES: () => (/* binding */ SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE: () => (/* binding */ SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH: () => (/* binding */ SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__NONCE_ACCOUNT_CANNOT_BE_IN_LOOKUP_TABLE: () => (/* binding */ SOLANA_ERROR__TRANSACTION__NONCE_ACCOUNT_CANNOT_BE_IN_LOOKUP_TABLE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING: () => (/* binding */ SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED: () => (/* binding */ SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE),\n/* harmony export */   SolanaError: () => (/* binding */ SolanaError),\n/* harmony export */   getSolanaErrorFromInstructionError: () => (/* binding */ getSolanaErrorFromInstructionError),\n/* harmony export */   getSolanaErrorFromJsonRpcError: () => (/* binding */ getSolanaErrorFromJsonRpcError),\n/* harmony export */   getSolanaErrorFromTransactionError: () => (/* binding */ getSolanaErrorFromTransactionError),\n/* harmony export */   isSolanaError: () => (/* binding */ isSolanaError),\n/* harmony export */   safeCaptureStackTrace: () => (/* binding */ safeCaptureStackTrace),\n/* harmony export */   unwrapSimulationError: () => (/* binding */ unwrapSimulationError)\n/* harmony export */ });\n// src/codes.ts\nvar SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED = 1;\nvar SOLANA_ERROR__INVALID_NONCE = 2;\nvar SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND = 3;\nvar SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE = 4;\nvar SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH = 5;\nvar SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE = 6;\nvar SOLANA_ERROR__MALFORMED_BIGINT_STRING = 7;\nvar SOLANA_ERROR__MALFORMED_NUMBER_STRING = 8;\nvar SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE = 9;\nvar SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR = 10;\nvar SOLANA_ERROR__JSON_RPC__PARSE_ERROR = -32700;\nvar SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR = -32603;\nvar SOLANA_ERROR__JSON_RPC__INVALID_PARAMS = -32602;\nvar SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND = -32601;\nvar SOLANA_ERROR__JSON_RPC__INVALID_REQUEST = -32600;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_UNREACHABLE = -32019;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_NOT_EPOCH_BOUNDARY = -32018;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_EPOCH_REWARDS_PERIOD_ACTIVE = -32017;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED = -32016;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION = -32015;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET = -32014;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH = -32013;\nvar SOLANA_ERROR__JSON_RPC__SCAN_ERROR = -32012;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE = -32011;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX = -32010;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED = -32009;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT = -32008;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED = -32007;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE = -32006;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY = -32005;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE = -32004;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE = -32003;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE = -32002;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP = -32001;\nvar SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH = 28e5;\nvar SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE = 2800001;\nvar SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS = 2800002;\nvar SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY = 2800003;\nvar SOLANA_ERROR__ADDRESSES__MALFORMED_PDA = 2800004;\nvar SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE = 2800005;\nvar SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED = 2800006;\nvar SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED = 2800007;\nvar SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE = 2800008;\nvar SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED = 2800009;\nvar SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER = 2800010;\nvar SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS = 2800011;\nvar SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND = 323e4;\nvar SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND = 32300001;\nvar SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT = 3230002;\nvar SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT = 3230003;\nvar SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED = 3230004;\nvar SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT = 361e4;\nvar SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED = 3610001;\nvar SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED = 3610002;\nvar SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED = 3610003;\nvar SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED = 3610004;\nvar SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED = 3610005;\nvar SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED = 3610006;\nvar SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY = 3610007;\nvar SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED = 3611e3;\nvar SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH = 3704e3;\nvar SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH = 3704001;\nvar SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH = 3704002;\nvar SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE = 3704003;\nvar SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY = 3704004;\nvar SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS = 4128e3;\nvar SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA = 4128001;\nvar SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH = 4128002;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN = 4615e3;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR = 4615001;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT = 4615002;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA = 4615003;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA = 4615004;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL = 4615005;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS = 4615006;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID = 4615007;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE = 4615008;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED = 4615009;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT = 4615010;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION = 4615011;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID = 4615012;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND = 4615013;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED = 4615014;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE = 4615015;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED = 4615016;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX = 4615017;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED = 4615018;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED = 4615019;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS = 4615020;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED = 4615021;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE = 4615022;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED = 4615023;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 4615024;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC = 4615025;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM = 4615026;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR = 4615027;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED = 4615028;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE = 4615029;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT = 4615030;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID = 4615031;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH = 4615032;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT = 4615033;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED = 4615034;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED = 4615035;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS = 4615036;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC = 4615037;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED = 4615038;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION = 4615039;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE = 4615040;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE = 4615041;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE = 4615042;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE = 4615043;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY = 4615044;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR = 4615045;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT = 4615046;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER = 4615047;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW = 4615048;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR = 4615049;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER = 4615050;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED = 4615051;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED = 4615052;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED = 4615053;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS = 4615054;\nvar SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS = 5508e3;\nvar SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER = 5508001;\nvar SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER = 5508002;\nvar SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER = 5508003;\nvar SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER = 5508004;\nvar SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER = 5508005;\nvar SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER = 5508006;\nvar SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER = 5508007;\nvar SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER = 5508008;\nvar SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS = 5508009;\nvar SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING = 5508010;\nvar SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED = 5508011;\nvar SOLANA_ERROR__OFFCHAIN_MESSAGE__MAXIMUM_LENGTH_EXCEEDED = 5607e3;\nvar SOLANA_ERROR__OFFCHAIN_MESSAGE__RESTRICTED_ASCII_BODY_CHARACTER_OUT_OF_RANGE = 5607001;\nvar SOLANA_ERROR__OFFCHAIN_MESSAGE__APPLICATION_DOMAIN_STRING_LENGTH_OUT_OF_RANGE = 5607002;\nvar SOLANA_ERROR__OFFCHAIN_MESSAGE__INVALID_APPLICATION_DOMAIN_BYTE_LENGTH = 5607003;\nvar SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_SIGNATURES_MISMATCH = 5607004;\nvar SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO = 5607005;\nvar SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED = 5607006;\nvar SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_FORMAT_MISMATCH = 5607007;\nvar SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_LENGTH_MISMATCH = 5607008;\nvar SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY = 5607009;\nvar SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_ENVELOPE_SIGNATURES_CANNOT_BE_ZERO = 5607010;\nvar SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURES_MISSING = 5607011;\nvar SOLANA_ERROR__OFFCHAIN_MESSAGE__ENVELOPE_SIGNERS_MISMATCH = 5607012;\nvar SOLANA_ERROR__OFFCHAIN_MESSAGE__ADDRESSES_CANNOT_SIGN_OFFCHAIN_MESSAGE = 5607013;\nvar SOLANA_ERROR__OFFCHAIN_MESSAGE__UNEXPECTED_VERSION = 5607014;\nvar SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_SORTED = 5607015;\nvar SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_UNIQUE = 5607016;\nvar SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURE_VERIFICATION_FAILURE = 5607017;\nvar SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES = 5663e3;\nvar SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE = 5663001;\nvar SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME = 5663002;\nvar SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME = 5663003;\nvar SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE = 5663004;\nvar SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING = 5663005;\nvar SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE = 5663006;\nvar SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND = 5663007;\nvar SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING = 5663008;\nvar SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING = 5663009;\nvar SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING = 5663010;\nvar SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING = 5663011;\nvar SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING = 5663012;\nvar SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING = 5663013;\nvar SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE = 5663014;\nvar SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION = 5663015;\nvar SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES = 5663016;\nvar SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH = 5663017;\nvar SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT = 5663018;\nvar SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT = 5663019;\nvar SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT = 5663020;\nvar SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED = 5663021;\nvar SOLANA_ERROR__TRANSACTION__NONCE_ACCOUNT_CANNOT_BE_IN_LOOKUP_TABLE = 5663022;\nvar SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN = 705e4;\nvar SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE = 7050001;\nvar SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE = 7050002;\nvar SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND = 7050003;\nvar SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND = 7050004;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE = 7050005;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE = 7050006;\nvar SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED = 7050007;\nvar SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND = 7050008;\nvar SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP = 7050009;\nvar SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE = 7050010;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX = 7050011;\nvar SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE = 7050012;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION = 7050013;\nvar SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE = 7050014;\nvar SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE = 7050015;\nvar SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 7050016;\nvar SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT = 7050017;\nvar SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION = 7050018;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT = 7050019;\nvar SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT = 7050020;\nvar SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT = 7050021;\nvar SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS = 7050022;\nvar SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND = 7050023;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER = 7050024;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA = 7050025;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX = 7050026;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT = 7050027;\nvar SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT = 7050028;\nvar SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT = 7050029;\nvar SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION = 7050030;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT = 7050031;\nvar SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED = 7050032;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT = 7050033;\nvar SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED = 7050034;\nvar SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED = 7050035;\nvar SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION = 7050036;\nvar SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN = 7618e3;\nvar SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE = 7618001;\nvar SOLANA_ERROR__INSTRUCTION_PLANS__EMPTY_INSTRUCTION_PLAN = 7618002;\nvar SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN = 7618003;\nvar SOLANA_ERROR__INSTRUCTION_PLANS__NON_DIVISIBLE_TRANSACTION_PLANS_NOT_SUPPORTED = 7618004;\nvar SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_SINGLE_TRANSACTION_PLAN_RESULT_NOT_FOUND = 7618005;\nvar SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_INSTRUCTION_PLAN = 7618006;\nvar SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN = 7618007;\nvar SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT = 7618008;\nvar SOLANA_ERROR__INSTRUCTION_PLANS__EXPECTED_SUCCESSFUL_TRANSACTION_PLAN_RESULT = 7618009;\nvar SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY = 8078e3;\nvar SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH = 8078001;\nvar SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH = 8078002;\nvar SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH = 8078003;\nvar SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH = 8078004;\nvar SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH = 8078005;\nvar SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH = 8078006;\nvar SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS = 8078007;\nvar SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE = 8078008;\nvar SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT = 8078009;\nvar SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT = 8078010;\nvar SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE = 8078011;\nvar SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE = 8078012;\nvar SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH = 8078013;\nvar SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE = 8078014;\nvar SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT = 8078015;\nvar SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE = 8078016;\nvar SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE = 8078017;\nvar SOLANA_ERROR__CODECS__INVALID_CONSTANT = 8078018;\nvar SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE = 8078019;\nvar SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL = 8078020;\nvar SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES = 8078021;\nvar SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS = 8078022;\nvar SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY = 8078023;\nvar SOLANA_ERROR__RPC__INTEGER_OVERFLOW = 81e5;\nvar SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN = 8100001;\nvar SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR = 8100002;\nvar SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD = 8100003;\nvar SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN = 819e4;\nvar SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID = 8190001;\nvar SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED = 8190002;\nvar SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED = 8190003;\nvar SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT = 8190004;\nvar SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING = 99e5;\nvar SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE = 9900001;\nvar SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING = 9900002;\nvar SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE = 9900003;\nvar SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED = 9900004;\nvar SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND = 9900005;\nvar SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND = 9900006;\n// src/context.ts\nfunction encodeValue(value) {\n    if (Array.isArray(value)) {\n        const commaSeparatedValues = value.map(encodeValue).join(\"%2C%20\");\n        return \"%5B\" + commaSeparatedValues + /* \"]\" */ \"%5D\";\n    } else if (typeof value === \"bigint\") {\n        return `${value}n`;\n    } else {\n        return encodeURIComponent(String(value != null && Object.getPrototypeOf(value) === null ? // Plain objects with no prototype don't have a `toString` method.\n        // Convert them before stringifying them.\n        {\n            ...value\n        } : value));\n    }\n}\nfunction encodeObjectContextEntry([key, value]) {\n    return `${key}=${encodeValue(value)}`;\n}\nfunction encodeContextObject(context) {\n    const searchParamsString = Object.entries(context).map(encodeObjectContextEntry).join(\"&\");\n    return Buffer.from(searchParamsString, \"utf8\").toString(\"base64\");\n}\n// src/messages.ts\nvar SolanaErrorMessages = {\n    [SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND]: \"Account not found at address: $address\",\n    [SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED]: \"Not all accounts were decoded. Encoded accounts found at addresses: $addresses.\",\n    [SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT]: \"Expected decoded account at address: $address\",\n    [SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT]: \"Failed to decode account data at address: $address\",\n    [SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND]: \"Accounts not found at addresses: $addresses\",\n    [SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED]: \"Unable to find a viable program address bump seed.\",\n    [SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS]: \"$putativeAddress is not a base58-encoded address.\",\n    [SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH]: \"Expected base58 encoded address to decode to a byte array of length 32. Actual length: $actualLength.\",\n    [SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY]: \"The `CryptoKey` must be an `Ed25519` public key.\",\n    [SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS]: \"$putativeOffCurveAddress is not a base58-encoded off-curve address.\",\n    [SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE]: \"Invalid seeds; point must fall off the Ed25519 curve.\",\n    [SOLANA_ERROR__ADDRESSES__MALFORMED_PDA]: \"Expected given program derived address to have the following format: [Address, ProgramDerivedAddressBump].\",\n    [SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED]: \"A maximum of $maxSeeds seeds, including the bump seed, may be supplied when creating an address. Received: $actual.\",\n    [SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED]: \"The seed at index $index with length $actual exceeds the maximum length of $maxSeedLength bytes.\",\n    [SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE]: \"Expected program derived address bump to be in the range [0, 255], got: $bump.\",\n    [SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER]: \"Program address cannot end with PDA marker.\",\n    [SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE]: \"Expected base58-encoded address string of length in the range [32, 44]. Actual length: $actualLength.\",\n    [SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE]: \"Expected base58-encoded blockash string of length in the range [32, 44]. Actual length: $actualLength.\",\n    [SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED]: \"The network has progressed past the last block for which this transaction could have been committed.\",\n    [SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY]: \"Codec [$codecDescription] cannot decode empty byte arrays.\",\n    [SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS]: \"Enum codec cannot use lexical values [$stringValues] as discriminators. Either remove all lexical values or set `useValuesAsDiscriminators` to `false`.\",\n    [SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL]: \"Sentinel [$hexSentinel] must not be present in encoded bytes [$hexEncodedBytes].\",\n    [SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH]: \"Encoder and decoder must have the same fixed size, got [$encoderFixedSize] and [$decoderFixedSize].\",\n    [SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH]: \"Encoder and decoder must have the same max size, got [$encoderMaxSize] and [$decoderMaxSize].\",\n    [SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH]: \"Encoder and decoder must either both be fixed-size or variable-size.\",\n    [SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE]: \"Enum discriminator out of range. Expected a number in [$formattedValidDiscriminators], got $discriminator.\",\n    [SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH]: \"Expected a fixed-size codec, got a variable-size one.\",\n    [SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH]: \"Codec [$codecDescription] expected a positive byte length, got $bytesLength.\",\n    [SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH]: \"Expected a variable-size codec, got a fixed-size one.\",\n    [SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE]: \"Codec [$codecDescription] expected zero-value [$hexZeroValue] to have the same size as the provided fixed-size item [$expectedSize bytes].\",\n    [SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH]: \"Codec [$codecDescription] expected $expected bytes, got $bytesLength.\",\n    [SOLANA_ERROR__CODECS__INVALID_CONSTANT]: \"Expected byte array constant [$hexConstant] to be present in data [$hexData] at offset [$offset].\",\n    [SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT]: \"Invalid discriminated union variant. Expected one of [$variants], got $value.\",\n    [SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT]: \"Invalid enum variant. Expected one of [$stringValues] or a number in [$formattedNumericalValues], got $variant.\",\n    [SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT]: \"Invalid literal union variant. Expected one of [$variants], got $value.\",\n    [SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS]: \"Expected [$codecDescription] to have $expected items, got $actual.\",\n    [SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE]: \"Invalid value $value for base $base with alphabet $alphabet.\",\n    [SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE]: \"Literal union discriminator out of range. Expected a number between $minRange and $maxRange, got $discriminator.\",\n    [SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE]: \"Codec [$codecDescription] expected number to be in the range [$min, $max], got $value.\",\n    [SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE]: \"Codec [$codecDescription] expected offset to be in the range [0, $bytesLength], got $offset.\",\n    [SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES]: \"Expected sentinel [$hexSentinel] to be present in decoded bytes [$hexDecodedBytes].\",\n    [SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE]: \"Union variant out of range. Expected an index between $minRange and $maxRange, got $variant.\",\n    [SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY]: \"This decoder expected a byte array of exactly $expectedLength bytes, but $numExcessBytes unexpected excess bytes remained after decoding. Are you sure that you have chosen the correct decoder for this data?\",\n    [SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED]: \"No random values implementation could be found.\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED]: \"instruction requires an uninitialized account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED]: \"instruction tries to borrow reference for an account which is already borrowed\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]: \"instruction left account with an outstanding borrowed reference\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED]: \"program other than the account's owner changed the size of the account data\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL]: \"account data too small for instruction\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE]: \"instruction expected an executable account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT]: \"An account does not have enough lamports to be rent-exempt\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW]: \"Program arithmetic overflowed\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR]: \"Failed to serialize or deserialize account data: $encodedData\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS]: \"Builtin programs must consume compute units\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH]: \"Cross-program invocation call depth too deep\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED]: \"Computational budget exceeded\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM]: \"custom program error: #$code\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX]: \"instruction contains duplicate accounts\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC]: \"instruction modifications of multiply-passed account differ\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT]: \"executable accounts must be rent exempt\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED]: \"instruction changed executable accounts data\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE]: \"instruction changed the balance of an executable account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED]: \"instruction changed executable bit of an account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED]: \"instruction modified data of an account it does not own\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND]: \"instruction spent from the balance of an account it does not own\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR]: \"generic instruction error\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER]: \"Provided owner is not allowed\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE]: \"Account is immutable\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY]: \"Incorrect authority provided\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID]: \"incorrect program id for instruction\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS]: \"insufficient funds for instruction\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA]: \"invalid account data for instruction\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER]: \"Invalid account owner\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT]: \"invalid program argument\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR]: \"program returned invalid error code\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA]: \"invalid instruction data\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC]: \"Failed to reallocate account data\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS]: \"Provided seeds do not result in a valid address\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED]: \"Accounts data allocations exceeded the maximum allowed per transaction\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED]: \"Max accounts exceeded\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED]: \"Max instruction trace length exceeded\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED]: \"Length of the seed is too long for address generation\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT]: \"An account required by the instruction is missing\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE]: \"missing required signature for instruction\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID]: \"instruction illegally modified the program id of an account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS]: \"insufficient account keys for instruction\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION]: \"Cross-program invocation with unauthorized signer or writable account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE]: \"Failed to create program execution environment\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE]: \"Program failed to compile\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE]: \"Program failed to complete\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED]: \"instruction modified data of a read-only account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE]: \"instruction changed the balance of a read-only account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED]: \"Cross-program invocation reentrancy not allowed for this instruction\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED]: \"instruction modified rent epoch of an account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION]: \"sum of account balances before and after instruction do not match\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT]: \"instruction requires an initialized account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN]: \"\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID]: \"Unsupported program id\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR]: \"Unsupported sysvar\",\n    [SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND]: \"Invalid instruction plan kind: $kind.\",\n    [SOLANA_ERROR__INSTRUCTION_PLANS__EMPTY_INSTRUCTION_PLAN]: \"The provided instruction plan is empty.\",\n    [SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_SINGLE_TRANSACTION_PLAN_RESULT_NOT_FOUND]: \"No failed transaction plan result was found in the provided transaction plan result.\",\n    [SOLANA_ERROR__INSTRUCTION_PLANS__NON_DIVISIBLE_TRANSACTION_PLANS_NOT_SUPPORTED]: \"This transaction plan executor does not support non-divisible sequential plans. To support them, you may create your own executor such that multi-transaction atomicity is preserved  e.g. by targetting RPCs that support transaction bundles.\",\n    [SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN]: \"The provided transaction plan failed to execute. See the `transactionPlanResult` attribute for more details. Note that the `cause` property is deprecated, and a future version will not set it.\",\n    [SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN]: \"The provided message has insufficient capacity to accommodate the next instruction(s) in this plan. Expected at least $numBytesRequired free byte(s), got $numFreeBytes byte(s).\",\n    [SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND]: \"Invalid transaction plan kind: $kind.\",\n    [SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE]: \"No more instructions to pack; the message packer has completed the instruction plan.\",\n    [SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_INSTRUCTION_PLAN]: \"Unexpected instruction plan. Expected $expectedKind plan, got $actualKind plan.\",\n    [SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN]: \"Unexpected transaction plan. Expected $expectedKind plan, got $actualKind plan.\",\n    [SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT]: \"Unexpected transaction plan result. Expected $expectedKind plan, got $actualKind plan.\",\n    [SOLANA_ERROR__INSTRUCTION_PLANS__EXPECTED_SUCCESSFUL_TRANSACTION_PLAN_RESULT]: \"Expected a successful transaction plan result. I.e. there is at least one failed or cancelled transaction in the plan.\",\n    [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS]: \"The instruction does not have any accounts.\",\n    [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA]: \"The instruction does not have any data.\",\n    [SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH]: \"Expected instruction to have progress address $expectedProgramAddress, got $actualProgramAddress.\",\n    [SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH]: \"Expected base58 encoded blockhash to decode to a byte array of length 32. Actual length: $actualLength.\",\n    [SOLANA_ERROR__INVALID_NONCE]: \"The nonce `$expectedNonceValue` is no longer valid. It has advanced to `$actualNonceValue`\",\n    [SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING]: \"Invariant violation: Found no abortable iterable cache entry for key `$cacheKey`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant\",\n    [SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED]: \"Invariant violation: This data publisher does not publish to the channel named `$channelName`. Supported channels include $supportedChannelNames.\",\n    [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE]: \"Invariant violation: WebSocket message iterator state is corrupt; iterated without first resolving existing message promise. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant\",\n    [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING]: \"Invariant violation: WebSocket message iterator is missing state storage. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant\",\n    [SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE]: \"Invariant violation: Switch statement non-exhaustive. Received unexpected value `$unexpectedValue`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant\",\n    [SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR]: \"JSON-RPC error: Internal JSON-RPC error ($__serverMessage)\",\n    [SOLANA_ERROR__JSON_RPC__INVALID_PARAMS]: \"JSON-RPC error: Invalid method parameter(s) ($__serverMessage)\",\n    [SOLANA_ERROR__JSON_RPC__INVALID_REQUEST]: \"JSON-RPC error: The JSON sent is not a valid `Request` object ($__serverMessage)\",\n    [SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND]: \"JSON-RPC error: The method does not exist / is not available ($__serverMessage)\",\n    [SOLANA_ERROR__JSON_RPC__PARSE_ERROR]: \"JSON-RPC error: An error occurred on the server while parsing the JSON text ($__serverMessage)\",\n    [SOLANA_ERROR__JSON_RPC__SCAN_ERROR]: \"$__serverMessage\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP]: \"$__serverMessage\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE]: \"$__serverMessage\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET]: \"$__serverMessage\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_EPOCH_REWARDS_PERIOD_ACTIVE]: \"Epoch rewards period still active at slot $slot\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX]: \"$__serverMessage\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED]: \"$__serverMessage\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_UNREACHABLE]: \"Failed to query long-term storage; please try again\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED]: \"Minimum context slot has not been reached\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY]: \"Node is unhealthy; behind by $numSlotsBehind slots\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT]: \"No snapshot\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE]: \"Transaction simulation failed\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_NOT_EPOCH_BOUNDARY]: \"Rewards cannot be found because slot $slot is not the epoch boundary. This may be due to gap in the queried node's local ledger or long-term storage\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED]: \"$__serverMessage\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE]: \"Transaction history is not available from this node\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE]: \"$__serverMessage\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH]: \"Transaction signature length mismatch\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE]: \"Transaction signature verification failure\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION]: \"$__serverMessage\",\n    [SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH]: \"Key pair bytes must be of length 64, got $byteLength.\",\n    [SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH]: \"Expected private key bytes with length 32. Actual length: $actualLength.\",\n    [SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH]: \"Expected base58-encoded signature to decode to a byte array of length 64. Actual length: $actualLength.\",\n    [SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY]: \"The provided private key does not match the provided public key.\",\n    [SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE]: \"Expected base58-encoded signature string of length in the range [64, 88]. Actual length: $actualLength.\",\n    [SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE]: \"Lamports value must be in the range [0, 2e64-1]\",\n    [SOLANA_ERROR__MALFORMED_BIGINT_STRING]: \"`$value` cannot be parsed as a `BigInt`\",\n    [SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR]: \"$message\",\n    [SOLANA_ERROR__MALFORMED_NUMBER_STRING]: \"`$value` cannot be parsed as a `Number`\",\n    [SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND]: \"No nonce account could be found at address `$nonceAccountAddress`\",\n    [SOLANA_ERROR__OFFCHAIN_MESSAGE__INVALID_APPLICATION_DOMAIN_BYTE_LENGTH]: \"Expected base58 encoded application domain to decode to a byte array of length 32. Actual length: $actualLength.\",\n    [SOLANA_ERROR__OFFCHAIN_MESSAGE__ADDRESSES_CANNOT_SIGN_OFFCHAIN_MESSAGE]: \"Attempted to sign an offchain message with an address that is not a signer for it\",\n    [SOLANA_ERROR__OFFCHAIN_MESSAGE__APPLICATION_DOMAIN_STRING_LENGTH_OUT_OF_RANGE]: \"Expected base58-encoded application domain string of length in the range [32, 44]. Actual length: $actualLength.\",\n    [SOLANA_ERROR__OFFCHAIN_MESSAGE__ENVELOPE_SIGNERS_MISMATCH]: \"The signer addresses in this offchain message envelope do not match the list of required signers in the message preamble. These unexpected signers were present in the envelope: `[$unexpectedSigners]`. These required signers were missing from the envelope `[$missingSigners]`.\",\n    [SOLANA_ERROR__OFFCHAIN_MESSAGE__MAXIMUM_LENGTH_EXCEEDED]: \"The message body provided has a byte-length of $actualBytes. The maximum allowable byte-length is $maxBytes\",\n    [SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_FORMAT_MISMATCH]: \"Expected message format $expectedMessageFormat, got $actualMessageFormat\",\n    [SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_LENGTH_MISMATCH]: \"The message length specified in the message preamble is $specifiedLength bytes. The actual length of the message is $actualLength bytes.\",\n    [SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY]: \"Offchain message content must be non-empty\",\n    [SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO]: \"Offchain message must specify the address of at least one required signer\",\n    [SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_ENVELOPE_SIGNATURES_CANNOT_BE_ZERO]: \"Offchain message envelope must reserve space for at least one signature\",\n    [SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_SIGNATURES_MISMATCH]: \"The offchain message preamble specifies $numRequiredSignatures required signature(s), got $signaturesLength.\",\n    [SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_SORTED]: \"The signatories of this offchain message must be listed in lexicographical order\",\n    [SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_UNIQUE]: \"An address must be listed no more than once among the signatories of an offchain message\",\n    [SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURES_MISSING]: \"Offchain message is missing signatures for addresses: $addresses.\",\n    [SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURE_VERIFICATION_FAILURE]: \"Offchain message signature verification failed. Signature mismatch for required signatories [$signatoriesWithInvalidSignatures]. Missing signatures for signatories [$signatoriesWithMissingSignatures]\",\n    [SOLANA_ERROR__OFFCHAIN_MESSAGE__RESTRICTED_ASCII_BODY_CHARACTER_OUT_OF_RANGE]: \"The message body provided contains characters whose codes fall outside the allowed range. In order to ensure clear-signing compatiblity with hardware wallets, the message may only contain line feeds and characters in the range [\\\\x20-\\\\x7e].\",\n    [SOLANA_ERROR__OFFCHAIN_MESSAGE__UNEXPECTED_VERSION]: \"Expected offchain message version $expectedVersion. Got $actualVersion.\",\n    [SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED]: \"This version of Kit does not support decoding offchain messages with version $unsupportedVersion. The current max supported version is 0.\",\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN]: \"The notification name must end in 'Notifications' and the API must supply a subscription plan creator function for the notification '$notificationName'.\",\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED]: \"WebSocket was closed before payload could be added to the send buffer\",\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED]: \"WebSocket connection closed\",\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT]: \"WebSocket failed to connect\",\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID]: \"Failed to obtain a subscription id from the server\",\n    [SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD]: \"Could not find an API plan for RPC method: `$method`\",\n    [SOLANA_ERROR__RPC__INTEGER_OVERFLOW]: \"The $argumentLabel argument to the `$methodName` RPC method$optionalPathLabel was `$value`. This number is unsafe for use with the Solana JSON-RPC because it exceeds `Number.MAX_SAFE_INTEGER`.\",\n    [SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR]: \"HTTP error ($statusCode): $message\",\n    [SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN]: \"HTTP header(s) forbidden: $headers. Learn more at https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name.\",\n    [SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS]: \"Multiple distinct signers were identified for address `$address`. Please ensure that you are using the same signer instance for each address.\",\n    [SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER]: \"The provided value does not implement the `KeyPairSigner` interface\",\n    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER]: \"The provided value does not implement the `MessageModifyingSigner` interface\",\n    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER]: \"The provided value does not implement the `MessagePartialSigner` interface\",\n    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER]: \"The provided value does not implement any of the `MessageSigner` interfaces\",\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER]: \"The provided value does not implement the `TransactionModifyingSigner` interface\",\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER]: \"The provided value does not implement the `TransactionPartialSigner` interface\",\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER]: \"The provided value does not implement the `TransactionSendingSigner` interface\",\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER]: \"The provided value does not implement any of the `TransactionSigner` interfaces\",\n    [SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS]: \"More than one `TransactionSendingSigner` was identified.\",\n    [SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING]: \"No `TransactionSendingSigner` was identified. Please provide a valid `TransactionWithSingleSendingSigner` transaction.\",\n    [SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED]: \"Wallet account signers do not support signing multiple messages/transactions in a single operation\",\n    [SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY]: \"Cannot export a non-extractable key.\",\n    [SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED]: \"No digest implementation could be found.\",\n    [SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT]: \"Cryptographic operations are only allowed in secure browser contexts. Read more here: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts.\",\n    [SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED]: \"This runtime does not support the generation of Ed25519 key pairs.\\n\\nInstall @solana/webcrypto-ed25519-polyfill and call its `install` function before generating keys in environments that do not support Ed25519.\\n\\nFor a list of runtimes that currently support Ed25519 operations, visit https://github.com/WICG/webcrypto-secure-curves/issues/20.\",\n    [SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED]: \"No signature verification implementation could be found.\",\n    [SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED]: \"No key generation implementation could be found.\",\n    [SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED]: \"No signing implementation could be found.\",\n    [SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED]: \"No key export implementation could be found.\",\n    [SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE]: \"Timestamp value must be in the range [-(2n ** 63n), (2n ** 63n) - 1]. `$value` given\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]: \"Transaction processing left an account with an outstanding borrowed reference\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE]: \"Account in use\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE]: \"Account loaded twice\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND]: \"Attempt to debit an account but found no record of a prior credit.\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND]: \"Transaction loads an address table account that doesn't exist\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED]: \"This transaction has already been processed\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND]: \"Blockhash not found\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP]: \"Loader call chain is too deep\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE]: \"Transactions are currently disabled due to cluster maintenance\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION]: \"Transaction contains a duplicate instruction ($index) that is not allowed\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE]: \"Insufficient funds for fee\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT]: \"Transaction results in an account ($accountIndex) with insufficient funds for rent\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE]: \"This account may not be used to pay transaction fees\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX]: \"Transaction contains an invalid account reference\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA]: \"Transaction loads an address table account with invalid data\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX]: \"Transaction address table lookup uses an invalid index\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER]: \"Transaction loads an address table account with an invalid owner\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT]: \"LoadedAccountsDataSizeLimit set for transaction must be greater than 0.\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION]: \"This program may not be used for executing instructions\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT]: \"Transaction leaves an account with a lower balance than rent-exempt minimum\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT]: \"Transaction loads a writable account that cannot be written\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED]: \"Transaction exceeded max loaded accounts data size cap\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE]: \"Transaction requires a fee but has no signature present\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND]: \"Attempt to load a program that does not exist\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED]: \"Execution of the program referenced by account at index $accountIndex is temporarily restricted.\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED]: \"ResanitizationNeeded\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE]: \"Transaction failed to sanitize accounts offsets correctly\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE]: \"Transaction did not pass signature verification\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS]: \"Transaction locked too many accounts\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION]: \"Sum of account balances before and after transaction do not match\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN]: \"The transaction failed with the error `$errorName`\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION]: \"Transaction version is unsupported\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT]: \"Transaction would exceed account data limit within the block\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT]: \"Transaction would exceed total account data limit\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT]: \"Transaction would exceed max account limit within the block\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT]: \"Transaction would exceed max Block Cost Limit\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT]: \"Transaction would exceed max Vote Cost Limit\",\n    [SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION]: \"Attempted to sign a transaction with an address that is not a signer for it\",\n    [SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING]: \"Transaction is missing an address at index: $index.\",\n    [SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES]: \"Transaction has no expected signers therefore it cannot be encoded\",\n    [SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT]: \"Transaction size $transactionSize exceeds limit of $transactionSizeLimit bytes\",\n    [SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME]: \"Transaction does not have a blockhash lifetime\",\n    [SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME]: \"Transaction is not a durable nonce transaction\",\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING]: \"Contents of these address lookup tables unknown: $lookupTableAddresses\",\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE]: \"Lookup of address at index $highestRequestedIndex failed for lookup table `$lookupTableAddress`. Highest known index is $highestKnownIndex. The lookup table may have been extended since its contents were retrieved\",\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING]: \"No fee payer set in CompiledTransaction\",\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND]: \"Could not find program address at index $index\",\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT]: \"Failed to estimate the compute unit consumption for this transaction message. This is likely because simulating the transaction failed. Inspect the `cause` property of this error to learn more\",\n    [SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT]: \"Transaction failed when it was simulated in order to estimate the compute unit consumption. The compute unit estimate provided is for a transaction that failed when simulated and may not be representative of the compute units this transaction would consume if successful. Inspect the `cause` property of this error to learn more\",\n    [SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING]: \"Transaction is missing a fee payer.\",\n    [SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING]: \"Could not determine this transaction's signature. Make sure that the transaction has been signed by its fee payer.\",\n    [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE]: \"Transaction first instruction is not advance nonce account instruction.\",\n    [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING]: \"Transaction with no instructions cannot be durable nonce transaction.\",\n    [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES]: \"This transaction includes an address (`$programAddress`) which is both invoked and set as the fee payer. Program addresses may not pay fees\",\n    [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE]: \"This transaction includes an address (`$programAddress`) which is both invoked and marked writable. Program addresses may not be writable\",\n    [SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH]: \"The transaction message expected the transaction to have $numRequiredSignatures signatures, got $signaturesLength.\",\n    [SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING]: \"Transaction is missing signatures for addresses: $addresses.\",\n    [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE]: \"Transaction version must be in the range [0, 127]. `$actualVersion` given\",\n    [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED]: \"This version of Kit does not support decoding transactions with version $unsupportedVersion. The current max supported version is 0.\",\n    [SOLANA_ERROR__TRANSACTION__NONCE_ACCOUNT_CANNOT_BE_IN_LOOKUP_TABLE]: \"The transaction has a durable nonce lifetime (with nonce `$nonce`), but the nonce account address is in a lookup table. The lifetime constraint cannot be constructed without fetching the lookup tables for the transaction.\"\n};\n// src/message-formatter.ts\nvar START_INDEX = \"i\";\nvar TYPE = \"t\";\nfunction getHumanReadableErrorMessage(code, context = {}) {\n    const messageFormatString = SolanaErrorMessages[code];\n    if (messageFormatString.length === 0) {\n        return \"\";\n    }\n    let state;\n    function commitStateUpTo(endIndex) {\n        if (state[TYPE] === 2 /* Variable */ ) {\n            const variableName = messageFormatString.slice(state[START_INDEX] + 1, endIndex);\n            fragments.push(variableName in context ? // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n            `${context[variableName]}` : `$${variableName}`);\n        } else if (state[TYPE] === 1 /* Text */ ) {\n            fragments.push(messageFormatString.slice(state[START_INDEX], endIndex));\n        }\n    }\n    const fragments = [];\n    messageFormatString.split(\"\").forEach((char, ii)=>{\n        if (ii === 0) {\n            state = {\n                [START_INDEX]: 0,\n                [TYPE]: messageFormatString[0] === \"\\\\\" ? 0 /* EscapeSequence */  : messageFormatString[0] === \"$\" ? 2 /* Variable */  : 1 /* Text */ \n            };\n            return;\n        }\n        let nextState;\n        switch(state[TYPE]){\n            case 0 /* EscapeSequence */ :\n                nextState = {\n                    [START_INDEX]: ii,\n                    [TYPE]: 1 /* Text */ \n                };\n                break;\n            case 1 /* Text */ :\n                if (char === \"\\\\\") {\n                    nextState = {\n                        [START_INDEX]: ii,\n                        [TYPE]: 0 /* EscapeSequence */ \n                    };\n                } else if (char === \"$\") {\n                    nextState = {\n                        [START_INDEX]: ii,\n                        [TYPE]: 2 /* Variable */ \n                    };\n                }\n                break;\n            case 2 /* Variable */ :\n                if (char === \"\\\\\") {\n                    nextState = {\n                        [START_INDEX]: ii,\n                        [TYPE]: 0 /* EscapeSequence */ \n                    };\n                } else if (char === \"$\") {\n                    nextState = {\n                        [START_INDEX]: ii,\n                        [TYPE]: 2 /* Variable */ \n                    };\n                } else if (!char.match(/\\w/)) {\n                    nextState = {\n                        [START_INDEX]: ii,\n                        [TYPE]: 1 /* Text */ \n                    };\n                }\n                break;\n        }\n        if (nextState) {\n            if (state !== nextState) {\n                commitStateUpTo(ii);\n            }\n            state = nextState;\n        }\n    });\n    commitStateUpTo();\n    return fragments.join(\"\");\n}\nfunction getErrorMessage(code, context = {}) {\n    if (true) {\n        return getHumanReadableErrorMessage(code, context);\n    } else {}\n}\n// src/error.ts\nfunction isSolanaError(e, code) {\n    const isSolanaError2 = e instanceof Error && e.name === \"SolanaError\";\n    if (isSolanaError2) {\n        if (code !== void 0) {\n            return e.context.__code === code;\n        }\n        return true;\n    }\n    return false;\n}\nvar SolanaError = class extends Error {\n    constructor(...[code, contextAndErrorOptions]){\n        let context;\n        let errorOptions;\n        if (contextAndErrorOptions) {\n            Object.entries(Object.getOwnPropertyDescriptors(contextAndErrorOptions)).forEach(([name, descriptor])=>{\n                if (name === \"cause\") {\n                    errorOptions = {\n                        cause: descriptor.value\n                    };\n                } else {\n                    if (context === void 0) {\n                        context = {\n                            __code: code\n                        };\n                    }\n                    Object.defineProperty(context, name, descriptor);\n                }\n            });\n        }\n        const message = getErrorMessage(code, context);\n        super(message, errorOptions);\n        /**\n   * Indicates the root cause of this {@link SolanaError}, if any.\n   *\n   * For example, a transaction error might have an instruction error as its root cause. In this\n   * case, you will be able to access the instruction error on the transaction error as `cause`.\n   */ this.cause = this.cause;\n        this.context = Object.freeze(context === void 0 ? {\n            __code: code\n        } : context);\n        this.name = \"SolanaError\";\n    }\n};\n// src/stack-trace.ts\nfunction safeCaptureStackTrace(...args) {\n    if (\"captureStackTrace\" in Error && typeof Error.captureStackTrace === \"function\") {\n        Error.captureStackTrace(...args);\n    }\n}\n// src/rpc-enum-errors.ts\nfunction getSolanaErrorFromRpcError({ errorCodeBaseOffset, getErrorContext, orderedErrorNames, rpcEnumError }, constructorOpt) {\n    let rpcErrorName;\n    let rpcErrorContext;\n    if (typeof rpcEnumError === \"string\") {\n        rpcErrorName = rpcEnumError;\n    } else {\n        rpcErrorName = Object.keys(rpcEnumError)[0];\n        rpcErrorContext = rpcEnumError[rpcErrorName];\n    }\n    const codeOffset = orderedErrorNames.indexOf(rpcErrorName);\n    const errorCode = errorCodeBaseOffset + codeOffset;\n    const errorContext = getErrorContext(errorCode, rpcErrorName, rpcErrorContext);\n    const err = new SolanaError(errorCode, errorContext);\n    safeCaptureStackTrace(err, constructorOpt);\n    return err;\n}\n// src/instruction-error.ts\nvar ORDERED_ERROR_NAMES = [\n    // Keep synced with RPC source: https://github.com/anza-xyz/solana-sdk/blob/master/instruction-error/src/lib.rs\n    // If this list ever gets too large, consider implementing a compression strategy like this:\n    // https://gist.github.com/steveluscher/aaa7cbbb5433b1197983908a40860c47\n    \"GenericError\",\n    \"InvalidArgument\",\n    \"InvalidInstructionData\",\n    \"InvalidAccountData\",\n    \"AccountDataTooSmall\",\n    \"InsufficientFunds\",\n    \"IncorrectProgramId\",\n    \"MissingRequiredSignature\",\n    \"AccountAlreadyInitialized\",\n    \"UninitializedAccount\",\n    \"UnbalancedInstruction\",\n    \"ModifiedProgramId\",\n    \"ExternalAccountLamportSpend\",\n    \"ExternalAccountDataModified\",\n    \"ReadonlyLamportChange\",\n    \"ReadonlyDataModified\",\n    \"DuplicateAccountIndex\",\n    \"ExecutableModified\",\n    \"RentEpochModified\",\n    \"NotEnoughAccountKeys\",\n    \"AccountDataSizeChanged\",\n    \"AccountNotExecutable\",\n    \"AccountBorrowFailed\",\n    \"AccountBorrowOutstanding\",\n    \"DuplicateAccountOutOfSync\",\n    \"Custom\",\n    \"InvalidError\",\n    \"ExecutableDataModified\",\n    \"ExecutableLamportChange\",\n    \"ExecutableAccountNotRentExempt\",\n    \"UnsupportedProgramId\",\n    \"CallDepth\",\n    \"MissingAccount\",\n    \"ReentrancyNotAllowed\",\n    \"MaxSeedLengthExceeded\",\n    \"InvalidSeeds\",\n    \"InvalidRealloc\",\n    \"ComputationalBudgetExceeded\",\n    \"PrivilegeEscalation\",\n    \"ProgramEnvironmentSetupFailure\",\n    \"ProgramFailedToComplete\",\n    \"ProgramFailedToCompile\",\n    \"Immutable\",\n    \"IncorrectAuthority\",\n    \"BorshIoError\",\n    \"AccountNotRentExempt\",\n    \"InvalidAccountOwner\",\n    \"ArithmeticOverflow\",\n    \"UnsupportedSysvar\",\n    \"IllegalOwner\",\n    \"MaxAccountsDataAllocationsExceeded\",\n    \"MaxAccountsExceeded\",\n    \"MaxInstructionTraceLengthExceeded\",\n    \"BuiltinProgramsMustConsumeComputeUnits\"\n];\nfunction getSolanaErrorFromInstructionError(index, instructionError) {\n    const numberIndex = Number(index);\n    return getSolanaErrorFromRpcError({\n        errorCodeBaseOffset: 4615001,\n        getErrorContext (errorCode, rpcErrorName, rpcErrorContext) {\n            if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN) {\n                return {\n                    errorName: rpcErrorName,\n                    index: numberIndex,\n                    ...rpcErrorContext !== void 0 ? {\n                        instructionErrorContext: rpcErrorContext\n                    } : null\n                };\n            } else if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM) {\n                return {\n                    code: Number(rpcErrorContext),\n                    index: numberIndex\n                };\n            }\n            return {\n                index: numberIndex\n            };\n        },\n        orderedErrorNames: ORDERED_ERROR_NAMES,\n        rpcEnumError: instructionError\n    }, getSolanaErrorFromInstructionError);\n}\n// src/transaction-error.ts\nvar ORDERED_ERROR_NAMES2 = [\n    // Keep synced with RPC source: https://github.com/anza-xyz/agave/blob/master/sdk/src/transaction/error.rs\n    // If this list ever gets too large, consider implementing a compression strategy like this:\n    // https://gist.github.com/steveluscher/aaa7cbbb5433b1197983908a40860c47\n    \"AccountInUse\",\n    \"AccountLoadedTwice\",\n    \"AccountNotFound\",\n    \"ProgramAccountNotFound\",\n    \"InsufficientFundsForFee\",\n    \"InvalidAccountForFee\",\n    \"AlreadyProcessed\",\n    \"BlockhashNotFound\",\n    // `InstructionError` intentionally omitted; delegated to `getSolanaErrorFromInstructionError`\n    \"CallChainTooDeep\",\n    \"MissingSignatureForFee\",\n    \"InvalidAccountIndex\",\n    \"SignatureFailure\",\n    \"InvalidProgramForExecution\",\n    \"SanitizeFailure\",\n    \"ClusterMaintenance\",\n    \"AccountBorrowOutstanding\",\n    \"WouldExceedMaxBlockCostLimit\",\n    \"UnsupportedVersion\",\n    \"InvalidWritableAccount\",\n    \"WouldExceedMaxAccountCostLimit\",\n    \"WouldExceedAccountDataBlockLimit\",\n    \"TooManyAccountLocks\",\n    \"AddressLookupTableNotFound\",\n    \"InvalidAddressLookupTableOwner\",\n    \"InvalidAddressLookupTableData\",\n    \"InvalidAddressLookupTableIndex\",\n    \"InvalidRentPayingAccount\",\n    \"WouldExceedMaxVoteCostLimit\",\n    \"WouldExceedAccountDataTotalLimit\",\n    \"DuplicateInstruction\",\n    \"InsufficientFundsForRent\",\n    \"MaxLoadedAccountsDataSizeExceeded\",\n    \"InvalidLoadedAccountsDataSizeLimit\",\n    \"ResanitizationNeeded\",\n    \"ProgramExecutionTemporarilyRestricted\",\n    \"UnbalancedTransaction\"\n];\nfunction getSolanaErrorFromTransactionError(transactionError) {\n    if (typeof transactionError === \"object\" && \"InstructionError\" in transactionError) {\n        return getSolanaErrorFromInstructionError(...transactionError.InstructionError);\n    }\n    return getSolanaErrorFromRpcError({\n        errorCodeBaseOffset: 7050001,\n        getErrorContext (errorCode, rpcErrorName, rpcErrorContext) {\n            if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN) {\n                return {\n                    errorName: rpcErrorName,\n                    ...rpcErrorContext !== void 0 ? {\n                        transactionErrorContext: rpcErrorContext\n                    } : null\n                };\n            } else if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION) {\n                return {\n                    index: Number(rpcErrorContext)\n                };\n            } else if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT || errorCode === SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED) {\n                return {\n                    accountIndex: Number(rpcErrorContext.account_index)\n                };\n            }\n        },\n        orderedErrorNames: ORDERED_ERROR_NAMES2,\n        rpcEnumError: transactionError\n    }, getSolanaErrorFromTransactionError);\n}\n// src/json-rpc-error.ts\nfunction getSolanaErrorFromJsonRpcError(putativeErrorResponse) {\n    let out;\n    if (isRpcErrorResponse(putativeErrorResponse)) {\n        const { code: rawCode, data, message } = putativeErrorResponse;\n        const code = Number(rawCode);\n        if (code === SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE) {\n            const { err, ...preflightErrorContext } = data;\n            const causeObject = err ? {\n                cause: getSolanaErrorFromTransactionError(err)\n            } : null;\n            out = new SolanaError(SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE, {\n                ...preflightErrorContext,\n                ...causeObject\n            });\n        } else {\n            let errorContext;\n            switch(code){\n                case SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR:\n                case SOLANA_ERROR__JSON_RPC__INVALID_PARAMS:\n                case SOLANA_ERROR__JSON_RPC__INVALID_REQUEST:\n                case SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND:\n                case SOLANA_ERROR__JSON_RPC__PARSE_ERROR:\n                case SOLANA_ERROR__JSON_RPC__SCAN_ERROR:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION:\n                    errorContext = {\n                        __serverMessage: message\n                    };\n                    break;\n                default:\n                    if (typeof data === \"object\" && !Array.isArray(data)) {\n                        errorContext = data;\n                    }\n            }\n            out = new SolanaError(code, errorContext);\n        }\n    } else {\n        const message = typeof putativeErrorResponse === \"object\" && putativeErrorResponse !== null && \"message\" in putativeErrorResponse && typeof putativeErrorResponse.message === \"string\" ? putativeErrorResponse.message : \"Malformed JSON-RPC error with no message attribute\";\n        out = new SolanaError(SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR, {\n            error: putativeErrorResponse,\n            message\n        });\n    }\n    safeCaptureStackTrace(out, getSolanaErrorFromJsonRpcError);\n    return out;\n}\nfunction isRpcErrorResponse(value) {\n    return typeof value === \"object\" && value !== null && \"code\" in value && \"message\" in value && (typeof value.code === \"number\" || typeof value.code === \"bigint\") && typeof value.message === \"string\";\n}\n// src/simulation-errors.ts\nfunction unwrapSimulationError(error) {\n    const simulationCodes = [\n        SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE,\n        SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT\n    ];\n    if (isSolanaError(error) && !!error.cause && simulationCodes.includes(error.context.__code)) {\n        return error.cause;\n    }\n    return error;\n}\n //# sourceMappingURL=index.node.mjs.map\n //# sourceMappingURL=index.node.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS9lcnJvcnMvZGlzdC9pbmRleC5ub2RlLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxlQUFlO0FBQ2YsSUFBSUEsc0NBQXNDO0FBQzFDLElBQUlDLDhCQUE4QjtBQUNsQyxJQUFJQyx3Q0FBd0M7QUFDNUMsSUFBSUMscURBQXFEO0FBQ3pELElBQUlDLDhDQUE4QztBQUNsRCxJQUFJQyxzQ0FBc0M7QUFDMUMsSUFBSUMsd0NBQXdDO0FBQzVDLElBQUlDLHdDQUF3QztBQUM1QyxJQUFJQyx1Q0FBdUM7QUFDM0MsSUFBSUMseUNBQXlDO0FBQzdDLElBQUlDLHNDQUFzQyxDQUFDO0FBQzNDLElBQUlDLHlDQUF5QyxDQUFDO0FBQzlDLElBQUlDLHlDQUF5QyxDQUFDO0FBQzlDLElBQUlDLDJDQUEyQyxDQUFDO0FBQ2hELElBQUlDLDBDQUEwQyxDQUFDO0FBQy9DLElBQUlDLHFFQUFxRSxDQUFDO0FBQzFFLElBQUlDLCtEQUErRCxDQUFDO0FBQ3BFLElBQUlDLG1FQUFtRSxDQUFDO0FBQ3hFLElBQUlDLG9FQUFvRSxDQUFDO0FBQ3pFLElBQUlDLHVFQUF1RSxDQUFDO0FBQzVFLElBQUlDLHNFQUFzRSxDQUFDO0FBQzNFLElBQUlDLDBFQUEwRSxDQUFDO0FBQy9FLElBQUlDLHFDQUFxQyxDQUFDO0FBQzFDLElBQUlDLHlFQUF5RSxDQUFDO0FBQzlFLElBQUlDLHlFQUF5RSxDQUFDO0FBQzlFLElBQUlDLHNFQUFzRSxDQUFDO0FBQzNFLElBQUlDLG1EQUFtRCxDQUFDO0FBQ3hELElBQUlDLG9EQUFvRCxDQUFDO0FBQ3pELElBQUlDLG1GQUFtRixDQUFDO0FBQ3hGLElBQUlDLHNEQUFzRCxDQUFDO0FBQzNELElBQUlDLDJEQUEyRCxDQUFDO0FBQ2hFLElBQUlDLGtGQUFrRixDQUFDO0FBQ3ZGLElBQUlDLDBFQUEwRSxDQUFDO0FBQy9FLElBQUlDLHdEQUF3RCxDQUFDO0FBQzdELElBQUlDLCtDQUErQztBQUNuRCxJQUFJQyxzREFBc0Q7QUFDMUQsSUFBSUMsMERBQTBEO0FBQzlELElBQUlDLHNEQUFzRDtBQUMxRCxJQUFJQyx5Q0FBeUM7QUFDN0MsSUFBSUMsc0RBQXNEO0FBQzFELElBQUlDLDREQUE0RDtBQUNoRSxJQUFJQyx3REFBd0Q7QUFDNUQsSUFBSUMsd0RBQXdEO0FBQzVELElBQUlDLCtEQUErRDtBQUNuRSxJQUFJQyxvREFBb0Q7QUFDeEQsSUFBSUMscURBQXFEO0FBQ3pELElBQUlDLDRDQUE0QztBQUNoRCxJQUFJQyx5REFBeUQ7QUFDN0QsSUFBSUMsbURBQW1EO0FBQ3ZELElBQUlDLG1EQUFtRDtBQUN2RCxJQUFJQyw4REFBOEQ7QUFDbEUsSUFBSUMsOERBQThEO0FBQ2xFLElBQUlDLG9EQUFvRDtBQUN4RCxJQUFJQywrREFBK0Q7QUFDbkUsSUFBSUMsNkRBQTZEO0FBQ2pFLElBQUlDLCtEQUErRDtBQUNuRSxJQUFJQywyREFBMkQ7QUFDL0QsSUFBSUMsNkRBQTZEO0FBQ2pFLElBQUlDLGlFQUFpRTtBQUNyRSxJQUFJQyw2REFBNkQ7QUFDakUsSUFBSUMsbURBQW1EO0FBQ3ZELElBQUlDLHNEQUFzRDtBQUMxRCxJQUFJQyxvREFBb0Q7QUFDeEQsSUFBSUMsMkRBQTJEO0FBQy9ELElBQUlDLHdEQUF3RDtBQUM1RCxJQUFJQyx1REFBdUQ7QUFDM0QsSUFBSUMsbURBQW1EO0FBQ3ZELElBQUlDLGlEQUFpRDtBQUNyRCxJQUFJQywyQ0FBMkM7QUFDL0MsSUFBSUMsaURBQWlEO0FBQ3JELElBQUlDLG9EQUFvRDtBQUN4RCxJQUFJQyw0REFBNEQ7QUFDaEUsSUFBSUMsd0RBQXdEO0FBQzVELElBQUlDLDBEQUEwRDtBQUM5RCxJQUFJQyxzREFBc0Q7QUFDMUQsSUFBSUMsd0RBQXdEO0FBQzVELElBQUlDLDhEQUE4RDtBQUNsRSxJQUFJQywrREFBK0Q7QUFDbkUsSUFBSUMseURBQXlEO0FBQzdELElBQUlDLDBEQUEwRDtBQUM5RCxJQUFJQyx1REFBdUQ7QUFDM0QsSUFBSUMsa0VBQWtFO0FBQ3RFLElBQUlDLGtFQUFrRTtBQUN0RSxJQUFJQywyREFBMkQ7QUFDL0QsSUFBSUMsMERBQTBEO0FBQzlELElBQUlDLDJEQUEyRDtBQUMvRCxJQUFJQyx1REFBdUQ7QUFDM0QsSUFBSUMsdURBQXVEO0FBQzNELElBQUlDLDJEQUEyRDtBQUMvRCxJQUFJQyw2REFBNkQ7QUFDakUsSUFBSUMsMERBQTBEO0FBQzlELElBQUlDLHlEQUF5RDtBQUM3RCxJQUFJQyw4REFBOEQ7QUFDbEUsSUFBSUMsaUVBQWlFO0FBQ3JFLElBQUlDLDBDQUEwQztBQUM5QyxJQUFJQyxpREFBaUQ7QUFDckQsSUFBSUMsNERBQTREO0FBQ2hFLElBQUlDLDZEQUE2RDtBQUNqRSxJQUFJQyxzRUFBc0U7QUFDMUUsSUFBSUMsMERBQTBEO0FBQzlELElBQUlDLDhDQUE4QztBQUNsRCxJQUFJQyxtREFBbUQ7QUFDdkQsSUFBSUMsMERBQTBEO0FBQzlELElBQUlDLDREQUE0RDtBQUNoRSxJQUFJQyxpREFBaUQ7QUFDckQsSUFBSUMsbURBQW1EO0FBQ3ZELElBQUlDLGlFQUFpRTtBQUNyRSxJQUFJQyx3REFBd0Q7QUFDNUQsSUFBSUMscUVBQXFFO0FBQ3pFLElBQUlDLDhEQUE4RDtBQUNsRSxJQUFJQyw2REFBNkQ7QUFDakUsSUFBSUMsNkNBQTZDO0FBQ2pELElBQUlDLHVEQUF1RDtBQUMzRCxJQUFJQyxrREFBa0Q7QUFDdEQsSUFBSUMsMkRBQTJEO0FBQy9ELElBQUlDLHlEQUF5RDtBQUM3RCxJQUFJQyx1REFBdUQ7QUFDM0QsSUFBSUMsc0RBQXNEO0FBQzFELElBQUlDLGlEQUFpRDtBQUNyRCxJQUFJQywwRUFBMEU7QUFDOUUsSUFBSUMseURBQXlEO0FBQzdELElBQUlDLHlFQUF5RTtBQUM3RSxJQUFJQywrRUFBK0U7QUFDbkYsSUFBSUMsNkRBQTZEO0FBQ2pFLElBQUlDLGlEQUFpRDtBQUNyRCxJQUFJQyxnREFBZ0Q7QUFDcEQsSUFBSUMsMERBQTBEO0FBQzlELElBQUlDLHdEQUF3RDtBQUM1RCxJQUFJQyxvREFBb0Q7QUFDeEQsSUFBSUMsOERBQThEO0FBQ2xFLElBQUlDLDREQUE0RDtBQUNoRSxJQUFJQyw0REFBNEQ7QUFDaEUsSUFBSUMseUVBQXlFO0FBQzdFLElBQUlDLDJEQUEyRDtBQUMvRCxJQUFJQyx1REFBdUQ7QUFDM0QsSUFBSUMsMERBQTBEO0FBQzlELElBQUlDLCtFQUErRTtBQUNuRixJQUFJQyxnRkFBZ0Y7QUFDcEYsSUFBSUMseUVBQXlFO0FBQzdFLElBQUlDLDBEQUEwRDtBQUM5RCxJQUFJQyxzRUFBc0U7QUFDMUUsSUFBSUMsK0RBQStEO0FBQ25FLElBQUlDLDBEQUEwRDtBQUM5RCxJQUFJQywwREFBMEQ7QUFDOUQsSUFBSUMsNERBQTREO0FBQ2hFLElBQUlDLHlFQUF5RTtBQUM3RSxJQUFJQyxxREFBcUQ7QUFDekQsSUFBSUMsNERBQTREO0FBQ2hFLElBQUlDLHlFQUF5RTtBQUM3RSxJQUFJQyxxREFBcUQ7QUFDekQsSUFBSUMsNkRBQTZEO0FBQ2pFLElBQUlDLDZEQUE2RDtBQUNqRSxJQUFJQyxpRUFBaUU7QUFDckUsSUFBSUMsOERBQThEO0FBQ2xFLElBQUlDLG1FQUFtRTtBQUN2RSxJQUFJQyx5REFBeUQ7QUFDN0QsSUFBSUMscURBQXFEO0FBQ3pELElBQUlDLHlEQUF5RDtBQUM3RCxJQUFJQyx1RkFBdUY7QUFDM0YsSUFBSUMseUZBQXlGO0FBQzdGLElBQUlDLHVGQUF1RjtBQUMzRixJQUFJQyxtRUFBbUU7QUFDdkUsSUFBSUMsZ0RBQWdEO0FBQ3BELElBQUlDLDZDQUE2QztBQUNqRCxJQUFJQywrQ0FBK0M7QUFDbkQsSUFBSUMseURBQXlEO0FBQzdELElBQUlDLDRFQUE0RTtBQUNoRixJQUFJQywrRkFBK0Y7QUFDbkcsSUFBSUMsK0RBQStEO0FBQ25FLElBQUlDLGlFQUFpRTtBQUNyRSxJQUFJQyx5REFBeUQ7QUFDN0QsSUFBSUMsOERBQThEO0FBQ2xFLElBQUlDLDhFQUE4RTtBQUNsRixJQUFJQyxnREFBZ0Q7QUFDcEQsSUFBSUMsMERBQTBEO0FBQzlELElBQUlDLHFFQUFxRTtBQUN6RSxJQUFJQywyQ0FBMkM7QUFDL0MsSUFBSUMsa0RBQWtEO0FBQ3RELElBQUlDLHdEQUF3RDtBQUM1RCxJQUFJQyxxREFBcUQ7QUFDekQsSUFBSUMsNkRBQTZEO0FBQ2pFLElBQUlDLDhEQUE4RDtBQUNsRSxJQUFJQywyREFBMkQ7QUFDL0QsSUFBSUMscURBQXFEO0FBQ3pELElBQUlDLHVEQUF1RDtBQUMzRCxJQUFJQyx1REFBdUQ7QUFDM0QsSUFBSUMsNkRBQTZEO0FBQ2pFLElBQUlDLHlEQUF5RDtBQUM3RCxJQUFJQyxxREFBcUQ7QUFDekQsSUFBSUMsaUVBQWlFO0FBQ3JFLElBQUlDLG9EQUFvRDtBQUN4RCxJQUFJQyx1REFBdUQ7QUFDM0QsSUFBSUMsOERBQThEO0FBQ2xFLElBQUlDLHFFQUFxRTtBQUN6RSxJQUFJQyx1REFBdUQ7QUFDM0QsSUFBSUMsNERBQTREO0FBQ2hFLElBQUlDLHVFQUF1RTtBQUMzRSxJQUFJQyx5RUFBeUU7QUFDN0UsSUFBSUMsMERBQTBEO0FBQzlELElBQUlDLGtFQUFrRTtBQUN0RSxJQUFJQyxzRUFBc0U7QUFDMUUsSUFBSUMscUVBQXFFO0FBQ3pFLElBQUlDLHNFQUFzRTtBQUMxRSxJQUFJQywrREFBK0Q7QUFDbkUsSUFBSUMsb0VBQW9FO0FBQ3hFLElBQUlDLHlFQUF5RTtBQUM3RSxJQUFJQyx5REFBeUQ7QUFDN0QsSUFBSUMsK0RBQStEO0FBQ25FLElBQUlDLDBFQUEwRTtBQUM5RSxJQUFJQywyRUFBMkU7QUFDL0UsSUFBSUMseURBQXlEO0FBQzdELElBQUlDLDRFQUE0RTtBQUNoRixJQUFJQywwREFBMEQ7QUFDOUQsSUFBSUMsbUVBQW1FO0FBQ3ZFLElBQUlDLG1FQUFtRTtBQUN2RSxJQUFJQywwREFBMEQ7QUFDOUQsSUFBSUMsc0VBQXNFO0FBQzFFLElBQUlDLGlGQUFpRjtBQUNyRixJQUFJQyxtRkFBbUY7QUFDdkYsSUFBSUMsK0RBQStEO0FBQ25FLElBQUlDLCtEQUErRDtBQUNuRSxJQUFJQyxzRUFBc0U7QUFDMUUsSUFBSUMsK0VBQStFO0FBQ25GLElBQUlDLHVEQUF1RDtBQUMzRCxJQUFJQyw0Q0FBNEM7QUFDaEQsSUFBSUMsOENBQThDO0FBQ2xELElBQUlDLGlEQUFpRDtBQUNyRCxJQUFJQyxvRUFBb0U7QUFDeEUsSUFBSUMsNERBQTREO0FBQ2hFLElBQUlDLDBEQUEwRDtBQUM5RCxJQUFJQyxnREFBZ0Q7QUFDcEQsSUFBSUMsd0RBQXdEO0FBQzVELElBQUlDLDREQUE0RDtBQUNoRSxJQUFJQyw2Q0FBNkM7QUFDakQsSUFBSUMsNENBQTRDO0FBQ2hELElBQUlDLGdEQUFnRDtBQUNwRCxJQUFJQyxzREFBc0Q7QUFDMUQsSUFBSUMsNENBQTRDO0FBQ2hELElBQUlDLHNEQUFzRDtBQUMxRCxJQUFJQyxpRUFBaUU7QUFDckUsSUFBSUMsbURBQW1EO0FBQ3ZELElBQUlDLHlDQUF5QztBQUM3QyxJQUFJQyxxRUFBcUU7QUFDekUsSUFBSUMsZ0VBQWdFO0FBQ3BFLElBQUlDLDBEQUEwRDtBQUM5RCxJQUFJQyx5RUFBeUU7QUFDN0UsSUFBSUMsc0VBQXNFO0FBQzFFLElBQUlDLHNDQUFzQztBQUMxQyxJQUFJQyxxREFBcUQ7QUFDekQsSUFBSUMsMENBQTBDO0FBQzlDLElBQUlDLHFEQUFxRDtBQUN6RCxJQUFJQyxtRUFBbUU7QUFDdkUsSUFBSUMsbUVBQW1FO0FBQ3ZFLElBQUlDLDBFQUEwRTtBQUM5RSxJQUFJQyw2REFBNkQ7QUFDakUsSUFBSUMsNkRBQTZEO0FBQ2pFLElBQUlDLHlFQUF5RTtBQUM3RSxJQUFJQyxtSEFBbUg7QUFDdkgsSUFBSUMsbUZBQW1GO0FBQ3ZGLElBQUlDLCtEQUErRDtBQUNuRSxJQUFJQywwRUFBMEU7QUFDOUUsSUFBSUMsbUVBQW1FO0FBQ3ZFLElBQUlDLG1FQUFtRTtBQUV2RSxpQkFBaUI7QUFDakIsU0FBU0MsWUFBWUMsS0FBSztJQUN4QixJQUFJQyxNQUFNQyxPQUFPLENBQUNGLFFBQVE7UUFDeEIsTUFBTUcsdUJBQXVCSCxNQUFNSSxHQUFHLENBQUNMLGFBQWFNLElBQUksQ0FDdEQ7UUFHRixPQUFPLFFBQVFGLHVCQUF1QixPQUFPLEdBQzdDO0lBQ0YsT0FBTyxJQUFJLE9BQU9ILFVBQVUsVUFBVTtRQUNwQyxPQUFPLENBQUMsRUFBRUEsTUFBTSxDQUFDLENBQUM7SUFDcEIsT0FBTztRQUNMLE9BQU9NLG1CQUNMQyxPQUNFUCxTQUFTLFFBQVFRLE9BQU9DLGNBQWMsQ0FBQ1QsV0FBVyxPQUNoRCxrRUFBa0U7UUFDbEUseUNBQXlDO1FBQ3pDO1lBQUUsR0FBR0EsS0FBSztRQUFDLElBQ1RBO0lBR1Y7QUFDRjtBQUNBLFNBQVNVLHlCQUF5QixDQUFDQyxLQUFLWCxNQUFNO0lBQzVDLE9BQU8sQ0FBQyxFQUFFVyxJQUFJLENBQUMsRUFBRVosWUFBWUMsT0FBTyxDQUFDO0FBQ3ZDO0FBQ0EsU0FBU1ksb0JBQW9CQyxPQUFPO0lBQ2xDLE1BQU1DLHFCQUFxQk4sT0FBT08sT0FBTyxDQUFDRixTQUFTVCxHQUFHLENBQUNNLDBCQUEwQkwsSUFBSSxDQUFDO0lBQ3RGLE9BQU9XLE9BQU9DLElBQUksQ0FBQ0gsb0JBQW9CLFFBQVFJLFFBQVEsQ0FBQztBQUMxRDtBQUVBLGtCQUFrQjtBQUNsQixJQUFJQyxzQkFBc0I7SUFDeEIsQ0FBQzdPLDBDQUEwQyxFQUFFO0lBQzdDLENBQUNJLDREQUE0RCxFQUFFO0lBQy9ELENBQUNELGlEQUFpRCxFQUFFO0lBQ3BELENBQUNELGlEQUFpRCxFQUFFO0lBQ3BELENBQUNELHVEQUF1RCxFQUFFO0lBQzFELENBQUNKLDZEQUE2RCxFQUFFO0lBQ2hFLENBQUNQLHdEQUF3RCxFQUFFO0lBQzNELENBQUNGLDZDQUE2QyxFQUFFO0lBQ2hELENBQUNHLG9EQUFvRCxFQUFFO0lBQ3ZELENBQUNRLG1EQUFtRCxFQUFFO0lBQ3RELENBQUNILHNEQUFzRCxFQUFFO0lBQ3pELENBQUNKLHVDQUF1QyxFQUFFO0lBQzFDLENBQUNFLDBEQUEwRCxFQUFFO0lBQzdELENBQUNDLHNEQUFzRCxFQUFFO0lBQ3pELENBQUNGLG9EQUFvRCxFQUFFO0lBQ3ZELENBQUNLLGtEQUFrRCxFQUFFO0lBQ3JELENBQUNULG9EQUFvRCxFQUFFO0lBQ3ZELENBQUNoQyxtREFBbUQsRUFBRTtJQUN0RCxDQUFDSCxvQ0FBb0MsRUFBRTtJQUN2QyxDQUFDK04scURBQXFELEVBQUU7SUFDeEQsQ0FBQ3NCLHVFQUF1RSxFQUFFO0lBQzFFLENBQUNGLDhEQUE4RCxFQUFFO0lBQ2pFLENBQUNmLDBEQUEwRCxFQUFFO0lBQzdELENBQUNDLHdEQUF3RCxFQUFFO0lBQzNELENBQUNGLGtFQUFrRSxFQUFFO0lBQ3JFLENBQUNJLHNEQUFzRCxFQUFFO0lBQ3pELENBQUNOLDRDQUE0QyxFQUFFO0lBQy9DLENBQUNXLG9EQUFvRCxFQUFFO0lBQ3ZELENBQUNWLCtDQUErQyxFQUFFO0lBQ2xELENBQUNnQixtRUFBbUUsRUFBRTtJQUN0RSxDQUFDbEIsMENBQTBDLEVBQUU7SUFDN0MsQ0FBQ2lCLHVDQUF1QyxFQUFFO0lBQzFDLENBQUNULDBEQUEwRCxFQUFFO0lBQzdELENBQUNDLDJDQUEyQyxFQUFFO0lBQzlDLENBQUNLLG9EQUFvRCxFQUFFO0lBQ3ZELENBQUNSLDhDQUE4QyxFQUFFO0lBQ2pELENBQUNLLDhDQUE4QyxFQUFFO0lBQ2pELENBQUNJLCtEQUErRCxFQUFFO0lBQ2xFLENBQUNMLDBDQUEwQyxFQUFFO0lBQzdDLENBQUNHLDBDQUEwQyxFQUFFO0lBQzdDLENBQUNPLHdEQUF3RCxFQUFFO0lBQzNELENBQUNKLGlEQUFpRCxFQUFFO0lBQ3BELENBQUNNLG9FQUFvRSxFQUFFO0lBQ3ZFLENBQUMzTCwyREFBMkQsRUFBRTtJQUM5RCxDQUFDa0IsNkRBQTZELEVBQUU7SUFDaEUsQ0FBQ2MsdURBQXVELEVBQUU7SUFDMUQsQ0FBQ0MsNERBQTRELEVBQUU7SUFDL0QsQ0FBQ0gsMkRBQTJELEVBQUU7SUFDOUQsQ0FBQ2hCLHdEQUF3RCxFQUFFO0lBQzNELENBQUNpQix3REFBd0QsRUFBRTtJQUMzRCxDQUFDd0IseURBQXlELEVBQUU7SUFDNUQsQ0FBQ0UscURBQXFELEVBQUU7SUFDeEQsQ0FBQ0gsZ0RBQWdELEVBQUU7SUFDbkQsQ0FBQ1MsNkVBQTZFLEVBQUU7SUFDaEYsQ0FBQ3RCLDRDQUE0QyxFQUFFO0lBQy9DLENBQUNNLCtEQUErRCxFQUFFO0lBQ2xFLENBQUNaLHdDQUF3QyxFQUFFO0lBQzNDLENBQUNULHlEQUF5RCxFQUFFO0lBQzVELENBQUNRLCtEQUErRCxFQUFFO0lBQ2xFLENBQUNLLG9FQUFvRSxFQUFFO0lBQ3ZFLENBQUNGLDBEQUEwRCxFQUFFO0lBQzdELENBQUNDLDJEQUEyRCxFQUFFO0lBQzlELENBQUNYLHFEQUFxRCxFQUFFO0lBQ3hELENBQUNKLGdFQUFnRSxFQUFFO0lBQ25FLENBQUNELGdFQUFnRSxFQUFFO0lBQ25FLENBQUNaLCtDQUErQyxFQUFFO0lBQ2xELENBQUNpRCwrQ0FBK0MsRUFBRTtJQUNsRCxDQUFDUCwyQ0FBMkMsRUFBRTtJQUM5QyxDQUFDQyxxREFBcUQsRUFBRTtJQUN4RCxDQUFDckMsc0RBQXNELEVBQUU7SUFDekQsQ0FBQ0Qsb0RBQW9ELEVBQUU7SUFDdkQsQ0FBQ0Ysc0RBQXNELEVBQUU7SUFDekQsQ0FBQzJDLHVEQUF1RCxFQUFFO0lBQzFELENBQUM3QyxrREFBa0QsRUFBRTtJQUNyRCxDQUFDeUIsK0NBQStDLEVBQUU7SUFDbEQsQ0FBQ3hCLDBEQUEwRCxFQUFFO0lBQzdELENBQUNrQyxpREFBaUQsRUFBRTtJQUNwRCxDQUFDRCwrQ0FBK0MsRUFBRTtJQUNsRCxDQUFDZSx3RUFBd0UsRUFBRTtJQUMzRSxDQUFDQyx1REFBdUQsRUFBRTtJQUMxRCxDQUFDQyx1RUFBdUUsRUFBRTtJQUMxRSxDQUFDbEIsMERBQTBELEVBQUU7SUFDN0QsQ0FBQ0YsaURBQWlELEVBQUU7SUFDcEQsQ0FBQ3pCLDREQUE0RCxFQUFFO0lBQy9ELENBQUNJLHFEQUFxRCxFQUFFO0lBQ3hELENBQUNRLHlEQUF5RCxFQUFFO0lBQzVELENBQUNtQixzREFBc0QsRUFBRTtJQUN6RCxDQUFDQyxtRUFBbUUsRUFBRTtJQUN0RSxDQUFDRSwyREFBMkQsRUFBRTtJQUM5RCxDQUFDRCw0REFBNEQsRUFBRTtJQUMvRCxDQUFDekIsd0RBQXdELEVBQUU7SUFDM0QsQ0FBQ0QseURBQXlELEVBQUU7SUFDNUQsQ0FBQ21CLHdEQUF3RCxFQUFFO0lBQzNELENBQUNmLHFEQUFxRCxFQUFFO0lBQ3hELENBQUNSLHdEQUF3RCxFQUFFO0lBQzNELENBQUNELHVEQUF1RCxFQUFFO0lBQzFELENBQUNWLHlDQUF5QyxFQUFFO0lBQzVDLENBQUMrQix3REFBd0QsRUFBRTtJQUMzRCxDQUFDa0Isb0RBQW9ELEVBQUU7SUFDdkQsQ0FBQ2dKLGlFQUFpRSxFQUFFO0lBQ3BFLENBQUM5Qyx3REFBd0QsRUFBRTtJQUMzRCxDQUFDRyxpRkFBaUYsRUFBRTtJQUNwRixDQUFDRCwrRUFBK0UsRUFBRTtJQUNsRixDQUFDRCxvRUFBb0UsRUFBRTtJQUN2RSxDQUFDSCxpRUFBaUUsRUFBRTtJQUNwRSxDQUFDaUQsaUVBQWlFLEVBQUU7SUFDcEUsQ0FBQ2hELGlFQUFpRSxFQUFFO0lBQ3BFLENBQUNLLDZEQUE2RCxFQUFFO0lBQ2hFLENBQUNDLDZEQUE2RCxFQUFFO0lBQ2hFLENBQUNDLG9FQUFvRSxFQUFFO0lBQ3ZFLENBQUNDLDZFQUE2RSxFQUFFO0lBQ2hGLENBQUM3SixxREFBcUQsRUFBRTtJQUN4RCxDQUFDQyxpREFBaUQsRUFBRTtJQUNwRCxDQUFDQywrQ0FBK0MsRUFBRTtJQUNsRCxDQUFDL0QsNENBQTRDLEVBQUU7SUFDL0MsQ0FBQ0gsNEJBQTRCLEVBQUU7SUFDL0IsQ0FBQ2lRLGlGQUFpRixFQUFFO0lBQ3BGLENBQUNFLHdFQUF3RSxFQUFFO0lBQzNFLENBQUNILGlIQUFpSCxFQUFFO0lBQ3BILENBQUNELHVFQUF1RSxFQUFFO0lBQzFFLENBQUNHLDZEQUE2RCxFQUFFO0lBQ2hFLENBQUN4UCx1Q0FBdUMsRUFBRTtJQUMxQyxDQUFDQyx1Q0FBdUMsRUFBRTtJQUMxQyxDQUFDRSx3Q0FBd0MsRUFBRTtJQUMzQyxDQUFDRCx5Q0FBeUMsRUFBRTtJQUM1QyxDQUFDSCxvQ0FBb0MsRUFBRTtJQUN2QyxDQUFDWSxtQ0FBbUMsRUFBRTtJQUN0QyxDQUFDVyxzREFBc0QsRUFBRTtJQUN6RCxDQUFDSCx5REFBeUQsRUFBRTtJQUM1RCxDQUFDVixvRUFBb0UsRUFBRTtJQUN2RSxDQUFDSCxpRUFBaUUsRUFBRTtJQUNwRSxDQUFDTyx1RUFBdUUsRUFBRTtJQUMxRSxDQUFDQyxvRUFBb0UsRUFBRTtJQUN2RSxDQUFDVixtRUFBbUUsRUFBRTtJQUN0RSxDQUFDRyxrRUFBa0UsRUFBRTtJQUNyRSxDQUFDVyxvREFBb0QsRUFBRTtJQUN2RCxDQUFDSCxpREFBaUQsRUFBRTtJQUNwRCxDQUFDTSx3RUFBd0UsRUFBRTtJQUMzRSxDQUFDaEIsNkRBQTZELEVBQUU7SUFDaEUsQ0FBQ1csa0RBQWtELEVBQUU7SUFDckQsQ0FBQ0osdUVBQXVFLEVBQUU7SUFDMUUsQ0FBQ0ssaUZBQWlGLEVBQUU7SUFDcEYsQ0FBQ1Asd0VBQXdFLEVBQUU7SUFDM0UsQ0FBQ1UsZ0ZBQWdGLEVBQUU7SUFDbkYsQ0FBQ1oscUVBQXFFLEVBQUU7SUFDeEUsQ0FBQ3lDLGlEQUFpRCxFQUFFO0lBQ3BELENBQUNDLG9EQUFvRCxFQUFFO0lBQ3ZELENBQUNDLGtEQUFrRCxFQUFFO0lBQ3JELENBQUNFLHNEQUFzRCxFQUFFO0lBQ3pELENBQUNELHlEQUF5RCxFQUFFO0lBQzVELENBQUMxRCxvQ0FBb0MsRUFBRTtJQUN2QyxDQUFDQyxzQ0FBc0MsRUFBRTtJQUN6QyxDQUFDRyx1Q0FBdUMsRUFBRTtJQUMxQyxDQUFDRixzQ0FBc0MsRUFBRTtJQUN6QyxDQUFDTCxzQ0FBc0MsRUFBRTtJQUN6QyxDQUFDd0ksdUVBQXVFLEVBQUU7SUFDMUUsQ0FBQ1UsdUVBQXVFLEVBQUU7SUFDMUUsQ0FBQ1gsOEVBQThFLEVBQUU7SUFDakYsQ0FBQ1UsMERBQTBELEVBQUU7SUFDN0QsQ0FBQ1osd0RBQXdELEVBQUU7SUFDM0QsQ0FBQ08sd0RBQXdELEVBQUU7SUFDM0QsQ0FBQ0Msd0RBQXdELEVBQUU7SUFDM0QsQ0FBQ0MsMERBQTBELEVBQUU7SUFDN0QsQ0FBQ0osb0VBQW9FLEVBQUU7SUFDdkUsQ0FBQ0ssdUVBQXVFLEVBQUU7SUFDMUUsQ0FBQ04sd0RBQXdELEVBQUU7SUFDM0QsQ0FBQ1csMkRBQTJELEVBQUU7SUFDOUQsQ0FBQ0MsMkRBQTJELEVBQUU7SUFDOUQsQ0FBQ0wsbURBQW1ELEVBQUU7SUFDdEQsQ0FBQ00sK0RBQStELEVBQUU7SUFDbEUsQ0FBQ2hCLDZFQUE2RSxFQUFFO0lBQ2hGLENBQUNhLG1EQUFtRCxFQUFFO0lBQ3RELENBQUNSLDZEQUE2RCxFQUFFO0lBQ2hFLENBQUM4RyxpRUFBaUUsRUFBRTtJQUNwRSxDQUFDRSx3RUFBd0UsRUFBRTtJQUMzRSxDQUFDQywyREFBMkQsRUFBRTtJQUM5RCxDQUFDQywyREFBMkQsRUFBRTtJQUM5RCxDQUFDSCxpRUFBaUUsRUFBRTtJQUNwRSxDQUFDRixtREFBbUQsRUFBRTtJQUN0RCxDQUFDSCxvQ0FBb0MsRUFBRTtJQUN2QyxDQUFDRSx3Q0FBd0MsRUFBRTtJQUMzQyxDQUFDRCxtREFBbUQsRUFBRTtJQUN0RCxDQUFDN0gsMkRBQTJELEVBQUU7SUFDOUQsQ0FBQ0MsK0NBQStDLEVBQUU7SUFDbEQsQ0FBQ0Usd0RBQXdELEVBQUU7SUFDM0QsQ0FBQ0Msc0RBQXNELEVBQUU7SUFDekQsQ0FBQ0YsOENBQThDLEVBQUU7SUFDakQsQ0FBQ0ksNERBQTRELEVBQUU7SUFDL0QsQ0FBQ0MsMERBQTBELEVBQUU7SUFDN0QsQ0FBQ0MsMERBQTBELEVBQUU7SUFDN0QsQ0FBQ0gsa0RBQWtELEVBQUU7SUFDckQsQ0FBQ0ksdUVBQXVFLEVBQUU7SUFDMUUsQ0FBQ0MseURBQXlELEVBQUU7SUFDNUQsQ0FBQ0MscURBQXFELEVBQUU7SUFDeEQsQ0FBQzVFLCtEQUErRCxFQUFFO0lBQ2xFLENBQUNOLGtEQUFrRCxFQUFFO0lBQ3JELENBQUNELDREQUE0RCxFQUFFO0lBQy9ELENBQUNFLDZEQUE2RCxFQUFFO0lBQ2hFLENBQUNDLDJEQUEyRCxFQUFFO0lBQzlELENBQUNDLDZEQUE2RCxFQUFFO0lBQ2hFLENBQUNDLHlEQUF5RCxFQUFFO0lBQzVELENBQUNDLDJEQUEyRCxFQUFFO0lBQzlELENBQUNqRCxxQ0FBcUMsRUFBRTtJQUN4QyxDQUFDd0wsNERBQTRELEVBQUU7SUFDL0QsQ0FBQ2YsZ0RBQWdELEVBQUU7SUFDbkQsQ0FBQ0Msc0RBQXNELEVBQUU7SUFDekQsQ0FBQ0MsbURBQW1ELEVBQUU7SUFDdEQsQ0FBQ29CLGdFQUFnRSxFQUFFO0lBQ25FLENBQUNoQixtREFBbUQsRUFBRTtJQUN0RCxDQUFDQyxxREFBcUQsRUFBRTtJQUN4RCxDQUFDQyxxREFBcUQsRUFBRTtJQUN4RCxDQUFDTSxxREFBcUQsRUFBRTtJQUN4RCxDQUFDZSx1REFBdUQsRUFBRTtJQUMxRCxDQUFDekIsNERBQTRELEVBQUU7SUFDL0QsQ0FBQzBCLDZEQUE2RCxFQUFFO0lBQ2hFLENBQUN6Qix5REFBeUQsRUFBRTtJQUM1RCxDQUFDSyx1REFBdUQsRUFBRTtJQUMxRCxDQUFDYyxtRUFBbUUsRUFBRTtJQUN0RSxDQUFDQyxvRUFBb0UsRUFBRTtJQUN2RSxDQUFDRixvRUFBb0UsRUFBRTtJQUN2RSxDQUFDUyx5RUFBeUUsRUFBRTtJQUM1RSxDQUFDcEIsK0RBQStELEVBQUU7SUFDbEUsQ0FBQ2MsNkRBQTZELEVBQUU7SUFDaEUsQ0FBQ1IsMERBQTBELEVBQUU7SUFDN0QsQ0FBQ2Esd0VBQXdFLEVBQUU7SUFDM0UsQ0FBQ3RCLDJEQUEyRCxFQUFFO0lBQzlELENBQUNOLDJEQUEyRCxFQUFFO0lBQzlELENBQUMrQiwwRUFBMEUsRUFBRTtJQUM3RSxDQUFDRCx1REFBdUQsRUFBRTtJQUMxRCxDQUFDcEIsa0RBQWtELEVBQUU7SUFDckQsQ0FBQ0YsbURBQW1ELEVBQUU7SUFDdEQsQ0FBQ1Usd0RBQXdELEVBQUU7SUFDM0QsQ0FBQ2Msd0RBQXdELEVBQUU7SUFDM0QsQ0FBQ3BDLHlDQUF5QyxFQUFFO0lBQzVDLENBQUNrQixxREFBcUQsRUFBRTtJQUN4RCxDQUFDRyx1RUFBdUUsRUFBRTtJQUMxRSxDQUFDUSx1RUFBdUUsRUFBRTtJQUMxRSxDQUFDVCxxRUFBcUUsRUFBRTtJQUN4RSxDQUFDSCxtRUFBbUUsRUFBRTtJQUN0RSxDQUFDVyxrRUFBa0UsRUFBRTtJQUNyRSxDQUFDcEMsNkRBQTZELEVBQUU7SUFDaEUsQ0FBQ0wsMkNBQTJDLEVBQUU7SUFDOUMsQ0FBQ00sK0RBQStELEVBQUU7SUFDbEUsQ0FBQ0ksOENBQThDLEVBQUU7SUFDakQsQ0FBQ2xCLHVEQUF1RCxFQUFFO0lBQzFELENBQUNDLG1EQUFtRCxFQUFFO0lBQ3RELENBQUNFLHFGQUFxRixFQUFFO0lBQ3hGLENBQUNDLHVGQUF1RixFQUFFO0lBQzFGLENBQUNFLGlFQUFpRSxFQUFFO0lBQ3BFLENBQUNELHFGQUFxRixFQUFFO0lBQ3hGLENBQUNXLDREQUE0RCxFQUFFO0lBQy9ELENBQUNDLDRFQUE0RSxFQUFFO0lBQy9FLENBQUNSLDZDQUE2QyxFQUFFO0lBQ2hELENBQUNDLHVEQUF1RCxFQUFFO0lBQzFELENBQUNFLDZGQUE2RixFQUFFO0lBQ2hHLENBQUNELDBFQUEwRSxFQUFFO0lBQzdFLENBQUNiLDREQUE0RCxFQUFFO0lBQy9ELENBQUNDLGlFQUFpRSxFQUFFO0lBQ3BFLENBQUNnQix1REFBdUQsRUFBRTtJQUMxRCxDQUFDUiw4Q0FBOEMsRUFBRTtJQUNqRCxDQUFDTCx1REFBdUQsRUFBRTtJQUMxRCxDQUFDaUIsd0RBQXdELEVBQUU7SUFDM0QsQ0FBQ0MsbUVBQW1FLEVBQUU7QUFDeEU7QUFFQSwyQkFBMkI7QUFDM0IsSUFBSTZHLGNBQWM7QUFDbEIsSUFBSUMsT0FBTztBQUNYLFNBQVNDLDZCQUE2QkMsSUFBSSxFQUFFVixVQUFVLENBQUMsQ0FBQztJQUN0RCxNQUFNVyxzQkFBc0JMLG1CQUFtQixDQUFDSSxLQUFLO0lBQ3JELElBQUlDLG9CQUFvQkMsTUFBTSxLQUFLLEdBQUc7UUFDcEMsT0FBTztJQUNUO0lBQ0EsSUFBSUM7SUFDSixTQUFTQyxnQkFBZ0JDLFFBQVE7UUFDL0IsSUFBSUYsS0FBSyxDQUFDTCxLQUFLLEtBQUssRUFBRSxZQUFZLEtBQUk7WUFDcEMsTUFBTVEsZUFBZUwsb0JBQW9CTSxLQUFLLENBQUNKLEtBQUssQ0FBQ04sWUFBWSxHQUFHLEdBQUdRO1lBQ3ZFRyxVQUFVQyxJQUFJLENBQ1pILGdCQUFnQmhCLFVBQ2QsNEVBQTRFO1lBQzVFLENBQUMsRUFBRUEsT0FBTyxDQUFDZ0IsYUFBYSxDQUFDLENBQUMsR0FDeEIsQ0FBQyxDQUFDLEVBQUVBLGFBQWEsQ0FBQztRQUUxQixPQUFPLElBQUlILEtBQUssQ0FBQ0wsS0FBSyxLQUFLLEVBQUUsUUFBUSxLQUFJO1lBQ3ZDVSxVQUFVQyxJQUFJLENBQUNSLG9CQUFvQk0sS0FBSyxDQUFDSixLQUFLLENBQUNOLFlBQVksRUFBRVE7UUFDL0Q7SUFDRjtJQUNBLE1BQU1HLFlBQVksRUFBRTtJQUNwQlAsb0JBQW9CUyxLQUFLLENBQUMsSUFBSUMsT0FBTyxDQUFDLENBQUNDLE1BQU1DO1FBQzNDLElBQUlBLE9BQU8sR0FBRztZQUNaVixRQUFRO2dCQUNOLENBQUNOLFlBQVksRUFBRTtnQkFDZixDQUFDQyxLQUFLLEVBQUVHLG1CQUFtQixDQUFDLEVBQUUsS0FBSyxPQUFPLEVBQUUsa0JBQWtCLE1BQUtBLG1CQUFtQixDQUFDLEVBQUUsS0FBSyxNQUFNLEVBQUUsWUFBWSxNQUFLLEVBQUUsUUFBUTtZQUNuSTtZQUNBO1FBQ0Y7UUFDQSxJQUFJYTtRQUNKLE9BQVFYLEtBQUssQ0FBQ0wsS0FBSztZQUNqQixLQUFLLEVBQUUsa0JBQWtCO2dCQUN2QmdCLFlBQVk7b0JBQUUsQ0FBQ2pCLFlBQVksRUFBRWdCO29CQUFJLENBQUNmLEtBQUssRUFBRSxFQUFFLFFBQVE7Z0JBQUc7Z0JBQ3REO1lBQ0YsS0FBSyxFQUFFLFFBQVE7Z0JBQ2IsSUFBSWMsU0FBUyxNQUFNO29CQUNqQkUsWUFBWTt3QkFBRSxDQUFDakIsWUFBWSxFQUFFZ0I7d0JBQUksQ0FBQ2YsS0FBSyxFQUFFLEVBQUUsa0JBQWtCO29CQUFHO2dCQUNsRSxPQUFPLElBQUljLFNBQVMsS0FBSztvQkFDdkJFLFlBQVk7d0JBQUUsQ0FBQ2pCLFlBQVksRUFBRWdCO3dCQUFJLENBQUNmLEtBQUssRUFBRSxFQUFFLFlBQVk7b0JBQUc7Z0JBQzVEO2dCQUNBO1lBQ0YsS0FBSyxFQUFFLFlBQVk7Z0JBQ2pCLElBQUljLFNBQVMsTUFBTTtvQkFDakJFLFlBQVk7d0JBQUUsQ0FBQ2pCLFlBQVksRUFBRWdCO3dCQUFJLENBQUNmLEtBQUssRUFBRSxFQUFFLGtCQUFrQjtvQkFBRztnQkFDbEUsT0FBTyxJQUFJYyxTQUFTLEtBQUs7b0JBQ3ZCRSxZQUFZO3dCQUFFLENBQUNqQixZQUFZLEVBQUVnQjt3QkFBSSxDQUFDZixLQUFLLEVBQUUsRUFBRSxZQUFZO29CQUFHO2dCQUM1RCxPQUFPLElBQUksQ0FBQ2MsS0FBS0csS0FBSyxDQUFDLE9BQU87b0JBQzVCRCxZQUFZO3dCQUFFLENBQUNqQixZQUFZLEVBQUVnQjt3QkFBSSxDQUFDZixLQUFLLEVBQUUsRUFBRSxRQUFRO29CQUFHO2dCQUN4RDtnQkFDQTtRQUNKO1FBQ0EsSUFBSWdCLFdBQVc7WUFDYixJQUFJWCxVQUFVVyxXQUFXO2dCQUN2QlYsZ0JBQWdCUztZQUNsQjtZQUNBVixRQUFRVztRQUNWO0lBQ0Y7SUFDQVY7SUFDQSxPQUFPSSxVQUFVMUIsSUFBSSxDQUFDO0FBQ3hCO0FBQ0EsU0FBU2tDLGdCQUFnQmhCLElBQUksRUFBRVYsVUFBVSxDQUFDLENBQUM7SUFDekMsSUFBSTJCLElBQXFDLEVBQUU7UUFDekMsT0FBT2xCLDZCQUE2QkMsTUFBTVY7SUFDNUMsT0FBTyxFQU1OO0FBQ0g7QUFFQSxlQUFlO0FBQ2YsU0FBUzhCLGNBQWNDLENBQUMsRUFBRXJCLElBQUk7SUFDNUIsTUFBTXNCLGlCQUFpQkQsYUFBYUUsU0FBU0YsRUFBRUcsSUFBSSxLQUFLO0lBQ3hELElBQUlGLGdCQUFnQjtRQUNsQixJQUFJdEIsU0FBUyxLQUFLLEdBQUc7WUFDbkIsT0FBT3FCLEVBQUUvQixPQUFPLENBQUNtQyxNQUFNLEtBQUt6QjtRQUM5QjtRQUNBLE9BQU87SUFDVDtJQUNBLE9BQU87QUFDVDtBQUNBLElBQUkwQixjQUFjLGNBQWNIO0lBWTlCSSxZQUFZLEdBQUcsQ0FBQzNCLE1BQU00Qix1QkFBdUIsQ0FBRTtRQUM3QyxJQUFJdEM7UUFDSixJQUFJdUM7UUFDSixJQUFJRCx3QkFBd0I7WUFDMUIzQyxPQUFPTyxPQUFPLENBQUNQLE9BQU82Qyx5QkFBeUIsQ0FBQ0YseUJBQXlCakIsT0FBTyxDQUFDLENBQUMsQ0FBQ2EsTUFBTU8sV0FBVztnQkFDbEcsSUFBSVAsU0FBUyxTQUFTO29CQUNwQkssZUFBZTt3QkFBRUcsT0FBT0QsV0FBV3RELEtBQUs7b0JBQUM7Z0JBQzNDLE9BQU87b0JBQ0wsSUFBSWEsWUFBWSxLQUFLLEdBQUc7d0JBQ3RCQSxVQUFVOzRCQUNSbUMsUUFBUXpCO3dCQUNWO29CQUNGO29CQUNBZixPQUFPZ0QsY0FBYyxDQUFDM0MsU0FBU2tDLE1BQU1PO2dCQUN2QztZQUNGO1FBQ0Y7UUFDQSxNQUFNRyxVQUFVbEIsZ0JBQWdCaEIsTUFBTVY7UUFDdEMsS0FBSyxDQUFDNEMsU0FBU0w7UUE3QmpCOzs7OztHQUtDLFFBQ0RHLFFBQVEsSUFBSSxDQUFDQSxLQUFLO1FBd0JoQixJQUFJLENBQUMxQyxPQUFPLEdBQUdMLE9BQU9rRCxNQUFNLENBQzFCN0MsWUFBWSxLQUFLLElBQUk7WUFDbkJtQyxRQUFRekI7UUFDVixJQUFJVjtRQUVOLElBQUksQ0FBQ2tDLElBQUksR0FBRztJQUNkO0FBQ0Y7QUFFQSxxQkFBcUI7QUFDckIsU0FBU1ksc0JBQXNCLEdBQUdDLElBQUk7SUFDcEMsSUFBSSx1QkFBdUJkLFNBQVMsT0FBT0EsTUFBTWUsaUJBQWlCLEtBQUssWUFBWTtRQUNqRmYsTUFBTWUsaUJBQWlCLElBQUlEO0lBQzdCO0FBQ0Y7QUFFQSx5QkFBeUI7QUFDekIsU0FBU0UsMkJBQTJCLEVBQUVDLG1CQUFtQixFQUFFQyxlQUFlLEVBQUVDLGlCQUFpQixFQUFFQyxZQUFZLEVBQUUsRUFBRUMsY0FBYztJQUMzSCxJQUFJQztJQUNKLElBQUlDO0lBQ0osSUFBSSxPQUFPSCxpQkFBaUIsVUFBVTtRQUNwQ0UsZUFBZUY7SUFDakIsT0FBTztRQUNMRSxlQUFlNUQsT0FBT2tDLElBQUksQ0FBQ3dCLGFBQWEsQ0FBQyxFQUFFO1FBQzNDRyxrQkFBa0JILFlBQVksQ0FBQ0UsYUFBYTtJQUM5QztJQUNBLE1BQU1FLGFBQWFMLGtCQUFrQk0sT0FBTyxDQUFDSDtJQUM3QyxNQUFNSSxZQUFZVCxzQkFBc0JPO0lBQ3hDLE1BQU1HLGVBQWVULGdCQUFnQlEsV0FBV0osY0FBY0M7SUFDOUQsTUFBTUssTUFBTSxJQUFJekIsWUFBWXVCLFdBQVdDO0lBQ3ZDZCxzQkFBc0JlLEtBQUtQO0lBQzNCLE9BQU9PO0FBQ1Q7QUFFQSwyQkFBMkI7QUFDM0IsSUFBSUMsc0JBQXNCO0lBQ3hCLCtHQUErRztJQUMvRyw0RkFBNEY7SUFDNUYsd0VBQXdFO0lBQ3hFO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBQ0QsU0FBU0MsbUNBQW1DQyxLQUFLLEVBQUVDLGdCQUFnQjtJQUNqRSxNQUFNQyxjQUFjQyxPQUFPSDtJQUMzQixPQUFPZiwyQkFDTDtRQUNFQyxxQkFBcUI7UUFDckJDLGlCQUFnQlEsU0FBUyxFQUFFSixZQUFZLEVBQUVDLGVBQWU7WUFDdEQsSUFBSUcsY0FBYzVRLDBDQUEwQztnQkFDMUQsT0FBTztvQkFDTHFSLFdBQVdiO29CQUNYUyxPQUFPRTtvQkFDUCxHQUFHVixvQkFBb0IsS0FBSyxJQUFJO3dCQUFFYSx5QkFBeUJiO29CQUFnQixJQUFJLElBQUk7Z0JBQ3JGO1lBQ0YsT0FBTyxJQUFJRyxjQUFjbFAseUNBQXlDO2dCQUNoRSxPQUFPO29CQUNMaU0sTUFBTXlELE9BQU9YO29CQUNiUSxPQUFPRTtnQkFDVDtZQUNGO1lBQ0EsT0FBTztnQkFBRUYsT0FBT0U7WUFBWTtRQUM5QjtRQUNBZCxtQkFBbUJVO1FBQ25CVCxjQUFjWTtJQUNoQixHQUNBRjtBQUVKO0FBRUEsMkJBQTJCO0FBQzNCLElBQUlPLHVCQUF1QjtJQUN6QiwwR0FBMEc7SUFDMUcsNEZBQTRGO0lBQzVGLHdFQUF3RTtJQUN4RTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsOEZBQThGO0lBQzlGO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0Q7QUFDRCxTQUFTQyxtQ0FBbUNDLGdCQUFnQjtJQUMxRCxJQUFJLE9BQU9BLHFCQUFxQixZQUFZLHNCQUFzQkEsa0JBQWtCO1FBQ2xGLE9BQU9ULHNDQUNGUyxpQkFBaUJDLGdCQUFnQjtJQUV4QztJQUNBLE9BQU94QiwyQkFDTDtRQUNFQyxxQkFBcUI7UUFDckJDLGlCQUFnQlEsU0FBUyxFQUFFSixZQUFZLEVBQUVDLGVBQWU7WUFDdEQsSUFBSUcsY0FBY2hLLDBDQUEwQztnQkFDMUQsT0FBTztvQkFDTHlLLFdBQVdiO29CQUNYLEdBQUdDLG9CQUFvQixLQUFLLElBQUk7d0JBQUVrQix5QkFBeUJsQjtvQkFBZ0IsSUFBSSxJQUFJO2dCQUNyRjtZQUNGLE9BQU8sSUFBSUcsY0FBY2xJLHdEQUF3RDtnQkFDL0UsT0FBTztvQkFDTHVJLE9BQU9HLE9BQU9YO2dCQUNoQjtZQUNGLE9BQU8sSUFBSUcsY0FBY2pJLGdFQUFnRWlJLGNBQWM3SCwyRUFBMkU7Z0JBQ2hMLE9BQU87b0JBQ0w2SSxjQUFjUixPQUFPWCxnQkFBZ0JvQixhQUFhO2dCQUNwRDtZQUNGO1FBQ0Y7UUFDQXhCLG1CQUFtQmtCO1FBQ25CakIsY0FBY21CO0lBQ2hCLEdBQ0FEO0FBRUo7QUFFQSx3QkFBd0I7QUFDeEIsU0FBU00sK0JBQStCQyxxQkFBcUI7SUFDM0QsSUFBSUM7SUFDSixJQUFJQyxtQkFBbUJGLHdCQUF3QjtRQUM3QyxNQUFNLEVBQUVwRSxNQUFNdUUsT0FBTyxFQUFFQyxJQUFJLEVBQUV0QyxPQUFPLEVBQUUsR0FBR2tDO1FBQ3pDLE1BQU1wRSxPQUFPeUQsT0FBT2M7UUFDcEIsSUFBSXZFLFNBQVMvUCx5RUFBeUU7WUFDcEYsTUFBTSxFQUFFa1QsR0FBRyxFQUFFLEdBQUdzQix1QkFBdUIsR0FBR0Q7WUFDMUMsTUFBTUUsY0FBY3ZCLE1BQU07Z0JBQUVuQixPQUFPNkIsbUNBQW1DVjtZQUFLLElBQUk7WUFDL0VrQixNQUFNLElBQUkzQyxZQUFZelIseUVBQXlFO2dCQUM3RixHQUFHd1UscUJBQXFCO2dCQUN4QixHQUFHQyxXQUFXO1lBQ2hCO1FBQ0YsT0FBTztZQUNMLElBQUl4QjtZQUNKLE9BQVFsRDtnQkFDTixLQUFLcFI7Z0JBQ0wsS0FBS0M7Z0JBQ0wsS0FBS0U7Z0JBQ0wsS0FBS0Q7Z0JBQ0wsS0FBS0g7Z0JBQ0wsS0FBS1k7Z0JBQ0wsS0FBS1c7Z0JBQ0wsS0FBS0g7Z0JBQ0wsS0FBS1Y7Z0JBQ0wsS0FBS0k7Z0JBQ0wsS0FBS0M7Z0JBQ0wsS0FBS0U7Z0JBQ0wsS0FBS0M7Z0JBQ0wsS0FBS1Q7b0JBQ0g4VCxlQUFlO3dCQUFFeUIsaUJBQWlCekM7b0JBQVE7b0JBQzFDO2dCQUNGO29CQUNFLElBQUksT0FBT3NDLFNBQVMsWUFBWSxDQUFDOUYsTUFBTUMsT0FBTyxDQUFDNkYsT0FBTzt3QkFDcER0QixlQUFlc0I7b0JBQ2pCO1lBQ0o7WUFDQUgsTUFBTSxJQUFJM0MsWUFBWTFCLE1BQU1rRDtRQUM5QjtJQUNGLE9BQU87UUFDTCxNQUFNaEIsVUFBVSxPQUFPa0MsMEJBQTBCLFlBQVlBLDBCQUEwQixRQUFRLGFBQWFBLHlCQUF5QixPQUFPQSxzQkFBc0JsQyxPQUFPLEtBQUssV0FBV2tDLHNCQUFzQmxDLE9BQU8sR0FBRztRQUN6Tm1DLE1BQU0sSUFBSTNDLFlBQVloVCx3Q0FBd0M7WUFBRWtXLE9BQU9SO1lBQXVCbEM7UUFBUTtJQUN4RztJQUNBRSxzQkFBc0JpQyxLQUFLRjtJQUMzQixPQUFPRTtBQUNUO0FBQ0EsU0FBU0MsbUJBQW1CN0YsS0FBSztJQUMvQixPQUFPLE9BQU9BLFVBQVUsWUFBWUEsVUFBVSxRQUFRLFVBQVVBLFNBQVMsYUFBYUEsU0FBVSxRQUFPQSxNQUFNdUIsSUFBSSxLQUFLLFlBQVksT0FBT3ZCLE1BQU11QixJQUFJLEtBQUssUUFBTyxLQUFNLE9BQU92QixNQUFNeUQsT0FBTyxLQUFLO0FBQ2hNO0FBRUEsMkJBQTJCO0FBQzNCLFNBQVMyQyxzQkFBc0JELEtBQUs7SUFDbEMsTUFBTUUsa0JBQWtCO1FBQ3RCN1U7UUFDQTRJO0tBQ0Q7SUFDRCxJQUFJdUksY0FBY3dELFVBQVUsQ0FBQyxDQUFDQSxNQUFNNUMsS0FBSyxJQUFJOEMsZ0JBQWdCQyxRQUFRLENBQUNILE1BQU10RixPQUFPLENBQUNtQyxNQUFNLEdBQUc7UUFDM0YsT0FBT21ELE1BQU01QyxLQUFLO0lBQ3BCO0lBQ0EsT0FBTzRDO0FBQ1Q7QUFFNnJlLENBQzdyZSx1Q0FBdUM7Q0FDdkMsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xhdy13b3Jrcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL2Vycm9ycy9kaXN0L2luZGV4Lm5vZGUubWpzPzkwMzAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2NvZGVzLnRzXG52YXIgU09MQU5BX0VSUk9SX19CTE9DS19IRUlHSFRfRVhDRUVERUQgPSAxO1xudmFyIFNPTEFOQV9FUlJPUl9fSU5WQUxJRF9OT05DRSA9IDI7XG52YXIgU09MQU5BX0VSUk9SX19OT05DRV9BQ0NPVU5UX05PVF9GT1VORCA9IDM7XG52YXIgU09MQU5BX0VSUk9SX19CTE9DS0hBU0hfU1RSSU5HX0xFTkdUSF9PVVRfT0ZfUkFOR0UgPSA0O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5WQUxJRF9CTE9DS0hBU0hfQllURV9MRU5HVEggPSA1O1xudmFyIFNPTEFOQV9FUlJPUl9fTEFNUE9SVFNfT1VUX09GX1JBTkdFID0gNjtcbnZhciBTT0xBTkFfRVJST1JfX01BTEZPUk1FRF9CSUdJTlRfU1RSSU5HID0gNztcbnZhciBTT0xBTkFfRVJST1JfX01BTEZPUk1FRF9OVU1CRVJfU1RSSU5HID0gODtcbnZhciBTT0xBTkFfRVJST1JfX1RJTUVTVEFNUF9PVVRfT0ZfUkFOR0UgPSA5O1xudmFyIFNPTEFOQV9FUlJPUl9fTUFMRk9STUVEX0pTT05fUlBDX0VSUk9SID0gMTA7XG52YXIgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fUEFSU0VfRVJST1IgPSAtMzI3MDA7XG52YXIgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fSU5URVJOQUxfRVJST1IgPSAtMzI2MDM7XG52YXIgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fSU5WQUxJRF9QQVJBTVMgPSAtMzI2MDI7XG52YXIgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fTUVUSE9EX05PVF9GT1VORCA9IC0zMjYwMTtcbnZhciBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19JTlZBTElEX1JFUVVFU1QgPSAtMzI2MDA7XG52YXIgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0xPTkdfVEVSTV9TVE9SQUdFX1VOUkVBQ0hBQkxFID0gLTMyMDE5O1xudmFyIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9TTE9UX05PVF9FUE9DSF9CT1VOREFSWSA9IC0zMjAxODtcbnZhciBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfRVBPQ0hfUkVXQVJEU19QRVJJT0RfQUNUSVZFID0gLTMyMDE3O1xudmFyIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9NSU5fQ09OVEVYVF9TTE9UX05PVF9SRUFDSEVEID0gLTMyMDE2O1xudmFyIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9VTlNVUFBPUlRFRF9UUkFOU0FDVElPTl9WRVJTSU9OID0gLTMyMDE1O1xudmFyIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9CTE9DS19TVEFUVVNfTk9UX0FWQUlMQUJMRV9ZRVQgPSAtMzIwMTQ7XG52YXIgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX1NJR05BVFVSRV9MRU5fTUlTTUFUQ0ggPSAtMzIwMTM7XG52YXIgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0NBTl9FUlJPUiA9IC0zMjAxMjtcbnZhciBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fSElTVE9SWV9OT1RfQVZBSUxBQkxFID0gLTMyMDExO1xudmFyIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9LRVlfRVhDTFVERURfRlJPTV9TRUNPTkRBUllfSU5ERVggPSAtMzIwMTA7XG52YXIgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0xPTkdfVEVSTV9TVE9SQUdFX1NMT1RfU0tJUFBFRCA9IC0zMjAwOTtcbnZhciBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfTk9fU05BUFNIT1QgPSAtMzIwMDg7XG52YXIgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1NMT1RfU0tJUFBFRCA9IC0zMjAwNztcbnZhciBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fUFJFQ09NUElMRV9WRVJJRklDQVRJT05fRkFJTFVSRSA9IC0zMjAwNjtcbnZhciBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfTk9ERV9VTkhFQUxUSFkgPSAtMzIwMDU7XG52YXIgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0JMT0NLX05PVF9BVkFJTEFCTEUgPSAtMzIwMDQ7XG52YXIgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX1NJR05BVFVSRV9WRVJJRklDQVRJT05fRkFJTFVSRSA9IC0zMjAwMztcbnZhciBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfU0VORF9UUkFOU0FDVElPTl9QUkVGTElHSFRfRkFJTFVSRSA9IC0zMjAwMjtcbnZhciBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfQkxPQ0tfQ0xFQU5FRF9VUCA9IC0zMjAwMTtcbnZhciBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fSU5WQUxJRF9CWVRFX0xFTkdUSCA9IDI4ZTU7XG52YXIgU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX1NUUklOR19MRU5HVEhfT1VUX09GX1JBTkdFID0gMjgwMDAwMTtcbnZhciBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fSU5WQUxJRF9CQVNFNThfRU5DT0RFRF9BRERSRVNTID0gMjgwMDAwMjtcbnZhciBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fSU5WQUxJRF9FRDI1NTE5X1BVQkxJQ19LRVkgPSAyODAwMDAzO1xudmFyIFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19NQUxGT1JNRURfUERBID0gMjgwMDAwNDtcbnZhciBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fUERBX0JVTVBfU0VFRF9PVVRfT0ZfUkFOR0UgPSAyODAwMDA1O1xudmFyIFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19NQVhfTlVNQkVSX09GX1BEQV9TRUVEU19FWENFRURFRCA9IDI4MDAwMDY7XG52YXIgU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX01BWF9QREFfU0VFRF9MRU5HVEhfRVhDRUVERUQgPSAyODAwMDA3O1xudmFyIFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19JTlZBTElEX1NFRURTX1BPSU5UX09OX0NVUlZFID0gMjgwMDAwODtcbnZhciBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fRkFJTEVEX1RPX0ZJTkRfVklBQkxFX1BEQV9CVU1QX1NFRUQgPSAyODAwMDA5O1xudmFyIFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19QREFfRU5EU19XSVRIX1BEQV9NQVJLRVIgPSAyODAwMDEwO1xudmFyIFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19JTlZBTElEX09GRl9DVVJWRV9BRERSRVNTID0gMjgwMDAxMTtcbnZhciBTT0xBTkFfRVJST1JfX0FDQ09VTlRTX19BQ0NPVU5UX05PVF9GT1VORCA9IDMyM2U0O1xudmFyIFNPTEFOQV9FUlJPUl9fQUNDT1VOVFNfX09ORV9PUl9NT1JFX0FDQ09VTlRTX05PVF9GT1VORCA9IDMyMzAwMDAxO1xudmFyIFNPTEFOQV9FUlJPUl9fQUNDT1VOVFNfX0ZBSUxFRF9UT19ERUNPREVfQUNDT1VOVCA9IDMyMzAwMDI7XG52YXIgU09MQU5BX0VSUk9SX19BQ0NPVU5UU19fRVhQRUNURURfREVDT0RFRF9BQ0NPVU5UID0gMzIzMDAwMztcbnZhciBTT0xBTkFfRVJST1JfX0FDQ09VTlRTX19FWFBFQ1RFRF9BTExfQUNDT1VOVFNfVE9fQkVfREVDT0RFRCA9IDMyMzAwMDQ7XG52YXIgU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19ESVNBTExPV0VEX0lOX0lOU0VDVVJFX0NPTlRFWFQgPSAzNjFlNDtcbnZhciBTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX0RJR0VTVF9VTklNUExFTUVOVEVEID0gMzYxMDAwMTtcbnZhciBTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX0VEMjU1MTlfQUxHT1JJVEhNX1VOSU1QTEVNRU5URUQgPSAzNjEwMDAyO1xudmFyIFNPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fRVhQT1JUX0ZVTkNUSU9OX1VOSU1QTEVNRU5URUQgPSAzNjEwMDAzO1xudmFyIFNPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fR0VORVJBVEVfRlVOQ1RJT05fVU5JTVBMRU1FTlRFRCA9IDM2MTAwMDQ7XG52YXIgU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19TSUdOX0ZVTkNUSU9OX1VOSU1QTEVNRU5URUQgPSAzNjEwMDA1O1xudmFyIFNPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fVkVSSUZZX0ZVTkNUSU9OX1VOSU1QTEVNRU5URUQgPSAzNjEwMDA2O1xudmFyIFNPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fQ0FOTk9UX0VYUE9SVF9OT05fRVhUUkFDVEFCTEVfS0VZID0gMzYxMDAwNztcbnZhciBTT0xBTkFfRVJST1JfX0NSWVBUT19fUkFORE9NX1ZBTFVFU19GVU5DVElPTl9VTklNUExFTUVOVEVEID0gMzYxMWUzO1xudmFyIFNPTEFOQV9FUlJPUl9fS0VZU19fSU5WQUxJRF9LRVlfUEFJUl9CWVRFX0xFTkdUSCA9IDM3MDRlMztcbnZhciBTT0xBTkFfRVJST1JfX0tFWVNfX0lOVkFMSURfUFJJVkFURV9LRVlfQllURV9MRU5HVEggPSAzNzA0MDAxO1xudmFyIFNPTEFOQV9FUlJPUl9fS0VZU19fSU5WQUxJRF9TSUdOQVRVUkVfQllURV9MRU5HVEggPSAzNzA0MDAyO1xudmFyIFNPTEFOQV9FUlJPUl9fS0VZU19fU0lHTkFUVVJFX1NUUklOR19MRU5HVEhfT1VUX09GX1JBTkdFID0gMzcwNDAwMztcbnZhciBTT0xBTkFfRVJST1JfX0tFWVNfX1BVQkxJQ19LRVlfTVVTVF9NQVRDSF9QUklWQVRFX0tFWSA9IDM3MDQwMDQ7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9fRVhQRUNURURfVE9fSEFWRV9BQ0NPVU5UUyA9IDQxMjhlMztcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX19FWFBFQ1RFRF9UT19IQVZFX0RBVEEgPSA0MTI4MDAxO1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fX1BST0dSQU1fSURfTUlTTUFUQ0ggPSA0MTI4MDAyO1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1VOS05PV04gPSA0NjE1ZTM7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fR0VORVJJQ19FUlJPUiA9IDQ2MTUwMDE7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9BUkdVTUVOVCA9IDQ2MTUwMDI7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9JTlNUUlVDVElPTl9EQVRBID0gNDYxNTAwMztcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX0FDQ09VTlRfREFUQSA9IDQ2MTUwMDQ7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9EQVRBX1RPT19TTUFMTCA9IDQ2MTUwMDU7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5TVUZGSUNJRU5UX0ZVTkRTID0gNDYxNTAwNjtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTkNPUlJFQ1RfUFJPR1JBTV9JRCA9IDQ2MTUwMDc7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTUlTU0lOR19SRVFVSVJFRF9TSUdOQVRVUkUgPSA0NjE1MDA4O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfQUxSRUFEWV9JTklUSUFMSVpFRCA9IDQ2MTUwMDk7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fVU5JTklUSUFMSVpFRF9BQ0NPVU5UID0gNDYxNTAxMDtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19VTkJBTEFOQ0VEX0lOU1RSVUNUSU9OID0gNDYxNTAxMTtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19NT0RJRklFRF9QUk9HUkFNX0lEID0gNDYxNTAxMjtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19FWFRFUk5BTF9BQ0NPVU5UX0xBTVBPUlRfU1BFTkQgPSA0NjE1MDEzO1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0VYVEVSTkFMX0FDQ09VTlRfREFUQV9NT0RJRklFRCA9IDQ2MTUwMTQ7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUkVBRE9OTFlfTEFNUE9SVF9DSEFOR0UgPSA0NjE1MDE1O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1JFQURPTkxZX0RBVEFfTU9ESUZJRUQgPSA0NjE1MDE2O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0RVUExJQ0FURV9BQ0NPVU5UX0lOREVYID0gNDYxNTAxNztcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19FWEVDVVRBQkxFX01PRElGSUVEID0gNDYxNTAxODtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19SRU5UX0VQT0NIX01PRElGSUVEID0gNDYxNTAxOTtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19OT1RfRU5PVUdIX0FDQ09VTlRfS0VZUyA9IDQ2MTUwMjA7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9EQVRBX1NJWkVfQ0hBTkdFRCA9IDQ2MTUwMjE7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9OT1RfRVhFQ1VUQUJMRSA9IDQ2MTUwMjI7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9CT1JST1dfRkFJTEVEID0gNDYxNTAyMztcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BQ0NPVU5UX0JPUlJPV19PVVRTVEFORElORyA9IDQ2MTUwMjQ7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRFVQTElDQVRFX0FDQ09VTlRfT1VUX09GX1NZTkMgPSA0NjE1MDI1O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0NVU1RPTSA9IDQ2MTUwMjY7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9FUlJPUiA9IDQ2MTUwMjc7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRVhFQ1VUQUJMRV9EQVRBX01PRElGSUVEID0gNDYxNTAyODtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19FWEVDVVRBQkxFX0xBTVBPUlRfQ0hBTkdFID0gNDYxNTAyOTtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19FWEVDVVRBQkxFX0FDQ09VTlRfTk9UX1JFTlRfRVhFTVBUID0gNDYxNTAzMDtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19VTlNVUFBPUlRFRF9QUk9HUkFNX0lEID0gNDYxNTAzMTtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19DQUxMX0RFUFRIID0gNDYxNTAzMjtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19NSVNTSU5HX0FDQ09VTlQgPSA0NjE1MDMzO1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1JFRU5UUkFOQ1lfTk9UX0FMTE9XRUQgPSA0NjE1MDM0O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01BWF9TRUVEX0xFTkdUSF9FWENFRURFRCA9IDQ2MTUwMzU7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9TRUVEUyA9IDQ2MTUwMzY7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9SRUFMTE9DID0gNDYxNTAzNztcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19DT01QVVRBVElPTkFMX0JVREdFVF9FWENFRURFRCA9IDQ2MTUwMzg7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUFJJVklMRUdFX0VTQ0FMQVRJT04gPSA0NjE1MDM5O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1BST0dSQU1fRU5WSVJPTk1FTlRfU0VUVVBfRkFJTFVSRSA9IDQ2MTUwNDA7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUFJPR1JBTV9GQUlMRURfVE9fQ09NUExFVEUgPSA0NjE1MDQxO1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1BST0dSQU1fRkFJTEVEX1RPX0NPTVBJTEUgPSA0NjE1MDQyO1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lNTVVUQUJMRSA9IDQ2MTUwNDM7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5DT1JSRUNUX0FVVEhPUklUWSA9IDQ2MTUwNDQ7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQk9SU0hfSU9fRVJST1IgPSA0NjE1MDQ1O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfTk9UX1JFTlRfRVhFTVBUID0gNDYxNTA0NjtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX0FDQ09VTlRfT1dORVIgPSA0NjE1MDQ3O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FSSVRITUVUSUNfT1ZFUkZMT1cgPSA0NjE1MDQ4O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1VOU1VQUE9SVEVEX1NZU1ZBUiA9IDQ2MTUwNDk7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSUxMRUdBTF9PV05FUiA9IDQ2MTUwNTA7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTUFYX0FDQ09VTlRTX0RBVEFfQUxMT0NBVElPTlNfRVhDRUVERUQgPSA0NjE1MDUxO1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01BWF9BQ0NPVU5UU19FWENFRURFRCA9IDQ2MTUwNTI7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTUFYX0lOU1RSVUNUSU9OX1RSQUNFX0xFTkdUSF9FWENFRURFRCA9IDQ2MTUwNTM7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQlVJTFRJTl9QUk9HUkFNU19NVVNUX0NPTlNVTUVfQ09NUFVURV9VTklUUyA9IDQ2MTUwNTQ7XG52YXIgU09MQU5BX0VSUk9SX19TSUdORVJfX0FERFJFU1NfQ0FOTk9UX0hBVkVfTVVMVElQTEVfU0lHTkVSUyA9IDU1MDhlMztcbnZhciBTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfS0VZX1BBSVJfU0lHTkVSID0gNTUwODAwMTtcbnZhciBTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfTUVTU0FHRV9TSUdORVIgPSA1NTA4MDAyO1xudmFyIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9NRVNTQUdFX01PRElGWUlOR19TSUdORVIgPSA1NTA4MDAzO1xudmFyIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9NRVNTQUdFX1BBUlRJQUxfU0lHTkVSID0gNTUwODAwNDtcbnZhciBTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfVFJBTlNBQ1RJT05fU0lHTkVSID0gNTUwODAwNTtcbnZhciBTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfVFJBTlNBQ1RJT05fTU9ESUZZSU5HX1NJR05FUiA9IDU1MDgwMDY7XG52YXIgU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX1RSQU5TQUNUSU9OX1BBUlRJQUxfU0lHTkVSID0gNTUwODAwNztcbnZhciBTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfVFJBTlNBQ1RJT05fU0VORElOR19TSUdORVIgPSA1NTA4MDA4O1xudmFyIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19UUkFOU0FDVElPTl9DQU5OT1RfSEFWRV9NVUxUSVBMRV9TRU5ESU5HX1NJR05FUlMgPSA1NTA4MDA5O1xudmFyIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19UUkFOU0FDVElPTl9TRU5ESU5HX1NJR05FUl9NSVNTSU5HID0gNTUwODAxMDtcbnZhciBTT0xBTkFfRVJST1JfX1NJR05FUl9fV0FMTEVUX01VTFRJU0lHTl9VTklNUExFTUVOVEVEID0gNTUwODAxMTtcbnZhciBTT0xBTkFfRVJST1JfX09GRkNIQUlOX01FU1NBR0VfX01BWElNVU1fTEVOR1RIX0VYQ0VFREVEID0gNTYwN2UzO1xudmFyIFNPTEFOQV9FUlJPUl9fT0ZGQ0hBSU5fTUVTU0FHRV9fUkVTVFJJQ1RFRF9BU0NJSV9CT0RZX0NIQVJBQ1RFUl9PVVRfT0ZfUkFOR0UgPSA1NjA3MDAxO1xudmFyIFNPTEFOQV9FUlJPUl9fT0ZGQ0hBSU5fTUVTU0FHRV9fQVBQTElDQVRJT05fRE9NQUlOX1NUUklOR19MRU5HVEhfT1VUX09GX1JBTkdFID0gNTYwNzAwMjtcbnZhciBTT0xBTkFfRVJST1JfX09GRkNIQUlOX01FU1NBR0VfX0lOVkFMSURfQVBQTElDQVRJT05fRE9NQUlOX0JZVEVfTEVOR1RIID0gNTYwNzAwMztcbnZhciBTT0xBTkFfRVJST1JfX09GRkNIQUlOX01FU1NBR0VfX05VTV9TSUdOQVRVUkVTX01JU01BVENIID0gNTYwNzAwNDtcbnZhciBTT0xBTkFfRVJST1JfX09GRkNIQUlOX01FU1NBR0VfX05VTV9SRVFVSVJFRF9TSUdORVJTX0NBTk5PVF9CRV9aRVJPID0gNTYwNzAwNTtcbnZhciBTT0xBTkFfRVJST1JfX09GRkNIQUlOX01FU1NBR0VfX1ZFUlNJT05fTlVNQkVSX05PVF9TVVBQT1JURUQgPSA1NjA3MDA2O1xudmFyIFNPTEFOQV9FUlJPUl9fT0ZGQ0hBSU5fTUVTU0FHRV9fTUVTU0FHRV9GT1JNQVRfTUlTTUFUQ0ggPSA1NjA3MDA3O1xudmFyIFNPTEFOQV9FUlJPUl9fT0ZGQ0hBSU5fTUVTU0FHRV9fTUVTU0FHRV9MRU5HVEhfTUlTTUFUQ0ggPSA1NjA3MDA4O1xudmFyIFNPTEFOQV9FUlJPUl9fT0ZGQ0hBSU5fTUVTU0FHRV9fTUVTU0FHRV9NVVNUX0JFX05PTl9FTVBUWSA9IDU2MDcwMDk7XG52YXIgU09MQU5BX0VSUk9SX19PRkZDSEFJTl9NRVNTQUdFX19OVU1fRU5WRUxPUEVfU0lHTkFUVVJFU19DQU5OT1RfQkVfWkVSTyA9IDU2MDcwMTA7XG52YXIgU09MQU5BX0VSUk9SX19PRkZDSEFJTl9NRVNTQUdFX19TSUdOQVRVUkVTX01JU1NJTkcgPSA1NjA3MDExO1xudmFyIFNPTEFOQV9FUlJPUl9fT0ZGQ0hBSU5fTUVTU0FHRV9fRU5WRUxPUEVfU0lHTkVSU19NSVNNQVRDSCA9IDU2MDcwMTI7XG52YXIgU09MQU5BX0VSUk9SX19PRkZDSEFJTl9NRVNTQUdFX19BRERSRVNTRVNfQ0FOTk9UX1NJR05fT0ZGQ0hBSU5fTUVTU0FHRSA9IDU2MDcwMTM7XG52YXIgU09MQU5BX0VSUk9SX19PRkZDSEFJTl9NRVNTQUdFX19VTkVYUEVDVEVEX1ZFUlNJT04gPSA1NjA3MDE0O1xudmFyIFNPTEFOQV9FUlJPUl9fT0ZGQ0hBSU5fTUVTU0FHRV9fU0lHTkFUT1JJRVNfTVVTVF9CRV9TT1JURUQgPSA1NjA3MDE1O1xudmFyIFNPTEFOQV9FUlJPUl9fT0ZGQ0hBSU5fTUVTU0FHRV9fU0lHTkFUT1JJRVNfTVVTVF9CRV9VTklRVUUgPSA1NjA3MDE2O1xudmFyIFNPTEFOQV9FUlJPUl9fT0ZGQ0hBSU5fTUVTU0FHRV9fU0lHTkFUVVJFX1ZFUklGSUNBVElPTl9GQUlMVVJFID0gNTYwNzAxNztcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19JTlZPS0VEX1BST0dSQU1TX0NBTk5PVF9QQVlfRkVFUyA9IDU2NjNlMztcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19JTlZPS0VEX1BST0dSQU1TX01VU1RfTk9UX0JFX1dSSVRBQkxFID0gNTY2MzAwMTtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19FWFBFQ1RFRF9CTE9DS0hBU0hfTElGRVRJTUUgPSA1NjYzMDAyO1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0VYUEVDVEVEX05PTkNFX0xJRkVUSU1FID0gNTY2MzAwMztcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19WRVJTSU9OX05VTUJFUl9PVVRfT0ZfUkFOR0UgPSA1NjYzMDA0O1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9UT19ERUNPTVBJTEVfQUREUkVTU19MT09LVVBfVEFCTEVfQ09OVEVOVFNfTUlTU0lORyA9IDU2NjMwMDU7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkFJTEVEX1RPX0RFQ09NUElMRV9BRERSRVNTX0xPT0tVUF9UQUJMRV9JTkRFWF9PVVRfT0ZfUkFOR0UgPSA1NjYzMDA2O1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9UT19ERUNPTVBJTEVfSU5TVFJVQ1RJT05fUFJPR1JBTV9BRERSRVNTX05PVF9GT1VORCA9IDU2NjMwMDc7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkFJTEVEX1RPX0RFQ09NUElMRV9GRUVfUEFZRVJfTUlTU0lORyA9IDU2NjMwMDg7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fU0lHTkFUVVJFU19NSVNTSU5HID0gNTY2MzAwOTtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19BRERSRVNTX01JU1NJTkcgPSA1NjYzMDEwO1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZFRV9QQVlFUl9NSVNTSU5HID0gNTY2MzAxMTtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GRUVfUEFZRVJfU0lHTkFUVVJFX01JU1NJTkcgPSA1NjYzMDEyO1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0lOVkFMSURfTk9OQ0VfVFJBTlNBQ1RJT05fSU5TVFJVQ1RJT05TX01JU1NJTkcgPSA1NjYzMDEzO1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0lOVkFMSURfTk9OQ0VfVFJBTlNBQ1RJT05fRklSU1RfSU5TVFJVQ1RJT05fTVVTVF9CRV9BRFZBTkNFX05PTkNFID0gNTY2MzAxNDtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19BRERSRVNTRVNfQ0FOTk9UX1NJR05fVFJBTlNBQ1RJT04gPSA1NjYzMDE1O1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0NBTk5PVF9FTkNPREVfV0lUSF9FTVBUWV9TSUdOQVRVUkVTID0gNTY2MzAxNjtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19NRVNTQUdFX1NJR05BVFVSRVNfTUlTTUFUQ0ggPSA1NjYzMDE3O1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9UT19FU1RJTUFURV9DT01QVVRFX0xJTUlUID0gNTY2MzAxODtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GQUlMRURfV0hFTl9TSU1VTEFUSU5HX1RPX0VTVElNQVRFX0NPTVBVVEVfTElNSVQgPSA1NjYzMDE5O1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0VYQ0VFRFNfU0laRV9MSU1JVCA9IDU2NjMwMjA7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fVkVSU0lPTl9OVU1CRVJfTk9UX1NVUFBPUlRFRCA9IDU2NjMwMjE7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fTk9OQ0VfQUNDT1VOVF9DQU5OT1RfQkVfSU5fTE9PS1VQX1RBQkxFID0gNTY2MzAyMjtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19VTktOT1dOID0gNzA1ZTQ7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQUNDT1VOVF9JTl9VU0UgPSA3MDUwMDAxO1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0FDQ09VTlRfTE9BREVEX1RXSUNFID0gNzA1MDAwMjtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19BQ0NPVU5UX05PVF9GT1VORCA9IDcwNTAwMDM7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fUFJPR1JBTV9BQ0NPVU5UX05PVF9GT1VORCA9IDcwNTAwMDQ7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5TVUZGSUNJRU5UX0ZVTkRTX0ZPUl9GRUUgPSA3MDUwMDA1O1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfQUNDT1VOVF9GT1JfRkVFID0gNzA1MDAwNjtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19BTFJFQURZX1BST0NFU1NFRCA9IDcwNTAwMDc7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQkxPQ0tIQVNIX05PVF9GT1VORCA9IDcwNTAwMDg7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQ0FMTF9DSEFJTl9UT09fREVFUCA9IDcwNTAwMDk7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fTUlTU0lOR19TSUdOQVRVUkVfRk9SX0ZFRSA9IDcwNTAwMTA7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9BQ0NPVU5UX0lOREVYID0gNzA1MDAxMTtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19TSUdOQVRVUkVfRkFJTFVSRSA9IDcwNTAwMTI7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9QUk9HUkFNX0ZPUl9FWEVDVVRJT04gPSA3MDUwMDEzO1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1NBTklUSVpFX0ZBSUxVUkUgPSA3MDUwMDE0O1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0NMVVNURVJfTUFJTlRFTkFOQ0UgPSA3MDUwMDE1O1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0FDQ09VTlRfQk9SUk9XX09VVFNUQU5ESU5HID0gNzA1MDAxNjtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19XT1VMRF9FWENFRURfTUFYX0JMT0NLX0NPU1RfTElNSVQgPSA3MDUwMDE3O1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1VOU1VQUE9SVEVEX1ZFUlNJT04gPSA3MDUwMDE4O1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfV1JJVEFCTEVfQUNDT1VOVCA9IDcwNTAwMTk7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fV09VTERfRVhDRUVEX01BWF9BQ0NPVU5UX0NPU1RfTElNSVQgPSA3MDUwMDIwO1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1dPVUxEX0VYQ0VFRF9BQ0NPVU5UX0RBVEFfQkxPQ0tfTElNSVQgPSA3MDUwMDIxO1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1RPT19NQU5ZX0FDQ09VTlRfTE9DS1MgPSA3MDUwMDIyO1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0FERFJFU1NfTE9PS1VQX1RBQkxFX05PVF9GT1VORCA9IDcwNTAwMjM7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9BRERSRVNTX0xPT0tVUF9UQUJMRV9PV05FUiA9IDcwNTAwMjQ7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9BRERSRVNTX0xPT0tVUF9UQUJMRV9EQVRBID0gNzA1MDAyNTtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX0FERFJFU1NfTE9PS1VQX1RBQkxFX0lOREVYID0gNzA1MDAyNjtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX1JFTlRfUEFZSU5HX0FDQ09VTlQgPSA3MDUwMDI3O1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1dPVUxEX0VYQ0VFRF9NQVhfVk9URV9DT1NUX0xJTUlUID0gNzA1MDAyODtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19XT1VMRF9FWENFRURfQUNDT1VOVF9EQVRBX1RPVEFMX0xJTUlUID0gNzA1MDAyOTtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19EVVBMSUNBVEVfSU5TVFJVQ1RJT04gPSA3MDUwMDMwO1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOU1VGRklDSUVOVF9GVU5EU19GT1JfUkVOVCA9IDcwNTAwMzE7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fTUFYX0xPQURFRF9BQ0NPVU5UU19EQVRBX1NJWkVfRVhDRUVERUQgPSA3MDUwMDMyO1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfTE9BREVEX0FDQ09VTlRTX0RBVEFfU0laRV9MSU1JVCA9IDcwNTAwMzM7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fUkVTQU5JVElaQVRJT05fTkVFREVEID0gNzA1MDAzNDtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19QUk9HUkFNX0VYRUNVVElPTl9URU1QT1JBUklMWV9SRVNUUklDVEVEID0gNzA1MDAzNTtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19VTkJBTEFOQ0VEX1RSQU5TQUNUSU9OID0gNzA1MDAzNjtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX1BMQU5TX19NRVNTQUdFX0NBTk5PVF9BQ0NPTU1PREFURV9QTEFOID0gNzYxOGUzO1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fUExBTlNfX01FU1NBR0VfUEFDS0VSX0FMUkVBRFlfQ09NUExFVEUgPSA3NjE4MDAxO1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fUExBTlNfX0VNUFRZX0lOU1RSVUNUSU9OX1BMQU4gPSA3NjE4MDAyO1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fUExBTlNfX0ZBSUxFRF9UT19FWEVDVVRFX1RSQU5TQUNUSU9OX1BMQU4gPSA3NjE4MDAzO1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fUExBTlNfX05PTl9ESVZJU0lCTEVfVFJBTlNBQ1RJT05fUExBTlNfTk9UX1NVUFBPUlRFRCA9IDc2MTgwMDQ7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9QTEFOU19fRkFJTEVEX1NJTkdMRV9UUkFOU0FDVElPTl9QTEFOX1JFU1VMVF9OT1RfRk9VTkQgPSA3NjE4MDA1O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fUExBTlNfX1VORVhQRUNURURfSU5TVFJVQ1RJT05fUExBTiA9IDc2MTgwMDY7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9QTEFOU19fVU5FWFBFQ1RFRF9UUkFOU0FDVElPTl9QTEFOID0gNzYxODAwNztcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX1BMQU5TX19VTkVYUEVDVEVEX1RSQU5TQUNUSU9OX1BMQU5fUkVTVUxUID0gNzYxODAwODtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX1BMQU5TX19FWFBFQ1RFRF9TVUNDRVNTRlVMX1RSQU5TQUNUSU9OX1BMQU5fUkVTVUxUID0gNzYxODAwOTtcbnZhciBTT0xBTkFfRVJST1JfX0NPREVDU19fQ0FOTk9UX0RFQ09ERV9FTVBUWV9CWVRFX0FSUkFZID0gODA3OGUzO1xudmFyIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0JZVEVfTEVOR1RIID0gODA3ODAwMTtcbnZhciBTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfRklYRURfTEVOR1RIID0gODA3ODAwMjtcbnZhciBTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfVkFSSUFCTEVfTEVOR1RIID0gODA3ODAwMztcbnZhciBTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFUl9ERUNPREVSX1NJWkVfQ09NUEFUSUJJTElUWV9NSVNNQVRDSCA9IDgwNzgwMDQ7XG52YXIgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9GSVhFRF9TSVpFX01JU01BVENIID0gODA3ODAwNTtcbnZhciBTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFUl9ERUNPREVSX01BWF9TSVpFX01JU01BVENIID0gODA3ODAwNjtcbnZhciBTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9OVU1CRVJfT0ZfSVRFTVMgPSA4MDc4MDA3O1xudmFyIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTlVNX0RJU0NSSU1JTkFUT1JfT1VUX09GX1JBTkdFID0gODA3ODAwODtcbnZhciBTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9ESVNDUklNSU5BVEVEX1VOSU9OX1ZBUklBTlQgPSA4MDc4MDA5O1xudmFyIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0VOVU1fVkFSSUFOVCA9IDgwNzgwMTA7XG52YXIgU09MQU5BX0VSUk9SX19DT0RFQ1NfX05VTUJFUl9PVVRfT0ZfUkFOR0UgPSA4MDc4MDExO1xudmFyIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX1NUUklOR19GT1JfQkFTRSA9IDgwNzgwMTI7XG52YXIgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX1BPU0lUSVZFX0JZVEVfTEVOR1RIID0gODA3ODAxMztcbnZhciBTT0xBTkFfRVJST1JfX0NPREVDU19fT0ZGU0VUX09VVF9PRl9SQU5HRSA9IDgwNzgwMTQ7XG52YXIgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfTElURVJBTF9VTklPTl9WQVJJQU5UID0gODA3ODAxNTtcbnZhciBTT0xBTkFfRVJST1JfX0NPREVDU19fTElURVJBTF9VTklPTl9ESVNDUklNSU5BVE9SX09VVF9PRl9SQU5HRSA9IDgwNzgwMTY7XG52YXIgU09MQU5BX0VSUk9SX19DT0RFQ1NfX1VOSU9OX1ZBUklBTlRfT1VUX09GX1JBTkdFID0gODA3ODAxNztcbnZhciBTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9DT05TVEFOVCA9IDgwNzgwMTg7XG52YXIgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX1pFUk9fVkFMVUVfVE9fTUFUQ0hfSVRFTV9GSVhFRF9TSVpFID0gODA3ODAxOTtcbnZhciBTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFRF9CWVRFU19NVVNUX05PVF9JTkNMVURFX1NFTlRJTkVMID0gODA3ODAyMDtcbnZhciBTT0xBTkFfRVJST1JfX0NPREVDU19fU0VOVElORUxfTUlTU0lOR19JTl9ERUNPREVEX0JZVEVTID0gODA3ODAyMTtcbnZhciBTT0xBTkFfRVJST1JfX0NPREVDU19fQ0FOTk9UX1VTRV9MRVhJQ0FMX1ZBTFVFU19BU19FTlVNX0RJU0NSSU1JTkFUT1JTID0gODA3ODAyMjtcbnZhciBTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfREVDT0RFUl9UT19DT05TVU1FX0VOVElSRV9CWVRFX0FSUkFZID0gODA3ODAyMztcbnZhciBTT0xBTkFfRVJST1JfX1JQQ19fSU5URUdFUl9PVkVSRkxPVyA9IDgxZTU7XG52YXIgU09MQU5BX0VSUk9SX19SUENfX1RSQU5TUE9SVF9IVFRQX0hFQURFUl9GT1JCSURERU4gPSA4MTAwMDAxO1xudmFyIFNPTEFOQV9FUlJPUl9fUlBDX19UUkFOU1BPUlRfSFRUUF9FUlJPUiA9IDgxMDAwMDI7XG52YXIgU09MQU5BX0VSUk9SX19SUENfX0FQSV9QTEFOX01JU1NJTkdfRk9SX1JQQ19NRVRIT0QgPSA4MTAwMDAzO1xudmFyIFNPTEFOQV9FUlJPUl9fUlBDX1NVQlNDUklQVElPTlNfX0NBTk5PVF9DUkVBVEVfU1VCU0NSSVBUSU9OX1BMQU4gPSA4MTllNDtcbnZhciBTT0xBTkFfRVJST1JfX1JQQ19TVUJTQ1JJUFRJT05TX19FWFBFQ1RFRF9TRVJWRVJfU1VCU0NSSVBUSU9OX0lEID0gODE5MDAwMTtcbnZhciBTT0xBTkFfRVJST1JfX1JQQ19TVUJTQ1JJUFRJT05TX19DSEFOTkVMX0NMT1NFRF9CRUZPUkVfTUVTU0FHRV9CVUZGRVJFRCA9IDgxOTAwMDI7XG52YXIgU09MQU5BX0VSUk9SX19SUENfU1VCU0NSSVBUSU9OU19fQ0hBTk5FTF9DT05ORUNUSU9OX0NMT1NFRCA9IDgxOTAwMDM7XG52YXIgU09MQU5BX0VSUk9SX19SUENfU1VCU0NSSVBUSU9OU19fQ0hBTk5FTF9GQUlMRURfVE9fQ09OTkVDVCA9IDgxOTAwMDQ7XG52YXIgU09MQU5BX0VSUk9SX19JTlZBUklBTlRfVklPTEFUSU9OX19TVUJTQ1JJUFRJT05fSVRFUkFUT1JfU1RBVEVfTUlTU0lORyA9IDk5ZTU7XG52YXIgU09MQU5BX0VSUk9SX19JTlZBUklBTlRfVklPTEFUSU9OX19TVUJTQ1JJUFRJT05fSVRFUkFUT1JfTVVTVF9OT1RfUE9MTF9CRUZPUkVfUkVTT0xWSU5HX0VYSVNUSU5HX01FU1NBR0VfUFJPTUlTRSA9IDk5MDAwMDE7XG52YXIgU09MQU5BX0VSUk9SX19JTlZBUklBTlRfVklPTEFUSU9OX19DQUNIRURfQUJPUlRBQkxFX0lURVJBQkxFX0NBQ0hFX0VOVFJZX01JU1NJTkcgPSA5OTAwMDAyO1xudmFyIFNPTEFOQV9FUlJPUl9fSU5WQVJJQU5UX1ZJT0xBVElPTl9fU1dJVENIX01VU1RfQkVfRVhIQVVTVElWRSA9IDk5MDAwMDM7XG52YXIgU09MQU5BX0VSUk9SX19JTlZBUklBTlRfVklPTEFUSU9OX19EQVRBX1BVQkxJU0hFUl9DSEFOTkVMX1VOSU1QTEVNRU5URUQgPSA5OTAwMDA0O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5WQVJJQU5UX1ZJT0xBVElPTl9fSU5WQUxJRF9JTlNUUlVDVElPTl9QTEFOX0tJTkQgPSA5OTAwMDA1O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5WQVJJQU5UX1ZJT0xBVElPTl9fSU5WQUxJRF9UUkFOU0FDVElPTl9QTEFOX0tJTkQgPSA5OTAwMDA2O1xuXG4vLyBzcmMvY29udGV4dC50c1xuZnVuY3Rpb24gZW5jb2RlVmFsdWUodmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgY29uc3QgY29tbWFTZXBhcmF0ZWRWYWx1ZXMgPSB2YWx1ZS5tYXAoZW5jb2RlVmFsdWUpLmpvaW4oXG4gICAgICBcIiUyQyUyMFwiXG4gICAgICAvKiBcIiwgXCIgKi9cbiAgICApO1xuICAgIHJldHVybiBcIiU1QlwiICsgY29tbWFTZXBhcmF0ZWRWYWx1ZXMgKyAvKiBcIl1cIiAqL1xuICAgIFwiJTVEXCI7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiKSB7XG4gICAgcmV0dXJuIGAke3ZhbHVlfW5gO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoXG4gICAgICBTdHJpbmcoXG4gICAgICAgIHZhbHVlICE9IG51bGwgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSA9PT0gbnVsbCA/IChcbiAgICAgICAgICAvLyBQbGFpbiBvYmplY3RzIHdpdGggbm8gcHJvdG90eXBlIGRvbid0IGhhdmUgYSBgdG9TdHJpbmdgIG1ldGhvZC5cbiAgICAgICAgICAvLyBDb252ZXJ0IHRoZW0gYmVmb3JlIHN0cmluZ2lmeWluZyB0aGVtLlxuICAgICAgICAgIHsgLi4udmFsdWUgfVxuICAgICAgICApIDogdmFsdWVcbiAgICAgIClcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiBlbmNvZGVPYmplY3RDb250ZXh0RW50cnkoW2tleSwgdmFsdWVdKSB7XG4gIHJldHVybiBgJHtrZXl9PSR7ZW5jb2RlVmFsdWUodmFsdWUpfWA7XG59XG5mdW5jdGlvbiBlbmNvZGVDb250ZXh0T2JqZWN0KGNvbnRleHQpIHtcbiAgY29uc3Qgc2VhcmNoUGFyYW1zU3RyaW5nID0gT2JqZWN0LmVudHJpZXMoY29udGV4dCkubWFwKGVuY29kZU9iamVjdENvbnRleHRFbnRyeSkuam9pbihcIiZcIik7XG4gIHJldHVybiBCdWZmZXIuZnJvbShzZWFyY2hQYXJhbXNTdHJpbmcsIFwidXRmOFwiKS50b1N0cmluZyhcImJhc2U2NFwiKSA7XG59XG5cbi8vIHNyYy9tZXNzYWdlcy50c1xudmFyIFNvbGFuYUVycm9yTWVzc2FnZXMgPSB7XG4gIFtTT0xBTkFfRVJST1JfX0FDQ09VTlRTX19BQ0NPVU5UX05PVF9GT1VORF06IFwiQWNjb3VudCBub3QgZm91bmQgYXQgYWRkcmVzczogJGFkZHJlc3NcIixcbiAgW1NPTEFOQV9FUlJPUl9fQUNDT1VOVFNfX0VYUEVDVEVEX0FMTF9BQ0NPVU5UU19UT19CRV9ERUNPREVEXTogXCJOb3QgYWxsIGFjY291bnRzIHdlcmUgZGVjb2RlZC4gRW5jb2RlZCBhY2NvdW50cyBmb3VuZCBhdCBhZGRyZXNzZXM6ICRhZGRyZXNzZXMuXCIsXG4gIFtTT0xBTkFfRVJST1JfX0FDQ09VTlRTX19FWFBFQ1RFRF9ERUNPREVEX0FDQ09VTlRdOiBcIkV4cGVjdGVkIGRlY29kZWQgYWNjb3VudCBhdCBhZGRyZXNzOiAkYWRkcmVzc1wiLFxuICBbU09MQU5BX0VSUk9SX19BQ0NPVU5UU19fRkFJTEVEX1RPX0RFQ09ERV9BQ0NPVU5UXTogXCJGYWlsZWQgdG8gZGVjb2RlIGFjY291bnQgZGF0YSBhdCBhZGRyZXNzOiAkYWRkcmVzc1wiLFxuICBbU09MQU5BX0VSUk9SX19BQ0NPVU5UU19fT05FX09SX01PUkVfQUNDT1VOVFNfTk9UX0ZPVU5EXTogXCJBY2NvdW50cyBub3QgZm91bmQgYXQgYWRkcmVzc2VzOiAkYWRkcmVzc2VzXCIsXG4gIFtTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fRkFJTEVEX1RPX0ZJTkRfVklBQkxFX1BEQV9CVU1QX1NFRURdOiBcIlVuYWJsZSB0byBmaW5kIGEgdmlhYmxlIHByb2dyYW0gYWRkcmVzcyBidW1wIHNlZWQuXCIsXG4gIFtTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fSU5WQUxJRF9CQVNFNThfRU5DT0RFRF9BRERSRVNTXTogXCIkcHV0YXRpdmVBZGRyZXNzIGlzIG5vdCBhIGJhc2U1OC1lbmNvZGVkIGFkZHJlc3MuXCIsXG4gIFtTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fSU5WQUxJRF9CWVRFX0xFTkdUSF06IFwiRXhwZWN0ZWQgYmFzZTU4IGVuY29kZWQgYWRkcmVzcyB0byBkZWNvZGUgdG8gYSBieXRlIGFycmF5IG9mIGxlbmd0aCAzMi4gQWN0dWFsIGxlbmd0aDogJGFjdHVhbExlbmd0aC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19JTlZBTElEX0VEMjU1MTlfUFVCTElDX0tFWV06IFwiVGhlIGBDcnlwdG9LZXlgIG11c3QgYmUgYW4gYEVkMjU1MTlgIHB1YmxpYyBrZXkuXCIsXG4gIFtTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fSU5WQUxJRF9PRkZfQ1VSVkVfQUREUkVTU106IFwiJHB1dGF0aXZlT2ZmQ3VydmVBZGRyZXNzIGlzIG5vdCBhIGJhc2U1OC1lbmNvZGVkIG9mZi1jdXJ2ZSBhZGRyZXNzLlwiLFxuICBbU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX0lOVkFMSURfU0VFRFNfUE9JTlRfT05fQ1VSVkVdOiBcIkludmFsaWQgc2VlZHM7IHBvaW50IG11c3QgZmFsbCBvZmYgdGhlIEVkMjU1MTkgY3VydmUuXCIsXG4gIFtTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fTUFMRk9STUVEX1BEQV06IFwiRXhwZWN0ZWQgZ2l2ZW4gcHJvZ3JhbSBkZXJpdmVkIGFkZHJlc3MgdG8gaGF2ZSB0aGUgZm9sbG93aW5nIGZvcm1hdDogW0FkZHJlc3MsIFByb2dyYW1EZXJpdmVkQWRkcmVzc0J1bXBdLlwiLFxuICBbU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX01BWF9OVU1CRVJfT0ZfUERBX1NFRURTX0VYQ0VFREVEXTogXCJBIG1heGltdW0gb2YgJG1heFNlZWRzIHNlZWRzLCBpbmNsdWRpbmcgdGhlIGJ1bXAgc2VlZCwgbWF5IGJlIHN1cHBsaWVkIHdoZW4gY3JlYXRpbmcgYW4gYWRkcmVzcy4gUmVjZWl2ZWQ6ICRhY3R1YWwuXCIsXG4gIFtTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fTUFYX1BEQV9TRUVEX0xFTkdUSF9FWENFRURFRF06IFwiVGhlIHNlZWQgYXQgaW5kZXggJGluZGV4IHdpdGggbGVuZ3RoICRhY3R1YWwgZXhjZWVkcyB0aGUgbWF4aW11bSBsZW5ndGggb2YgJG1heFNlZWRMZW5ndGggYnl0ZXMuXCIsXG4gIFtTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fUERBX0JVTVBfU0VFRF9PVVRfT0ZfUkFOR0VdOiBcIkV4cGVjdGVkIHByb2dyYW0gZGVyaXZlZCBhZGRyZXNzIGJ1bXAgdG8gYmUgaW4gdGhlIHJhbmdlIFswLCAyNTVdLCBnb3Q6ICRidW1wLlwiLFxuICBbU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX1BEQV9FTkRTX1dJVEhfUERBX01BUktFUl06IFwiUHJvZ3JhbSBhZGRyZXNzIGNhbm5vdCBlbmQgd2l0aCBQREEgbWFya2VyLlwiLFxuICBbU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX1NUUklOR19MRU5HVEhfT1VUX09GX1JBTkdFXTogXCJFeHBlY3RlZCBiYXNlNTgtZW5jb2RlZCBhZGRyZXNzIHN0cmluZyBvZiBsZW5ndGggaW4gdGhlIHJhbmdlIFszMiwgNDRdLiBBY3R1YWwgbGVuZ3RoOiAkYWN0dWFsTGVuZ3RoLlwiLFxuICBbU09MQU5BX0VSUk9SX19CTE9DS0hBU0hfU1RSSU5HX0xFTkdUSF9PVVRfT0ZfUkFOR0VdOiBcIkV4cGVjdGVkIGJhc2U1OC1lbmNvZGVkIGJsb2NrYXNoIHN0cmluZyBvZiBsZW5ndGggaW4gdGhlIHJhbmdlIFszMiwgNDRdLiBBY3R1YWwgbGVuZ3RoOiAkYWN0dWFsTGVuZ3RoLlwiLFxuICBbU09MQU5BX0VSUk9SX19CTE9DS19IRUlHSFRfRVhDRUVERURdOiBcIlRoZSBuZXR3b3JrIGhhcyBwcm9ncmVzc2VkIHBhc3QgdGhlIGxhc3QgYmxvY2sgZm9yIHdoaWNoIHRoaXMgdHJhbnNhY3Rpb24gY291bGQgaGF2ZSBiZWVuIGNvbW1pdHRlZC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQ09ERUNTX19DQU5OT1RfREVDT0RFX0VNUFRZX0JZVEVfQVJSQVldOiBcIkNvZGVjIFskY29kZWNEZXNjcmlwdGlvbl0gY2Fubm90IGRlY29kZSBlbXB0eSBieXRlIGFycmF5cy5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQ09ERUNTX19DQU5OT1RfVVNFX0xFWElDQUxfVkFMVUVTX0FTX0VOVU1fRElTQ1JJTUlOQVRPUlNdOiBcIkVudW0gY29kZWMgY2Fubm90IHVzZSBsZXhpY2FsIHZhbHVlcyBbJHN0cmluZ1ZhbHVlc10gYXMgZGlzY3JpbWluYXRvcnMuIEVpdGhlciByZW1vdmUgYWxsIGxleGljYWwgdmFsdWVzIG9yIHNldCBgdXNlVmFsdWVzQXNEaXNjcmltaW5hdG9yc2AgdG8gYGZhbHNlYC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVEX0JZVEVTX01VU1RfTk9UX0lOQ0xVREVfU0VOVElORUxdOiBcIlNlbnRpbmVsIFskaGV4U2VudGluZWxdIG11c3Qgbm90IGJlIHByZXNlbnQgaW4gZW5jb2RlZCBieXRlcyBbJGhleEVuY29kZWRCeXRlc10uXCIsXG4gIFtTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFUl9ERUNPREVSX0ZJWEVEX1NJWkVfTUlTTUFUQ0hdOiBcIkVuY29kZXIgYW5kIGRlY29kZXIgbXVzdCBoYXZlIHRoZSBzYW1lIGZpeGVkIHNpemUsIGdvdCBbJGVuY29kZXJGaXhlZFNpemVdIGFuZCBbJGRlY29kZXJGaXhlZFNpemVdLlwiLFxuICBbU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9NQVhfU0laRV9NSVNNQVRDSF06IFwiRW5jb2RlciBhbmQgZGVjb2RlciBtdXN0IGhhdmUgdGhlIHNhbWUgbWF4IHNpemUsIGdvdCBbJGVuY29kZXJNYXhTaXplXSBhbmQgWyRkZWNvZGVyTWF4U2l6ZV0uXCIsXG4gIFtTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFUl9ERUNPREVSX1NJWkVfQ09NUEFUSUJJTElUWV9NSVNNQVRDSF06IFwiRW5jb2RlciBhbmQgZGVjb2RlciBtdXN0IGVpdGhlciBib3RoIGJlIGZpeGVkLXNpemUgb3IgdmFyaWFibGUtc2l6ZS5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQ09ERUNTX19FTlVNX0RJU0NSSU1JTkFUT1JfT1VUX09GX1JBTkdFXTogXCJFbnVtIGRpc2NyaW1pbmF0b3Igb3V0IG9mIHJhbmdlLiBFeHBlY3RlZCBhIG51bWJlciBpbiBbJGZvcm1hdHRlZFZhbGlkRGlzY3JpbWluYXRvcnNdLCBnb3QgJGRpc2NyaW1pbmF0b3IuXCIsXG4gIFtTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfRklYRURfTEVOR1RIXTogXCJFeHBlY3RlZCBhIGZpeGVkLXNpemUgY29kZWMsIGdvdCBhIHZhcmlhYmxlLXNpemUgb25lLlwiLFxuICBbU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX1BPU0lUSVZFX0JZVEVfTEVOR1RIXTogXCJDb2RlYyBbJGNvZGVjRGVzY3JpcHRpb25dIGV4cGVjdGVkIGEgcG9zaXRpdmUgYnl0ZSBsZW5ndGgsIGdvdCAkYnl0ZXNMZW5ndGguXCIsXG4gIFtTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfVkFSSUFCTEVfTEVOR1RIXTogXCJFeHBlY3RlZCBhIHZhcmlhYmxlLXNpemUgY29kZWMsIGdvdCBhIGZpeGVkLXNpemUgb25lLlwiLFxuICBbU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX1pFUk9fVkFMVUVfVE9fTUFUQ0hfSVRFTV9GSVhFRF9TSVpFXTogXCJDb2RlYyBbJGNvZGVjRGVzY3JpcHRpb25dIGV4cGVjdGVkIHplcm8tdmFsdWUgWyRoZXhaZXJvVmFsdWVdIHRvIGhhdmUgdGhlIHNhbWUgc2l6ZSBhcyB0aGUgcHJvdmlkZWQgZml4ZWQtc2l6ZSBpdGVtIFskZXhwZWN0ZWRTaXplIGJ5dGVzXS5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0JZVEVfTEVOR1RIXTogXCJDb2RlYyBbJGNvZGVjRGVzY3JpcHRpb25dIGV4cGVjdGVkICRleHBlY3RlZCBieXRlcywgZ290ICRieXRlc0xlbmd0aC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0NPTlNUQU5UXTogXCJFeHBlY3RlZCBieXRlIGFycmF5IGNvbnN0YW50IFskaGV4Q29uc3RhbnRdIHRvIGJlIHByZXNlbnQgaW4gZGF0YSBbJGhleERhdGFdIGF0IG9mZnNldCBbJG9mZnNldF0uXCIsXG4gIFtTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9ESVNDUklNSU5BVEVEX1VOSU9OX1ZBUklBTlRdOiBcIkludmFsaWQgZGlzY3JpbWluYXRlZCB1bmlvbiB2YXJpYW50LiBFeHBlY3RlZCBvbmUgb2YgWyR2YXJpYW50c10sIGdvdCAkdmFsdWUuXCIsXG4gIFtTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9FTlVNX1ZBUklBTlRdOiBcIkludmFsaWQgZW51bSB2YXJpYW50LiBFeHBlY3RlZCBvbmUgb2YgWyRzdHJpbmdWYWx1ZXNdIG9yIGEgbnVtYmVyIGluIFskZm9ybWF0dGVkTnVtZXJpY2FsVmFsdWVzXSwgZ290ICR2YXJpYW50LlwiLFxuICBbU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfTElURVJBTF9VTklPTl9WQVJJQU5UXTogXCJJbnZhbGlkIGxpdGVyYWwgdW5pb24gdmFyaWFudC4gRXhwZWN0ZWQgb25lIG9mIFskdmFyaWFudHNdLCBnb3QgJHZhbHVlLlwiLFxuICBbU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfTlVNQkVSX09GX0lURU1TXTogXCJFeHBlY3RlZCBbJGNvZGVjRGVzY3JpcHRpb25dIHRvIGhhdmUgJGV4cGVjdGVkIGl0ZW1zLCBnb3QgJGFjdHVhbC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX1NUUklOR19GT1JfQkFTRV06IFwiSW52YWxpZCB2YWx1ZSAkdmFsdWUgZm9yIGJhc2UgJGJhc2Ugd2l0aCBhbHBoYWJldCAkYWxwaGFiZXQuXCIsXG4gIFtTT0xBTkFfRVJST1JfX0NPREVDU19fTElURVJBTF9VTklPTl9ESVNDUklNSU5BVE9SX09VVF9PRl9SQU5HRV06IFwiTGl0ZXJhbCB1bmlvbiBkaXNjcmltaW5hdG9yIG91dCBvZiByYW5nZS4gRXhwZWN0ZWQgYSBudW1iZXIgYmV0d2VlbiAkbWluUmFuZ2UgYW5kICRtYXhSYW5nZSwgZ290ICRkaXNjcmltaW5hdG9yLlwiLFxuICBbU09MQU5BX0VSUk9SX19DT0RFQ1NfX05VTUJFUl9PVVRfT0ZfUkFOR0VdOiBcIkNvZGVjIFskY29kZWNEZXNjcmlwdGlvbl0gZXhwZWN0ZWQgbnVtYmVyIHRvIGJlIGluIHRoZSByYW5nZSBbJG1pbiwgJG1heF0sIGdvdCAkdmFsdWUuXCIsXG4gIFtTT0xBTkFfRVJST1JfX0NPREVDU19fT0ZGU0VUX09VVF9PRl9SQU5HRV06IFwiQ29kZWMgWyRjb2RlY0Rlc2NyaXB0aW9uXSBleHBlY3RlZCBvZmZzZXQgdG8gYmUgaW4gdGhlIHJhbmdlIFswLCAkYnl0ZXNMZW5ndGhdLCBnb3QgJG9mZnNldC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQ09ERUNTX19TRU5USU5FTF9NSVNTSU5HX0lOX0RFQ09ERURfQllURVNdOiBcIkV4cGVjdGVkIHNlbnRpbmVsIFskaGV4U2VudGluZWxdIHRvIGJlIHByZXNlbnQgaW4gZGVjb2RlZCBieXRlcyBbJGhleERlY29kZWRCeXRlc10uXCIsXG4gIFtTT0xBTkFfRVJST1JfX0NPREVDU19fVU5JT05fVkFSSUFOVF9PVVRfT0ZfUkFOR0VdOiBcIlVuaW9uIHZhcmlhbnQgb3V0IG9mIHJhbmdlLiBFeHBlY3RlZCBhbiBpbmRleCBiZXR3ZWVuICRtaW5SYW5nZSBhbmQgJG1heFJhbmdlLCBnb3QgJHZhcmlhbnQuXCIsXG4gIFtTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfREVDT0RFUl9UT19DT05TVU1FX0VOVElSRV9CWVRFX0FSUkFZXTogXCJUaGlzIGRlY29kZXIgZXhwZWN0ZWQgYSBieXRlIGFycmF5IG9mIGV4YWN0bHkgJGV4cGVjdGVkTGVuZ3RoIGJ5dGVzLCBidXQgJG51bUV4Y2Vzc0J5dGVzIHVuZXhwZWN0ZWQgZXhjZXNzIGJ5dGVzIHJlbWFpbmVkIGFmdGVyIGRlY29kaW5nLiBBcmUgeW91IHN1cmUgdGhhdCB5b3UgaGF2ZSBjaG9zZW4gdGhlIGNvcnJlY3QgZGVjb2RlciBmb3IgdGhpcyBkYXRhP1wiLFxuICBbU09MQU5BX0VSUk9SX19DUllQVE9fX1JBTkRPTV9WQUxVRVNfRlVOQ1RJT05fVU5JTVBMRU1FTlRFRF06IFwiTm8gcmFuZG9tIHZhbHVlcyBpbXBsZW1lbnRhdGlvbiBjb3VsZCBiZSBmb3VuZC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfQUxSRUFEWV9JTklUSUFMSVpFRF06IFwiaW5zdHJ1Y3Rpb24gcmVxdWlyZXMgYW4gdW5pbml0aWFsaXplZCBhY2NvdW50XCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BQ0NPVU5UX0JPUlJPV19GQUlMRURdOiBcImluc3RydWN0aW9uIHRyaWVzIHRvIGJvcnJvdyByZWZlcmVuY2UgZm9yIGFuIGFjY291bnQgd2hpY2ggaXMgYWxyZWFkeSBib3Jyb3dlZFwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9CT1JST1dfT1VUU1RBTkRJTkddOiBcImluc3RydWN0aW9uIGxlZnQgYWNjb3VudCB3aXRoIGFuIG91dHN0YW5kaW5nIGJvcnJvd2VkIHJlZmVyZW5jZVwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9EQVRBX1NJWkVfQ0hBTkdFRF06IFwicHJvZ3JhbSBvdGhlciB0aGFuIHRoZSBhY2NvdW50J3Mgb3duZXIgY2hhbmdlZCB0aGUgc2l6ZSBvZiB0aGUgYWNjb3VudCBkYXRhXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BQ0NPVU5UX0RBVEFfVE9PX1NNQUxMXTogXCJhY2NvdW50IGRhdGEgdG9vIHNtYWxsIGZvciBpbnN0cnVjdGlvblwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9OT1RfRVhFQ1VUQUJMRV06IFwiaW5zdHJ1Y3Rpb24gZXhwZWN0ZWQgYW4gZXhlY3V0YWJsZSBhY2NvdW50XCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BQ0NPVU5UX05PVF9SRU5UX0VYRU1QVF06IFwiQW4gYWNjb3VudCBkb2VzIG5vdCBoYXZlIGVub3VnaCBsYW1wb3J0cyB0byBiZSByZW50LWV4ZW1wdFwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQVJJVEhNRVRJQ19PVkVSRkxPV106IFwiUHJvZ3JhbSBhcml0aG1ldGljIG92ZXJmbG93ZWRcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0JPUlNIX0lPX0VSUk9SXTogXCJGYWlsZWQgdG8gc2VyaWFsaXplIG9yIGRlc2VyaWFsaXplIGFjY291bnQgZGF0YTogJGVuY29kZWREYXRhXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19CVUlMVElOX1BST0dSQU1TX01VU1RfQ09OU1VNRV9DT01QVVRFX1VOSVRTXTogXCJCdWlsdGluIHByb2dyYW1zIG11c3QgY29uc3VtZSBjb21wdXRlIHVuaXRzXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19DQUxMX0RFUFRIXTogXCJDcm9zcy1wcm9ncmFtIGludm9jYXRpb24gY2FsbCBkZXB0aCB0b28gZGVlcFwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQ09NUFVUQVRJT05BTF9CVURHRVRfRVhDRUVERURdOiBcIkNvbXB1dGF0aW9uYWwgYnVkZ2V0IGV4Y2VlZGVkXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19DVVNUT01dOiBcImN1c3RvbSBwcm9ncmFtIGVycm9yOiAjJGNvZGVcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0RVUExJQ0FURV9BQ0NPVU5UX0lOREVYXTogXCJpbnN0cnVjdGlvbiBjb250YWlucyBkdXBsaWNhdGUgYWNjb3VudHNcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0RVUExJQ0FURV9BQ0NPVU5UX09VVF9PRl9TWU5DXTogXCJpbnN0cnVjdGlvbiBtb2RpZmljYXRpb25zIG9mIG11bHRpcGx5LXBhc3NlZCBhY2NvdW50IGRpZmZlclwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRVhFQ1VUQUJMRV9BQ0NPVU5UX05PVF9SRU5UX0VYRU1QVF06IFwiZXhlY3V0YWJsZSBhY2NvdW50cyBtdXN0IGJlIHJlbnQgZXhlbXB0XCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19FWEVDVVRBQkxFX0RBVEFfTU9ESUZJRURdOiBcImluc3RydWN0aW9uIGNoYW5nZWQgZXhlY3V0YWJsZSBhY2NvdW50cyBkYXRhXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19FWEVDVVRBQkxFX0xBTVBPUlRfQ0hBTkdFXTogXCJpbnN0cnVjdGlvbiBjaGFuZ2VkIHRoZSBiYWxhbmNlIG9mIGFuIGV4ZWN1dGFibGUgYWNjb3VudFwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRVhFQ1VUQUJMRV9NT0RJRklFRF06IFwiaW5zdHJ1Y3Rpb24gY2hhbmdlZCBleGVjdXRhYmxlIGJpdCBvZiBhbiBhY2NvdW50XCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19FWFRFUk5BTF9BQ0NPVU5UX0RBVEFfTU9ESUZJRURdOiBcImluc3RydWN0aW9uIG1vZGlmaWVkIGRhdGEgb2YgYW4gYWNjb3VudCBpdCBkb2VzIG5vdCBvd25cIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0VYVEVSTkFMX0FDQ09VTlRfTEFNUE9SVF9TUEVORF06IFwiaW5zdHJ1Y3Rpb24gc3BlbnQgZnJvbSB0aGUgYmFsYW5jZSBvZiBhbiBhY2NvdW50IGl0IGRvZXMgbm90IG93blwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fR0VORVJJQ19FUlJPUl06IFwiZ2VuZXJpYyBpbnN0cnVjdGlvbiBlcnJvclwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSUxMRUdBTF9PV05FUl06IFwiUHJvdmlkZWQgb3duZXIgaXMgbm90IGFsbG93ZWRcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lNTVVUQUJMRV06IFwiQWNjb3VudCBpcyBpbW11dGFibGVcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOQ09SUkVDVF9BVVRIT1JJVFldOiBcIkluY29ycmVjdCBhdXRob3JpdHkgcHJvdmlkZWRcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOQ09SUkVDVF9QUk9HUkFNX0lEXTogXCJpbmNvcnJlY3QgcHJvZ3JhbSBpZCBmb3IgaW5zdHJ1Y3Rpb25cIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOU1VGRklDSUVOVF9GVU5EU106IFwiaW5zdWZmaWNpZW50IGZ1bmRzIGZvciBpbnN0cnVjdGlvblwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9BQ0NPVU5UX0RBVEFdOiBcImludmFsaWQgYWNjb3VudCBkYXRhIGZvciBpbnN0cnVjdGlvblwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9BQ0NPVU5UX09XTkVSXTogXCJJbnZhbGlkIGFjY291bnQgb3duZXJcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfQVJHVU1FTlRdOiBcImludmFsaWQgcHJvZ3JhbSBhcmd1bWVudFwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9FUlJPUl06IFwicHJvZ3JhbSByZXR1cm5lZCBpbnZhbGlkIGVycm9yIGNvZGVcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfSU5TVFJVQ1RJT05fREFUQV06IFwiaW52YWxpZCBpbnN0cnVjdGlvbiBkYXRhXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX1JFQUxMT0NdOiBcIkZhaWxlZCB0byByZWFsbG9jYXRlIGFjY291bnQgZGF0YVwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9TRUVEU106IFwiUHJvdmlkZWQgc2VlZHMgZG8gbm90IHJlc3VsdCBpbiBhIHZhbGlkIGFkZHJlc3NcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01BWF9BQ0NPVU5UU19EQVRBX0FMTE9DQVRJT05TX0VYQ0VFREVEXTogXCJBY2NvdW50cyBkYXRhIGFsbG9jYXRpb25zIGV4Y2VlZGVkIHRoZSBtYXhpbXVtIGFsbG93ZWQgcGVyIHRyYW5zYWN0aW9uXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19NQVhfQUNDT1VOVFNfRVhDRUVERURdOiBcIk1heCBhY2NvdW50cyBleGNlZWRlZFwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTUFYX0lOU1RSVUNUSU9OX1RSQUNFX0xFTkdUSF9FWENFRURFRF06IFwiTWF4IGluc3RydWN0aW9uIHRyYWNlIGxlbmd0aCBleGNlZWRlZFwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTUFYX1NFRURfTEVOR1RIX0VYQ0VFREVEXTogXCJMZW5ndGggb2YgdGhlIHNlZWQgaXMgdG9vIGxvbmcgZm9yIGFkZHJlc3MgZ2VuZXJhdGlvblwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTUlTU0lOR19BQ0NPVU5UXTogXCJBbiBhY2NvdW50IHJlcXVpcmVkIGJ5IHRoZSBpbnN0cnVjdGlvbiBpcyBtaXNzaW5nXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19NSVNTSU5HX1JFUVVJUkVEX1NJR05BVFVSRV06IFwibWlzc2luZyByZXF1aXJlZCBzaWduYXR1cmUgZm9yIGluc3RydWN0aW9uXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19NT0RJRklFRF9QUk9HUkFNX0lEXTogXCJpbnN0cnVjdGlvbiBpbGxlZ2FsbHkgbW9kaWZpZWQgdGhlIHByb2dyYW0gaWQgb2YgYW4gYWNjb3VudFwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTk9UX0VOT1VHSF9BQ0NPVU5UX0tFWVNdOiBcImluc3VmZmljaWVudCBhY2NvdW50IGtleXMgZm9yIGluc3RydWN0aW9uXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19QUklWSUxFR0VfRVNDQUxBVElPTl06IFwiQ3Jvc3MtcHJvZ3JhbSBpbnZvY2F0aW9uIHdpdGggdW5hdXRob3JpemVkIHNpZ25lciBvciB3cml0YWJsZSBhY2NvdW50XCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19QUk9HUkFNX0VOVklST05NRU5UX1NFVFVQX0ZBSUxVUkVdOiBcIkZhaWxlZCB0byBjcmVhdGUgcHJvZ3JhbSBleGVjdXRpb24gZW52aXJvbm1lbnRcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1BST0dSQU1fRkFJTEVEX1RPX0NPTVBJTEVdOiBcIlByb2dyYW0gZmFpbGVkIHRvIGNvbXBpbGVcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1BST0dSQU1fRkFJTEVEX1RPX0NPTVBMRVRFXTogXCJQcm9ncmFtIGZhaWxlZCB0byBjb21wbGV0ZVwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUkVBRE9OTFlfREFUQV9NT0RJRklFRF06IFwiaW5zdHJ1Y3Rpb24gbW9kaWZpZWQgZGF0YSBvZiBhIHJlYWQtb25seSBhY2NvdW50XCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19SRUFET05MWV9MQU1QT1JUX0NIQU5HRV06IFwiaW5zdHJ1Y3Rpb24gY2hhbmdlZCB0aGUgYmFsYW5jZSBvZiBhIHJlYWQtb25seSBhY2NvdW50XCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19SRUVOVFJBTkNZX05PVF9BTExPV0VEXTogXCJDcm9zcy1wcm9ncmFtIGludm9jYXRpb24gcmVlbnRyYW5jeSBub3QgYWxsb3dlZCBmb3IgdGhpcyBpbnN0cnVjdGlvblwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUkVOVF9FUE9DSF9NT0RJRklFRF06IFwiaW5zdHJ1Y3Rpb24gbW9kaWZpZWQgcmVudCBlcG9jaCBvZiBhbiBhY2NvdW50XCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19VTkJBTEFOQ0VEX0lOU1RSVUNUSU9OXTogXCJzdW0gb2YgYWNjb3VudCBiYWxhbmNlcyBiZWZvcmUgYW5kIGFmdGVyIGluc3RydWN0aW9uIGRvIG5vdCBtYXRjaFwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fVU5JTklUSUFMSVpFRF9BQ0NPVU5UXTogXCJpbnN0cnVjdGlvbiByZXF1aXJlcyBhbiBpbml0aWFsaXplZCBhY2NvdW50XCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19VTktOT1dOXTogXCJcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1VOU1VQUE9SVEVEX1BST0dSQU1fSURdOiBcIlVuc3VwcG9ydGVkIHByb2dyYW0gaWRcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1VOU1VQUE9SVEVEX1NZU1ZBUl06IFwiVW5zdXBwb3J0ZWQgc3lzdmFyXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOVkFSSUFOVF9WSU9MQVRJT05fX0lOVkFMSURfSU5TVFJVQ1RJT05fUExBTl9LSU5EXTogXCJJbnZhbGlkIGluc3RydWN0aW9uIHBsYW4ga2luZDogJGtpbmQuXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX1BMQU5TX19FTVBUWV9JTlNUUlVDVElPTl9QTEFOXTogXCJUaGUgcHJvdmlkZWQgaW5zdHJ1Y3Rpb24gcGxhbiBpcyBlbXB0eS5cIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fUExBTlNfX0ZBSUxFRF9TSU5HTEVfVFJBTlNBQ1RJT05fUExBTl9SRVNVTFRfTk9UX0ZPVU5EXTogXCJObyBmYWlsZWQgdHJhbnNhY3Rpb24gcGxhbiByZXN1bHQgd2FzIGZvdW5kIGluIHRoZSBwcm92aWRlZCB0cmFuc2FjdGlvbiBwbGFuIHJlc3VsdC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fUExBTlNfX05PTl9ESVZJU0lCTEVfVFJBTlNBQ1RJT05fUExBTlNfTk9UX1NVUFBPUlRFRF06IFwiVGhpcyB0cmFuc2FjdGlvbiBwbGFuIGV4ZWN1dG9yIGRvZXMgbm90IHN1cHBvcnQgbm9uLWRpdmlzaWJsZSBzZXF1ZW50aWFsIHBsYW5zLiBUbyBzdXBwb3J0IHRoZW0sIHlvdSBtYXkgY3JlYXRlIHlvdXIgb3duIGV4ZWN1dG9yIHN1Y2ggdGhhdCBtdWx0aS10cmFuc2FjdGlvbiBhdG9taWNpdHkgaXMgcHJlc2VydmVkIFxcdTIwMTQgZS5nLiBieSB0YXJnZXR0aW5nIFJQQ3MgdGhhdCBzdXBwb3J0IHRyYW5zYWN0aW9uIGJ1bmRsZXMuXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX1BMQU5TX19GQUlMRURfVE9fRVhFQ1VURV9UUkFOU0FDVElPTl9QTEFOXTogXCJUaGUgcHJvdmlkZWQgdHJhbnNhY3Rpb24gcGxhbiBmYWlsZWQgdG8gZXhlY3V0ZS4gU2VlIHRoZSBgdHJhbnNhY3Rpb25QbGFuUmVzdWx0YCBhdHRyaWJ1dGUgZm9yIG1vcmUgZGV0YWlscy4gTm90ZSB0aGF0IHRoZSBgY2F1c2VgIHByb3BlcnR5IGlzIGRlcHJlY2F0ZWQsIGFuZCBhIGZ1dHVyZSB2ZXJzaW9uIHdpbGwgbm90IHNldCBpdC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fUExBTlNfX01FU1NBR0VfQ0FOTk9UX0FDQ09NTU9EQVRFX1BMQU5dOiBcIlRoZSBwcm92aWRlZCBtZXNzYWdlIGhhcyBpbnN1ZmZpY2llbnQgY2FwYWNpdHkgdG8gYWNjb21tb2RhdGUgdGhlIG5leHQgaW5zdHJ1Y3Rpb24ocykgaW4gdGhpcyBwbGFuLiBFeHBlY3RlZCBhdCBsZWFzdCAkbnVtQnl0ZXNSZXF1aXJlZCBmcmVlIGJ5dGUocyksIGdvdCAkbnVtRnJlZUJ5dGVzIGJ5dGUocykuXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOVkFSSUFOVF9WSU9MQVRJT05fX0lOVkFMSURfVFJBTlNBQ1RJT05fUExBTl9LSU5EXTogXCJJbnZhbGlkIHRyYW5zYWN0aW9uIHBsYW4ga2luZDogJGtpbmQuXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX1BMQU5TX19NRVNTQUdFX1BBQ0tFUl9BTFJFQURZX0NPTVBMRVRFXTogXCJObyBtb3JlIGluc3RydWN0aW9ucyB0byBwYWNrOyB0aGUgbWVzc2FnZSBwYWNrZXIgaGFzIGNvbXBsZXRlZCB0aGUgaW5zdHJ1Y3Rpb24gcGxhbi5cIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fUExBTlNfX1VORVhQRUNURURfSU5TVFJVQ1RJT05fUExBTl06IFwiVW5leHBlY3RlZCBpbnN0cnVjdGlvbiBwbGFuLiBFeHBlY3RlZCAkZXhwZWN0ZWRLaW5kIHBsYW4sIGdvdCAkYWN0dWFsS2luZCBwbGFuLlwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9QTEFOU19fVU5FWFBFQ1RFRF9UUkFOU0FDVElPTl9QTEFOXTogXCJVbmV4cGVjdGVkIHRyYW5zYWN0aW9uIHBsYW4uIEV4cGVjdGVkICRleHBlY3RlZEtpbmQgcGxhbiwgZ290ICRhY3R1YWxLaW5kIHBsYW4uXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX1BMQU5TX19VTkVYUEVDVEVEX1RSQU5TQUNUSU9OX1BMQU5fUkVTVUxUXTogXCJVbmV4cGVjdGVkIHRyYW5zYWN0aW9uIHBsYW4gcmVzdWx0LiBFeHBlY3RlZCAkZXhwZWN0ZWRLaW5kIHBsYW4sIGdvdCAkYWN0dWFsS2luZCBwbGFuLlwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9QTEFOU19fRVhQRUNURURfU1VDQ0VTU0ZVTF9UUkFOU0FDVElPTl9QTEFOX1JFU1VMVF06IFwiRXhwZWN0ZWQgYSBzdWNjZXNzZnVsIHRyYW5zYWN0aW9uIHBsYW4gcmVzdWx0LiBJLmUuIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBmYWlsZWQgb3IgY2FuY2VsbGVkIHRyYW5zYWN0aW9uIGluIHRoZSBwbGFuLlwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9fRVhQRUNURURfVE9fSEFWRV9BQ0NPVU5UU106IFwiVGhlIGluc3RydWN0aW9uIGRvZXMgbm90IGhhdmUgYW55IGFjY291bnRzLlwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9fRVhQRUNURURfVE9fSEFWRV9EQVRBXTogXCJUaGUgaW5zdHJ1Y3Rpb24gZG9lcyBub3QgaGF2ZSBhbnkgZGF0YS5cIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fX1BST0dSQU1fSURfTUlTTUFUQ0hdOiBcIkV4cGVjdGVkIGluc3RydWN0aW9uIHRvIGhhdmUgcHJvZ3Jlc3MgYWRkcmVzcyAkZXhwZWN0ZWRQcm9ncmFtQWRkcmVzcywgZ290ICRhY3R1YWxQcm9ncmFtQWRkcmVzcy5cIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5WQUxJRF9CTE9DS0hBU0hfQllURV9MRU5HVEhdOiBcIkV4cGVjdGVkIGJhc2U1OCBlbmNvZGVkIGJsb2NraGFzaCB0byBkZWNvZGUgdG8gYSBieXRlIGFycmF5IG9mIGxlbmd0aCAzMi4gQWN0dWFsIGxlbmd0aDogJGFjdHVhbExlbmd0aC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5WQUxJRF9OT05DRV06IFwiVGhlIG5vbmNlIGAkZXhwZWN0ZWROb25jZVZhbHVlYCBpcyBubyBsb25nZXIgdmFsaWQuIEl0IGhhcyBhZHZhbmNlZCB0byBgJGFjdHVhbE5vbmNlVmFsdWVgXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOVkFSSUFOVF9WSU9MQVRJT05fX0NBQ0hFRF9BQk9SVEFCTEVfSVRFUkFCTEVfQ0FDSEVfRU5UUllfTUlTU0lOR106IFwiSW52YXJpYW50IHZpb2xhdGlvbjogRm91bmQgbm8gYWJvcnRhYmxlIGl0ZXJhYmxlIGNhY2hlIGVudHJ5IGZvciBrZXkgYCRjYWNoZUtleWAuIEl0IHNob3VsZCBiZSBpbXBvc3NpYmxlIHRvIGhpdCB0aGlzIGVycm9yOyBwbGVhc2UgZmlsZSBhbiBpc3N1ZSBhdCBodHRwczovL3NvbGEubmEvd2ViM2ludmFyaWFudFwiLFxuICBbU09MQU5BX0VSUk9SX19JTlZBUklBTlRfVklPTEFUSU9OX19EQVRBX1BVQkxJU0hFUl9DSEFOTkVMX1VOSU1QTEVNRU5URURdOiBcIkludmFyaWFudCB2aW9sYXRpb246IFRoaXMgZGF0YSBwdWJsaXNoZXIgZG9lcyBub3QgcHVibGlzaCB0byB0aGUgY2hhbm5lbCBuYW1lZCBgJGNoYW5uZWxOYW1lYC4gU3VwcG9ydGVkIGNoYW5uZWxzIGluY2x1ZGUgJHN1cHBvcnRlZENoYW5uZWxOYW1lcy5cIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5WQVJJQU5UX1ZJT0xBVElPTl9fU1VCU0NSSVBUSU9OX0lURVJBVE9SX01VU1RfTk9UX1BPTExfQkVGT1JFX1JFU09MVklOR19FWElTVElOR19NRVNTQUdFX1BST01JU0VdOiBcIkludmFyaWFudCB2aW9sYXRpb246IFdlYlNvY2tldCBtZXNzYWdlIGl0ZXJhdG9yIHN0YXRlIGlzIGNvcnJ1cHQ7IGl0ZXJhdGVkIHdpdGhvdXQgZmlyc3QgcmVzb2x2aW5nIGV4aXN0aW5nIG1lc3NhZ2UgcHJvbWlzZS4gSXQgc2hvdWxkIGJlIGltcG9zc2libGUgdG8gaGl0IHRoaXMgZXJyb3I7IHBsZWFzZSBmaWxlIGFuIGlzc3VlIGF0IGh0dHBzOi8vc29sYS5uYS93ZWIzaW52YXJpYW50XCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOVkFSSUFOVF9WSU9MQVRJT05fX1NVQlNDUklQVElPTl9JVEVSQVRPUl9TVEFURV9NSVNTSU5HXTogXCJJbnZhcmlhbnQgdmlvbGF0aW9uOiBXZWJTb2NrZXQgbWVzc2FnZSBpdGVyYXRvciBpcyBtaXNzaW5nIHN0YXRlIHN0b3JhZ2UuIEl0IHNob3VsZCBiZSBpbXBvc3NpYmxlIHRvIGhpdCB0aGlzIGVycm9yOyBwbGVhc2UgZmlsZSBhbiBpc3N1ZSBhdCBodHRwczovL3NvbGEubmEvd2ViM2ludmFyaWFudFwiLFxuICBbU09MQU5BX0VSUk9SX19JTlZBUklBTlRfVklPTEFUSU9OX19TV0lUQ0hfTVVTVF9CRV9FWEhBVVNUSVZFXTogXCJJbnZhcmlhbnQgdmlvbGF0aW9uOiBTd2l0Y2ggc3RhdGVtZW50IG5vbi1leGhhdXN0aXZlLiBSZWNlaXZlZCB1bmV4cGVjdGVkIHZhbHVlIGAkdW5leHBlY3RlZFZhbHVlYC4gSXQgc2hvdWxkIGJlIGltcG9zc2libGUgdG8gaGl0IHRoaXMgZXJyb3I7IHBsZWFzZSBmaWxlIGFuIGlzc3VlIGF0IGh0dHBzOi8vc29sYS5uYS93ZWIzaW52YXJpYW50XCIsXG4gIFtTT0xBTkFfRVJST1JfX0pTT05fUlBDX19JTlRFUk5BTF9FUlJPUl06IFwiSlNPTi1SUEMgZXJyb3I6IEludGVybmFsIEpTT04tUlBDIGVycm9yICgkX19zZXJ2ZXJNZXNzYWdlKVwiLFxuICBbU09MQU5BX0VSUk9SX19KU09OX1JQQ19fSU5WQUxJRF9QQVJBTVNdOiBcIkpTT04tUlBDIGVycm9yOiBJbnZhbGlkIG1ldGhvZCBwYXJhbWV0ZXIocykgKCRfX3NlcnZlck1lc3NhZ2UpXCIsXG4gIFtTT0xBTkFfRVJST1JfX0pTT05fUlBDX19JTlZBTElEX1JFUVVFU1RdOiBcIkpTT04tUlBDIGVycm9yOiBUaGUgSlNPTiBzZW50IGlzIG5vdCBhIHZhbGlkIGBSZXF1ZXN0YCBvYmplY3QgKCRfX3NlcnZlck1lc3NhZ2UpXCIsXG4gIFtTT0xBTkFfRVJST1JfX0pTT05fUlBDX19NRVRIT0RfTk9UX0ZPVU5EXTogXCJKU09OLVJQQyBlcnJvcjogVGhlIG1ldGhvZCBkb2VzIG5vdCBleGlzdCAvIGlzIG5vdCBhdmFpbGFibGUgKCRfX3NlcnZlck1lc3NhZ2UpXCIsXG4gIFtTT0xBTkFfRVJST1JfX0pTT05fUlBDX19QQVJTRV9FUlJPUl06IFwiSlNPTi1SUEMgZXJyb3I6IEFuIGVycm9yIG9jY3VycmVkIG9uIHRoZSBzZXJ2ZXIgd2hpbGUgcGFyc2luZyB0aGUgSlNPTiB0ZXh0ICgkX19zZXJ2ZXJNZXNzYWdlKVwiLFxuICBbU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0NBTl9FUlJPUl06IFwiJF9fc2VydmVyTWVzc2FnZVwiLFxuICBbU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0JMT0NLX0NMRUFORURfVVBdOiBcIiRfX3NlcnZlck1lc3NhZ2VcIixcbiAgW1NPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9CTE9DS19OT1RfQVZBSUxBQkxFXTogXCIkX19zZXJ2ZXJNZXNzYWdlXCIsXG4gIFtTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfQkxPQ0tfU1RBVFVTX05PVF9BVkFJTEFCTEVfWUVUXTogXCIkX19zZXJ2ZXJNZXNzYWdlXCIsXG4gIFtTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfRVBPQ0hfUkVXQVJEU19QRVJJT0RfQUNUSVZFXTogXCJFcG9jaCByZXdhcmRzIHBlcmlvZCBzdGlsbCBhY3RpdmUgYXQgc2xvdCAkc2xvdFwiLFxuICBbU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0tFWV9FWENMVURFRF9GUk9NX1NFQ09OREFSWV9JTkRFWF06IFwiJF9fc2VydmVyTWVzc2FnZVwiLFxuICBbU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0xPTkdfVEVSTV9TVE9SQUdFX1NMT1RfU0tJUFBFRF06IFwiJF9fc2VydmVyTWVzc2FnZVwiLFxuICBbU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0xPTkdfVEVSTV9TVE9SQUdFX1VOUkVBQ0hBQkxFXTogXCJGYWlsZWQgdG8gcXVlcnkgbG9uZy10ZXJtIHN0b3JhZ2U7IHBsZWFzZSB0cnkgYWdhaW5cIixcbiAgW1NPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9NSU5fQ09OVEVYVF9TTE9UX05PVF9SRUFDSEVEXTogXCJNaW5pbXVtIGNvbnRleHQgc2xvdCBoYXMgbm90IGJlZW4gcmVhY2hlZFwiLFxuICBbU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX05PREVfVU5IRUFMVEhZXTogXCJOb2RlIGlzIHVuaGVhbHRoeTsgYmVoaW5kIGJ5ICRudW1TbG90c0JlaGluZCBzbG90c1wiLFxuICBbU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX05PX1NOQVBTSE9UXTogXCJObyBzbmFwc2hvdFwiLFxuICBbU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1NFTkRfVFJBTlNBQ1RJT05fUFJFRkxJR0hUX0ZBSUxVUkVdOiBcIlRyYW5zYWN0aW9uIHNpbXVsYXRpb24gZmFpbGVkXCIsXG4gIFtTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfU0xPVF9OT1RfRVBPQ0hfQk9VTkRBUlldOiBcIlJld2FyZHMgY2Fubm90IGJlIGZvdW5kIGJlY2F1c2Ugc2xvdCAkc2xvdCBpcyBub3QgdGhlIGVwb2NoIGJvdW5kYXJ5LiBUaGlzIG1heSBiZSBkdWUgdG8gZ2FwIGluIHRoZSBxdWVyaWVkIG5vZGUncyBsb2NhbCBsZWRnZXIgb3IgbG9uZy10ZXJtIHN0b3JhZ2VcIixcbiAgW1NPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9TTE9UX1NLSVBQRURdOiBcIiRfX3NlcnZlck1lc3NhZ2VcIixcbiAgW1NPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9ISVNUT1JZX05PVF9BVkFJTEFCTEVdOiBcIlRyYW5zYWN0aW9uIGhpc3RvcnkgaXMgbm90IGF2YWlsYWJsZSBmcm9tIHRoaXMgbm9kZVwiLFxuICBbU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX1BSRUNPTVBJTEVfVkVSSUZJQ0FUSU9OX0ZBSUxVUkVdOiBcIiRfX3NlcnZlck1lc3NhZ2VcIixcbiAgW1NPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9TSUdOQVRVUkVfTEVOX01JU01BVENIXTogXCJUcmFuc2FjdGlvbiBzaWduYXR1cmUgbGVuZ3RoIG1pc21hdGNoXCIsXG4gIFtTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fU0lHTkFUVVJFX1ZFUklGSUNBVElPTl9GQUlMVVJFXTogXCJUcmFuc2FjdGlvbiBzaWduYXR1cmUgdmVyaWZpY2F0aW9uIGZhaWx1cmVcIixcbiAgW1NPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9VTlNVUFBPUlRFRF9UUkFOU0FDVElPTl9WRVJTSU9OXTogXCIkX19zZXJ2ZXJNZXNzYWdlXCIsXG4gIFtTT0xBTkFfRVJST1JfX0tFWVNfX0lOVkFMSURfS0VZX1BBSVJfQllURV9MRU5HVEhdOiBcIktleSBwYWlyIGJ5dGVzIG11c3QgYmUgb2YgbGVuZ3RoIDY0LCBnb3QgJGJ5dGVMZW5ndGguXCIsXG4gIFtTT0xBTkFfRVJST1JfX0tFWVNfX0lOVkFMSURfUFJJVkFURV9LRVlfQllURV9MRU5HVEhdOiBcIkV4cGVjdGVkIHByaXZhdGUga2V5IGJ5dGVzIHdpdGggbGVuZ3RoIDMyLiBBY3R1YWwgbGVuZ3RoOiAkYWN0dWFsTGVuZ3RoLlwiLFxuICBbU09MQU5BX0VSUk9SX19LRVlTX19JTlZBTElEX1NJR05BVFVSRV9CWVRFX0xFTkdUSF06IFwiRXhwZWN0ZWQgYmFzZTU4LWVuY29kZWQgc2lnbmF0dXJlIHRvIGRlY29kZSB0byBhIGJ5dGUgYXJyYXkgb2YgbGVuZ3RoIDY0LiBBY3R1YWwgbGVuZ3RoOiAkYWN0dWFsTGVuZ3RoLlwiLFxuICBbU09MQU5BX0VSUk9SX19LRVlTX19QVUJMSUNfS0VZX01VU1RfTUFUQ0hfUFJJVkFURV9LRVldOiBcIlRoZSBwcm92aWRlZCBwcml2YXRlIGtleSBkb2VzIG5vdCBtYXRjaCB0aGUgcHJvdmlkZWQgcHVibGljIGtleS5cIixcbiAgW1NPTEFOQV9FUlJPUl9fS0VZU19fU0lHTkFUVVJFX1NUUklOR19MRU5HVEhfT1VUX09GX1JBTkdFXTogXCJFeHBlY3RlZCBiYXNlNTgtZW5jb2RlZCBzaWduYXR1cmUgc3RyaW5nIG9mIGxlbmd0aCBpbiB0aGUgcmFuZ2UgWzY0LCA4OF0uIEFjdHVhbCBsZW5ndGg6ICRhY3R1YWxMZW5ndGguXCIsXG4gIFtTT0xBTkFfRVJST1JfX0xBTVBPUlRTX09VVF9PRl9SQU5HRV06IFwiTGFtcG9ydHMgdmFsdWUgbXVzdCBiZSBpbiB0aGUgcmFuZ2UgWzAsIDJlNjQtMV1cIixcbiAgW1NPTEFOQV9FUlJPUl9fTUFMRk9STUVEX0JJR0lOVF9TVFJJTkddOiBcImAkdmFsdWVgIGNhbm5vdCBiZSBwYXJzZWQgYXMgYSBgQmlnSW50YFwiLFxuICBbU09MQU5BX0VSUk9SX19NQUxGT1JNRURfSlNPTl9SUENfRVJST1JdOiBcIiRtZXNzYWdlXCIsXG4gIFtTT0xBTkFfRVJST1JfX01BTEZPUk1FRF9OVU1CRVJfU1RSSU5HXTogXCJgJHZhbHVlYCBjYW5ub3QgYmUgcGFyc2VkIGFzIGEgYE51bWJlcmBcIixcbiAgW1NPTEFOQV9FUlJPUl9fTk9OQ0VfQUNDT1VOVF9OT1RfRk9VTkRdOiBcIk5vIG5vbmNlIGFjY291bnQgY291bGQgYmUgZm91bmQgYXQgYWRkcmVzcyBgJG5vbmNlQWNjb3VudEFkZHJlc3NgXCIsXG4gIFtTT0xBTkFfRVJST1JfX09GRkNIQUlOX01FU1NBR0VfX0lOVkFMSURfQVBQTElDQVRJT05fRE9NQUlOX0JZVEVfTEVOR1RIXTogXCJFeHBlY3RlZCBiYXNlNTggZW5jb2RlZCBhcHBsaWNhdGlvbiBkb21haW4gdG8gZGVjb2RlIHRvIGEgYnl0ZSBhcnJheSBvZiBsZW5ndGggMzIuIEFjdHVhbCBsZW5ndGg6ICRhY3R1YWxMZW5ndGguXCIsXG4gIFtTT0xBTkFfRVJST1JfX09GRkNIQUlOX01FU1NBR0VfX0FERFJFU1NFU19DQU5OT1RfU0lHTl9PRkZDSEFJTl9NRVNTQUdFXTogXCJBdHRlbXB0ZWQgdG8gc2lnbiBhbiBvZmZjaGFpbiBtZXNzYWdlIHdpdGggYW4gYWRkcmVzcyB0aGF0IGlzIG5vdCBhIHNpZ25lciBmb3IgaXRcIixcbiAgW1NPTEFOQV9FUlJPUl9fT0ZGQ0hBSU5fTUVTU0FHRV9fQVBQTElDQVRJT05fRE9NQUlOX1NUUklOR19MRU5HVEhfT1VUX09GX1JBTkdFXTogXCJFeHBlY3RlZCBiYXNlNTgtZW5jb2RlZCBhcHBsaWNhdGlvbiBkb21haW4gc3RyaW5nIG9mIGxlbmd0aCBpbiB0aGUgcmFuZ2UgWzMyLCA0NF0uIEFjdHVhbCBsZW5ndGg6ICRhY3R1YWxMZW5ndGguXCIsXG4gIFtTT0xBTkFfRVJST1JfX09GRkNIQUlOX01FU1NBR0VfX0VOVkVMT1BFX1NJR05FUlNfTUlTTUFUQ0hdOiBcIlRoZSBzaWduZXIgYWRkcmVzc2VzIGluIHRoaXMgb2ZmY2hhaW4gbWVzc2FnZSBlbnZlbG9wZSBkbyBub3QgbWF0Y2ggdGhlIGxpc3Qgb2YgcmVxdWlyZWQgc2lnbmVycyBpbiB0aGUgbWVzc2FnZSBwcmVhbWJsZS4gVGhlc2UgdW5leHBlY3RlZCBzaWduZXJzIHdlcmUgcHJlc2VudCBpbiB0aGUgZW52ZWxvcGU6IGBbJHVuZXhwZWN0ZWRTaWduZXJzXWAuIFRoZXNlIHJlcXVpcmVkIHNpZ25lcnMgd2VyZSBtaXNzaW5nIGZyb20gdGhlIGVudmVsb3BlIGBbJG1pc3NpbmdTaWduZXJzXWAuXCIsXG4gIFtTT0xBTkFfRVJST1JfX09GRkNIQUlOX01FU1NBR0VfX01BWElNVU1fTEVOR1RIX0VYQ0VFREVEXTogXCJUaGUgbWVzc2FnZSBib2R5IHByb3ZpZGVkIGhhcyBhIGJ5dGUtbGVuZ3RoIG9mICRhY3R1YWxCeXRlcy4gVGhlIG1heGltdW0gYWxsb3dhYmxlIGJ5dGUtbGVuZ3RoIGlzICRtYXhCeXRlc1wiLFxuICBbU09MQU5BX0VSUk9SX19PRkZDSEFJTl9NRVNTQUdFX19NRVNTQUdFX0ZPUk1BVF9NSVNNQVRDSF06IFwiRXhwZWN0ZWQgbWVzc2FnZSBmb3JtYXQgJGV4cGVjdGVkTWVzc2FnZUZvcm1hdCwgZ290ICRhY3R1YWxNZXNzYWdlRm9ybWF0XCIsXG4gIFtTT0xBTkFfRVJST1JfX09GRkNIQUlOX01FU1NBR0VfX01FU1NBR0VfTEVOR1RIX01JU01BVENIXTogXCJUaGUgbWVzc2FnZSBsZW5ndGggc3BlY2lmaWVkIGluIHRoZSBtZXNzYWdlIHByZWFtYmxlIGlzICRzcGVjaWZpZWRMZW5ndGggYnl0ZXMuIFRoZSBhY3R1YWwgbGVuZ3RoIG9mIHRoZSBtZXNzYWdlIGlzICRhY3R1YWxMZW5ndGggYnl0ZXMuXCIsXG4gIFtTT0xBTkFfRVJST1JfX09GRkNIQUlOX01FU1NBR0VfX01FU1NBR0VfTVVTVF9CRV9OT05fRU1QVFldOiBcIk9mZmNoYWluIG1lc3NhZ2UgY29udGVudCBtdXN0IGJlIG5vbi1lbXB0eVwiLFxuICBbU09MQU5BX0VSUk9SX19PRkZDSEFJTl9NRVNTQUdFX19OVU1fUkVRVUlSRURfU0lHTkVSU19DQU5OT1RfQkVfWkVST106IFwiT2ZmY2hhaW4gbWVzc2FnZSBtdXN0IHNwZWNpZnkgdGhlIGFkZHJlc3Mgb2YgYXQgbGVhc3Qgb25lIHJlcXVpcmVkIHNpZ25lclwiLFxuICBbU09MQU5BX0VSUk9SX19PRkZDSEFJTl9NRVNTQUdFX19OVU1fRU5WRUxPUEVfU0lHTkFUVVJFU19DQU5OT1RfQkVfWkVST106IFwiT2ZmY2hhaW4gbWVzc2FnZSBlbnZlbG9wZSBtdXN0IHJlc2VydmUgc3BhY2UgZm9yIGF0IGxlYXN0IG9uZSBzaWduYXR1cmVcIixcbiAgW1NPTEFOQV9FUlJPUl9fT0ZGQ0hBSU5fTUVTU0FHRV9fTlVNX1NJR05BVFVSRVNfTUlTTUFUQ0hdOiBcIlRoZSBvZmZjaGFpbiBtZXNzYWdlIHByZWFtYmxlIHNwZWNpZmllcyAkbnVtUmVxdWlyZWRTaWduYXR1cmVzIHJlcXVpcmVkIHNpZ25hdHVyZShzKSwgZ290ICRzaWduYXR1cmVzTGVuZ3RoLlwiLFxuICBbU09MQU5BX0VSUk9SX19PRkZDSEFJTl9NRVNTQUdFX19TSUdOQVRPUklFU19NVVNUX0JFX1NPUlRFRF06IFwiVGhlIHNpZ25hdG9yaWVzIG9mIHRoaXMgb2ZmY2hhaW4gbWVzc2FnZSBtdXN0IGJlIGxpc3RlZCBpbiBsZXhpY29ncmFwaGljYWwgb3JkZXJcIixcbiAgW1NPTEFOQV9FUlJPUl9fT0ZGQ0hBSU5fTUVTU0FHRV9fU0lHTkFUT1JJRVNfTVVTVF9CRV9VTklRVUVdOiBcIkFuIGFkZHJlc3MgbXVzdCBiZSBsaXN0ZWQgbm8gbW9yZSB0aGFuIG9uY2UgYW1vbmcgdGhlIHNpZ25hdG9yaWVzIG9mIGFuIG9mZmNoYWluIG1lc3NhZ2VcIixcbiAgW1NPTEFOQV9FUlJPUl9fT0ZGQ0hBSU5fTUVTU0FHRV9fU0lHTkFUVVJFU19NSVNTSU5HXTogXCJPZmZjaGFpbiBtZXNzYWdlIGlzIG1pc3Npbmcgc2lnbmF0dXJlcyBmb3IgYWRkcmVzc2VzOiAkYWRkcmVzc2VzLlwiLFxuICBbU09MQU5BX0VSUk9SX19PRkZDSEFJTl9NRVNTQUdFX19TSUdOQVRVUkVfVkVSSUZJQ0FUSU9OX0ZBSUxVUkVdOiBcIk9mZmNoYWluIG1lc3NhZ2Ugc2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBmYWlsZWQuIFNpZ25hdHVyZSBtaXNtYXRjaCBmb3IgcmVxdWlyZWQgc2lnbmF0b3JpZXMgWyRzaWduYXRvcmllc1dpdGhJbnZhbGlkU2lnbmF0dXJlc10uIE1pc3Npbmcgc2lnbmF0dXJlcyBmb3Igc2lnbmF0b3JpZXMgWyRzaWduYXRvcmllc1dpdGhNaXNzaW5nU2lnbmF0dXJlc11cIixcbiAgW1NPTEFOQV9FUlJPUl9fT0ZGQ0hBSU5fTUVTU0FHRV9fUkVTVFJJQ1RFRF9BU0NJSV9CT0RZX0NIQVJBQ1RFUl9PVVRfT0ZfUkFOR0VdOiBcIlRoZSBtZXNzYWdlIGJvZHkgcHJvdmlkZWQgY29udGFpbnMgY2hhcmFjdGVycyB3aG9zZSBjb2RlcyBmYWxsIG91dHNpZGUgdGhlIGFsbG93ZWQgcmFuZ2UuIEluIG9yZGVyIHRvIGVuc3VyZSBjbGVhci1zaWduaW5nIGNvbXBhdGlibGl0eSB3aXRoIGhhcmR3YXJlIHdhbGxldHMsIHRoZSBtZXNzYWdlIG1heSBvbmx5IGNvbnRhaW4gbGluZSBmZWVkcyBhbmQgY2hhcmFjdGVycyBpbiB0aGUgcmFuZ2UgW1xcXFx4MjAtXFxcXHg3ZV0uXCIsXG4gIFtTT0xBTkFfRVJST1JfX09GRkNIQUlOX01FU1NBR0VfX1VORVhQRUNURURfVkVSU0lPTl06IFwiRXhwZWN0ZWQgb2ZmY2hhaW4gbWVzc2FnZSB2ZXJzaW9uICRleHBlY3RlZFZlcnNpb24uIEdvdCAkYWN0dWFsVmVyc2lvbi5cIixcbiAgW1NPTEFOQV9FUlJPUl9fT0ZGQ0hBSU5fTUVTU0FHRV9fVkVSU0lPTl9OVU1CRVJfTk9UX1NVUFBPUlRFRF06IFwiVGhpcyB2ZXJzaW9uIG9mIEtpdCBkb2VzIG5vdCBzdXBwb3J0IGRlY29kaW5nIG9mZmNoYWluIG1lc3NhZ2VzIHdpdGggdmVyc2lvbiAkdW5zdXBwb3J0ZWRWZXJzaW9uLiBUaGUgY3VycmVudCBtYXggc3VwcG9ydGVkIHZlcnNpb24gaXMgMC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fUlBDX1NVQlNDUklQVElPTlNfX0NBTk5PVF9DUkVBVEVfU1VCU0NSSVBUSU9OX1BMQU5dOiBcIlRoZSBub3RpZmljYXRpb24gbmFtZSBtdXN0IGVuZCBpbiAnTm90aWZpY2F0aW9ucycgYW5kIHRoZSBBUEkgbXVzdCBzdXBwbHkgYSBzdWJzY3JpcHRpb24gcGxhbiBjcmVhdG9yIGZ1bmN0aW9uIGZvciB0aGUgbm90aWZpY2F0aW9uICckbm90aWZpY2F0aW9uTmFtZScuXCIsXG4gIFtTT0xBTkFfRVJST1JfX1JQQ19TVUJTQ1JJUFRJT05TX19DSEFOTkVMX0NMT1NFRF9CRUZPUkVfTUVTU0FHRV9CVUZGRVJFRF06IFwiV2ViU29ja2V0IHdhcyBjbG9zZWQgYmVmb3JlIHBheWxvYWQgY291bGQgYmUgYWRkZWQgdG8gdGhlIHNlbmQgYnVmZmVyXCIsXG4gIFtTT0xBTkFfRVJST1JfX1JQQ19TVUJTQ1JJUFRJT05TX19DSEFOTkVMX0NPTk5FQ1RJT05fQ0xPU0VEXTogXCJXZWJTb2NrZXQgY29ubmVjdGlvbiBjbG9zZWRcIixcbiAgW1NPTEFOQV9FUlJPUl9fUlBDX1NVQlNDUklQVElPTlNfX0NIQU5ORUxfRkFJTEVEX1RPX0NPTk5FQ1RdOiBcIldlYlNvY2tldCBmYWlsZWQgdG8gY29ubmVjdFwiLFxuICBbU09MQU5BX0VSUk9SX19SUENfU1VCU0NSSVBUSU9OU19fRVhQRUNURURfU0VSVkVSX1NVQlNDUklQVElPTl9JRF06IFwiRmFpbGVkIHRvIG9idGFpbiBhIHN1YnNjcmlwdGlvbiBpZCBmcm9tIHRoZSBzZXJ2ZXJcIixcbiAgW1NPTEFOQV9FUlJPUl9fUlBDX19BUElfUExBTl9NSVNTSU5HX0ZPUl9SUENfTUVUSE9EXTogXCJDb3VsZCBub3QgZmluZCBhbiBBUEkgcGxhbiBmb3IgUlBDIG1ldGhvZDogYCRtZXRob2RgXCIsXG4gIFtTT0xBTkFfRVJST1JfX1JQQ19fSU5URUdFUl9PVkVSRkxPV106IFwiVGhlICRhcmd1bWVudExhYmVsIGFyZ3VtZW50IHRvIHRoZSBgJG1ldGhvZE5hbWVgIFJQQyBtZXRob2Qkb3B0aW9uYWxQYXRoTGFiZWwgd2FzIGAkdmFsdWVgLiBUaGlzIG51bWJlciBpcyB1bnNhZmUgZm9yIHVzZSB3aXRoIHRoZSBTb2xhbmEgSlNPTi1SUEMgYmVjYXVzZSBpdCBleGNlZWRzIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXCIsXG4gIFtTT0xBTkFfRVJST1JfX1JQQ19fVFJBTlNQT1JUX0hUVFBfRVJST1JdOiBcIkhUVFAgZXJyb3IgKCRzdGF0dXNDb2RlKTogJG1lc3NhZ2VcIixcbiAgW1NPTEFOQV9FUlJPUl9fUlBDX19UUkFOU1BPUlRfSFRUUF9IRUFERVJfRk9SQklEREVOXTogXCJIVFRQIGhlYWRlcihzKSBmb3JiaWRkZW46ICRoZWFkZXJzLiBMZWFybiBtb3JlIGF0IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvR2xvc3NhcnkvRm9yYmlkZGVuX2hlYWRlcl9uYW1lLlwiLFxuICBbU09MQU5BX0VSUk9SX19TSUdORVJfX0FERFJFU1NfQ0FOTk9UX0hBVkVfTVVMVElQTEVfU0lHTkVSU106IFwiTXVsdGlwbGUgZGlzdGluY3Qgc2lnbmVycyB3ZXJlIGlkZW50aWZpZWQgZm9yIGFkZHJlc3MgYCRhZGRyZXNzYC4gUGxlYXNlIGVuc3VyZSB0aGF0IHlvdSBhcmUgdXNpbmcgdGhlIHNhbWUgc2lnbmVyIGluc3RhbmNlIGZvciBlYWNoIGFkZHJlc3MuXCIsXG4gIFtTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfS0VZX1BBSVJfU0lHTkVSXTogXCJUaGUgcHJvdmlkZWQgdmFsdWUgZG9lcyBub3QgaW1wbGVtZW50IHRoZSBgS2V5UGFpclNpZ25lcmAgaW50ZXJmYWNlXCIsXG4gIFtTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfTUVTU0FHRV9NT0RJRllJTkdfU0lHTkVSXTogXCJUaGUgcHJvdmlkZWQgdmFsdWUgZG9lcyBub3QgaW1wbGVtZW50IHRoZSBgTWVzc2FnZU1vZGlmeWluZ1NpZ25lcmAgaW50ZXJmYWNlXCIsXG4gIFtTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfTUVTU0FHRV9QQVJUSUFMX1NJR05FUl06IFwiVGhlIHByb3ZpZGVkIHZhbHVlIGRvZXMgbm90IGltcGxlbWVudCB0aGUgYE1lc3NhZ2VQYXJ0aWFsU2lnbmVyYCBpbnRlcmZhY2VcIixcbiAgW1NPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9NRVNTQUdFX1NJR05FUl06IFwiVGhlIHByb3ZpZGVkIHZhbHVlIGRvZXMgbm90IGltcGxlbWVudCBhbnkgb2YgdGhlIGBNZXNzYWdlU2lnbmVyYCBpbnRlcmZhY2VzXCIsXG4gIFtTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfVFJBTlNBQ1RJT05fTU9ESUZZSU5HX1NJR05FUl06IFwiVGhlIHByb3ZpZGVkIHZhbHVlIGRvZXMgbm90IGltcGxlbWVudCB0aGUgYFRyYW5zYWN0aW9uTW9kaWZ5aW5nU2lnbmVyYCBpbnRlcmZhY2VcIixcbiAgW1NPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9UUkFOU0FDVElPTl9QQVJUSUFMX1NJR05FUl06IFwiVGhlIHByb3ZpZGVkIHZhbHVlIGRvZXMgbm90IGltcGxlbWVudCB0aGUgYFRyYW5zYWN0aW9uUGFydGlhbFNpZ25lcmAgaW50ZXJmYWNlXCIsXG4gIFtTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfVFJBTlNBQ1RJT05fU0VORElOR19TSUdORVJdOiBcIlRoZSBwcm92aWRlZCB2YWx1ZSBkb2VzIG5vdCBpbXBsZW1lbnQgdGhlIGBUcmFuc2FjdGlvblNlbmRpbmdTaWduZXJgIGludGVyZmFjZVwiLFxuICBbU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX1RSQU5TQUNUSU9OX1NJR05FUl06IFwiVGhlIHByb3ZpZGVkIHZhbHVlIGRvZXMgbm90IGltcGxlbWVudCBhbnkgb2YgdGhlIGBUcmFuc2FjdGlvblNpZ25lcmAgaW50ZXJmYWNlc1wiLFxuICBbU09MQU5BX0VSUk9SX19TSUdORVJfX1RSQU5TQUNUSU9OX0NBTk5PVF9IQVZFX01VTFRJUExFX1NFTkRJTkdfU0lHTkVSU106IFwiTW9yZSB0aGFuIG9uZSBgVHJhbnNhY3Rpb25TZW5kaW5nU2lnbmVyYCB3YXMgaWRlbnRpZmllZC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fU0lHTkVSX19UUkFOU0FDVElPTl9TRU5ESU5HX1NJR05FUl9NSVNTSU5HXTogXCJObyBgVHJhbnNhY3Rpb25TZW5kaW5nU2lnbmVyYCB3YXMgaWRlbnRpZmllZC4gUGxlYXNlIHByb3ZpZGUgYSB2YWxpZCBgVHJhbnNhY3Rpb25XaXRoU2luZ2xlU2VuZGluZ1NpZ25lcmAgdHJhbnNhY3Rpb24uXCIsXG4gIFtTT0xBTkFfRVJST1JfX1NJR05FUl9fV0FMTEVUX01VTFRJU0lHTl9VTklNUExFTUVOVEVEXTogXCJXYWxsZXQgYWNjb3VudCBzaWduZXJzIGRvIG5vdCBzdXBwb3J0IHNpZ25pbmcgbXVsdGlwbGUgbWVzc2FnZXMvdHJhbnNhY3Rpb25zIGluIGEgc2luZ2xlIG9wZXJhdGlvblwiLFxuICBbU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19DQU5OT1RfRVhQT1JUX05PTl9FWFRSQUNUQUJMRV9LRVldOiBcIkNhbm5vdCBleHBvcnQgYSBub24tZXh0cmFjdGFibGUga2V5LlwiLFxuICBbU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19ESUdFU1RfVU5JTVBMRU1FTlRFRF06IFwiTm8gZGlnZXN0IGltcGxlbWVudGF0aW9uIGNvdWxkIGJlIGZvdW5kLlwiLFxuICBbU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19ESVNBTExPV0VEX0lOX0lOU0VDVVJFX0NPTlRFWFRdOiBcIkNyeXB0b2dyYXBoaWMgb3BlcmF0aW9ucyBhcmUgb25seSBhbGxvd2VkIGluIHNlY3VyZSBicm93c2VyIGNvbnRleHRzLiBSZWFkIG1vcmUgaGVyZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvU2VjdXJpdHkvU2VjdXJlX0NvbnRleHRzLlwiLFxuICBbU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19FRDI1NTE5X0FMR09SSVRITV9VTklNUExFTUVOVEVEXTogXCJUaGlzIHJ1bnRpbWUgZG9lcyBub3Qgc3VwcG9ydCB0aGUgZ2VuZXJhdGlvbiBvZiBFZDI1NTE5IGtleSBwYWlycy5cXG5cXG5JbnN0YWxsIEBzb2xhbmEvd2ViY3J5cHRvLWVkMjU1MTktcG9seWZpbGwgYW5kIGNhbGwgaXRzIGBpbnN0YWxsYCBmdW5jdGlvbiBiZWZvcmUgZ2VuZXJhdGluZyBrZXlzIGluIGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCBzdXBwb3J0IEVkMjU1MTkuXFxuXFxuRm9yIGEgbGlzdCBvZiBydW50aW1lcyB0aGF0IGN1cnJlbnRseSBzdXBwb3J0IEVkMjU1MTkgb3BlcmF0aW9ucywgdmlzaXQgaHR0cHM6Ly9naXRodWIuY29tL1dJQ0cvd2ViY3J5cHRvLXNlY3VyZS1jdXJ2ZXMvaXNzdWVzLzIwLlwiLFxuICBbU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19FWFBPUlRfRlVOQ1RJT05fVU5JTVBMRU1FTlRFRF06IFwiTm8gc2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBpbXBsZW1lbnRhdGlvbiBjb3VsZCBiZSBmb3VuZC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fR0VORVJBVEVfRlVOQ1RJT05fVU5JTVBMRU1FTlRFRF06IFwiTm8ga2V5IGdlbmVyYXRpb24gaW1wbGVtZW50YXRpb24gY291bGQgYmUgZm91bmQuXCIsXG4gIFtTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX1NJR05fRlVOQ1RJT05fVU5JTVBMRU1FTlRFRF06IFwiTm8gc2lnbmluZyBpbXBsZW1lbnRhdGlvbiBjb3VsZCBiZSBmb3VuZC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fVkVSSUZZX0ZVTkNUSU9OX1VOSU1QTEVNRU5URURdOiBcIk5vIGtleSBleHBvcnQgaW1wbGVtZW50YXRpb24gY291bGQgYmUgZm91bmQuXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RJTUVTVEFNUF9PVVRfT0ZfUkFOR0VdOiBcIlRpbWVzdGFtcCB2YWx1ZSBtdXN0IGJlIGluIHRoZSByYW5nZSBbLSgybiAqKiA2M24pLCAoMm4gKiogNjNuKSAtIDFdLiBgJHZhbHVlYCBnaXZlblwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQUNDT1VOVF9CT1JST1dfT1VUU1RBTkRJTkddOiBcIlRyYW5zYWN0aW9uIHByb2Nlc3NpbmcgbGVmdCBhbiBhY2NvdW50IHdpdGggYW4gb3V0c3RhbmRpbmcgYm9ycm93ZWQgcmVmZXJlbmNlXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19BQ0NPVU5UX0lOX1VTRV06IFwiQWNjb3VudCBpbiB1c2VcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0FDQ09VTlRfTE9BREVEX1RXSUNFXTogXCJBY2NvdW50IGxvYWRlZCB0d2ljZVwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQUNDT1VOVF9OT1RfRk9VTkRdOiBcIkF0dGVtcHQgdG8gZGViaXQgYW4gYWNjb3VudCBidXQgZm91bmQgbm8gcmVjb3JkIG9mIGEgcHJpb3IgY3JlZGl0LlwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQUREUkVTU19MT09LVVBfVEFCTEVfTk9UX0ZPVU5EXTogXCJUcmFuc2FjdGlvbiBsb2FkcyBhbiBhZGRyZXNzIHRhYmxlIGFjY291bnQgdGhhdCBkb2Vzbid0IGV4aXN0XCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19BTFJFQURZX1BST0NFU1NFRF06IFwiVGhpcyB0cmFuc2FjdGlvbiBoYXMgYWxyZWFkeSBiZWVuIHByb2Nlc3NlZFwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQkxPQ0tIQVNIX05PVF9GT1VORF06IFwiQmxvY2toYXNoIG5vdCBmb3VuZFwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQ0FMTF9DSEFJTl9UT09fREVFUF06IFwiTG9hZGVyIGNhbGwgY2hhaW4gaXMgdG9vIGRlZXBcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0NMVVNURVJfTUFJTlRFTkFOQ0VdOiBcIlRyYW5zYWN0aW9ucyBhcmUgY3VycmVudGx5IGRpc2FibGVkIGR1ZSB0byBjbHVzdGVyIG1haW50ZW5hbmNlXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19EVVBMSUNBVEVfSU5TVFJVQ1RJT05dOiBcIlRyYW5zYWN0aW9uIGNvbnRhaW5zIGEgZHVwbGljYXRlIGluc3RydWN0aW9uICgkaW5kZXgpIHRoYXQgaXMgbm90IGFsbG93ZWRcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOU1VGRklDSUVOVF9GVU5EU19GT1JfRkVFXTogXCJJbnN1ZmZpY2llbnQgZnVuZHMgZm9yIGZlZVwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5TVUZGSUNJRU5UX0ZVTkRTX0ZPUl9SRU5UXTogXCJUcmFuc2FjdGlvbiByZXN1bHRzIGluIGFuIGFjY291bnQgKCRhY2NvdW50SW5kZXgpIHdpdGggaW5zdWZmaWNpZW50IGZ1bmRzIGZvciByZW50XCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX0FDQ09VTlRfRk9SX0ZFRV06IFwiVGhpcyBhY2NvdW50IG1heSBub3QgYmUgdXNlZCB0byBwYXkgdHJhbnNhY3Rpb24gZmVlc1wiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9BQ0NPVU5UX0lOREVYXTogXCJUcmFuc2FjdGlvbiBjb250YWlucyBhbiBpbnZhbGlkIGFjY291bnQgcmVmZXJlbmNlXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX0FERFJFU1NfTE9PS1VQX1RBQkxFX0RBVEFdOiBcIlRyYW5zYWN0aW9uIGxvYWRzIGFuIGFkZHJlc3MgdGFibGUgYWNjb3VudCB3aXRoIGludmFsaWQgZGF0YVwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9BRERSRVNTX0xPT0tVUF9UQUJMRV9JTkRFWF06IFwiVHJhbnNhY3Rpb24gYWRkcmVzcyB0YWJsZSBsb29rdXAgdXNlcyBhbiBpbnZhbGlkIGluZGV4XCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX0FERFJFU1NfTE9PS1VQX1RBQkxFX09XTkVSXTogXCJUcmFuc2FjdGlvbiBsb2FkcyBhbiBhZGRyZXNzIHRhYmxlIGFjY291bnQgd2l0aCBhbiBpbnZhbGlkIG93bmVyXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX0xPQURFRF9BQ0NPVU5UU19EQVRBX1NJWkVfTElNSVRdOiBcIkxvYWRlZEFjY291bnRzRGF0YVNpemVMaW1pdCBzZXQgZm9yIHRyYW5zYWN0aW9uIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAuXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX1BST0dSQU1fRk9SX0VYRUNVVElPTl06IFwiVGhpcyBwcm9ncmFtIG1heSBub3QgYmUgdXNlZCBmb3IgZXhlY3V0aW5nIGluc3RydWN0aW9uc1wiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9SRU5UX1BBWUlOR19BQ0NPVU5UXTogXCJUcmFuc2FjdGlvbiBsZWF2ZXMgYW4gYWNjb3VudCB3aXRoIGEgbG93ZXIgYmFsYW5jZSB0aGFuIHJlbnQtZXhlbXB0IG1pbmltdW1cIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfV1JJVEFCTEVfQUNDT1VOVF06IFwiVHJhbnNhY3Rpb24gbG9hZHMgYSB3cml0YWJsZSBhY2NvdW50IHRoYXQgY2Fubm90IGJlIHdyaXR0ZW5cIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX01BWF9MT0FERURfQUNDT1VOVFNfREFUQV9TSVpFX0VYQ0VFREVEXTogXCJUcmFuc2FjdGlvbiBleGNlZWRlZCBtYXggbG9hZGVkIGFjY291bnRzIGRhdGEgc2l6ZSBjYXBcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX01JU1NJTkdfU0lHTkFUVVJFX0ZPUl9GRUVdOiBcIlRyYW5zYWN0aW9uIHJlcXVpcmVzIGEgZmVlIGJ1dCBoYXMgbm8gc2lnbmF0dXJlIHByZXNlbnRcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1BST0dSQU1fQUNDT1VOVF9OT1RfRk9VTkRdOiBcIkF0dGVtcHQgdG8gbG9hZCBhIHByb2dyYW0gdGhhdCBkb2VzIG5vdCBleGlzdFwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fUFJPR1JBTV9FWEVDVVRJT05fVEVNUE9SQVJJTFlfUkVTVFJJQ1RFRF06IFwiRXhlY3V0aW9uIG9mIHRoZSBwcm9ncmFtIHJlZmVyZW5jZWQgYnkgYWNjb3VudCBhdCBpbmRleCAkYWNjb3VudEluZGV4IGlzIHRlbXBvcmFyaWx5IHJlc3RyaWN0ZWQuXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19SRVNBTklUSVpBVElPTl9ORUVERURdOiBcIlJlc2FuaXRpemF0aW9uTmVlZGVkXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19TQU5JVElaRV9GQUlMVVJFXTogXCJUcmFuc2FjdGlvbiBmYWlsZWQgdG8gc2FuaXRpemUgYWNjb3VudHMgb2Zmc2V0cyBjb3JyZWN0bHlcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1NJR05BVFVSRV9GQUlMVVJFXTogXCJUcmFuc2FjdGlvbiBkaWQgbm90IHBhc3Mgc2lnbmF0dXJlIHZlcmlmaWNhdGlvblwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fVE9PX01BTllfQUNDT1VOVF9MT0NLU106IFwiVHJhbnNhY3Rpb24gbG9ja2VkIHRvbyBtYW55IGFjY291bnRzXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19VTkJBTEFOQ0VEX1RSQU5TQUNUSU9OXTogXCJTdW0gb2YgYWNjb3VudCBiYWxhbmNlcyBiZWZvcmUgYW5kIGFmdGVyIHRyYW5zYWN0aW9uIGRvIG5vdCBtYXRjaFwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fVU5LTk9XTl06IFwiVGhlIHRyYW5zYWN0aW9uIGZhaWxlZCB3aXRoIHRoZSBlcnJvciBgJGVycm9yTmFtZWBcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1VOU1VQUE9SVEVEX1ZFUlNJT05dOiBcIlRyYW5zYWN0aW9uIHZlcnNpb24gaXMgdW5zdXBwb3J0ZWRcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1dPVUxEX0VYQ0VFRF9BQ0NPVU5UX0RBVEFfQkxPQ0tfTElNSVRdOiBcIlRyYW5zYWN0aW9uIHdvdWxkIGV4Y2VlZCBhY2NvdW50IGRhdGEgbGltaXQgd2l0aGluIHRoZSBibG9ja1wiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fV09VTERfRVhDRUVEX0FDQ09VTlRfREFUQV9UT1RBTF9MSU1JVF06IFwiVHJhbnNhY3Rpb24gd291bGQgZXhjZWVkIHRvdGFsIGFjY291bnQgZGF0YSBsaW1pdFwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fV09VTERfRVhDRUVEX01BWF9BQ0NPVU5UX0NPU1RfTElNSVRdOiBcIlRyYW5zYWN0aW9uIHdvdWxkIGV4Y2VlZCBtYXggYWNjb3VudCBsaW1pdCB3aXRoaW4gdGhlIGJsb2NrXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19XT1VMRF9FWENFRURfTUFYX0JMT0NLX0NPU1RfTElNSVRdOiBcIlRyYW5zYWN0aW9uIHdvdWxkIGV4Y2VlZCBtYXggQmxvY2sgQ29zdCBMaW1pdFwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fV09VTERfRVhDRUVEX01BWF9WT1RFX0NPU1RfTElNSVRdOiBcIlRyYW5zYWN0aW9uIHdvdWxkIGV4Y2VlZCBtYXggVm90ZSBDb3N0IExpbWl0XCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19BRERSRVNTRVNfQ0FOTk9UX1NJR05fVFJBTlNBQ1RJT05dOiBcIkF0dGVtcHRlZCB0byBzaWduIGEgdHJhbnNhY3Rpb24gd2l0aCBhbiBhZGRyZXNzIHRoYXQgaXMgbm90IGEgc2lnbmVyIGZvciBpdFwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fQUREUkVTU19NSVNTSU5HXTogXCJUcmFuc2FjdGlvbiBpcyBtaXNzaW5nIGFuIGFkZHJlc3MgYXQgaW5kZXg6ICRpbmRleC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0NBTk5PVF9FTkNPREVfV0lUSF9FTVBUWV9TSUdOQVRVUkVTXTogXCJUcmFuc2FjdGlvbiBoYXMgbm8gZXhwZWN0ZWQgc2lnbmVycyB0aGVyZWZvcmUgaXQgY2Fubm90IGJlIGVuY29kZWRcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0VYQ0VFRFNfU0laRV9MSU1JVF06IFwiVHJhbnNhY3Rpb24gc2l6ZSAkdHJhbnNhY3Rpb25TaXplIGV4Y2VlZHMgbGltaXQgb2YgJHRyYW5zYWN0aW9uU2l6ZUxpbWl0IGJ5dGVzXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19FWFBFQ1RFRF9CTE9DS0hBU0hfTElGRVRJTUVdOiBcIlRyYW5zYWN0aW9uIGRvZXMgbm90IGhhdmUgYSBibG9ja2hhc2ggbGlmZXRpbWVcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0VYUEVDVEVEX05PTkNFX0xJRkVUSU1FXTogXCJUcmFuc2FjdGlvbiBpcyBub3QgYSBkdXJhYmxlIG5vbmNlIHRyYW5zYWN0aW9uXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GQUlMRURfVE9fREVDT01QSUxFX0FERFJFU1NfTE9PS1VQX1RBQkxFX0NPTlRFTlRTX01JU1NJTkddOiBcIkNvbnRlbnRzIG9mIHRoZXNlIGFkZHJlc3MgbG9va3VwIHRhYmxlcyB1bmtub3duOiAkbG9va3VwVGFibGVBZGRyZXNzZXNcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9UT19ERUNPTVBJTEVfQUREUkVTU19MT09LVVBfVEFCTEVfSU5ERVhfT1VUX09GX1JBTkdFXTogXCJMb29rdXAgb2YgYWRkcmVzcyBhdCBpbmRleCAkaGlnaGVzdFJlcXVlc3RlZEluZGV4IGZhaWxlZCBmb3IgbG9va3VwIHRhYmxlIGAkbG9va3VwVGFibGVBZGRyZXNzYC4gSGlnaGVzdCBrbm93biBpbmRleCBpcyAkaGlnaGVzdEtub3duSW5kZXguIFRoZSBsb29rdXAgdGFibGUgbWF5IGhhdmUgYmVlbiBleHRlbmRlZCBzaW5jZSBpdHMgY29udGVudHMgd2VyZSByZXRyaWV2ZWRcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9UT19ERUNPTVBJTEVfRkVFX1BBWUVSX01JU1NJTkddOiBcIk5vIGZlZSBwYXllciBzZXQgaW4gQ29tcGlsZWRUcmFuc2FjdGlvblwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkFJTEVEX1RPX0RFQ09NUElMRV9JTlNUUlVDVElPTl9QUk9HUkFNX0FERFJFU1NfTk9UX0ZPVU5EXTogXCJDb3VsZCBub3QgZmluZCBwcm9ncmFtIGFkZHJlc3MgYXQgaW5kZXggJGluZGV4XCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GQUlMRURfVE9fRVNUSU1BVEVfQ09NUFVURV9MSU1JVF06IFwiRmFpbGVkIHRvIGVzdGltYXRlIHRoZSBjb21wdXRlIHVuaXQgY29uc3VtcHRpb24gZm9yIHRoaXMgdHJhbnNhY3Rpb24gbWVzc2FnZS4gVGhpcyBpcyBsaWtlbHkgYmVjYXVzZSBzaW11bGF0aW5nIHRoZSB0cmFuc2FjdGlvbiBmYWlsZWQuIEluc3BlY3QgdGhlIGBjYXVzZWAgcHJvcGVydHkgb2YgdGhpcyBlcnJvciB0byBsZWFybiBtb3JlXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GQUlMRURfV0hFTl9TSU1VTEFUSU5HX1RPX0VTVElNQVRFX0NPTVBVVEVfTElNSVRdOiBcIlRyYW5zYWN0aW9uIGZhaWxlZCB3aGVuIGl0IHdhcyBzaW11bGF0ZWQgaW4gb3JkZXIgdG8gZXN0aW1hdGUgdGhlIGNvbXB1dGUgdW5pdCBjb25zdW1wdGlvbi4gVGhlIGNvbXB1dGUgdW5pdCBlc3RpbWF0ZSBwcm92aWRlZCBpcyBmb3IgYSB0cmFuc2FjdGlvbiB0aGF0IGZhaWxlZCB3aGVuIHNpbXVsYXRlZCBhbmQgbWF5IG5vdCBiZSByZXByZXNlbnRhdGl2ZSBvZiB0aGUgY29tcHV0ZSB1bml0cyB0aGlzIHRyYW5zYWN0aW9uIHdvdWxkIGNvbnN1bWUgaWYgc3VjY2Vzc2Z1bC4gSW5zcGVjdCB0aGUgYGNhdXNlYCBwcm9wZXJ0eSBvZiB0aGlzIGVycm9yIHRvIGxlYXJuIG1vcmVcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZFRV9QQVlFUl9NSVNTSU5HXTogXCJUcmFuc2FjdGlvbiBpcyBtaXNzaW5nIGEgZmVlIHBheWVyLlwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkVFX1BBWUVSX1NJR05BVFVSRV9NSVNTSU5HXTogXCJDb3VsZCBub3QgZGV0ZXJtaW5lIHRoaXMgdHJhbnNhY3Rpb24ncyBzaWduYXR1cmUuIE1ha2Ugc3VyZSB0aGF0IHRoZSB0cmFuc2FjdGlvbiBoYXMgYmVlbiBzaWduZWQgYnkgaXRzIGZlZSBwYXllci5cIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0lOVkFMSURfTk9OQ0VfVFJBTlNBQ1RJT05fRklSU1RfSU5TVFJVQ1RJT05fTVVTVF9CRV9BRFZBTkNFX05PTkNFXTogXCJUcmFuc2FjdGlvbiBmaXJzdCBpbnN0cnVjdGlvbiBpcyBub3QgYWR2YW5jZSBub25jZSBhY2NvdW50IGluc3RydWN0aW9uLlwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fSU5WQUxJRF9OT05DRV9UUkFOU0FDVElPTl9JTlNUUlVDVElPTlNfTUlTU0lOR106IFwiVHJhbnNhY3Rpb24gd2l0aCBubyBpbnN0cnVjdGlvbnMgY2Fubm90IGJlIGR1cmFibGUgbm9uY2UgdHJhbnNhY3Rpb24uXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19JTlZPS0VEX1BST0dSQU1TX0NBTk5PVF9QQVlfRkVFU106IFwiVGhpcyB0cmFuc2FjdGlvbiBpbmNsdWRlcyBhbiBhZGRyZXNzIChgJHByb2dyYW1BZGRyZXNzYCkgd2hpY2ggaXMgYm90aCBpbnZva2VkIGFuZCBzZXQgYXMgdGhlIGZlZSBwYXllci4gUHJvZ3JhbSBhZGRyZXNzZXMgbWF5IG5vdCBwYXkgZmVlc1wiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fSU5WT0tFRF9QUk9HUkFNU19NVVNUX05PVF9CRV9XUklUQUJMRV06IFwiVGhpcyB0cmFuc2FjdGlvbiBpbmNsdWRlcyBhbiBhZGRyZXNzIChgJHByb2dyYW1BZGRyZXNzYCkgd2hpY2ggaXMgYm90aCBpbnZva2VkIGFuZCBtYXJrZWQgd3JpdGFibGUuIFByb2dyYW0gYWRkcmVzc2VzIG1heSBub3QgYmUgd3JpdGFibGVcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX01FU1NBR0VfU0lHTkFUVVJFU19NSVNNQVRDSF06IFwiVGhlIHRyYW5zYWN0aW9uIG1lc3NhZ2UgZXhwZWN0ZWQgdGhlIHRyYW5zYWN0aW9uIHRvIGhhdmUgJG51bVJlcXVpcmVkU2lnbmF0dXJlcyBzaWduYXR1cmVzLCBnb3QgJHNpZ25hdHVyZXNMZW5ndGguXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19TSUdOQVRVUkVTX01JU1NJTkddOiBcIlRyYW5zYWN0aW9uIGlzIG1pc3Npbmcgc2lnbmF0dXJlcyBmb3IgYWRkcmVzc2VzOiAkYWRkcmVzc2VzLlwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fVkVSU0lPTl9OVU1CRVJfT1VUX09GX1JBTkdFXTogXCJUcmFuc2FjdGlvbiB2ZXJzaW9uIG11c3QgYmUgaW4gdGhlIHJhbmdlIFswLCAxMjddLiBgJGFjdHVhbFZlcnNpb25gIGdpdmVuXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19WRVJTSU9OX05VTUJFUl9OT1RfU1VQUE9SVEVEXTogXCJUaGlzIHZlcnNpb24gb2YgS2l0IGRvZXMgbm90IHN1cHBvcnQgZGVjb2RpbmcgdHJhbnNhY3Rpb25zIHdpdGggdmVyc2lvbiAkdW5zdXBwb3J0ZWRWZXJzaW9uLiBUaGUgY3VycmVudCBtYXggc3VwcG9ydGVkIHZlcnNpb24gaXMgMC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX05PTkNFX0FDQ09VTlRfQ0FOTk9UX0JFX0lOX0xPT0tVUF9UQUJMRV06IFwiVGhlIHRyYW5zYWN0aW9uIGhhcyBhIGR1cmFibGUgbm9uY2UgbGlmZXRpbWUgKHdpdGggbm9uY2UgYCRub25jZWApLCBidXQgdGhlIG5vbmNlIGFjY291bnQgYWRkcmVzcyBpcyBpbiBhIGxvb2t1cCB0YWJsZS4gVGhlIGxpZmV0aW1lIGNvbnN0cmFpbnQgY2Fubm90IGJlIGNvbnN0cnVjdGVkIHdpdGhvdXQgZmV0Y2hpbmcgdGhlIGxvb2t1cCB0YWJsZXMgZm9yIHRoZSB0cmFuc2FjdGlvbi5cIlxufTtcblxuLy8gc3JjL21lc3NhZ2UtZm9ybWF0dGVyLnRzXG52YXIgU1RBUlRfSU5ERVggPSBcImlcIjtcbnZhciBUWVBFID0gXCJ0XCI7XG5mdW5jdGlvbiBnZXRIdW1hblJlYWRhYmxlRXJyb3JNZXNzYWdlKGNvZGUsIGNvbnRleHQgPSB7fSkge1xuICBjb25zdCBtZXNzYWdlRm9ybWF0U3RyaW5nID0gU29sYW5hRXJyb3JNZXNzYWdlc1tjb2RlXTtcbiAgaWYgKG1lc3NhZ2VGb3JtYXRTdHJpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgbGV0IHN0YXRlO1xuICBmdW5jdGlvbiBjb21taXRTdGF0ZVVwVG8oZW5kSW5kZXgpIHtcbiAgICBpZiAoc3RhdGVbVFlQRV0gPT09IDIgLyogVmFyaWFibGUgKi8pIHtcbiAgICAgIGNvbnN0IHZhcmlhYmxlTmFtZSA9IG1lc3NhZ2VGb3JtYXRTdHJpbmcuc2xpY2Uoc3RhdGVbU1RBUlRfSU5ERVhdICsgMSwgZW5kSW5kZXgpO1xuICAgICAgZnJhZ21lbnRzLnB1c2goXG4gICAgICAgIHZhcmlhYmxlTmFtZSBpbiBjb250ZXh0ID8gKFxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtdGVtcGxhdGUtZXhwcmVzc2lvbnNcbiAgICAgICAgICBgJHtjb250ZXh0W3ZhcmlhYmxlTmFtZV19YFxuICAgICAgICApIDogYCQke3ZhcmlhYmxlTmFtZX1gXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoc3RhdGVbVFlQRV0gPT09IDEgLyogVGV4dCAqLykge1xuICAgICAgZnJhZ21lbnRzLnB1c2gobWVzc2FnZUZvcm1hdFN0cmluZy5zbGljZShzdGF0ZVtTVEFSVF9JTkRFWF0sIGVuZEluZGV4KSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGZyYWdtZW50cyA9IFtdO1xuICBtZXNzYWdlRm9ybWF0U3RyaW5nLnNwbGl0KFwiXCIpLmZvckVhY2goKGNoYXIsIGlpKSA9PiB7XG4gICAgaWYgKGlpID09PSAwKSB7XG4gICAgICBzdGF0ZSA9IHtcbiAgICAgICAgW1NUQVJUX0lOREVYXTogMCxcbiAgICAgICAgW1RZUEVdOiBtZXNzYWdlRm9ybWF0U3RyaW5nWzBdID09PSBcIlxcXFxcIiA/IDAgLyogRXNjYXBlU2VxdWVuY2UgKi8gOiBtZXNzYWdlRm9ybWF0U3RyaW5nWzBdID09PSBcIiRcIiA/IDIgLyogVmFyaWFibGUgKi8gOiAxIC8qIFRleHQgKi9cbiAgICAgIH07XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBuZXh0U3RhdGU7XG4gICAgc3dpdGNoIChzdGF0ZVtUWVBFXSkge1xuICAgICAgY2FzZSAwIC8qIEVzY2FwZVNlcXVlbmNlICovOlxuICAgICAgICBuZXh0U3RhdGUgPSB7IFtTVEFSVF9JTkRFWF06IGlpLCBbVFlQRV06IDEgLyogVGV4dCAqLyB9O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMSAvKiBUZXh0ICovOlxuICAgICAgICBpZiAoY2hhciA9PT0gXCJcXFxcXCIpIHtcbiAgICAgICAgICBuZXh0U3RhdGUgPSB7IFtTVEFSVF9JTkRFWF06IGlpLCBbVFlQRV06IDAgLyogRXNjYXBlU2VxdWVuY2UgKi8gfTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyID09PSBcIiRcIikge1xuICAgICAgICAgIG5leHRTdGF0ZSA9IHsgW1NUQVJUX0lOREVYXTogaWksIFtUWVBFXTogMiAvKiBWYXJpYWJsZSAqLyB9O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyIC8qIFZhcmlhYmxlICovOlxuICAgICAgICBpZiAoY2hhciA9PT0gXCJcXFxcXCIpIHtcbiAgICAgICAgICBuZXh0U3RhdGUgPSB7IFtTVEFSVF9JTkRFWF06IGlpLCBbVFlQRV06IDAgLyogRXNjYXBlU2VxdWVuY2UgKi8gfTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyID09PSBcIiRcIikge1xuICAgICAgICAgIG5leHRTdGF0ZSA9IHsgW1NUQVJUX0lOREVYXTogaWksIFtUWVBFXTogMiAvKiBWYXJpYWJsZSAqLyB9O1xuICAgICAgICB9IGVsc2UgaWYgKCFjaGFyLm1hdGNoKC9cXHcvKSkge1xuICAgICAgICAgIG5leHRTdGF0ZSA9IHsgW1NUQVJUX0lOREVYXTogaWksIFtUWVBFXTogMSAvKiBUZXh0ICovIH07XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChuZXh0U3RhdGUpIHtcbiAgICAgIGlmIChzdGF0ZSAhPT0gbmV4dFN0YXRlKSB7XG4gICAgICAgIGNvbW1pdFN0YXRlVXBUbyhpaSk7XG4gICAgICB9XG4gICAgICBzdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICB9XG4gIH0pO1xuICBjb21taXRTdGF0ZVVwVG8oKTtcbiAgcmV0dXJuIGZyYWdtZW50cy5qb2luKFwiXCIpO1xufVxuZnVuY3Rpb24gZ2V0RXJyb3JNZXNzYWdlKGNvZGUsIGNvbnRleHQgPSB7fSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgcmV0dXJuIGdldEh1bWFuUmVhZGFibGVFcnJvck1lc3NhZ2UoY29kZSwgY29udGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IGRlY29kaW5nQWR2aWNlTWVzc2FnZSA9IGBTb2xhbmEgZXJyb3IgIyR7Y29kZX07IERlY29kZSB0aGlzIGVycm9yIGJ5IHJ1bm5pbmcgXFxgbnB4IEBzb2xhbmEvZXJyb3JzIGRlY29kZSAtLSAke2NvZGV9YDtcbiAgICBpZiAoT2JqZWN0LmtleXMoY29udGV4dCkubGVuZ3RoKSB7XG4gICAgICBkZWNvZGluZ0FkdmljZU1lc3NhZ2UgKz0gYCAnJHtlbmNvZGVDb250ZXh0T2JqZWN0KGNvbnRleHQpfSdgO1xuICAgIH1cbiAgICByZXR1cm4gYCR7ZGVjb2RpbmdBZHZpY2VNZXNzYWdlfVxcYGA7XG4gIH1cbn1cblxuLy8gc3JjL2Vycm9yLnRzXG5mdW5jdGlvbiBpc1NvbGFuYUVycm9yKGUsIGNvZGUpIHtcbiAgY29uc3QgaXNTb2xhbmFFcnJvcjIgPSBlIGluc3RhbmNlb2YgRXJyb3IgJiYgZS5uYW1lID09PSBcIlNvbGFuYUVycm9yXCI7XG4gIGlmIChpc1NvbGFuYUVycm9yMikge1xuICAgIGlmIChjb2RlICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBlLmNvbnRleHQuX19jb2RlID09PSBjb2RlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG52YXIgU29sYW5hRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgLyoqXG4gICAqIEluZGljYXRlcyB0aGUgcm9vdCBjYXVzZSBvZiB0aGlzIHtAbGluayBTb2xhbmFFcnJvcn0sIGlmIGFueS5cbiAgICpcbiAgICogRm9yIGV4YW1wbGUsIGEgdHJhbnNhY3Rpb24gZXJyb3IgbWlnaHQgaGF2ZSBhbiBpbnN0cnVjdGlvbiBlcnJvciBhcyBpdHMgcm9vdCBjYXVzZS4gSW4gdGhpc1xuICAgKiBjYXNlLCB5b3Ugd2lsbCBiZSBhYmxlIHRvIGFjY2VzcyB0aGUgaW5zdHJ1Y3Rpb24gZXJyb3Igb24gdGhlIHRyYW5zYWN0aW9uIGVycm9yIGFzIGBjYXVzZWAuXG4gICAqL1xuICBjYXVzZSA9IHRoaXMuY2F1c2U7XG4gIC8qKlxuICAgKiBDb250YWlucyBjb250ZXh0IHRoYXQgY2FuIGFzc2lzdCBpbiB1bmRlcnN0YW5kaW5nIG9yIHJlY292ZXJpbmcgZnJvbSBhIHtAbGluayBTb2xhbmFFcnJvcn0uXG4gICAqL1xuICBjb250ZXh0O1xuICBjb25zdHJ1Y3RvciguLi5bY29kZSwgY29udGV4dEFuZEVycm9yT3B0aW9uc10pIHtcbiAgICBsZXQgY29udGV4dDtcbiAgICBsZXQgZXJyb3JPcHRpb25zO1xuICAgIGlmIChjb250ZXh0QW5kRXJyb3JPcHRpb25zKSB7XG4gICAgICBPYmplY3QuZW50cmllcyhPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhjb250ZXh0QW5kRXJyb3JPcHRpb25zKSkuZm9yRWFjaCgoW25hbWUsIGRlc2NyaXB0b3JdKSA9PiB7XG4gICAgICAgIGlmIChuYW1lID09PSBcImNhdXNlXCIpIHtcbiAgICAgICAgICBlcnJvck9wdGlvbnMgPSB7IGNhdXNlOiBkZXNjcmlwdG9yLnZhbHVlIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgY29udGV4dCA9IHtcbiAgICAgICAgICAgICAgX19jb2RlOiBjb2RlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29udGV4dCwgbmFtZSwgZGVzY3JpcHRvcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlID0gZ2V0RXJyb3JNZXNzYWdlKGNvZGUsIGNvbnRleHQpO1xuICAgIHN1cGVyKG1lc3NhZ2UsIGVycm9yT3B0aW9ucyk7XG4gICAgdGhpcy5jb250ZXh0ID0gT2JqZWN0LmZyZWV6ZShcbiAgICAgIGNvbnRleHQgPT09IHZvaWQgMCA/IHtcbiAgICAgICAgX19jb2RlOiBjb2RlXG4gICAgICB9IDogY29udGV4dFxuICAgICk7XG4gICAgdGhpcy5uYW1lID0gXCJTb2xhbmFFcnJvclwiO1xuICB9XG59O1xuXG4vLyBzcmMvc3RhY2stdHJhY2UudHNcbmZ1bmN0aW9uIHNhZmVDYXB0dXJlU3RhY2tUcmFjZSguLi5hcmdzKSB7XG4gIGlmIChcImNhcHR1cmVTdGFja1RyYWNlXCIgaW4gRXJyb3IgJiYgdHlwZW9mIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSguLi5hcmdzKTtcbiAgfVxufVxuXG4vLyBzcmMvcnBjLWVudW0tZXJyb3JzLnRzXG5mdW5jdGlvbiBnZXRTb2xhbmFFcnJvckZyb21ScGNFcnJvcih7IGVycm9yQ29kZUJhc2VPZmZzZXQsIGdldEVycm9yQ29udGV4dCwgb3JkZXJlZEVycm9yTmFtZXMsIHJwY0VudW1FcnJvciB9LCBjb25zdHJ1Y3Rvck9wdCkge1xuICBsZXQgcnBjRXJyb3JOYW1lO1xuICBsZXQgcnBjRXJyb3JDb250ZXh0O1xuICBpZiAodHlwZW9mIHJwY0VudW1FcnJvciA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJwY0Vycm9yTmFtZSA9IHJwY0VudW1FcnJvcjtcbiAgfSBlbHNlIHtcbiAgICBycGNFcnJvck5hbWUgPSBPYmplY3Qua2V5cyhycGNFbnVtRXJyb3IpWzBdO1xuICAgIHJwY0Vycm9yQ29udGV4dCA9IHJwY0VudW1FcnJvcltycGNFcnJvck5hbWVdO1xuICB9XG4gIGNvbnN0IGNvZGVPZmZzZXQgPSBvcmRlcmVkRXJyb3JOYW1lcy5pbmRleE9mKHJwY0Vycm9yTmFtZSk7XG4gIGNvbnN0IGVycm9yQ29kZSA9IGVycm9yQ29kZUJhc2VPZmZzZXQgKyBjb2RlT2Zmc2V0O1xuICBjb25zdCBlcnJvckNvbnRleHQgPSBnZXRFcnJvckNvbnRleHQoZXJyb3JDb2RlLCBycGNFcnJvck5hbWUsIHJwY0Vycm9yQ29udGV4dCk7XG4gIGNvbnN0IGVyciA9IG5ldyBTb2xhbmFFcnJvcihlcnJvckNvZGUsIGVycm9yQ29udGV4dCk7XG4gIHNhZmVDYXB0dXJlU3RhY2tUcmFjZShlcnIsIGNvbnN0cnVjdG9yT3B0KTtcbiAgcmV0dXJuIGVycjtcbn1cblxuLy8gc3JjL2luc3RydWN0aW9uLWVycm9yLnRzXG52YXIgT1JERVJFRF9FUlJPUl9OQU1FUyA9IFtcbiAgLy8gS2VlcCBzeW5jZWQgd2l0aCBSUEMgc291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vYW56YS14eXovc29sYW5hLXNkay9ibG9iL21hc3Rlci9pbnN0cnVjdGlvbi1lcnJvci9zcmMvbGliLnJzXG4gIC8vIElmIHRoaXMgbGlzdCBldmVyIGdldHMgdG9vIGxhcmdlLCBjb25zaWRlciBpbXBsZW1lbnRpbmcgYSBjb21wcmVzc2lvbiBzdHJhdGVneSBsaWtlIHRoaXM6XG4gIC8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3N0ZXZlbHVzY2hlci9hYWE3Y2JiYjU0MzNiMTE5Nzk4MzkwOGE0MDg2MGM0N1xuICBcIkdlbmVyaWNFcnJvclwiLFxuICBcIkludmFsaWRBcmd1bWVudFwiLFxuICBcIkludmFsaWRJbnN0cnVjdGlvbkRhdGFcIixcbiAgXCJJbnZhbGlkQWNjb3VudERhdGFcIixcbiAgXCJBY2NvdW50RGF0YVRvb1NtYWxsXCIsXG4gIFwiSW5zdWZmaWNpZW50RnVuZHNcIixcbiAgXCJJbmNvcnJlY3RQcm9ncmFtSWRcIixcbiAgXCJNaXNzaW5nUmVxdWlyZWRTaWduYXR1cmVcIixcbiAgXCJBY2NvdW50QWxyZWFkeUluaXRpYWxpemVkXCIsXG4gIFwiVW5pbml0aWFsaXplZEFjY291bnRcIixcbiAgXCJVbmJhbGFuY2VkSW5zdHJ1Y3Rpb25cIixcbiAgXCJNb2RpZmllZFByb2dyYW1JZFwiLFxuICBcIkV4dGVybmFsQWNjb3VudExhbXBvcnRTcGVuZFwiLFxuICBcIkV4dGVybmFsQWNjb3VudERhdGFNb2RpZmllZFwiLFxuICBcIlJlYWRvbmx5TGFtcG9ydENoYW5nZVwiLFxuICBcIlJlYWRvbmx5RGF0YU1vZGlmaWVkXCIsXG4gIFwiRHVwbGljYXRlQWNjb3VudEluZGV4XCIsXG4gIFwiRXhlY3V0YWJsZU1vZGlmaWVkXCIsXG4gIFwiUmVudEVwb2NoTW9kaWZpZWRcIixcbiAgXCJOb3RFbm91Z2hBY2NvdW50S2V5c1wiLFxuICBcIkFjY291bnREYXRhU2l6ZUNoYW5nZWRcIixcbiAgXCJBY2NvdW50Tm90RXhlY3V0YWJsZVwiLFxuICBcIkFjY291bnRCb3Jyb3dGYWlsZWRcIixcbiAgXCJBY2NvdW50Qm9ycm93T3V0c3RhbmRpbmdcIixcbiAgXCJEdXBsaWNhdGVBY2NvdW50T3V0T2ZTeW5jXCIsXG4gIFwiQ3VzdG9tXCIsXG4gIFwiSW52YWxpZEVycm9yXCIsXG4gIFwiRXhlY3V0YWJsZURhdGFNb2RpZmllZFwiLFxuICBcIkV4ZWN1dGFibGVMYW1wb3J0Q2hhbmdlXCIsXG4gIFwiRXhlY3V0YWJsZUFjY291bnROb3RSZW50RXhlbXB0XCIsXG4gIFwiVW5zdXBwb3J0ZWRQcm9ncmFtSWRcIixcbiAgXCJDYWxsRGVwdGhcIixcbiAgXCJNaXNzaW5nQWNjb3VudFwiLFxuICBcIlJlZW50cmFuY3lOb3RBbGxvd2VkXCIsXG4gIFwiTWF4U2VlZExlbmd0aEV4Y2VlZGVkXCIsXG4gIFwiSW52YWxpZFNlZWRzXCIsXG4gIFwiSW52YWxpZFJlYWxsb2NcIixcbiAgXCJDb21wdXRhdGlvbmFsQnVkZ2V0RXhjZWVkZWRcIixcbiAgXCJQcml2aWxlZ2VFc2NhbGF0aW9uXCIsXG4gIFwiUHJvZ3JhbUVudmlyb25tZW50U2V0dXBGYWlsdXJlXCIsXG4gIFwiUHJvZ3JhbUZhaWxlZFRvQ29tcGxldGVcIixcbiAgXCJQcm9ncmFtRmFpbGVkVG9Db21waWxlXCIsXG4gIFwiSW1tdXRhYmxlXCIsXG4gIFwiSW5jb3JyZWN0QXV0aG9yaXR5XCIsXG4gIFwiQm9yc2hJb0Vycm9yXCIsXG4gIFwiQWNjb3VudE5vdFJlbnRFeGVtcHRcIixcbiAgXCJJbnZhbGlkQWNjb3VudE93bmVyXCIsXG4gIFwiQXJpdGhtZXRpY092ZXJmbG93XCIsXG4gIFwiVW5zdXBwb3J0ZWRTeXN2YXJcIixcbiAgXCJJbGxlZ2FsT3duZXJcIixcbiAgXCJNYXhBY2NvdW50c0RhdGFBbGxvY2F0aW9uc0V4Y2VlZGVkXCIsXG4gIFwiTWF4QWNjb3VudHNFeGNlZWRlZFwiLFxuICBcIk1heEluc3RydWN0aW9uVHJhY2VMZW5ndGhFeGNlZWRlZFwiLFxuICBcIkJ1aWx0aW5Qcm9ncmFtc011c3RDb25zdW1lQ29tcHV0ZVVuaXRzXCJcbl07XG5mdW5jdGlvbiBnZXRTb2xhbmFFcnJvckZyb21JbnN0cnVjdGlvbkVycm9yKGluZGV4LCBpbnN0cnVjdGlvbkVycm9yKSB7XG4gIGNvbnN0IG51bWJlckluZGV4ID0gTnVtYmVyKGluZGV4KTtcbiAgcmV0dXJuIGdldFNvbGFuYUVycm9yRnJvbVJwY0Vycm9yKFxuICAgIHtcbiAgICAgIGVycm9yQ29kZUJhc2VPZmZzZXQ6IDQ2MTUwMDEsXG4gICAgICBnZXRFcnJvckNvbnRleHQoZXJyb3JDb2RlLCBycGNFcnJvck5hbWUsIHJwY0Vycm9yQ29udGV4dCkge1xuICAgICAgICBpZiAoZXJyb3JDb2RlID09PSBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19VTktOT1dOKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVycm9yTmFtZTogcnBjRXJyb3JOYW1lLFxuICAgICAgICAgICAgaW5kZXg6IG51bWJlckluZGV4LFxuICAgICAgICAgICAgLi4ucnBjRXJyb3JDb250ZXh0ICE9PSB2b2lkIDAgPyB7IGluc3RydWN0aW9uRXJyb3JDb250ZXh0OiBycGNFcnJvckNvbnRleHQgfSA6IG51bGxcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGVycm9yQ29kZSA9PT0gU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQ1VTVE9NKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvZGU6IE51bWJlcihycGNFcnJvckNvbnRleHQpLFxuICAgICAgICAgICAgaW5kZXg6IG51bWJlckluZGV4XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBpbmRleDogbnVtYmVySW5kZXggfTtcbiAgICAgIH0sXG4gICAgICBvcmRlcmVkRXJyb3JOYW1lczogT1JERVJFRF9FUlJPUl9OQU1FUyxcbiAgICAgIHJwY0VudW1FcnJvcjogaW5zdHJ1Y3Rpb25FcnJvclxuICAgIH0sXG4gICAgZ2V0U29sYW5hRXJyb3JGcm9tSW5zdHJ1Y3Rpb25FcnJvclxuICApO1xufVxuXG4vLyBzcmMvdHJhbnNhY3Rpb24tZXJyb3IudHNcbnZhciBPUkRFUkVEX0VSUk9SX05BTUVTMiA9IFtcbiAgLy8gS2VlcCBzeW5jZWQgd2l0aCBSUEMgc291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vYW56YS14eXovYWdhdmUvYmxvYi9tYXN0ZXIvc2RrL3NyYy90cmFuc2FjdGlvbi9lcnJvci5yc1xuICAvLyBJZiB0aGlzIGxpc3QgZXZlciBnZXRzIHRvbyBsYXJnZSwgY29uc2lkZXIgaW1wbGVtZW50aW5nIGEgY29tcHJlc3Npb24gc3RyYXRlZ3kgbGlrZSB0aGlzOlxuICAvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9zdGV2ZWx1c2NoZXIvYWFhN2NiYmI1NDMzYjExOTc5ODM5MDhhNDA4NjBjNDdcbiAgXCJBY2NvdW50SW5Vc2VcIixcbiAgXCJBY2NvdW50TG9hZGVkVHdpY2VcIixcbiAgXCJBY2NvdW50Tm90Rm91bmRcIixcbiAgXCJQcm9ncmFtQWNjb3VudE5vdEZvdW5kXCIsXG4gIFwiSW5zdWZmaWNpZW50RnVuZHNGb3JGZWVcIixcbiAgXCJJbnZhbGlkQWNjb3VudEZvckZlZVwiLFxuICBcIkFscmVhZHlQcm9jZXNzZWRcIixcbiAgXCJCbG9ja2hhc2hOb3RGb3VuZFwiLFxuICAvLyBgSW5zdHJ1Y3Rpb25FcnJvcmAgaW50ZW50aW9uYWxseSBvbWl0dGVkOyBkZWxlZ2F0ZWQgdG8gYGdldFNvbGFuYUVycm9yRnJvbUluc3RydWN0aW9uRXJyb3JgXG4gIFwiQ2FsbENoYWluVG9vRGVlcFwiLFxuICBcIk1pc3NpbmdTaWduYXR1cmVGb3JGZWVcIixcbiAgXCJJbnZhbGlkQWNjb3VudEluZGV4XCIsXG4gIFwiU2lnbmF0dXJlRmFpbHVyZVwiLFxuICBcIkludmFsaWRQcm9ncmFtRm9yRXhlY3V0aW9uXCIsXG4gIFwiU2FuaXRpemVGYWlsdXJlXCIsXG4gIFwiQ2x1c3Rlck1haW50ZW5hbmNlXCIsXG4gIFwiQWNjb3VudEJvcnJvd091dHN0YW5kaW5nXCIsXG4gIFwiV291bGRFeGNlZWRNYXhCbG9ja0Nvc3RMaW1pdFwiLFxuICBcIlVuc3VwcG9ydGVkVmVyc2lvblwiLFxuICBcIkludmFsaWRXcml0YWJsZUFjY291bnRcIixcbiAgXCJXb3VsZEV4Y2VlZE1heEFjY291bnRDb3N0TGltaXRcIixcbiAgXCJXb3VsZEV4Y2VlZEFjY291bnREYXRhQmxvY2tMaW1pdFwiLFxuICBcIlRvb01hbnlBY2NvdW50TG9ja3NcIixcbiAgXCJBZGRyZXNzTG9va3VwVGFibGVOb3RGb3VuZFwiLFxuICBcIkludmFsaWRBZGRyZXNzTG9va3VwVGFibGVPd25lclwiLFxuICBcIkludmFsaWRBZGRyZXNzTG9va3VwVGFibGVEYXRhXCIsXG4gIFwiSW52YWxpZEFkZHJlc3NMb29rdXBUYWJsZUluZGV4XCIsXG4gIFwiSW52YWxpZFJlbnRQYXlpbmdBY2NvdW50XCIsXG4gIFwiV291bGRFeGNlZWRNYXhWb3RlQ29zdExpbWl0XCIsXG4gIFwiV291bGRFeGNlZWRBY2NvdW50RGF0YVRvdGFsTGltaXRcIixcbiAgXCJEdXBsaWNhdGVJbnN0cnVjdGlvblwiLFxuICBcIkluc3VmZmljaWVudEZ1bmRzRm9yUmVudFwiLFxuICBcIk1heExvYWRlZEFjY291bnRzRGF0YVNpemVFeGNlZWRlZFwiLFxuICBcIkludmFsaWRMb2FkZWRBY2NvdW50c0RhdGFTaXplTGltaXRcIixcbiAgXCJSZXNhbml0aXphdGlvbk5lZWRlZFwiLFxuICBcIlByb2dyYW1FeGVjdXRpb25UZW1wb3JhcmlseVJlc3RyaWN0ZWRcIixcbiAgXCJVbmJhbGFuY2VkVHJhbnNhY3Rpb25cIlxuXTtcbmZ1bmN0aW9uIGdldFNvbGFuYUVycm9yRnJvbVRyYW5zYWN0aW9uRXJyb3IodHJhbnNhY3Rpb25FcnJvcikge1xuICBpZiAodHlwZW9mIHRyYW5zYWN0aW9uRXJyb3IgPT09IFwib2JqZWN0XCIgJiYgXCJJbnN0cnVjdGlvbkVycm9yXCIgaW4gdHJhbnNhY3Rpb25FcnJvcikge1xuICAgIHJldHVybiBnZXRTb2xhbmFFcnJvckZyb21JbnN0cnVjdGlvbkVycm9yKFxuICAgICAgLi4udHJhbnNhY3Rpb25FcnJvci5JbnN0cnVjdGlvbkVycm9yXG4gICAgKTtcbiAgfVxuICByZXR1cm4gZ2V0U29sYW5hRXJyb3JGcm9tUnBjRXJyb3IoXG4gICAge1xuICAgICAgZXJyb3JDb2RlQmFzZU9mZnNldDogNzA1MDAwMSxcbiAgICAgIGdldEVycm9yQ29udGV4dChlcnJvckNvZGUsIHJwY0Vycm9yTmFtZSwgcnBjRXJyb3JDb250ZXh0KSB7XG4gICAgICAgIGlmIChlcnJvckNvZGUgPT09IFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1VOS05PV04pIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXJyb3JOYW1lOiBycGNFcnJvck5hbWUsXG4gICAgICAgICAgICAuLi5ycGNFcnJvckNvbnRleHQgIT09IHZvaWQgMCA/IHsgdHJhbnNhY3Rpb25FcnJvckNvbnRleHQ6IHJwY0Vycm9yQ29udGV4dCB9IDogbnVsbFxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoZXJyb3JDb2RlID09PSBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19EVVBMSUNBVEVfSU5TVFJVQ1RJT04pIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5kZXg6IE51bWJlcihycGNFcnJvckNvbnRleHQpXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChlcnJvckNvZGUgPT09IFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOU1VGRklDSUVOVF9GVU5EU19GT1JfUkVOVCB8fCBlcnJvckNvZGUgPT09IFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1BST0dSQU1fRVhFQ1VUSU9OX1RFTVBPUkFSSUxZX1JFU1RSSUNURUQpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWNjb3VudEluZGV4OiBOdW1iZXIocnBjRXJyb3JDb250ZXh0LmFjY291bnRfaW5kZXgpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9yZGVyZWRFcnJvck5hbWVzOiBPUkRFUkVEX0VSUk9SX05BTUVTMixcbiAgICAgIHJwY0VudW1FcnJvcjogdHJhbnNhY3Rpb25FcnJvclxuICAgIH0sXG4gICAgZ2V0U29sYW5hRXJyb3JGcm9tVHJhbnNhY3Rpb25FcnJvclxuICApO1xufVxuXG4vLyBzcmMvanNvbi1ycGMtZXJyb3IudHNcbmZ1bmN0aW9uIGdldFNvbGFuYUVycm9yRnJvbUpzb25ScGNFcnJvcihwdXRhdGl2ZUVycm9yUmVzcG9uc2UpIHtcbiAgbGV0IG91dDtcbiAgaWYgKGlzUnBjRXJyb3JSZXNwb25zZShwdXRhdGl2ZUVycm9yUmVzcG9uc2UpKSB7XG4gICAgY29uc3QgeyBjb2RlOiByYXdDb2RlLCBkYXRhLCBtZXNzYWdlIH0gPSBwdXRhdGl2ZUVycm9yUmVzcG9uc2U7XG4gICAgY29uc3QgY29kZSA9IE51bWJlcihyYXdDb2RlKTtcbiAgICBpZiAoY29kZSA9PT0gU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1NFTkRfVFJBTlNBQ1RJT05fUFJFRkxJR0hUX0ZBSUxVUkUpIHtcbiAgICAgIGNvbnN0IHsgZXJyLCAuLi5wcmVmbGlnaHRFcnJvckNvbnRleHQgfSA9IGRhdGE7XG4gICAgICBjb25zdCBjYXVzZU9iamVjdCA9IGVyciA/IHsgY2F1c2U6IGdldFNvbGFuYUVycm9yRnJvbVRyYW5zYWN0aW9uRXJyb3IoZXJyKSB9IDogbnVsbDtcbiAgICAgIG91dCA9IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfU0VORF9UUkFOU0FDVElPTl9QUkVGTElHSFRfRkFJTFVSRSwge1xuICAgICAgICAuLi5wcmVmbGlnaHRFcnJvckNvbnRleHQsXG4gICAgICAgIC4uLmNhdXNlT2JqZWN0XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGVycm9yQ29udGV4dDtcbiAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICBjYXNlIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX0lOVEVSTkFMX0VSUk9SOlxuICAgICAgICBjYXNlIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX0lOVkFMSURfUEFSQU1TOlxuICAgICAgICBjYXNlIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX0lOVkFMSURfUkVRVUVTVDpcbiAgICAgICAgY2FzZSBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19NRVRIT0RfTk9UX0ZPVU5EOlxuICAgICAgICBjYXNlIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1BBUlNFX0VSUk9SOlxuICAgICAgICBjYXNlIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NDQU5fRVJST1I6XG4gICAgICAgIGNhc2UgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0JMT0NLX0NMRUFORURfVVA6XG4gICAgICAgIGNhc2UgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0JMT0NLX05PVF9BVkFJTEFCTEU6XG4gICAgICAgIGNhc2UgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0JMT0NLX1NUQVRVU19OT1RfQVZBSUxBQkxFX1lFVDpcbiAgICAgICAgY2FzZSBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfS0VZX0VYQ0xVREVEX0ZST01fU0VDT05EQVJZX0lOREVYOlxuICAgICAgICBjYXNlIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9MT05HX1RFUk1fU1RPUkFHRV9TTE9UX1NLSVBQRUQ6XG4gICAgICAgIGNhc2UgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1NMT1RfU0tJUFBFRDpcbiAgICAgICAgY2FzZSBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fUFJFQ09NUElMRV9WRVJJRklDQVRJT05fRkFJTFVSRTpcbiAgICAgICAgY2FzZSBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfVU5TVVBQT1JURURfVFJBTlNBQ1RJT05fVkVSU0lPTjpcbiAgICAgICAgICBlcnJvckNvbnRleHQgPSB7IF9fc2VydmVyTWVzc2FnZTogbWVzc2FnZSB9O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgZXJyb3JDb250ZXh0ID0gZGF0YTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBvdXQgPSBuZXcgU29sYW5hRXJyb3IoY29kZSwgZXJyb3JDb250ZXh0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IHR5cGVvZiBwdXRhdGl2ZUVycm9yUmVzcG9uc2UgPT09IFwib2JqZWN0XCIgJiYgcHV0YXRpdmVFcnJvclJlc3BvbnNlICE9PSBudWxsICYmIFwibWVzc2FnZVwiIGluIHB1dGF0aXZlRXJyb3JSZXNwb25zZSAmJiB0eXBlb2YgcHV0YXRpdmVFcnJvclJlc3BvbnNlLm1lc3NhZ2UgPT09IFwic3RyaW5nXCIgPyBwdXRhdGl2ZUVycm9yUmVzcG9uc2UubWVzc2FnZSA6IFwiTWFsZm9ybWVkIEpTT04tUlBDIGVycm9yIHdpdGggbm8gbWVzc2FnZSBhdHRyaWJ1dGVcIjtcbiAgICBvdXQgPSBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19NQUxGT1JNRURfSlNPTl9SUENfRVJST1IsIHsgZXJyb3I6IHB1dGF0aXZlRXJyb3JSZXNwb25zZSwgbWVzc2FnZSB9KTtcbiAgfVxuICBzYWZlQ2FwdHVyZVN0YWNrVHJhY2Uob3V0LCBnZXRTb2xhbmFFcnJvckZyb21Kc29uUnBjRXJyb3IpO1xuICByZXR1cm4gb3V0O1xufVxuZnVuY3Rpb24gaXNScGNFcnJvclJlc3BvbnNlKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwgJiYgXCJjb2RlXCIgaW4gdmFsdWUgJiYgXCJtZXNzYWdlXCIgaW4gdmFsdWUgJiYgKHR5cGVvZiB2YWx1ZS5jb2RlID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiB2YWx1ZS5jb2RlID09PSBcImJpZ2ludFwiKSAmJiB0eXBlb2YgdmFsdWUubWVzc2FnZSA9PT0gXCJzdHJpbmdcIjtcbn1cblxuLy8gc3JjL3NpbXVsYXRpb24tZXJyb3JzLnRzXG5mdW5jdGlvbiB1bndyYXBTaW11bGF0aW9uRXJyb3IoZXJyb3IpIHtcbiAgY29uc3Qgc2ltdWxhdGlvbkNvZGVzID0gW1xuICAgIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9TRU5EX1RSQU5TQUNUSU9OX1BSRUZMSUdIVF9GQUlMVVJFLFxuICAgIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9XSEVOX1NJTVVMQVRJTkdfVE9fRVNUSU1BVEVfQ09NUFVURV9MSU1JVFxuICBdO1xuICBpZiAoaXNTb2xhbmFFcnJvcihlcnJvcikgJiYgISFlcnJvci5jYXVzZSAmJiBzaW11bGF0aW9uQ29kZXMuaW5jbHVkZXMoZXJyb3IuY29udGV4dC5fX2NvZGUpKSB7XG4gICAgcmV0dXJuIGVycm9yLmNhdXNlO1xuICB9XG4gIHJldHVybiBlcnJvcjtcbn1cblxuZXhwb3J0IHsgU09MQU5BX0VSUk9SX19BQ0NPVU5UU19fQUNDT1VOVF9OT1RfRk9VTkQsIFNPTEFOQV9FUlJPUl9fQUNDT1VOVFNfX0VYUEVDVEVEX0FMTF9BQ0NPVU5UU19UT19CRV9ERUNPREVELCBTT0xBTkFfRVJST1JfX0FDQ09VTlRTX19FWFBFQ1RFRF9ERUNPREVEX0FDQ09VTlQsIFNPTEFOQV9FUlJPUl9fQUNDT1VOVFNfX0ZBSUxFRF9UT19ERUNPREVfQUNDT1VOVCwgU09MQU5BX0VSUk9SX19BQ0NPVU5UU19fT05FX09SX01PUkVfQUNDT1VOVFNfTk9UX0ZPVU5ELCBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fRkFJTEVEX1RPX0ZJTkRfVklBQkxFX1BEQV9CVU1QX1NFRUQsIFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19JTlZBTElEX0JBU0U1OF9FTkNPREVEX0FERFJFU1MsIFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19JTlZBTElEX0JZVEVfTEVOR1RILCBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fSU5WQUxJRF9FRDI1NTE5X1BVQkxJQ19LRVksIFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19JTlZBTElEX09GRl9DVVJWRV9BRERSRVNTLCBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fSU5WQUxJRF9TRUVEU19QT0lOVF9PTl9DVVJWRSwgU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX01BTEZPUk1FRF9QREEsIFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19NQVhfTlVNQkVSX09GX1BEQV9TRUVEU19FWENFRURFRCwgU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX01BWF9QREFfU0VFRF9MRU5HVEhfRVhDRUVERUQsIFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19QREFfQlVNUF9TRUVEX09VVF9PRl9SQU5HRSwgU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX1BEQV9FTkRTX1dJVEhfUERBX01BUktFUiwgU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX1NUUklOR19MRU5HVEhfT1VUX09GX1JBTkdFLCBTT0xBTkFfRVJST1JfX0JMT0NLSEFTSF9TVFJJTkdfTEVOR1RIX09VVF9PRl9SQU5HRSwgU09MQU5BX0VSUk9SX19CTE9DS19IRUlHSFRfRVhDRUVERUQsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19DQU5OT1RfREVDT0RFX0VNUFRZX0JZVEVfQVJSQVksIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19DQU5OT1RfVVNFX0xFWElDQUxfVkFMVUVTX0FTX0VOVU1fRElTQ1JJTUlOQVRPUlMsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVEX0JZVEVTX01VU1RfTk9UX0lOQ0xVREVfU0VOVElORUwsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfRklYRURfU0laRV9NSVNNQVRDSCwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9NQVhfU0laRV9NSVNNQVRDSCwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9TSVpFX0NPTVBBVElCSUxJVFlfTUlTTUFUQ0gsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTlVNX0RJU0NSSU1JTkFUT1JfT1VUX09GX1JBTkdFLCBTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfREVDT0RFUl9UT19DT05TVU1FX0VOVElSRV9CWVRFX0FSUkFZLCBTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfRklYRURfTEVOR1RILCBTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfUE9TSVRJVkVfQllURV9MRU5HVEgsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9WQVJJQUJMRV9MRU5HVEgsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9aRVJPX1ZBTFVFX1RPX01BVENIX0lURU1fRklYRURfU0laRSwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfQllURV9MRU5HVEgsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0NPTlNUQU5ULCBTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9ESVNDUklNSU5BVEVEX1VOSU9OX1ZBUklBTlQsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0VOVU1fVkFSSUFOVCwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfTElURVJBTF9VTklPTl9WQVJJQU5ULCBTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9OVU1CRVJfT0ZfSVRFTVMsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX1NUUklOR19GT1JfQkFTRSwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0xJVEVSQUxfVU5JT05fRElTQ1JJTUlOQVRPUl9PVVRfT0ZfUkFOR0UsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19OVU1CRVJfT1VUX09GX1JBTkdFLCBTT0xBTkFfRVJST1JfX0NPREVDU19fT0ZGU0VUX09VVF9PRl9SQU5HRSwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX1NFTlRJTkVMX01JU1NJTkdfSU5fREVDT0RFRF9CWVRFUywgU09MQU5BX0VSUk9SX19DT0RFQ1NfX1VOSU9OX1ZBUklBTlRfT1VUX09GX1JBTkdFLCBTT0xBTkFfRVJST1JfX0NSWVBUT19fUkFORE9NX1ZBTFVFU19GVU5DVElPTl9VTklNUExFTUVOVEVELCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BQ0NPVU5UX0FMUkVBRFlfSU5JVElBTElaRUQsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfQk9SUk9XX0ZBSUxFRCwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9CT1JST1dfT1VUU1RBTkRJTkcsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfREFUQV9TSVpFX0NIQU5HRUQsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfREFUQV9UT09fU01BTEwsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfTk9UX0VYRUNVVEFCTEUsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfTk9UX1JFTlRfRVhFTVBULCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BUklUSE1FVElDX09WRVJGTE9XLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19CT1JTSF9JT19FUlJPUiwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQlVJTFRJTl9QUk9HUkFNU19NVVNUX0NPTlNVTUVfQ09NUFVURV9VTklUUywgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQ0FMTF9ERVBUSCwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQ09NUFVUQVRJT05BTF9CVURHRVRfRVhDRUVERUQsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0NVU1RPTSwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRFVQTElDQVRFX0FDQ09VTlRfSU5ERVgsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0RVUExJQ0FURV9BQ0NPVU5UX09VVF9PRl9TWU5DLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19FWEVDVVRBQkxFX0FDQ09VTlRfTk9UX1JFTlRfRVhFTVBULCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19FWEVDVVRBQkxFX0RBVEFfTU9ESUZJRUQsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0VYRUNVVEFCTEVfTEFNUE9SVF9DSEFOR0UsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0VYRUNVVEFCTEVfTU9ESUZJRUQsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0VYVEVSTkFMX0FDQ09VTlRfREFUQV9NT0RJRklFRCwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRVhURVJOQUxfQUNDT1VOVF9MQU1QT1JUX1NQRU5ELCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19HRU5FUklDX0VSUk9SLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTExFR0FMX09XTkVSLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTU1VVEFCTEUsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOQ09SUkVDVF9BVVRIT1JJVFksIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOQ09SUkVDVF9QUk9HUkFNX0lELCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlNVRkZJQ0lFTlRfRlVORFMsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfQUNDT1VOVF9EQVRBLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX0FDQ09VTlRfT1dORVIsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfQVJHVU1FTlQsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfRVJST1IsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfSU5TVFJVQ1RJT05fREFUQSwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9SRUFMTE9DLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX1NFRURTLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19NQVhfQUNDT1VOVFNfREFUQV9BTExPQ0FUSU9OU19FWENFRURFRCwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTUFYX0FDQ09VTlRTX0VYQ0VFREVELCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19NQVhfSU5TVFJVQ1RJT05fVFJBQ0VfTEVOR1RIX0VYQ0VFREVELCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19NQVhfU0VFRF9MRU5HVEhfRVhDRUVERUQsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01JU1NJTkdfQUNDT1VOVCwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTUlTU0lOR19SRVFVSVJFRF9TSUdOQVRVUkUsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01PRElGSUVEX1BST0dSQU1fSUQsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX05PVF9FTk9VR0hfQUNDT1VOVF9LRVlTLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19QUklWSUxFR0VfRVNDQUxBVElPTiwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUFJPR1JBTV9FTlZJUk9OTUVOVF9TRVRVUF9GQUlMVVJFLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19QUk9HUkFNX0ZBSUxFRF9UT19DT01QSUxFLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19QUk9HUkFNX0ZBSUxFRF9UT19DT01QTEVURSwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUkVBRE9OTFlfREFUQV9NT0RJRklFRCwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUkVBRE9OTFlfTEFNUE9SVF9DSEFOR0UsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1JFRU5UUkFOQ1lfTk9UX0FMTE9XRUQsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1JFTlRfRVBPQ0hfTU9ESUZJRUQsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1VOQkFMQU5DRURfSU5TVFJVQ1RJT04sIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1VOSU5JVElBTElaRURfQUNDT1VOVCwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fVU5LTk9XTiwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fVU5TVVBQT1JURURfUFJPR1JBTV9JRCwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fVU5TVVBQT1JURURfU1lTVkFSLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX1BMQU5TX19FTVBUWV9JTlNUUlVDVElPTl9QTEFOLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX1BMQU5TX19FWFBFQ1RFRF9TVUNDRVNTRlVMX1RSQU5TQUNUSU9OX1BMQU5fUkVTVUxULCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX1BMQU5TX19GQUlMRURfU0lOR0xFX1RSQU5TQUNUSU9OX1BMQU5fUkVTVUxUX05PVF9GT1VORCwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9QTEFOU19fRkFJTEVEX1RPX0VYRUNVVEVfVFJBTlNBQ1RJT05fUExBTiwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9QTEFOU19fTUVTU0FHRV9DQU5OT1RfQUNDT01NT0RBVEVfUExBTiwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9QTEFOU19fTUVTU0FHRV9QQUNLRVJfQUxSRUFEWV9DT01QTEVURSwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9QTEFOU19fTk9OX0RJVklTSUJMRV9UUkFOU0FDVElPTl9QTEFOU19OT1RfU1VQUE9SVEVELCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX1BMQU5TX19VTkVYUEVDVEVEX0lOU1RSVUNUSU9OX1BMQU4sIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fUExBTlNfX1VORVhQRUNURURfVFJBTlNBQ1RJT05fUExBTiwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9QTEFOU19fVU5FWFBFQ1RFRF9UUkFOU0FDVElPTl9QTEFOX1JFU1VMVCwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9fRVhQRUNURURfVE9fSEFWRV9BQ0NPVU5UUywgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9fRVhQRUNURURfVE9fSEFWRV9EQVRBLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX19QUk9HUkFNX0lEX01JU01BVENILCBTT0xBTkFfRVJST1JfX0lOVkFMSURfQkxPQ0tIQVNIX0JZVEVfTEVOR1RILCBTT0xBTkFfRVJST1JfX0lOVkFMSURfTk9OQ0UsIFNPTEFOQV9FUlJPUl9fSU5WQVJJQU5UX1ZJT0xBVElPTl9fQ0FDSEVEX0FCT1JUQUJMRV9JVEVSQUJMRV9DQUNIRV9FTlRSWV9NSVNTSU5HLCBTT0xBTkFfRVJST1JfX0lOVkFSSUFOVF9WSU9MQVRJT05fX0RBVEFfUFVCTElTSEVSX0NIQU5ORUxfVU5JTVBMRU1FTlRFRCwgU09MQU5BX0VSUk9SX19JTlZBUklBTlRfVklPTEFUSU9OX19JTlZBTElEX0lOU1RSVUNUSU9OX1BMQU5fS0lORCwgU09MQU5BX0VSUk9SX19JTlZBUklBTlRfVklPTEFUSU9OX19JTlZBTElEX1RSQU5TQUNUSU9OX1BMQU5fS0lORCwgU09MQU5BX0VSUk9SX19JTlZBUklBTlRfVklPTEFUSU9OX19TVUJTQ1JJUFRJT05fSVRFUkFUT1JfTVVTVF9OT1RfUE9MTF9CRUZPUkVfUkVTT0xWSU5HX0VYSVNUSU5HX01FU1NBR0VfUFJPTUlTRSwgU09MQU5BX0VSUk9SX19JTlZBUklBTlRfVklPTEFUSU9OX19TVUJTQ1JJUFRJT05fSVRFUkFUT1JfU1RBVEVfTUlTU0lORywgU09MQU5BX0VSUk9SX19JTlZBUklBTlRfVklPTEFUSU9OX19TV0lUQ0hfTVVTVF9CRV9FWEhBVVNUSVZFLCBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19JTlRFUk5BTF9FUlJPUiwgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fSU5WQUxJRF9QQVJBTVMsIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX0lOVkFMSURfUkVRVUVTVCwgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fTUVUSE9EX05PVF9GT1VORCwgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fUEFSU0VfRVJST1IsIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NDQU5fRVJST1IsIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9CTE9DS19DTEVBTkVEX1VQLCBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfQkxPQ0tfTk9UX0FWQUlMQUJMRSwgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0JMT0NLX1NUQVRVU19OT1RfQVZBSUxBQkxFX1lFVCwgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0VQT0NIX1JFV0FSRFNfUEVSSU9EX0FDVElWRSwgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0tFWV9FWENMVURFRF9GUk9NX1NFQ09OREFSWV9JTkRFWCwgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0xPTkdfVEVSTV9TVE9SQUdFX1NMT1RfU0tJUFBFRCwgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0xPTkdfVEVSTV9TVE9SQUdFX1VOUkVBQ0hBQkxFLCBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfTUlOX0NPTlRFWFRfU0xPVF9OT1RfUkVBQ0hFRCwgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX05PREVfVU5IRUFMVEhZLCBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfTk9fU05BUFNIT1QsIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9TRU5EX1RSQU5TQUNUSU9OX1BSRUZMSUdIVF9GQUlMVVJFLCBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfU0xPVF9OT1RfRVBPQ0hfQk9VTkRBUlksIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9TTE9UX1NLSVBQRUQsIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9ISVNUT1JZX05PVF9BVkFJTEFCTEUsIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9QUkVDT01QSUxFX1ZFUklGSUNBVElPTl9GQUlMVVJFLCBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fU0lHTkFUVVJFX0xFTl9NSVNNQVRDSCwgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX1NJR05BVFVSRV9WRVJJRklDQVRJT05fRkFJTFVSRSwgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1VOU1VQUE9SVEVEX1RSQU5TQUNUSU9OX1ZFUlNJT04sIFNPTEFOQV9FUlJPUl9fS0VZU19fSU5WQUxJRF9LRVlfUEFJUl9CWVRFX0xFTkdUSCwgU09MQU5BX0VSUk9SX19LRVlTX19JTlZBTElEX1BSSVZBVEVfS0VZX0JZVEVfTEVOR1RILCBTT0xBTkFfRVJST1JfX0tFWVNfX0lOVkFMSURfU0lHTkFUVVJFX0JZVEVfTEVOR1RILCBTT0xBTkFfRVJST1JfX0tFWVNfX1BVQkxJQ19LRVlfTVVTVF9NQVRDSF9QUklWQVRFX0tFWSwgU09MQU5BX0VSUk9SX19LRVlTX19TSUdOQVRVUkVfU1RSSU5HX0xFTkdUSF9PVVRfT0ZfUkFOR0UsIFNPTEFOQV9FUlJPUl9fTEFNUE9SVFNfT1VUX09GX1JBTkdFLCBTT0xBTkFfRVJST1JfX01BTEZPUk1FRF9CSUdJTlRfU1RSSU5HLCBTT0xBTkFfRVJST1JfX01BTEZPUk1FRF9KU09OX1JQQ19FUlJPUiwgU09MQU5BX0VSUk9SX19NQUxGT1JNRURfTlVNQkVSX1NUUklORywgU09MQU5BX0VSUk9SX19OT05DRV9BQ0NPVU5UX05PVF9GT1VORCwgU09MQU5BX0VSUk9SX19PRkZDSEFJTl9NRVNTQUdFX19BRERSRVNTRVNfQ0FOTk9UX1NJR05fT0ZGQ0hBSU5fTUVTU0FHRSwgU09MQU5BX0VSUk9SX19PRkZDSEFJTl9NRVNTQUdFX19BUFBMSUNBVElPTl9ET01BSU5fU1RSSU5HX0xFTkdUSF9PVVRfT0ZfUkFOR0UsIFNPTEFOQV9FUlJPUl9fT0ZGQ0hBSU5fTUVTU0FHRV9fRU5WRUxPUEVfU0lHTkVSU19NSVNNQVRDSCwgU09MQU5BX0VSUk9SX19PRkZDSEFJTl9NRVNTQUdFX19JTlZBTElEX0FQUExJQ0FUSU9OX0RPTUFJTl9CWVRFX0xFTkdUSCwgU09MQU5BX0VSUk9SX19PRkZDSEFJTl9NRVNTQUdFX19NQVhJTVVNX0xFTkdUSF9FWENFRURFRCwgU09MQU5BX0VSUk9SX19PRkZDSEFJTl9NRVNTQUdFX19NRVNTQUdFX0ZPUk1BVF9NSVNNQVRDSCwgU09MQU5BX0VSUk9SX19PRkZDSEFJTl9NRVNTQUdFX19NRVNTQUdFX0xFTkdUSF9NSVNNQVRDSCwgU09MQU5BX0VSUk9SX19PRkZDSEFJTl9NRVNTQUdFX19NRVNTQUdFX01VU1RfQkVfTk9OX0VNUFRZLCBTT0xBTkFfRVJST1JfX09GRkNIQUlOX01FU1NBR0VfX05VTV9FTlZFTE9QRV9TSUdOQVRVUkVTX0NBTk5PVF9CRV9aRVJPLCBTT0xBTkFfRVJST1JfX09GRkNIQUlOX01FU1NBR0VfX05VTV9SRVFVSVJFRF9TSUdORVJTX0NBTk5PVF9CRV9aRVJPLCBTT0xBTkFfRVJST1JfX09GRkNIQUlOX01FU1NBR0VfX05VTV9TSUdOQVRVUkVTX01JU01BVENILCBTT0xBTkFfRVJST1JfX09GRkNIQUlOX01FU1NBR0VfX1JFU1RSSUNURURfQVNDSUlfQk9EWV9DSEFSQUNURVJfT1VUX09GX1JBTkdFLCBTT0xBTkFfRVJST1JfX09GRkNIQUlOX01FU1NBR0VfX1NJR05BVE9SSUVTX01VU1RfQkVfU09SVEVELCBTT0xBTkFfRVJST1JfX09GRkNIQUlOX01FU1NBR0VfX1NJR05BVE9SSUVTX01VU1RfQkVfVU5JUVVFLCBTT0xBTkFfRVJST1JfX09GRkNIQUlOX01FU1NBR0VfX1NJR05BVFVSRVNfTUlTU0lORywgU09MQU5BX0VSUk9SX19PRkZDSEFJTl9NRVNTQUdFX19TSUdOQVRVUkVfVkVSSUZJQ0FUSU9OX0ZBSUxVUkUsIFNPTEFOQV9FUlJPUl9fT0ZGQ0hBSU5fTUVTU0FHRV9fVU5FWFBFQ1RFRF9WRVJTSU9OLCBTT0xBTkFfRVJST1JfX09GRkNIQUlOX01FU1NBR0VfX1ZFUlNJT05fTlVNQkVSX05PVF9TVVBQT1JURUQsIFNPTEFOQV9FUlJPUl9fUlBDX1NVQlNDUklQVElPTlNfX0NBTk5PVF9DUkVBVEVfU1VCU0NSSVBUSU9OX1BMQU4sIFNPTEFOQV9FUlJPUl9fUlBDX1NVQlNDUklQVElPTlNfX0NIQU5ORUxfQ0xPU0VEX0JFRk9SRV9NRVNTQUdFX0JVRkZFUkVELCBTT0xBTkFfRVJST1JfX1JQQ19TVUJTQ1JJUFRJT05TX19DSEFOTkVMX0NPTk5FQ1RJT05fQ0xPU0VELCBTT0xBTkFfRVJST1JfX1JQQ19TVUJTQ1JJUFRJT05TX19DSEFOTkVMX0ZBSUxFRF9UT19DT05ORUNULCBTT0xBTkFfRVJST1JfX1JQQ19TVUJTQ1JJUFRJT05TX19FWFBFQ1RFRF9TRVJWRVJfU1VCU0NSSVBUSU9OX0lELCBTT0xBTkFfRVJST1JfX1JQQ19fQVBJX1BMQU5fTUlTU0lOR19GT1JfUlBDX01FVEhPRCwgU09MQU5BX0VSUk9SX19SUENfX0lOVEVHRVJfT1ZFUkZMT1csIFNPTEFOQV9FUlJPUl9fUlBDX19UUkFOU1BPUlRfSFRUUF9FUlJPUiwgU09MQU5BX0VSUk9SX19SUENfX1RSQU5TUE9SVF9IVFRQX0hFQURFUl9GT1JCSURERU4sIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19BRERSRVNTX0NBTk5PVF9IQVZFX01VTFRJUExFX1NJR05FUlMsIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9LRVlfUEFJUl9TSUdORVIsIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9NRVNTQUdFX01PRElGWUlOR19TSUdORVIsIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9NRVNTQUdFX1BBUlRJQUxfU0lHTkVSLCBTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfTUVTU0FHRV9TSUdORVIsIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9UUkFOU0FDVElPTl9NT0RJRllJTkdfU0lHTkVSLCBTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfVFJBTlNBQ1RJT05fUEFSVElBTF9TSUdORVIsIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9UUkFOU0FDVElPTl9TRU5ESU5HX1NJR05FUiwgU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX1RSQU5TQUNUSU9OX1NJR05FUiwgU09MQU5BX0VSUk9SX19TSUdORVJfX1RSQU5TQUNUSU9OX0NBTk5PVF9IQVZFX01VTFRJUExFX1NFTkRJTkdfU0lHTkVSUywgU09MQU5BX0VSUk9SX19TSUdORVJfX1RSQU5TQUNUSU9OX1NFTkRJTkdfU0lHTkVSX01JU1NJTkcsIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19XQUxMRVRfTVVMVElTSUdOX1VOSU1QTEVNRU5URUQsIFNPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fQ0FOTk9UX0VYUE9SVF9OT05fRVhUUkFDVEFCTEVfS0VZLCBTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX0RJR0VTVF9VTklNUExFTUVOVEVELCBTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX0RJU0FMTE9XRURfSU5fSU5TRUNVUkVfQ09OVEVYVCwgU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19FRDI1NTE5X0FMR09SSVRITV9VTklNUExFTUVOVEVELCBTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX0VYUE9SVF9GVU5DVElPTl9VTklNUExFTUVOVEVELCBTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX0dFTkVSQVRFX0ZVTkNUSU9OX1VOSU1QTEVNRU5URUQsIFNPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fU0lHTl9GVU5DVElPTl9VTklNUExFTUVOVEVELCBTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX1ZFUklGWV9GVU5DVElPTl9VTklNUExFTUVOVEVELCBTT0xBTkFfRVJST1JfX1RJTUVTVEFNUF9PVVRfT0ZfUkFOR0UsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0FDQ09VTlRfQk9SUk9XX09VVFNUQU5ESU5HLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19BQ0NPVU5UX0lOX1VTRSwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQUNDT1VOVF9MT0FERURfVFdJQ0UsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0FDQ09VTlRfTk9UX0ZPVU5ELCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19BRERSRVNTX0xPT0tVUF9UQUJMRV9OT1RfRk9VTkQsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0FMUkVBRFlfUFJPQ0VTU0VELCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19CTE9DS0hBU0hfTk9UX0ZPVU5ELCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19DQUxMX0NIQUlOX1RPT19ERUVQLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19DTFVTVEVSX01BSU5URU5BTkNFLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19EVVBMSUNBVEVfSU5TVFJVQ1RJT04sIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOU1VGRklDSUVOVF9GVU5EU19GT1JfRkVFLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlNVRkZJQ0lFTlRfRlVORFNfRk9SX1JFTlQsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfQUNDT1VOVF9GT1JfRkVFLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX0FDQ09VTlRfSU5ERVgsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfQUREUkVTU19MT09LVVBfVEFCTEVfREFUQSwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9BRERSRVNTX0xPT0tVUF9UQUJMRV9JTkRFWCwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9BRERSRVNTX0xPT0tVUF9UQUJMRV9PV05FUiwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9MT0FERURfQUNDT1VOVFNfREFUQV9TSVpFX0xJTUlULCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX1BST0dSQU1fRk9SX0VYRUNVVElPTiwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9SRU5UX1BBWUlOR19BQ0NPVU5ULCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX1dSSVRBQkxFX0FDQ09VTlQsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX01BWF9MT0FERURfQUNDT1VOVFNfREFUQV9TSVpFX0VYQ0VFREVELCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19NSVNTSU5HX1NJR05BVFVSRV9GT1JfRkVFLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19QUk9HUkFNX0FDQ09VTlRfTk9UX0ZPVU5ELCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19QUk9HUkFNX0VYRUNVVElPTl9URU1QT1JBUklMWV9SRVNUUklDVEVELCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19SRVNBTklUSVpBVElPTl9ORUVERUQsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1NBTklUSVpFX0ZBSUxVUkUsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1NJR05BVFVSRV9GQUlMVVJFLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19UT09fTUFOWV9BQ0NPVU5UX0xPQ0tTLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19VTkJBTEFOQ0VEX1RSQU5TQUNUSU9OLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19VTktOT1dOLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19VTlNVUFBPUlRFRF9WRVJTSU9OLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19XT1VMRF9FWENFRURfQUNDT1VOVF9EQVRBX0JMT0NLX0xJTUlULCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19XT1VMRF9FWENFRURfQUNDT1VOVF9EQVRBX1RPVEFMX0xJTUlULCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19XT1VMRF9FWENFRURfTUFYX0FDQ09VTlRfQ09TVF9MSU1JVCwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fV09VTERfRVhDRUVEX01BWF9CTE9DS19DT1NUX0xJTUlULCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19XT1VMRF9FWENFRURfTUFYX1ZPVEVfQ09TVF9MSU1JVCwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fQUREUkVTU0VTX0NBTk5PVF9TSUdOX1RSQU5TQUNUSU9OLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19BRERSRVNTX01JU1NJTkcsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0NBTk5PVF9FTkNPREVfV0lUSF9FTVBUWV9TSUdOQVRVUkVTLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19FWENFRURTX1NJWkVfTElNSVQsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0VYUEVDVEVEX0JMT0NLSEFTSF9MSUZFVElNRSwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRVhQRUNURURfTk9OQ0VfTElGRVRJTUUsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9UT19ERUNPTVBJTEVfQUREUkVTU19MT09LVVBfVEFCTEVfQ09OVEVOVFNfTUlTU0lORywgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkFJTEVEX1RPX0RFQ09NUElMRV9BRERSRVNTX0xPT0tVUF9UQUJMRV9JTkRFWF9PVVRfT0ZfUkFOR0UsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9UT19ERUNPTVBJTEVfRkVFX1BBWUVSX01JU1NJTkcsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9UT19ERUNPTVBJTEVfSU5TVFJVQ1RJT05fUFJPR1JBTV9BRERSRVNTX05PVF9GT1VORCwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkFJTEVEX1RPX0VTVElNQVRFX0NPTVBVVEVfTElNSVQsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9XSEVOX1NJTVVMQVRJTkdfVE9fRVNUSU1BVEVfQ09NUFVURV9MSU1JVCwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkVFX1BBWUVSX01JU1NJTkcsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZFRV9QQVlFUl9TSUdOQVRVUkVfTUlTU0lORywgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fSU5WQUxJRF9OT05DRV9UUkFOU0FDVElPTl9GSVJTVF9JTlNUUlVDVElPTl9NVVNUX0JFX0FEVkFOQ0VfTk9OQ0UsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0lOVkFMSURfTk9OQ0VfVFJBTlNBQ1RJT05fSU5TVFJVQ1RJT05TX01JU1NJTkcsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0lOVk9LRURfUFJPR1JBTVNfQ0FOTk9UX1BBWV9GRUVTLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19JTlZPS0VEX1BST0dSQU1TX01VU1RfTk9UX0JFX1dSSVRBQkxFLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19NRVNTQUdFX1NJR05BVFVSRVNfTUlTTUFUQ0gsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX05PTkNFX0FDQ09VTlRfQ0FOTk9UX0JFX0lOX0xPT0tVUF9UQUJMRSwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fU0lHTkFUVVJFU19NSVNTSU5HLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19WRVJTSU9OX05VTUJFUl9OT1RfU1VQUE9SVEVELCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19WRVJTSU9OX05VTUJFUl9PVVRfT0ZfUkFOR0UsIFNvbGFuYUVycm9yLCBnZXRTb2xhbmFFcnJvckZyb21JbnN0cnVjdGlvbkVycm9yLCBnZXRTb2xhbmFFcnJvckZyb21Kc29uUnBjRXJyb3IsIGdldFNvbGFuYUVycm9yRnJvbVRyYW5zYWN0aW9uRXJyb3IsIGlzU29sYW5hRXJyb3IsIHNhZmVDYXB0dXJlU3RhY2tUcmFjZSwgdW53cmFwU2ltdWxhdGlvbkVycm9yIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5ub2RlLm1qcy5tYXBcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm5vZGUubWpzLm1hcCJdLCJuYW1lcyI6WyJTT0xBTkFfRVJST1JfX0JMT0NLX0hFSUdIVF9FWENFRURFRCIsIlNPTEFOQV9FUlJPUl9fSU5WQUxJRF9OT05DRSIsIlNPTEFOQV9FUlJPUl9fTk9OQ0VfQUNDT1VOVF9OT1RfRk9VTkQiLCJTT0xBTkFfRVJST1JfX0JMT0NLSEFTSF9TVFJJTkdfTEVOR1RIX09VVF9PRl9SQU5HRSIsIlNPTEFOQV9FUlJPUl9fSU5WQUxJRF9CTE9DS0hBU0hfQllURV9MRU5HVEgiLCJTT0xBTkFfRVJST1JfX0xBTVBPUlRTX09VVF9PRl9SQU5HRSIsIlNPTEFOQV9FUlJPUl9fTUFMRk9STUVEX0JJR0lOVF9TVFJJTkciLCJTT0xBTkFfRVJST1JfX01BTEZPUk1FRF9OVU1CRVJfU1RSSU5HIiwiU09MQU5BX0VSUk9SX19USU1FU1RBTVBfT1VUX09GX1JBTkdFIiwiU09MQU5BX0VSUk9SX19NQUxGT1JNRURfSlNPTl9SUENfRVJST1IiLCJTT0xBTkFfRVJST1JfX0pTT05fUlBDX19QQVJTRV9FUlJPUiIsIlNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX0lOVEVSTkFMX0VSUk9SIiwiU09MQU5BX0VSUk9SX19KU09OX1JQQ19fSU5WQUxJRF9QQVJBTVMiLCJTT0xBTkFfRVJST1JfX0pTT05fUlBDX19NRVRIT0RfTk9UX0ZPVU5EIiwiU09MQU5BX0VSUk9SX19KU09OX1JQQ19fSU5WQUxJRF9SRVFVRVNUIiwiU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0xPTkdfVEVSTV9TVE9SQUdFX1VOUkVBQ0hBQkxFIiwiU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1NMT1RfTk9UX0VQT0NIX0JPVU5EQVJZIiwiU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0VQT0NIX1JFV0FSRFNfUEVSSU9EX0FDVElWRSIsIlNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9NSU5fQ09OVEVYVF9TTE9UX05PVF9SRUFDSEVEIiwiU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1VOU1VQUE9SVEVEX1RSQU5TQUNUSU9OX1ZFUlNJT04iLCJTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfQkxPQ0tfU1RBVFVTX05PVF9BVkFJTEFCTEVfWUVUIiwiU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX1NJR05BVFVSRV9MRU5fTUlTTUFUQ0giLCJTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TQ0FOX0VSUk9SIiwiU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX0hJU1RPUllfTk9UX0FWQUlMQUJMRSIsIlNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9LRVlfRVhDTFVERURfRlJPTV9TRUNPTkRBUllfSU5ERVgiLCJTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfTE9OR19URVJNX1NUT1JBR0VfU0xPVF9TS0lQUEVEIiwiU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX05PX1NOQVBTSE9UIiwiU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1NMT1RfU0tJUFBFRCIsIlNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9QUkVDT01QSUxFX1ZFUklGSUNBVElPTl9GQUlMVVJFIiwiU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX05PREVfVU5IRUFMVEhZIiwiU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0JMT0NLX05PVF9BVkFJTEFCTEUiLCJTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fU0lHTkFUVVJFX1ZFUklGSUNBVElPTl9GQUlMVVJFIiwiU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1NFTkRfVFJBTlNBQ1RJT05fUFJFRkxJR0hUX0ZBSUxVUkUiLCJTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfQkxPQ0tfQ0xFQU5FRF9VUCIsIlNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19JTlZBTElEX0JZVEVfTEVOR1RIIiwiU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX1NUUklOR19MRU5HVEhfT1VUX09GX1JBTkdFIiwiU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX0lOVkFMSURfQkFTRTU4X0VOQ09ERURfQUREUkVTUyIsIlNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19JTlZBTElEX0VEMjU1MTlfUFVCTElDX0tFWSIsIlNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19NQUxGT1JNRURfUERBIiwiU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX1BEQV9CVU1QX1NFRURfT1VUX09GX1JBTkdFIiwiU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX01BWF9OVU1CRVJfT0ZfUERBX1NFRURTX0VYQ0VFREVEIiwiU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX01BWF9QREFfU0VFRF9MRU5HVEhfRVhDRUVERUQiLCJTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fSU5WQUxJRF9TRUVEU19QT0lOVF9PTl9DVVJWRSIsIlNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19GQUlMRURfVE9fRklORF9WSUFCTEVfUERBX0JVTVBfU0VFRCIsIlNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19QREFfRU5EU19XSVRIX1BEQV9NQVJLRVIiLCJTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fSU5WQUxJRF9PRkZfQ1VSVkVfQUREUkVTUyIsIlNPTEFOQV9FUlJPUl9fQUNDT1VOVFNfX0FDQ09VTlRfTk9UX0ZPVU5EIiwiU09MQU5BX0VSUk9SX19BQ0NPVU5UU19fT05FX09SX01PUkVfQUNDT1VOVFNfTk9UX0ZPVU5EIiwiU09MQU5BX0VSUk9SX19BQ0NPVU5UU19fRkFJTEVEX1RPX0RFQ09ERV9BQ0NPVU5UIiwiU09MQU5BX0VSUk9SX19BQ0NPVU5UU19fRVhQRUNURURfREVDT0RFRF9BQ0NPVU5UIiwiU09MQU5BX0VSUk9SX19BQ0NPVU5UU19fRVhQRUNURURfQUxMX0FDQ09VTlRTX1RPX0JFX0RFQ09ERUQiLCJTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX0RJU0FMTE9XRURfSU5fSU5TRUNVUkVfQ09OVEVYVCIsIlNPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fRElHRVNUX1VOSU1QTEVNRU5URUQiLCJTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX0VEMjU1MTlfQUxHT1JJVEhNX1VOSU1QTEVNRU5URUQiLCJTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX0VYUE9SVF9GVU5DVElPTl9VTklNUExFTUVOVEVEIiwiU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19HRU5FUkFURV9GVU5DVElPTl9VTklNUExFTUVOVEVEIiwiU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19TSUdOX0ZVTkNUSU9OX1VOSU1QTEVNRU5URUQiLCJTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX1ZFUklGWV9GVU5DVElPTl9VTklNUExFTUVOVEVEIiwiU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19DQU5OT1RfRVhQT1JUX05PTl9FWFRSQUNUQUJMRV9LRVkiLCJTT0xBTkFfRVJST1JfX0NSWVBUT19fUkFORE9NX1ZBTFVFU19GVU5DVElPTl9VTklNUExFTUVOVEVEIiwiU09MQU5BX0VSUk9SX19LRVlTX19JTlZBTElEX0tFWV9QQUlSX0JZVEVfTEVOR1RIIiwiU09MQU5BX0VSUk9SX19LRVlTX19JTlZBTElEX1BSSVZBVEVfS0VZX0JZVEVfTEVOR1RIIiwiU09MQU5BX0VSUk9SX19LRVlTX19JTlZBTElEX1NJR05BVFVSRV9CWVRFX0xFTkdUSCIsIlNPTEFOQV9FUlJPUl9fS0VZU19fU0lHTkFUVVJFX1NUUklOR19MRU5HVEhfT1VUX09GX1JBTkdFIiwiU09MQU5BX0VSUk9SX19LRVlTX19QVUJMSUNfS0VZX01VU1RfTUFUQ0hfUFJJVkFURV9LRVkiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX19FWFBFQ1RFRF9UT19IQVZFX0FDQ09VTlRTIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9fRVhQRUNURURfVE9fSEFWRV9EQVRBIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9fUFJPR1JBTV9JRF9NSVNNQVRDSCIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1VOS05PV04iLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19HRU5FUklDX0VSUk9SIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9BUkdVTUVOVCIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfSU5TVFJVQ1RJT05fREFUQSIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfQUNDT1VOVF9EQVRBIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9EQVRBX1RPT19TTUFMTCIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOU1VGRklDSUVOVF9GVU5EUyIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOQ09SUkVDVF9QUk9HUkFNX0lEIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTUlTU0lOR19SRVFVSVJFRF9TSUdOQVRVUkUiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BQ0NPVU5UX0FMUkVBRFlfSU5JVElBTElaRUQiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19VTklOSVRJQUxJWkVEX0FDQ09VTlQiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19VTkJBTEFOQ0VEX0lOU1RSVUNUSU9OIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTU9ESUZJRURfUFJPR1JBTV9JRCIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0VYVEVSTkFMX0FDQ09VTlRfTEFNUE9SVF9TUEVORCIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0VYVEVSTkFMX0FDQ09VTlRfREFUQV9NT0RJRklFRCIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1JFQURPTkxZX0xBTVBPUlRfQ0hBTkdFIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUkVBRE9OTFlfREFUQV9NT0RJRklFRCIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0RVUExJQ0FURV9BQ0NPVU5UX0lOREVYIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRVhFQ1VUQUJMRV9NT0RJRklFRCIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1JFTlRfRVBPQ0hfTU9ESUZJRUQiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19OT1RfRU5PVUdIX0FDQ09VTlRfS0VZUyIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfREFUQV9TSVpFX0NIQU5HRUQiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BQ0NPVU5UX05PVF9FWEVDVVRBQkxFIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9CT1JST1dfRkFJTEVEIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9CT1JST1dfT1VUU1RBTkRJTkciLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19EVVBMSUNBVEVfQUNDT1VOVF9PVVRfT0ZfU1lOQyIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0NVU1RPTSIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfRVJST1IiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19FWEVDVVRBQkxFX0RBVEFfTU9ESUZJRUQiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19FWEVDVVRBQkxFX0xBTVBPUlRfQ0hBTkdFIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRVhFQ1VUQUJMRV9BQ0NPVU5UX05PVF9SRU5UX0VYRU1QVCIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1VOU1VQUE9SVEVEX1BST0dSQU1fSUQiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19DQUxMX0RFUFRIIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTUlTU0lOR19BQ0NPVU5UIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUkVFTlRSQU5DWV9OT1RfQUxMT1dFRCIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01BWF9TRUVEX0xFTkdUSF9FWENFRURFRCIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfU0VFRFMiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX1JFQUxMT0MiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19DT01QVVRBVElPTkFMX0JVREdFVF9FWENFRURFRCIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1BSSVZJTEVHRV9FU0NBTEFUSU9OIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUFJPR1JBTV9FTlZJUk9OTUVOVF9TRVRVUF9GQUlMVVJFIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUFJPR1JBTV9GQUlMRURfVE9fQ09NUExFVEUiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19QUk9HUkFNX0ZBSUxFRF9UT19DT01QSUxFIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU1NVVRBQkxFIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5DT1JSRUNUX0FVVEhPUklUWSIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0JPUlNIX0lPX0VSUk9SIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9OT1RfUkVOVF9FWEVNUFQiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX0FDQ09VTlRfT1dORVIiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BUklUSE1FVElDX09WRVJGTE9XIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fVU5TVVBQT1JURURfU1lTVkFSIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSUxMRUdBTF9PV05FUiIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01BWF9BQ0NPVU5UU19EQVRBX0FMTE9DQVRJT05TX0VYQ0VFREVEIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTUFYX0FDQ09VTlRTX0VYQ0VFREVEIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTUFYX0lOU1RSVUNUSU9OX1RSQUNFX0xFTkdUSF9FWENFRURFRCIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0JVSUxUSU5fUFJPR1JBTVNfTVVTVF9DT05TVU1FX0NPTVBVVEVfVU5JVFMiLCJTT0xBTkFfRVJST1JfX1NJR05FUl9fQUREUkVTU19DQU5OT1RfSEFWRV9NVUxUSVBMRV9TSUdORVJTIiwiU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX0tFWV9QQUlSX1NJR05FUiIsIlNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9NRVNTQUdFX1NJR05FUiIsIlNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9NRVNTQUdFX01PRElGWUlOR19TSUdORVIiLCJTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfTUVTU0FHRV9QQVJUSUFMX1NJR05FUiIsIlNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9UUkFOU0FDVElPTl9TSUdORVIiLCJTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfVFJBTlNBQ1RJT05fTU9ESUZZSU5HX1NJR05FUiIsIlNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9UUkFOU0FDVElPTl9QQVJUSUFMX1NJR05FUiIsIlNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9UUkFOU0FDVElPTl9TRU5ESU5HX1NJR05FUiIsIlNPTEFOQV9FUlJPUl9fU0lHTkVSX19UUkFOU0FDVElPTl9DQU5OT1RfSEFWRV9NVUxUSVBMRV9TRU5ESU5HX1NJR05FUlMiLCJTT0xBTkFfRVJST1JfX1NJR05FUl9fVFJBTlNBQ1RJT05fU0VORElOR19TSUdORVJfTUlTU0lORyIsIlNPTEFOQV9FUlJPUl9fU0lHTkVSX19XQUxMRVRfTVVMVElTSUdOX1VOSU1QTEVNRU5URUQiLCJTT0xBTkFfRVJST1JfX09GRkNIQUlOX01FU1NBR0VfX01BWElNVU1fTEVOR1RIX0VYQ0VFREVEIiwiU09MQU5BX0VSUk9SX19PRkZDSEFJTl9NRVNTQUdFX19SRVNUUklDVEVEX0FTQ0lJX0JPRFlfQ0hBUkFDVEVSX09VVF9PRl9SQU5HRSIsIlNPTEFOQV9FUlJPUl9fT0ZGQ0hBSU5fTUVTU0FHRV9fQVBQTElDQVRJT05fRE9NQUlOX1NUUklOR19MRU5HVEhfT1VUX09GX1JBTkdFIiwiU09MQU5BX0VSUk9SX19PRkZDSEFJTl9NRVNTQUdFX19JTlZBTElEX0FQUExJQ0FUSU9OX0RPTUFJTl9CWVRFX0xFTkdUSCIsIlNPTEFOQV9FUlJPUl9fT0ZGQ0hBSU5fTUVTU0FHRV9fTlVNX1NJR05BVFVSRVNfTUlTTUFUQ0giLCJTT0xBTkFfRVJST1JfX09GRkNIQUlOX01FU1NBR0VfX05VTV9SRVFVSVJFRF9TSUdORVJTX0NBTk5PVF9CRV9aRVJPIiwiU09MQU5BX0VSUk9SX19PRkZDSEFJTl9NRVNTQUdFX19WRVJTSU9OX05VTUJFUl9OT1RfU1VQUE9SVEVEIiwiU09MQU5BX0VSUk9SX19PRkZDSEFJTl9NRVNTQUdFX19NRVNTQUdFX0ZPUk1BVF9NSVNNQVRDSCIsIlNPTEFOQV9FUlJPUl9fT0ZGQ0hBSU5fTUVTU0FHRV9fTUVTU0FHRV9MRU5HVEhfTUlTTUFUQ0giLCJTT0xBTkFfRVJST1JfX09GRkNIQUlOX01FU1NBR0VfX01FU1NBR0VfTVVTVF9CRV9OT05fRU1QVFkiLCJTT0xBTkFfRVJST1JfX09GRkNIQUlOX01FU1NBR0VfX05VTV9FTlZFTE9QRV9TSUdOQVRVUkVTX0NBTk5PVF9CRV9aRVJPIiwiU09MQU5BX0VSUk9SX19PRkZDSEFJTl9NRVNTQUdFX19TSUdOQVRVUkVTX01JU1NJTkciLCJTT0xBTkFfRVJST1JfX09GRkNIQUlOX01FU1NBR0VfX0VOVkVMT1BFX1NJR05FUlNfTUlTTUFUQ0giLCJTT0xBTkFfRVJST1JfX09GRkNIQUlOX01FU1NBR0VfX0FERFJFU1NFU19DQU5OT1RfU0lHTl9PRkZDSEFJTl9NRVNTQUdFIiwiU09MQU5BX0VSUk9SX19PRkZDSEFJTl9NRVNTQUdFX19VTkVYUEVDVEVEX1ZFUlNJT04iLCJTT0xBTkFfRVJST1JfX09GRkNIQUlOX01FU1NBR0VfX1NJR05BVE9SSUVTX01VU1RfQkVfU09SVEVEIiwiU09MQU5BX0VSUk9SX19PRkZDSEFJTl9NRVNTQUdFX19TSUdOQVRPUklFU19NVVNUX0JFX1VOSVFVRSIsIlNPTEFOQV9FUlJPUl9fT0ZGQ0hBSU5fTUVTU0FHRV9fU0lHTkFUVVJFX1ZFUklGSUNBVElPTl9GQUlMVVJFIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fSU5WT0tFRF9QUk9HUkFNU19DQU5OT1RfUEFZX0ZFRVMiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19JTlZPS0VEX1BST0dSQU1TX01VU1RfTk9UX0JFX1dSSVRBQkxFIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRVhQRUNURURfQkxPQ0tIQVNIX0xJRkVUSU1FIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRVhQRUNURURfTk9OQ0VfTElGRVRJTUUiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19WRVJTSU9OX05VTUJFUl9PVVRfT0ZfUkFOR0UiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GQUlMRURfVE9fREVDT01QSUxFX0FERFJFU1NfTE9PS1VQX1RBQkxFX0NPTlRFTlRTX01JU1NJTkciLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GQUlMRURfVE9fREVDT01QSUxFX0FERFJFU1NfTE9PS1VQX1RBQkxFX0lOREVYX09VVF9PRl9SQU5HRSIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9UT19ERUNPTVBJTEVfSU5TVFJVQ1RJT05fUFJPR1JBTV9BRERSRVNTX05PVF9GT1VORCIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9UT19ERUNPTVBJTEVfRkVFX1BBWUVSX01JU1NJTkciLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19TSUdOQVRVUkVTX01JU1NJTkciLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19BRERSRVNTX01JU1NJTkciLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GRUVfUEFZRVJfTUlTU0lORyIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZFRV9QQVlFUl9TSUdOQVRVUkVfTUlTU0lORyIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0lOVkFMSURfTk9OQ0VfVFJBTlNBQ1RJT05fSU5TVFJVQ1RJT05TX01JU1NJTkciLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19JTlZBTElEX05PTkNFX1RSQU5TQUNUSU9OX0ZJUlNUX0lOU1RSVUNUSU9OX01VU1RfQkVfQURWQU5DRV9OT05DRSIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0FERFJFU1NFU19DQU5OT1RfU0lHTl9UUkFOU0FDVElPTiIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0NBTk5PVF9FTkNPREVfV0lUSF9FTVBUWV9TSUdOQVRVUkVTIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fTUVTU0FHRV9TSUdOQVRVUkVTX01JU01BVENIIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkFJTEVEX1RPX0VTVElNQVRFX0NPTVBVVEVfTElNSVQiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GQUlMRURfV0hFTl9TSU1VTEFUSU5HX1RPX0VTVElNQVRFX0NPTVBVVEVfTElNSVQiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19FWENFRURTX1NJWkVfTElNSVQiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19WRVJTSU9OX05VTUJFUl9OT1RfU1VQUE9SVEVEIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fTk9OQ0VfQUNDT1VOVF9DQU5OT1RfQkVfSU5fTE9PS1VQX1RBQkxFIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fVU5LTk9XTiIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0FDQ09VTlRfSU5fVVNFIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQUNDT1VOVF9MT0FERURfVFdJQ0UiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19BQ0NPVU5UX05PVF9GT1VORCIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1BST0dSQU1fQUNDT1VOVF9OT1RfRk9VTkQiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlNVRkZJQ0lFTlRfRlVORFNfRk9SX0ZFRSIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfQUNDT1VOVF9GT1JfRkVFIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQUxSRUFEWV9QUk9DRVNTRUQiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19CTE9DS0hBU0hfTk9UX0ZPVU5EIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQ0FMTF9DSEFJTl9UT09fREVFUCIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX01JU1NJTkdfU0lHTkFUVVJFX0ZPUl9GRUUiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX0FDQ09VTlRfSU5ERVgiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19TSUdOQVRVUkVfRkFJTFVSRSIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfUFJPR1JBTV9GT1JfRVhFQ1VUSU9OIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fU0FOSVRJWkVfRkFJTFVSRSIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0NMVVNURVJfTUFJTlRFTkFOQ0UiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19BQ0NPVU5UX0JPUlJPV19PVVRTVEFORElORyIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1dPVUxEX0VYQ0VFRF9NQVhfQkxPQ0tfQ09TVF9MSU1JVCIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1VOU1VQUE9SVEVEX1ZFUlNJT04iLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX1dSSVRBQkxFX0FDQ09VTlQiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19XT1VMRF9FWENFRURfTUFYX0FDQ09VTlRfQ09TVF9MSU1JVCIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1dPVUxEX0VYQ0VFRF9BQ0NPVU5UX0RBVEFfQkxPQ0tfTElNSVQiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19UT09fTUFOWV9BQ0NPVU5UX0xPQ0tTIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQUREUkVTU19MT09LVVBfVEFCTEVfTk9UX0ZPVU5EIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9BRERSRVNTX0xPT0tVUF9UQUJMRV9PV05FUiIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfQUREUkVTU19MT09LVVBfVEFCTEVfREFUQSIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfQUREUkVTU19MT09LVVBfVEFCTEVfSU5ERVgiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX1JFTlRfUEFZSU5HX0FDQ09VTlQiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19XT1VMRF9FWENFRURfTUFYX1ZPVEVfQ09TVF9MSU1JVCIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1dPVUxEX0VYQ0VFRF9BQ0NPVU5UX0RBVEFfVE9UQUxfTElNSVQiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19EVVBMSUNBVEVfSU5TVFJVQ1RJT04iLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlNVRkZJQ0lFTlRfRlVORFNfRk9SX1JFTlQiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19NQVhfTE9BREVEX0FDQ09VTlRTX0RBVEFfU0laRV9FWENFRURFRCIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfTE9BREVEX0FDQ09VTlRTX0RBVEFfU0laRV9MSU1JVCIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1JFU0FOSVRJWkFUSU9OX05FRURFRCIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1BST0dSQU1fRVhFQ1VUSU9OX1RFTVBPUkFSSUxZX1JFU1RSSUNURUQiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19VTkJBTEFOQ0VEX1RSQU5TQUNUSU9OIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9QTEFOU19fTUVTU0FHRV9DQU5OT1RfQUNDT01NT0RBVEVfUExBTiIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fUExBTlNfX01FU1NBR0VfUEFDS0VSX0FMUkVBRFlfQ09NUExFVEUiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX1BMQU5TX19FTVBUWV9JTlNUUlVDVElPTl9QTEFOIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9QTEFOU19fRkFJTEVEX1RPX0VYRUNVVEVfVFJBTlNBQ1RJT05fUExBTiIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fUExBTlNfX05PTl9ESVZJU0lCTEVfVFJBTlNBQ1RJT05fUExBTlNfTk9UX1NVUFBPUlRFRCIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fUExBTlNfX0ZBSUxFRF9TSU5HTEVfVFJBTlNBQ1RJT05fUExBTl9SRVNVTFRfTk9UX0ZPVU5EIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9QTEFOU19fVU5FWFBFQ1RFRF9JTlNUUlVDVElPTl9QTEFOIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9QTEFOU19fVU5FWFBFQ1RFRF9UUkFOU0FDVElPTl9QTEFOIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9QTEFOU19fVU5FWFBFQ1RFRF9UUkFOU0FDVElPTl9QTEFOX1JFU1VMVCIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fUExBTlNfX0VYUEVDVEVEX1NVQ0NFU1NGVUxfVFJBTlNBQ1RJT05fUExBTl9SRVNVTFQiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fQ0FOTk9UX0RFQ09ERV9FTVBUWV9CWVRFX0FSUkFZIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfQllURV9MRU5HVEgiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfRklYRURfTEVOR1RIIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX1ZBUklBQkxFX0xFTkdUSCIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfU0laRV9DT01QQVRJQklMSVRZX01JU01BVENIIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9GSVhFRF9TSVpFX01JU01BVENIIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9NQVhfU0laRV9NSVNNQVRDSCIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX05VTUJFUl9PRl9JVEVNUyIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTlVNX0RJU0NSSU1JTkFUT1JfT1VUX09GX1JBTkdFIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfRElTQ1JJTUlOQVRFRF9VTklPTl9WQVJJQU5UIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfRU5VTV9WQVJJQU5UIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX05VTUJFUl9PVVRfT0ZfUkFOR0UiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9TVFJJTkdfRk9SX0JBU0UiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfUE9TSVRJVkVfQllURV9MRU5HVEgiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fT0ZGU0VUX09VVF9PRl9SQU5HRSIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0xJVEVSQUxfVU5JT05fVkFSSUFOVCIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19MSVRFUkFMX1VOSU9OX0RJU0NSSU1JTkFUT1JfT1VUX09GX1JBTkdFIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX1VOSU9OX1ZBUklBTlRfT1VUX09GX1JBTkdFIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfQ09OU1RBTlQiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfWkVST19WQUxVRV9UT19NQVRDSF9JVEVNX0ZJWEVEX1NJWkUiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFRF9CWVRFU19NVVNUX05PVF9JTkNMVURFX1NFTlRJTkVMIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX1NFTlRJTkVMX01JU1NJTkdfSU5fREVDT0RFRF9CWVRFUyIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19DQU5OT1RfVVNFX0xFWElDQUxfVkFMVUVTX0FTX0VOVU1fRElTQ1JJTUlOQVRPUlMiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfREVDT0RFUl9UT19DT05TVU1FX0VOVElSRV9CWVRFX0FSUkFZIiwiU09MQU5BX0VSUk9SX19SUENfX0lOVEVHRVJfT1ZFUkZMT1ciLCJTT0xBTkFfRVJST1JfX1JQQ19fVFJBTlNQT1JUX0hUVFBfSEVBREVSX0ZPUkJJRERFTiIsIlNPTEFOQV9FUlJPUl9fUlBDX19UUkFOU1BPUlRfSFRUUF9FUlJPUiIsIlNPTEFOQV9FUlJPUl9fUlBDX19BUElfUExBTl9NSVNTSU5HX0ZPUl9SUENfTUVUSE9EIiwiU09MQU5BX0VSUk9SX19SUENfU1VCU0NSSVBUSU9OU19fQ0FOTk9UX0NSRUFURV9TVUJTQ1JJUFRJT05fUExBTiIsIlNPTEFOQV9FUlJPUl9fUlBDX1NVQlNDUklQVElPTlNfX0VYUEVDVEVEX1NFUlZFUl9TVUJTQ1JJUFRJT05fSUQiLCJTT0xBTkFfRVJST1JfX1JQQ19TVUJTQ1JJUFRJT05TX19DSEFOTkVMX0NMT1NFRF9CRUZPUkVfTUVTU0FHRV9CVUZGRVJFRCIsIlNPTEFOQV9FUlJPUl9fUlBDX1NVQlNDUklQVElPTlNfX0NIQU5ORUxfQ09OTkVDVElPTl9DTE9TRUQiLCJTT0xBTkFfRVJST1JfX1JQQ19TVUJTQ1JJUFRJT05TX19DSEFOTkVMX0ZBSUxFRF9UT19DT05ORUNUIiwiU09MQU5BX0VSUk9SX19JTlZBUklBTlRfVklPTEFUSU9OX19TVUJTQ1JJUFRJT05fSVRFUkFUT1JfU1RBVEVfTUlTU0lORyIsIlNPTEFOQV9FUlJPUl9fSU5WQVJJQU5UX1ZJT0xBVElPTl9fU1VCU0NSSVBUSU9OX0lURVJBVE9SX01VU1RfTk9UX1BPTExfQkVGT1JFX1JFU09MVklOR19FWElTVElOR19NRVNTQUdFX1BST01JU0UiLCJTT0xBTkFfRVJST1JfX0lOVkFSSUFOVF9WSU9MQVRJT05fX0NBQ0hFRF9BQk9SVEFCTEVfSVRFUkFCTEVfQ0FDSEVfRU5UUllfTUlTU0lORyIsIlNPTEFOQV9FUlJPUl9fSU5WQVJJQU5UX1ZJT0xBVElPTl9fU1dJVENIX01VU1RfQkVfRVhIQVVTVElWRSIsIlNPTEFOQV9FUlJPUl9fSU5WQVJJQU5UX1ZJT0xBVElPTl9fREFUQV9QVUJMSVNIRVJfQ0hBTk5FTF9VTklNUExFTUVOVEVEIiwiU09MQU5BX0VSUk9SX19JTlZBUklBTlRfVklPTEFUSU9OX19JTlZBTElEX0lOU1RSVUNUSU9OX1BMQU5fS0lORCIsIlNPTEFOQV9FUlJPUl9fSU5WQVJJQU5UX1ZJT0xBVElPTl9fSU5WQUxJRF9UUkFOU0FDVElPTl9QTEFOX0tJTkQiLCJlbmNvZGVWYWx1ZSIsInZhbHVlIiwiQXJyYXkiLCJpc0FycmF5IiwiY29tbWFTZXBhcmF0ZWRWYWx1ZXMiLCJtYXAiLCJqb2luIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiU3RyaW5nIiwiT2JqZWN0IiwiZ2V0UHJvdG90eXBlT2YiLCJlbmNvZGVPYmplY3RDb250ZXh0RW50cnkiLCJrZXkiLCJlbmNvZGVDb250ZXh0T2JqZWN0IiwiY29udGV4dCIsInNlYXJjaFBhcmFtc1N0cmluZyIsImVudHJpZXMiLCJCdWZmZXIiLCJmcm9tIiwidG9TdHJpbmciLCJTb2xhbmFFcnJvck1lc3NhZ2VzIiwiU1RBUlRfSU5ERVgiLCJUWVBFIiwiZ2V0SHVtYW5SZWFkYWJsZUVycm9yTWVzc2FnZSIsImNvZGUiLCJtZXNzYWdlRm9ybWF0U3RyaW5nIiwibGVuZ3RoIiwic3RhdGUiLCJjb21taXRTdGF0ZVVwVG8iLCJlbmRJbmRleCIsInZhcmlhYmxlTmFtZSIsInNsaWNlIiwiZnJhZ21lbnRzIiwicHVzaCIsInNwbGl0IiwiZm9yRWFjaCIsImNoYXIiLCJpaSIsIm5leHRTdGF0ZSIsIm1hdGNoIiwiZ2V0RXJyb3JNZXNzYWdlIiwicHJvY2VzcyIsImRlY29kaW5nQWR2aWNlTWVzc2FnZSIsImtleXMiLCJpc1NvbGFuYUVycm9yIiwiZSIsImlzU29sYW5hRXJyb3IyIiwiRXJyb3IiLCJuYW1lIiwiX19jb2RlIiwiU29sYW5hRXJyb3IiLCJjb25zdHJ1Y3RvciIsImNvbnRleHRBbmRFcnJvck9wdGlvbnMiLCJlcnJvck9wdGlvbnMiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVzY3JpcHRvciIsImNhdXNlIiwiZGVmaW5lUHJvcGVydHkiLCJtZXNzYWdlIiwiZnJlZXplIiwic2FmZUNhcHR1cmVTdGFja1RyYWNlIiwiYXJncyIsImNhcHR1cmVTdGFja1RyYWNlIiwiZ2V0U29sYW5hRXJyb3JGcm9tUnBjRXJyb3IiLCJlcnJvckNvZGVCYXNlT2Zmc2V0IiwiZ2V0RXJyb3JDb250ZXh0Iiwib3JkZXJlZEVycm9yTmFtZXMiLCJycGNFbnVtRXJyb3IiLCJjb25zdHJ1Y3Rvck9wdCIsInJwY0Vycm9yTmFtZSIsInJwY0Vycm9yQ29udGV4dCIsImNvZGVPZmZzZXQiLCJpbmRleE9mIiwiZXJyb3JDb2RlIiwiZXJyb3JDb250ZXh0IiwiZXJyIiwiT1JERVJFRF9FUlJPUl9OQU1FUyIsImdldFNvbGFuYUVycm9yRnJvbUluc3RydWN0aW9uRXJyb3IiLCJpbmRleCIsImluc3RydWN0aW9uRXJyb3IiLCJudW1iZXJJbmRleCIsIk51bWJlciIsImVycm9yTmFtZSIsImluc3RydWN0aW9uRXJyb3JDb250ZXh0IiwiT1JERVJFRF9FUlJPUl9OQU1FUzIiLCJnZXRTb2xhbmFFcnJvckZyb21UcmFuc2FjdGlvbkVycm9yIiwidHJhbnNhY3Rpb25FcnJvciIsIkluc3RydWN0aW9uRXJyb3IiLCJ0cmFuc2FjdGlvbkVycm9yQ29udGV4dCIsImFjY291bnRJbmRleCIsImFjY291bnRfaW5kZXgiLCJnZXRTb2xhbmFFcnJvckZyb21Kc29uUnBjRXJyb3IiLCJwdXRhdGl2ZUVycm9yUmVzcG9uc2UiLCJvdXQiLCJpc1JwY0Vycm9yUmVzcG9uc2UiLCJyYXdDb2RlIiwiZGF0YSIsInByZWZsaWdodEVycm9yQ29udGV4dCIsImNhdXNlT2JqZWN0IiwiX19zZXJ2ZXJNZXNzYWdlIiwiZXJyb3IiLCJ1bndyYXBTaW11bGF0aW9uRXJyb3IiLCJzaW11bGF0aW9uQ29kZXMiLCJpbmNsdWRlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/errors/dist/index.node.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/fast-stable-stringify/dist/index.node.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@solana/fast-stable-stringify/dist/index.node.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ index_default)\n/* harmony export */ });\n// src/index.ts\nvar objToString = Object.prototype.toString;\nvar objKeys = Object.keys || function(obj) {\n    const keys = [];\n    for(const name in obj){\n        keys.push(name);\n    }\n    return keys;\n};\nfunction stringify(val, isArrayProp) {\n    let i, max, str, keys, key, propVal, toStr;\n    if (val === true) {\n        return \"true\";\n    }\n    if (val === false) {\n        return \"false\";\n    }\n    switch(typeof val){\n        case \"object\":\n            if (val === null) {\n                return null;\n            } else if (\"toJSON\" in val && typeof val.toJSON === \"function\") {\n                return stringify(val.toJSON(), isArrayProp);\n            } else {\n                toStr = objToString.call(val);\n                if (toStr === \"[object Array]\") {\n                    str = \"[\";\n                    max = val.length - 1;\n                    for(i = 0; i < max; i++){\n                        str += stringify(val[i], true) + \",\";\n                    }\n                    if (max > -1) {\n                        str += stringify(val[i], true);\n                    }\n                    return str + \"]\";\n                } else if (toStr === \"[object Object]\") {\n                    keys = objKeys(val).sort();\n                    max = keys.length;\n                    str = \"\";\n                    i = 0;\n                    while(i < max){\n                        key = keys[i];\n                        propVal = stringify(val[key], false);\n                        if (propVal !== void 0) {\n                            if (str) {\n                                str += \",\";\n                            }\n                            str += JSON.stringify(key) + \":\" + propVal;\n                        }\n                        i++;\n                    }\n                    return \"{\" + str + \"}\";\n                } else {\n                    return JSON.stringify(val);\n                }\n            }\n        case \"function\":\n        case \"undefined\":\n            return isArrayProp ? null : void 0;\n        case \"bigint\":\n            return `${val.toString()}n`;\n        case \"string\":\n            return JSON.stringify(val);\n        default:\n            return isFinite(val) ? val : null;\n    }\n}\nfunction index_default(val) {\n    const returnVal = stringify(val, false);\n    if (returnVal !== void 0) {\n        return \"\" + returnVal;\n    }\n}\n //# sourceMappingURL=index.node.mjs.map\n //# sourceMappingURL=index.node.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS9mYXN0LXN0YWJsZS1zdHJpbmdpZnkvZGlzdC9pbmRleC5ub2RlLm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsZUFBZTtBQUNmLElBQUlBLGNBQWNDLE9BQU9DLFNBQVMsQ0FBQ0MsUUFBUTtBQUMzQyxJQUFJQyxVQUFVSCxPQUFPSSxJQUFJLElBQUksU0FBU0MsR0FBRztJQUN2QyxNQUFNRCxPQUFPLEVBQUU7SUFDZixJQUFLLE1BQU1FLFFBQVFELElBQUs7UUFDdEJELEtBQUtHLElBQUksQ0FBQ0Q7SUFDWjtJQUNBLE9BQU9GO0FBQ1Q7QUFDQSxTQUFTSSxVQUFVQyxHQUFHLEVBQUVDLFdBQVc7SUFDakMsSUFBSUMsR0FBR0MsS0FBS0MsS0FBS1QsTUFBTVUsS0FBS0MsU0FBU0M7SUFDckMsSUFBSVAsUUFBUSxNQUFNO1FBQ2hCLE9BQU87SUFDVDtJQUNBLElBQUlBLFFBQVEsT0FBTztRQUNqQixPQUFPO0lBQ1Q7SUFDQSxPQUFRLE9BQU9BO1FBQ2IsS0FBSztZQUNILElBQUlBLFFBQVEsTUFBTTtnQkFDaEIsT0FBTztZQUNULE9BQU8sSUFBSSxZQUFZQSxPQUFPLE9BQU9BLElBQUlRLE1BQU0sS0FBSyxZQUFZO2dCQUM5RCxPQUFPVCxVQUFVQyxJQUFJUSxNQUFNLElBQUlQO1lBQ2pDLE9BQU87Z0JBQ0xNLFFBQVFqQixZQUFZbUIsSUFBSSxDQUFDVDtnQkFDekIsSUFBSU8sVUFBVSxrQkFBa0I7b0JBQzlCSCxNQUFNO29CQUNORCxNQUFNSCxJQUFJVSxNQUFNLEdBQUc7b0JBQ25CLElBQUtSLElBQUksR0FBR0EsSUFBSUMsS0FBS0QsSUFBSzt3QkFDeEJFLE9BQU9MLFVBQVVDLEdBQUcsQ0FBQ0UsRUFBRSxFQUFFLFFBQVE7b0JBQ25DO29CQUNBLElBQUlDLE1BQU0sQ0FBQyxHQUFHO3dCQUNaQyxPQUFPTCxVQUFVQyxHQUFHLENBQUNFLEVBQUUsRUFBRTtvQkFDM0I7b0JBQ0EsT0FBT0UsTUFBTTtnQkFDZixPQUFPLElBQUlHLFVBQVUsbUJBQW1CO29CQUN0Q1osT0FBT0QsUUFBUU0sS0FBS1csSUFBSTtvQkFDeEJSLE1BQU1SLEtBQUtlLE1BQU07b0JBQ2pCTixNQUFNO29CQUNORixJQUFJO29CQUNKLE1BQU9BLElBQUlDLElBQUs7d0JBQ2RFLE1BQU1WLElBQUksQ0FBQ08sRUFBRTt3QkFDYkksVUFBVVAsVUFBVUMsR0FBRyxDQUFDSyxJQUFJLEVBQUU7d0JBQzlCLElBQUlDLFlBQVksS0FBSyxHQUFHOzRCQUN0QixJQUFJRixLQUFLO2dDQUNQQSxPQUFPOzRCQUNUOzRCQUNBQSxPQUFPUSxLQUFLYixTQUFTLENBQUNNLE9BQU8sTUFBTUM7d0JBQ3JDO3dCQUNBSjtvQkFDRjtvQkFDQSxPQUFPLE1BQU1FLE1BQU07Z0JBQ3JCLE9BQU87b0JBQ0wsT0FBT1EsS0FBS2IsU0FBUyxDQUFDQztnQkFDeEI7WUFDRjtRQUNGLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBT0MsY0FBYyxPQUFPLEtBQUs7UUFDbkMsS0FBSztZQUNILE9BQU8sQ0FBQyxFQUFFRCxJQUFJUCxRQUFRLEdBQUcsQ0FBQyxDQUFDO1FBQzdCLEtBQUs7WUFDSCxPQUFPbUIsS0FBS2IsU0FBUyxDQUFDQztRQUN4QjtZQUNFLE9BQU9hLFNBQVNiLE9BQU9BLE1BQU07SUFDakM7QUFDRjtBQUNBLFNBQVNjLGNBQWNkLEdBQUc7SUFDeEIsTUFBTWUsWUFBWWhCLFVBQVVDLEtBQUs7SUFDakMsSUFBSWUsY0FBYyxLQUFLLEdBQUc7UUFDeEIsT0FBTyxLQUFLQTtJQUNkO0FBQ0Y7QUFFb0MsQ0FDcEMsdUNBQXVDO0NBQ3ZDLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsYXctd29ya3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS9mYXN0LXN0YWJsZS1zdHJpbmdpZnkvZGlzdC9pbmRleC5ub2RlLm1qcz82OTk0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9pbmRleC50c1xudmFyIG9ialRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBvYmpLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ob2JqKSB7XG4gIGNvbnN0IGtleXMgPSBbXTtcbiAgZm9yIChjb25zdCBuYW1lIGluIG9iaikge1xuICAgIGtleXMucHVzaChuYW1lKTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn07XG5mdW5jdGlvbiBzdHJpbmdpZnkodmFsLCBpc0FycmF5UHJvcCkge1xuICBsZXQgaSwgbWF4LCBzdHIsIGtleXMsIGtleSwgcHJvcFZhbCwgdG9TdHI7XG4gIGlmICh2YWwgPT09IHRydWUpIHtcbiAgICByZXR1cm4gXCJ0cnVlXCI7XG4gIH1cbiAgaWYgKHZhbCA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gXCJmYWxzZVwiO1xuICB9XG4gIHN3aXRjaCAodHlwZW9mIHZhbCkge1xuICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2UgaWYgKFwidG9KU09OXCIgaW4gdmFsICYmIHR5cGVvZiB2YWwudG9KU09OID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeSh2YWwudG9KU09OKCksIGlzQXJyYXlQcm9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRvU3RyID0gb2JqVG9TdHJpbmcuY2FsbCh2YWwpO1xuICAgICAgICBpZiAodG9TdHIgPT09IFwiW29iamVjdCBBcnJheV1cIikge1xuICAgICAgICAgIHN0ciA9IFwiW1wiO1xuICAgICAgICAgIG1heCA9IHZhbC5sZW5ndGggLSAxO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBtYXg7IGkrKykge1xuICAgICAgICAgICAgc3RyICs9IHN0cmluZ2lmeSh2YWxbaV0sIHRydWUpICsgXCIsXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtYXggPiAtMSkge1xuICAgICAgICAgICAgc3RyICs9IHN0cmluZ2lmeSh2YWxbaV0sIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc3RyICsgXCJdXCI7XG4gICAgICAgIH0gZWxzZSBpZiAodG9TdHIgPT09IFwiW29iamVjdCBPYmplY3RdXCIpIHtcbiAgICAgICAgICBrZXlzID0gb2JqS2V5cyh2YWwpLnNvcnQoKTtcbiAgICAgICAgICBtYXggPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgICBzdHIgPSBcIlwiO1xuICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgIHdoaWxlIChpIDwgbWF4KSB7XG4gICAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgcHJvcFZhbCA9IHN0cmluZ2lmeSh2YWxba2V5XSwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKHByb3BWYWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBpZiAoc3RyKSB7XG4gICAgICAgICAgICAgICAgc3RyICs9IFwiLFwiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN0ciArPSBKU09OLnN0cmluZ2lmeShrZXkpICsgXCI6XCIgKyBwcm9wVmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gXCJ7XCIgKyBzdHIgKyBcIn1cIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgIHJldHVybiBpc0FycmF5UHJvcCA/IG51bGwgOiB2b2lkIDA7XG4gICAgY2FzZSBcImJpZ2ludFwiOlxuICAgICAgcmV0dXJuIGAke3ZhbC50b1N0cmluZygpfW5gO1xuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWwpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gaXNGaW5pdGUodmFsKSA/IHZhbCA6IG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIGluZGV4X2RlZmF1bHQodmFsKSB7XG4gIGNvbnN0IHJldHVyblZhbCA9IHN0cmluZ2lmeSh2YWwsIGZhbHNlKTtcbiAgaWYgKHJldHVyblZhbCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIFwiXCIgKyByZXR1cm5WYWw7XG4gIH1cbn1cblxuZXhwb3J0IHsgaW5kZXhfZGVmYXVsdCBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5ub2RlLm1qcy5tYXBcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm5vZGUubWpzLm1hcCJdLCJuYW1lcyI6WyJvYmpUb1N0cmluZyIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwib2JqS2V5cyIsImtleXMiLCJvYmoiLCJuYW1lIiwicHVzaCIsInN0cmluZ2lmeSIsInZhbCIsImlzQXJyYXlQcm9wIiwiaSIsIm1heCIsInN0ciIsImtleSIsInByb3BWYWwiLCJ0b1N0ciIsInRvSlNPTiIsImNhbGwiLCJsZW5ndGgiLCJzb3J0IiwiSlNPTiIsImlzRmluaXRlIiwiaW5kZXhfZGVmYXVsdCIsInJldHVyblZhbCIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/fast-stable-stringify/dist/index.node.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/functional/dist/index.node.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@solana/functional/dist/index.node.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   pipe: () => (/* binding */ pipe)\n/* harmony export */ });\n// src/pipe.ts\nfunction pipe(init, ...fns) {\n    return fns.reduce((acc, fn)=>fn(acc), init);\n}\n //# sourceMappingURL=index.node.mjs.map\n //# sourceMappingURL=index.node.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS9mdW5jdGlvbmFsL2Rpc3QvaW5kZXgubm9kZS5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGNBQWM7QUFDZCxTQUFTQSxLQUFLQyxJQUFJLEVBQUUsR0FBR0MsR0FBRztJQUN4QixPQUFPQSxJQUFJQyxNQUFNLENBQUMsQ0FBQ0MsS0FBS0MsS0FBT0EsR0FBR0QsTUFBTUg7QUFDMUM7QUFFZ0IsQ0FDaEIsdUNBQXVDO0NBQ3ZDLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsYXctd29ya3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS9mdW5jdGlvbmFsL2Rpc3QvaW5kZXgubm9kZS5tanM/MTJlZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvcGlwZS50c1xuZnVuY3Rpb24gcGlwZShpbml0LCAuLi5mbnMpIHtcbiAgcmV0dXJuIGZucy5yZWR1Y2UoKGFjYywgZm4pID0+IGZuKGFjYyksIGluaXQpO1xufVxuXG5leHBvcnQgeyBwaXBlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5ub2RlLm1qcy5tYXBcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm5vZGUubWpzLm1hcCJdLCJuYW1lcyI6WyJwaXBlIiwiaW5pdCIsImZucyIsInJlZHVjZSIsImFjYyIsImZuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/functional/dist/index.node.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/instruction-plans/dist/index.node.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@solana/instruction-plans/dist/index.node.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   appendTransactionMessageInstructionPlan: () => (/* binding */ appendTransactionMessageInstructionPlan),\n/* harmony export */   assertIsCanceledSingleTransactionPlanResult: () => (/* binding */ assertIsCanceledSingleTransactionPlanResult),\n/* harmony export */   assertIsFailedSingleTransactionPlanResult: () => (/* binding */ assertIsFailedSingleTransactionPlanResult),\n/* harmony export */   assertIsMessagePackerInstructionPlan: () => (/* binding */ assertIsMessagePackerInstructionPlan),\n/* harmony export */   assertIsNonDivisibleSequentialInstructionPlan: () => (/* binding */ assertIsNonDivisibleSequentialInstructionPlan),\n/* harmony export */   assertIsNonDivisibleSequentialTransactionPlan: () => (/* binding */ assertIsNonDivisibleSequentialTransactionPlan),\n/* harmony export */   assertIsNonDivisibleSequentialTransactionPlanResult: () => (/* binding */ assertIsNonDivisibleSequentialTransactionPlanResult),\n/* harmony export */   assertIsParallelInstructionPlan: () => (/* binding */ assertIsParallelInstructionPlan),\n/* harmony export */   assertIsParallelTransactionPlan: () => (/* binding */ assertIsParallelTransactionPlan),\n/* harmony export */   assertIsParallelTransactionPlanResult: () => (/* binding */ assertIsParallelTransactionPlanResult),\n/* harmony export */   assertIsSequentialInstructionPlan: () => (/* binding */ assertIsSequentialInstructionPlan),\n/* harmony export */   assertIsSequentialTransactionPlan: () => (/* binding */ assertIsSequentialTransactionPlan),\n/* harmony export */   assertIsSequentialTransactionPlanResult: () => (/* binding */ assertIsSequentialTransactionPlanResult),\n/* harmony export */   assertIsSingleInstructionPlan: () => (/* binding */ assertIsSingleInstructionPlan),\n/* harmony export */   assertIsSingleTransactionPlan: () => (/* binding */ assertIsSingleTransactionPlan),\n/* harmony export */   assertIsSingleTransactionPlanResult: () => (/* binding */ assertIsSingleTransactionPlanResult),\n/* harmony export */   assertIsSuccessfulSingleTransactionPlanResult: () => (/* binding */ assertIsSuccessfulSingleTransactionPlanResult),\n/* harmony export */   assertIsSuccessfulTransactionPlanResult: () => (/* binding */ assertIsSuccessfulTransactionPlanResult),\n/* harmony export */   canceledSingleTransactionPlanResult: () => (/* binding */ canceledSingleTransactionPlanResult),\n/* harmony export */   createTransactionPlanExecutor: () => (/* binding */ createTransactionPlanExecutor),\n/* harmony export */   createTransactionPlanner: () => (/* binding */ createTransactionPlanner),\n/* harmony export */   everyInstructionPlan: () => (/* binding */ everyInstructionPlan),\n/* harmony export */   everyTransactionPlan: () => (/* binding */ everyTransactionPlan),\n/* harmony export */   everyTransactionPlanResult: () => (/* binding */ everyTransactionPlanResult),\n/* harmony export */   failedSingleTransactionPlanResult: () => (/* binding */ failedSingleTransactionPlanResult),\n/* harmony export */   findInstructionPlan: () => (/* binding */ findInstructionPlan),\n/* harmony export */   findTransactionPlan: () => (/* binding */ findTransactionPlan),\n/* harmony export */   findTransactionPlanResult: () => (/* binding */ findTransactionPlanResult),\n/* harmony export */   flattenInstructionPlan: () => (/* binding */ flattenInstructionPlan),\n/* harmony export */   flattenTransactionPlan: () => (/* binding */ flattenTransactionPlan),\n/* harmony export */   flattenTransactionPlanResult: () => (/* binding */ flattenTransactionPlanResult),\n/* harmony export */   getAllSingleTransactionPlans: () => (/* binding */ getAllSingleTransactionPlans),\n/* harmony export */   getFirstFailedSingleTransactionPlanResult: () => (/* binding */ getFirstFailedSingleTransactionPlanResult),\n/* harmony export */   getLinearMessagePackerInstructionPlan: () => (/* binding */ getLinearMessagePackerInstructionPlan),\n/* harmony export */   getMessagePackerInstructionPlanFromInstructions: () => (/* binding */ getMessagePackerInstructionPlanFromInstructions),\n/* harmony export */   getReallocMessagePackerInstructionPlan: () => (/* binding */ getReallocMessagePackerInstructionPlan),\n/* harmony export */   isCanceledSingleTransactionPlanResult: () => (/* binding */ isCanceledSingleTransactionPlanResult),\n/* harmony export */   isFailedSingleTransactionPlanResult: () => (/* binding */ isFailedSingleTransactionPlanResult),\n/* harmony export */   isMessagePackerInstructionPlan: () => (/* binding */ isMessagePackerInstructionPlan),\n/* harmony export */   isNonDivisibleSequentialInstructionPlan: () => (/* binding */ isNonDivisibleSequentialInstructionPlan),\n/* harmony export */   isNonDivisibleSequentialTransactionPlan: () => (/* binding */ isNonDivisibleSequentialTransactionPlan),\n/* harmony export */   isNonDivisibleSequentialTransactionPlanResult: () => (/* binding */ isNonDivisibleSequentialTransactionPlanResult),\n/* harmony export */   isParallelInstructionPlan: () => (/* binding */ isParallelInstructionPlan),\n/* harmony export */   isParallelTransactionPlan: () => (/* binding */ isParallelTransactionPlan),\n/* harmony export */   isParallelTransactionPlanResult: () => (/* binding */ isParallelTransactionPlanResult),\n/* harmony export */   isSequentialInstructionPlan: () => (/* binding */ isSequentialInstructionPlan),\n/* harmony export */   isSequentialTransactionPlan: () => (/* binding */ isSequentialTransactionPlan),\n/* harmony export */   isSequentialTransactionPlanResult: () => (/* binding */ isSequentialTransactionPlanResult),\n/* harmony export */   isSingleInstructionPlan: () => (/* binding */ isSingleInstructionPlan),\n/* harmony export */   isSingleTransactionPlan: () => (/* binding */ isSingleTransactionPlan),\n/* harmony export */   isSingleTransactionPlanResult: () => (/* binding */ isSingleTransactionPlanResult),\n/* harmony export */   isSuccessfulSingleTransactionPlanResult: () => (/* binding */ isSuccessfulSingleTransactionPlanResult),\n/* harmony export */   isSuccessfulTransactionPlanResult: () => (/* binding */ isSuccessfulTransactionPlanResult),\n/* harmony export */   nonDivisibleSequentialInstructionPlan: () => (/* binding */ nonDivisibleSequentialInstructionPlan),\n/* harmony export */   nonDivisibleSequentialTransactionPlan: () => (/* binding */ nonDivisibleSequentialTransactionPlan),\n/* harmony export */   nonDivisibleSequentialTransactionPlanResult: () => (/* binding */ nonDivisibleSequentialTransactionPlanResult),\n/* harmony export */   parallelInstructionPlan: () => (/* binding */ parallelInstructionPlan),\n/* harmony export */   parallelTransactionPlan: () => (/* binding */ parallelTransactionPlan),\n/* harmony export */   parallelTransactionPlanResult: () => (/* binding */ parallelTransactionPlanResult),\n/* harmony export */   passthroughFailedTransactionPlanExecution: () => (/* binding */ passthroughFailedTransactionPlanExecution),\n/* harmony export */   sequentialInstructionPlan: () => (/* binding */ sequentialInstructionPlan),\n/* harmony export */   sequentialTransactionPlan: () => (/* binding */ sequentialTransactionPlan),\n/* harmony export */   sequentialTransactionPlanResult: () => (/* binding */ sequentialTransactionPlanResult),\n/* harmony export */   singleInstructionPlan: () => (/* binding */ singleInstructionPlan),\n/* harmony export */   singleTransactionPlan: () => (/* binding */ singleTransactionPlan),\n/* harmony export */   successfulSingleTransactionPlanResult: () => (/* binding */ successfulSingleTransactionPlanResult),\n/* harmony export */   successfulSingleTransactionPlanResultFromSignature: () => (/* binding */ successfulSingleTransactionPlanResultFromSignature),\n/* harmony export */   summarizeTransactionPlanResult: () => (/* binding */ summarizeTransactionPlanResult),\n/* harmony export */   transformInstructionPlan: () => (/* binding */ transformInstructionPlan),\n/* harmony export */   transformTransactionPlan: () => (/* binding */ transformTransactionPlan),\n/* harmony export */   transformTransactionPlanResult: () => (/* binding */ transformTransactionPlanResult)\n/* harmony export */ });\n/* harmony import */ var _solana_errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/errors */ \"(ssr)/./node_modules/@solana/errors/dist/index.node.mjs\");\n/* harmony import */ var _solana_transaction_messages__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @solana/transaction-messages */ \"(ssr)/./node_modules/@solana/transaction-messages/dist/index.node.mjs\");\n/* harmony import */ var _solana_transactions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana/transactions */ \"(ssr)/./node_modules/@solana/transactions/dist/index.node.mjs\");\n/* harmony import */ var _solana_promises__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @solana/promises */ \"(ssr)/./node_modules/@solana/promises/dist/index.node.mjs\");\n\n\n\n\n// src/append-instruction-plan.ts\nfunction parallelInstructionPlan(plans) {\n    return Object.freeze({\n        kind: \"parallel\",\n        plans: parseSingleInstructionPlans(plans)\n    });\n}\nfunction sequentialInstructionPlan(plans) {\n    return Object.freeze({\n        divisible: true,\n        kind: \"sequential\",\n        plans: parseSingleInstructionPlans(plans)\n    });\n}\nfunction nonDivisibleSequentialInstructionPlan(plans) {\n    return Object.freeze({\n        divisible: false,\n        kind: \"sequential\",\n        plans: parseSingleInstructionPlans(plans)\n    });\n}\nfunction singleInstructionPlan(instruction) {\n    return Object.freeze({\n        instruction,\n        kind: \"single\"\n    });\n}\nfunction parseSingleInstructionPlans(plans) {\n    return plans.map((plan)=>\"kind\" in plan ? plan : singleInstructionPlan(plan));\n}\nfunction isSingleInstructionPlan(plan) {\n    return plan.kind === \"single\";\n}\nfunction assertIsSingleInstructionPlan(plan) {\n    if (!isSingleInstructionPlan(plan)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_INSTRUCTION_PLAN, {\n            actualKind: plan.kind,\n            expectedKind: \"single\",\n            instructionPlan: plan\n        });\n    }\n}\nfunction isMessagePackerInstructionPlan(plan) {\n    return plan.kind === \"messagePacker\";\n}\nfunction assertIsMessagePackerInstructionPlan(plan) {\n    if (!isMessagePackerInstructionPlan(plan)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_INSTRUCTION_PLAN, {\n            actualKind: plan.kind,\n            expectedKind: \"messagePacker\",\n            instructionPlan: plan\n        });\n    }\n}\nfunction isSequentialInstructionPlan(plan) {\n    return plan.kind === \"sequential\";\n}\nfunction assertIsSequentialInstructionPlan(plan) {\n    if (!isSequentialInstructionPlan(plan)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_INSTRUCTION_PLAN, {\n            actualKind: plan.kind,\n            expectedKind: \"sequential\",\n            instructionPlan: plan\n        });\n    }\n}\nfunction isNonDivisibleSequentialInstructionPlan(plan) {\n    return plan.kind === \"sequential\" && plan.divisible === false;\n}\nfunction assertIsNonDivisibleSequentialInstructionPlan(plan) {\n    if (!isNonDivisibleSequentialInstructionPlan(plan)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_INSTRUCTION_PLAN, {\n            actualKind: plan.kind === \"sequential\" ? \"divisible sequential\" : plan.kind,\n            expectedKind: \"non-divisible sequential\",\n            instructionPlan: plan\n        });\n    }\n}\nfunction isParallelInstructionPlan(plan) {\n    return plan.kind === \"parallel\";\n}\nfunction assertIsParallelInstructionPlan(plan) {\n    if (!isParallelInstructionPlan(plan)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_INSTRUCTION_PLAN, {\n            actualKind: plan.kind,\n            expectedKind: \"parallel\",\n            instructionPlan: plan\n        });\n    }\n}\nfunction findInstructionPlan(instructionPlan, predicate) {\n    if (predicate(instructionPlan)) {\n        return instructionPlan;\n    }\n    if (instructionPlan.kind === \"single\" || instructionPlan.kind === \"messagePacker\") {\n        return void 0;\n    }\n    for (const subPlan of instructionPlan.plans){\n        const foundPlan = findInstructionPlan(subPlan, predicate);\n        if (foundPlan) {\n            return foundPlan;\n        }\n    }\n    return void 0;\n}\nfunction everyInstructionPlan(instructionPlan, predicate) {\n    if (!predicate(instructionPlan)) {\n        return false;\n    }\n    if (instructionPlan.kind === \"single\" || instructionPlan.kind === \"messagePacker\") {\n        return true;\n    }\n    return instructionPlan.plans.every((p)=>everyInstructionPlan(p, predicate));\n}\nfunction transformInstructionPlan(instructionPlan, fn) {\n    if (instructionPlan.kind === \"single\" || instructionPlan.kind === \"messagePacker\") {\n        return Object.freeze(fn(instructionPlan));\n    }\n    return Object.freeze(fn(Object.freeze({\n        ...instructionPlan,\n        plans: instructionPlan.plans.map((p)=>transformInstructionPlan(p, fn))\n    })));\n}\nfunction flattenInstructionPlan(instructionPlan) {\n    if (instructionPlan.kind === \"single\" || instructionPlan.kind === \"messagePacker\") {\n        return [\n            instructionPlan\n        ];\n    }\n    return instructionPlan.plans.flatMap(flattenInstructionPlan);\n}\nfunction getLinearMessagePackerInstructionPlan({ getInstruction, totalLength: totalBytes }) {\n    return Object.freeze({\n        getMessagePacker: ()=>{\n            let offset = 0;\n            return Object.freeze({\n                done: ()=>offset >= totalBytes,\n                packMessageToCapacity: (message)=>{\n                    if (offset >= totalBytes) {\n                        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE);\n                    }\n                    const messageSizeWithBaseInstruction = (0,_solana_transactions__WEBPACK_IMPORTED_MODULE_1__.getTransactionMessageSize)((0,_solana_transaction_messages__WEBPACK_IMPORTED_MODULE_2__.appendTransactionMessageInstruction)(getInstruction(offset, 0), message));\n                    const freeSpace = _solana_transactions__WEBPACK_IMPORTED_MODULE_1__.TRANSACTION_SIZE_LIMIT - messageSizeWithBaseInstruction - 1;\n                    if (freeSpace <= 0) {\n                        const messageSize = (0,_solana_transactions__WEBPACK_IMPORTED_MODULE_1__.getTransactionMessageSize)(message);\n                        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN, {\n                            // (+1) We need to pack at least one byte of data otherwise\n                            // there is no point packing the base instruction alone.\n                            numBytesRequired: messageSizeWithBaseInstruction - messageSize + 1,\n                            // (-1) Leeway for shortU16 numbers in transaction headers.\n                            numFreeBytes: _solana_transactions__WEBPACK_IMPORTED_MODULE_1__.TRANSACTION_SIZE_LIMIT - messageSize - 1\n                        });\n                    }\n                    const length = Math.min(totalBytes - offset, freeSpace);\n                    const instruction = getInstruction(offset, length);\n                    offset += length;\n                    return (0,_solana_transaction_messages__WEBPACK_IMPORTED_MODULE_2__.appendTransactionMessageInstruction)(instruction, message);\n                }\n            });\n        },\n        kind: \"messagePacker\"\n    });\n}\nfunction getMessagePackerInstructionPlanFromInstructions(instructions) {\n    return Object.freeze({\n        getMessagePacker: ()=>{\n            let instructionIndex = 0;\n            return Object.freeze({\n                done: ()=>instructionIndex >= instructions.length,\n                packMessageToCapacity: (message)=>{\n                    if (instructionIndex >= instructions.length) {\n                        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE);\n                    }\n                    const originalMessageSize = (0,_solana_transactions__WEBPACK_IMPORTED_MODULE_1__.getTransactionMessageSize)(message);\n                    for(let index = instructionIndex; index < instructions.length; index++){\n                        message = (0,_solana_transaction_messages__WEBPACK_IMPORTED_MODULE_2__.appendTransactionMessageInstruction)(instructions[index], message);\n                        const messageSize = (0,_solana_transactions__WEBPACK_IMPORTED_MODULE_1__.getTransactionMessageSize)(message);\n                        if (messageSize > _solana_transactions__WEBPACK_IMPORTED_MODULE_1__.TRANSACTION_SIZE_LIMIT) {\n                            if (index === instructionIndex) {\n                                throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN, {\n                                    numBytesRequired: messageSize - originalMessageSize,\n                                    numFreeBytes: _solana_transactions__WEBPACK_IMPORTED_MODULE_1__.TRANSACTION_SIZE_LIMIT - originalMessageSize\n                                });\n                            }\n                            instructionIndex = index;\n                            return message;\n                        }\n                    }\n                    instructionIndex = instructions.length;\n                    return message;\n                }\n            });\n        },\n        kind: \"messagePacker\"\n    });\n}\nvar REALLOC_LIMIT = 10240;\nfunction getReallocMessagePackerInstructionPlan({ getInstruction, totalSize }) {\n    const numberOfInstructions = Math.ceil(totalSize / REALLOC_LIMIT);\n    const lastInstructionSize = totalSize % REALLOC_LIMIT;\n    const instructions = new Array(numberOfInstructions).fill(0).map((_, i)=>getInstruction(i === numberOfInstructions - 1 ? lastInstructionSize : REALLOC_LIMIT));\n    return getMessagePackerInstructionPlanFromInstructions(instructions);\n}\n// src/append-instruction-plan.ts\nfunction appendTransactionMessageInstructionPlan(instructionPlan, transactionMessage) {\n    const leafInstructionPlans = flattenInstructionPlan(instructionPlan);\n    return leafInstructionPlans.reduce((messageSoFar, plan)=>{\n        const kind = plan.kind;\n        if (kind === \"single\") {\n            return (0,_solana_transaction_messages__WEBPACK_IMPORTED_MODULE_2__.appendTransactionMessageInstruction)(plan.instruction, messageSoFar);\n        }\n        if (kind === \"messagePacker\") {\n            const messagerPacker = plan.getMessagePacker();\n            let nextMessage = messageSoFar;\n            while(!messagerPacker.done()){\n                nextMessage = messagerPacker.packMessageToCapacity(nextMessage);\n            }\n            return nextMessage;\n        }\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND, {\n            kind\n        });\n    }, transactionMessage);\n}\nfunction parallelTransactionPlan(plans) {\n    return Object.freeze({\n        kind: \"parallel\",\n        plans: parseSingleTransactionPlans(plans)\n    });\n}\nfunction sequentialTransactionPlan(plans) {\n    return Object.freeze({\n        divisible: true,\n        kind: \"sequential\",\n        plans: parseSingleTransactionPlans(plans)\n    });\n}\nfunction nonDivisibleSequentialTransactionPlan(plans) {\n    return Object.freeze({\n        divisible: false,\n        kind: \"sequential\",\n        plans: parseSingleTransactionPlans(plans)\n    });\n}\nfunction singleTransactionPlan(transactionMessage) {\n    return Object.freeze({\n        kind: \"single\",\n        message: transactionMessage\n    });\n}\nfunction parseSingleTransactionPlans(plans) {\n    return plans.map((plan)=>\"kind\" in plan ? plan : singleTransactionPlan(plan));\n}\nfunction isSingleTransactionPlan(plan) {\n    return plan.kind === \"single\";\n}\nfunction assertIsSingleTransactionPlan(plan) {\n    if (!isSingleTransactionPlan(plan)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN, {\n            actualKind: plan.kind,\n            expectedKind: \"single\",\n            transactionPlan: plan\n        });\n    }\n}\nfunction isSequentialTransactionPlan(plan) {\n    return plan.kind === \"sequential\";\n}\nfunction assertIsSequentialTransactionPlan(plan) {\n    if (!isSequentialTransactionPlan(plan)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN, {\n            actualKind: plan.kind,\n            expectedKind: \"sequential\",\n            transactionPlan: plan\n        });\n    }\n}\nfunction isNonDivisibleSequentialTransactionPlan(plan) {\n    return plan.kind === \"sequential\" && plan.divisible === false;\n}\nfunction assertIsNonDivisibleSequentialTransactionPlan(plan) {\n    if (!isNonDivisibleSequentialTransactionPlan(plan)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN, {\n            actualKind: plan.kind === \"sequential\" ? \"divisible sequential\" : plan.kind,\n            expectedKind: \"non-divisible sequential\",\n            transactionPlan: plan\n        });\n    }\n}\nfunction isParallelTransactionPlan(plan) {\n    return plan.kind === \"parallel\";\n}\nfunction assertIsParallelTransactionPlan(plan) {\n    if (!isParallelTransactionPlan(plan)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN, {\n            actualKind: plan.kind,\n            expectedKind: \"parallel\",\n            transactionPlan: plan\n        });\n    }\n}\nvar getAllSingleTransactionPlans = flattenTransactionPlan;\nfunction flattenTransactionPlan(transactionPlan) {\n    if (transactionPlan.kind === \"single\") {\n        return [\n            transactionPlan\n        ];\n    }\n    return transactionPlan.plans.flatMap(flattenTransactionPlan);\n}\nfunction findTransactionPlan(transactionPlan, predicate) {\n    if (predicate(transactionPlan)) {\n        return transactionPlan;\n    }\n    if (transactionPlan.kind === \"single\") {\n        return void 0;\n    }\n    for (const subPlan of transactionPlan.plans){\n        const foundPlan = findTransactionPlan(subPlan, predicate);\n        if (foundPlan) {\n            return foundPlan;\n        }\n    }\n    return void 0;\n}\nfunction everyTransactionPlan(transactionPlan, predicate) {\n    if (!predicate(transactionPlan)) {\n        return false;\n    }\n    if (transactionPlan.kind === \"single\") {\n        return true;\n    }\n    return transactionPlan.plans.every((p)=>everyTransactionPlan(p, predicate));\n}\nfunction transformTransactionPlan(transactionPlan, fn) {\n    if (transactionPlan.kind === \"single\") {\n        return Object.freeze(fn(transactionPlan));\n    }\n    return Object.freeze(fn(Object.freeze({\n        ...transactionPlan,\n        plans: transactionPlan.plans.map((p)=>transformTransactionPlan(p, fn))\n    })));\n}\nfunction sequentialTransactionPlanResult(plans) {\n    return Object.freeze({\n        divisible: true,\n        kind: \"sequential\",\n        plans\n    });\n}\nfunction nonDivisibleSequentialTransactionPlanResult(plans) {\n    return Object.freeze({\n        divisible: false,\n        kind: \"sequential\",\n        plans\n    });\n}\nfunction parallelTransactionPlanResult(plans) {\n    return Object.freeze({\n        kind: \"parallel\",\n        plans\n    });\n}\nfunction successfulSingleTransactionPlanResult(transactionMessage, transaction, context) {\n    return Object.freeze({\n        kind: \"single\",\n        message: transactionMessage,\n        status: Object.freeze({\n            context: context ?? {},\n            kind: \"successful\",\n            signature: (0,_solana_transactions__WEBPACK_IMPORTED_MODULE_1__.getSignatureFromTransaction)(transaction),\n            transaction\n        })\n    });\n}\nfunction successfulSingleTransactionPlanResultFromSignature(transactionMessage, signature, context) {\n    return Object.freeze({\n        kind: \"single\",\n        message: transactionMessage,\n        status: Object.freeze({\n            context: context ?? {},\n            kind: \"successful\",\n            signature\n        })\n    });\n}\nfunction failedSingleTransactionPlanResult(transactionMessage, error) {\n    return Object.freeze({\n        kind: \"single\",\n        message: transactionMessage,\n        status: Object.freeze({\n            error,\n            kind: \"failed\"\n        })\n    });\n}\nfunction canceledSingleTransactionPlanResult(transactionMessage) {\n    return Object.freeze({\n        kind: \"single\",\n        message: transactionMessage,\n        status: Object.freeze({\n            kind: \"canceled\"\n        })\n    });\n}\nfunction isSingleTransactionPlanResult(plan) {\n    return plan.kind === \"single\";\n}\nfunction assertIsSingleTransactionPlanResult(plan) {\n    if (!isSingleTransactionPlanResult(plan)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT, {\n            actualKind: plan.kind,\n            expectedKind: \"single\",\n            transactionPlanResult: plan\n        });\n    }\n}\nfunction isSuccessfulSingleTransactionPlanResult(plan) {\n    return plan.kind === \"single\" && plan.status.kind === \"successful\";\n}\nfunction assertIsSuccessfulSingleTransactionPlanResult(plan) {\n    if (!isSuccessfulSingleTransactionPlanResult(plan)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT, {\n            actualKind: plan.kind === \"single\" ? `${plan.status.kind} single` : plan.kind,\n            expectedKind: \"successful single\",\n            transactionPlanResult: plan\n        });\n    }\n}\nfunction isFailedSingleTransactionPlanResult(plan) {\n    return plan.kind === \"single\" && plan.status.kind === \"failed\";\n}\nfunction assertIsFailedSingleTransactionPlanResult(plan) {\n    if (!isFailedSingleTransactionPlanResult(plan)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT, {\n            actualKind: plan.kind === \"single\" ? `${plan.status.kind} single` : plan.kind,\n            expectedKind: \"failed single\",\n            transactionPlanResult: plan\n        });\n    }\n}\nfunction isCanceledSingleTransactionPlanResult(plan) {\n    return plan.kind === \"single\" && plan.status.kind === \"canceled\";\n}\nfunction assertIsCanceledSingleTransactionPlanResult(plan) {\n    if (!isCanceledSingleTransactionPlanResult(plan)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT, {\n            actualKind: plan.kind === \"single\" ? `${plan.status.kind} single` : plan.kind,\n            expectedKind: \"canceled single\",\n            transactionPlanResult: plan\n        });\n    }\n}\nfunction isSequentialTransactionPlanResult(plan) {\n    return plan.kind === \"sequential\";\n}\nfunction assertIsSequentialTransactionPlanResult(plan) {\n    if (!isSequentialTransactionPlanResult(plan)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT, {\n            actualKind: plan.kind,\n            expectedKind: \"sequential\",\n            transactionPlanResult: plan\n        });\n    }\n}\nfunction isNonDivisibleSequentialTransactionPlanResult(plan) {\n    return plan.kind === \"sequential\" && plan.divisible === false;\n}\nfunction assertIsNonDivisibleSequentialTransactionPlanResult(plan) {\n    if (!isNonDivisibleSequentialTransactionPlanResult(plan)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT, {\n            actualKind: plan.kind === \"sequential\" ? \"divisible sequential\" : plan.kind,\n            expectedKind: \"non-divisible sequential\",\n            transactionPlanResult: plan\n        });\n    }\n}\nfunction isParallelTransactionPlanResult(plan) {\n    return plan.kind === \"parallel\";\n}\nfunction assertIsParallelTransactionPlanResult(plan) {\n    if (!isParallelTransactionPlanResult(plan)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__INSTRUCTION_PLANS__UNEXPECTED_TRANSACTION_PLAN_RESULT, {\n            actualKind: plan.kind,\n            expectedKind: \"parallel\",\n            transactionPlanResult: plan\n        });\n    }\n}\nfunction isSuccessfulTransactionPlanResult(plan) {\n    return everyTransactionPlanResult(plan, (r)=>!isSingleTransactionPlanResult(r) || isSuccessfulSingleTransactionPlanResult(r));\n}\nfunction assertIsSuccessfulTransactionPlanResult(plan) {\n    if (!isSuccessfulTransactionPlanResult(plan)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__INSTRUCTION_PLANS__EXPECTED_SUCCESSFUL_TRANSACTION_PLAN_RESULT, {\n            transactionPlanResult: plan\n        });\n    }\n}\nfunction findTransactionPlanResult(transactionPlanResult, predicate) {\n    if (predicate(transactionPlanResult)) {\n        return transactionPlanResult;\n    }\n    if (transactionPlanResult.kind === \"single\") {\n        return void 0;\n    }\n    for (const subResult of transactionPlanResult.plans){\n        const foundResult = findTransactionPlanResult(subResult, predicate);\n        if (foundResult) {\n            return foundResult;\n        }\n    }\n    return void 0;\n}\nfunction getFirstFailedSingleTransactionPlanResult(transactionPlanResult) {\n    const result = findTransactionPlanResult(transactionPlanResult, (r)=>r.kind === \"single\" && r.status.kind === \"failed\");\n    if (!result) {\n        const context = {};\n        Object.defineProperty(context, \"transactionPlanResult\", {\n            configurable: false,\n            enumerable: false,\n            value: transactionPlanResult,\n            writable: false\n        });\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_SINGLE_TRANSACTION_PLAN_RESULT_NOT_FOUND, context);\n    }\n    return result;\n}\nfunction everyTransactionPlanResult(transactionPlanResult, predicate) {\n    if (!predicate(transactionPlanResult)) {\n        return false;\n    }\n    if (transactionPlanResult.kind === \"single\") {\n        return true;\n    }\n    return transactionPlanResult.plans.every((p)=>everyTransactionPlanResult(p, predicate));\n}\nfunction transformTransactionPlanResult(transactionPlanResult, fn) {\n    if (transactionPlanResult.kind === \"single\") {\n        return Object.freeze(fn(transactionPlanResult));\n    }\n    return Object.freeze(fn(Object.freeze({\n        ...transactionPlanResult,\n        plans: transactionPlanResult.plans.map((p)=>transformTransactionPlanResult(p, fn))\n    })));\n}\nfunction flattenTransactionPlanResult(result) {\n    if (result.kind === \"single\") {\n        return [\n            result\n        ];\n    }\n    return result.plans.flatMap(flattenTransactionPlanResult);\n}\nfunction summarizeTransactionPlanResult(result) {\n    const successfulTransactions = [];\n    const failedTransactions = [];\n    const canceledTransactions = [];\n    const flattenedResults = flattenTransactionPlanResult(result);\n    for (const singleResult of flattenedResults){\n        switch(singleResult.status.kind){\n            case \"successful\":\n                {\n                    successfulTransactions.push(singleResult);\n                    break;\n                }\n            case \"failed\":\n                {\n                    failedTransactions.push(singleResult);\n                    break;\n                }\n            case \"canceled\":\n                {\n                    canceledTransactions.push(singleResult);\n                    break;\n                }\n        }\n    }\n    return Object.freeze({\n        canceledTransactions,\n        failedTransactions,\n        successful: failedTransactions.length === 0 && canceledTransactions.length === 0,\n        successfulTransactions\n    });\n}\n// src/transaction-plan-executor.ts\nfunction createTransactionPlanExecutor(config) {\n    return async (plan, { abortSignal } = {})=>{\n        const context = {\n            ...config,\n            abortSignal,\n            canceled: abortSignal?.aborted ?? false\n        };\n        assertDivisibleSequentialPlansOnly(plan);\n        const cancelHandler = ()=>{\n            context.canceled = true;\n        };\n        abortSignal?.addEventListener(\"abort\", cancelHandler);\n        const transactionPlanResult = await traverse(plan, context);\n        abortSignal?.removeEventListener(\"abort\", cancelHandler);\n        if (context.canceled) {\n            const abortReason = abortSignal?.aborted ? abortSignal.reason : void 0;\n            const context2 = {\n                cause: findErrorFromTransactionPlanResult(transactionPlanResult) ?? abortReason\n            };\n            Object.defineProperty(context2, \"transactionPlanResult\", {\n                configurable: false,\n                enumerable: false,\n                value: transactionPlanResult,\n                writable: false\n            });\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN, context2);\n        }\n        return transactionPlanResult;\n    };\n}\nasync function traverse(transactionPlan, context) {\n    const kind = transactionPlan.kind;\n    switch(kind){\n        case \"sequential\":\n            return await traverseSequential(transactionPlan, context);\n        case \"parallel\":\n            return await traverseParallel(transactionPlan, context);\n        case \"single\":\n            return await traverseSingle(transactionPlan, context);\n        default:\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND, {\n                kind\n            });\n    }\n}\nasync function traverseSequential(transactionPlan, context) {\n    if (!transactionPlan.divisible) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__INSTRUCTION_PLANS__NON_DIVISIBLE_TRANSACTION_PLANS_NOT_SUPPORTED);\n    }\n    const results = [];\n    for (const subPlan of transactionPlan.plans){\n        const result = await traverse(subPlan, context);\n        results.push(result);\n    }\n    return sequentialTransactionPlanResult(results);\n}\nasync function traverseParallel(transactionPlan, context) {\n    const results = await Promise.all(transactionPlan.plans.map((plan)=>traverse(plan, context)));\n    return parallelTransactionPlanResult(results);\n}\nasync function traverseSingle(transactionPlan, context) {\n    if (context.canceled) {\n        return canceledSingleTransactionPlanResult(transactionPlan.message);\n    }\n    try {\n        const result = await (0,_solana_promises__WEBPACK_IMPORTED_MODULE_3__.getAbortablePromise)(context.executeTransactionMessage(transactionPlan.message, {\n            abortSignal: context.abortSignal\n        }), context.abortSignal);\n        if (\"transaction\" in result) {\n            return successfulSingleTransactionPlanResult(transactionPlan.message, result.transaction, result.context);\n        } else {\n            return successfulSingleTransactionPlanResultFromSignature(transactionPlan.message, result.signature, result.context);\n        }\n    } catch (error) {\n        context.canceled = true;\n        return failedSingleTransactionPlanResult(transactionPlan.message, error);\n    }\n}\nfunction findErrorFromTransactionPlanResult(result) {\n    if (result.kind === \"single\") {\n        return result.status.kind === \"failed\" ? result.status.error : void 0;\n    }\n    for (const plan of result.plans){\n        const error = findErrorFromTransactionPlanResult(plan);\n        if (error) {\n            return error;\n        }\n    }\n}\nfunction assertDivisibleSequentialPlansOnly(transactionPlan) {\n    const kind = transactionPlan.kind;\n    switch(kind){\n        case \"sequential\":\n            if (!transactionPlan.divisible) {\n                throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__INSTRUCTION_PLANS__NON_DIVISIBLE_TRANSACTION_PLANS_NOT_SUPPORTED);\n            }\n            for (const subPlan of transactionPlan.plans){\n                assertDivisibleSequentialPlansOnly(subPlan);\n            }\n            return;\n        case \"parallel\":\n            for (const subPlan of transactionPlan.plans){\n                assertDivisibleSequentialPlansOnly(subPlan);\n            }\n            return;\n        case \"single\":\n        default:\n            return;\n    }\n}\nasync function passthroughFailedTransactionPlanExecution(promise) {\n    try {\n        return await promise;\n    } catch (error) {\n        if ((0,_solana_errors__WEBPACK_IMPORTED_MODULE_0__.isSolanaError)(error, _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN)) {\n            return error.context.transactionPlanResult;\n        }\n        throw error;\n    }\n}\nfunction createTransactionPlanner(config) {\n    return async (instructionPlan, { abortSignal } = {})=>{\n        const plan = await traverse2(instructionPlan, {\n            abortSignal,\n            createTransactionMessage: config.createTransactionMessage,\n            onTransactionMessageUpdated: config.onTransactionMessageUpdated ?? ((msg)=>msg),\n            parent: null,\n            parentCandidates: []\n        });\n        if (!plan) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__INSTRUCTION_PLANS__EMPTY_INSTRUCTION_PLAN);\n        }\n        return freezeTransactionPlan(plan);\n    };\n}\nasync function traverse2(instructionPlan, context) {\n    context.abortSignal?.throwIfAborted();\n    const kind = instructionPlan.kind;\n    switch(kind){\n        case \"sequential\":\n            return await traverseSequential2(instructionPlan, context);\n        case \"parallel\":\n            return await traverseParallel2(instructionPlan, context);\n        case \"single\":\n            return await traverseSingle2(instructionPlan, context);\n        case \"messagePacker\":\n            return await traverseMessagePacker(instructionPlan, context);\n        default:\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND, {\n                kind\n            });\n    }\n}\nasync function traverseSequential2(instructionPlan, context) {\n    let candidate = null;\n    const mustEntirelyFitInParentCandidate = context.parent && (context.parent.kind === \"parallel\" || !instructionPlan.divisible);\n    if (mustEntirelyFitInParentCandidate) {\n        const candidate2 = await selectAndMutateCandidate(context, context.parentCandidates, (message)=>fitEntirePlanInsideMessage(instructionPlan, message));\n        if (candidate2) {\n            return null;\n        }\n    } else {\n        candidate = context.parentCandidates.length > 0 ? context.parentCandidates[0] : null;\n    }\n    const transactionPlans = [];\n    for (const plan of instructionPlan.plans){\n        const transactionPlan = await traverse2(plan, {\n            ...context,\n            parent: instructionPlan,\n            parentCandidates: candidate ? [\n                candidate\n            ] : []\n        });\n        if (transactionPlan) {\n            candidate = getSequentialCandidate(transactionPlan);\n            const newPlans = transactionPlan.kind === \"sequential\" && (transactionPlan.divisible || !instructionPlan.divisible) ? transactionPlan.plans : [\n                transactionPlan\n            ];\n            transactionPlans.push(...newPlans);\n        }\n    }\n    if (transactionPlans.length === 1) {\n        return transactionPlans[0];\n    }\n    if (transactionPlans.length === 0) {\n        return null;\n    }\n    return {\n        divisible: instructionPlan.divisible,\n        kind: \"sequential\",\n        plans: transactionPlans\n    };\n}\nasync function traverseParallel2(instructionPlan, context) {\n    const candidates = [\n        ...context.parentCandidates\n    ];\n    const transactionPlans = [];\n    const sortedChildren = Array.from(instructionPlan.plans).sort((a, b)=>Number(a.kind === \"messagePacker\") - Number(b.kind === \"messagePacker\"));\n    for (const plan of sortedChildren){\n        const transactionPlan = await traverse2(plan, {\n            ...context,\n            parent: instructionPlan,\n            parentCandidates: candidates\n        });\n        if (transactionPlan) {\n            candidates.push(...getParallelCandidates(transactionPlan));\n            const newPlans = transactionPlan.kind === \"parallel\" ? transactionPlan.plans : [\n                transactionPlan\n            ];\n            transactionPlans.push(...newPlans);\n        }\n    }\n    if (transactionPlans.length === 1) {\n        return transactionPlans[0];\n    }\n    if (transactionPlans.length === 0) {\n        return null;\n    }\n    return {\n        kind: \"parallel\",\n        plans: transactionPlans\n    };\n}\nasync function traverseSingle2(instructionPlan, context) {\n    const predicate = (message2)=>(0,_solana_transaction_messages__WEBPACK_IMPORTED_MODULE_2__.appendTransactionMessageInstructions)([\n            instructionPlan.instruction\n        ], message2);\n    const candidate = await selectAndMutateCandidate(context, context.parentCandidates, predicate);\n    if (candidate) {\n        return null;\n    }\n    const message = await createNewMessage(context, predicate);\n    return {\n        kind: \"single\",\n        message\n    };\n}\nasync function traverseMessagePacker(instructionPlan, context) {\n    const messagePacker = instructionPlan.getMessagePacker();\n    const transactionPlans = [];\n    const candidates = [\n        ...context.parentCandidates\n    ];\n    while(!messagePacker.done()){\n        const candidate = await selectAndMutateCandidate(context, candidates, messagePacker.packMessageToCapacity);\n        if (!candidate) {\n            const message = await createNewMessage(context, messagePacker.packMessageToCapacity);\n            const newPlan = {\n                kind: \"single\",\n                message\n            };\n            transactionPlans.push(newPlan);\n        }\n    }\n    if (transactionPlans.length === 1) {\n        return transactionPlans[0];\n    }\n    if (transactionPlans.length === 0) {\n        return null;\n    }\n    if (context.parent?.kind === \"parallel\") {\n        return {\n            kind: \"parallel\",\n            plans: transactionPlans\n        };\n    }\n    return {\n        divisible: context.parent?.kind === \"sequential\" ? context.parent.divisible : true,\n        kind: \"sequential\",\n        plans: transactionPlans\n    };\n}\nfunction getSequentialCandidate(latestPlan) {\n    if (latestPlan.kind === \"single\") {\n        return latestPlan;\n    }\n    if (latestPlan.kind === \"sequential\" && latestPlan.plans.length > 0) {\n        return getSequentialCandidate(latestPlan.plans[latestPlan.plans.length - 1]);\n    }\n    return null;\n}\nfunction getParallelCandidates(latestPlan) {\n    return flattenTransactionPlan(latestPlan);\n}\nasync function selectAndMutateCandidate(context, candidates, predicate) {\n    for (const candidate of candidates){\n        try {\n            const message = await (0,_solana_promises__WEBPACK_IMPORTED_MODULE_3__.getAbortablePromise)(Promise.resolve(context.onTransactionMessageUpdated(predicate(candidate.message), {\n                abortSignal: context.abortSignal\n            })), context.abortSignal);\n            if ((0,_solana_transactions__WEBPACK_IMPORTED_MODULE_1__.getTransactionMessageSize)(message) <= _solana_transactions__WEBPACK_IMPORTED_MODULE_1__.TRANSACTION_SIZE_LIMIT) {\n                candidate.message = message;\n                return candidate;\n            }\n        } catch (error) {\n            if ((0,_solana_errors__WEBPACK_IMPORTED_MODULE_0__.isSolanaError)(error, _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN)) ;\n            else {\n                throw error;\n            }\n        }\n    }\n    return null;\n}\nasync function createNewMessage(context, predicate) {\n    const newMessage = await (0,_solana_promises__WEBPACK_IMPORTED_MODULE_3__.getAbortablePromise)(Promise.resolve(context.createTransactionMessage({\n        abortSignal: context.abortSignal\n    })), context.abortSignal);\n    const updatedMessage = await (0,_solana_promises__WEBPACK_IMPORTED_MODULE_3__.getAbortablePromise)(Promise.resolve(context.onTransactionMessageUpdated(predicate(newMessage), {\n        abortSignal: context.abortSignal\n    })), context.abortSignal);\n    const updatedMessageSize = (0,_solana_transactions__WEBPACK_IMPORTED_MODULE_1__.getTransactionMessageSize)(updatedMessage);\n    if (updatedMessageSize > _solana_transactions__WEBPACK_IMPORTED_MODULE_1__.TRANSACTION_SIZE_LIMIT) {\n        const newMessageSize = (0,_solana_transactions__WEBPACK_IMPORTED_MODULE_1__.getTransactionMessageSize)(newMessage);\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN, {\n            numBytesRequired: updatedMessageSize - newMessageSize,\n            numFreeBytes: _solana_transactions__WEBPACK_IMPORTED_MODULE_1__.TRANSACTION_SIZE_LIMIT - newMessageSize\n        });\n    }\n    return updatedMessage;\n}\nfunction freezeTransactionPlan(plan) {\n    const kind = plan.kind;\n    switch(kind){\n        case \"single\":\n            return singleTransactionPlan(plan.message);\n        case \"sequential\":\n            return plan.divisible ? sequentialTransactionPlan(plan.plans.map(freezeTransactionPlan)) : nonDivisibleSequentialTransactionPlan(plan.plans.map(freezeTransactionPlan));\n        case \"parallel\":\n            return parallelTransactionPlan(plan.plans.map(freezeTransactionPlan));\n        default:\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND, {\n                kind\n            });\n    }\n}\nfunction fitEntirePlanInsideMessage(instructionPlan, message) {\n    let newMessage = message;\n    const kind = instructionPlan.kind;\n    switch(kind){\n        case \"sequential\":\n        case \"parallel\":\n            for (const plan of instructionPlan.plans){\n                newMessage = fitEntirePlanInsideMessage(plan, newMessage);\n            }\n            return newMessage;\n        case \"single\":\n            newMessage = (0,_solana_transaction_messages__WEBPACK_IMPORTED_MODULE_2__.appendTransactionMessageInstructions)([\n                instructionPlan.instruction\n            ], message);\n            const newMessageSize = (0,_solana_transactions__WEBPACK_IMPORTED_MODULE_1__.getTransactionMessageSize)(newMessage);\n            if (newMessageSize > _solana_transactions__WEBPACK_IMPORTED_MODULE_1__.TRANSACTION_SIZE_LIMIT) {\n                const baseMessageSize = (0,_solana_transactions__WEBPACK_IMPORTED_MODULE_1__.getTransactionMessageSize)(message);\n                throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN, {\n                    numBytesRequired: newMessageSize - baseMessageSize,\n                    numFreeBytes: _solana_transactions__WEBPACK_IMPORTED_MODULE_1__.TRANSACTION_SIZE_LIMIT - baseMessageSize\n                });\n            }\n            return newMessage;\n        case \"messagePacker\":\n            const messagePacker = instructionPlan.getMessagePacker();\n            while(!messagePacker.done()){\n                newMessage = messagePacker.packMessageToCapacity(newMessage);\n            }\n            return newMessage;\n        default:\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND, {\n                kind\n            });\n    }\n}\n //# sourceMappingURL=index.node.mjs.map\n //# sourceMappingURL=index.node.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS9pbnN0cnVjdGlvbi1wbGFucy9kaXN0L2luZGV4Lm5vZGUubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFtM0I7QUFDMXZCO0FBQ0g7QUFDL0Q7QUFFdkQsaUNBQWlDO0FBQ2pDLFNBQVNvQix3QkFBd0JDLEtBQUs7SUFDcEMsT0FBT0MsT0FBT0MsTUFBTSxDQUFDO1FBQ25CQyxNQUFNO1FBQ05ILE9BQU9JLDRCQUE0Qko7SUFDckM7QUFDRjtBQUNBLFNBQVNLLDBCQUEwQkwsS0FBSztJQUN0QyxPQUFPQyxPQUFPQyxNQUFNLENBQUM7UUFDbkJJLFdBQVc7UUFDWEgsTUFBTTtRQUNOSCxPQUFPSSw0QkFBNEJKO0lBQ3JDO0FBQ0Y7QUFDQSxTQUFTTyxzQ0FBc0NQLEtBQUs7SUFDbEQsT0FBT0MsT0FBT0MsTUFBTSxDQUFDO1FBQ25CSSxXQUFXO1FBQ1hILE1BQU07UUFDTkgsT0FBT0ksNEJBQTRCSjtJQUNyQztBQUNGO0FBQ0EsU0FBU1Esc0JBQXNCQyxXQUFXO0lBQ3hDLE9BQU9SLE9BQU9DLE1BQU0sQ0FBQztRQUFFTztRQUFhTixNQUFNO0lBQVM7QUFDckQ7QUFDQSxTQUFTQyw0QkFBNEJKLEtBQUs7SUFDeEMsT0FBT0EsTUFBTVUsR0FBRyxDQUFDLENBQUNDLE9BQVMsVUFBVUEsT0FBT0EsT0FBT0gsc0JBQXNCRztBQUMzRTtBQUNBLFNBQVNDLHdCQUF3QkQsSUFBSTtJQUNuQyxPQUFPQSxLQUFLUixJQUFJLEtBQUs7QUFDdkI7QUFDQSxTQUFTVSw4QkFBOEJGLElBQUk7SUFDekMsSUFBSSxDQUFDQyx3QkFBd0JELE9BQU87UUFDbEMsTUFBTSxJQUFJaEMsdURBQVdBLENBQUNDLHdHQUE0REEsRUFBRTtZQUNsRmtDLFlBQVlILEtBQUtSLElBQUk7WUFDckJZLGNBQWM7WUFDZEMs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RUFBc0JBLEdBQUdvTjtnQkFDekM7WUFDRjtZQUNBLE9BQU9KO1FBQ1QsS0FBSztZQUNILE1BQU1KLGdCQUFnQnhMLGdCQUFnQndCLGdCQUFnQjtZQUN0RCxNQUFPLENBQUNnSyxjQUFjOUosSUFBSSxHQUFJO2dCQUM1QmtLLGFBQWFKLGNBQWM3SixxQkFBcUIsQ0FBQ2lLO1lBQ25EO1lBQ0EsT0FBT0E7UUFDVDtZQUNFLE1BQU0sSUFBSWpPLHVEQUFXQSxDQUFDSSw0R0FBZ0VBLEVBQUU7Z0JBQUVvQjtZQUFLO0lBQ25HO0FBQ0Y7QUFFcTRFLENBQ3I0RSx1Q0FBdUM7Q0FDdkMsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xhdy13b3Jrcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL2luc3RydWN0aW9uLXBsYW5zL2Rpc3QvaW5kZXgubm9kZS5tanM/ZmQwMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTb2xhbmFFcnJvciwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9QTEFOU19fVU5FWFBFQ1RFRF9JTlNUUlVDVElPTl9QTEFOLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX1BMQU5TX19NRVNTQUdFX1BBQ0tFUl9BTFJFQURZX0NPTVBMRVRFLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX1BMQU5TX19NRVNTQUdFX0NBTk5PVF9BQ0NPTU1PREFURV9QTEFOLCBTT0xBTkFfRVJST1JfX0lOVkFSSUFOVF9WSU9MQVRJT05fX0lOVkFMSURfSU5TVFJVQ1RJT05fUExBTl9LSU5ELCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX1BMQU5TX19VTkVYUEVDVEVEX1RSQU5TQUNUSU9OX1BMQU4sIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fUExBTlNfX1VORVhQRUNURURfVFJBTlNBQ1RJT05fUExBTl9SRVNVTFQsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fUExBTlNfX0VYUEVDVEVEX1NVQ0NFU1NGVUxfVFJBTlNBQ1RJT05fUExBTl9SRVNVTFQsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fUExBTlNfX0ZBSUxFRF9TSU5HTEVfVFJBTlNBQ1RJT05fUExBTl9SRVNVTFRfTk9UX0ZPVU5ELCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX1BMQU5TX19GQUlMRURfVE9fRVhFQ1VURV9UUkFOU0FDVElPTl9QTEFOLCBTT0xBTkFfRVJST1JfX0lOVkFSSUFOVF9WSU9MQVRJT05fX0lOVkFMSURfVFJBTlNBQ1RJT05fUExBTl9LSU5ELCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX1BMQU5TX19OT05fRElWSVNJQkxFX1RSQU5TQUNUSU9OX1BMQU5TX05PVF9TVVBQT1JURUQsIGlzU29sYW5hRXJyb3IsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fUExBTlNfX0VNUFRZX0lOU1RSVUNUSU9OX1BMQU4gfSBmcm9tICdAc29sYW5hL2Vycm9ycyc7XG5pbXBvcnQgeyBhcHBlbmRUcmFuc2FjdGlvbk1lc3NhZ2VJbnN0cnVjdGlvbiwgYXBwZW5kVHJhbnNhY3Rpb25NZXNzYWdlSW5zdHJ1Y3Rpb25zIH0gZnJvbSAnQHNvbGFuYS90cmFuc2FjdGlvbi1tZXNzYWdlcyc7XG5pbXBvcnQgeyBnZXRUcmFuc2FjdGlvbk1lc3NhZ2VTaXplLCBUUkFOU0FDVElPTl9TSVpFX0xJTUlULCBnZXRTaWduYXR1cmVGcm9tVHJhbnNhY3Rpb24gfSBmcm9tICdAc29sYW5hL3RyYW5zYWN0aW9ucyc7XG5pbXBvcnQgeyBnZXRBYm9ydGFibGVQcm9taXNlIH0gZnJvbSAnQHNvbGFuYS9wcm9taXNlcyc7XG5cbi8vIHNyYy9hcHBlbmQtaW5zdHJ1Y3Rpb24tcGxhbi50c1xuZnVuY3Rpb24gcGFyYWxsZWxJbnN0cnVjdGlvblBsYW4ocGxhbnMpIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgIGtpbmQ6IFwicGFyYWxsZWxcIixcbiAgICBwbGFuczogcGFyc2VTaW5nbGVJbnN0cnVjdGlvblBsYW5zKHBsYW5zKVxuICB9KTtcbn1cbmZ1bmN0aW9uIHNlcXVlbnRpYWxJbnN0cnVjdGlvblBsYW4ocGxhbnMpIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgIGRpdmlzaWJsZTogdHJ1ZSxcbiAgICBraW5kOiBcInNlcXVlbnRpYWxcIixcbiAgICBwbGFuczogcGFyc2VTaW5nbGVJbnN0cnVjdGlvblBsYW5zKHBsYW5zKVxuICB9KTtcbn1cbmZ1bmN0aW9uIG5vbkRpdmlzaWJsZVNlcXVlbnRpYWxJbnN0cnVjdGlvblBsYW4ocGxhbnMpIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgIGRpdmlzaWJsZTogZmFsc2UsXG4gICAga2luZDogXCJzZXF1ZW50aWFsXCIsXG4gICAgcGxhbnM6IHBhcnNlU2luZ2xlSW5zdHJ1Y3Rpb25QbGFucyhwbGFucylcbiAgfSk7XG59XG5mdW5jdGlvbiBzaW5nbGVJbnN0cnVjdGlvblBsYW4oaW5zdHJ1Y3Rpb24pIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyBpbnN0cnVjdGlvbiwga2luZDogXCJzaW5nbGVcIiB9KTtcbn1cbmZ1bmN0aW9uIHBhcnNlU2luZ2xlSW5zdHJ1Y3Rpb25QbGFucyhwbGFucykge1xuICByZXR1cm4gcGxhbnMubWFwKChwbGFuKSA9PiBcImtpbmRcIiBpbiBwbGFuID8gcGxhbiA6IHNpbmdsZUluc3RydWN0aW9uUGxhbihwbGFuKSk7XG59XG5mdW5jdGlvbiBpc1NpbmdsZUluc3RydWN0aW9uUGxhbihwbGFuKSB7XG4gIHJldHVybiBwbGFuLmtpbmQgPT09IFwic2luZ2xlXCI7XG59XG5mdW5jdGlvbiBhc3NlcnRJc1NpbmdsZUluc3RydWN0aW9uUGxhbihwbGFuKSB7XG4gIGlmICghaXNTaW5nbGVJbnN0cnVjdGlvblBsYW4ocGxhbikpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9QTEFOU19fVU5FWFBFQ1RFRF9JTlNUUlVDVElPTl9QTEFOLCB7XG4gICAgICBhY3R1YWxLaW5kOiBwbGFuLmtpbmQsXG4gICAgICBleHBlY3RlZEtpbmQ6IFwic2luZ2xlXCIsXG4gICAgICBpbnN0cnVjdGlvblBsYW46IHBsYW5cbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gaXNNZXNzYWdlUGFja2VySW5zdHJ1Y3Rpb25QbGFuKHBsYW4pIHtcbiAgcmV0dXJuIHBsYW4ua2luZCA9PT0gXCJtZXNzYWdlUGFja2VyXCI7XG59XG5mdW5jdGlvbiBhc3NlcnRJc01lc3NhZ2VQYWNrZXJJbnN0cnVjdGlvblBsYW4ocGxhbikge1xuICBpZiAoIWlzTWVzc2FnZVBhY2tlckluc3RydWN0aW9uUGxhbihwbGFuKSkge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX1BMQU5TX19VTkVYUEVDVEVEX0lOU1RSVUNUSU9OX1BMQU4sIHtcbiAgICAgIGFjdHVhbEtpbmQ6IHBsYW4ua2luZCxcbiAgICAgIGV4cGVjdGVkS2luZDogXCJtZXNzYWdlUGFja2VyXCIsXG4gICAgICBpbnN0cnVjdGlvblBsYW46IHBsYW5cbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gaXNTZXF1ZW50aWFsSW5zdHJ1Y3Rpb25QbGFuKHBsYW4pIHtcbiAgcmV0dXJuIHBsYW4ua2luZCA9PT0gXCJzZXF1ZW50aWFsXCI7XG59XG5mdW5jdGlvbiBhc3NlcnRJc1NlcXVlbnRpYWxJbnN0cnVjdGlvblBsYW4ocGxhbikge1xuICBpZiAoIWlzU2VxdWVudGlhbEluc3RydWN0aW9uUGxhbihwbGFuKSkge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX1BMQU5TX19VTkVYUEVDVEVEX0lOU1RSVUNUSU9OX1BMQU4sIHtcbiAgICAgIGFjdHVhbEtpbmQ6IHBsYW4ua2luZCxcbiAgICAgIGV4cGVjdGVkS2luZDogXCJzZXF1ZW50aWFsXCIsXG4gICAgICBpbnN0cnVjdGlvblBsYW46IHBsYW5cbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gaXNOb25EaXZpc2libGVTZXF1ZW50aWFsSW5zdHJ1Y3Rpb25QbGFuKHBsYW4pIHtcbiAgcmV0dXJuIHBsYW4ua2luZCA9PT0gXCJzZXF1ZW50aWFsXCIgJiYgcGxhbi5kaXZpc2libGUgPT09IGZhbHNlO1xufVxuZnVuY3Rpb24gYXNzZXJ0SXNOb25EaXZpc2libGVTZXF1ZW50aWFsSW5zdHJ1Y3Rpb25QbGFuKHBsYW4pIHtcbiAgaWYgKCFpc05vbkRpdmlzaWJsZVNlcXVlbnRpYWxJbnN0cnVjdGlvblBsYW4ocGxhbikpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9QTEFOU19fVU5FWFBFQ1RFRF9JTlNUUlVDVElPTl9QTEFOLCB7XG4gICAgICBhY3R1YWxLaW5kOiBwbGFuLmtpbmQgPT09IFwic2VxdWVudGlhbFwiID8gXCJkaXZpc2libGUgc2VxdWVudGlhbFwiIDogcGxhbi5raW5kLFxuICAgICAgZXhwZWN0ZWRLaW5kOiBcIm5vbi1kaXZpc2libGUgc2VxdWVudGlhbFwiLFxuICAgICAgaW5zdHJ1Y3Rpb25QbGFuOiBwbGFuXG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzUGFyYWxsZWxJbnN0cnVjdGlvblBsYW4ocGxhbikge1xuICByZXR1cm4gcGxhbi5raW5kID09PSBcInBhcmFsbGVsXCI7XG59XG5mdW5jdGlvbiBhc3NlcnRJc1BhcmFsbGVsSW5zdHJ1Y3Rpb25QbGFuKHBsYW4pIHtcbiAgaWYgKCFpc1BhcmFsbGVsSW5zdHJ1Y3Rpb25QbGFuKHBsYW4pKSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fUExBTlNfX1VORVhQRUNURURfSU5TVFJVQ1RJT05fUExBTiwge1xuICAgICAgYWN0dWFsS2luZDogcGxhbi5raW5kLFxuICAgICAgZXhwZWN0ZWRLaW5kOiBcInBhcmFsbGVsXCIsXG4gICAgICBpbnN0cnVjdGlvblBsYW46IHBsYW5cbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gZmluZEluc3RydWN0aW9uUGxhbihpbnN0cnVjdGlvblBsYW4sIHByZWRpY2F0ZSkge1xuICBpZiAocHJlZGljYXRlKGluc3RydWN0aW9uUGxhbikpIHtcbiAgICByZXR1cm4gaW5zdHJ1Y3Rpb25QbGFuO1xuICB9XG4gIGlmIChpbnN0cnVjdGlvblBsYW4ua2luZCA9PT0gXCJzaW5nbGVcIiB8fCBpbnN0cnVjdGlvblBsYW4ua2luZCA9PT0gXCJtZXNzYWdlUGFja2VyXCIpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGZvciAoY29uc3Qgc3ViUGxhbiBvZiBpbnN0cnVjdGlvblBsYW4ucGxhbnMpIHtcbiAgICBjb25zdCBmb3VuZFBsYW4gPSBmaW5kSW5zdHJ1Y3Rpb25QbGFuKHN1YlBsYW4sIHByZWRpY2F0ZSk7XG4gICAgaWYgKGZvdW5kUGxhbikge1xuICAgICAgcmV0dXJuIGZvdW5kUGxhbjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGV2ZXJ5SW5zdHJ1Y3Rpb25QbGFuKGluc3RydWN0aW9uUGxhbiwgcHJlZGljYXRlKSB7XG4gIGlmICghcHJlZGljYXRlKGluc3RydWN0aW9uUGxhbikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGluc3RydWN0aW9uUGxhbi5raW5kID09PSBcInNpbmdsZVwiIHx8IGluc3RydWN0aW9uUGxhbi5raW5kID09PSBcIm1lc3NhZ2VQYWNrZXJcIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBpbnN0cnVjdGlvblBsYW4ucGxhbnMuZXZlcnkoKHApID0+IGV2ZXJ5SW5zdHJ1Y3Rpb25QbGFuKHAsIHByZWRpY2F0ZSkpO1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtSW5zdHJ1Y3Rpb25QbGFuKGluc3RydWN0aW9uUGxhbiwgZm4pIHtcbiAgaWYgKGluc3RydWN0aW9uUGxhbi5raW5kID09PSBcInNpbmdsZVwiIHx8IGluc3RydWN0aW9uUGxhbi5raW5kID09PSBcIm1lc3NhZ2VQYWNrZXJcIikge1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKGZuKGluc3RydWN0aW9uUGxhbikpO1xuICB9XG4gIHJldHVybiBPYmplY3QuZnJlZXplKFxuICAgIGZuKFxuICAgICAgT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIC4uLmluc3RydWN0aW9uUGxhbixcbiAgICAgICAgcGxhbnM6IGluc3RydWN0aW9uUGxhbi5wbGFucy5tYXAoKHApID0+IHRyYW5zZm9ybUluc3RydWN0aW9uUGxhbihwLCBmbikpXG4gICAgICB9KVxuICAgIClcbiAgKTtcbn1cbmZ1bmN0aW9uIGZsYXR0ZW5JbnN0cnVjdGlvblBsYW4oaW5zdHJ1Y3Rpb25QbGFuKSB7XG4gIGlmIChpbnN0cnVjdGlvblBsYW4ua2luZCA9PT0gXCJzaW5nbGVcIiB8fCBpbnN0cnVjdGlvblBsYW4ua2luZCA9PT0gXCJtZXNzYWdlUGFja2VyXCIpIHtcbiAgICByZXR1cm4gW2luc3RydWN0aW9uUGxhbl07XG4gIH1cbiAgcmV0dXJuIGluc3RydWN0aW9uUGxhbi5wbGFucy5mbGF0TWFwKGZsYXR0ZW5JbnN0cnVjdGlvblBsYW4pO1xufVxuZnVuY3Rpb24gZ2V0TGluZWFyTWVzc2FnZVBhY2tlckluc3RydWN0aW9uUGxhbih7XG4gIGdldEluc3RydWN0aW9uLFxuICB0b3RhbExlbmd0aDogdG90YWxCeXRlc1xufSkge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgZ2V0TWVzc2FnZVBhY2tlcjogKCkgPT4ge1xuICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIGRvbmU6ICgpID0+IG9mZnNldCA+PSB0b3RhbEJ5dGVzLFxuICAgICAgICBwYWNrTWVzc2FnZVRvQ2FwYWNpdHk6IChtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgaWYgKG9mZnNldCA+PSB0b3RhbEJ5dGVzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9QTEFOU19fTUVTU0FHRV9QQUNLRVJfQUxSRUFEWV9DT01QTEVURSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG1lc3NhZ2VTaXplV2l0aEJhc2VJbnN0cnVjdGlvbiA9IGdldFRyYW5zYWN0aW9uTWVzc2FnZVNpemUoXG4gICAgICAgICAgICBhcHBlbmRUcmFuc2FjdGlvbk1lc3NhZ2VJbnN0cnVjdGlvbihnZXRJbnN0cnVjdGlvbihvZmZzZXQsIDApLCBtZXNzYWdlKVxuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3QgZnJlZVNwYWNlID0gVFJBTlNBQ1RJT05fU0laRV9MSU1JVCAtIG1lc3NhZ2VTaXplV2l0aEJhc2VJbnN0cnVjdGlvbiAtIDE7XG4gICAgICAgICAgaWYgKGZyZWVTcGFjZSA8PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlU2l6ZSA9IGdldFRyYW5zYWN0aW9uTWVzc2FnZVNpemUobWVzc2FnZSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9QTEFOU19fTUVTU0FHRV9DQU5OT1RfQUNDT01NT0RBVEVfUExBTiwge1xuICAgICAgICAgICAgICAvLyAoKzEpIFdlIG5lZWQgdG8gcGFjayBhdCBsZWFzdCBvbmUgYnl0ZSBvZiBkYXRhIG90aGVyd2lzZVxuICAgICAgICAgICAgICAvLyB0aGVyZSBpcyBubyBwb2ludCBwYWNraW5nIHRoZSBiYXNlIGluc3RydWN0aW9uIGFsb25lLlxuICAgICAgICAgICAgICBudW1CeXRlc1JlcXVpcmVkOiBtZXNzYWdlU2l6ZVdpdGhCYXNlSW5zdHJ1Y3Rpb24gLSBtZXNzYWdlU2l6ZSArIDEsXG4gICAgICAgICAgICAgIC8vICgtMSkgTGVld2F5IGZvciBzaG9ydFUxNiBudW1iZXJzIGluIHRyYW5zYWN0aW9uIGhlYWRlcnMuXG4gICAgICAgICAgICAgIG51bUZyZWVCeXRlczogVFJBTlNBQ1RJT05fU0laRV9MSU1JVCAtIG1lc3NhZ2VTaXplIC0gMVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IE1hdGgubWluKHRvdGFsQnl0ZXMgLSBvZmZzZXQsIGZyZWVTcGFjZSk7XG4gICAgICAgICAgY29uc3QgaW5zdHJ1Y3Rpb24gPSBnZXRJbnN0cnVjdGlvbihvZmZzZXQsIGxlbmd0aCk7XG4gICAgICAgICAgb2Zmc2V0ICs9IGxlbmd0aDtcbiAgICAgICAgICByZXR1cm4gYXBwZW5kVHJhbnNhY3Rpb25NZXNzYWdlSW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb24sIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGtpbmQ6IFwibWVzc2FnZVBhY2tlclwiXG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0TWVzc2FnZVBhY2tlckluc3RydWN0aW9uUGxhbkZyb21JbnN0cnVjdGlvbnMoaW5zdHJ1Y3Rpb25zKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICBnZXRNZXNzYWdlUGFja2VyOiAoKSA9PiB7XG4gICAgICBsZXQgaW5zdHJ1Y3Rpb25JbmRleCA9IDA7XG4gICAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIGRvbmU6ICgpID0+IGluc3RydWN0aW9uSW5kZXggPj0gaW5zdHJ1Y3Rpb25zLmxlbmd0aCxcbiAgICAgICAgcGFja01lc3NhZ2VUb0NhcGFjaXR5OiAobWVzc2FnZSkgPT4ge1xuICAgICAgICAgIGlmIChpbnN0cnVjdGlvbkluZGV4ID49IGluc3RydWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX1BMQU5TX19NRVNTQUdFX1BBQ0tFUl9BTFJFQURZX0NPTVBMRVRFKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgb3JpZ2luYWxNZXNzYWdlU2l6ZSA9IGdldFRyYW5zYWN0aW9uTWVzc2FnZVNpemUobWVzc2FnZSk7XG4gICAgICAgICAgZm9yIChsZXQgaW5kZXggPSBpbnN0cnVjdGlvbkluZGV4OyBpbmRleCA8IGluc3RydWN0aW9ucy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBhcHBlbmRUcmFuc2FjdGlvbk1lc3NhZ2VJbnN0cnVjdGlvbihpbnN0cnVjdGlvbnNbaW5kZXhdLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VTaXplID0gZ2V0VHJhbnNhY3Rpb25NZXNzYWdlU2l6ZShtZXNzYWdlKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlU2l6ZSA+IFRSQU5TQUNUSU9OX1NJWkVfTElNSVQpIHtcbiAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSBpbnN0cnVjdGlvbkluZGV4KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFxuICAgICAgICAgICAgICAgICAgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9QTEFOU19fTUVTU0FHRV9DQU5OT1RfQUNDT01NT0RBVEVfUExBTixcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbnVtQnl0ZXNSZXF1aXJlZDogbWVzc2FnZVNpemUgLSBvcmlnaW5hbE1lc3NhZ2VTaXplLFxuICAgICAgICAgICAgICAgICAgICBudW1GcmVlQnl0ZXM6IFRSQU5TQUNUSU9OX1NJWkVfTElNSVQgLSBvcmlnaW5hbE1lc3NhZ2VTaXplXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpbnN0cnVjdGlvbkluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpbnN0cnVjdGlvbkluZGV4ID0gaW5zdHJ1Y3Rpb25zLmxlbmd0aDtcbiAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBraW5kOiBcIm1lc3NhZ2VQYWNrZXJcIlxuICB9KTtcbn1cbnZhciBSRUFMTE9DX0xJTUlUID0gMTAyNDA7XG5mdW5jdGlvbiBnZXRSZWFsbG9jTWVzc2FnZVBhY2tlckluc3RydWN0aW9uUGxhbih7XG4gIGdldEluc3RydWN0aW9uLFxuICB0b3RhbFNpemVcbn0pIHtcbiAgY29uc3QgbnVtYmVyT2ZJbnN0cnVjdGlvbnMgPSBNYXRoLmNlaWwodG90YWxTaXplIC8gUkVBTExPQ19MSU1JVCk7XG4gIGNvbnN0IGxhc3RJbnN0cnVjdGlvblNpemUgPSB0b3RhbFNpemUgJSBSRUFMTE9DX0xJTUlUO1xuICBjb25zdCBpbnN0cnVjdGlvbnMgPSBuZXcgQXJyYXkobnVtYmVyT2ZJbnN0cnVjdGlvbnMpLmZpbGwoMCkubWFwKChfLCBpKSA9PiBnZXRJbnN0cnVjdGlvbihpID09PSBudW1iZXJPZkluc3RydWN0aW9ucyAtIDEgPyBsYXN0SW5zdHJ1Y3Rpb25TaXplIDogUkVBTExPQ19MSU1JVCkpO1xuICByZXR1cm4gZ2V0TWVzc2FnZVBhY2tlckluc3RydWN0aW9uUGxhbkZyb21JbnN0cnVjdGlvbnMoaW5zdHJ1Y3Rpb25zKTtcbn1cblxuLy8gc3JjL2FwcGVuZC1pbnN0cnVjdGlvbi1wbGFuLnRzXG5mdW5jdGlvbiBhcHBlbmRUcmFuc2FjdGlvbk1lc3NhZ2VJbnN0cnVjdGlvblBsYW4oaW5zdHJ1Y3Rpb25QbGFuLCB0cmFuc2FjdGlvbk1lc3NhZ2UpIHtcbiAgY29uc3QgbGVhZkluc3RydWN0aW9uUGxhbnMgPSBmbGF0dGVuSW5zdHJ1Y3Rpb25QbGFuKGluc3RydWN0aW9uUGxhbik7XG4gIHJldHVybiBsZWFmSW5zdHJ1Y3Rpb25QbGFucy5yZWR1Y2UoXG4gICAgKG1lc3NhZ2VTb0ZhciwgcGxhbikgPT4ge1xuICAgICAgY29uc3Qga2luZCA9IHBsYW4ua2luZDtcbiAgICAgIGlmIChraW5kID09PSBcInNpbmdsZVwiKSB7XG4gICAgICAgIHJldHVybiBhcHBlbmRUcmFuc2FjdGlvbk1lc3NhZ2VJbnN0cnVjdGlvbihwbGFuLmluc3RydWN0aW9uLCBtZXNzYWdlU29GYXIpO1xuICAgICAgfVxuICAgICAgaWYgKGtpbmQgPT09IFwibWVzc2FnZVBhY2tlclwiKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VyUGFja2VyID0gcGxhbi5nZXRNZXNzYWdlUGFja2VyKCk7XG4gICAgICAgIGxldCBuZXh0TWVzc2FnZSA9IG1lc3NhZ2VTb0ZhcjtcbiAgICAgICAgd2hpbGUgKCFtZXNzYWdlclBhY2tlci5kb25lKCkpIHtcbiAgICAgICAgICBuZXh0TWVzc2FnZSA9IG1lc3NhZ2VyUGFja2VyLnBhY2tNZXNzYWdlVG9DYXBhY2l0eShuZXh0TWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5leHRNZXNzYWdlO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fSU5WQVJJQU5UX1ZJT0xBVElPTl9fSU5WQUxJRF9JTlNUUlVDVElPTl9QTEFOX0tJTkQsIHtcbiAgICAgICAga2luZFxuICAgICAgfSk7XG4gICAgfSxcbiAgICB0cmFuc2FjdGlvbk1lc3NhZ2VcbiAgKTtcbn1cbmZ1bmN0aW9uIHBhcmFsbGVsVHJhbnNhY3Rpb25QbGFuKHBsYW5zKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKHsga2luZDogXCJwYXJhbGxlbFwiLCBwbGFuczogcGFyc2VTaW5nbGVUcmFuc2FjdGlvblBsYW5zKHBsYW5zKSB9KTtcbn1cbmZ1bmN0aW9uIHNlcXVlbnRpYWxUcmFuc2FjdGlvblBsYW4ocGxhbnMpIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyBkaXZpc2libGU6IHRydWUsIGtpbmQ6IFwic2VxdWVudGlhbFwiLCBwbGFuczogcGFyc2VTaW5nbGVUcmFuc2FjdGlvblBsYW5zKHBsYW5zKSB9KTtcbn1cbmZ1bmN0aW9uIG5vbkRpdmlzaWJsZVNlcXVlbnRpYWxUcmFuc2FjdGlvblBsYW4ocGxhbnMpIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyBkaXZpc2libGU6IGZhbHNlLCBraW5kOiBcInNlcXVlbnRpYWxcIiwgcGxhbnM6IHBhcnNlU2luZ2xlVHJhbnNhY3Rpb25QbGFucyhwbGFucykgfSk7XG59XG5mdW5jdGlvbiBzaW5nbGVUcmFuc2FjdGlvblBsYW4odHJhbnNhY3Rpb25NZXNzYWdlKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKHsga2luZDogXCJzaW5nbGVcIiwgbWVzc2FnZTogdHJhbnNhY3Rpb25NZXNzYWdlIH0pO1xufVxuZnVuY3Rpb24gcGFyc2VTaW5nbGVUcmFuc2FjdGlvblBsYW5zKHBsYW5zKSB7XG4gIHJldHVybiBwbGFucy5tYXAoKHBsYW4pID0+IFwia2luZFwiIGluIHBsYW4gPyBwbGFuIDogc2luZ2xlVHJhbnNhY3Rpb25QbGFuKHBsYW4pKTtcbn1cbmZ1bmN0aW9uIGlzU2luZ2xlVHJhbnNhY3Rpb25QbGFuKHBsYW4pIHtcbiAgcmV0dXJuIHBsYW4ua2luZCA9PT0gXCJzaW5nbGVcIjtcbn1cbmZ1bmN0aW9uIGFzc2VydElzU2luZ2xlVHJhbnNhY3Rpb25QbGFuKHBsYW4pIHtcbiAgaWYgKCFpc1NpbmdsZVRyYW5zYWN0aW9uUGxhbihwbGFuKSkge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX1BMQU5TX19VTkVYUEVDVEVEX1RSQU5TQUNUSU9OX1BMQU4sIHtcbiAgICAgIGFjdHVhbEtpbmQ6IHBsYW4ua2luZCxcbiAgICAgIGV4cGVjdGVkS2luZDogXCJzaW5nbGVcIixcbiAgICAgIHRyYW5zYWN0aW9uUGxhbjogcGxhblxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBpc1NlcXVlbnRpYWxUcmFuc2FjdGlvblBsYW4ocGxhbikge1xuICByZXR1cm4gcGxhbi5raW5kID09PSBcInNlcXVlbnRpYWxcIjtcbn1cbmZ1bmN0aW9uIGFzc2VydElzU2VxdWVudGlhbFRyYW5zYWN0aW9uUGxhbihwbGFuKSB7XG4gIGlmICghaXNTZXF1ZW50aWFsVHJhbnNhY3Rpb25QbGFuKHBsYW4pKSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fUExBTlNfX1VORVhQRUNURURfVFJBTlNBQ1RJT05fUExBTiwge1xuICAgICAgYWN0dWFsS2luZDogcGxhbi5raW5kLFxuICAgICAgZXhwZWN0ZWRLaW5kOiBcInNlcXVlbnRpYWxcIixcbiAgICAgIHRyYW5zYWN0aW9uUGxhbjogcGxhblxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBpc05vbkRpdmlzaWJsZVNlcXVlbnRpYWxUcmFuc2FjdGlvblBsYW4ocGxhbikge1xuICByZXR1cm4gcGxhbi5raW5kID09PSBcInNlcXVlbnRpYWxcIiAmJiBwbGFuLmRpdmlzaWJsZSA9PT0gZmFsc2U7XG59XG5mdW5jdGlvbiBhc3NlcnRJc05vbkRpdmlzaWJsZVNlcXVlbnRpYWxUcmFuc2FjdGlvblBsYW4ocGxhbikge1xuICBpZiAoIWlzTm9uRGl2aXNpYmxlU2VxdWVudGlhbFRyYW5zYWN0aW9uUGxhbihwbGFuKSkge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX1BMQU5TX19VTkVYUEVDVEVEX1RSQU5TQUNUSU9OX1BMQU4sIHtcbiAgICAgIGFjdHVhbEtpbmQ6IHBsYW4ua2luZCA9PT0gXCJzZXF1ZW50aWFsXCIgPyBcImRpdmlzaWJsZSBzZXF1ZW50aWFsXCIgOiBwbGFuLmtpbmQsXG4gICAgICBleHBlY3RlZEtpbmQ6IFwibm9uLWRpdmlzaWJsZSBzZXF1ZW50aWFsXCIsXG4gICAgICB0cmFuc2FjdGlvblBsYW46IHBsYW5cbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gaXNQYXJhbGxlbFRyYW5zYWN0aW9uUGxhbihwbGFuKSB7XG4gIHJldHVybiBwbGFuLmtpbmQgPT09IFwicGFyYWxsZWxcIjtcbn1cbmZ1bmN0aW9uIGFzc2VydElzUGFyYWxsZWxUcmFuc2FjdGlvblBsYW4ocGxhbikge1xuICBpZiAoIWlzUGFyYWxsZWxUcmFuc2FjdGlvblBsYW4ocGxhbikpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9QTEFOU19fVU5FWFBFQ1RFRF9UUkFOU0FDVElPTl9QTEFOLCB7XG4gICAgICBhY3R1YWxLaW5kOiBwbGFuLmtpbmQsXG4gICAgICBleHBlY3RlZEtpbmQ6IFwicGFyYWxsZWxcIixcbiAgICAgIHRyYW5zYWN0aW9uUGxhbjogcGxhblxuICAgIH0pO1xuICB9XG59XG52YXIgZ2V0QWxsU2luZ2xlVHJhbnNhY3Rpb25QbGFucyA9IGZsYXR0ZW5UcmFuc2FjdGlvblBsYW47XG5mdW5jdGlvbiBmbGF0dGVuVHJhbnNhY3Rpb25QbGFuKHRyYW5zYWN0aW9uUGxhbikge1xuICBpZiAodHJhbnNhY3Rpb25QbGFuLmtpbmQgPT09IFwic2luZ2xlXCIpIHtcbiAgICByZXR1cm4gW3RyYW5zYWN0aW9uUGxhbl07XG4gIH1cbiAgcmV0dXJuIHRyYW5zYWN0aW9uUGxhbi5wbGFucy5mbGF0TWFwKGZsYXR0ZW5UcmFuc2FjdGlvblBsYW4pO1xufVxuZnVuY3Rpb24gZmluZFRyYW5zYWN0aW9uUGxhbih0cmFuc2FjdGlvblBsYW4sIHByZWRpY2F0ZSkge1xuICBpZiAocHJlZGljYXRlKHRyYW5zYWN0aW9uUGxhbikpIHtcbiAgICByZXR1cm4gdHJhbnNhY3Rpb25QbGFuO1xuICB9XG4gIGlmICh0cmFuc2FjdGlvblBsYW4ua2luZCA9PT0gXCJzaW5nbGVcIikge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgZm9yIChjb25zdCBzdWJQbGFuIG9mIHRyYW5zYWN0aW9uUGxhbi5wbGFucykge1xuICAgIGNvbnN0IGZvdW5kUGxhbiA9IGZpbmRUcmFuc2FjdGlvblBsYW4oc3ViUGxhbiwgcHJlZGljYXRlKTtcbiAgICBpZiAoZm91bmRQbGFuKSB7XG4gICAgICByZXR1cm4gZm91bmRQbGFuO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufVxuZnVuY3Rpb24gZXZlcnlUcmFuc2FjdGlvblBsYW4odHJhbnNhY3Rpb25QbGFuLCBwcmVkaWNhdGUpIHtcbiAgaWYgKCFwcmVkaWNhdGUodHJhbnNhY3Rpb25QbGFuKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHJhbnNhY3Rpb25QbGFuLmtpbmQgPT09IFwic2luZ2xlXCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gdHJhbnNhY3Rpb25QbGFuLnBsYW5zLmV2ZXJ5KChwKSA9PiBldmVyeVRyYW5zYWN0aW9uUGxhbihwLCBwcmVkaWNhdGUpKTtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybVRyYW5zYWN0aW9uUGxhbih0cmFuc2FjdGlvblBsYW4sIGZuKSB7XG4gIGlmICh0cmFuc2FjdGlvblBsYW4ua2luZCA9PT0gXCJzaW5nbGVcIikge1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKGZuKHRyYW5zYWN0aW9uUGxhbikpO1xuICB9XG4gIHJldHVybiBPYmplY3QuZnJlZXplKFxuICAgIGZuKFxuICAgICAgT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIC4uLnRyYW5zYWN0aW9uUGxhbixcbiAgICAgICAgcGxhbnM6IHRyYW5zYWN0aW9uUGxhbi5wbGFucy5tYXAoKHApID0+IHRyYW5zZm9ybVRyYW5zYWN0aW9uUGxhbihwLCBmbikpXG4gICAgICB9KVxuICAgIClcbiAgKTtcbn1cbmZ1bmN0aW9uIHNlcXVlbnRpYWxUcmFuc2FjdGlvblBsYW5SZXN1bHQocGxhbnMpIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyBkaXZpc2libGU6IHRydWUsIGtpbmQ6IFwic2VxdWVudGlhbFwiLCBwbGFucyB9KTtcbn1cbmZ1bmN0aW9uIG5vbkRpdmlzaWJsZVNlcXVlbnRpYWxUcmFuc2FjdGlvblBsYW5SZXN1bHQocGxhbnMpIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyBkaXZpc2libGU6IGZhbHNlLCBraW5kOiBcInNlcXVlbnRpYWxcIiwgcGxhbnMgfSk7XG59XG5mdW5jdGlvbiBwYXJhbGxlbFRyYW5zYWN0aW9uUGxhblJlc3VsdChwbGFucykge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IGtpbmQ6IFwicGFyYWxsZWxcIiwgcGxhbnMgfSk7XG59XG5mdW5jdGlvbiBzdWNjZXNzZnVsU2luZ2xlVHJhbnNhY3Rpb25QbGFuUmVzdWx0KHRyYW5zYWN0aW9uTWVzc2FnZSwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgIGtpbmQ6IFwic2luZ2xlXCIsXG4gICAgbWVzc2FnZTogdHJhbnNhY3Rpb25NZXNzYWdlLFxuICAgIHN0YXR1czogT2JqZWN0LmZyZWV6ZSh7XG4gICAgICBjb250ZXh0OiBjb250ZXh0ID8/IHt9LFxuICAgICAga2luZDogXCJzdWNjZXNzZnVsXCIsXG4gICAgICBzaWduYXR1cmU6IGdldFNpZ25hdHVyZUZyb21UcmFuc2FjdGlvbih0cmFuc2FjdGlvbiksXG4gICAgICB0cmFuc2FjdGlvblxuICAgIH0pXG4gIH0pO1xufVxuZnVuY3Rpb24gc3VjY2Vzc2Z1bFNpbmdsZVRyYW5zYWN0aW9uUGxhblJlc3VsdEZyb21TaWduYXR1cmUodHJhbnNhY3Rpb25NZXNzYWdlLCBzaWduYXR1cmUsIGNvbnRleHQpIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgIGtpbmQ6IFwic2luZ2xlXCIsXG4gICAgbWVzc2FnZTogdHJhbnNhY3Rpb25NZXNzYWdlLFxuICAgIHN0YXR1czogT2JqZWN0LmZyZWV6ZSh7IGNvbnRleHQ6IGNvbnRleHQgPz8ge30sIGtpbmQ6IFwic3VjY2Vzc2Z1bFwiLCBzaWduYXR1cmUgfSlcbiAgfSk7XG59XG5mdW5jdGlvbiBmYWlsZWRTaW5nbGVUcmFuc2FjdGlvblBsYW5SZXN1bHQodHJhbnNhY3Rpb25NZXNzYWdlLCBlcnJvcikge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAga2luZDogXCJzaW5nbGVcIixcbiAgICBtZXNzYWdlOiB0cmFuc2FjdGlvbk1lc3NhZ2UsXG4gICAgc3RhdHVzOiBPYmplY3QuZnJlZXplKHsgZXJyb3IsIGtpbmQ6IFwiZmFpbGVkXCIgfSlcbiAgfSk7XG59XG5mdW5jdGlvbiBjYW5jZWxlZFNpbmdsZVRyYW5zYWN0aW9uUGxhblJlc3VsdCh0cmFuc2FjdGlvbk1lc3NhZ2UpIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgIGtpbmQ6IFwic2luZ2xlXCIsXG4gICAgbWVzc2FnZTogdHJhbnNhY3Rpb25NZXNzYWdlLFxuICAgIHN0YXR1czogT2JqZWN0LmZyZWV6ZSh7IGtpbmQ6IFwiY2FuY2VsZWRcIiB9KVxuICB9KTtcbn1cbmZ1bmN0aW9uIGlzU2luZ2xlVHJhbnNhY3Rpb25QbGFuUmVzdWx0KHBsYW4pIHtcbiAgcmV0dXJuIHBsYW4ua2luZCA9PT0gXCJzaW5nbGVcIjtcbn1cbmZ1bmN0aW9uIGFzc2VydElzU2luZ2xlVHJhbnNhY3Rpb25QbGFuUmVzdWx0KHBsYW4pIHtcbiAgaWYgKCFpc1NpbmdsZVRyYW5zYWN0aW9uUGxhblJlc3VsdChwbGFuKSkge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX1BMQU5TX19VTkVYUEVDVEVEX1RSQU5TQUNUSU9OX1BMQU5fUkVTVUxULCB7XG4gICAgICBhY3R1YWxLaW5kOiBwbGFuLmtpbmQsXG4gICAgICBleHBlY3RlZEtpbmQ6IFwic2luZ2xlXCIsXG4gICAgICB0cmFuc2FjdGlvblBsYW5SZXN1bHQ6IHBsYW5cbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gaXNTdWNjZXNzZnVsU2luZ2xlVHJhbnNhY3Rpb25QbGFuUmVzdWx0KHBsYW4pIHtcbiAgcmV0dXJuIHBsYW4ua2luZCA9PT0gXCJzaW5nbGVcIiAmJiBwbGFuLnN0YXR1cy5raW5kID09PSBcInN1Y2Nlc3NmdWxcIjtcbn1cbmZ1bmN0aW9uIGFzc2VydElzU3VjY2Vzc2Z1bFNpbmdsZVRyYW5zYWN0aW9uUGxhblJlc3VsdChwbGFuKSB7XG4gIGlmICghaXNTdWNjZXNzZnVsU2luZ2xlVHJhbnNhY3Rpb25QbGFuUmVzdWx0KHBsYW4pKSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fUExBTlNfX1VORVhQRUNURURfVFJBTlNBQ1RJT05fUExBTl9SRVNVTFQsIHtcbiAgICAgIGFjdHVhbEtpbmQ6IHBsYW4ua2luZCA9PT0gXCJzaW5nbGVcIiA/IGAke3BsYW4uc3RhdHVzLmtpbmR9IHNpbmdsZWAgOiBwbGFuLmtpbmQsXG4gICAgICBleHBlY3RlZEtpbmQ6IFwic3VjY2Vzc2Z1bCBzaW5nbGVcIixcbiAgICAgIHRyYW5zYWN0aW9uUGxhblJlc3VsdDogcGxhblxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBpc0ZhaWxlZFNpbmdsZVRyYW5zYWN0aW9uUGxhblJlc3VsdChwbGFuKSB7XG4gIHJldHVybiBwbGFuLmtpbmQgPT09IFwic2luZ2xlXCIgJiYgcGxhbi5zdGF0dXMua2luZCA9PT0gXCJmYWlsZWRcIjtcbn1cbmZ1bmN0aW9uIGFzc2VydElzRmFpbGVkU2luZ2xlVHJhbnNhY3Rpb25QbGFuUmVzdWx0KHBsYW4pIHtcbiAgaWYgKCFpc0ZhaWxlZFNpbmdsZVRyYW5zYWN0aW9uUGxhblJlc3VsdChwbGFuKSkge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX1BMQU5TX19VTkVYUEVDVEVEX1RSQU5TQUNUSU9OX1BMQU5fUkVTVUxULCB7XG4gICAgICBhY3R1YWxLaW5kOiBwbGFuLmtpbmQgPT09IFwic2luZ2xlXCIgPyBgJHtwbGFuLnN0YXR1cy5raW5kfSBzaW5nbGVgIDogcGxhbi5raW5kLFxuICAgICAgZXhwZWN0ZWRLaW5kOiBcImZhaWxlZCBzaW5nbGVcIixcbiAgICAgIHRyYW5zYWN0aW9uUGxhblJlc3VsdDogcGxhblxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBpc0NhbmNlbGVkU2luZ2xlVHJhbnNhY3Rpb25QbGFuUmVzdWx0KHBsYW4pIHtcbiAgcmV0dXJuIHBsYW4ua2luZCA9PT0gXCJzaW5nbGVcIiAmJiBwbGFuLnN0YXR1cy5raW5kID09PSBcImNhbmNlbGVkXCI7XG59XG5mdW5jdGlvbiBhc3NlcnRJc0NhbmNlbGVkU2luZ2xlVHJhbnNhY3Rpb25QbGFuUmVzdWx0KHBsYW4pIHtcbiAgaWYgKCFpc0NhbmNlbGVkU2luZ2xlVHJhbnNhY3Rpb25QbGFuUmVzdWx0KHBsYW4pKSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fUExBTlNfX1VORVhQRUNURURfVFJBTlNBQ1RJT05fUExBTl9SRVNVTFQsIHtcbiAgICAgIGFjdHVhbEtpbmQ6IHBsYW4ua2luZCA9PT0gXCJzaW5nbGVcIiA/IGAke3BsYW4uc3RhdHVzLmtpbmR9IHNpbmdsZWAgOiBwbGFuLmtpbmQsXG4gICAgICBleHBlY3RlZEtpbmQ6IFwiY2FuY2VsZWQgc2luZ2xlXCIsXG4gICAgICB0cmFuc2FjdGlvblBsYW5SZXN1bHQ6IHBsYW5cbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gaXNTZXF1ZW50aWFsVHJhbnNhY3Rpb25QbGFuUmVzdWx0KHBsYW4pIHtcbiAgcmV0dXJuIHBsYW4ua2luZCA9PT0gXCJzZXF1ZW50aWFsXCI7XG59XG5mdW5jdGlvbiBhc3NlcnRJc1NlcXVlbnRpYWxUcmFuc2FjdGlvblBsYW5SZXN1bHQocGxhbikge1xuICBpZiAoIWlzU2VxdWVudGlhbFRyYW5zYWN0aW9uUGxhblJlc3VsdChwbGFuKSkge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX1BMQU5TX19VTkVYUEVDVEVEX1RSQU5TQUNUSU9OX1BMQU5fUkVTVUxULCB7XG4gICAgICBhY3R1YWxLaW5kOiBwbGFuLmtpbmQsXG4gICAgICBleHBlY3RlZEtpbmQ6IFwic2VxdWVudGlhbFwiLFxuICAgICAgdHJhbnNhY3Rpb25QbGFuUmVzdWx0OiBwbGFuXG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzTm9uRGl2aXNpYmxlU2VxdWVudGlhbFRyYW5zYWN0aW9uUGxhblJlc3VsdChwbGFuKSB7XG4gIHJldHVybiBwbGFuLmtpbmQgPT09IFwic2VxdWVudGlhbFwiICYmIHBsYW4uZGl2aXNpYmxlID09PSBmYWxzZTtcbn1cbmZ1bmN0aW9uIGFzc2VydElzTm9uRGl2aXNpYmxlU2VxdWVudGlhbFRyYW5zYWN0aW9uUGxhblJlc3VsdChwbGFuKSB7XG4gIGlmICghaXNOb25EaXZpc2libGVTZXF1ZW50aWFsVHJhbnNhY3Rpb25QbGFuUmVzdWx0KHBsYW4pKSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fUExBTlNfX1VORVhQRUNURURfVFJBTlNBQ1RJT05fUExBTl9SRVNVTFQsIHtcbiAgICAgIGFjdHVhbEtpbmQ6IHBsYW4ua2luZCA9PT0gXCJzZXF1ZW50aWFsXCIgPyBcImRpdmlzaWJsZSBzZXF1ZW50aWFsXCIgOiBwbGFuLmtpbmQsXG4gICAgICBleHBlY3RlZEtpbmQ6IFwibm9uLWRpdmlzaWJsZSBzZXF1ZW50aWFsXCIsXG4gICAgICB0cmFuc2FjdGlvblBsYW5SZXN1bHQ6IHBsYW5cbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gaXNQYXJhbGxlbFRyYW5zYWN0aW9uUGxhblJlc3VsdChwbGFuKSB7XG4gIHJldHVybiBwbGFuLmtpbmQgPT09IFwicGFyYWxsZWxcIjtcbn1cbmZ1bmN0aW9uIGFzc2VydElzUGFyYWxsZWxUcmFuc2FjdGlvblBsYW5SZXN1bHQocGxhbikge1xuICBpZiAoIWlzUGFyYWxsZWxUcmFuc2FjdGlvblBsYW5SZXN1bHQocGxhbikpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9QTEFOU19fVU5FWFBFQ1RFRF9UUkFOU0FDVElPTl9QTEFOX1JFU1VMVCwge1xuICAgICAgYWN0dWFsS2luZDogcGxhbi5raW5kLFxuICAgICAgZXhwZWN0ZWRLaW5kOiBcInBhcmFsbGVsXCIsXG4gICAgICB0cmFuc2FjdGlvblBsYW5SZXN1bHQ6IHBsYW5cbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gaXNTdWNjZXNzZnVsVHJhbnNhY3Rpb25QbGFuUmVzdWx0KHBsYW4pIHtcbiAgcmV0dXJuIGV2ZXJ5VHJhbnNhY3Rpb25QbGFuUmVzdWx0KFxuICAgIHBsYW4sXG4gICAgKHIpID0+ICFpc1NpbmdsZVRyYW5zYWN0aW9uUGxhblJlc3VsdChyKSB8fCBpc1N1Y2Nlc3NmdWxTaW5nbGVUcmFuc2FjdGlvblBsYW5SZXN1bHQocilcbiAgKTtcbn1cbmZ1bmN0aW9uIGFzc2VydElzU3VjY2Vzc2Z1bFRyYW5zYWN0aW9uUGxhblJlc3VsdChwbGFuKSB7XG4gIGlmICghaXNTdWNjZXNzZnVsVHJhbnNhY3Rpb25QbGFuUmVzdWx0KHBsYW4pKSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fUExBTlNfX0VYUEVDVEVEX1NVQ0NFU1NGVUxfVFJBTlNBQ1RJT05fUExBTl9SRVNVTFQsIHtcbiAgICAgIHRyYW5zYWN0aW9uUGxhblJlc3VsdDogcGxhblxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBmaW5kVHJhbnNhY3Rpb25QbGFuUmVzdWx0KHRyYW5zYWN0aW9uUGxhblJlc3VsdCwgcHJlZGljYXRlKSB7XG4gIGlmIChwcmVkaWNhdGUodHJhbnNhY3Rpb25QbGFuUmVzdWx0KSkge1xuICAgIHJldHVybiB0cmFuc2FjdGlvblBsYW5SZXN1bHQ7XG4gIH1cbiAgaWYgKHRyYW5zYWN0aW9uUGxhblJlc3VsdC5raW5kID09PSBcInNpbmdsZVwiKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBmb3IgKGNvbnN0IHN1YlJlc3VsdCBvZiB0cmFuc2FjdGlvblBsYW5SZXN1bHQucGxhbnMpIHtcbiAgICBjb25zdCBmb3VuZFJlc3VsdCA9IGZpbmRUcmFuc2FjdGlvblBsYW5SZXN1bHQoc3ViUmVzdWx0LCBwcmVkaWNhdGUpO1xuICAgIGlmIChmb3VuZFJlc3VsdCkge1xuICAgICAgcmV0dXJuIGZvdW5kUmVzdWx0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufVxuZnVuY3Rpb24gZ2V0Rmlyc3RGYWlsZWRTaW5nbGVUcmFuc2FjdGlvblBsYW5SZXN1bHQodHJhbnNhY3Rpb25QbGFuUmVzdWx0KSB7XG4gIGNvbnN0IHJlc3VsdCA9IGZpbmRUcmFuc2FjdGlvblBsYW5SZXN1bHQoXG4gICAgdHJhbnNhY3Rpb25QbGFuUmVzdWx0LFxuICAgIChyKSA9PiByLmtpbmQgPT09IFwic2luZ2xlXCIgJiYgci5zdGF0dXMua2luZCA9PT0gXCJmYWlsZWRcIlxuICApO1xuICBpZiAoIXJlc3VsdCkge1xuICAgIGNvbnN0IGNvbnRleHQgPSB7fTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29udGV4dCwgXCJ0cmFuc2FjdGlvblBsYW5SZXN1bHRcIiwge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHRyYW5zYWN0aW9uUGxhblJlc3VsdCxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZVxuICAgIH0pO1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihcbiAgICAgIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fUExBTlNfX0ZBSUxFRF9TSU5HTEVfVFJBTlNBQ1RJT05fUExBTl9SRVNVTFRfTk9UX0ZPVU5ELFxuICAgICAgY29udGV4dFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGV2ZXJ5VHJhbnNhY3Rpb25QbGFuUmVzdWx0KHRyYW5zYWN0aW9uUGxhblJlc3VsdCwgcHJlZGljYXRlKSB7XG4gIGlmICghcHJlZGljYXRlKHRyYW5zYWN0aW9uUGxhblJlc3VsdCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHRyYW5zYWN0aW9uUGxhblJlc3VsdC5raW5kID09PSBcInNpbmdsZVwiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIHRyYW5zYWN0aW9uUGxhblJlc3VsdC5wbGFucy5ldmVyeSgocCkgPT4gZXZlcnlUcmFuc2FjdGlvblBsYW5SZXN1bHQocCwgcHJlZGljYXRlKSk7XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1UcmFuc2FjdGlvblBsYW5SZXN1bHQodHJhbnNhY3Rpb25QbGFuUmVzdWx0LCBmbikge1xuICBpZiAodHJhbnNhY3Rpb25QbGFuUmVzdWx0LmtpbmQgPT09IFwic2luZ2xlXCIpIHtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShmbih0cmFuc2FjdGlvblBsYW5SZXN1bHQpKTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShcbiAgICBmbihcbiAgICAgIE9iamVjdC5mcmVlemUoe1xuICAgICAgICAuLi50cmFuc2FjdGlvblBsYW5SZXN1bHQsXG4gICAgICAgIHBsYW5zOiB0cmFuc2FjdGlvblBsYW5SZXN1bHQucGxhbnMubWFwKChwKSA9PiB0cmFuc2Zvcm1UcmFuc2FjdGlvblBsYW5SZXN1bHQocCwgZm4pKVxuICAgICAgfSlcbiAgICApXG4gICk7XG59XG5mdW5jdGlvbiBmbGF0dGVuVHJhbnNhY3Rpb25QbGFuUmVzdWx0KHJlc3VsdCkge1xuICBpZiAocmVzdWx0LmtpbmQgPT09IFwic2luZ2xlXCIpIHtcbiAgICByZXR1cm4gW3Jlc3VsdF07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC5wbGFucy5mbGF0TWFwKGZsYXR0ZW5UcmFuc2FjdGlvblBsYW5SZXN1bHQpO1xufVxuZnVuY3Rpb24gc3VtbWFyaXplVHJhbnNhY3Rpb25QbGFuUmVzdWx0KHJlc3VsdCkge1xuICBjb25zdCBzdWNjZXNzZnVsVHJhbnNhY3Rpb25zID0gW107XG4gIGNvbnN0IGZhaWxlZFRyYW5zYWN0aW9ucyA9IFtdO1xuICBjb25zdCBjYW5jZWxlZFRyYW5zYWN0aW9ucyA9IFtdO1xuICBjb25zdCBmbGF0dGVuZWRSZXN1bHRzID0gZmxhdHRlblRyYW5zYWN0aW9uUGxhblJlc3VsdChyZXN1bHQpO1xuICBmb3IgKGNvbnN0IHNpbmdsZVJlc3VsdCBvZiBmbGF0dGVuZWRSZXN1bHRzKSB7XG4gICAgc3dpdGNoIChzaW5nbGVSZXN1bHQuc3RhdHVzLmtpbmQpIHtcbiAgICAgIGNhc2UgXCJzdWNjZXNzZnVsXCI6IHtcbiAgICAgICAgc3VjY2Vzc2Z1bFRyYW5zYWN0aW9ucy5wdXNoKHNpbmdsZVJlc3VsdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImZhaWxlZFwiOiB7XG4gICAgICAgIGZhaWxlZFRyYW5zYWN0aW9ucy5wdXNoKHNpbmdsZVJlc3VsdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImNhbmNlbGVkXCI6IHtcbiAgICAgICAgY2FuY2VsZWRUcmFuc2FjdGlvbnMucHVzaChzaW5nbGVSZXN1bHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgIGNhbmNlbGVkVHJhbnNhY3Rpb25zLFxuICAgIGZhaWxlZFRyYW5zYWN0aW9ucyxcbiAgICBzdWNjZXNzZnVsOiBmYWlsZWRUcmFuc2FjdGlvbnMubGVuZ3RoID09PSAwICYmIGNhbmNlbGVkVHJhbnNhY3Rpb25zLmxlbmd0aCA9PT0gMCxcbiAgICBzdWNjZXNzZnVsVHJhbnNhY3Rpb25zXG4gIH0pO1xufVxuXG4vLyBzcmMvdHJhbnNhY3Rpb24tcGxhbi1leGVjdXRvci50c1xuZnVuY3Rpb24gY3JlYXRlVHJhbnNhY3Rpb25QbGFuRXhlY3V0b3IoY29uZmlnKSB7XG4gIHJldHVybiBhc3luYyAocGxhbiwgeyBhYm9ydFNpZ25hbCB9ID0ge30pID0+IHtcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgLi4uY29uZmlnLFxuICAgICAgYWJvcnRTaWduYWwsXG4gICAgICBjYW5jZWxlZDogYWJvcnRTaWduYWw/LmFib3J0ZWQgPz8gZmFsc2VcbiAgICB9O1xuICAgIGFzc2VydERpdmlzaWJsZVNlcXVlbnRpYWxQbGFuc09ubHkocGxhbik7XG4gICAgY29uc3QgY2FuY2VsSGFuZGxlciA9ICgpID0+IHtcbiAgICAgIGNvbnRleHQuY2FuY2VsZWQgPSB0cnVlO1xuICAgIH07XG4gICAgYWJvcnRTaWduYWw/LmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBjYW5jZWxIYW5kbGVyKTtcbiAgICBjb25zdCB0cmFuc2FjdGlvblBsYW5SZXN1bHQgPSBhd2FpdCB0cmF2ZXJzZShwbGFuLCBjb250ZXh0KTtcbiAgICBhYm9ydFNpZ25hbD8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGNhbmNlbEhhbmRsZXIpO1xuICAgIGlmIChjb250ZXh0LmNhbmNlbGVkKSB7XG4gICAgICBjb25zdCBhYm9ydFJlYXNvbiA9IGFib3J0U2lnbmFsPy5hYm9ydGVkID8gYWJvcnRTaWduYWwucmVhc29uIDogdm9pZCAwO1xuICAgICAgY29uc3QgY29udGV4dDIgPSB7IGNhdXNlOiBmaW5kRXJyb3JGcm9tVHJhbnNhY3Rpb25QbGFuUmVzdWx0KHRyYW5zYWN0aW9uUGxhblJlc3VsdCkgPz8gYWJvcnRSZWFzb24gfTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb250ZXh0MiwgXCJ0cmFuc2FjdGlvblBsYW5SZXN1bHRcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IHRyYW5zYWN0aW9uUGxhblJlc3VsdCxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX1BMQU5TX19GQUlMRURfVE9fRVhFQ1VURV9UUkFOU0FDVElPTl9QTEFOLCBjb250ZXh0Mik7XG4gICAgfVxuICAgIHJldHVybiB0cmFuc2FjdGlvblBsYW5SZXN1bHQ7XG4gIH07XG59XG5hc3luYyBmdW5jdGlvbiB0cmF2ZXJzZSh0cmFuc2FjdGlvblBsYW4sIGNvbnRleHQpIHtcbiAgY29uc3Qga2luZCA9IHRyYW5zYWN0aW9uUGxhbi5raW5kO1xuICBzd2l0Y2ggKGtpbmQpIHtcbiAgICBjYXNlIFwic2VxdWVudGlhbFwiOlxuICAgICAgcmV0dXJuIGF3YWl0IHRyYXZlcnNlU2VxdWVudGlhbCh0cmFuc2FjdGlvblBsYW4sIGNvbnRleHQpO1xuICAgIGNhc2UgXCJwYXJhbGxlbFwiOlxuICAgICAgcmV0dXJuIGF3YWl0IHRyYXZlcnNlUGFyYWxsZWwodHJhbnNhY3Rpb25QbGFuLCBjb250ZXh0KTtcbiAgICBjYXNlIFwic2luZ2xlXCI6XG4gICAgICByZXR1cm4gYXdhaXQgdHJhdmVyc2VTaW5nbGUodHJhbnNhY3Rpb25QbGFuLCBjb250ZXh0KTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fSU5WQVJJQU5UX1ZJT0xBVElPTl9fSU5WQUxJRF9UUkFOU0FDVElPTl9QTEFOX0tJTkQsIHsga2luZCB9KTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gdHJhdmVyc2VTZXF1ZW50aWFsKHRyYW5zYWN0aW9uUGxhbiwgY29udGV4dCkge1xuICBpZiAoIXRyYW5zYWN0aW9uUGxhbi5kaXZpc2libGUpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9QTEFOU19fTk9OX0RJVklTSUJMRV9UUkFOU0FDVElPTl9QTEFOU19OT1RfU1VQUE9SVEVEKTtcbiAgfVxuICBjb25zdCByZXN1bHRzID0gW107XG4gIGZvciAoY29uc3Qgc3ViUGxhbiBvZiB0cmFuc2FjdGlvblBsYW4ucGxhbnMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0cmF2ZXJzZShzdWJQbGFuLCBjb250ZXh0KTtcbiAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcbiAgfVxuICByZXR1cm4gc2VxdWVudGlhbFRyYW5zYWN0aW9uUGxhblJlc3VsdChyZXN1bHRzKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHRyYXZlcnNlUGFyYWxsZWwodHJhbnNhY3Rpb25QbGFuLCBjb250ZXh0KSB7XG4gIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbCh0cmFuc2FjdGlvblBsYW4ucGxhbnMubWFwKChwbGFuKSA9PiB0cmF2ZXJzZShwbGFuLCBjb250ZXh0KSkpO1xuICByZXR1cm4gcGFyYWxsZWxUcmFuc2FjdGlvblBsYW5SZXN1bHQocmVzdWx0cyk7XG59XG5hc3luYyBmdW5jdGlvbiB0cmF2ZXJzZVNpbmdsZSh0cmFuc2FjdGlvblBsYW4sIGNvbnRleHQpIHtcbiAgaWYgKGNvbnRleHQuY2FuY2VsZWQpIHtcbiAgICByZXR1cm4gY2FuY2VsZWRTaW5nbGVUcmFuc2FjdGlvblBsYW5SZXN1bHQodHJhbnNhY3Rpb25QbGFuLm1lc3NhZ2UpO1xuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0QWJvcnRhYmxlUHJvbWlzZShcbiAgICAgIGNvbnRleHQuZXhlY3V0ZVRyYW5zYWN0aW9uTWVzc2FnZSh0cmFuc2FjdGlvblBsYW4ubWVzc2FnZSwgeyBhYm9ydFNpZ25hbDogY29udGV4dC5hYm9ydFNpZ25hbCB9KSxcbiAgICAgIGNvbnRleHQuYWJvcnRTaWduYWxcbiAgICApO1xuICAgIGlmIChcInRyYW5zYWN0aW9uXCIgaW4gcmVzdWx0KSB7XG4gICAgICByZXR1cm4gc3VjY2Vzc2Z1bFNpbmdsZVRyYW5zYWN0aW9uUGxhblJlc3VsdCh0cmFuc2FjdGlvblBsYW4ubWVzc2FnZSwgcmVzdWx0LnRyYW5zYWN0aW9uLCByZXN1bHQuY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzdWNjZXNzZnVsU2luZ2xlVHJhbnNhY3Rpb25QbGFuUmVzdWx0RnJvbVNpZ25hdHVyZShcbiAgICAgICAgdHJhbnNhY3Rpb25QbGFuLm1lc3NhZ2UsXG4gICAgICAgIHJlc3VsdC5zaWduYXR1cmUsXG4gICAgICAgIHJlc3VsdC5jb250ZXh0XG4gICAgICApO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb250ZXh0LmNhbmNlbGVkID0gdHJ1ZTtcbiAgICByZXR1cm4gZmFpbGVkU2luZ2xlVHJhbnNhY3Rpb25QbGFuUmVzdWx0KHRyYW5zYWN0aW9uUGxhbi5tZXNzYWdlLCBlcnJvcik7XG4gIH1cbn1cbmZ1bmN0aW9uIGZpbmRFcnJvckZyb21UcmFuc2FjdGlvblBsYW5SZXN1bHQocmVzdWx0KSB7XG4gIGlmIChyZXN1bHQua2luZCA9PT0gXCJzaW5nbGVcIikge1xuICAgIHJldHVybiByZXN1bHQuc3RhdHVzLmtpbmQgPT09IFwiZmFpbGVkXCIgPyByZXN1bHQuc3RhdHVzLmVycm9yIDogdm9pZCAwO1xuICB9XG4gIGZvciAoY29uc3QgcGxhbiBvZiByZXN1bHQucGxhbnMpIHtcbiAgICBjb25zdCBlcnJvciA9IGZpbmRFcnJvckZyb21UcmFuc2FjdGlvblBsYW5SZXN1bHQocGxhbik7XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICByZXR1cm4gZXJyb3I7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhc3NlcnREaXZpc2libGVTZXF1ZW50aWFsUGxhbnNPbmx5KHRyYW5zYWN0aW9uUGxhbikge1xuICBjb25zdCBraW5kID0gdHJhbnNhY3Rpb25QbGFuLmtpbmQ7XG4gIHN3aXRjaCAoa2luZCkge1xuICAgIGNhc2UgXCJzZXF1ZW50aWFsXCI6XG4gICAgICBpZiAoIXRyYW5zYWN0aW9uUGxhbi5kaXZpc2libGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fUExBTlNfX05PTl9ESVZJU0lCTEVfVFJBTlNBQ1RJT05fUExBTlNfTk9UX1NVUFBPUlRFRCk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHN1YlBsYW4gb2YgdHJhbnNhY3Rpb25QbGFuLnBsYW5zKSB7XG4gICAgICAgIGFzc2VydERpdmlzaWJsZVNlcXVlbnRpYWxQbGFuc09ubHkoc3ViUGxhbik7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgY2FzZSBcInBhcmFsbGVsXCI6XG4gICAgICBmb3IgKGNvbnN0IHN1YlBsYW4gb2YgdHJhbnNhY3Rpb25QbGFuLnBsYW5zKSB7XG4gICAgICAgIGFzc2VydERpdmlzaWJsZVNlcXVlbnRpYWxQbGFuc09ubHkoc3ViUGxhbik7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgY2FzZSBcInNpbmdsZVwiOlxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm47XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHBhc3N0aHJvdWdoRmFpbGVkVHJhbnNhY3Rpb25QbGFuRXhlY3V0aW9uKHByb21pc2UpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgcHJvbWlzZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoaXNTb2xhbmFFcnJvcihlcnJvciwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9QTEFOU19fRkFJTEVEX1RPX0VYRUNVVEVfVFJBTlNBQ1RJT05fUExBTikpIHtcbiAgICAgIHJldHVybiBlcnJvci5jb250ZXh0LnRyYW5zYWN0aW9uUGxhblJlc3VsdDtcbiAgICB9XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVRyYW5zYWN0aW9uUGxhbm5lcihjb25maWcpIHtcbiAgcmV0dXJuIGFzeW5jIChpbnN0cnVjdGlvblBsYW4sIHsgYWJvcnRTaWduYWwgfSA9IHt9KSA9PiB7XG4gICAgY29uc3QgcGxhbiA9IGF3YWl0IHRyYXZlcnNlMihpbnN0cnVjdGlvblBsYW4sIHtcbiAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgY3JlYXRlVHJhbnNhY3Rpb25NZXNzYWdlOiBjb25maWcuY3JlYXRlVHJhbnNhY3Rpb25NZXNzYWdlLFxuICAgICAgb25UcmFuc2FjdGlvbk1lc3NhZ2VVcGRhdGVkOiBjb25maWcub25UcmFuc2FjdGlvbk1lc3NhZ2VVcGRhdGVkID8/ICgobXNnKSA9PiBtc2cpLFxuICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgcGFyZW50Q2FuZGlkYXRlczogW11cbiAgICB9KTtcbiAgICBpZiAoIXBsYW4pIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX1BMQU5TX19FTVBUWV9JTlNUUlVDVElPTl9QTEFOKTtcbiAgICB9XG4gICAgcmV0dXJuIGZyZWV6ZVRyYW5zYWN0aW9uUGxhbihwbGFuKTtcbiAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHRyYXZlcnNlMihpbnN0cnVjdGlvblBsYW4sIGNvbnRleHQpIHtcbiAgY29udGV4dC5hYm9ydFNpZ25hbD8udGhyb3dJZkFib3J0ZWQoKTtcbiAgY29uc3Qga2luZCA9IGluc3RydWN0aW9uUGxhbi5raW5kO1xuICBzd2l0Y2ggKGtpbmQpIHtcbiAgICBjYXNlIFwic2VxdWVudGlhbFwiOlxuICAgICAgcmV0dXJuIGF3YWl0IHRyYXZlcnNlU2VxdWVudGlhbDIoaW5zdHJ1Y3Rpb25QbGFuLCBjb250ZXh0KTtcbiAgICBjYXNlIFwicGFyYWxsZWxcIjpcbiAgICAgIHJldHVybiBhd2FpdCB0cmF2ZXJzZVBhcmFsbGVsMihpbnN0cnVjdGlvblBsYW4sIGNvbnRleHQpO1xuICAgIGNhc2UgXCJzaW5nbGVcIjpcbiAgICAgIHJldHVybiBhd2FpdCB0cmF2ZXJzZVNpbmdsZTIoaW5zdHJ1Y3Rpb25QbGFuLCBjb250ZXh0KTtcbiAgICBjYXNlIFwibWVzc2FnZVBhY2tlclwiOlxuICAgICAgcmV0dXJuIGF3YWl0IHRyYXZlcnNlTWVzc2FnZVBhY2tlcihpbnN0cnVjdGlvblBsYW4sIGNvbnRleHQpO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19JTlZBUklBTlRfVklPTEFUSU9OX19JTlZBTElEX0lOU1RSVUNUSU9OX1BMQU5fS0lORCwgeyBraW5kIH0pO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiB0cmF2ZXJzZVNlcXVlbnRpYWwyKGluc3RydWN0aW9uUGxhbiwgY29udGV4dCkge1xuICBsZXQgY2FuZGlkYXRlID0gbnVsbDtcbiAgY29uc3QgbXVzdEVudGlyZWx5Rml0SW5QYXJlbnRDYW5kaWRhdGUgPSBjb250ZXh0LnBhcmVudCAmJiAoY29udGV4dC5wYXJlbnQua2luZCA9PT0gXCJwYXJhbGxlbFwiIHx8ICFpbnN0cnVjdGlvblBsYW4uZGl2aXNpYmxlKTtcbiAgaWYgKG11c3RFbnRpcmVseUZpdEluUGFyZW50Q2FuZGlkYXRlKSB7XG4gICAgY29uc3QgY2FuZGlkYXRlMiA9IGF3YWl0IHNlbGVjdEFuZE11dGF0ZUNhbmRpZGF0ZShcbiAgICAgIGNvbnRleHQsXG4gICAgICBjb250ZXh0LnBhcmVudENhbmRpZGF0ZXMsXG4gICAgICAobWVzc2FnZSkgPT4gZml0RW50aXJlUGxhbkluc2lkZU1lc3NhZ2UoaW5zdHJ1Y3Rpb25QbGFuLCBtZXNzYWdlKVxuICAgICk7XG4gICAgaWYgKGNhbmRpZGF0ZTIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjYW5kaWRhdGUgPSBjb250ZXh0LnBhcmVudENhbmRpZGF0ZXMubGVuZ3RoID4gMCA/IGNvbnRleHQucGFyZW50Q2FuZGlkYXRlc1swXSA6IG51bGw7XG4gIH1cbiAgY29uc3QgdHJhbnNhY3Rpb25QbGFucyA9IFtdO1xuICBmb3IgKGNvbnN0IHBsYW4gb2YgaW5zdHJ1Y3Rpb25QbGFuLnBsYW5zKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25QbGFuID0gYXdhaXQgdHJhdmVyc2UyKHBsYW4sIHtcbiAgICAgIC4uLmNvbnRleHQsXG4gICAgICBwYXJlbnQ6IGluc3RydWN0aW9uUGxhbixcbiAgICAgIHBhcmVudENhbmRpZGF0ZXM6IGNhbmRpZGF0ZSA/IFtjYW5kaWRhdGVdIDogW11cbiAgICB9KTtcbiAgICBpZiAodHJhbnNhY3Rpb25QbGFuKSB7XG4gICAgICBjYW5kaWRhdGUgPSBnZXRTZXF1ZW50aWFsQ2FuZGlkYXRlKHRyYW5zYWN0aW9uUGxhbik7XG4gICAgICBjb25zdCBuZXdQbGFucyA9IHRyYW5zYWN0aW9uUGxhbi5raW5kID09PSBcInNlcXVlbnRpYWxcIiAmJiAodHJhbnNhY3Rpb25QbGFuLmRpdmlzaWJsZSB8fCAhaW5zdHJ1Y3Rpb25QbGFuLmRpdmlzaWJsZSkgPyB0cmFuc2FjdGlvblBsYW4ucGxhbnMgOiBbdHJhbnNhY3Rpb25QbGFuXTtcbiAgICAgIHRyYW5zYWN0aW9uUGxhbnMucHVzaCguLi5uZXdQbGFucyk7XG4gICAgfVxuICB9XG4gIGlmICh0cmFuc2FjdGlvblBsYW5zLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiB0cmFuc2FjdGlvblBsYW5zWzBdO1xuICB9XG4gIGlmICh0cmFuc2FjdGlvblBsYW5zLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiB7XG4gICAgZGl2aXNpYmxlOiBpbnN0cnVjdGlvblBsYW4uZGl2aXNpYmxlLFxuICAgIGtpbmQ6IFwic2VxdWVudGlhbFwiLFxuICAgIHBsYW5zOiB0cmFuc2FjdGlvblBsYW5zXG4gIH07XG59XG5hc3luYyBmdW5jdGlvbiB0cmF2ZXJzZVBhcmFsbGVsMihpbnN0cnVjdGlvblBsYW4sIGNvbnRleHQpIHtcbiAgY29uc3QgY2FuZGlkYXRlcyA9IFsuLi5jb250ZXh0LnBhcmVudENhbmRpZGF0ZXNdO1xuICBjb25zdCB0cmFuc2FjdGlvblBsYW5zID0gW107XG4gIGNvbnN0IHNvcnRlZENoaWxkcmVuID0gQXJyYXkuZnJvbShpbnN0cnVjdGlvblBsYW4ucGxhbnMpLnNvcnQoXG4gICAgKGEsIGIpID0+IE51bWJlcihhLmtpbmQgPT09IFwibWVzc2FnZVBhY2tlclwiKSAtIE51bWJlcihiLmtpbmQgPT09IFwibWVzc2FnZVBhY2tlclwiKVxuICApO1xuICBmb3IgKGNvbnN0IHBsYW4gb2Ygc29ydGVkQ2hpbGRyZW4pIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvblBsYW4gPSBhd2FpdCB0cmF2ZXJzZTIocGxhbiwge1xuICAgICAgLi4uY29udGV4dCxcbiAgICAgIHBhcmVudDogaW5zdHJ1Y3Rpb25QbGFuLFxuICAgICAgcGFyZW50Q2FuZGlkYXRlczogY2FuZGlkYXRlc1xuICAgIH0pO1xuICAgIGlmICh0cmFuc2FjdGlvblBsYW4pIHtcbiAgICAgIGNhbmRpZGF0ZXMucHVzaCguLi5nZXRQYXJhbGxlbENhbmRpZGF0ZXModHJhbnNhY3Rpb25QbGFuKSk7XG4gICAgICBjb25zdCBuZXdQbGFucyA9IHRyYW5zYWN0aW9uUGxhbi5raW5kID09PSBcInBhcmFsbGVsXCIgPyB0cmFuc2FjdGlvblBsYW4ucGxhbnMgOiBbdHJhbnNhY3Rpb25QbGFuXTtcbiAgICAgIHRyYW5zYWN0aW9uUGxhbnMucHVzaCguLi5uZXdQbGFucyk7XG4gICAgfVxuICB9XG4gIGlmICh0cmFuc2FjdGlvblBsYW5zLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiB0cmFuc2FjdGlvblBsYW5zWzBdO1xuICB9XG4gIGlmICh0cmFuc2FjdGlvblBsYW5zLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiB7IGtpbmQ6IFwicGFyYWxsZWxcIiwgcGxhbnM6IHRyYW5zYWN0aW9uUGxhbnMgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHRyYXZlcnNlU2luZ2xlMihpbnN0cnVjdGlvblBsYW4sIGNvbnRleHQpIHtcbiAgY29uc3QgcHJlZGljYXRlID0gKG1lc3NhZ2UyKSA9PiBhcHBlbmRUcmFuc2FjdGlvbk1lc3NhZ2VJbnN0cnVjdGlvbnMoW2luc3RydWN0aW9uUGxhbi5pbnN0cnVjdGlvbl0sIG1lc3NhZ2UyKTtcbiAgY29uc3QgY2FuZGlkYXRlID0gYXdhaXQgc2VsZWN0QW5kTXV0YXRlQ2FuZGlkYXRlKGNvbnRleHQsIGNvbnRleHQucGFyZW50Q2FuZGlkYXRlcywgcHJlZGljYXRlKTtcbiAgaWYgKGNhbmRpZGF0ZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IG1lc3NhZ2UgPSBhd2FpdCBjcmVhdGVOZXdNZXNzYWdlKGNvbnRleHQsIHByZWRpY2F0ZSk7XG4gIHJldHVybiB7IGtpbmQ6IFwic2luZ2xlXCIsIG1lc3NhZ2UgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHRyYXZlcnNlTWVzc2FnZVBhY2tlcihpbnN0cnVjdGlvblBsYW4sIGNvbnRleHQpIHtcbiAgY29uc3QgbWVzc2FnZVBhY2tlciA9IGluc3RydWN0aW9uUGxhbi5nZXRNZXNzYWdlUGFja2VyKCk7XG4gIGNvbnN0IHRyYW5zYWN0aW9uUGxhbnMgPSBbXTtcbiAgY29uc3QgY2FuZGlkYXRlcyA9IFsuLi5jb250ZXh0LnBhcmVudENhbmRpZGF0ZXNdO1xuICB3aGlsZSAoIW1lc3NhZ2VQYWNrZXIuZG9uZSgpKSB7XG4gICAgY29uc3QgY2FuZGlkYXRlID0gYXdhaXQgc2VsZWN0QW5kTXV0YXRlQ2FuZGlkYXRlKGNvbnRleHQsIGNhbmRpZGF0ZXMsIG1lc3NhZ2VQYWNrZXIucGFja01lc3NhZ2VUb0NhcGFjaXR5KTtcbiAgICBpZiAoIWNhbmRpZGF0ZSkge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGF3YWl0IGNyZWF0ZU5ld01lc3NhZ2UoY29udGV4dCwgbWVzc2FnZVBhY2tlci5wYWNrTWVzc2FnZVRvQ2FwYWNpdHkpO1xuICAgICAgY29uc3QgbmV3UGxhbiA9IHsga2luZDogXCJzaW5nbGVcIiwgbWVzc2FnZSB9O1xuICAgICAgdHJhbnNhY3Rpb25QbGFucy5wdXNoKG5ld1BsYW4pO1xuICAgIH1cbiAgfVxuICBpZiAodHJhbnNhY3Rpb25QbGFucy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gdHJhbnNhY3Rpb25QbGFuc1swXTtcbiAgfVxuICBpZiAodHJhbnNhY3Rpb25QbGFucy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoY29udGV4dC5wYXJlbnQ/LmtpbmQgPT09IFwicGFyYWxsZWxcIikge1xuICAgIHJldHVybiB7IGtpbmQ6IFwicGFyYWxsZWxcIiwgcGxhbnM6IHRyYW5zYWN0aW9uUGxhbnMgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGRpdmlzaWJsZTogY29udGV4dC5wYXJlbnQ/LmtpbmQgPT09IFwic2VxdWVudGlhbFwiID8gY29udGV4dC5wYXJlbnQuZGl2aXNpYmxlIDogdHJ1ZSxcbiAgICBraW5kOiBcInNlcXVlbnRpYWxcIixcbiAgICBwbGFuczogdHJhbnNhY3Rpb25QbGFuc1xuICB9O1xufVxuZnVuY3Rpb24gZ2V0U2VxdWVudGlhbENhbmRpZGF0ZShsYXRlc3RQbGFuKSB7XG4gIGlmIChsYXRlc3RQbGFuLmtpbmQgPT09IFwic2luZ2xlXCIpIHtcbiAgICByZXR1cm4gbGF0ZXN0UGxhbjtcbiAgfVxuICBpZiAobGF0ZXN0UGxhbi5raW5kID09PSBcInNlcXVlbnRpYWxcIiAmJiBsYXRlc3RQbGFuLnBsYW5zLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gZ2V0U2VxdWVudGlhbENhbmRpZGF0ZShsYXRlc3RQbGFuLnBsYW5zW2xhdGVzdFBsYW4ucGxhbnMubGVuZ3RoIC0gMV0pO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0UGFyYWxsZWxDYW5kaWRhdGVzKGxhdGVzdFBsYW4pIHtcbiAgcmV0dXJuIGZsYXR0ZW5UcmFuc2FjdGlvblBsYW4obGF0ZXN0UGxhbik7XG59XG5hc3luYyBmdW5jdGlvbiBzZWxlY3RBbmRNdXRhdGVDYW5kaWRhdGUoY29udGV4dCwgY2FuZGlkYXRlcywgcHJlZGljYXRlKSB7XG4gIGZvciAoY29uc3QgY2FuZGlkYXRlIG9mIGNhbmRpZGF0ZXMpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGF3YWl0IGdldEFib3J0YWJsZVByb21pc2UoXG4gICAgICAgIFByb21pc2UucmVzb2x2ZShcbiAgICAgICAgICBjb250ZXh0Lm9uVHJhbnNhY3Rpb25NZXNzYWdlVXBkYXRlZChwcmVkaWNhdGUoY2FuZGlkYXRlLm1lc3NhZ2UpLCB7XG4gICAgICAgICAgICBhYm9ydFNpZ25hbDogY29udGV4dC5hYm9ydFNpZ25hbFxuICAgICAgICAgIH0pXG4gICAgICAgICksXG4gICAgICAgIGNvbnRleHQuYWJvcnRTaWduYWxcbiAgICAgICk7XG4gICAgICBpZiAoZ2V0VHJhbnNhY3Rpb25NZXNzYWdlU2l6ZShtZXNzYWdlKSA8PSBUUkFOU0FDVElPTl9TSVpFX0xJTUlUKSB7XG4gICAgICAgIGNhbmRpZGF0ZS5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGlzU29sYW5hRXJyb3IoZXJyb3IsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fUExBTlNfX01FU1NBR0VfQ0FOTk9UX0FDQ09NTU9EQVRFX1BMQU4pKSA7IGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5hc3luYyBmdW5jdGlvbiBjcmVhdGVOZXdNZXNzYWdlKGNvbnRleHQsIHByZWRpY2F0ZSkge1xuICBjb25zdCBuZXdNZXNzYWdlID0gYXdhaXQgZ2V0QWJvcnRhYmxlUHJvbWlzZShcbiAgICBQcm9taXNlLnJlc29sdmUoY29udGV4dC5jcmVhdGVUcmFuc2FjdGlvbk1lc3NhZ2UoeyBhYm9ydFNpZ25hbDogY29udGV4dC5hYm9ydFNpZ25hbCB9KSksXG4gICAgY29udGV4dC5hYm9ydFNpZ25hbFxuICApO1xuICBjb25zdCB1cGRhdGVkTWVzc2FnZSA9IGF3YWl0IGdldEFib3J0YWJsZVByb21pc2UoXG4gICAgUHJvbWlzZS5yZXNvbHZlKFxuICAgICAgY29udGV4dC5vblRyYW5zYWN0aW9uTWVzc2FnZVVwZGF0ZWQocHJlZGljYXRlKG5ld01lc3NhZ2UpLCB7IGFib3J0U2lnbmFsOiBjb250ZXh0LmFib3J0U2lnbmFsIH0pXG4gICAgKSxcbiAgICBjb250ZXh0LmFib3J0U2lnbmFsXG4gICk7XG4gIGNvbnN0IHVwZGF0ZWRNZXNzYWdlU2l6ZSA9IGdldFRyYW5zYWN0aW9uTWVzc2FnZVNpemUodXBkYXRlZE1lc3NhZ2UpO1xuICBpZiAodXBkYXRlZE1lc3NhZ2VTaXplID4gVFJBTlNBQ1RJT05fU0laRV9MSU1JVCkge1xuICAgIGNvbnN0IG5ld01lc3NhZ2VTaXplID0gZ2V0VHJhbnNhY3Rpb25NZXNzYWdlU2l6ZShuZXdNZXNzYWdlKTtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9QTEFOU19fTUVTU0FHRV9DQU5OT1RfQUNDT01NT0RBVEVfUExBTiwge1xuICAgICAgbnVtQnl0ZXNSZXF1aXJlZDogdXBkYXRlZE1lc3NhZ2VTaXplIC0gbmV3TWVzc2FnZVNpemUsXG4gICAgICBudW1GcmVlQnl0ZXM6IFRSQU5TQUNUSU9OX1NJWkVfTElNSVQgLSBuZXdNZXNzYWdlU2l6ZVxuICAgIH0pO1xuICB9XG4gIHJldHVybiB1cGRhdGVkTWVzc2FnZTtcbn1cbmZ1bmN0aW9uIGZyZWV6ZVRyYW5zYWN0aW9uUGxhbihwbGFuKSB7XG4gIGNvbnN0IGtpbmQgPSBwbGFuLmtpbmQ7XG4gIHN3aXRjaCAoa2luZCkge1xuICAgIGNhc2UgXCJzaW5nbGVcIjpcbiAgICAgIHJldHVybiBzaW5nbGVUcmFuc2FjdGlvblBsYW4ocGxhbi5tZXNzYWdlKTtcbiAgICBjYXNlIFwic2VxdWVudGlhbFwiOlxuICAgICAgcmV0dXJuIHBsYW4uZGl2aXNpYmxlID8gc2VxdWVudGlhbFRyYW5zYWN0aW9uUGxhbihwbGFuLnBsYW5zLm1hcChmcmVlemVUcmFuc2FjdGlvblBsYW4pKSA6IG5vbkRpdmlzaWJsZVNlcXVlbnRpYWxUcmFuc2FjdGlvblBsYW4ocGxhbi5wbGFucy5tYXAoZnJlZXplVHJhbnNhY3Rpb25QbGFuKSk7XG4gICAgY2FzZSBcInBhcmFsbGVsXCI6XG4gICAgICByZXR1cm4gcGFyYWxsZWxUcmFuc2FjdGlvblBsYW4ocGxhbi5wbGFucy5tYXAoZnJlZXplVHJhbnNhY3Rpb25QbGFuKSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0lOVkFSSUFOVF9WSU9MQVRJT05fX0lOVkFMSURfVFJBTlNBQ1RJT05fUExBTl9LSU5ELCB7IGtpbmQgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGZpdEVudGlyZVBsYW5JbnNpZGVNZXNzYWdlKGluc3RydWN0aW9uUGxhbiwgbWVzc2FnZSkge1xuICBsZXQgbmV3TWVzc2FnZSA9IG1lc3NhZ2U7XG4gIGNvbnN0IGtpbmQgPSBpbnN0cnVjdGlvblBsYW4ua2luZDtcbiAgc3dpdGNoIChraW5kKSB7XG4gICAgY2FzZSBcInNlcXVlbnRpYWxcIjpcbiAgICBjYXNlIFwicGFyYWxsZWxcIjpcbiAgICAgIGZvciAoY29uc3QgcGxhbiBvZiBpbnN0cnVjdGlvblBsYW4ucGxhbnMpIHtcbiAgICAgICAgbmV3TWVzc2FnZSA9IGZpdEVudGlyZVBsYW5JbnNpZGVNZXNzYWdlKHBsYW4sIG5ld01lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld01lc3NhZ2U7XG4gICAgY2FzZSBcInNpbmdsZVwiOlxuICAgICAgbmV3TWVzc2FnZSA9IGFwcGVuZFRyYW5zYWN0aW9uTWVzc2FnZUluc3RydWN0aW9ucyhbaW5zdHJ1Y3Rpb25QbGFuLmluc3RydWN0aW9uXSwgbWVzc2FnZSk7XG4gICAgICBjb25zdCBuZXdNZXNzYWdlU2l6ZSA9IGdldFRyYW5zYWN0aW9uTWVzc2FnZVNpemUobmV3TWVzc2FnZSk7XG4gICAgICBpZiAobmV3TWVzc2FnZVNpemUgPiBUUkFOU0FDVElPTl9TSVpFX0xJTUlUKSB7XG4gICAgICAgIGNvbnN0IGJhc2VNZXNzYWdlU2l6ZSA9IGdldFRyYW5zYWN0aW9uTWVzc2FnZVNpemUobWVzc2FnZSk7XG4gICAgICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX1BMQU5TX19NRVNTQUdFX0NBTk5PVF9BQ0NPTU1PREFURV9QTEFOLCB7XG4gICAgICAgICAgbnVtQnl0ZXNSZXF1aXJlZDogbmV3TWVzc2FnZVNpemUgLSBiYXNlTWVzc2FnZVNpemUsXG4gICAgICAgICAgbnVtRnJlZUJ5dGVzOiBUUkFOU0FDVElPTl9TSVpFX0xJTUlUIC0gYmFzZU1lc3NhZ2VTaXplXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld01lc3NhZ2U7XG4gICAgY2FzZSBcIm1lc3NhZ2VQYWNrZXJcIjpcbiAgICAgIGNvbnN0IG1lc3NhZ2VQYWNrZXIgPSBpbnN0cnVjdGlvblBsYW4uZ2V0TWVzc2FnZVBhY2tlcigpO1xuICAgICAgd2hpbGUgKCFtZXNzYWdlUGFja2VyLmRvbmUoKSkge1xuICAgICAgICBuZXdNZXNzYWdlID0gbWVzc2FnZVBhY2tlci5wYWNrTWVzc2FnZVRvQ2FwYWNpdHkobmV3TWVzc2FnZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3TWVzc2FnZTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fSU5WQVJJQU5UX1ZJT0xBVElPTl9fSU5WQUxJRF9JTlNUUlVDVElPTl9QTEFOX0tJTkQsIHsga2luZCB9KTtcbiAgfVxufVxuXG5leHBvcnQgeyBhcHBlbmRUcmFuc2FjdGlvbk1lc3NhZ2VJbnN0cnVjdGlvblBsYW4sIGFzc2VydElzQ2FuY2VsZWRTaW5nbGVUcmFuc2FjdGlvblBsYW5SZXN1bHQsIGFzc2VydElzRmFpbGVkU2luZ2xlVHJhbnNhY3Rpb25QbGFuUmVzdWx0LCBhc3NlcnRJc01lc3NhZ2VQYWNrZXJJbnN0cnVjdGlvblBsYW4sIGFzc2VydElzTm9uRGl2aXNpYmxlU2VxdWVudGlhbEluc3RydWN0aW9uUGxhbiwgYXNzZXJ0SXNOb25EaXZpc2libGVTZXF1ZW50aWFsVHJhbnNhY3Rpb25QbGFuLCBhc3NlcnRJc05vbkRpdmlzaWJsZVNlcXVlbnRpYWxUcmFuc2FjdGlvblBsYW5SZXN1bHQsIGFzc2VydElzUGFyYWxsZWxJbnN0cnVjdGlvblBsYW4sIGFzc2VydElzUGFyYWxsZWxUcmFuc2FjdGlvblBsYW4sIGFzc2VydElzUGFyYWxsZWxUcmFuc2FjdGlvblBsYW5SZXN1bHQsIGFzc2VydElzU2VxdWVudGlhbEluc3RydWN0aW9uUGxhbiwgYXNzZXJ0SXNTZXF1ZW50aWFsVHJhbnNhY3Rpb25QbGFuLCBhc3NlcnRJc1NlcXVlbnRpYWxUcmFuc2FjdGlvblBsYW5SZXN1bHQsIGFzc2VydElzU2luZ2xlSW5zdHJ1Y3Rpb25QbGFuLCBhc3NlcnRJc1NpbmdsZVRyYW5zYWN0aW9uUGxhbiwgYXNzZXJ0SXNTaW5nbGVUcmFuc2FjdGlvblBsYW5SZXN1bHQsIGFzc2VydElzU3VjY2Vzc2Z1bFNpbmdsZVRyYW5zYWN0aW9uUGxhblJlc3VsdCwgYXNzZXJ0SXNTdWNjZXNzZnVsVHJhbnNhY3Rpb25QbGFuUmVzdWx0LCBjYW5jZWxlZFNpbmdsZVRyYW5zYWN0aW9uUGxhblJlc3VsdCwgY3JlYXRlVHJhbnNhY3Rpb25QbGFuRXhlY3V0b3IsIGNyZWF0ZVRyYW5zYWN0aW9uUGxhbm5lciwgZXZlcnlJbnN0cnVjdGlvblBsYW4sIGV2ZXJ5VHJhbnNhY3Rpb25QbGFuLCBldmVyeVRyYW5zYWN0aW9uUGxhblJlc3VsdCwgZmFpbGVkU2luZ2xlVHJhbnNhY3Rpb25QbGFuUmVzdWx0LCBmaW5kSW5zdHJ1Y3Rpb25QbGFuLCBmaW5kVHJhbnNhY3Rpb25QbGFuLCBmaW5kVHJhbnNhY3Rpb25QbGFuUmVzdWx0LCBmbGF0dGVuSW5zdHJ1Y3Rpb25QbGFuLCBmbGF0dGVuVHJhbnNhY3Rpb25QbGFuLCBmbGF0dGVuVHJhbnNhY3Rpb25QbGFuUmVzdWx0LCBnZXRBbGxTaW5nbGVUcmFuc2FjdGlvblBsYW5zLCBnZXRGaXJzdEZhaWxlZFNpbmdsZVRyYW5zYWN0aW9uUGxhblJlc3VsdCwgZ2V0TGluZWFyTWVzc2FnZVBhY2tlckluc3RydWN0aW9uUGxhbiwgZ2V0TWVzc2FnZVBhY2tlckluc3RydWN0aW9uUGxhbkZyb21JbnN0cnVjdGlvbnMsIGdldFJlYWxsb2NNZXNzYWdlUGFja2VySW5zdHJ1Y3Rpb25QbGFuLCBpc0NhbmNlbGVkU2luZ2xlVHJhbnNhY3Rpb25QbGFuUmVzdWx0LCBpc0ZhaWxlZFNpbmdsZVRyYW5zYWN0aW9uUGxhblJlc3VsdCwgaXNNZXNzYWdlUGFja2VySW5zdHJ1Y3Rpb25QbGFuLCBpc05vbkRpdmlzaWJsZVNlcXVlbnRpYWxJbnN0cnVjdGlvblBsYW4sIGlzTm9uRGl2aXNpYmxlU2VxdWVudGlhbFRyYW5zYWN0aW9uUGxhbiwgaXNOb25EaXZpc2libGVTZXF1ZW50aWFsVHJhbnNhY3Rpb25QbGFuUmVzdWx0LCBpc1BhcmFsbGVsSW5zdHJ1Y3Rpb25QbGFuLCBpc1BhcmFsbGVsVHJhbnNhY3Rpb25QbGFuLCBpc1BhcmFsbGVsVHJhbnNhY3Rpb25QbGFuUmVzdWx0LCBpc1NlcXVlbnRpYWxJbnN0cnVjdGlvblBsYW4sIGlzU2VxdWVudGlhbFRyYW5zYWN0aW9uUGxhbiwgaXNTZXF1ZW50aWFsVHJhbnNhY3Rpb25QbGFuUmVzdWx0LCBpc1NpbmdsZUluc3RydWN0aW9uUGxhbiwgaXNTaW5nbGVUcmFuc2FjdGlvblBsYW4sIGlzU2luZ2xlVHJhbnNhY3Rpb25QbGFuUmVzdWx0LCBpc1N1Y2Nlc3NmdWxTaW5nbGVUcmFuc2FjdGlvblBsYW5SZXN1bHQsIGlzU3VjY2Vzc2Z1bFRyYW5zYWN0aW9uUGxhblJlc3VsdCwgbm9uRGl2aXNpYmxlU2VxdWVudGlhbEluc3RydWN0aW9uUGxhbiwgbm9uRGl2aXNpYmxlU2VxdWVudGlhbFRyYW5zYWN0aW9uUGxhbiwgbm9uRGl2aXNpYmxlU2VxdWVudGlhbFRyYW5zYWN0aW9uUGxhblJlc3VsdCwgcGFyYWxsZWxJbnN0cnVjdGlvblBsYW4sIHBhcmFsbGVsVHJhbnNhY3Rpb25QbGFuLCBwYXJhbGxlbFRyYW5zYWN0aW9uUGxhblJlc3VsdCwgcGFzc3Rocm91Z2hGYWlsZWRUcmFuc2FjdGlvblBsYW5FeGVjdXRpb24sIHNlcXVlbnRpYWxJbnN0cnVjdGlvblBsYW4sIHNlcXVlbnRpYWxUcmFuc2FjdGlvblBsYW4sIHNlcXVlbnRpYWxUcmFuc2FjdGlvblBsYW5SZXN1bHQsIHNpbmdsZUluc3RydWN0aW9uUGxhbiwgc2luZ2xlVHJhbnNhY3Rpb25QbGFuLCBzdWNjZXNzZnVsU2luZ2xlVHJhbnNhY3Rpb25QbGFuUmVzdWx0LCBzdWNjZXNzZnVsU2luZ2xlVHJhbnNhY3Rpb25QbGFuUmVzdWx0RnJvbVNpZ25hdHVyZSwgc3VtbWFyaXplVHJhbnNhY3Rpb25QbGFuUmVzdWx0LCB0cmFuc2Zvcm1JbnN0cnVjdGlvblBsYW4sIHRyYW5zZm9ybVRyYW5zYWN0aW9uUGxhbiwgdHJhbnNmb3JtVHJhbnNhY3Rpb25QbGFuUmVzdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5ub2RlLm1qcy5tYXBcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm5vZGUubWpzLm1hcCJdLCJuYW1lcyI6WyJTb2xhbmFFcnJvciIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fUExBTlNfX1VORVhQRUNURURfSU5TVFJVQ1RJT05fUExBTiIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fUExBTlNfX01FU1NBR0VfUEFDS0VSX0FMUkVBRFlfQ09NUExFVEUiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX1BMQU5TX19NRVNTQUdFX0NBTk5PVF9BQ0NPTU1PREFURV9QTEFOIiwiU09MQU5BX0VSUk9SX19JTlZBUklBTlRfVklPTEFUSU9OX19JTlZBTElEX0lOU1RSVUNUSU9OX1BMQU5fS0lORCIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fUExBTlNfX1VORVhQRUNURURfVFJBTlNBQ1RJT05fUExBTiIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fUExBTlNfX1VORVhQRUNURURfVFJBTlNBQ1RJT05fUExBTl9SRVNVTFQiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX1BMQU5TX19FWFBFQ1RFRF9TVUNDRVNTRlVMX1RSQU5TQUNUSU9OX1BMQU5fUkVTVUxUIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9QTEFOU19fRkFJTEVEX1NJTkdMRV9UUkFOU0FDVElPTl9QTEFOX1JFU1VMVF9OT1RfRk9VTkQiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX1BMQU5TX19GQUlMRURfVE9fRVhFQ1VURV9UUkFOU0FDVElPTl9QTEFOIiwiU09MQU5BX0VSUk9SX19JTlZBUklBTlRfVklPTEFUSU9OX19JTlZBTElEX1RSQU5TQUNUSU9OX1BMQU5fS0lORCIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fUExBTlNfX05PTl9ESVZJU0lCTEVfVFJBTlNBQ1RJT05fUExBTlNfTk9UX1NVUFBPUlRFRCIsImlzU29sYW5hRXJyb3IiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX1BMQU5TX19FTVBUWV9JTlNUUlVDVElPTl9QTEFOIiwiYXBwZW5kVHJhbnNhY3Rpb25NZXNzYWdlSW5zdHJ1Y3Rpb24iLCJhcHBlbmRUcmFuc2FjdGlvbk1lc3NhZ2VJbnN0cnVjdGlvbnMiLCJnZXRUcmFuc2FjdGlvbk1lc3NhZ2VTaXplIiwiVFJBTlNBQ1RJT05fU0laRV9MSU1JVCIsImdldFNpZ25hdHVyZUZyb21UcmFuc2FjdGlvbiIsImdldEFib3J0YWJsZVByb21pc2UiLCJwYXJhbGxlbEluc3RydWN0aW9uUGxhbiIsInBsYW5zIiwiT2JqZWN0IiwiZnJlZXplIiwia2luZCIsInBhcnNlU2luZ2xlSW5zdHJ1Y3Rpb25QbGFucyIsInNlcXVlbnRpYWxJbnN0cnVjdGlvblBsYW4iLCJkaXZpc2libGUiLCJub25EaXZpc2libGVTZXF1ZW50aWFsSW5zdHJ1Y3Rpb25QbGFuIiwic2luZ2xlSW5zdHJ1Y3Rpb25QbGFuIiwiaW5zdHJ1Y3Rpb24iLCJtYXAiLCJwbGFuIiwiaXNTaW5nbGVJbnN0cnVjdGlvblBsYW4iLCJhc3NlcnRJc1NpbmdsZUluc3RydWN0aW9uUGxhbiIsImFjdHVhbEtpbmQiLCJleHBlY3RlZEtpbmQiLCJpbnN0cnVjdGlvblBsYW4iLCJpc01lc3NhZ2VQYWNrZXJJbnN0cnVjdGlvblBsYW4iLCJhc3NlcnRJc01lc3NhZ2VQYWNrZXJJbnN0cnVjdGlvblBsYW4iLCJpc1NlcXVlbnRpYWxJbnN0cnVjdGlvblBsYW4iLCJhc3NlcnRJc1NlcXVlbnRpYWxJbnN0cnVjdGlvblBsYW4iLCJpc05vbkRpdmlzaWJsZVNlcXVlbnRpYWxJbnN0cnVjdGlvblBsYW4iLCJhc3NlcnRJc05vbkRpdmlzaWJsZVNlcXVlbnRpYWxJbnN0cnVjdGlvblBsYW4iLCJpc1BhcmFsbGVsSW5zdHJ1Y3Rpb25QbGFuIiwiYXNzZXJ0SXNQYXJhbGxlbEluc3RydWN0aW9uUGxhbiIsImZpbmRJbnN0cnVjdGlvblBsYW4iLCJwcmVkaWNhdGUiLCJzdWJQbGFuIiwiZm91bmRQbGFuIiwiZXZlcnlJbnN0cnVjdGlvblBsYW4iLCJldmVyeSIsInAiLCJ0cmFuc2Zvcm1JbnN0cnVjdGlvblBsYW4iLCJmbiIsImZsYXR0ZW5JbnN0cnVjdGlvblBsYW4iLCJmbGF0TWFwIiwiZ2V0TGluZWFyTWVzc2FnZVBhY2tlckluc3RydWN0aW9uUGxhbiIsImdldEluc3RydWN0aW9uIiwidG90YWxMZW5ndGgiLCJ0b3RhbEJ5dGVzIiwiZ2V0TWVzc2FnZVBhY2tlciIsIm9mZnNldCIsImRvbmUiLCJwYWNrTWVzc2FnZVRvQ2FwYWNpdHkiLCJtZXNzYWdlIiwibWVzc2FnZVNpemVXaXRoQmFzZUluc3RydWN0aW9uIiwiZnJlZVNwYWNlIiwibWVzc2FnZVNpemUiLCJudW1CeXRlc1JlcXVpcmVkIiwibnVtRnJlZUJ5dGVzIiwibGVuZ3RoIiwiTWF0aCIsIm1pbiIsImdldE1lc3NhZ2VQYWNrZXJJbnN0cnVjdGlvblBsYW5Gcm9tSW5zdHJ1Y3Rpb25zIiwiaW5zdHJ1Y3Rpb25zIiwiaW5zdHJ1Y3Rpb25JbmRleCIsIm9yaWdpbmFsTWVzc2FnZVNpemUiLCJpbmRleCIsIlJFQUxMT0NfTElNSVQiLCJnZXRSZWFsbG9jTWVzc2FnZVBhY2tlckluc3RydWN0aW9uUGxhbiIsInRvdGFsU2l6ZSIsIm51bWJlck9mSW5zdHJ1Y3Rpb25zIiwiY2VpbCIsImxhc3RJbnN0cnVjdGlvblNpemUiLCJBcnJheSIsImZpbGwiLCJfIiwiaSIsImFwcGVuZFRyYW5zYWN0aW9uTWVzc2FnZUluc3RydWN0aW9uUGxhbiIsInRyYW5zYWN0aW9uTWVzc2FnZSIsImxlYWZJbnN0cnVjdGlvblBsYW5zIiwicmVkdWNlIiwibWVzc2FnZVNvRmFyIiwibWVzc2FnZXJQYWNrZXIiLCJuZXh0TWVzc2FnZSIsInBhcmFsbGVsVHJhbnNhY3Rpb25QbGFuIiwicGFyc2VTaW5nbGVUcmFuc2FjdGlvblBsYW5zIiwic2VxdWVudGlhbFRyYW5zYWN0aW9uUGxhbiIsIm5vbkRpdmlzaWJsZVNlcXVlbnRpYWxUcmFuc2FjdGlvblBsYW4iLCJzaW5nbGVUcmFuc2FjdGlvblBsYW4iLCJpc1NpbmdsZVRyYW5zYWN0aW9uUGxhbiIsImFzc2VydElzU2luZ2xlVHJhbnNhY3Rpb25QbGFuIiwidHJhbnNhY3Rpb25QbGFuIiwiaXNTZXF1ZW50aWFsVHJhbnNhY3Rpb25QbGFuIiwiYXNzZXJ0SXNTZXF1ZW50aWFsVHJhbnNhY3Rpb25QbGFuIiwiaXNOb25EaXZpc2libGVTZXF1ZW50aWFsVHJhbnNhY3Rpb25QbGFuIiwiYXNzZXJ0SXNOb25EaXZpc2libGVTZXF1ZW50aWFsVHJhbnNhY3Rpb25QbGFuIiwiaXNQYXJhbGxlbFRyYW5zYWN0aW9uUGxhbiIsImFzc2VydElzUGFyYWxsZWxUcmFuc2FjdGlvblBsYW4iLCJnZXRBbGxTaW5nbGVUcmFuc2FjdGlvblBsYW5zIiwiZmxhdHRlblRyYW5zYWN0aW9uUGxhbiIsImZpbmRUcmFuc2FjdGlvblBsYW4iLCJldmVyeVRyYW5zYWN0aW9uUGxhbiIsInRyYW5zZm9ybVRyYW5zYWN0aW9uUGxhbiIsInNlcXVlbnRpYWxUcmFuc2FjdGlvblBsYW5SZXN1bHQiLCJub25EaXZpc2libGVTZXF1ZW50aWFsVHJhbnNhY3Rpb25QbGFuUmVzdWx0IiwicGFyYWxsZWxUcmFuc2FjdGlvblBsYW5SZXN1bHQiLCJzdWNjZXNzZnVsU2luZ2xlVHJhbnNhY3Rpb25QbGFuUmVzdWx0IiwidHJhbnNhY3Rpb24iLCJjb250ZXh0Iiwic3RhdHVzIiwic2lnbmF0dXJlIiwic3VjY2Vzc2Z1bFNpbmdsZVRyYW5zYWN0aW9uUGxhblJlc3VsdEZyb21TaWduYXR1cmUiLCJmYWlsZWRTaW5nbGVUcmFuc2FjdGlvblBsYW5SZXN1bHQiLCJlcnJvciIsImNhbmNlbGVkU2luZ2xlVHJhbnNhY3Rpb25QbGFuUmVzdWx0IiwiaXNTaW5nbGVUcmFuc2FjdGlvblBsYW5SZXN1bHQiLCJhc3NlcnRJc1NpbmdsZVRyYW5zYWN0aW9uUGxhblJlc3VsdCIsInRyYW5zYWN0aW9uUGxhblJlc3VsdCIsImlzU3VjY2Vzc2Z1bFNpbmdsZVRyYW5zYWN0aW9uUGxhblJlc3VsdCIsImFzc2VydElzU3VjY2Vzc2Z1bFNpbmdsZVRyYW5zYWN0aW9uUGxhblJlc3VsdCIsImlzRmFpbGVkU2luZ2xlVHJhbnNhY3Rpb25QbGFuUmVzdWx0IiwiYXNzZXJ0SXNGYWlsZWRTaW5nbGVUcmFuc2FjdGlvblBsYW5SZXN1bHQiLCJpc0NhbmNlbGVkU2luZ2xlVHJhbnNhY3Rpb25QbGFuUmVzdWx0IiwiYXNzZXJ0SXNDYW5jZWxlZFNpbmdsZVRyYW5zYWN0aW9uUGxhblJlc3VsdCIsImlzU2VxdWVudGlhbFRyYW5zYWN0aW9uUGxhblJlc3VsdCIsImFzc2VydElzU2VxdWVudGlhbFRyYW5zYWN0aW9uUGxhblJlc3VsdCIsImlzTm9uRGl2aXNpYmxlU2VxdWVudGlhbFRyYW5zYWN0aW9uUGxhblJlc3VsdCIsImFzc2VydElzTm9uRGl2aXNpYmxlU2VxdWVudGlhbFRyYW5zYWN0aW9uUGxhblJlc3VsdCIsImlzUGFyYWxsZWxUcmFuc2FjdGlvblBsYW5SZXN1bHQiLCJhc3NlcnRJc1BhcmFsbGVsVHJhbnNhY3Rpb25QbGFuUmVzdWx0IiwiaXNTdWNjZXNzZnVsVHJhbnNhY3Rpb25QbGFuUmVzdWx0IiwiZXZlcnlUcmFuc2FjdGlvblBsYW5SZXN1bHQiLCJyIiwiYXNzZXJ0SXNTdWNjZXNzZnVsVHJhbnNhY3Rpb25QbGFuUmVzdWx0IiwiZmluZFRyYW5zYWN0aW9uUGxhblJlc3VsdCIsInN1YlJlc3VsdCIsImZvdW5kUmVzdWx0IiwiZ2V0Rmlyc3RGYWlsZWRTaW5nbGVUcmFuc2FjdGlvblBsYW5SZXN1bHQiLCJyZXN1bHQiLCJkZWZpbmVQcm9wZXJ0eSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJ2YWx1ZSIsIndyaXRhYmxlIiwidHJhbnNmb3JtVHJhbnNhY3Rpb25QbGFuUmVzdWx0IiwiZmxhdHRlblRyYW5zYWN0aW9uUGxhblJlc3VsdCIsInN1bW1hcml6ZVRyYW5zYWN0aW9uUGxhblJlc3VsdCIsInN1Y2Nlc3NmdWxUcmFuc2FjdGlvbnMiLCJmYWlsZWRUcmFuc2FjdGlvbnMiLCJjYW5jZWxlZFRyYW5zYWN0aW9ucyIsImZsYXR0ZW5lZFJlc3VsdHMiLCJzaW5nbGVSZXN1bHQiLCJwdXNoIiwic3VjY2Vzc2Z1bCIsImNyZWF0ZVRyYW5zYWN0aW9uUGxhbkV4ZWN1dG9yIiwiY29uZmlnIiwiYWJvcnRTaWduYWwiLCJjYW5jZWxlZCIsImFib3J0ZWQiLCJhc3NlcnREaXZpc2libGVTZXF1ZW50aWFsUGxhbnNPbmx5IiwiY2FuY2VsSGFuZGxlciIsImFkZEV2ZW50TGlzdGVuZXIiLCJ0cmF2ZXJzZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJhYm9ydFJlYXNvbiIsInJlYXNvbiIsImNvbnRleHQyIiwiY2F1c2UiLCJmaW5kRXJyb3JGcm9tVHJhbnNhY3Rpb25QbGFuUmVzdWx0IiwidHJhdmVyc2VTZXF1ZW50aWFsIiwidHJhdmVyc2VQYXJhbGxlbCIsInRyYXZlcnNlU2luZ2xlIiwicmVzdWx0cyIsIlByb21pc2UiLCJhbGwiLCJleGVjdXRlVHJhbnNhY3Rpb25NZXNzYWdlIiwicGFzc3Rocm91Z2hGYWlsZWRUcmFuc2FjdGlvblBsYW5FeGVjdXRpb24iLCJwcm9taXNlIiwiY3JlYXRlVHJhbnNhY3Rpb25QbGFubmVyIiwidHJhdmVyc2UyIiwiY3JlYXRlVHJhbnNhY3Rpb25NZXNzYWdlIiwib25UcmFuc2FjdGlvbk1lc3NhZ2VVcGRhdGVkIiwibXNnIiwicGFyZW50IiwicGFyZW50Q2FuZGlkYXRlcyIsImZyZWV6ZVRyYW5zYWN0aW9uUGxhbiIsInRocm93SWZBYm9ydGVkIiwidHJhdmVyc2VTZXF1ZW50aWFsMiIsInRyYXZlcnNlUGFyYWxsZWwyIiwidHJhdmVyc2VTaW5nbGUyIiwidHJhdmVyc2VNZXNzYWdlUGFja2VyIiwiY2FuZGlkYXRlIiwibXVzdEVudGlyZWx5Rml0SW5QYXJlbnRDYW5kaWRhdGUiLCJjYW5kaWRhdGUyIiwic2VsZWN0QW5kTXV0YXRlQ2FuZGlkYXRlIiwiZml0RW50aXJlUGxhbkluc2lkZU1lc3NhZ2UiLCJ0cmFuc2FjdGlvblBsYW5zIiwiZ2V0U2VxdWVudGlhbENhbmRpZGF0ZSIsIm5ld1BsYW5zIiwiY2FuZGlkYXRlcyIsInNvcnRlZENoaWxkcmVuIiwiZnJvbSIsInNvcnQiLCJhIiwiYiIsIk51bWJlciIsImdldFBhcmFsbGVsQ2FuZGlkYXRlcyIsIm1lc3NhZ2UyIiwiY3JlYXRlTmV3TWVzc2FnZSIsIm1lc3NhZ2VQYWNrZXIiLCJuZXdQbGFuIiwibGF0ZXN0UGxhbiIsInJlc29sdmUiLCJuZXdNZXNzYWdlIiwidXBkYXRlZE1lc3NhZ2UiLCJ1cGRhdGVkTWVzc2FnZVNpemUiLCJuZXdNZXNzYWdlU2l6ZSIsImJhc2VNZXNzYWdlU2l6ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/instruction-plans/dist/index.node.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/instructions/dist/index.node.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@solana/instructions/dist/index.node.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AccountRole: () => (/* binding */ AccountRole),\n/* harmony export */   assertIsInstructionForProgram: () => (/* binding */ assertIsInstructionForProgram),\n/* harmony export */   assertIsInstructionWithAccounts: () => (/* binding */ assertIsInstructionWithAccounts),\n/* harmony export */   assertIsInstructionWithData: () => (/* binding */ assertIsInstructionWithData),\n/* harmony export */   downgradeRoleToNonSigner: () => (/* binding */ downgradeRoleToNonSigner),\n/* harmony export */   downgradeRoleToReadonly: () => (/* binding */ downgradeRoleToReadonly),\n/* harmony export */   isInstructionForProgram: () => (/* binding */ isInstructionForProgram),\n/* harmony export */   isInstructionWithAccounts: () => (/* binding */ isInstructionWithAccounts),\n/* harmony export */   isInstructionWithData: () => (/* binding */ isInstructionWithData),\n/* harmony export */   isSignerRole: () => (/* binding */ isSignerRole),\n/* harmony export */   isWritableRole: () => (/* binding */ isWritableRole),\n/* harmony export */   mergeRoles: () => (/* binding */ mergeRoles),\n/* harmony export */   upgradeRoleToSigner: () => (/* binding */ upgradeRoleToSigner),\n/* harmony export */   upgradeRoleToWritable: () => (/* binding */ upgradeRoleToWritable)\n/* harmony export */ });\n/* harmony import */ var _solana_errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/errors */ \"(ssr)/./node_modules/@solana/errors/dist/index.node.mjs\");\n\n// src/instruction.ts\nfunction isInstructionForProgram(instruction, programAddress) {\n    return instruction.programAddress === programAddress;\n}\nfunction assertIsInstructionForProgram(instruction, programAddress) {\n    if (instruction.programAddress !== programAddress) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH, {\n            actualProgramAddress: instruction.programAddress,\n            expectedProgramAddress: programAddress\n        });\n    }\n}\nfunction isInstructionWithAccounts(instruction) {\n    return instruction.accounts !== void 0;\n}\nfunction assertIsInstructionWithAccounts(instruction) {\n    if (instruction.accounts === void 0) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS, {\n            data: instruction.data,\n            programAddress: instruction.programAddress\n        });\n    }\n}\nfunction isInstructionWithData(instruction) {\n    return instruction.data !== void 0;\n}\nfunction assertIsInstructionWithData(instruction) {\n    if (instruction.data === void 0) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA, {\n            accountAddresses: instruction.accounts?.map((a)=>a.address),\n            programAddress: instruction.programAddress\n        });\n    }\n}\n// src/roles.ts\nvar AccountRole = /* @__PURE__ */ ((AccountRole2)=>{\n    AccountRole2[AccountRole2[\"WRITABLE_SIGNER\"] = /* 3 */ 3] = \"WRITABLE_SIGNER\";\n    AccountRole2[AccountRole2[\"READONLY_SIGNER\"] = /* 2 */ 2] = \"READONLY_SIGNER\";\n    AccountRole2[AccountRole2[\"WRITABLE\"] = /* 1 */ 1] = \"WRITABLE\";\n    AccountRole2[AccountRole2[\"READONLY\"] = /* 0 */ 0] = \"READONLY\";\n    return AccountRole2;\n})(AccountRole || {});\nvar IS_SIGNER_BITMASK = 2;\nvar IS_WRITABLE_BITMASK = 1;\nfunction downgradeRoleToNonSigner(role) {\n    return role & ~IS_SIGNER_BITMASK;\n}\nfunction downgradeRoleToReadonly(role) {\n    return role & ~IS_WRITABLE_BITMASK;\n}\nfunction isSignerRole(role) {\n    return role >= 2 /* READONLY_SIGNER */ ;\n}\nfunction isWritableRole(role) {\n    return (role & IS_WRITABLE_BITMASK) !== 0;\n}\nfunction mergeRoles(roleA, roleB) {\n    return roleA | roleB;\n}\nfunction upgradeRoleToSigner(role) {\n    return role | IS_SIGNER_BITMASK;\n}\nfunction upgradeRoleToWritable(role) {\n    return role | IS_WRITABLE_BITMASK;\n}\n //# sourceMappingURL=index.node.mjs.map\n //# sourceMappingURL=index.node.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS9pbnN0cnVjdGlvbnMvZGlzdC9pbmRleC5ub2RlLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBcU07QUFFck0scUJBQXFCO0FBQ3JCLFNBQVNJLHdCQUF3QkMsV0FBVyxFQUFFQyxjQUFjO0lBQzFELE9BQU9ELFlBQVlDLGNBQWMsS0FBS0E7QUFDeEM7QUFDQSxTQUFTQyw4QkFBOEJGLFdBQVcsRUFBRUMsY0FBYztJQUNoRSxJQUFJRCxZQUFZQyxjQUFjLEtBQUtBLGdCQUFnQjtRQUNqRCxNQUFNLElBQUlOLHVEQUFXQSxDQUFDQywwRkFBOENBLEVBQUU7WUFDcEVPLHNCQUFzQkgsWUFBWUMsY0FBYztZQUNoREcsd0JBQXdCSDtRQUMxQjtJQUNGO0FBQ0Y7QUFDQSxTQUFTSSwwQkFBMEJMLFdBQVc7SUFDNUMsT0FBT0EsWUFBWU0sUUFBUSxLQUFLLEtBQUs7QUFDdkM7QUFDQSxTQUFTQyxnQ0FBZ0NQLFdBQVc7SUFDbEQsSUFBSUEsWUFBWU0sUUFBUSxLQUFLLEtBQUssR0FBRztRQUNuQyxNQUFNLElBQUlYLHVEQUFXQSxDQUFDRSxnR0FBb0RBLEVBQUU7WUFDMUVXLE1BQU1SLFlBQVlRLElBQUk7WUFDdEJQLGdCQUFnQkQsWUFBWUMsY0FBYztRQUM1QztJQUNGO0FBQ0Y7QUFDQSxTQUFTUSxzQkFBc0JULFdBQVc7SUFDeEMsT0FBT0EsWUFBWVEsSUFBSSxLQUFLLEtBQUs7QUFDbkM7QUFDQSxTQUFTRSw0QkFBNEJWLFdBQVc7SUFDOUMsSUFBSUEsWUFBWVEsSUFBSSxLQUFLLEtBQUssR0FBRztRQUMvQixNQUFNLElBQUliLHVEQUFXQSxDQUFDRyw0RkFBZ0RBLEVBQUU7WUFDdEVhLGtCQUFrQlgsWUFBWU0sUUFBUSxFQUFFTSxJQUFJLENBQUNDLElBQU1BLEVBQUVDLE9BQU87WUFDNURiLGdCQUFnQkQsWUFBWUMsY0FBYztRQUM1QztJQUNGO0FBQ0Y7QUFFQSxlQUFlO0FBQ2YsSUFBSWMsY0FBOEIsYUFBSCxHQUFJLEVBQUNDO0lBQ2xDQSxZQUFZLENBQUNBLFlBQVksQ0FBQyxrQkFBa0IsR0FBRyxLQUFLLEdBQ3BELEVBQUUsR0FBRztJQUNMQSxZQUFZLENBQUNBLFlBQVksQ0FBQyxrQkFBa0IsR0FBRyxLQUFLLEdBQ3BELEVBQUUsR0FBRztJQUNMQSxZQUFZLENBQUNBLFlBQVksQ0FBQyxXQUFXLEdBQUcsS0FBSyxHQUM3QyxFQUFFLEdBQUc7SUFDTEEsWUFBWSxDQUFDQSxZQUFZLENBQUMsV0FBVyxHQUFHLEtBQUssR0FDN0MsRUFBRSxHQUFHO0lBQ0wsT0FBT0E7QUFDVCxHQUFHRCxlQUFlLENBQUM7QUFDbkIsSUFBSUUsb0JBQW9CO0FBQ3hCLElBQUlDLHNCQUFzQjtBQUMxQixTQUFTQyx5QkFBeUJDLElBQUk7SUFDcEMsT0FBT0EsT0FBTyxDQUFDSDtBQUNqQjtBQUNBLFNBQVNJLHdCQUF3QkQsSUFBSTtJQUNuQyxPQUFPQSxPQUFPLENBQUNGO0FBQ2pCO0FBQ0EsU0FBU0ksYUFBYUYsSUFBSTtJQUN4QixPQUFPQSxRQUFRLEVBQUUsbUJBQW1CO0FBQ3RDO0FBQ0EsU0FBU0csZUFBZUgsSUFBSTtJQUMxQixPQUFPLENBQUNBLE9BQU9GLG1CQUFrQixNQUFPO0FBQzFDO0FBQ0EsU0FBU00sV0FBV0MsS0FBSyxFQUFFQyxLQUFLO0lBQzlCLE9BQU9ELFFBQVFDO0FBQ2pCO0FBQ0EsU0FBU0Msb0JBQW9CUCxJQUFJO0lBQy9CLE9BQU9BLE9BQU9IO0FBQ2hCO0FBQ0EsU0FBU1csc0JBQXNCUixJQUFJO0lBQ2pDLE9BQU9BLE9BQU9GO0FBQ2hCO0FBRXdVLENBQ3hVLHVDQUF1QztDQUN2Qyx1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGF3LXdvcmtzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvaW5zdHJ1Y3Rpb25zL2Rpc3QvaW5kZXgubm9kZS5tanM/Njk4MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTb2xhbmFFcnJvciwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9fUFJPR1JBTV9JRF9NSVNNQVRDSCwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9fRVhQRUNURURfVE9fSEFWRV9BQ0NPVU5UUywgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9fRVhQRUNURURfVE9fSEFWRV9EQVRBIH0gZnJvbSAnQHNvbGFuYS9lcnJvcnMnO1xuXG4vLyBzcmMvaW5zdHJ1Y3Rpb24udHNcbmZ1bmN0aW9uIGlzSW5zdHJ1Y3Rpb25Gb3JQcm9ncmFtKGluc3RydWN0aW9uLCBwcm9ncmFtQWRkcmVzcykge1xuICByZXR1cm4gaW5zdHJ1Y3Rpb24ucHJvZ3JhbUFkZHJlc3MgPT09IHByb2dyYW1BZGRyZXNzO1xufVxuZnVuY3Rpb24gYXNzZXJ0SXNJbnN0cnVjdGlvbkZvclByb2dyYW0oaW5zdHJ1Y3Rpb24sIHByb2dyYW1BZGRyZXNzKSB7XG4gIGlmIChpbnN0cnVjdGlvbi5wcm9ncmFtQWRkcmVzcyAhPT0gcHJvZ3JhbUFkZHJlc3MpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9fUFJPR1JBTV9JRF9NSVNNQVRDSCwge1xuICAgICAgYWN0dWFsUHJvZ3JhbUFkZHJlc3M6IGluc3RydWN0aW9uLnByb2dyYW1BZGRyZXNzLFxuICAgICAgZXhwZWN0ZWRQcm9ncmFtQWRkcmVzczogcHJvZ3JhbUFkZHJlc3NcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gaXNJbnN0cnVjdGlvbldpdGhBY2NvdW50cyhpbnN0cnVjdGlvbikge1xuICByZXR1cm4gaW5zdHJ1Y3Rpb24uYWNjb3VudHMgIT09IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGFzc2VydElzSW5zdHJ1Y3Rpb25XaXRoQWNjb3VudHMoaW5zdHJ1Y3Rpb24pIHtcbiAgaWYgKGluc3RydWN0aW9uLmFjY291bnRzID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9fRVhQRUNURURfVE9fSEFWRV9BQ0NPVU5UUywge1xuICAgICAgZGF0YTogaW5zdHJ1Y3Rpb24uZGF0YSxcbiAgICAgIHByb2dyYW1BZGRyZXNzOiBpbnN0cnVjdGlvbi5wcm9ncmFtQWRkcmVzc1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBpc0luc3RydWN0aW9uV2l0aERhdGEoaW5zdHJ1Y3Rpb24pIHtcbiAgcmV0dXJuIGluc3RydWN0aW9uLmRhdGEgIT09IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGFzc2VydElzSW5zdHJ1Y3Rpb25XaXRoRGF0YShpbnN0cnVjdGlvbikge1xuICBpZiAoaW5zdHJ1Y3Rpb24uZGF0YSA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fX0VYUEVDVEVEX1RPX0hBVkVfREFUQSwge1xuICAgICAgYWNjb3VudEFkZHJlc3NlczogaW5zdHJ1Y3Rpb24uYWNjb3VudHM/Lm1hcCgoYSkgPT4gYS5hZGRyZXNzKSxcbiAgICAgIHByb2dyYW1BZGRyZXNzOiBpbnN0cnVjdGlvbi5wcm9ncmFtQWRkcmVzc1xuICAgIH0pO1xuICB9XG59XG5cbi8vIHNyYy9yb2xlcy50c1xudmFyIEFjY291bnRSb2xlID0gLyogQF9fUFVSRV9fICovICgoQWNjb3VudFJvbGUyKSA9PiB7XG4gIEFjY291bnRSb2xlMltBY2NvdW50Um9sZTJbXCJXUklUQUJMRV9TSUdORVJcIl0gPSAvKiAzICovXG4gIDNdID0gXCJXUklUQUJMRV9TSUdORVJcIjtcbiAgQWNjb3VudFJvbGUyW0FjY291bnRSb2xlMltcIlJFQURPTkxZX1NJR05FUlwiXSA9IC8qIDIgKi9cbiAgMl0gPSBcIlJFQURPTkxZX1NJR05FUlwiO1xuICBBY2NvdW50Um9sZTJbQWNjb3VudFJvbGUyW1wiV1JJVEFCTEVcIl0gPSAvKiAxICovXG4gIDFdID0gXCJXUklUQUJMRVwiO1xuICBBY2NvdW50Um9sZTJbQWNjb3VudFJvbGUyW1wiUkVBRE9OTFlcIl0gPSAvKiAwICovXG4gIDBdID0gXCJSRUFET05MWVwiO1xuICByZXR1cm4gQWNjb3VudFJvbGUyO1xufSkoQWNjb3VudFJvbGUgfHwge30pO1xudmFyIElTX1NJR05FUl9CSVRNQVNLID0gMjtcbnZhciBJU19XUklUQUJMRV9CSVRNQVNLID0gMTtcbmZ1bmN0aW9uIGRvd25ncmFkZVJvbGVUb05vblNpZ25lcihyb2xlKSB7XG4gIHJldHVybiByb2xlICYgfklTX1NJR05FUl9CSVRNQVNLO1xufVxuZnVuY3Rpb24gZG93bmdyYWRlUm9sZVRvUmVhZG9ubHkocm9sZSkge1xuICByZXR1cm4gcm9sZSAmIH5JU19XUklUQUJMRV9CSVRNQVNLO1xufVxuZnVuY3Rpb24gaXNTaWduZXJSb2xlKHJvbGUpIHtcbiAgcmV0dXJuIHJvbGUgPj0gMiAvKiBSRUFET05MWV9TSUdORVIgKi87XG59XG5mdW5jdGlvbiBpc1dyaXRhYmxlUm9sZShyb2xlKSB7XG4gIHJldHVybiAocm9sZSAmIElTX1dSSVRBQkxFX0JJVE1BU0spICE9PSAwO1xufVxuZnVuY3Rpb24gbWVyZ2VSb2xlcyhyb2xlQSwgcm9sZUIpIHtcbiAgcmV0dXJuIHJvbGVBIHwgcm9sZUI7XG59XG5mdW5jdGlvbiB1cGdyYWRlUm9sZVRvU2lnbmVyKHJvbGUpIHtcbiAgcmV0dXJuIHJvbGUgfCBJU19TSUdORVJfQklUTUFTSztcbn1cbmZ1bmN0aW9uIHVwZ3JhZGVSb2xlVG9Xcml0YWJsZShyb2xlKSB7XG4gIHJldHVybiByb2xlIHwgSVNfV1JJVEFCTEVfQklUTUFTSztcbn1cblxuZXhwb3J0IHsgQWNjb3VudFJvbGUsIGFzc2VydElzSW5zdHJ1Y3Rpb25Gb3JQcm9ncmFtLCBhc3NlcnRJc0luc3RydWN0aW9uV2l0aEFjY291bnRzLCBhc3NlcnRJc0luc3RydWN0aW9uV2l0aERhdGEsIGRvd25ncmFkZVJvbGVUb05vblNpZ25lciwgZG93bmdyYWRlUm9sZVRvUmVhZG9ubHksIGlzSW5zdHJ1Y3Rpb25Gb3JQcm9ncmFtLCBpc0luc3RydWN0aW9uV2l0aEFjY291bnRzLCBpc0luc3RydWN0aW9uV2l0aERhdGEsIGlzU2lnbmVyUm9sZSwgaXNXcml0YWJsZVJvbGUsIG1lcmdlUm9sZXMsIHVwZ3JhZGVSb2xlVG9TaWduZXIsIHVwZ3JhZGVSb2xlVG9Xcml0YWJsZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubm9kZS5tanMubWFwXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5ub2RlLm1qcy5tYXAiXSwibmFtZXMiOlsiU29sYW5hRXJyb3IiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX19QUk9HUkFNX0lEX01JU01BVENIIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9fRVhQRUNURURfVE9fSEFWRV9BQ0NPVU5UUyIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fX0VYUEVDVEVEX1RPX0hBVkVfREFUQSIsImlzSW5zdHJ1Y3Rpb25Gb3JQcm9ncmFtIiwiaW5zdHJ1Y3Rpb24iLCJwcm9ncmFtQWRkcmVzcyIsImFzc2VydElzSW5zdHJ1Y3Rpb25Gb3JQcm9ncmFtIiwiYWN0dWFsUHJvZ3JhbUFkZHJlc3MiLCJleHBlY3RlZFByb2dyYW1BZGRyZXNzIiwiaXNJbnN0cnVjdGlvbldpdGhBY2NvdW50cyIsImFjY291bnRzIiwiYXNzZXJ0SXNJbnN0cnVjdGlvbldpdGhBY2NvdW50cyIsImRhdGEiLCJpc0luc3RydWN0aW9uV2l0aERhdGEiLCJhc3NlcnRJc0luc3RydWN0aW9uV2l0aERhdGEiLCJhY2NvdW50QWRkcmVzc2VzIiwibWFwIiwiYSIsImFkZHJlc3MiLCJBY2NvdW50Um9sZSIsIkFjY291bnRSb2xlMiIsIklTX1NJR05FUl9CSVRNQVNLIiwiSVNfV1JJVEFCTEVfQklUTUFTSyIsImRvd25ncmFkZVJvbGVUb05vblNpZ25lciIsInJvbGUiLCJkb3duZ3JhZGVSb2xlVG9SZWFkb25seSIsImlzU2lnbmVyUm9sZSIsImlzV3JpdGFibGVSb2xlIiwibWVyZ2VSb2xlcyIsInJvbGVBIiwicm9sZUIiLCJ1cGdyYWRlUm9sZVRvU2lnbmVyIiwidXBncmFkZVJvbGVUb1dyaXRhYmxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/instructions/dist/index.node.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/keys/dist/index.node.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@solana/keys/dist/index.node.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertIsSignature: () => (/* binding */ assertIsSignature),\n/* harmony export */   assertIsSignatureBytes: () => (/* binding */ assertIsSignatureBytes),\n/* harmony export */   createKeyPairFromBytes: () => (/* binding */ createKeyPairFromBytes),\n/* harmony export */   createKeyPairFromPrivateKeyBytes: () => (/* binding */ createKeyPairFromPrivateKeyBytes),\n/* harmony export */   createPrivateKeyFromBytes: () => (/* binding */ createPrivateKeyFromBytes),\n/* harmony export */   generateKeyPair: () => (/* binding */ generateKeyPair),\n/* harmony export */   getPublicKeyFromPrivateKey: () => (/* binding */ getPublicKeyFromPrivateKey),\n/* harmony export */   isSignature: () => (/* binding */ isSignature),\n/* harmony export */   isSignatureBytes: () => (/* binding */ isSignatureBytes),\n/* harmony export */   signBytes: () => (/* binding */ signBytes),\n/* harmony export */   signature: () => (/* binding */ signature),\n/* harmony export */   signatureBytes: () => (/* binding */ signatureBytes),\n/* harmony export */   verifySignature: () => (/* binding */ verifySignature)\n/* harmony export */ });\n/* harmony import */ var _solana_assertions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana/assertions */ \"(ssr)/./node_modules/@solana/assertions/dist/index.node.mjs\");\n/* harmony import */ var _solana_errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/errors */ \"(ssr)/./node_modules/@solana/errors/dist/index.node.mjs\");\n/* harmony import */ var _solana_codecs_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @solana/codecs-core */ \"(ssr)/./node_modules/@solana/codecs-core/dist/index.node.mjs\");\n/* harmony import */ var _solana_codecs_strings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @solana/codecs-strings */ \"(ssr)/./node_modules/@solana/codecs-strings/dist/index.node.mjs\");\n\n\n\n\n// src/key-pair.ts\n// src/algorithm.ts\nvar ED25519_ALGORITHM_IDENTIFIER = // Resist the temptation to convert this to a simple string; As of version 133.0.3, Firefox\n// requires the object form of `AlgorithmIdentifier` and will throw a `DOMException` otherwise.\nObject.freeze({\n    name: \"Ed25519\"\n});\nfunction addPkcs8Header(bytes) {\n    return new Uint8Array([\n        /**\n     * PKCS#8 header\n     */ 48,\n        // ASN.1 sequence tag\n        46,\n        // Length of sequence (46 more bytes)\n        2,\n        // ASN.1 integer tag\n        1,\n        // Length of integer\n        0,\n        // Version number\n        48,\n        // ASN.1 sequence tag\n        5,\n        // Length of sequence\n        6,\n        // ASN.1 object identifier tag\n        3,\n        // Length of object identifier\n        // Edwards curve algorithms identifier https://oid-rep.orange-labs.fr/get/1.3.101.112\n        43,\n        // iso(1) / identified-organization(3) (The first node is multiplied by the decimal 40 and the result is added to the value of the second node)\n        101,\n        // thawte(101)\n        // Ed25519 identifier\n        112,\n        // id-Ed25519(112)\n        /**\n     * Private key payload\n     */ 4,\n        // ASN.1 octet string tag\n        34,\n        // String length (34 more bytes)\n        // Private key bytes as octet string\n        4,\n        // ASN.1 octet string tag\n        32,\n        // String length (32 bytes)\n        ...bytes\n    ]);\n}\nasync function createPrivateKeyFromBytes(bytes, extractable = false) {\n    const actualLength = bytes.byteLength;\n    if (actualLength !== 32) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH, {\n            actualLength\n        });\n    }\n    const privateKeyBytesPkcs8 = addPkcs8Header(bytes);\n    return await crypto.subtle.importKey(\"pkcs8\", privateKeyBytesPkcs8, ED25519_ALGORITHM_IDENTIFIER, extractable, [\n        \"sign\"\n    ]);\n}\nasync function getPublicKeyFromPrivateKey(privateKey, extractable = false) {\n    (0,_solana_assertions__WEBPACK_IMPORTED_MODULE_1__.assertKeyExporterIsAvailable)();\n    if (privateKey.extractable === false) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY, {\n            key: privateKey\n        });\n    }\n    const jwk = await crypto.subtle.exportKey(\"jwk\", privateKey);\n    return await crypto.subtle.importKey(\"jwk\", {\n        crv: \"Ed25519\",\n        ext: extractable,\n        key_ops: [\n            \"verify\"\n        ],\n        kty: \"OKP\",\n        x: jwk.x\n    }, \"Ed25519\", extractable, [\n        \"verify\"\n    ]);\n}\nvar base58Encoder;\nfunction assertIsSignature(putativeSignature) {\n    if (!base58Encoder) base58Encoder = (0,_solana_codecs_strings__WEBPACK_IMPORTED_MODULE_2__.getBase58Encoder)();\n    if (// Lowest value (64 bytes of zeroes)\n    putativeSignature.length < 64 || // Highest value (64 bytes of 255)\n    putativeSignature.length > 88) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE, {\n            actualLength: putativeSignature.length\n        });\n    }\n    const bytes = base58Encoder.encode(putativeSignature);\n    assertIsSignatureBytes(bytes);\n}\nfunction assertIsSignatureBytes(putativeSignatureBytes) {\n    const numBytes = putativeSignatureBytes.byteLength;\n    if (numBytes !== 64) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH, {\n            actualLength: numBytes\n        });\n    }\n}\nfunction isSignature(putativeSignature) {\n    if (!base58Encoder) base58Encoder = (0,_solana_codecs_strings__WEBPACK_IMPORTED_MODULE_2__.getBase58Encoder)();\n    if (// Lowest value (64 bytes of zeroes)\n    putativeSignature.length < 64 || // Highest value (64 bytes of 255)\n    putativeSignature.length > 88) {\n        return false;\n    }\n    const bytes = base58Encoder.encode(putativeSignature);\n    return isSignatureBytes(bytes);\n}\nfunction isSignatureBytes(putativeSignatureBytes) {\n    return putativeSignatureBytes.byteLength === 64;\n}\nasync function signBytes(key, data) {\n    (0,_solana_assertions__WEBPACK_IMPORTED_MODULE_1__.assertSigningCapabilityIsAvailable)();\n    const signedData = await crypto.subtle.sign(ED25519_ALGORITHM_IDENTIFIER, key, (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_3__.toArrayBuffer)(data));\n    return new Uint8Array(signedData);\n}\nfunction signature(putativeSignature) {\n    assertIsSignature(putativeSignature);\n    return putativeSignature;\n}\nfunction signatureBytes(putativeSignatureBytes) {\n    assertIsSignatureBytes(putativeSignatureBytes);\n    return putativeSignatureBytes;\n}\nasync function verifySignature(key, signature2, data) {\n    (0,_solana_assertions__WEBPACK_IMPORTED_MODULE_1__.assertVerificationCapabilityIsAvailable)();\n    return await crypto.subtle.verify(ED25519_ALGORITHM_IDENTIFIER, key, (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_3__.toArrayBuffer)(signature2), (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_3__.toArrayBuffer)(data));\n}\n// src/key-pair.ts\nasync function generateKeyPair() {\n    await (0,_solana_assertions__WEBPACK_IMPORTED_MODULE_1__.assertKeyGenerationIsAvailable)();\n    const keyPair = await crypto.subtle.generateKey(/* algorithm */ ED25519_ALGORITHM_IDENTIFIER, // Native implementation status: https://github.com/WICG/webcrypto-secure-curves/issues/20\n    /* extractable */ false, // Prevents the bytes of the private key from being visible to JS.\n    /* allowed uses */ [\n        \"sign\",\n        \"verify\"\n    ]);\n    return keyPair;\n}\nasync function createKeyPairFromBytes(bytes, extractable = false) {\n    (0,_solana_assertions__WEBPACK_IMPORTED_MODULE_1__.assertPRNGIsAvailable)();\n    if (bytes.byteLength !== 64) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH, {\n            byteLength: bytes.byteLength\n        });\n    }\n    const [publicKey, privateKey] = await Promise.all([\n        crypto.subtle.importKey(\"raw\", bytes.slice(32), ED25519_ALGORITHM_IDENTIFIER, /* extractable */ true, [\n            \"verify\"\n        ]),\n        createPrivateKeyFromBytes(bytes.slice(0, 32), extractable)\n    ]);\n    const randomBytes = new Uint8Array(32);\n    crypto.getRandomValues(randomBytes);\n    const signedData = await signBytes(privateKey, randomBytes);\n    const isValid = await verifySignature(publicKey, signedData, randomBytes);\n    if (!isValid) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY);\n    }\n    return {\n        privateKey,\n        publicKey\n    };\n}\nasync function createKeyPairFromPrivateKeyBytes(bytes, extractable = false) {\n    const privateKeyPromise = createPrivateKeyFromBytes(bytes, extractable);\n    const [publicKey, privateKey] = await Promise.all([\n        // This nested promise makes things efficient by\n        // creating the public key in parallel with the\n        // second private key creation, if it is needed.\n        (extractable ? privateKeyPromise : createPrivateKeyFromBytes(bytes, true)).then(async (privateKey2)=>await getPublicKeyFromPrivateKey(privateKey2, true)),\n        privateKeyPromise\n    ]);\n    return {\n        privateKey,\n        publicKey\n    };\n}\n //# sourceMappingURL=index.node.mjs.map\n //# sourceMappingURL=index.node.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS9rZXlzL2Rpc3QvaW5kZXgubm9kZS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBc007QUFDa0w7QUFDcFU7QUFDTTtBQUUxRCxrQkFBa0I7QUFFbEIsbUJBQW1CO0FBQ25CLElBQUljLCtCQUNGLDJGQUEyRjtBQUMzRiwrRkFBK0Y7QUFDL0ZDLE9BQU9DLE1BQU0sQ0FBQztJQUFFQyxNQUFNO0FBQVU7QUFFbEMsU0FBU0MsZUFBZUMsS0FBSztJQUMzQixPQUFPLElBQUlDLFdBQVc7UUFDcEI7O0tBRUMsR0FDRDtRQUNBLHFCQUFxQjtRQUNyQjtRQUNBLHFDQUFxQztRQUNyQztRQUNBLG9CQUFvQjtRQUNwQjtRQUNBLG9CQUFvQjtRQUNwQjtRQUNBLGlCQUFpQjtRQUNqQjtRQUNBLHFCQUFxQjtRQUNyQjtRQUNBLHFCQUFxQjtRQUNyQjtRQUNBLDhCQUE4QjtRQUM5QjtRQUNBLDhCQUE4QjtRQUM5QixxRkFBcUY7UUFDckY7UUFDQSwrSUFBK0k7UUFDL0k7UUFDQSxjQUFjO1FBQ2QscUJBQXFCO1FBQ3JCO1FBQ0Esa0JBQWtCO1FBQ2xCOztLQUVDLEdBQ0Q7UUFDQSx5QkFBeUI7UUFDekI7UUFDQSxnQ0FBZ0M7UUFDaEMsb0NBQW9DO1FBQ3BDO1FBQ0EseUJBQXlCO1FBQ3pCO1FBQ0EsMkJBQTJCO1dBQ3hCRDtLQUNKO0FBQ0g7QUFDQSxlQUFlRSwwQkFBMEJGLEtBQUssRUFBRUcsY0FBYyxLQUFLO0lBQ2pFLE1BQU1DLGVBQWVKLE1BQU1LLFVBQVU7SUFDckMsSUFBSUQsaUJBQWlCLElBQUk7UUFDdkIsTUFBTSxJQUFJbEIsdURBQVdBLENBQUNDLCtGQUFtREEsRUFBRTtZQUN6RWlCO1FBQ0Y7SUFDRjtJQUNBLE1BQU1FLHVCQUF1QlAsZUFBZUM7SUFDNUMsT0FBTyxNQUFNTyxPQUFPQyxNQUFNLENBQUNDLFNBQVMsQ0FBQyxTQUFTSCxzQkFBc0JYLDhCQUE4QlEsYUFBYTtRQUM3RztL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QUFZZ0M7SUFBVTtBQUNqQztBQUU2USxDQUM3USx1Q0FBdUM7Q0FDdkMsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xhdy13b3Jrcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL2tleXMvZGlzdC9pbmRleC5ub2RlLm1qcz81M2ZmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFzc2VydEtleUV4cG9ydGVySXNBdmFpbGFibGUsIGFzc2VydFNpZ25pbmdDYXBhYmlsaXR5SXNBdmFpbGFibGUsIGFzc2VydFZlcmlmaWNhdGlvbkNhcGFiaWxpdHlJc0F2YWlsYWJsZSwgYXNzZXJ0S2V5R2VuZXJhdGlvbklzQXZhaWxhYmxlLCBhc3NlcnRQUk5HSXNBdmFpbGFibGUgfSBmcm9tICdAc29sYW5hL2Fzc2VydGlvbnMnO1xuaW1wb3J0IHsgU29sYW5hRXJyb3IsIFNPTEFOQV9FUlJPUl9fS0VZU19fSU5WQUxJRF9QUklWQVRFX0tFWV9CWVRFX0xFTkdUSCwgU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19DQU5OT1RfRVhQT1JUX05PTl9FWFRSQUNUQUJMRV9LRVksIFNPTEFOQV9FUlJPUl9fS0VZU19fU0lHTkFUVVJFX1NUUklOR19MRU5HVEhfT1VUX09GX1JBTkdFLCBTT0xBTkFfRVJST1JfX0tFWVNfX0lOVkFMSURfU0lHTkFUVVJFX0JZVEVfTEVOR1RILCBTT0xBTkFfRVJST1JfX0tFWVNfX0lOVkFMSURfS0VZX1BBSVJfQllURV9MRU5HVEgsIFNPTEFOQV9FUlJPUl9fS0VZU19fUFVCTElDX0tFWV9NVVNUX01BVENIX1BSSVZBVEVfS0VZIH0gZnJvbSAnQHNvbGFuYS9lcnJvcnMnO1xuaW1wb3J0IHsgdG9BcnJheUJ1ZmZlciB9IGZyb20gJ0Bzb2xhbmEvY29kZWNzLWNvcmUnO1xuaW1wb3J0IHsgZ2V0QmFzZTU4RW5jb2RlciB9IGZyb20gJ0Bzb2xhbmEvY29kZWNzLXN0cmluZ3MnO1xuXG4vLyBzcmMva2V5LXBhaXIudHNcblxuLy8gc3JjL2FsZ29yaXRobS50c1xudmFyIEVEMjU1MTlfQUxHT1JJVEhNX0lERU5USUZJRVIgPSAoXG4gIC8vIFJlc2lzdCB0aGUgdGVtcHRhdGlvbiB0byBjb252ZXJ0IHRoaXMgdG8gYSBzaW1wbGUgc3RyaW5nOyBBcyBvZiB2ZXJzaW9uIDEzMy4wLjMsIEZpcmVmb3hcbiAgLy8gcmVxdWlyZXMgdGhlIG9iamVjdCBmb3JtIG9mIGBBbGdvcml0aG1JZGVudGlmaWVyYCBhbmQgd2lsbCB0aHJvdyBhIGBET01FeGNlcHRpb25gIG90aGVyd2lzZS5cbiAgT2JqZWN0LmZyZWV6ZSh7IG5hbWU6IFwiRWQyNTUxOVwiIH0pXG4pO1xuZnVuY3Rpb24gYWRkUGtjczhIZWFkZXIoYnl0ZXMpIHtcbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFtcbiAgICAvKipcbiAgICAgKiBQS0NTIzggaGVhZGVyXG4gICAgICovXG4gICAgNDgsXG4gICAgLy8gQVNOLjEgc2VxdWVuY2UgdGFnXG4gICAgNDYsXG4gICAgLy8gTGVuZ3RoIG9mIHNlcXVlbmNlICg0NiBtb3JlIGJ5dGVzKVxuICAgIDIsXG4gICAgLy8gQVNOLjEgaW50ZWdlciB0YWdcbiAgICAxLFxuICAgIC8vIExlbmd0aCBvZiBpbnRlZ2VyXG4gICAgMCxcbiAgICAvLyBWZXJzaW9uIG51bWJlclxuICAgIDQ4LFxuICAgIC8vIEFTTi4xIHNlcXVlbmNlIHRhZ1xuICAgIDUsXG4gICAgLy8gTGVuZ3RoIG9mIHNlcXVlbmNlXG4gICAgNixcbiAgICAvLyBBU04uMSBvYmplY3QgaWRlbnRpZmllciB0YWdcbiAgICAzLFxuICAgIC8vIExlbmd0aCBvZiBvYmplY3QgaWRlbnRpZmllclxuICAgIC8vIEVkd2FyZHMgY3VydmUgYWxnb3JpdGhtcyBpZGVudGlmaWVyIGh0dHBzOi8vb2lkLXJlcC5vcmFuZ2UtbGFicy5mci9nZXQvMS4zLjEwMS4xMTJcbiAgICA0MyxcbiAgICAvLyBpc28oMSkgLyBpZGVudGlmaWVkLW9yZ2FuaXphdGlvbigzKSAoVGhlIGZpcnN0IG5vZGUgaXMgbXVsdGlwbGllZCBieSB0aGUgZGVjaW1hbCA0MCBhbmQgdGhlIHJlc3VsdCBpcyBhZGRlZCB0byB0aGUgdmFsdWUgb2YgdGhlIHNlY29uZCBub2RlKVxuICAgIDEwMSxcbiAgICAvLyB0aGF3dGUoMTAxKVxuICAgIC8vIEVkMjU1MTkgaWRlbnRpZmllclxuICAgIDExMixcbiAgICAvLyBpZC1FZDI1NTE5KDExMilcbiAgICAvKipcbiAgICAgKiBQcml2YXRlIGtleSBwYXlsb2FkXG4gICAgICovXG4gICAgNCxcbiAgICAvLyBBU04uMSBvY3RldCBzdHJpbmcgdGFnXG4gICAgMzQsXG4gICAgLy8gU3RyaW5nIGxlbmd0aCAoMzQgbW9yZSBieXRlcylcbiAgICAvLyBQcml2YXRlIGtleSBieXRlcyBhcyBvY3RldCBzdHJpbmdcbiAgICA0LFxuICAgIC8vIEFTTi4xIG9jdGV0IHN0cmluZyB0YWdcbiAgICAzMixcbiAgICAvLyBTdHJpbmcgbGVuZ3RoICgzMiBieXRlcylcbiAgICAuLi5ieXRlc1xuICBdKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVByaXZhdGVLZXlGcm9tQnl0ZXMoYnl0ZXMsIGV4dHJhY3RhYmxlID0gZmFsc2UpIHtcbiAgY29uc3QgYWN0dWFsTGVuZ3RoID0gYnl0ZXMuYnl0ZUxlbmd0aDtcbiAgaWYgKGFjdHVhbExlbmd0aCAhPT0gMzIpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19LRVlTX19JTlZBTElEX1BSSVZBVEVfS0VZX0JZVEVfTEVOR1RILCB7XG4gICAgICBhY3R1YWxMZW5ndGhcbiAgICB9KTtcbiAgfVxuICBjb25zdCBwcml2YXRlS2V5Qnl0ZXNQa2NzOCA9IGFkZFBrY3M4SGVhZGVyKGJ5dGVzKTtcbiAgcmV0dXJuIGF3YWl0IGNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KFwicGtjczhcIiwgcHJpdmF0ZUtleUJ5dGVzUGtjczgsIEVEMjU1MTlfQUxHT1JJVEhNX0lERU5USUZJRVIsIGV4dHJhY3RhYmxlLCBbXG4gICAgXCJzaWduXCJcbiAgXSk7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRQdWJsaWNLZXlGcm9tUHJpdmF0ZUtleShwcml2YXRlS2V5LCBleHRyYWN0YWJsZSA9IGZhbHNlKSB7XG4gIGFzc2VydEtleUV4cG9ydGVySXNBdmFpbGFibGUoKTtcbiAgaWYgKHByaXZhdGVLZXkuZXh0cmFjdGFibGUgPT09IGZhbHNlKSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fQ0FOTk9UX0VYUE9SVF9OT05fRVhUUkFDVEFCTEVfS0VZLCB7IGtleTogcHJpdmF0ZUtleSB9KTtcbiAgfVxuICBjb25zdCBqd2sgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmV4cG9ydEtleShcImp3a1wiLCBwcml2YXRlS2V5KTtcbiAgcmV0dXJuIGF3YWl0IGNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KFxuICAgIFwiandrXCIsXG4gICAge1xuICAgICAgY3J2OiBcIkVkMjU1MTlcIixcbiAgICAgIGV4dDogZXh0cmFjdGFibGUsXG4gICAgICBrZXlfb3BzOiBbXCJ2ZXJpZnlcIl0sXG4gICAgICBrdHk6IFwiT0tQXCIsXG4gICAgICB4OiBqd2sueFxuICAgIH0sXG4gICAgXCJFZDI1NTE5XCIsXG4gICAgZXh0cmFjdGFibGUsXG4gICAgW1widmVyaWZ5XCJdXG4gICk7XG59XG52YXIgYmFzZTU4RW5jb2RlcjtcbmZ1bmN0aW9uIGFzc2VydElzU2lnbmF0dXJlKHB1dGF0aXZlU2lnbmF0dXJlKSB7XG4gIGlmICghYmFzZTU4RW5jb2RlcikgYmFzZTU4RW5jb2RlciA9IGdldEJhc2U1OEVuY29kZXIoKTtcbiAgaWYgKFxuICAgIC8vIExvd2VzdCB2YWx1ZSAoNjQgYnl0ZXMgb2YgemVyb2VzKVxuICAgIHB1dGF0aXZlU2lnbmF0dXJlLmxlbmd0aCA8IDY0IHx8IC8vIEhpZ2hlc3QgdmFsdWUgKDY0IGJ5dGVzIG9mIDI1NSlcbiAgICBwdXRhdGl2ZVNpZ25hdHVyZS5sZW5ndGggPiA4OFxuICApIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19LRVlTX19TSUdOQVRVUkVfU1RSSU5HX0xFTkdUSF9PVVRfT0ZfUkFOR0UsIHtcbiAgICAgIGFjdHVhbExlbmd0aDogcHV0YXRpdmVTaWduYXR1cmUubGVuZ3RoXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgYnl0ZXMgPSBiYXNlNThFbmNvZGVyLmVuY29kZShwdXRhdGl2ZVNpZ25hdHVyZSk7XG4gIGFzc2VydElzU2lnbmF0dXJlQnl0ZXMoYnl0ZXMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0SXNTaWduYXR1cmVCeXRlcyhwdXRhdGl2ZVNpZ25hdHVyZUJ5dGVzKSB7XG4gIGNvbnN0IG51bUJ5dGVzID0gcHV0YXRpdmVTaWduYXR1cmVCeXRlcy5ieXRlTGVuZ3RoO1xuICBpZiAobnVtQnl0ZXMgIT09IDY0KSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fS0VZU19fSU5WQUxJRF9TSUdOQVRVUkVfQllURV9MRU5HVEgsIHtcbiAgICAgIGFjdHVhbExlbmd0aDogbnVtQnl0ZXNcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gaXNTaWduYXR1cmUocHV0YXRpdmVTaWduYXR1cmUpIHtcbiAgaWYgKCFiYXNlNThFbmNvZGVyKSBiYXNlNThFbmNvZGVyID0gZ2V0QmFzZTU4RW5jb2RlcigpO1xuICBpZiAoXG4gICAgLy8gTG93ZXN0IHZhbHVlICg2NCBieXRlcyBvZiB6ZXJvZXMpXG4gICAgcHV0YXRpdmVTaWduYXR1cmUubGVuZ3RoIDwgNjQgfHwgLy8gSGlnaGVzdCB2YWx1ZSAoNjQgYnl0ZXMgb2YgMjU1KVxuICAgIHB1dGF0aXZlU2lnbmF0dXJlLmxlbmd0aCA+IDg4XG4gICkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBieXRlcyA9IGJhc2U1OEVuY29kZXIuZW5jb2RlKHB1dGF0aXZlU2lnbmF0dXJlKTtcbiAgcmV0dXJuIGlzU2lnbmF0dXJlQnl0ZXMoYnl0ZXMpO1xufVxuZnVuY3Rpb24gaXNTaWduYXR1cmVCeXRlcyhwdXRhdGl2ZVNpZ25hdHVyZUJ5dGVzKSB7XG4gIHJldHVybiBwdXRhdGl2ZVNpZ25hdHVyZUJ5dGVzLmJ5dGVMZW5ndGggPT09IDY0O1xufVxuYXN5bmMgZnVuY3Rpb24gc2lnbkJ5dGVzKGtleSwgZGF0YSkge1xuICBhc3NlcnRTaWduaW5nQ2FwYWJpbGl0eUlzQXZhaWxhYmxlKCk7XG4gIGNvbnN0IHNpZ25lZERhdGEgPSBhd2FpdCBjcnlwdG8uc3VidGxlLnNpZ24oRUQyNTUxOV9BTEdPUklUSE1fSURFTlRJRklFUiwga2V5LCB0b0FycmF5QnVmZmVyKGRhdGEpKTtcbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHNpZ25lZERhdGEpO1xufVxuZnVuY3Rpb24gc2lnbmF0dXJlKHB1dGF0aXZlU2lnbmF0dXJlKSB7XG4gIGFzc2VydElzU2lnbmF0dXJlKHB1dGF0aXZlU2lnbmF0dXJlKTtcbiAgcmV0dXJuIHB1dGF0aXZlU2lnbmF0dXJlO1xufVxuZnVuY3Rpb24gc2lnbmF0dXJlQnl0ZXMocHV0YXRpdmVTaWduYXR1cmVCeXRlcykge1xuICBhc3NlcnRJc1NpZ25hdHVyZUJ5dGVzKHB1dGF0aXZlU2lnbmF0dXJlQnl0ZXMpO1xuICByZXR1cm4gcHV0YXRpdmVTaWduYXR1cmVCeXRlcztcbn1cbmFzeW5jIGZ1bmN0aW9uIHZlcmlmeVNpZ25hdHVyZShrZXksIHNpZ25hdHVyZTIsIGRhdGEpIHtcbiAgYXNzZXJ0VmVyaWZpY2F0aW9uQ2FwYWJpbGl0eUlzQXZhaWxhYmxlKCk7XG4gIHJldHVybiBhd2FpdCBjcnlwdG8uc3VidGxlLnZlcmlmeShFRDI1NTE5X0FMR09SSVRITV9JREVOVElGSUVSLCBrZXksIHRvQXJyYXlCdWZmZXIoc2lnbmF0dXJlMiksIHRvQXJyYXlCdWZmZXIoZGF0YSkpO1xufVxuXG4vLyBzcmMva2V5LXBhaXIudHNcbmFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlS2V5UGFpcigpIHtcbiAgYXdhaXQgYXNzZXJ0S2V5R2VuZXJhdGlvbklzQXZhaWxhYmxlKCk7XG4gIGNvbnN0IGtleVBhaXIgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmdlbmVyYXRlS2V5KFxuICAgIC8qIGFsZ29yaXRobSAqL1xuICAgIEVEMjU1MTlfQUxHT1JJVEhNX0lERU5USUZJRVIsXG4gICAgLy8gTmF0aXZlIGltcGxlbWVudGF0aW9uIHN0YXR1czogaHR0cHM6Ly9naXRodWIuY29tL1dJQ0cvd2ViY3J5cHRvLXNlY3VyZS1jdXJ2ZXMvaXNzdWVzLzIwXG4gICAgLyogZXh0cmFjdGFibGUgKi9cbiAgICBmYWxzZSxcbiAgICAvLyBQcmV2ZW50cyB0aGUgYnl0ZXMgb2YgdGhlIHByaXZhdGUga2V5IGZyb20gYmVpbmcgdmlzaWJsZSB0byBKUy5cbiAgICAvKiBhbGxvd2VkIHVzZXMgKi9cbiAgICBbXCJzaWduXCIsIFwidmVyaWZ5XCJdXG4gICk7XG4gIHJldHVybiBrZXlQYWlyO1xufVxuYXN5bmMgZnVuY3Rpb24gY3JlYXRlS2V5UGFpckZyb21CeXRlcyhieXRlcywgZXh0cmFjdGFibGUgPSBmYWxzZSkge1xuICBhc3NlcnRQUk5HSXNBdmFpbGFibGUoKTtcbiAgaWYgKGJ5dGVzLmJ5dGVMZW5ndGggIT09IDY0KSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fS0VZU19fSU5WQUxJRF9LRVlfUEFJUl9CWVRFX0xFTkdUSCwgeyBieXRlTGVuZ3RoOiBieXRlcy5ieXRlTGVuZ3RoIH0pO1xuICB9XG4gIGNvbnN0IFtwdWJsaWNLZXksIHByaXZhdGVLZXldID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgIGNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KFxuICAgICAgXCJyYXdcIixcbiAgICAgIGJ5dGVzLnNsaWNlKDMyKSxcbiAgICAgIEVEMjU1MTlfQUxHT1JJVEhNX0lERU5USUZJRVIsXG4gICAgICAvKiBleHRyYWN0YWJsZSAqL1xuICAgICAgdHJ1ZSxcbiAgICAgIFtcbiAgICAgICAgXCJ2ZXJpZnlcIlxuICAgICAgXVxuICAgICksXG4gICAgY3JlYXRlUHJpdmF0ZUtleUZyb21CeXRlcyhieXRlcy5zbGljZSgwLCAzMiksIGV4dHJhY3RhYmxlKVxuICBdKTtcbiAgY29uc3QgcmFuZG9tQnl0ZXMgPSBuZXcgVWludDhBcnJheSgzMik7XG4gIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMocmFuZG9tQnl0ZXMpO1xuICBjb25zdCBzaWduZWREYXRhID0gYXdhaXQgc2lnbkJ5dGVzKHByaXZhdGVLZXksIHJhbmRvbUJ5dGVzKTtcbiAgY29uc3QgaXNWYWxpZCA9IGF3YWl0IHZlcmlmeVNpZ25hdHVyZShwdWJsaWNLZXksIHNpZ25lZERhdGEsIHJhbmRvbUJ5dGVzKTtcbiAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fS0VZU19fUFVCTElDX0tFWV9NVVNUX01BVENIX1BSSVZBVEVfS0VZKTtcbiAgfVxuICByZXR1cm4geyBwcml2YXRlS2V5LCBwdWJsaWNLZXkgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUtleVBhaXJGcm9tUHJpdmF0ZUtleUJ5dGVzKGJ5dGVzLCBleHRyYWN0YWJsZSA9IGZhbHNlKSB7XG4gIGNvbnN0IHByaXZhdGVLZXlQcm9taXNlID0gY3JlYXRlUHJpdmF0ZUtleUZyb21CeXRlcyhieXRlcywgZXh0cmFjdGFibGUpO1xuICBjb25zdCBbcHVibGljS2V5LCBwcml2YXRlS2V5XSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAvLyBUaGlzIG5lc3RlZCBwcm9taXNlIG1ha2VzIHRoaW5ncyBlZmZpY2llbnQgYnlcbiAgICAvLyBjcmVhdGluZyB0aGUgcHVibGljIGtleSBpbiBwYXJhbGxlbCB3aXRoIHRoZVxuICAgIC8vIHNlY29uZCBwcml2YXRlIGtleSBjcmVhdGlvbiwgaWYgaXQgaXMgbmVlZGVkLlxuICAgIChleHRyYWN0YWJsZSA/IHByaXZhdGVLZXlQcm9taXNlIDogY3JlYXRlUHJpdmF0ZUtleUZyb21CeXRlcyhcbiAgICAgIGJ5dGVzLFxuICAgICAgdHJ1ZVxuICAgICAgLyogZXh0cmFjdGFibGUgKi9cbiAgICApKS50aGVuKFxuICAgICAgYXN5bmMgKHByaXZhdGVLZXkyKSA9PiBhd2FpdCBnZXRQdWJsaWNLZXlGcm9tUHJpdmF0ZUtleShcbiAgICAgICAgcHJpdmF0ZUtleTIsXG4gICAgICAgIHRydWVcbiAgICAgICAgLyogZXh0cmFjdGFibGUgKi9cbiAgICAgIClcbiAgICApLFxuICAgIHByaXZhdGVLZXlQcm9taXNlXG4gIF0pO1xuICByZXR1cm4geyBwcml2YXRlS2V5LCBwdWJsaWNLZXkgfTtcbn1cblxuZXhwb3J0IHsgYXNzZXJ0SXNTaWduYXR1cmUsIGFzc2VydElzU2lnbmF0dXJlQnl0ZXMsIGNyZWF0ZUtleVBhaXJGcm9tQnl0ZXMsIGNyZWF0ZUtleVBhaXJGcm9tUHJpdmF0ZUtleUJ5dGVzLCBjcmVhdGVQcml2YXRlS2V5RnJvbUJ5dGVzLCBnZW5lcmF0ZUtleVBhaXIsIGdldFB1YmxpY0tleUZyb21Qcml2YXRlS2V5LCBpc1NpZ25hdHVyZSwgaXNTaWduYXR1cmVCeXRlcywgc2lnbkJ5dGVzLCBzaWduYXR1cmUsIHNpZ25hdHVyZUJ5dGVzLCB2ZXJpZnlTaWduYXR1cmUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm5vZGUubWpzLm1hcFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubm9kZS5tanMubWFwIl0sIm5hbWVzIjpbImFzc2VydEtleUV4cG9ydGVySXNBdmFpbGFibGUiLCJhc3NlcnRTaWduaW5nQ2FwYWJpbGl0eUlzQXZhaWxhYmxlIiwiYXNzZXJ0VmVyaWZpY2F0aW9uQ2FwYWJpbGl0eUlzQXZhaWxhYmxlIiwiYXNzZXJ0S2V5R2VuZXJhdGlvbklzQXZhaWxhYmxlIiwiYXNzZXJ0UFJOR0lzQXZhaWxhYmxlIiwiU29sYW5hRXJyb3IiLCJTT0xBTkFfRVJST1JfX0tFWVNfX0lOVkFMSURfUFJJVkFURV9LRVlfQllURV9MRU5HVEgiLCJTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX0NBTk5PVF9FWFBPUlRfTk9OX0VYVFJBQ1RBQkxFX0tFWSIsIlNPTEFOQV9FUlJPUl9fS0VZU19fU0lHTkFUVVJFX1NUUklOR19MRU5HVEhfT1VUX09GX1JBTkdFIiwiU09MQU5BX0VSUk9SX19LRVlTX19JTlZBTElEX1NJR05BVFVSRV9CWVRFX0xFTkdUSCIsIlNPTEFOQV9FUlJPUl9fS0VZU19fSU5WQUxJRF9LRVlfUEFJUl9CWVRFX0xFTkdUSCIsIlNPTEFOQV9FUlJPUl9fS0VZU19fUFVCTElDX0tFWV9NVVNUX01BVENIX1BSSVZBVEVfS0VZIiwidG9BcnJheUJ1ZmZlciIsImdldEJhc2U1OEVuY29kZXIiLCJFRDI1NTE5X0FMR09SSVRITV9JREVOVElGSUVSIiwiT2JqZWN0IiwiZnJlZXplIiwibmFtZSIsImFkZFBrY3M4SGVhZGVyIiwiYnl0ZXMiLCJVaW50OEFycmF5IiwiY3JlYXRlUHJpdmF0ZUtleUZyb21CeXRlcyIsImV4dHJhY3RhYmxlIiwiYWN0dWFsTGVuZ3RoIiwiYnl0ZUxlbmd0aCIsInByaXZhdGVLZXlCeXRlc1BrY3M4IiwiY3J5cHRvIiwic3VidGxlIiwiaW1wb3J0S2V5IiwiZ2V0UHVibGljS2V5RnJvbVByaXZhdGVLZXkiLCJwcml2YXRlS2V5Iiwia2V5IiwiandrIiwiZXhwb3J0S2V5IiwiY3J2IiwiZXh0Iiwia2V5X29wcyIsImt0eSIsIngiLCJiYXNlNThFbmNvZGVyIiwiYXNzZXJ0SXNTaWduYXR1cmUiLCJwdXRhdGl2ZVNpZ25hdHVyZSIsImxlbmd0aCIsImVuY29kZSIsImFzc2VydElzU2lnbmF0dXJlQnl0ZXMiLCJwdXRhdGl2ZVNpZ25hdHVyZUJ5dGVzIiwibnVtQnl0ZXMiLCJpc1NpZ25hdHVyZSIsImlzU2lnbmF0dXJlQnl0ZXMiLCJzaWduQnl0ZXMiLCJkYXRhIiwic2lnbmVkRGF0YSIsInNpZ24iLCJzaWduYXR1cmUiLCJzaWduYXR1cmVCeXRlcyIsInZlcmlmeVNpZ25hdHVyZSIsInNpZ25hdHVyZTIiLCJ2ZXJpZnkiLCJnZW5lcmF0ZUtleVBhaXIiLCJrZXlQYWlyIiwiZ2VuZXJhdGVLZXkiLCJjcmVhdGVLZXlQYWlyRnJvbUJ5dGVzIiwicHVibGljS2V5IiwiUHJvbWlzZSIsImFsbCIsInNsaWNlIiwicmFuZG9tQnl0ZXMiLCJnZXRSYW5kb21WYWx1ZXMiLCJpc1ZhbGlkIiwiY3JlYXRlS2V5UGFpckZyb21Qcml2YXRlS2V5Qnl0ZXMiLCJwcml2YXRlS2V5UHJvbWlzZSIsInRoZW4iLCJwcml2YXRlS2V5MiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/keys/dist/index.node.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/offchain-messages/dist/index.node.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@solana/offchain-messages/dist/index.node.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OffchainMessageContentFormat: () => (/* binding */ OffchainMessageContentFormat),\n/* harmony export */   assertIsFullySignedOffchainMessageEnvelope: () => (/* binding */ assertIsFullySignedOffchainMessageEnvelope),\n/* harmony export */   assertIsOffchainMessageApplicationDomain: () => (/* binding */ assertIsOffchainMessageApplicationDomain),\n/* harmony export */   assertIsOffchainMessageContentRestrictedAsciiOf1232BytesMax: () => (/* binding */ assertIsOffchainMessageContentRestrictedAsciiOf1232BytesMax),\n/* harmony export */   assertIsOffchainMessageContentUtf8Of1232BytesMax: () => (/* binding */ assertIsOffchainMessageContentUtf8Of1232BytesMax),\n/* harmony export */   assertIsOffchainMessageContentUtf8Of65535BytesMax: () => (/* binding */ assertIsOffchainMessageContentUtf8Of65535BytesMax),\n/* harmony export */   assertIsOffchainMessageRestrictedAsciiOf1232BytesMax: () => (/* binding */ assertIsOffchainMessageRestrictedAsciiOf1232BytesMax),\n/* harmony export */   assertIsOffchainMessageUtf8Of1232BytesMax: () => (/* binding */ assertIsOffchainMessageUtf8Of1232BytesMax),\n/* harmony export */   assertIsOffchainMessageUtf8Of65535BytesMax: () => (/* binding */ assertIsOffchainMessageUtf8Of65535BytesMax),\n/* harmony export */   compileOffchainMessageEnvelope: () => (/* binding */ compileOffchainMessageEnvelope),\n/* harmony export */   compileOffchainMessageV0Envelope: () => (/* binding */ compileOffchainMessageV0Envelope),\n/* harmony export */   compileOffchainMessageV1Envelope: () => (/* binding */ compileOffchainMessageV1Envelope),\n/* harmony export */   getOffchainMessageApplicationDomainCodec: () => (/* binding */ getOffchainMessageApplicationDomainCodec),\n/* harmony export */   getOffchainMessageApplicationDomainDecoder: () => (/* binding */ getOffchainMessageApplicationDomainDecoder),\n/* harmony export */   getOffchainMessageApplicationDomainEncoder: () => (/* binding */ getOffchainMessageApplicationDomainEncoder),\n/* harmony export */   getOffchainMessageCodec: () => (/* binding */ getOffchainMessageCodec),\n/* harmony export */   getOffchainMessageDecoder: () => (/* binding */ getOffchainMessageDecoder),\n/* harmony export */   getOffchainMessageEncoder: () => (/* binding */ getOffchainMessageEncoder),\n/* harmony export */   getOffchainMessageEnvelopeCodec: () => (/* binding */ getOffchainMessageEnvelopeCodec),\n/* harmony export */   getOffchainMessageEnvelopeDecoder: () => (/* binding */ getOffchainMessageEnvelopeDecoder),\n/* harmony export */   getOffchainMessageEnvelopeEncoder: () => (/* binding */ getOffchainMessageEnvelopeEncoder),\n/* harmony export */   getOffchainMessageV0Codec: () => (/* binding */ getOffchainMessageV0Codec),\n/* harmony export */   getOffchainMessageV0Decoder: () => (/* binding */ getOffchainMessageV0Decoder),\n/* harmony export */   getOffchainMessageV0Encoder: () => (/* binding */ getOffchainMessageV0Encoder),\n/* harmony export */   getOffchainMessageV1Codec: () => (/* binding */ getOffchainMessageV1Codec),\n/* harmony export */   getOffchainMessageV1Decoder: () => (/* binding */ getOffchainMessageV1Decoder),\n/* harmony export */   getOffchainMessageV1Encoder: () => (/* binding */ getOffchainMessageV1Encoder),\n/* harmony export */   isFullySignedOffchainMessageEnvelope: () => (/* binding */ isFullySignedOffchainMessageEnvelope),\n/* harmony export */   isOffchainMessageApplicationDomain: () => (/* binding */ isOffchainMessageApplicationDomain),\n/* harmony export */   isOffchainMessageContentRestrictedAsciiOf1232BytesMax: () => (/* binding */ isOffchainMessageContentRestrictedAsciiOf1232BytesMax),\n/* harmony export */   isOffchainMessageContentUtf8Of1232BytesMax: () => (/* binding */ isOffchainMessageContentUtf8Of1232BytesMax),\n/* harmony export */   isOffchainMessageContentUtf8Of65535BytesMax: () => (/* binding */ isOffchainMessageContentUtf8Of65535BytesMax),\n/* harmony export */   offchainMessageApplicationDomain: () => (/* binding */ offchainMessageApplicationDomain),\n/* harmony export */   offchainMessageContentRestrictedAsciiOf1232BytesMax: () => (/* binding */ offchainMessageContentRestrictedAsciiOf1232BytesMax),\n/* harmony export */   offchainMessageContentUtf8Of1232BytesMax: () => (/* binding */ offchainMessageContentUtf8Of1232BytesMax),\n/* harmony export */   offchainMessageContentUtf8Of65535BytesMax: () => (/* binding */ offchainMessageContentUtf8Of65535BytesMax),\n/* harmony export */   partiallySignOffchainMessageEnvelope: () => (/* binding */ partiallySignOffchainMessageEnvelope),\n/* harmony export */   signOffchainMessageEnvelope: () => (/* binding */ signOffchainMessageEnvelope),\n/* harmony export */   verifyOffchainMessageEnvelope: () => (/* binding */ verifyOffchainMessageEnvelope)\n/* harmony export */ });\n/* harmony import */ var _solana_addresses__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/addresses */ \"(ssr)/./node_modules/@solana/addresses/dist/index.node.mjs\");\n/* harmony import */ var _solana_errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana/errors */ \"(ssr)/./node_modules/@solana/errors/dist/index.node.mjs\");\n/* harmony import */ var _solana_codecs_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @solana/codecs-core */ \"(ssr)/./node_modules/@solana/codecs-core/dist/index.node.mjs\");\n/* harmony import */ var _solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @solana/codecs-data-structures */ \"(ssr)/./node_modules/@solana/codecs-data-structures/dist/index.node.mjs\");\n/* harmony import */ var _solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @solana/codecs-numbers */ \"(ssr)/./node_modules/@solana/codecs-numbers/dist/index.node.mjs\");\n/* harmony import */ var _solana_codecs_strings__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @solana/codecs-strings */ \"(ssr)/./node_modules/@solana/codecs-strings/dist/index.node.mjs\");\n/* harmony import */ var _solana_keys__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @solana/keys */ \"(ssr)/./node_modules/@solana/keys/dist/index.node.mjs\");\n\n\n\n\n\n\n\n// src/application-domain.ts\nfunction isOffchainMessageApplicationDomain(putativeApplicationDomain) {\n    return (0,_solana_addresses__WEBPACK_IMPORTED_MODULE_0__.isAddress)(putativeApplicationDomain);\n}\nfunction assertIsOffchainMessageApplicationDomain(putativeApplicationDomain) {\n    try {\n        (0,_solana_addresses__WEBPACK_IMPORTED_MODULE_0__.assertIsAddress)(putativeApplicationDomain);\n    } catch (error) {\n        if ((0,_solana_errors__WEBPACK_IMPORTED_MODULE_1__.isSolanaError)(error, _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE)) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__OFFCHAIN_MESSAGE__APPLICATION_DOMAIN_STRING_LENGTH_OUT_OF_RANGE, error.context);\n        }\n        if ((0,_solana_errors__WEBPACK_IMPORTED_MODULE_1__.isSolanaError)(error, _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH)) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__OFFCHAIN_MESSAGE__INVALID_APPLICATION_DOMAIN_BYTE_LENGTH, error.context);\n        }\n        throw error;\n    }\n}\nfunction offchainMessageApplicationDomain(putativeApplicationDomain) {\n    assertIsOffchainMessageApplicationDomain(putativeApplicationDomain);\n    return putativeApplicationDomain;\n}\nfunction getOffchainMessageApplicationDomainEncoder() {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_2__.transformEncoder)((0,_solana_addresses__WEBPACK_IMPORTED_MODULE_0__.getAddressEncoder)(), (putativeApplicationDomain)=>offchainMessageApplicationDomain(putativeApplicationDomain));\n}\nfunction getOffchainMessageApplicationDomainDecoder() {\n    return (0,_solana_addresses__WEBPACK_IMPORTED_MODULE_0__.getAddressDecoder)();\n}\nfunction getOffchainMessageApplicationDomainCodec() {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_2__.combineCodec)(getOffchainMessageApplicationDomainEncoder(), getOffchainMessageApplicationDomainDecoder());\n}\nvar OFFCHAIN_MESSAGE_SIGNING_DOMAIN_BYTES = new Uint8Array([\n    255,\n    115,\n    111,\n    108,\n    97,\n    110,\n    97,\n    32,\n    111,\n    102,\n    102,\n    99,\n    104,\n    97,\n    105,\n    110\n]);\nfunction getOffchainMessageSigningDomainDecoder() {\n    return (0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_3__.getConstantDecoder)(OFFCHAIN_MESSAGE_SIGNING_DOMAIN_BYTES);\n}\nfunction getOffchainMessageSigningDomainEncoder() {\n    return (0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_3__.getConstantEncoder)(OFFCHAIN_MESSAGE_SIGNING_DOMAIN_BYTES);\n}\n// src/codecs/preamble-common.ts\nfunction getSigningDomainPrefixedDecoder(...fields) {\n    return (0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_3__.getHiddenPrefixDecoder)((0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_3__.getStructDecoder)(fields), [\n        getOffchainMessageSigningDomainDecoder()\n    ]);\n}\nfunction getSigningDomainPrefixedEncoder(...fields) {\n    return (0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_3__.getHiddenPrefixEncoder)((0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_3__.getStructEncoder)(fields), [\n        getOffchainMessageSigningDomainEncoder()\n    ]);\n}\nfunction getVersionTransformer(fixedVersion) {\n    return (version)=>{\n        if (version > 1) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED, {\n                unsupportedVersion: version\n            });\n        }\n        if (fixedVersion != null && version !== fixedVersion) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__OFFCHAIN_MESSAGE__UNEXPECTED_VERSION, {\n                actualVersion: version,\n                expectedVersion: fixedVersion\n            });\n        }\n        return version;\n    };\n}\nfunction createOffchainMessagePreambleDecoder(version, ...fields) {\n    return getSigningDomainPrefixedDecoder([\n        \"version\",\n        (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_2__.transformDecoder)((0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_4__.getU8Decoder)(), getVersionTransformer(version))\n    ], ...fields);\n}\nfunction createOffchainMessagePreambleEncoder(version, ...fields) {\n    return getSigningDomainPrefixedEncoder([\n        \"version\",\n        (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_2__.transformEncoder)((0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_4__.getU8Encoder)(), getVersionTransformer(version))\n    ], ...fields);\n}\nfunction decodeRequiredSignatoryAddresses(bytes) {\n    const { version, bytesAfterVersion } = getSigningDomainPrefixedDecoder([\n        \"version\",\n        (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_2__.transformDecoder)((0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_4__.getU8Decoder)(), getVersionTransformer())\n    ], [\n        \"bytesAfterVersion\",\n        (0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_3__.getBytesDecoder)()\n    ]).decode(bytes);\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_2__.offsetDecoder)((0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_2__.transformDecoder)((0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_3__.getArrayDecoder)((0,_solana_addresses__WEBPACK_IMPORTED_MODULE_0__.getAddressDecoder)(), {\n        size: (0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_4__.getU8Decoder)()\n    }), (signatoryAddresses)=>{\n        if (signatoryAddresses.length === 0) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO);\n        }\n        return signatoryAddresses;\n    }), {\n        preOffset: ({ preOffset })=>preOffset + (version === 0 ? 32 + 1 : 0)\n    }).decode(bytesAfterVersion);\n}\nfunction getSignatoriesComparator() {\n    return (x, y)=>{\n        if (x.length !== y.length) {\n            return x.length < y.length ? -1 : 1;\n        }\n        for(let ii = 0; ii < x.length; ii++){\n            if (x[ii] === y[ii]) {\n                continue;\n            } else {\n                return x[ii] < y[ii] ? -1 : 1;\n            }\n        }\n        return 0;\n    };\n}\nfunction getSignaturesToEncode(signaturesMap) {\n    const signatures = Object.values(signaturesMap);\n    if (signatures.length === 0) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_ENVELOPE_SIGNATURES_CANNOT_BE_ZERO);\n    }\n    return signatures.map((signature)=>{\n        if (!signature) {\n            return new Uint8Array(64).fill(0);\n        }\n        return signature;\n    });\n}\nfunction getSignaturesEncoder() {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_2__.transformEncoder)((0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_3__.getArrayEncoder)((0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_2__.fixEncoderSize)((0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_3__.getBytesEncoder)(), 64), {\n        size: (0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_4__.getU8Encoder)()\n    }), getSignaturesToEncode);\n}\n// src/codecs/envelope.ts\nfunction getOffchainMessageEnvelopeEncoder() {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_2__.transformEncoder)((0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_3__.getStructEncoder)([\n        [\n            \"signatures\",\n            getSignaturesEncoder()\n        ],\n        [\n            \"content\",\n            (0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_3__.getBytesEncoder)()\n        ]\n    ]), (envelope)=>{\n        const signaturesMapAddresses = Object.keys(envelope.signatures).map(_solana_addresses__WEBPACK_IMPORTED_MODULE_0__.address);\n        if (signaturesMapAddresses.length === 0) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_ENVELOPE_SIGNATURES_CANNOT_BE_ZERO);\n        }\n        const signatoryAddresses = decodeAndValidateRequiredSignatoryAddresses(envelope.content);\n        const missingRequiredSigners = [];\n        const unexpectedSigners = [];\n        for (const address2 of signatoryAddresses){\n            if (!signaturesMapAddresses.includes(address2)) {\n                missingRequiredSigners.push(address2);\n            }\n        }\n        for (const address2 of signaturesMapAddresses){\n            if (!signatoryAddresses.includes(address2)) {\n                unexpectedSigners.push(address2);\n            }\n        }\n        if (missingRequiredSigners.length || unexpectedSigners.length) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__OFFCHAIN_MESSAGE__ENVELOPE_SIGNERS_MISMATCH, {\n                missingRequiredSigners,\n                unexpectedSigners\n            });\n        }\n        const orderedSignatureMap = {};\n        for (const address2 of signatoryAddresses){\n            orderedSignatureMap[address2] = envelope.signatures[address2];\n        }\n        return {\n            ...envelope,\n            signatures: orderedSignatureMap\n        };\n    });\n}\nfunction getOffchainMessageEnvelopeDecoder() {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_2__.transformDecoder)((0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_3__.getStructDecoder)([\n        [\n            \"signatures\",\n            (0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_3__.getArrayDecoder)((0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_2__.fixDecoderSize)((0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_3__.getBytesDecoder)(), 64), {\n                size: (0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_4__.getU8Decoder)()\n            })\n        ],\n        [\n            \"content\",\n            (0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_3__.getBytesDecoder)()\n        ]\n    ]), decodePartiallyDecodedOffchainMessageEnvelope);\n}\nfunction getOffchainMessageEnvelopeCodec() {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_2__.combineCodec)(getOffchainMessageEnvelopeEncoder(), getOffchainMessageEnvelopeDecoder());\n}\nfunction decodePartiallyDecodedOffchainMessageEnvelope(offchainMessageEnvelope) {\n    const { content, signatures } = offchainMessageEnvelope;\n    if (signatures.length === 0) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_ENVELOPE_SIGNATURES_CANNOT_BE_ZERO);\n    }\n    const signatoryAddresses = decodeAndValidateRequiredSignatoryAddresses(content);\n    if (signatoryAddresses.length !== signatures.length) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_SIGNATURES_MISMATCH, {\n            numRequiredSignatures: signatoryAddresses.length,\n            signatoryAddresses,\n            signaturesLength: signatures.length\n        });\n    }\n    const signaturesMap = {};\n    signatoryAddresses.forEach((address2, index)=>{\n        const signatureForAddress = signatures[index];\n        if (signatureForAddress.every((b)=>b === 0)) {\n            signaturesMap[address2] = null;\n        } else {\n            signaturesMap[address2] = signatureForAddress;\n        }\n    });\n    return Object.freeze({\n        content,\n        signatures: Object.freeze(signaturesMap)\n    });\n}\nfunction decodeAndValidateRequiredSignatoryAddresses(bytes) {\n    const signatoryAddresses = decodeRequiredSignatoryAddresses(bytes);\n    if (signatoryAddresses.length === 0) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO);\n    }\n    return signatoryAddresses;\n}\nvar MAX_BODY_BYTES = // Largest 16-bit unsigned integer\n65535;\nvar MAX_BODY_BYTES_HARDWARE_WALLET_SIGNABLE = // Space remaining in the mininum IPv6 MTU after network header overhead\n1232;\nvar OffchainMessageContentFormat = /* @__PURE__ */ ((OffchainMessageContentFormat3)=>{\n    OffchainMessageContentFormat3[OffchainMessageContentFormat3[\"RESTRICTED_ASCII_1232_BYTES_MAX\"] = 0] = \"RESTRICTED_ASCII_1232_BYTES_MAX\";\n    OffchainMessageContentFormat3[OffchainMessageContentFormat3[\"UTF8_1232_BYTES_MAX\"] = 1] = \"UTF8_1232_BYTES_MAX\";\n    OffchainMessageContentFormat3[OffchainMessageContentFormat3[\"UTF8_65535_BYTES_MAX\"] = 2] = \"UTF8_65535_BYTES_MAX\";\n    return OffchainMessageContentFormat3;\n})(OffchainMessageContentFormat || {});\nfunction assertIsOffchainMessageContentRestrictedAsciiOf1232BytesMax(putativeContent) {\n    if (putativeContent.format !== 0 /* RESTRICTED_ASCII_1232_BYTES_MAX */ ) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_FORMAT_MISMATCH, {\n            actualMessageFormat: putativeContent.format,\n            expectedMessageFormat: 0 /* RESTRICTED_ASCII_1232_BYTES_MAX */ \n        });\n    }\n    if (putativeContent.text.length === 0) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY);\n    }\n    if (isTextRestrictedAscii(putativeContent.text) === false) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__OFFCHAIN_MESSAGE__RESTRICTED_ASCII_BODY_CHARACTER_OUT_OF_RANGE);\n    }\n    const length = (0,_solana_codecs_strings__WEBPACK_IMPORTED_MODULE_5__.getUtf8Encoder)().getSizeFromValue(putativeContent.text);\n    if (length > MAX_BODY_BYTES_HARDWARE_WALLET_SIGNABLE) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__OFFCHAIN_MESSAGE__MAXIMUM_LENGTH_EXCEEDED, {\n            actualBytes: length,\n            maxBytes: MAX_BODY_BYTES_HARDWARE_WALLET_SIGNABLE\n        });\n    }\n}\nfunction isOffchainMessageContentRestrictedAsciiOf1232BytesMax(putativeContent) {\n    if (putativeContent.format !== 0 /* RESTRICTED_ASCII_1232_BYTES_MAX */  || putativeContent.text.length === 0 || isTextRestrictedAscii(putativeContent.text) === false) {\n        return false;\n    }\n    const length = (0,_solana_codecs_strings__WEBPACK_IMPORTED_MODULE_5__.getUtf8Encoder)().getSizeFromValue(putativeContent.text);\n    return length <= MAX_BODY_BYTES_HARDWARE_WALLET_SIGNABLE;\n}\nfunction offchainMessageContentRestrictedAsciiOf1232BytesMax(text) {\n    const putativeContent = Object.freeze({\n        format: 0 /* RESTRICTED_ASCII_1232_BYTES_MAX */ ,\n        text\n    });\n    assertIsOffchainMessageContentRestrictedAsciiOf1232BytesMax(putativeContent);\n    return putativeContent;\n}\nfunction assertIsOffchainMessageContentUtf8Of1232BytesMax(putativeContent) {\n    if (putativeContent.text.length === 0) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY);\n    }\n    if (putativeContent.format !== 1 /* UTF8_1232_BYTES_MAX */ ) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_FORMAT_MISMATCH, {\n            actualMessageFormat: putativeContent.format,\n            expectedMessageFormat: 1 /* UTF8_1232_BYTES_MAX */ \n        });\n    }\n    const length = (0,_solana_codecs_strings__WEBPACK_IMPORTED_MODULE_5__.getUtf8Encoder)().getSizeFromValue(putativeContent.text);\n    if (length > MAX_BODY_BYTES_HARDWARE_WALLET_SIGNABLE) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__OFFCHAIN_MESSAGE__MAXIMUM_LENGTH_EXCEEDED, {\n            actualBytes: length,\n            maxBytes: MAX_BODY_BYTES_HARDWARE_WALLET_SIGNABLE\n        });\n    }\n}\nfunction isOffchainMessageContentUtf8Of1232BytesMax(putativeContent) {\n    if (putativeContent.format !== 1 /* UTF8_1232_BYTES_MAX */  || putativeContent.text.length === 0) {\n        return false;\n    }\n    const length = (0,_solana_codecs_strings__WEBPACK_IMPORTED_MODULE_5__.getUtf8Encoder)().getSizeFromValue(putativeContent.text);\n    return length <= MAX_BODY_BYTES_HARDWARE_WALLET_SIGNABLE;\n}\nfunction offchainMessageContentUtf8Of1232BytesMax(text) {\n    const putativeContent = Object.freeze({\n        format: 1 /* UTF8_1232_BYTES_MAX */ ,\n        text\n    });\n    assertIsOffchainMessageContentUtf8Of1232BytesMax(putativeContent);\n    return putativeContent;\n}\nfunction assertIsOffchainMessageContentUtf8Of65535BytesMax(putativeContent) {\n    if (putativeContent.format !== 2 /* UTF8_65535_BYTES_MAX */ ) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_FORMAT_MISMATCH, {\n            actualMessageFormat: putativeContent.format,\n            expectedMessageFormat: 2 /* UTF8_65535_BYTES_MAX */ \n        });\n    }\n    if (putativeContent.text.length === 0) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY);\n    }\n    const length = (0,_solana_codecs_strings__WEBPACK_IMPORTED_MODULE_5__.getUtf8Encoder)().getSizeFromValue(putativeContent.text);\n    if (length > MAX_BODY_BYTES) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__OFFCHAIN_MESSAGE__MAXIMUM_LENGTH_EXCEEDED, {\n            actualBytes: length,\n            maxBytes: MAX_BODY_BYTES\n        });\n    }\n}\nfunction isOffchainMessageContentUtf8Of65535BytesMax(putativeContent) {\n    if (putativeContent.format !== 2 /* UTF8_65535_BYTES_MAX */  || putativeContent.text.length === 0) {\n        return false;\n    }\n    const length = (0,_solana_codecs_strings__WEBPACK_IMPORTED_MODULE_5__.getUtf8Encoder)().getSizeFromValue(putativeContent.text);\n    return length <= MAX_BODY_BYTES;\n}\nfunction offchainMessageContentUtf8Of65535BytesMax(text) {\n    const putativeContent = Object.freeze({\n        format: 2 /* UTF8_65535_BYTES_MAX */ ,\n        text\n    });\n    assertIsOffchainMessageContentUtf8Of65535BytesMax(putativeContent);\n    return putativeContent;\n}\nfunction isTextRestrictedAscii(putativeRestrictedAsciiString) {\n    return /^[\\x20-\\x7e]+$/.test(putativeRestrictedAsciiString);\n}\n// src/message-v0.ts\nfunction assertIsOffchainMessageRestrictedAsciiOf1232BytesMax(putativeMessage) {\n    assertIsOffchainMessageContentRestrictedAsciiOf1232BytesMax(putativeMessage.content);\n}\nfunction assertIsOffchainMessageUtf8Of1232BytesMax(putativeMessage) {\n    assertIsOffchainMessageContentUtf8Of1232BytesMax(putativeMessage.content);\n}\nfunction assertIsOffchainMessageUtf8Of65535BytesMax(putativeMessage) {\n    assertIsOffchainMessageContentUtf8Of65535BytesMax(putativeMessage.content);\n}\nfunction getOffchainMessageContentFormatDecoder() {\n    return (0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_3__.getEnumDecoder)(OffchainMessageContentFormat, {\n        useValuesAsDiscriminators: true\n    });\n}\nfunction getOffchainMessageContentFormatEncoder() {\n    return (0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_3__.getEnumEncoder)(OffchainMessageContentFormat, {\n        useValuesAsDiscriminators: true\n    });\n}\n// src/codecs/preamble-v0.ts\nfunction getOffchainMessageV0PreambleDecoder() {\n    return createOffchainMessagePreambleDecoder(/* version */ 0, [\n        \"applicationDomain\",\n        getOffchainMessageApplicationDomainDecoder()\n    ], [\n        \"messageFormat\",\n        getOffchainMessageContentFormatDecoder()\n    ], [\n        \"requiredSignatories\",\n        (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_2__.transformDecoder)((0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_3__.getArrayDecoder)((0,_solana_addresses__WEBPACK_IMPORTED_MODULE_0__.getAddressDecoder)(), {\n            size: (0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_4__.getU8Decoder)()\n        }), (signatoryAddresses)=>{\n            if (signatoryAddresses.length === 0) {\n                throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO);\n            }\n            return signatoryAddresses.map((address2)=>Object.freeze({\n                    address: address2\n                }));\n        })\n    ], [\n        \"messageLength\",\n        (0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_4__.getU16Decoder)()\n    ]);\n}\nfunction getOffchainMessageV0PreambleEncoder() {\n    return createOffchainMessagePreambleEncoder(/* version */ 0, [\n        \"applicationDomain\",\n        getOffchainMessageApplicationDomainEncoder()\n    ], [\n        \"messageFormat\",\n        getOffchainMessageContentFormatEncoder()\n    ], [\n        \"requiredSignatories\",\n        (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_2__.transformEncoder)((0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_3__.getArrayEncoder)((0,_solana_addresses__WEBPACK_IMPORTED_MODULE_0__.getAddressEncoder)(), {\n            size: (0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_4__.getU8Encoder)()\n        }), (signatoryAddresses)=>{\n            if (signatoryAddresses.length === 0) {\n                throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO);\n            }\n            return signatoryAddresses.map(({ address: address2 })=>address2);\n        })\n    ], [\n        \"messageLength\",\n        (0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_4__.getU16Encoder)()\n    ]);\n}\n// src/codecs/message-v0.ts\nfunction getOffchainMessageV0Decoder() {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_2__.transformDecoder)((0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_3__.getTupleDecoder)([\n        getOffchainMessageV0PreambleDecoder(),\n        (0,_solana_codecs_strings__WEBPACK_IMPORTED_MODULE_5__.getUtf8Decoder)()\n    ]), ([{ messageLength, messageFormat, requiredSignatories, ...preambleRest }, text])=>{\n        const actualLength = (0,_solana_codecs_strings__WEBPACK_IMPORTED_MODULE_5__.getUtf8Encoder)().getSizeFromValue(text);\n        if (messageLength !== actualLength) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_LENGTH_MISMATCH, {\n                actualLength,\n                specifiedLength: messageLength\n            });\n        }\n        const offchainMessage = Object.freeze({\n            ...preambleRest,\n            content: Object.freeze({\n                format: messageFormat,\n                text\n            }),\n            requiredSignatories: Object.freeze(requiredSignatories)\n        });\n        switch(messageFormat){\n            case 0 /* RESTRICTED_ASCII_1232_BYTES_MAX */ :\n                {\n                    assertIsOffchainMessageRestrictedAsciiOf1232BytesMax(offchainMessage);\n                    return offchainMessage;\n                }\n            case 1 /* UTF8_1232_BYTES_MAX */ :\n                {\n                    assertIsOffchainMessageUtf8Of1232BytesMax(offchainMessage);\n                    return offchainMessage;\n                }\n            case 2 /* UTF8_65535_BYTES_MAX */ :\n                {\n                    assertIsOffchainMessageUtf8Of65535BytesMax(offchainMessage);\n                    return offchainMessage;\n                }\n            default:\n                {\n                    throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE, {\n                        unexpectedValue: messageFormat\n                    });\n                }\n        }\n    });\n}\nfunction getOffchainMessageV0Encoder() {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_2__.transformEncoder)((0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_3__.getTupleEncoder)([\n        getOffchainMessageV0PreambleEncoder(),\n        (0,_solana_codecs_strings__WEBPACK_IMPORTED_MODULE_5__.getUtf8Encoder)()\n    ]), (offchainMessage)=>{\n        const { content, ...preamble } = offchainMessage;\n        switch(offchainMessage.content.format){\n            case 0 /* RESTRICTED_ASCII_1232_BYTES_MAX */ :\n                {\n                    assertIsOffchainMessageRestrictedAsciiOf1232BytesMax(offchainMessage);\n                    break;\n                }\n            case 1 /* UTF8_1232_BYTES_MAX */ :\n                {\n                    assertIsOffchainMessageUtf8Of1232BytesMax(offchainMessage);\n                    break;\n                }\n            case 2 /* UTF8_65535_BYTES_MAX */ :\n                {\n                    assertIsOffchainMessageUtf8Of65535BytesMax(offchainMessage);\n                    break;\n                }\n            default:\n                {\n                    throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE, {\n                        unexpectedValue: offchainMessage.content\n                    });\n                }\n        }\n        const messageLength = (0,_solana_codecs_strings__WEBPACK_IMPORTED_MODULE_5__.getUtf8Encoder)().getSizeFromValue(content.text);\n        const compiledPreamble = {\n            ...preamble,\n            messageFormat: content.format,\n            messageLength\n        };\n        return [\n            compiledPreamble,\n            content.text\n        ];\n    });\n}\nfunction getOffchainMessageV0Codec() {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_2__.combineCodec)(getOffchainMessageV0Encoder(), getOffchainMessageV0Decoder());\n}\nfunction getOffchainMessageV1PreambleDecoder() {\n    return createOffchainMessagePreambleDecoder(/* version */ 1, [\n        \"requiredSignatories\",\n        (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_2__.transformDecoder)((0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_3__.getArrayDecoder)((0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_2__.fixDecoderSize)((0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_3__.getBytesDecoder)(), 32), {\n            size: (0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_4__.getU8Decoder)()\n        }), (signatoryAddressesBytes)=>{\n            if (signatoryAddressesBytes.length === 0) {\n                throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO);\n            }\n            const comparator = getSignatoriesComparator();\n            for(let ii = 0; ii < signatoryAddressesBytes.length - 1; ii++){\n                switch(comparator(signatoryAddressesBytes[ii], signatoryAddressesBytes[ii + 1])){\n                    case 0:\n                        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_UNIQUE);\n                    case 1:\n                        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_SORTED);\n                }\n            }\n            const addressDecoder = (0,_solana_addresses__WEBPACK_IMPORTED_MODULE_0__.getAddressDecoder)();\n            return signatoryAddressesBytes.map((addressBytes)=>Object.freeze({\n                    address: addressDecoder.decode(addressBytes)\n                }));\n        })\n    ]);\n}\nfunction getOffchainMessageV1PreambleEncoder() {\n    return createOffchainMessagePreambleEncoder(/* version */ 1, [\n        \"requiredSignatories\",\n        (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_2__.transformEncoder)((0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_2__.transformEncoder)((0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_3__.getArrayEncoder)((0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_3__.getBytesEncoder)(), {\n            size: (0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_4__.getU8Encoder)()\n        }), (signatoryAddressesBytes)=>{\n            return signatoryAddressesBytes.toSorted(getSignatoriesComparator());\n        }), (signatoryAddresses)=>{\n            if (signatoryAddresses.length === 0) {\n                throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO);\n            }\n            const seenSignatories = /* @__PURE__ */ new Set();\n            for (const { address: address2 } of signatoryAddresses){\n                if (seenSignatories.has(address2)) {\n                    throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_UNIQUE);\n                }\n                seenSignatories.add(address2);\n            }\n            const addressEncoder = (0,_solana_addresses__WEBPACK_IMPORTED_MODULE_0__.getAddressEncoder)();\n            return signatoryAddresses.map(({ address: address2 })=>addressEncoder.encode(address2));\n        })\n    ]);\n}\n// src/codecs/message-v1.ts\nfunction getOffchainMessageV1Decoder() {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_2__.transformDecoder)((0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_3__.getTupleDecoder)([\n        getOffchainMessageV1PreambleDecoder(),\n        (0,_solana_codecs_strings__WEBPACK_IMPORTED_MODULE_5__.getUtf8Decoder)()\n    ]), ([{ requiredSignatories, ...preambleRest }, text])=>{\n        if (text.length === 0) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY);\n        }\n        return Object.freeze({\n            ...preambleRest,\n            content: text,\n            requiredSignatories: Object.freeze(requiredSignatories)\n        });\n    });\n}\nfunction getOffchainMessageV1Encoder() {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_2__.transformEncoder)((0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_3__.getTupleEncoder)([\n        getOffchainMessageV1PreambleEncoder(),\n        (0,_solana_codecs_strings__WEBPACK_IMPORTED_MODULE_5__.getUtf8Encoder)()\n    ]), (offchainMessage)=>{\n        const { content, ...compiledPreamble } = offchainMessage;\n        if (content.length === 0) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY);\n        }\n        return [\n            compiledPreamble,\n            content\n        ];\n    });\n}\nfunction getOffchainMessageV1Codec() {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_2__.combineCodec)(getOffchainMessageV1Encoder(), getOffchainMessageV1Decoder());\n}\n// src/codecs/message.ts\nfunction getOffchainMessageDecoder() {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_2__.createDecoder)({\n        read (bytes, offset) {\n            const version = (0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_3__.getHiddenPrefixDecoder)((0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_4__.getU8Decoder)(), [\n                // Discard the signing domain\n                getOffchainMessageSigningDomainDecoder()\n            ]).decode(bytes, offset);\n            switch(version){\n                case 0:\n                    return getOffchainMessageV0Decoder().read(bytes, offset);\n                case 1:\n                    return getOffchainMessageV1Decoder().read(bytes, offset);\n                default:\n                    throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED, {\n                        unsupportedVersion: version\n                    });\n            }\n        }\n    });\n}\nfunction getOffchainMessageEncoder() {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_2__.createEncoder)({\n        getSizeFromValue: (offchainMessage)=>{\n            const { version } = offchainMessage;\n            switch(version){\n                case 0:\n                    return getOffchainMessageV0Encoder().getSizeFromValue(offchainMessage);\n                case 1:\n                    return getOffchainMessageV1Encoder().getSizeFromValue(offchainMessage);\n                default:\n                    throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED, {\n                        unsupportedVersion: version\n                    });\n            }\n        },\n        write: (offchainMessage, bytes, offset)=>{\n            const { version } = offchainMessage;\n            switch(version){\n                case 0:\n                    return getOffchainMessageV0Encoder().write(offchainMessage, bytes, offset);\n                case 1:\n                    return getOffchainMessageV1Encoder().write(offchainMessage, bytes, offset);\n                default:\n                    throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED, {\n                        unsupportedVersion: version\n                    });\n            }\n        }\n    });\n}\nfunction getOffchainMessageCodec() {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_2__.combineCodec)(getOffchainMessageEncoder(), getOffchainMessageDecoder());\n}\n// src/envelope-common.ts\nfunction compileOffchainMessageEnvelopeUsingEncoder(offchainMessage, encoder) {\n    const offchainMessageBytes = encoder.encode(offchainMessage);\n    const signatures = {};\n    for (const { address: address2 } of offchainMessage.requiredSignatories){\n        signatures[address2] = null;\n    }\n    return Object.freeze({\n        content: offchainMessageBytes,\n        signatures: Object.freeze(signatures)\n    });\n}\n// src/envelope-v0.ts\nfunction compileOffchainMessageV0Envelope(offchainMessage) {\n    return compileOffchainMessageEnvelopeUsingEncoder(offchainMessage, getOffchainMessageV0Encoder());\n}\n// src/envelope-v1.ts\nfunction compileOffchainMessageV1Envelope(offchainMessage) {\n    return compileOffchainMessageEnvelopeUsingEncoder(offchainMessage, getOffchainMessageV1Encoder());\n}\n// src/envelope.ts\nfunction compileOffchainMessageEnvelope(offchainMessage) {\n    const { version } = offchainMessage;\n    switch(version){\n        case 0:\n            return compileOffchainMessageV0Envelope(offchainMessage);\n        case 1:\n            return compileOffchainMessageV1Envelope(offchainMessage);\n        default:\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE, {\n                unexpectedValue: version\n            });\n    }\n}\nasync function partiallySignOffchainMessageEnvelope(keyPairs, offchainMessageEnvelope) {\n    let newSignatures;\n    let unexpectedSigners;\n    const requiredSignatoryAddresses = decodeRequiredSignatoryAddresses(offchainMessageEnvelope.content);\n    await Promise.all(keyPairs.map(async (keyPair)=>{\n        const address2 = await (0,_solana_addresses__WEBPACK_IMPORTED_MODULE_0__.getAddressFromPublicKey)(keyPair.publicKey);\n        if (!requiredSignatoryAddresses.includes(address2)) {\n            unexpectedSigners ||= /* @__PURE__ */ new Set();\n            unexpectedSigners.add(address2);\n            return;\n        }\n        if (unexpectedSigners) {\n            return;\n        }\n        const existingSignature = offchainMessageEnvelope.signatures[address2];\n        const newSignature = await (0,_solana_keys__WEBPACK_IMPORTED_MODULE_6__.signBytes)(keyPair.privateKey, offchainMessageEnvelope.content);\n        if (existingSignature != null && (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_2__.bytesEqual)(newSignature, existingSignature)) {\n            return;\n        }\n        newSignatures ||= {};\n        newSignatures[address2] = newSignature;\n    }));\n    if (unexpectedSigners && unexpectedSigners.size > 0) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__OFFCHAIN_MESSAGE__ADDRESSES_CANNOT_SIGN_OFFCHAIN_MESSAGE, {\n            expectedAddresses: requiredSignatoryAddresses,\n            unexpectedAddresses: [\n                ...unexpectedSigners\n            ]\n        });\n    }\n    if (!newSignatures) {\n        return offchainMessageEnvelope;\n    }\n    return Object.freeze({\n        ...offchainMessageEnvelope,\n        signatures: Object.freeze({\n            ...offchainMessageEnvelope.signatures,\n            ...newSignatures\n        })\n    });\n}\nasync function signOffchainMessageEnvelope(keyPairs, offchainMessageEnvelope) {\n    const out = await partiallySignOffchainMessageEnvelope(keyPairs, offchainMessageEnvelope);\n    assertIsFullySignedOffchainMessageEnvelope(out);\n    Object.freeze(out);\n    return out;\n}\nfunction isFullySignedOffchainMessageEnvelope(offchainMessage) {\n    return Object.entries(offchainMessage.signatures).every(([_, signatureBytes])=>!!signatureBytes);\n}\nfunction assertIsFullySignedOffchainMessageEnvelope(offchainMessage) {\n    const missingSigs = [];\n    Object.entries(offchainMessage.signatures).forEach(([address2, signatureBytes])=>{\n        if (!signatureBytes) {\n            missingSigs.push(address2);\n        }\n    });\n    if (missingSigs.length > 0) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURES_MISSING, {\n            addresses: missingSigs\n        });\n    }\n}\nasync function verifyOffchainMessageEnvelope(offchainMessageEnvelope) {\n    let errorContext;\n    const requiredSignatories = decodeRequiredSignatoryAddresses(offchainMessageEnvelope.content);\n    await Promise.all(requiredSignatories.map(async (address2)=>{\n        const signature = offchainMessageEnvelope.signatures[address2];\n        if (signature == null) {\n            errorContext ||= {};\n            errorContext.signatoriesWithMissingSignatures ||= [];\n            errorContext.signatoriesWithMissingSignatures.push(address2);\n        } else {\n            const publicKey = await (0,_solana_addresses__WEBPACK_IMPORTED_MODULE_0__.getPublicKeyFromAddress)(address2);\n            if (await (0,_solana_keys__WEBPACK_IMPORTED_MODULE_6__.verifySignature)(publicKey, signature, offchainMessageEnvelope.content)) {\n                return true;\n            } else {\n                errorContext ||= {};\n                errorContext.signatoriesWithInvalidSignatures ||= [];\n                errorContext.signatoriesWithInvalidSignatures.push(address2);\n            }\n        }\n    }));\n    if (errorContext) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURE_VERIFICATION_FAILURE, errorContext);\n    }\n}\n //# sourceMappingURL=index.node.mjs.map\n //# sourceMappingURL=index.node.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS9vZmZjaGFpbi1tZXNzYWdlcy9kaXN0L2luZGV4Lm5vZGUubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBZ0s7QUFDK3FDO0FBQy9wQztBQUNrSTtBQUNoTjtBQUMxQjtBQUNkO0FBRTFELDRCQUE0QjtBQUM1QixTQUFTNkQsbUNBQW1DQyx5QkFBeUI7SUFDbkUsT0FBTzlELDREQUFTQSxDQUFDOEQ7QUFDbkI7QUFDQSxTQUFTQyx5Q0FBeUNELHlCQUF5QjtJQUN6RSxJQUFJO1FBQ0Y3RCxrRUFBZUEsQ0FBQzZEO0lBQ2xCLEVBQUUsT0FBT0UsT0FBTztRQUNkLElBQUl6RCw2REFBYUEsQ0FBQ3lELE9BQU94RCwrRkFBbURBLEdBQUc7WUFDN0UsTUFBTSxJQUFJQyx1REFBV0EsQ0FDbkJDLHlIQUE2RUEsRUFDN0VzRCxNQUFNQyxPQUFPO1FBRWpCO1FBQ0EsSUFBSTFELDZEQUFhQSxDQUFDeUQsT0FBT3JELHdGQUE0Q0EsR0FBRztZQUN0RSxNQUFNLElBQUlGLHVEQUFXQSxDQUNuQkcsa0hBQXNFQSxFQUN0RW9ELE1BQU1DLE9BQU87UUFFakI7UUFDQSxNQUFNRDtJQUNSO0FBQ0Y7QUFDQSxTQUFTRSxpQ0FBaUNKLHlCQUF5QjtJQUNqRUMseUNBQXlDRDtJQUN6QyxPQUFPQTtBQUNUO0FBQ0EsU0FBU0s7SUFDUCxPQUFPckMscUVBQWdCQSxDQUNyQjVCLG9FQUFpQkEsSUFDakIsQ0FBQzRELDRCQUE4QkksaUNBQWlDSjtBQUVwRTtBQUNBLFNBQVNNO0lBQ1AsT0FBT2pFLG9FQUFpQkE7QUFDMUI7QUFDQSxTQUFTa0U7SUFDUCxPQUFPdEMsaUVBQVlBLENBQUNvQyw4Q0FBOENDO0FBQ3BFO0FBQ0EsSUFBSUUsd0NBQXdDLElBQUlDLFdBQVc7SUFDekQ7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDRDtBQUNELFNBQVNDO0lBQ1AsT0FBT3hCLGtGQUFrQkEsQ0FBQ3NCO0FBQzVCO0FBQ0EsU0FBU0c7SUFDUCxPQUFPckIsa0ZBQWtCQSxDQUFDa0I7QUFDNUI7QUFFQSxnQ0FBZ0M7QUFDaEMsU0FBU0ksZ0NBQWdDLEdBQUdDLE1BQU07SUFDaEQsT0FBTzdCLHNGQUFzQkEsQ0FBQ0wsZ0ZBQWdCQSxDQUFDa0MsU0FBUztRQUFDSDtLQUF5QztBQUNwRztBQUNBLFNBQVNJLGdDQUFnQyxHQUFHRCxNQUFNO0lBQ2hELE9BQU94QixzRkFBc0JBLENBQUNaLGdGQUFnQkEsQ0FBQ29DLFNBQVM7UUFBQ0Y7S0FBeUM7QUFDcEc7QUFDQSxTQUFTSSxzQkFBc0JDLFlBQVk7SUFDekMsT0FBTyxDQUFDQztRQUNOLElBQUlBLFVBQVUsR0FBRztZQUNmLE1BQU0sSUFBSXRFLHVEQUFXQSxDQUFDYyx3R0FBNERBLEVBQUU7Z0JBQ2xGeUQsb0JBQW9CRDtZQUN0QjtRQUNGO1FBQ0EsSUFBSUQsZ0JBQWdCLFFBQVFDLFlBQVlELGNBQWM7WUFDcEQsTUFBTSxJQUFJckUsdURBQVdBLENBQUNvQiw4RkFBa0RBLEVBQUU7Z0JBQ3hFb0QsZUFBZUY7Z0JBQ2ZHLGlCQUFpQko7WUFDbkI7UUFDRjtRQUNBLE9BQU9DO0lBQ1Q7QUFDRjtBQUNBLFNBQVNJLHFDQUFxQ0osT0FBTyxFQUFFLEdBQUdKLE1BQU07SUFDOUQsT0FBT0QsZ0NBQ0w7UUFBQztRQUFXMUMscUVBQWdCQSxDQUFDcUIsb0VBQVlBLElBQUl3QixzQkFBc0JFO0tBQVUsS0FDMUVKO0FBRVA7QUFDQSxTQUFTUyxxQ0FBcUNMLE9BQU8sRUFBRSxHQUFHSixNQUFNO0lBQzlELE9BQU9DLGdDQUNMO1FBQUM7UUFBVzlDLHFFQUFnQkEsQ0FBQ3dCLG9FQUFZQSxJQUFJdUIsc0JBQXNCRTtLQUFVLEtBQzFFSjtBQUVQO0FBQ0EsU0FBU1UsaUNBQWlDQyxLQUFLO0lBQzdDLE1BQU0sRUFBRVAsT0FBTyxFQUFFUSxpQkFBaUIsRUFBRSxHQUFHYixnQ0FDckM7UUFBQztRQUFXMUMscUVBQWdCQSxDQUFDcUIsb0VBQVlBLElBQUl3QjtLQUF5QixFQUN0RTtRQUFDO1FBQXFCbEMsK0VBQWVBO0tBQUcsRUFDeEM2QyxNQUFNLENBQUNGO0lBQ1QsT0FBT2hELGtFQUFhQSxDQUNsQk4scUVBQWdCQSxDQUFDVSwrRUFBZUEsQ0FBQ3ZDLG9FQUFpQkEsSUFBSTtRQUFFc0YsTUFBTXBDLG9FQUFZQTtJQUFHLElBQUksQ0FBQ3FDO1FBQ2hGLElBQUlBLG1CQUFtQkMsTUFBTSxLQUFLLEdBQUc7WUFDbkMsTUFBTSxJQUFJbEYsdURBQVdBLENBQUNPLCtHQUFtRUE7UUFDM0Y7UUFDQSxPQUFPMEU7SUFDVCxJQUNBO1FBQ0VFLFdBQVcsQ0FBQyxFQUFFQSxTQUFTLEVBQUUsR0FBS0EsWUFBYWIsQ0FBQUEsWUFBWSxJQUFJLEtBQUssSUFBSTtJQUN0RSxHQUNBUyxNQUFNLENBQUNEO0FBQ1g7QUFDQSxTQUFTTTtJQUNQLE9BQU8sQ0FBQ0MsR0FBR0M7UUFDVCxJQUFJRCxFQUFFSCxNQUFNLEtBQUtJLEVBQUVKLE1BQU0sRUFBRTtZQUN6QixPQUFPRyxFQUFFSCxNQUFNLEdBQUdJLEVBQUVKLE1BQU0sR0FBRyxDQUFDLElBQUk7UUFDcEM7UUFDQSxJQUFLLElBQUlLLEtBQUssR0FBR0EsS0FBS0YsRUFBRUgsTUFBTSxFQUFFSyxLQUFNO1lBQ3BDLElBQUlGLENBQUMsQ0FBQ0UsR0FBRyxLQUFLRCxDQUFDLENBQUNDLEdBQUcsRUFBRTtnQkFDbkI7WUFDRixPQUFPO2dCQUNMLE9BQU9GLENBQUMsQ0FBQ0UsR0FBRyxHQUFHRCxDQUFDLENBQUNDLEdBQUcsR0FBRyxDQUFDLElBQUk7WUFDOUI7UUFDRjtRQUNBLE9BQU87SUFDVDtBQUNGO0FBQ0EsU0FBU0Msc0JBQXNCQyxhQUFhO0lBQzFDLE1BQU1DLGFBQWFDLE9BQU9DLE1BQU0sQ0FBQ0g7SUFDakMsSUFBSUMsV0FBV1IsTUFBTSxLQUFLLEdBQUc7UUFDM0IsTUFBTSxJQUFJbEYsdURBQVdBLENBQUNJLGtIQUFzRUE7SUFDOUY7SUFDQSxPQUFPc0YsV0FBV0csR0FBRyxDQUFDLENBQUNDO1FBQ3JCLElBQUksQ0FBQ0EsV0FBVztZQUNkLE9BQU8sSUFBSWhDLFdBQVcsSUFBSWlDLElBQUksQ0FBQztRQUNqQztRQUNBLE9BQU9EO0lBQ1Q7QUFDRjtBQUNBLFNBQVNFO0lBQ1AsT0FBTzNFLHFFQUFnQkEsQ0FDckJpQiwrRUFBZUEsQ0FBQ1YsbUVBQWNBLENBQUNHLCtFQUFlQSxJQUFJLEtBQUs7UUFBRWlELE1BQU1uQyxvRUFBWUE7SUFBRyxJQUM5RTJDO0FBRUo7QUFFQSx5QkFBeUI7QUFDekIsU0FBU1M7SUFDUCxPQUFPNUUscUVBQWdCQSxDQUNyQlMsZ0ZBQWdCQSxDQUFDO1FBQ2Y7WUFBQztZQUFja0U7U0FBdUI7UUFDdEM7WUFBQztZQUFXakUsK0VBQWVBO1NBQUc7S0FDL0IsR0FDRCxDQUFDbUU7UUFDQyxNQUFNQyx5QkFBeUJSLE9BQU9TLElBQUksQ0FBQ0YsU0FBU1IsVUFBVSxFQUFFRyxHQUFHLENBQUNsRyxzREFBT0E7UUFDM0UsSUFBSXdHLHVCQUF1QmpCLE1BQU0sS0FBSyxHQUFHO1lBQ3ZDLE1BQU0sSUFBSWxGLHVEQUFXQSxDQUFDSSxrSEFBc0VBO1FBQzlGO1FBQ0EsTUFBTTZFLHFCQUFxQm9CLDRDQUE0Q0gsU0FBU0ksT0FBTztRQUN2RixNQUFNQyx5QkFBeUIsRUFBRTtRQUNqQyxNQUFNQyxvQkFBb0IsRUFBRTtRQUM1QixLQUFLLE1BQU1DLFlBQVl4QixtQkFBb0I7WUFDekMsSUFBSSxDQUFDa0IsdUJBQXVCTyxRQUFRLENBQUNELFdBQVc7Z0JBQzlDRix1QkFBdUJJLElBQUksQ0FBQ0Y7WUFDOUI7UUFDRjtRQUNBLEtBQUssTUFBTUEsWUFBWU4sdUJBQXdCO1lBQzdDLElBQUksQ0FBQ2xCLG1CQUFtQnlCLFFBQVEsQ0FBQ0QsV0FBVztnQkFDMUNELGtCQUFrQkcsSUFBSSxDQUFDRjtZQUN6QjtRQUNGO1FBQ0EsSUFBSUYsdUJBQXVCckIsTUFBTSxJQUFJc0Isa0JBQWtCdEIsTUFBTSxFQUFFO1lBQzdELE1BQU0sSUFBSWxGLHVEQUFXQSxDQUFDSyxxR0FBeURBLEVBQUU7Z0JBQy9Fa0c7Z0JBQ0FDO1lBQ0Y7UUFDRjtRQUNBLE1BQU1JLHNCQUFzQixDQUFDO1FBQzdCLEtBQUssTUFBTUgsWUFBWXhCLG1CQUFvQjtZQUN6QzJCLG1CQUFtQixDQUFDSCxTQUFTLEdBQUdQLFNBQVNSLFVBQVUsQ0FBQ2UsU0FBUztRQUMvRDtRQUNBLE9BQU87WUFDTCxHQUFHUCxRQUFRO1lBQ1hSLFlBQVlrQjtRQUNkO0lBQ0Y7QUFFSjtBQUNBLFNBQVNDO0lBQ1AsT0FBT3RGLHFFQUFnQkEsQ0FDckJTLGdGQUFnQkEsQ0FBQztRQUNmO1lBQUM7WUFBY0MsK0VBQWVBLENBQUNULG1FQUFjQSxDQUFDVSwrRUFBZUEsSUFBSSxLQUFLO2dCQUFFOEMsTUFBTXBDLG9FQUFZQTtZQUFHO1NBQUc7UUFDaEc7WUFBQztZQUFXViwrRUFBZUE7U0FBRztLQUMvQixHQUNENEU7QUFFSjtBQUNBLFNBQVNDO0lBQ1AsT0FBT3pGLGlFQUFZQSxDQUFDMkUscUNBQXFDWTtBQUMzRDtBQUNBLFNBQVNDLDhDQUE4Q0UsdUJBQXVCO0lBQzVFLE1BQU0sRUFBRVYsT0FBTyxFQUFFWixVQUFVLEVBQUUsR0FBR3NCO0lBQ2hDLElBQUl0QixXQUFXUixNQUFNLEtBQUssR0FBRztRQUMzQixNQUFNLElBQUlsRix1REFBV0EsQ0FBQ0ksa0hBQXNFQTtJQUM5RjtJQUNBLE1BQU02RSxxQkFBcUJvQiw0Q0FBNENDO0lBQ3ZFLElBQUlyQixtQkFBbUJDLE1BQU0sS0FBS1EsV0FBV1IsTUFBTSxFQUFFO1FBQ25ELE1BQU0sSUFBSWxGLHVEQUFXQSxDQUFDTSxtR0FBdURBLEVBQUU7WUFDN0UyRyx1QkFBdUJoQyxtQkFBbUJDLE1BQU07WUFDaEREO1lBQ0FpQyxrQkFBa0J4QixXQUFXUixNQUFNO1FBQ3JDO0lBQ0Y7SUFDQSxNQUFNTyxnQkFBZ0IsQ0FBQztJQUN2QlIsbUJBQW1Ca0MsT0FBTyxDQUFDLENBQUNWLFVBQVVXO1FBQ3BDLE1BQU1DLHNCQUFzQjNCLFVBQVUsQ0FBQzBCLE1BQU07UUFDN0MsSUFBSUMsb0JBQW9CQyxLQUFLLENBQUMsQ0FBQ0MsSUFBTUEsTUFBTSxJQUFJO1lBQzdDOUIsYUFBYSxDQUFDZ0IsU0FBUyxHQUFHO1FBQzVCLE9BQU87WUFDTGhCLGFBQWEsQ0FBQ2dCLFNBQVMsR0FBR1k7UUFDNUI7SUFDRjtJQUNBLE9BQU8xQixPQUFPNkIsTUFBTSxDQUFDO1FBQ25CbEI7UUFDQVosWUFBWUMsT0FBTzZCLE1BQU0sQ0FBQy9CO0lBQzVCO0FBQ0Y7QUFDQSxTQUFTWSw0Q0FBNEN4QixLQUFLO0lBQ3hELE1BQU1JLHFCQUFxQkwsaUNBQWlDQztJQUM1RCxJQUFJSSxtQkFBbUJDLE1BQU0sS0FBSyxHQUFHO1FBQ25DLE1BQU0sSUFBSWxGLHVEQUFXQSxDQUFDTywrR0FBbUVBO0lBQzNGO0lBQ0EsT0FBTzBFO0FBQ1Q7QUFDQSxJQUFJd0MsaUJBQ0Ysa0NBQWtDO0FBQ2xDO0FBRUYsSUFBSUMsMENBQ0Ysd0VBQXdFO0FBQ3hFO0FBRUYsSUFBSUMsK0JBQStDLGFBQUgsR0FBSSxFQUFDQztJQUNuREEsNkJBQTZCLENBQUNBLDZCQUE2QixDQUFDLGtDQUFrQyxHQUFHLEVBQUUsR0FBRztJQUN0R0EsNkJBQTZCLENBQUNBLDZCQUE2QixDQUFDLHNCQUFzQixHQUFHLEVBQUUsR0FBRztJQUMxRkEsNkJBQTZCLENBQUNBLDZCQUE2QixDQUFDLHVCQUF1QixHQUFHLEVBQUUsR0FBRztJQUMzRixPQUFPQTtBQUNULEdBQUdELGdDQUFnQyxDQUFDO0FBQ3BDLFNBQVNFLDREQUE0REMsZUFBZTtJQUNsRixJQUFJQSxnQkFBZ0JDLE1BQU0sS0FBSyxFQUFFLG1DQUFtQyxLQUFJO1FBQ3RFLE1BQU0sSUFBSS9ILHVEQUFXQSxDQUFDUSxtR0FBdURBLEVBQUU7WUFDN0V3SCxxQkFBcUJGLGdCQUFnQkMsTUFBTTtZQUMzQ0UsdUJBQXVCLEVBQUUsbUNBQW1DO1FBQzlEO0lBQ0Y7SUFDQSxJQUFJSCxnQkFBZ0JJLElBQUksQ0FBQ2hELE1BQU0sS0FBSyxHQUFHO1FBQ3JDLE1BQU0sSUFBSWxGLHVEQUFXQSxDQUFDUyxxR0FBeURBO0lBQ2pGO0lBQ0EsSUFBSTBILHNCQUFzQkwsZ0JBQWdCSSxJQUFJLE1BQU0sT0FBTztRQUN6RCxNQUFNLElBQUlsSSx1REFBV0EsQ0FBQ1Usd0hBQTRFQTtJQUNwRztJQUNBLE1BQU13RSxTQUFTbEMsc0VBQWNBLEdBQUdvRixnQkFBZ0IsQ0FBQ04sZ0JBQWdCSSxJQUFJO0lBQ3JFLElBQUloRCxTQUFTd0MseUNBQXlDO1FBQ3BELE1BQU0sSUFBSTFILHVEQUFXQSxDQUFDVyxtR0FBdURBLEVBQUU7WUFDN0UwSCxhQUFhbkQ7WUFDYm9ELFVBQVVaO1FBQ1o7SUFDRjtBQUNGO0FBQ0EsU0FBU2Esc0RBQXNEVCxlQUFlO0lBQzVFLElBQUlBLGdCQUFnQkMsTUFBTSxLQUFLLEVBQUUsbUNBQW1DLE9BQU1ELGdCQUFnQkksSUFBSSxDQUFDaEQsTUFBTSxLQUFLLEtBQUtpRCxzQkFBc0JMLGdCQUFnQkksSUFBSSxNQUFNLE9BQU87UUFDcEssT0FBTztJQUNUO0lBQ0EsTUFBTWhELFNBQVNsQyxzRUFBY0EsR0FBR29GLGdCQUFnQixDQUFDTixnQkFBZ0JJLElBQUk7SUFDckUsT0FBT2hELFVBQVV3QztBQUNuQjtBQUNBLFNBQVNjLG9EQUFvRE4sSUFBSTtJQUMvRCxNQUFNSixrQkFBa0JuQyxPQUFPNkIsTUFBTSxDQUFDO1FBQ3BDTyxRQUFRLEVBQUUsbUNBQW1DO1FBQzdDRztJQUNGO0lBQ0FMLDREQUE0REM7SUFDNUQsT0FBT0E7QUFDVDtBQUNBLFNBQVNXLGlEQUFpRFgsZUFBZTtJQUN2RSxJQUFJQSxnQkFBZ0JJLElBQUksQ0FBQ2hELE1BQU0sS0FBSyxHQUFHO1FBQ3JDLE1BQU0sSUFBSWxGLHVEQUFXQSxDQUFDUyxxR0FBeURBO0lBQ2pGO0lBQ0EsSUFBSXFILGdCQUFnQkMsTUFBTSxLQUFLLEVBQUUsdUJBQXVCLEtBQUk7UUFDMUQsTUFBTSxJQUFJL0gsdURBQVdBLENBQUNRLG1HQUF1REEsRUFBRTtZQUM3RXdILHFCQUFxQkYsZ0JBQWdCQyxNQUFNO1lBQzNDRSx1QkFBdUIsRUFBRSx1QkFBdUI7UUFDbEQ7SUFDRjtJQUNBLE1BQU0vQyxTQUFTbEMsc0VBQWNBLEdBQUdvRixnQkFBZ0IsQ0FBQ04sZ0JBQWdCSSxJQUFJO0lBQ3JFLElBQUloRCxTQUFTd0MseUNBQXlDO1FBQ3BELE1BQU0sSUFBSTFILHVEQUFXQSxDQUFDVyxtR0FBdURBLEVBQUU7WUFDN0UwSCxhQUFhbkQ7WUFDYm9ELFVBQVVaO1FBQ1o7SUFDRjtBQUNGO0FBQ0EsU0FBU2dCLDJDQUEyQ1osZUFBZTtJQUNqRSxJQUFJQSxnQkFBZ0JDLE1BQU0sS0FBSyxFQUFFLHVCQUF1QixPQUFNRCxnQkFBZ0JJLElBQUksQ0FBQ2hELE1BQU0sS0FBSyxHQUFHO1FBQy9GLE9BQU87SUFDVDtJQUNBLE1BQU1BLFNBQVNsQyxzRUFBY0EsR0FBR29GLGdCQUFnQixDQUFDTixnQkFBZ0JJLElBQUk7SUFDckUsT0FBT2hELFVBQVV3QztBQUNuQjtBQUNBLFNBQVNpQix5Q0FBeUNULElBQUk7SUFDcEQsTUFBTUosa0JBQWtCbkMsT0FBTzZCLE1BQU0sQ0FBQztRQUNwQ08sUUFBUSxFQUFFLHVCQUF1QjtRQUNqQ0c7SUFDRjtJQUNBTyxpREFBaURYO0lBQ2pELE9BQU9BO0FBQ1Q7QUFDQSxTQUFTYyxrREFBa0RkLGVBQWU7SUFDeEUsSUFBSUEsZ0JBQWdCQyxNQUFNLEtBQUssRUFBRSx3QkFBd0IsS0FBSTtRQUMzRCxNQUFNLElBQUkvSCx1REFBV0EsQ0FBQ1EsbUdBQXVEQSxFQUFFO1lBQzdFd0gscUJBQXFCRixnQkFBZ0JDLE1BQU07WUFDM0NFLHVCQUF1QixFQUFFLHdCQUF3QjtRQUNuRDtJQUNGO0lBQ0EsSUFBSUgsZ0JBQWdCSSxJQUFJLENBQUNoRCxNQUFNLEtBQUssR0FBRztRQUNyQyxNQUFNLElBQUlsRix1REFBV0EsQ0FBQ1MscUdBQXlEQTtJQUNqRjtJQUNBLE1BQU15RSxTQUFTbEMsc0VBQWNBLEdBQUdvRixnQkFBZ0IsQ0FBQ04sZ0JBQWdCSSxJQUFJO0lBQ3JFLElBQUloRCxTQUFTdUMsZ0JBQWdCO1FBQzNCLE1BQU0sSUFBSXpILHVEQUFXQSxDQUFDVyxtR0FBdURBLEVBQUU7WUFDN0UwSCxhQUFhbkQ7WUFDYm9ELFVBQVViO1FBQ1o7SUFDRjtBQUNGO0FBQ0EsU0FBU29CLDRDQUE0Q2YsZUFBZTtJQUNsRSxJQUFJQSxnQkFBZ0JDLE1BQU0sS0FBSyxFQUFFLHdCQUF3QixPQUFNRCxnQkFBZ0JJLElBQUksQ0FBQ2hELE1BQU0sS0FBSyxHQUFHO1FBQ2hHLE9BQU87SUFDVDtJQUNBLE1BQU1BLFNBQVNsQyxzRUFBY0EsR0FBR29GLGdCQUFnQixDQUFDTixnQkFBZ0JJLElBQUk7SUFDckUsT0FBT2hELFVBQVV1QztBQUNuQjtBQUNBLFNBQVNxQiwwQ0FBMENaLElBQUk7SUFDckQsTUFBTUosa0JBQWtCbkMsT0FBTzZCLE1BQU0sQ0FBQztRQUNwQ08sUUFBUSxFQUFFLHdCQUF3QjtRQUNsQ0c7SUFDRjtJQUNBVSxrREFBa0RkO0lBQ2xELE9BQU9BO0FBQ1Q7QUFDQSxTQUFTSyxzQkFBc0JZLDZCQUE2QjtJQUMxRCxPQUFPLGlCQUFpQkMsSUFBSSxDQUFDRDtBQUMvQjtBQUVBLG9CQUFvQjtBQUNwQixTQUFTRSxxREFBcURDLGVBQWU7SUFDM0VyQiw0REFBNERxQixnQkFBZ0I1QyxPQUFPO0FBQ3JGO0FBQ0EsU0FBUzZDLDBDQUEwQ0QsZUFBZTtJQUNoRVQsaURBQWlEUyxnQkFBZ0I1QyxPQUFPO0FBQzFFO0FBQ0EsU0FBUzhDLDJDQUEyQ0YsZUFBZTtJQUNqRU4sa0RBQWtETSxnQkFBZ0I1QyxPQUFPO0FBQzNFO0FBQ0EsU0FBUytDO0lBQ1AsT0FBTzdHLDhFQUFjQSxDQUFDbUYsOEJBQThCO1FBQ2xEMkIsMkJBQTJCO0lBQzdCO0FBQ0Y7QUFDQSxTQUFTQztJQUNQLE9BQU85Ryw4RUFBY0EsQ0FBQ2tGLDhCQUE4QjtRQUNsRDJCLDJCQUEyQjtJQUM3QjtBQUNGO0FBRUEsNEJBQTRCO0FBQzVCLFNBQVNFO0lBQ1AsT0FBTzlFLHFDQUNMLFdBQVcsR0FDWCxHQUNBO1FBQUM7UUFBcUJmO0tBQTZDLEVBQ25FO1FBQUM7UUFBaUIwRjtLQUF5QyxFQUMzRDtRQUNFO1FBQ0E5SCxxRUFBZ0JBLENBQUNVLCtFQUFlQSxDQUFDdkMsb0VBQWlCQSxJQUFJO1lBQUVzRixNQUFNcEMsb0VBQVlBO1FBQUcsSUFBSSxDQUFDcUM7WUFDaEYsSUFBSUEsbUJBQW1CQyxNQUFNLEtBQUssR0FBRztnQkFDbkMsTUFBTSxJQUFJbEYsdURBQVdBLENBQUNPLCtHQUFtRUE7WUFDM0Y7WUFDQSxPQUFPMEUsbUJBQW1CWSxHQUFHLENBQUMsQ0FBQ1ksV0FBYWQsT0FBTzZCLE1BQU0sQ0FBQztvQkFBRTdILFNBQVM4RztnQkFBUztRQUNoRjtLQUNELEVBQ0Q7UUFBQztRQUFpQjNELHFFQUFhQTtLQUFHO0FBRXRDO0FBQ0EsU0FBUzJHO0lBQ1AsT0FBTzlFLHFDQUNMLFdBQVcsR0FDWCxHQUNBO1FBQUM7UUFBcUJqQjtLQUE2QyxFQUNuRTtRQUFDO1FBQWlCNkY7S0FBeUMsRUFDM0Q7UUFDRTtRQUNBbEkscUVBQWdCQSxDQUNkaUIsK0VBQWVBLENBQUM3QyxvRUFBaUJBLElBQUk7WUFBRXVGLE1BQU1uQyxvRUFBWUE7UUFBRyxJQUM1RCxDQUFDb0M7WUFDQyxJQUFJQSxtQkFBbUJDLE1BQU0sS0FBSyxHQUFHO2dCQUNuQyxNQUFNLElBQUlsRix1REFBV0EsQ0FBQ08sK0dBQW1FQTtZQUMzRjtZQUNBLE9BQU8wRSxtQkFBbUJZLEdBQUcsQ0FBQyxDQUFDLEVBQUVsRyxTQUFTOEcsUUFBUSxFQUFFLEdBQUtBO1FBQzNEO0tBRUgsRUFDRDtRQUFDO1FBQWlCMUQscUVBQWFBO0tBQUc7QUFFdEM7QUFFQSwyQkFBMkI7QUFDM0IsU0FBUzJHO0lBQ1AsT0FBT25JLHFFQUFnQkEsQ0FDckJZLCtFQUFlQSxDQUFDO1FBQUNxSDtRQUF1Q3ZHLHNFQUFjQTtLQUFHLEdBQ3pFLENBQUMsQ0FBQyxFQUFFMEcsYUFBYSxFQUFFQyxhQUFhLEVBQUVDLG1CQUFtQixFQUFFLEdBQUdDLGNBQWMsRUFBRTVCLEtBQUs7UUFDN0UsTUFBTTZCLGVBQWUvRyxzRUFBY0EsR0FBR29GLGdCQUFnQixDQUFDRjtRQUN2RCxJQUFJeUIsa0JBQWtCSSxjQUFjO1lBQ2xDLE1BQU0sSUFBSS9KLHVEQUFXQSxDQUFDWSxtR0FBdURBLEVBQUU7Z0JBQzdFbUo7Z0JBQ0FDLGlCQUFpQkw7WUFDbkI7UUFDRjtRQUNBLE1BQU1NLGtCQUFrQnRFLE9BQU82QixNQUFNLENBQUM7WUFDcEMsR0FBR3NDLFlBQVk7WUFDZnhELFNBQVNYLE9BQU82QixNQUFNLENBQUM7Z0JBQ3JCTyxRQUFRNkI7Z0JBQ1IxQjtZQUNGO1lBQ0EyQixxQkFBcUJsRSxPQUFPNkIsTUFBTSxDQUFDcUM7UUFDckM7UUFDQSxPQUFRRDtZQUNOLEtBQUssRUFBRSxtQ0FBbUM7Z0JBQUk7b0JBQzVDWCxxREFBcURnQjtvQkFDckQsT0FBT0E7Z0JBQ1Q7WUFDQSxLQUFLLEVBQUUsdUJBQXVCO2dCQUFJO29CQUNoQ2QsMENBQTBDYztvQkFDMUMsT0FBT0E7Z0JBQ1Q7WUFDQSxLQUFLLEVBQUUsd0JBQXdCO2dCQUFJO29CQUNqQ2IsMkNBQTJDYTtvQkFDM0MsT0FBT0E7Z0JBQ1Q7WUFDQTtnQkFBUztvQkFDUCxNQUFNLElBQUlqSyx1REFBV0EsQ0FBQ2Esd0dBQTREQSxFQUFFO3dCQUNsRnFKLGlCQUFpQk47b0JBQ25CO2dCQUNGO1FBQ0Y7SUFDRjtBQUVKO0FBQ0EsU0FBU087SUFDUCxPQUFPOUkscUVBQWdCQSxDQUNyQmUsK0VBQWVBLENBQUM7UUFBQ3FIO1FBQXVDekcsc0VBQWNBO0tBQUcsR0FDekUsQ0FBQ2lIO1FBQ0MsTUFBTSxFQUFFM0QsT0FBTyxFQUFFLEdBQUc4RCxVQUFVLEdBQUdIO1FBQ2pDLE9BQVFBLGdCQUFnQjNELE9BQU8sQ0FBQ3lCLE1BQU07WUFDcEMsS0FBSyxFQUFFLG1DQUFtQztnQkFBSTtvQkFDNUNrQixxREFBcURnQjtvQkFDckQ7Z0JBQ0Y7WUFDQSxLQUFLLEVBQUUsdUJBQXVCO2dCQUFJO29CQUNoQ2QsMENBQTBDYztvQkFDMUM7Z0JBQ0Y7WUFDQSxLQUFLLEVBQUUsd0JBQXdCO2dCQUFJO29CQUNqQ2IsMkNBQTJDYTtvQkFDM0M7Z0JBQ0Y7WUFDQTtnQkFBUztvQkFDUCxNQUFNLElBQUlqSyx1REFBV0EsQ0FBQ2Esd0dBQTREQSxFQUFFO3dCQUNsRnFKLGlCQUFpQkQsZ0JBQWdCM0QsT0FBTztvQkFDMUM7Z0JBQ0Y7UUFDRjtRQUNBLE1BQU1xRCxnQkFBZ0IzRyxzRUFBY0EsR0FBR29GLGdCQUFnQixDQUFDOUIsUUFBUTRCLElBQUk7UUFDcEUsTUFBTW1DLG1CQUFtQjtZQUN2QixHQUFHRCxRQUFRO1lBQ1hSLGVBQWV0RCxRQUFReUIsTUFBTTtZQUM3QjRCO1FBQ0Y7UUFDQSxPQUFPO1lBQUNVO1lBQWtCL0QsUUFBUTRCLElBQUk7U0FBQztJQUN6QztBQUVKO0FBQ0EsU0FBU29DO0lBQ1AsT0FBT2hKLGlFQUFZQSxDQUFDNkksK0JBQStCVDtBQUNyRDtBQUNBLFNBQVNhO0lBQ1AsT0FBTzdGLHFDQUNMLFdBQVcsR0FDWCxHQUNBO1FBQ0U7UUFDQW5ELHFFQUFnQkEsQ0FDZFUsK0VBQWVBLENBQUNULG1FQUFjQSxDQUFDVSwrRUFBZUEsSUFBSSxLQUFLO1lBQUU4QyxNQUFNcEMsb0VBQVlBO1FBQUcsSUFDOUUsQ0FBQzRIO1lBQ0MsSUFBSUEsd0JBQXdCdEYsTUFBTSxLQUFLLEdBQUc7Z0JBQ3hDLE1BQU0sSUFBSWxGLHVEQUFXQSxDQUFDTywrR0FBbUVBO1lBQzNGO1lBQ0EsTUFBTWtLLGFBQWFyRjtZQUNuQixJQUFLLElBQUlHLEtBQUssR0FBR0EsS0FBS2lGLHdCQUF3QnRGLE1BQU0sR0FBRyxHQUFHSyxLQUFNO2dCQUM5RCxPQUFRa0YsV0FBV0QsdUJBQXVCLENBQUNqRixHQUFHLEVBQUVpRix1QkFBdUIsQ0FBQ2pGLEtBQUssRUFBRTtvQkFDN0UsS0FBSzt3QkFDSCxNQUFNLElBQUl2Rix1REFBV0EsQ0FBQ21CLHNHQUEwREE7b0JBQ2xGLEtBQUs7d0JBQ0gsTUFBTSxJQUFJbkIsdURBQVdBLENBQUNrQixzR0FBMERBO2dCQUNwRjtZQUNGO1lBQ0EsTUFBTXdKLGlCQUFpQmhMLG9FQUFpQkE7WUFDeEMsT0FBTzhLLHdCQUF3QjNFLEdBQUcsQ0FDaEMsQ0FBQzhFLGVBQWlCaEYsT0FBTzZCLE1BQU0sQ0FBQztvQkFDOUI3SCxTQUFTK0ssZUFBZTNGLE1BQU0sQ0FBQzRGO2dCQUNqQztRQUVKO0tBRUg7QUFFTDtBQUNBLFNBQVNDO0lBQ1AsT0FBT2pHLHFDQUNMLFdBQVcsR0FDWCxHQUNBO1FBQ0U7UUFDQXRELHFFQUFnQkEsQ0FDZEEscUVBQWdCQSxDQUNkaUIsK0VBQWVBLENBQUNQLCtFQUFlQSxJQUFJO1lBQUVpRCxNQUFNbkMsb0VBQVlBO1FBQUcsSUFDMUQsQ0FBQzJIO1lBQ0MsT0FBT0Esd0JBQXdCSyxRQUFRLENBQUN6RjtRQUMxQyxJQUVGLENBQUNIO1lBQ0MsSUFBSUEsbUJBQW1CQyxNQUFNLEtBQUssR0FBRztnQkFDbkMsTUFBTSxJQUFJbEYsdURBQVdBLENBQUNPLCtHQUFtRUE7WUFDM0Y7WUFDQSxNQUFNdUssa0JBQWtCLGFBQWEsR0FBRyxJQUFJQztZQUM1QyxLQUFLLE1BQU0sRUFBRXBMLFNBQVM4RyxRQUFRLEVBQUUsSUFBSXhCLG1CQUFvQjtnQkFDdEQsSUFBSTZGLGdCQUFnQkUsR0FBRyxDQUFDdkUsV0FBVztvQkFDakMsTUFBTSxJQUFJekcsdURBQVdBLENBQUNtQixzR0FBMERBO2dCQUNsRjtnQkFDQTJKLGdCQUFnQkcsR0FBRyxDQUFDeEU7WUFDdEI7WUFDQSxNQUFNeUUsaUJBQWlCekwsb0VBQWlCQTtZQUN4QyxPQUFPd0YsbUJBQW1CWSxHQUFHLENBQUMsQ0FBQyxFQUFFbEcsU0FBUzhHLFFBQVEsRUFBRSxHQUFLeUUsZUFBZUMsTUFBTSxDQUFDMUU7UUFDakY7S0FFSDtBQUVMO0FBRUEsMkJBQTJCO0FBQzNCLFNBQVMyRTtJQUNQLE9BQU83SixxRUFBZ0JBLENBQ3JCWSwrRUFBZUEsQ0FBQztRQUFDb0k7UUFBdUN0SCxzRUFBY0E7S0FBRyxHQUN6RSxDQUFDLENBQUMsRUFBRTRHLG1CQUFtQixFQUFFLEdBQUdDLGNBQWMsRUFBRTVCLEtBQUs7UUFDL0MsSUFBSUEsS0FBS2hELE1BQU0sS0FBSyxHQUFHO1lBQ3JCLE1BQU0sSUFBSWxGLHVEQUFXQSxDQUFDUyxxR0FBeURBO1FBQ2pGO1FBQ0EsT0FBT2tGLE9BQU82QixNQUFNLENBQUM7WUFDbkIsR0FBR3NDLFlBQVk7WUFDZnhELFNBQVM0QjtZQUNUMkIscUJBQXFCbEUsT0FBTzZCLE1BQU0sQ0FBQ3FDO1FBQ3JDO0lBQ0Y7QUFFSjtBQUNBLFNBQVN3QjtJQUNQLE9BQU9oSyxxRUFBZ0JBLENBQ3JCZSwrRUFBZUEsQ0FBQztRQUFDd0k7UUFBdUM1SCxzRUFBY0E7S0FBRyxHQUN6RSxDQUFDaUg7UUFDQyxNQUFNLEVBQUUzRCxPQUFPLEVBQUUsR0FBRytELGtCQUFrQixHQUFHSjtRQUN6QyxJQUFJM0QsUUFBUXBCLE1BQU0sS0FBSyxHQUFHO1lBQ3hCLE1BQU0sSUFBSWxGLHVEQUFXQSxDQUFDUyxxR0FBeURBO1FBQ2pGO1FBQ0EsT0FBTztZQUFDNEo7WUFBa0IvRDtTQUFRO0lBQ3BDO0FBRUo7QUFDQSxTQUFTZ0Y7SUFDUCxPQUFPaEssaUVBQVlBLENBQUMrSiwrQkFBK0JEO0FBQ3JEO0FBRUEsd0JBQXdCO0FBQ3hCLFNBQVNHO0lBQ1AsT0FBTzlKLGtFQUFhQSxDQUFDO1FBQ25CK0osTUFBSzNHLEtBQUssRUFBRTRHLE1BQU07WUFDaEIsTUFBTW5ILFVBQVVqQyxzRkFBc0JBLENBQUNPLG9FQUFZQSxJQUFJO2dCQUNyRCw2QkFBNkI7Z0JBQzdCbUI7YUFDRCxFQUFFZ0IsTUFBTSxDQUFDRixPQUFPNEc7WUFDakIsT0FBUW5IO2dCQUNOLEtBQUs7b0JBQ0gsT0FBT29GLDhCQUE4QjhCLElBQUksQ0FBQzNHLE9BQU80RztnQkFDbkQsS0FBSztvQkFDSCxPQUFPTCw4QkFBOEJJLElBQUksQ0FBQzNHLE9BQU80RztnQkFDbkQ7b0JBQ0UsTUFBTSxJQUFJekwsdURBQVdBLENBQUNjLHdHQUE0REEsRUFBRTt3QkFDbEZ5RCxvQkFBb0JEO29CQUN0QjtZQUNKO1FBQ0Y7SUFDRjtBQUNGO0FBQ0EsU0FBU29IO0lBQ1AsT0FBT2hLLGtFQUFhQSxDQUFDO1FBQ25CMEcsa0JBQWtCLENBQUM2QjtZQUNqQixNQUFNLEVBQUUzRixPQUFPLEVBQUUsR0FBRzJGO1lBQ3BCLE9BQVEzRjtnQkFDTixLQUFLO29CQUNILE9BQU82Riw4QkFBOEIvQixnQkFBZ0IsQ0FBQzZCO2dCQUN4RCxLQUFLO29CQUNILE9BQU9vQiw4QkFBOEJqRCxnQkFBZ0IsQ0FBQzZCO2dCQUN4RDtvQkFDRSxNQUFNLElBQUlqSyx1REFBV0EsQ0FBQ2Msd0dBQTREQSxFQUFFO3dCQUNsRnlELG9CQUFvQkQ7b0JBQ3RCO1lBQ0o7UUFDRjtRQUNBcUgsT0FBTyxDQUFDMUIsaUJBQWlCcEYsT0FBTzRHO1lBQzlCLE1BQU0sRUFBRW5ILE9BQU8sRUFBRSxHQUFHMkY7WUFDcEIsT0FBUTNGO2dCQUNOLEtBQUs7b0JBQ0gsT0FBTzZGLDhCQUE4QndCLEtBQUssQ0FBQzFCLGlCQUFpQnBGLE9BQU80RztnQkFDckUsS0FBSztvQkFDSCxPQUFPSiw4QkFBOEJNLEtBQUssQ0FBQzFCLGlCQUFpQnBGLE9BQU80RztnQkFDckU7b0JBQ0UsTUFBTSxJQUFJekwsdURBQVdBLENBQUNjLHdHQUE0REEsRUFBRTt3QkFDbEZ5RCxvQkFBb0JEO29CQUN0QjtZQUNKO1FBQ0Y7SUFDRjtBQUNGO0FBQ0EsU0FBU3NIO0lBQ1AsT0FBT3RLLGlFQUFZQSxDQUFDb0ssNkJBQTZCSDtBQUNuRDtBQUVBLHlCQUF5QjtBQUN6QixTQUFTTSwyQ0FBMkM1QixlQUFlLEVBQUU2QixPQUFPO0lBQzFFLE1BQU1DLHVCQUF1QkQsUUFBUVgsTUFBTSxDQUFDbEI7SUFDNUMsTUFBTXZFLGFBQWEsQ0FBQztJQUNwQixLQUFLLE1BQU0sRUFBRS9GLFNBQVM4RyxRQUFRLEVBQUUsSUFBSXdELGdCQUFnQkosbUJBQW1CLENBQUU7UUFDdkVuRSxVQUFVLENBQUNlLFNBQVMsR0FBRztJQUN6QjtJQUNBLE9BQU9kLE9BQU82QixNQUFNLENBQUM7UUFDbkJsQixTQUFTeUY7UUFDVHJHLFlBQVlDLE9BQU82QixNQUFNLENBQUM5QjtJQUM1QjtBQUNGO0FBRUEscUJBQXFCO0FBQ3JCLFNBQVNzRyxpQ0FBaUMvQixlQUFlO0lBQ3ZELE9BQU80QiwyQ0FBMkM1QixpQkFBaUJFO0FBQ3JFO0FBRUEscUJBQXFCO0FBQ3JCLFNBQVM4QixpQ0FBaUNoQyxlQUFlO0lBQ3ZELE9BQU80QiwyQ0FBMkM1QixpQkFBaUJvQjtBQUNyRTtBQUVBLGtCQUFrQjtBQUNsQixTQUFTYSwrQkFBK0JqQyxlQUFlO0lBQ3JELE1BQU0sRUFBRTNGLE9BQU8sRUFBRSxHQUFHMkY7SUFDcEIsT0FBUTNGO1FBQ04sS0FBSztZQUNILE9BQU8wSCxpQ0FBaUMvQjtRQUMxQyxLQUFLO1lBQ0gsT0FBT2dDLGlDQUFpQ2hDO1FBQzFDO1lBQ0UsTUFBTSxJQUFJakssdURBQVdBLENBQUNhLHdHQUE0REEsRUFBRTtnQkFDbEZxSixpQkFBaUI1RjtZQUNuQjtJQUNKO0FBQ0Y7QUFDQSxlQUFlNkgscUNBQXFDQyxRQUFRLEVBQUVwRix1QkFBdUI7SUFDbkYsSUFBSXFGO0lBQ0osSUFBSTdGO0lBQ0osTUFBTThGLDZCQUE2QjFILGlDQUFpQ29DLHdCQUF3QlYsT0FBTztJQUNuRyxNQUFNaUcsUUFBUUMsR0FBRyxDQUNmSixTQUFTdkcsR0FBRyxDQUFDLE9BQU80RztRQUNsQixNQUFNaEcsV0FBVyxNQUFNN0csMEVBQXVCQSxDQUFDNk0sUUFBUUMsU0FBUztRQUNoRSxJQUFJLENBQUNKLDJCQUEyQjVGLFFBQVEsQ0FBQ0QsV0FBVztZQUNsREQsc0JBQXNCLGFBQWEsR0FBRyxJQUFJdUU7WUFDMUN2RSxrQkFBa0J5RSxHQUFHLENBQUN4RTtZQUN0QjtRQUNGO1FBQ0EsSUFBSUQsbUJBQW1CO1lBQ3JCO1FBQ0Y7UUFDQSxNQUFNbUcsb0JBQW9CM0Ysd0JBQXdCdEIsVUFBVSxDQUFDZSxTQUFTO1FBQ3RFLE1BQU1tRyxlQUFlLE1BQU0xSix1REFBU0EsQ0FBQ3VKLFFBQVFJLFVBQVUsRUFBRTdGLHdCQUF3QlYsT0FBTztRQUN4RixJQUFJcUcscUJBQXFCLFFBQVFoTCwrREFBVUEsQ0FBQ2lMLGNBQWNELG9CQUFvQjtZQUM1RTtRQUNGO1FBQ0FOLGtCQUFrQixDQUFDO1FBQ25CQSxhQUFhLENBQUM1RixTQUFTLEdBQUdtRztJQUM1QjtJQUVGLElBQUlwRyxxQkFBcUJBLGtCQUFrQnhCLElBQUksR0FBRyxHQUFHO1FBQ25ELE1BQU0sSUFBSWhGLHVEQUFXQSxDQUFDZSxrSEFBc0VBLEVBQUU7WUFDNUYrTCxtQkFBbUJSO1lBQ25CUyxxQkFBcUI7bUJBQUl2RzthQUFrQjtRQUM3QztJQUNGO0lBQ0EsSUFBSSxDQUFDNkYsZUFBZTtRQUNsQixPQUFPckY7SUFDVDtJQUNBLE9BQU9yQixPQUFPNkIsTUFBTSxDQUFDO1FBQ25CLEdBQUdSLHVCQUF1QjtRQUMxQnRCLFlBQVlDLE9BQU82QixNQUFNLENBQUM7WUFDeEIsR0FBR1Isd0JBQXdCdEIsVUFBVTtZQUNyQyxHQUFHMkcsYUFBYTtRQUNsQjtJQUNGO0FBQ0Y7QUFDQSxlQUFlVyw0QkFBNEJaLFFBQVEsRUFBRXBGLHVCQUF1QjtJQUMxRSxNQUFNaUcsTUFBTSxNQUFNZCxxQ0FBcUNDLFVBQVVwRjtJQUNqRWtHLDJDQUEyQ0Q7SUFDM0N0SCxPQUFPNkIsTUFBTSxDQUFDeUY7SUFDZCxPQUFPQTtBQUNUO0FBQ0EsU0FBU0UscUNBQXFDbEQsZUFBZTtJQUMzRCxPQUFPdEUsT0FBT3lILE9BQU8sQ0FBQ25ELGdCQUFnQnZFLFVBQVUsRUFBRTRCLEtBQUssQ0FBQyxDQUFDLENBQUMrRixHQUFHQyxlQUFlLEdBQUssQ0FBQyxDQUFDQTtBQUNyRjtBQUNBLFNBQVNKLDJDQUEyQ2pELGVBQWU7SUFDakUsTUFBTXNELGNBQWMsRUFBRTtJQUN0QjVILE9BQU95SCxPQUFPLENBQUNuRCxnQkFBZ0J2RSxVQUFVLEVBQUV5QixPQUFPLENBQUMsQ0FBQyxDQUFDVixVQUFVNkcsZUFBZTtRQUM1RSxJQUFJLENBQUNBLGdCQUFnQjtZQUNuQkMsWUFBWTVHLElBQUksQ0FBQ0Y7UUFDbkI7SUFDRjtJQUNBLElBQUk4RyxZQUFZckksTUFBTSxHQUFHLEdBQUc7UUFDMUIsTUFBTSxJQUFJbEYsdURBQVdBLENBQUNnQiw4RkFBa0RBLEVBQUU7WUFDeEV3TSxXQUFXRDtRQUNiO0lBQ0Y7QUFDRjtBQUNBLGVBQWVFLDhCQUE4QnpHLHVCQUF1QjtJQUNsRSxJQUFJMEc7SUFDSixNQUFNN0Qsc0JBQXNCakYsaUNBQWlDb0Msd0JBQXdCVixPQUFPO0lBQzVGLE1BQU1pRyxRQUFRQyxHQUFHLENBQ2YzQyxvQkFBb0JoRSxHQUFHLENBQUMsT0FBT1k7UUFDN0IsTUFBTVgsWUFBWWtCLHdCQUF3QnRCLFVBQVUsQ0FBQ2UsU0FBUztRQUM5RCxJQUFJWCxhQUFhLE1BQU07WUFDckI0SCxpQkFBaUIsQ0FBQztZQUNsQkEsYUFBYUMsZ0NBQWdDLEtBQUssRUFBRTtZQUNwREQsYUFBYUMsZ0NBQWdDLENBQUNoSCxJQUFJLENBQUNGO1FBQ3JELE9BQU87WUFDTCxNQUFNaUcsWUFBWSxNQUFNN00sMEVBQXVCQSxDQUFDNEc7WUFDaEQsSUFBSSxNQUFNdEQsNkRBQWVBLENBQUN1SixXQUFXNUcsV0FBV2tCLHdCQUF3QlYsT0FBTyxHQUFHO2dCQUNoRixPQUFPO1lBQ1QsT0FBTztnQkFDTG9ILGlCQUFpQixDQUFDO2dCQUNsQkEsYUFBYUUsZ0NBQWdDLEtBQUssRUFBRTtnQkFDcERGLGFBQWFFLGdDQUFnQyxDQUFDakgsSUFBSSxDQUFDRjtZQUNyRDtRQUNGO0lBQ0Y7SUFFRixJQUFJaUgsY0FBYztRQUNoQixNQUFNLElBQUkxTix1REFBV0EsQ0FBQ2lCLDBHQUE4REEsRUFBRXlNO0lBQ3hGO0FBQ0Y7QUFFMjlDLENBQzM5Qyx1Q0FBdUM7Q0FDdkMsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xhdy13b3Jrcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL29mZmNoYWluLW1lc3NhZ2VzL2Rpc3QvaW5kZXgubm9kZS5tanM/NTU4YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc0FkZHJlc3MsIGFzc2VydElzQWRkcmVzcywgZ2V0QWRkcmVzc0VuY29kZXIsIGdldEFkZHJlc3NEZWNvZGVyLCBhZGRyZXNzLCBnZXRBZGRyZXNzRnJvbVB1YmxpY0tleSwgZ2V0UHVibGljS2V5RnJvbUFkZHJlc3MgfSBmcm9tICdAc29sYW5hL2FkZHJlc3Nlcyc7XG5pbXBvcnQgeyBpc1NvbGFuYUVycm9yLCBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fU1RSSU5HX0xFTkdUSF9PVVRfT0ZfUkFOR0UsIFNvbGFuYUVycm9yLCBTT0xBTkFfRVJST1JfX09GRkNIQUlOX01FU1NBR0VfX0FQUExJQ0FUSU9OX0RPTUFJTl9TVFJJTkdfTEVOR1RIX09VVF9PRl9SQU5HRSwgU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX0lOVkFMSURfQllURV9MRU5HVEgsIFNPTEFOQV9FUlJPUl9fT0ZGQ0hBSU5fTUVTU0FHRV9fSU5WQUxJRF9BUFBMSUNBVElPTl9ET01BSU5fQllURV9MRU5HVEgsIFNPTEFOQV9FUlJPUl9fT0ZGQ0hBSU5fTUVTU0FHRV9fTlVNX0VOVkVMT1BFX1NJR05BVFVSRVNfQ0FOTk9UX0JFX1pFUk8sIFNPTEFOQV9FUlJPUl9fT0ZGQ0hBSU5fTUVTU0FHRV9fRU5WRUxPUEVfU0lHTkVSU19NSVNNQVRDSCwgU09MQU5BX0VSUk9SX19PRkZDSEFJTl9NRVNTQUdFX19OVU1fU0lHTkFUVVJFU19NSVNNQVRDSCwgU09MQU5BX0VSUk9SX19PRkZDSEFJTl9NRVNTQUdFX19OVU1fUkVRVUlSRURfU0lHTkVSU19DQU5OT1RfQkVfWkVSTywgU09MQU5BX0VSUk9SX19PRkZDSEFJTl9NRVNTQUdFX19NRVNTQUdFX0ZPUk1BVF9NSVNNQVRDSCwgU09MQU5BX0VSUk9SX19PRkZDSEFJTl9NRVNTQUdFX19NRVNTQUdFX01VU1RfQkVfTk9OX0VNUFRZLCBTT0xBTkFfRVJST1JfX09GRkNIQUlOX01FU1NBR0VfX1JFU1RSSUNURURfQVNDSUlfQk9EWV9DSEFSQUNURVJfT1VUX09GX1JBTkdFLCBTT0xBTkFfRVJST1JfX09GRkNIQUlOX01FU1NBR0VfX01BWElNVU1fTEVOR1RIX0VYQ0VFREVELCBTT0xBTkFfRVJST1JfX09GRkNIQUlOX01FU1NBR0VfX01FU1NBR0VfTEVOR1RIX01JU01BVENILCBTT0xBTkFfRVJST1JfX0lOVkFSSUFOVF9WSU9MQVRJT05fX1NXSVRDSF9NVVNUX0JFX0VYSEFVU1RJVkUsIFNPTEFOQV9FUlJPUl9fT0ZGQ0hBSU5fTUVTU0FHRV9fVkVSU0lPTl9OVU1CRVJfTk9UX1NVUFBPUlRFRCwgU09MQU5BX0VSUk9SX19PRkZDSEFJTl9NRVNTQUdFX19BRERSRVNTRVNfQ0FOTk9UX1NJR05fT0ZGQ0hBSU5fTUVTU0FHRSwgU09MQU5BX0VSUk9SX19PRkZDSEFJTl9NRVNTQUdFX19TSUdOQVRVUkVTX01JU1NJTkcsIFNPTEFOQV9FUlJPUl9fT0ZGQ0hBSU5fTUVTU0FHRV9fU0lHTkFUVVJFX1ZFUklGSUNBVElPTl9GQUlMVVJFLCBTT0xBTkFfRVJST1JfX09GRkNIQUlOX01FU1NBR0VfX1NJR05BVE9SSUVTX01VU1RfQkVfU09SVEVELCBTT0xBTkFfRVJST1JfX09GRkNIQUlOX01FU1NBR0VfX1NJR05BVE9SSUVTX01VU1RfQkVfVU5JUVVFLCBTT0xBTkFfRVJST1JfX09GRkNIQUlOX01FU1NBR0VfX1VORVhQRUNURURfVkVSU0lPTiB9IGZyb20gJ0Bzb2xhbmEvZXJyb3JzJztcbmltcG9ydCB7IHRyYW5zZm9ybUVuY29kZXIsIGNvbWJpbmVDb2RlYywgdHJhbnNmb3JtRGVjb2RlciwgZml4RGVjb2RlclNpemUsIGNyZWF0ZURlY29kZXIsIGNyZWF0ZUVuY29kZXIsIGJ5dGVzRXF1YWwsIGZpeEVuY29kZXJTaXplLCBvZmZzZXREZWNvZGVyIH0gZnJvbSAnQHNvbGFuYS9jb2RlY3MtY29yZSc7XG5pbXBvcnQgeyBnZXRTdHJ1Y3RFbmNvZGVyLCBnZXRCeXRlc0VuY29kZXIsIGdldFN0cnVjdERlY29kZXIsIGdldEFycmF5RGVjb2RlciwgZ2V0Qnl0ZXNEZWNvZGVyLCBnZXRUdXBsZURlY29kZXIsIGdldFR1cGxlRW5jb2RlciwgZ2V0SGlkZGVuUHJlZml4RGVjb2RlciwgZ2V0QXJyYXlFbmNvZGVyLCBnZXRDb25zdGFudERlY29kZXIsIGdldEVudW1EZWNvZGVyLCBnZXRFbnVtRW5jb2RlciwgZ2V0SGlkZGVuUHJlZml4RW5jb2RlciwgZ2V0Q29uc3RhbnRFbmNvZGVyIH0gZnJvbSAnQHNvbGFuYS9jb2RlY3MtZGF0YS1zdHJ1Y3R1cmVzJztcbmltcG9ydCB7IGdldFU4RGVjb2RlciwgZ2V0VThFbmNvZGVyLCBnZXRVMTZEZWNvZGVyLCBnZXRVMTZFbmNvZGVyIH0gZnJvbSAnQHNvbGFuYS9jb2RlY3MtbnVtYmVycyc7XG5pbXBvcnQgeyBnZXRVdGY4RW5jb2RlciwgZ2V0VXRmOERlY29kZXIgfSBmcm9tICdAc29sYW5hL2NvZGVjcy1zdHJpbmdzJztcbmltcG9ydCB7IHNpZ25CeXRlcywgdmVyaWZ5U2lnbmF0dXJlIH0gZnJvbSAnQHNvbGFuYS9rZXlzJztcblxuLy8gc3JjL2FwcGxpY2F0aW9uLWRvbWFpbi50c1xuZnVuY3Rpb24gaXNPZmZjaGFpbk1lc3NhZ2VBcHBsaWNhdGlvbkRvbWFpbihwdXRhdGl2ZUFwcGxpY2F0aW9uRG9tYWluKSB7XG4gIHJldHVybiBpc0FkZHJlc3MocHV0YXRpdmVBcHBsaWNhdGlvbkRvbWFpbik7XG59XG5mdW5jdGlvbiBhc3NlcnRJc09mZmNoYWluTWVzc2FnZUFwcGxpY2F0aW9uRG9tYWluKHB1dGF0aXZlQXBwbGljYXRpb25Eb21haW4pIHtcbiAgdHJ5IHtcbiAgICBhc3NlcnRJc0FkZHJlc3MocHV0YXRpdmVBcHBsaWNhdGlvbkRvbWFpbik7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGlzU29sYW5hRXJyb3IoZXJyb3IsIFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19TVFJJTkdfTEVOR1RIX09VVF9PRl9SQU5HRSkpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihcbiAgICAgICAgU09MQU5BX0VSUk9SX19PRkZDSEFJTl9NRVNTQUdFX19BUFBMSUNBVElPTl9ET01BSU5fU1RSSU5HX0xFTkdUSF9PVVRfT0ZfUkFOR0UsXG4gICAgICAgIGVycm9yLmNvbnRleHRcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChpc1NvbGFuYUVycm9yKGVycm9yLCBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fSU5WQUxJRF9CWVRFX0xFTkdUSCkpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihcbiAgICAgICAgU09MQU5BX0VSUk9SX19PRkZDSEFJTl9NRVNTQUdFX19JTlZBTElEX0FQUExJQ0FUSU9OX0RPTUFJTl9CWVRFX0xFTkdUSCxcbiAgICAgICAgZXJyb3IuY29udGV4dFxuICAgICAgKTtcbiAgICB9XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cbmZ1bmN0aW9uIG9mZmNoYWluTWVzc2FnZUFwcGxpY2F0aW9uRG9tYWluKHB1dGF0aXZlQXBwbGljYXRpb25Eb21haW4pIHtcbiAgYXNzZXJ0SXNPZmZjaGFpbk1lc3NhZ2VBcHBsaWNhdGlvbkRvbWFpbihwdXRhdGl2ZUFwcGxpY2F0aW9uRG9tYWluKTtcbiAgcmV0dXJuIHB1dGF0aXZlQXBwbGljYXRpb25Eb21haW47XG59XG5mdW5jdGlvbiBnZXRPZmZjaGFpbk1lc3NhZ2VBcHBsaWNhdGlvbkRvbWFpbkVuY29kZXIoKSB7XG4gIHJldHVybiB0cmFuc2Zvcm1FbmNvZGVyKFxuICAgIGdldEFkZHJlc3NFbmNvZGVyKCksXG4gICAgKHB1dGF0aXZlQXBwbGljYXRpb25Eb21haW4pID0+IG9mZmNoYWluTWVzc2FnZUFwcGxpY2F0aW9uRG9tYWluKHB1dGF0aXZlQXBwbGljYXRpb25Eb21haW4pXG4gICk7XG59XG5mdW5jdGlvbiBnZXRPZmZjaGFpbk1lc3NhZ2VBcHBsaWNhdGlvbkRvbWFpbkRlY29kZXIoKSB7XG4gIHJldHVybiBnZXRBZGRyZXNzRGVjb2RlcigpO1xufVxuZnVuY3Rpb24gZ2V0T2ZmY2hhaW5NZXNzYWdlQXBwbGljYXRpb25Eb21haW5Db2RlYygpIHtcbiAgcmV0dXJuIGNvbWJpbmVDb2RlYyhnZXRPZmZjaGFpbk1lc3NhZ2VBcHBsaWNhdGlvbkRvbWFpbkVuY29kZXIoKSwgZ2V0T2ZmY2hhaW5NZXNzYWdlQXBwbGljYXRpb25Eb21haW5EZWNvZGVyKCkpO1xufVxudmFyIE9GRkNIQUlOX01FU1NBR0VfU0lHTklOR19ET01BSU5fQllURVMgPSBuZXcgVWludDhBcnJheShbXG4gIDI1NSxcbiAgMTE1LFxuICAxMTEsXG4gIDEwOCxcbiAgOTcsXG4gIDExMCxcbiAgOTcsXG4gIDMyLFxuICAxMTEsXG4gIDEwMixcbiAgMTAyLFxuICA5OSxcbiAgMTA0LFxuICA5NyxcbiAgMTA1LFxuICAxMTBcbl0pO1xuZnVuY3Rpb24gZ2V0T2ZmY2hhaW5NZXNzYWdlU2lnbmluZ0RvbWFpbkRlY29kZXIoKSB7XG4gIHJldHVybiBnZXRDb25zdGFudERlY29kZXIoT0ZGQ0hBSU5fTUVTU0FHRV9TSUdOSU5HX0RPTUFJTl9CWVRFUyk7XG59XG5mdW5jdGlvbiBnZXRPZmZjaGFpbk1lc3NhZ2VTaWduaW5nRG9tYWluRW5jb2RlcigpIHtcbiAgcmV0dXJuIGdldENvbnN0YW50RW5jb2RlcihPRkZDSEFJTl9NRVNTQUdFX1NJR05JTkdfRE9NQUlOX0JZVEVTKTtcbn1cblxuLy8gc3JjL2NvZGVjcy9wcmVhbWJsZS1jb21tb24udHNcbmZ1bmN0aW9uIGdldFNpZ25pbmdEb21haW5QcmVmaXhlZERlY29kZXIoLi4uZmllbGRzKSB7XG4gIHJldHVybiBnZXRIaWRkZW5QcmVmaXhEZWNvZGVyKGdldFN0cnVjdERlY29kZXIoZmllbGRzKSwgW2dldE9mZmNoYWluTWVzc2FnZVNpZ25pbmdEb21haW5EZWNvZGVyKCldKTtcbn1cbmZ1bmN0aW9uIGdldFNpZ25pbmdEb21haW5QcmVmaXhlZEVuY29kZXIoLi4uZmllbGRzKSB7XG4gIHJldHVybiBnZXRIaWRkZW5QcmVmaXhFbmNvZGVyKGdldFN0cnVjdEVuY29kZXIoZmllbGRzKSwgW2dldE9mZmNoYWluTWVzc2FnZVNpZ25pbmdEb21haW5FbmNvZGVyKCldKTtcbn1cbmZ1bmN0aW9uIGdldFZlcnNpb25UcmFuc2Zvcm1lcihmaXhlZFZlcnNpb24pIHtcbiAgcmV0dXJuICh2ZXJzaW9uKSA9PiB7XG4gICAgaWYgKHZlcnNpb24gPiAxKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19PRkZDSEFJTl9NRVNTQUdFX19WRVJTSU9OX05VTUJFUl9OT1RfU1VQUE9SVEVELCB7XG4gICAgICAgIHVuc3VwcG9ydGVkVmVyc2lvbjogdmVyc2lvblxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChmaXhlZFZlcnNpb24gIT0gbnVsbCAmJiB2ZXJzaW9uICE9PSBmaXhlZFZlcnNpb24pIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX09GRkNIQUlOX01FU1NBR0VfX1VORVhQRUNURURfVkVSU0lPTiwge1xuICAgICAgICBhY3R1YWxWZXJzaW9uOiB2ZXJzaW9uLFxuICAgICAgICBleHBlY3RlZFZlcnNpb246IGZpeGVkVmVyc2lvblxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB2ZXJzaW9uO1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlT2ZmY2hhaW5NZXNzYWdlUHJlYW1ibGVEZWNvZGVyKHZlcnNpb24sIC4uLmZpZWxkcykge1xuICByZXR1cm4gZ2V0U2lnbmluZ0RvbWFpblByZWZpeGVkRGVjb2RlcihcbiAgICBbXCJ2ZXJzaW9uXCIsIHRyYW5zZm9ybURlY29kZXIoZ2V0VThEZWNvZGVyKCksIGdldFZlcnNpb25UcmFuc2Zvcm1lcih2ZXJzaW9uKSldLFxuICAgIC4uLmZpZWxkc1xuICApO1xufVxuZnVuY3Rpb24gY3JlYXRlT2ZmY2hhaW5NZXNzYWdlUHJlYW1ibGVFbmNvZGVyKHZlcnNpb24sIC4uLmZpZWxkcykge1xuICByZXR1cm4gZ2V0U2lnbmluZ0RvbWFpblByZWZpeGVkRW5jb2RlcihcbiAgICBbXCJ2ZXJzaW9uXCIsIHRyYW5zZm9ybUVuY29kZXIoZ2V0VThFbmNvZGVyKCksIGdldFZlcnNpb25UcmFuc2Zvcm1lcih2ZXJzaW9uKSldLFxuICAgIC4uLmZpZWxkc1xuICApO1xufVxuZnVuY3Rpb24gZGVjb2RlUmVxdWlyZWRTaWduYXRvcnlBZGRyZXNzZXMoYnl0ZXMpIHtcbiAgY29uc3QgeyB2ZXJzaW9uLCBieXRlc0FmdGVyVmVyc2lvbiB9ID0gZ2V0U2lnbmluZ0RvbWFpblByZWZpeGVkRGVjb2RlcihcbiAgICBbXCJ2ZXJzaW9uXCIsIHRyYW5zZm9ybURlY29kZXIoZ2V0VThEZWNvZGVyKCksIGdldFZlcnNpb25UcmFuc2Zvcm1lcigpKV0sXG4gICAgW1wiYnl0ZXNBZnRlclZlcnNpb25cIiwgZ2V0Qnl0ZXNEZWNvZGVyKCldXG4gICkuZGVjb2RlKGJ5dGVzKTtcbiAgcmV0dXJuIG9mZnNldERlY29kZXIoXG4gICAgdHJhbnNmb3JtRGVjb2RlcihnZXRBcnJheURlY29kZXIoZ2V0QWRkcmVzc0RlY29kZXIoKSwgeyBzaXplOiBnZXRVOERlY29kZXIoKSB9KSwgKHNpZ25hdG9yeUFkZHJlc3NlcykgPT4ge1xuICAgICAgaWYgKHNpZ25hdG9yeUFkZHJlc3Nlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fT0ZGQ0hBSU5fTUVTU0FHRV9fTlVNX1JFUVVJUkVEX1NJR05FUlNfQ0FOTk9UX0JFX1pFUk8pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNpZ25hdG9yeUFkZHJlc3NlcztcbiAgICB9KSxcbiAgICB7XG4gICAgICBwcmVPZmZzZXQ6ICh7IHByZU9mZnNldCB9KSA9PiBwcmVPZmZzZXQgKyAodmVyc2lvbiA9PT0gMCA/IDMyICsgMSA6IDApXG4gICAgfVxuICApLmRlY29kZShieXRlc0FmdGVyVmVyc2lvbik7XG59XG5mdW5jdGlvbiBnZXRTaWduYXRvcmllc0NvbXBhcmF0b3IoKSB7XG4gIHJldHVybiAoeCwgeSkgPT4ge1xuICAgIGlmICh4Lmxlbmd0aCAhPT0geS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB4Lmxlbmd0aCA8IHkubGVuZ3RoID8gLTEgOiAxO1xuICAgIH1cbiAgICBmb3IgKGxldCBpaSA9IDA7IGlpIDwgeC5sZW5ndGg7IGlpKyspIHtcbiAgICAgIGlmICh4W2lpXSA9PT0geVtpaV0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4geFtpaV0gPCB5W2lpXSA/IC0xIDogMTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH07XG59XG5mdW5jdGlvbiBnZXRTaWduYXR1cmVzVG9FbmNvZGUoc2lnbmF0dXJlc01hcCkge1xuICBjb25zdCBzaWduYXR1cmVzID0gT2JqZWN0LnZhbHVlcyhzaWduYXR1cmVzTWFwKTtcbiAgaWYgKHNpZ25hdHVyZXMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fT0ZGQ0hBSU5fTUVTU0FHRV9fTlVNX0VOVkVMT1BFX1NJR05BVFVSRVNfQ0FOTk9UX0JFX1pFUk8pO1xuICB9XG4gIHJldHVybiBzaWduYXR1cmVzLm1hcCgoc2lnbmF0dXJlKSA9PiB7XG4gICAgaWYgKCFzaWduYXR1cmUpIHtcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSg2NCkuZmlsbCgwKTtcbiAgICB9XG4gICAgcmV0dXJuIHNpZ25hdHVyZTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRTaWduYXR1cmVzRW5jb2RlcigpIHtcbiAgcmV0dXJuIHRyYW5zZm9ybUVuY29kZXIoXG4gICAgZ2V0QXJyYXlFbmNvZGVyKGZpeEVuY29kZXJTaXplKGdldEJ5dGVzRW5jb2RlcigpLCA2NCksIHsgc2l6ZTogZ2V0VThFbmNvZGVyKCkgfSksXG4gICAgZ2V0U2lnbmF0dXJlc1RvRW5jb2RlXG4gICk7XG59XG5cbi8vIHNyYy9jb2RlY3MvZW52ZWxvcGUudHNcbmZ1bmN0aW9uIGdldE9mZmNoYWluTWVzc2FnZUVudmVsb3BlRW5jb2RlcigpIHtcbiAgcmV0dXJuIHRyYW5zZm9ybUVuY29kZXIoXG4gICAgZ2V0U3RydWN0RW5jb2RlcihbXG4gICAgICBbXCJzaWduYXR1cmVzXCIsIGdldFNpZ25hdHVyZXNFbmNvZGVyKCldLFxuICAgICAgW1wiY29udGVudFwiLCBnZXRCeXRlc0VuY29kZXIoKV1cbiAgICBdKSxcbiAgICAoZW52ZWxvcGUpID0+IHtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZXNNYXBBZGRyZXNzZXMgPSBPYmplY3Qua2V5cyhlbnZlbG9wZS5zaWduYXR1cmVzKS5tYXAoYWRkcmVzcyk7XG4gICAgICBpZiAoc2lnbmF0dXJlc01hcEFkZHJlc3Nlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fT0ZGQ0hBSU5fTUVTU0FHRV9fTlVNX0VOVkVMT1BFX1NJR05BVFVSRVNfQ0FOTk9UX0JFX1pFUk8pO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2lnbmF0b3J5QWRkcmVzc2VzID0gZGVjb2RlQW5kVmFsaWRhdGVSZXF1aXJlZFNpZ25hdG9yeUFkZHJlc3NlcyhlbnZlbG9wZS5jb250ZW50KTtcbiAgICAgIGNvbnN0IG1pc3NpbmdSZXF1aXJlZFNpZ25lcnMgPSBbXTtcbiAgICAgIGNvbnN0IHVuZXhwZWN0ZWRTaWduZXJzID0gW107XG4gICAgICBmb3IgKGNvbnN0IGFkZHJlc3MyIG9mIHNpZ25hdG9yeUFkZHJlc3Nlcykge1xuICAgICAgICBpZiAoIXNpZ25hdHVyZXNNYXBBZGRyZXNzZXMuaW5jbHVkZXMoYWRkcmVzczIpKSB7XG4gICAgICAgICAgbWlzc2luZ1JlcXVpcmVkU2lnbmVycy5wdXNoKGFkZHJlc3MyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBhZGRyZXNzMiBvZiBzaWduYXR1cmVzTWFwQWRkcmVzc2VzKSB7XG4gICAgICAgIGlmICghc2lnbmF0b3J5QWRkcmVzc2VzLmluY2x1ZGVzKGFkZHJlc3MyKSkge1xuICAgICAgICAgIHVuZXhwZWN0ZWRTaWduZXJzLnB1c2goYWRkcmVzczIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobWlzc2luZ1JlcXVpcmVkU2lnbmVycy5sZW5ndGggfHwgdW5leHBlY3RlZFNpZ25lcnMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX09GRkNIQUlOX01FU1NBR0VfX0VOVkVMT1BFX1NJR05FUlNfTUlTTUFUQ0gsIHtcbiAgICAgICAgICBtaXNzaW5nUmVxdWlyZWRTaWduZXJzLFxuICAgICAgICAgIHVuZXhwZWN0ZWRTaWduZXJzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3JkZXJlZFNpZ25hdHVyZU1hcCA9IHt9O1xuICAgICAgZm9yIChjb25zdCBhZGRyZXNzMiBvZiBzaWduYXRvcnlBZGRyZXNzZXMpIHtcbiAgICAgICAgb3JkZXJlZFNpZ25hdHVyZU1hcFthZGRyZXNzMl0gPSBlbnZlbG9wZS5zaWduYXR1cmVzW2FkZHJlc3MyXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmVudmVsb3BlLFxuICAgICAgICBzaWduYXR1cmVzOiBvcmRlcmVkU2lnbmF0dXJlTWFwXG4gICAgICB9O1xuICAgIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIGdldE9mZmNoYWluTWVzc2FnZUVudmVsb3BlRGVjb2RlcigpIHtcbiAgcmV0dXJuIHRyYW5zZm9ybURlY29kZXIoXG4gICAgZ2V0U3RydWN0RGVjb2RlcihbXG4gICAgICBbXCJzaWduYXR1cmVzXCIsIGdldEFycmF5RGVjb2RlcihmaXhEZWNvZGVyU2l6ZShnZXRCeXRlc0RlY29kZXIoKSwgNjQpLCB7IHNpemU6IGdldFU4RGVjb2RlcigpIH0pXSxcbiAgICAgIFtcImNvbnRlbnRcIiwgZ2V0Qnl0ZXNEZWNvZGVyKCldXG4gICAgXSksXG4gICAgZGVjb2RlUGFydGlhbGx5RGVjb2RlZE9mZmNoYWluTWVzc2FnZUVudmVsb3BlXG4gICk7XG59XG5mdW5jdGlvbiBnZXRPZmZjaGFpbk1lc3NhZ2VFbnZlbG9wZUNvZGVjKCkge1xuICByZXR1cm4gY29tYmluZUNvZGVjKGdldE9mZmNoYWluTWVzc2FnZUVudmVsb3BlRW5jb2RlcigpLCBnZXRPZmZjaGFpbk1lc3NhZ2VFbnZlbG9wZURlY29kZXIoKSk7XG59XG5mdW5jdGlvbiBkZWNvZGVQYXJ0aWFsbHlEZWNvZGVkT2ZmY2hhaW5NZXNzYWdlRW52ZWxvcGUob2ZmY2hhaW5NZXNzYWdlRW52ZWxvcGUpIHtcbiAgY29uc3QgeyBjb250ZW50LCBzaWduYXR1cmVzIH0gPSBvZmZjaGFpbk1lc3NhZ2VFbnZlbG9wZTtcbiAgaWYgKHNpZ25hdHVyZXMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fT0ZGQ0hBSU5fTUVTU0FHRV9fTlVNX0VOVkVMT1BFX1NJR05BVFVSRVNfQ0FOTk9UX0JFX1pFUk8pO1xuICB9XG4gIGNvbnN0IHNpZ25hdG9yeUFkZHJlc3NlcyA9IGRlY29kZUFuZFZhbGlkYXRlUmVxdWlyZWRTaWduYXRvcnlBZGRyZXNzZXMoY29udGVudCk7XG4gIGlmIChzaWduYXRvcnlBZGRyZXNzZXMubGVuZ3RoICE9PSBzaWduYXR1cmVzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX09GRkNIQUlOX01FU1NBR0VfX05VTV9TSUdOQVRVUkVTX01JU01BVENILCB7XG4gICAgICBudW1SZXF1aXJlZFNpZ25hdHVyZXM6IHNpZ25hdG9yeUFkZHJlc3Nlcy5sZW5ndGgsXG4gICAgICBzaWduYXRvcnlBZGRyZXNzZXMsXG4gICAgICBzaWduYXR1cmVzTGVuZ3RoOiBzaWduYXR1cmVzLmxlbmd0aFxuICAgIH0pO1xuICB9XG4gIGNvbnN0IHNpZ25hdHVyZXNNYXAgPSB7fTtcbiAgc2lnbmF0b3J5QWRkcmVzc2VzLmZvckVhY2goKGFkZHJlc3MyLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IHNpZ25hdHVyZUZvckFkZHJlc3MgPSBzaWduYXR1cmVzW2luZGV4XTtcbiAgICBpZiAoc2lnbmF0dXJlRm9yQWRkcmVzcy5ldmVyeSgoYikgPT4gYiA9PT0gMCkpIHtcbiAgICAgIHNpZ25hdHVyZXNNYXBbYWRkcmVzczJdID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc2lnbmF0dXJlc01hcFthZGRyZXNzMl0gPSBzaWduYXR1cmVGb3JBZGRyZXNzO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICBjb250ZW50LFxuICAgIHNpZ25hdHVyZXM6IE9iamVjdC5mcmVlemUoc2lnbmF0dXJlc01hcClcbiAgfSk7XG59XG5mdW5jdGlvbiBkZWNvZGVBbmRWYWxpZGF0ZVJlcXVpcmVkU2lnbmF0b3J5QWRkcmVzc2VzKGJ5dGVzKSB7XG4gIGNvbnN0IHNpZ25hdG9yeUFkZHJlc3NlcyA9IGRlY29kZVJlcXVpcmVkU2lnbmF0b3J5QWRkcmVzc2VzKGJ5dGVzKTtcbiAgaWYgKHNpZ25hdG9yeUFkZHJlc3Nlcy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19PRkZDSEFJTl9NRVNTQUdFX19OVU1fUkVRVUlSRURfU0lHTkVSU19DQU5OT1RfQkVfWkVSTyk7XG4gIH1cbiAgcmV0dXJuIHNpZ25hdG9yeUFkZHJlc3Nlcztcbn1cbnZhciBNQVhfQk9EWV9CWVRFUyA9IChcbiAgLy8gTGFyZ2VzdCAxNi1iaXQgdW5zaWduZWQgaW50ZWdlclxuICA2NTUzNVxuKTtcbnZhciBNQVhfQk9EWV9CWVRFU19IQVJEV0FSRV9XQUxMRVRfU0lHTkFCTEUgPSAoXG4gIC8vIFNwYWNlIHJlbWFpbmluZyBpbiB0aGUgbWluaW51bSBJUHY2IE1UVSBhZnRlciBuZXR3b3JrIGhlYWRlciBvdmVyaGVhZFxuICAxMjMyXG4pO1xudmFyIE9mZmNoYWluTWVzc2FnZUNvbnRlbnRGb3JtYXQgPSAvKiBAX19QVVJFX18gKi8gKChPZmZjaGFpbk1lc3NhZ2VDb250ZW50Rm9ybWF0MykgPT4ge1xuICBPZmZjaGFpbk1lc3NhZ2VDb250ZW50Rm9ybWF0M1tPZmZjaGFpbk1lc3NhZ2VDb250ZW50Rm9ybWF0M1tcIlJFU1RSSUNURURfQVNDSUlfMTIzMl9CWVRFU19NQVhcIl0gPSAwXSA9IFwiUkVTVFJJQ1RFRF9BU0NJSV8xMjMyX0JZVEVTX01BWFwiO1xuICBPZmZjaGFpbk1lc3NhZ2VDb250ZW50Rm9ybWF0M1tPZmZjaGFpbk1lc3NhZ2VDb250ZW50Rm9ybWF0M1tcIlVURjhfMTIzMl9CWVRFU19NQVhcIl0gPSAxXSA9IFwiVVRGOF8xMjMyX0JZVEVTX01BWFwiO1xuICBPZmZjaGFpbk1lc3NhZ2VDb250ZW50Rm9ybWF0M1tPZmZjaGFpbk1lc3NhZ2VDb250ZW50Rm9ybWF0M1tcIlVURjhfNjU1MzVfQllURVNfTUFYXCJdID0gMl0gPSBcIlVURjhfNjU1MzVfQllURVNfTUFYXCI7XG4gIHJldHVybiBPZmZjaGFpbk1lc3NhZ2VDb250ZW50Rm9ybWF0Mztcbn0pKE9mZmNoYWluTWVzc2FnZUNvbnRlbnRGb3JtYXQgfHwge30pO1xuZnVuY3Rpb24gYXNzZXJ0SXNPZmZjaGFpbk1lc3NhZ2VDb250ZW50UmVzdHJpY3RlZEFzY2lpT2YxMjMyQnl0ZXNNYXgocHV0YXRpdmVDb250ZW50KSB7XG4gIGlmIChwdXRhdGl2ZUNvbnRlbnQuZm9ybWF0ICE9PSAwIC8qIFJFU1RSSUNURURfQVNDSUlfMTIzMl9CWVRFU19NQVggKi8pIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19PRkZDSEFJTl9NRVNTQUdFX19NRVNTQUdFX0ZPUk1BVF9NSVNNQVRDSCwge1xuICAgICAgYWN0dWFsTWVzc2FnZUZvcm1hdDogcHV0YXRpdmVDb250ZW50LmZvcm1hdCxcbiAgICAgIGV4cGVjdGVkTWVzc2FnZUZvcm1hdDogMCAvKiBSRVNUUklDVEVEX0FTQ0lJXzEyMzJfQllURVNfTUFYICovXG4gICAgfSk7XG4gIH1cbiAgaWYgKHB1dGF0aXZlQ29udGVudC50ZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX09GRkNIQUlOX01FU1NBR0VfX01FU1NBR0VfTVVTVF9CRV9OT05fRU1QVFkpO1xuICB9XG4gIGlmIChpc1RleHRSZXN0cmljdGVkQXNjaWkocHV0YXRpdmVDb250ZW50LnRleHQpID09PSBmYWxzZSkge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX09GRkNIQUlOX01FU1NBR0VfX1JFU1RSSUNURURfQVNDSUlfQk9EWV9DSEFSQUNURVJfT1VUX09GX1JBTkdFKTtcbiAgfVxuICBjb25zdCBsZW5ndGggPSBnZXRVdGY4RW5jb2RlcigpLmdldFNpemVGcm9tVmFsdWUocHV0YXRpdmVDb250ZW50LnRleHQpO1xuICBpZiAobGVuZ3RoID4gTUFYX0JPRFlfQllURVNfSEFSRFdBUkVfV0FMTEVUX1NJR05BQkxFKSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fT0ZGQ0hBSU5fTUVTU0FHRV9fTUFYSU1VTV9MRU5HVEhfRVhDRUVERUQsIHtcbiAgICAgIGFjdHVhbEJ5dGVzOiBsZW5ndGgsXG4gICAgICBtYXhCeXRlczogTUFYX0JPRFlfQllURVNfSEFSRFdBUkVfV0FMTEVUX1NJR05BQkxFXG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzT2ZmY2hhaW5NZXNzYWdlQ29udGVudFJlc3RyaWN0ZWRBc2NpaU9mMTIzMkJ5dGVzTWF4KHB1dGF0aXZlQ29udGVudCkge1xuICBpZiAocHV0YXRpdmVDb250ZW50LmZvcm1hdCAhPT0gMCAvKiBSRVNUUklDVEVEX0FTQ0lJXzEyMzJfQllURVNfTUFYICovIHx8IHB1dGF0aXZlQ29udGVudC50ZXh0Lmxlbmd0aCA9PT0gMCB8fCBpc1RleHRSZXN0cmljdGVkQXNjaWkocHV0YXRpdmVDb250ZW50LnRleHQpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBsZW5ndGggPSBnZXRVdGY4RW5jb2RlcigpLmdldFNpemVGcm9tVmFsdWUocHV0YXRpdmVDb250ZW50LnRleHQpO1xuICByZXR1cm4gbGVuZ3RoIDw9IE1BWF9CT0RZX0JZVEVTX0hBUkRXQVJFX1dBTExFVF9TSUdOQUJMRTtcbn1cbmZ1bmN0aW9uIG9mZmNoYWluTWVzc2FnZUNvbnRlbnRSZXN0cmljdGVkQXNjaWlPZjEyMzJCeXRlc01heCh0ZXh0KSB7XG4gIGNvbnN0IHB1dGF0aXZlQ29udGVudCA9IE9iamVjdC5mcmVlemUoe1xuICAgIGZvcm1hdDogMCAvKiBSRVNUUklDVEVEX0FTQ0lJXzEyMzJfQllURVNfTUFYICovLFxuICAgIHRleHRcbiAgfSk7XG4gIGFzc2VydElzT2ZmY2hhaW5NZXNzYWdlQ29udGVudFJlc3RyaWN0ZWRBc2NpaU9mMTIzMkJ5dGVzTWF4KHB1dGF0aXZlQ29udGVudCk7XG4gIHJldHVybiBwdXRhdGl2ZUNvbnRlbnQ7XG59XG5mdW5jdGlvbiBhc3NlcnRJc09mZmNoYWluTWVzc2FnZUNvbnRlbnRVdGY4T2YxMjMyQnl0ZXNNYXgocHV0YXRpdmVDb250ZW50KSB7XG4gIGlmIChwdXRhdGl2ZUNvbnRlbnQudGV4dC5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19PRkZDSEFJTl9NRVNTQUdFX19NRVNTQUdFX01VU1RfQkVfTk9OX0VNUFRZKTtcbiAgfVxuICBpZiAocHV0YXRpdmVDb250ZW50LmZvcm1hdCAhPT0gMSAvKiBVVEY4XzEyMzJfQllURVNfTUFYICovKSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fT0ZGQ0hBSU5fTUVTU0FHRV9fTUVTU0FHRV9GT1JNQVRfTUlTTUFUQ0gsIHtcbiAgICAgIGFjdHVhbE1lc3NhZ2VGb3JtYXQ6IHB1dGF0aXZlQ29udGVudC5mb3JtYXQsXG4gICAgICBleHBlY3RlZE1lc3NhZ2VGb3JtYXQ6IDEgLyogVVRGOF8xMjMyX0JZVEVTX01BWCAqL1xuICAgIH0pO1xuICB9XG4gIGNvbnN0IGxlbmd0aCA9IGdldFV0ZjhFbmNvZGVyKCkuZ2V0U2l6ZUZyb21WYWx1ZShwdXRhdGl2ZUNvbnRlbnQudGV4dCk7XG4gIGlmIChsZW5ndGggPiBNQVhfQk9EWV9CWVRFU19IQVJEV0FSRV9XQUxMRVRfU0lHTkFCTEUpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19PRkZDSEFJTl9NRVNTQUdFX19NQVhJTVVNX0xFTkdUSF9FWENFRURFRCwge1xuICAgICAgYWN0dWFsQnl0ZXM6IGxlbmd0aCxcbiAgICAgIG1heEJ5dGVzOiBNQVhfQk9EWV9CWVRFU19IQVJEV0FSRV9XQUxMRVRfU0lHTkFCTEVcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gaXNPZmZjaGFpbk1lc3NhZ2VDb250ZW50VXRmOE9mMTIzMkJ5dGVzTWF4KHB1dGF0aXZlQ29udGVudCkge1xuICBpZiAocHV0YXRpdmVDb250ZW50LmZvcm1hdCAhPT0gMSAvKiBVVEY4XzEyMzJfQllURVNfTUFYICovIHx8IHB1dGF0aXZlQ29udGVudC50ZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBsZW5ndGggPSBnZXRVdGY4RW5jb2RlcigpLmdldFNpemVGcm9tVmFsdWUocHV0YXRpdmVDb250ZW50LnRleHQpO1xuICByZXR1cm4gbGVuZ3RoIDw9IE1BWF9CT0RZX0JZVEVTX0hBUkRXQVJFX1dBTExFVF9TSUdOQUJMRTtcbn1cbmZ1bmN0aW9uIG9mZmNoYWluTWVzc2FnZUNvbnRlbnRVdGY4T2YxMjMyQnl0ZXNNYXgodGV4dCkge1xuICBjb25zdCBwdXRhdGl2ZUNvbnRlbnQgPSBPYmplY3QuZnJlZXplKHtcbiAgICBmb3JtYXQ6IDEgLyogVVRGOF8xMjMyX0JZVEVTX01BWCAqLyxcbiAgICB0ZXh0XG4gIH0pO1xuICBhc3NlcnRJc09mZmNoYWluTWVzc2FnZUNvbnRlbnRVdGY4T2YxMjMyQnl0ZXNNYXgocHV0YXRpdmVDb250ZW50KTtcbiAgcmV0dXJuIHB1dGF0aXZlQ29udGVudDtcbn1cbmZ1bmN0aW9uIGFzc2VydElzT2ZmY2hhaW5NZXNzYWdlQ29udGVudFV0ZjhPZjY1NTM1Qnl0ZXNNYXgocHV0YXRpdmVDb250ZW50KSB7XG4gIGlmIChwdXRhdGl2ZUNvbnRlbnQuZm9ybWF0ICE9PSAyIC8qIFVURjhfNjU1MzVfQllURVNfTUFYICovKSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fT0ZGQ0hBSU5fTUVTU0FHRV9fTUVTU0FHRV9GT1JNQVRfTUlTTUFUQ0gsIHtcbiAgICAgIGFjdHVhbE1lc3NhZ2VGb3JtYXQ6IHB1dGF0aXZlQ29udGVudC5mb3JtYXQsXG4gICAgICBleHBlY3RlZE1lc3NhZ2VGb3JtYXQ6IDIgLyogVVRGOF82NTUzNV9CWVRFU19NQVggKi9cbiAgICB9KTtcbiAgfVxuICBpZiAocHV0YXRpdmVDb250ZW50LnRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fT0ZGQ0hBSU5fTUVTU0FHRV9fTUVTU0FHRV9NVVNUX0JFX05PTl9FTVBUWSk7XG4gIH1cbiAgY29uc3QgbGVuZ3RoID0gZ2V0VXRmOEVuY29kZXIoKS5nZXRTaXplRnJvbVZhbHVlKHB1dGF0aXZlQ29udGVudC50ZXh0KTtcbiAgaWYgKGxlbmd0aCA+IE1BWF9CT0RZX0JZVEVTKSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fT0ZGQ0hBSU5fTUVTU0FHRV9fTUFYSU1VTV9MRU5HVEhfRVhDRUVERUQsIHtcbiAgICAgIGFjdHVhbEJ5dGVzOiBsZW5ndGgsXG4gICAgICBtYXhCeXRlczogTUFYX0JPRFlfQllURVNcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gaXNPZmZjaGFpbk1lc3NhZ2VDb250ZW50VXRmOE9mNjU1MzVCeXRlc01heChwdXRhdGl2ZUNvbnRlbnQpIHtcbiAgaWYgKHB1dGF0aXZlQ29udGVudC5mb3JtYXQgIT09IDIgLyogVVRGOF82NTUzNV9CWVRFU19NQVggKi8gfHwgcHV0YXRpdmVDb250ZW50LnRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGxlbmd0aCA9IGdldFV0ZjhFbmNvZGVyKCkuZ2V0U2l6ZUZyb21WYWx1ZShwdXRhdGl2ZUNvbnRlbnQudGV4dCk7XG4gIHJldHVybiBsZW5ndGggPD0gTUFYX0JPRFlfQllURVM7XG59XG5mdW5jdGlvbiBvZmZjaGFpbk1lc3NhZ2VDb250ZW50VXRmOE9mNjU1MzVCeXRlc01heCh0ZXh0KSB7XG4gIGNvbnN0IHB1dGF0aXZlQ29udGVudCA9IE9iamVjdC5mcmVlemUoe1xuICAgIGZvcm1hdDogMiAvKiBVVEY4XzY1NTM1X0JZVEVTX01BWCAqLyxcbiAgICB0ZXh0XG4gIH0pO1xuICBhc3NlcnRJc09mZmNoYWluTWVzc2FnZUNvbnRlbnRVdGY4T2Y2NTUzNUJ5dGVzTWF4KHB1dGF0aXZlQ29udGVudCk7XG4gIHJldHVybiBwdXRhdGl2ZUNvbnRlbnQ7XG59XG5mdW5jdGlvbiBpc1RleHRSZXN0cmljdGVkQXNjaWkocHV0YXRpdmVSZXN0cmljdGVkQXNjaWlTdHJpbmcpIHtcbiAgcmV0dXJuIC9eW1xceDIwLVxceDdlXSskLy50ZXN0KHB1dGF0aXZlUmVzdHJpY3RlZEFzY2lpU3RyaW5nKTtcbn1cblxuLy8gc3JjL21lc3NhZ2UtdjAudHNcbmZ1bmN0aW9uIGFzc2VydElzT2ZmY2hhaW5NZXNzYWdlUmVzdHJpY3RlZEFzY2lpT2YxMjMyQnl0ZXNNYXgocHV0YXRpdmVNZXNzYWdlKSB7XG4gIGFzc2VydElzT2ZmY2hhaW5NZXNzYWdlQ29udGVudFJlc3RyaWN0ZWRBc2NpaU9mMTIzMkJ5dGVzTWF4KHB1dGF0aXZlTWVzc2FnZS5jb250ZW50KTtcbn1cbmZ1bmN0aW9uIGFzc2VydElzT2ZmY2hhaW5NZXNzYWdlVXRmOE9mMTIzMkJ5dGVzTWF4KHB1dGF0aXZlTWVzc2FnZSkge1xuICBhc3NlcnRJc09mZmNoYWluTWVzc2FnZUNvbnRlbnRVdGY4T2YxMjMyQnl0ZXNNYXgocHV0YXRpdmVNZXNzYWdlLmNvbnRlbnQpO1xufVxuZnVuY3Rpb24gYXNzZXJ0SXNPZmZjaGFpbk1lc3NhZ2VVdGY4T2Y2NTUzNUJ5dGVzTWF4KHB1dGF0aXZlTWVzc2FnZSkge1xuICBhc3NlcnRJc09mZmNoYWluTWVzc2FnZUNvbnRlbnRVdGY4T2Y2NTUzNUJ5dGVzTWF4KHB1dGF0aXZlTWVzc2FnZS5jb250ZW50KTtcbn1cbmZ1bmN0aW9uIGdldE9mZmNoYWluTWVzc2FnZUNvbnRlbnRGb3JtYXREZWNvZGVyKCkge1xuICByZXR1cm4gZ2V0RW51bURlY29kZXIoT2ZmY2hhaW5NZXNzYWdlQ29udGVudEZvcm1hdCwge1xuICAgIHVzZVZhbHVlc0FzRGlzY3JpbWluYXRvcnM6IHRydWVcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRPZmZjaGFpbk1lc3NhZ2VDb250ZW50Rm9ybWF0RW5jb2RlcigpIHtcbiAgcmV0dXJuIGdldEVudW1FbmNvZGVyKE9mZmNoYWluTWVzc2FnZUNvbnRlbnRGb3JtYXQsIHtcbiAgICB1c2VWYWx1ZXNBc0Rpc2NyaW1pbmF0b3JzOiB0cnVlXG4gIH0pO1xufVxuXG4vLyBzcmMvY29kZWNzL3ByZWFtYmxlLXYwLnRzXG5mdW5jdGlvbiBnZXRPZmZjaGFpbk1lc3NhZ2VWMFByZWFtYmxlRGVjb2RlcigpIHtcbiAgcmV0dXJuIGNyZWF0ZU9mZmNoYWluTWVzc2FnZVByZWFtYmxlRGVjb2RlcihcbiAgICAvKiB2ZXJzaW9uICovXG4gICAgMCxcbiAgICBbXCJhcHBsaWNhdGlvbkRvbWFpblwiLCBnZXRPZmZjaGFpbk1lc3NhZ2VBcHBsaWNhdGlvbkRvbWFpbkRlY29kZXIoKV0sXG4gICAgW1wibWVzc2FnZUZvcm1hdFwiLCBnZXRPZmZjaGFpbk1lc3NhZ2VDb250ZW50Rm9ybWF0RGVjb2RlcigpXSxcbiAgICBbXG4gICAgICBcInJlcXVpcmVkU2lnbmF0b3JpZXNcIixcbiAgICAgIHRyYW5zZm9ybURlY29kZXIoZ2V0QXJyYXlEZWNvZGVyKGdldEFkZHJlc3NEZWNvZGVyKCksIHsgc2l6ZTogZ2V0VThEZWNvZGVyKCkgfSksIChzaWduYXRvcnlBZGRyZXNzZXMpID0+IHtcbiAgICAgICAgaWYgKHNpZ25hdG9yeUFkZHJlc3Nlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19PRkZDSEFJTl9NRVNTQUdFX19OVU1fUkVRVUlSRURfU0lHTkVSU19DQU5OT1RfQkVfWkVSTyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpZ25hdG9yeUFkZHJlc3Nlcy5tYXAoKGFkZHJlc3MyKSA9PiBPYmplY3QuZnJlZXplKHsgYWRkcmVzczogYWRkcmVzczIgfSkpO1xuICAgICAgfSlcbiAgICBdLFxuICAgIFtcIm1lc3NhZ2VMZW5ndGhcIiwgZ2V0VTE2RGVjb2RlcigpXVxuICApO1xufVxuZnVuY3Rpb24gZ2V0T2ZmY2hhaW5NZXNzYWdlVjBQcmVhbWJsZUVuY29kZXIoKSB7XG4gIHJldHVybiBjcmVhdGVPZmZjaGFpbk1lc3NhZ2VQcmVhbWJsZUVuY29kZXIoXG4gICAgLyogdmVyc2lvbiAqL1xuICAgIDAsXG4gICAgW1wiYXBwbGljYXRpb25Eb21haW5cIiwgZ2V0T2ZmY2hhaW5NZXNzYWdlQXBwbGljYXRpb25Eb21haW5FbmNvZGVyKCldLFxuICAgIFtcIm1lc3NhZ2VGb3JtYXRcIiwgZ2V0T2ZmY2hhaW5NZXNzYWdlQ29udGVudEZvcm1hdEVuY29kZXIoKV0sXG4gICAgW1xuICAgICAgXCJyZXF1aXJlZFNpZ25hdG9yaWVzXCIsXG4gICAgICB0cmFuc2Zvcm1FbmNvZGVyKFxuICAgICAgICBnZXRBcnJheUVuY29kZXIoZ2V0QWRkcmVzc0VuY29kZXIoKSwgeyBzaXplOiBnZXRVOEVuY29kZXIoKSB9KSxcbiAgICAgICAgKHNpZ25hdG9yeUFkZHJlc3NlcykgPT4ge1xuICAgICAgICAgIGlmIChzaWduYXRvcnlBZGRyZXNzZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19PRkZDSEFJTl9NRVNTQUdFX19OVU1fUkVRVUlSRURfU0lHTkVSU19DQU5OT1RfQkVfWkVSTyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzaWduYXRvcnlBZGRyZXNzZXMubWFwKCh7IGFkZHJlc3M6IGFkZHJlc3MyIH0pID0+IGFkZHJlc3MyKTtcbiAgICAgICAgfVxuICAgICAgKVxuICAgIF0sXG4gICAgW1wibWVzc2FnZUxlbmd0aFwiLCBnZXRVMTZFbmNvZGVyKCldXG4gICk7XG59XG5cbi8vIHNyYy9jb2RlY3MvbWVzc2FnZS12MC50c1xuZnVuY3Rpb24gZ2V0T2ZmY2hhaW5NZXNzYWdlVjBEZWNvZGVyKCkge1xuICByZXR1cm4gdHJhbnNmb3JtRGVjb2RlcihcbiAgICBnZXRUdXBsZURlY29kZXIoW2dldE9mZmNoYWluTWVzc2FnZVYwUHJlYW1ibGVEZWNvZGVyKCksIGdldFV0ZjhEZWNvZGVyKCldKSxcbiAgICAoW3sgbWVzc2FnZUxlbmd0aCwgbWVzc2FnZUZvcm1hdCwgcmVxdWlyZWRTaWduYXRvcmllcywgLi4ucHJlYW1ibGVSZXN0IH0sIHRleHRdKSA9PiB7XG4gICAgICBjb25zdCBhY3R1YWxMZW5ndGggPSBnZXRVdGY4RW5jb2RlcigpLmdldFNpemVGcm9tVmFsdWUodGV4dCk7XG4gICAgICBpZiAobWVzc2FnZUxlbmd0aCAhPT0gYWN0dWFsTGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX09GRkNIQUlOX01FU1NBR0VfX01FU1NBR0VfTEVOR1RIX01JU01BVENILCB7XG4gICAgICAgICAgYWN0dWFsTGVuZ3RoLFxuICAgICAgICAgIHNwZWNpZmllZExlbmd0aDogbWVzc2FnZUxlbmd0aFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9mZmNoYWluTWVzc2FnZSA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICAuLi5wcmVhbWJsZVJlc3QsXG4gICAgICAgIGNvbnRlbnQ6IE9iamVjdC5mcmVlemUoe1xuICAgICAgICAgIGZvcm1hdDogbWVzc2FnZUZvcm1hdCxcbiAgICAgICAgICB0ZXh0XG4gICAgICAgIH0pLFxuICAgICAgICByZXF1aXJlZFNpZ25hdG9yaWVzOiBPYmplY3QuZnJlZXplKHJlcXVpcmVkU2lnbmF0b3JpZXMpXG4gICAgICB9KTtcbiAgICAgIHN3aXRjaCAobWVzc2FnZUZvcm1hdCkge1xuICAgICAgICBjYXNlIDAgLyogUkVTVFJJQ1RFRF9BU0NJSV8xMjMyX0JZVEVTX01BWCAqLzoge1xuICAgICAgICAgIGFzc2VydElzT2ZmY2hhaW5NZXNzYWdlUmVzdHJpY3RlZEFzY2lpT2YxMjMyQnl0ZXNNYXgob2ZmY2hhaW5NZXNzYWdlKTtcbiAgICAgICAgICByZXR1cm4gb2ZmY2hhaW5NZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMSAvKiBVVEY4XzEyMzJfQllURVNfTUFYICovOiB7XG4gICAgICAgICAgYXNzZXJ0SXNPZmZjaGFpbk1lc3NhZ2VVdGY4T2YxMjMyQnl0ZXNNYXgob2ZmY2hhaW5NZXNzYWdlKTtcbiAgICAgICAgICByZXR1cm4gb2ZmY2hhaW5NZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMiAvKiBVVEY4XzY1NTM1X0JZVEVTX01BWCAqLzoge1xuICAgICAgICAgIGFzc2VydElzT2ZmY2hhaW5NZXNzYWdlVXRmOE9mNjU1MzVCeXRlc01heChvZmZjaGFpbk1lc3NhZ2UpO1xuICAgICAgICAgIHJldHVybiBvZmZjaGFpbk1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0lOVkFSSUFOVF9WSU9MQVRJT05fX1NXSVRDSF9NVVNUX0JFX0VYSEFVU1RJVkUsIHtcbiAgICAgICAgICAgIHVuZXhwZWN0ZWRWYWx1ZTogbWVzc2FnZUZvcm1hdFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICApO1xufVxuZnVuY3Rpb24gZ2V0T2ZmY2hhaW5NZXNzYWdlVjBFbmNvZGVyKCkge1xuICByZXR1cm4gdHJhbnNmb3JtRW5jb2RlcihcbiAgICBnZXRUdXBsZUVuY29kZXIoW2dldE9mZmNoYWluTWVzc2FnZVYwUHJlYW1ibGVFbmNvZGVyKCksIGdldFV0ZjhFbmNvZGVyKCldKSxcbiAgICAob2ZmY2hhaW5NZXNzYWdlKSA9PiB7XG4gICAgICBjb25zdCB7IGNvbnRlbnQsIC4uLnByZWFtYmxlIH0gPSBvZmZjaGFpbk1lc3NhZ2U7XG4gICAgICBzd2l0Y2ggKG9mZmNoYWluTWVzc2FnZS5jb250ZW50LmZvcm1hdCkge1xuICAgICAgICBjYXNlIDAgLyogUkVTVFJJQ1RFRF9BU0NJSV8xMjMyX0JZVEVTX01BWCAqLzoge1xuICAgICAgICAgIGFzc2VydElzT2ZmY2hhaW5NZXNzYWdlUmVzdHJpY3RlZEFzY2lpT2YxMjMyQnl0ZXNNYXgob2ZmY2hhaW5NZXNzYWdlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDEgLyogVVRGOF8xMjMyX0JZVEVTX01BWCAqLzoge1xuICAgICAgICAgIGFzc2VydElzT2ZmY2hhaW5NZXNzYWdlVXRmOE9mMTIzMkJ5dGVzTWF4KG9mZmNoYWluTWVzc2FnZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAyIC8qIFVURjhfNjU1MzVfQllURVNfTUFYICovOiB7XG4gICAgICAgICAgYXNzZXJ0SXNPZmZjaGFpbk1lc3NhZ2VVdGY4T2Y2NTUzNUJ5dGVzTWF4KG9mZmNoYWluTWVzc2FnZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0lOVkFSSUFOVF9WSU9MQVRJT05fX1NXSVRDSF9NVVNUX0JFX0VYSEFVU1RJVkUsIHtcbiAgICAgICAgICAgIHVuZXhwZWN0ZWRWYWx1ZTogb2ZmY2hhaW5NZXNzYWdlLmNvbnRlbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgbWVzc2FnZUxlbmd0aCA9IGdldFV0ZjhFbmNvZGVyKCkuZ2V0U2l6ZUZyb21WYWx1ZShjb250ZW50LnRleHQpO1xuICAgICAgY29uc3QgY29tcGlsZWRQcmVhbWJsZSA9IHtcbiAgICAgICAgLi4ucHJlYW1ibGUsXG4gICAgICAgIG1lc3NhZ2VGb3JtYXQ6IGNvbnRlbnQuZm9ybWF0LFxuICAgICAgICBtZXNzYWdlTGVuZ3RoXG4gICAgICB9O1xuICAgICAgcmV0dXJuIFtjb21waWxlZFByZWFtYmxlLCBjb250ZW50LnRleHRdO1xuICAgIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIGdldE9mZmNoYWluTWVzc2FnZVYwQ29kZWMoKSB7XG4gIHJldHVybiBjb21iaW5lQ29kZWMoZ2V0T2ZmY2hhaW5NZXNzYWdlVjBFbmNvZGVyKCksIGdldE9mZmNoYWluTWVzc2FnZVYwRGVjb2RlcigpKTtcbn1cbmZ1bmN0aW9uIGdldE9mZmNoYWluTWVzc2FnZVYxUHJlYW1ibGVEZWNvZGVyKCkge1xuICByZXR1cm4gY3JlYXRlT2ZmY2hhaW5NZXNzYWdlUHJlYW1ibGVEZWNvZGVyKFxuICAgIC8qIHZlcnNpb24gKi9cbiAgICAxLFxuICAgIFtcbiAgICAgIFwicmVxdWlyZWRTaWduYXRvcmllc1wiLFxuICAgICAgdHJhbnNmb3JtRGVjb2RlcihcbiAgICAgICAgZ2V0QXJyYXlEZWNvZGVyKGZpeERlY29kZXJTaXplKGdldEJ5dGVzRGVjb2RlcigpLCAzMiksIHsgc2l6ZTogZ2V0VThEZWNvZGVyKCkgfSksXG4gICAgICAgIChzaWduYXRvcnlBZGRyZXNzZXNCeXRlcykgPT4ge1xuICAgICAgICAgIGlmIChzaWduYXRvcnlBZGRyZXNzZXNCeXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX09GRkNIQUlOX01FU1NBR0VfX05VTV9SRVFVSVJFRF9TSUdORVJTX0NBTk5PVF9CRV9aRVJPKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgY29tcGFyYXRvciA9IGdldFNpZ25hdG9yaWVzQ29tcGFyYXRvcigpO1xuICAgICAgICAgIGZvciAobGV0IGlpID0gMDsgaWkgPCBzaWduYXRvcnlBZGRyZXNzZXNCeXRlcy5sZW5ndGggLSAxOyBpaSsrKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGNvbXBhcmF0b3Ioc2lnbmF0b3J5QWRkcmVzc2VzQnl0ZXNbaWldLCBzaWduYXRvcnlBZGRyZXNzZXNCeXRlc1tpaSArIDFdKSkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fT0ZGQ0hBSU5fTUVTU0FHRV9fU0lHTkFUT1JJRVNfTVVTVF9CRV9VTklRVUUpO1xuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fT0ZGQ0hBSU5fTUVTU0FHRV9fU0lHTkFUT1JJRVNfTVVTVF9CRV9TT1JURUQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBhZGRyZXNzRGVjb2RlciA9IGdldEFkZHJlc3NEZWNvZGVyKCk7XG4gICAgICAgICAgcmV0dXJuIHNpZ25hdG9yeUFkZHJlc3Nlc0J5dGVzLm1hcChcbiAgICAgICAgICAgIChhZGRyZXNzQnl0ZXMpID0+IE9iamVjdC5mcmVlemUoe1xuICAgICAgICAgICAgICBhZGRyZXNzOiBhZGRyZXNzRGVjb2Rlci5kZWNvZGUoYWRkcmVzc0J5dGVzKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICApXG4gICAgXVxuICApO1xufVxuZnVuY3Rpb24gZ2V0T2ZmY2hhaW5NZXNzYWdlVjFQcmVhbWJsZUVuY29kZXIoKSB7XG4gIHJldHVybiBjcmVhdGVPZmZjaGFpbk1lc3NhZ2VQcmVhbWJsZUVuY29kZXIoXG4gICAgLyogdmVyc2lvbiAqL1xuICAgIDEsXG4gICAgW1xuICAgICAgXCJyZXF1aXJlZFNpZ25hdG9yaWVzXCIsXG4gICAgICB0cmFuc2Zvcm1FbmNvZGVyKFxuICAgICAgICB0cmFuc2Zvcm1FbmNvZGVyKFxuICAgICAgICAgIGdldEFycmF5RW5jb2RlcihnZXRCeXRlc0VuY29kZXIoKSwgeyBzaXplOiBnZXRVOEVuY29kZXIoKSB9KSxcbiAgICAgICAgICAoc2lnbmF0b3J5QWRkcmVzc2VzQnl0ZXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBzaWduYXRvcnlBZGRyZXNzZXNCeXRlcy50b1NvcnRlZChnZXRTaWduYXRvcmllc0NvbXBhcmF0b3IoKSk7XG4gICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICAoc2lnbmF0b3J5QWRkcmVzc2VzKSA9PiB7XG4gICAgICAgICAgaWYgKHNpZ25hdG9yeUFkZHJlc3Nlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX09GRkNIQUlOX01FU1NBR0VfX05VTV9SRVFVSVJFRF9TSUdORVJTX0NBTk5PVF9CRV9aRVJPKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgc2VlblNpZ25hdG9yaWVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IHsgYWRkcmVzczogYWRkcmVzczIgfSBvZiBzaWduYXRvcnlBZGRyZXNzZXMpIHtcbiAgICAgICAgICAgIGlmIChzZWVuU2lnbmF0b3JpZXMuaGFzKGFkZHJlc3MyKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19PRkZDSEFJTl9NRVNTQUdFX19TSUdOQVRPUklFU19NVVNUX0JFX1VOSVFVRSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWVuU2lnbmF0b3JpZXMuYWRkKGFkZHJlc3MyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgYWRkcmVzc0VuY29kZXIgPSBnZXRBZGRyZXNzRW5jb2RlcigpO1xuICAgICAgICAgIHJldHVybiBzaWduYXRvcnlBZGRyZXNzZXMubWFwKCh7IGFkZHJlc3M6IGFkZHJlc3MyIH0pID0+IGFkZHJlc3NFbmNvZGVyLmVuY29kZShhZGRyZXNzMikpO1xuICAgICAgICB9XG4gICAgICApXG4gICAgXVxuICApO1xufVxuXG4vLyBzcmMvY29kZWNzL21lc3NhZ2UtdjEudHNcbmZ1bmN0aW9uIGdldE9mZmNoYWluTWVzc2FnZVYxRGVjb2RlcigpIHtcbiAgcmV0dXJuIHRyYW5zZm9ybURlY29kZXIoXG4gICAgZ2V0VHVwbGVEZWNvZGVyKFtnZXRPZmZjaGFpbk1lc3NhZ2VWMVByZWFtYmxlRGVjb2RlcigpLCBnZXRVdGY4RGVjb2RlcigpXSksXG4gICAgKFt7IHJlcXVpcmVkU2lnbmF0b3JpZXMsIC4uLnByZWFtYmxlUmVzdCB9LCB0ZXh0XSkgPT4ge1xuICAgICAgaWYgKHRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX09GRkNIQUlOX01FU1NBR0VfX01FU1NBR0VfTVVTVF9CRV9OT05fRU1QVFkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgICAgICAuLi5wcmVhbWJsZVJlc3QsXG4gICAgICAgIGNvbnRlbnQ6IHRleHQsXG4gICAgICAgIHJlcXVpcmVkU2lnbmF0b3JpZXM6IE9iamVjdC5mcmVlemUocmVxdWlyZWRTaWduYXRvcmllcylcbiAgICAgIH0pO1xuICAgIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIGdldE9mZmNoYWluTWVzc2FnZVYxRW5jb2RlcigpIHtcbiAgcmV0dXJuIHRyYW5zZm9ybUVuY29kZXIoXG4gICAgZ2V0VHVwbGVFbmNvZGVyKFtnZXRPZmZjaGFpbk1lc3NhZ2VWMVByZWFtYmxlRW5jb2RlcigpLCBnZXRVdGY4RW5jb2RlcigpXSksXG4gICAgKG9mZmNoYWluTWVzc2FnZSkgPT4ge1xuICAgICAgY29uc3QgeyBjb250ZW50LCAuLi5jb21waWxlZFByZWFtYmxlIH0gPSBvZmZjaGFpbk1lc3NhZ2U7XG4gICAgICBpZiAoY29udGVudC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fT0ZGQ0hBSU5fTUVTU0FHRV9fTUVTU0FHRV9NVVNUX0JFX05PTl9FTVBUWSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW2NvbXBpbGVkUHJlYW1ibGUsIGNvbnRlbnRdO1xuICAgIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIGdldE9mZmNoYWluTWVzc2FnZVYxQ29kZWMoKSB7XG4gIHJldHVybiBjb21iaW5lQ29kZWMoZ2V0T2ZmY2hhaW5NZXNzYWdlVjFFbmNvZGVyKCksIGdldE9mZmNoYWluTWVzc2FnZVYxRGVjb2RlcigpKTtcbn1cblxuLy8gc3JjL2NvZGVjcy9tZXNzYWdlLnRzXG5mdW5jdGlvbiBnZXRPZmZjaGFpbk1lc3NhZ2VEZWNvZGVyKCkge1xuICByZXR1cm4gY3JlYXRlRGVjb2Rlcih7XG4gICAgcmVhZChieXRlcywgb2Zmc2V0KSB7XG4gICAgICBjb25zdCB2ZXJzaW9uID0gZ2V0SGlkZGVuUHJlZml4RGVjb2RlcihnZXRVOERlY29kZXIoKSwgW1xuICAgICAgICAvLyBEaXNjYXJkIHRoZSBzaWduaW5nIGRvbWFpblxuICAgICAgICBnZXRPZmZjaGFpbk1lc3NhZ2VTaWduaW5nRG9tYWluRGVjb2RlcigpXG4gICAgICBdKS5kZWNvZGUoYnl0ZXMsIG9mZnNldCk7XG4gICAgICBzd2l0Y2ggKHZlcnNpb24pIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiBnZXRPZmZjaGFpbk1lc3NhZ2VWMERlY29kZXIoKS5yZWFkKGJ5dGVzLCBvZmZzZXQpO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmV0dXJuIGdldE9mZmNoYWluTWVzc2FnZVYxRGVjb2RlcigpLnJlYWQoYnl0ZXMsIG9mZnNldCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fT0ZGQ0hBSU5fTUVTU0FHRV9fVkVSU0lPTl9OVU1CRVJfTk9UX1NVUFBPUlRFRCwge1xuICAgICAgICAgICAgdW5zdXBwb3J0ZWRWZXJzaW9uOiB2ZXJzaW9uXG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGdldE9mZmNoYWluTWVzc2FnZUVuY29kZXIoKSB7XG4gIHJldHVybiBjcmVhdGVFbmNvZGVyKHtcbiAgICBnZXRTaXplRnJvbVZhbHVlOiAob2ZmY2hhaW5NZXNzYWdlKSA9PiB7XG4gICAgICBjb25zdCB7IHZlcnNpb24gfSA9IG9mZmNoYWluTWVzc2FnZTtcbiAgICAgIHN3aXRjaCAodmVyc2lvbikge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIGdldE9mZmNoYWluTWVzc2FnZVYwRW5jb2RlcigpLmdldFNpemVGcm9tVmFsdWUob2ZmY2hhaW5NZXNzYWdlKTtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJldHVybiBnZXRPZmZjaGFpbk1lc3NhZ2VWMUVuY29kZXIoKS5nZXRTaXplRnJvbVZhbHVlKG9mZmNoYWluTWVzc2FnZSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fT0ZGQ0hBSU5fTUVTU0FHRV9fVkVSU0lPTl9OVU1CRVJfTk9UX1NVUFBPUlRFRCwge1xuICAgICAgICAgICAgdW5zdXBwb3J0ZWRWZXJzaW9uOiB2ZXJzaW9uXG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB3cml0ZTogKG9mZmNoYWluTWVzc2FnZSwgYnl0ZXMsIG9mZnNldCkgPT4ge1xuICAgICAgY29uc3QgeyB2ZXJzaW9uIH0gPSBvZmZjaGFpbk1lc3NhZ2U7XG4gICAgICBzd2l0Y2ggKHZlcnNpb24pIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiBnZXRPZmZjaGFpbk1lc3NhZ2VWMEVuY29kZXIoKS53cml0ZShvZmZjaGFpbk1lc3NhZ2UsIGJ5dGVzLCBvZmZzZXQpO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmV0dXJuIGdldE9mZmNoYWluTWVzc2FnZVYxRW5jb2RlcigpLndyaXRlKG9mZmNoYWluTWVzc2FnZSwgYnl0ZXMsIG9mZnNldCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fT0ZGQ0hBSU5fTUVTU0FHRV9fVkVSU0lPTl9OVU1CRVJfTk9UX1NVUFBPUlRFRCwge1xuICAgICAgICAgICAgdW5zdXBwb3J0ZWRWZXJzaW9uOiB2ZXJzaW9uXG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGdldE9mZmNoYWluTWVzc2FnZUNvZGVjKCkge1xuICByZXR1cm4gY29tYmluZUNvZGVjKGdldE9mZmNoYWluTWVzc2FnZUVuY29kZXIoKSwgZ2V0T2ZmY2hhaW5NZXNzYWdlRGVjb2RlcigpKTtcbn1cblxuLy8gc3JjL2VudmVsb3BlLWNvbW1vbi50c1xuZnVuY3Rpb24gY29tcGlsZU9mZmNoYWluTWVzc2FnZUVudmVsb3BlVXNpbmdFbmNvZGVyKG9mZmNoYWluTWVzc2FnZSwgZW5jb2Rlcikge1xuICBjb25zdCBvZmZjaGFpbk1lc3NhZ2VCeXRlcyA9IGVuY29kZXIuZW5jb2RlKG9mZmNoYWluTWVzc2FnZSk7XG4gIGNvbnN0IHNpZ25hdHVyZXMgPSB7fTtcbiAgZm9yIChjb25zdCB7IGFkZHJlc3M6IGFkZHJlc3MyIH0gb2Ygb2ZmY2hhaW5NZXNzYWdlLnJlcXVpcmVkU2lnbmF0b3JpZXMpIHtcbiAgICBzaWduYXR1cmVzW2FkZHJlc3MyXSA9IG51bGw7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgIGNvbnRlbnQ6IG9mZmNoYWluTWVzc2FnZUJ5dGVzLFxuICAgIHNpZ25hdHVyZXM6IE9iamVjdC5mcmVlemUoc2lnbmF0dXJlcylcbiAgfSk7XG59XG5cbi8vIHNyYy9lbnZlbG9wZS12MC50c1xuZnVuY3Rpb24gY29tcGlsZU9mZmNoYWluTWVzc2FnZVYwRW52ZWxvcGUob2ZmY2hhaW5NZXNzYWdlKSB7XG4gIHJldHVybiBjb21waWxlT2ZmY2hhaW5NZXNzYWdlRW52ZWxvcGVVc2luZ0VuY29kZXIob2ZmY2hhaW5NZXNzYWdlLCBnZXRPZmZjaGFpbk1lc3NhZ2VWMEVuY29kZXIoKSk7XG59XG5cbi8vIHNyYy9lbnZlbG9wZS12MS50c1xuZnVuY3Rpb24gY29tcGlsZU9mZmNoYWluTWVzc2FnZVYxRW52ZWxvcGUob2ZmY2hhaW5NZXNzYWdlKSB7XG4gIHJldHVybiBjb21waWxlT2ZmY2hhaW5NZXNzYWdlRW52ZWxvcGVVc2luZ0VuY29kZXIob2ZmY2hhaW5NZXNzYWdlLCBnZXRPZmZjaGFpbk1lc3NhZ2VWMUVuY29kZXIoKSk7XG59XG5cbi8vIHNyYy9lbnZlbG9wZS50c1xuZnVuY3Rpb24gY29tcGlsZU9mZmNoYWluTWVzc2FnZUVudmVsb3BlKG9mZmNoYWluTWVzc2FnZSkge1xuICBjb25zdCB7IHZlcnNpb24gfSA9IG9mZmNoYWluTWVzc2FnZTtcbiAgc3dpdGNoICh2ZXJzaW9uKSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuIGNvbXBpbGVPZmZjaGFpbk1lc3NhZ2VWMEVudmVsb3BlKG9mZmNoYWluTWVzc2FnZSk7XG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIGNvbXBpbGVPZmZjaGFpbk1lc3NhZ2VWMUVudmVsb3BlKG9mZmNoYWluTWVzc2FnZSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0lOVkFSSUFOVF9WSU9MQVRJT05fX1NXSVRDSF9NVVNUX0JFX0VYSEFVU1RJVkUsIHtcbiAgICAgICAgdW5leHBlY3RlZFZhbHVlOiB2ZXJzaW9uXG4gICAgICB9KTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gcGFydGlhbGx5U2lnbk9mZmNoYWluTWVzc2FnZUVudmVsb3BlKGtleVBhaXJzLCBvZmZjaGFpbk1lc3NhZ2VFbnZlbG9wZSkge1xuICBsZXQgbmV3U2lnbmF0dXJlcztcbiAgbGV0IHVuZXhwZWN0ZWRTaWduZXJzO1xuICBjb25zdCByZXF1aXJlZFNpZ25hdG9yeUFkZHJlc3NlcyA9IGRlY29kZVJlcXVpcmVkU2lnbmF0b3J5QWRkcmVzc2VzKG9mZmNoYWluTWVzc2FnZUVudmVsb3BlLmNvbnRlbnQpO1xuICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICBrZXlQYWlycy5tYXAoYXN5bmMgKGtleVBhaXIpID0+IHtcbiAgICAgIGNvbnN0IGFkZHJlc3MyID0gYXdhaXQgZ2V0QWRkcmVzc0Zyb21QdWJsaWNLZXkoa2V5UGFpci5wdWJsaWNLZXkpO1xuICAgICAgaWYgKCFyZXF1aXJlZFNpZ25hdG9yeUFkZHJlc3Nlcy5pbmNsdWRlcyhhZGRyZXNzMikpIHtcbiAgICAgICAgdW5leHBlY3RlZFNpZ25lcnMgfHw9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICAgIHVuZXhwZWN0ZWRTaWduZXJzLmFkZChhZGRyZXNzMik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh1bmV4cGVjdGVkU2lnbmVycykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBleGlzdGluZ1NpZ25hdHVyZSA9IG9mZmNoYWluTWVzc2FnZUVudmVsb3BlLnNpZ25hdHVyZXNbYWRkcmVzczJdO1xuICAgICAgY29uc3QgbmV3U2lnbmF0dXJlID0gYXdhaXQgc2lnbkJ5dGVzKGtleVBhaXIucHJpdmF0ZUtleSwgb2ZmY2hhaW5NZXNzYWdlRW52ZWxvcGUuY29udGVudCk7XG4gICAgICBpZiAoZXhpc3RpbmdTaWduYXR1cmUgIT0gbnVsbCAmJiBieXRlc0VxdWFsKG5ld1NpZ25hdHVyZSwgZXhpc3RpbmdTaWduYXR1cmUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG5ld1NpZ25hdHVyZXMgfHw9IHt9O1xuICAgICAgbmV3U2lnbmF0dXJlc1thZGRyZXNzMl0gPSBuZXdTaWduYXR1cmU7XG4gICAgfSlcbiAgKTtcbiAgaWYgKHVuZXhwZWN0ZWRTaWduZXJzICYmIHVuZXhwZWN0ZWRTaWduZXJzLnNpemUgPiAwKSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fT0ZGQ0hBSU5fTUVTU0FHRV9fQUREUkVTU0VTX0NBTk5PVF9TSUdOX09GRkNIQUlOX01FU1NBR0UsIHtcbiAgICAgIGV4cGVjdGVkQWRkcmVzc2VzOiByZXF1aXJlZFNpZ25hdG9yeUFkZHJlc3NlcyxcbiAgICAgIHVuZXhwZWN0ZWRBZGRyZXNzZXM6IFsuLi51bmV4cGVjdGVkU2lnbmVyc11cbiAgICB9KTtcbiAgfVxuICBpZiAoIW5ld1NpZ25hdHVyZXMpIHtcbiAgICByZXR1cm4gb2ZmY2hhaW5NZXNzYWdlRW52ZWxvcGU7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgIC4uLm9mZmNoYWluTWVzc2FnZUVudmVsb3BlLFxuICAgIHNpZ25hdHVyZXM6IE9iamVjdC5mcmVlemUoe1xuICAgICAgLi4ub2ZmY2hhaW5NZXNzYWdlRW52ZWxvcGUuc2lnbmF0dXJlcyxcbiAgICAgIC4uLm5ld1NpZ25hdHVyZXNcbiAgICB9KVxuICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNpZ25PZmZjaGFpbk1lc3NhZ2VFbnZlbG9wZShrZXlQYWlycywgb2ZmY2hhaW5NZXNzYWdlRW52ZWxvcGUpIHtcbiAgY29uc3Qgb3V0ID0gYXdhaXQgcGFydGlhbGx5U2lnbk9mZmNoYWluTWVzc2FnZUVudmVsb3BlKGtleVBhaXJzLCBvZmZjaGFpbk1lc3NhZ2VFbnZlbG9wZSk7XG4gIGFzc2VydElzRnVsbHlTaWduZWRPZmZjaGFpbk1lc3NhZ2VFbnZlbG9wZShvdXQpO1xuICBPYmplY3QuZnJlZXplKG91dCk7XG4gIHJldHVybiBvdXQ7XG59XG5mdW5jdGlvbiBpc0Z1bGx5U2lnbmVkT2ZmY2hhaW5NZXNzYWdlRW52ZWxvcGUob2ZmY2hhaW5NZXNzYWdlKSB7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhvZmZjaGFpbk1lc3NhZ2Uuc2lnbmF0dXJlcykuZXZlcnkoKFtfLCBzaWduYXR1cmVCeXRlc10pID0+ICEhc2lnbmF0dXJlQnl0ZXMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0SXNGdWxseVNpZ25lZE9mZmNoYWluTWVzc2FnZUVudmVsb3BlKG9mZmNoYWluTWVzc2FnZSkge1xuICBjb25zdCBtaXNzaW5nU2lncyA9IFtdO1xuICBPYmplY3QuZW50cmllcyhvZmZjaGFpbk1lc3NhZ2Uuc2lnbmF0dXJlcykuZm9yRWFjaCgoW2FkZHJlc3MyLCBzaWduYXR1cmVCeXRlc10pID0+IHtcbiAgICBpZiAoIXNpZ25hdHVyZUJ5dGVzKSB7XG4gICAgICBtaXNzaW5nU2lncy5wdXNoKGFkZHJlc3MyKTtcbiAgICB9XG4gIH0pO1xuICBpZiAobWlzc2luZ1NpZ3MubGVuZ3RoID4gMCkge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX09GRkNIQUlOX01FU1NBR0VfX1NJR05BVFVSRVNfTUlTU0lORywge1xuICAgICAgYWRkcmVzc2VzOiBtaXNzaW5nU2lnc1xuICAgIH0pO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiB2ZXJpZnlPZmZjaGFpbk1lc3NhZ2VFbnZlbG9wZShvZmZjaGFpbk1lc3NhZ2VFbnZlbG9wZSkge1xuICBsZXQgZXJyb3JDb250ZXh0O1xuICBjb25zdCByZXF1aXJlZFNpZ25hdG9yaWVzID0gZGVjb2RlUmVxdWlyZWRTaWduYXRvcnlBZGRyZXNzZXMob2ZmY2hhaW5NZXNzYWdlRW52ZWxvcGUuY29udGVudCk7XG4gIGF3YWl0IFByb21pc2UuYWxsKFxuICAgIHJlcXVpcmVkU2lnbmF0b3JpZXMubWFwKGFzeW5jIChhZGRyZXNzMikgPT4ge1xuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gb2ZmY2hhaW5NZXNzYWdlRW52ZWxvcGUuc2lnbmF0dXJlc1thZGRyZXNzMl07XG4gICAgICBpZiAoc2lnbmF0dXJlID09IG51bGwpIHtcbiAgICAgICAgZXJyb3JDb250ZXh0IHx8PSB7fTtcbiAgICAgICAgZXJyb3JDb250ZXh0LnNpZ25hdG9yaWVzV2l0aE1pc3NpbmdTaWduYXR1cmVzIHx8PSBbXTtcbiAgICAgICAgZXJyb3JDb250ZXh0LnNpZ25hdG9yaWVzV2l0aE1pc3NpbmdTaWduYXR1cmVzLnB1c2goYWRkcmVzczIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcHVibGljS2V5ID0gYXdhaXQgZ2V0UHVibGljS2V5RnJvbUFkZHJlc3MoYWRkcmVzczIpO1xuICAgICAgICBpZiAoYXdhaXQgdmVyaWZ5U2lnbmF0dXJlKHB1YmxpY0tleSwgc2lnbmF0dXJlLCBvZmZjaGFpbk1lc3NhZ2VFbnZlbG9wZS5jb250ZW50KSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVycm9yQ29udGV4dCB8fD0ge307XG4gICAgICAgICAgZXJyb3JDb250ZXh0LnNpZ25hdG9yaWVzV2l0aEludmFsaWRTaWduYXR1cmVzIHx8PSBbXTtcbiAgICAgICAgICBlcnJvckNvbnRleHQuc2lnbmF0b3JpZXNXaXRoSW52YWxpZFNpZ25hdHVyZXMucHVzaChhZGRyZXNzMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICApO1xuICBpZiAoZXJyb3JDb250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fT0ZGQ0hBSU5fTUVTU0FHRV9fU0lHTkFUVVJFX1ZFUklGSUNBVElPTl9GQUlMVVJFLCBlcnJvckNvbnRleHQpO1xuICB9XG59XG5cbmV4cG9ydCB7IE9mZmNoYWluTWVzc2FnZUNvbnRlbnRGb3JtYXQsIGFzc2VydElzRnVsbHlTaWduZWRPZmZjaGFpbk1lc3NhZ2VFbnZlbG9wZSwgYXNzZXJ0SXNPZmZjaGFpbk1lc3NhZ2VBcHBsaWNhdGlvbkRvbWFpbiwgYXNzZXJ0SXNPZmZjaGFpbk1lc3NhZ2VDb250ZW50UmVzdHJpY3RlZEFzY2lpT2YxMjMyQnl0ZXNNYXgsIGFzc2VydElzT2ZmY2hhaW5NZXNzYWdlQ29udGVudFV0ZjhPZjEyMzJCeXRlc01heCwgYXNzZXJ0SXNPZmZjaGFpbk1lc3NhZ2VDb250ZW50VXRmOE9mNjU1MzVCeXRlc01heCwgYXNzZXJ0SXNPZmZjaGFpbk1lc3NhZ2VSZXN0cmljdGVkQXNjaWlPZjEyMzJCeXRlc01heCwgYXNzZXJ0SXNPZmZjaGFpbk1lc3NhZ2VVdGY4T2YxMjMyQnl0ZXNNYXgsIGFzc2VydElzT2ZmY2hhaW5NZXNzYWdlVXRmOE9mNjU1MzVCeXRlc01heCwgY29tcGlsZU9mZmNoYWluTWVzc2FnZUVudmVsb3BlLCBjb21waWxlT2ZmY2hhaW5NZXNzYWdlVjBFbnZlbG9wZSwgY29tcGlsZU9mZmNoYWluTWVzc2FnZVYxRW52ZWxvcGUsIGdldE9mZmNoYWluTWVzc2FnZUFwcGxpY2F0aW9uRG9tYWluQ29kZWMsIGdldE9mZmNoYWluTWVzc2FnZUFwcGxpY2F0aW9uRG9tYWluRGVjb2RlciwgZ2V0T2ZmY2hhaW5NZXNzYWdlQXBwbGljYXRpb25Eb21haW5FbmNvZGVyLCBnZXRPZmZjaGFpbk1lc3NhZ2VDb2RlYywgZ2V0T2ZmY2hhaW5NZXNzYWdlRGVjb2RlciwgZ2V0T2ZmY2hhaW5NZXNzYWdlRW5jb2RlciwgZ2V0T2ZmY2hhaW5NZXNzYWdlRW52ZWxvcGVDb2RlYywgZ2V0T2ZmY2hhaW5NZXNzYWdlRW52ZWxvcGVEZWNvZGVyLCBnZXRPZmZjaGFpbk1lc3NhZ2VFbnZlbG9wZUVuY29kZXIsIGdldE9mZmNoYWluTWVzc2FnZVYwQ29kZWMsIGdldE9mZmNoYWluTWVzc2FnZVYwRGVjb2RlciwgZ2V0T2ZmY2hhaW5NZXNzYWdlVjBFbmNvZGVyLCBnZXRPZmZjaGFpbk1lc3NhZ2VWMUNvZGVjLCBnZXRPZmZjaGFpbk1lc3NhZ2VWMURlY29kZXIsIGdldE9mZmNoYWluTWVzc2FnZVYxRW5jb2RlciwgaXNGdWxseVNpZ25lZE9mZmNoYWluTWVzc2FnZUVudmVsb3BlLCBpc09mZmNoYWluTWVzc2FnZUFwcGxpY2F0aW9uRG9tYWluLCBpc09mZmNoYWluTWVzc2FnZUNvbnRlbnRSZXN0cmljdGVkQXNjaWlPZjEyMzJCeXRlc01heCwgaXNPZmZjaGFpbk1lc3NhZ2VDb250ZW50VXRmOE9mMTIzMkJ5dGVzTWF4LCBpc09mZmNoYWluTWVzc2FnZUNvbnRlbnRVdGY4T2Y2NTUzNUJ5dGVzTWF4LCBvZmZjaGFpbk1lc3NhZ2VBcHBsaWNhdGlvbkRvbWFpbiwgb2ZmY2hhaW5NZXNzYWdlQ29udGVudFJlc3RyaWN0ZWRBc2NpaU9mMTIzMkJ5dGVzTWF4LCBvZmZjaGFpbk1lc3NhZ2VDb250ZW50VXRmOE9mMTIzMkJ5dGVzTWF4LCBvZmZjaGFpbk1lc3NhZ2VDb250ZW50VXRmOE9mNjU1MzVCeXRlc01heCwgcGFydGlhbGx5U2lnbk9mZmNoYWluTWVzc2FnZUVudmVsb3BlLCBzaWduT2ZmY2hhaW5NZXNzYWdlRW52ZWxvcGUsIHZlcmlmeU9mZmNoYWluTWVzc2FnZUVudmVsb3BlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5ub2RlLm1qcy5tYXBcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm5vZGUubWpzLm1hcCJdLCJuYW1lcyI6WyJpc0FkZHJlc3MiLCJhc3NlcnRJc0FkZHJlc3MiLCJnZXRBZGRyZXNzRW5jb2RlciIsImdldEFkZHJlc3NEZWNvZGVyIiwiYWRkcmVzcyIsImdldEFkZHJlc3NGcm9tUHVibGljS2V5IiwiZ2V0UHVibGljS2V5RnJvbUFkZHJlc3MiLCJpc1NvbGFuYUVycm9yIiwiU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX1NUUklOR19MRU5HVEhfT1VUX09GX1JBTkdFIiwiU29sYW5hRXJyb3IiLCJTT0xBTkFfRVJST1JfX09GRkNIQUlOX01FU1NBR0VfX0FQUExJQ0FUSU9OX0RPTUFJTl9TVFJJTkdfTEVOR1RIX09VVF9PRl9SQU5HRSIsIlNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19JTlZBTElEX0JZVEVfTEVOR1RIIiwiU09MQU5BX0VSUk9SX19PRkZDSEFJTl9NRVNTQUdFX19JTlZBTElEX0FQUExJQ0FUSU9OX0RPTUFJTl9CWVRFX0xFTkdUSCIsIlNPTEFOQV9FUlJPUl9fT0ZGQ0hBSU5fTUVTU0FHRV9fTlVNX0VOVkVMT1BFX1NJR05BVFVSRVNfQ0FOTk9UX0JFX1pFUk8iLCJTT0xBTkFfRVJST1JfX09GRkNIQUlOX01FU1NBR0VfX0VOVkVMT1BFX1NJR05FUlNfTUlTTUFUQ0giLCJTT0xBTkFfRVJST1JfX09GRkNIQUlOX01FU1NBR0VfX05VTV9TSUdOQVRVUkVTX01JU01BVENIIiwiU09MQU5BX0VSUk9SX19PRkZDSEFJTl9NRVNTQUdFX19OVU1fUkVRVUlSRURfU0lHTkVSU19DQU5OT1RfQkVfWkVSTyIsIlNPTEFOQV9FUlJPUl9fT0ZGQ0hBSU5fTUVTU0FHRV9fTUVTU0FHRV9GT1JNQVRfTUlTTUFUQ0giLCJTT0xBTkFfRVJST1JfX09GRkNIQUlOX01FU1NBR0VfX01FU1NBR0VfTVVTVF9CRV9OT05fRU1QVFkiLCJTT0xBTkFfRVJST1JfX09GRkNIQUlOX01FU1NBR0VfX1JFU1RSSUNURURfQVNDSUlfQk9EWV9DSEFSQUNURVJfT1VUX09GX1JBTkdFIiwiU09MQU5BX0VSUk9SX19PRkZDSEFJTl9NRVNTQUdFX19NQVhJTVVNX0xFTkdUSF9FWENFRURFRCIsIlNPTEFOQV9FUlJPUl9fT0ZGQ0hBSU5fTUVTU0FHRV9fTUVTU0FHRV9MRU5HVEhfTUlTTUFUQ0giLCJTT0xBTkFfRVJST1JfX0lOVkFSSUFOVF9WSU9MQVRJT05fX1NXSVRDSF9NVVNUX0JFX0VYSEFVU1RJVkUiLCJTT0xBTkFfRVJST1JfX09GRkNIQUlOX01FU1NBR0VfX1ZFUlNJT05fTlVNQkVSX05PVF9TVVBQT1JURUQiLCJTT0xBTkFfRVJST1JfX09GRkNIQUlOX01FU1NBR0VfX0FERFJFU1NFU19DQU5OT1RfU0lHTl9PRkZDSEFJTl9NRVNTQUdFIiwiU09MQU5BX0VSUk9SX19PRkZDSEFJTl9NRVNTQUdFX19TSUdOQVRVUkVTX01JU1NJTkciLCJTT0xBTkFfRVJST1JfX09GRkNIQUlOX01FU1NBR0VfX1NJR05BVFVSRV9WRVJJRklDQVRJT05fRkFJTFVSRSIsIlNPTEFOQV9FUlJPUl9fT0ZGQ0hBSU5fTUVTU0FHRV9fU0lHTkFUT1JJRVNfTVVTVF9CRV9TT1JURUQiLCJTT0xBTkFfRVJST1JfX09GRkNIQUlOX01FU1NBR0VfX1NJR05BVE9SSUVTX01VU1RfQkVfVU5JUVVFIiwiU09MQU5BX0VSUk9SX19PRkZDSEFJTl9NRVNTQUdFX19VTkVYUEVDVEVEX1ZFUlNJT04iLCJ0cmFuc2Zvcm1FbmNvZGVyIiwiY29tYmluZUNvZGVjIiwidHJhbnNmb3JtRGVjb2RlciIsImZpeERlY29kZXJTaXplIiwiY3JlYXRlRGVjb2RlciIsImNyZWF0ZUVuY29kZXIiLCJieXRlc0VxdWFsIiwiZml4RW5jb2RlclNpemUiLCJvZmZzZXREZWNvZGVyIiwiZ2V0U3RydWN0RW5jb2RlciIsImdldEJ5dGVzRW5jb2RlciIsImdldFN0cnVjdERlY29kZXIiLCJnZXRBcnJheURlY29kZXIiLCJnZXRCeXRlc0RlY29kZXIiLCJnZXRUdXBsZURlY29kZXIiLCJnZXRUdXBsZUVuY29kZXIiLCJnZXRIaWRkZW5QcmVmaXhEZWNvZGVyIiwiZ2V0QXJyYXlFbmNvZGVyIiwiZ2V0Q29uc3RhbnREZWNvZGVyIiwiZ2V0RW51bURlY29kZXIiLCJnZXRFbnVtRW5jb2RlciIsImdldEhpZGRlblByZWZpeEVuY29kZXIiLCJnZXRDb25zdGFudEVuY29kZXIiLCJnZXRVOERlY29kZXIiLCJnZXRVOEVuY29kZXIiLCJnZXRVMTZEZWNvZGVyIiwiZ2V0VTE2RW5jb2RlciIsImdldFV0ZjhFbmNvZGVyIiwiZ2V0VXRmOERlY29kZXIiLCJzaWduQnl0ZXMiLCJ2ZXJpZnlTaWduYXR1cmUiLCJpc09mZmNoYWluTWVzc2FnZUFwcGxpY2F0aW9uRG9tYWluIiwicHV0YXRpdmVBcHBsaWNhdGlvbkRvbWFpbiIsImFzc2VydElzT2ZmY2hhaW5NZXNzYWdlQXBwbGljYXRpb25Eb21haW4iLCJlcnJvciIsImNvbnRleHQiLCJvZmZjaGFpbk1lc3NhZ2VBcHBsaWNhdGlvbkRvbWFpbiIsImdldE9mZmNoYWluTWVzc2FnZUFwcGxpY2F0aW9uRG9tYWluRW5jb2RlciIsImdldE9mZmNoYWluTWVzc2FnZUFwcGxpY2F0aW9uRG9tYWluRGVjb2RlciIsImdldE9mZmNoYWluTWVzc2FnZUFwcGxpY2F0aW9uRG9tYWluQ29kZWMiLCJPRkZDSEFJTl9NRVNTQUdFX1NJR05JTkdfRE9NQUlOX0JZVEVTIiwiVWludDhBcnJheSIsImdldE9mZmNoYWluTWVzc2FnZVNpZ25pbmdEb21haW5EZWNvZGVyIiwiZ2V0T2ZmY2hhaW5NZXNzYWdlU2lnbmluZ0RvbWFpbkVuY29kZXIiLCJnZXRTaWduaW5nRG9tYWluUHJlZml4ZWREZWNvZGVyIiwiZmllbGRzIiwiZ2V0U2lnbmluZ0RvbWFpblByZWZpeGVkRW5jb2RlciIsImdldFZlcnNpb25UcmFuc2Zvcm1lciIsImZpeGVkVmVyc2lvbiIsInZlcnNpb24iLCJ1bnN1cHBvcnRlZFZlcnNpb24iLCJhY3R1YWxWZXJzaW9uIiwiZXhwZWN0ZWRWZXJzaW9uIiwiY3JlYXRlT2ZmY2hhaW5NZXNzYWdlUHJlYW1ibGVEZWNvZGVyIiwiY3JlYXRlT2ZmY2hhaW5NZXNzYWdlUHJlYW1ibGVFbmNvZGVyIiwiZGVjb2RlUmVxdWlyZWRTaWduYXRvcnlBZGRyZXNzZXMiLCJieXRlcyIsImJ5dGVzQWZ0ZXJWZXJzaW9uIiwiZGVjb2RlIiwic2l6ZSIsInNpZ25hdG9yeUFkZHJlc3NlcyIsImxlbmd0aCIsInByZU9mZnNldCIsImdldFNpZ25hdG9yaWVzQ29tcGFyYXRvciIsIngiLCJ5IiwiaWkiLCJnZXRTaWduYXR1cmVzVG9FbmNvZGUiLCJzaWduYXR1cmVzTWFwIiwic2lnbmF0dXJlcyIsIk9iamVjdCIsInZhbHVlcyIsIm1hcCIsInNpZ25hdHVyZSIsImZpbGwiLCJnZXRTaWduYXR1cmVzRW5jb2RlciIsImdldE9mZmNoYWluTWVzc2FnZUVudmVsb3BlRW5jb2RlciIsImVudmVsb3BlIiwic2lnbmF0dXJlc01hcEFkZHJlc3NlcyIsImtleXMiLCJkZWNvZGVBbmRWYWxpZGF0ZVJlcXVpcmVkU2lnbmF0b3J5QWRkcmVzc2VzIiwiY29udGVudCIsIm1pc3NpbmdSZXF1aXJlZFNpZ25lcnMiLCJ1bmV4cGVjdGVkU2lnbmVycyIsImFkZHJlc3MyIiwiaW5jbHVkZXMiLCJwdXNoIiwib3JkZXJlZFNpZ25hdHVyZU1hcCIsImdldE9mZmNoYWluTWVzc2FnZUVudmVsb3BlRGVjb2RlciIsImRlY29kZVBhcnRpYWxseURlY29kZWRPZmZjaGFpbk1lc3NhZ2VFbnZlbG9wZSIsImdldE9mZmNoYWluTWVzc2FnZUVudmVsb3BlQ29kZWMiLCJvZmZjaGFpbk1lc3NhZ2VFbnZlbG9wZSIsIm51bVJlcXVpcmVkU2lnbmF0dXJlcyIsInNpZ25hdHVyZXNMZW5ndGgiLCJmb3JFYWNoIiwiaW5kZXgiLCJzaWduYXR1cmVGb3JBZGRyZXNzIiwiZXZlcnkiLCJiIiwiZnJlZXplIiwiTUFYX0JPRFlfQllURVMiLCJNQVhfQk9EWV9CWVRFU19IQVJEV0FSRV9XQUxMRVRfU0lHTkFCTEUiLCJPZmZjaGFpbk1lc3NhZ2VDb250ZW50Rm9ybWF0IiwiT2ZmY2hhaW5NZXNzYWdlQ29udGVudEZvcm1hdDMiLCJhc3NlcnRJc09mZmNoYWluTWVzc2FnZUNvbnRlbnRSZXN0cmljdGVkQXNjaWlPZjEyMzJCeXRlc01heCIsInB1dGF0aXZlQ29udGVudCIsImZvcm1hdCIsImFjdHVhbE1lc3NhZ2VGb3JtYXQiLCJleHBlY3RlZE1lc3NhZ2VGb3JtYXQiLCJ0ZXh0IiwiaXNUZXh0UmVzdHJpY3RlZEFzY2lpIiwiZ2V0U2l6ZUZyb21WYWx1ZSIsImFjdHVhbEJ5dGVzIiwibWF4Qnl0ZXMiLCJpc09mZmNoYWluTWVzc2FnZUNvbnRlbnRSZXN0cmljdGVkQXNjaWlPZjEyMzJCeXRlc01heCIsIm9mZmNoYWluTWVzc2FnZUNvbnRlbnRSZXN0cmljdGVkQXNjaWlPZjEyMzJCeXRlc01heCIsImFzc2VydElzT2ZmY2hhaW5NZXNzYWdlQ29udGVudFV0ZjhPZjEyMzJCeXRlc01heCIsImlzT2ZmY2hhaW5NZXNzYWdlQ29udGVudFV0ZjhPZjEyMzJCeXRlc01heCIsIm9mZmNoYWluTWVzc2FnZUNvbnRlbnRVdGY4T2YxMjMyQnl0ZXNNYXgiLCJhc3NlcnRJc09mZmNoYWluTWVzc2FnZUNvbnRlbnRVdGY4T2Y2NTUzNUJ5dGVzTWF4IiwiaXNPZmZjaGFpbk1lc3NhZ2VDb250ZW50VXRmOE9mNjU1MzVCeXRlc01heCIsIm9mZmNoYWluTWVzc2FnZUNvbnRlbnRVdGY4T2Y2NTUzNUJ5dGVzTWF4IiwicHV0YXRpdmVSZXN0cmljdGVkQXNjaWlTdHJpbmciLCJ0ZXN0IiwiYXNzZXJ0SXNPZmZjaGFpbk1lc3NhZ2VSZXN0cmljdGVkQXNjaWlPZjEyMzJCeXRlc01heCIsInB1dGF0aXZlTWVzc2FnZSIsImFzc2VydElzT2ZmY2hhaW5NZXNzYWdlVXRmOE9mMTIzMkJ5dGVzTWF4IiwiYXNzZXJ0SXNPZmZjaGFpbk1lc3NhZ2VVdGY4T2Y2NTUzNUJ5dGVzTWF4IiwiZ2V0T2ZmY2hhaW5NZXNzYWdlQ29udGVudEZvcm1hdERlY29kZXIiLCJ1c2VWYWx1ZXNBc0Rpc2NyaW1pbmF0b3JzIiwiZ2V0T2ZmY2hhaW5NZXNzYWdlQ29udGVudEZvcm1hdEVuY29kZXIiLCJnZXRPZmZjaGFpbk1lc3NhZ2VWMFByZWFtYmxlRGVjb2RlciIsImdldE9mZmNoYWluTWVzc2FnZVYwUHJlYW1ibGVFbmNvZGVyIiwiZ2V0T2ZmY2hhaW5NZXNzYWdlVjBEZWNvZGVyIiwibWVzc2FnZUxlbmd0aCIsIm1lc3NhZ2VGb3JtYXQiLCJyZXF1aXJlZFNpZ25hdG9yaWVzIiwicHJlYW1ibGVSZXN0IiwiYWN0dWFsTGVuZ3RoIiwic3BlY2lmaWVkTGVuZ3RoIiwib2ZmY2hhaW5NZXNzYWdlIiwidW5leHBlY3RlZFZhbHVlIiwiZ2V0T2ZmY2hhaW5NZXNzYWdlVjBFbmNvZGVyIiwicHJlYW1ibGUiLCJjb21waWxlZFByZWFtYmxlIiwiZ2V0T2ZmY2hhaW5NZXNzYWdlVjBDb2RlYyIsImdldE9mZmNoYWluTWVzc2FnZVYxUHJlYW1ibGVEZWNvZGVyIiwic2lnbmF0b3J5QWRkcmVzc2VzQnl0ZXMiLCJjb21wYXJhdG9yIiwiYWRkcmVzc0RlY29kZXIiLCJhZGRyZXNzQnl0ZXMiLCJnZXRPZmZjaGFpbk1lc3NhZ2VWMVByZWFtYmxlRW5jb2RlciIsInRvU29ydGVkIiwic2VlblNpZ25hdG9yaWVzIiwiU2V0IiwiaGFzIiwiYWRkIiwiYWRkcmVzc0VuY29kZXIiLCJlbmNvZGUiLCJnZXRPZmZjaGFpbk1lc3NhZ2VWMURlY29kZXIiLCJnZXRPZmZjaGFpbk1lc3NhZ2VWMUVuY29kZXIiLCJnZXRPZmZjaGFpbk1lc3NhZ2VWMUNvZGVjIiwiZ2V0T2ZmY2hhaW5NZXNzYWdlRGVjb2RlciIsInJlYWQiLCJvZmZzZXQiLCJnZXRPZmZjaGFpbk1lc3NhZ2VFbmNvZGVyIiwid3JpdGUiLCJnZXRPZmZjaGFpbk1lc3NhZ2VDb2RlYyIsImNvbXBpbGVPZmZjaGFpbk1lc3NhZ2VFbnZlbG9wZVVzaW5nRW5jb2RlciIsImVuY29kZXIiLCJvZmZjaGFpbk1lc3NhZ2VCeXRlcyIsImNvbXBpbGVPZmZjaGFpbk1lc3NhZ2VWMEVudmVsb3BlIiwiY29tcGlsZU9mZmNoYWluTWVzc2FnZVYxRW52ZWxvcGUiLCJjb21waWxlT2ZmY2hhaW5NZXNzYWdlRW52ZWxvcGUiLCJwYXJ0aWFsbHlTaWduT2ZmY2hhaW5NZXNzYWdlRW52ZWxvcGUiLCJrZXlQYWlycyIsIm5ld1NpZ25hdHVyZXMiLCJyZXF1aXJlZFNpZ25hdG9yeUFkZHJlc3NlcyIsIlByb21pc2UiLCJhbGwiLCJrZXlQYWlyIiwicHVibGljS2V5IiwiZXhpc3RpbmdTaWduYXR1cmUiLCJuZXdTaWduYXR1cmUiLCJwcml2YXRlS2V5IiwiZXhwZWN0ZWRBZGRyZXNzZXMiLCJ1bmV4cGVjdGVkQWRkcmVzc2VzIiwic2lnbk9mZmNoYWluTWVzc2FnZUVudmVsb3BlIiwib3V0IiwiYXNzZXJ0SXNGdWxseVNpZ25lZE9mZmNoYWluTWVzc2FnZUVudmVsb3BlIiwiaXNGdWxseVNpZ25lZE9mZmNoYWluTWVzc2FnZUVudmVsb3BlIiwiZW50cmllcyIsIl8iLCJzaWduYXR1cmVCeXRlcyIsIm1pc3NpbmdTaWdzIiwiYWRkcmVzc2VzIiwidmVyaWZ5T2ZmY2hhaW5NZXNzYWdlRW52ZWxvcGUiLCJlcnJvckNvbnRleHQiLCJzaWduYXRvcmllc1dpdGhNaXNzaW5nU2lnbmF0dXJlcyIsInNpZ25hdG9yaWVzV2l0aEludmFsaWRTaWduYXR1cmVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/offchain-messages/dist/index.node.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/options/dist/index.node.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@solana/options/dist/index.node.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getOptionCodec: () => (/* binding */ getOptionCodec),\n/* harmony export */   getOptionDecoder: () => (/* binding */ getOptionDecoder),\n/* harmony export */   getOptionEncoder: () => (/* binding */ getOptionEncoder),\n/* harmony export */   isNone: () => (/* binding */ isNone),\n/* harmony export */   isOption: () => (/* binding */ isOption),\n/* harmony export */   isSome: () => (/* binding */ isSome),\n/* harmony export */   none: () => (/* binding */ none),\n/* harmony export */   some: () => (/* binding */ some),\n/* harmony export */   unwrapOption: () => (/* binding */ unwrapOption),\n/* harmony export */   unwrapOptionRecursively: () => (/* binding */ unwrapOptionRecursively),\n/* harmony export */   wrapNullable: () => (/* binding */ wrapNullable)\n/* harmony export */ });\n/* harmony import */ var _solana_codecs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/codecs-core */ \"(ssr)/./node_modules/@solana/codecs-core/dist/index.node.mjs\");\n/* harmony import */ var _solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana/codecs-data-structures */ \"(ssr)/./node_modules/@solana/codecs-data-structures/dist/index.node.mjs\");\n/* harmony import */ var _solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @solana/codecs-numbers */ \"(ssr)/./node_modules/@solana/codecs-numbers/dist/index.node.mjs\");\n\n\n\n// src/option.ts\nvar some = (value)=>({\n        __option: \"Some\",\n        value\n    });\nvar none = ()=>({\n        __option: \"None\"\n    });\nvar isOption = (input)=>!!(input && typeof input === \"object\" && \"__option\" in input && (input.__option === \"Some\" && \"value\" in input || input.__option === \"None\"));\nvar isSome = (option)=>option.__option === \"Some\";\nvar isNone = (option)=>option.__option === \"None\";\n// src/unwrap-option.ts\nfunction unwrapOption(option, fallback) {\n    if (isSome(option)) return option.value;\n    return fallback ? fallback() : null;\n}\nvar wrapNullable = (nullable)=>nullable !== null ? some(nullable) : none();\n// src/option-codec.ts\nfunction getOptionEncoder(item, config = {}) {\n    const prefix = (()=>{\n        if (config.prefix === null) {\n            return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_0__.transformEncoder)((0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_1__.getUnitEncoder)(), (_boolean)=>void 0);\n        }\n        return (0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_1__.getBooleanEncoder)({\n            size: config.prefix ?? (0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_2__.getU8Encoder)()\n        });\n    })();\n    const noneValue = (()=>{\n        if (config.noneValue === \"zeroes\") {\n            (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_0__.assertIsFixedSize)(item);\n            return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_0__.fixEncoderSize)((0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_1__.getUnitEncoder)(), item.fixedSize);\n        }\n        if (!config.noneValue) {\n            return (0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_1__.getUnitEncoder)();\n        }\n        return (0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_1__.getConstantEncoder)(config.noneValue);\n    })();\n    return (0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_1__.getUnionEncoder)([\n        (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_0__.transformEncoder)((0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_1__.getTupleEncoder)([\n            prefix,\n            noneValue\n        ]), (_value)=>[\n                false,\n                void 0\n            ]),\n        (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_0__.transformEncoder)((0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_1__.getTupleEncoder)([\n            prefix,\n            item\n        ]), (value)=>[\n                true,\n                isOption(value) && isSome(value) ? value.value : value\n            ])\n    ], (variant)=>{\n        const option = isOption(variant) ? variant : wrapNullable(variant);\n        return Number(isSome(option));\n    });\n}\nfunction getOptionDecoder(item, config = {}) {\n    const prefix = (()=>{\n        if (config.prefix === null) {\n            return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_0__.transformDecoder)((0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_1__.getUnitDecoder)(), ()=>false);\n        }\n        return (0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_1__.getBooleanDecoder)({\n            size: config.prefix ?? (0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_2__.getU8Decoder)()\n        });\n    })();\n    const noneValue = (()=>{\n        if (config.noneValue === \"zeroes\") {\n            (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_0__.assertIsFixedSize)(item);\n            return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_0__.fixDecoderSize)((0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_1__.getUnitDecoder)(), item.fixedSize);\n        }\n        if (!config.noneValue) {\n            return (0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_1__.getUnitDecoder)();\n        }\n        return (0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_1__.getConstantDecoder)(config.noneValue);\n    })();\n    return (0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_1__.getUnionDecoder)([\n        (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_0__.transformDecoder)((0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_1__.getTupleDecoder)([\n            prefix,\n            noneValue\n        ]), ()=>none()),\n        (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_0__.transformDecoder)((0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_1__.getTupleDecoder)([\n            prefix,\n            item\n        ]), ([, value])=>some(value))\n    ], (bytes, offset)=>{\n        if (config.prefix === null && !config.noneValue) {\n            return Number(offset < bytes.length);\n        }\n        if (config.prefix === null && config.noneValue != null) {\n            const zeroValue = config.noneValue === \"zeroes\" ? new Uint8Array(noneValue.fixedSize).fill(0) : config.noneValue;\n            return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_0__.containsBytes)(bytes, zeroValue, offset) ? 0 : 1;\n        }\n        return Number(prefix.read(bytes, offset)[0]);\n    });\n}\nfunction getOptionCodec(item, config = {}) {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_0__.combineCodec)(getOptionEncoder(item, config), getOptionDecoder(item, config));\n}\n// src/unwrap-option-recursively.ts\nfunction unwrapOptionRecursively(input, fallback) {\n    if (!input || ArrayBuffer.isView(input)) {\n        return input;\n    }\n    const next = (x)=>fallback ? unwrapOptionRecursively(x, fallback) : unwrapOptionRecursively(x);\n    if (isOption(input)) {\n        if (isSome(input)) return next(input.value);\n        return fallback ? fallback() : null;\n    }\n    if (Array.isArray(input)) {\n        return input.map(next);\n    }\n    if (typeof input === \"object\") {\n        return Object.fromEntries(Object.entries(input).map(([k, v])=>[\n                k,\n                next(v)\n            ]));\n    }\n    return input;\n}\n //# sourceMappingURL=index.node.mjs.map\n //# sourceMappingURL=index.node.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS9vcHRpb25zL2Rpc3QvaW5kZXgubm9kZS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBeUo7QUFDeUU7QUFDOUo7QUFFcEUsZ0JBQWdCO0FBQ2hCLElBQUltQixPQUFPLENBQUNDLFFBQVc7UUFBRUMsVUFBVTtRQUFRRDtJQUFNO0FBQ2pELElBQUlFLE9BQU8sSUFBTztRQUFFRCxVQUFVO0lBQU87QUFDckMsSUFBSUUsV0FBVyxDQUFDQyxRQUFVLENBQUMsQ0FBRUEsQ0FBQUEsU0FBUyxPQUFPQSxVQUFVLFlBQVksY0FBY0EsU0FBVUEsQ0FBQUEsTUFBTUgsUUFBUSxLQUFLLFVBQVUsV0FBV0csU0FBU0EsTUFBTUgsUUFBUSxLQUFLLE1BQUssQ0FBQztBQUNySyxJQUFJSSxTQUFTLENBQUNDLFNBQVdBLE9BQU9MLFFBQVEsS0FBSztBQUM3QyxJQUFJTSxTQUFTLENBQUNELFNBQVdBLE9BQU9MLFFBQVEsS0FBSztBQUU3Qyx1QkFBdUI7QUFDdkIsU0FBU08sYUFBYUYsTUFBTSxFQUFFRyxRQUFRO0lBQ3BDLElBQUlKLE9BQU9DLFNBQVMsT0FBT0EsT0FBT04sS0FBSztJQUN2QyxPQUFPUyxXQUFXQSxhQUFhO0FBQ2pDO0FBQ0EsSUFBSUMsZUFBZSxDQUFDQyxXQUFhQSxhQUFhLE9BQU9aLEtBQUtZLFlBQVlUO0FBRXRFLHNCQUFzQjtBQUN0QixTQUFTVSxpQkFBaUJDLElBQUksRUFBRUMsU0FBUyxDQUFDLENBQUM7SUFDekMsTUFBTUMsU0FBUyxDQUFDO1FBQ2QsSUFBSUQsT0FBT0MsTUFBTSxLQUFLLE1BQU07WUFDMUIsT0FBT25DLHFFQUFnQkEsQ0FBQ08sOEVBQWNBLElBQUksQ0FBQzZCLFdBQWEsS0FBSztRQUMvRDtRQUNBLE9BQU81QixpRkFBaUJBLENBQUM7WUFBRTZCLE1BQU1ILE9BQU9DLE1BQU0sSUFBSWxCLG9FQUFZQTtRQUFHO0lBQ25FO0lBQ0EsTUFBTXFCLFlBQVksQ0FBQztR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QSxNQUFNK0IsT0FBTyxDQUFDQyxJQUFNM0IsV0FBV3VCLHdCQUF3QkksR0FBRzNCLFlBQVl1Qix3QkFBd0JJO0lBQzlGLElBQUlqQyxTQUFTQyxRQUFRO1FBQ25CLElBQUlDLE9BQU9ELFFBQVEsT0FBTytCLEtBQUsvQixNQUFNSixLQUFLO1FBQzFDLE9BQU9TLFdBQVdBLGFBQWE7SUFDakM7SUFDQSxJQUFJNEIsTUFBTUMsT0FBTyxDQUFDbEMsUUFBUTtRQUN4QixPQUFPQSxNQUFNbUMsR0FBRyxDQUFDSjtJQUNuQjtJQUNBLElBQUksT0FBTy9CLFVBQVUsVUFBVTtRQUM3QixPQUFPb0MsT0FBT0MsV0FBVyxDQUFDRCxPQUFPRSxPQUFPLENBQUN0QyxPQUFPbUMsR0FBRyxDQUFDLENBQUMsQ0FBQ0ksR0FBR0MsRUFBRSxHQUFLO2dCQUFDRDtnQkFBR1IsS0FBS1M7YUFBRztJQUM5RTtJQUNBLE9BQU94QztBQUNUO0FBRXlKLENBQ3pKLHVDQUF1QztDQUN2Qyx1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGF3LXdvcmtzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvb3B0aW9ucy9kaXN0L2luZGV4Lm5vZGUubWpzP2ZlYzciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdHJhbnNmb3JtRW5jb2RlciwgYXNzZXJ0SXNGaXhlZFNpemUsIGZpeEVuY29kZXJTaXplLCB0cmFuc2Zvcm1EZWNvZGVyLCBmaXhEZWNvZGVyU2l6ZSwgY29udGFpbnNCeXRlcywgY29tYmluZUNvZGVjIH0gZnJvbSAnQHNvbGFuYS9jb2RlY3MtY29yZSc7XG5pbXBvcnQgeyBnZXRVbml0RW5jb2RlciwgZ2V0Qm9vbGVhbkVuY29kZXIsIGdldENvbnN0YW50RW5jb2RlciwgZ2V0VW5pb25FbmNvZGVyLCBnZXRUdXBsZUVuY29kZXIsIGdldFVuaXREZWNvZGVyLCBnZXRCb29sZWFuRGVjb2RlciwgZ2V0Q29uc3RhbnREZWNvZGVyLCBnZXRVbmlvbkRlY29kZXIsIGdldFR1cGxlRGVjb2RlciB9IGZyb20gJ0Bzb2xhbmEvY29kZWNzLWRhdGEtc3RydWN0dXJlcyc7XG5pbXBvcnQgeyBnZXRVOEVuY29kZXIsIGdldFU4RGVjb2RlciB9IGZyb20gJ0Bzb2xhbmEvY29kZWNzLW51bWJlcnMnO1xuXG4vLyBzcmMvb3B0aW9uLnRzXG52YXIgc29tZSA9ICh2YWx1ZSkgPT4gKHsgX19vcHRpb246IFwiU29tZVwiLCB2YWx1ZSB9KTtcbnZhciBub25lID0gKCkgPT4gKHsgX19vcHRpb246IFwiTm9uZVwiIH0pO1xudmFyIGlzT3B0aW9uID0gKGlucHV0KSA9PiAhIShpbnB1dCAmJiB0eXBlb2YgaW5wdXQgPT09IFwib2JqZWN0XCIgJiYgXCJfX29wdGlvblwiIGluIGlucHV0ICYmIChpbnB1dC5fX29wdGlvbiA9PT0gXCJTb21lXCIgJiYgXCJ2YWx1ZVwiIGluIGlucHV0IHx8IGlucHV0Ll9fb3B0aW9uID09PSBcIk5vbmVcIikpO1xudmFyIGlzU29tZSA9IChvcHRpb24pID0+IG9wdGlvbi5fX29wdGlvbiA9PT0gXCJTb21lXCI7XG52YXIgaXNOb25lID0gKG9wdGlvbikgPT4gb3B0aW9uLl9fb3B0aW9uID09PSBcIk5vbmVcIjtcblxuLy8gc3JjL3Vud3JhcC1vcHRpb24udHNcbmZ1bmN0aW9uIHVud3JhcE9wdGlvbihvcHRpb24sIGZhbGxiYWNrKSB7XG4gIGlmIChpc1NvbWUob3B0aW9uKSkgcmV0dXJuIG9wdGlvbi52YWx1ZTtcbiAgcmV0dXJuIGZhbGxiYWNrID8gZmFsbGJhY2soKSA6IG51bGw7XG59XG52YXIgd3JhcE51bGxhYmxlID0gKG51bGxhYmxlKSA9PiBudWxsYWJsZSAhPT0gbnVsbCA/IHNvbWUobnVsbGFibGUpIDogbm9uZSgpO1xuXG4vLyBzcmMvb3B0aW9uLWNvZGVjLnRzXG5mdW5jdGlvbiBnZXRPcHRpb25FbmNvZGVyKGl0ZW0sIGNvbmZpZyA9IHt9KSB7XG4gIGNvbnN0IHByZWZpeCA9ICgoKSA9PiB7XG4gICAgaWYgKGNvbmZpZy5wcmVmaXggPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB0cmFuc2Zvcm1FbmNvZGVyKGdldFVuaXRFbmNvZGVyKCksIChfYm9vbGVhbikgPT4gdm9pZCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIGdldEJvb2xlYW5FbmNvZGVyKHsgc2l6ZTogY29uZmlnLnByZWZpeCA/PyBnZXRVOEVuY29kZXIoKSB9KTtcbiAgfSkoKTtcbiAgY29uc3Qgbm9uZVZhbHVlID0gKCgpID0+IHtcbiAgICBpZiAoY29uZmlnLm5vbmVWYWx1ZSA9PT0gXCJ6ZXJvZXNcIikge1xuICAgICAgYXNzZXJ0SXNGaXhlZFNpemUoaXRlbSk7XG4gICAgICByZXR1cm4gZml4RW5jb2RlclNpemUoZ2V0VW5pdEVuY29kZXIoKSwgaXRlbS5maXhlZFNpemUpO1xuICAgIH1cbiAgICBpZiAoIWNvbmZpZy5ub25lVmFsdWUpIHtcbiAgICAgIHJldHVybiBnZXRVbml0RW5jb2RlcigpO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0Q29uc3RhbnRFbmNvZGVyKGNvbmZpZy5ub25lVmFsdWUpO1xuICB9KSgpO1xuICByZXR1cm4gZ2V0VW5pb25FbmNvZGVyKFxuICAgIFtcbiAgICAgIHRyYW5zZm9ybUVuY29kZXIoZ2V0VHVwbGVFbmNvZGVyKFtwcmVmaXgsIG5vbmVWYWx1ZV0pLCAoX3ZhbHVlKSA9PiBbXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB2b2lkIDBcbiAgICAgIF0pLFxuICAgICAgdHJhbnNmb3JtRW5jb2RlcihnZXRUdXBsZUVuY29kZXIoW3ByZWZpeCwgaXRlbV0pLCAodmFsdWUpID0+IFtcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgaXNPcHRpb24odmFsdWUpICYmIGlzU29tZSh2YWx1ZSkgPyB2YWx1ZS52YWx1ZSA6IHZhbHVlXG4gICAgICBdKVxuICAgIF0sXG4gICAgKHZhcmlhbnQpID0+IHtcbiAgICAgIGNvbnN0IG9wdGlvbiA9IGlzT3B0aW9uKHZhcmlhbnQpID8gdmFyaWFudCA6IHdyYXBOdWxsYWJsZSh2YXJpYW50KTtcbiAgICAgIHJldHVybiBOdW1iZXIoaXNTb21lKG9wdGlvbikpO1xuICAgIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIGdldE9wdGlvbkRlY29kZXIoaXRlbSwgY29uZmlnID0ge30pIHtcbiAgY29uc3QgcHJlZml4ID0gKCgpID0+IHtcbiAgICBpZiAoY29uZmlnLnByZWZpeCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRyYW5zZm9ybURlY29kZXIoZ2V0VW5pdERlY29kZXIoKSwgKCkgPT4gZmFsc2UpO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0Qm9vbGVhbkRlY29kZXIoeyBzaXplOiBjb25maWcucHJlZml4ID8/IGdldFU4RGVjb2RlcigpIH0pO1xuICB9KSgpO1xuICBjb25zdCBub25lVmFsdWUgPSAoKCkgPT4ge1xuICAgIGlmIChjb25maWcubm9uZVZhbHVlID09PSBcInplcm9lc1wiKSB7XG4gICAgICBhc3NlcnRJc0ZpeGVkU2l6ZShpdGVtKTtcbiAgICAgIHJldHVybiBmaXhEZWNvZGVyU2l6ZShnZXRVbml0RGVjb2RlcigpLCBpdGVtLmZpeGVkU2l6ZSk7XG4gICAgfVxuICAgIGlmICghY29uZmlnLm5vbmVWYWx1ZSkge1xuICAgICAgcmV0dXJuIGdldFVuaXREZWNvZGVyKCk7XG4gICAgfVxuICAgIHJldHVybiBnZXRDb25zdGFudERlY29kZXIoY29uZmlnLm5vbmVWYWx1ZSk7XG4gIH0pKCk7XG4gIHJldHVybiBnZXRVbmlvbkRlY29kZXIoXG4gICAgW1xuICAgICAgdHJhbnNmb3JtRGVjb2RlcihnZXRUdXBsZURlY29kZXIoW3ByZWZpeCwgbm9uZVZhbHVlXSksICgpID0+IG5vbmUoKSksXG4gICAgICB0cmFuc2Zvcm1EZWNvZGVyKGdldFR1cGxlRGVjb2RlcihbcHJlZml4LCBpdGVtXSksIChbLCB2YWx1ZV0pID0+IHNvbWUodmFsdWUpKVxuICAgIF0sXG4gICAgKGJ5dGVzLCBvZmZzZXQpID0+IHtcbiAgICAgIGlmIChjb25maWcucHJlZml4ID09PSBudWxsICYmICFjb25maWcubm9uZVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBOdW1iZXIob2Zmc2V0IDwgYnl0ZXMubGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb25maWcucHJlZml4ID09PSBudWxsICYmIGNvbmZpZy5ub25lVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCB6ZXJvVmFsdWUgPSBjb25maWcubm9uZVZhbHVlID09PSBcInplcm9lc1wiID8gbmV3IFVpbnQ4QXJyYXkobm9uZVZhbHVlLmZpeGVkU2l6ZSkuZmlsbCgwKSA6IGNvbmZpZy5ub25lVmFsdWU7XG4gICAgICAgIHJldHVybiBjb250YWluc0J5dGVzKGJ5dGVzLCB6ZXJvVmFsdWUsIG9mZnNldCkgPyAwIDogMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBOdW1iZXIocHJlZml4LnJlYWQoYnl0ZXMsIG9mZnNldClbMF0pO1xuICAgIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIGdldE9wdGlvbkNvZGVjKGl0ZW0sIGNvbmZpZyA9IHt9KSB7XG4gIHJldHVybiBjb21iaW5lQ29kZWMoXG4gICAgZ2V0T3B0aW9uRW5jb2RlcihpdGVtLCBjb25maWcpLFxuICAgIGdldE9wdGlvbkRlY29kZXIoaXRlbSwgY29uZmlnKVxuICApO1xufVxuXG4vLyBzcmMvdW53cmFwLW9wdGlvbi1yZWN1cnNpdmVseS50c1xuZnVuY3Rpb24gdW53cmFwT3B0aW9uUmVjdXJzaXZlbHkoaW5wdXQsIGZhbGxiYWNrKSB7XG4gIGlmICghaW5wdXQgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KGlucHV0KSkge1xuICAgIHJldHVybiBpbnB1dDtcbiAgfVxuICBjb25zdCBuZXh0ID0gKHgpID0+IGZhbGxiYWNrID8gdW53cmFwT3B0aW9uUmVjdXJzaXZlbHkoeCwgZmFsbGJhY2spIDogdW53cmFwT3B0aW9uUmVjdXJzaXZlbHkoeCk7XG4gIGlmIChpc09wdGlvbihpbnB1dCkpIHtcbiAgICBpZiAoaXNTb21lKGlucHV0KSkgcmV0dXJuIG5leHQoaW5wdXQudmFsdWUpO1xuICAgIHJldHVybiBmYWxsYmFjayA/IGZhbGxiYWNrKCkgOiBudWxsO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgIHJldHVybiBpbnB1dC5tYXAobmV4dCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoaW5wdXQpLm1hcCgoW2ssIHZdKSA9PiBbaywgbmV4dCh2KV0pKTtcbiAgfVxuICByZXR1cm4gaW5wdXQ7XG59XG5cbmV4cG9ydCB7IGdldE9wdGlvbkNvZGVjLCBnZXRPcHRpb25EZWNvZGVyLCBnZXRPcHRpb25FbmNvZGVyLCBpc05vbmUsIGlzT3B0aW9uLCBpc1NvbWUsIG5vbmUsIHNvbWUsIHVud3JhcE9wdGlvbiwgdW53cmFwT3B0aW9uUmVjdXJzaXZlbHksIHdyYXBOdWxsYWJsZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubm9kZS5tanMubWFwXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5ub2RlLm1qcy5tYXAiXSwibmFtZXMiOlsidHJhbnNmb3JtRW5jb2RlciIsImFzc2VydElzRml4ZWRTaXplIiwiZml4RW5jb2RlclNpemUiLCJ0cmFuc2Zvcm1EZWNvZGVyIiwiZml4RGVjb2RlclNpemUiLCJjb250YWluc0J5dGVzIiwiY29tYmluZUNvZGVjIiwiZ2V0VW5pdEVuY29kZXIiLCJnZXRCb29sZWFuRW5jb2RlciIsImdldENvbnN0YW50RW5jb2RlciIsImdldFVuaW9uRW5jb2RlciIsImdldFR1cGxlRW5jb2RlciIsImdldFVuaXREZWNvZGVyIiwiZ2V0Qm9vbGVhbkRlY29kZXIiLCJnZXRDb25zdGFudERlY29kZXIiLCJnZXRVbmlvbkRlY29kZXIiLCJnZXRUdXBsZURlY29kZXIiLCJnZXRVOEVuY29kZXIiLCJnZXRVOERlY29kZXIiLCJzb21lIiwidmFsdWUiLCJfX29wdGlvbiIsIm5vbmUiLCJpc09wdGlvbiIsImlucHV0IiwiaXNTb21lIiwib3B0aW9uIiwiaXNOb25lIiwidW53cmFwT3B0aW9uIiwiZmFsbGJhY2siLCJ3cmFwTnVsbGFibGUiLCJudWxsYWJsZSIsImdldE9wdGlvbkVuY29kZXIiLCJpdGVtIiwiY29uZmlnIiwicHJlZml4IiwiX2Jvb2xlYW4iLCJzaXplIiwibm9uZVZhbHVlIiwiZml4ZWRTaXplIiwiX3ZhbHVlIiwidmFyaWFudCIsIk51bWJlciIsImdldE9wdGlvbkRlY29kZXIiLCJieXRlcyIsIm9mZnNldCIsImxlbmd0aCIsInplcm9WYWx1ZSIsIlVpbnQ4QXJyYXkiLCJmaWxsIiwicmVhZCIsImdldE9wdGlvbkNvZGVjIiwidW53cmFwT3B0aW9uUmVjdXJzaXZlbHkiLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsIm5leHQiLCJ4IiwiQXJyYXkiLCJpc0FycmF5IiwibWFwIiwiT2JqZWN0IiwiZnJvbUVudHJpZXMiLCJlbnRyaWVzIiwiayIsInYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/options/dist/index.node.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/programs/dist/index.node.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@solana/programs/dist/index.node.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isProgramError: () => (/* binding */ isProgramError)\n/* harmony export */ });\n/* harmony import */ var _solana_errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/errors */ \"(ssr)/./node_modules/@solana/errors/dist/index.node.mjs\");\n\n// src/program-error.ts\nfunction isProgramError(error, transactionMessage, programAddress, code) {\n    if (!(0,_solana_errors__WEBPACK_IMPORTED_MODULE_0__.isSolanaError)(error, _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM)) {\n        return false;\n    }\n    const instructionProgramAddress = transactionMessage.instructions[error.context.index]?.programAddress;\n    if (!instructionProgramAddress || instructionProgramAddress !== programAddress) {\n        return false;\n    }\n    return typeof code === \"undefined\" || error.context.code === code;\n}\n //# sourceMappingURL=index.node.mjs.map\n //# sourceMappingURL=index.node.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS9wcm9ncmFtcy9kaXN0L2luZGV4Lm5vZGUubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXdGO0FBRXhGLHVCQUF1QjtBQUN2QixTQUFTRSxlQUFlQyxLQUFLLEVBQUVDLGtCQUFrQixFQUFFQyxjQUFjLEVBQUVDLElBQUk7SUFDckUsSUFBSSxDQUFDTiw2REFBYUEsQ0FBQ0csT0FBT0YsbUZBQXVDQSxHQUFHO1FBQ2xFLE9BQU87SUFDVDtJQUNBLE1BQU1NLDRCQUE0QkgsbUJBQW1CSSxZQUFZLENBQUNMLE1BQU1NLE9BQU8sQ0FBQ0MsS0FBSyxDQUFDLEVBQUVMO0lBQ3hGLElBQUksQ0FBQ0UsNkJBQTZCQSw4QkFBOEJGLGdCQUFnQjtRQUM5RSxPQUFPO0lBQ1Q7SUFDQSxPQUFPLE9BQU9DLFNBQVMsZUFBZUgsTUFBTU0sT0FBTyxDQUFDSCxJQUFJLEtBQUtBO0FBQy9EO0FBRTBCLENBQzFCLHVDQUF1QztDQUN2Qyx1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGF3LXdvcmtzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvcHJvZ3JhbXMvZGlzdC9pbmRleC5ub2RlLm1qcz85MTBlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzU29sYW5hRXJyb3IsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0NVU1RPTSB9IGZyb20gJ0Bzb2xhbmEvZXJyb3JzJztcblxuLy8gc3JjL3Byb2dyYW0tZXJyb3IudHNcbmZ1bmN0aW9uIGlzUHJvZ3JhbUVycm9yKGVycm9yLCB0cmFuc2FjdGlvbk1lc3NhZ2UsIHByb2dyYW1BZGRyZXNzLCBjb2RlKSB7XG4gIGlmICghaXNTb2xhbmFFcnJvcihlcnJvciwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQ1VTVE9NKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBpbnN0cnVjdGlvblByb2dyYW1BZGRyZXNzID0gdHJhbnNhY3Rpb25NZXNzYWdlLmluc3RydWN0aW9uc1tlcnJvci5jb250ZXh0LmluZGV4XT8ucHJvZ3JhbUFkZHJlc3M7XG4gIGlmICghaW5zdHJ1Y3Rpb25Qcm9ncmFtQWRkcmVzcyB8fCBpbnN0cnVjdGlvblByb2dyYW1BZGRyZXNzICE9PSBwcm9ncmFtQWRkcmVzcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHlwZW9mIGNvZGUgPT09IFwidW5kZWZpbmVkXCIgfHwgZXJyb3IuY29udGV4dC5jb2RlID09PSBjb2RlO1xufVxuXG5leHBvcnQgeyBpc1Byb2dyYW1FcnJvciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubm9kZS5tanMubWFwXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5ub2RlLm1qcy5tYXAiXSwibmFtZXMiOlsiaXNTb2xhbmFFcnJvciIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0NVU1RPTSIsImlzUHJvZ3JhbUVycm9yIiwiZXJyb3IiLCJ0cmFuc2FjdGlvbk1lc3NhZ2UiLCJwcm9ncmFtQWRkcmVzcyIsImNvZGUiLCJpbnN0cnVjdGlvblByb2dyYW1BZGRyZXNzIiwiaW5zdHJ1Y3Rpb25zIiwiY29udGV4dCIsImluZGV4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/programs/dist/index.node.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/promises/dist/index.node.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@solana/promises/dist/index.node.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAbortablePromise: () => (/* binding */ getAbortablePromise),\n/* harmony export */   safeRace: () => (/* binding */ safeRace)\n/* harmony export */ });\n// src/race.ts\nfunction isObject(value) {\n    return value !== null && (typeof value === \"object\" || typeof value === \"function\");\n}\nfunction addRaceContender(contender) {\n    const deferreds = /* @__PURE__ */ new Set();\n    const record = {\n        deferreds,\n        settled: false\n    };\n    Promise.resolve(contender).then((value)=>{\n        for (const { resolve } of deferreds){\n            resolve(value);\n        }\n        deferreds.clear();\n        record.settled = true;\n    }, (err)=>{\n        for (const { reject } of deferreds){\n            reject(err);\n        }\n        deferreds.clear();\n        record.settled = true;\n    });\n    return record;\n}\nvar wm = /* @__PURE__ */ new WeakMap();\nasync function safeRace(contenders) {\n    let deferred;\n    const result = new Promise((resolve, reject)=>{\n        deferred = {\n            reject,\n            resolve\n        };\n        for (const contender of contenders){\n            if (!isObject(contender)) {\n                Promise.resolve(contender).then(resolve, reject);\n                continue;\n            }\n            let record = wm.get(contender);\n            if (record === void 0) {\n                record = addRaceContender(contender);\n                record.deferreds.add(deferred);\n                wm.set(contender, record);\n            } else if (record.settled) {\n                Promise.resolve(contender).then(resolve, reject);\n            } else {\n                record.deferreds.add(deferred);\n            }\n        }\n    });\n    return await result.finally(()=>{\n        for (const contender of contenders){\n            if (isObject(contender)) {\n                const record = wm.get(contender);\n                record.deferreds.delete(deferred);\n            }\n        }\n    });\n}\n// src/abortable.ts\nfunction getAbortablePromise(promise, abortSignal) {\n    if (!abortSignal) {\n        return promise;\n    } else {\n        return safeRace([\n            // This promise only ever rejects if the signal is aborted. Otherwise it idles forever.\n            // It's important that this come before the input promise; in the event of an abort, we\n            // want to throw even if the input promise's result is ready\n            new Promise((_, reject)=>{\n                if (abortSignal.aborted) {\n                    reject(abortSignal.reason);\n                } else {\n                    abortSignal.addEventListener(\"abort\", function() {\n                        reject(this.reason);\n                    });\n                }\n            }),\n            promise\n        ]);\n    }\n}\n //# sourceMappingURL=index.node.mjs.map\n //# sourceMappingURL=index.node.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS9wcm9taXNlcy9kaXN0L2luZGV4Lm5vZGUubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsY0FBYztBQUNkLFNBQVNBLFNBQVNDLEtBQUs7SUFDckIsT0FBT0EsVUFBVSxRQUFTLFFBQU9BLFVBQVUsWUFBWSxPQUFPQSxVQUFVLFVBQVM7QUFDbkY7QUFDQSxTQUFTQyxpQkFBaUJDLFNBQVM7SUFDakMsTUFBTUMsWUFBWSxhQUFhLEdBQUcsSUFBSUM7SUFDdEMsTUFBTUMsU0FBUztRQUFFRjtRQUFXRyxTQUFTO0lBQU07SUFDM0NDLFFBQVFDLE9BQU8sQ0FBQ04sV0FBV08sSUFBSSxDQUM3QixDQUFDVDtRQUNDLEtBQUssTUFBTSxFQUFFUSxPQUFPLEVBQUUsSUFBSUwsVUFBVztZQUNuQ0ssUUFBUVI7UUFDVjtRQUNBRyxVQUFVTyxLQUFLO1FBQ2ZMLE9BQU9DLE9BQU8sR0FBRztJQUNuQixHQUNBLENBQUNLO1FBQ0MsS0FBSyxNQUFNLEVBQUVDLE1BQU0sRUFBRSxJQUFJVCxVQUFXO1lBQ2xDUyxPQUFPRDtRQUNUO1FBQ0FSLFVBQVVPLEtBQUs7UUFDZkwsT0FBT0MsT0FBTyxHQUFHO0lBQ25CO0lBRUYsT0FBT0Q7QUFDVDtBQUNBLElBQUlRLEtBQUssYUFBYSxHQUFHLElBQUlDO0FBQzdCLGVBQWVDLFNBQVNDLFVBQVU7SUFDaEMsSUFBSUM7SUFDSixNQUFNQyxTQUFTLElBQUlYLFFBQVEsQ0FBQ0MsU0FBU0k7UUFDbkNLLFdBQVc7WUFBRUw7WUFBUUo7UUFBUTtRQUM3QixLQUFLLE1BQU1OLGFBQWFjLFdBQVk7WUFDbEMsSUFBSSxDQUFDakIsU0FBU0csWUFBWTtnQkFDeEJLLFFBQVFDLE9BQU8sQ0FBQ04sV0FBV08sSUFBSSxDQUFDRCxTQUFTSTtnQkFDekM7WUFDRjtZQUNBLElBQUlQLFNBQVNRLEdBQUdNLEdBQUcsQ0FBQ2pCO1lBQ3BCLElBQUlHLFdBQVcsS0FBSyxHQUFHO2dCQUNyQkEsU0FBU0osaUJBQWlCQztnQkFDMUJHLE9BQU9GLFNBQVMsQ0FBQ2lCLEdBQUcsQ0FBQ0g7Z0JBQ3JCSixHQUFHUSxHQUFHLENBQUNuQixXQUFXRztZQUNwQixPQUFPLElBQUlBLE9BQU9DLE9BQU8sRUFBRTtnQkFDekJDLFFBQVFDLE9BQU8sQ0FBQ04sV0FBV08sSUFBSSxDQUFDRCxTQUFTSTtZQUMzQyxPQUFPO2dCQUNMUCxPQUFPRixTQUFTLENBQUNpQixHQUFHLENBQUNIO1lBQ3ZCO1FBQ0Y7SUFDRjtJQUNBLE9BQU8sTUFBTUMsT0FBT0ksT0FBTyxDQUFDO1FBQzFCLEtBQUssTUFBTXBCLGFBQWFjLFdBQVk7WUFDbEMsSUFBSWpCLFNBQVNHLFlBQVk7Z0JBQ3ZCLE1BQU1HLFNBQVNRLEdBQUdNLEdBQUcsQ0FBQ2pCO2dCQUN0QkcsT0FBT0YsU0FBUyxDQUFDb0IsTUFBTSxDQUFDTjtZQUMxQjtRQUNGO0lBQ0Y7QUFDRjtBQUVBLG1CQUFtQjtBQUNuQixTQUFTTyxvQkFBb0JDLE9BQU8sRUFBRUMsV0FBVztJQUMvQyxJQUFJLENBQUNBLGFBQWE7UUFDaEIsT0FBT0Q7SUFDVCxPQUFPO1FBQ0wsT0FBT1YsU0FBUztZQUNkLHVGQUF1RjtZQUN2Rix1RkFBdUY7WUFDdkYsNERBQTREO1lBQzVELElBQUlSLFFBQVEsQ0FBQ29CLEdBQUdmO2dCQUNkLElBQUljLFlBQVlFLE9BQU8sRUFBRTtvQkFDdkJoQixPQUFPYyxZQUFZRyxNQUFNO2dCQUMzQixPQUFPO29CQUNMSCxZQUFZSSxnQkFBZ0IsQ0FBQyxTQUFTO3dCQUNwQ2xCLE9BQU8sSUFBSSxDQUFDaUIsTUFBTTtvQkFDcEI7Z0JBQ0Y7WUFDRjtZQUNBSjtTQUNEO0lBQ0g7QUFDRjtBQUV5QyxDQUN6Qyx1Q0FBdUM7Q0FDdkMsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xhdy13b3Jrcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3Byb21pc2VzL2Rpc3QvaW5kZXgubm9kZS5tanM/NzJlZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvcmFjZS50c1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpO1xufVxuZnVuY3Rpb24gYWRkUmFjZUNvbnRlbmRlcihjb250ZW5kZXIpIHtcbiAgY29uc3QgZGVmZXJyZWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgY29uc3QgcmVjb3JkID0geyBkZWZlcnJlZHMsIHNldHRsZWQ6IGZhbHNlIH07XG4gIFByb21pc2UucmVzb2x2ZShjb250ZW5kZXIpLnRoZW4oXG4gICAgKHZhbHVlKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IHsgcmVzb2x2ZSB9IG9mIGRlZmVycmVkcykge1xuICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGRlZmVycmVkcy5jbGVhcigpO1xuICAgICAgcmVjb3JkLnNldHRsZWQgPSB0cnVlO1xuICAgIH0sXG4gICAgKGVycikgPT4ge1xuICAgICAgZm9yIChjb25zdCB7IHJlamVjdCB9IG9mIGRlZmVycmVkcykge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICAgIGRlZmVycmVkcy5jbGVhcigpO1xuICAgICAgcmVjb3JkLnNldHRsZWQgPSB0cnVlO1xuICAgIH1cbiAgKTtcbiAgcmV0dXJuIHJlY29yZDtcbn1cbnZhciB3bSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuYXN5bmMgZnVuY3Rpb24gc2FmZVJhY2UoY29udGVuZGVycykge1xuICBsZXQgZGVmZXJyZWQ7XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBkZWZlcnJlZCA9IHsgcmVqZWN0LCByZXNvbHZlIH07XG4gICAgZm9yIChjb25zdCBjb250ZW5kZXIgb2YgY29udGVuZGVycykge1xuICAgICAgaWYgKCFpc09iamVjdChjb250ZW5kZXIpKSB7XG4gICAgICAgIFByb21pc2UucmVzb2x2ZShjb250ZW5kZXIpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBsZXQgcmVjb3JkID0gd20uZ2V0KGNvbnRlbmRlcik7XG4gICAgICBpZiAocmVjb3JkID09PSB2b2lkIDApIHtcbiAgICAgICAgcmVjb3JkID0gYWRkUmFjZUNvbnRlbmRlcihjb250ZW5kZXIpO1xuICAgICAgICByZWNvcmQuZGVmZXJyZWRzLmFkZChkZWZlcnJlZCk7XG4gICAgICAgIHdtLnNldChjb250ZW5kZXIsIHJlY29yZCk7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC5zZXR0bGVkKSB7XG4gICAgICAgIFByb21pc2UucmVzb2x2ZShjb250ZW5kZXIpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlY29yZC5kZWZlcnJlZHMuYWRkKGRlZmVycmVkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gYXdhaXQgcmVzdWx0LmZpbmFsbHkoKCkgPT4ge1xuICAgIGZvciAoY29uc3QgY29udGVuZGVyIG9mIGNvbnRlbmRlcnMpIHtcbiAgICAgIGlmIChpc09iamVjdChjb250ZW5kZXIpKSB7XG4gICAgICAgIGNvbnN0IHJlY29yZCA9IHdtLmdldChjb250ZW5kZXIpO1xuICAgICAgICByZWNvcmQuZGVmZXJyZWRzLmRlbGV0ZShkZWZlcnJlZCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL2Fib3J0YWJsZS50c1xuZnVuY3Rpb24gZ2V0QWJvcnRhYmxlUHJvbWlzZShwcm9taXNlLCBhYm9ydFNpZ25hbCkge1xuICBpZiAoIWFib3J0U2lnbmFsKSB7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHNhZmVSYWNlKFtcbiAgICAgIC8vIFRoaXMgcHJvbWlzZSBvbmx5IGV2ZXIgcmVqZWN0cyBpZiB0aGUgc2lnbmFsIGlzIGFib3J0ZWQuIE90aGVyd2lzZSBpdCBpZGxlcyBmb3JldmVyLlxuICAgICAgLy8gSXQncyBpbXBvcnRhbnQgdGhhdCB0aGlzIGNvbWUgYmVmb3JlIHRoZSBpbnB1dCBwcm9taXNlOyBpbiB0aGUgZXZlbnQgb2YgYW4gYWJvcnQsIHdlXG4gICAgICAvLyB3YW50IHRvIHRocm93IGV2ZW4gaWYgdGhlIGlucHV0IHByb21pc2UncyByZXN1bHQgaXMgcmVhZHlcbiAgICAgIG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICAgICAgaWYgKGFib3J0U2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICByZWplY3QoYWJvcnRTaWduYWwucmVhc29uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhYm9ydFNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZWplY3QodGhpcy5yZWFzb24pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIHByb21pc2VcbiAgICBdKTtcbiAgfVxufVxuXG5leHBvcnQgeyBnZXRBYm9ydGFibGVQcm9taXNlLCBzYWZlUmFjZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubm9kZS5tanMubWFwXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5ub2RlLm1qcy5tYXAiXSwibmFtZXMiOlsiaXNPYmplY3QiLCJ2YWx1ZSIsImFkZFJhY2VDb250ZW5kZXIiLCJjb250ZW5kZXIiLCJkZWZlcnJlZHMiLCJTZXQiLCJyZWNvcmQiLCJzZXR0bGVkIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwiY2xlYXIiLCJlcnIiLCJyZWplY3QiLCJ3bSIsIldlYWtNYXAiLCJzYWZlUmFjZSIsImNvbnRlbmRlcnMiLCJkZWZlcnJlZCIsInJlc3VsdCIsImdldCIsImFkZCIsInNldCIsImZpbmFsbHkiLCJkZWxldGUiLCJnZXRBYm9ydGFibGVQcm9taXNlIiwicHJvbWlzZSIsImFib3J0U2lnbmFsIiwiXyIsImFib3J0ZWQiLCJyZWFzb24iLCJhZGRFdmVudExpc3RlbmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/promises/dist/index.node.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/rpc-api/dist/index.node.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@solana/rpc-api/dist/index.node.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createSolanaRpcApi: () => (/* binding */ createSolanaRpcApi)\n/* harmony export */ });\n/* harmony import */ var _solana_rpc_spec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/rpc-spec */ \"(ssr)/./node_modules/@solana/rpc-spec/dist/index.node.mjs\");\n/* harmony import */ var _solana_rpc_transformers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana/rpc-transformers */ \"(ssr)/./node_modules/@solana/rpc-transformers/dist/index.node.mjs\");\n\n\n// src/index.ts\nfunction createSolanaRpcApi(config) {\n    return (0,_solana_rpc_spec__WEBPACK_IMPORTED_MODULE_0__.createJsonRpcApi)({\n        requestTransformer: (0,_solana_rpc_transformers__WEBPACK_IMPORTED_MODULE_1__.getDefaultRequestTransformerForSolanaRpc)(config),\n        responseTransformer: (0,_solana_rpc_transformers__WEBPACK_IMPORTED_MODULE_1__.getDefaultResponseTransformerForSolanaRpc)({\n            allowedNumericKeyPaths: getAllowedNumericKeypaths()\n        })\n    });\n}\nvar memoizedKeypaths;\nfunction getAllowedNumericKeypaths() {\n    if (!memoizedKeypaths) {\n        memoizedKeypaths = {\n            getAccountInfo: _solana_rpc_transformers__WEBPACK_IMPORTED_MODULE_1__.jsonParsedAccountsConfigs.map((c)=>[\n                    \"value\",\n                    ...c\n                ]),\n            getBlock: [\n                [\n                    \"transactions\",\n                    _solana_rpc_transformers__WEBPACK_IMPORTED_MODULE_1__.KEYPATH_WILDCARD,\n                    \"meta\",\n                    \"preTokenBalances\",\n                    _solana_rpc_transformers__WEBPACK_IMPORTED_MODULE_1__.KEYPATH_WILDCARD,\n                    \"accountIndex\"\n                ],\n                [\n                    \"transactions\",\n                    _solana_rpc_transformers__WEBPACK_IMPORTED_MODULE_1__.KEYPATH_WILDCARD,\n                    \"meta\",\n                    \"preTokenBalances\",\n                    _solana_rpc_transformers__WEBPACK_IMPORTED_MODULE_1__.KEYPATH_WILDCARD,\n                    \"uiTokenAmount\",\n                    \"decimals\"\n                ],\n                [\n                    \"transactions\",\n                    _solana_rpc_transformers__WEBPACK_IMPORTED_MODULE_1__.KEYPATH_WILDCARD,\n                    \"meta\",\n                    \"postTokenBalances\",\n                    _solana_rpc_transformers__WEBPACK_IMPORTED_MODULE_1__.KEYPATH_WILDCARD,\n                    \"accountIndex\"\n                ],\n                [\n                    \"transactions\",\n                    _solana_rpc_transformers__WEBPACK_IMPORTED_MODULE_1__.KEYPATH_WILDCARD,\n                    \"meta\",\n                    \"postTokenBalances\",\n                    _solana_rpc_transformers__WEBPACK_IMPORTED_MODULE_1__.KEYPATH_WILDCARD,\n                    \"uiTokenAmount\",\n                    \"decimals\"\n                ],\n                [\n                    \"transactions\",\n                    _solana_rpc_transformers__WEBPACK_IMPORTED_MODULE_1__.KEYPATH_WILDCARD,\n                    \"meta\",\n                    \"rewards\",\n                    _solana_rpc_transformers__WEBPACK_IMPORTED_MODULE_1__.KEYPATH_WILDCARD,\n                    \"commission\"\n                ],\n                ..._solana_rpc_transformers__WEBPACK_IMPORTED_MODULE_1__.innerInstructionsConfigs.map((c)=>[\n                        \"transactions\",\n                        _solana_rpc_transformers__WEBPACK_IMPORTED_MODULE_1__.KEYPATH_WILDCARD,\n                        \"meta\",\n                        \"innerInstructions\",\n                        _solana_rpc_transformers__WEBPACK_IMPORTED_MODULE_1__.KEYPATH_WILDCARD,\n                        ...c\n                    ]),\n                ..._solana_rpc_transformers__WEBPACK_IMPORTED_MODULE_1__.messageConfig.map((c)=>[\n                        \"transactions\",\n                        _solana_rpc_transformers__WEBPACK_IMPORTED_MODULE_1__.KEYPATH_WILDCARD,\n                        \"transaction\",\n                        \"message\",\n                        ...c\n                    ]),\n                [\n                    \"rewards\",\n                    _solana_rpc_transformers__WEBPACK_IMPORTED_MODULE_1__.KEYPATH_WILDCARD,\n                    \"commission\"\n                ]\n            ],\n            getClusterNodes: [\n                [\n                    _solana_rpc_transformers__WEBPACK_IMPORTED_MODULE_1__.KEYPATH_WILDCARD,\n                    \"featureSet\"\n                ],\n                [\n                    _solana_rpc_transformers__WEBPACK_IMPORTED_MODULE_1__.KEYPATH_WILDCARD,\n                    \"shredVersion\"\n                ]\n            ],\n            getInflationGovernor: [\n                [\n                    \"initial\"\n                ],\n                [\n                    \"foundation\"\n                ],\n                [\n                    \"foundationTerm\"\n                ],\n                [\n                    \"taper\"\n                ],\n                [\n                    \"terminal\"\n                ]\n            ],\n            getInflationRate: [\n                [\n                    \"foundation\"\n                ],\n                [\n                    \"total\"\n                ],\n                [\n                    \"validator\"\n                ]\n            ],\n            getInflationReward: [\n                [\n                    _solana_rpc_transformers__WEBPACK_IMPORTED_MODULE_1__.KEYPATH_WILDCARD,\n                    \"commission\"\n                ]\n            ],\n            getMultipleAccounts: _solana_rpc_transformers__WEBPACK_IMPORTED_MODULE_1__.jsonParsedAccountsConfigs.map((c)=>[\n                    \"value\",\n                    _solana_rpc_transformers__WEBPACK_IMPORTED_MODULE_1__.KEYPATH_WILDCARD,\n                    ...c\n                ]),\n            getProgramAccounts: _solana_rpc_transformers__WEBPACK_IMPORTED_MODULE_1__.jsonParsedAccountsConfigs.flatMap((c)=>[\n                    [\n                        \"value\",\n                        _solana_rpc_transformers__WEBPACK_IMPORTED_MODULE_1__.KEYPATH_WILDCARD,\n                        \"account\",\n                        ...c\n                    ],\n                    [\n                        _solana_rpc_transformers__WEBPACK_IMPORTED_MODULE_1__.KEYPATH_WILDCARD,\n                        \"account\",\n                        ...c\n                    ]\n                ]),\n            getRecentPerformanceSamples: [\n                [\n                    _solana_rpc_transformers__WEBPACK_IMPORTED_MODULE_1__.KEYPATH_WILDCARD,\n                    \"samplePeriodSecs\"\n                ]\n            ],\n            getTokenAccountBalance: [\n                [\n                    \"value\",\n                    \"decimals\"\n                ],\n                [\n                    \"value\",\n                    \"uiAmount\"\n                ]\n            ],\n            getTokenAccountsByDelegate: _solana_rpc_transformers__WEBPACK_IMPORTED_MODULE_1__.jsonParsedTokenAccountsConfigs.map((c)=>[\n                    \"value\",\n                    _solana_rpc_transformers__WEBPACK_IMPORTED_MODULE_1__.KEYPATH_WILDCARD,\n                    \"account\",\n                    ...c\n                ]),\n            getTokenAccountsByOwner: _solana_rpc_transformers__WEBPACK_IMPORTED_MODULE_1__.jsonParsedTokenAccountsConfigs.map((c)=>[\n                    \"value\",\n                    _solana_rpc_transformers__WEBPACK_IMPORTED_MODULE_1__.KEYPATH_WILDCARD,\n                    \"account\",\n                    ...c\n                ]),\n            getTokenLargestAccounts: [\n                [\n                    \"value\",\n                    _solana_rpc_transformers__WEBPACK_IMPORTED_MODULE_1__.KEYPATH_WILDCARD,\n                    \"decimals\"\n                ],\n                [\n                    \"value\",\n                    _solana_rpc_transformers__WEBPACK_IMPORTED_MODULE_1__.KEYPATH_WILDCARD,\n                    \"uiAmount\"\n                ]\n            ],\n            getTokenSupply: [\n                [\n                    \"value\",\n                    \"decimals\"\n                ],\n                [\n                    \"value\",\n                    \"uiAmount\"\n                ]\n            ],\n            getTransaction: [\n                [\n                    \"meta\",\n                    \"preTokenBalances\",\n                    _solana_rpc_transformers__WEBPACK_IMPORTED_MODULE_1__.KEYPATH_WILDCARD,\n                    \"accountIndex\"\n                ],\n                [\n                    \"meta\",\n                    \"preTokenBalances\",\n                    _solana_rpc_transformers__WEBPACK_IMPORTED_MODULE_1__.KEYPATH_WILDCARD,\n                    \"uiTokenAmount\",\n                    \"decimals\"\n                ],\n                [\n                    \"meta\",\n                    \"postTokenBalances\",\n                    _solana_rpc_transformers__WEBPACK_IMPORTED_MODULE_1__.KEYPATH_WILDCARD,\n                    \"accountIndex\"\n                ],\n                [\n                    \"meta\",\n                    \"postTokenBalances\",\n                    _solana_rpc_transformers__WEBPACK_IMPORTED_MODULE_1__.KEYPATH_WILDCARD,\n                    \"uiTokenAmount\",\n                    \"decimals\"\n                ],\n                [\n                    \"meta\",\n                    \"rewards\",\n                    _solana_rpc_transformers__WEBPACK_IMPORTED_MODULE_1__.KEYPATH_WILDCARD,\n                    \"commission\"\n                ],\n                ..._solana_rpc_transformers__WEBPACK_IMPORTED_MODULE_1__.innerInstructionsConfigs.map((c)=>[\n                        \"meta\",\n                        \"innerInstructions\",\n                        _solana_rpc_transformers__WEBPACK_IMPORTED_MODULE_1__.KEYPATH_WILDCARD,\n                        ...c\n                    ]),\n                ..._solana_rpc_transformers__WEBPACK_IMPORTED_MODULE_1__.messageConfig.map((c)=>[\n                        \"transaction\",\n                        \"message\",\n                        ...c\n                    ])\n            ],\n            getVersion: [\n                [\n                    \"feature-set\"\n                ]\n            ],\n            getVoteAccounts: [\n                [\n                    \"current\",\n                    _solana_rpc_transformers__WEBPACK_IMPORTED_MODULE_1__.KEYPATH_WILDCARD,\n                    \"commission\"\n                ],\n                [\n                    \"delinquent\",\n                    _solana_rpc_transformers__WEBPACK_IMPORTED_MODULE_1__.KEYPATH_WILDCARD,\n                    \"commission\"\n                ]\n            ],\n            simulateTransaction: [\n                [\n                    \"value\",\n                    \"loadedAccountsDataSize\"\n                ],\n                ..._solana_rpc_transformers__WEBPACK_IMPORTED_MODULE_1__.jsonParsedAccountsConfigs.map((c)=>[\n                        \"value\",\n                        \"accounts\",\n                        _solana_rpc_transformers__WEBPACK_IMPORTED_MODULE_1__.KEYPATH_WILDCARD,\n                        ...c\n                    ]),\n                ..._solana_rpc_transformers__WEBPACK_IMPORTED_MODULE_1__.innerInstructionsConfigs.map((c)=>[\n                        \"value\",\n                        \"innerInstructions\",\n                        _solana_rpc_transformers__WEBPACK_IMPORTED_MODULE_1__.KEYPATH_WILDCARD,\n                        ...c\n                    ])\n            ]\n        };\n    }\n    return memoizedKeypaths;\n}\n //# sourceMappingURL=index.node.mjs.map\n //# sourceMappingURL=index.node.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS9ycGMtYXBpL2Rpc3QvaW5kZXgubm9kZS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQW9EO0FBQ2lNO0FBRXJQLGVBQWU7QUFDZixTQUFTUSxtQkFBbUJDLE1BQU07SUFDaEMsT0FBT1Qsa0VBQWdCQSxDQUFDO1FBQ3RCVSxvQkFBb0JSLGtHQUF3Q0EsQ0FBQ087UUFDN0RFLHFCQUFxQlYsbUdBQXlDQSxDQUFDO1lBQzdEVyx3QkFBd0JDO1FBQzFCO0lBQ0Y7QUFDRjtBQUNBLElBQUlDO0FBQ0osU0FBU0Q7SUFDUCxJQUFJLENBQUNDLGtCQUFrQjtRQUNyQkEsbUJBQW1CO1lBQ2pCQyxnQkFBZ0JaLCtFQUF5QkEsQ0FBQ2EsR0FBRyxDQUFDLENBQUNDLElBQU07b0JBQUM7dUJBQVlBO2lCQUFFO1lBQ3BFQyxVQUFVO2dCQUNSO29CQUFDO29CQUFnQmIsc0VBQWdCQTtvQkFBRTtvQkFBUTtvQkFBb0JBLHNFQUFnQkE7b0JBQUU7aUJBQWU7Z0JBQ2hHO29CQUNFO29CQUNBQSxzRUFBZ0JBO29CQUNoQjtvQkFDQTtvQkFDQUEsc0VBQWdCQTtvQkFDaEI7b0JBQ0E7aUJBQ0Q7Z0JBQ0Q7b0JBQUM7b0JBQWdCQSxzRUFBZ0JBO29CQUFFO29CQUFRO29CQUFxQkEsc0VBQWdCQTtvQkFBRTtpQkFBZTtnQkFDakc7b0JBQ0U7b0JBQ0FBLHNFQUFnQkE7b0JBQ2hCO29CQUNBO29CQUNBQSxzRUFBZ0JBO29CQUNoQjtvQkFDQTtpQkFDRDtnQkFDRDtvQkFBQztvQkFBZ0JBLHNFQUFnQkE7b0JBQUU7b0JBQVE7b0JBQVdBLHNFQUFnQkE7b0JBQUU7aUJBQWE7bUJBQ2xGRCw4RUFBd0JBLENBQUNZLEdBQUcsQ0FBQyxDQUFDQyxJQUFNO3dCQUNyQzt3QkFDQVosc0VBQWdCQTt3QkFDaEI7d0JBQ0E7d0JBQ0FBLHNFQUFnQkE7MkJBQ2JZO3FCQUNKO21CQUNFWCxtRUFBYUEsQ0FBQ1UsR0FBRyxDQUFDLENBQUNDLElBQU07d0JB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QUNsRmIsOEVBQXdCQSxDQUFDWSxHQUFHLENBQUMsQ0FBQ0MsSUFBTTt3QkFBQzt3QkFBUzt3QkFBcUJaLHNFQUFnQkE7MkJBQUtZO3FCQUFFO2FBQzlGO1FBQ0g7SUFDRjtJQUNBLE9BQU9IO0FBQ1Q7QUFFOEIsQ0FDOUIsdUNBQXVDO0NBQ3ZDLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsYXctd29ya3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS9ycGMtYXBpL2Rpc3QvaW5kZXgubm9kZS5tanM/M2E2NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVKc29uUnBjQXBpIH0gZnJvbSAnQHNvbGFuYS9ycGMtc3BlYyc7XG5pbXBvcnQgeyBnZXREZWZhdWx0UmVzcG9uc2VUcmFuc2Zvcm1lckZvclNvbGFuYVJwYywgZ2V0RGVmYXVsdFJlcXVlc3RUcmFuc2Zvcm1lckZvclNvbGFuYVJwYywganNvblBhcnNlZEFjY291bnRzQ29uZmlncywgaW5uZXJJbnN0cnVjdGlvbnNDb25maWdzLCBLRVlQQVRIX1dJTERDQVJELCBtZXNzYWdlQ29uZmlnLCBqc29uUGFyc2VkVG9rZW5BY2NvdW50c0NvbmZpZ3MgfSBmcm9tICdAc29sYW5hL3JwYy10cmFuc2Zvcm1lcnMnO1xuXG4vLyBzcmMvaW5kZXgudHNcbmZ1bmN0aW9uIGNyZWF0ZVNvbGFuYVJwY0FwaShjb25maWcpIHtcbiAgcmV0dXJuIGNyZWF0ZUpzb25ScGNBcGkoe1xuICAgIHJlcXVlc3RUcmFuc2Zvcm1lcjogZ2V0RGVmYXVsdFJlcXVlc3RUcmFuc2Zvcm1lckZvclNvbGFuYVJwYyhjb25maWcpLFxuICAgIHJlc3BvbnNlVHJhbnNmb3JtZXI6IGdldERlZmF1bHRSZXNwb25zZVRyYW5zZm9ybWVyRm9yU29sYW5hUnBjKHtcbiAgICAgIGFsbG93ZWROdW1lcmljS2V5UGF0aHM6IGdldEFsbG93ZWROdW1lcmljS2V5cGF0aHMoKVxuICAgIH0pXG4gIH0pO1xufVxudmFyIG1lbW9pemVkS2V5cGF0aHM7XG5mdW5jdGlvbiBnZXRBbGxvd2VkTnVtZXJpY0tleXBhdGhzKCkge1xuICBpZiAoIW1lbW9pemVkS2V5cGF0aHMpIHtcbiAgICBtZW1vaXplZEtleXBhdGhzID0ge1xuICAgICAgZ2V0QWNjb3VudEluZm86IGpzb25QYXJzZWRBY2NvdW50c0NvbmZpZ3MubWFwKChjKSA9PiBbXCJ2YWx1ZVwiLCAuLi5jXSksXG4gICAgICBnZXRCbG9jazogW1xuICAgICAgICBbXCJ0cmFuc2FjdGlvbnNcIiwgS0VZUEFUSF9XSUxEQ0FSRCwgXCJtZXRhXCIsIFwicHJlVG9rZW5CYWxhbmNlc1wiLCBLRVlQQVRIX1dJTERDQVJELCBcImFjY291bnRJbmRleFwiXSxcbiAgICAgICAgW1xuICAgICAgICAgIFwidHJhbnNhY3Rpb25zXCIsXG4gICAgICAgICAgS0VZUEFUSF9XSUxEQ0FSRCxcbiAgICAgICAgICBcIm1ldGFcIixcbiAgICAgICAgICBcInByZVRva2VuQmFsYW5jZXNcIixcbiAgICAgICAgICBLRVlQQVRIX1dJTERDQVJELFxuICAgICAgICAgIFwidWlUb2tlbkFtb3VudFwiLFxuICAgICAgICAgIFwiZGVjaW1hbHNcIlxuICAgICAgICBdLFxuICAgICAgICBbXCJ0cmFuc2FjdGlvbnNcIiwgS0VZUEFUSF9XSUxEQ0FSRCwgXCJtZXRhXCIsIFwicG9zdFRva2VuQmFsYW5jZXNcIiwgS0VZUEFUSF9XSUxEQ0FSRCwgXCJhY2NvdW50SW5kZXhcIl0sXG4gICAgICAgIFtcbiAgICAgICAgICBcInRyYW5zYWN0aW9uc1wiLFxuICAgICAgICAgIEtFWVBBVEhfV0lMRENBUkQsXG4gICAgICAgICAgXCJtZXRhXCIsXG4gICAgICAgICAgXCJwb3N0VG9rZW5CYWxhbmNlc1wiLFxuICAgICAgICAgIEtFWVBBVEhfV0lMRENBUkQsXG4gICAgICAgICAgXCJ1aVRva2VuQW1vdW50XCIsXG4gICAgICAgICAgXCJkZWNpbWFsc1wiXG4gICAgICAgIF0sXG4gICAgICAgIFtcInRyYW5zYWN0aW9uc1wiLCBLRVlQQVRIX1dJTERDQVJELCBcIm1ldGFcIiwgXCJyZXdhcmRzXCIsIEtFWVBBVEhfV0lMRENBUkQsIFwiY29tbWlzc2lvblwiXSxcbiAgICAgICAgLi4uaW5uZXJJbnN0cnVjdGlvbnNDb25maWdzLm1hcCgoYykgPT4gW1xuICAgICAgICAgIFwidHJhbnNhY3Rpb25zXCIsXG4gICAgICAgICAgS0VZUEFUSF9XSUxEQ0FSRCxcbiAgICAgICAgICBcIm1ldGFcIixcbiAgICAgICAgICBcImlubmVySW5zdHJ1Y3Rpb25zXCIsXG4gICAgICAgICAgS0VZUEFUSF9XSUxEQ0FSRCxcbiAgICAgICAgICAuLi5jXG4gICAgICAgIF0pLFxuICAgICAgICAuLi5tZXNzYWdlQ29uZmlnLm1hcCgoYykgPT4gW1widHJhbnNhY3Rpb25zXCIsIEtFWVBBVEhfV0lMRENBUkQsIFwidHJhbnNhY3Rpb25cIiwgXCJtZXNzYWdlXCIsIC4uLmNdKSxcbiAgICAgICAgW1wicmV3YXJkc1wiLCBLRVlQQVRIX1dJTERDQVJELCBcImNvbW1pc3Npb25cIl1cbiAgICAgIF0sXG4gICAgICBnZXRDbHVzdGVyTm9kZXM6IFtcbiAgICAgICAgW0tFWVBBVEhfV0lMRENBUkQsIFwiZmVhdHVyZVNldFwiXSxcbiAgICAgICAgW0tFWVBBVEhfV0lMRENBUkQsIFwic2hyZWRWZXJzaW9uXCJdXG4gICAgICBdLFxuICAgICAgZ2V0SW5mbGF0aW9uR292ZXJub3I6IFtbXCJpbml0aWFsXCJdLCBbXCJmb3VuZGF0aW9uXCJdLCBbXCJmb3VuZGF0aW9uVGVybVwiXSwgW1widGFwZXJcIl0sIFtcInRlcm1pbmFsXCJdXSxcbiAgICAgIGdldEluZmxhdGlvblJhdGU6IFtbXCJmb3VuZGF0aW9uXCJdLCBbXCJ0b3RhbFwiXSwgW1widmFsaWRhdG9yXCJdXSxcbiAgICAgIGdldEluZmxhdGlvblJld2FyZDogW1tLRVlQQVRIX1dJTERDQVJELCBcImNvbW1pc3Npb25cIl1dLFxuICAgICAgZ2V0TXVsdGlwbGVBY2NvdW50czoganNvblBhcnNlZEFjY291bnRzQ29uZmlncy5tYXAoKGMpID0+IFtcInZhbHVlXCIsIEtFWVBBVEhfV0lMRENBUkQsIC4uLmNdKSxcbiAgICAgIGdldFByb2dyYW1BY2NvdW50czoganNvblBhcnNlZEFjY291bnRzQ29uZmlncy5mbGF0TWFwKChjKSA9PiBbXG4gICAgICAgIFtcInZhbHVlXCIsIEtFWVBBVEhfV0lMRENBUkQsIFwiYWNjb3VudFwiLCAuLi5jXSxcbiAgICAgICAgW0tFWVBBVEhfV0lMRENBUkQsIFwiYWNjb3VudFwiLCAuLi5jXVxuICAgICAgXSksXG4gICAgICBnZXRSZWNlbnRQZXJmb3JtYW5jZVNhbXBsZXM6IFtbS0VZUEFUSF9XSUxEQ0FSRCwgXCJzYW1wbGVQZXJpb2RTZWNzXCJdXSxcbiAgICAgIGdldFRva2VuQWNjb3VudEJhbGFuY2U6IFtcbiAgICAgICAgW1widmFsdWVcIiwgXCJkZWNpbWFsc1wiXSxcbiAgICAgICAgW1widmFsdWVcIiwgXCJ1aUFtb3VudFwiXVxuICAgICAgXSxcbiAgICAgIGdldFRva2VuQWNjb3VudHNCeURlbGVnYXRlOiBqc29uUGFyc2VkVG9rZW5BY2NvdW50c0NvbmZpZ3MubWFwKChjKSA9PiBbXG4gICAgICAgIFwidmFsdWVcIixcbiAgICAgICAgS0VZUEFUSF9XSUxEQ0FSRCxcbiAgICAgICAgXCJhY2NvdW50XCIsXG4gICAgICAgIC4uLmNcbiAgICAgIF0pLFxuICAgICAgZ2V0VG9rZW5BY2NvdW50c0J5T3duZXI6IGpzb25QYXJzZWRUb2tlbkFjY291bnRzQ29uZmlncy5tYXAoKGMpID0+IFtcbiAgICAgICAgXCJ2YWx1ZVwiLFxuICAgICAgICBLRVlQQVRIX1dJTERDQVJELFxuICAgICAgICBcImFjY291bnRcIixcbiAgICAgICAgLi4uY1xuICAgICAgXSksXG4gICAgICBnZXRUb2tlbkxhcmdlc3RBY2NvdW50czogW1xuICAgICAgICBbXCJ2YWx1ZVwiLCBLRVlQQVRIX1dJTERDQVJELCBcImRlY2ltYWxzXCJdLFxuICAgICAgICBbXCJ2YWx1ZVwiLCBLRVlQQVRIX1dJTERDQVJELCBcInVpQW1vdW50XCJdXG4gICAgICBdLFxuICAgICAgZ2V0VG9rZW5TdXBwbHk6IFtcbiAgICAgICAgW1widmFsdWVcIiwgXCJkZWNpbWFsc1wiXSxcbiAgICAgICAgW1widmFsdWVcIiwgXCJ1aUFtb3VudFwiXVxuICAgICAgXSxcbiAgICAgIGdldFRyYW5zYWN0aW9uOiBbXG4gICAgICAgIFtcIm1ldGFcIiwgXCJwcmVUb2tlbkJhbGFuY2VzXCIsIEtFWVBBVEhfV0lMRENBUkQsIFwiYWNjb3VudEluZGV4XCJdLFxuICAgICAgICBbXCJtZXRhXCIsIFwicHJlVG9rZW5CYWxhbmNlc1wiLCBLRVlQQVRIX1dJTERDQVJELCBcInVpVG9rZW5BbW91bnRcIiwgXCJkZWNpbWFsc1wiXSxcbiAgICAgICAgW1wibWV0YVwiLCBcInBvc3RUb2tlbkJhbGFuY2VzXCIsIEtFWVBBVEhfV0lMRENBUkQsIFwiYWNjb3VudEluZGV4XCJdLFxuICAgICAgICBbXCJtZXRhXCIsIFwicG9zdFRva2VuQmFsYW5jZXNcIiwgS0VZUEFUSF9XSUxEQ0FSRCwgXCJ1aVRva2VuQW1vdW50XCIsIFwiZGVjaW1hbHNcIl0sXG4gICAgICAgIFtcIm1ldGFcIiwgXCJyZXdhcmRzXCIsIEtFWVBBVEhfV0lMRENBUkQsIFwiY29tbWlzc2lvblwiXSxcbiAgICAgICAgLi4uaW5uZXJJbnN0cnVjdGlvbnNDb25maWdzLm1hcCgoYykgPT4gW1wibWV0YVwiLCBcImlubmVySW5zdHJ1Y3Rpb25zXCIsIEtFWVBBVEhfV0lMRENBUkQsIC4uLmNdKSxcbiAgICAgICAgLi4ubWVzc2FnZUNvbmZpZy5tYXAoKGMpID0+IFtcInRyYW5zYWN0aW9uXCIsIFwibWVzc2FnZVwiLCAuLi5jXSlcbiAgICAgIF0sXG4gICAgICBnZXRWZXJzaW9uOiBbW1wiZmVhdHVyZS1zZXRcIl1dLFxuICAgICAgZ2V0Vm90ZUFjY291bnRzOiBbXG4gICAgICAgIFtcImN1cnJlbnRcIiwgS0VZUEFUSF9XSUxEQ0FSRCwgXCJjb21taXNzaW9uXCJdLFxuICAgICAgICBbXCJkZWxpbnF1ZW50XCIsIEtFWVBBVEhfV0lMRENBUkQsIFwiY29tbWlzc2lvblwiXVxuICAgICAgXSxcbiAgICAgIHNpbXVsYXRlVHJhbnNhY3Rpb246IFtcbiAgICAgICAgW1widmFsdWVcIiwgXCJsb2FkZWRBY2NvdW50c0RhdGFTaXplXCJdLFxuICAgICAgICAuLi5qc29uUGFyc2VkQWNjb3VudHNDb25maWdzLm1hcCgoYykgPT4gW1widmFsdWVcIiwgXCJhY2NvdW50c1wiLCBLRVlQQVRIX1dJTERDQVJELCAuLi5jXSksXG4gICAgICAgIC4uLmlubmVySW5zdHJ1Y3Rpb25zQ29uZmlncy5tYXAoKGMpID0+IFtcInZhbHVlXCIsIFwiaW5uZXJJbnN0cnVjdGlvbnNcIiwgS0VZUEFUSF9XSUxEQ0FSRCwgLi4uY10pXG4gICAgICBdXG4gICAgfTtcbiAgfVxuICByZXR1cm4gbWVtb2l6ZWRLZXlwYXRocztcbn1cblxuZXhwb3J0IHsgY3JlYXRlU29sYW5hUnBjQXBpIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5ub2RlLm1qcy5tYXBcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm5vZGUubWpzLm1hcCJdLCJuYW1lcyI6WyJjcmVhdGVKc29uUnBjQXBpIiwiZ2V0RGVmYXVsdFJlc3BvbnNlVHJhbnNmb3JtZXJGb3JTb2xhbmFScGMiLCJnZXREZWZhdWx0UmVxdWVzdFRyYW5zZm9ybWVyRm9yU29sYW5hUnBjIiwianNvblBhcnNlZEFjY291bnRzQ29uZmlncyIsImlubmVySW5zdHJ1Y3Rpb25zQ29uZmlncyIsIktFWVBBVEhfV0lMRENBUkQiLCJtZXNzYWdlQ29uZmlnIiwianNvblBhcnNlZFRva2VuQWNjb3VudHNDb25maWdzIiwiY3JlYXRlU29sYW5hUnBjQXBpIiwiY29uZmlnIiwicmVxdWVzdFRyYW5zZm9ybWVyIiwicmVzcG9uc2VUcmFuc2Zvcm1lciIsImFsbG93ZWROdW1lcmljS2V5UGF0aHMiLCJnZXRBbGxvd2VkTnVtZXJpY0tleXBhdGhzIiwibWVtb2l6ZWRLZXlwYXRocyIsImdldEFjY291bnRJbmZvIiwibWFwIiwiYyIsImdldEJsb2NrIiwiZ2V0Q2x1c3Rlck5vZGVzIiwiZ2V0SW5mbGF0aW9uR292ZXJub3IiLCJnZXRJbmZsYXRpb25SYXRlIiwiZ2V0SW5mbGF0aW9uUmV3YXJkIiwiZ2V0TXVsdGlwbGVBY2NvdW50cyIsImdldFByb2dyYW1BY2NvdW50cyIsImZsYXRNYXAiLCJnZXRSZWNlbnRQZXJmb3JtYW5jZVNhbXBsZXMiLCJnZXRUb2tlbkFjY291bnRCYWxhbmNlIiwiZ2V0VG9rZW5BY2NvdW50c0J5RGVsZWdhdGUiLCJnZXRUb2tlbkFjY291bnRzQnlPd25lciIsImdldFRva2VuTGFyZ2VzdEFjY291bnRzIiwiZ2V0VG9rZW5TdXBwbHkiLCJnZXRUcmFuc2FjdGlvbiIsImdldFZlcnNpb24iLCJnZXRWb3RlQWNjb3VudHMiLCJzaW11bGF0ZVRyYW5zYWN0aW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/rpc-api/dist/index.node.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/rpc-spec-types/dist/index.node.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@solana/rpc-spec-types/dist/index.node.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createRpcMessage: () => (/* binding */ createRpcMessage),\n/* harmony export */   parseJsonWithBigInts: () => (/* binding */ parseJsonWithBigInts),\n/* harmony export */   stringifyJsonWithBigInts: () => (/* binding */ stringifyJsonWithBigInts)\n/* harmony export */ });\n// src/parse-json-with-bigints.ts\nfunction parseJsonWithBigInts(json) {\n    return JSON.parse(wrapIntegersInBigIntValueObject(json), (_, value)=>{\n        return isBigIntValueObject(value) ? unwrapBigIntValueObject(value) : value;\n    });\n}\nfunction wrapIntegersInBigIntValueObject(json) {\n    const out = [];\n    let inQuote = false;\n    for(let ii = 0; ii < json.length; ii++){\n        let isEscaped = false;\n        if (json[ii] === \"\\\\\") {\n            out.push(json[ii++]);\n            isEscaped = !isEscaped;\n        }\n        if (json[ii] === '\"') {\n            out.push(json[ii]);\n            if (!isEscaped) {\n                inQuote = !inQuote;\n            }\n            continue;\n        }\n        if (!inQuote) {\n            const consumedNumber = consumeNumber(json, ii);\n            if (consumedNumber?.length) {\n                ii += consumedNumber.length - 1;\n                if (consumedNumber.match(/\\.|[eE]-/)) {\n                    out.push(consumedNumber);\n                } else {\n                    out.push(wrapBigIntValueObject(consumedNumber));\n                }\n                continue;\n            }\n        }\n        out.push(json[ii]);\n    }\n    return out.join(\"\");\n}\nfunction consumeNumber(json, ii) {\n    const JSON_NUMBER_REGEX = /^-?(?:0|[1-9]\\d*)(?:\\.\\d+)?(?:[eE][+-]?\\d+)?/;\n    if (!json[ii]?.match(/[-\\d]/)) {\n        return null;\n    }\n    const numberMatch = json.slice(ii).match(JSON_NUMBER_REGEX);\n    return numberMatch ? numberMatch[0] : null;\n}\nfunction wrapBigIntValueObject(value) {\n    return `{\"$n\":\"${value}\"}`;\n}\nfunction unwrapBigIntValueObject({ $n }) {\n    if ($n.match(/[eE]/)) {\n        const [units, exponent] = $n.split(/[eE]/);\n        return BigInt(units) * BigInt(10) ** BigInt(exponent);\n    }\n    return BigInt($n);\n}\nfunction isBigIntValueObject(value) {\n    return !!value && typeof value === \"object\" && \"$n\" in value && typeof value.$n === \"string\";\n}\n// src/rpc-message.ts\nvar _nextMessageId = 0n;\nfunction getNextMessageId() {\n    const id = _nextMessageId;\n    _nextMessageId++;\n    return id.toString();\n}\nfunction createRpcMessage(request) {\n    return {\n        id: getNextMessageId(),\n        jsonrpc: \"2.0\",\n        method: request.methodName,\n        params: request.params\n    };\n}\n// src/stringify-json-with-bigints.ts\nfunction stringifyJsonWithBigInts(value, space) {\n    return unwrapBigIntValueObject2(JSON.stringify(value, (_, v)=>typeof v === \"bigint\" ? wrapBigIntValueObject2(v) : v, space));\n}\nfunction wrapBigIntValueObject2(value) {\n    return {\n        $n: `${value}`\n    };\n}\nfunction unwrapBigIntValueObject2(value) {\n    return value.replace(/\\{\\s*\"\\$n\"\\s*:\\s*\"(-?\\d+)\"\\s*\\}/g, \"$1\");\n}\n //# sourceMappingURL=index.node.mjs.map\n //# sourceMappingURL=index.node.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS9ycGMtc3BlYy10eXBlcy9kaXN0L2luZGV4Lm5vZGUubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLGlDQUFpQztBQUNqQyxTQUFTQSxxQkFBcUJDLElBQUk7SUFDaEMsT0FBT0MsS0FBS0MsS0FBSyxDQUFDQyxnQ0FBZ0NILE9BQU8sQ0FBQ0ksR0FBR0M7UUFDM0QsT0FBT0Msb0JBQW9CRCxTQUFTRSx3QkFBd0JGLFNBQVNBO0lBQ3ZFO0FBQ0Y7QUFDQSxTQUFTRixnQ0FBZ0NILElBQUk7SUFDM0MsTUFBTVEsTUFBTSxFQUFFO0lBQ2QsSUFBSUMsVUFBVTtJQUNkLElBQUssSUFBSUMsS0FBSyxHQUFHQSxLQUFLVixLQUFLVyxNQUFNLEVBQUVELEtBQU07UUFDdkMsSUFBSUUsWUFBWTtRQUNoQixJQUFJWixJQUFJLENBQUNVLEdBQUcsS0FBSyxNQUFNO1lBQ3JCRixJQUFJSyxJQUFJLENBQUNiLElBQUksQ0FBQ1UsS0FBSztZQUNuQkUsWUFBWSxDQUFDQTtRQUNmO1FBQ0EsSUFBSVosSUFBSSxDQUFDVSxHQUFHLEtBQUssS0FBSztZQUNwQkYsSUFBSUssSUFBSSxDQUFDYixJQUFJLENBQUNVLEdBQUc7WUFDakIsSUFBSSxDQUFDRSxXQUFXO2dCQUNkSCxVQUFVLENBQUNBO1lBQ2I7WUFDQTtRQUNGO1FBQ0EsSUFBSSxDQUFDQSxTQUFTO1lBQ1osTUFBTUssaUJBQWlCQyxjQUFjZixNQUFNVTtZQUMzQyxJQUFJSSxnQkFBZ0JILFFBQVE7Z0JBQzFCRCxNQUFNSSxlQUFlSCxNQUFNLEdBQUc7Z0JBQzlCLElBQUlHLGVBQWVFLEtBQUssQ0FBQyxhQUFhO29CQUNwQ1IsSUFBSUssSUFBSSxDQUFDQztnQkFDWCxPQUFPO29CQUNMTixJQUFJSyxJQUFJLENBQUNJLHNCQUFzQkg7Z0JBQ2pDO2dCQUNBO1lBQ0Y7UUFDRjtRQUNBTixJQUFJSyxJQUFJLENBQUNiLElBQUksQ0FBQ1UsR0FBRztJQUNuQjtJQUNBLE9BQU9GLElBQUlVLElBQUksQ0FBQztBQUNsQjtBQUNBLFNBQVNILGNBQWNmLElBQUksRUFBRVUsRUFBRTtJQUM3QixNQUFNUyxvQkFBb0I7SUFDMUIsSUFBSSxDQUFDbkIsSUFBSSxDQUFDVSxHQUFHLEVBQUVNLE1BQU0sVUFBVTtRQUM3QixPQUFPO0lBQ1Q7SUFDQSxNQUFNSSxjQUFjcEIsS0FBS3FCLEtBQUssQ0FBQ1gsSUFBSU0sS0FBSyxDQUFDRztJQUN6QyxPQUFPQyxjQUFjQSxXQUFXLENBQUMsRUFBRSxHQUFHO0FBQ3hDO0FBQ0EsU0FBU0gsc0JBQXNCWixLQUFLO0lBQ2xDLE9BQU8sQ0FBQyxPQUFPLEVBQUVBLE1BQU0sRUFBRSxDQUFDO0FBQzVCO0FBQ0EsU0FBU0Usd0JBQXdCLEVBQUVlLEVBQUUsRUFBRTtJQUNyQyxJQUFJQSxHQUFHTixLQUFLLENBQUMsU0FBUztRQUNwQixNQUFNLENBQUNPLE9BQU9DLFNBQVMsR0FBR0YsR0FBR0csS0FBSyxDQUFDO1FBQ25DLE9BQU9DLE9BQU9ILFNBQVNHLE9BQU8sT0FBT0EsT0FBT0Y7SUFDOUM7SUFDQSxPQUFPRSxPQUFPSjtBQUNoQjtBQUNBLFNBQVNoQixvQkFBb0JELEtBQUs7SUFDaEMsT0FBTyxDQUFDLENBQUNBLFNBQVMsT0FBT0EsVUFBVSxZQUFZLFFBQVFBLFNBQVMsT0FBT0EsTUFBTWlCLEVBQUUsS0FBSztBQUN0RjtBQUVBLHFCQUFxQjtBQUNyQixJQUFJSyxpQkFBaUIsRUFBRTtBQUN2QixTQUFTQztJQUNQLE1BQU1DLEtBQUtGO0lBQ1hBO0lBQ0EsT0FBT0UsR0FBR0MsUUFBUTtBQUNwQjtBQUNBLFNBQVNDLGlCQUFpQkMsT0FBTztJQUMvQixPQUFPO1FBQ0xILElBQUlEO1FBQ0pLLFNBQVM7UUFDVEMsUUFBUUYsUUFBUUcsVUFBVTtRQUMxQkMsUUFBUUosUUFBUUksTUFBTTtJQUN4QjtBQUNGO0FBRUEscUNBQXFDO0FBQ3JDLFNBQVNDLHlCQUF5QmhDLEtBQUssRUFBRWlDLEtBQUs7SUFDNUMsT0FBT0MseUJBQ0x0QyxLQUFLdUMsU0FBUyxDQUFDbkMsT0FBTyxDQUFDRCxHQUFHcUMsSUFBTSxPQUFPQSxNQUFNLFdBQVdDLHVCQUF1QkQsS0FBS0EsR0FBR0g7QUFFM0Y7QUFDQSxTQUFTSSx1QkFBdUJyQyxLQUFLO0lBQ25DLE9BQU87UUFBRWlCLElBQUksQ0FBQyxFQUFFakIsTUFBTSxDQUFDO0lBQUM7QUFDMUI7QUFDQSxTQUFTa0MseUJBQXlCbEMsS0FBSztJQUNyQyxPQUFPQSxNQUFNc0MsT0FBTyxDQUFDLG9DQUFvQztBQUMzRDtBQUU0RSxDQUM1RSx1Q0FBdUM7Q0FDdkMsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xhdy13b3Jrcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3JwYy1zcGVjLXR5cGVzL2Rpc3QvaW5kZXgubm9kZS5tanM/ZDA4MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvcGFyc2UtanNvbi13aXRoLWJpZ2ludHMudHNcbmZ1bmN0aW9uIHBhcnNlSnNvbldpdGhCaWdJbnRzKGpzb24pIHtcbiAgcmV0dXJuIEpTT04ucGFyc2Uod3JhcEludGVnZXJzSW5CaWdJbnRWYWx1ZU9iamVjdChqc29uKSwgKF8sIHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIGlzQmlnSW50VmFsdWVPYmplY3QodmFsdWUpID8gdW53cmFwQmlnSW50VmFsdWVPYmplY3QodmFsdWUpIDogdmFsdWU7XG4gIH0pO1xufVxuZnVuY3Rpb24gd3JhcEludGVnZXJzSW5CaWdJbnRWYWx1ZU9iamVjdChqc29uKSB7XG4gIGNvbnN0IG91dCA9IFtdO1xuICBsZXQgaW5RdW90ZSA9IGZhbHNlO1xuICBmb3IgKGxldCBpaSA9IDA7IGlpIDwganNvbi5sZW5ndGg7IGlpKyspIHtcbiAgICBsZXQgaXNFc2NhcGVkID0gZmFsc2U7XG4gICAgaWYgKGpzb25baWldID09PSBcIlxcXFxcIikge1xuICAgICAgb3V0LnB1c2goanNvbltpaSsrXSk7XG4gICAgICBpc0VzY2FwZWQgPSAhaXNFc2NhcGVkO1xuICAgIH1cbiAgICBpZiAoanNvbltpaV0gPT09ICdcIicpIHtcbiAgICAgIG91dC5wdXNoKGpzb25baWldKTtcbiAgICAgIGlmICghaXNFc2NhcGVkKSB7XG4gICAgICAgIGluUXVvdGUgPSAhaW5RdW90ZTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoIWluUXVvdGUpIHtcbiAgICAgIGNvbnN0IGNvbnN1bWVkTnVtYmVyID0gY29uc3VtZU51bWJlcihqc29uLCBpaSk7XG4gICAgICBpZiAoY29uc3VtZWROdW1iZXI/Lmxlbmd0aCkge1xuICAgICAgICBpaSArPSBjb25zdW1lZE51bWJlci5sZW5ndGggLSAxO1xuICAgICAgICBpZiAoY29uc3VtZWROdW1iZXIubWF0Y2goL1xcLnxbZUVdLS8pKSB7XG4gICAgICAgICAgb3V0LnB1c2goY29uc3VtZWROdW1iZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dC5wdXNoKHdyYXBCaWdJbnRWYWx1ZU9iamVjdChjb25zdW1lZE51bWJlcikpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBvdXQucHVzaChqc29uW2lpXSk7XG4gIH1cbiAgcmV0dXJuIG91dC5qb2luKFwiXCIpO1xufVxuZnVuY3Rpb24gY29uc3VtZU51bWJlcihqc29uLCBpaSkge1xuICBjb25zdCBKU09OX05VTUJFUl9SRUdFWCA9IC9eLT8oPzowfFsxLTldXFxkKikoPzpcXC5cXGQrKT8oPzpbZUVdWystXT9cXGQrKT8vO1xuICBpZiAoIWpzb25baWldPy5tYXRjaCgvWy1cXGRdLykpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBudW1iZXJNYXRjaCA9IGpzb24uc2xpY2UoaWkpLm1hdGNoKEpTT05fTlVNQkVSX1JFR0VYKTtcbiAgcmV0dXJuIG51bWJlck1hdGNoID8gbnVtYmVyTWF0Y2hbMF0gOiBudWxsO1xufVxuZnVuY3Rpb24gd3JhcEJpZ0ludFZhbHVlT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBge1wiJG5cIjpcIiR7dmFsdWV9XCJ9YDtcbn1cbmZ1bmN0aW9uIHVud3JhcEJpZ0ludFZhbHVlT2JqZWN0KHsgJG4gfSkge1xuICBpZiAoJG4ubWF0Y2goL1tlRV0vKSkge1xuICAgIGNvbnN0IFt1bml0cywgZXhwb25lbnRdID0gJG4uc3BsaXQoL1tlRV0vKTtcbiAgICByZXR1cm4gQmlnSW50KHVuaXRzKSAqIEJpZ0ludCgxMCkgKiogQmlnSW50KGV4cG9uZW50KTtcbiAgfVxuICByZXR1cm4gQmlnSW50KCRuKTtcbn1cbmZ1bmN0aW9uIGlzQmlnSW50VmFsdWVPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIFwiJG5cIiBpbiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUuJG4gPT09IFwic3RyaW5nXCI7XG59XG5cbi8vIHNyYy9ycGMtbWVzc2FnZS50c1xudmFyIF9uZXh0TWVzc2FnZUlkID0gMG47XG5mdW5jdGlvbiBnZXROZXh0TWVzc2FnZUlkKCkge1xuICBjb25zdCBpZCA9IF9uZXh0TWVzc2FnZUlkO1xuICBfbmV4dE1lc3NhZ2VJZCsrO1xuICByZXR1cm4gaWQudG9TdHJpbmcoKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJwY01lc3NhZ2UocmVxdWVzdCkge1xuICByZXR1cm4ge1xuICAgIGlkOiBnZXROZXh0TWVzc2FnZUlkKCksXG4gICAganNvbnJwYzogXCIyLjBcIixcbiAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kTmFtZSxcbiAgICBwYXJhbXM6IHJlcXVlc3QucGFyYW1zXG4gIH07XG59XG5cbi8vIHNyYy9zdHJpbmdpZnktanNvbi13aXRoLWJpZ2ludHMudHNcbmZ1bmN0aW9uIHN0cmluZ2lmeUpzb25XaXRoQmlnSW50cyh2YWx1ZSwgc3BhY2UpIHtcbiAgcmV0dXJuIHVud3JhcEJpZ0ludFZhbHVlT2JqZWN0MihcbiAgICBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgKF8sIHYpID0+IHR5cGVvZiB2ID09PSBcImJpZ2ludFwiID8gd3JhcEJpZ0ludFZhbHVlT2JqZWN0Mih2KSA6IHYsIHNwYWNlKVxuICApO1xufVxuZnVuY3Rpb24gd3JhcEJpZ0ludFZhbHVlT2JqZWN0Mih2YWx1ZSkge1xuICByZXR1cm4geyAkbjogYCR7dmFsdWV9YCB9O1xufVxuZnVuY3Rpb24gdW53cmFwQmlnSW50VmFsdWVPYmplY3QyKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKC9cXHtcXHMqXCJcXCRuXCJcXHMqOlxccypcIigtP1xcZCspXCJcXHMqXFx9L2csIFwiJDFcIik7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZVJwY01lc3NhZ2UsIHBhcnNlSnNvbldpdGhCaWdJbnRzLCBzdHJpbmdpZnlKc29uV2l0aEJpZ0ludHMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm5vZGUubWpzLm1hcFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubm9kZS5tanMubWFwIl0sIm5hbWVzIjpbInBhcnNlSnNvbldpdGhCaWdJbnRzIiwianNvbiIsIkpTT04iLCJwYXJzZSIsIndyYXBJbnRlZ2Vyc0luQmlnSW50VmFsdWVPYmplY3QiLCJfIiwidmFsdWUiLCJpc0JpZ0ludFZhbHVlT2JqZWN0IiwidW53cmFwQmlnSW50VmFsdWVPYmplY3QiLCJvdXQiLCJpblF1b3RlIiwiaWkiLCJsZW5ndGgiLCJpc0VzY2FwZWQiLCJwdXNoIiwiY29uc3VtZWROdW1iZXIiLCJjb25zdW1lTnVtYmVyIiwibWF0Y2giLCJ3cmFwQmlnSW50VmFsdWVPYmplY3QiLCJqb2luIiwiSlNPTl9OVU1CRVJfUkVHRVgiLCJudW1iZXJNYXRjaCIsInNsaWNlIiwiJG4iLCJ1bml0cyIsImV4cG9uZW50Iiwic3BsaXQiLCJCaWdJbnQiLCJfbmV4dE1lc3NhZ2VJZCIsImdldE5leHRNZXNzYWdlSWQiLCJpZCIsInRvU3RyaW5nIiwiY3JlYXRlUnBjTWVzc2FnZSIsInJlcXVlc3QiLCJqc29ucnBjIiwibWV0aG9kIiwibWV0aG9kTmFtZSIsInBhcmFtcyIsInN0cmluZ2lmeUpzb25XaXRoQmlnSW50cyIsInNwYWNlIiwidW53cmFwQmlnSW50VmFsdWVPYmplY3QyIiwic3RyaW5naWZ5IiwidiIsIndyYXBCaWdJbnRWYWx1ZU9iamVjdDIiLCJyZXBsYWNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/rpc-spec-types/dist/index.node.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/rpc-spec/dist/index.node.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@solana/rpc-spec/dist/index.node.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createJsonRpcApi: () => (/* binding */ createJsonRpcApi),\n/* harmony export */   createRpc: () => (/* binding */ createRpc),\n/* harmony export */   isJsonRpcPayload: () => (/* binding */ isJsonRpcPayload)\n/* harmony export */ });\n/* harmony import */ var _solana_errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/errors */ \"(ssr)/./node_modules/@solana/errors/dist/index.node.mjs\");\n/* harmony import */ var _solana_rpc_spec_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana/rpc-spec-types */ \"(ssr)/./node_modules/@solana/rpc-spec-types/dist/index.node.mjs\");\n\n\n// src/rpc.ts\nfunction createRpc(rpcConfig) {\n    return makeProxy(rpcConfig);\n}\nfunction makeProxy(rpcConfig) {\n    return new Proxy(rpcConfig.api, {\n        defineProperty () {\n            return false;\n        },\n        deleteProperty () {\n            return false;\n        },\n        get (target, p, receiver) {\n            if (p === \"then\") {\n                return void 0;\n            }\n            return function(...rawParams) {\n                const methodName = p.toString();\n                const getApiPlan = Reflect.get(target, methodName, receiver);\n                if (!getApiPlan) {\n                    throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD, {\n                        method: methodName,\n                        params: rawParams\n                    });\n                }\n                const apiPlan = getApiPlan(...rawParams);\n                return createPendingRpcRequest(rpcConfig, apiPlan);\n            };\n        }\n    });\n}\nfunction createPendingRpcRequest({ transport }, plan) {\n    return {\n        async send (options) {\n            return await plan.execute({\n                signal: options?.abortSignal,\n                transport\n            });\n        }\n    };\n}\nfunction createJsonRpcApi(config) {\n    return new Proxy({}, {\n        defineProperty () {\n            return false;\n        },\n        deleteProperty () {\n            return false;\n        },\n        get (...args) {\n            const [_, p] = args;\n            const methodName = p.toString();\n            return function(...rawParams) {\n                const rawRequest = Object.freeze({\n                    methodName,\n                    params: rawParams\n                });\n                const request = config?.requestTransformer ? config?.requestTransformer(rawRequest) : rawRequest;\n                return Object.freeze({\n                    execute: async ({ signal, transport })=>{\n                        const payload = (0,_solana_rpc_spec_types__WEBPACK_IMPORTED_MODULE_1__.createRpcMessage)(request);\n                        const response = await transport({\n                            payload,\n                            signal\n                        });\n                        if (!config?.responseTransformer) {\n                            return response;\n                        }\n                        return config.responseTransformer(response, request);\n                    }\n                });\n            };\n        }\n    });\n}\n// src/rpc-transport.ts\nfunction isJsonRpcPayload(payload) {\n    if (payload == null || typeof payload !== \"object\" || Array.isArray(payload)) {\n        return false;\n    }\n    return \"jsonrpc\" in payload && payload.jsonrpc === \"2.0\" && \"method\" in payload && typeof payload.method === \"string\" && \"params\" in payload;\n}\n //# sourceMappingURL=index.node.mjs.map\n //# sourceMappingURL=index.node.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS9ycGMtc3BlYy9kaXN0L2luZGV4Lm5vZGUubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQWlHO0FBQ3ZDO0FBRTFELGFBQWE7QUFDYixTQUFTRyxVQUFVQyxTQUFTO0lBQzFCLE9BQU9DLFVBQVVEO0FBQ25CO0FBQ0EsU0FBU0MsVUFBVUQsU0FBUztJQUMxQixPQUFPLElBQUlFLE1BQU1GLFVBQVVHLEdBQUcsRUFBRTtRQUM5QkM7WUFDRSxPQUFPO1FBQ1Q7UUFDQUM7WUFDRSxPQUFPO1FBQ1Q7UUFDQUMsS0FBSUMsTUFBTSxFQUFFQyxDQUFDLEVBQUVDLFFBQVE7WUFDckIsSUFBSUQsTUFBTSxRQUFRO2dCQUNoQixPQUFPLEtBQUs7WUFDZDtZQUNBLE9BQU8sU0FBUyxHQUFHRSxTQUFTO2dCQUMxQixNQUFNQyxhQUFhSCxFQUFFSSxRQUFRO2dCQUM3QixNQUFNQyxhQUFhQyxRQUFRUixHQUFHLENBQUNDLFFBQVFJLFlBQVlGO2dCQUNuRCxJQUFJLENBQUNJLFlBQVk7b0JBQ2YsTUFBTSxJQUFJakIsdURBQVdBLENBQUNDLDhGQUFrREEsRUFBRTt3QkFDeEVrQixRQUFRSjt3QkFDUkssUUFBUU47b0JBQ1Y7Z0JBQ0Y7Z0JBQ0EsTUFBTU8sVUFBVUosY0FBY0g7Z0JBQzlCLE9BQU9RLHdCQUF3QmxCLFdBQVdpQjtZQUM1QztRQUNGO0lBQ0Y7QUFDRjtBQUNBLFNBQVNDLHdCQUF3QixFQUFFQyxTQUFTLEVBQUUsRUFBRUMsSUFBSTtJQUNsRCxPQUFPO1FBQ0wsTUFBTUMsTUFBS0MsT0FBTztZQUNoQixPQUFPLE1BQU1GLEtBQUtHLE9BQU8sQ0FBQztnQkFBRUMsUUFBUUYsU0FBU0c7Z0JBQWFOO1lBQVU7UUFDdEU7SUFDRjtBQUNGO0FBQ0EsU0FBU08saUJBQWlCQyxNQUFNO0lBQzlCLE9BQU8sSUFBSXpCLE1BQU0sQ0FBQyxHQUFHO1FBQ25CRTtZQUNFLE9BQU87UUFDVDtRQUNBQztZQUNFLE9BQU87UUFDVDtRQUNBQyxLQUFJLEdBQUdzQixJQUFJO1lBQ1QsTUFBTSxDQUFDQyxHQUFHckIsRUFBRSxHQUFHb0I7WUFDZixNQUFNakIsYUFBYUgsRUFBRUksUUFBUTtZQUM3QixPQUFPLFNBQVMsR0FBR0YsU0FBUztnQkFDMUIsTUFBTW9CLGFBQWFDLE9BQU9DLE1BQU0sQ0FBQztvQkFBRXJCO29CQUFZSyxRQUFRTjtnQkFBVTtnQkFDakUsTUFBTXVCLFVBQVVOLFFBQVFPLHFCQUFxQlAsUUFBUU8sbUJBQW1CSixjQUFjQTtnQkFDdEYsT0FBT0MsT0FBT0MsTUFBTSxDQUFDO29CQUNuQlQsU0FBUyxPQUFPLEVBQUVDLE1BQU0sRUFBRUwsU0FBUyxFQUFFO3dCQUNuQyxNQUFNZ0IsVUFBVXJDLHdFQUFnQkEsQ0FBQ21DO3dCQUNqQyxNQUFNRyxXQUFXLE1BQU1qQixVQUFVOzRCQUFFZ0I7NEJBQVNYO3dCQUFPO3dCQUNuRCxJQUFJLENBQUNHLFFBQVFVLHFCQUFxQjs0QkFDaEMsT0FBT0Q7d0JBQ1Q7d0JBQ0EsT0FBT1QsT0FBT1UsbUJBQW1CLENBQUNELFVBQVVIO29CQUM5QztnQkFDRjtZQUNGO1FBQ0Y7SUFDRjtBQUNGO0FBRUEsdUJBQXVCO0FBQ3ZCLFNBQVNLLGlCQUFpQkgsT0FBTztJQUMvQixJQUFJQSxXQUFXLFFBQVEsT0FBT0EsWUFBWSxZQUFZSSxNQUFNQyxPQUFPLENBQUNMLFVBQVU7UUFDNUUsT0FBTztJQUNUO0lBQ0EsT0FBTyxhQUFhQSxXQUFXQSxRQUFRTSxPQUFPLEtBQUssU0FBUyxZQUFZTixXQUFXLE9BQU9BLFFBQVFwQixNQUFNLEtBQUssWUFBWSxZQUFZb0I7QUFDdkk7QUFFeUQsQ0FDekQsdUNBQXVDO0NBQ3ZDLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsYXctd29ya3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS9ycGMtc3BlYy9kaXN0L2luZGV4Lm5vZGUubWpzP2E5NzAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU29sYW5hRXJyb3IsIFNPTEFOQV9FUlJPUl9fUlBDX19BUElfUExBTl9NSVNTSU5HX0ZPUl9SUENfTUVUSE9EIH0gZnJvbSAnQHNvbGFuYS9lcnJvcnMnO1xuaW1wb3J0IHsgY3JlYXRlUnBjTWVzc2FnZSB9IGZyb20gJ0Bzb2xhbmEvcnBjLXNwZWMtdHlwZXMnO1xuXG4vLyBzcmMvcnBjLnRzXG5mdW5jdGlvbiBjcmVhdGVScGMocnBjQ29uZmlnKSB7XG4gIHJldHVybiBtYWtlUHJveHkocnBjQ29uZmlnKTtcbn1cbmZ1bmN0aW9uIG1ha2VQcm94eShycGNDb25maWcpIHtcbiAgcmV0dXJuIG5ldyBQcm94eShycGNDb25maWcuYXBpLCB7XG4gICAgZGVmaW5lUHJvcGVydHkoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBkZWxldGVQcm9wZXJ0eSgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGdldCh0YXJnZXQsIHAsIHJlY2VpdmVyKSB7XG4gICAgICBpZiAocCA9PT0gXCJ0aGVuXCIpIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbiguLi5yYXdQYXJhbXMpIHtcbiAgICAgICAgY29uc3QgbWV0aG9kTmFtZSA9IHAudG9TdHJpbmcoKTtcbiAgICAgICAgY29uc3QgZ2V0QXBpUGxhbiA9IFJlZmxlY3QuZ2V0KHRhcmdldCwgbWV0aG9kTmFtZSwgcmVjZWl2ZXIpO1xuICAgICAgICBpZiAoIWdldEFwaVBsYW4pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19SUENfX0FQSV9QTEFOX01JU1NJTkdfRk9SX1JQQ19NRVRIT0QsIHtcbiAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kTmFtZSxcbiAgICAgICAgICAgIHBhcmFtczogcmF3UGFyYW1zXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGxhbiA9IGdldEFwaVBsYW4oLi4ucmF3UGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVBlbmRpbmdScGNSZXF1ZXN0KHJwY0NvbmZpZywgYXBpUGxhbik7XG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVQZW5kaW5nUnBjUmVxdWVzdCh7IHRyYW5zcG9ydCB9LCBwbGFuKSB7XG4gIHJldHVybiB7XG4gICAgYXN5bmMgc2VuZChvcHRpb25zKSB7XG4gICAgICByZXR1cm4gYXdhaXQgcGxhbi5leGVjdXRlKHsgc2lnbmFsOiBvcHRpb25zPy5hYm9ydFNpZ25hbCwgdHJhbnNwb3J0IH0pO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUpzb25ScGNBcGkoY29uZmlnKSB7XG4gIHJldHVybiBuZXcgUHJveHkoe30sIHtcbiAgICBkZWZpbmVQcm9wZXJ0eSgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGRlbGV0ZVByb3BlcnR5KCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgZ2V0KC4uLmFyZ3MpIHtcbiAgICAgIGNvbnN0IFtfLCBwXSA9IGFyZ3M7XG4gICAgICBjb25zdCBtZXRob2ROYW1lID0gcC50b1N0cmluZygpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKC4uLnJhd1BhcmFtcykge1xuICAgICAgICBjb25zdCByYXdSZXF1ZXN0ID0gT2JqZWN0LmZyZWV6ZSh7IG1ldGhvZE5hbWUsIHBhcmFtczogcmF3UGFyYW1zIH0pO1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gY29uZmlnPy5yZXF1ZXN0VHJhbnNmb3JtZXIgPyBjb25maWc/LnJlcXVlc3RUcmFuc2Zvcm1lcihyYXdSZXF1ZXN0KSA6IHJhd1JlcXVlc3Q7XG4gICAgICAgIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgICBleGVjdXRlOiBhc3luYyAoeyBzaWduYWwsIHRyYW5zcG9ydCB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gY3JlYXRlUnBjTWVzc2FnZShyZXF1ZXN0KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdHJhbnNwb3J0KHsgcGF5bG9hZCwgc2lnbmFsIH0pO1xuICAgICAgICAgICAgaWYgKCFjb25maWc/LnJlc3BvbnNlVHJhbnNmb3JtZXIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZy5yZXNwb25zZVRyYW5zZm9ybWVyKHJlc3BvbnNlLCByZXF1ZXN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzcmMvcnBjLXRyYW5zcG9ydC50c1xuZnVuY3Rpb24gaXNKc29uUnBjUGF5bG9hZChwYXlsb2FkKSB7XG4gIGlmIChwYXlsb2FkID09IG51bGwgfHwgdHlwZW9mIHBheWxvYWQgIT09IFwib2JqZWN0XCIgfHwgQXJyYXkuaXNBcnJheShwYXlsb2FkKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gXCJqc29ucnBjXCIgaW4gcGF5bG9hZCAmJiBwYXlsb2FkLmpzb25ycGMgPT09IFwiMi4wXCIgJiYgXCJtZXRob2RcIiBpbiBwYXlsb2FkICYmIHR5cGVvZiBwYXlsb2FkLm1ldGhvZCA9PT0gXCJzdHJpbmdcIiAmJiBcInBhcmFtc1wiIGluIHBheWxvYWQ7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZUpzb25ScGNBcGksIGNyZWF0ZVJwYywgaXNKc29uUnBjUGF5bG9hZCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubm9kZS5tanMubWFwXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5ub2RlLm1qcy5tYXAiXSwibmFtZXMiOlsiU29sYW5hRXJyb3IiLCJTT0xBTkFfRVJST1JfX1JQQ19fQVBJX1BMQU5fTUlTU0lOR19GT1JfUlBDX01FVEhPRCIsImNyZWF0ZVJwY01lc3NhZ2UiLCJjcmVhdGVScGMiLCJycGNDb25maWciLCJtYWtlUHJveHkiLCJQcm94eSIsImFwaSIsImRlZmluZVByb3BlcnR5IiwiZGVsZXRlUHJvcGVydHkiLCJnZXQiLCJ0YXJnZXQiLCJwIiwicmVjZWl2ZXIiLCJyYXdQYXJhbXMiLCJtZXRob2ROYW1lIiwidG9TdHJpbmciLCJnZXRBcGlQbGFuIiwiUmVmbGVjdCIsIm1ldGhvZCIsInBhcmFtcyIsImFwaVBsYW4iLCJjcmVhdGVQZW5kaW5nUnBjUmVxdWVzdCIsInRyYW5zcG9ydCIsInBsYW4iLCJzZW5kIiwib3B0aW9ucyIsImV4ZWN1dGUiLCJzaWduYWwiLCJhYm9ydFNpZ25hbCIsImNyZWF0ZUpzb25ScGNBcGkiLCJjb25maWciLCJhcmdzIiwiXyIsInJhd1JlcXVlc3QiLCJPYmplY3QiLCJmcmVlemUiLCJyZXF1ZXN0IiwicmVxdWVzdFRyYW5zZm9ybWVyIiwicGF5bG9hZCIsInJlc3BvbnNlIiwicmVzcG9uc2VUcmFuc2Zvcm1lciIsImlzSnNvblJwY1BheWxvYWQiLCJBcnJheSIsImlzQXJyYXkiLCJqc29ucnBjIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/rpc-spec/dist/index.node.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/rpc-transformers/dist/index.node.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@solana/rpc-transformers/dist/index.node.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   KEYPATH_WILDCARD: () => (/* binding */ KEYPATH_WILDCARD),\n/* harmony export */   getBigIntDowncastRequestTransformer: () => (/* binding */ getBigIntDowncastRequestTransformer),\n/* harmony export */   getBigIntUpcastResponseTransformer: () => (/* binding */ getBigIntUpcastResponseTransformer),\n/* harmony export */   getDefaultCommitmentRequestTransformer: () => (/* binding */ getDefaultCommitmentRequestTransformer),\n/* harmony export */   getDefaultRequestTransformerForSolanaRpc: () => (/* binding */ getDefaultRequestTransformerForSolanaRpc),\n/* harmony export */   getDefaultResponseTransformerForSolanaRpc: () => (/* binding */ getDefaultResponseTransformerForSolanaRpc),\n/* harmony export */   getDefaultResponseTransformerForSolanaRpcSubscriptions: () => (/* binding */ getDefaultResponseTransformerForSolanaRpcSubscriptions),\n/* harmony export */   getIntegerOverflowRequestTransformer: () => (/* binding */ getIntegerOverflowRequestTransformer),\n/* harmony export */   getResultResponseTransformer: () => (/* binding */ getResultResponseTransformer),\n/* harmony export */   getThrowSolanaErrorResponseTransformer: () => (/* binding */ getThrowSolanaErrorResponseTransformer),\n/* harmony export */   getTreeWalkerRequestTransformer: () => (/* binding */ getTreeWalkerRequestTransformer),\n/* harmony export */   getTreeWalkerResponseTransformer: () => (/* binding */ getTreeWalkerResponseTransformer),\n/* harmony export */   innerInstructionsConfigs: () => (/* binding */ innerInstructionsConfigs),\n/* harmony export */   jsonParsedAccountsConfigs: () => (/* binding */ jsonParsedAccountsConfigs),\n/* harmony export */   jsonParsedTokenAccountsConfigs: () => (/* binding */ jsonParsedTokenAccountsConfigs),\n/* harmony export */   messageConfig: () => (/* binding */ messageConfig)\n/* harmony export */ });\n/* harmony import */ var _solana_functional__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/functional */ \"(ssr)/./node_modules/@solana/functional/dist/index.node.mjs\");\n/* harmony import */ var _solana_errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana/errors */ \"(ssr)/./node_modules/@solana/errors/dist/index.node.mjs\");\n\n\n// src/request-transformer.ts\n// src/request-transformer-bigint-downcast-internal.ts\nfunction downcastNodeToNumberIfBigint(value) {\n    return typeof value === \"bigint\" ? // FIXME(solana-labs/solana/issues/30341) Create a data type to represent u64 in the Solana\n    // JSON RPC implementation so that we can throw away this entire patcher instead of unsafely\n    // downcasting `bigints` to `numbers`.\n    Number(value) : value;\n}\n// src/tree-traversal.ts\nvar KEYPATH_WILDCARD = {};\nfunction getTreeWalker(visitors) {\n    return function traverse(node, state) {\n        if (Array.isArray(node)) {\n            return node.map((element, ii)=>{\n                const nextState = {\n                    ...state,\n                    keyPath: [\n                        ...state.keyPath,\n                        ii\n                    ]\n                };\n                return traverse(element, nextState);\n            });\n        } else if (typeof node === \"object\" && node !== null) {\n            const out = {};\n            for(const propName in node){\n                if (!Object.prototype.hasOwnProperty.call(node, propName)) {\n                    continue;\n                }\n                const nextState = {\n                    ...state,\n                    keyPath: [\n                        ...state.keyPath,\n                        propName\n                    ]\n                };\n                out[propName] = traverse(node[propName], nextState);\n            }\n            return out;\n        } else {\n            return visitors.reduce((acc, visitNode)=>visitNode(acc, state), node);\n        }\n    };\n}\nfunction getTreeWalkerRequestTransformer(visitors, initialState) {\n    return (request)=>{\n        const traverse = getTreeWalker(visitors);\n        return Object.freeze({\n            ...request,\n            params: traverse(request.params, initialState)\n        });\n    };\n}\nfunction getTreeWalkerResponseTransformer(visitors, initialState) {\n    return (json)=>getTreeWalker(visitors)(json, initialState);\n}\n// src/request-transformer-bigint-downcast.ts\nfunction getBigIntDowncastRequestTransformer() {\n    return getTreeWalkerRequestTransformer([\n        downcastNodeToNumberIfBigint\n    ], {\n        keyPath: []\n    });\n}\n// src/request-transformer-default-commitment-internal.ts\nfunction applyDefaultCommitment({ commitmentPropertyName, params, optionsObjectPositionInParams, overrideCommitment }) {\n    const paramInTargetPosition = params[optionsObjectPositionInParams];\n    if (// There's no config.\n    paramInTargetPosition === void 0 || // There is a config object.\n    paramInTargetPosition && typeof paramInTargetPosition === \"object\" && !Array.isArray(paramInTargetPosition)) {\n        if (// The config object already has a commitment set.\n        paramInTargetPosition && commitmentPropertyName in paramInTargetPosition) {\n            if (!paramInTargetPosition[commitmentPropertyName] || paramInTargetPosition[commitmentPropertyName] === \"finalized\") {\n                const nextParams = [\n                    ...params\n                ];\n                const { [commitmentPropertyName]: _, // eslint-disable-line @typescript-eslint/no-unused-vars\n                ...rest } = paramInTargetPosition;\n                if (Object.keys(rest).length > 0) {\n                    nextParams[optionsObjectPositionInParams] = rest;\n                } else {\n                    if (optionsObjectPositionInParams === nextParams.length - 1) {\n                        nextParams.length--;\n                    } else {\n                        nextParams[optionsObjectPositionInParams] = void 0;\n                    }\n                }\n                return nextParams;\n            }\n        } else if (overrideCommitment !== \"finalized\") {\n            const nextParams = [\n                ...params\n            ];\n            nextParams[optionsObjectPositionInParams] = {\n                ...paramInTargetPosition,\n                [commitmentPropertyName]: overrideCommitment\n            };\n            return nextParams;\n        }\n    }\n    return params;\n}\n// src/request-transformer-default-commitment.ts\nfunction getDefaultCommitmentRequestTransformer({ defaultCommitment, optionsObjectPositionByMethod }) {\n    return (request)=>{\n        const { params, methodName } = request;\n        if (!Array.isArray(params)) {\n            return request;\n        }\n        const optionsObjectPositionInParams = optionsObjectPositionByMethod[methodName];\n        if (optionsObjectPositionInParams == null) {\n            return request;\n        }\n        return Object.freeze({\n            methodName,\n            params: applyDefaultCommitment({\n                commitmentPropertyName: methodName === \"sendTransaction\" ? \"preflightCommitment\" : \"commitment\",\n                optionsObjectPositionInParams,\n                overrideCommitment: defaultCommitment,\n                params\n            })\n        });\n    };\n}\n// src/request-transformer-integer-overflow-internal.ts\nfunction getIntegerOverflowNodeVisitor(onIntegerOverflow) {\n    return (value, { keyPath })=>{\n        if (typeof value === \"bigint\") {\n            if (onIntegerOverflow && (value > Number.MAX_SAFE_INTEGER || value < -Number.MAX_SAFE_INTEGER)) {\n                onIntegerOverflow(keyPath, value);\n            }\n        }\n        return value;\n    };\n}\n// src/request-transformer-integer-overflow.ts\nfunction getIntegerOverflowRequestTransformer(onIntegerOverflow) {\n    return (request)=>{\n        const transformer = getTreeWalkerRequestTransformer([\n            getIntegerOverflowNodeVisitor((...args)=>onIntegerOverflow(request, ...args))\n        ], {\n            keyPath: []\n        });\n        return transformer(request);\n    };\n}\n// src/request-transformer-options-object-position-config.ts\nvar OPTIONS_OBJECT_POSITION_BY_METHOD = {\n    accountNotifications: 1,\n    blockNotifications: 1,\n    getAccountInfo: 1,\n    getBalance: 1,\n    getBlock: 1,\n    getBlockHeight: 0,\n    getBlockProduction: 0,\n    getBlocks: 2,\n    getBlocksWithLimit: 2,\n    getEpochInfo: 0,\n    getFeeForMessage: 1,\n    getInflationGovernor: 0,\n    getInflationReward: 1,\n    getLargestAccounts: 0,\n    getLatestBlockhash: 0,\n    getLeaderSchedule: 1,\n    getMinimumBalanceForRentExemption: 1,\n    getMultipleAccounts: 1,\n    getProgramAccounts: 1,\n    getSignaturesForAddress: 1,\n    getSlot: 0,\n    getSlotLeader: 0,\n    getStakeMinimumDelegation: 0,\n    getSupply: 0,\n    getTokenAccountBalance: 1,\n    getTokenAccountsByDelegate: 2,\n    getTokenAccountsByOwner: 2,\n    getTokenLargestAccounts: 1,\n    getTokenSupply: 1,\n    getTransaction: 1,\n    getTransactionCount: 0,\n    getVoteAccounts: 0,\n    isBlockhashValid: 1,\n    logsNotifications: 1,\n    programNotifications: 1,\n    requestAirdrop: 2,\n    sendTransaction: 1,\n    signatureNotifications: 1,\n    simulateTransaction: 1\n};\n// src/request-transformer.ts\nfunction getDefaultRequestTransformerForSolanaRpc(config) {\n    const handleIntegerOverflow = config?.onIntegerOverflow;\n    return (request)=>{\n        return (0,_solana_functional__WEBPACK_IMPORTED_MODULE_0__.pipe)(request, handleIntegerOverflow ? getIntegerOverflowRequestTransformer(handleIntegerOverflow) : (r)=>r, getBigIntDowncastRequestTransformer(), getDefaultCommitmentRequestTransformer({\n            defaultCommitment: config?.defaultCommitment,\n            optionsObjectPositionByMethod: OPTIONS_OBJECT_POSITION_BY_METHOD\n        }));\n    };\n}\n// src/response-transformer-bigint-upcast-internal.ts\nfunction getBigIntUpcastVisitor(allowedNumericKeyPaths) {\n    return function upcastNodeToBigIntIfNumber(value, { keyPath }) {\n        const isInteger = typeof value === \"number\" && Number.isInteger(value) || typeof value === \"bigint\";\n        if (!isInteger) return value;\n        if (keyPathIsAllowedToBeNumeric(keyPath, allowedNumericKeyPaths)) {\n            return Number(value);\n        } else {\n            return BigInt(value);\n        }\n    };\n}\nfunction keyPathIsAllowedToBeNumeric(keyPath, allowedNumericKeyPaths) {\n    return allowedNumericKeyPaths.some((prohibitedKeyPath)=>{\n        if (prohibitedKeyPath.length !== keyPath.length) {\n            return false;\n        }\n        for(let ii = keyPath.length - 1; ii >= 0; ii--){\n            const keyPathPart = keyPath[ii];\n            const prohibitedKeyPathPart = prohibitedKeyPath[ii];\n            if (prohibitedKeyPathPart !== keyPathPart && (prohibitedKeyPathPart !== KEYPATH_WILDCARD || typeof keyPathPart !== \"number\")) {\n                return false;\n            }\n        }\n        return true;\n    });\n}\n// src/response-transformer-bigint-upcast.ts\nfunction getBigIntUpcastResponseTransformer(allowedNumericKeyPaths) {\n    return getTreeWalkerResponseTransformer([\n        getBigIntUpcastVisitor(allowedNumericKeyPaths)\n    ], {\n        keyPath: []\n    });\n}\n// src/response-transformer-result.ts\nfunction getResultResponseTransformer() {\n    return (json)=>json.result;\n}\n// src/response-transformer-allowed-numeric-values.ts\nvar jsonParsedTokenAccountsConfigs = [\n    // parsed Token/Token22 token account\n    [\n        \"data\",\n        \"parsed\",\n        \"info\",\n        \"tokenAmount\",\n        \"decimals\"\n    ],\n    [\n        \"data\",\n        \"parsed\",\n        \"info\",\n        \"tokenAmount\",\n        \"uiAmount\"\n    ],\n    [\n        \"data\",\n        \"parsed\",\n        \"info\",\n        \"rentExemptReserve\",\n        \"decimals\"\n    ],\n    [\n        \"data\",\n        \"parsed\",\n        \"info\",\n        \"rentExemptReserve\",\n        \"uiAmount\"\n    ],\n    [\n        \"data\",\n        \"parsed\",\n        \"info\",\n        \"delegatedAmount\",\n        \"decimals\"\n    ],\n    [\n        \"data\",\n        \"parsed\",\n        \"info\",\n        \"delegatedAmount\",\n        \"uiAmount\"\n    ],\n    [\n        \"data\",\n        \"parsed\",\n        \"info\",\n        \"extensions\",\n        KEYPATH_WILDCARD,\n        \"state\",\n        \"olderTransferFee\",\n        \"transferFeeBasisPoints\"\n    ],\n    [\n        \"data\",\n        \"parsed\",\n        \"info\",\n        \"extensions\",\n        KEYPATH_WILDCARD,\n        \"state\",\n        \"newerTransferFee\",\n        \"transferFeeBasisPoints\"\n    ],\n    [\n        \"data\",\n        \"parsed\",\n        \"info\",\n        \"extensions\",\n        KEYPATH_WILDCARD,\n        \"state\",\n        \"preUpdateAverageRate\"\n    ],\n    [\n        \"data\",\n        \"parsed\",\n        \"info\",\n        \"extensions\",\n        KEYPATH_WILDCARD,\n        \"state\",\n        \"currentRate\"\n    ]\n];\nvar jsonParsedAccountsConfigs = [\n    ...jsonParsedTokenAccountsConfigs,\n    // parsed AddressTableLookup account\n    [\n        \"data\",\n        \"parsed\",\n        \"info\",\n        \"lastExtendedSlotStartIndex\"\n    ],\n    // parsed Config account\n    [\n        \"data\",\n        \"parsed\",\n        \"info\",\n        \"slashPenalty\"\n    ],\n    [\n        \"data\",\n        \"parsed\",\n        \"info\",\n        \"warmupCooldownRate\"\n    ],\n    // parsed Token/Token22 mint account\n    [\n        \"data\",\n        \"parsed\",\n        \"info\",\n        \"decimals\"\n    ],\n    // parsed Token/Token22 multisig account\n    [\n        \"data\",\n        \"parsed\",\n        \"info\",\n        \"numRequiredSigners\"\n    ],\n    [\n        \"data\",\n        \"parsed\",\n        \"info\",\n        \"numValidSigners\"\n    ],\n    // parsed Stake account\n    [\n        \"data\",\n        \"parsed\",\n        \"info\",\n        \"stake\",\n        \"delegation\",\n        \"warmupCooldownRate\"\n    ],\n    // parsed Sysvar rent account\n    [\n        \"data\",\n        \"parsed\",\n        \"info\",\n        \"exemptionThreshold\"\n    ],\n    [\n        \"data\",\n        \"parsed\",\n        \"info\",\n        \"burnPercent\"\n    ],\n    // parsed Vote account\n    [\n        \"data\",\n        \"parsed\",\n        \"info\",\n        \"commission\"\n    ],\n    [\n        \"data\",\n        \"parsed\",\n        \"info\",\n        \"votes\",\n        KEYPATH_WILDCARD,\n        \"confirmationCount\"\n    ]\n];\nvar innerInstructionsConfigs = [\n    [\n        \"index\"\n    ],\n    [\n        \"instructions\",\n        KEYPATH_WILDCARD,\n        \"accounts\",\n        KEYPATH_WILDCARD\n    ],\n    [\n        \"instructions\",\n        KEYPATH_WILDCARD,\n        \"programIdIndex\"\n    ],\n    [\n        \"instructions\",\n        KEYPATH_WILDCARD,\n        \"stackHeight\"\n    ]\n];\nvar messageConfig = [\n    [\n        \"addressTableLookups\",\n        KEYPATH_WILDCARD,\n        \"writableIndexes\",\n        KEYPATH_WILDCARD\n    ],\n    [\n        \"addressTableLookups\",\n        KEYPATH_WILDCARD,\n        \"readonlyIndexes\",\n        KEYPATH_WILDCARD\n    ],\n    [\n        \"header\",\n        \"numReadonlySignedAccounts\"\n    ],\n    [\n        \"header\",\n        \"numReadonlyUnsignedAccounts\"\n    ],\n    [\n        \"header\",\n        \"numRequiredSignatures\"\n    ],\n    [\n        \"instructions\",\n        KEYPATH_WILDCARD,\n        \"accounts\",\n        KEYPATH_WILDCARD\n    ],\n    [\n        \"instructions\",\n        KEYPATH_WILDCARD,\n        \"programIdIndex\"\n    ],\n    [\n        \"instructions\",\n        KEYPATH_WILDCARD,\n        \"stackHeight\"\n    ]\n];\n// src/response-transformer-throw-solana-error.ts\nfunction getSimulateTransactionAllowedNumericKeypaths() {\n    return [\n        [\n            \"loadedAccountsDataSize\"\n        ],\n        ...jsonParsedAccountsConfigs.map((c)=>[\n                \"accounts\",\n                KEYPATH_WILDCARD,\n                ...c\n            ]),\n        ...innerInstructionsConfigs.map((c)=>[\n                \"innerInstructions\",\n                KEYPATH_WILDCARD,\n                ...c\n            ])\n    ];\n}\nfunction getThrowSolanaErrorResponseTransformer() {\n    return (json, request)=>{\n        const jsonRpcResponse = json;\n        if (\"error\" in jsonRpcResponse) {\n            const { error } = jsonRpcResponse;\n            const isSendTransactionPreflightFailure = error && typeof error === \"object\" && \"code\" in error && (error.code === -32002 || error.code === -32002n);\n            if (isSendTransactionPreflightFailure && \"data\" in error && error.data) {\n                const treeWalker = getTreeWalkerResponseTransformer([\n                    getBigIntUpcastVisitor(getSimulateTransactionAllowedNumericKeypaths())\n                ], {\n                    keyPath: []\n                });\n                const transformedData = treeWalker(error.data, request);\n                const transformedError = {\n                    ...error,\n                    data: transformedData\n                };\n                throw (0,_solana_errors__WEBPACK_IMPORTED_MODULE_1__.getSolanaErrorFromJsonRpcError)(transformedError);\n            }\n            throw (0,_solana_errors__WEBPACK_IMPORTED_MODULE_1__.getSolanaErrorFromJsonRpcError)(jsonRpcResponse.error);\n        }\n        return jsonRpcResponse;\n    };\n}\n// src/response-transformer.ts\nfunction getDefaultResponseTransformerForSolanaRpc(config) {\n    return (response, request)=>{\n        const methodName = request.methodName;\n        const keyPaths = config?.allowedNumericKeyPaths && methodName ? config.allowedNumericKeyPaths[methodName] : void 0;\n        return (0,_solana_functional__WEBPACK_IMPORTED_MODULE_0__.pipe)(response, (r)=>getThrowSolanaErrorResponseTransformer()(r, request), (r)=>getResultResponseTransformer()(r, request), (r)=>getBigIntUpcastResponseTransformer(keyPaths ?? [])(r, request));\n    };\n}\nfunction getDefaultResponseTransformerForSolanaRpcSubscriptions(config) {\n    return (response, request)=>{\n        const methodName = request.methodName;\n        const keyPaths = config?.allowedNumericKeyPaths && methodName ? config.allowedNumericKeyPaths[methodName] : void 0;\n        return (0,_solana_functional__WEBPACK_IMPORTED_MODULE_0__.pipe)(response, (r)=>getBigIntUpcastResponseTransformer(keyPaths ?? [])(r, request));\n    };\n}\n //# sourceMappingURL=index.node.mjs.map\n //# sourceMappingURL=index.node.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS9ycGMtdHJhbnNmb3JtZXJzL2Rpc3QvaW5kZXgubm9kZS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTBDO0FBQ3NCO0FBRWhFLDZCQUE2QjtBQUU3QixzREFBc0Q7QUFDdEQsU0FBU0UsNkJBQTZCQyxLQUFLO0lBQ3pDLE9BQU8sT0FBT0EsVUFBVSxXQUN0QiwyRkFBMkY7SUFDM0YsNEZBQTRGO0lBQzVGLHNDQUFzQztJQUN0Q0MsT0FBT0QsU0FDTEE7QUFDTjtBQUVBLHdCQUF3QjtBQUN4QixJQUFJRSxtQkFBbUIsQ0FBQztBQUN4QixTQUFTQyxjQUFjQyxRQUFRO0lBQzdCLE9BQU8sU0FBU0MsU0FBU0MsSUFBSSxFQUFFQyxLQUFLO1FBQ2xDLElBQUlDLE1BQU1DLE9BQU8sQ0FBQ0gsT0FBTztZQUN2QixPQUFPQSxLQUFLSSxHQUFHLENBQUMsQ0FBQ0MsU0FBU0M7Z0JBQ3hCLE1BQU1DLFlBQVk7b0JBQ2hCLEdBQUdOLEtBQUs7b0JBQ1JPLFNBQVM7MkJBQUlQLE1BQU1PLE9BQU87d0JBQUVGO3FCQUFHO2dCQUNqQztnQkFDQSxPQUFPUCxTQUFTTSxTQUFTRTtZQUMzQjtRQUNGLE9BQU8sSUFBSSxPQUFPUCxTQUFTLFlBQVlBLFNBQVMsTUFBTTtZQUNwRCxNQUFNUyxNQUFNLENBQUM7WUFDYixJQUFLLE1BQU1DLFlBQVlWLEtBQU07Z0JBQzNCLElBQUksQ0FBQ1csT0FBT0MsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ2QsTUFBTVUsV0FBVztvQkFDekQ7Z0JBQ0Y7Z0JBQ0EsTUFBTUgsWUFBWTtvQkFDaEIsR0FBR04sS0FBSztvQkFDUk8sU0FBUzsyQkFBSVAsTUFBTU8sT0FBTzt3QkFBRUU7cUJBQVM7Z0JBQ3ZDO2dCQUNBRCxHQUFHLENBQUNDLFNBQVMsR0FBR1gsU0FBU0MsSUFBSSxDQUFDVSxTQUFTLEVBQUVIO1lBQzNDO1lBQ0EsT0FBT0U7UUFDVCxPQUFPO1lBQ0wsT0FBT1gsU0FBU2lCLE1BQU0sQ0FBQyxDQUFDQyxLQUFLQyxZQUFjQSxVQUFVRCxLQUFLZixRQUFRRDtRQUNwRTtJQUNGO0FBQ0Y7QUFDQSxTQUFTa0IsZ0NBQWdDcEIsUUFBUSxFQUFFcUIsWUFBWTtJQUM3RCxPQUFPLENBQUNDO1FBQ04sTUFBTXJCLFdBQVdGLGNBQWNDO1FBQy9CLE9BQU9hLE9BQU9VLE1BQU0sQ0FBQztZQUNuQixHQUFHRCxPQUFPO1lBQ1ZFLFFBQVF2QixTQUFTcUIsUUFBUUUsTUFBTSxFQUFFSDtRQUNuQztJQUNGO0FBQ0Y7QUFDQSxTQUFTSSxpQ0FBaUN6QixRQUFRLEVBQUVxQixZQUFZO0lBQzlELE9BQU8sQ0FBQ0ssT0FBUzNCLGNBQWNDLFVBQVUwQixNQUFNTDtBQUNqRDtBQUVBLDZDQUE2QztBQUM3QyxTQUFTTTtJQUNQLE9BQU9QLGdDQUFnQztRQUFDekI7S0FBNkIsRUFBRTtRQUFFZSxTQUFTLEVBQUU7SUFBQztBQUN2RjtBQUVBLHlEQUF5RDtBQUN6RCxTQUFTa0IsdUJBQXVCLEVBQzlCQyxzQkFBc0IsRUFDdEJMLE1BQU0sRUFDTk0sNkJBQTZCLEVBQzdCQyxrQkFBa0IsRUFDbkI7SUFDQyxNQUFNQyx3QkFBd0JSLE1BQU0sQ0FBQ00sOEJBQThCO0lBQ25FLElBQ0UscUJBQXFCO0lBQ3JCRSwwQkFBMEIsS0FBSyxLQUFLLDRCQUE0QjtJQUNoRUEseUJBQXlCLE9BQU9BLDBCQUEwQixZQUFZLENBQUM1QixNQUFNQyxPQUFPLENBQUMyQix3QkFDckY7UUFDQSxJQUNFLGtEQUFrRDtRQUNsREEseUJBQXlCSCwwQkFBMEJHLHVCQUNuRDtZQUNBLElBQUksQ0FBQ0EscUJBQXFCLENBQUNILHVCQUF1QixJQUFJRyxxQkFBcUIsQ0FBQ0gsdUJBQXVCLEtBQUssYUFBYTtnQkFDbkgsTUFBTUksYUFBYTt1QkFBSVQ7aUJBQU87Z0JBQzlCLE1BQU0sRUFDSixDQUFDSyx1QkFBdUIsRUFBRUssQ0FBQyxFQUMzQix3REFBd0Q7Z0JBQ3hELEdBQUdDLE1BQ0osR0FBR0g7Z0JBQ0osSUFBSW5CLE9BQU91QixJQUFJLENBQUNELE1BQU1FLE1BQU0sR0FBRyxHQUFHO29CQUNoQ0osVUFBVSxDQUFDSCw4QkFBOEIsR0FBR0s7Z0JBQzlDLE9BQU87b0JBQ0wsSUFBSUwsa0NBQWtDRyxXQUFXSSxNQUFNLEdBQUcsR0FBRzt3QkFDM0RKLFdBQVdJLE1BQU07b0JBQ25CLE9BQU87d0JBQ0xKLFVBQVUsQ0FBQ0gsOEJBQThCLEdBQUcsS0FBSztvQkFDbkQ7Z0JBQ0Y7Z0JBQ0EsT0FBT0c7WUFDVDtRQUNGLE9BQU8sSUFBSUYsdUJBQXVCLGFBQWE7WUFDN0MsTUFBTUUsYUFBYTttQkFBSVQ7YUFBTztZQUM5QlMsVUFBVSxDQUFDSCw4QkFBOEIsR0FBRztnQkFDMUMsR0FBR0UscUJBQXFCO2dCQUN4QixDQUFDSCx1QkFBdUIsRUFBRUU7WUFDNUI7WUFDQSxPQUFPRTtRQUNUO0lBQ0Y7SUFDQSxPQUFPVDtBQUNUO0FBRUEsZ0RBQWdEO0FBQ2hELFNBQVNjLHVDQUF1QyxFQUM5Q0MsaUJBQWlCLEVBQ2pCQyw2QkFBNkIsRUFDOUI7SUFDQyxPQUFPLENBQUNsQjtRQUNOLE1BQU0sRUFBRUUsTUFBTSxFQUFFaUIsVUFBVSxFQUFFLEdBQUduQjtRQUMvQixJQUFJLENBQUNsQixNQUFNQyxPQUFPLENBQUNtQixTQUFTO1lBQzFCLE9BQU9GO1FBQ1Q7UUFDQSxNQUFNUSxnQ0FBZ0NVLDZCQUE2QixDQUFDQyxXQUFXO1FBQy9FLElBQUlYLGlDQUFpQyxNQUFNO1lBQ3pDLE9BQU9SO1FBQ1Q7UUFDQSxPQUFPVCxPQUFPVSxNQUFNLENBQUM7WUFDbkJrQjtZQUNBakIsUUFBUUksdUJBQXVCO2dCQUM3QkMsd0JBQXdCWSxlQUFlLG9CQUFvQix3QkFBd0I7Z0JBQ25GWDtnQkFDQUMsb0JBQW9CUTtnQkFDcEJmO1lBQ0Y7UUFDRjtJQUNGO0FBQ0Y7QUFFQSx1REFBdUQ7QUFDdkQsU0FBU2tCLDhCQUE4QkMsaUJBQWlCO0lBQ3RELE9BQU8sQ0FBQy9DLE9BQU8sRUFBRWMsT0FBTyxFQUFFO1FBQ3hCLElBQUksT0FBT2QsVUFBVSxVQUFVO1lBQzdCLElBQUkrQyxxQkFBc0IvQyxDQUFBQSxRQUFRQyxPQUFPK0MsZ0JBQWdCLElBQUloRCxRQUFRLENBQUNDLE9BQU8rQyxnQkFBZ0IsR0FBRztnQkFDOUZELGtCQUFrQmpDLFNBQVNkO1lBQzdCO1FBQ0Y7UUFDQSxPQUFPQTtJQUNUO0FBQ0Y7QUFFQSw4Q0FBOEM7QUFDOUMsU0FBU2lELHFDQUFxQ0YsaUJBQWlCO0lBQzdELE9BQU8sQ0FBQ3JCO1FBQ04sTUFBTXdCLGNBQWMxQixnQ0FDbEI7WUFBQ3NCLDhCQUE4QixDQUFDLEdBQUdLLE9BQVNKLGtCQUFrQnJCLFlBQVl5QjtTQUFPLEVBQ2pGO1lBQUVyQyxTQUFTLEVBQUU7UUFBQztRQUVoQixPQUFPb0MsWUFBWXhCO0lBQ3JCO0FBQ0Y7QUFFQSw0REFBNEQ7QUFDNUQsSUFBSTBCLG9DQUFvQztJQUN0Q0Msc0JBQXNCO0lBQ3RCQyxvQkFBb0I7SUFDcEJDLGdCQUFnQjtJQUNoQkMsWUFBWTtJQUNaQyxVQUFVO0lBQ1ZDLGdCQUFnQjtJQUNoQkMsb0JBQW9CO0lBQ3BCQyxXQUFXO0lBQ1hDLG9CQUFvQjtJQUNwQkMsY0FBYztJQUNkQyxrQkFBa0I7SUFDbEJDLHNCQUFzQjtJQUN0QkMsb0JBQW9CO0lBQ3BCQyxvQkFBb0I7SUFDcEJDLG9CQUFvQjtJQUNwQkMsbUJBQW1CO0lBQ25CQyxtQ0FBbUM7SUFDbkNDLHFCQUFxQjtJQUNyQkMsb0JBQW9CO0lBQ3BCQyx5QkFBeUI7SUFDekJDLFNBQVM7SUFDVEMsZUFBZTtJQUNmQywyQkFBMkI7SUFDM0JDLFdBQVc7SUFDWEMsd0JBQXdCO0lBQ3hCQyw0QkFBNEI7SUFDNUJDLHlCQUF5QjtJQUN6QkMseUJBQXlCO0lBQ3pCQyxnQkFBZ0I7SUFDaEJDLGdCQUFnQjtJQUNoQkMscUJBQXFCO0lBQ3JCQyxpQkFBaUI7SUFDakJDLGtCQUFrQjtJQUNsQkMsbUJBQW1CO0lBQ25CQyxzQkFBc0I7SUFDdEJDLGdCQUFnQjtJQUNoQkMsaUJBQWlCO0lBQ2pCQyx3QkFBd0I7SUFDeEJDLHFCQUFxQjtBQUN2QjtBQUVBLDZCQUE2QjtBQUM3QixTQUFTQyx5Q0FBeUNDLE1BQU07SUFDdEQsTUFBTUMsd0JBQXdCRCxRQUFROUM7SUFDdEMsT0FBTyxDQUFDckI7UUFDTixPQUFPN0Isd0RBQUlBLENBQ1Q2QixTQUNBb0Usd0JBQXdCN0MscUNBQXFDNkMseUJBQXlCLENBQUNDLElBQU1BLEdBQzdGaEUsdUNBQ0FXLHVDQUF1QztZQUNyQ0MsbUJBQW1Ca0QsUUFBUWxEO1lBQzNCQywrQkFBK0JRO1FBQ2pDO0lBRUo7QUFDRjtBQUVBLHFEQUFxRDtBQUNyRCxTQUFTNEMsdUJBQXVCQyxzQkFBc0I7SUFDcEQsT0FBTyxTQUFTQywyQkFBMkJsRyxLQUFLLEVBQUUsRUFBRWMsT0FBTyxFQUFFO1FBQzNELE1BQU1xRixZQUFZLE9BQU9uRyxVQUFVLFlBQVlDLE9BQU9rRyxTQUFTLENBQUNuRyxVQUFVLE9BQU9BLFVBQVU7UUFDM0YsSUFBSSxDQUFDbUcsV0FBVyxPQUFPbkc7UUFDdkIsSUFBSW9HLDRCQUE0QnRGLFNBQVNtRix5QkFBeUI7WUFDaEUsT0FBT2hHLE9BQU9EO1FBQ2hCLE9BQU87WUFDTCxPQUFPcUcsT0FBT3JHO1FBQ2hCO0lBQ0Y7QUFDRjtBQUNBLFNBQVNvRyw0QkFBNEJ0RixPQUFPLEVBQUVtRixzQkFBc0I7SUFDbEUsT0FBT0EsdUJBQXVCSyxJQUFJLENBQUMsQ0FBQ0M7UUFDbEMsSUFBSUEsa0JBQWtCOUQsTUFBTSxLQUFLM0IsUUFBUTJCLE1BQU0sRUFBRTtZQUMvQyxPQUFPO1FBQ1Q7UUFDQSxJQUFLLElBQUk3QixLQUFLRSxRQUFRMkIsTUFBTSxHQUFHLEdBQUc3QixNQUFNLEdBQUdBLEtBQU07WUFDL0MsTUFBTTRGLGNBQWMxRixPQUFPLENBQUNGLEdBQUc7WUFDL0IsTUFBTTZGLHdCQUF3QkYsaUJBQWlCLENBQUMzRixHQUFHO1lBQ25ELElBQUk2RiwwQkFBMEJELGVBQWdCQyxDQUFBQSwwQkFBMEJ2RyxvQkFBb0IsT0FBT3NHLGdCQUFnQixRQUFPLEdBQUk7Z0JBQzVILE9BQU87WUFDVDtRQUNGO1FBQ0EsT0FBTztJQUNUO0FBQ0Y7QUFFQSw0Q0FBNEM7QUFDNUMsU0FBU0UsbUNBQW1DVCxzQkFBc0I7SUFDaEUsT0FBT3BFLGlDQUFpQztRQUFDbUUsdUJBQXVCQztLQUF3QixFQUFFO1FBQUVuRixTQUFTLEVBQUU7SUFBQztBQUMxRztBQUVBLHFDQUFxQztBQUNyQyxTQUFTNkY7SUFDUCxPQUFPLENBQUM3RSxPQUFTQSxLQUFLOEUsTUFBTTtBQUM5QjtBQUVBLHFEQUFxRDtBQUNyRCxJQUFJQyxpQ0FBaUM7SUFDbkMscUNBQXFDO0lBQ3JDO1FBQUM7UUFBUTtRQUFVO1FBQVE7UUFBZTtLQUFXO0lBQ3JEO1FBQUM7UUFBUTtRQUFVO1FBQVE7UUFBZTtLQUFXO0lBQ3JEO1FBQUM7UUFBUTtRQUFVO1FBQVE7UUFBcUI7S0FBVztJQUMzRDtRQUFDO1FBQVE7UUFBVTtRQUFRO1FBQXFCO0tBQVc7SUFDM0Q7UUFBQztRQUFRO1FBQVU7UUFBUTtRQUFtQjtLQUFXO0lBQ3pEO1FBQUM7UUFBUTtRQUFVO1FBQVE7UUFBbUI7S0FBVztJQUN6RDtRQUFDO1FBQVE7UUFBVTtRQUFRO1FBQWMzRztRQUFrQjtRQUFTO1FBQW9CO0tBQXlCO0lBQ2pIO1FBQUM7UUFBUTtRQUFVO1FBQVE7UUFBY0E7UUFBa0I7UUFBUztRQUFvQjtLQUF5QjtJQUNqSDtRQUFDO1FBQVE7UUFBVTtRQUFRO1FBQWNBO1FBQWtCO1FBQVM7S0FBdUI7SUFDM0Y7UUFBQztRQUFRO1FBQVU7UUFBUTtRQUFjQTtRQUFrQjtRQUFTO0tBQWM7Q0FDbkY7QUFDRCxJQUFJNEcsNEJBQTRCO09BQzNCRDtJQUNILG9DQUFvQztJQUNwQztRQUFDO1FBQVE7UUFBVTtRQUFRO0tBQTZCO0lBQ3hELHdCQUF3QjtJQUN4QjtRQUFDO1FBQVE7UUFBVTtRQUFRO0tBQWU7SUFDMUM7UUFBQztRQUFRO1FBQVU7UUFBUTtLQUFxQjtJQUNoRCxvQ0FBb0M7SUFDcEM7UUFBQztRQUFRO1FBQVU7UUFBUTtLQUFXO0lBQ3RDLHdDQUF3QztJQUN4QztRQUFDO1FBQVE7UUFBVTtRQUFRO0tBQXFCO0lBQ2hEO1FBQUM7UUFBUTtRQUFVO1FBQVE7S0FBa0I7SUFDN0MsdUJBQXVCO0lBQ3ZCO1FBQUM7UUFBUTtRQUFVO1FBQVE7UUFBUztRQUFjO0tBQXFCO0lBQ3ZFLDZCQUE2QjtJQUM3QjtRQUFDO1FBQVE7UUFBVTtRQUFRO0tBQXFCO0lBQ2hEO1FBQUM7UUFBUTtRQUFVO1FBQVE7S0FBYztJQUN6QyxzQkFBc0I7SUFDdEI7UUFBQztRQUFRO1FBQVU7UUFBUTtLQUFhO0lBQ3hDO1FBQUM7UUFBUTtRQUFVO1FBQVE7UUFBUzNHO1FBQWtCO0tBQW9CO0NBQzNFO0FBQ0QsSUFBSTZHLDJCQUEyQjtJQUM3QjtRQUFDO0tBQVE7SUFDVDtRQUFDO1FBQWdCN0c7UUFBa0I7UUFBWUE7S0FBaUI7SUFDaEU7UUFBQztRQUFnQkE7UUFBa0I7S0FBaUI7SUFDcEQ7UUFBQztRQUFnQkE7UUFBa0I7S0FBYztDQUNsRDtBQUNELElBQUk4RyxnQkFBZ0I7SUFDbEI7UUFBQztRQUF1QjlHO1FBQWtCO1FBQW1CQTtLQUFpQjtJQUM5RTtRQUFDO1FBQXVCQTtRQUFrQjtRQUFtQkE7S0FBaUI7SUFDOUU7UUFBQztRQUFVO0tBQTRCO0lBQ3ZDO1FBQUM7UUFBVTtLQUE4QjtJQUN6QztRQUFDO1FBQVU7S0FBd0I7SUFDbkM7UUFBQztRQUFnQkE7UUFBa0I7UUFBWUE7S0FBaUI7SUFDaEU7UUFBQztRQUFnQkE7UUFBa0I7S0FBaUI7SUFDcEQ7UUFBQztRQUFnQkE7UUFBa0I7S0FBYztDQUNsRDtBQUVELGlEQUFpRDtBQUNqRCxTQUFTK0c7SUFDUCxPQUFPO1FBQ0w7WUFBQztTQUF5QjtXQUN2QkgsMEJBQTBCcEcsR0FBRyxDQUFDLENBQUN3RyxJQUFNO2dCQUFDO2dCQUFZaEg7bUJBQXFCZ0g7YUFBRTtXQUN6RUgseUJBQXlCckcsR0FBRyxDQUFDLENBQUN3RyxJQUFNO2dCQUFDO2dCQUFxQmhIO21CQUFxQmdIO2FBQUU7S0FDckY7QUFDSDtBQUNBLFNBQVNDO0lBQ1AsT0FBTyxDQUFDckYsTUFBTUo7UUFDWixNQUFNMEYsa0JBQWtCdEY7UUFDeEIsSUFBSSxXQUFXc0YsaUJBQWlCO1lBQzlCLE1BQU0sRUFBRUMsS0FBSyxFQUFFLEdBQUdEO1lBQ2xCLE1BQU1FLG9DQUFvQ0QsU0FBUyxPQUFPQSxVQUFVLFlBQVksVUFBVUEsU0FBVUEsQ0FBQUEsTUFBTUUsSUFBSSxLQUFLLENBQUMsU0FBU0YsTUFBTUUsSUFBSSxLQUFLLENBQUMsTUFBTTtZQUNuSixJQUFJRCxxQ0FBcUMsVUFBVUQsU0FBU0EsTUFBTUcsSUFBSSxFQUFFO2dCQUN0RSxNQUFNQyxhQUFhNUYsaUNBQ2pCO29CQUFDbUUsdUJBQXVCaUI7aUJBQWdELEVBQ3hFO29CQUFFbkcsU0FBUyxFQUFFO2dCQUFDO2dCQUVoQixNQUFNNEcsa0JBQWtCRCxXQUFXSixNQUFNRyxJQUFJLEVBQUU5RjtnQkFDL0MsTUFBTWlHLG1CQUFtQjtvQkFBRSxHQUFHTixLQUFLO29CQUFFRyxNQUFNRTtnQkFBZ0I7Z0JBQzNELE1BQU01SCw4RUFBOEJBLENBQUM2SDtZQUN2QztZQUNBLE1BQU03SCw4RUFBOEJBLENBQUNzSCxnQkFBZ0JDLEtBQUs7UUFDNUQ7UUFDQSxPQUFPRDtJQUNUO0FBQ0Y7QUFFQSw4QkFBOEI7QUFDOUIsU0FBU1EsMENBQTBDL0IsTUFBTTtJQUN2RCxPQUFPLENBQUNnQyxVQUFVbkc7UUFDaEIsTUFBTW1CLGFBQWFuQixRQUFRbUIsVUFBVTtRQUNyQyxNQUFNaUYsV0FBV2pDLFFBQVFJLDBCQUEwQnBELGFBQWFnRCxPQUFPSSxzQkFBc0IsQ0FBQ3BELFdBQVcsR0FBRyxLQUFLO1FBQ2pILE9BQU9oRCx3REFBSUEsQ0FDVGdJLFVBQ0EsQ0FBQzlCLElBQU1vQix5Q0FBeUNwQixHQUFHckUsVUFDbkQsQ0FBQ3FFLElBQU1ZLCtCQUErQlosR0FBR3JFLFVBQ3pDLENBQUNxRSxJQUFNVyxtQ0FBbUNvQixZQUFZLEVBQUUsRUFBRS9CLEdBQUdyRTtJQUVqRTtBQUNGO0FBQ0EsU0FBU3FHLHVEQUF1RGxDLE1BQU07SUFDcEUsT0FBTyxDQUFDZ0MsVUFBVW5HO1FBQ2hCLE1BQU1tQixhQUFhbkIsUUFBUW1CLFVBQVU7UUFDckMsTUFBTWlGLFdBQVdqQyxRQUFRSSwwQkFBMEJwRCxhQUFhZ0QsT0FBT0ksc0JBQXNCLENBQUNwRCxXQUFXLEdBQUcsS0FBSztRQUNqSCxPQUFPaEQsd0RBQUlBLENBQUNnSSxVQUFVLENBQUM5QixJQUFNVyxtQ0FBbUNvQixZQUFZLEVBQUUsRUFBRS9CLEdBQUdyRTtJQUNyRjtBQUNGO0FBRTZpQixDQUM3aUIsdUNBQXVDO0NBQ3ZDLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsYXctd29ya3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS9ycGMtdHJhbnNmb3JtZXJzL2Rpc3QvaW5kZXgubm9kZS5tanM/MjZjNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwaXBlIH0gZnJvbSAnQHNvbGFuYS9mdW5jdGlvbmFsJztcbmltcG9ydCB7IGdldFNvbGFuYUVycm9yRnJvbUpzb25ScGNFcnJvciB9IGZyb20gJ0Bzb2xhbmEvZXJyb3JzJztcblxuLy8gc3JjL3JlcXVlc3QtdHJhbnNmb3JtZXIudHNcblxuLy8gc3JjL3JlcXVlc3QtdHJhbnNmb3JtZXItYmlnaW50LWRvd25jYXN0LWludGVybmFsLnRzXG5mdW5jdGlvbiBkb3duY2FzdE5vZGVUb051bWJlcklmQmlnaW50KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwiYmlnaW50XCIgPyAoXG4gICAgLy8gRklYTUUoc29sYW5hLWxhYnMvc29sYW5hL2lzc3Vlcy8zMDM0MSkgQ3JlYXRlIGEgZGF0YSB0eXBlIHRvIHJlcHJlc2VudCB1NjQgaW4gdGhlIFNvbGFuYVxuICAgIC8vIEpTT04gUlBDIGltcGxlbWVudGF0aW9uIHNvIHRoYXQgd2UgY2FuIHRocm93IGF3YXkgdGhpcyBlbnRpcmUgcGF0Y2hlciBpbnN0ZWFkIG9mIHVuc2FmZWx5XG4gICAgLy8gZG93bmNhc3RpbmcgYGJpZ2ludHNgIHRvIGBudW1iZXJzYC5cbiAgICBOdW1iZXIodmFsdWUpXG4gICkgOiB2YWx1ZTtcbn1cblxuLy8gc3JjL3RyZWUtdHJhdmVyc2FsLnRzXG52YXIgS0VZUEFUSF9XSUxEQ0FSRCA9IHt9O1xuZnVuY3Rpb24gZ2V0VHJlZVdhbGtlcih2aXNpdG9ycykge1xuICByZXR1cm4gZnVuY3Rpb24gdHJhdmVyc2Uobm9kZSwgc3RhdGUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgICAgcmV0dXJuIG5vZGUubWFwKChlbGVtZW50LCBpaSkgPT4ge1xuICAgICAgICBjb25zdCBuZXh0U3RhdGUgPSB7XG4gICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAga2V5UGF0aDogWy4uLnN0YXRlLmtleVBhdGgsIGlpXVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdHJhdmVyc2UoZWxlbWVudCwgbmV4dFN0YXRlKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG5vZGUgPT09IFwib2JqZWN0XCIgJiYgbm9kZSAhPT0gbnVsbCkge1xuICAgICAgY29uc3Qgb3V0ID0ge307XG4gICAgICBmb3IgKGNvbnN0IHByb3BOYW1lIGluIG5vZGUpIHtcbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobm9kZSwgcHJvcE5hbWUpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV4dFN0YXRlID0ge1xuICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgIGtleVBhdGg6IFsuLi5zdGF0ZS5rZXlQYXRoLCBwcm9wTmFtZV1cbiAgICAgICAgfTtcbiAgICAgICAgb3V0W3Byb3BOYW1lXSA9IHRyYXZlcnNlKG5vZGVbcHJvcE5hbWVdLCBuZXh0U3RhdGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZpc2l0b3JzLnJlZHVjZSgoYWNjLCB2aXNpdE5vZGUpID0+IHZpc2l0Tm9kZShhY2MsIHN0YXRlKSwgbm9kZSk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0VHJlZVdhbGtlclJlcXVlc3RUcmFuc2Zvcm1lcih2aXNpdG9ycywgaW5pdGlhbFN0YXRlKSB7XG4gIHJldHVybiAocmVxdWVzdCkgPT4ge1xuICAgIGNvbnN0IHRyYXZlcnNlID0gZ2V0VHJlZVdhbGtlcih2aXNpdG9ycyk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgICAgLi4ucmVxdWVzdCxcbiAgICAgIHBhcmFtczogdHJhdmVyc2UocmVxdWVzdC5wYXJhbXMsIGluaXRpYWxTdGF0ZSlcbiAgICB9KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFRyZWVXYWxrZXJSZXNwb25zZVRyYW5zZm9ybWVyKHZpc2l0b3JzLCBpbml0aWFsU3RhdGUpIHtcbiAgcmV0dXJuIChqc29uKSA9PiBnZXRUcmVlV2Fsa2VyKHZpc2l0b3JzKShqc29uLCBpbml0aWFsU3RhdGUpO1xufVxuXG4vLyBzcmMvcmVxdWVzdC10cmFuc2Zvcm1lci1iaWdpbnQtZG93bmNhc3QudHNcbmZ1bmN0aW9uIGdldEJpZ0ludERvd25jYXN0UmVxdWVzdFRyYW5zZm9ybWVyKCkge1xuICByZXR1cm4gZ2V0VHJlZVdhbGtlclJlcXVlc3RUcmFuc2Zvcm1lcihbZG93bmNhc3ROb2RlVG9OdW1iZXJJZkJpZ2ludF0sIHsga2V5UGF0aDogW10gfSk7XG59XG5cbi8vIHNyYy9yZXF1ZXN0LXRyYW5zZm9ybWVyLWRlZmF1bHQtY29tbWl0bWVudC1pbnRlcm5hbC50c1xuZnVuY3Rpb24gYXBwbHlEZWZhdWx0Q29tbWl0bWVudCh7XG4gIGNvbW1pdG1lbnRQcm9wZXJ0eU5hbWUsXG4gIHBhcmFtcyxcbiAgb3B0aW9uc09iamVjdFBvc2l0aW9uSW5QYXJhbXMsXG4gIG92ZXJyaWRlQ29tbWl0bWVudFxufSkge1xuICBjb25zdCBwYXJhbUluVGFyZ2V0UG9zaXRpb24gPSBwYXJhbXNbb3B0aW9uc09iamVjdFBvc2l0aW9uSW5QYXJhbXNdO1xuICBpZiAoXG4gICAgLy8gVGhlcmUncyBubyBjb25maWcuXG4gICAgcGFyYW1JblRhcmdldFBvc2l0aW9uID09PSB2b2lkIDAgfHwgLy8gVGhlcmUgaXMgYSBjb25maWcgb2JqZWN0LlxuICAgIHBhcmFtSW5UYXJnZXRQb3NpdGlvbiAmJiB0eXBlb2YgcGFyYW1JblRhcmdldFBvc2l0aW9uID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KHBhcmFtSW5UYXJnZXRQb3NpdGlvbilcbiAgKSB7XG4gICAgaWYgKFxuICAgICAgLy8gVGhlIGNvbmZpZyBvYmplY3QgYWxyZWFkeSBoYXMgYSBjb21taXRtZW50IHNldC5cbiAgICAgIHBhcmFtSW5UYXJnZXRQb3NpdGlvbiAmJiBjb21taXRtZW50UHJvcGVydHlOYW1lIGluIHBhcmFtSW5UYXJnZXRQb3NpdGlvblxuICAgICkge1xuICAgICAgaWYgKCFwYXJhbUluVGFyZ2V0UG9zaXRpb25bY29tbWl0bWVudFByb3BlcnR5TmFtZV0gfHwgcGFyYW1JblRhcmdldFBvc2l0aW9uW2NvbW1pdG1lbnRQcm9wZXJ0eU5hbWVdID09PSBcImZpbmFsaXplZFwiKSB7XG4gICAgICAgIGNvbnN0IG5leHRQYXJhbXMgPSBbLi4ucGFyYW1zXTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIFtjb21taXRtZW50UHJvcGVydHlOYW1lXTogXyxcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgICAgIC4uLnJlc3RcbiAgICAgICAgfSA9IHBhcmFtSW5UYXJnZXRQb3NpdGlvbjtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHJlc3QpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBuZXh0UGFyYW1zW29wdGlvbnNPYmplY3RQb3NpdGlvbkluUGFyYW1zXSA9IHJlc3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnNPYmplY3RQb3NpdGlvbkluUGFyYW1zID09PSBuZXh0UGFyYW1zLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIG5leHRQYXJhbXMubGVuZ3RoLS07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5leHRQYXJhbXNbb3B0aW9uc09iamVjdFBvc2l0aW9uSW5QYXJhbXNdID0gdm9pZCAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV4dFBhcmFtcztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG92ZXJyaWRlQ29tbWl0bWVudCAhPT0gXCJmaW5hbGl6ZWRcIikge1xuICAgICAgY29uc3QgbmV4dFBhcmFtcyA9IFsuLi5wYXJhbXNdO1xuICAgICAgbmV4dFBhcmFtc1tvcHRpb25zT2JqZWN0UG9zaXRpb25JblBhcmFtc10gPSB7XG4gICAgICAgIC4uLnBhcmFtSW5UYXJnZXRQb3NpdGlvbixcbiAgICAgICAgW2NvbW1pdG1lbnRQcm9wZXJ0eU5hbWVdOiBvdmVycmlkZUNvbW1pdG1lbnRcbiAgICAgIH07XG4gICAgICByZXR1cm4gbmV4dFBhcmFtcztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhcmFtcztcbn1cblxuLy8gc3JjL3JlcXVlc3QtdHJhbnNmb3JtZXItZGVmYXVsdC1jb21taXRtZW50LnRzXG5mdW5jdGlvbiBnZXREZWZhdWx0Q29tbWl0bWVudFJlcXVlc3RUcmFuc2Zvcm1lcih7XG4gIGRlZmF1bHRDb21taXRtZW50LFxuICBvcHRpb25zT2JqZWN0UG9zaXRpb25CeU1ldGhvZFxufSkge1xuICByZXR1cm4gKHJlcXVlc3QpID0+IHtcbiAgICBjb25zdCB7IHBhcmFtcywgbWV0aG9kTmFtZSB9ID0gcmVxdWVzdDtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocGFyYW1zKSkge1xuICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgfVxuICAgIGNvbnN0IG9wdGlvbnNPYmplY3RQb3NpdGlvbkluUGFyYW1zID0gb3B0aW9uc09iamVjdFBvc2l0aW9uQnlNZXRob2RbbWV0aG9kTmFtZV07XG4gICAgaWYgKG9wdGlvbnNPYmplY3RQb3NpdGlvbkluUGFyYW1zID09IG51bGwpIHtcbiAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICBtZXRob2ROYW1lLFxuICAgICAgcGFyYW1zOiBhcHBseURlZmF1bHRDb21taXRtZW50KHtcbiAgICAgICAgY29tbWl0bWVudFByb3BlcnR5TmFtZTogbWV0aG9kTmFtZSA9PT0gXCJzZW5kVHJhbnNhY3Rpb25cIiA/IFwicHJlZmxpZ2h0Q29tbWl0bWVudFwiIDogXCJjb21taXRtZW50XCIsXG4gICAgICAgIG9wdGlvbnNPYmplY3RQb3NpdGlvbkluUGFyYW1zLFxuICAgICAgICBvdmVycmlkZUNvbW1pdG1lbnQ6IGRlZmF1bHRDb21taXRtZW50LFxuICAgICAgICBwYXJhbXNcbiAgICAgIH0pXG4gICAgfSk7XG4gIH07XG59XG5cbi8vIHNyYy9yZXF1ZXN0LXRyYW5zZm9ybWVyLWludGVnZXItb3ZlcmZsb3ctaW50ZXJuYWwudHNcbmZ1bmN0aW9uIGdldEludGVnZXJPdmVyZmxvd05vZGVWaXNpdG9yKG9uSW50ZWdlck92ZXJmbG93KSB7XG4gIHJldHVybiAodmFsdWUsIHsga2V5UGF0aCB9KSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgaWYgKG9uSW50ZWdlck92ZXJmbG93ICYmICh2YWx1ZSA+IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8IHZhbHVlIDwgLU51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSkge1xuICAgICAgICBvbkludGVnZXJPdmVyZmxvdyhrZXlQYXRoLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbn1cblxuLy8gc3JjL3JlcXVlc3QtdHJhbnNmb3JtZXItaW50ZWdlci1vdmVyZmxvdy50c1xuZnVuY3Rpb24gZ2V0SW50ZWdlck92ZXJmbG93UmVxdWVzdFRyYW5zZm9ybWVyKG9uSW50ZWdlck92ZXJmbG93KSB7XG4gIHJldHVybiAocmVxdWVzdCkgPT4ge1xuICAgIGNvbnN0IHRyYW5zZm9ybWVyID0gZ2V0VHJlZVdhbGtlclJlcXVlc3RUcmFuc2Zvcm1lcihcbiAgICAgIFtnZXRJbnRlZ2VyT3ZlcmZsb3dOb2RlVmlzaXRvcigoLi4uYXJncykgPT4gb25JbnRlZ2VyT3ZlcmZsb3cocmVxdWVzdCwgLi4uYXJncykpXSxcbiAgICAgIHsga2V5UGF0aDogW10gfVxuICAgICk7XG4gICAgcmV0dXJuIHRyYW5zZm9ybWVyKHJlcXVlc3QpO1xuICB9O1xufVxuXG4vLyBzcmMvcmVxdWVzdC10cmFuc2Zvcm1lci1vcHRpb25zLW9iamVjdC1wb3NpdGlvbi1jb25maWcudHNcbnZhciBPUFRJT05TX09CSkVDVF9QT1NJVElPTl9CWV9NRVRIT0QgPSB7XG4gIGFjY291bnROb3RpZmljYXRpb25zOiAxLFxuICBibG9ja05vdGlmaWNhdGlvbnM6IDEsXG4gIGdldEFjY291bnRJbmZvOiAxLFxuICBnZXRCYWxhbmNlOiAxLFxuICBnZXRCbG9jazogMSxcbiAgZ2V0QmxvY2tIZWlnaHQ6IDAsXG4gIGdldEJsb2NrUHJvZHVjdGlvbjogMCxcbiAgZ2V0QmxvY2tzOiAyLFxuICBnZXRCbG9ja3NXaXRoTGltaXQ6IDIsXG4gIGdldEVwb2NoSW5mbzogMCxcbiAgZ2V0RmVlRm9yTWVzc2FnZTogMSxcbiAgZ2V0SW5mbGF0aW9uR292ZXJub3I6IDAsXG4gIGdldEluZmxhdGlvblJld2FyZDogMSxcbiAgZ2V0TGFyZ2VzdEFjY291bnRzOiAwLFxuICBnZXRMYXRlc3RCbG9ja2hhc2g6IDAsXG4gIGdldExlYWRlclNjaGVkdWxlOiAxLFxuICBnZXRNaW5pbXVtQmFsYW5jZUZvclJlbnRFeGVtcHRpb246IDEsXG4gIGdldE11bHRpcGxlQWNjb3VudHM6IDEsXG4gIGdldFByb2dyYW1BY2NvdW50czogMSxcbiAgZ2V0U2lnbmF0dXJlc0ZvckFkZHJlc3M6IDEsXG4gIGdldFNsb3Q6IDAsXG4gIGdldFNsb3RMZWFkZXI6IDAsXG4gIGdldFN0YWtlTWluaW11bURlbGVnYXRpb246IDAsXG4gIGdldFN1cHBseTogMCxcbiAgZ2V0VG9rZW5BY2NvdW50QmFsYW5jZTogMSxcbiAgZ2V0VG9rZW5BY2NvdW50c0J5RGVsZWdhdGU6IDIsXG4gIGdldFRva2VuQWNjb3VudHNCeU93bmVyOiAyLFxuICBnZXRUb2tlbkxhcmdlc3RBY2NvdW50czogMSxcbiAgZ2V0VG9rZW5TdXBwbHk6IDEsXG4gIGdldFRyYW5zYWN0aW9uOiAxLFxuICBnZXRUcmFuc2FjdGlvbkNvdW50OiAwLFxuICBnZXRWb3RlQWNjb3VudHM6IDAsXG4gIGlzQmxvY2toYXNoVmFsaWQ6IDEsXG4gIGxvZ3NOb3RpZmljYXRpb25zOiAxLFxuICBwcm9ncmFtTm90aWZpY2F0aW9uczogMSxcbiAgcmVxdWVzdEFpcmRyb3A6IDIsXG4gIHNlbmRUcmFuc2FjdGlvbjogMSxcbiAgc2lnbmF0dXJlTm90aWZpY2F0aW9uczogMSxcbiAgc2ltdWxhdGVUcmFuc2FjdGlvbjogMVxufTtcblxuLy8gc3JjL3JlcXVlc3QtdHJhbnNmb3JtZXIudHNcbmZ1bmN0aW9uIGdldERlZmF1bHRSZXF1ZXN0VHJhbnNmb3JtZXJGb3JTb2xhbmFScGMoY29uZmlnKSB7XG4gIGNvbnN0IGhhbmRsZUludGVnZXJPdmVyZmxvdyA9IGNvbmZpZz8ub25JbnRlZ2VyT3ZlcmZsb3c7XG4gIHJldHVybiAocmVxdWVzdCkgPT4ge1xuICAgIHJldHVybiBwaXBlKFxuICAgICAgcmVxdWVzdCxcbiAgICAgIGhhbmRsZUludGVnZXJPdmVyZmxvdyA/IGdldEludGVnZXJPdmVyZmxvd1JlcXVlc3RUcmFuc2Zvcm1lcihoYW5kbGVJbnRlZ2VyT3ZlcmZsb3cpIDogKHIpID0+IHIsXG4gICAgICBnZXRCaWdJbnREb3duY2FzdFJlcXVlc3RUcmFuc2Zvcm1lcigpLFxuICAgICAgZ2V0RGVmYXVsdENvbW1pdG1lbnRSZXF1ZXN0VHJhbnNmb3JtZXIoe1xuICAgICAgICBkZWZhdWx0Q29tbWl0bWVudDogY29uZmlnPy5kZWZhdWx0Q29tbWl0bWVudCxcbiAgICAgICAgb3B0aW9uc09iamVjdFBvc2l0aW9uQnlNZXRob2Q6IE9QVElPTlNfT0JKRUNUX1BPU0lUSU9OX0JZX01FVEhPRFxuICAgICAgfSlcbiAgICApO1xuICB9O1xufVxuXG4vLyBzcmMvcmVzcG9uc2UtdHJhbnNmb3JtZXItYmlnaW50LXVwY2FzdC1pbnRlcm5hbC50c1xuZnVuY3Rpb24gZ2V0QmlnSW50VXBjYXN0VmlzaXRvcihhbGxvd2VkTnVtZXJpY0tleVBhdGhzKSB7XG4gIHJldHVybiBmdW5jdGlvbiB1cGNhc3ROb2RlVG9CaWdJbnRJZk51bWJlcih2YWx1ZSwgeyBrZXlQYXRoIH0pIHtcbiAgICBjb25zdCBpc0ludGVnZXIgPSB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgJiYgTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiO1xuICAgIGlmICghaXNJbnRlZ2VyKSByZXR1cm4gdmFsdWU7XG4gICAgaWYgKGtleVBhdGhJc0FsbG93ZWRUb0JlTnVtZXJpYyhrZXlQYXRoLCBhbGxvd2VkTnVtZXJpY0tleVBhdGhzKSkge1xuICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBCaWdJbnQodmFsdWUpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGtleVBhdGhJc0FsbG93ZWRUb0JlTnVtZXJpYyhrZXlQYXRoLCBhbGxvd2VkTnVtZXJpY0tleVBhdGhzKSB7XG4gIHJldHVybiBhbGxvd2VkTnVtZXJpY0tleVBhdGhzLnNvbWUoKHByb2hpYml0ZWRLZXlQYXRoKSA9PiB7XG4gICAgaWYgKHByb2hpYml0ZWRLZXlQYXRoLmxlbmd0aCAhPT0ga2V5UGF0aC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaWkgPSBrZXlQYXRoLmxlbmd0aCAtIDE7IGlpID49IDA7IGlpLS0pIHtcbiAgICAgIGNvbnN0IGtleVBhdGhQYXJ0ID0ga2V5UGF0aFtpaV07XG4gICAgICBjb25zdCBwcm9oaWJpdGVkS2V5UGF0aFBhcnQgPSBwcm9oaWJpdGVkS2V5UGF0aFtpaV07XG4gICAgICBpZiAocHJvaGliaXRlZEtleVBhdGhQYXJ0ICE9PSBrZXlQYXRoUGFydCAmJiAocHJvaGliaXRlZEtleVBhdGhQYXJ0ICE9PSBLRVlQQVRIX1dJTERDQVJEIHx8IHR5cGVvZiBrZXlQYXRoUGFydCAhPT0gXCJudW1iZXJcIikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG59XG5cbi8vIHNyYy9yZXNwb25zZS10cmFuc2Zvcm1lci1iaWdpbnQtdXBjYXN0LnRzXG5mdW5jdGlvbiBnZXRCaWdJbnRVcGNhc3RSZXNwb25zZVRyYW5zZm9ybWVyKGFsbG93ZWROdW1lcmljS2V5UGF0aHMpIHtcbiAgcmV0dXJuIGdldFRyZWVXYWxrZXJSZXNwb25zZVRyYW5zZm9ybWVyKFtnZXRCaWdJbnRVcGNhc3RWaXNpdG9yKGFsbG93ZWROdW1lcmljS2V5UGF0aHMpXSwgeyBrZXlQYXRoOiBbXSB9KTtcbn1cblxuLy8gc3JjL3Jlc3BvbnNlLXRyYW5zZm9ybWVyLXJlc3VsdC50c1xuZnVuY3Rpb24gZ2V0UmVzdWx0UmVzcG9uc2VUcmFuc2Zvcm1lcigpIHtcbiAgcmV0dXJuIChqc29uKSA9PiBqc29uLnJlc3VsdDtcbn1cblxuLy8gc3JjL3Jlc3BvbnNlLXRyYW5zZm9ybWVyLWFsbG93ZWQtbnVtZXJpYy12YWx1ZXMudHNcbnZhciBqc29uUGFyc2VkVG9rZW5BY2NvdW50c0NvbmZpZ3MgPSBbXG4gIC8vIHBhcnNlZCBUb2tlbi9Ub2tlbjIyIHRva2VuIGFjY291bnRcbiAgW1wiZGF0YVwiLCBcInBhcnNlZFwiLCBcImluZm9cIiwgXCJ0b2tlbkFtb3VudFwiLCBcImRlY2ltYWxzXCJdLFxuICBbXCJkYXRhXCIsIFwicGFyc2VkXCIsIFwiaW5mb1wiLCBcInRva2VuQW1vdW50XCIsIFwidWlBbW91bnRcIl0sXG4gIFtcImRhdGFcIiwgXCJwYXJzZWRcIiwgXCJpbmZvXCIsIFwicmVudEV4ZW1wdFJlc2VydmVcIiwgXCJkZWNpbWFsc1wiXSxcbiAgW1wiZGF0YVwiLCBcInBhcnNlZFwiLCBcImluZm9cIiwgXCJyZW50RXhlbXB0UmVzZXJ2ZVwiLCBcInVpQW1vdW50XCJdLFxuICBbXCJkYXRhXCIsIFwicGFyc2VkXCIsIFwiaW5mb1wiLCBcImRlbGVnYXRlZEFtb3VudFwiLCBcImRlY2ltYWxzXCJdLFxuICBbXCJkYXRhXCIsIFwicGFyc2VkXCIsIFwiaW5mb1wiLCBcImRlbGVnYXRlZEFtb3VudFwiLCBcInVpQW1vdW50XCJdLFxuICBbXCJkYXRhXCIsIFwicGFyc2VkXCIsIFwiaW5mb1wiLCBcImV4dGVuc2lvbnNcIiwgS0VZUEFUSF9XSUxEQ0FSRCwgXCJzdGF0ZVwiLCBcIm9sZGVyVHJhbnNmZXJGZWVcIiwgXCJ0cmFuc2ZlckZlZUJhc2lzUG9pbnRzXCJdLFxuICBbXCJkYXRhXCIsIFwicGFyc2VkXCIsIFwiaW5mb1wiLCBcImV4dGVuc2lvbnNcIiwgS0VZUEFUSF9XSUxEQ0FSRCwgXCJzdGF0ZVwiLCBcIm5ld2VyVHJhbnNmZXJGZWVcIiwgXCJ0cmFuc2ZlckZlZUJhc2lzUG9pbnRzXCJdLFxuICBbXCJkYXRhXCIsIFwicGFyc2VkXCIsIFwiaW5mb1wiLCBcImV4dGVuc2lvbnNcIiwgS0VZUEFUSF9XSUxEQ0FSRCwgXCJzdGF0ZVwiLCBcInByZVVwZGF0ZUF2ZXJhZ2VSYXRlXCJdLFxuICBbXCJkYXRhXCIsIFwicGFyc2VkXCIsIFwiaW5mb1wiLCBcImV4dGVuc2lvbnNcIiwgS0VZUEFUSF9XSUxEQ0FSRCwgXCJzdGF0ZVwiLCBcImN1cnJlbnRSYXRlXCJdXG5dO1xudmFyIGpzb25QYXJzZWRBY2NvdW50c0NvbmZpZ3MgPSBbXG4gIC4uLmpzb25QYXJzZWRUb2tlbkFjY291bnRzQ29uZmlncyxcbiAgLy8gcGFyc2VkIEFkZHJlc3NUYWJsZUxvb2t1cCBhY2NvdW50XG4gIFtcImRhdGFcIiwgXCJwYXJzZWRcIiwgXCJpbmZvXCIsIFwibGFzdEV4dGVuZGVkU2xvdFN0YXJ0SW5kZXhcIl0sXG4gIC8vIHBhcnNlZCBDb25maWcgYWNjb3VudFxuICBbXCJkYXRhXCIsIFwicGFyc2VkXCIsIFwiaW5mb1wiLCBcInNsYXNoUGVuYWx0eVwiXSxcbiAgW1wiZGF0YVwiLCBcInBhcnNlZFwiLCBcImluZm9cIiwgXCJ3YXJtdXBDb29sZG93blJhdGVcIl0sXG4gIC8vIHBhcnNlZCBUb2tlbi9Ub2tlbjIyIG1pbnQgYWNjb3VudFxuICBbXCJkYXRhXCIsIFwicGFyc2VkXCIsIFwiaW5mb1wiLCBcImRlY2ltYWxzXCJdLFxuICAvLyBwYXJzZWQgVG9rZW4vVG9rZW4yMiBtdWx0aXNpZyBhY2NvdW50XG4gIFtcImRhdGFcIiwgXCJwYXJzZWRcIiwgXCJpbmZvXCIsIFwibnVtUmVxdWlyZWRTaWduZXJzXCJdLFxuICBbXCJkYXRhXCIsIFwicGFyc2VkXCIsIFwiaW5mb1wiLCBcIm51bVZhbGlkU2lnbmVyc1wiXSxcbiAgLy8gcGFyc2VkIFN0YWtlIGFjY291bnRcbiAgW1wiZGF0YVwiLCBcInBhcnNlZFwiLCBcImluZm9cIiwgXCJzdGFrZVwiLCBcImRlbGVnYXRpb25cIiwgXCJ3YXJtdXBDb29sZG93blJhdGVcIl0sXG4gIC8vIHBhcnNlZCBTeXN2YXIgcmVudCBhY2NvdW50XG4gIFtcImRhdGFcIiwgXCJwYXJzZWRcIiwgXCJpbmZvXCIsIFwiZXhlbXB0aW9uVGhyZXNob2xkXCJdLFxuICBbXCJkYXRhXCIsIFwicGFyc2VkXCIsIFwiaW5mb1wiLCBcImJ1cm5QZXJjZW50XCJdLFxuICAvLyBwYXJzZWQgVm90ZSBhY2NvdW50XG4gIFtcImRhdGFcIiwgXCJwYXJzZWRcIiwgXCJpbmZvXCIsIFwiY29tbWlzc2lvblwiXSxcbiAgW1wiZGF0YVwiLCBcInBhcnNlZFwiLCBcImluZm9cIiwgXCJ2b3Rlc1wiLCBLRVlQQVRIX1dJTERDQVJELCBcImNvbmZpcm1hdGlvbkNvdW50XCJdXG5dO1xudmFyIGlubmVySW5zdHJ1Y3Rpb25zQ29uZmlncyA9IFtcbiAgW1wiaW5kZXhcIl0sXG4gIFtcImluc3RydWN0aW9uc1wiLCBLRVlQQVRIX1dJTERDQVJELCBcImFjY291bnRzXCIsIEtFWVBBVEhfV0lMRENBUkRdLFxuICBbXCJpbnN0cnVjdGlvbnNcIiwgS0VZUEFUSF9XSUxEQ0FSRCwgXCJwcm9ncmFtSWRJbmRleFwiXSxcbiAgW1wiaW5zdHJ1Y3Rpb25zXCIsIEtFWVBBVEhfV0lMRENBUkQsIFwic3RhY2tIZWlnaHRcIl1cbl07XG52YXIgbWVzc2FnZUNvbmZpZyA9IFtcbiAgW1wiYWRkcmVzc1RhYmxlTG9va3Vwc1wiLCBLRVlQQVRIX1dJTERDQVJELCBcIndyaXRhYmxlSW5kZXhlc1wiLCBLRVlQQVRIX1dJTERDQVJEXSxcbiAgW1wiYWRkcmVzc1RhYmxlTG9va3Vwc1wiLCBLRVlQQVRIX1dJTERDQVJELCBcInJlYWRvbmx5SW5kZXhlc1wiLCBLRVlQQVRIX1dJTERDQVJEXSxcbiAgW1wiaGVhZGVyXCIsIFwibnVtUmVhZG9ubHlTaWduZWRBY2NvdW50c1wiXSxcbiAgW1wiaGVhZGVyXCIsIFwibnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzXCJdLFxuICBbXCJoZWFkZXJcIiwgXCJudW1SZXF1aXJlZFNpZ25hdHVyZXNcIl0sXG4gIFtcImluc3RydWN0aW9uc1wiLCBLRVlQQVRIX1dJTERDQVJELCBcImFjY291bnRzXCIsIEtFWVBBVEhfV0lMRENBUkRdLFxuICBbXCJpbnN0cnVjdGlvbnNcIiwgS0VZUEFUSF9XSUxEQ0FSRCwgXCJwcm9ncmFtSWRJbmRleFwiXSxcbiAgW1wiaW5zdHJ1Y3Rpb25zXCIsIEtFWVBBVEhfV0lMRENBUkQsIFwic3RhY2tIZWlnaHRcIl1cbl07XG5cbi8vIHNyYy9yZXNwb25zZS10cmFuc2Zvcm1lci10aHJvdy1zb2xhbmEtZXJyb3IudHNcbmZ1bmN0aW9uIGdldFNpbXVsYXRlVHJhbnNhY3Rpb25BbGxvd2VkTnVtZXJpY0tleXBhdGhzKCkge1xuICByZXR1cm4gW1xuICAgIFtcImxvYWRlZEFjY291bnRzRGF0YVNpemVcIl0sXG4gICAgLi4uanNvblBhcnNlZEFjY291bnRzQ29uZmlncy5tYXAoKGMpID0+IFtcImFjY291bnRzXCIsIEtFWVBBVEhfV0lMRENBUkQsIC4uLmNdKSxcbiAgICAuLi5pbm5lckluc3RydWN0aW9uc0NvbmZpZ3MubWFwKChjKSA9PiBbXCJpbm5lckluc3RydWN0aW9uc1wiLCBLRVlQQVRIX1dJTERDQVJELCAuLi5jXSlcbiAgXTtcbn1cbmZ1bmN0aW9uIGdldFRocm93U29sYW5hRXJyb3JSZXNwb25zZVRyYW5zZm9ybWVyKCkge1xuICByZXR1cm4gKGpzb24sIHJlcXVlc3QpID0+IHtcbiAgICBjb25zdCBqc29uUnBjUmVzcG9uc2UgPSBqc29uO1xuICAgIGlmIChcImVycm9yXCIgaW4ganNvblJwY1Jlc3BvbnNlKSB7XG4gICAgICBjb25zdCB7IGVycm9yIH0gPSBqc29uUnBjUmVzcG9uc2U7XG4gICAgICBjb25zdCBpc1NlbmRUcmFuc2FjdGlvblByZWZsaWdodEZhaWx1cmUgPSBlcnJvciAmJiB0eXBlb2YgZXJyb3IgPT09IFwib2JqZWN0XCIgJiYgXCJjb2RlXCIgaW4gZXJyb3IgJiYgKGVycm9yLmNvZGUgPT09IC0zMjAwMiB8fCBlcnJvci5jb2RlID09PSAtMzIwMDJuKTtcbiAgICAgIGlmIChpc1NlbmRUcmFuc2FjdGlvblByZWZsaWdodEZhaWx1cmUgJiYgXCJkYXRhXCIgaW4gZXJyb3IgJiYgZXJyb3IuZGF0YSkge1xuICAgICAgICBjb25zdCB0cmVlV2Fsa2VyID0gZ2V0VHJlZVdhbGtlclJlc3BvbnNlVHJhbnNmb3JtZXIoXG4gICAgICAgICAgW2dldEJpZ0ludFVwY2FzdFZpc2l0b3IoZ2V0U2ltdWxhdGVUcmFuc2FjdGlvbkFsbG93ZWROdW1lcmljS2V5cGF0aHMoKSldLFxuICAgICAgICAgIHsga2V5UGF0aDogW10gfVxuICAgICAgICApO1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZERhdGEgPSB0cmVlV2Fsa2VyKGVycm9yLmRhdGEsIHJlcXVlc3QpO1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZEVycm9yID0geyAuLi5lcnJvciwgZGF0YTogdHJhbnNmb3JtZWREYXRhIH07XG4gICAgICAgIHRocm93IGdldFNvbGFuYUVycm9yRnJvbUpzb25ScGNFcnJvcih0cmFuc2Zvcm1lZEVycm9yKTtcbiAgICAgIH1cbiAgICAgIHRocm93IGdldFNvbGFuYUVycm9yRnJvbUpzb25ScGNFcnJvcihqc29uUnBjUmVzcG9uc2UuZXJyb3IpO1xuICAgIH1cbiAgICByZXR1cm4ganNvblJwY1Jlc3BvbnNlO1xuICB9O1xufVxuXG4vLyBzcmMvcmVzcG9uc2UtdHJhbnNmb3JtZXIudHNcbmZ1bmN0aW9uIGdldERlZmF1bHRSZXNwb25zZVRyYW5zZm9ybWVyRm9yU29sYW5hUnBjKGNvbmZpZykge1xuICByZXR1cm4gKHJlc3BvbnNlLCByZXF1ZXN0KSA9PiB7XG4gICAgY29uc3QgbWV0aG9kTmFtZSA9IHJlcXVlc3QubWV0aG9kTmFtZTtcbiAgICBjb25zdCBrZXlQYXRocyA9IGNvbmZpZz8uYWxsb3dlZE51bWVyaWNLZXlQYXRocyAmJiBtZXRob2ROYW1lID8gY29uZmlnLmFsbG93ZWROdW1lcmljS2V5UGF0aHNbbWV0aG9kTmFtZV0gOiB2b2lkIDA7XG4gICAgcmV0dXJuIHBpcGUoXG4gICAgICByZXNwb25zZSxcbiAgICAgIChyKSA9PiBnZXRUaHJvd1NvbGFuYUVycm9yUmVzcG9uc2VUcmFuc2Zvcm1lcigpKHIsIHJlcXVlc3QpLFxuICAgICAgKHIpID0+IGdldFJlc3VsdFJlc3BvbnNlVHJhbnNmb3JtZXIoKShyLCByZXF1ZXN0KSxcbiAgICAgIChyKSA9PiBnZXRCaWdJbnRVcGNhc3RSZXNwb25zZVRyYW5zZm9ybWVyKGtleVBhdGhzID8/IFtdKShyLCByZXF1ZXN0KVxuICAgICk7XG4gIH07XG59XG5mdW5jdGlvbiBnZXREZWZhdWx0UmVzcG9uc2VUcmFuc2Zvcm1lckZvclNvbGFuYVJwY1N1YnNjcmlwdGlvbnMoY29uZmlnKSB7XG4gIHJldHVybiAocmVzcG9uc2UsIHJlcXVlc3QpID0+IHtcbiAgICBjb25zdCBtZXRob2ROYW1lID0gcmVxdWVzdC5tZXRob2ROYW1lO1xuICAgIGNvbnN0IGtleVBhdGhzID0gY29uZmlnPy5hbGxvd2VkTnVtZXJpY0tleVBhdGhzICYmIG1ldGhvZE5hbWUgPyBjb25maWcuYWxsb3dlZE51bWVyaWNLZXlQYXRoc1ttZXRob2ROYW1lXSA6IHZvaWQgMDtcbiAgICByZXR1cm4gcGlwZShyZXNwb25zZSwgKHIpID0+IGdldEJpZ0ludFVwY2FzdFJlc3BvbnNlVHJhbnNmb3JtZXIoa2V5UGF0aHMgPz8gW10pKHIsIHJlcXVlc3QpKTtcbiAgfTtcbn1cblxuZXhwb3J0IHsgS0VZUEFUSF9XSUxEQ0FSRCwgZ2V0QmlnSW50RG93bmNhc3RSZXF1ZXN0VHJhbnNmb3JtZXIsIGdldEJpZ0ludFVwY2FzdFJlc3BvbnNlVHJhbnNmb3JtZXIsIGdldERlZmF1bHRDb21taXRtZW50UmVxdWVzdFRyYW5zZm9ybWVyLCBnZXREZWZhdWx0UmVxdWVzdFRyYW5zZm9ybWVyRm9yU29sYW5hUnBjLCBnZXREZWZhdWx0UmVzcG9uc2VUcmFuc2Zvcm1lckZvclNvbGFuYVJwYywgZ2V0RGVmYXVsdFJlc3BvbnNlVHJhbnNmb3JtZXJGb3JTb2xhbmFScGNTdWJzY3JpcHRpb25zLCBnZXRJbnRlZ2VyT3ZlcmZsb3dSZXF1ZXN0VHJhbnNmb3JtZXIsIGdldFJlc3VsdFJlc3BvbnNlVHJhbnNmb3JtZXIsIGdldFRocm93U29sYW5hRXJyb3JSZXNwb25zZVRyYW5zZm9ybWVyLCBnZXRUcmVlV2Fsa2VyUmVxdWVzdFRyYW5zZm9ybWVyLCBnZXRUcmVlV2Fsa2VyUmVzcG9uc2VUcmFuc2Zvcm1lciwgaW5uZXJJbnN0cnVjdGlvbnNDb25maWdzLCBqc29uUGFyc2VkQWNjb3VudHNDb25maWdzLCBqc29uUGFyc2VkVG9rZW5BY2NvdW50c0NvbmZpZ3MsIG1lc3NhZ2VDb25maWcgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm5vZGUubWpzLm1hcFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubm9kZS5tanMubWFwIl0sIm5hbWVzIjpbInBpcGUiLCJnZXRTb2xhbmFFcnJvckZyb21Kc29uUnBjRXJyb3IiLCJkb3duY2FzdE5vZGVUb051bWJlcklmQmlnaW50IiwidmFsdWUiLCJOdW1iZXIiLCJLRVlQQVRIX1dJTERDQVJEIiwiZ2V0VHJlZVdhbGtlciIsInZpc2l0b3JzIiwidHJhdmVyc2UiLCJub2RlIiwic3RhdGUiLCJBcnJheSIsImlzQXJyYXkiLCJtYXAiLCJlbGVtZW50IiwiaWkiLCJuZXh0U3RhdGUiLCJrZXlQYXRoIiwib3V0IiwicHJvcE5hbWUiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJyZWR1Y2UiLCJhY2MiLCJ2aXNpdE5vZGUiLCJnZXRUcmVlV2Fsa2VyUmVxdWVzdFRyYW5zZm9ybWVyIiwiaW5pdGlhbFN0YXRlIiwicmVxdWVzdCIsImZyZWV6ZSIsInBhcmFtcyIsImdldFRyZWVXYWxrZXJSZXNwb25zZVRyYW5zZm9ybWVyIiwianNvbiIsImdldEJpZ0ludERvd25jYXN0UmVxdWVzdFRyYW5zZm9ybWVyIiwiYXBwbHlEZWZhdWx0Q29tbWl0bWVudCIsImNvbW1pdG1lbnRQcm9wZXJ0eU5hbWUiLCJvcHRpb25zT2JqZWN0UG9zaXRpb25JblBhcmFtcyIsIm92ZXJyaWRlQ29tbWl0bWVudCIsInBhcmFtSW5UYXJnZXRQb3NpdGlvbiIsIm5leHRQYXJhbXMiLCJfIiwicmVzdCIsImtleXMiLCJsZW5ndGgiLCJnZXREZWZhdWx0Q29tbWl0bWVudFJlcXVlc3RUcmFuc2Zvcm1lciIsImRlZmF1bHRDb21taXRtZW50Iiwib3B0aW9uc09iamVjdFBvc2l0aW9uQnlNZXRob2QiLCJtZXRob2ROYW1lIiwiZ2V0SW50ZWdlck92ZXJmbG93Tm9kZVZpc2l0b3IiLCJvbkludGVnZXJPdmVyZmxvdyIsIk1BWF9TQUZFX0lOVEVHRVIiLCJnZXRJbnRlZ2VyT3ZlcmZsb3dSZXF1ZXN0VHJhbnNmb3JtZXIiLCJ0cmFuc2Zvcm1lciIsImFyZ3MiLCJPUFRJT05TX09CSkVDVF9QT1NJVElPTl9CWV9NRVRIT0QiLCJhY2NvdW50Tm90aWZpY2F0aW9ucyIsImJsb2NrTm90aWZpY2F0aW9ucyIsImdldEFjY291bnRJbmZvIiwiZ2V0QmFsYW5jZSIsImdldEJsb2NrIiwiZ2V0QmxvY2tIZWlnaHQiLCJnZXRCbG9ja1Byb2R1Y3Rpb24iLCJnZXRCbG9ja3MiLCJnZXRCbG9ja3NXaXRoTGltaXQiLCJnZXRFcG9jaEluZm8iLCJnZXRGZWVGb3JNZXNzYWdlIiwiZ2V0SW5mbGF0aW9uR292ZXJub3IiLCJnZXRJbmZsYXRpb25SZXdhcmQiLCJnZXRMYXJnZXN0QWNjb3VudHMiLCJnZXRMYXRlc3RCbG9ja2hhc2giLCJnZXRMZWFkZXJTY2hlZHVsZSIsImdldE1pbmltdW1CYWxhbmNlRm9yUmVudEV4ZW1wdGlvbiIsImdldE11bHRpcGxlQWNjb3VudHMiLCJnZXRQcm9ncmFtQWNjb3VudHMiLCJnZXRTaWduYXR1cmVzRm9yQWRkcmVzcyIsImdldFNsb3QiLCJnZXRTbG90TGVhZGVyIiwiZ2V0U3Rha2VNaW5pbXVtRGVsZWdhdGlvbiIsImdldFN1cHBseSIsImdldFRva2VuQWNjb3VudEJhbGFuY2UiLCJnZXRUb2tlbkFjY291bnRzQnlEZWxlZ2F0ZSIsImdldFRva2VuQWNjb3VudHNCeU93bmVyIiwiZ2V0VG9rZW5MYXJnZXN0QWNjb3VudHMiLCJnZXRUb2tlblN1cHBseSIsImdldFRyYW5zYWN0aW9uIiwiZ2V0VHJhbnNhY3Rpb25Db3VudCIsImdldFZvdGVBY2NvdW50cyIsImlzQmxvY2toYXNoVmFsaWQiLCJsb2dzTm90aWZpY2F0aW9ucyIsInByb2dyYW1Ob3RpZmljYXRpb25zIiwicmVxdWVzdEFpcmRyb3AiLCJzZW5kVHJhbnNhY3Rpb24iLCJzaWduYXR1cmVOb3RpZmljYXRpb25zIiwic2ltdWxhdGVUcmFuc2FjdGlvbiIsImdldERlZmF1bHRSZXF1ZXN0VHJhbnNmb3JtZXJGb3JTb2xhbmFScGMiLCJjb25maWciLCJoYW5kbGVJbnRlZ2VyT3ZlcmZsb3ciLCJyIiwiZ2V0QmlnSW50VXBjYXN0VmlzaXRvciIsImFsbG93ZWROdW1lcmljS2V5UGF0aHMiLCJ1cGNhc3ROb2RlVG9CaWdJbnRJZk51bWJlciIsImlzSW50ZWdlciIsImtleVBhdGhJc0FsbG93ZWRUb0JlTnVtZXJpYyIsIkJpZ0ludCIsInNvbWUiLCJwcm9oaWJpdGVkS2V5UGF0aCIsImtleVBhdGhQYXJ0IiwicHJvaGliaXRlZEtleVBhdGhQYXJ0IiwiZ2V0QmlnSW50VXBjYXN0UmVzcG9uc2VUcmFuc2Zvcm1lciIsImdldFJlc3VsdFJlc3BvbnNlVHJhbnNmb3JtZXIiLCJyZXN1bHQiLCJqc29uUGFyc2VkVG9rZW5BY2NvdW50c0NvbmZpZ3MiLCJqc29uUGFyc2VkQWNjb3VudHNDb25maWdzIiwiaW5uZXJJbnN0cnVjdGlvbnNDb25maWdzIiwibWVzc2FnZUNvbmZpZyIsImdldFNpbXVsYXRlVHJhbnNhY3Rpb25BbGxvd2VkTnVtZXJpY0tleXBhdGhzIiwiYyIsImdldFRocm93U29sYW5hRXJyb3JSZXNwb25zZVRyYW5zZm9ybWVyIiwianNvblJwY1Jlc3BvbnNlIiwiZXJyb3IiLCJpc1NlbmRUcmFuc2FjdGlvblByZWZsaWdodEZhaWx1cmUiLCJjb2RlIiwiZGF0YSIsInRyZWVXYWxrZXIiLCJ0cmFuc2Zvcm1lZERhdGEiLCJ0cmFuc2Zvcm1lZEVycm9yIiwiZ2V0RGVmYXVsdFJlc3BvbnNlVHJhbnNmb3JtZXJGb3JTb2xhbmFScGMiLCJyZXNwb25zZSIsImtleVBhdGhzIiwiZ2V0RGVmYXVsdFJlc3BvbnNlVHJhbnNmb3JtZXJGb3JTb2xhbmFScGNTdWJzY3JpcHRpb25zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/rpc-transformers/dist/index.node.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/rpc-transport-http/dist/index.node.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@solana/rpc-transport-http/dist/index.node.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createHttpTransport: () => (/* binding */ createHttpTransport),\n/* harmony export */   createHttpTransportForSolanaRpc: () => (/* binding */ createHttpTransportForSolanaRpc)\n/* harmony export */ });\n/* harmony import */ var _solana_errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/errors */ \"(ssr)/./node_modules/@solana/errors/dist/index.node.mjs\");\n/* harmony import */ var _solana_rpc_spec_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @solana/rpc-spec-types */ \"(ssr)/./node_modules/@solana/rpc-spec-types/dist/index.node.mjs\");\n/* harmony import */ var _solana_rpc_spec__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana/rpc-spec */ \"(ssr)/./node_modules/@solana/rpc-spec/dist/index.node.mjs\");\n\n\n\n// src/http-transport.ts\nvar DISALLOWED_HEADERS = {\n    accept: true,\n    \"content-length\": true,\n    \"content-type\": true\n};\nvar FORBIDDEN_HEADERS = /* @__PURE__ */ Object.assign({\n    \"accept-charset\": true,\n    \"access-control-request-headers\": true,\n    \"access-control-request-method\": true,\n    connection: true,\n    \"content-length\": true,\n    cookie: true,\n    date: true,\n    dnt: true,\n    expect: true,\n    host: true,\n    \"keep-alive\": true,\n    \"permissions-policy\": true,\n    // Prefix matching is implemented in code, below.\n    // 'proxy-': true,\n    // 'sec-': true,\n    referer: true,\n    te: true,\n    trailer: true,\n    \"transfer-encoding\": true,\n    upgrade: true,\n    via: true\n}, void 0, void 0);\nfunction assertIsAllowedHttpRequestHeaders(headers) {\n    const badHeaders = Object.keys(headers).filter((headerName)=>{\n        const lowercaseHeaderName = headerName.toLowerCase();\n        return DISALLOWED_HEADERS[headerName.toLowerCase()] === true || FORBIDDEN_HEADERS[headerName.toLowerCase()] === true || lowercaseHeaderName.startsWith(\"proxy-\") || lowercaseHeaderName.startsWith(\"sec-\");\n    });\n    if (badHeaders.length > 0) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN, {\n            headers: badHeaders\n        });\n    }\n}\nfunction normalizeHeaders(headers) {\n    const out = {};\n    for(const headerName in headers){\n        out[headerName.toLowerCase()] = headers[headerName];\n    }\n    return out;\n}\n// src/http-transport.ts\nfunction createHttpTransport(config) {\n    if (false) {}\n    const { fromJson, headers, toJson, url } = config;\n    if ( true && headers) {\n        assertIsAllowedHttpRequestHeaders(headers);\n    }\n    let dispatcherConfig;\n    if (\"dispatcher_NODE_ONLY\" in config) {\n        dispatcherConfig = {\n            dispatcher: config.dispatcher_NODE_ONLY\n        };\n    }\n    const customHeaders = headers && normalizeHeaders(headers);\n    return async function makeHttpRequest({ payload, signal }) {\n        const body = toJson ? toJson(payload) : JSON.stringify(payload);\n        const requestInfo = {\n            ...dispatcherConfig,\n            body,\n            headers: {\n                ...customHeaders,\n                // Keep these headers lowercase so they will override any user-supplied headers above.\n                accept: \"application/json\",\n                \"content-length\": body.length.toString(),\n                \"content-type\": \"application/json; charset=utf-8\"\n            },\n            method: \"POST\",\n            signal\n        };\n        const response = await fetch(url, requestInfo);\n        if (!response.ok) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR, {\n                headers: response.headers,\n                message: response.statusText,\n                statusCode: response.status\n            });\n        }\n        if (fromJson) {\n            return fromJson(await response.text(), payload);\n        }\n        return await response.json();\n    };\n}\nvar SOLANA_RPC_METHODS = [\n    \"getAccountInfo\",\n    \"getBalance\",\n    \"getBlock\",\n    \"getBlockCommitment\",\n    \"getBlockHeight\",\n    \"getBlockProduction\",\n    \"getBlocks\",\n    \"getBlocksWithLimit\",\n    \"getBlockTime\",\n    \"getClusterNodes\",\n    \"getEpochInfo\",\n    \"getEpochSchedule\",\n    \"getFeeForMessage\",\n    \"getFirstAvailableBlock\",\n    \"getGenesisHash\",\n    \"getHealth\",\n    \"getHighestSnapshotSlot\",\n    \"getIdentity\",\n    \"getInflationGovernor\",\n    \"getInflationRate\",\n    \"getInflationReward\",\n    \"getLargestAccounts\",\n    \"getLatestBlockhash\",\n    \"getLeaderSchedule\",\n    \"getMaxRetransmitSlot\",\n    \"getMaxShredInsertSlot\",\n    \"getMinimumBalanceForRentExemption\",\n    \"getMultipleAccounts\",\n    \"getProgramAccounts\",\n    \"getRecentPerformanceSamples\",\n    \"getRecentPrioritizationFees\",\n    \"getSignaturesForAddress\",\n    \"getSignatureStatuses\",\n    \"getSlot\",\n    \"getSlotLeader\",\n    \"getSlotLeaders\",\n    \"getStakeMinimumDelegation\",\n    \"getSupply\",\n    \"getTokenAccountBalance\",\n    \"getTokenAccountsByDelegate\",\n    \"getTokenAccountsByOwner\",\n    \"getTokenLargestAccounts\",\n    \"getTokenSupply\",\n    \"getTransaction\",\n    \"getTransactionCount\",\n    \"getVersion\",\n    \"getVoteAccounts\",\n    \"index\",\n    \"isBlockhashValid\",\n    \"minimumLedgerSlot\",\n    \"requestAirdrop\",\n    \"sendTransaction\",\n    \"simulateTransaction\"\n];\nfunction isSolanaRequest(payload) {\n    return (0,_solana_rpc_spec__WEBPACK_IMPORTED_MODULE_1__.isJsonRpcPayload)(payload) && SOLANA_RPC_METHODS.includes(payload.method);\n}\n// src/http-transport-for-solana-rpc.ts\nfunction createHttpTransportForSolanaRpc(config) {\n    return createHttpTransport({\n        ...config,\n        fromJson: (rawResponse, payload)=>isSolanaRequest(payload) ? (0,_solana_rpc_spec_types__WEBPACK_IMPORTED_MODULE_2__.parseJsonWithBigInts)(rawResponse) : JSON.parse(rawResponse),\n        toJson: (payload)=>isSolanaRequest(payload) ? (0,_solana_rpc_spec_types__WEBPACK_IMPORTED_MODULE_2__.stringifyJsonWithBigInts)(payload) : JSON.stringify(payload)\n    });\n}\n //# sourceMappingURL=index.node.mjs.map\n //# sourceMappingURL=index.node.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS9ycGMtdHJhbnNwb3J0LWh0dHAvZGlzdC9pbmRleC5ub2RlLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUEwSTtBQUNsRDtBQUNwQztBQUVwRCx3QkFBd0I7QUFDeEIsSUFBSU0scUJBQXFCO0lBQ3ZCQyxRQUFRO0lBQ1Isa0JBQWtCO0lBQ2xCLGdCQUFnQjtBQUNsQjtBQUNBLElBQUlDLG9CQUFvQixhQUFhLEdBQUdDLE9BQU9DLE1BQU0sQ0FDbkQ7SUFDRSxrQkFBa0I7SUFDbEIsa0NBQWtDO0lBQ2xDLGlDQUFpQztJQUNqQ0MsWUFBWTtJQUNaLGtCQUFrQjtJQUNsQkMsUUFBUTtJQUNSQyxNQUFNO0lBQ05DLEtBQUs7SUFDTEMsUUFBUTtJQUNSQyxNQUFNO0lBQ04sY0FBYztJQUNkLHNCQUFzQjtJQUN0QixpREFBaUQ7SUFDakQsa0JBQWtCO0lBQ2xCLGdCQUFnQjtJQUNoQkMsU0FBUztJQUNUQyxJQUFJO0lBQ0pDLFNBQVM7SUFDVCxxQkFBcUI7SUFDckJDLFNBQVM7SUFDVEMsS0FBSztBQUNQLEdBQ0EsS0FBSyxHQUNMLEtBQUs7QUFFUCxTQUFTQyxrQ0FBa0NDLE9BQU87SUFDaEQsTUFBTUMsYUFBYWYsT0FBT2dCLElBQUksQ0FBQ0YsU0FBU0csTUFBTSxDQUFDLENBQUNDO1FBQzlDLE1BQU1DLHNCQUFzQkQsV0FBV0UsV0FBVztRQUNsRCxPQUFPdkIsa0JBQWtCLENBQUNxQixXQUFXRSxXQUFXLEdBQUcsS0FBSyxRQUFRckIsaUJBQWlCLENBQUNtQixXQUFXRSxXQUFXLEdBQUcsS0FBSyxRQUFRRCxvQkFBb0JFLFVBQVUsQ0FBQyxhQUFhRixvQkFBb0JFLFVBQVUsQ0FBQztJQUNyTTtJQUNBLElBQUlOLFdBQVdPLE1BQU0sR0FBRyxHQUFHO1FBQ3pCLE1BQU0sSUFBSS9CLHVEQUFXQSxDQUFDRSw4RkFBa0RBLEVBQUU7WUFDeEVxQixTQUFTQztRQUNYO0lBQ0Y7QUFDRjtBQUNBLFNBQVNRLGlCQUFpQlQsT0FBTztJQUMvQixNQUFNVSxNQUFNLENBQUM7SUFDYixJQUFLLE1BQU1OLGNBQWNKLFFBQVM7UUFDaENVLEdBQUcsQ0FBQ04sV0FBV0UsV0FBVyxHQUFHLEdBQUdOLE9BQU8sQ0FBQ0ksV0FBVztJQUNyRDtJQUNBLE9BQU9NO0FBQ1Q7QUFFQSx3QkFBd0I7QUFDeEIsU0FBU0Msb0JBQW9CQyxNQUFNO0lBQ2pDLElBQUlDLEtBQThDLEVBQUUsRUFBQztJQUNyRCxNQUFNLEVBQUVDLFFBQVEsRUFBRWQsT0FBTyxFQUFFZSxNQUFNLEVBQUVDLEdBQUcsRUFBRSxHQUFHSjtJQUMzQyxJQUFJQyxLQUFxQyxJQUFJYixTQUFTO1FBQ3BERCxrQ0FBa0NDO0lBQ3BDO0lBQ0EsSUFBSWlCO0lBQ0osSUFBSSwwQkFBMEJMLFFBQVE7UUFDcENLLG1CQUFtQjtZQUFFQyxZQUFZTixPQUFPTyxvQkFBb0I7UUFBQztJQUMvRDtJQUNBLE1BQU1DLGdCQUFnQnBCLFdBQVdTLGlCQUFpQlQ7SUFDbEQsT0FBTyxlQUFlcUIsZ0JBQWdCLEVBQ3BDQyxPQUFPLEVBQ1BDLE1BQU0sRUFDUDtRQUNDLE1BQU1DLE9BQU9ULFNBQVNBLE9BQU9PLFdBQVdHLEtBQUtDLFNBQVMsQ0FBQ0o7UUFDdkQsTUFBTUssY0FBYztZQUNsQixHQUFHVixnQkFBZ0I7WUFDbkJPO1lBQ0F4QixTQUFTO2dCQUNQLEdBQUdvQixhQUFhO2dCQUNoQixzRkFBc0Y7Z0JBQ3RGcEMsUUFBUTtnQkFDUixrQkFBa0J3QyxLQUFLaEIsTUFBTSxDQUFDb0IsUUFBUTtnQkFDdEMsZ0JBQWdCO1lBQ2xCO1lBQ0FDLFFBQVE7WUFDUk47UUFDRjtRQUNBLE1BQU1PLFdBQVcsTUFBTUMsTUFBTWYsS0FBS1c7UUFDbEMsSUFBSSxDQUFDRyxTQUFTRSxFQUFFLEVBQUU7WUFDaEIsTUFBTSxJQUFJdkQsdURBQVdBLENBQUNDLG1GQUF1Q0EsRUFBRTtnQkFDN0RzQixTQUFTOEIsU0FBUzlCLE9BQU87Z0JBQ3pCaUMsU0FBU0gsU0FBU0ksVUFBVTtnQkFDNUJDLFlBQVlMLFNBQVNNLE1BQU07WUFDN0I7UUFDRjtRQUNBLElBQUl0QixVQUFVO1lBQ1osT0FBT0EsU0FBUyxNQUFNZ0IsU0FBU08sSUFBSSxJQUFJZjtRQUN6QztRQUNBLE9BQU8sTUFBTVEsU0FBU1EsSUFBSTtJQUM1QjtBQUNGO0FBQ0EsSUFBSUMscUJBQXFCO0lBQ3ZCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDRDtBQUNELFNBQVNDLGdCQUFnQmxCLE9BQU87SUFDOUIsT0FBT3hDLGtFQUFnQkEsQ0FBQ3dDLFlBQVlpQixtQkFBbUJFLFFBQVEsQ0FBQ25CLFFBQVFPLE1BQU07QUFDaEY7QUFFQSx1Q0FBdUM7QUFDdkMsU0FBU2EsZ0NBQWdDOUIsTUFBTTtJQUM3QyxPQUFPRCxvQkFBb0I7UUFDekIsR0FBR0MsTUFBTTtRQUNURSxVQUFVLENBQUM2QixhQUFhckIsVUFBWWtCLGdCQUFnQmxCLFdBQVd6Qyw0RUFBb0JBLENBQUM4RCxlQUFlbEIsS0FBS21CLEtBQUssQ0FBQ0Q7UUFDOUc1QixRQUFRLENBQUNPLFVBQVlrQixnQkFBZ0JsQixXQUFXMUMsZ0ZBQXdCQSxDQUFDMEMsV0FBV0csS0FBS0MsU0FBUyxDQUFDSjtJQUNyRztBQUNGO0FBRWdFLENBQ2hFLHVDQUF1QztDQUN2Qyx1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGF3LXdvcmtzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvcnBjLXRyYW5zcG9ydC1odHRwL2Rpc3QvaW5kZXgubm9kZS5tanM/MWJmYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTb2xhbmFFcnJvciwgU09MQU5BX0VSUk9SX19SUENfX1RSQU5TUE9SVF9IVFRQX0VSUk9SLCBTT0xBTkFfRVJST1JfX1JQQ19fVFJBTlNQT1JUX0hUVFBfSEVBREVSX0ZPUkJJRERFTiB9IGZyb20gJ0Bzb2xhbmEvZXJyb3JzJztcbmltcG9ydCB7IHN0cmluZ2lmeUpzb25XaXRoQmlnSW50cywgcGFyc2VKc29uV2l0aEJpZ0ludHMgfSBmcm9tICdAc29sYW5hL3JwYy1zcGVjLXR5cGVzJztcbmltcG9ydCB7IGlzSnNvblJwY1BheWxvYWQgfSBmcm9tICdAc29sYW5hL3JwYy1zcGVjJztcblxuLy8gc3JjL2h0dHAtdHJhbnNwb3J0LnRzXG52YXIgRElTQUxMT1dFRF9IRUFERVJTID0ge1xuICBhY2NlcHQ6IHRydWUsXG4gIFwiY29udGVudC1sZW5ndGhcIjogdHJ1ZSxcbiAgXCJjb250ZW50LXR5cGVcIjogdHJ1ZVxufTtcbnZhciBGT1JCSURERU5fSEVBREVSUyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuYXNzaWduKFxuICB7XG4gICAgXCJhY2NlcHQtY2hhcnNldFwiOiB0cnVlLFxuICAgIFwiYWNjZXNzLWNvbnRyb2wtcmVxdWVzdC1oZWFkZXJzXCI6IHRydWUsXG4gICAgXCJhY2Nlc3MtY29udHJvbC1yZXF1ZXN0LW1ldGhvZFwiOiB0cnVlLFxuICAgIGNvbm5lY3Rpb246IHRydWUsXG4gICAgXCJjb250ZW50LWxlbmd0aFwiOiB0cnVlLFxuICAgIGNvb2tpZTogdHJ1ZSxcbiAgICBkYXRlOiB0cnVlLFxuICAgIGRudDogdHJ1ZSxcbiAgICBleHBlY3Q6IHRydWUsXG4gICAgaG9zdDogdHJ1ZSxcbiAgICBcImtlZXAtYWxpdmVcIjogdHJ1ZSxcbiAgICBcInBlcm1pc3Npb25zLXBvbGljeVwiOiB0cnVlLFxuICAgIC8vIFByZWZpeCBtYXRjaGluZyBpcyBpbXBsZW1lbnRlZCBpbiBjb2RlLCBiZWxvdy5cbiAgICAvLyAncHJveHktJzogdHJ1ZSxcbiAgICAvLyAnc2VjLSc6IHRydWUsXG4gICAgcmVmZXJlcjogdHJ1ZSxcbiAgICB0ZTogdHJ1ZSxcbiAgICB0cmFpbGVyOiB0cnVlLFxuICAgIFwidHJhbnNmZXItZW5jb2RpbmdcIjogdHJ1ZSxcbiAgICB1cGdyYWRlOiB0cnVlLFxuICAgIHZpYTogdHJ1ZVxuICB9LFxuICB2b2lkIDAgLFxuICB2b2lkIDBcbik7XG5mdW5jdGlvbiBhc3NlcnRJc0FsbG93ZWRIdHRwUmVxdWVzdEhlYWRlcnMoaGVhZGVycykge1xuICBjb25zdCBiYWRIZWFkZXJzID0gT2JqZWN0LmtleXMoaGVhZGVycykuZmlsdGVyKChoZWFkZXJOYW1lKSA9PiB7XG4gICAgY29uc3QgbG93ZXJjYXNlSGVhZGVyTmFtZSA9IGhlYWRlck5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gRElTQUxMT1dFRF9IRUFERVJTW2hlYWRlck5hbWUudG9Mb3dlckNhc2UoKV0gPT09IHRydWUgfHwgRk9SQklEREVOX0hFQURFUlNbaGVhZGVyTmFtZS50b0xvd2VyQ2FzZSgpXSA9PT0gdHJ1ZSB8fCBsb3dlcmNhc2VIZWFkZXJOYW1lLnN0YXJ0c1dpdGgoXCJwcm94eS1cIikgfHwgbG93ZXJjYXNlSGVhZGVyTmFtZS5zdGFydHNXaXRoKFwic2VjLVwiKTtcbiAgfSk7XG4gIGlmIChiYWRIZWFkZXJzLmxlbmd0aCA+IDApIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19SUENfX1RSQU5TUE9SVF9IVFRQX0hFQURFUl9GT1JCSURERU4sIHtcbiAgICAgIGhlYWRlcnM6IGJhZEhlYWRlcnNcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gbm9ybWFsaXplSGVhZGVycyhoZWFkZXJzKSB7XG4gIGNvbnN0IG91dCA9IHt9O1xuICBmb3IgKGNvbnN0IGhlYWRlck5hbWUgaW4gaGVhZGVycykge1xuICAgIG91dFtoZWFkZXJOYW1lLnRvTG93ZXJDYXNlKCldID0gaGVhZGVyc1toZWFkZXJOYW1lXTtcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuXG4vLyBzcmMvaHR0cC10cmFuc3BvcnQudHNcbmZ1bmN0aW9uIGNyZWF0ZUh0dHBUcmFuc3BvcnQoY29uZmlnKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZmFsc2UpIDtcbiAgY29uc3QgeyBmcm9tSnNvbiwgaGVhZGVycywgdG9Kc29uLCB1cmwgfSA9IGNvbmZpZztcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBoZWFkZXJzKSB7XG4gICAgYXNzZXJ0SXNBbGxvd2VkSHR0cFJlcXVlc3RIZWFkZXJzKGhlYWRlcnMpO1xuICB9XG4gIGxldCBkaXNwYXRjaGVyQ29uZmlnO1xuICBpZiAoXCJkaXNwYXRjaGVyX05PREVfT05MWVwiIGluIGNvbmZpZykge1xuICAgIGRpc3BhdGNoZXJDb25maWcgPSB7IGRpc3BhdGNoZXI6IGNvbmZpZy5kaXNwYXRjaGVyX05PREVfT05MWSB9O1xuICB9XG4gIGNvbnN0IGN1c3RvbUhlYWRlcnMgPSBoZWFkZXJzICYmIG5vcm1hbGl6ZUhlYWRlcnMoaGVhZGVycyk7XG4gIHJldHVybiBhc3luYyBmdW5jdGlvbiBtYWtlSHR0cFJlcXVlc3Qoe1xuICAgIHBheWxvYWQsXG4gICAgc2lnbmFsXG4gIH0pIHtcbiAgICBjb25zdCBib2R5ID0gdG9Kc29uID8gdG9Kc29uKHBheWxvYWQpIDogSlNPTi5zdHJpbmdpZnkocGF5bG9hZCk7XG4gICAgY29uc3QgcmVxdWVzdEluZm8gPSB7XG4gICAgICAuLi5kaXNwYXRjaGVyQ29uZmlnLFxuICAgICAgYm9keSxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgLi4uY3VzdG9tSGVhZGVycyxcbiAgICAgICAgLy8gS2VlcCB0aGVzZSBoZWFkZXJzIGxvd2VyY2FzZSBzbyB0aGV5IHdpbGwgb3ZlcnJpZGUgYW55IHVzZXItc3VwcGxpZWQgaGVhZGVycyBhYm92ZS5cbiAgICAgICAgYWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgXCJjb250ZW50LWxlbmd0aFwiOiBib2R5Lmxlbmd0aC50b1N0cmluZygpLFxuICAgICAgICBcImNvbnRlbnQtdHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIlxuICAgICAgfSxcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBzaWduYWxcbiAgICB9O1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCByZXF1ZXN0SW5mbyk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fUlBDX19UUkFOU1BPUlRfSFRUUF9FUlJPUiwge1xuICAgICAgICBoZWFkZXJzOiByZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICBtZXNzYWdlOiByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXNcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZnJvbUpzb24pIHtcbiAgICAgIHJldHVybiBmcm9tSnNvbihhd2FpdCByZXNwb25zZS50ZXh0KCksIHBheWxvYWQpO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICB9O1xufVxudmFyIFNPTEFOQV9SUENfTUVUSE9EUyA9IFtcbiAgXCJnZXRBY2NvdW50SW5mb1wiLFxuICBcImdldEJhbGFuY2VcIixcbiAgXCJnZXRCbG9ja1wiLFxuICBcImdldEJsb2NrQ29tbWl0bWVudFwiLFxuICBcImdldEJsb2NrSGVpZ2h0XCIsXG4gIFwiZ2V0QmxvY2tQcm9kdWN0aW9uXCIsXG4gIFwiZ2V0QmxvY2tzXCIsXG4gIFwiZ2V0QmxvY2tzV2l0aExpbWl0XCIsXG4gIFwiZ2V0QmxvY2tUaW1lXCIsXG4gIFwiZ2V0Q2x1c3Rlck5vZGVzXCIsXG4gIFwiZ2V0RXBvY2hJbmZvXCIsXG4gIFwiZ2V0RXBvY2hTY2hlZHVsZVwiLFxuICBcImdldEZlZUZvck1lc3NhZ2VcIixcbiAgXCJnZXRGaXJzdEF2YWlsYWJsZUJsb2NrXCIsXG4gIFwiZ2V0R2VuZXNpc0hhc2hcIixcbiAgXCJnZXRIZWFsdGhcIixcbiAgXCJnZXRIaWdoZXN0U25hcHNob3RTbG90XCIsXG4gIFwiZ2V0SWRlbnRpdHlcIixcbiAgXCJnZXRJbmZsYXRpb25Hb3Zlcm5vclwiLFxuICBcImdldEluZmxhdGlvblJhdGVcIixcbiAgXCJnZXRJbmZsYXRpb25SZXdhcmRcIixcbiAgXCJnZXRMYXJnZXN0QWNjb3VudHNcIixcbiAgXCJnZXRMYXRlc3RCbG9ja2hhc2hcIixcbiAgXCJnZXRMZWFkZXJTY2hlZHVsZVwiLFxuICBcImdldE1heFJldHJhbnNtaXRTbG90XCIsXG4gIFwiZ2V0TWF4U2hyZWRJbnNlcnRTbG90XCIsXG4gIFwiZ2V0TWluaW11bUJhbGFuY2VGb3JSZW50RXhlbXB0aW9uXCIsXG4gIFwiZ2V0TXVsdGlwbGVBY2NvdW50c1wiLFxuICBcImdldFByb2dyYW1BY2NvdW50c1wiLFxuICBcImdldFJlY2VudFBlcmZvcm1hbmNlU2FtcGxlc1wiLFxuICBcImdldFJlY2VudFByaW9yaXRpemF0aW9uRmVlc1wiLFxuICBcImdldFNpZ25hdHVyZXNGb3JBZGRyZXNzXCIsXG4gIFwiZ2V0U2lnbmF0dXJlU3RhdHVzZXNcIixcbiAgXCJnZXRTbG90XCIsXG4gIFwiZ2V0U2xvdExlYWRlclwiLFxuICBcImdldFNsb3RMZWFkZXJzXCIsXG4gIFwiZ2V0U3Rha2VNaW5pbXVtRGVsZWdhdGlvblwiLFxuICBcImdldFN1cHBseVwiLFxuICBcImdldFRva2VuQWNjb3VudEJhbGFuY2VcIixcbiAgXCJnZXRUb2tlbkFjY291bnRzQnlEZWxlZ2F0ZVwiLFxuICBcImdldFRva2VuQWNjb3VudHNCeU93bmVyXCIsXG4gIFwiZ2V0VG9rZW5MYXJnZXN0QWNjb3VudHNcIixcbiAgXCJnZXRUb2tlblN1cHBseVwiLFxuICBcImdldFRyYW5zYWN0aW9uXCIsXG4gIFwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiLFxuICBcImdldFZlcnNpb25cIixcbiAgXCJnZXRWb3RlQWNjb3VudHNcIixcbiAgXCJpbmRleFwiLFxuICBcImlzQmxvY2toYXNoVmFsaWRcIixcbiAgXCJtaW5pbXVtTGVkZ2VyU2xvdFwiLFxuICBcInJlcXVlc3RBaXJkcm9wXCIsXG4gIFwic2VuZFRyYW5zYWN0aW9uXCIsXG4gIFwic2ltdWxhdGVUcmFuc2FjdGlvblwiXG5dO1xuZnVuY3Rpb24gaXNTb2xhbmFSZXF1ZXN0KHBheWxvYWQpIHtcbiAgcmV0dXJuIGlzSnNvblJwY1BheWxvYWQocGF5bG9hZCkgJiYgU09MQU5BX1JQQ19NRVRIT0RTLmluY2x1ZGVzKHBheWxvYWQubWV0aG9kKTtcbn1cblxuLy8gc3JjL2h0dHAtdHJhbnNwb3J0LWZvci1zb2xhbmEtcnBjLnRzXG5mdW5jdGlvbiBjcmVhdGVIdHRwVHJhbnNwb3J0Rm9yU29sYW5hUnBjKGNvbmZpZykge1xuICByZXR1cm4gY3JlYXRlSHR0cFRyYW5zcG9ydCh7XG4gICAgLi4uY29uZmlnLFxuICAgIGZyb21Kc29uOiAocmF3UmVzcG9uc2UsIHBheWxvYWQpID0+IGlzU29sYW5hUmVxdWVzdChwYXlsb2FkKSA/IHBhcnNlSnNvbldpdGhCaWdJbnRzKHJhd1Jlc3BvbnNlKSA6IEpTT04ucGFyc2UocmF3UmVzcG9uc2UpLFxuICAgIHRvSnNvbjogKHBheWxvYWQpID0+IGlzU29sYW5hUmVxdWVzdChwYXlsb2FkKSA/IHN0cmluZ2lmeUpzb25XaXRoQmlnSW50cyhwYXlsb2FkKSA6IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpXG4gIH0pO1xufVxuXG5leHBvcnQgeyBjcmVhdGVIdHRwVHJhbnNwb3J0LCBjcmVhdGVIdHRwVHJhbnNwb3J0Rm9yU29sYW5hUnBjIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5ub2RlLm1qcy5tYXBcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm5vZGUubWpzLm1hcCJdLCJuYW1lcyI6WyJTb2xhbmFFcnJvciIsIlNPTEFOQV9FUlJPUl9fUlBDX19UUkFOU1BPUlRfSFRUUF9FUlJPUiIsIlNPTEFOQV9FUlJPUl9fUlBDX19UUkFOU1BPUlRfSFRUUF9IRUFERVJfRk9SQklEREVOIiwic3RyaW5naWZ5SnNvbldpdGhCaWdJbnRzIiwicGFyc2VKc29uV2l0aEJpZ0ludHMiLCJpc0pzb25ScGNQYXlsb2FkIiwiRElTQUxMT1dFRF9IRUFERVJTIiwiYWNjZXB0IiwiRk9SQklEREVOX0hFQURFUlMiLCJPYmplY3QiLCJhc3NpZ24iLCJjb25uZWN0aW9uIiwiY29va2llIiwiZGF0ZSIsImRudCIsImV4cGVjdCIsImhvc3QiLCJyZWZlcmVyIiwidGUiLCJ0cmFpbGVyIiwidXBncmFkZSIsInZpYSIsImFzc2VydElzQWxsb3dlZEh0dHBSZXF1ZXN0SGVhZGVycyIsImhlYWRlcnMiLCJiYWRIZWFkZXJzIiwia2V5cyIsImZpbHRlciIsImhlYWRlck5hbWUiLCJsb3dlcmNhc2VIZWFkZXJOYW1lIiwidG9Mb3dlckNhc2UiLCJzdGFydHNXaXRoIiwibGVuZ3RoIiwibm9ybWFsaXplSGVhZGVycyIsIm91dCIsImNyZWF0ZUh0dHBUcmFuc3BvcnQiLCJjb25maWciLCJwcm9jZXNzIiwiZnJvbUpzb24iLCJ0b0pzb24iLCJ1cmwiLCJkaXNwYXRjaGVyQ29uZmlnIiwiZGlzcGF0Y2hlciIsImRpc3BhdGNoZXJfTk9ERV9PTkxZIiwiY3VzdG9tSGVhZGVycyIsIm1ha2VIdHRwUmVxdWVzdCIsInBheWxvYWQiLCJzaWduYWwiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsInJlcXVlc3RJbmZvIiwidG9TdHJpbmciLCJtZXRob2QiLCJyZXNwb25zZSIsImZldGNoIiwib2siLCJtZXNzYWdlIiwic3RhdHVzVGV4dCIsInN0YXR1c0NvZGUiLCJzdGF0dXMiLCJ0ZXh0IiwianNvbiIsIlNPTEFOQV9SUENfTUVUSE9EUyIsImlzU29sYW5hUmVxdWVzdCIsImluY2x1ZGVzIiwiY3JlYXRlSHR0cFRyYW5zcG9ydEZvclNvbGFuYVJwYyIsInJhd1Jlc3BvbnNlIiwicGFyc2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/rpc-transport-http/dist/index.node.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/rpc-types/dist/index.node.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@solana/rpc-types/dist/index.node.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertIsBlockhash: () => (/* binding */ assertIsBlockhash),\n/* harmony export */   assertIsLamports: () => (/* binding */ assertIsLamports),\n/* harmony export */   assertIsStringifiedBigInt: () => (/* binding */ assertIsStringifiedBigInt),\n/* harmony export */   assertIsStringifiedNumber: () => (/* binding */ assertIsStringifiedNumber),\n/* harmony export */   assertIsUnixTimestamp: () => (/* binding */ assertIsUnixTimestamp),\n/* harmony export */   blockhash: () => (/* binding */ blockhash),\n/* harmony export */   commitmentComparator: () => (/* binding */ commitmentComparator),\n/* harmony export */   devnet: () => (/* binding */ devnet),\n/* harmony export */   getBlockhashCodec: () => (/* binding */ getBlockhashCodec),\n/* harmony export */   getBlockhashComparator: () => (/* binding */ getBlockhashComparator),\n/* harmony export */   getBlockhashDecoder: () => (/* binding */ getBlockhashDecoder),\n/* harmony export */   getBlockhashEncoder: () => (/* binding */ getBlockhashEncoder),\n/* harmony export */   getDefaultLamportsCodec: () => (/* binding */ getDefaultLamportsCodec),\n/* harmony export */   getDefaultLamportsDecoder: () => (/* binding */ getDefaultLamportsDecoder),\n/* harmony export */   getDefaultLamportsEncoder: () => (/* binding */ getDefaultLamportsEncoder),\n/* harmony export */   getLamportsCodec: () => (/* binding */ getLamportsCodec),\n/* harmony export */   getLamportsDecoder: () => (/* binding */ getLamportsDecoder),\n/* harmony export */   getLamportsEncoder: () => (/* binding */ getLamportsEncoder),\n/* harmony export */   isBlockhash: () => (/* binding */ isBlockhash),\n/* harmony export */   isLamports: () => (/* binding */ isLamports),\n/* harmony export */   isStringifiedBigInt: () => (/* binding */ isStringifiedBigInt),\n/* harmony export */   isStringifiedNumber: () => (/* binding */ isStringifiedNumber),\n/* harmony export */   isUnixTimestamp: () => (/* binding */ isUnixTimestamp),\n/* harmony export */   lamports: () => (/* binding */ lamports),\n/* harmony export */   mainnet: () => (/* binding */ mainnet),\n/* harmony export */   stringifiedBigInt: () => (/* binding */ stringifiedBigInt),\n/* harmony export */   stringifiedNumber: () => (/* binding */ stringifiedNumber),\n/* harmony export */   testnet: () => (/* binding */ testnet),\n/* harmony export */   unixTimestamp: () => (/* binding */ unixTimestamp)\n/* harmony export */ });\n/* harmony import */ var _solana_addresses__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/addresses */ \"(ssr)/./node_modules/@solana/addresses/dist/index.node.mjs\");\n/* harmony import */ var _solana_codecs_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @solana/codecs-core */ \"(ssr)/./node_modules/@solana/codecs-core/dist/index.node.mjs\");\n/* harmony import */ var _solana_errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana/errors */ \"(ssr)/./node_modules/@solana/errors/dist/index.node.mjs\");\n/* harmony import */ var _solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @solana/codecs-numbers */ \"(ssr)/./node_modules/@solana/codecs-numbers/dist/index.node.mjs\");\n\n\n\n\n// src/blockhash.ts\nfunction isBlockhash(putativeBlockhash) {\n    return (0,_solana_addresses__WEBPACK_IMPORTED_MODULE_0__.isAddress)(putativeBlockhash);\n}\nfunction assertIsBlockhash(putativeBlockhash) {\n    try {\n        (0,_solana_addresses__WEBPACK_IMPORTED_MODULE_0__.assertIsAddress)(putativeBlockhash);\n    } catch (error) {\n        if ((0,_solana_errors__WEBPACK_IMPORTED_MODULE_1__.isSolanaError)(error, _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE)) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE, error.context);\n        }\n        if ((0,_solana_errors__WEBPACK_IMPORTED_MODULE_1__.isSolanaError)(error, _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH)) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH, error.context);\n        }\n        throw error;\n    }\n}\nfunction blockhash(putativeBlockhash) {\n    assertIsBlockhash(putativeBlockhash);\n    return putativeBlockhash;\n}\nfunction getBlockhashEncoder() {\n    const addressEncoder = (0,_solana_addresses__WEBPACK_IMPORTED_MODULE_0__.getAddressEncoder)();\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_2__.createEncoder)({\n        fixedSize: 32,\n        write: (value, bytes, offset)=>{\n            assertIsBlockhash(value);\n            return addressEncoder.write(value, bytes, offset);\n        }\n    });\n}\nfunction getBlockhashDecoder() {\n    return (0,_solana_addresses__WEBPACK_IMPORTED_MODULE_0__.getAddressDecoder)();\n}\nfunction getBlockhashCodec() {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_2__.combineCodec)(getBlockhashEncoder(), getBlockhashDecoder());\n}\nfunction getBlockhashComparator() {\n    return new Intl.Collator(\"en\", {\n        caseFirst: \"lower\",\n        ignorePunctuation: false,\n        localeMatcher: \"best fit\",\n        numeric: false,\n        sensitivity: \"variant\",\n        usage: \"sort\"\n    }).compare;\n}\n// src/cluster-url.ts\nfunction mainnet(putativeString) {\n    return putativeString;\n}\nfunction devnet(putativeString) {\n    return putativeString;\n}\nfunction testnet(putativeString) {\n    return putativeString;\n}\nfunction getCommitmentScore(commitment) {\n    switch(commitment){\n        case \"finalized\":\n            return 2;\n        case \"confirmed\":\n            return 1;\n        case \"processed\":\n            return 0;\n        default:\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE, {\n                unexpectedValue: commitment\n            });\n    }\n}\nfunction commitmentComparator(a, b) {\n    if (a === b) {\n        return 0;\n    }\n    return getCommitmentScore(a) < getCommitmentScore(b) ? -1 : 1;\n}\nvar maxU64Value = 18446744073709551615n;\nvar memoizedU64Encoder;\nvar memoizedU64Decoder;\nfunction getMemoizedU64Encoder() {\n    if (!memoizedU64Encoder) memoizedU64Encoder = (0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_3__.getU64Encoder)();\n    return memoizedU64Encoder;\n}\nfunction getMemoizedU64Decoder() {\n    if (!memoizedU64Decoder) memoizedU64Decoder = (0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_3__.getU64Decoder)();\n    return memoizedU64Decoder;\n}\nfunction isLamports(putativeLamports) {\n    return putativeLamports >= 0 && putativeLamports <= maxU64Value;\n}\nfunction assertIsLamports(putativeLamports) {\n    if (putativeLamports < 0 || putativeLamports > maxU64Value) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE);\n    }\n}\nfunction lamports(putativeLamports) {\n    assertIsLamports(putativeLamports);\n    return putativeLamports;\n}\nfunction getDefaultLamportsEncoder() {\n    return getLamportsEncoder(getMemoizedU64Encoder());\n}\nfunction getLamportsEncoder(innerEncoder) {\n    return innerEncoder;\n}\nfunction getDefaultLamportsDecoder() {\n    return getLamportsDecoder(getMemoizedU64Decoder());\n}\nfunction getLamportsDecoder(innerDecoder) {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_2__.transformDecoder)(innerDecoder, (value)=>lamports(typeof value === \"bigint\" ? value : BigInt(value)));\n}\nfunction getDefaultLamportsCodec() {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_2__.combineCodec)(getDefaultLamportsEncoder(), getDefaultLamportsDecoder());\n}\nfunction getLamportsCodec(innerCodec) {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_2__.combineCodec)(getLamportsEncoder(innerCodec), getLamportsDecoder(innerCodec));\n}\nfunction isStringifiedBigInt(putativeBigInt) {\n    try {\n        BigInt(putativeBigInt);\n        return true;\n    } catch  {\n        return false;\n    }\n}\nfunction assertIsStringifiedBigInt(putativeBigInt) {\n    try {\n        BigInt(putativeBigInt);\n    } catch  {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__MALFORMED_BIGINT_STRING, {\n            value: putativeBigInt\n        });\n    }\n}\nfunction stringifiedBigInt(putativeBigInt) {\n    assertIsStringifiedBigInt(putativeBigInt);\n    return putativeBigInt;\n}\nfunction isStringifiedNumber(putativeNumber) {\n    return !Number.isNaN(Number(putativeNumber));\n}\nfunction assertIsStringifiedNumber(putativeNumber) {\n    if (Number.isNaN(Number(putativeNumber))) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__MALFORMED_NUMBER_STRING, {\n            value: putativeNumber\n        });\n    }\n}\nfunction stringifiedNumber(putativeNumber) {\n    assertIsStringifiedNumber(putativeNumber);\n    return putativeNumber;\n}\nvar maxI64Value = 9223372036854775807n;\nvar minI64Value = -9223372036854775808n;\nfunction isUnixTimestamp(putativeTimestamp) {\n    return putativeTimestamp >= minI64Value && putativeTimestamp <= maxI64Value;\n}\nfunction assertIsUnixTimestamp(putativeTimestamp) {\n    if (putativeTimestamp < minI64Value || putativeTimestamp > maxI64Value) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE, {\n            value: putativeTimestamp\n        });\n    }\n}\nfunction unixTimestamp(putativeTimestamp) {\n    assertIsUnixTimestamp(putativeTimestamp);\n    return putativeTimestamp;\n}\n //# sourceMappingURL=index.node.mjs.map\n //# sourceMappingURL=index.node.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS9ycGMtdHlwZXMvZGlzdC9pbmRleC5ub2RlLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBcUc7QUFDakI7QUFDbVk7QUFDalo7QUFFdEUsbUJBQW1CO0FBQ25CLFNBQVNvQixZQUFZQyxpQkFBaUI7SUFDcEMsT0FBT3JCLDREQUFTQSxDQUFDcUI7QUFDbkI7QUFDQSxTQUFTQyxrQkFBa0JELGlCQUFpQjtJQUMxQyxJQUFJO1FBQ0ZwQixrRUFBZUEsQ0FBQ29CO0lBQ2xCLEVBQUUsT0FBT0UsT0FBTztRQUNkLElBQUloQiw2REFBYUEsQ0FBQ2dCLE9BQU9mLCtGQUFtREEsR0FBRztZQUM3RSxNQUFNLElBQUlDLHVEQUFXQSxDQUFDQyw4RkFBa0RBLEVBQUVhLE1BQU1DLE9BQU87UUFDekY7UUFDQSxJQUFJakIsNkRBQWFBLENBQUNnQixPQUFPWix3RkFBNENBLEdBQUc7WUFDdEUsTUFBTSxJQUFJRix1REFBV0EsQ0FBQ0csdUZBQTJDQSxFQUFFVyxNQUFNQyxPQUFPO1FBQ2xGO1FBQ0EsTUFBTUQ7SUFDUjtBQUNGO0FBQ0EsU0FBU0UsVUFBVUosaUJBQWlCO0lBQ2xDQyxrQkFBa0JEO0lBQ2xCLE9BQU9BO0FBQ1Q7QUFDQSxTQUFTSztJQUNQLE1BQU1DLGlCQUFpQnpCLG9FQUFpQkE7SUFDeEMsT0FBT0Usa0VBQWFBLENBQUM7UUFDbkJ3QixXQUFXO1FBQ1hDLE9BQU8sQ0FBQ0MsT0FBT0MsT0FBT0M7WUFDcEJWLGtCQUFrQlE7WUFDbEIsT0FBT0gsZUFBZUUsS0FBSyxDQUFDQyxPQUFPQyxPQUFPQztRQUM1QztJQUNGO0FBQ0Y7QUFDQSxTQUFTQztJQUNQLE9BQU85QixvRUFBaUJBO0FBQzFCO0FBQ0EsU0FBUytCO0lBQ1AsT0FBTzdCLGlFQUFZQSxDQUFDcUIsdUJBQXVCTztBQUM3QztBQUNBLFNBQVNFO0lBQ1AsT0FBTyxJQUFJQyxLQUFLQyxRQUFRLENB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RjtBQUNBLFNBQVNJLGtCQUFrQkosY0FBYztJQUN2Q0csMEJBQTBCSDtJQUMxQixPQUFPQTtBQUNUO0FBQ0EsSUFBSUssY0FBYyxvQkFBb0I7QUFDdEMsSUFBSUMsY0FBYyxDQUFDLG9CQUFvQjtBQUN2QyxTQUFTQyxnQkFBZ0JDLGlCQUFpQjtJQUN4QyxPQUFPQSxxQkFBcUJGLGVBQWVFLHFCQUFxQkg7QUFDbEU7QUFDQSxTQUFTSSxzQkFBc0JELGlCQUFpQjtJQUM5QyxJQUFJQSxvQkFBb0JGLGVBQWVFLG9CQUFvQkgsYUFBYTtRQUN0RSxNQUFNLElBQUkzRSx1REFBV0EsQ0FBQ08sZ0ZBQW9DQSxFQUFFO1lBQzFEYyxPQUFPeUQ7UUFDVDtJQUNGO0FBQ0Y7QUFDQSxTQUFTRSxjQUFjRixpQkFBaUI7SUFDdENDLHNCQUFzQkQ7SUFDdEIsT0FBT0E7QUFDVDtBQUV3aUIsQ0FDeGlCLHVDQUF1QztDQUN2Qyx1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGF3LXdvcmtzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvcnBjLXR5cGVzL2Rpc3QvaW5kZXgubm9kZS5tanM/NGI0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc0FkZHJlc3MsIGFzc2VydElzQWRkcmVzcywgZ2V0QWRkcmVzc0VuY29kZXIsIGdldEFkZHJlc3NEZWNvZGVyIH0gZnJvbSAnQHNvbGFuYS9hZGRyZXNzZXMnO1xuaW1wb3J0IHsgY3JlYXRlRW5jb2RlciwgY29tYmluZUNvZGVjLCB0cmFuc2Zvcm1EZWNvZGVyIH0gZnJvbSAnQHNvbGFuYS9jb2RlY3MtY29yZSc7XG5pbXBvcnQgeyBpc1NvbGFuYUVycm9yLCBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fU1RSSU5HX0xFTkdUSF9PVVRfT0ZfUkFOR0UsIFNvbGFuYUVycm9yLCBTT0xBTkFfRVJST1JfX0JMT0NLSEFTSF9TVFJJTkdfTEVOR1RIX09VVF9PRl9SQU5HRSwgU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX0lOVkFMSURfQllURV9MRU5HVEgsIFNPTEFOQV9FUlJPUl9fSU5WQUxJRF9CTE9DS0hBU0hfQllURV9MRU5HVEgsIFNPTEFOQV9FUlJPUl9fTEFNUE9SVFNfT1VUX09GX1JBTkdFLCBTT0xBTkFfRVJST1JfX01BTEZPUk1FRF9CSUdJTlRfU1RSSU5HLCBTT0xBTkFfRVJST1JfX01BTEZPUk1FRF9OVU1CRVJfU1RSSU5HLCBTT0xBTkFfRVJST1JfX1RJTUVTVEFNUF9PVVRfT0ZfUkFOR0UsIFNPTEFOQV9FUlJPUl9fSU5WQVJJQU5UX1ZJT0xBVElPTl9fU1dJVENIX01VU1RfQkVfRVhIQVVTVElWRSB9IGZyb20gJ0Bzb2xhbmEvZXJyb3JzJztcbmltcG9ydCB7IGdldFU2NEVuY29kZXIsIGdldFU2NERlY29kZXIgfSBmcm9tICdAc29sYW5hL2NvZGVjcy1udW1iZXJzJztcblxuLy8gc3JjL2Jsb2NraGFzaC50c1xuZnVuY3Rpb24gaXNCbG9ja2hhc2gocHV0YXRpdmVCbG9ja2hhc2gpIHtcbiAgcmV0dXJuIGlzQWRkcmVzcyhwdXRhdGl2ZUJsb2NraGFzaCk7XG59XG5mdW5jdGlvbiBhc3NlcnRJc0Jsb2NraGFzaChwdXRhdGl2ZUJsb2NraGFzaCkge1xuICB0cnkge1xuICAgIGFzc2VydElzQWRkcmVzcyhwdXRhdGl2ZUJsb2NraGFzaCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGlzU29sYW5hRXJyb3IoZXJyb3IsIFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19TVFJJTkdfTEVOR1RIX09VVF9PRl9SQU5HRSkpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0JMT0NLSEFTSF9TVFJJTkdfTEVOR1RIX09VVF9PRl9SQU5HRSwgZXJyb3IuY29udGV4dCk7XG4gICAgfVxuICAgIGlmIChpc1NvbGFuYUVycm9yKGVycm9yLCBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fSU5WQUxJRF9CWVRFX0xFTkdUSCkpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0lOVkFMSURfQkxPQ0tIQVNIX0JZVEVfTEVOR1RILCBlcnJvci5jb250ZXh0KTtcbiAgICB9XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cbmZ1bmN0aW9uIGJsb2NraGFzaChwdXRhdGl2ZUJsb2NraGFzaCkge1xuICBhc3NlcnRJc0Jsb2NraGFzaChwdXRhdGl2ZUJsb2NraGFzaCk7XG4gIHJldHVybiBwdXRhdGl2ZUJsb2NraGFzaDtcbn1cbmZ1bmN0aW9uIGdldEJsb2NraGFzaEVuY29kZXIoKSB7XG4gIGNvbnN0IGFkZHJlc3NFbmNvZGVyID0gZ2V0QWRkcmVzc0VuY29kZXIoKTtcbiAgcmV0dXJuIGNyZWF0ZUVuY29kZXIoe1xuICAgIGZpeGVkU2l6ZTogMzIsXG4gICAgd3JpdGU6ICh2YWx1ZSwgYnl0ZXMsIG9mZnNldCkgPT4ge1xuICAgICAgYXNzZXJ0SXNCbG9ja2hhc2godmFsdWUpO1xuICAgICAgcmV0dXJuIGFkZHJlc3NFbmNvZGVyLndyaXRlKHZhbHVlLCBieXRlcywgb2Zmc2V0KTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0QmxvY2toYXNoRGVjb2RlcigpIHtcbiAgcmV0dXJuIGdldEFkZHJlc3NEZWNvZGVyKCk7XG59XG5mdW5jdGlvbiBnZXRCbG9ja2hhc2hDb2RlYygpIHtcbiAgcmV0dXJuIGNvbWJpbmVDb2RlYyhnZXRCbG9ja2hhc2hFbmNvZGVyKCksIGdldEJsb2NraGFzaERlY29kZXIoKSk7XG59XG5mdW5jdGlvbiBnZXRCbG9ja2hhc2hDb21wYXJhdG9yKCkge1xuICByZXR1cm4gbmV3IEludGwuQ29sbGF0b3IoXCJlblwiLCB7XG4gICAgY2FzZUZpcnN0OiBcImxvd2VyXCIsXG4gICAgaWdub3JlUHVuY3R1YXRpb246IGZhbHNlLFxuICAgIGxvY2FsZU1hdGNoZXI6IFwiYmVzdCBmaXRcIixcbiAgICBudW1lcmljOiBmYWxzZSxcbiAgICBzZW5zaXRpdml0eTogXCJ2YXJpYW50XCIsXG4gICAgdXNhZ2U6IFwic29ydFwiXG4gIH0pLmNvbXBhcmU7XG59XG5cbi8vIHNyYy9jbHVzdGVyLXVybC50c1xuZnVuY3Rpb24gbWFpbm5ldChwdXRhdGl2ZVN0cmluZykge1xuICByZXR1cm4gcHV0YXRpdmVTdHJpbmc7XG59XG5mdW5jdGlvbiBkZXZuZXQocHV0YXRpdmVTdHJpbmcpIHtcbiAgcmV0dXJuIHB1dGF0aXZlU3RyaW5nO1xufVxuZnVuY3Rpb24gdGVzdG5ldChwdXRhdGl2ZVN0cmluZykge1xuICByZXR1cm4gcHV0YXRpdmVTdHJpbmc7XG59XG5mdW5jdGlvbiBnZXRDb21taXRtZW50U2NvcmUoY29tbWl0bWVudCkge1xuICBzd2l0Y2ggKGNvbW1pdG1lbnQpIHtcbiAgICBjYXNlIFwiZmluYWxpemVkXCI6XG4gICAgICByZXR1cm4gMjtcbiAgICBjYXNlIFwiY29uZmlybWVkXCI6XG4gICAgICByZXR1cm4gMTtcbiAgICBjYXNlIFwicHJvY2Vzc2VkXCI6XG4gICAgICByZXR1cm4gMDtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fSU5WQVJJQU5UX1ZJT0xBVElPTl9fU1dJVENIX01VU1RfQkVfRVhIQVVTVElWRSwge1xuICAgICAgICB1bmV4cGVjdGVkVmFsdWU6IGNvbW1pdG1lbnRcbiAgICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBjb21taXRtZW50Q29tcGFyYXRvcihhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIGdldENvbW1pdG1lbnRTY29yZShhKSA8IGdldENvbW1pdG1lbnRTY29yZShiKSA/IC0xIDogMTtcbn1cbnZhciBtYXhVNjRWYWx1ZSA9IDE4NDQ2NzQ0MDczNzA5NTUxNjE1bjtcbnZhciBtZW1vaXplZFU2NEVuY29kZXI7XG52YXIgbWVtb2l6ZWRVNjREZWNvZGVyO1xuZnVuY3Rpb24gZ2V0TWVtb2l6ZWRVNjRFbmNvZGVyKCkge1xuICBpZiAoIW1lbW9pemVkVTY0RW5jb2RlcikgbWVtb2l6ZWRVNjRFbmNvZGVyID0gZ2V0VTY0RW5jb2RlcigpO1xuICByZXR1cm4gbWVtb2l6ZWRVNjRFbmNvZGVyO1xufVxuZnVuY3Rpb24gZ2V0TWVtb2l6ZWRVNjREZWNvZGVyKCkge1xuICBpZiAoIW1lbW9pemVkVTY0RGVjb2RlcikgbWVtb2l6ZWRVNjREZWNvZGVyID0gZ2V0VTY0RGVjb2RlcigpO1xuICByZXR1cm4gbWVtb2l6ZWRVNjREZWNvZGVyO1xufVxuZnVuY3Rpb24gaXNMYW1wb3J0cyhwdXRhdGl2ZUxhbXBvcnRzKSB7XG4gIHJldHVybiBwdXRhdGl2ZUxhbXBvcnRzID49IDAgJiYgcHV0YXRpdmVMYW1wb3J0cyA8PSBtYXhVNjRWYWx1ZTtcbn1cbmZ1bmN0aW9uIGFzc2VydElzTGFtcG9ydHMocHV0YXRpdmVMYW1wb3J0cykge1xuICBpZiAocHV0YXRpdmVMYW1wb3J0cyA8IDAgfHwgcHV0YXRpdmVMYW1wb3J0cyA+IG1heFU2NFZhbHVlKSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fTEFNUE9SVFNfT1VUX09GX1JBTkdFKTtcbiAgfVxufVxuZnVuY3Rpb24gbGFtcG9ydHMocHV0YXRpdmVMYW1wb3J0cykge1xuICBhc3NlcnRJc0xhbXBvcnRzKHB1dGF0aXZlTGFtcG9ydHMpO1xuICByZXR1cm4gcHV0YXRpdmVMYW1wb3J0cztcbn1cbmZ1bmN0aW9uIGdldERlZmF1bHRMYW1wb3J0c0VuY29kZXIoKSB7XG4gIHJldHVybiBnZXRMYW1wb3J0c0VuY29kZXIoZ2V0TWVtb2l6ZWRVNjRFbmNvZGVyKCkpO1xufVxuZnVuY3Rpb24gZ2V0TGFtcG9ydHNFbmNvZGVyKGlubmVyRW5jb2Rlcikge1xuICByZXR1cm4gaW5uZXJFbmNvZGVyO1xufVxuZnVuY3Rpb24gZ2V0RGVmYXVsdExhbXBvcnRzRGVjb2RlcigpIHtcbiAgcmV0dXJuIGdldExhbXBvcnRzRGVjb2RlcihnZXRNZW1vaXplZFU2NERlY29kZXIoKSk7XG59XG5mdW5jdGlvbiBnZXRMYW1wb3J0c0RlY29kZXIoaW5uZXJEZWNvZGVyKSB7XG4gIHJldHVybiB0cmFuc2Zvcm1EZWNvZGVyKFxuICAgIGlubmVyRGVjb2RlcixcbiAgICAodmFsdWUpID0+IGxhbXBvcnRzKHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIiA/IHZhbHVlIDogQmlnSW50KHZhbHVlKSlcbiAgKTtcbn1cbmZ1bmN0aW9uIGdldERlZmF1bHRMYW1wb3J0c0NvZGVjKCkge1xuICByZXR1cm4gY29tYmluZUNvZGVjKGdldERlZmF1bHRMYW1wb3J0c0VuY29kZXIoKSwgZ2V0RGVmYXVsdExhbXBvcnRzRGVjb2RlcigpKTtcbn1cbmZ1bmN0aW9uIGdldExhbXBvcnRzQ29kZWMoaW5uZXJDb2RlYykge1xuICByZXR1cm4gY29tYmluZUNvZGVjKGdldExhbXBvcnRzRW5jb2Rlcihpbm5lckNvZGVjKSwgZ2V0TGFtcG9ydHNEZWNvZGVyKGlubmVyQ29kZWMpKTtcbn1cbmZ1bmN0aW9uIGlzU3RyaW5naWZpZWRCaWdJbnQocHV0YXRpdmVCaWdJbnQpIHtcbiAgdHJ5IHtcbiAgICBCaWdJbnQocHV0YXRpdmVCaWdJbnQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIGFzc2VydElzU3RyaW5naWZpZWRCaWdJbnQocHV0YXRpdmVCaWdJbnQpIHtcbiAgdHJ5IHtcbiAgICBCaWdJbnQocHV0YXRpdmVCaWdJbnQpO1xuICB9IGNhdGNoIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19NQUxGT1JNRURfQklHSU5UX1NUUklORywge1xuICAgICAgdmFsdWU6IHB1dGF0aXZlQmlnSW50XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHN0cmluZ2lmaWVkQmlnSW50KHB1dGF0aXZlQmlnSW50KSB7XG4gIGFzc2VydElzU3RyaW5naWZpZWRCaWdJbnQocHV0YXRpdmVCaWdJbnQpO1xuICByZXR1cm4gcHV0YXRpdmVCaWdJbnQ7XG59XG5mdW5jdGlvbiBpc1N0cmluZ2lmaWVkTnVtYmVyKHB1dGF0aXZlTnVtYmVyKSB7XG4gIHJldHVybiAhTnVtYmVyLmlzTmFOKE51bWJlcihwdXRhdGl2ZU51bWJlcikpO1xufVxuZnVuY3Rpb24gYXNzZXJ0SXNTdHJpbmdpZmllZE51bWJlcihwdXRhdGl2ZU51bWJlcikge1xuICBpZiAoTnVtYmVyLmlzTmFOKE51bWJlcihwdXRhdGl2ZU51bWJlcikpKSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fTUFMRk9STUVEX05VTUJFUl9TVFJJTkcsIHtcbiAgICAgIHZhbHVlOiBwdXRhdGl2ZU51bWJlclxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBzdHJpbmdpZmllZE51bWJlcihwdXRhdGl2ZU51bWJlcikge1xuICBhc3NlcnRJc1N0cmluZ2lmaWVkTnVtYmVyKHB1dGF0aXZlTnVtYmVyKTtcbiAgcmV0dXJuIHB1dGF0aXZlTnVtYmVyO1xufVxudmFyIG1heEk2NFZhbHVlID0gOTIyMzM3MjAzNjg1NDc3NTgwN247XG52YXIgbWluSTY0VmFsdWUgPSAtOTIyMzM3MjAzNjg1NDc3NTgwOG47XG5mdW5jdGlvbiBpc1VuaXhUaW1lc3RhbXAocHV0YXRpdmVUaW1lc3RhbXApIHtcbiAgcmV0dXJuIHB1dGF0aXZlVGltZXN0YW1wID49IG1pbkk2NFZhbHVlICYmIHB1dGF0aXZlVGltZXN0YW1wIDw9IG1heEk2NFZhbHVlO1xufVxuZnVuY3Rpb24gYXNzZXJ0SXNVbml4VGltZXN0YW1wKHB1dGF0aXZlVGltZXN0YW1wKSB7XG4gIGlmIChwdXRhdGl2ZVRpbWVzdGFtcCA8IG1pbkk2NFZhbHVlIHx8IHB1dGF0aXZlVGltZXN0YW1wID4gbWF4STY0VmFsdWUpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19USU1FU1RBTVBfT1VUX09GX1JBTkdFLCB7XG4gICAgICB2YWx1ZTogcHV0YXRpdmVUaW1lc3RhbXBcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gdW5peFRpbWVzdGFtcChwdXRhdGl2ZVRpbWVzdGFtcCkge1xuICBhc3NlcnRJc1VuaXhUaW1lc3RhbXAocHV0YXRpdmVUaW1lc3RhbXApO1xuICByZXR1cm4gcHV0YXRpdmVUaW1lc3RhbXA7XG59XG5cbmV4cG9ydCB7IGFzc2VydElzQmxvY2toYXNoLCBhc3NlcnRJc0xhbXBvcnRzLCBhc3NlcnRJc1N0cmluZ2lmaWVkQmlnSW50LCBhc3NlcnRJc1N0cmluZ2lmaWVkTnVtYmVyLCBhc3NlcnRJc1VuaXhUaW1lc3RhbXAsIGJsb2NraGFzaCwgY29tbWl0bWVudENvbXBhcmF0b3IsIGRldm5ldCwgZ2V0QmxvY2toYXNoQ29kZWMsIGdldEJsb2NraGFzaENvbXBhcmF0b3IsIGdldEJsb2NraGFzaERlY29kZXIsIGdldEJsb2NraGFzaEVuY29kZXIsIGdldERlZmF1bHRMYW1wb3J0c0NvZGVjLCBnZXREZWZhdWx0TGFtcG9ydHNEZWNvZGVyLCBnZXREZWZhdWx0TGFtcG9ydHNFbmNvZGVyLCBnZXRMYW1wb3J0c0NvZGVjLCBnZXRMYW1wb3J0c0RlY29kZXIsIGdldExhbXBvcnRzRW5jb2RlciwgaXNCbG9ja2hhc2gsIGlzTGFtcG9ydHMsIGlzU3RyaW5naWZpZWRCaWdJbnQsIGlzU3RyaW5naWZpZWROdW1iZXIsIGlzVW5peFRpbWVzdGFtcCwgbGFtcG9ydHMsIG1haW5uZXQsIHN0cmluZ2lmaWVkQmlnSW50LCBzdHJpbmdpZmllZE51bWJlciwgdGVzdG5ldCwgdW5peFRpbWVzdGFtcCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubm9kZS5tanMubWFwXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5ub2RlLm1qcy5tYXAiXSwibmFtZXMiOlsiaXNBZGRyZXNzIiwiYXNzZXJ0SXNBZGRyZXNzIiwiZ2V0QWRkcmVzc0VuY29kZXIiLCJnZXRBZGRyZXNzRGVjb2RlciIsImNyZWF0ZUVuY29kZXIiLCJjb21iaW5lQ29kZWMiLCJ0cmFuc2Zvcm1EZWNvZGVyIiwiaXNTb2xhbmFFcnJvciIsIlNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19TVFJJTkdfTEVOR1RIX09VVF9PRl9SQU5HRSIsIlNvbGFuYUVycm9yIiwiU09MQU5BX0VSUk9SX19CTE9DS0hBU0hfU1RSSU5HX0xFTkdUSF9PVVRfT0ZfUkFOR0UiLCJTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fSU5WQUxJRF9CWVRFX0xFTkdUSCIsIlNPTEFOQV9FUlJPUl9fSU5WQUxJRF9CTE9DS0hBU0hfQllURV9MRU5HVEgiLCJTT0xBTkFfRVJST1JfX0xBTVBPUlRTX09VVF9PRl9SQU5HRSIsIlNPTEFOQV9FUlJPUl9fTUFMRk9STUVEX0JJR0lOVF9TVFJJTkciLCJTT0xBTkFfRVJST1JfX01BTEZPUk1FRF9OVU1CRVJfU1RSSU5HIiwiU09MQU5BX0VSUk9SX19USU1FU1RBTVBfT1VUX09GX1JBTkdFIiwiU09MQU5BX0VSUk9SX19JTlZBUklBTlRfVklPTEFUSU9OX19TV0lUQ0hfTVVTVF9CRV9FWEhBVVNUSVZFIiwiZ2V0VTY0RW5jb2RlciIsImdldFU2NERlY29kZXIiLCJpc0Jsb2NraGFzaCIsInB1dGF0aXZlQmxvY2toYXNoIiwiYXNzZXJ0SXNCbG9ja2hhc2giLCJlcnJvciIsImNvbnRleHQiLCJibG9ja2hhc2giLCJnZXRCbG9ja2hhc2hFbmNvZGVyIiwiYWRkcmVzc0VuY29kZXIiLCJmaXhlZFNpemUiLCJ3cml0ZSIsInZhbHVlIiwiYnl0ZXMiLCJvZmZzZXQiLCJnZXRCbG9ja2hhc2hEZWNvZGVyIiwiZ2V0QmxvY2toYXNoQ29kZWMiLCJnZXRCbG9ja2hhc2hDb21wYXJhdG9yIiwiSW50bCIsIkNvbGxhdG9yIiwiY2FzZUZpcnN0IiwiaWdub3JlUHVuY3R1YXRpb24iLCJsb2NhbGVNYXRjaGVyIiwibnVtZXJpYyIsInNlbnNpdGl2aXR5IiwidXNhZ2UiLCJjb21wYXJlIiwibWFpbm5ldCIsInB1dGF0aXZlU3RyaW5nIiwiZGV2bmV0IiwidGVzdG5ldCIsImdldENvbW1pdG1lbnRTY29yZSIsImNvbW1pdG1lbnQiLCJ1bmV4cGVjdGVkVmFsdWUiLCJjb21taXRtZW50Q29tcGFyYXRvciIsImEiLCJiIiwibWF4VTY0VmFsdWUiLCJtZW1vaXplZFU2NEVuY29kZXIiLCJtZW1vaXplZFU2NERlY29kZXIiLCJnZXRNZW1vaXplZFU2NEVuY29kZXIiLCJnZXRNZW1vaXplZFU2NERlY29kZXIiLCJpc0xhbXBvcnRzIiwicHV0YXRpdmVMYW1wb3J0cyIsImFzc2VydElzTGFtcG9ydHMiLCJsYW1wb3J0cyIsImdldERlZmF1bHRMYW1wb3J0c0VuY29kZXIiLCJnZXRMYW1wb3J0c0VuY29kZXIiLCJpbm5lckVuY29kZXIiLCJnZXREZWZhdWx0TGFtcG9ydHNEZWNvZGVyIiwiZ2V0TGFtcG9ydHNEZWNvZGVyIiwiaW5uZXJEZWNvZGVyIiwiQmlnSW50IiwiZ2V0RGVmYXVsdExhbXBvcnRzQ29kZWMiLCJnZXRMYW1wb3J0c0NvZGVjIiwiaW5uZXJDb2RlYyIsImlzU3RyaW5naWZpZWRCaWdJbnQiLCJwdXRhdGl2ZUJpZ0ludCIsImFzc2VydElzU3RyaW5naWZpZWRCaWdJbnQiLCJzdHJpbmdpZmllZEJpZ0ludCIsImlzU3RyaW5naWZpZWROdW1iZXIiLCJwdXRhdGl2ZU51bWJlciIsIk51bWJlciIsImlzTmFOIiwiYXNzZXJ0SXNTdHJpbmdpZmllZE51bWJlciIsInN0cmluZ2lmaWVkTnVtYmVyIiwibWF4STY0VmFsdWUiLCJtaW5JNjRWYWx1ZSIsImlzVW5peFRpbWVzdGFtcCIsInB1dGF0aXZlVGltZXN0YW1wIiwiYXNzZXJ0SXNVbml4VGltZXN0YW1wIiwidW5peFRpbWVzdGFtcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/rpc-types/dist/index.node.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/rpc/dist/index.node.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@solana/rpc/dist/index.node.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_RPC_CONFIG: () => (/* binding */ DEFAULT_RPC_CONFIG),\n/* harmony export */   createDefaultRpcTransport: () => (/* binding */ createDefaultRpcTransport),\n/* harmony export */   createJsonRpcApi: () => (/* reexport safe */ _solana_rpc_spec__WEBPACK_IMPORTED_MODULE_1__.createJsonRpcApi),\n/* harmony export */   createRpc: () => (/* reexport safe */ _solana_rpc_spec__WEBPACK_IMPORTED_MODULE_1__.createRpc),\n/* harmony export */   createSolanaRpc: () => (/* binding */ createSolanaRpc),\n/* harmony export */   createSolanaRpcApi: () => (/* reexport safe */ _solana_rpc_api__WEBPACK_IMPORTED_MODULE_0__.createSolanaRpcApi),\n/* harmony export */   createSolanaRpcFromTransport: () => (/* binding */ createSolanaRpcFromTransport),\n/* harmony export */   isJsonRpcPayload: () => (/* reexport safe */ _solana_rpc_spec__WEBPACK_IMPORTED_MODULE_1__.isJsonRpcPayload)\n/* harmony export */ });\n/* harmony import */ var _solana_rpc_api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/rpc-api */ \"(ssr)/./node_modules/@solana/rpc-api/dist/index.node.mjs\");\n/* harmony import */ var _solana_rpc_spec__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana/rpc-spec */ \"(ssr)/./node_modules/@solana/rpc-spec/dist/index.node.mjs\");\n/* harmony import */ var _solana_errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @solana/errors */ \"(ssr)/./node_modules/@solana/errors/dist/index.node.mjs\");\n/* harmony import */ var _solana_functional__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @solana/functional */ \"(ssr)/./node_modules/@solana/functional/dist/index.node.mjs\");\n/* harmony import */ var _solana_rpc_transport_http__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @solana/rpc-transport-http */ \"(ssr)/./node_modules/@solana/rpc-transport-http/dist/index.node.mjs\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var _solana_fast_stable_stringify__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @solana/fast-stable-stringify */ \"(ssr)/./node_modules/@solana/fast-stable-stringify/dist/index.node.mjs\");\n\n\n\n\n\n\n\n\n\n// src/index.ts\nfunction createSolanaJsonRpcIntegerOverflowError(methodName, keyPath, value) {\n    let argumentLabel = \"\";\n    if (typeof keyPath[0] === \"number\") {\n        const argPosition = keyPath[0] + 1;\n        const lastDigit = argPosition % 10;\n        const lastTwoDigits = argPosition % 100;\n        if (lastDigit == 1 && lastTwoDigits != 11) {\n            argumentLabel = argPosition + \"st\";\n        } else if (lastDigit == 2 && lastTwoDigits != 12) {\n            argumentLabel = argPosition + \"nd\";\n        } else if (lastDigit == 3 && lastTwoDigits != 13) {\n            argumentLabel = argPosition + \"rd\";\n        } else {\n            argumentLabel = argPosition + \"th\";\n        }\n    } else {\n        argumentLabel = `\\`${keyPath[0].toString()}\\``;\n    }\n    const path = keyPath.length > 1 ? keyPath.slice(1).map((pathPart)=>typeof pathPart === \"number\" ? `[${pathPart}]` : pathPart).join(\".\") : void 0;\n    const error = new _solana_errors__WEBPACK_IMPORTED_MODULE_3__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_3__.SOLANA_ERROR__RPC__INTEGER_OVERFLOW, {\n        argumentLabel,\n        keyPath,\n        methodName,\n        optionalPathLabel: path ? ` at path \\`${path}\\`` : \"\",\n        value,\n        ...path !== void 0 ? {\n            path\n        } : void 0\n    });\n    (0,_solana_errors__WEBPACK_IMPORTED_MODULE_3__.safeCaptureStackTrace)(error, createSolanaJsonRpcIntegerOverflowError);\n    return error;\n}\n// src/rpc-default-config.ts\nvar DEFAULT_RPC_CONFIG = {\n    defaultCommitment: \"confirmed\",\n    onIntegerOverflow (request, keyPath, value) {\n        throw createSolanaJsonRpcIntegerOverflowError(request.methodName, keyPath, value);\n    }\n};\nvar e = class extends globalThis.AbortController {\n    constructor(...t){\n        super(...t), (0,events__WEBPACK_IMPORTED_MODULE_2__.setMaxListeners)(Number.MAX_SAFE_INTEGER, this.signal);\n    }\n};\n// src/rpc-request-coalescer.ts\nvar EXPLICIT_ABORT_TOKEN;\nfunction createExplicitAbortToken() {\n    return  true ? {\n        EXPLICIT_ABORT_TOKEN: \"This object is thrown from the request that underlies a series of coalesced requests when the last request in that series aborts\"\n    } : 0;\n}\nfunction getRpcTransportWithRequestCoalescing(transport, getDeduplicationKey) {\n    let coalescedRequestsByDeduplicationKey;\n    return async function makeCoalescedHttpRequest(request) {\n        const { payload, signal } = request;\n        const deduplicationKey = getDeduplicationKey(payload);\n        if (deduplicationKey === void 0) {\n            return await transport(request);\n        }\n        if (!coalescedRequestsByDeduplicationKey) {\n            queueMicrotask(()=>{\n                coalescedRequestsByDeduplicationKey = void 0;\n            });\n            coalescedRequestsByDeduplicationKey = {};\n        }\n        if (coalescedRequestsByDeduplicationKey[deduplicationKey] == null) {\n            const abortController = new e();\n            const responsePromise = (async ()=>{\n                try {\n                    return await transport({\n                        ...request,\n                        signal: abortController.signal\n                    });\n                } catch (e2) {\n                    if (e2 === (EXPLICIT_ABORT_TOKEN ||= createExplicitAbortToken())) {\n                        return;\n                    }\n                    throw e2;\n                }\n            })();\n            coalescedRequestsByDeduplicationKey[deduplicationKey] = {\n                abortController,\n                numConsumers: 0,\n                responsePromise\n            };\n        }\n        const coalescedRequest = coalescedRequestsByDeduplicationKey[deduplicationKey];\n        coalescedRequest.numConsumers++;\n        if (signal) {\n            const responsePromise = coalescedRequest.responsePromise;\n            return await new Promise((resolve, reject)=>{\n                const handleAbort = (e2)=>{\n                    signal.removeEventListener(\"abort\", handleAbort);\n                    coalescedRequest.numConsumers -= 1;\n                    queueMicrotask(()=>{\n                        if (coalescedRequest.numConsumers === 0) {\n                            const abortController = coalescedRequest.abortController;\n                            abortController.abort(EXPLICIT_ABORT_TOKEN ||= createExplicitAbortToken());\n                        }\n                    });\n                    reject(e2.target.reason);\n                };\n                signal.addEventListener(\"abort\", handleAbort);\n                responsePromise.then(resolve).catch(reject).finally(()=>{\n                    signal.removeEventListener(\"abort\", handleAbort);\n                });\n            });\n        } else {\n            return await coalescedRequest.responsePromise;\n        }\n    };\n}\nfunction getSolanaRpcPayloadDeduplicationKey(payload) {\n    return (0,_solana_rpc_spec__WEBPACK_IMPORTED_MODULE_1__.isJsonRpcPayload)(payload) ? (0,_solana_fast_stable_stringify__WEBPACK_IMPORTED_MODULE_4__[\"default\"])([\n        payload.method,\n        payload.params\n    ]) : void 0;\n}\n// src/rpc-transport.ts\nfunction normalizeHeaders(headers) {\n    const out = {};\n    for(const headerName in headers){\n        out[headerName.toLowerCase()] = headers[headerName];\n    }\n    return out;\n}\nfunction createDefaultRpcTransport(config) {\n    return (0,_solana_functional__WEBPACK_IMPORTED_MODULE_5__.pipe)((0,_solana_rpc_transport_http__WEBPACK_IMPORTED_MODULE_6__.createHttpTransportForSolanaRpc)({\n        ...config,\n        headers: {\n            ...{\n                // Keep these headers lowercase so they will be overridden by any user-supplied headers below.\n                \"accept-encoding\": // Natively supported by Node LTS v20.18.0 and above.\n                \"br,gzip,deflate\"\n            },\n            ...config.headers ? normalizeHeaders(config.headers) : void 0,\n            ...{\n                // Keep these headers lowercase so they will override any user-supplied headers above.\n                \"solana-client\": `js/${\"5.5.1\"}`\n            }\n        }\n    }), (transport)=>getRpcTransportWithRequestCoalescing(transport, getSolanaRpcPayloadDeduplicationKey));\n}\n// src/rpc.ts\nfunction createSolanaRpc(clusterUrl, config) {\n    return createSolanaRpcFromTransport(createDefaultRpcTransport({\n        url: clusterUrl,\n        ...config\n    }));\n}\nfunction createSolanaRpcFromTransport(transport) {\n    return (0,_solana_rpc_spec__WEBPACK_IMPORTED_MODULE_1__.createRpc)({\n        api: (0,_solana_rpc_api__WEBPACK_IMPORTED_MODULE_0__.createSolanaRpcApi)(DEFAULT_RPC_CONFIG),\n        transport\n    });\n}\n //# sourceMappingURL=index.node.mjs.map\n //# sourceMappingURL=index.node.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS9ycGMvZGlzdC9pbmRleC5ub2RlLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBcUQ7QUFDckI7QUFDK0I7QUFDOUI7QUFDd0U7QUFDL0Q7QUFDbUM7QUFDcEM7QUFDdUI7QUFFaEUsZUFBZTtBQUNmLFNBQVNVLHdDQUF3Q0MsVUFBVSxFQUFFQyxPQUFPLEVBQUVDLEtBQUs7SUFDekUsSUFBSUMsZ0JBQWdCO0lBQ3BCLElBQUksT0FBT0YsT0FBTyxDQUFDLEVBQUUsS0FBSyxVQUFVO1FBQ2xDLE1BQU1HLGNBQWNILE9BQU8sQ0FBQyxFQUFFLEdBQUc7UUFDakMsTUFBTUksWUFBWUQsY0FBYztRQUNoQyxNQUFNRSxnQkFBZ0JGLGNBQWM7UUFDcEMsSUFBSUMsYUFBYSxLQUFLQyxpQkFBaUIsSUFBSTtZQUN6Q0gsZ0JBQWdCQyxjQUFjO1FBQ2hDLE9BQU8sSUFBSUMsYUFBYSxLQUFLQyxpQkFBaUIsSUFBSTtZQUNoREgsZ0JBQWdCQyxjQUFjO1FBQ2hDLE9BQU8sSUFBSUMsYUFBYSxLQUFLQyxpQkFBaUIsSUFBSTtZQUNoREgsZ0JBQWdCQyxjQUFjO1FBQ2hDLE9BQU87WUFDTEQsZ0JBQWdCQyxjQUFjO1FBQ2hDO0lBQ0YsT0FBTztRQUNMRCxnQkFBZ0IsQ0FBQyxFQUFFLEVBQUVGLE9BQU8sQ0FBQyxFQUFFLENBQUNNLFFBQVEsR0FBRyxFQUFFLENBQUM7SUFDaEQ7SUFDQSxNQUFNQyxPQUFPUCxRQUFRUSxNQUFNLEdBQUcsSUFBSVIsUUFBUVMsS0FBSyxDQUFDLEdBQUdDLEdBQUcsQ0FBQyxDQUFDQyxXQUFhLE9BQU9BLGFBQWEsV0FBVyxDQUFDLENBQUMsRUFBRUEsU0FBUyxDQUFDLENBQUMsR0FBR0EsVUFBVUMsSUFBSSxDQUFDLE9BQU8sS0FBSztJQUNqSixNQUFNQyxRQUFRLElBQUl0Qix1REFBV0EsQ0FBQ0MsK0VBQW1DQSxFQUFFO1FBQ2pFVTtRQUNBRjtRQUNBRDtRQUNBZSxtQkFB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b2R1bGVzL0Bzb2xhbmEvcnBjL2Rpc3QvaW5kZXgubm9kZS5tanM/NDkxMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVTb2xhbmFScGNBcGkgfSBmcm9tICdAc29sYW5hL3JwYy1hcGknO1xuZXhwb3J0ICogZnJvbSAnQHNvbGFuYS9ycGMtYXBpJztcbmltcG9ydCB7IGNyZWF0ZVJwYywgaXNKc29uUnBjUGF5bG9hZCB9IGZyb20gJ0Bzb2xhbmEvcnBjLXNwZWMnO1xuZXhwb3J0ICogZnJvbSAnQHNvbGFuYS9ycGMtc3BlYyc7XG5pbXBvcnQgeyBTb2xhbmFFcnJvciwgU09MQU5BX0VSUk9SX19SUENfX0lOVEVHRVJfT1ZFUkZMT1csIHNhZmVDYXB0dXJlU3RhY2tUcmFjZSB9IGZyb20gJ0Bzb2xhbmEvZXJyb3JzJztcbmltcG9ydCB7IHBpcGUgfSBmcm9tICdAc29sYW5hL2Z1bmN0aW9uYWwnO1xuaW1wb3J0IHsgY3JlYXRlSHR0cFRyYW5zcG9ydEZvclNvbGFuYVJwYyB9IGZyb20gJ0Bzb2xhbmEvcnBjLXRyYW5zcG9ydC1odHRwJztcbmltcG9ydCB7IHNldE1heExpc3RlbmVycyB9IGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgZmFzdFN0YWJsZVN0cmluZ2lmeSBmcm9tICdAc29sYW5hL2Zhc3Qtc3RhYmxlLXN0cmluZ2lmeSc7XG5cbi8vIHNyYy9pbmRleC50c1xuZnVuY3Rpb24gY3JlYXRlU29sYW5hSnNvblJwY0ludGVnZXJPdmVyZmxvd0Vycm9yKG1ldGhvZE5hbWUsIGtleVBhdGgsIHZhbHVlKSB7XG4gIGxldCBhcmd1bWVudExhYmVsID0gXCJcIjtcbiAgaWYgKHR5cGVvZiBrZXlQYXRoWzBdID09PSBcIm51bWJlclwiKSB7XG4gICAgY29uc3QgYXJnUG9zaXRpb24gPSBrZXlQYXRoWzBdICsgMTtcbiAgICBjb25zdCBsYXN0RGlnaXQgPSBhcmdQb3NpdGlvbiAlIDEwO1xuICAgIGNvbnN0IGxhc3RUd29EaWdpdHMgPSBhcmdQb3NpdGlvbiAlIDEwMDtcbiAgICBpZiAobGFzdERpZ2l0ID09IDEgJiYgbGFzdFR3b0RpZ2l0cyAhPSAxMSkge1xuICAgICAgYXJndW1lbnRMYWJlbCA9IGFyZ1Bvc2l0aW9uICsgXCJzdFwiO1xuICAgIH0gZWxzZSBpZiAobGFzdERpZ2l0ID09IDIgJiYgbGFzdFR3b0RpZ2l0cyAhPSAxMikge1xuICAgICAgYXJndW1lbnRMYWJlbCA9IGFyZ1Bvc2l0aW9uICsgXCJuZFwiO1xuICAgIH0gZWxzZSBpZiAobGFzdERpZ2l0ID09IDMgJiYgbGFzdFR3b0RpZ2l0cyAhPSAxMykge1xuICAgICAgYXJndW1lbnRMYWJlbCA9IGFyZ1Bvc2l0aW9uICsgXCJyZFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcmd1bWVudExhYmVsID0gYXJnUG9zaXRpb24gKyBcInRoXCI7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGFyZ3VtZW50TGFiZWwgPSBgXFxgJHtrZXlQYXRoWzBdLnRvU3RyaW5nKCl9XFxgYDtcbiAgfVxuICBjb25zdCBwYXRoID0ga2V5UGF0aC5sZW5ndGggPiAxID8ga2V5UGF0aC5zbGljZSgxKS5tYXAoKHBhdGhQYXJ0KSA9PiB0eXBlb2YgcGF0aFBhcnQgPT09IFwibnVtYmVyXCIgPyBgWyR7cGF0aFBhcnR9XWAgOiBwYXRoUGFydCkuam9pbihcIi5cIikgOiB2b2lkIDA7XG4gIGNvbnN0IGVycm9yID0gbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fUlBDX19JTlRFR0VSX09WRVJGTE9XLCB7XG4gICAgYXJndW1lbnRMYWJlbCxcbiAgICBrZXlQYXRoLFxuICAgIG1ldGhvZE5hbWUsXG4gICAgb3B0aW9uYWxQYXRoTGFiZWw6IHBhdGggPyBgIGF0IHBhdGggXFxgJHtwYXRofVxcYGAgOiBcIlwiLFxuICAgIHZhbHVlLFxuICAgIC4uLnBhdGggIT09IHZvaWQgMCA/IHsgcGF0aCB9IDogdm9pZCAwXG4gIH0pO1xuICBzYWZlQ2FwdHVyZVN0YWNrVHJhY2UoZXJyb3IsIGNyZWF0ZVNvbGFuYUpzb25ScGNJbnRlZ2VyT3ZlcmZsb3dFcnJvcik7XG4gIHJldHVybiBlcnJvcjtcbn1cblxuLy8gc3JjL3JwYy1kZWZhdWx0LWNvbmZpZy50c1xudmFyIERFRkFVTFRfUlBDX0NPTkZJRyA9IHtcbiAgZGVmYXVsdENvbW1pdG1lbnQ6IFwiY29uZmlybWVkXCIsXG4gIG9uSW50ZWdlck92ZXJmbG93KHJlcXVlc3QsIGtleVBhdGgsIHZhbHVlKSB7XG4gICAgdGhyb3cgY3JlYXRlU29sYW5hSnNvblJwY0ludGVnZXJPdmVyZmxvd0Vycm9yKHJlcXVlc3QubWV0aG9kTmFtZSwga2V5UGF0aCwgdmFsdWUpO1xuICB9XG59O1xudmFyIGUgPSBjbGFzcyBleHRlbmRzIGdsb2JhbFRoaXMuQWJvcnRDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IoLi4udCkge1xuICAgIHN1cGVyKC4uLnQpLCBzZXRNYXhMaXN0ZW5lcnMoTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsIHRoaXMuc2lnbmFsKTtcbiAgfVxufTtcblxuLy8gc3JjL3JwYy1yZXF1ZXN0LWNvYWxlc2Nlci50c1xudmFyIEVYUExJQ0lUX0FCT1JUX1RPS0VOO1xuZnVuY3Rpb24gY3JlYXRlRXhwbGljaXRBYm9ydFRva2VuKCkge1xuICByZXR1cm4gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8ge1xuICAgIEVYUExJQ0lUX0FCT1JUX1RPS0VOOiBcIlRoaXMgb2JqZWN0IGlzIHRocm93biBmcm9tIHRoZSByZXF1ZXN0IHRoYXQgdW5kZXJsaWVzIGEgc2VyaWVzIG9mIGNvYWxlc2NlZCByZXF1ZXN0cyB3aGVuIHRoZSBsYXN0IHJlcXVlc3QgaW4gdGhhdCBzZXJpZXMgYWJvcnRzXCJcbiAgfSA6IHt9O1xufVxuZnVuY3Rpb24gZ2V0UnBjVHJhbnNwb3J0V2l0aFJlcXVlc3RDb2FsZXNjaW5nKHRyYW5zcG9ydCwgZ2V0RGVkdXBsaWNhdGlvbktleSkge1xuICBsZXQgY29hbGVzY2VkUmVxdWVzdHNCeURlZHVwbGljYXRpb25LZXk7XG4gIHJldHVybiBhc3luYyBmdW5jdGlvbiBtYWtlQ29hbGVzY2VkSHR0cFJlcXVlc3QocmVxdWVzdCkge1xuICAgIGNvbnN0IHsgcGF5bG9hZCwgc2lnbmFsIH0gPSByZXF1ZXN0O1xuICAgIGNvbnN0IGRlZHVwbGljYXRpb25LZXkgPSBnZXREZWR1cGxpY2F0aW9uS2V5KHBheWxvYWQpO1xuICAgIGlmIChkZWR1cGxpY2F0aW9uS2V5ID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBhd2FpdCB0cmFuc3BvcnQocmVxdWVzdCk7XG4gICAgfVxuICAgIGlmICghY29hbGVzY2VkUmVxdWVzdHNCeURlZHVwbGljYXRpb25LZXkpIHtcbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgY29hbGVzY2VkUmVxdWVzdHNCeURlZHVwbGljYXRpb25LZXkgPSB2b2lkIDA7XG4gICAgICB9KTtcbiAgICAgIGNvYWxlc2NlZFJlcXVlc3RzQnlEZWR1cGxpY2F0aW9uS2V5ID0ge307XG4gICAgfVxuICAgIGlmIChjb2FsZXNjZWRSZXF1ZXN0c0J5RGVkdXBsaWNhdGlvbktleVtkZWR1cGxpY2F0aW9uS2V5XSA9PSBudWxsKSB7XG4gICAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgZSgpO1xuICAgICAgY29uc3QgcmVzcG9uc2VQcm9taXNlID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gYXdhaXQgdHJhbnNwb3J0KHtcbiAgICAgICAgICAgIC4uLnJlcXVlc3QsXG4gICAgICAgICAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgICAgICBpZiAoZTIgPT09IChFWFBMSUNJVF9BQk9SVF9UT0tFTiB8fD0gY3JlYXRlRXhwbGljaXRBYm9ydFRva2VuKCkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IGUyO1xuICAgICAgICB9XG4gICAgICB9KSgpO1xuICAgICAgY29hbGVzY2VkUmVxdWVzdHNCeURlZHVwbGljYXRpb25LZXlbZGVkdXBsaWNhdGlvbktleV0gPSB7XG4gICAgICAgIGFib3J0Q29udHJvbGxlcixcbiAgICAgICAgbnVtQ29uc3VtZXJzOiAwLFxuICAgICAgICByZXNwb25zZVByb21pc2VcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGNvYWxlc2NlZFJlcXVlc3QgPSBjb2FsZXNjZWRSZXF1ZXN0c0J5RGVkdXBsaWNhdGlvbktleVtkZWR1cGxpY2F0aW9uS2V5XTtcbiAgICBjb2FsZXNjZWRSZXF1ZXN0Lm51bUNvbnN1bWVycysrO1xuICAgIGlmIChzaWduYWwpIHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlUHJvbWlzZSA9IGNvYWxlc2NlZFJlcXVlc3QucmVzcG9uc2VQcm9taXNlO1xuICAgICAgcmV0dXJuIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgaGFuZGxlQWJvcnQgPSAoZTIpID0+IHtcbiAgICAgICAgICBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGhhbmRsZUFib3J0KTtcbiAgICAgICAgICBjb2FsZXNjZWRSZXF1ZXN0Lm51bUNvbnN1bWVycyAtPSAxO1xuICAgICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChjb2FsZXNjZWRSZXF1ZXN0Lm51bUNvbnN1bWVycyA9PT0gMCkge1xuICAgICAgICAgICAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBjb2FsZXNjZWRSZXF1ZXN0LmFib3J0Q29udHJvbGxlcjtcbiAgICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyLmFib3J0KEVYUExJQ0lUX0FCT1JUX1RPS0VOIHx8PSBjcmVhdGVFeHBsaWNpdEFib3J0VG9rZW4oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmVqZWN0KGUyLnRhcmdldC5yZWFzb24pO1xuICAgICAgICB9O1xuICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGhhbmRsZUFib3J0KTtcbiAgICAgICAgcmVzcG9uc2VQcm9taXNlLnRoZW4ocmVzb2x2ZSkuY2F0Y2gocmVqZWN0KS5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGhhbmRsZUFib3J0KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGF3YWl0IGNvYWxlc2NlZFJlcXVlc3QucmVzcG9uc2VQcm9taXNlO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFNvbGFuYVJwY1BheWxvYWREZWR1cGxpY2F0aW9uS2V5KHBheWxvYWQpIHtcbiAgcmV0dXJuIGlzSnNvblJwY1BheWxvYWQocGF5bG9hZCkgPyBmYXN0U3RhYmxlU3RyaW5naWZ5KFtwYXlsb2FkLm1ldGhvZCwgcGF5bG9hZC5wYXJhbXNdKSA6IHZvaWQgMDtcbn1cblxuLy8gc3JjL3JwYy10cmFuc3BvcnQudHNcbmZ1bmN0aW9uIG5vcm1hbGl6ZUhlYWRlcnMoaGVhZGVycykge1xuICBjb25zdCBvdXQgPSB7fTtcbiAgZm9yIChjb25zdCBoZWFkZXJOYW1lIGluIGhlYWRlcnMpIHtcbiAgICBvdXRbaGVhZGVyTmFtZS50b0xvd2VyQ2FzZSgpXSA9IGhlYWRlcnNbaGVhZGVyTmFtZV07XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRScGNUcmFuc3BvcnQoY29uZmlnKSB7XG4gIHJldHVybiBwaXBlKFxuICAgIGNyZWF0ZUh0dHBUcmFuc3BvcnRGb3JTb2xhbmFScGMoe1xuICAgICAgLi4uY29uZmlnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAuLi57XG4gICAgICAgICAgLy8gS2VlcCB0aGVzZSBoZWFkZXJzIGxvd2VyY2FzZSBzbyB0aGV5IHdpbGwgYmUgb3ZlcnJpZGRlbiBieSBhbnkgdXNlci1zdXBwbGllZCBoZWFkZXJzIGJlbG93LlxuICAgICAgICAgIFwiYWNjZXB0LWVuY29kaW5nXCI6IChcbiAgICAgICAgICAgIC8vIE5hdGl2ZWx5IHN1cHBvcnRlZCBieSBOb2RlIExUUyB2MjAuMTguMCBhbmQgYWJvdmUuXG4gICAgICAgICAgICBcImJyLGd6aXAsZGVmbGF0ZVwiXG4gICAgICAgICAgKVxuICAgICAgICAgIC8vIEJyb3RsaSwgZ3ppcCwgYW5kIERlZmxhdGUsIGluIHRoYXQgb3JkZXIuXG4gICAgICAgIH0sXG4gICAgICAgIC4uLmNvbmZpZy5oZWFkZXJzID8gbm9ybWFsaXplSGVhZGVycyhjb25maWcuaGVhZGVycykgOiB2b2lkIDAsXG4gICAgICAgIC4uLntcbiAgICAgICAgICAvLyBLZWVwIHRoZXNlIGhlYWRlcnMgbG93ZXJjYXNlIHNvIHRoZXkgd2lsbCBvdmVycmlkZSBhbnkgdXNlci1zdXBwbGllZCBoZWFkZXJzIGFib3ZlLlxuICAgICAgICAgIFwic29sYW5hLWNsaWVudFwiOiBganMvJHtcIjUuNS4xXCJ9YCBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pLFxuICAgICh0cmFuc3BvcnQpID0+IGdldFJwY1RyYW5zcG9ydFdpdGhSZXF1ZXN0Q29hbGVzY2luZyh0cmFuc3BvcnQsIGdldFNvbGFuYVJwY1BheWxvYWREZWR1cGxpY2F0aW9uS2V5KVxuICApO1xufVxuXG4vLyBzcmMvcnBjLnRzXG5mdW5jdGlvbiBjcmVhdGVTb2xhbmFScGMoY2x1c3RlclVybCwgY29uZmlnKSB7XG4gIHJldHVybiBjcmVhdGVTb2xhbmFScGNGcm9tVHJhbnNwb3J0KGNyZWF0ZURlZmF1bHRScGNUcmFuc3BvcnQoeyB1cmw6IGNsdXN0ZXJVcmwsIC4uLmNvbmZpZyB9KSk7XG59XG5mdW5jdGlvbiBjcmVhdGVTb2xhbmFScGNGcm9tVHJhbnNwb3J0KHRyYW5zcG9ydCkge1xuICByZXR1cm4gY3JlYXRlUnBjKHtcbiAgICBhcGk6IGNyZWF0ZVNvbGFuYVJwY0FwaShERUZBVUxUX1JQQ19DT05GSUcpLFxuICAgIHRyYW5zcG9ydFxuICB9KTtcbn1cblxuZXhwb3J0IHsgREVGQVVMVF9SUENfQ09ORklHLCBjcmVhdGVEZWZhdWx0UnBjVHJhbnNwb3J0LCBjcmVhdGVTb2xhbmFScGMsIGNyZWF0ZVNvbGFuYVJwY0Zyb21UcmFuc3BvcnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm5vZGUubWpzLm1hcFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubm9kZS5tanMubWFwIl0sIm5hbWVzIjpbImNyZWF0ZVNvbGFuYVJwY0FwaSIsImNyZWF0ZVJwYyIsImlzSnNvblJwY1BheWxvYWQiLCJTb2xhbmFFcnJvciIsIlNPTEFOQV9FUlJPUl9fUlBDX19JTlRFR0VSX09WRVJGTE9XIiwic2FmZUNhcHR1cmVTdGFja1RyYWNlIiwicGlwZSIsImNyZWF0ZUh0dHBUcmFuc3BvcnRGb3JTb2xhbmFScGMiLCJzZXRNYXhMaXN0ZW5lcnMiLCJmYXN0U3RhYmxlU3RyaW5naWZ5IiwiY3JlYXRlU29sYW5hSnNvblJwY0ludGVnZXJPdmVyZmxvd0Vycm9yIiwibWV0aG9kTmFtZSIsImtleVBhdGgiLCJ2YWx1ZSIsImFyZ3VtZW50TGFiZWwiLCJhcmdQb3NpdGlvbiIsImxhc3REaWdpdCIsImxhc3RUd29EaWdpdHMiLCJ0b1N0cmluZyIsInBhdGgiLCJsZW5ndGgiLCJzbGljZSIsIm1hcCIsInBhdGhQYXJ0Iiwiam9pbiIsImVycm9yIiwib3B0aW9uYWxQYXRoTGFiZWwiLCJERUZBVUxUX1JQQ19DT05GSUciLCJkZWZhdWx0Q29tbWl0bWVudCIsIm9uSW50ZWdlck92ZXJmbG93IiwicmVxdWVzdCIsImUiLCJnbG9iYWxUaGlzIiwiQWJvcnRDb250cm9sbGVyIiwiY29uc3RydWN0b3IiLCJ0IiwiTnVtYmVyIiwiTUFYX1NBRkVfSU5URUdFUiIsInNpZ25hbCIsIkVYUExJQ0lUX0FCT1JUX1RPS0VOIiwiY3JlYXRlRXhwbGljaXRBYm9ydFRva2VuIiwicHJvY2VzcyIsImdldFJwY1RyYW5zcG9ydFdpdGhSZXF1ZXN0Q29hbGVzY2luZyIsInRyYW5zcG9ydCIsImdldERlZHVwbGljYXRpb25LZXkiLCJjb2FsZXNjZWRSZXF1ZXN0c0J5RGVkdXBsaWNhdGlvbktleSIsIm1ha2VDb2FsZXNjZWRIdHRwUmVxdWVzdCIsInBheWxvYWQiLCJkZWR1cGxpY2F0aW9uS2V5IiwicXVldWVNaWNyb3Rhc2siLCJhYm9ydENvbnRyb2xsZXIiLCJyZXNwb25zZVByb21pc2UiLCJlMiIsIm51bUNvbnN1bWVycyIsImNvYWxlc2NlZFJlcXVlc3QiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImhhbmRsZUFib3J0IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImFib3J0IiwidGFyZ2V0IiwicmVhc29uIiwiYWRkRXZlbnRMaXN0ZW5lciIsInRoZW4iLCJjYXRjaCIsImZpbmFsbHkiLCJnZXRTb2xhbmFScGNQYXlsb2FkRGVkdXBsaWNhdGlvbktleSIsIm1ldGhvZCIsInBhcmFtcyIsIm5vcm1hbGl6ZUhlYWRlcnMiLCJoZWFkZXJzIiwib3V0IiwiaGVhZGVyTmFtZSIsInRvTG93ZXJDYXNlIiwiY3JlYXRlRGVmYXVsdFJwY1RyYW5zcG9ydCIsImNvbmZpZyIsImNyZWF0ZVNvbGFuYVJwYyIsImNsdXN0ZXJVcmwiLCJjcmVhdGVTb2xhbmFScGNGcm9tVHJhbnNwb3J0IiwidXJsIiwiYXBpIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/rpc/dist/index.node.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/signers/dist/index.node.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@solana/signers/dist/index.node.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addSignersToInstruction: () => (/* binding */ addSignersToInstruction),\n/* harmony export */   addSignersToTransactionMessage: () => (/* binding */ addSignersToTransactionMessage),\n/* harmony export */   assertIsKeyPairSigner: () => (/* binding */ assertIsKeyPairSigner),\n/* harmony export */   assertIsMessageModifyingSigner: () => (/* binding */ assertIsMessageModifyingSigner),\n/* harmony export */   assertIsMessagePartialSigner: () => (/* binding */ assertIsMessagePartialSigner),\n/* harmony export */   assertIsMessageSigner: () => (/* binding */ assertIsMessageSigner),\n/* harmony export */   assertIsTransactionMessageWithSingleSendingSigner: () => (/* binding */ assertIsTransactionMessageWithSingleSendingSigner),\n/* harmony export */   assertIsTransactionModifyingSigner: () => (/* binding */ assertIsTransactionModifyingSigner),\n/* harmony export */   assertIsTransactionPartialSigner: () => (/* binding */ assertIsTransactionPartialSigner),\n/* harmony export */   assertIsTransactionSendingSigner: () => (/* binding */ assertIsTransactionSendingSigner),\n/* harmony export */   assertIsTransactionSigner: () => (/* binding */ assertIsTransactionSigner),\n/* harmony export */   createKeyPairSignerFromBytes: () => (/* binding */ createKeyPairSignerFromBytes),\n/* harmony export */   createKeyPairSignerFromPrivateKeyBytes: () => (/* binding */ createKeyPairSignerFromPrivateKeyBytes),\n/* harmony export */   createNoopSigner: () => (/* binding */ createNoopSigner),\n/* harmony export */   createSignableMessage: () => (/* binding */ createSignableMessage),\n/* harmony export */   createSignerFromKeyPair: () => (/* binding */ createSignerFromKeyPair),\n/* harmony export */   generateKeyPairSigner: () => (/* binding */ generateKeyPairSigner),\n/* harmony export */   getSignersFromInstruction: () => (/* binding */ getSignersFromInstruction),\n/* harmony export */   getSignersFromOffchainMessage: () => (/* binding */ getSignersFromOffchainMessage),\n/* harmony export */   getSignersFromTransactionMessage: () => (/* binding */ getSignersFromTransactionMessage),\n/* harmony export */   isKeyPairSigner: () => (/* binding */ isKeyPairSigner),\n/* harmony export */   isMessageModifyingSigner: () => (/* binding */ isMessageModifyingSigner),\n/* harmony export */   isMessagePartialSigner: () => (/* binding */ isMessagePartialSigner),\n/* harmony export */   isMessageSigner: () => (/* binding */ isMessageSigner),\n/* harmony export */   isTransactionMessageWithSingleSendingSigner: () => (/* binding */ isTransactionMessageWithSingleSendingSigner),\n/* harmony export */   isTransactionModifyingSigner: () => (/* binding */ isTransactionModifyingSigner),\n/* harmony export */   isTransactionPartialSigner: () => (/* binding */ isTransactionPartialSigner),\n/* harmony export */   isTransactionSendingSigner: () => (/* binding */ isTransactionSendingSigner),\n/* harmony export */   isTransactionSigner: () => (/* binding */ isTransactionSigner),\n/* harmony export */   partiallySignOffchainMessageWithSigners: () => (/* binding */ partiallySignOffchainMessageWithSigners),\n/* harmony export */   partiallySignTransactionMessageWithSigners: () => (/* binding */ partiallySignTransactionMessageWithSigners),\n/* harmony export */   setTransactionMessageFeePayerSigner: () => (/* binding */ setTransactionMessageFeePayerSigner),\n/* harmony export */   signAndSendTransactionMessageWithSigners: () => (/* binding */ signAndSendTransactionMessageWithSigners),\n/* harmony export */   signOffchainMessageWithSigners: () => (/* binding */ signOffchainMessageWithSigners),\n/* harmony export */   signTransactionMessageWithSigners: () => (/* binding */ signTransactionMessageWithSigners)\n/* harmony export */ });\n/* harmony import */ var _solana_errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/errors */ \"(ssr)/./node_modules/@solana/errors/dist/index.node.mjs\");\n/* harmony import */ var _solana_instructions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana/instructions */ \"(ssr)/./node_modules/@solana/instructions/dist/index.node.mjs\");\n/* harmony import */ var _solana_addresses__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @solana/addresses */ \"(ssr)/./node_modules/@solana/addresses/dist/index.node.mjs\");\n/* harmony import */ var _solana_keys__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @solana/keys */ \"(ssr)/./node_modules/@solana/keys/dist/index.node.mjs\");\n/* harmony import */ var _solana_transactions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @solana/transactions */ \"(ssr)/./node_modules/@solana/transactions/dist/index.node.mjs\");\n/* harmony import */ var _solana_offchain_messages__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @solana/offchain-messages */ \"(ssr)/./node_modules/@solana/offchain-messages/dist/index.node.mjs\");\n\n\n\n\n\n\n// src/deduplicate-signers.ts\nfunction deduplicateSigners(signers) {\n    const deduplicated = {};\n    signers.forEach((signer)=>{\n        if (!deduplicated[signer.address]) {\n            deduplicated[signer.address] = signer;\n        } else if (deduplicated[signer.address] !== signer) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS, {\n                address: signer.address\n            });\n        }\n    });\n    return Object.values(deduplicated);\n}\nfunction isTransactionModifyingSigner(value) {\n    return \"modifyAndSignTransactions\" in value && typeof value.modifyAndSignTransactions === \"function\";\n}\nfunction assertIsTransactionModifyingSigner(value) {\n    if (!isTransactionModifyingSigner(value)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER, {\n            address: value.address\n        });\n    }\n}\nfunction isTransactionPartialSigner(value) {\n    return \"signTransactions\" in value && typeof value.signTransactions === \"function\";\n}\nfunction assertIsTransactionPartialSigner(value) {\n    if (!isTransactionPartialSigner(value)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER, {\n            address: value.address\n        });\n    }\n}\nfunction isTransactionSendingSigner(value) {\n    return \"signAndSendTransactions\" in value && typeof value.signAndSendTransactions === \"function\";\n}\nfunction assertIsTransactionSendingSigner(value) {\n    if (!isTransactionSendingSigner(value)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER, {\n            address: value.address\n        });\n    }\n}\n// src/transaction-signer.ts\nfunction isTransactionSigner(value) {\n    return isTransactionPartialSigner(value) || isTransactionModifyingSigner(value) || isTransactionSendingSigner(value);\n}\nfunction assertIsTransactionSigner(value) {\n    if (!isTransactionSigner(value)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER, {\n            address: value.address\n        });\n    }\n}\n// src/account-signer-meta.ts\nfunction getSignersFromInstruction(instruction) {\n    return deduplicateSigners((instruction.accounts ?? []).flatMap((account)=>\"signer\" in account ? account.signer : []));\n}\nfunction getSignersFromTransactionMessage(transaction) {\n    return deduplicateSigners([\n        ...transaction.feePayer && isTransactionSigner(transaction.feePayer) ? [\n            transaction.feePayer\n        ] : [],\n        ...transaction.instructions.flatMap(getSignersFromInstruction)\n    ]);\n}\nfunction addSignersToInstruction(signers, instruction) {\n    if (!instruction.accounts || instruction.accounts.length === 0) {\n        return instruction;\n    }\n    const signerByAddress = new Map(deduplicateSigners(signers).map((signer)=>[\n            signer.address,\n            signer\n        ]));\n    return Object.freeze({\n        ...instruction,\n        accounts: instruction.accounts.map((account)=>{\n            const signer = signerByAddress.get(account.address);\n            if (!(0,_solana_instructions__WEBPACK_IMPORTED_MODULE_1__.isSignerRole)(account.role) || \"signer\" in account || !signer) {\n                return account;\n            }\n            return Object.freeze({\n                ...account,\n                signer\n            });\n        })\n    });\n}\nfunction addSignersToTransactionMessage(signers, transactionMessage) {\n    const feePayerSigner = hasAddressOnlyFeePayer(transactionMessage) ? signers.find((signer)=>signer.address === transactionMessage.feePayer.address) : void 0;\n    if (!feePayerSigner && transactionMessage.instructions.length === 0) {\n        return transactionMessage;\n    }\n    return Object.freeze({\n        ...transactionMessage,\n        ...feePayerSigner ? {\n            feePayer: feePayerSigner\n        } : null,\n        instructions: transactionMessage.instructions.map((instruction)=>addSignersToInstruction(signers, instruction))\n    });\n}\nfunction hasAddressOnlyFeePayer(message) {\n    return !!message && \"feePayer\" in message && !!message.feePayer && typeof message.feePayer.address === \"string\" && !isTransactionSigner(message.feePayer);\n}\n// src/fee-payer-signer.ts\nfunction setTransactionMessageFeePayerSigner(feePayer, transactionMessage) {\n    Object.freeze(feePayer);\n    const out = {\n        ...transactionMessage,\n        feePayer\n    };\n    Object.freeze(out);\n    return out;\n}\nfunction isMessagePartialSigner(value) {\n    return \"signMessages\" in value && typeof value.signMessages === \"function\";\n}\nfunction assertIsMessagePartialSigner(value) {\n    if (!isMessagePartialSigner(value)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER, {\n            address: value.address\n        });\n    }\n}\n// src/keypair-signer.ts\nfunction isKeyPairSigner(value) {\n    return \"keyPair\" in value && typeof value.keyPair === \"object\" && isMessagePartialSigner(value) && isTransactionPartialSigner(value);\n}\nfunction assertIsKeyPairSigner(value) {\n    if (!isKeyPairSigner(value)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER, {\n            address: value.address\n        });\n    }\n}\nasync function createSignerFromKeyPair(keyPair) {\n    const address = await (0,_solana_addresses__WEBPACK_IMPORTED_MODULE_2__.getAddressFromPublicKey)(keyPair.publicKey);\n    const out = {\n        address,\n        keyPair,\n        signMessages: (messages)=>Promise.all(messages.map(async (message)=>Object.freeze({\n                    [address]: await (0,_solana_keys__WEBPACK_IMPORTED_MODULE_3__.signBytes)(keyPair.privateKey, message.content)\n                }))),\n        signTransactions: (transactions)=>Promise.all(transactions.map(async (transaction)=>{\n                const signedTransaction = await (0,_solana_transactions__WEBPACK_IMPORTED_MODULE_4__.partiallySignTransaction)([\n                    keyPair\n                ], transaction);\n                return Object.freeze({\n                    [address]: signedTransaction.signatures[address]\n                });\n            }))\n    };\n    return Object.freeze(out);\n}\nasync function generateKeyPairSigner() {\n    return await createSignerFromKeyPair(await (0,_solana_keys__WEBPACK_IMPORTED_MODULE_3__.generateKeyPair)());\n}\nasync function createKeyPairSignerFromBytes(bytes, extractable) {\n    return await createSignerFromKeyPair(await (0,_solana_keys__WEBPACK_IMPORTED_MODULE_3__.createKeyPairFromBytes)(bytes, extractable));\n}\nasync function createKeyPairSignerFromPrivateKeyBytes(bytes, extractable) {\n    return await createSignerFromKeyPair(await (0,_solana_keys__WEBPACK_IMPORTED_MODULE_3__.createKeyPairFromPrivateKeyBytes)(bytes, extractable));\n}\nfunction isMessageModifyingSigner(value) {\n    return (0,_solana_addresses__WEBPACK_IMPORTED_MODULE_2__.isAddress)(value.address) && \"modifyAndSignMessages\" in value && typeof value.modifyAndSignMessages === \"function\";\n}\nfunction assertIsMessageModifyingSigner(value) {\n    if (!isMessageModifyingSigner(value)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER, {\n            address: value.address\n        });\n    }\n}\nfunction isMessageSigner(value) {\n    return isMessagePartialSigner(value) || isMessageModifyingSigner(value);\n}\nfunction assertIsMessageSigner(value) {\n    if (!isMessageSigner(value)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER, {\n            address: value.address\n        });\n    }\n}\n// src/noop-signer.ts\nfunction createNoopSigner(address) {\n    const out = {\n        address,\n        signMessages: (messages)=>Promise.resolve(messages.map(()=>Object.freeze({}))),\n        signTransactions: (transactions)=>Promise.resolve(transactions.map(()=>Object.freeze({})))\n    };\n    return Object.freeze(out);\n}\n// src/offchain-message-signer.ts\nfunction getSignersFromOffchainMessage({ requiredSignatories }) {\n    const messageSigners = requiredSignatories.filter(isMessageSigner);\n    return deduplicateSigners(messageSigners);\n}\nasync function partiallySignOffchainMessageWithSigners(offchainMessage, config) {\n    const { partialSigners, modifyingSigners } = categorizeMessageSigners(getSignersFromOffchainMessage(offchainMessage));\n    return await signModifyingAndPartialMessageSigners(offchainMessage, modifyingSigners, partialSigners, config);\n}\nasync function signOffchainMessageWithSigners(offchainMessage, config) {\n    const signedOffchainMessageEnvelope = await partiallySignOffchainMessageWithSigners(offchainMessage, config);\n    (0,_solana_offchain_messages__WEBPACK_IMPORTED_MODULE_5__.assertIsFullySignedOffchainMessageEnvelope)(signedOffchainMessageEnvelope);\n    return signedOffchainMessageEnvelope;\n}\nfunction categorizeMessageSigners(signers) {\n    const modifyingSigners = identifyMessageModifyingSigners(signers);\n    const partialSigners = signers.filter(isMessagePartialSigner).filter((signer)=>!modifyingSigners.includes(signer));\n    return Object.freeze({\n        modifyingSigners,\n        partialSigners\n    });\n}\nfunction identifyMessageModifyingSigners(signers) {\n    const modifyingSigners = signers.filter(isMessageModifyingSigner);\n    if (modifyingSigners.length === 0) return [];\n    const nonPartialSigners = modifyingSigners.filter((signer)=>!isMessagePartialSigner(signer));\n    if (nonPartialSigners.length > 0) return nonPartialSigners;\n    return [\n        modifyingSigners[0]\n    ];\n}\nasync function signModifyingAndPartialMessageSigners(offchainMessage, modifyingSigners = [], partialSigners = [], config) {\n    const offchainMessageEnvelope = (0,_solana_offchain_messages__WEBPACK_IMPORTED_MODULE_5__.compileOffchainMessageEnvelope)(offchainMessage);\n    const modifiedOffchainMessage = await modifyingSigners.reduce(async (offchainMessageEnvelope2, modifyingSigner)=>{\n        config?.abortSignal?.throwIfAborted();\n        const [message] = await modifyingSigner.modifyAndSignMessages([\n            await offchainMessageEnvelope2\n        ], config);\n        return Object.freeze(message);\n    }, Promise.resolve(offchainMessageEnvelope));\n    config?.abortSignal?.throwIfAborted();\n    const signatureDictionaries = await Promise.all(partialSigners.map(async (partialSigner)=>{\n        const [signatures] = await partialSigner.signMessages([\n            modifiedOffchainMessage\n        ], config);\n        return signatures;\n    }));\n    return Object.freeze({\n        ...modifiedOffchainMessage,\n        signatures: Object.freeze(signatureDictionaries.reduce((signatures, signatureDictionary)=>{\n            return {\n                ...signatures,\n                ...signatureDictionary\n            };\n        }, modifiedOffchainMessage.signatures ?? {}))\n    });\n}\nfunction isTransactionMessageWithSingleSendingSigner(transaction) {\n    try {\n        assertIsTransactionMessageWithSingleSendingSigner(transaction);\n        return true;\n    } catch  {\n        return false;\n    }\n}\nfunction assertIsTransactionMessageWithSingleSendingSigner(transaction) {\n    const signers = getSignersFromTransactionMessage(transaction);\n    const sendingSigners = signers.filter(isTransactionSendingSigner);\n    if (sendingSigners.length === 0) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING);\n    }\n    const sendingOnlySigners = sendingSigners.filter((signer)=>!isTransactionPartialSigner(signer) && !isTransactionModifyingSigner(signer));\n    if (sendingOnlySigners.length > 1) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS);\n    }\n}\n// src/sign-transaction.ts\nasync function partiallySignTransactionMessageWithSigners(transactionMessage, config) {\n    const { partialSigners, modifyingSigners } = categorizeTransactionSigners(deduplicateSigners(getSignersFromTransactionMessage(transactionMessage).filter(isTransactionSigner)), {\n        identifySendingSigner: false\n    });\n    return await signModifyingAndPartialTransactionSigners(transactionMessage, modifyingSigners, partialSigners, config);\n}\nasync function signTransactionMessageWithSigners(transactionMessage, config) {\n    const signedTransaction = await partiallySignTransactionMessageWithSigners(transactionMessage, config);\n    (0,_solana_transactions__WEBPACK_IMPORTED_MODULE_4__.assertIsFullySignedTransaction)(signedTransaction);\n    return signedTransaction;\n}\nasync function signAndSendTransactionMessageWithSigners(transaction, config) {\n    assertIsTransactionMessageWithSingleSendingSigner(transaction);\n    const abortSignal = config?.abortSignal;\n    const { partialSigners, modifyingSigners, sendingSigner } = categorizeTransactionSigners(deduplicateSigners(getSignersFromTransactionMessage(transaction).filter(isTransactionSigner)));\n    abortSignal?.throwIfAborted();\n    const signedTransaction = await signModifyingAndPartialTransactionSigners(transaction, modifyingSigners, partialSigners, config);\n    if (!sendingSigner) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING);\n    }\n    abortSignal?.throwIfAborted();\n    const [signature] = await sendingSigner.signAndSendTransactions([\n        signedTransaction\n    ], config);\n    abortSignal?.throwIfAborted();\n    return signature;\n}\nfunction categorizeTransactionSigners(signers, config = {}) {\n    const identifySendingSigner = config.identifySendingSigner ?? true;\n    const sendingSigner = identifySendingSigner ? identifyTransactionSendingSigner(signers) : null;\n    const otherSigners = signers.filter((signer)=>signer !== sendingSigner && (isTransactionModifyingSigner(signer) || isTransactionPartialSigner(signer)));\n    const modifyingSigners = identifyTransactionModifyingSigners(otherSigners);\n    const partialSigners = otherSigners.filter(isTransactionPartialSigner).filter((signer)=>!modifyingSigners.includes(signer));\n    return Object.freeze({\n        modifyingSigners,\n        partialSigners,\n        sendingSigner\n    });\n}\nfunction identifyTransactionSendingSigner(signers) {\n    const sendingSigners = signers.filter(isTransactionSendingSigner);\n    if (sendingSigners.length === 0) return null;\n    const sendingOnlySigners = sendingSigners.filter((signer)=>!isTransactionModifyingSigner(signer) && !isTransactionPartialSigner(signer));\n    if (sendingOnlySigners.length > 0) {\n        return sendingOnlySigners[0];\n    }\n    return sendingSigners[0];\n}\nfunction identifyTransactionModifyingSigners(signers) {\n    const modifyingSigners = signers.filter(isTransactionModifyingSigner);\n    if (modifyingSigners.length === 0) return [];\n    const nonPartialSigners = modifyingSigners.filter((signer)=>!isTransactionPartialSigner(signer));\n    if (nonPartialSigners.length > 0) return nonPartialSigners;\n    return [\n        modifyingSigners[0]\n    ];\n}\nasync function signModifyingAndPartialTransactionSigners(transactionMessage, modifyingSigners = [], partialSigners = [], config) {\n    const transaction = (0,_solana_transactions__WEBPACK_IMPORTED_MODULE_4__.compileTransaction)(transactionMessage);\n    const modifiedTransaction = await modifyingSigners.reduce(async (transaction2, modifyingSigner)=>{\n        config?.abortSignal?.throwIfAborted();\n        const [tx] = await modifyingSigner.modifyAndSignTransactions([\n            await transaction2\n        ], config);\n        return Object.freeze(tx);\n    }, Promise.resolve(transaction));\n    config?.abortSignal?.throwIfAborted();\n    const signatureDictionaries = await Promise.all(partialSigners.map(async (partialSigner)=>{\n        const [signatures] = await partialSigner.signTransactions([\n            modifiedTransaction\n        ], config);\n        return signatures;\n    }));\n    return Object.freeze({\n        ...modifiedTransaction,\n        signatures: Object.freeze(signatureDictionaries.reduce((signatures, signatureDictionary)=>{\n            return {\n                ...signatures,\n                ...signatureDictionary\n            };\n        }, modifiedTransaction.signatures ?? {}))\n    });\n}\nvar o = globalThis.TextEncoder;\n// src/signable-message.ts\nfunction createSignableMessage(content, signatures = {}) {\n    return Object.freeze({\n        content: typeof content === \"string\" ? new o().encode(content) : content,\n        signatures: Object.freeze({\n            ...signatures\n        })\n    });\n}\n //# sourceMappingURL=index.node.mjs.map\n //# sourceMappingURL=index.node.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS9zaWduZXJzL2Rpc3QvaW5kZXgubm9kZS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBZ3FCO0FBQzVtQjtBQUNtQjtBQUM2QztBQUNBO0FBQ0c7QUFFdkgsNkJBQTZCO0FBQzdCLFNBQVN3QixtQkFBbUJDLE9BQU87SUFDakMsTUFBTUMsZUFBZSxDQUFDO0lBQ3RCRCxRQUFRRSxPQUFPLENBQUMsQ0FBQ0M7UUFDZixJQUFJLENBQUNGLFlBQVksQ0FBQ0UsT0FBT0MsT0FBTyxDQUFDLEVBQUU7WUFDakNILFlBQVksQ0FBQ0UsT0FBT0MsT0FBTyxDQUFDLEdBQUdEO1FBQ2pDLE9BQU8sSUFBSUYsWUFBWSxDQUFDRSxPQUFPQyxPQUFPLENBQUMsS0FBS0QsUUFBUTtZQUNsRCxNQUFNLElBQUk1Qix1REFBV0EsQ0FBQ1csc0dBQTBEQSxFQUFFO2dCQUNoRmtCLFNBQVNELE9BQU9DLE9BQU87WUFDekI7UUFDRjtJQUNGO0lBQ0EsT0FBT0MsT0FBT0MsTUFBTSxDQUFDTDtBQUN2QjtBQUNBLFNBQVNNLDZCQUE2QkMsS0FBSztJQUN6QyxPQUFPLCtCQUErQkEsU0FBUyxPQUFPQSxNQUFNQyx5QkFBeUIsS0FBSztBQUM1RjtBQUNBLFNBQVNDLG1DQUFtQ0YsS0FBSztJQUMvQyxJQUFJLENBQUNELDZCQUE2QkMsUUFBUTtRQUN4QyxNQUFNLElBQUlqQyx1REFBV0EsQ0FBQ0MsdUdBQTJEQSxFQUFFO1lBQ2pGNEIsU0FBU0ksTUFBTUosT0FBTztRQUN4QjtJQUNGO0FBQ0Y7QUFDQSxTQUFTTywyQkFBMkJILEtBQUs7SUFDdkMsT0FBTyxzQkFBc0JBLFNBQVMsT0FBT0EsTUFBTUksZ0JBQWdCLEtBQUs7QUFDMUU7QUFDQSxTQUFTQyxpQ0FBaUNMLEtBQUs7SUFDN0MsSUFBSSxDQUFDRywyQkFBMkJILFFBQVE7UUFDdEMsTUFBTSxJQUFJakMsdURBQVdBLENB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QUNxQixHQUFHLEdBQUcsTUFBTXZCLGdCQUFnQm5GLHlCQUF5QixDQUFDO1lBQUMsTUFBTXlHO1NBQWEsRUFBRXBDO1FBQ25GLE9BQU96RSxPQUFPNEIsTUFBTSxDQUFDa0Y7SUFDdkIsR0FDQTlELFFBQVFrQixPQUFPLENBQUM5QztJQUVsQnFELFFBQVFlLGFBQWFDO0lBQ3JCLE1BQU1DLHdCQUF3QixNQUFNMUMsUUFBUUMsR0FBRyxDQUM3Q3lCLGVBQWUvQyxHQUFHLENBQUMsT0FBT2dFO1FBQ3hCLE1BQU0sQ0FBQ3JDLFdBQVcsR0FBRyxNQUFNcUMsY0FBY3BGLGdCQUFnQixDQUFDO1lBQUNxRztTQUFvQixFQUFFbkM7UUFDakYsT0FBT25CO0lBQ1Q7SUFFRixPQUFPdEQsT0FBTzRCLE1BQU0sQ0FBQztRQUNuQixHQUFHZ0YsbUJBQW1CO1FBQ3RCdEQsWUFBWXRELE9BQU80QixNQUFNLENBQ3ZCOEQsc0JBQXNCTCxNQUFNLENBQUMsQ0FBQy9CLFlBQVlzQztZQUN4QyxPQUFPO2dCQUFFLEdBQUd0QyxVQUFVO2dCQUFFLEdBQUdzQyxtQkFBbUI7WUFBQztRQUNqRCxHQUFHZ0Isb0JBQW9CdEQsVUFBVSxJQUFJLENBQUM7SUFFMUM7QUFDRjtBQUNBLElBQUl5RCxJQUFJQyxXQUFXQyxXQUFXO0FBRTlCLDBCQUEwQjtBQUMxQixTQUFTQyxzQkFBc0IvRCxPQUFPLEVBQUVHLGFBQWEsQ0FBQyxDQUFDO0lBQ3JELE9BQU90RCxPQUFPNEIsTUFBTSxDQUFDO1FBQ25CdUIsU0FBUyxPQUFPQSxZQUFZLFdBQVcsSUFBSTRELElBQUlJLE1BQU0sQ0FBQ2hFLFdBQVdBO1FBQ2pFRyxZQUFZdEQsT0FBTzRCLE1BQU0sQ0FBQztZQUFFLEdBQUcwQixVQUFVO1FBQUM7SUFDNUM7QUFDRjtBQUVtakMsQ0FDbmpDLHVDQUF1QztDQUN2Qyx1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGF3LXdvcmtzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvc2lnbmVycy9kaXN0L2luZGV4Lm5vZGUubWpzP2FlNjAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU29sYW5hRXJyb3IsIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9UUkFOU0FDVElPTl9NT0RJRllJTkdfU0lHTkVSLCBTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfVFJBTlNBQ1RJT05fUEFSVElBTF9TSUdORVIsIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9UUkFOU0FDVElPTl9TRU5ESU5HX1NJR05FUiwgU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX1RSQU5TQUNUSU9OX1NJR05FUiwgU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX01FU1NBR0VfUEFSVElBTF9TSUdORVIsIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9LRVlfUEFJUl9TSUdORVIsIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9NRVNTQUdFX01PRElGWUlOR19TSUdORVIsIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9NRVNTQUdFX1NJR05FUiwgU09MQU5BX0VSUk9SX19TSUdORVJfX1RSQU5TQUNUSU9OX1NFTkRJTkdfU0lHTkVSX01JU1NJTkcsIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19UUkFOU0FDVElPTl9DQU5OT1RfSEFWRV9NVUxUSVBMRV9TRU5ESU5HX1NJR05FUlMsIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19BRERSRVNTX0NBTk5PVF9IQVZFX01VTFRJUExFX1NJR05FUlMgfSBmcm9tICdAc29sYW5hL2Vycm9ycyc7XG5pbXBvcnQgeyBpc1NpZ25lclJvbGUgfSBmcm9tICdAc29sYW5hL2luc3RydWN0aW9ucyc7XG5pbXBvcnQgeyBnZXRBZGRyZXNzRnJvbVB1YmxpY0tleSwgaXNBZGRyZXNzIH0gZnJvbSAnQHNvbGFuYS9hZGRyZXNzZXMnO1xuaW1wb3J0IHsgZ2VuZXJhdGVLZXlQYWlyLCBjcmVhdGVLZXlQYWlyRnJvbUJ5dGVzLCBjcmVhdGVLZXlQYWlyRnJvbVByaXZhdGVLZXlCeXRlcywgc2lnbkJ5dGVzIH0gZnJvbSAnQHNvbGFuYS9rZXlzJztcbmltcG9ydCB7IGFzc2VydElzRnVsbHlTaWduZWRUcmFuc2FjdGlvbiwgY29tcGlsZVRyYW5zYWN0aW9uLCBwYXJ0aWFsbHlTaWduVHJhbnNhY3Rpb24gfSBmcm9tICdAc29sYW5hL3RyYW5zYWN0aW9ucyc7XG5pbXBvcnQgeyBhc3NlcnRJc0Z1bGx5U2lnbmVkT2ZmY2hhaW5NZXNzYWdlRW52ZWxvcGUsIGNvbXBpbGVPZmZjaGFpbk1lc3NhZ2VFbnZlbG9wZSB9IGZyb20gJ0Bzb2xhbmEvb2ZmY2hhaW4tbWVzc2FnZXMnO1xuXG4vLyBzcmMvZGVkdXBsaWNhdGUtc2lnbmVycy50c1xuZnVuY3Rpb24gZGVkdXBsaWNhdGVTaWduZXJzKHNpZ25lcnMpIHtcbiAgY29uc3QgZGVkdXBsaWNhdGVkID0ge307XG4gIHNpZ25lcnMuZm9yRWFjaCgoc2lnbmVyKSA9PiB7XG4gICAgaWYgKCFkZWR1cGxpY2F0ZWRbc2lnbmVyLmFkZHJlc3NdKSB7XG4gICAgICBkZWR1cGxpY2F0ZWRbc2lnbmVyLmFkZHJlc3NdID0gc2lnbmVyO1xuICAgIH0gZWxzZSBpZiAoZGVkdXBsaWNhdGVkW3NpZ25lci5hZGRyZXNzXSAhPT0gc2lnbmVyKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19TSUdORVJfX0FERFJFU1NfQ0FOTk9UX0hBVkVfTVVMVElQTEVfU0lHTkVSUywge1xuICAgICAgICBhZGRyZXNzOiBzaWduZXIuYWRkcmVzc1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIE9iamVjdC52YWx1ZXMoZGVkdXBsaWNhdGVkKTtcbn1cbmZ1bmN0aW9uIGlzVHJhbnNhY3Rpb25Nb2RpZnlpbmdTaWduZXIodmFsdWUpIHtcbiAgcmV0dXJuIFwibW9kaWZ5QW5kU2lnblRyYW5zYWN0aW9uc1wiIGluIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5tb2RpZnlBbmRTaWduVHJhbnNhY3Rpb25zID09PSBcImZ1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiBhc3NlcnRJc1RyYW5zYWN0aW9uTW9kaWZ5aW5nU2lnbmVyKHZhbHVlKSB7XG4gIGlmICghaXNUcmFuc2FjdGlvbk1vZGlmeWluZ1NpZ25lcih2YWx1ZSkpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX1RSQU5TQUNUSU9OX01PRElGWUlOR19TSUdORVIsIHtcbiAgICAgIGFkZHJlc3M6IHZhbHVlLmFkZHJlc3NcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gaXNUcmFuc2FjdGlvblBhcnRpYWxTaWduZXIodmFsdWUpIHtcbiAgcmV0dXJuIFwic2lnblRyYW5zYWN0aW9uc1wiIGluIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5zaWduVHJhbnNhY3Rpb25zID09PSBcImZ1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiBhc3NlcnRJc1RyYW5zYWN0aW9uUGFydGlhbFNpZ25lcih2YWx1ZSkge1xuICBpZiAoIWlzVHJhbnNhY3Rpb25QYXJ0aWFsU2lnbmVyKHZhbHVlKSkge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfVFJBTlNBQ1RJT05fUEFSVElBTF9TSUdORVIsIHtcbiAgICAgIGFkZHJlc3M6IHZhbHVlLmFkZHJlc3NcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gaXNUcmFuc2FjdGlvblNlbmRpbmdTaWduZXIodmFsdWUpIHtcbiAgcmV0dXJuIFwic2lnbkFuZFNlbmRUcmFuc2FjdGlvbnNcIiBpbiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUuc2lnbkFuZFNlbmRUcmFuc2FjdGlvbnMgPT09IFwiZnVuY3Rpb25cIjtcbn1cbmZ1bmN0aW9uIGFzc2VydElzVHJhbnNhY3Rpb25TZW5kaW5nU2lnbmVyKHZhbHVlKSB7XG4gIGlmICghaXNUcmFuc2FjdGlvblNlbmRpbmdTaWduZXIodmFsdWUpKSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9UUkFOU0FDVElPTl9TRU5ESU5HX1NJR05FUiwge1xuICAgICAgYWRkcmVzczogdmFsdWUuYWRkcmVzc1xuICAgIH0pO1xuICB9XG59XG5cbi8vIHNyYy90cmFuc2FjdGlvbi1zaWduZXIudHNcbmZ1bmN0aW9uIGlzVHJhbnNhY3Rpb25TaWduZXIodmFsdWUpIHtcbiAgcmV0dXJuIGlzVHJhbnNhY3Rpb25QYXJ0aWFsU2lnbmVyKHZhbHVlKSB8fCBpc1RyYW5zYWN0aW9uTW9kaWZ5aW5nU2lnbmVyKHZhbHVlKSB8fCBpc1RyYW5zYWN0aW9uU2VuZGluZ1NpZ25lcih2YWx1ZSk7XG59XG5mdW5jdGlvbiBhc3NlcnRJc1RyYW5zYWN0aW9uU2lnbmVyKHZhbHVlKSB7XG4gIGlmICghaXNUcmFuc2FjdGlvblNpZ25lcih2YWx1ZSkpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX1RSQU5TQUNUSU9OX1NJR05FUiwge1xuICAgICAgYWRkcmVzczogdmFsdWUuYWRkcmVzc1xuICAgIH0pO1xuICB9XG59XG5cbi8vIHNyYy9hY2NvdW50LXNpZ25lci1tZXRhLnRzXG5mdW5jdGlvbiBnZXRTaWduZXJzRnJvbUluc3RydWN0aW9uKGluc3RydWN0aW9uKSB7XG4gIHJldHVybiBkZWR1cGxpY2F0ZVNpZ25lcnMoXG4gICAgKGluc3RydWN0aW9uLmFjY291bnRzID8/IFtdKS5mbGF0TWFwKChhY2NvdW50KSA9PiBcInNpZ25lclwiIGluIGFjY291bnQgPyBhY2NvdW50LnNpZ25lciA6IFtdKVxuICApO1xufVxuZnVuY3Rpb24gZ2V0U2lnbmVyc0Zyb21UcmFuc2FjdGlvbk1lc3NhZ2UodHJhbnNhY3Rpb24pIHtcbiAgcmV0dXJuIGRlZHVwbGljYXRlU2lnbmVycyhbXG4gICAgLi4udHJhbnNhY3Rpb24uZmVlUGF5ZXIgJiYgaXNUcmFuc2FjdGlvblNpZ25lcih0cmFuc2FjdGlvbi5mZWVQYXllcikgPyBbdHJhbnNhY3Rpb24uZmVlUGF5ZXJdIDogW10sXG4gICAgLi4udHJhbnNhY3Rpb24uaW5zdHJ1Y3Rpb25zLmZsYXRNYXAoZ2V0U2lnbmVyc0Zyb21JbnN0cnVjdGlvbilcbiAgXSk7XG59XG5mdW5jdGlvbiBhZGRTaWduZXJzVG9JbnN0cnVjdGlvbihzaWduZXJzLCBpbnN0cnVjdGlvbikge1xuICBpZiAoIWluc3RydWN0aW9uLmFjY291bnRzIHx8IGluc3RydWN0aW9uLmFjY291bnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBpbnN0cnVjdGlvbjtcbiAgfVxuICBjb25zdCBzaWduZXJCeUFkZHJlc3MgPSBuZXcgTWFwKGRlZHVwbGljYXRlU2lnbmVycyhzaWduZXJzKS5tYXAoKHNpZ25lcikgPT4gW3NpZ25lci5hZGRyZXNzLCBzaWduZXJdKSk7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAuLi5pbnN0cnVjdGlvbixcbiAgICBhY2NvdW50czogaW5zdHJ1Y3Rpb24uYWNjb3VudHMubWFwKChhY2NvdW50KSA9PiB7XG4gICAgICBjb25zdCBzaWduZXIgPSBzaWduZXJCeUFkZHJlc3MuZ2V0KGFjY291bnQuYWRkcmVzcyk7XG4gICAgICBpZiAoIWlzU2lnbmVyUm9sZShhY2NvdW50LnJvbGUpIHx8IFwic2lnbmVyXCIgaW4gYWNjb3VudCB8fCAhc2lnbmVyKSB7XG4gICAgICAgIHJldHVybiBhY2NvdW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyAuLi5hY2NvdW50LCBzaWduZXIgfSk7XG4gICAgfSlcbiAgfSk7XG59XG5mdW5jdGlvbiBhZGRTaWduZXJzVG9UcmFuc2FjdGlvbk1lc3NhZ2Uoc2lnbmVycywgdHJhbnNhY3Rpb25NZXNzYWdlKSB7XG4gIGNvbnN0IGZlZVBheWVyU2lnbmVyID0gaGFzQWRkcmVzc09ubHlGZWVQYXllcih0cmFuc2FjdGlvbk1lc3NhZ2UpID8gc2lnbmVycy5maW5kKChzaWduZXIpID0+IHNpZ25lci5hZGRyZXNzID09PSB0cmFuc2FjdGlvbk1lc3NhZ2UuZmVlUGF5ZXIuYWRkcmVzcykgOiB2b2lkIDA7XG4gIGlmICghZmVlUGF5ZXJTaWduZXIgJiYgdHJhbnNhY3Rpb25NZXNzYWdlLmluc3RydWN0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJhbnNhY3Rpb25NZXNzYWdlO1xuICB9XG4gIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAuLi50cmFuc2FjdGlvbk1lc3NhZ2UsXG4gICAgLi4uZmVlUGF5ZXJTaWduZXIgPyB7IGZlZVBheWVyOiBmZWVQYXllclNpZ25lciB9IDogbnVsbCxcbiAgICBpbnN0cnVjdGlvbnM6IHRyYW5zYWN0aW9uTWVzc2FnZS5pbnN0cnVjdGlvbnMubWFwKChpbnN0cnVjdGlvbikgPT4gYWRkU2lnbmVyc1RvSW5zdHJ1Y3Rpb24oc2lnbmVycywgaW5zdHJ1Y3Rpb24pKVxuICB9KTtcbn1cbmZ1bmN0aW9uIGhhc0FkZHJlc3NPbmx5RmVlUGF5ZXIobWVzc2FnZSkge1xuICByZXR1cm4gISFtZXNzYWdlICYmIFwiZmVlUGF5ZXJcIiBpbiBtZXNzYWdlICYmICEhbWVzc2FnZS5mZWVQYXllciAmJiB0eXBlb2YgbWVzc2FnZS5mZWVQYXllci5hZGRyZXNzID09PSBcInN0cmluZ1wiICYmICFpc1RyYW5zYWN0aW9uU2lnbmVyKG1lc3NhZ2UuZmVlUGF5ZXIpO1xufVxuXG4vLyBzcmMvZmVlLXBheWVyLXNpZ25lci50c1xuZnVuY3Rpb24gc2V0VHJhbnNhY3Rpb25NZXNzYWdlRmVlUGF5ZXJTaWduZXIoZmVlUGF5ZXIsIHRyYW5zYWN0aW9uTWVzc2FnZSkge1xuICBPYmplY3QuZnJlZXplKGZlZVBheWVyKTtcbiAgY29uc3Qgb3V0ID0geyAuLi50cmFuc2FjdGlvbk1lc3NhZ2UsIGZlZVBheWVyIH07XG4gIE9iamVjdC5mcmVlemUob3V0KTtcbiAgcmV0dXJuIG91dDtcbn1cbmZ1bmN0aW9uIGlzTWVzc2FnZVBhcnRpYWxTaWduZXIodmFsdWUpIHtcbiAgcmV0dXJuIFwic2lnbk1lc3NhZ2VzXCIgaW4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLnNpZ25NZXNzYWdlcyA9PT0gXCJmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24gYXNzZXJ0SXNNZXNzYWdlUGFydGlhbFNpZ25lcih2YWx1ZSkge1xuICBpZiAoIWlzTWVzc2FnZVBhcnRpYWxTaWduZXIodmFsdWUpKSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9NRVNTQUdFX1BBUlRJQUxfU0lHTkVSLCB7XG4gICAgICBhZGRyZXNzOiB2YWx1ZS5hZGRyZXNzXG4gICAgfSk7XG4gIH1cbn1cblxuLy8gc3JjL2tleXBhaXItc2lnbmVyLnRzXG5mdW5jdGlvbiBpc0tleVBhaXJTaWduZXIodmFsdWUpIHtcbiAgcmV0dXJuIFwia2V5UGFpclwiIGluIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5rZXlQYWlyID09PSBcIm9iamVjdFwiICYmIGlzTWVzc2FnZVBhcnRpYWxTaWduZXIodmFsdWUpICYmIGlzVHJhbnNhY3Rpb25QYXJ0aWFsU2lnbmVyKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGFzc2VydElzS2V5UGFpclNpZ25lcih2YWx1ZSkge1xuICBpZiAoIWlzS2V5UGFpclNpZ25lcih2YWx1ZSkpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX0tFWV9QQUlSX1NJR05FUiwge1xuICAgICAgYWRkcmVzczogdmFsdWUuYWRkcmVzc1xuICAgIH0pO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBjcmVhdGVTaWduZXJGcm9tS2V5UGFpcihrZXlQYWlyKSB7XG4gIGNvbnN0IGFkZHJlc3MgPSBhd2FpdCBnZXRBZGRyZXNzRnJvbVB1YmxpY0tleShrZXlQYWlyLnB1YmxpY0tleSk7XG4gIGNvbnN0IG91dCA9IHtcbiAgICBhZGRyZXNzLFxuICAgIGtleVBhaXIsXG4gICAgc2lnbk1lc3NhZ2VzOiAobWVzc2FnZXMpID0+IFByb21pc2UuYWxsKFxuICAgICAgbWVzc2FnZXMubWFwKFxuICAgICAgICBhc3luYyAobWVzc2FnZSkgPT4gT2JqZWN0LmZyZWV6ZSh7IFthZGRyZXNzXTogYXdhaXQgc2lnbkJ5dGVzKGtleVBhaXIucHJpdmF0ZUtleSwgbWVzc2FnZS5jb250ZW50KSB9KVxuICAgICAgKVxuICAgICksXG4gICAgc2lnblRyYW5zYWN0aW9uczogKHRyYW5zYWN0aW9ucykgPT4gUHJvbWlzZS5hbGwoXG4gICAgICB0cmFuc2FjdGlvbnMubWFwKGFzeW5jICh0cmFuc2FjdGlvbikgPT4ge1xuICAgICAgICBjb25zdCBzaWduZWRUcmFuc2FjdGlvbiA9IGF3YWl0IHBhcnRpYWxseVNpZ25UcmFuc2FjdGlvbihba2V5UGFpcl0sIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyBbYWRkcmVzc106IHNpZ25lZFRyYW5zYWN0aW9uLnNpZ25hdHVyZXNbYWRkcmVzc10gfSk7XG4gICAgICB9KVxuICAgIClcbiAgfTtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUob3V0KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlS2V5UGFpclNpZ25lcigpIHtcbiAgcmV0dXJuIGF3YWl0IGNyZWF0ZVNpZ25lckZyb21LZXlQYWlyKGF3YWl0IGdlbmVyYXRlS2V5UGFpcigpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUtleVBhaXJTaWduZXJGcm9tQnl0ZXMoYnl0ZXMsIGV4dHJhY3RhYmxlKSB7XG4gIHJldHVybiBhd2FpdCBjcmVhdGVTaWduZXJGcm9tS2V5UGFpcihhd2FpdCBjcmVhdGVLZXlQYWlyRnJvbUJ5dGVzKGJ5dGVzLCBleHRyYWN0YWJsZSkpO1xufVxuYXN5bmMgZnVuY3Rpb24gY3JlYXRlS2V5UGFpclNpZ25lckZyb21Qcml2YXRlS2V5Qnl0ZXMoYnl0ZXMsIGV4dHJhY3RhYmxlKSB7XG4gIHJldHVybiBhd2FpdCBjcmVhdGVTaWduZXJGcm9tS2V5UGFpcihhd2FpdCBjcmVhdGVLZXlQYWlyRnJvbVByaXZhdGVLZXlCeXRlcyhieXRlcywgZXh0cmFjdGFibGUpKTtcbn1cbmZ1bmN0aW9uIGlzTWVzc2FnZU1vZGlmeWluZ1NpZ25lcih2YWx1ZSkge1xuICByZXR1cm4gaXNBZGRyZXNzKHZhbHVlLmFkZHJlc3MpICYmIFwibW9kaWZ5QW5kU2lnbk1lc3NhZ2VzXCIgaW4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLm1vZGlmeUFuZFNpZ25NZXNzYWdlcyA9PT0gXCJmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24gYXNzZXJ0SXNNZXNzYWdlTW9kaWZ5aW5nU2lnbmVyKHZhbHVlKSB7XG4gIGlmICghaXNNZXNzYWdlTW9kaWZ5aW5nU2lnbmVyKHZhbHVlKSkge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfTUVTU0FHRV9NT0RJRllJTkdfU0lHTkVSLCB7XG4gICAgICBhZGRyZXNzOiB2YWx1ZS5hZGRyZXNzXG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzTWVzc2FnZVNpZ25lcih2YWx1ZSkge1xuICByZXR1cm4gaXNNZXNzYWdlUGFydGlhbFNpZ25lcih2YWx1ZSkgfHwgaXNNZXNzYWdlTW9kaWZ5aW5nU2lnbmVyKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGFzc2VydElzTWVzc2FnZVNpZ25lcih2YWx1ZSkge1xuICBpZiAoIWlzTWVzc2FnZVNpZ25lcih2YWx1ZSkpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX01FU1NBR0VfU0lHTkVSLCB7XG4gICAgICBhZGRyZXNzOiB2YWx1ZS5hZGRyZXNzXG4gICAgfSk7XG4gIH1cbn1cblxuLy8gc3JjL25vb3Atc2lnbmVyLnRzXG5mdW5jdGlvbiBjcmVhdGVOb29wU2lnbmVyKGFkZHJlc3MpIHtcbiAgY29uc3Qgb3V0ID0ge1xuICAgIGFkZHJlc3MsXG4gICAgc2lnbk1lc3NhZ2VzOiAobWVzc2FnZXMpID0+IFByb21pc2UucmVzb2x2ZShtZXNzYWdlcy5tYXAoKCkgPT4gT2JqZWN0LmZyZWV6ZSh7fSkpKSxcbiAgICBzaWduVHJhbnNhY3Rpb25zOiAodHJhbnNhY3Rpb25zKSA9PiBQcm9taXNlLnJlc29sdmUodHJhbnNhY3Rpb25zLm1hcCgoKSA9PiBPYmplY3QuZnJlZXplKHt9KSkpXG4gIH07XG4gIHJldHVybiBPYmplY3QuZnJlZXplKG91dCk7XG59XG5cbi8vIHNyYy9vZmZjaGFpbi1tZXNzYWdlLXNpZ25lci50c1xuZnVuY3Rpb24gZ2V0U2lnbmVyc0Zyb21PZmZjaGFpbk1lc3NhZ2Uoe1xuICByZXF1aXJlZFNpZ25hdG9yaWVzXG59KSB7XG4gIGNvbnN0IG1lc3NhZ2VTaWduZXJzID0gcmVxdWlyZWRTaWduYXRvcmllcy5maWx0ZXIoaXNNZXNzYWdlU2lnbmVyKTtcbiAgcmV0dXJuIGRlZHVwbGljYXRlU2lnbmVycyhtZXNzYWdlU2lnbmVycyk7XG59XG5hc3luYyBmdW5jdGlvbiBwYXJ0aWFsbHlTaWduT2ZmY2hhaW5NZXNzYWdlV2l0aFNpZ25lcnMob2ZmY2hhaW5NZXNzYWdlLCBjb25maWcpIHtcbiAgY29uc3QgeyBwYXJ0aWFsU2lnbmVycywgbW9kaWZ5aW5nU2lnbmVycyB9ID0gY2F0ZWdvcml6ZU1lc3NhZ2VTaWduZXJzKFxuICAgIGdldFNpZ25lcnNGcm9tT2ZmY2hhaW5NZXNzYWdlKG9mZmNoYWluTWVzc2FnZSlcbiAgKTtcbiAgcmV0dXJuIGF3YWl0IHNpZ25Nb2RpZnlpbmdBbmRQYXJ0aWFsTWVzc2FnZVNpZ25lcnMob2ZmY2hhaW5NZXNzYWdlLCBtb2RpZnlpbmdTaWduZXJzLCBwYXJ0aWFsU2lnbmVycywgY29uZmlnKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNpZ25PZmZjaGFpbk1lc3NhZ2VXaXRoU2lnbmVycyhvZmZjaGFpbk1lc3NhZ2UsIGNvbmZpZykge1xuICBjb25zdCBzaWduZWRPZmZjaGFpbk1lc3NhZ2VFbnZlbG9wZSA9IGF3YWl0IHBhcnRpYWxseVNpZ25PZmZjaGFpbk1lc3NhZ2VXaXRoU2lnbmVycyhvZmZjaGFpbk1lc3NhZ2UsIGNvbmZpZyk7XG4gIGFzc2VydElzRnVsbHlTaWduZWRPZmZjaGFpbk1lc3NhZ2VFbnZlbG9wZShzaWduZWRPZmZjaGFpbk1lc3NhZ2VFbnZlbG9wZSk7XG4gIHJldHVybiBzaWduZWRPZmZjaGFpbk1lc3NhZ2VFbnZlbG9wZTtcbn1cbmZ1bmN0aW9uIGNhdGVnb3JpemVNZXNzYWdlU2lnbmVycyhzaWduZXJzKSB7XG4gIGNvbnN0IG1vZGlmeWluZ1NpZ25lcnMgPSBpZGVudGlmeU1lc3NhZ2VNb2RpZnlpbmdTaWduZXJzKHNpZ25lcnMpO1xuICBjb25zdCBwYXJ0aWFsU2lnbmVycyA9IHNpZ25lcnMuZmlsdGVyKGlzTWVzc2FnZVBhcnRpYWxTaWduZXIpLmZpbHRlcigoc2lnbmVyKSA9PiAhbW9kaWZ5aW5nU2lnbmVycy5pbmNsdWRlcyhzaWduZXIpKTtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyBtb2RpZnlpbmdTaWduZXJzLCBwYXJ0aWFsU2lnbmVycyB9KTtcbn1cbmZ1bmN0aW9uIGlkZW50aWZ5TWVzc2FnZU1vZGlmeWluZ1NpZ25lcnMoc2lnbmVycykge1xuICBjb25zdCBtb2RpZnlpbmdTaWduZXJzID0gc2lnbmVycy5maWx0ZXIoaXNNZXNzYWdlTW9kaWZ5aW5nU2lnbmVyKTtcbiAgaWYgKG1vZGlmeWluZ1NpZ25lcnMubGVuZ3RoID09PSAwKSByZXR1cm4gW107XG4gIGNvbnN0IG5vblBhcnRpYWxTaWduZXJzID0gbW9kaWZ5aW5nU2lnbmVycy5maWx0ZXIoKHNpZ25lcikgPT4gIWlzTWVzc2FnZVBhcnRpYWxTaWduZXIoc2lnbmVyKSk7XG4gIGlmIChub25QYXJ0aWFsU2lnbmVycy5sZW5ndGggPiAwKSByZXR1cm4gbm9uUGFydGlhbFNpZ25lcnM7XG4gIHJldHVybiBbbW9kaWZ5aW5nU2lnbmVyc1swXV07XG59XG5hc3luYyBmdW5jdGlvbiBzaWduTW9kaWZ5aW5nQW5kUGFydGlhbE1lc3NhZ2VTaWduZXJzKG9mZmNoYWluTWVzc2FnZSwgbW9kaWZ5aW5nU2lnbmVycyA9IFtdLCBwYXJ0aWFsU2lnbmVycyA9IFtdLCBjb25maWcpIHtcbiAgY29uc3Qgb2ZmY2hhaW5NZXNzYWdlRW52ZWxvcGUgPSBjb21waWxlT2ZmY2hhaW5NZXNzYWdlRW52ZWxvcGUob2ZmY2hhaW5NZXNzYWdlKTtcbiAgY29uc3QgbW9kaWZpZWRPZmZjaGFpbk1lc3NhZ2UgPSBhd2FpdCBtb2RpZnlpbmdTaWduZXJzLnJlZHVjZShhc3luYyAob2ZmY2hhaW5NZXNzYWdlRW52ZWxvcGUyLCBtb2RpZnlpbmdTaWduZXIpID0+IHtcbiAgICBjb25maWc/LmFib3J0U2lnbmFsPy50aHJvd0lmQWJvcnRlZCgpO1xuICAgIGNvbnN0IFttZXNzYWdlXSA9IGF3YWl0IG1vZGlmeWluZ1NpZ25lci5tb2RpZnlBbmRTaWduTWVzc2FnZXMoW2F3YWl0IG9mZmNoYWluTWVzc2FnZUVudmVsb3BlMl0sIGNvbmZpZyk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUobWVzc2FnZSk7XG4gIH0sIFByb21pc2UucmVzb2x2ZShvZmZjaGFpbk1lc3NhZ2VFbnZlbG9wZSkpO1xuICBjb25maWc/LmFib3J0U2lnbmFsPy50aHJvd0lmQWJvcnRlZCgpO1xuICBjb25zdCBzaWduYXR1cmVEaWN0aW9uYXJpZXMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICBwYXJ0aWFsU2lnbmVycy5tYXAoYXN5bmMgKHBhcnRpYWxTaWduZXIpID0+IHtcbiAgICAgIGNvbnN0IFtzaWduYXR1cmVzXSA9IGF3YWl0IHBhcnRpYWxTaWduZXIuc2lnbk1lc3NhZ2VzKFttb2RpZmllZE9mZmNoYWluTWVzc2FnZV0sIGNvbmZpZyk7XG4gICAgICByZXR1cm4gc2lnbmF0dXJlcztcbiAgICB9KVxuICApO1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgLi4ubW9kaWZpZWRPZmZjaGFpbk1lc3NhZ2UsXG4gICAgc2lnbmF0dXJlczogT2JqZWN0LmZyZWV6ZShcbiAgICAgIHNpZ25hdHVyZURpY3Rpb25hcmllcy5yZWR1Y2UoKHNpZ25hdHVyZXMsIHNpZ25hdHVyZURpY3Rpb25hcnkpID0+IHtcbiAgICAgICAgcmV0dXJuIHsgLi4uc2lnbmF0dXJlcywgLi4uc2lnbmF0dXJlRGljdGlvbmFyeSB9O1xuICAgICAgfSwgbW9kaWZpZWRPZmZjaGFpbk1lc3NhZ2Uuc2lnbmF0dXJlcyA/PyB7fSlcbiAgICApXG4gIH0pO1xufVxuZnVuY3Rpb24gaXNUcmFuc2FjdGlvbk1lc3NhZ2VXaXRoU2luZ2xlU2VuZGluZ1NpZ25lcih0cmFuc2FjdGlvbikge1xuICB0cnkge1xuICAgIGFzc2VydElzVHJhbnNhY3Rpb25NZXNzYWdlV2l0aFNpbmdsZVNlbmRpbmdTaWduZXIodHJhbnNhY3Rpb24pO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIGFzc2VydElzVHJhbnNhY3Rpb25NZXNzYWdlV2l0aFNpbmdsZVNlbmRpbmdTaWduZXIodHJhbnNhY3Rpb24pIHtcbiAgY29uc3Qgc2lnbmVycyA9IGdldFNpZ25lcnNGcm9tVHJhbnNhY3Rpb25NZXNzYWdlKHRyYW5zYWN0aW9uKTtcbiAgY29uc3Qgc2VuZGluZ1NpZ25lcnMgPSBzaWduZXJzLmZpbHRlcihpc1RyYW5zYWN0aW9uU2VuZGluZ1NpZ25lcik7XG4gIGlmIChzZW5kaW5nU2lnbmVycy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19TSUdORVJfX1RSQU5TQUNUSU9OX1NFTkRJTkdfU0lHTkVSX01JU1NJTkcpO1xuICB9XG4gIGNvbnN0IHNlbmRpbmdPbmx5U2lnbmVycyA9IHNlbmRpbmdTaWduZXJzLmZpbHRlcihcbiAgICAoc2lnbmVyKSA9PiAhaXNUcmFuc2FjdGlvblBhcnRpYWxTaWduZXIoc2lnbmVyKSAmJiAhaXNUcmFuc2FjdGlvbk1vZGlmeWluZ1NpZ25lcihzaWduZXIpXG4gICk7XG4gIGlmIChzZW5kaW5nT25seVNpZ25lcnMubGVuZ3RoID4gMSkge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX1NJR05FUl9fVFJBTlNBQ1RJT05fQ0FOTk9UX0hBVkVfTVVMVElQTEVfU0VORElOR19TSUdORVJTKTtcbiAgfVxufVxuXG4vLyBzcmMvc2lnbi10cmFuc2FjdGlvbi50c1xuYXN5bmMgZnVuY3Rpb24gcGFydGlhbGx5U2lnblRyYW5zYWN0aW9uTWVzc2FnZVdpdGhTaWduZXJzKHRyYW5zYWN0aW9uTWVzc2FnZSwgY29uZmlnKSB7XG4gIGNvbnN0IHsgcGFydGlhbFNpZ25lcnMsIG1vZGlmeWluZ1NpZ25lcnMgfSA9IGNhdGVnb3JpemVUcmFuc2FjdGlvblNpZ25lcnMoXG4gICAgZGVkdXBsaWNhdGVTaWduZXJzKGdldFNpZ25lcnNGcm9tVHJhbnNhY3Rpb25NZXNzYWdlKHRyYW5zYWN0aW9uTWVzc2FnZSkuZmlsdGVyKGlzVHJhbnNhY3Rpb25TaWduZXIpKSxcbiAgICB7IGlkZW50aWZ5U2VuZGluZ1NpZ25lcjogZmFsc2UgfVxuICApO1xuICByZXR1cm4gYXdhaXQgc2lnbk1vZGlmeWluZ0FuZFBhcnRpYWxUcmFuc2FjdGlvblNpZ25lcnMoXG4gICAgdHJhbnNhY3Rpb25NZXNzYWdlLFxuICAgIG1vZGlmeWluZ1NpZ25lcnMsXG4gICAgcGFydGlhbFNpZ25lcnMsXG4gICAgY29uZmlnXG4gICk7XG59XG5hc3luYyBmdW5jdGlvbiBzaWduVHJhbnNhY3Rpb25NZXNzYWdlV2l0aFNpZ25lcnModHJhbnNhY3Rpb25NZXNzYWdlLCBjb25maWcpIHtcbiAgY29uc3Qgc2lnbmVkVHJhbnNhY3Rpb24gPSBhd2FpdCBwYXJ0aWFsbHlTaWduVHJhbnNhY3Rpb25NZXNzYWdlV2l0aFNpZ25lcnModHJhbnNhY3Rpb25NZXNzYWdlLCBjb25maWcpO1xuICBhc3NlcnRJc0Z1bGx5U2lnbmVkVHJhbnNhY3Rpb24oc2lnbmVkVHJhbnNhY3Rpb24pO1xuICByZXR1cm4gc2lnbmVkVHJhbnNhY3Rpb247XG59XG5hc3luYyBmdW5jdGlvbiBzaWduQW5kU2VuZFRyYW5zYWN0aW9uTWVzc2FnZVdpdGhTaWduZXJzKHRyYW5zYWN0aW9uLCBjb25maWcpIHtcbiAgYXNzZXJ0SXNUcmFuc2FjdGlvbk1lc3NhZ2VXaXRoU2luZ2xlU2VuZGluZ1NpZ25lcih0cmFuc2FjdGlvbik7XG4gIGNvbnN0IGFib3J0U2lnbmFsID0gY29uZmlnPy5hYm9ydFNpZ25hbDtcbiAgY29uc3QgeyBwYXJ0aWFsU2lnbmVycywgbW9kaWZ5aW5nU2lnbmVycywgc2VuZGluZ1NpZ25lciB9ID0gY2F0ZWdvcml6ZVRyYW5zYWN0aW9uU2lnbmVycyhcbiAgICBkZWR1cGxpY2F0ZVNpZ25lcnMoZ2V0U2lnbmVyc0Zyb21UcmFuc2FjdGlvbk1lc3NhZ2UodHJhbnNhY3Rpb24pLmZpbHRlcihpc1RyYW5zYWN0aW9uU2lnbmVyKSlcbiAgKTtcbiAgYWJvcnRTaWduYWw/LnRocm93SWZBYm9ydGVkKCk7XG4gIGNvbnN0IHNpZ25lZFRyYW5zYWN0aW9uID0gYXdhaXQgc2lnbk1vZGlmeWluZ0FuZFBhcnRpYWxUcmFuc2FjdGlvblNpZ25lcnMoXG4gICAgdHJhbnNhY3Rpb24sXG4gICAgbW9kaWZ5aW5nU2lnbmVycyxcbiAgICBwYXJ0aWFsU2lnbmVycyxcbiAgICBjb25maWdcbiAgKTtcbiAgaWYgKCFzZW5kaW5nU2lnbmVyKSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fU0lHTkVSX19UUkFOU0FDVElPTl9TRU5ESU5HX1NJR05FUl9NSVNTSU5HKTtcbiAgfVxuICBhYm9ydFNpZ25hbD8udGhyb3dJZkFib3J0ZWQoKTtcbiAgY29uc3QgW3NpZ25hdHVyZV0gPSBhd2FpdCBzZW5kaW5nU2lnbmVyLnNpZ25BbmRTZW5kVHJhbnNhY3Rpb25zKFtzaWduZWRUcmFuc2FjdGlvbl0sIGNvbmZpZyk7XG4gIGFib3J0U2lnbmFsPy50aHJvd0lmQWJvcnRlZCgpO1xuICByZXR1cm4gc2lnbmF0dXJlO1xufVxuZnVuY3Rpb24gY2F0ZWdvcml6ZVRyYW5zYWN0aW9uU2lnbmVycyhzaWduZXJzLCBjb25maWcgPSB7fSkge1xuICBjb25zdCBpZGVudGlmeVNlbmRpbmdTaWduZXIgPSBjb25maWcuaWRlbnRpZnlTZW5kaW5nU2lnbmVyID8/IHRydWU7XG4gIGNvbnN0IHNlbmRpbmdTaWduZXIgPSBpZGVudGlmeVNlbmRpbmdTaWduZXIgPyBpZGVudGlmeVRyYW5zYWN0aW9uU2VuZGluZ1NpZ25lcihzaWduZXJzKSA6IG51bGw7XG4gIGNvbnN0IG90aGVyU2lnbmVycyA9IHNpZ25lcnMuZmlsdGVyKFxuICAgIChzaWduZXIpID0+IHNpZ25lciAhPT0gc2VuZGluZ1NpZ25lciAmJiAoaXNUcmFuc2FjdGlvbk1vZGlmeWluZ1NpZ25lcihzaWduZXIpIHx8IGlzVHJhbnNhY3Rpb25QYXJ0aWFsU2lnbmVyKHNpZ25lcikpXG4gICk7XG4gIGNvbnN0IG1vZGlmeWluZ1NpZ25lcnMgPSBpZGVudGlmeVRyYW5zYWN0aW9uTW9kaWZ5aW5nU2lnbmVycyhvdGhlclNpZ25lcnMpO1xuICBjb25zdCBwYXJ0aWFsU2lnbmVycyA9IG90aGVyU2lnbmVycy5maWx0ZXIoaXNUcmFuc2FjdGlvblBhcnRpYWxTaWduZXIpLmZpbHRlcigoc2lnbmVyKSA9PiAhbW9kaWZ5aW5nU2lnbmVycy5pbmNsdWRlcyhzaWduZXIpKTtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyBtb2RpZnlpbmdTaWduZXJzLCBwYXJ0aWFsU2lnbmVycywgc2VuZGluZ1NpZ25lciB9KTtcbn1cbmZ1bmN0aW9uIGlkZW50aWZ5VHJhbnNhY3Rpb25TZW5kaW5nU2lnbmVyKHNpZ25lcnMpIHtcbiAgY29uc3Qgc2VuZGluZ1NpZ25lcnMgPSBzaWduZXJzLmZpbHRlcihpc1RyYW5zYWN0aW9uU2VuZGluZ1NpZ25lcik7XG4gIGlmIChzZW5kaW5nU2lnbmVycy5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuICBjb25zdCBzZW5kaW5nT25seVNpZ25lcnMgPSBzZW5kaW5nU2lnbmVycy5maWx0ZXIoXG4gICAgKHNpZ25lcikgPT4gIWlzVHJhbnNhY3Rpb25Nb2RpZnlpbmdTaWduZXIoc2lnbmVyKSAmJiAhaXNUcmFuc2FjdGlvblBhcnRpYWxTaWduZXIoc2lnbmVyKVxuICApO1xuICBpZiAoc2VuZGluZ09ubHlTaWduZXJzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gc2VuZGluZ09ubHlTaWduZXJzWzBdO1xuICB9XG4gIHJldHVybiBzZW5kaW5nU2lnbmVyc1swXTtcbn1cbmZ1bmN0aW9uIGlkZW50aWZ5VHJhbnNhY3Rpb25Nb2RpZnlpbmdTaWduZXJzKHNpZ25lcnMpIHtcbiAgY29uc3QgbW9kaWZ5aW5nU2lnbmVycyA9IHNpZ25lcnMuZmlsdGVyKGlzVHJhbnNhY3Rpb25Nb2RpZnlpbmdTaWduZXIpO1xuICBpZiAobW9kaWZ5aW5nU2lnbmVycy5sZW5ndGggPT09IDApIHJldHVybiBbXTtcbiAgY29uc3Qgbm9uUGFydGlhbFNpZ25lcnMgPSBtb2RpZnlpbmdTaWduZXJzLmZpbHRlcigoc2lnbmVyKSA9PiAhaXNUcmFuc2FjdGlvblBhcnRpYWxTaWduZXIoc2lnbmVyKSk7XG4gIGlmIChub25QYXJ0aWFsU2lnbmVycy5sZW5ndGggPiAwKSByZXR1cm4gbm9uUGFydGlhbFNpZ25lcnM7XG4gIHJldHVybiBbbW9kaWZ5aW5nU2lnbmVyc1swXV07XG59XG5hc3luYyBmdW5jdGlvbiBzaWduTW9kaWZ5aW5nQW5kUGFydGlhbFRyYW5zYWN0aW9uU2lnbmVycyh0cmFuc2FjdGlvbk1lc3NhZ2UsIG1vZGlmeWluZ1NpZ25lcnMgPSBbXSwgcGFydGlhbFNpZ25lcnMgPSBbXSwgY29uZmlnKSB7XG4gIGNvbnN0IHRyYW5zYWN0aW9uID0gY29tcGlsZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uTWVzc2FnZSk7XG4gIGNvbnN0IG1vZGlmaWVkVHJhbnNhY3Rpb24gPSBhd2FpdCBtb2RpZnlpbmdTaWduZXJzLnJlZHVjZShcbiAgICBhc3luYyAodHJhbnNhY3Rpb24yLCBtb2RpZnlpbmdTaWduZXIpID0+IHtcbiAgICAgIGNvbmZpZz8uYWJvcnRTaWduYWw/LnRocm93SWZBYm9ydGVkKCk7XG4gICAgICBjb25zdCBbdHhdID0gYXdhaXQgbW9kaWZ5aW5nU2lnbmVyLm1vZGlmeUFuZFNpZ25UcmFuc2FjdGlvbnMoW2F3YWl0IHRyYW5zYWN0aW9uMl0sIGNvbmZpZyk7XG4gICAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh0eCk7XG4gICAgfSxcbiAgICBQcm9taXNlLnJlc29sdmUodHJhbnNhY3Rpb24pXG4gICk7XG4gIGNvbmZpZz8uYWJvcnRTaWduYWw/LnRocm93SWZBYm9ydGVkKCk7XG4gIGNvbnN0IHNpZ25hdHVyZURpY3Rpb25hcmllcyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgIHBhcnRpYWxTaWduZXJzLm1hcChhc3luYyAocGFydGlhbFNpZ25lcikgPT4ge1xuICAgICAgY29uc3QgW3NpZ25hdHVyZXNdID0gYXdhaXQgcGFydGlhbFNpZ25lci5zaWduVHJhbnNhY3Rpb25zKFttb2RpZmllZFRyYW5zYWN0aW9uXSwgY29uZmlnKTtcbiAgICAgIHJldHVybiBzaWduYXR1cmVzO1xuICAgIH0pXG4gICk7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAuLi5tb2RpZmllZFRyYW5zYWN0aW9uLFxuICAgIHNpZ25hdHVyZXM6IE9iamVjdC5mcmVlemUoXG4gICAgICBzaWduYXR1cmVEaWN0aW9uYXJpZXMucmVkdWNlKChzaWduYXR1cmVzLCBzaWduYXR1cmVEaWN0aW9uYXJ5KSA9PiB7XG4gICAgICAgIHJldHVybiB7IC4uLnNpZ25hdHVyZXMsIC4uLnNpZ25hdHVyZURpY3Rpb25hcnkgfTtcbiAgICAgIH0sIG1vZGlmaWVkVHJhbnNhY3Rpb24uc2lnbmF0dXJlcyA/PyB7fSlcbiAgICApXG4gIH0pO1xufVxudmFyIG8gPSBnbG9iYWxUaGlzLlRleHRFbmNvZGVyO1xuXG4vLyBzcmMvc2lnbmFibGUtbWVzc2FnZS50c1xuZnVuY3Rpb24gY3JlYXRlU2lnbmFibGVNZXNzYWdlKGNvbnRlbnQsIHNpZ25hdHVyZXMgPSB7fSkge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgY29udGVudDogdHlwZW9mIGNvbnRlbnQgPT09IFwic3RyaW5nXCIgPyBuZXcgbygpLmVuY29kZShjb250ZW50KSA6IGNvbnRlbnQsXG4gICAgc2lnbmF0dXJlczogT2JqZWN0LmZyZWV6ZSh7IC4uLnNpZ25hdHVyZXMgfSlcbiAgfSk7XG59XG5cbmV4cG9ydCB7IGFkZFNpZ25lcnNUb0luc3RydWN0aW9uLCBhZGRTaWduZXJzVG9UcmFuc2FjdGlvbk1lc3NhZ2UsIGFzc2VydElzS2V5UGFpclNpZ25lciwgYXNzZXJ0SXNNZXNzYWdlTW9kaWZ5aW5nU2lnbmVyLCBhc3NlcnRJc01lc3NhZ2VQYXJ0aWFsU2lnbmVyLCBhc3NlcnRJc01lc3NhZ2VTaWduZXIsIGFzc2VydElzVHJhbnNhY3Rpb25NZXNzYWdlV2l0aFNpbmdsZVNlbmRpbmdTaWduZXIsIGFzc2VydElzVHJhbnNhY3Rpb25Nb2RpZnlpbmdTaWduZXIsIGFzc2VydElzVHJhbnNhY3Rpb25QYXJ0aWFsU2lnbmVyLCBhc3NlcnRJc1RyYW5zYWN0aW9uU2VuZGluZ1NpZ25lciwgYXNzZXJ0SXNUcmFuc2FjdGlvblNpZ25lciwgY3JlYXRlS2V5UGFpclNpZ25lckZyb21CeXRlcywgY3JlYXRlS2V5UGFpclNpZ25lckZyb21Qcml2YXRlS2V5Qnl0ZXMsIGNyZWF0ZU5vb3BTaWduZXIsIGNyZWF0ZVNpZ25hYmxlTWVzc2FnZSwgY3JlYXRlU2lnbmVyRnJvbUtleVBhaXIsIGdlbmVyYXRlS2V5UGFpclNpZ25lciwgZ2V0U2lnbmVyc0Zyb21JbnN0cnVjdGlvbiwgZ2V0U2lnbmVyc0Zyb21PZmZjaGFpbk1lc3NhZ2UsIGdldFNpZ25lcnNGcm9tVHJhbnNhY3Rpb25NZXNzYWdlLCBpc0tleVBhaXJTaWduZXIsIGlzTWVzc2FnZU1vZGlmeWluZ1NpZ25lciwgaXNNZXNzYWdlUGFydGlhbFNpZ25lciwgaXNNZXNzYWdlU2lnbmVyLCBpc1RyYW5zYWN0aW9uTWVzc2FnZVdpdGhTaW5nbGVTZW5kaW5nU2lnbmVyLCBpc1RyYW5zYWN0aW9uTW9kaWZ5aW5nU2lnbmVyLCBpc1RyYW5zYWN0aW9uUGFydGlhbFNpZ25lciwgaXNUcmFuc2FjdGlvblNlbmRpbmdTaWduZXIsIGlzVHJhbnNhY3Rpb25TaWduZXIsIHBhcnRpYWxseVNpZ25PZmZjaGFpbk1lc3NhZ2VXaXRoU2lnbmVycywgcGFydGlhbGx5U2lnblRyYW5zYWN0aW9uTWVzc2FnZVdpdGhTaWduZXJzLCBzZXRUcmFuc2FjdGlvbk1lc3NhZ2VGZWVQYXllclNpZ25lciwgc2lnbkFuZFNlbmRUcmFuc2FjdGlvbk1lc3NhZ2VXaXRoU2lnbmVycywgc2lnbk9mZmNoYWluTWVzc2FnZVdpdGhTaWduZXJzLCBzaWduVHJhbnNhY3Rpb25NZXNzYWdlV2l0aFNpZ25lcnMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm5vZGUubWpzLm1hcFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubm9kZS5tanMubWFwIl0sIm5hbWVzIjpbIlNvbGFuYUVycm9yIiwiU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX1RSQU5TQUNUSU9OX01PRElGWUlOR19TSUdORVIiLCJTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfVFJBTlNBQ1RJT05fUEFSVElBTF9TSUdORVIiLCJTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfVFJBTlNBQ1RJT05fU0VORElOR19TSUdORVIiLCJTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfVFJBTlNBQ1RJT05fU0lHTkVSIiwiU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX01FU1NBR0VfUEFSVElBTF9TSUdORVIiLCJTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfS0VZX1BBSVJfU0lHTkVSIiwiU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX01FU1NBR0VfTU9ESUZZSU5HX1NJR05FUiIsIlNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9NRVNTQUdFX1NJR05FUiIsIlNPTEFOQV9FUlJPUl9fU0lHTkVSX19UUkFOU0FDVElPTl9TRU5ESU5HX1NJR05FUl9NSVNTSU5HIiwiU09MQU5BX0VSUk9SX19TSUdORVJfX1RSQU5TQUNUSU9OX0NBTk5PVF9IQVZFX01VTFRJUExFX1NFTkRJTkdfU0lHTkVSUyIsIlNPTEFOQV9FUlJPUl9fU0lHTkVSX19BRERSRVNTX0NBTk5PVF9IQVZFX01VTFRJUExFX1NJR05FUlMiLCJpc1NpZ25lclJvbGUiLCJnZXRBZGRyZXNzRnJvbVB1YmxpY0tleSIsImlzQWRkcmVzcyIsImdlbmVyYXRlS2V5UGFpciIsImNyZWF0ZUtleVBhaXJGcm9tQnl0ZXMiLCJjcmVhdGVLZXlQYWlyRnJvbVByaXZhdGVLZXlCeXRlcyIsInNpZ25CeXRlcyIsImFzc2VydElzRnVsbHlTaWduZWRUcmFuc2FjdGlvbiIsImNvbXBpbGVUcmFuc2FjdGlvbiIsInBhcnRpYWxseVNpZ25UcmFuc2FjdGlvbiIsImFzc2VydElzRnVsbHlTaWduZWRPZmZjaGFpbk1lc3NhZ2VFbnZlbG9wZSIsImNvbXBpbGVPZmZjaGFpbk1lc3NhZ2VFbnZlbG9wZSIsImRlZHVwbGljYXRlU2lnbmVycyIsInNpZ25lcnMiLCJkZWR1cGxpY2F0ZWQiLCJmb3JFYWNoIiwic2lnbmVyIiwiYWRkcmVzcyIsIk9iamVjdCIsInZhbHVlcyIsImlzVHJhbnNhY3Rpb25Nb2RpZnlpbmdTaWduZXIiLCJ2YWx1ZSIsIm1vZGlmeUFuZFNpZ25UcmFuc2FjdGlvbnMiLCJhc3NlcnRJc1RyYW5zYWN0aW9uTW9kaWZ5aW5nU2lnbmVyIiwiaXNUcmFuc2FjdGlvblBhcnRpYWxTaWduZXIiLCJzaWduVHJhbnNhY3Rpb25zIiwiYXNzZXJ0SXNUcmFuc2FjdGlvblBhcnRpYWxTaWduZXIiLCJpc1RyYW5zYWN0aW9uU2VuZGluZ1NpZ25lciIsInNpZ25BbmRTZW5kVHJhbnNhY3Rpb25zIiwiYXNzZXJ0SXNUcmFuc2FjdGlvblNlbmRpbmdTaWduZXIiLCJpc1RyYW5zYWN0aW9uU2lnbmVyIiwiYXNzZXJ0SXNUcmFuc2FjdGlvblNpZ25lciIsImdldFNpZ25lcnNGcm9tSW5zdHJ1Y3Rpb24iLCJpbnN0cnVjdGlvbiIsImFjY291bnRzIiwiZmxhdE1hcCIsImFjY291bnQiLCJnZXRTaWduZXJzRnJvbVRyYW5zYWN0aW9uTWVzc2FnZSIsInRyYW5zYWN0aW9uIiwiZmVlUGF5ZXIiLCJpbnN0cnVjdGlvbnMiLCJhZGRTaWduZXJzVG9JbnN0cnVjdGlvbiIsImxlbmd0aCIsInNpZ25lckJ5QWRkcmVzcyIsIk1hcCIsIm1hcCIsImZyZWV6ZSIsImdldCIsInJvbGUiLCJhZGRTaWduZXJzVG9UcmFuc2FjdGlvbk1lc3NhZ2UiLCJ0cmFuc2FjdGlvbk1lc3NhZ2UiLCJmZWVQYXllclNpZ25lciIsImhhc0FkZHJlc3NPbmx5RmVlUGF5ZXIiLCJmaW5kIiwibWVzc2FnZSIsInNldFRyYW5zYWN0aW9uTWVzc2FnZUZlZVBheWVyU2lnbmVyIiwib3V0IiwiaXNNZXNzYWdlUGFydGlhbFNpZ25lciIsInNpZ25NZXNzYWdlcyIsImFzc2VydElzTWVzc2FnZVBhcnRpYWxTaWduZXIiLCJpc0tleVBhaXJTaWduZXIiLCJrZXlQYWlyIiwiYXNzZXJ0SXNLZXlQYWlyU2lnbmVyIiwiY3JlYXRlU2lnbmVyRnJvbUtleVBhaXIiLCJwdWJsaWNLZXkiLCJtZXNzYWdlcyIsIlByb21pc2UiLCJhbGwiLCJwcml2YXRlS2V5IiwiY29udGVudCIsInRyYW5zYWN0aW9ucyIsInNpZ25lZFRyYW5zYWN0aW9uIiwic2lnbmF0dXJlcyIsImdlbmVyYXRlS2V5UGFpclNpZ25lciIsImNyZWF0ZUtleVBhaXJTaWduZXJGcm9tQnl0ZXMiLCJieXRlcyIsImV4dHJhY3RhYmxlIiwiY3JlYXRlS2V5UGFpclNpZ25lckZyb21Qcml2YXRlS2V5Qnl0ZXMiLCJpc01lc3NhZ2VNb2RpZnlpbmdTaWduZXIiLCJtb2RpZnlBbmRTaWduTWVzc2FnZXMiLCJhc3NlcnRJc01lc3NhZ2VNb2RpZnlpbmdTaWduZXIiLCJpc01lc3NhZ2VTaWduZXIiLCJhc3NlcnRJc01lc3NhZ2VTaWduZXIiLCJjcmVhdGVOb29wU2lnbmVyIiwicmVzb2x2ZSIsImdldFNpZ25lcnNGcm9tT2ZmY2hhaW5NZXNzYWdlIiwicmVxdWlyZWRTaWduYXRvcmllcyIsIm1lc3NhZ2VTaWduZXJzIiwiZmlsdGVyIiwicGFydGlhbGx5U2lnbk9mZmNoYWluTWVzc2FnZVdpdGhTaWduZXJzIiwib2ZmY2hhaW5NZXNzYWdlIiwiY29uZmlnIiwicGFydGlhbFNpZ25lcnMiLCJtb2RpZnlpbmdTaWduZXJzIiwiY2F0ZWdvcml6ZU1lc3NhZ2VTaWduZXJzIiwic2lnbk1vZGlmeWluZ0FuZFBhcnRpYWxNZXNzYWdlU2lnbmVycyIsInNpZ25PZmZjaGFpbk1lc3NhZ2VXaXRoU2lnbmVycyIsInNpZ25lZE9mZmNoYWluTWVzc2FnZUVudmVsb3BlIiwiaWRlbnRpZnlNZXNzYWdlTW9kaWZ5aW5nU2lnbmVycyIsImluY2x1ZGVzIiwibm9uUGFydGlhbFNpZ25lcnMiLCJvZmZjaGFpbk1lc3NhZ2VFbnZlbG9wZSIsIm1vZGlmaWVkT2ZmY2hhaW5NZXNzYWdlIiwicmVkdWNlIiwib2ZmY2hhaW5NZXNzYWdlRW52ZWxvcGUyIiwibW9kaWZ5aW5nU2lnbmVyIiwiYWJvcnRTaWduYWwiLCJ0aHJvd0lmQWJvcnRlZCIsInNpZ25hdHVyZURpY3Rpb25hcmllcyIsInBhcnRpYWxTaWduZXIiLCJzaWduYXR1cmVEaWN0aW9uYXJ5IiwiaXNUcmFuc2FjdGlvbk1lc3NhZ2VXaXRoU2luZ2xlU2VuZGluZ1NpZ25lciIsImFzc2VydElzVHJhbnNhY3Rpb25NZXNzYWdlV2l0aFNpbmdsZVNlbmRpbmdTaWduZXIiLCJzZW5kaW5nU2lnbmVycyIsInNlbmRpbmdPbmx5U2lnbmVycyIsInBhcnRpYWxseVNpZ25UcmFuc2FjdGlvbk1lc3NhZ2VXaXRoU2lnbmVycyIsImNhdGVnb3JpemVUcmFuc2FjdGlvblNpZ25lcnMiLCJpZGVudGlmeVNlbmRpbmdTaWduZXIiLCJzaWduTW9kaWZ5aW5nQW5kUGFydGlhbFRyYW5zYWN0aW9uU2lnbmVycyIsInNpZ25UcmFuc2FjdGlvbk1lc3NhZ2VXaXRoU2lnbmVycyIsInNpZ25BbmRTZW5kVHJhbnNhY3Rpb25NZXNzYWdlV2l0aFNpZ25lcnMiLCJzZW5kaW5nU2lnbmVyIiwic2lnbmF0dXJlIiwiaWRlbnRpZnlUcmFuc2FjdGlvblNlbmRpbmdTaWduZXIiLCJvdGhlclNpZ25lcnMiLCJpZGVudGlmeVRyYW5zYWN0aW9uTW9kaWZ5aW5nU2lnbmVycyIsIm1vZGlmaWVkVHJhbnNhY3Rpb24iLCJ0cmFuc2FjdGlvbjIiLCJ0eCIsIm8iLCJnbG9iYWxUaGlzIiwiVGV4dEVuY29kZXIiLCJjcmVhdGVTaWduYWJsZU1lc3NhZ2UiLCJlbmNvZGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/signers/dist/index.node.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/transaction-messages/dist/index.node.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@solana/transaction-messages/dist/index.node.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MAX_SUPPORTED_TRANSACTION_VERSION: () => (/* binding */ MAX_SUPPORTED_TRANSACTION_VERSION),\n/* harmony export */   appendTransactionMessageInstruction: () => (/* binding */ appendTransactionMessageInstruction),\n/* harmony export */   appendTransactionMessageInstructions: () => (/* binding */ appendTransactionMessageInstructions),\n/* harmony export */   assertIsTransactionMessageWithBlockhashLifetime: () => (/* binding */ assertIsTransactionMessageWithBlockhashLifetime),\n/* harmony export */   assertIsTransactionMessageWithDurableNonceLifetime: () => (/* binding */ assertIsTransactionMessageWithDurableNonceLifetime),\n/* harmony export */   compileTransactionMessage: () => (/* binding */ compileTransactionMessage),\n/* harmony export */   compressTransactionMessageUsingAddressLookupTables: () => (/* binding */ compressTransactionMessageUsingAddressLookupTables),\n/* harmony export */   createTransactionMessage: () => (/* binding */ createTransactionMessage),\n/* harmony export */   decompileTransactionMessage: () => (/* binding */ decompileTransactionMessage),\n/* harmony export */   getCompiledTransactionMessageCodec: () => (/* binding */ getCompiledTransactionMessageCodec),\n/* harmony export */   getCompiledTransactionMessageDecoder: () => (/* binding */ getCompiledTransactionMessageDecoder),\n/* harmony export */   getCompiledTransactionMessageEncoder: () => (/* binding */ getCompiledTransactionMessageEncoder),\n/* harmony export */   getTransactionVersionCodec: () => (/* binding */ getTransactionVersionCodec),\n/* harmony export */   getTransactionVersionDecoder: () => (/* binding */ getTransactionVersionDecoder),\n/* harmony export */   getTransactionVersionEncoder: () => (/* binding */ getTransactionVersionEncoder),\n/* harmony export */   isAdvanceNonceAccountInstruction: () => (/* binding */ isAdvanceNonceAccountInstruction),\n/* harmony export */   isTransactionMessageWithBlockhashLifetime: () => (/* binding */ isTransactionMessageWithBlockhashLifetime),\n/* harmony export */   isTransactionMessageWithDurableNonceLifetime: () => (/* binding */ isTransactionMessageWithDurableNonceLifetime),\n/* harmony export */   prependTransactionMessageInstruction: () => (/* binding */ prependTransactionMessageInstruction),\n/* harmony export */   prependTransactionMessageInstructions: () => (/* binding */ prependTransactionMessageInstructions),\n/* harmony export */   setTransactionMessageFeePayer: () => (/* binding */ setTransactionMessageFeePayer),\n/* harmony export */   setTransactionMessageLifetimeUsingBlockhash: () => (/* binding */ setTransactionMessageLifetimeUsingBlockhash),\n/* harmony export */   setTransactionMessageLifetimeUsingDurableNonce: () => (/* binding */ setTransactionMessageLifetimeUsingDurableNonce)\n/* harmony export */ });\n/* harmony import */ var _solana_errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana/errors */ \"(ssr)/./node_modules/@solana/errors/dist/index.node.mjs\");\n/* harmony import */ var _solana_rpc_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/rpc-types */ \"(ssr)/./node_modules/@solana/rpc-types/dist/index.node.mjs\");\n/* harmony import */ var _solana_addresses__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @solana/addresses */ \"(ssr)/./node_modules/@solana/addresses/dist/index.node.mjs\");\n/* harmony import */ var _solana_codecs_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @solana/codecs-core */ \"(ssr)/./node_modules/@solana/codecs-core/dist/index.node.mjs\");\n/* harmony import */ var _solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @solana/codecs-data-structures */ \"(ssr)/./node_modules/@solana/codecs-data-structures/dist/index.node.mjs\");\n/* harmony import */ var _solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @solana/codecs-numbers */ \"(ssr)/./node_modules/@solana/codecs-numbers/dist/index.node.mjs\");\n/* harmony import */ var _solana_instructions__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @solana/instructions */ \"(ssr)/./node_modules/@solana/instructions/dist/index.node.mjs\");\n/* harmony import */ var _solana_functional__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @solana/functional */ \"(ssr)/./node_modules/@solana/functional/dist/index.node.mjs\");\n\n\n\n\n\n\n\n\n// src/blockhash.ts\nfunction isTransactionMessageWithBlockhashLifetime(transactionMessage) {\n    return \"lifetimeConstraint\" in transactionMessage && typeof transactionMessage.lifetimeConstraint.blockhash === \"string\" && typeof transactionMessage.lifetimeConstraint.lastValidBlockHeight === \"bigint\" && (0,_solana_rpc_types__WEBPACK_IMPORTED_MODULE_0__.isBlockhash)(transactionMessage.lifetimeConstraint.blockhash);\n}\nfunction assertIsTransactionMessageWithBlockhashLifetime(transactionMessage) {\n    if (!isTransactionMessageWithBlockhashLifetime(transactionMessage)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME);\n    }\n}\nfunction setTransactionMessageLifetimeUsingBlockhash(blockhashLifetimeConstraint, transactionMessage) {\n    if (\"lifetimeConstraint\" in transactionMessage && transactionMessage.lifetimeConstraint && \"blockhash\" in transactionMessage.lifetimeConstraint && transactionMessage.lifetimeConstraint.blockhash === blockhashLifetimeConstraint.blockhash && transactionMessage.lifetimeConstraint.lastValidBlockHeight === blockhashLifetimeConstraint.lastValidBlockHeight) {\n        return transactionMessage;\n    }\n    return Object.freeze({\n        ...transactionMessage,\n        lifetimeConstraint: Object.freeze(blockhashLifetimeConstraint)\n    });\n}\nfunction assertValidBaseString(alphabet4, testValue, givenValue = testValue) {\n    if (!testValue.match(new RegExp(`^[${alphabet4}]*$`))) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n            alphabet: alphabet4,\n            base: alphabet4.length,\n            value: givenValue\n        });\n    }\n}\nvar getBaseXEncoder = (alphabet4)=>{\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_2__.createEncoder)({\n        getSizeFromValue: (value)=>{\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet4[0]);\n            if (!tailChars) return value.length;\n            const base10Number = getBigIntFromBaseX(tailChars, alphabet4);\n            return leadingZeroes.length + Math.ceil(base10Number.toString(16).length / 2);\n        },\n        write (value, bytes, offset) {\n            assertValidBaseString(alphabet4, value);\n            if (value === \"\") return offset;\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet4[0]);\n            if (!tailChars) {\n                bytes.set(new Uint8Array(leadingZeroes.length).fill(0), offset);\n                return offset + leadingZeroes.length;\n            }\n            let base10Number = getBigIntFromBaseX(tailChars, alphabet4);\n            const tailBytes = [];\n            while(base10Number > 0n){\n                tailBytes.unshift(Number(base10Number % 256n));\n                base10Number /= 256n;\n            }\n            const bytesToAdd = [\n                ...Array(leadingZeroes.length).fill(0),\n                ...tailBytes\n            ];\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        }\n    });\n};\nvar getBaseXDecoder = (alphabet4)=>{\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_2__.createDecoder)({\n        read (rawBytes, offset) {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return [\n                \"\",\n                0\n            ];\n            let trailIndex = bytes.findIndex((n)=>n !== 0);\n            trailIndex = trailIndex === -1 ? bytes.length : trailIndex;\n            const leadingZeroes = alphabet4[0].repeat(trailIndex);\n            if (trailIndex === bytes.length) return [\n                leadingZeroes,\n                rawBytes.length\n            ];\n            const base10Number = bytes.slice(trailIndex).reduce((sum, byte)=>sum * 256n + BigInt(byte), 0n);\n            const tailChars = getBaseXFromBigInt(base10Number, alphabet4);\n            return [\n                leadingZeroes + tailChars,\n                rawBytes.length\n            ];\n        }\n    });\n};\nfunction partitionLeadingZeroes(value, zeroCharacter) {\n    const [leadingZeros, tailChars] = value.split(new RegExp(`((?!${zeroCharacter}).*)`));\n    return [\n        leadingZeros,\n        tailChars\n    ];\n}\nfunction getBigIntFromBaseX(value, alphabet4) {\n    const base = BigInt(alphabet4.length);\n    let sum = 0n;\n    for (const char of value){\n        sum *= base;\n        sum += BigInt(alphabet4.indexOf(char));\n    }\n    return sum;\n}\nfunction getBaseXFromBigInt(value, alphabet4) {\n    const base = BigInt(alphabet4.length);\n    const tailChars = [];\n    while(value > 0n){\n        tailChars.unshift(alphabet4[Number(value % base)]);\n        value /= base;\n    }\n    return tailChars.join(\"\");\n}\nvar alphabet2 = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\nvar getBase58Encoder = ()=>getBaseXEncoder(alphabet2);\nvar getBase58Decoder = ()=>getBaseXDecoder(alphabet2);\nvar memoizedAddressTableLookupEncoder;\nfunction getAddressTableLookupEncoder() {\n    if (!memoizedAddressTableLookupEncoder) {\n        const indexEncoder = (0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_3__.getArrayEncoder)((0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_4__.getU8Encoder)(), {\n            size: (0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_4__.getShortU16Encoder)()\n        });\n        memoizedAddressTableLookupEncoder = (0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_3__.getStructEncoder)([\n            [\n                \"lookupTableAddress\",\n                (0,_solana_addresses__WEBPACK_IMPORTED_MODULE_5__.getAddressEncoder)()\n            ],\n            [\n                \"writableIndexes\",\n                indexEncoder\n            ],\n            [\n                \"readonlyIndexes\",\n                indexEncoder\n            ]\n        ]);\n    }\n    return memoizedAddressTableLookupEncoder;\n}\nvar memoizedAddressTableLookupDecoder;\nfunction getAddressTableLookupDecoder() {\n    if (!memoizedAddressTableLookupDecoder) {\n        const indexEncoder = (0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_3__.getArrayDecoder)((0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_4__.getU8Decoder)(), {\n            size: (0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_4__.getShortU16Decoder)()\n        });\n        memoizedAddressTableLookupDecoder = (0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_3__.getStructDecoder)([\n            [\n                \"lookupTableAddress\",\n                (0,_solana_addresses__WEBPACK_IMPORTED_MODULE_5__.getAddressDecoder)()\n            ],\n            [\n                \"writableIndexes\",\n                indexEncoder\n            ],\n            [\n                \"readonlyIndexes\",\n                indexEncoder\n            ]\n        ]);\n    }\n    return memoizedAddressTableLookupDecoder;\n}\nvar memoizedU8Encoder;\nfunction getMemoizedU8Encoder() {\n    if (!memoizedU8Encoder) memoizedU8Encoder = (0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_4__.getU8Encoder)();\n    return memoizedU8Encoder;\n}\nvar memoizedU8Decoder;\nfunction getMemoizedU8Decoder() {\n    if (!memoizedU8Decoder) memoizedU8Decoder = (0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_4__.getU8Decoder)();\n    return memoizedU8Decoder;\n}\nfunction getMessageHeaderEncoder() {\n    return (0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_3__.getStructEncoder)([\n        [\n            \"numSignerAccounts\",\n            getMemoizedU8Encoder()\n        ],\n        [\n            \"numReadonlySignerAccounts\",\n            getMemoizedU8Encoder()\n        ],\n        [\n            \"numReadonlyNonSignerAccounts\",\n            getMemoizedU8Encoder()\n        ]\n    ]);\n}\nfunction getMessageHeaderDecoder() {\n    return (0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_3__.getStructDecoder)([\n        [\n            \"numSignerAccounts\",\n            getMemoizedU8Decoder()\n        ],\n        [\n            \"numReadonlySignerAccounts\",\n            getMemoizedU8Decoder()\n        ],\n        [\n            \"numReadonlyNonSignerAccounts\",\n            getMemoizedU8Decoder()\n        ]\n    ]);\n}\nvar memoizedGetInstructionEncoder;\nfunction getInstructionEncoder() {\n    if (!memoizedGetInstructionEncoder) {\n        memoizedGetInstructionEncoder = (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_2__.transformEncoder)((0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_3__.getStructEncoder)([\n            [\n                \"programAddressIndex\",\n                (0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_4__.getU8Encoder)()\n            ],\n            [\n                \"accountIndices\",\n                (0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_3__.getArrayEncoder)((0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_4__.getU8Encoder)(), {\n                    size: (0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_4__.getShortU16Encoder)()\n                })\n            ],\n            [\n                \"data\",\n                (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_2__.addEncoderSizePrefix)((0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_3__.getBytesEncoder)(), (0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_4__.getShortU16Encoder)())\n            ]\n        ]), // Convert an instruction to have all fields defined\n        (instruction)=>{\n            if (instruction.accountIndices !== void 0 && instruction.data !== void 0) {\n                return instruction;\n            }\n            return {\n                ...instruction,\n                accountIndices: instruction.accountIndices ?? [],\n                data: instruction.data ?? new Uint8Array(0)\n            };\n        });\n    }\n    return memoizedGetInstructionEncoder;\n}\nvar memoizedGetInstructionDecoder;\nfunction getInstructionDecoder() {\n    if (!memoizedGetInstructionDecoder) {\n        memoizedGetInstructionDecoder = (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_2__.transformDecoder)((0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_3__.getStructDecoder)([\n            [\n                \"programAddressIndex\",\n                (0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_4__.getU8Decoder)()\n            ],\n            [\n                \"accountIndices\",\n                (0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_3__.getArrayDecoder)((0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_4__.getU8Decoder)(), {\n                    size: (0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_4__.getShortU16Decoder)()\n                })\n            ],\n            [\n                \"data\",\n                (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_2__.addDecoderSizePrefix)((0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_3__.getBytesDecoder)(), (0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_4__.getShortU16Decoder)())\n            ]\n        ]), // Convert an instruction to exclude optional fields if they are empty\n        (instruction)=>{\n            if (instruction.accountIndices.length && instruction.data.byteLength) {\n                return instruction;\n            }\n            const { accountIndices, data, ...rest } = instruction;\n            return {\n                ...rest,\n                ...accountIndices.length ? {\n                    accountIndices\n                } : null,\n                ...data.byteLength ? {\n                    data\n                } : null\n            };\n        });\n    }\n    return memoizedGetInstructionDecoder;\n}\n// src/transaction-message.ts\nvar MAX_SUPPORTED_TRANSACTION_VERSION = 0;\n// src/codecs/transaction-version.ts\nvar VERSION_FLAG_MASK = 128;\nfunction getTransactionVersionEncoder() {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_2__.createEncoder)({\n        getSizeFromValue: (value)=>value === \"legacy\" ? 0 : 1,\n        maxSize: 1,\n        write: (value, bytes, offset)=>{\n            if (value === \"legacy\") {\n                return offset;\n            }\n            if (value < 0 || value > 127) {\n                throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE, {\n                    actualVersion: value\n                });\n            }\n            if (value > MAX_SUPPORTED_TRANSACTION_VERSION) {\n                throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED, {\n                    unsupportedVersion: value\n                });\n            }\n            bytes.set([\n                value | VERSION_FLAG_MASK\n            ], offset);\n            return offset + 1;\n        }\n    });\n}\nfunction getTransactionVersionDecoder() {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_2__.createDecoder)({\n        maxSize: 1,\n        read: (bytes, offset)=>{\n            const firstByte = bytes[offset];\n            if ((firstByte & VERSION_FLAG_MASK) === 0) {\n                return [\n                    \"legacy\",\n                    offset\n                ];\n            } else {\n                const version = firstByte ^ VERSION_FLAG_MASK;\n                if (version > MAX_SUPPORTED_TRANSACTION_VERSION) {\n                    throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED, {\n                        unsupportedVersion: version\n                    });\n                }\n                return [\n                    version,\n                    offset + 1\n                ];\n            }\n        }\n    });\n}\nfunction getTransactionVersionCodec() {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_2__.combineCodec)(getTransactionVersionEncoder(), getTransactionVersionDecoder());\n}\n// src/codecs/message.ts\nfunction getCompiledMessageLegacyEncoder() {\n    return (0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_3__.getStructEncoder)(getPreludeStructEncoderTuple());\n}\nfunction getCompiledMessageVersionedEncoder() {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_2__.transformEncoder)((0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_3__.getStructEncoder)([\n        ...getPreludeStructEncoderTuple(),\n        [\n            \"addressTableLookups\",\n            getAddressTableLookupArrayEncoder()\n        ]\n    ]), (value)=>{\n        if (value.version === \"legacy\") {\n            return value;\n        }\n        return {\n            ...value,\n            addressTableLookups: value.addressTableLookups ?? []\n        };\n    });\n}\nfunction getPreludeStructEncoderTuple() {\n    const lifetimeTokenEncoder = (0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_3__.getUnionEncoder)([\n        // Use a 32-byte constant encoder for a missing lifetime token (index 0).\n        (0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_3__.getConstantEncoder)(new Uint8Array(32)),\n        // Use a 32-byte base58 encoder for a valid lifetime token (index 1).\n        (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_2__.fixEncoderSize)(getBase58Encoder(), 32)\n    ], (value)=>value === void 0 ? 0 : 1);\n    return [\n        [\n            \"version\",\n            getTransactionVersionEncoder()\n        ],\n        [\n            \"header\",\n            getMessageHeaderEncoder()\n        ],\n        [\n            \"staticAccounts\",\n            (0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_3__.getArrayEncoder)((0,_solana_addresses__WEBPACK_IMPORTED_MODULE_5__.getAddressEncoder)(), {\n                size: (0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_4__.getShortU16Encoder)()\n            })\n        ],\n        [\n            \"lifetimeToken\",\n            lifetimeTokenEncoder\n        ],\n        [\n            \"instructions\",\n            (0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_3__.getArrayEncoder)(getInstructionEncoder(), {\n                size: (0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_4__.getShortU16Encoder)()\n            })\n        ]\n    ];\n}\nfunction getPreludeStructDecoderTuple() {\n    return [\n        [\n            \"version\",\n            getTransactionVersionDecoder()\n        ],\n        [\n            \"header\",\n            getMessageHeaderDecoder()\n        ],\n        [\n            \"staticAccounts\",\n            (0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_3__.getArrayDecoder)((0,_solana_addresses__WEBPACK_IMPORTED_MODULE_5__.getAddressDecoder)(), {\n                size: (0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_4__.getShortU16Decoder)()\n            })\n        ],\n        [\n            \"lifetimeToken\",\n            (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_2__.fixDecoderSize)(getBase58Decoder(), 32)\n        ],\n        [\n            \"instructions\",\n            (0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_3__.getArrayDecoder)(getInstructionDecoder(), {\n                size: (0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_4__.getShortU16Decoder)()\n            })\n        ],\n        [\n            \"addressTableLookups\",\n            getAddressTableLookupArrayDecoder()\n        ]\n    ];\n}\nfunction getAddressTableLookupArrayEncoder() {\n    return (0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_3__.getArrayEncoder)(getAddressTableLookupEncoder(), {\n        size: (0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_4__.getShortU16Encoder)()\n    });\n}\nfunction getAddressTableLookupArrayDecoder() {\n    return (0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_3__.getArrayDecoder)(getAddressTableLookupDecoder(), {\n        size: (0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_4__.getShortU16Decoder)()\n    });\n}\nfunction getCompiledTransactionMessageEncoder() {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_2__.createEncoder)({\n        getSizeFromValue: (compiledMessage)=>{\n            if (compiledMessage.version === \"legacy\") {\n                return getCompiledMessageLegacyEncoder().getSizeFromValue(compiledMessage);\n            } else {\n                return getCompiledMessageVersionedEncoder().getSizeFromValue(compiledMessage);\n            }\n        },\n        write: (compiledMessage, bytes, offset)=>{\n            if (compiledMessage.version === \"legacy\") {\n                return getCompiledMessageLegacyEncoder().write(compiledMessage, bytes, offset);\n            } else {\n                return getCompiledMessageVersionedEncoder().write(compiledMessage, bytes, offset);\n            }\n        }\n    });\n}\nfunction getCompiledTransactionMessageDecoder() {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_2__.transformDecoder)((0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_3__.getStructDecoder)(getPreludeStructDecoderTuple()), ({ addressTableLookups, ...restOfMessage })=>{\n        if (restOfMessage.version === \"legacy\" || !addressTableLookups?.length) {\n            return restOfMessage;\n        }\n        return {\n            ...restOfMessage,\n            addressTableLookups\n        };\n    });\n}\nfunction getCompiledTransactionMessageCodec() {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_2__.combineCodec)(getCompiledTransactionMessageEncoder(), getCompiledTransactionMessageDecoder());\n}\nfunction upsert(addressMap, address, update) {\n    addressMap[address] = update(addressMap[address] ?? {\n        role: _solana_instructions__WEBPACK_IMPORTED_MODULE_6__.AccountRole.READONLY\n    });\n}\nvar TYPE = Symbol(\"AddressMapTypeProperty\");\nfunction getAddressMapFromInstructions(feePayer, instructions) {\n    const addressMap = {\n        [feePayer]: {\n            [TYPE]: 0 /* FEE_PAYER */ ,\n            role: _solana_instructions__WEBPACK_IMPORTED_MODULE_6__.AccountRole.WRITABLE_SIGNER\n        }\n    };\n    const addressesOfInvokedPrograms = /* @__PURE__ */ new Set();\n    for (const instruction of instructions){\n        upsert(addressMap, instruction.programAddress, (entry)=>{\n            addressesOfInvokedPrograms.add(instruction.programAddress);\n            if (TYPE in entry) {\n                if ((0,_solana_instructions__WEBPACK_IMPORTED_MODULE_6__.isWritableRole)(entry.role)) {\n                    switch(entry[TYPE]){\n                        case 0 /* FEE_PAYER */ :\n                            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES, {\n                                programAddress: instruction.programAddress\n                            });\n                        default:\n                            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE, {\n                                programAddress: instruction.programAddress\n                            });\n                    }\n                }\n                if (entry[TYPE] === 2 /* STATIC */ ) {\n                    return entry;\n                }\n            }\n            return {\n                [TYPE]: 2 /* STATIC */ ,\n                role: _solana_instructions__WEBPACK_IMPORTED_MODULE_6__.AccountRole.READONLY\n            };\n        });\n        let addressComparator;\n        if (!instruction.accounts) {\n            continue;\n        }\n        for (const account of instruction.accounts){\n            upsert(addressMap, account.address, (entry)=>{\n                const { // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                address: _, ...accountMeta } = account;\n                if (TYPE in entry) {\n                    switch(entry[TYPE]){\n                        case 0 /* FEE_PAYER */ :\n                            return entry;\n                        case 1 /* LOOKUP_TABLE */ :\n                            {\n                                const nextRole = (0,_solana_instructions__WEBPACK_IMPORTED_MODULE_6__.mergeRoles)(entry.role, accountMeta.role);\n                                if (\"lookupTableAddress\" in accountMeta) {\n                                    const shouldReplaceEntry = // Consider using the new LOOKUP_TABLE if its address is different...\n                                    entry.lookupTableAddress !== accountMeta.lookupTableAddress && // ...and sorts before the existing one.\n                                    (addressComparator ||= (0,_solana_addresses__WEBPACK_IMPORTED_MODULE_5__.getAddressComparator)())(accountMeta.lookupTableAddress, entry.lookupTableAddress) < 0;\n                                    if (shouldReplaceEntry) {\n                                        return {\n                                            [TYPE]: 1 /* LOOKUP_TABLE */ ,\n                                            ...accountMeta,\n                                            role: nextRole\n                                        };\n                                    }\n                                } else if ((0,_solana_instructions__WEBPACK_IMPORTED_MODULE_6__.isSignerRole)(accountMeta.role)) {\n                                    return {\n                                        [TYPE]: 2 /* STATIC */ ,\n                                        role: nextRole\n                                    };\n                                }\n                                if (entry.role !== nextRole) {\n                                    return {\n                                        ...entry,\n                                        role: nextRole\n                                    };\n                                } else {\n                                    return entry;\n                                }\n                            }\n                        case 2 /* STATIC */ :\n                            {\n                                const nextRole = (0,_solana_instructions__WEBPACK_IMPORTED_MODULE_6__.mergeRoles)(entry.role, accountMeta.role);\n                                if (// Check to see if this address represents a program that is invoked\n                                // in this transaction.\n                                addressesOfInvokedPrograms.has(account.address)) {\n                                    if ((0,_solana_instructions__WEBPACK_IMPORTED_MODULE_6__.isWritableRole)(accountMeta.role)) {\n                                        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE, {\n                                            programAddress: account.address\n                                        });\n                                    }\n                                    if (entry.role !== nextRole) {\n                                        return {\n                                            ...entry,\n                                            role: nextRole\n                                        };\n                                    } else {\n                                        return entry;\n                                    }\n                                } else if (\"lookupTableAddress\" in accountMeta && // Static accounts can be 'upgraded' to lookup table accounts as\n                                // long as they are not require to sign the transaction.\n                                !(0,_solana_instructions__WEBPACK_IMPORTED_MODULE_6__.isSignerRole)(entry.role)) {\n                                    return {\n                                        ...accountMeta,\n                                        [TYPE]: 1 /* LOOKUP_TABLE */ ,\n                                        role: nextRole\n                                    };\n                                } else {\n                                    if (entry.role !== nextRole) {\n                                        return {\n                                            ...entry,\n                                            role: nextRole\n                                        };\n                                    } else {\n                                        return entry;\n                                    }\n                                }\n                            }\n                    }\n                }\n                if (\"lookupTableAddress\" in accountMeta) {\n                    return {\n                        ...accountMeta,\n                        [TYPE]: 1 /* LOOKUP_TABLE */ \n                    };\n                } else {\n                    return {\n                        ...accountMeta,\n                        [TYPE]: 2 /* STATIC */ \n                    };\n                }\n            });\n        }\n    }\n    return addressMap;\n}\nfunction getOrderedAccountsFromAddressMap(addressMap) {\n    let addressComparator;\n    const orderedAccounts = Object.entries(addressMap).sort(([leftAddress, leftEntry], [rightAddress, rightEntry])=>{\n        if (leftEntry[TYPE] !== rightEntry[TYPE]) {\n            if (leftEntry[TYPE] === 0 /* FEE_PAYER */ ) {\n                return -1;\n            } else if (rightEntry[TYPE] === 0 /* FEE_PAYER */ ) {\n                return 1;\n            } else if (leftEntry[TYPE] === 2 /* STATIC */ ) {\n                return -1;\n            } else if (rightEntry[TYPE] === 2 /* STATIC */ ) {\n                return 1;\n            }\n        }\n        const leftIsSigner = (0,_solana_instructions__WEBPACK_IMPORTED_MODULE_6__.isSignerRole)(leftEntry.role);\n        if (leftIsSigner !== (0,_solana_instructions__WEBPACK_IMPORTED_MODULE_6__.isSignerRole)(rightEntry.role)) {\n            return leftIsSigner ? -1 : 1;\n        }\n        const leftIsWritable = (0,_solana_instructions__WEBPACK_IMPORTED_MODULE_6__.isWritableRole)(leftEntry.role);\n        if (leftIsWritable !== (0,_solana_instructions__WEBPACK_IMPORTED_MODULE_6__.isWritableRole)(rightEntry.role)) {\n            return leftIsWritable ? -1 : 1;\n        }\n        addressComparator ||= (0,_solana_addresses__WEBPACK_IMPORTED_MODULE_5__.getAddressComparator)();\n        if (leftEntry[TYPE] === 1 /* LOOKUP_TABLE */  && rightEntry[TYPE] === 1 /* LOOKUP_TABLE */  && leftEntry.lookupTableAddress !== rightEntry.lookupTableAddress) {\n            return addressComparator(leftEntry.lookupTableAddress, rightEntry.lookupTableAddress);\n        } else {\n            return addressComparator(leftAddress, rightAddress);\n        }\n    }).map(([address, addressMeta])=>({\n            address,\n            ...addressMeta\n        }));\n    return orderedAccounts;\n}\nfunction getCompiledAddressTableLookups(orderedAccounts) {\n    const index = {};\n    for (const account of orderedAccounts){\n        if (!(\"lookupTableAddress\" in account)) {\n            continue;\n        }\n        const entry = index[account.lookupTableAddress] ||= {\n            readonlyIndexes: [],\n            writableIndexes: []\n        };\n        if (account.role === _solana_instructions__WEBPACK_IMPORTED_MODULE_6__.AccountRole.WRITABLE) {\n            entry.writableIndexes.push(account.addressIndex);\n        } else {\n            entry.readonlyIndexes.push(account.addressIndex);\n        }\n    }\n    return Object.keys(index).sort((0,_solana_addresses__WEBPACK_IMPORTED_MODULE_5__.getAddressComparator)()).map((lookupTableAddress)=>({\n            lookupTableAddress,\n            ...index[lookupTableAddress]\n        }));\n}\nfunction getCompiledMessageHeader(orderedAccounts) {\n    let numReadonlyNonSignerAccounts = 0;\n    let numReadonlySignerAccounts = 0;\n    let numSignerAccounts = 0;\n    for (const account of orderedAccounts){\n        if (\"lookupTableAddress\" in account) {\n            break;\n        }\n        const accountIsWritable = (0,_solana_instructions__WEBPACK_IMPORTED_MODULE_6__.isWritableRole)(account.role);\n        if ((0,_solana_instructions__WEBPACK_IMPORTED_MODULE_6__.isSignerRole)(account.role)) {\n            numSignerAccounts++;\n            if (!accountIsWritable) {\n                numReadonlySignerAccounts++;\n            }\n        } else if (!accountIsWritable) {\n            numReadonlyNonSignerAccounts++;\n        }\n    }\n    return {\n        numReadonlyNonSignerAccounts,\n        numReadonlySignerAccounts,\n        numSignerAccounts\n    };\n}\n// src/compile/instructions.ts\nfunction getAccountIndex(orderedAccounts) {\n    const out = {};\n    for (const [index, account] of orderedAccounts.entries()){\n        out[account.address] = index;\n    }\n    return out;\n}\nfunction getCompiledInstructions(instructions, orderedAccounts) {\n    const accountIndex = getAccountIndex(orderedAccounts);\n    return instructions.map(({ accounts, data, programAddress })=>{\n        return {\n            programAddressIndex: accountIndex[programAddress],\n            ...accounts ? {\n                accountIndices: accounts.map(({ address })=>accountIndex[address])\n            } : null,\n            ...data ? {\n                data\n            } : null\n        };\n    });\n}\n// src/compile/lifetime-token.ts\nfunction getCompiledLifetimeToken(lifetimeConstraint) {\n    if (\"nonce\" in lifetimeConstraint) {\n        return lifetimeConstraint.nonce;\n    }\n    return lifetimeConstraint.blockhash;\n}\n// src/compile/static-accounts.ts\nfunction getCompiledStaticAccounts(orderedAccounts) {\n    const firstLookupTableAccountIndex = orderedAccounts.findIndex((account)=>\"lookupTableAddress\" in account);\n    const orderedStaticAccounts = firstLookupTableAccountIndex === -1 ? orderedAccounts : orderedAccounts.slice(0, firstLookupTableAccountIndex);\n    return orderedStaticAccounts.map(({ address })=>address);\n}\n// src/compile/message.ts\nfunction compileTransactionMessage(transactionMessage) {\n    const addressMap = getAddressMapFromInstructions(transactionMessage.feePayer.address, transactionMessage.instructions);\n    const orderedAccounts = getOrderedAccountsFromAddressMap(addressMap);\n    const lifetimeConstraint = transactionMessage.lifetimeConstraint;\n    return {\n        ...transactionMessage.version !== \"legacy\" ? {\n            addressTableLookups: getCompiledAddressTableLookups(orderedAccounts)\n        } : null,\n        ...lifetimeConstraint ? {\n            lifetimeToken: getCompiledLifetimeToken(lifetimeConstraint)\n        } : null,\n        header: getCompiledMessageHeader(orderedAccounts),\n        instructions: getCompiledInstructions(transactionMessage.instructions, orderedAccounts),\n        staticAccounts: getCompiledStaticAccounts(orderedAccounts),\n        version: transactionMessage.version\n    };\n}\nfunction findAddressInLookupTables(address, role, addressesByLookupTableAddress) {\n    for (const [lookupTableAddress, addresses] of Object.entries(addressesByLookupTableAddress)){\n        for(let i = 0; i < addresses.length; i++){\n            if (address === addresses[i]) {\n                return {\n                    address,\n                    addressIndex: i,\n                    lookupTableAddress,\n                    role\n                };\n            }\n        }\n    }\n}\nfunction compressTransactionMessageUsingAddressLookupTables(transactionMessage, addressesByLookupTableAddress) {\n    const programAddresses = new Set(transactionMessage.instructions.map((ix)=>ix.programAddress));\n    const eligibleLookupAddresses = new Set(Object.values(addressesByLookupTableAddress).flatMap((a)=>a).filter((address)=>!programAddresses.has(address)));\n    const newInstructions = [];\n    let updatedAnyInstructions = false;\n    for (const instruction of transactionMessage.instructions){\n        if (!instruction.accounts) {\n            newInstructions.push(instruction);\n            continue;\n        }\n        const newAccounts = [];\n        let updatedAnyAccounts = false;\n        for (const account of instruction.accounts){\n            if (\"lookupTableAddress\" in account || !eligibleLookupAddresses.has(account.address) || (0,_solana_instructions__WEBPACK_IMPORTED_MODULE_6__.isSignerRole)(account.role)) {\n                newAccounts.push(account);\n                continue;\n            }\n            const lookupMetaAccount = findAddressInLookupTables(account.address, account.role, addressesByLookupTableAddress);\n            newAccounts.push(Object.freeze(lookupMetaAccount));\n            updatedAnyAccounts = true;\n            updatedAnyInstructions = true;\n        }\n        newInstructions.push(Object.freeze(updatedAnyAccounts ? {\n            ...instruction,\n            accounts: newAccounts\n        } : instruction));\n    }\n    return Object.freeze(updatedAnyInstructions ? {\n        ...transactionMessage,\n        instructions: newInstructions\n    } : transactionMessage);\n}\n// src/create-transaction-message.ts\nfunction createTransactionMessage(config) {\n    return Object.freeze({\n        instructions: Object.freeze([]),\n        version: config.version\n    });\n}\nvar RECENT_BLOCKHASHES_SYSVAR_ADDRESS = \"SysvarRecentB1ockHashes11111111111111111111\";\nvar SYSTEM_PROGRAM_ADDRESS = \"11111111111111111111111111111111\";\nfunction createAdvanceNonceAccountInstruction(nonceAccountAddress, nonceAuthorityAddress) {\n    return {\n        accounts: [\n            {\n                address: nonceAccountAddress,\n                role: _solana_instructions__WEBPACK_IMPORTED_MODULE_6__.AccountRole.WRITABLE\n            },\n            {\n                address: RECENT_BLOCKHASHES_SYSVAR_ADDRESS,\n                role: _solana_instructions__WEBPACK_IMPORTED_MODULE_6__.AccountRole.READONLY\n            },\n            {\n                address: nonceAuthorityAddress,\n                role: _solana_instructions__WEBPACK_IMPORTED_MODULE_6__.AccountRole.READONLY_SIGNER\n            }\n        ],\n        data: new Uint8Array([\n            4,\n            0,\n            0,\n            0\n        ]),\n        programAddress: SYSTEM_PROGRAM_ADDRESS\n    };\n}\nfunction isAdvanceNonceAccountInstruction(instruction) {\n    return instruction.programAddress === SYSTEM_PROGRAM_ADDRESS && // Test for `AdvanceNonceAccount` instruction data\n    instruction.data != null && isAdvanceNonceAccountInstructionData(instruction.data) && // Test for exactly 3 accounts\n    instruction.accounts?.length === 3 && // First account is nonce account address\n    instruction.accounts[0].address != null && instruction.accounts[0].role === _solana_instructions__WEBPACK_IMPORTED_MODULE_6__.AccountRole.WRITABLE && // Second account is recent blockhashes sysvar\n    instruction.accounts[1].address === RECENT_BLOCKHASHES_SYSVAR_ADDRESS && instruction.accounts[1].role === _solana_instructions__WEBPACK_IMPORTED_MODULE_6__.AccountRole.READONLY && // Third account is nonce authority account\n    instruction.accounts[2].address != null && (0,_solana_instructions__WEBPACK_IMPORTED_MODULE_6__.isSignerRole)(instruction.accounts[2].role);\n}\nfunction isAdvanceNonceAccountInstructionData(data) {\n    return data.byteLength === 4 && data[0] === 4 && data[1] === 0 && data[2] === 0 && data[3] === 0;\n}\n// src/durable-nonce.ts\nfunction isTransactionMessageWithDurableNonceLifetime(transactionMessage) {\n    return \"lifetimeConstraint\" in transactionMessage && typeof transactionMessage.lifetimeConstraint.nonce === \"string\" && transactionMessage.instructions[0] != null && isAdvanceNonceAccountInstruction(transactionMessage.instructions[0]);\n}\nfunction assertIsTransactionMessageWithDurableNonceLifetime(transactionMessage) {\n    if (!isTransactionMessageWithDurableNonceLifetime(transactionMessage)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME);\n    }\n}\nfunction isAdvanceNonceAccountInstructionForNonce(instruction, nonceAccountAddress, nonceAuthorityAddress) {\n    return instruction.accounts[0].address === nonceAccountAddress && instruction.accounts[2].address === nonceAuthorityAddress;\n}\nfunction setTransactionMessageLifetimeUsingDurableNonce({ nonce, nonceAccountAddress, nonceAuthorityAddress }, transactionMessage) {\n    let newInstructions;\n    const firstInstruction = transactionMessage.instructions[0];\n    if (firstInstruction && isAdvanceNonceAccountInstruction(firstInstruction)) {\n        if (isAdvanceNonceAccountInstructionForNonce(firstInstruction, nonceAccountAddress, nonceAuthorityAddress)) {\n            if (isTransactionMessageWithDurableNonceLifetime(transactionMessage) && transactionMessage.lifetimeConstraint.nonce === nonce) {\n                return transactionMessage;\n            } else {\n                newInstructions = [\n                    firstInstruction,\n                    ...transactionMessage.instructions.slice(1)\n                ];\n            }\n        } else {\n            newInstructions = [\n                Object.freeze(createAdvanceNonceAccountInstruction(nonceAccountAddress, nonceAuthorityAddress)),\n                ...transactionMessage.instructions.slice(1)\n            ];\n        }\n    } else {\n        newInstructions = [\n            Object.freeze(createAdvanceNonceAccountInstruction(nonceAccountAddress, nonceAuthorityAddress)),\n            ...transactionMessage.instructions\n        ];\n    }\n    return Object.freeze({\n        ...transactionMessage,\n        instructions: Object.freeze(newInstructions),\n        lifetimeConstraint: Object.freeze({\n            nonce\n        })\n    });\n}\n// src/fee-payer.ts\nfunction setTransactionMessageFeePayer(feePayer, transactionMessage) {\n    if (\"feePayer\" in transactionMessage && feePayer === transactionMessage.feePayer?.address && isAddressOnlyFeePayer(transactionMessage.feePayer)) {\n        return transactionMessage;\n    }\n    const out = {\n        ...transactionMessage,\n        feePayer: Object.freeze({\n            address: feePayer\n        })\n    };\n    Object.freeze(out);\n    return out;\n}\nfunction isAddressOnlyFeePayer(feePayer) {\n    return !!feePayer && \"address\" in feePayer && typeof feePayer.address === \"string\" && Object.keys(feePayer).length === 1;\n}\n// src/instructions.ts\nfunction appendTransactionMessageInstruction(instruction, transactionMessage) {\n    return appendTransactionMessageInstructions([\n        instruction\n    ], transactionMessage);\n}\nfunction appendTransactionMessageInstructions(instructions, transactionMessage) {\n    return Object.freeze({\n        ...transactionMessage,\n        instructions: Object.freeze([\n            ...transactionMessage.instructions,\n            ...instructions\n        ])\n    });\n}\nfunction prependTransactionMessageInstruction(instruction, transactionMessage) {\n    return prependTransactionMessageInstructions([\n        instruction\n    ], transactionMessage);\n}\nfunction prependTransactionMessageInstructions(instructions, transactionMessage) {\n    return Object.freeze({\n        ...transactionMessage,\n        instructions: Object.freeze([\n            ...instructions,\n            ...transactionMessage.instructions\n        ])\n    });\n}\n// src/decompile-message.ts\nfunction getAccountMetas(message) {\n    const { header } = message;\n    const numWritableSignerAccounts = header.numSignerAccounts - header.numReadonlySignerAccounts;\n    const numWritableNonSignerAccounts = message.staticAccounts.length - header.numSignerAccounts - header.numReadonlyNonSignerAccounts;\n    const accountMetas = [];\n    let accountIndex = 0;\n    for(let i = 0; i < numWritableSignerAccounts; i++){\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: _solana_instructions__WEBPACK_IMPORTED_MODULE_6__.AccountRole.WRITABLE_SIGNER\n        });\n        accountIndex++;\n    }\n    for(let i = 0; i < header.numReadonlySignerAccounts; i++){\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: _solana_instructions__WEBPACK_IMPORTED_MODULE_6__.AccountRole.READONLY_SIGNER\n        });\n        accountIndex++;\n    }\n    for(let i = 0; i < numWritableNonSignerAccounts; i++){\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: _solana_instructions__WEBPACK_IMPORTED_MODULE_6__.AccountRole.WRITABLE\n        });\n        accountIndex++;\n    }\n    for(let i = 0; i < header.numReadonlyNonSignerAccounts; i++){\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: _solana_instructions__WEBPACK_IMPORTED_MODULE_6__.AccountRole.READONLY\n        });\n        accountIndex++;\n    }\n    return accountMetas;\n}\nfunction getAddressLookupMetas(compiledAddressTableLookups, addressesByLookupTableAddress) {\n    const compiledAddressTableLookupAddresses = compiledAddressTableLookups.map((l)=>l.lookupTableAddress);\n    const missing = compiledAddressTableLookupAddresses.filter((a)=>addressesByLookupTableAddress[a] === void 0);\n    if (missing.length > 0) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING, {\n            lookupTableAddresses: missing\n        });\n    }\n    const readOnlyMetas = [];\n    const writableMetas = [];\n    for (const lookup of compiledAddressTableLookups){\n        const addresses = addressesByLookupTableAddress[lookup.lookupTableAddress];\n        const readonlyIndexes = lookup.readonlyIndexes;\n        const writableIndexes = lookup.writableIndexes;\n        const highestIndex = Math.max(...readonlyIndexes, ...writableIndexes);\n        if (highestIndex >= addresses.length) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE, {\n                highestKnownIndex: addresses.length - 1,\n                highestRequestedIndex: highestIndex,\n                lookupTableAddress: lookup.lookupTableAddress\n            });\n        }\n        const readOnlyForLookup = readonlyIndexes.map((r)=>({\n                address: addresses[r],\n                addressIndex: r,\n                lookupTableAddress: lookup.lookupTableAddress,\n                role: _solana_instructions__WEBPACK_IMPORTED_MODULE_6__.AccountRole.READONLY\n            }));\n        readOnlyMetas.push(...readOnlyForLookup);\n        const writableForLookup = writableIndexes.map((w)=>({\n                address: addresses[w],\n                addressIndex: w,\n                lookupTableAddress: lookup.lookupTableAddress,\n                role: _solana_instructions__WEBPACK_IMPORTED_MODULE_6__.AccountRole.WRITABLE\n            }));\n        writableMetas.push(...writableForLookup);\n    }\n    return [\n        ...writableMetas,\n        ...readOnlyMetas\n    ];\n}\nfunction convertInstruction(instruction, accountMetas) {\n    const programAddress = accountMetas[instruction.programAddressIndex]?.address;\n    if (!programAddress) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND, {\n            index: instruction.programAddressIndex\n        });\n    }\n    const accounts = instruction.accountIndices?.map((accountIndex)=>accountMetas[accountIndex]);\n    const { data } = instruction;\n    return Object.freeze({\n        programAddress,\n        ...accounts && accounts.length ? {\n            accounts: Object.freeze(accounts)\n        } : {},\n        ...data && data.length ? {\n            data\n        } : {}\n    });\n}\nfunction getLifetimeConstraint(messageLifetimeToken, firstInstruction, lastValidBlockHeight) {\n    if (!firstInstruction || !isAdvanceNonceAccountInstruction(firstInstruction)) {\n        return {\n            blockhash: messageLifetimeToken,\n            lastValidBlockHeight: lastValidBlockHeight ?? 2n ** 64n - 1n\n        };\n    } else {\n        const nonceAccountAddress = firstInstruction.accounts[0].address;\n        (0,_solana_addresses__WEBPACK_IMPORTED_MODULE_5__.assertIsAddress)(nonceAccountAddress);\n        const nonceAuthorityAddress = firstInstruction.accounts[2].address;\n        (0,_solana_addresses__WEBPACK_IMPORTED_MODULE_5__.assertIsAddress)(nonceAuthorityAddress);\n        return {\n            nonce: messageLifetimeToken,\n            nonceAccountAddress,\n            nonceAuthorityAddress\n        };\n    }\n}\nfunction decompileTransactionMessage(compiledTransactionMessage, config) {\n    const feePayer = compiledTransactionMessage.staticAccounts[0];\n    if (!feePayer) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_1__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_1__.SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING);\n    }\n    const accountMetas = getAccountMetas(compiledTransactionMessage);\n    const accountLookupMetas = \"addressTableLookups\" in compiledTransactionMessage && compiledTransactionMessage.addressTableLookups !== void 0 && compiledTransactionMessage.addressTableLookups.length > 0 ? getAddressLookupMetas(compiledTransactionMessage.addressTableLookups, config?.addressesByLookupTableAddress ?? {}) : [];\n    const transactionMetas = [\n        ...accountMetas,\n        ...accountLookupMetas\n    ];\n    const instructions = compiledTransactionMessage.instructions.map((compiledInstruction)=>convertInstruction(compiledInstruction, transactionMetas));\n    const firstInstruction = instructions[0];\n    const lifetimeConstraint = getLifetimeConstraint(compiledTransactionMessage.lifetimeToken, firstInstruction, config?.lastValidBlockHeight);\n    return (0,_solana_functional__WEBPACK_IMPORTED_MODULE_7__.pipe)(createTransactionMessage({\n        version: compiledTransactionMessage.version\n    }), (m)=>setTransactionMessageFeePayer(feePayer, m), (m)=>instructions.reduce((acc, instruction)=>appendTransactionMessageInstruction(instruction, acc), m), (m)=>\"blockhash\" in lifetimeConstraint ? setTransactionMessageLifetimeUsingBlockhash(lifetimeConstraint, m) : setTransactionMessageLifetimeUsingDurableNonce(lifetimeConstraint, m));\n}\n //# sourceMappingURL=index.node.mjs.map\n //# sourceMappingURL=index.node.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS90cmFuc2FjdGlvbi1tZXNzYWdlcy9kaXN0L2luZGV4Lm5vZGUubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBOHZCO0FBQzlzQjtBQUNnRTtBQUNpRjtBQUNKO0FBQ2pGO0FBQ2Y7QUFDbkQ7QUFFMUMsbUJBQW1CO0FBQ25CLFNBQVMyQywwQ0FBMENDLGtCQUFrQjtJQUNuRSxPQUFPLHdCQUF3QkEsc0JBQXNCLE9BQU9BLG1CQUFtQkMsa0JBQWtCLENBQUNDLFNBQVMsS0FBSyxZQUFZLE9BQU9GLG1CQUFtQkMsa0JBQWtCLENBQUNFLG9CQUFvQixLQUFLLFlBQVluQyw4REFBV0EsQ0FBQ2dDLG1CQUFtQkMsa0JBQWtCLENBQUNDLFNBQVM7QUFDM1E7QUFDQSxTQUFTRSxnREFBZ0RKLGtCQUFrQjtJQUN6RSxJQUFJLENBQUNELDBDQUEwQ0MscUJBQXFCO1FBQ2xFLE1BQU0sSUFBSTVDLHVEQUFXQSxDQUFDQyxrR0FBc0RBO0lBQzlFO0FBQ0Y7QUFDQSxTQUFTZ0QsNENBQTRDQywyQkFBMkIsRUFBRU4sa0JBQWtCO0lBQ2xHLElBQUksd0JBQXdCQSxzQkFBc0JBLG1CQUFtQkMsa0JBQWtCLElBQUksZUFBZUQsbUJBQW1CQyxrQkFBa0IsSUFBSUQsbUJBQW1CQyxrQkFBa0IsQ0FBQ0MsU0FBUyxLQUFLSSw0QkFBNEJKLFNBQVMsSUFBSUYsbUJBQW1CQyxrQkFBa0IsQ0FBQ0Usb0JBQW9CLEtBQUtHLDRCQUE0Qkgsb0JBQW9CLEVBQUU7UUFDL1YsT0FBT0g7SUFDVDtJQUNBLE9BQU9PLE9BQU9DLE1BQU0sQ0FBQztRQUNuQixHQUFHUixrQkFBa0I7UUFDckJDLG9CQUFvQk0sT0FBT0MsTUFBTSxDQUFDRjtJQUNwQztBQUNGO0FBQ0EsU0FBU0csc0JBQXNCQyxTQUFTLEVBQUVDLFNBQVMsRUFBRUMsYUFBYUQsU0FBUztJQUN6RSxJQUFJLENBQUNBLFVBQVVFLEtBQUss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SUFFRixDQUFDQSxJQUFNLGVBQWU5TyxxQkFBcUJJLDRDQUE0Q0osb0JBQW9COE8sS0FBS3RDLCtDQUErQ3hNLG9CQUFvQjhPO0FBRXZMO0FBRSsyQixDQUMvMkIsdUNBQXVDO0NBQ3ZDLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsYXctd29ya3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS90cmFuc2FjdGlvbi1tZXNzYWdlcy9kaXN0L2luZGV4Lm5vZGUubWpzPzlkZTgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU29sYW5hRXJyb3IsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0VYUEVDVEVEX0JMT0NLSEFTSF9MSUZFVElNRSwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fVkVSU0lPTl9OVU1CRVJfT1VUX09GX1JBTkdFLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19WRVJTSU9OX05VTUJFUl9OT1RfU1VQUE9SVEVELCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19FWFBFQ1RFRF9OT05DRV9MSUZFVElNRSwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkFJTEVEX1RPX0RFQ09NUElMRV9GRUVfUEFZRVJfTUlTU0lORywgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkFJTEVEX1RPX0RFQ09NUElMRV9BRERSRVNTX0xPT0tVUF9UQUJMRV9DT05URU5UU19NSVNTSU5HLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GQUlMRURfVE9fREVDT01QSUxFX0FERFJFU1NfTE9PS1VQX1RBQkxFX0lOREVYX09VVF9PRl9SQU5HRSwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkFJTEVEX1RPX0RFQ09NUElMRV9JTlNUUlVDVElPTl9QUk9HUkFNX0FERFJFU1NfTk9UX0ZPVU5ELCBTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9TVFJJTkdfRk9SX0JBU0UsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0lOVk9LRURfUFJPR1JBTVNfTVVTVF9OT1RfQkVfV1JJVEFCTEUsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0lOVk9LRURfUFJPR1JBTVNfQ0FOTk9UX1BBWV9GRUVTIH0gZnJvbSAnQHNvbGFuYS9lcnJvcnMnO1xuaW1wb3J0IHsgaXNCbG9ja2hhc2ggfSBmcm9tICdAc29sYW5hL3JwYy10eXBlcyc7XG5pbXBvcnQgeyBnZXRBZGRyZXNzRGVjb2RlciwgZ2V0QWRkcmVzc0NvbXBhcmF0b3IsIGFzc2VydElzQWRkcmVzcywgZ2V0QWRkcmVzc0VuY29kZXIgfSBmcm9tICdAc29sYW5hL2FkZHJlc3Nlcyc7XG5pbXBvcnQgeyBjcmVhdGVFbmNvZGVyLCBjcmVhdGVEZWNvZGVyLCBjb21iaW5lQ29kZWMsIHRyYW5zZm9ybURlY29kZXIsIHRyYW5zZm9ybUVuY29kZXIsIGZpeERlY29kZXJTaXplLCBmaXhFbmNvZGVyU2l6ZSwgYWRkRGVjb2RlclNpemVQcmVmaXgsIGFkZEVuY29kZXJTaXplUHJlZml4IH0gZnJvbSAnQHNvbGFuYS9jb2RlY3MtY29yZSc7XG5pbXBvcnQgeyBnZXRTdHJ1Y3REZWNvZGVyLCBnZXRTdHJ1Y3RFbmNvZGVyLCBnZXRBcnJheURlY29kZXIsIGdldFVuaW9uRW5jb2RlciwgZ2V0Q29uc3RhbnRFbmNvZGVyLCBnZXRBcnJheUVuY29kZXIsIGdldEJ5dGVzRGVjb2RlciwgZ2V0Qnl0ZXNFbmNvZGVyIH0gZnJvbSAnQHNvbGFuYS9jb2RlY3MtZGF0YS1zdHJ1Y3R1cmVzJztcbmltcG9ydCB7IGdldFNob3J0VTE2RGVjb2RlciwgZ2V0U2hvcnRVMTZFbmNvZGVyLCBnZXRVOERlY29kZXIsIGdldFU4RW5jb2RlciB9IGZyb20gJ0Bzb2xhbmEvY29kZWNzLW51bWJlcnMnO1xuaW1wb3J0IHsgaXNTaWduZXJSb2xlLCBBY2NvdW50Um9sZSwgaXNXcml0YWJsZVJvbGUsIG1lcmdlUm9sZXMgfSBmcm9tICdAc29sYW5hL2luc3RydWN0aW9ucyc7XG5pbXBvcnQgeyBwaXBlIH0gZnJvbSAnQHNvbGFuYS9mdW5jdGlvbmFsJztcblxuLy8gc3JjL2Jsb2NraGFzaC50c1xuZnVuY3Rpb24gaXNUcmFuc2FjdGlvbk1lc3NhZ2VXaXRoQmxvY2toYXNoTGlmZXRpbWUodHJhbnNhY3Rpb25NZXNzYWdlKSB7XG4gIHJldHVybiBcImxpZmV0aW1lQ29uc3RyYWludFwiIGluIHRyYW5zYWN0aW9uTWVzc2FnZSAmJiB0eXBlb2YgdHJhbnNhY3Rpb25NZXNzYWdlLmxpZmV0aW1lQ29uc3RyYWludC5ibG9ja2hhc2ggPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHRyYW5zYWN0aW9uTWVzc2FnZS5saWZldGltZUNvbnN0cmFpbnQubGFzdFZhbGlkQmxvY2tIZWlnaHQgPT09IFwiYmlnaW50XCIgJiYgaXNCbG9ja2hhc2godHJhbnNhY3Rpb25NZXNzYWdlLmxpZmV0aW1lQ29uc3RyYWludC5ibG9ja2hhc2gpO1xufVxuZnVuY3Rpb24gYXNzZXJ0SXNUcmFuc2FjdGlvbk1lc3NhZ2VXaXRoQmxvY2toYXNoTGlmZXRpbWUodHJhbnNhY3Rpb25NZXNzYWdlKSB7XG4gIGlmICghaXNUcmFuc2FjdGlvbk1lc3NhZ2VXaXRoQmxvY2toYXNoTGlmZXRpbWUodHJhbnNhY3Rpb25NZXNzYWdlKSkge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19FWFBFQ1RFRF9CTE9DS0hBU0hfTElGRVRJTUUpO1xuICB9XG59XG5mdW5jdGlvbiBzZXRUcmFuc2FjdGlvbk1lc3NhZ2VMaWZldGltZVVzaW5nQmxvY2toYXNoKGJsb2NraGFzaExpZmV0aW1lQ29uc3RyYWludCwgdHJhbnNhY3Rpb25NZXNzYWdlKSB7XG4gIGlmIChcImxpZmV0aW1lQ29uc3RyYWludFwiIGluIHRyYW5zYWN0aW9uTWVzc2FnZSAmJiB0cmFuc2FjdGlvbk1lc3NhZ2UubGlmZXRpbWVDb25zdHJhaW50ICYmIFwiYmxvY2toYXNoXCIgaW4gdHJhbnNhY3Rpb25NZXNzYWdlLmxpZmV0aW1lQ29uc3RyYWludCAmJiB0cmFuc2FjdGlvbk1lc3NhZ2UubGlmZXRpbWVDb25zdHJhaW50LmJsb2NraGFzaCA9PT0gYmxvY2toYXNoTGlmZXRpbWVDb25zdHJhaW50LmJsb2NraGFzaCAmJiB0cmFuc2FjdGlvbk1lc3NhZ2UubGlmZXRpbWVDb25zdHJhaW50Lmxhc3RWYWxpZEJsb2NrSGVpZ2h0ID09PSBibG9ja2hhc2hMaWZldGltZUNvbnN0cmFpbnQubGFzdFZhbGlkQmxvY2tIZWlnaHQpIHtcbiAgICByZXR1cm4gdHJhbnNhY3Rpb25NZXNzYWdlO1xuICB9XG4gIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAuLi50cmFuc2FjdGlvbk1lc3NhZ2UsXG4gICAgbGlmZXRpbWVDb25zdHJhaW50OiBPYmplY3QuZnJlZXplKGJsb2NraGFzaExpZmV0aW1lQ29uc3RyYWludClcbiAgfSk7XG59XG5mdW5jdGlvbiBhc3NlcnRWYWxpZEJhc2VTdHJpbmcoYWxwaGFiZXQ0LCB0ZXN0VmFsdWUsIGdpdmVuVmFsdWUgPSB0ZXN0VmFsdWUpIHtcbiAgaWYgKCF0ZXN0VmFsdWUubWF0Y2gobmV3IFJlZ0V4cChgXlske2FscGhhYmV0NH1dKiRgKSkpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfU1RSSU5HX0ZPUl9CQVNFLCB7XG4gICAgICBhbHBoYWJldDogYWxwaGFiZXQ0LFxuICAgICAgYmFzZTogYWxwaGFiZXQ0Lmxlbmd0aCxcbiAgICAgIHZhbHVlOiBnaXZlblZhbHVlXG4gICAgfSk7XG4gIH1cbn1cbnZhciBnZXRCYXNlWEVuY29kZXIgPSAoYWxwaGFiZXQ0KSA9PiB7XG4gIHJldHVybiBjcmVhdGVFbmNvZGVyKHtcbiAgICBnZXRTaXplRnJvbVZhbHVlOiAodmFsdWUpID0+IHtcbiAgICAgIGNvbnN0IFtsZWFkaW5nWmVyb2VzLCB0YWlsQ2hhcnNdID0gcGFydGl0aW9uTGVhZGluZ1plcm9lcyh2YWx1ZSwgYWxwaGFiZXQ0WzBdKTtcbiAgICAgIGlmICghdGFpbENoYXJzKSByZXR1cm4gdmFsdWUubGVuZ3RoO1xuICAgICAgY29uc3QgYmFzZTEwTnVtYmVyID0gZ2V0QmlnSW50RnJvbUJhc2VYKHRhaWxDaGFycywgYWxwaGFiZXQ0KTtcbiAgICAgIHJldHVybiBsZWFkaW5nWmVyb2VzLmxlbmd0aCArIE1hdGguY2VpbChiYXNlMTBOdW1iZXIudG9TdHJpbmcoMTYpLmxlbmd0aCAvIDIpO1xuICAgIH0sXG4gICAgd3JpdGUodmFsdWUsIGJ5dGVzLCBvZmZzZXQpIHtcbiAgICAgIGFzc2VydFZhbGlkQmFzZVN0cmluZyhhbHBoYWJldDQsIHZhbHVlKTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gXCJcIikgcmV0dXJuIG9mZnNldDtcbiAgICAgIGNvbnN0IFtsZWFkaW5nWmVyb2VzLCB0YWlsQ2hhcnNdID0gcGFydGl0aW9uTGVhZGluZ1plcm9lcyh2YWx1ZSwgYWxwaGFiZXQ0WzBdKTtcbiAgICAgIGlmICghdGFpbENoYXJzKSB7XG4gICAgICAgIGJ5dGVzLnNldChuZXcgVWludDhBcnJheShsZWFkaW5nWmVyb2VzLmxlbmd0aCkuZmlsbCgwKSwgb2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIG9mZnNldCArIGxlYWRpbmdaZXJvZXMubGVuZ3RoO1xuICAgICAgfVxuICAgICAgbGV0IGJhc2UxME51bWJlciA9IGdldEJpZ0ludEZyb21CYXNlWCh0YWlsQ2hhcnMsIGFscGhhYmV0NCk7XG4gICAgICBjb25zdCB0YWlsQnl0ZXMgPSBbXTtcbiAgICAgIHdoaWxlIChiYXNlMTBOdW1iZXIgPiAwbikge1xuICAgICAgICB0YWlsQnl0ZXMudW5zaGlmdChOdW1iZXIoYmFzZTEwTnVtYmVyICUgMjU2bikpO1xuICAgICAgICBiYXNlMTBOdW1iZXIgLz0gMjU2bjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJ5dGVzVG9BZGQgPSBbLi4uQXJyYXkobGVhZGluZ1plcm9lcy5sZW5ndGgpLmZpbGwoMCksIC4uLnRhaWxCeXRlc107XG4gICAgICBieXRlcy5zZXQoYnl0ZXNUb0FkZCwgb2Zmc2V0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgKyBieXRlc1RvQWRkLmxlbmd0aDtcbiAgICB9XG4gIH0pO1xufTtcbnZhciBnZXRCYXNlWERlY29kZXIgPSAoYWxwaGFiZXQ0KSA9PiB7XG4gIHJldHVybiBjcmVhdGVEZWNvZGVyKHtcbiAgICByZWFkKHJhd0J5dGVzLCBvZmZzZXQpIHtcbiAgICAgIGNvbnN0IGJ5dGVzID0gb2Zmc2V0ID09PSAwID8gcmF3Qnl0ZXMgOiByYXdCeXRlcy5zbGljZShvZmZzZXQpO1xuICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIFtcIlwiLCAwXTtcbiAgICAgIGxldCB0cmFpbEluZGV4ID0gYnl0ZXMuZmluZEluZGV4KChuKSA9PiBuICE9PSAwKTtcbiAgICAgIHRyYWlsSW5kZXggPSB0cmFpbEluZGV4ID09PSAtMSA/IGJ5dGVzLmxlbmd0aCA6IHRyYWlsSW5kZXg7XG4gICAgICBjb25zdCBsZWFkaW5nWmVyb2VzID0gYWxwaGFiZXQ0WzBdLnJlcGVhdCh0cmFpbEluZGV4KTtcbiAgICAgIGlmICh0cmFpbEluZGV4ID09PSBieXRlcy5sZW5ndGgpIHJldHVybiBbbGVhZGluZ1plcm9lcywgcmF3Qnl0ZXMubGVuZ3RoXTtcbiAgICAgIGNvbnN0IGJhc2UxME51bWJlciA9IGJ5dGVzLnNsaWNlKHRyYWlsSW5kZXgpLnJlZHVjZSgoc3VtLCBieXRlKSA9PiBzdW0gKiAyNTZuICsgQmlnSW50KGJ5dGUpLCAwbik7XG4gICAgICBjb25zdCB0YWlsQ2hhcnMgPSBnZXRCYXNlWEZyb21CaWdJbnQoYmFzZTEwTnVtYmVyLCBhbHBoYWJldDQpO1xuICAgICAgcmV0dXJuIFtsZWFkaW5nWmVyb2VzICsgdGFpbENoYXJzLCByYXdCeXRlcy5sZW5ndGhdO1xuICAgIH1cbiAgfSk7XG59O1xuZnVuY3Rpb24gcGFydGl0aW9uTGVhZGluZ1plcm9lcyh2YWx1ZSwgemVyb0NoYXJhY3Rlcikge1xuICBjb25zdCBbbGVhZGluZ1plcm9zLCB0YWlsQ2hhcnNdID0gdmFsdWUuc3BsaXQobmV3IFJlZ0V4cChgKCg/ISR7emVyb0NoYXJhY3Rlcn0pLiopYCkpO1xuICByZXR1cm4gW2xlYWRpbmdaZXJvcywgdGFpbENoYXJzXTtcbn1cbmZ1bmN0aW9uIGdldEJpZ0ludEZyb21CYXNlWCh2YWx1ZSwgYWxwaGFiZXQ0KSB7XG4gIGNvbnN0IGJhc2UgPSBCaWdJbnQoYWxwaGFiZXQ0Lmxlbmd0aCk7XG4gIGxldCBzdW0gPSAwbjtcbiAgZm9yIChjb25zdCBjaGFyIG9mIHZhbHVlKSB7XG4gICAgc3VtICo9IGJhc2U7XG4gICAgc3VtICs9IEJpZ0ludChhbHBoYWJldDQuaW5kZXhPZihjaGFyKSk7XG4gIH1cbiAgcmV0dXJuIHN1bTtcbn1cbmZ1bmN0aW9uIGdldEJhc2VYRnJvbUJpZ0ludCh2YWx1ZSwgYWxwaGFiZXQ0KSB7XG4gIGNvbnN0IGJhc2UgPSBCaWdJbnQoYWxwaGFiZXQ0Lmxlbmd0aCk7XG4gIGNvbnN0IHRhaWxDaGFycyA9IFtdO1xuICB3aGlsZSAodmFsdWUgPiAwbikge1xuICAgIHRhaWxDaGFycy51bnNoaWZ0KGFscGhhYmV0NFtOdW1iZXIodmFsdWUgJSBiYXNlKV0pO1xuICAgIHZhbHVlIC89IGJhc2U7XG4gIH1cbiAgcmV0dXJuIHRhaWxDaGFycy5qb2luKFwiXCIpO1xufVxudmFyIGFscGhhYmV0MiA9IFwiMTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5elwiO1xudmFyIGdldEJhc2U1OEVuY29kZXIgPSAoKSA9PiBnZXRCYXNlWEVuY29kZXIoYWxwaGFiZXQyKTtcbnZhciBnZXRCYXNlNThEZWNvZGVyID0gKCkgPT4gZ2V0QmFzZVhEZWNvZGVyKGFscGhhYmV0Mik7XG52YXIgbWVtb2l6ZWRBZGRyZXNzVGFibGVMb29rdXBFbmNvZGVyO1xuZnVuY3Rpb24gZ2V0QWRkcmVzc1RhYmxlTG9va3VwRW5jb2RlcigpIHtcbiAgaWYgKCFtZW1vaXplZEFkZHJlc3NUYWJsZUxvb2t1cEVuY29kZXIpIHtcbiAgICBjb25zdCBpbmRleEVuY29kZXIgPSBnZXRBcnJheUVuY29kZXIoZ2V0VThFbmNvZGVyKCksIHsgc2l6ZTogZ2V0U2hvcnRVMTZFbmNvZGVyKCkgfSk7XG4gICAgbWVtb2l6ZWRBZGRyZXNzVGFibGVMb29rdXBFbmNvZGVyID0gZ2V0U3RydWN0RW5jb2RlcihbXG4gICAgICBbXCJsb29rdXBUYWJsZUFkZHJlc3NcIiwgZ2V0QWRkcmVzc0VuY29kZXIoKV0sXG4gICAgICBbXCJ3cml0YWJsZUluZGV4ZXNcIiwgaW5kZXhFbmNvZGVyXSxcbiAgICAgIFtcInJlYWRvbmx5SW5kZXhlc1wiLCBpbmRleEVuY29kZXJdXG4gICAgXSk7XG4gIH1cbiAgcmV0dXJuIG1lbW9pemVkQWRkcmVzc1RhYmxlTG9va3VwRW5jb2Rlcjtcbn1cbnZhciBtZW1vaXplZEFkZHJlc3NUYWJsZUxvb2t1cERlY29kZXI7XG5mdW5jdGlvbiBnZXRBZGRyZXNzVGFibGVMb29rdXBEZWNvZGVyKCkge1xuICBpZiAoIW1lbW9pemVkQWRkcmVzc1RhYmxlTG9va3VwRGVjb2Rlcikge1xuICAgIGNvbnN0IGluZGV4RW5jb2RlciA9IGdldEFycmF5RGVjb2RlcihnZXRVOERlY29kZXIoKSwgeyBzaXplOiBnZXRTaG9ydFUxNkRlY29kZXIoKSB9KTtcbiAgICBtZW1vaXplZEFkZHJlc3NUYWJsZUxvb2t1cERlY29kZXIgPSBnZXRTdHJ1Y3REZWNvZGVyKFtcbiAgICAgIFtcImxvb2t1cFRhYmxlQWRkcmVzc1wiLCBnZXRBZGRyZXNzRGVjb2RlcigpXSxcbiAgICAgIFtcIndyaXRhYmxlSW5kZXhlc1wiLCBpbmRleEVuY29kZXJdLFxuICAgICAgW1wicmVhZG9ubHlJbmRleGVzXCIsIGluZGV4RW5jb2Rlcl1cbiAgICBdKTtcbiAgfVxuICByZXR1cm4gbWVtb2l6ZWRBZGRyZXNzVGFibGVMb29rdXBEZWNvZGVyO1xufVxudmFyIG1lbW9pemVkVThFbmNvZGVyO1xuZnVuY3Rpb24gZ2V0TWVtb2l6ZWRVOEVuY29kZXIoKSB7XG4gIGlmICghbWVtb2l6ZWRVOEVuY29kZXIpIG1lbW9pemVkVThFbmNvZGVyID0gZ2V0VThFbmNvZGVyKCk7XG4gIHJldHVybiBtZW1vaXplZFU4RW5jb2Rlcjtcbn1cbnZhciBtZW1vaXplZFU4RGVjb2RlcjtcbmZ1bmN0aW9uIGdldE1lbW9pemVkVThEZWNvZGVyKCkge1xuICBpZiAoIW1lbW9pemVkVThEZWNvZGVyKSBtZW1vaXplZFU4RGVjb2RlciA9IGdldFU4RGVjb2RlcigpO1xuICByZXR1cm4gbWVtb2l6ZWRVOERlY29kZXI7XG59XG5mdW5jdGlvbiBnZXRNZXNzYWdlSGVhZGVyRW5jb2RlcigpIHtcbiAgcmV0dXJuIGdldFN0cnVjdEVuY29kZXIoW1xuICAgIFtcIm51bVNpZ25lckFjY291bnRzXCIsIGdldE1lbW9pemVkVThFbmNvZGVyKCldLFxuICAgIFtcIm51bVJlYWRvbmx5U2lnbmVyQWNjb3VudHNcIiwgZ2V0TWVtb2l6ZWRVOEVuY29kZXIoKV0sXG4gICAgW1wibnVtUmVhZG9ubHlOb25TaWduZXJBY2NvdW50c1wiLCBnZXRNZW1vaXplZFU4RW5jb2RlcigpXVxuICBdKTtcbn1cbmZ1bmN0aW9uIGdldE1lc3NhZ2VIZWFkZXJEZWNvZGVyKCkge1xuICByZXR1cm4gZ2V0U3RydWN0RGVjb2RlcihbXG4gICAgW1wibnVtU2lnbmVyQWNjb3VudHNcIiwgZ2V0TWVtb2l6ZWRVOERlY29kZXIoKV0sXG4gICAgW1wibnVtUmVhZG9ubHlTaWduZXJBY2NvdW50c1wiLCBnZXRNZW1vaXplZFU4RGVjb2RlcigpXSxcbiAgICBbXCJudW1SZWFkb25seU5vblNpZ25lckFjY291bnRzXCIsIGdldE1lbW9pemVkVThEZWNvZGVyKCldXG4gIF0pO1xufVxudmFyIG1lbW9pemVkR2V0SW5zdHJ1Y3Rpb25FbmNvZGVyO1xuZnVuY3Rpb24gZ2V0SW5zdHJ1Y3Rpb25FbmNvZGVyKCkge1xuICBpZiAoIW1lbW9pemVkR2V0SW5zdHJ1Y3Rpb25FbmNvZGVyKSB7XG4gICAgbWVtb2l6ZWRHZXRJbnN0cnVjdGlvbkVuY29kZXIgPSB0cmFuc2Zvcm1FbmNvZGVyKFxuICAgICAgZ2V0U3RydWN0RW5jb2RlcihbXG4gICAgICAgIFtcInByb2dyYW1BZGRyZXNzSW5kZXhcIiwgZ2V0VThFbmNvZGVyKCldLFxuICAgICAgICBbXCJhY2NvdW50SW5kaWNlc1wiLCBnZXRBcnJheUVuY29kZXIoZ2V0VThFbmNvZGVyKCksIHsgc2l6ZTogZ2V0U2hvcnRVMTZFbmNvZGVyKCkgfSldLFxuICAgICAgICBbXCJkYXRhXCIsIGFkZEVuY29kZXJTaXplUHJlZml4KGdldEJ5dGVzRW5jb2RlcigpLCBnZXRTaG9ydFUxNkVuY29kZXIoKSldXG4gICAgICBdKSxcbiAgICAgIC8vIENvbnZlcnQgYW4gaW5zdHJ1Y3Rpb24gdG8gaGF2ZSBhbGwgZmllbGRzIGRlZmluZWRcbiAgICAgIChpbnN0cnVjdGlvbikgPT4ge1xuICAgICAgICBpZiAoaW5zdHJ1Y3Rpb24uYWNjb3VudEluZGljZXMgIT09IHZvaWQgMCAmJiBpbnN0cnVjdGlvbi5kYXRhICE9PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4gaW5zdHJ1Y3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5pbnN0cnVjdGlvbixcbiAgICAgICAgICBhY2NvdW50SW5kaWNlczogaW5zdHJ1Y3Rpb24uYWNjb3VudEluZGljZXMgPz8gW10sXG4gICAgICAgICAgZGF0YTogaW5zdHJ1Y3Rpb24uZGF0YSA/PyBuZXcgVWludDhBcnJheSgwKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIG1lbW9pemVkR2V0SW5zdHJ1Y3Rpb25FbmNvZGVyO1xufVxudmFyIG1lbW9pemVkR2V0SW5zdHJ1Y3Rpb25EZWNvZGVyO1xuZnVuY3Rpb24gZ2V0SW5zdHJ1Y3Rpb25EZWNvZGVyKCkge1xuICBpZiAoIW1lbW9pemVkR2V0SW5zdHJ1Y3Rpb25EZWNvZGVyKSB7XG4gICAgbWVtb2l6ZWRHZXRJbnN0cnVjdGlvbkRlY29kZXIgPSB0cmFuc2Zvcm1EZWNvZGVyKFxuICAgICAgZ2V0U3RydWN0RGVjb2RlcihbXG4gICAgICAgIFtcInByb2dyYW1BZGRyZXNzSW5kZXhcIiwgZ2V0VThEZWNvZGVyKCldLFxuICAgICAgICBbXCJhY2NvdW50SW5kaWNlc1wiLCBnZXRBcnJheURlY29kZXIoZ2V0VThEZWNvZGVyKCksIHsgc2l6ZTogZ2V0U2hvcnRVMTZEZWNvZGVyKCkgfSldLFxuICAgICAgICBbXG4gICAgICAgICAgXCJkYXRhXCIsXG4gICAgICAgICAgYWRkRGVjb2RlclNpemVQcmVmaXgoZ2V0Qnl0ZXNEZWNvZGVyKCksIGdldFNob3J0VTE2RGVjb2RlcigpKVxuICAgICAgICBdXG4gICAgICBdKSxcbiAgICAgIC8vIENvbnZlcnQgYW4gaW5zdHJ1Y3Rpb24gdG8gZXhjbHVkZSBvcHRpb25hbCBmaWVsZHMgaWYgdGhleSBhcmUgZW1wdHlcbiAgICAgIChpbnN0cnVjdGlvbikgPT4ge1xuICAgICAgICBpZiAoaW5zdHJ1Y3Rpb24uYWNjb3VudEluZGljZXMubGVuZ3RoICYmIGluc3RydWN0aW9uLmRhdGEuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBpbnN0cnVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGFjY291bnRJbmRpY2VzLCBkYXRhLCAuLi5yZXN0IH0gPSBpbnN0cnVjdGlvbjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5yZXN0LFxuICAgICAgICAgIC4uLmFjY291bnRJbmRpY2VzLmxlbmd0aCA/IHsgYWNjb3VudEluZGljZXMgfSA6IG51bGwsXG4gICAgICAgICAgLi4uZGF0YS5ieXRlTGVuZ3RoID8geyBkYXRhIH0gOiBudWxsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICByZXR1cm4gbWVtb2l6ZWRHZXRJbnN0cnVjdGlvbkRlY29kZXI7XG59XG5cbi8vIHNyYy90cmFuc2FjdGlvbi1tZXNzYWdlLnRzXG52YXIgTUFYX1NVUFBPUlRFRF9UUkFOU0FDVElPTl9WRVJTSU9OID0gMDtcblxuLy8gc3JjL2NvZGVjcy90cmFuc2FjdGlvbi12ZXJzaW9uLnRzXG52YXIgVkVSU0lPTl9GTEFHX01BU0sgPSAxMjg7XG5mdW5jdGlvbiBnZXRUcmFuc2FjdGlvblZlcnNpb25FbmNvZGVyKCkge1xuICByZXR1cm4gY3JlYXRlRW5jb2Rlcih7XG4gICAgZ2V0U2l6ZUZyb21WYWx1ZTogKHZhbHVlKSA9PiB2YWx1ZSA9PT0gXCJsZWdhY3lcIiA/IDAgOiAxLFxuICAgIG1heFNpemU6IDEsXG4gICAgd3JpdGU6ICh2YWx1ZSwgYnl0ZXMsIG9mZnNldCkgPT4ge1xuICAgICAgaWYgKHZhbHVlID09PSBcImxlZ2FjeVwiKSB7XG4gICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID4gMTI3KSB7XG4gICAgICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19WRVJTSU9OX05VTUJFUl9PVVRfT0ZfUkFOR0UsIHtcbiAgICAgICAgICBhY3R1YWxWZXJzaW9uOiB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA+IE1BWF9TVVBQT1JURURfVFJBTlNBQ1RJT05fVkVSU0lPTikge1xuICAgICAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fVkVSU0lPTl9OVU1CRVJfTk9UX1NVUFBPUlRFRCwge1xuICAgICAgICAgIHVuc3VwcG9ydGVkVmVyc2lvbjogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBieXRlcy5zZXQoW3ZhbHVlIHwgVkVSU0lPTl9GTEFHX01BU0tdLCBvZmZzZXQpO1xuICAgICAgcmV0dXJuIG9mZnNldCArIDE7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGdldFRyYW5zYWN0aW9uVmVyc2lvbkRlY29kZXIoKSB7XG4gIHJldHVybiBjcmVhdGVEZWNvZGVyKHtcbiAgICBtYXhTaXplOiAxLFxuICAgIHJlYWQ6IChieXRlcywgb2Zmc2V0KSA9PiB7XG4gICAgICBjb25zdCBmaXJzdEJ5dGUgPSBieXRlc1tvZmZzZXRdO1xuICAgICAgaWYgKChmaXJzdEJ5dGUgJiBWRVJTSU9OX0ZMQUdfTUFTSykgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFtcImxlZ2FjeVwiLCBvZmZzZXRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9IGZpcnN0Qnl0ZSBeIFZFUlNJT05fRkxBR19NQVNLO1xuICAgICAgICBpZiAodmVyc2lvbiA+IE1BWF9TVVBQT1JURURfVFJBTlNBQ1RJT05fVkVSU0lPTikge1xuICAgICAgICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19WRVJTSU9OX05VTUJFUl9OT1RfU1VQUE9SVEVELCB7XG4gICAgICAgICAgICB1bnN1cHBvcnRlZFZlcnNpb246IHZlcnNpb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3ZlcnNpb24sIG9mZnNldCArIDFdO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRUcmFuc2FjdGlvblZlcnNpb25Db2RlYygpIHtcbiAgcmV0dXJuIGNvbWJpbmVDb2RlYyhnZXRUcmFuc2FjdGlvblZlcnNpb25FbmNvZGVyKCksIGdldFRyYW5zYWN0aW9uVmVyc2lvbkRlY29kZXIoKSk7XG59XG5cbi8vIHNyYy9jb2RlY3MvbWVzc2FnZS50c1xuZnVuY3Rpb24gZ2V0Q29tcGlsZWRNZXNzYWdlTGVnYWN5RW5jb2RlcigpIHtcbiAgcmV0dXJuIGdldFN0cnVjdEVuY29kZXIoZ2V0UHJlbHVkZVN0cnVjdEVuY29kZXJUdXBsZSgpKTtcbn1cbmZ1bmN0aW9uIGdldENvbXBpbGVkTWVzc2FnZVZlcnNpb25lZEVuY29kZXIoKSB7XG4gIHJldHVybiB0cmFuc2Zvcm1FbmNvZGVyKFxuICAgIGdldFN0cnVjdEVuY29kZXIoW1xuICAgICAgLi4uZ2V0UHJlbHVkZVN0cnVjdEVuY29kZXJUdXBsZSgpLFxuICAgICAgW1wiYWRkcmVzc1RhYmxlTG9va3Vwc1wiLCBnZXRBZGRyZXNzVGFibGVMb29rdXBBcnJheUVuY29kZXIoKV1cbiAgICBdKSxcbiAgICAodmFsdWUpID0+IHtcbiAgICAgIGlmICh2YWx1ZS52ZXJzaW9uID09PSBcImxlZ2FjeVwiKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnZhbHVlLFxuICAgICAgICBhZGRyZXNzVGFibGVMb29rdXBzOiB2YWx1ZS5hZGRyZXNzVGFibGVMb29rdXBzID8/IFtdXG4gICAgICB9O1xuICAgIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIGdldFByZWx1ZGVTdHJ1Y3RFbmNvZGVyVHVwbGUoKSB7XG4gIGNvbnN0IGxpZmV0aW1lVG9rZW5FbmNvZGVyID0gZ2V0VW5pb25FbmNvZGVyKFxuICAgIFtcbiAgICAgIC8vIFVzZSBhIDMyLWJ5dGUgY29uc3RhbnQgZW5jb2RlciBmb3IgYSBtaXNzaW5nIGxpZmV0aW1lIHRva2VuIChpbmRleCAwKS5cbiAgICAgIGdldENvbnN0YW50RW5jb2RlcihuZXcgVWludDhBcnJheSgzMikpLFxuICAgICAgLy8gVXNlIGEgMzItYnl0ZSBiYXNlNTggZW5jb2RlciBmb3IgYSB2YWxpZCBsaWZldGltZSB0b2tlbiAoaW5kZXggMSkuXG4gICAgICBmaXhFbmNvZGVyU2l6ZShnZXRCYXNlNThFbmNvZGVyKCksIDMyKVxuICAgIF0sXG4gICAgKHZhbHVlKSA9PiB2YWx1ZSA9PT0gdm9pZCAwID8gMCA6IDFcbiAgKTtcbiAgcmV0dXJuIFtcbiAgICBbXCJ2ZXJzaW9uXCIsIGdldFRyYW5zYWN0aW9uVmVyc2lvbkVuY29kZXIoKV0sXG4gICAgW1wiaGVhZGVyXCIsIGdldE1lc3NhZ2VIZWFkZXJFbmNvZGVyKCldLFxuICAgIFtcInN0YXRpY0FjY291bnRzXCIsIGdldEFycmF5RW5jb2RlcihnZXRBZGRyZXNzRW5jb2RlcigpLCB7IHNpemU6IGdldFNob3J0VTE2RW5jb2RlcigpIH0pXSxcbiAgICBbXCJsaWZldGltZVRva2VuXCIsIGxpZmV0aW1lVG9rZW5FbmNvZGVyXSxcbiAgICBbXCJpbnN0cnVjdGlvbnNcIiwgZ2V0QXJyYXlFbmNvZGVyKGdldEluc3RydWN0aW9uRW5jb2RlcigpLCB7IHNpemU6IGdldFNob3J0VTE2RW5jb2RlcigpIH0pXVxuICBdO1xufVxuZnVuY3Rpb24gZ2V0UHJlbHVkZVN0cnVjdERlY29kZXJUdXBsZSgpIHtcbiAgcmV0dXJuIFtcbiAgICBbXCJ2ZXJzaW9uXCIsIGdldFRyYW5zYWN0aW9uVmVyc2lvbkRlY29kZXIoKV0sXG4gICAgW1wiaGVhZGVyXCIsIGdldE1lc3NhZ2VIZWFkZXJEZWNvZGVyKCldLFxuICAgIFtcInN0YXRpY0FjY291bnRzXCIsIGdldEFycmF5RGVjb2RlcihnZXRBZGRyZXNzRGVjb2RlcigpLCB7IHNpemU6IGdldFNob3J0VTE2RGVjb2RlcigpIH0pXSxcbiAgICBbXCJsaWZldGltZVRva2VuXCIsIGZpeERlY29kZXJTaXplKGdldEJhc2U1OERlY29kZXIoKSwgMzIpXSxcbiAgICBbXCJpbnN0cnVjdGlvbnNcIiwgZ2V0QXJyYXlEZWNvZGVyKGdldEluc3RydWN0aW9uRGVjb2RlcigpLCB7IHNpemU6IGdldFNob3J0VTE2RGVjb2RlcigpIH0pXSxcbiAgICBbXCJhZGRyZXNzVGFibGVMb29rdXBzXCIsIGdldEFkZHJlc3NUYWJsZUxvb2t1cEFycmF5RGVjb2RlcigpXVxuICBdO1xufVxuZnVuY3Rpb24gZ2V0QWRkcmVzc1RhYmxlTG9va3VwQXJyYXlFbmNvZGVyKCkge1xuICByZXR1cm4gZ2V0QXJyYXlFbmNvZGVyKGdldEFkZHJlc3NUYWJsZUxvb2t1cEVuY29kZXIoKSwgeyBzaXplOiBnZXRTaG9ydFUxNkVuY29kZXIoKSB9KTtcbn1cbmZ1bmN0aW9uIGdldEFkZHJlc3NUYWJsZUxvb2t1cEFycmF5RGVjb2RlcigpIHtcbiAgcmV0dXJuIGdldEFycmF5RGVjb2RlcihnZXRBZGRyZXNzVGFibGVMb29rdXBEZWNvZGVyKCksIHsgc2l6ZTogZ2V0U2hvcnRVMTZEZWNvZGVyKCkgfSk7XG59XG5mdW5jdGlvbiBnZXRDb21waWxlZFRyYW5zYWN0aW9uTWVzc2FnZUVuY29kZXIoKSB7XG4gIHJldHVybiBjcmVhdGVFbmNvZGVyKHtcbiAgICBnZXRTaXplRnJvbVZhbHVlOiAoY29tcGlsZWRNZXNzYWdlKSA9PiB7XG4gICAgICBpZiAoY29tcGlsZWRNZXNzYWdlLnZlcnNpb24gPT09IFwibGVnYWN5XCIpIHtcbiAgICAgICAgcmV0dXJuIGdldENvbXBpbGVkTWVzc2FnZUxlZ2FjeUVuY29kZXIoKS5nZXRTaXplRnJvbVZhbHVlKGNvbXBpbGVkTWVzc2FnZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZ2V0Q29tcGlsZWRNZXNzYWdlVmVyc2lvbmVkRW5jb2RlcigpLmdldFNpemVGcm9tVmFsdWUoY29tcGlsZWRNZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHdyaXRlOiAoY29tcGlsZWRNZXNzYWdlLCBieXRlcywgb2Zmc2V0KSA9PiB7XG4gICAgICBpZiAoY29tcGlsZWRNZXNzYWdlLnZlcnNpb24gPT09IFwibGVnYWN5XCIpIHtcbiAgICAgICAgcmV0dXJuIGdldENvbXBpbGVkTWVzc2FnZUxlZ2FjeUVuY29kZXIoKS53cml0ZShjb21waWxlZE1lc3NhZ2UsIGJ5dGVzLCBvZmZzZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGdldENvbXBpbGVkTWVzc2FnZVZlcnNpb25lZEVuY29kZXIoKS53cml0ZShjb21waWxlZE1lc3NhZ2UsIGJ5dGVzLCBvZmZzZXQpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRDb21waWxlZFRyYW5zYWN0aW9uTWVzc2FnZURlY29kZXIoKSB7XG4gIHJldHVybiB0cmFuc2Zvcm1EZWNvZGVyKFxuICAgIGdldFN0cnVjdERlY29kZXIoZ2V0UHJlbHVkZVN0cnVjdERlY29kZXJUdXBsZSgpKSxcbiAgICAoeyBhZGRyZXNzVGFibGVMb29rdXBzLCAuLi5yZXN0T2ZNZXNzYWdlIH0pID0+IHtcbiAgICAgIGlmIChyZXN0T2ZNZXNzYWdlLnZlcnNpb24gPT09IFwibGVnYWN5XCIgfHwgIWFkZHJlc3NUYWJsZUxvb2t1cHM/Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcmVzdE9mTWVzc2FnZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IC4uLnJlc3RPZk1lc3NhZ2UsIGFkZHJlc3NUYWJsZUxvb2t1cHMgfTtcbiAgICB9XG4gICk7XG59XG5mdW5jdGlvbiBnZXRDb21waWxlZFRyYW5zYWN0aW9uTWVzc2FnZUNvZGVjKCkge1xuICByZXR1cm4gY29tYmluZUNvZGVjKGdldENvbXBpbGVkVHJhbnNhY3Rpb25NZXNzYWdlRW5jb2RlcigpLCBnZXRDb21waWxlZFRyYW5zYWN0aW9uTWVzc2FnZURlY29kZXIoKSk7XG59XG5mdW5jdGlvbiB1cHNlcnQoYWRkcmVzc01hcCwgYWRkcmVzcywgdXBkYXRlKSB7XG4gIGFkZHJlc3NNYXBbYWRkcmVzc10gPSB1cGRhdGUoYWRkcmVzc01hcFthZGRyZXNzXSA/PyB7IHJvbGU6IEFjY291bnRSb2xlLlJFQURPTkxZIH0pO1xufVxudmFyIFRZUEUgPSBTeW1ib2woXCJBZGRyZXNzTWFwVHlwZVByb3BlcnR5XCIpO1xuZnVuY3Rpb24gZ2V0QWRkcmVzc01hcEZyb21JbnN0cnVjdGlvbnMoZmVlUGF5ZXIsIGluc3RydWN0aW9ucykge1xuICBjb25zdCBhZGRyZXNzTWFwID0ge1xuICAgIFtmZWVQYXllcl06IHsgW1RZUEVdOiAwIC8qIEZFRV9QQVlFUiAqLywgcm9sZTogQWNjb3VudFJvbGUuV1JJVEFCTEVfU0lHTkVSIH1cbiAgfTtcbiAgY29uc3QgYWRkcmVzc2VzT2ZJbnZva2VkUHJvZ3JhbXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBmb3IgKGNvbnN0IGluc3RydWN0aW9uIG9mIGluc3RydWN0aW9ucykge1xuICAgIHVwc2VydChhZGRyZXNzTWFwLCBpbnN0cnVjdGlvbi5wcm9ncmFtQWRkcmVzcywgKGVudHJ5KSA9PiB7XG4gICAgICBhZGRyZXNzZXNPZkludm9rZWRQcm9ncmFtcy5hZGQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUFkZHJlc3MpO1xuICAgICAgaWYgKFRZUEUgaW4gZW50cnkpIHtcbiAgICAgICAgaWYgKGlzV3JpdGFibGVSb2xlKGVudHJ5LnJvbGUpKSB7XG4gICAgICAgICAgc3dpdGNoIChlbnRyeVtUWVBFXSkge1xuICAgICAgICAgICAgY2FzZSAwIC8qIEZFRV9QQVlFUiAqLzpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0lOVk9LRURfUFJPR1JBTVNfQ0FOTk9UX1BBWV9GRUVTLCB7XG4gICAgICAgICAgICAgICAgcHJvZ3JhbUFkZHJlc3M6IGluc3RydWN0aW9uLnByb2dyYW1BZGRyZXNzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0lOVk9LRURfUFJPR1JBTVNfTVVTVF9OT1RfQkVfV1JJVEFCTEUsIHtcbiAgICAgICAgICAgICAgICBwcm9ncmFtQWRkcmVzczogaW5zdHJ1Y3Rpb24ucHJvZ3JhbUFkZHJlc3NcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlbnRyeVtUWVBFXSA9PT0gMiAvKiBTVEFUSUMgKi8pIHtcbiAgICAgICAgICByZXR1cm4gZW50cnk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7IFtUWVBFXTogMiAvKiBTVEFUSUMgKi8sIHJvbGU6IEFjY291bnRSb2xlLlJFQURPTkxZIH07XG4gICAgfSk7XG4gICAgbGV0IGFkZHJlc3NDb21wYXJhdG9yO1xuICAgIGlmICghaW5zdHJ1Y3Rpb24uYWNjb3VudHMpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGFjY291bnQgb2YgaW5zdHJ1Y3Rpb24uYWNjb3VudHMpIHtcbiAgICAgIHVwc2VydChhZGRyZXNzTWFwLCBhY2NvdW50LmFkZHJlc3MsIChlbnRyeSkgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgICAgIGFkZHJlc3M6IF8sXG4gICAgICAgICAgLi4uYWNjb3VudE1ldGFcbiAgICAgICAgfSA9IGFjY291bnQ7XG4gICAgICAgIGlmIChUWVBFIGluIGVudHJ5KSB7XG4gICAgICAgICAgc3dpdGNoIChlbnRyeVtUWVBFXSkge1xuICAgICAgICAgICAgY2FzZSAwIC8qIEZFRV9QQVlFUiAqLzpcbiAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5O1xuICAgICAgICAgICAgY2FzZSAxIC8qIExPT0tVUF9UQUJMRSAqLzoge1xuICAgICAgICAgICAgICBjb25zdCBuZXh0Um9sZSA9IG1lcmdlUm9sZXMoZW50cnkucm9sZSwgYWNjb3VudE1ldGEucm9sZSk7XG4gICAgICAgICAgICAgIGlmIChcImxvb2t1cFRhYmxlQWRkcmVzc1wiIGluIGFjY291bnRNZXRhKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2hvdWxkUmVwbGFjZUVudHJ5ID0gKFxuICAgICAgICAgICAgICAgICAgLy8gQ29uc2lkZXIgdXNpbmcgdGhlIG5ldyBMT09LVVBfVEFCTEUgaWYgaXRzIGFkZHJlc3MgaXMgZGlmZmVyZW50Li4uXG4gICAgICAgICAgICAgICAgICBlbnRyeS5sb29rdXBUYWJsZUFkZHJlc3MgIT09IGFjY291bnRNZXRhLmxvb2t1cFRhYmxlQWRkcmVzcyAmJiAvLyAuLi5hbmQgc29ydHMgYmVmb3JlIHRoZSBleGlzdGluZyBvbmUuXG4gICAgICAgICAgICAgICAgICAoYWRkcmVzc0NvbXBhcmF0b3IgfHw9IGdldEFkZHJlc3NDb21wYXJhdG9yKCkpKFxuICAgICAgICAgICAgICAgICAgICBhY2NvdW50TWV0YS5sb29rdXBUYWJsZUFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgIGVudHJ5Lmxvb2t1cFRhYmxlQWRkcmVzc1xuICAgICAgICAgICAgICAgICAgKSA8IDBcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmIChzaG91bGRSZXBsYWNlRW50cnkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIFtUWVBFXTogMSAvKiBMT09LVVBfVEFCTEUgKi8sXG4gICAgICAgICAgICAgICAgICAgIC4uLmFjY291bnRNZXRhLFxuICAgICAgICAgICAgICAgICAgICByb2xlOiBuZXh0Um9sZVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNTaWduZXJSb2xlKGFjY291bnRNZXRhLnJvbGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIFtUWVBFXTogMiAvKiBTVEFUSUMgKi8sXG4gICAgICAgICAgICAgICAgICByb2xlOiBuZXh0Um9sZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGVudHJ5LnJvbGUgIT09IG5leHRSb2xlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIC4uLmVudHJ5LFxuICAgICAgICAgICAgICAgICAgcm9sZTogbmV4dFJvbGVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbnRyeTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAyIC8qIFNUQVRJQyAqLzoge1xuICAgICAgICAgICAgICBjb25zdCBuZXh0Um9sZSA9IG1lcmdlUm9sZXMoZW50cnkucm9sZSwgYWNjb3VudE1ldGEucm9sZSk7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAvLyBDaGVjayB0byBzZWUgaWYgdGhpcyBhZGRyZXNzIHJlcHJlc2VudHMgYSBwcm9ncmFtIHRoYXQgaXMgaW52b2tlZFxuICAgICAgICAgICAgICAgIC8vIGluIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICAgICAgICAgICAgYWRkcmVzc2VzT2ZJbnZva2VkUHJvZ3JhbXMuaGFzKGFjY291bnQuYWRkcmVzcylcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzV3JpdGFibGVSb2xlKGFjY291bnRNZXRhLnJvbGUpKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0lOVk9LRURfUFJPR1JBTVNfTVVTVF9OT1RfQkVfV1JJVEFCTEUsXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICBwcm9ncmFtQWRkcmVzczogYWNjb3VudC5hZGRyZXNzXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlbnRyeS5yb2xlICE9PSBuZXh0Um9sZSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgLi4uZW50cnksXG4gICAgICAgICAgICAgICAgICAgIHJvbGU6IG5leHRSb2xlXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZW50cnk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKFwibG9va3VwVGFibGVBZGRyZXNzXCIgaW4gYWNjb3VudE1ldGEgJiYgLy8gU3RhdGljIGFjY291bnRzIGNhbiBiZSAndXBncmFkZWQnIHRvIGxvb2t1cCB0YWJsZSBhY2NvdW50cyBhc1xuICAgICAgICAgICAgICAvLyBsb25nIGFzIHRoZXkgYXJlIG5vdCByZXF1aXJlIHRvIHNpZ24gdGhlIHRyYW5zYWN0aW9uLlxuICAgICAgICAgICAgICAhaXNTaWduZXJSb2xlKGVudHJ5LnJvbGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIC4uLmFjY291bnRNZXRhLFxuICAgICAgICAgICAgICAgICAgW1RZUEVdOiAxIC8qIExPT0tVUF9UQUJMRSAqLyxcbiAgICAgICAgICAgICAgICAgIHJvbGU6IG5leHRSb2xlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZW50cnkucm9sZSAhPT0gbmV4dFJvbGUpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmVudHJ5LFxuICAgICAgICAgICAgICAgICAgICByb2xlOiBuZXh0Um9sZVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJsb29rdXBUYWJsZUFkZHJlc3NcIiBpbiBhY2NvdW50TWV0YSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5hY2NvdW50TWV0YSxcbiAgICAgICAgICAgIFtUWVBFXTogMSAvKiBMT09LVVBfVEFCTEUgKi9cbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5hY2NvdW50TWV0YSxcbiAgICAgICAgICAgIFtUWVBFXTogMiAvKiBTVEFUSUMgKi9cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFkZHJlc3NNYXA7XG59XG5mdW5jdGlvbiBnZXRPcmRlcmVkQWNjb3VudHNGcm9tQWRkcmVzc01hcChhZGRyZXNzTWFwKSB7XG4gIGxldCBhZGRyZXNzQ29tcGFyYXRvcjtcbiAgY29uc3Qgb3JkZXJlZEFjY291bnRzID0gT2JqZWN0LmVudHJpZXMoYWRkcmVzc01hcCkuc29ydCgoW2xlZnRBZGRyZXNzLCBsZWZ0RW50cnldLCBbcmlnaHRBZGRyZXNzLCByaWdodEVudHJ5XSkgPT4ge1xuICAgIGlmIChsZWZ0RW50cnlbVFlQRV0gIT09IHJpZ2h0RW50cnlbVFlQRV0pIHtcbiAgICAgIGlmIChsZWZ0RW50cnlbVFlQRV0gPT09IDAgLyogRkVFX1BBWUVSICovKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH0gZWxzZSBpZiAocmlnaHRFbnRyeVtUWVBFXSA9PT0gMCAvKiBGRUVfUEFZRVIgKi8pIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9IGVsc2UgaWYgKGxlZnRFbnRyeVtUWVBFXSA9PT0gMiAvKiBTVEFUSUMgKi8pIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfSBlbHNlIGlmIChyaWdodEVudHJ5W1RZUEVdID09PSAyIC8qIFNUQVRJQyAqLykge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbGVmdElzU2lnbmVyID0gaXNTaWduZXJSb2xlKGxlZnRFbnRyeS5yb2xlKTtcbiAgICBpZiAobGVmdElzU2lnbmVyICE9PSBpc1NpZ25lclJvbGUocmlnaHRFbnRyeS5yb2xlKSkge1xuICAgICAgcmV0dXJuIGxlZnRJc1NpZ25lciA/IC0xIDogMTtcbiAgICB9XG4gICAgY29uc3QgbGVmdElzV3JpdGFibGUgPSBpc1dyaXRhYmxlUm9sZShsZWZ0RW50cnkucm9sZSk7XG4gICAgaWYgKGxlZnRJc1dyaXRhYmxlICE9PSBpc1dyaXRhYmxlUm9sZShyaWdodEVudHJ5LnJvbGUpKSB7XG4gICAgICByZXR1cm4gbGVmdElzV3JpdGFibGUgPyAtMSA6IDE7XG4gICAgfVxuICAgIGFkZHJlc3NDb21wYXJhdG9yIHx8PSBnZXRBZGRyZXNzQ29tcGFyYXRvcigpO1xuICAgIGlmIChsZWZ0RW50cnlbVFlQRV0gPT09IDEgLyogTE9PS1VQX1RBQkxFICovICYmIHJpZ2h0RW50cnlbVFlQRV0gPT09IDEgLyogTE9PS1VQX1RBQkxFICovICYmIGxlZnRFbnRyeS5sb29rdXBUYWJsZUFkZHJlc3MgIT09IHJpZ2h0RW50cnkubG9va3VwVGFibGVBZGRyZXNzKSB7XG4gICAgICByZXR1cm4gYWRkcmVzc0NvbXBhcmF0b3IobGVmdEVudHJ5Lmxvb2t1cFRhYmxlQWRkcmVzcywgcmlnaHRFbnRyeS5sb29rdXBUYWJsZUFkZHJlc3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYWRkcmVzc0NvbXBhcmF0b3IobGVmdEFkZHJlc3MsIHJpZ2h0QWRkcmVzcyk7XG4gICAgfVxuICB9KS5tYXAoKFthZGRyZXNzLCBhZGRyZXNzTWV0YV0pID0+ICh7XG4gICAgYWRkcmVzcyxcbiAgICAuLi5hZGRyZXNzTWV0YVxuICB9KSk7XG4gIHJldHVybiBvcmRlcmVkQWNjb3VudHM7XG59XG5mdW5jdGlvbiBnZXRDb21waWxlZEFkZHJlc3NUYWJsZUxvb2t1cHMob3JkZXJlZEFjY291bnRzKSB7XG4gIGNvbnN0IGluZGV4ID0ge307XG4gIGZvciAoY29uc3QgYWNjb3VudCBvZiBvcmRlcmVkQWNjb3VudHMpIHtcbiAgICBpZiAoIShcImxvb2t1cFRhYmxlQWRkcmVzc1wiIGluIGFjY291bnQpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgZW50cnkgPSBpbmRleFthY2NvdW50Lmxvb2t1cFRhYmxlQWRkcmVzc10gfHw9IHtcbiAgICAgIHJlYWRvbmx5SW5kZXhlczogW10sXG4gICAgICB3cml0YWJsZUluZGV4ZXM6IFtdXG4gICAgfTtcbiAgICBpZiAoYWNjb3VudC5yb2xlID09PSBBY2NvdW50Um9sZS5XUklUQUJMRSkge1xuICAgICAgZW50cnkud3JpdGFibGVJbmRleGVzLnB1c2goYWNjb3VudC5hZGRyZXNzSW5kZXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbnRyeS5yZWFkb25seUluZGV4ZXMucHVzaChhY2NvdW50LmFkZHJlc3NJbmRleCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBPYmplY3Qua2V5cyhpbmRleCkuc29ydChnZXRBZGRyZXNzQ29tcGFyYXRvcigpKS5tYXAoKGxvb2t1cFRhYmxlQWRkcmVzcykgPT4gKHtcbiAgICBsb29rdXBUYWJsZUFkZHJlc3MsXG4gICAgLi4uaW5kZXhbbG9va3VwVGFibGVBZGRyZXNzXVxuICB9KSk7XG59XG5mdW5jdGlvbiBnZXRDb21waWxlZE1lc3NhZ2VIZWFkZXIob3JkZXJlZEFjY291bnRzKSB7XG4gIGxldCBudW1SZWFkb25seU5vblNpZ25lckFjY291bnRzID0gMDtcbiAgbGV0IG51bVJlYWRvbmx5U2lnbmVyQWNjb3VudHMgPSAwO1xuICBsZXQgbnVtU2lnbmVyQWNjb3VudHMgPSAwO1xuICBmb3IgKGNvbnN0IGFjY291bnQgb2Ygb3JkZXJlZEFjY291bnRzKSB7XG4gICAgaWYgKFwibG9va3VwVGFibGVBZGRyZXNzXCIgaW4gYWNjb3VudCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNvbnN0IGFjY291bnRJc1dyaXRhYmxlID0gaXNXcml0YWJsZVJvbGUoYWNjb3VudC5yb2xlKTtcbiAgICBpZiAoaXNTaWduZXJSb2xlKGFjY291bnQucm9sZSkpIHtcbiAgICAgIG51bVNpZ25lckFjY291bnRzKys7XG4gICAgICBpZiAoIWFjY291bnRJc1dyaXRhYmxlKSB7XG4gICAgICAgIG51bVJlYWRvbmx5U2lnbmVyQWNjb3VudHMrKztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFhY2NvdW50SXNXcml0YWJsZSkge1xuICAgICAgbnVtUmVhZG9ubHlOb25TaWduZXJBY2NvdW50cysrO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIG51bVJlYWRvbmx5Tm9uU2lnbmVyQWNjb3VudHMsXG4gICAgbnVtUmVhZG9ubHlTaWduZXJBY2NvdW50cyxcbiAgICBudW1TaWduZXJBY2NvdW50c1xuICB9O1xufVxuXG4vLyBzcmMvY29tcGlsZS9pbnN0cnVjdGlvbnMudHNcbmZ1bmN0aW9uIGdldEFjY291bnRJbmRleChvcmRlcmVkQWNjb3VudHMpIHtcbiAgY29uc3Qgb3V0ID0ge307XG4gIGZvciAoY29uc3QgW2luZGV4LCBhY2NvdW50XSBvZiBvcmRlcmVkQWNjb3VudHMuZW50cmllcygpKSB7XG4gICAgb3V0W2FjY291bnQuYWRkcmVzc10gPSBpbmRleDtcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuZnVuY3Rpb24gZ2V0Q29tcGlsZWRJbnN0cnVjdGlvbnMoaW5zdHJ1Y3Rpb25zLCBvcmRlcmVkQWNjb3VudHMpIHtcbiAgY29uc3QgYWNjb3VudEluZGV4ID0gZ2V0QWNjb3VudEluZGV4KG9yZGVyZWRBY2NvdW50cyk7XG4gIHJldHVybiBpbnN0cnVjdGlvbnMubWFwKCh7IGFjY291bnRzLCBkYXRhLCBwcm9ncmFtQWRkcmVzcyB9KSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHByb2dyYW1BZGRyZXNzSW5kZXg6IGFjY291bnRJbmRleFtwcm9ncmFtQWRkcmVzc10sXG4gICAgICAuLi5hY2NvdW50cyA/IHsgYWNjb3VudEluZGljZXM6IGFjY291bnRzLm1hcCgoeyBhZGRyZXNzIH0pID0+IGFjY291bnRJbmRleFthZGRyZXNzXSkgfSA6IG51bGwsXG4gICAgICAuLi5kYXRhID8geyBkYXRhIH0gOiBudWxsXG4gICAgfTtcbiAgfSk7XG59XG5cbi8vIHNyYy9jb21waWxlL2xpZmV0aW1lLXRva2VuLnRzXG5mdW5jdGlvbiBnZXRDb21waWxlZExpZmV0aW1lVG9rZW4obGlmZXRpbWVDb25zdHJhaW50KSB7XG4gIGlmIChcIm5vbmNlXCIgaW4gbGlmZXRpbWVDb25zdHJhaW50KSB7XG4gICAgcmV0dXJuIGxpZmV0aW1lQ29uc3RyYWludC5ub25jZTtcbiAgfVxuICByZXR1cm4gbGlmZXRpbWVDb25zdHJhaW50LmJsb2NraGFzaDtcbn1cblxuLy8gc3JjL2NvbXBpbGUvc3RhdGljLWFjY291bnRzLnRzXG5mdW5jdGlvbiBnZXRDb21waWxlZFN0YXRpY0FjY291bnRzKG9yZGVyZWRBY2NvdW50cykge1xuICBjb25zdCBmaXJzdExvb2t1cFRhYmxlQWNjb3VudEluZGV4ID0gb3JkZXJlZEFjY291bnRzLmZpbmRJbmRleCgoYWNjb3VudCkgPT4gXCJsb29rdXBUYWJsZUFkZHJlc3NcIiBpbiBhY2NvdW50KTtcbiAgY29uc3Qgb3JkZXJlZFN0YXRpY0FjY291bnRzID0gZmlyc3RMb29rdXBUYWJsZUFjY291bnRJbmRleCA9PT0gLTEgPyBvcmRlcmVkQWNjb3VudHMgOiBvcmRlcmVkQWNjb3VudHMuc2xpY2UoMCwgZmlyc3RMb29rdXBUYWJsZUFjY291bnRJbmRleCk7XG4gIHJldHVybiBvcmRlcmVkU3RhdGljQWNjb3VudHMubWFwKCh7IGFkZHJlc3MgfSkgPT4gYWRkcmVzcyk7XG59XG5cbi8vIHNyYy9jb21waWxlL21lc3NhZ2UudHNcbmZ1bmN0aW9uIGNvbXBpbGVUcmFuc2FjdGlvbk1lc3NhZ2UodHJhbnNhY3Rpb25NZXNzYWdlKSB7XG4gIGNvbnN0IGFkZHJlc3NNYXAgPSBnZXRBZGRyZXNzTWFwRnJvbUluc3RydWN0aW9ucyhcbiAgICB0cmFuc2FjdGlvbk1lc3NhZ2UuZmVlUGF5ZXIuYWRkcmVzcyxcbiAgICB0cmFuc2FjdGlvbk1lc3NhZ2UuaW5zdHJ1Y3Rpb25zXG4gICk7XG4gIGNvbnN0IG9yZGVyZWRBY2NvdW50cyA9IGdldE9yZGVyZWRBY2NvdW50c0Zyb21BZGRyZXNzTWFwKGFkZHJlc3NNYXApO1xuICBjb25zdCBsaWZldGltZUNvbnN0cmFpbnQgPSB0cmFuc2FjdGlvbk1lc3NhZ2UubGlmZXRpbWVDb25zdHJhaW50O1xuICByZXR1cm4ge1xuICAgIC4uLnRyYW5zYWN0aW9uTWVzc2FnZS52ZXJzaW9uICE9PSBcImxlZ2FjeVwiID8geyBhZGRyZXNzVGFibGVMb29rdXBzOiBnZXRDb21waWxlZEFkZHJlc3NUYWJsZUxvb2t1cHMob3JkZXJlZEFjY291bnRzKSB9IDogbnVsbCxcbiAgICAuLi5saWZldGltZUNvbnN0cmFpbnQgPyB7IGxpZmV0aW1lVG9rZW46IGdldENvbXBpbGVkTGlmZXRpbWVUb2tlbihsaWZldGltZUNvbnN0cmFpbnQpIH0gOiBudWxsLFxuICAgIGhlYWRlcjogZ2V0Q29tcGlsZWRNZXNzYWdlSGVhZGVyKG9yZGVyZWRBY2NvdW50cyksXG4gICAgaW5zdHJ1Y3Rpb25zOiBnZXRDb21waWxlZEluc3RydWN0aW9ucyh0cmFuc2FjdGlvbk1lc3NhZ2UuaW5zdHJ1Y3Rpb25zLCBvcmRlcmVkQWNjb3VudHMpLFxuICAgIHN0YXRpY0FjY291bnRzOiBnZXRDb21waWxlZFN0YXRpY0FjY291bnRzKG9yZGVyZWRBY2NvdW50cyksXG4gICAgdmVyc2lvbjogdHJhbnNhY3Rpb25NZXNzYWdlLnZlcnNpb25cbiAgfTtcbn1cbmZ1bmN0aW9uIGZpbmRBZGRyZXNzSW5Mb29rdXBUYWJsZXMoYWRkcmVzcywgcm9sZSwgYWRkcmVzc2VzQnlMb29rdXBUYWJsZUFkZHJlc3MpIHtcbiAgZm9yIChjb25zdCBbbG9va3VwVGFibGVBZGRyZXNzLCBhZGRyZXNzZXNdIG9mIE9iamVjdC5lbnRyaWVzKGFkZHJlc3Nlc0J5TG9va3VwVGFibGVBZGRyZXNzKSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWRkcmVzc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYWRkcmVzcyA9PT0gYWRkcmVzc2VzW2ldKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICBhZGRyZXNzSW5kZXg6IGksXG4gICAgICAgICAgbG9va3VwVGFibGVBZGRyZXNzLFxuICAgICAgICAgIHJvbGVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbXByZXNzVHJhbnNhY3Rpb25NZXNzYWdlVXNpbmdBZGRyZXNzTG9va3VwVGFibGVzKHRyYW5zYWN0aW9uTWVzc2FnZSwgYWRkcmVzc2VzQnlMb29rdXBUYWJsZUFkZHJlc3MpIHtcbiAgY29uc3QgcHJvZ3JhbUFkZHJlc3NlcyA9IG5ldyBTZXQodHJhbnNhY3Rpb25NZXNzYWdlLmluc3RydWN0aW9ucy5tYXAoKGl4KSA9PiBpeC5wcm9ncmFtQWRkcmVzcykpO1xuICBjb25zdCBlbGlnaWJsZUxvb2t1cEFkZHJlc3NlcyA9IG5ldyBTZXQoXG4gICAgT2JqZWN0LnZhbHVlcyhhZGRyZXNzZXNCeUxvb2t1cFRhYmxlQWRkcmVzcykuZmxhdE1hcCgoYSkgPT4gYSkuZmlsdGVyKChhZGRyZXNzKSA9PiAhcHJvZ3JhbUFkZHJlc3Nlcy5oYXMoYWRkcmVzcykpXG4gICk7XG4gIGNvbnN0IG5ld0luc3RydWN0aW9ucyA9IFtdO1xuICBsZXQgdXBkYXRlZEFueUluc3RydWN0aW9ucyA9IGZhbHNlO1xuICBmb3IgKGNvbnN0IGluc3RydWN0aW9uIG9mIHRyYW5zYWN0aW9uTWVzc2FnZS5pbnN0cnVjdGlvbnMpIHtcbiAgICBpZiAoIWluc3RydWN0aW9uLmFjY291bnRzKSB7XG4gICAgICBuZXdJbnN0cnVjdGlvbnMucHVzaChpbnN0cnVjdGlvbik7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgbmV3QWNjb3VudHMgPSBbXTtcbiAgICBsZXQgdXBkYXRlZEFueUFjY291bnRzID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBhY2NvdW50IG9mIGluc3RydWN0aW9uLmFjY291bnRzKSB7XG4gICAgICBpZiAoXCJsb29rdXBUYWJsZUFkZHJlc3NcIiBpbiBhY2NvdW50IHx8ICFlbGlnaWJsZUxvb2t1cEFkZHJlc3Nlcy5oYXMoYWNjb3VudC5hZGRyZXNzKSB8fCBpc1NpZ25lclJvbGUoYWNjb3VudC5yb2xlKSkge1xuICAgICAgICBuZXdBY2NvdW50cy5wdXNoKGFjY291bnQpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxvb2t1cE1ldGFBY2NvdW50ID0gZmluZEFkZHJlc3NJbkxvb2t1cFRhYmxlcyhcbiAgICAgICAgYWNjb3VudC5hZGRyZXNzLFxuICAgICAgICBhY2NvdW50LnJvbGUsXG4gICAgICAgIGFkZHJlc3Nlc0J5TG9va3VwVGFibGVBZGRyZXNzXG4gICAgICApO1xuICAgICAgbmV3QWNjb3VudHMucHVzaChPYmplY3QuZnJlZXplKGxvb2t1cE1ldGFBY2NvdW50KSk7XG4gICAgICB1cGRhdGVkQW55QWNjb3VudHMgPSB0cnVlO1xuICAgICAgdXBkYXRlZEFueUluc3RydWN0aW9ucyA9IHRydWU7XG4gICAgfVxuICAgIG5ld0luc3RydWN0aW9ucy5wdXNoKFxuICAgICAgT2JqZWN0LmZyZWV6ZSh1cGRhdGVkQW55QWNjb3VudHMgPyB7IC4uLmluc3RydWN0aW9uLCBhY2NvdW50czogbmV3QWNjb3VudHMgfSA6IGluc3RydWN0aW9uKVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoXG4gICAgdXBkYXRlZEFueUluc3RydWN0aW9ucyA/IHsgLi4udHJhbnNhY3Rpb25NZXNzYWdlLCBpbnN0cnVjdGlvbnM6IG5ld0luc3RydWN0aW9ucyB9IDogdHJhbnNhY3Rpb25NZXNzYWdlXG4gICk7XG59XG5cbi8vIHNyYy9jcmVhdGUtdHJhbnNhY3Rpb24tbWVzc2FnZS50c1xuZnVuY3Rpb24gY3JlYXRlVHJhbnNhY3Rpb25NZXNzYWdlKGNvbmZpZykge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgaW5zdHJ1Y3Rpb25zOiBPYmplY3QuZnJlZXplKFtdKSxcbiAgICB2ZXJzaW9uOiBjb25maWcudmVyc2lvblxuICB9KTtcbn1cbnZhciBSRUNFTlRfQkxPQ0tIQVNIRVNfU1lTVkFSX0FERFJFU1MgPSBcIlN5c3ZhclJlY2VudEIxb2NrSGFzaGVzMTExMTExMTExMTExMTExMTExMTFcIjtcbnZhciBTWVNURU1fUFJPR1JBTV9BRERSRVNTID0gXCIxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMVwiO1xuZnVuY3Rpb24gY3JlYXRlQWR2YW5jZU5vbmNlQWNjb3VudEluc3RydWN0aW9uKG5vbmNlQWNjb3VudEFkZHJlc3MsIG5vbmNlQXV0aG9yaXR5QWRkcmVzcykge1xuICByZXR1cm4ge1xuICAgIGFjY291bnRzOiBbXG4gICAgICB7IGFkZHJlc3M6IG5vbmNlQWNjb3VudEFkZHJlc3MsIHJvbGU6IEFjY291bnRSb2xlLldSSVRBQkxFIH0sXG4gICAgICB7XG4gICAgICAgIGFkZHJlc3M6IFJFQ0VOVF9CTE9DS0hBU0hFU19TWVNWQVJfQUREUkVTUyxcbiAgICAgICAgcm9sZTogQWNjb3VudFJvbGUuUkVBRE9OTFlcbiAgICAgIH0sXG4gICAgICB7IGFkZHJlc3M6IG5vbmNlQXV0aG9yaXR5QWRkcmVzcywgcm9sZTogQWNjb3VudFJvbGUuUkVBRE9OTFlfU0lHTkVSIH1cbiAgICBdLFxuICAgIGRhdGE6IG5ldyBVaW50OEFycmF5KFs0LCAwLCAwLCAwXSksXG4gICAgcHJvZ3JhbUFkZHJlc3M6IFNZU1RFTV9QUk9HUkFNX0FERFJFU1NcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzQWR2YW5jZU5vbmNlQWNjb3VudEluc3RydWN0aW9uKGluc3RydWN0aW9uKSB7XG4gIHJldHVybiBpbnN0cnVjdGlvbi5wcm9ncmFtQWRkcmVzcyA9PT0gU1lTVEVNX1BST0dSQU1fQUREUkVTUyAmJiAvLyBUZXN0IGZvciBgQWR2YW5jZU5vbmNlQWNjb3VudGAgaW5zdHJ1Y3Rpb24gZGF0YVxuICBpbnN0cnVjdGlvbi5kYXRhICE9IG51bGwgJiYgaXNBZHZhbmNlTm9uY2VBY2NvdW50SW5zdHJ1Y3Rpb25EYXRhKGluc3RydWN0aW9uLmRhdGEpICYmIC8vIFRlc3QgZm9yIGV4YWN0bHkgMyBhY2NvdW50c1xuICBpbnN0cnVjdGlvbi5hY2NvdW50cz8ubGVuZ3RoID09PSAzICYmIC8vIEZpcnN0IGFjY291bnQgaXMgbm9uY2UgYWNjb3VudCBhZGRyZXNzXG4gIGluc3RydWN0aW9uLmFjY291bnRzWzBdLmFkZHJlc3MgIT0gbnVsbCAmJiBpbnN0cnVjdGlvbi5hY2NvdW50c1swXS5yb2xlID09PSBBY2NvdW50Um9sZS5XUklUQUJMRSAmJiAvLyBTZWNvbmQgYWNjb3VudCBpcyByZWNlbnQgYmxvY2toYXNoZXMgc3lzdmFyXG4gIGluc3RydWN0aW9uLmFjY291bnRzWzFdLmFkZHJlc3MgPT09IFJFQ0VOVF9CTE9DS0hBU0hFU19TWVNWQVJfQUREUkVTUyAmJiBpbnN0cnVjdGlvbi5hY2NvdW50c1sxXS5yb2xlID09PSBBY2NvdW50Um9sZS5SRUFET05MWSAmJiAvLyBUaGlyZCBhY2NvdW50IGlzIG5vbmNlIGF1dGhvcml0eSBhY2NvdW50XG4gIGluc3RydWN0aW9uLmFjY291bnRzWzJdLmFkZHJlc3MgIT0gbnVsbCAmJiBpc1NpZ25lclJvbGUoaW5zdHJ1Y3Rpb24uYWNjb3VudHNbMl0ucm9sZSk7XG59XG5mdW5jdGlvbiBpc0FkdmFuY2VOb25jZUFjY291bnRJbnN0cnVjdGlvbkRhdGEoZGF0YSkge1xuICByZXR1cm4gZGF0YS5ieXRlTGVuZ3RoID09PSA0ICYmIGRhdGFbMF0gPT09IDQgJiYgZGF0YVsxXSA9PT0gMCAmJiBkYXRhWzJdID09PSAwICYmIGRhdGFbM10gPT09IDA7XG59XG5cbi8vIHNyYy9kdXJhYmxlLW5vbmNlLnRzXG5mdW5jdGlvbiBpc1RyYW5zYWN0aW9uTWVzc2FnZVdpdGhEdXJhYmxlTm9uY2VMaWZldGltZSh0cmFuc2FjdGlvbk1lc3NhZ2UpIHtcbiAgcmV0dXJuIFwibGlmZXRpbWVDb25zdHJhaW50XCIgaW4gdHJhbnNhY3Rpb25NZXNzYWdlICYmIHR5cGVvZiB0cmFuc2FjdGlvbk1lc3NhZ2UubGlmZXRpbWVDb25zdHJhaW50Lm5vbmNlID09PSBcInN0cmluZ1wiICYmIHRyYW5zYWN0aW9uTWVzc2FnZS5pbnN0cnVjdGlvbnNbMF0gIT0gbnVsbCAmJiBpc0FkdmFuY2VOb25jZUFjY291bnRJbnN0cnVjdGlvbih0cmFuc2FjdGlvbk1lc3NhZ2UuaW5zdHJ1Y3Rpb25zWzBdKTtcbn1cbmZ1bmN0aW9uIGFzc2VydElzVHJhbnNhY3Rpb25NZXNzYWdlV2l0aER1cmFibGVOb25jZUxpZmV0aW1lKHRyYW5zYWN0aW9uTWVzc2FnZSkge1xuICBpZiAoIWlzVHJhbnNhY3Rpb25NZXNzYWdlV2l0aER1cmFibGVOb25jZUxpZmV0aW1lKHRyYW5zYWN0aW9uTWVzc2FnZSkpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRVhQRUNURURfTk9OQ0VfTElGRVRJTUUpO1xuICB9XG59XG5mdW5jdGlvbiBpc0FkdmFuY2VOb25jZUFjY291bnRJbnN0cnVjdGlvbkZvck5vbmNlKGluc3RydWN0aW9uLCBub25jZUFjY291bnRBZGRyZXNzLCBub25jZUF1dGhvcml0eUFkZHJlc3MpIHtcbiAgcmV0dXJuIGluc3RydWN0aW9uLmFjY291bnRzWzBdLmFkZHJlc3MgPT09IG5vbmNlQWNjb3VudEFkZHJlc3MgJiYgaW5zdHJ1Y3Rpb24uYWNjb3VudHNbMl0uYWRkcmVzcyA9PT0gbm9uY2VBdXRob3JpdHlBZGRyZXNzO1xufVxuZnVuY3Rpb24gc2V0VHJhbnNhY3Rpb25NZXNzYWdlTGlmZXRpbWVVc2luZ0R1cmFibGVOb25jZSh7XG4gIG5vbmNlLFxuICBub25jZUFjY291bnRBZGRyZXNzLFxuICBub25jZUF1dGhvcml0eUFkZHJlc3Ncbn0sIHRyYW5zYWN0aW9uTWVzc2FnZSkge1xuICBsZXQgbmV3SW5zdHJ1Y3Rpb25zO1xuICBjb25zdCBmaXJzdEluc3RydWN0aW9uID0gdHJhbnNhY3Rpb25NZXNzYWdlLmluc3RydWN0aW9uc1swXTtcbiAgaWYgKGZpcnN0SW5zdHJ1Y3Rpb24gJiYgaXNBZHZhbmNlTm9uY2VBY2NvdW50SW5zdHJ1Y3Rpb24oZmlyc3RJbnN0cnVjdGlvbikpIHtcbiAgICBpZiAoaXNBZHZhbmNlTm9uY2VBY2NvdW50SW5zdHJ1Y3Rpb25Gb3JOb25jZShmaXJzdEluc3RydWN0aW9uLCBub25jZUFjY291bnRBZGRyZXNzLCBub25jZUF1dGhvcml0eUFkZHJlc3MpKSB7XG4gICAgICBpZiAoaXNUcmFuc2FjdGlvbk1lc3NhZ2VXaXRoRHVyYWJsZU5vbmNlTGlmZXRpbWUodHJhbnNhY3Rpb25NZXNzYWdlKSAmJiB0cmFuc2FjdGlvbk1lc3NhZ2UubGlmZXRpbWVDb25zdHJhaW50Lm5vbmNlID09PSBub25jZSkge1xuICAgICAgICByZXR1cm4gdHJhbnNhY3Rpb25NZXNzYWdlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3SW5zdHJ1Y3Rpb25zID0gW2ZpcnN0SW5zdHJ1Y3Rpb24sIC4uLnRyYW5zYWN0aW9uTWVzc2FnZS5pbnN0cnVjdGlvbnMuc2xpY2UoMSldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBuZXdJbnN0cnVjdGlvbnMgPSBbXG4gICAgICAgIE9iamVjdC5mcmVlemUoY3JlYXRlQWR2YW5jZU5vbmNlQWNjb3VudEluc3RydWN0aW9uKG5vbmNlQWNjb3VudEFkZHJlc3MsIG5vbmNlQXV0aG9yaXR5QWRkcmVzcykpLFxuICAgICAgICAuLi50cmFuc2FjdGlvbk1lc3NhZ2UuaW5zdHJ1Y3Rpb25zLnNsaWNlKDEpXG4gICAgICBdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBuZXdJbnN0cnVjdGlvbnMgPSBbXG4gICAgICBPYmplY3QuZnJlZXplKGNyZWF0ZUFkdmFuY2VOb25jZUFjY291bnRJbnN0cnVjdGlvbihub25jZUFjY291bnRBZGRyZXNzLCBub25jZUF1dGhvcml0eUFkZHJlc3MpKSxcbiAgICAgIC4uLnRyYW5zYWN0aW9uTWVzc2FnZS5pbnN0cnVjdGlvbnNcbiAgICBdO1xuICB9XG4gIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAuLi50cmFuc2FjdGlvbk1lc3NhZ2UsXG4gICAgaW5zdHJ1Y3Rpb25zOiBPYmplY3QuZnJlZXplKG5ld0luc3RydWN0aW9ucyksXG4gICAgbGlmZXRpbWVDb25zdHJhaW50OiBPYmplY3QuZnJlZXplKHsgbm9uY2UgfSlcbiAgfSk7XG59XG5cbi8vIHNyYy9mZWUtcGF5ZXIudHNcbmZ1bmN0aW9uIHNldFRyYW5zYWN0aW9uTWVzc2FnZUZlZVBheWVyKGZlZVBheWVyLCB0cmFuc2FjdGlvbk1lc3NhZ2UpIHtcbiAgaWYgKFwiZmVlUGF5ZXJcIiBpbiB0cmFuc2FjdGlvbk1lc3NhZ2UgJiYgZmVlUGF5ZXIgPT09IHRyYW5zYWN0aW9uTWVzc2FnZS5mZWVQYXllcj8uYWRkcmVzcyAmJiBpc0FkZHJlc3NPbmx5RmVlUGF5ZXIodHJhbnNhY3Rpb25NZXNzYWdlLmZlZVBheWVyKSkge1xuICAgIHJldHVybiB0cmFuc2FjdGlvbk1lc3NhZ2U7XG4gIH1cbiAgY29uc3Qgb3V0ID0ge1xuICAgIC4uLnRyYW5zYWN0aW9uTWVzc2FnZSxcbiAgICBmZWVQYXllcjogT2JqZWN0LmZyZWV6ZSh7IGFkZHJlc3M6IGZlZVBheWVyIH0pXG4gIH07XG4gIE9iamVjdC5mcmVlemUob3V0KTtcbiAgcmV0dXJuIG91dDtcbn1cbmZ1bmN0aW9uIGlzQWRkcmVzc09ubHlGZWVQYXllcihmZWVQYXllcikge1xuICByZXR1cm4gISFmZWVQYXllciAmJiBcImFkZHJlc3NcIiBpbiBmZWVQYXllciAmJiB0eXBlb2YgZmVlUGF5ZXIuYWRkcmVzcyA9PT0gXCJzdHJpbmdcIiAmJiBPYmplY3Qua2V5cyhmZWVQYXllcikubGVuZ3RoID09PSAxO1xufVxuXG4vLyBzcmMvaW5zdHJ1Y3Rpb25zLnRzXG5mdW5jdGlvbiBhcHBlbmRUcmFuc2FjdGlvbk1lc3NhZ2VJbnN0cnVjdGlvbihpbnN0cnVjdGlvbiwgdHJhbnNhY3Rpb25NZXNzYWdlKSB7XG4gIHJldHVybiBhcHBlbmRUcmFuc2FjdGlvbk1lc3NhZ2VJbnN0cnVjdGlvbnMoW2luc3RydWN0aW9uXSwgdHJhbnNhY3Rpb25NZXNzYWdlKTtcbn1cbmZ1bmN0aW9uIGFwcGVuZFRyYW5zYWN0aW9uTWVzc2FnZUluc3RydWN0aW9ucyhpbnN0cnVjdGlvbnMsIHRyYW5zYWN0aW9uTWVzc2FnZSkge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgLi4udHJhbnNhY3Rpb25NZXNzYWdlLFxuICAgIGluc3RydWN0aW9uczogT2JqZWN0LmZyZWV6ZShbXG4gICAgICAuLi50cmFuc2FjdGlvbk1lc3NhZ2UuaW5zdHJ1Y3Rpb25zLFxuICAgICAgLi4uaW5zdHJ1Y3Rpb25zXG4gICAgXSlcbiAgfSk7XG59XG5mdW5jdGlvbiBwcmVwZW5kVHJhbnNhY3Rpb25NZXNzYWdlSW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb24sIHRyYW5zYWN0aW9uTWVzc2FnZSkge1xuICByZXR1cm4gcHJlcGVuZFRyYW5zYWN0aW9uTWVzc2FnZUluc3RydWN0aW9ucyhbaW5zdHJ1Y3Rpb25dLCB0cmFuc2FjdGlvbk1lc3NhZ2UpO1xufVxuZnVuY3Rpb24gcHJlcGVuZFRyYW5zYWN0aW9uTWVzc2FnZUluc3RydWN0aW9ucyhpbnN0cnVjdGlvbnMsIHRyYW5zYWN0aW9uTWVzc2FnZSkge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgLi4udHJhbnNhY3Rpb25NZXNzYWdlLFxuICAgIGluc3RydWN0aW9uczogT2JqZWN0LmZyZWV6ZShbXG4gICAgICAuLi5pbnN0cnVjdGlvbnMsXG4gICAgICAuLi50cmFuc2FjdGlvbk1lc3NhZ2UuaW5zdHJ1Y3Rpb25zXG4gICAgXSlcbiAgfSk7XG59XG5cbi8vIHNyYy9kZWNvbXBpbGUtbWVzc2FnZS50c1xuZnVuY3Rpb24gZ2V0QWNjb3VudE1ldGFzKG1lc3NhZ2UpIHtcbiAgY29uc3QgeyBoZWFkZXIgfSA9IG1lc3NhZ2U7XG4gIGNvbnN0IG51bVdyaXRhYmxlU2lnbmVyQWNjb3VudHMgPSBoZWFkZXIubnVtU2lnbmVyQWNjb3VudHMgLSBoZWFkZXIubnVtUmVhZG9ubHlTaWduZXJBY2NvdW50cztcbiAgY29uc3QgbnVtV3JpdGFibGVOb25TaWduZXJBY2NvdW50cyA9IG1lc3NhZ2Uuc3RhdGljQWNjb3VudHMubGVuZ3RoIC0gaGVhZGVyLm51bVNpZ25lckFjY291bnRzIC0gaGVhZGVyLm51bVJlYWRvbmx5Tm9uU2lnbmVyQWNjb3VudHM7XG4gIGNvbnN0IGFjY291bnRNZXRhcyA9IFtdO1xuICBsZXQgYWNjb3VudEluZGV4ID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Xcml0YWJsZVNpZ25lckFjY291bnRzOyBpKyspIHtcbiAgICBhY2NvdW50TWV0YXMucHVzaCh7XG4gICAgICBhZGRyZXNzOiBtZXNzYWdlLnN0YXRpY0FjY291bnRzW2FjY291bnRJbmRleF0sXG4gICAgICByb2xlOiBBY2NvdW50Um9sZS5XUklUQUJMRV9TSUdORVJcbiAgICB9KTtcbiAgICBhY2NvdW50SW5kZXgrKztcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGhlYWRlci5udW1SZWFkb25seVNpZ25lckFjY291bnRzOyBpKyspIHtcbiAgICBhY2NvdW50TWV0YXMucHVzaCh7XG4gICAgICBhZGRyZXNzOiBtZXNzYWdlLnN0YXRpY0FjY291bnRzW2FjY291bnRJbmRleF0sXG4gICAgICByb2xlOiBBY2NvdW50Um9sZS5SRUFET05MWV9TSUdORVJcbiAgICB9KTtcbiAgICBhY2NvdW50SW5kZXgrKztcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVdyaXRhYmxlTm9uU2lnbmVyQWNjb3VudHM7IGkrKykge1xuICAgIGFjY291bnRNZXRhcy5wdXNoKHtcbiAgICAgIGFkZHJlc3M6IG1lc3NhZ2Uuc3RhdGljQWNjb3VudHNbYWNjb3VudEluZGV4XSxcbiAgICAgIHJvbGU6IEFjY291bnRSb2xlLldSSVRBQkxFXG4gICAgfSk7XG4gICAgYWNjb3VudEluZGV4Kys7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWFkZXIubnVtUmVhZG9ubHlOb25TaWduZXJBY2NvdW50czsgaSsrKSB7XG4gICAgYWNjb3VudE1ldGFzLnB1c2goe1xuICAgICAgYWRkcmVzczogbWVzc2FnZS5zdGF0aWNBY2NvdW50c1thY2NvdW50SW5kZXhdLFxuICAgICAgcm9sZTogQWNjb3VudFJvbGUuUkVBRE9OTFlcbiAgICB9KTtcbiAgICBhY2NvdW50SW5kZXgrKztcbiAgfVxuICByZXR1cm4gYWNjb3VudE1ldGFzO1xufVxuZnVuY3Rpb24gZ2V0QWRkcmVzc0xvb2t1cE1ldGFzKGNvbXBpbGVkQWRkcmVzc1RhYmxlTG9va3VwcywgYWRkcmVzc2VzQnlMb29rdXBUYWJsZUFkZHJlc3MpIHtcbiAgY29uc3QgY29tcGlsZWRBZGRyZXNzVGFibGVMb29rdXBBZGRyZXNzZXMgPSBjb21waWxlZEFkZHJlc3NUYWJsZUxvb2t1cHMubWFwKChsKSA9PiBsLmxvb2t1cFRhYmxlQWRkcmVzcyk7XG4gIGNvbnN0IG1pc3NpbmcgPSBjb21waWxlZEFkZHJlc3NUYWJsZUxvb2t1cEFkZHJlc3Nlcy5maWx0ZXIoKGEpID0+IGFkZHJlc3Nlc0J5TG9va3VwVGFibGVBZGRyZXNzW2FdID09PSB2b2lkIDApO1xuICBpZiAobWlzc2luZy5sZW5ndGggPiAwKSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9UT19ERUNPTVBJTEVfQUREUkVTU19MT09LVVBfVEFCTEVfQ09OVEVOVFNfTUlTU0lORywge1xuICAgICAgbG9va3VwVGFibGVBZGRyZXNzZXM6IG1pc3NpbmdcbiAgICB9KTtcbiAgfVxuICBjb25zdCByZWFkT25seU1ldGFzID0gW107XG4gIGNvbnN0IHdyaXRhYmxlTWV0YXMgPSBbXTtcbiAgZm9yIChjb25zdCBsb29rdXAgb2YgY29tcGlsZWRBZGRyZXNzVGFibGVMb29rdXBzKSB7XG4gICAgY29uc3QgYWRkcmVzc2VzID0gYWRkcmVzc2VzQnlMb29rdXBUYWJsZUFkZHJlc3NbbG9va3VwLmxvb2t1cFRhYmxlQWRkcmVzc107XG4gICAgY29uc3QgcmVhZG9ubHlJbmRleGVzID0gbG9va3VwLnJlYWRvbmx5SW5kZXhlcztcbiAgICBjb25zdCB3cml0YWJsZUluZGV4ZXMgPSBsb29rdXAud3JpdGFibGVJbmRleGVzO1xuICAgIGNvbnN0IGhpZ2hlc3RJbmRleCA9IE1hdGgubWF4KC4uLnJlYWRvbmx5SW5kZXhlcywgLi4ud3JpdGFibGVJbmRleGVzKTtcbiAgICBpZiAoaGlnaGVzdEluZGV4ID49IGFkZHJlc3Nlcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihcbiAgICAgICAgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkFJTEVEX1RPX0RFQ09NUElMRV9BRERSRVNTX0xPT0tVUF9UQUJMRV9JTkRFWF9PVVRfT0ZfUkFOR0UsXG4gICAgICAgIHtcbiAgICAgICAgICBoaWdoZXN0S25vd25JbmRleDogYWRkcmVzc2VzLmxlbmd0aCAtIDEsXG4gICAgICAgICAgaGlnaGVzdFJlcXVlc3RlZEluZGV4OiBoaWdoZXN0SW5kZXgsXG4gICAgICAgICAgbG9va3VwVGFibGVBZGRyZXNzOiBsb29rdXAubG9va3VwVGFibGVBZGRyZXNzXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHJlYWRPbmx5Rm9yTG9va3VwID0gcmVhZG9ubHlJbmRleGVzLm1hcCgocikgPT4gKHtcbiAgICAgIGFkZHJlc3M6IGFkZHJlc3Nlc1tyXSxcbiAgICAgIGFkZHJlc3NJbmRleDogcixcbiAgICAgIGxvb2t1cFRhYmxlQWRkcmVzczogbG9va3VwLmxvb2t1cFRhYmxlQWRkcmVzcyxcbiAgICAgIHJvbGU6IEFjY291bnRSb2xlLlJFQURPTkxZXG4gICAgfSkpO1xuICAgIHJlYWRPbmx5TWV0YXMucHVzaCguLi5yZWFkT25seUZvckxvb2t1cCk7XG4gICAgY29uc3Qgd3JpdGFibGVGb3JMb29rdXAgPSB3cml0YWJsZUluZGV4ZXMubWFwKCh3KSA9PiAoe1xuICAgICAgYWRkcmVzczogYWRkcmVzc2VzW3ddLFxuICAgICAgYWRkcmVzc0luZGV4OiB3LFxuICAgICAgbG9va3VwVGFibGVBZGRyZXNzOiBsb29rdXAubG9va3VwVGFibGVBZGRyZXNzLFxuICAgICAgcm9sZTogQWNjb3VudFJvbGUuV1JJVEFCTEVcbiAgICB9KSk7XG4gICAgd3JpdGFibGVNZXRhcy5wdXNoKC4uLndyaXRhYmxlRm9yTG9va3VwKTtcbiAgfVxuICByZXR1cm4gWy4uLndyaXRhYmxlTWV0YXMsIC4uLnJlYWRPbmx5TWV0YXNdO1xufVxuZnVuY3Rpb24gY29udmVydEluc3RydWN0aW9uKGluc3RydWN0aW9uLCBhY2NvdW50TWV0YXMpIHtcbiAgY29uc3QgcHJvZ3JhbUFkZHJlc3MgPSBhY2NvdW50TWV0YXNbaW5zdHJ1Y3Rpb24ucHJvZ3JhbUFkZHJlc3NJbmRleF0/LmFkZHJlc3M7XG4gIGlmICghcHJvZ3JhbUFkZHJlc3MpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkFJTEVEX1RPX0RFQ09NUElMRV9JTlNUUlVDVElPTl9QUk9HUkFNX0FERFJFU1NfTk9UX0ZPVU5ELCB7XG4gICAgICBpbmRleDogaW5zdHJ1Y3Rpb24ucHJvZ3JhbUFkZHJlc3NJbmRleFxuICAgIH0pO1xuICB9XG4gIGNvbnN0IGFjY291bnRzID0gaW5zdHJ1Y3Rpb24uYWNjb3VudEluZGljZXM/Lm1hcCgoYWNjb3VudEluZGV4KSA9PiBhY2NvdW50TWV0YXNbYWNjb3VudEluZGV4XSk7XG4gIGNvbnN0IHsgZGF0YSB9ID0gaW5zdHJ1Y3Rpb247XG4gIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICBwcm9ncmFtQWRkcmVzcyxcbiAgICAuLi5hY2NvdW50cyAmJiBhY2NvdW50cy5sZW5ndGggPyB7IGFjY291bnRzOiBPYmplY3QuZnJlZXplKGFjY291bnRzKSB9IDoge30sXG4gICAgLi4uZGF0YSAmJiBkYXRhLmxlbmd0aCA/IHsgZGF0YSB9IDoge31cbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRMaWZldGltZUNvbnN0cmFpbnQobWVzc2FnZUxpZmV0aW1lVG9rZW4sIGZpcnN0SW5zdHJ1Y3Rpb24sIGxhc3RWYWxpZEJsb2NrSGVpZ2h0KSB7XG4gIGlmICghZmlyc3RJbnN0cnVjdGlvbiB8fCAhaXNBZHZhbmNlTm9uY2VBY2NvdW50SW5zdHJ1Y3Rpb24oZmlyc3RJbnN0cnVjdGlvbikpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYmxvY2toYXNoOiBtZXNzYWdlTGlmZXRpbWVUb2tlbixcbiAgICAgIGxhc3RWYWxpZEJsb2NrSGVpZ2h0OiBsYXN0VmFsaWRCbG9ja0hlaWdodCA/PyAybiAqKiA2NG4gLSAxblxuICAgICAgLy8gVTY0IE1BWFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgbm9uY2VBY2NvdW50QWRkcmVzcyA9IGZpcnN0SW5zdHJ1Y3Rpb24uYWNjb3VudHNbMF0uYWRkcmVzcztcbiAgICBhc3NlcnRJc0FkZHJlc3Mobm9uY2VBY2NvdW50QWRkcmVzcyk7XG4gICAgY29uc3Qgbm9uY2VBdXRob3JpdHlBZGRyZXNzID0gZmlyc3RJbnN0cnVjdGlvbi5hY2NvdW50c1syXS5hZGRyZXNzO1xuICAgIGFzc2VydElzQWRkcmVzcyhub25jZUF1dGhvcml0eUFkZHJlc3MpO1xuICAgIHJldHVybiB7XG4gICAgICBub25jZTogbWVzc2FnZUxpZmV0aW1lVG9rZW4sXG4gICAgICBub25jZUFjY291bnRBZGRyZXNzLFxuICAgICAgbm9uY2VBdXRob3JpdHlBZGRyZXNzXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gZGVjb21waWxlVHJhbnNhY3Rpb25NZXNzYWdlKGNvbXBpbGVkVHJhbnNhY3Rpb25NZXNzYWdlLCBjb25maWcpIHtcbiAgY29uc3QgZmVlUGF5ZXIgPSBjb21waWxlZFRyYW5zYWN0aW9uTWVzc2FnZS5zdGF0aWNBY2NvdW50c1swXTtcbiAgaWYgKCFmZWVQYXllcikge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GQUlMRURfVE9fREVDT01QSUxFX0ZFRV9QQVlFUl9NSVNTSU5HKTtcbiAgfVxuICBjb25zdCBhY2NvdW50TWV0YXMgPSBnZXRBY2NvdW50TWV0YXMoY29tcGlsZWRUcmFuc2FjdGlvbk1lc3NhZ2UpO1xuICBjb25zdCBhY2NvdW50TG9va3VwTWV0YXMgPSBcImFkZHJlc3NUYWJsZUxvb2t1cHNcIiBpbiBjb21waWxlZFRyYW5zYWN0aW9uTWVzc2FnZSAmJiBjb21waWxlZFRyYW5zYWN0aW9uTWVzc2FnZS5hZGRyZXNzVGFibGVMb29rdXBzICE9PSB2b2lkIDAgJiYgY29tcGlsZWRUcmFuc2FjdGlvbk1lc3NhZ2UuYWRkcmVzc1RhYmxlTG9va3Vwcy5sZW5ndGggPiAwID8gZ2V0QWRkcmVzc0xvb2t1cE1ldGFzKFxuICAgIGNvbXBpbGVkVHJhbnNhY3Rpb25NZXNzYWdlLmFkZHJlc3NUYWJsZUxvb2t1cHMsXG4gICAgY29uZmlnPy5hZGRyZXNzZXNCeUxvb2t1cFRhYmxlQWRkcmVzcyA/PyB7fVxuICApIDogW107XG4gIGNvbnN0IHRyYW5zYWN0aW9uTWV0YXMgPSBbLi4uYWNjb3VudE1ldGFzLCAuLi5hY2NvdW50TG9va3VwTWV0YXNdO1xuICBjb25zdCBpbnN0cnVjdGlvbnMgPSBjb21waWxlZFRyYW5zYWN0aW9uTWVzc2FnZS5pbnN0cnVjdGlvbnMubWFwKFxuICAgIChjb21waWxlZEluc3RydWN0aW9uKSA9PiBjb252ZXJ0SW5zdHJ1Y3Rpb24oY29tcGlsZWRJbnN0cnVjdGlvbiwgdHJhbnNhY3Rpb25NZXRhcylcbiAgKTtcbiAgY29uc3QgZmlyc3RJbnN0cnVjdGlvbiA9IGluc3RydWN0aW9uc1swXTtcbiAgY29uc3QgbGlmZXRpbWVDb25zdHJhaW50ID0gZ2V0TGlmZXRpbWVDb25zdHJhaW50KFxuICAgIGNvbXBpbGVkVHJhbnNhY3Rpb25NZXNzYWdlLmxpZmV0aW1lVG9rZW4sXG4gICAgZmlyc3RJbnN0cnVjdGlvbixcbiAgICBjb25maWc/Lmxhc3RWYWxpZEJsb2NrSGVpZ2h0XG4gICk7XG4gIHJldHVybiBwaXBlKFxuICAgIGNyZWF0ZVRyYW5zYWN0aW9uTWVzc2FnZSh7IHZlcnNpb246IGNvbXBpbGVkVHJhbnNhY3Rpb25NZXNzYWdlLnZlcnNpb24gfSksXG4gICAgKG0pID0+IHNldFRyYW5zYWN0aW9uTWVzc2FnZUZlZVBheWVyKGZlZVBheWVyLCBtKSxcbiAgICAobSkgPT4gaW5zdHJ1Y3Rpb25zLnJlZHVjZShcbiAgICAgIChhY2MsIGluc3RydWN0aW9uKSA9PiBhcHBlbmRUcmFuc2FjdGlvbk1lc3NhZ2VJbnN0cnVjdGlvbihpbnN0cnVjdGlvbiwgYWNjKSxcbiAgICAgIG1cbiAgICApLFxuICAgIChtKSA9PiBcImJsb2NraGFzaFwiIGluIGxpZmV0aW1lQ29uc3RyYWludCA/IHNldFRyYW5zYWN0aW9uTWVzc2FnZUxpZmV0aW1lVXNpbmdCbG9ja2hhc2gobGlmZXRpbWVDb25zdHJhaW50LCBtKSA6IHNldFRyYW5zYWN0aW9uTWVzc2FnZUxpZmV0aW1lVXNpbmdEdXJhYmxlTm9uY2UobGlmZXRpbWVDb25zdHJhaW50LCBtKVxuICApO1xufVxuXG5leHBvcnQgeyBNQVhfU1VQUE9SVEVEX1RSQU5TQUNUSU9OX1ZFUlNJT04sIGFwcGVuZFRyYW5zYWN0aW9uTWVzc2FnZUluc3RydWN0aW9uLCBhcHBlbmRUcmFuc2FjdGlvbk1lc3NhZ2VJbnN0cnVjdGlvbnMsIGFzc2VydElzVHJhbnNhY3Rpb25NZXNzYWdlV2l0aEJsb2NraGFzaExpZmV0aW1lLCBhc3NlcnRJc1RyYW5zYWN0aW9uTWVzc2FnZVdpdGhEdXJhYmxlTm9uY2VMaWZldGltZSwgY29tcGlsZVRyYW5zYWN0aW9uTWVzc2FnZSwgY29tcHJlc3NUcmFuc2FjdGlvbk1lc3NhZ2VVc2luZ0FkZHJlc3NMb29rdXBUYWJsZXMsIGNyZWF0ZVRyYW5zYWN0aW9uTWVzc2FnZSwgZGVjb21waWxlVHJhbnNhY3Rpb25NZXNzYWdlLCBnZXRDb21waWxlZFRyYW5zYWN0aW9uTWVzc2FnZUNvZGVjLCBnZXRDb21waWxlZFRyYW5zYWN0aW9uTWVzc2FnZURlY29kZXIsIGdldENvbXBpbGVkVHJhbnNhY3Rpb25NZXNzYWdlRW5jb2RlciwgZ2V0VHJhbnNhY3Rpb25WZXJzaW9uQ29kZWMsIGdldFRyYW5zYWN0aW9uVmVyc2lvbkRlY29kZXIsIGdldFRyYW5zYWN0aW9uVmVyc2lvbkVuY29kZXIsIGlzQWR2YW5jZU5vbmNlQWNjb3VudEluc3RydWN0aW9uLCBpc1RyYW5zYWN0aW9uTWVzc2FnZVdpdGhCbG9ja2hhc2hMaWZldGltZSwgaXNUcmFuc2FjdGlvbk1lc3NhZ2VXaXRoRHVyYWJsZU5vbmNlTGlmZXRpbWUsIHByZXBlbmRUcmFuc2FjdGlvbk1lc3NhZ2VJbnN0cnVjdGlvbiwgcHJlcGVuZFRyYW5zYWN0aW9uTWVzc2FnZUluc3RydWN0aW9ucywgc2V0VHJhbnNhY3Rpb25NZXNzYWdlRmVlUGF5ZXIsIHNldFRyYW5zYWN0aW9uTWVzc2FnZUxpZmV0aW1lVXNpbmdCbG9ja2hhc2gsIHNldFRyYW5zYWN0aW9uTWVzc2FnZUxpZmV0aW1lVXNpbmdEdXJhYmxlTm9uY2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm5vZGUubWpzLm1hcFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubm9kZS5tanMubWFwIl0sIm5hbWVzIjpbIlNvbGFuYUVycm9yIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRVhQRUNURURfQkxPQ0tIQVNIX0xJRkVUSU1FIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fVkVSU0lPTl9OVU1CRVJfT1VUX09GX1JBTkdFIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fVkVSU0lPTl9OVU1CRVJfTk9UX1NVUFBPUlRFRCIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0VYUEVDVEVEX05PTkNFX0xJRkVUSU1FIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkFJTEVEX1RPX0RFQ09NUElMRV9GRUVfUEFZRVJfTUlTU0lORyIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9UT19ERUNPTVBJTEVfQUREUkVTU19MT09LVVBfVEFCTEVfQ09OVEVOVFNfTUlTU0lORyIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9UT19ERUNPTVBJTEVfQUREUkVTU19MT09LVVBfVEFCTEVfSU5ERVhfT1VUX09GX1JBTkdFIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkFJTEVEX1RPX0RFQ09NUElMRV9JTlNUUlVDVElPTl9QUk9HUkFNX0FERFJFU1NfTk9UX0ZPVU5EIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfU1RSSU5HX0ZPUl9CQVNFIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fSU5WT0tFRF9QUk9HUkFNU19NVVNUX05PVF9CRV9XUklUQUJMRSIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0lOVk9LRURfUFJPR1JBTVNfQ0FOTk9UX1BBWV9GRUVTIiwiaXNCbG9ja2hhc2giLCJnZXRBZGRyZXNzRGVjb2RlciIsImdldEFkZHJlc3NDb21wYXJhdG9yIiwiYXNzZXJ0SXNBZGRyZXNzIiwiZ2V0QWRkcmVzc0VuY29kZXIiLCJjcmVhdGVFbmNvZGVyIiwiY3JlYXRlRGVjb2RlciIsImNvbWJpbmVDb2RlYyIsInRyYW5zZm9ybURlY29kZXIiLCJ0cmFuc2Zvcm1FbmNvZGVyIiwiZml4RGVjb2RlclNpemUiLCJmaXhFbmNvZGVyU2l6ZSIsImFkZERlY29kZXJTaXplUHJlZml4IiwiYWRkRW5jb2RlclNpemVQcmVmaXgiLCJnZXRTdHJ1Y3REZWNvZGVyIiwiZ2V0U3RydWN0RW5jb2RlciIsImdldEFycmF5RGVjb2RlciIsImdldFVuaW9uRW5jb2RlciIsImdldENvbnN0YW50RW5jb2RlciIsImdldEFycmF5RW5jb2RlciIsImdldEJ5dGVzRGVjb2RlciIsImdldEJ5dGVzRW5jb2RlciIsImdldFNob3J0VTE2RGVjb2RlciIsImdldFNob3J0VTE2RW5jb2RlciIsImdldFU4RGVjb2RlciIsImdldFU4RW5jb2RlciIsImlzU2lnbmVyUm9sZSIsIkFjY291bnRSb2xlIiwiaXNXcml0YWJsZVJvbGUiLCJtZXJnZVJvbGVzIiwicGlwZSIsImlzVHJhbnNhY3Rpb25NZXNzYWdlV2l0aEJsb2NraGFzaExpZmV0aW1lIiwidHJhbnNhY3Rpb25NZXNzYWdlIiwibGlmZXRpbWVDb25zdHJhaW50IiwiYmxvY2toYXNoIiwibGFzdFZhbGlkQmxvY2tIZWlnaHQiLCJhc3NlcnRJc1RyYW5zYWN0aW9uTWVzc2FnZVdpdGhCbG9ja2hhc2hMaWZldGltZSIsInNldFRyYW5zYWN0aW9uTWVzc2FnZUxpZmV0aW1lVXNpbmdCbG9ja2hhc2giLCJibG9ja2hhc2hMaWZldGltZUNvbnN0cmFpbnQiLCJPYmplY3QiLCJmcmVlemUiLCJhc3NlcnRWYWxpZEJhc2VTdHJpbmciLCJhbHBoYWJldDQiLCJ0ZXN0VmFsdWUiLCJnaXZlblZhbHVlIiwibWF0Y2giLCJSZWdFeHAiLCJhbHBoYWJldCIsImJhc2UiLCJsZW5ndGgiLCJ2YWx1ZSIsImdldEJhc2VYRW5jb2RlciIsImdldFNpemVGcm9tVmFsdWUiLCJsZWFkaW5nWmVyb2VzIiwidGFpbENoYXJzIiwicGFydGl0aW9uTGVhZGluZ1plcm9lcyIsImJhc2UxME51bWJlciIsImdldEJpZ0ludEZyb21CYXNlWCIsIk1hdGgiLCJjZWlsIiwidG9TdHJpbmciLCJ3cml0ZSIsImJ5dGVzIiwib2Zmc2V0Iiwic2V0IiwiVWludDhBcnJheSIsImZpbGwiLCJ0YWlsQnl0ZXMiLCJ1bnNoaWZ0IiwiTnVtYmVyIiwiYnl0ZXNUb0FkZCIsIkFycmF5IiwiZ2V0QmFzZVhEZWNvZGVyIiwicmVhZCIsInJhd0J5dGVzIiwic2xpY2UiLCJ0cmFpbEluZGV4IiwiZmluZEluZGV4IiwibiIsInJlcGVhdCIsInJlZHVjZSIsInN1bSIsImJ5dGUiLCJCaWdJbnQiLCJnZXRCYXNlWEZyb21CaWdJbnQiLCJ6ZXJvQ2hhcmFjdGVyIiwibGVhZGluZ1plcm9zIiwic3BsaXQiLCJjaGFyIiwiaW5kZXhPZiIsImpvaW4iLCJhbHBoYWJldDIiLCJnZXRCYXNlNThFbmNvZGVyIiwiZ2V0QmFzZTU4RGVjb2RlciIsIm1lbW9pemVkQWRkcmVzc1RhYmxlTG9va3VwRW5jb2RlciIsImdldEFkZHJlc3NUYWJsZUxvb2t1cEVuY29kZXIiLCJpbmRleEVuY29kZXIiLCJzaXplIiwibWVtb2l6ZWRBZGRyZXNzVGFibGVMb29rdXBEZWNvZGVyIiwiZ2V0QWRkcmVzc1RhYmxlTG9va3VwRGVjb2RlciIsIm1lbW9pemVkVThFbmNvZGVyIiwiZ2V0TWVtb2l6ZWRVOEVuY29kZXIiLCJtZW1vaXplZFU4RGVjb2RlciIsImdldE1lbW9pemVkVThEZWNvZGVyIiwiZ2V0TWVzc2FnZUhlYWRlckVuY29kZXIiLCJnZXRNZXNzYWdlSGVhZGVyRGVjb2RlciIsIm1lbW9pemVkR2V0SW5zdHJ1Y3Rpb25FbmNvZGVyIiwiZ2V0SW5zdHJ1Y3Rpb25FbmNvZGVyIiwiaW5zdHJ1Y3Rpb24iLCJhY2NvdW50SW5kaWNlcyIsImRhdGEiLCJtZW1vaXplZEdldEluc3RydWN0aW9uRGVjb2RlciIsImdldEluc3RydWN0aW9uRGVjb2RlciIsImJ5dGVMZW5ndGgiLCJyZXN0IiwiTUFYX1NVUFBPUlRFRF9UUkFOU0FDVElPTl9WRVJTSU9OIiwiVkVSU0lPTl9GTEFHX01BU0siLCJnZXRUcmFuc2FjdGlvblZlcnNpb25FbmNvZGVyIiwibWF4U2l6ZSIsImFjdHVhbFZlcnNpb24iLCJ1bnN1cHBvcnRlZFZlcnNpb24iLCJnZXRUcmFuc2FjdGlvblZlcnNpb25EZWNvZGVyIiwiZmlyc3RCeXRlIiwidmVyc2lvbiIsImdldFRyYW5zYWN0aW9uVmVyc2lvbkNvZGVjIiwiZ2V0Q29tcGlsZWRNZXNzYWdlTGVnYWN5RW5jb2RlciIsImdldFByZWx1ZGVTdHJ1Y3RFbmNvZGVyVHVwbGUiLCJnZXRDb21waWxlZE1lc3NhZ2VWZXJzaW9uZWRFbmNvZGVyIiwiZ2V0QWRkcmVzc1RhYmxlTG9va3VwQXJyYXlFbmNvZGVyIiwiYWRkcmVzc1RhYmxlTG9va3VwcyIsImxpZmV0aW1lVG9rZW5FbmNvZGVyIiwiZ2V0UHJlbHVkZVN0cnVjdERlY29kZXJUdXBsZSIsImdldEFkZHJlc3NUYWJsZUxvb2t1cEFycmF5RGVjb2RlciIsImdldENvbXBpbGVkVHJhbnNhY3Rpb25NZXNzYWdlRW5jb2RlciIsImNvbXBpbGVkTWVzc2FnZSIsImdldENvbXBpbGVkVHJhbnNhY3Rpb25NZXNzYWdlRGVjb2RlciIsInJlc3RPZk1lc3NhZ2UiLCJnZXRDb21waWxlZFRyYW5zYWN0aW9uTWVzc2FnZUNvZGVjIiwidXBzZXJ0IiwiYWRkcmVzc01hcCIsImFkZHJlc3MiLCJ1cGRhdGUiLCJyb2xlIiwiUkVBRE9OTFkiLCJUWVBFIiwiU3ltYm9sIiwiZ2V0QWRkcmVzc01hcEZyb21JbnN0cnVjdGlvbnMiLCJmZWVQYXllciIsImluc3RydWN0aW9ucyIsIldSSVRBQkxFX1NJR05FUiIsImFkZHJlc3Nlc09mSW52b2tlZFByb2dyYW1zIiwiU2V0IiwicHJvZ3JhbUFkZHJlc3MiLCJlbnRyeSIsImFkZCIsImFkZHJlc3NDb21wYXJhdG9yIiwiYWNjb3VudHMiLCJhY2NvdW50IiwiXyIsImFjY291bnRNZXRhIiwibmV4dFJvbGUiLCJzaG91bGRSZXBsYWNlRW50cnkiLCJsb29rdXBUYWJsZUFkZHJlc3MiLCJoYXMiLCJnZXRPcmRlcmVkQWNjb3VudHNGcm9tQWRkcmVzc01hcCIsIm9yZGVyZWRBY2NvdW50cyIsImVudHJpZXMiLCJzb3J0IiwibGVmdEFkZHJlc3MiLCJsZWZ0RW50cnkiLCJyaWdodEFkZHJlc3MiLCJyaWdodEVudHJ5IiwibGVmdElzU2lnbmVyIiwibGVmdElzV3JpdGFibGUiLCJtYXAiLCJhZGRyZXNzTWV0YSIsImdldENvbXBpbGVkQWRkcmVzc1RhYmxlTG9va3VwcyIsImluZGV4IiwicmVhZG9ubHlJbmRleGVzIiwid3JpdGFibGVJbmRleGVzIiwiV1JJVEFCTEUiLCJwdXNoIiwiYWRkcmVzc0luZGV4Iiwia2V5cyIsImdldENvbXBpbGVkTWVzc2FnZUhlYWRlciIsIm51bVJlYWRvbmx5Tm9uU2lnbmVyQWNjb3VudHMiLCJudW1SZWFkb25seVNpZ25lckFjY291bnRzIiwibnVtU2lnbmVyQWNjb3VudHMiLCJhY2NvdW50SXNXcml0YWJsZSIsImdldEFjY291bnRJbmRleCIsIm91dCIsImdldENvbXBpbGVkSW5zdHJ1Y3Rpb25zIiwiYWNjb3VudEluZGV4IiwicHJvZ3JhbUFkZHJlc3NJbmRleCIsImdldENvbXBpbGVkTGlmZXRpbWVUb2tlbiIsIm5vbmNlIiwiZ2V0Q29tcGlsZWRTdGF0aWNBY2NvdW50cyIsImZpcnN0TG9va3VwVGFibGVBY2NvdW50SW5kZXgiLCJvcmRlcmVkU3RhdGljQWNjb3VudHMiLCJjb21waWxlVHJhbnNhY3Rpb25NZXNzYWdlIiwibGlmZXRpbWVUb2tlbiIsImhlYWRlciIsInN0YXRpY0FjY291bnRzIiwiZmluZEFkZHJlc3NJbkxvb2t1cFRhYmxlcyIsImFkZHJlc3Nlc0J5TG9va3VwVGFibGVBZGRyZXNzIiwiYWRkcmVzc2VzIiwiaSIsImNvbXByZXNzVHJhbnNhY3Rpb25NZXNzYWdlVXNpbmdBZGRyZXNzTG9va3VwVGFibGVzIiwicHJvZ3JhbUFkZHJlc3NlcyIsIml4IiwiZWxpZ2libGVMb29rdXBBZGRyZXNzZXMiLCJ2YWx1ZXMiLCJmbGF0TWFwIiwiYSIsImZpbHRlciIsIm5ld0luc3RydWN0aW9ucyIsInVwZGF0ZWRBbnlJbnN0cnVjdGlvbnMiLCJuZXdBY2NvdW50cyIsInVwZGF0ZWRBbnlBY2NvdW50cyIsImxvb2t1cE1ldGFBY2NvdW50IiwiY3JlYXRlVHJhbnNhY3Rpb25NZXNzYWdlIiwiY29uZmlnIiwiUkVDRU5UX0JMT0NLSEFTSEVTX1NZU1ZBUl9BRERSRVNTIiwiU1lTVEVNX1BST0dSQU1fQUREUkVTUyIsImNyZWF0ZUFkdmFuY2VOb25jZUFjY291bnRJbnN0cnVjdGlvbiIsIm5vbmNlQWNjb3VudEFkZHJlc3MiLCJub25jZUF1dGhvcml0eUFkZHJlc3MiLCJSRUFET05MWV9TSUdORVIiLCJpc0FkdmFuY2VOb25jZUFjY291bnRJbnN0cnVjdGlvbiIsImlzQWR2YW5jZU5vbmNlQWNjb3VudEluc3RydWN0aW9uRGF0YSIsImlzVHJhbnNhY3Rpb25NZXNzYWdlV2l0aER1cmFibGVOb25jZUxpZmV0aW1lIiwiYXNzZXJ0SXNUcmFuc2FjdGlvbk1lc3NhZ2VXaXRoRHVyYWJsZU5vbmNlTGlmZXRpbWUiLCJpc0FkdmFuY2VOb25jZUFjY291bnRJbnN0cnVjdGlvbkZvck5vbmNlIiwic2V0VHJhbnNhY3Rpb25NZXNzYWdlTGlmZXRpbWVVc2luZ0R1cmFibGVOb25jZSIsImZpcnN0SW5zdHJ1Y3Rpb24iLCJzZXRUcmFuc2FjdGlvbk1lc3NhZ2VGZWVQYXllciIsImlzQWRkcmVzc09ubHlGZWVQYXllciIsImFwcGVuZFRyYW5zYWN0aW9uTWVzc2FnZUluc3RydWN0aW9uIiwiYXBwZW5kVHJhbnNhY3Rpb25NZXNzYWdlSW5zdHJ1Y3Rpb25zIiwicHJlcGVuZFRyYW5zYWN0aW9uTWVzc2FnZUluc3RydWN0aW9uIiwicHJlcGVuZFRyYW5zYWN0aW9uTWVzc2FnZUluc3RydWN0aW9ucyIsImdldEFjY291bnRNZXRhcyIsIm1lc3NhZ2UiLCJudW1Xcml0YWJsZVNpZ25lckFjY291bnRzIiwibnVtV3JpdGFibGVOb25TaWduZXJBY2NvdW50cyIsImFjY291bnRNZXRhcyIsImdldEFkZHJlc3NMb29rdXBNZXRhcyIsImNvbXBpbGVkQWRkcmVzc1RhYmxlTG9va3VwcyIsImNvbXBpbGVkQWRkcmVzc1RhYmxlTG9va3VwQWRkcmVzc2VzIiwibCIsIm1pc3NpbmciLCJsb29rdXBUYWJsZUFkZHJlc3NlcyIsInJlYWRPbmx5TWV0YXMiLCJ3cml0YWJsZU1ldGFzIiwibG9va3VwIiwiaGlnaGVzdEluZGV4IiwibWF4IiwiaGlnaGVzdEtub3duSW5kZXgiLCJoaWdoZXN0UmVxdWVzdGVkSW5kZXgiLCJyZWFkT25seUZvckxvb2t1cCIsInIiLCJ3cml0YWJsZUZvckxvb2t1cCIsInciLCJjb252ZXJ0SW5zdHJ1Y3Rpb24iLCJnZXRMaWZldGltZUNvbnN0cmFpbnQiLCJtZXNzYWdlTGlmZXRpbWVUb2tlbiIsImRlY29tcGlsZVRyYW5zYWN0aW9uTWVzc2FnZSIsImNvbXBpbGVkVHJhbnNhY3Rpb25NZXNzYWdlIiwiYWNjb3VudExvb2t1cE1ldGFzIiwidHJhbnNhY3Rpb25NZXRhcyIsImNvbXBpbGVkSW5zdHJ1Y3Rpb24iLCJtIiwiYWNjIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/transaction-messages/dist/index.node.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/transactions/dist/index.node.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@solana/transactions/dist/index.node.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TRANSACTION_PACKET_HEADER: () => (/* binding */ TRANSACTION_PACKET_HEADER),\n/* harmony export */   TRANSACTION_PACKET_SIZE: () => (/* binding */ TRANSACTION_PACKET_SIZE),\n/* harmony export */   TRANSACTION_SIZE_LIMIT: () => (/* binding */ TRANSACTION_SIZE_LIMIT),\n/* harmony export */   assertIsFullySignedTransaction: () => (/* binding */ assertIsFullySignedTransaction),\n/* harmony export */   assertIsSendableTransaction: () => (/* binding */ assertIsSendableTransaction),\n/* harmony export */   assertIsTransactionMessageWithinSizeLimit: () => (/* binding */ assertIsTransactionMessageWithinSizeLimit),\n/* harmony export */   assertIsTransactionWithBlockhashLifetime: () => (/* binding */ assertIsTransactionWithBlockhashLifetime),\n/* harmony export */   assertIsTransactionWithDurableNonceLifetime: () => (/* binding */ assertIsTransactionWithDurableNonceLifetime),\n/* harmony export */   assertIsTransactionWithinSizeLimit: () => (/* binding */ assertIsTransactionWithinSizeLimit),\n/* harmony export */   compileTransaction: () => (/* binding */ compileTransaction),\n/* harmony export */   getBase64EncodedWireTransaction: () => (/* binding */ getBase64EncodedWireTransaction),\n/* harmony export */   getSignatureFromTransaction: () => (/* binding */ getSignatureFromTransaction),\n/* harmony export */   getTransactionCodec: () => (/* binding */ getTransactionCodec),\n/* harmony export */   getTransactionDecoder: () => (/* binding */ getTransactionDecoder),\n/* harmony export */   getTransactionEncoder: () => (/* binding */ getTransactionEncoder),\n/* harmony export */   getTransactionLifetimeConstraintFromCompiledTransactionMessage: () => (/* binding */ getTransactionLifetimeConstraintFromCompiledTransactionMessage),\n/* harmony export */   getTransactionMessageSize: () => (/* binding */ getTransactionMessageSize),\n/* harmony export */   getTransactionSize: () => (/* binding */ getTransactionSize),\n/* harmony export */   isFullySignedTransaction: () => (/* binding */ isFullySignedTransaction),\n/* harmony export */   isSendableTransaction: () => (/* binding */ isSendableTransaction),\n/* harmony export */   isTransactionMessageWithinSizeLimit: () => (/* binding */ isTransactionMessageWithinSizeLimit),\n/* harmony export */   isTransactionWithBlockhashLifetime: () => (/* binding */ isTransactionWithBlockhashLifetime),\n/* harmony export */   isTransactionWithDurableNonceLifetime: () => (/* binding */ isTransactionWithDurableNonceLifetime),\n/* harmony export */   isTransactionWithinSizeLimit: () => (/* binding */ isTransactionWithinSizeLimit),\n/* harmony export */   partiallySignTransaction: () => (/* binding */ partiallySignTransaction),\n/* harmony export */   signTransaction: () => (/* binding */ signTransaction)\n/* harmony export */ });\n/* harmony import */ var _solana_addresses__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @solana/addresses */ \"(ssr)/./node_modules/@solana/addresses/dist/index.node.mjs\");\n/* harmony import */ var _solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana/codecs-core */ \"(ssr)/./node_modules/@solana/codecs-core/dist/index.node.mjs\");\n/* harmony import */ var _solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @solana/codecs-data-structures */ \"(ssr)/./node_modules/@solana/codecs-data-structures/dist/index.node.mjs\");\n/* harmony import */ var _solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @solana/codecs-numbers */ \"(ssr)/./node_modules/@solana/codecs-numbers/dist/index.node.mjs\");\n/* harmony import */ var _solana_errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/errors */ \"(ssr)/./node_modules/@solana/errors/dist/index.node.mjs\");\n/* harmony import */ var _solana_transaction_messages__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @solana/transaction-messages */ \"(ssr)/./node_modules/@solana/transaction-messages/dist/index.node.mjs\");\n/* harmony import */ var _solana_rpc_types__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @solana/rpc-types */ \"(ssr)/./node_modules/@solana/rpc-types/dist/index.node.mjs\");\n/* harmony import */ var _solana_codecs_strings__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @solana/codecs-strings */ \"(ssr)/./node_modules/@solana/codecs-strings/dist/index.node.mjs\");\n/* harmony import */ var _solana_keys__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @solana/keys */ \"(ssr)/./node_modules/@solana/keys/dist/index.node.mjs\");\n\n\n\n\n\n\n\n\n\n// src/codecs/transaction-codec.ts\nfunction getSignaturesToEncode(signaturesMap) {\n    const signatures = Object.values(signaturesMap);\n    if (signatures.length === 0) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES);\n    }\n    return signatures.map((signature)=>{\n        if (!signature) {\n            return new Uint8Array(64).fill(0);\n        }\n        return signature;\n    });\n}\nfunction getSignaturesEncoder() {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.transformEncoder)((0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_2__.getArrayEncoder)((0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.fixEncoderSize)((0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_2__.getBytesEncoder)(), 64), {\n        size: (0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_3__.getShortU16Encoder)()\n    }), getSignaturesToEncode);\n}\n// src/codecs/transaction-codec.ts\nfunction getTransactionEncoder() {\n    return (0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_2__.getStructEncoder)([\n        [\n            \"signatures\",\n            getSignaturesEncoder()\n        ],\n        [\n            \"messageBytes\",\n            (0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_2__.getBytesEncoder)()\n        ]\n    ]);\n}\nfunction getTransactionDecoder() {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.transformDecoder)((0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_2__.getStructDecoder)([\n        [\n            \"signatures\",\n            (0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_2__.getArrayDecoder)((0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.fixDecoderSize)((0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_2__.getBytesDecoder)(), 64), {\n                size: (0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_3__.getShortU16Decoder)()\n            })\n        ],\n        [\n            \"messageBytes\",\n            (0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_2__.getBytesDecoder)()\n        ]\n    ]), decodePartiallyDecodedTransaction);\n}\nfunction getTransactionCodec() {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getTransactionEncoder(), getTransactionDecoder());\n}\nfunction decodePartiallyDecodedTransaction(transaction) {\n    const { messageBytes, signatures } = transaction;\n    const signerAddressesDecoder = (0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_2__.getTupleDecoder)([\n        // read transaction version\n        (0,_solana_transaction_messages__WEBPACK_IMPORTED_MODULE_4__.getTransactionVersionDecoder)(),\n        // read first byte of header, `numSignerAccounts`\n        // padRight to skip the next 2 bytes, `numReadOnlySignedAccounts` and `numReadOnlyUnsignedAccounts` which we don't need\n        (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.padRightDecoder)((0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_3__.getU8Decoder)(), 2),\n        // read static addresses\n        (0,_solana_codecs_data_structures__WEBPACK_IMPORTED_MODULE_2__.getArrayDecoder)((0,_solana_addresses__WEBPACK_IMPORTED_MODULE_5__.getAddressDecoder)(), {\n            size: (0,_solana_codecs_numbers__WEBPACK_IMPORTED_MODULE_3__.getShortU16Decoder)()\n        })\n    ]);\n    const [_txVersion, numRequiredSignatures, staticAddresses] = signerAddressesDecoder.decode(messageBytes);\n    const signerAddresses = staticAddresses.slice(0, numRequiredSignatures);\n    if (signerAddresses.length !== signatures.length) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH, {\n            numRequiredSignatures,\n            signaturesLength: signatures.length,\n            signerAddresses\n        });\n    }\n    const signaturesMap = {};\n    signerAddresses.forEach((address, index)=>{\n        const signatureForAddress = signatures[index];\n        if (signatureForAddress.every((b)=>b === 0)) {\n            signaturesMap[address] = null;\n        } else {\n            signaturesMap[address] = signatureForAddress;\n        }\n    });\n    return {\n        messageBytes,\n        signatures: Object.freeze(signaturesMap)\n    };\n}\nvar SYSTEM_PROGRAM_ADDRESS = \"11111111111111111111111111111111\";\nfunction compiledInstructionIsAdvanceNonceInstruction(instruction, staticAddresses) {\n    return staticAddresses[instruction.programAddressIndex] === SYSTEM_PROGRAM_ADDRESS && // Test for `AdvanceNonceAccount` instruction data\n    instruction.data != null && isAdvanceNonceAccountInstructionData(instruction.data) && // Test for exactly 3 accounts\n    instruction.accountIndices?.length === 3;\n}\nfunction isAdvanceNonceAccountInstructionData(data) {\n    return data.byteLength === 4 && data[0] === 4 && data[1] === 0 && data[2] === 0 && data[3] === 0;\n}\nasync function getTransactionLifetimeConstraintFromCompiledTransactionMessage(compiledTransactionMessage) {\n    const firstInstruction = compiledTransactionMessage.instructions[0];\n    const { staticAccounts } = compiledTransactionMessage;\n    if (firstInstruction && compiledInstructionIsAdvanceNonceInstruction(firstInstruction, staticAccounts)) {\n        const nonceAccountAddress = staticAccounts[firstInstruction.accountIndices[0]];\n        if (!nonceAccountAddress) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__TRANSACTION__NONCE_ACCOUNT_CANNOT_BE_IN_LOOKUP_TABLE, {\n                nonce: compiledTransactionMessage.lifetimeToken\n            });\n        }\n        return {\n            nonce: compiledTransactionMessage.lifetimeToken,\n            nonceAccountAddress\n        };\n    } else {\n        return {\n            blockhash: compiledTransactionMessage.lifetimeToken,\n            // This is not known from the compiled message, so we set it to the maximum possible value\n            lastValidBlockHeight: 0xffffffffffffffffn\n        };\n    }\n}\nfunction isTransactionWithBlockhashLifetime(transaction) {\n    return \"lifetimeConstraint\" in transaction && \"blockhash\" in transaction.lifetimeConstraint && typeof transaction.lifetimeConstraint.blockhash === \"string\" && typeof transaction.lifetimeConstraint.lastValidBlockHeight === \"bigint\" && (0,_solana_rpc_types__WEBPACK_IMPORTED_MODULE_6__.isBlockhash)(transaction.lifetimeConstraint.blockhash);\n}\nfunction assertIsTransactionWithBlockhashLifetime(transaction) {\n    if (!isTransactionWithBlockhashLifetime(transaction)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME);\n    }\n}\nfunction isTransactionWithDurableNonceLifetime(transaction) {\n    return \"lifetimeConstraint\" in transaction && \"nonce\" in transaction.lifetimeConstraint && typeof transaction.lifetimeConstraint.nonce === \"string\" && typeof transaction.lifetimeConstraint.nonceAccountAddress === \"string\" && (0,_solana_addresses__WEBPACK_IMPORTED_MODULE_5__.isAddress)(transaction.lifetimeConstraint.nonceAccountAddress);\n}\nfunction assertIsTransactionWithDurableNonceLifetime(transaction) {\n    if (!isTransactionWithDurableNonceLifetime(transaction)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME);\n    }\n}\nfunction compileTransaction(transactionMessage) {\n    const compiledMessage = (0,_solana_transaction_messages__WEBPACK_IMPORTED_MODULE_4__.compileTransactionMessage)(transactionMessage);\n    const messageBytes = (0,_solana_transaction_messages__WEBPACK_IMPORTED_MODULE_4__.getCompiledTransactionMessageEncoder)().encode(compiledMessage);\n    const transactionSigners = compiledMessage.staticAccounts.slice(0, compiledMessage.header.numSignerAccounts);\n    const signatures = {};\n    for (const signerAddress of transactionSigners){\n        signatures[signerAddress] = null;\n    }\n    let lifetimeConstraint;\n    if ((0,_solana_transaction_messages__WEBPACK_IMPORTED_MODULE_4__.isTransactionMessageWithBlockhashLifetime)(transactionMessage)) {\n        lifetimeConstraint = {\n            blockhash: transactionMessage.lifetimeConstraint.blockhash,\n            lastValidBlockHeight: transactionMessage.lifetimeConstraint.lastValidBlockHeight\n        };\n    } else if ((0,_solana_transaction_messages__WEBPACK_IMPORTED_MODULE_4__.isTransactionMessageWithDurableNonceLifetime)(transactionMessage)) {\n        lifetimeConstraint = {\n            nonce: transactionMessage.lifetimeConstraint.nonce,\n            nonceAccountAddress: transactionMessage.instructions[0].accounts[0].address\n        };\n    }\n    return Object.freeze({\n        ...lifetimeConstraint ? {\n            lifetimeConstraint\n        } : void 0,\n        messageBytes,\n        signatures: Object.freeze(signatures)\n    });\n}\nvar base58Decoder;\nfunction getSignatureFromTransaction(transaction) {\n    if (!base58Decoder) base58Decoder = (0,_solana_codecs_strings__WEBPACK_IMPORTED_MODULE_7__.getBase58Decoder)();\n    const signatureBytes = Object.values(transaction.signatures)[0];\n    if (!signatureBytes) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING);\n    }\n    const transactionSignature = base58Decoder.decode(signatureBytes);\n    return transactionSignature;\n}\nasync function partiallySignTransaction(keyPairs, transaction) {\n    let newSignatures;\n    let unexpectedSigners;\n    await Promise.all(keyPairs.map(async (keyPair)=>{\n        const address = await (0,_solana_addresses__WEBPACK_IMPORTED_MODULE_5__.getAddressFromPublicKey)(keyPair.publicKey);\n        const existingSignature = transaction.signatures[address];\n        if (existingSignature === void 0) {\n            unexpectedSigners ||= /* @__PURE__ */ new Set();\n            unexpectedSigners.add(address);\n            return;\n        }\n        if (unexpectedSigners) {\n            return;\n        }\n        const newSignature = await (0,_solana_keys__WEBPACK_IMPORTED_MODULE_8__.signBytes)(keyPair.privateKey, transaction.messageBytes);\n        if (existingSignature !== null && (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.bytesEqual)(newSignature, existingSignature)) {\n            return;\n        }\n        newSignatures ||= {};\n        newSignatures[address] = newSignature;\n    }));\n    if (unexpectedSigners && unexpectedSigners.size > 0) {\n        const expectedSigners = Object.keys(transaction.signatures);\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION, {\n            expectedAddresses: expectedSigners,\n            unexpectedAddresses: [\n                ...unexpectedSigners\n            ]\n        });\n    }\n    if (!newSignatures) {\n        return transaction;\n    }\n    return Object.freeze({\n        ...transaction,\n        signatures: Object.freeze({\n            ...transaction.signatures,\n            ...newSignatures\n        })\n    });\n}\nasync function signTransaction(keyPairs, transaction) {\n    const out = await partiallySignTransaction(keyPairs, transaction);\n    assertIsFullySignedTransaction(out);\n    Object.freeze(out);\n    return out;\n}\nfunction isFullySignedTransaction(transaction) {\n    return Object.entries(transaction.signatures).every(([_, signatureBytes])=>!!signatureBytes);\n}\nfunction assertIsFullySignedTransaction(transaction) {\n    const missingSigs = [];\n    Object.entries(transaction.signatures).forEach(([address, signatureBytes])=>{\n        if (!signatureBytes) {\n            missingSigs.push(address);\n        }\n    });\n    if (missingSigs.length > 0) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING, {\n            addresses: missingSigs\n        });\n    }\n}\nfunction getBase64EncodedWireTransaction(transaction) {\n    const wireTransactionBytes = getTransactionEncoder().encode(transaction);\n    return (0,_solana_codecs_strings__WEBPACK_IMPORTED_MODULE_7__.getBase64Decoder)().decode(wireTransactionBytes);\n}\nvar TRANSACTION_PACKET_SIZE = 1280;\nvar TRANSACTION_PACKET_HEADER = 40 + 8;\nvar TRANSACTION_SIZE_LIMIT = TRANSACTION_PACKET_SIZE - TRANSACTION_PACKET_HEADER;\nfunction getTransactionSize(transaction) {\n    return getTransactionEncoder().getSizeFromValue(transaction);\n}\nfunction isTransactionWithinSizeLimit(transaction) {\n    return getTransactionSize(transaction) <= TRANSACTION_SIZE_LIMIT;\n}\nfunction assertIsTransactionWithinSizeLimit(transaction) {\n    const transactionSize = getTransactionSize(transaction);\n    if (transactionSize > TRANSACTION_SIZE_LIMIT) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT, {\n            transactionSize,\n            transactionSizeLimit: TRANSACTION_SIZE_LIMIT\n        });\n    }\n}\n// src/sendable-transaction.ts\nfunction isSendableTransaction(transaction) {\n    return isFullySignedTransaction(transaction) && isTransactionWithinSizeLimit(transaction);\n}\nfunction assertIsSendableTransaction(transaction) {\n    assertIsFullySignedTransaction(transaction);\n    assertIsTransactionWithinSizeLimit(transaction);\n}\nfunction getTransactionMessageSize(transactionMessage) {\n    return getTransactionSize(compileTransaction(transactionMessage));\n}\nfunction isTransactionMessageWithinSizeLimit(transactionMessage) {\n    return getTransactionMessageSize(transactionMessage) <= TRANSACTION_SIZE_LIMIT;\n}\nfunction assertIsTransactionMessageWithinSizeLimit(transactionMessage) {\n    const transactionSize = getTransactionMessageSize(transactionMessage);\n    if (transactionSize > TRANSACTION_SIZE_LIMIT) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT, {\n            transactionSize,\n            transactionSizeLimit: TRANSACTION_SIZE_LIMIT\n        });\n    }\n}\n //# sourceMappingURL=index.node.mjs.map\n //# sourceMappingURL=index.node.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS90cmFuc2FjdGlvbnMvZGlzdC9pbmRleC5ub2RlLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEwRjtBQUMwRDtBQUNxQjtBQUMzRTtBQUMyYztBQUNuVTtBQUN0TDtBQUM0QjtBQUNuQztBQUV6QyxrQ0FBa0M7QUFDbEMsU0FBU3VDLHNCQUFzQkMsYUFBYTtJQUMxQyxNQUFNQyxhQUFhQyxPQUFPQyxNQUFNLENBQUNIO0lBQ2pDLElBQUlDLFdBQVdHLE1BQU0sS0FBSyxHQUFHO1FBQzNCLE1BQU0sSUFBSXhCLHVEQUFXQSxDQUFDUywwR0FBOERBO0lBQ3RGO0lBQ0EsT0FBT1ksV0FBV0ksR0FBRyxDQUFDLENBQUNDO1FBQ3JCLElBQUksQ0FBQ0EsV0FBVztZQUNkLE9BQU8sSUFBSUMsV0FBVyxJQUFJQyxJQUFJLENBQUM7UUFDakM7UUFDQSxPQUFPRjtJQUNUO0FBQ0Y7QUFDQSxTQUFTRztJQUNQLE9BQU96QyxxRUFBZ0JBLENBQ3JCUSwrRUFBZUEsQ0FBQ1AsbUVBQWNBLENBQUNFLCtFQUFlQSxJQUFJLEtBQUs7UUFBRXVDLE1BQU0vQiwwRUFBa0JBO0lBQUcsSUFDcEZvQjtBQUVKO0FBRUEsa0NBQWtDO0FBQ2xDLFNBQVNZO0lBQ1AsT0FBT3pDLGdGQUFnQkEsQ0FBQztRQUN0QjtZQUFDO1lBQWN1QztTQUF1QjtRQUN0QztZQUFDO1lBQWdCdEMsK0VBQWVBO1NBQUc7S0FDcEM7QUFDSDtBQUNBLFNBQVN5QztJQUNQLE9BQU9qRCxxRUFBZ0JBLENBQ3JCUyxnRkFBZ0JBLENBQUM7UUFDZjtZQUFDO1lBQWNDLCtFQUFlQSxDQUFDVCxtRUFBY0EsQ0FBQ1UsK0VBQWVBLElBQUksS0FBSztnQkFBRW9DLE1BQU1qQywwRUFBa0JBO1lBQUc7U0FBRztRQUN0RztZQUFDO1lBQWdCSCwrRUFBZUE7U0FBRztLQUNwQyxHQUNEdUM7QUFFSjtBQUNBLFNBQVNDO0lB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MEJuRCxrQkFBa0I7SUFDbkQsT0FBTzJDLG1CQUFtQjVDLG1CQUFtQkM7QUFDL0M7QUFDQSxTQUFTb0Qsb0NBQW9DcEQsa0JBQWtCO0lBQzdELE9BQU9tRCwwQkFBMEJuRCx1QkFBdUIwQztBQUMxRDtBQUNBLFNBQVNXLDBDQUEwQ3JELGtCQUFrQjtJQUNuRSxNQUFNK0Msa0JBQWtCSSwwQkFBMEJuRDtJQUNsRCxJQUFJK0Msa0JBQWtCTCx3QkFBd0I7UUFDNUMsTUFBTSxJQUFJdEgsdURBQVdBLENBQUNRLHlGQUE2Q0EsRUFBRTtZQUNuRW1IO1lBQ0FDLHNCQUFzQk47UUFDeEI7SUFDRjtBQUNGO0FBRXV5QixDQUN2eUIsdUNBQXVDO0NBQ3ZDLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsYXctd29ya3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS90cmFuc2FjdGlvbnMvZGlzdC9pbmRleC5ub2RlLm1qcz8yMDEzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldEFkZHJlc3NEZWNvZGVyLCBpc0FkZHJlc3MsIGdldEFkZHJlc3NGcm9tUHVibGljS2V5IH0gZnJvbSAnQHNvbGFuYS9hZGRyZXNzZXMnO1xuaW1wb3J0IHsgdHJhbnNmb3JtRGVjb2RlciwgZml4RGVjb2RlclNpemUsIGNvbWJpbmVDb2RlYywgcGFkUmlnaHREZWNvZGVyLCBieXRlc0VxdWFsLCB0cmFuc2Zvcm1FbmNvZGVyLCBmaXhFbmNvZGVyU2l6ZSB9IGZyb20gJ0Bzb2xhbmEvY29kZWNzLWNvcmUnO1xuaW1wb3J0IHsgZ2V0U3RydWN0RW5jb2RlciwgZ2V0Qnl0ZXNFbmNvZGVyLCBnZXRTdHJ1Y3REZWNvZGVyLCBnZXRBcnJheURlY29kZXIsIGdldEJ5dGVzRGVjb2RlciwgZ2V0VHVwbGVEZWNvZGVyLCBnZXRBcnJheUVuY29kZXIgfSBmcm9tICdAc29sYW5hL2NvZGVjcy1kYXRhLXN0cnVjdHVyZXMnO1xuaW1wb3J0IHsgZ2V0U2hvcnRVMTZEZWNvZGVyLCBnZXRVOERlY29kZXIsIGdldFNob3J0VTE2RW5jb2RlciB9IGZyb20gJ0Bzb2xhbmEvY29kZWNzLW51bWJlcnMnO1xuaW1wb3J0IHsgU29sYW5hRXJyb3IsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX01FU1NBR0VfU0lHTkFUVVJFU19NSVNNQVRDSCwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fTk9OQ0VfQUNDT1VOVF9DQU5OT1RfQkVfSU5fTE9PS1VQX1RBQkxFLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19FWFBFQ1RFRF9CTE9DS0hBU0hfTElGRVRJTUUsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0VYUEVDVEVEX05PTkNFX0xJRkVUSU1FLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GRUVfUEFZRVJfU0lHTkFUVVJFX01JU1NJTkcsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0FERFJFU1NFU19DQU5OT1RfU0lHTl9UUkFOU0FDVElPTiwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fU0lHTkFUVVJFU19NSVNTSU5HLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19FWENFRURTX1NJWkVfTElNSVQsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0NBTk5PVF9FTkNPREVfV0lUSF9FTVBUWV9TSUdOQVRVUkVTIH0gZnJvbSAnQHNvbGFuYS9lcnJvcnMnO1xuaW1wb3J0IHsgZ2V0VHJhbnNhY3Rpb25WZXJzaW9uRGVjb2RlciwgY29tcGlsZVRyYW5zYWN0aW9uTWVzc2FnZSwgZ2V0Q29tcGlsZWRUcmFuc2FjdGlvbk1lc3NhZ2VFbmNvZGVyLCBpc1RyYW5zYWN0aW9uTWVzc2FnZVdpdGhCbG9ja2hhc2hMaWZldGltZSwgaXNUcmFuc2FjdGlvbk1lc3NhZ2VXaXRoRHVyYWJsZU5vbmNlTGlmZXRpbWUgfSBmcm9tICdAc29sYW5hL3RyYW5zYWN0aW9uLW1lc3NhZ2VzJztcbmltcG9ydCB7IGlzQmxvY2toYXNoIH0gZnJvbSAnQHNvbGFuYS9ycGMtdHlwZXMnO1xuaW1wb3J0IHsgZ2V0QmFzZTU4RGVjb2RlciwgZ2V0QmFzZTY0RGVjb2RlciB9IGZyb20gJ0Bzb2xhbmEvY29kZWNzLXN0cmluZ3MnO1xuaW1wb3J0IHsgc2lnbkJ5dGVzIH0gZnJvbSAnQHNvbGFuYS9rZXlzJztcblxuLy8gc3JjL2NvZGVjcy90cmFuc2FjdGlvbi1jb2RlYy50c1xuZnVuY3Rpb24gZ2V0U2lnbmF0dXJlc1RvRW5jb2RlKHNpZ25hdHVyZXNNYXApIHtcbiAgY29uc3Qgc2lnbmF0dXJlcyA9IE9iamVjdC52YWx1ZXMoc2lnbmF0dXJlc01hcCk7XG4gIGlmIChzaWduYXR1cmVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19DQU5OT1RfRU5DT0RFX1dJVEhfRU1QVFlfU0lHTkFUVVJFUyk7XG4gIH1cbiAgcmV0dXJuIHNpZ25hdHVyZXMubWFwKChzaWduYXR1cmUpID0+IHtcbiAgICBpZiAoIXNpZ25hdHVyZSkge1xuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KDY0KS5maWxsKDApO1xuICAgIH1cbiAgICByZXR1cm4gc2lnbmF0dXJlO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldFNpZ25hdHVyZXNFbmNvZGVyKCkge1xuICByZXR1cm4gdHJhbnNmb3JtRW5jb2RlcihcbiAgICBnZXRBcnJheUVuY29kZXIoZml4RW5jb2RlclNpemUoZ2V0Qnl0ZXNFbmNvZGVyKCksIDY0KSwgeyBzaXplOiBnZXRTaG9ydFUxNkVuY29kZXIoKSB9KSxcbiAgICBnZXRTaWduYXR1cmVzVG9FbmNvZGVcbiAgKTtcbn1cblxuLy8gc3JjL2NvZGVjcy90cmFuc2FjdGlvbi1jb2RlYy50c1xuZnVuY3Rpb24gZ2V0VHJhbnNhY3Rpb25FbmNvZGVyKCkge1xuICByZXR1cm4gZ2V0U3RydWN0RW5jb2RlcihbXG4gICAgW1wic2lnbmF0dXJlc1wiLCBnZXRTaWduYXR1cmVzRW5jb2RlcigpXSxcbiAgICBbXCJtZXNzYWdlQnl0ZXNcIiwgZ2V0Qnl0ZXNFbmNvZGVyKCldXG4gIF0pO1xufVxuZnVuY3Rpb24gZ2V0VHJhbnNhY3Rpb25EZWNvZGVyKCkge1xuICByZXR1cm4gdHJhbnNmb3JtRGVjb2RlcihcbiAgICBnZXRTdHJ1Y3REZWNvZGVyKFtcbiAgICAgIFtcInNpZ25hdHVyZXNcIiwgZ2V0QXJyYXlEZWNvZGVyKGZpeERlY29kZXJTaXplKGdldEJ5dGVzRGVjb2RlcigpLCA2NCksIHsgc2l6ZTogZ2V0U2hvcnRVMTZEZWNvZGVyKCkgfSldLFxuICAgICAgW1wibWVzc2FnZUJ5dGVzXCIsIGdldEJ5dGVzRGVjb2RlcigpXVxuICAgIF0pLFxuICAgIGRlY29kZVBhcnRpYWxseURlY29kZWRUcmFuc2FjdGlvblxuICApO1xufVxuZnVuY3Rpb24gZ2V0VHJhbnNhY3Rpb25Db2RlYygpIHtcbiAgcmV0dXJuIGNvbWJpbmVDb2RlYyhnZXRUcmFuc2FjdGlvbkVuY29kZXIoKSwgZ2V0VHJhbnNhY3Rpb25EZWNvZGVyKCkpO1xufVxuZnVuY3Rpb24gZGVjb2RlUGFydGlhbGx5RGVjb2RlZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gIGNvbnN0IHsgbWVzc2FnZUJ5dGVzLCBzaWduYXR1cmVzIH0gPSB0cmFuc2FjdGlvbjtcbiAgY29uc3Qgc2lnbmVyQWRkcmVzc2VzRGVjb2RlciA9IGdldFR1cGxlRGVjb2RlcihbXG4gICAgLy8gcmVhZCB0cmFuc2FjdGlvbiB2ZXJzaW9uXG4gICAgZ2V0VHJhbnNhY3Rpb25WZXJzaW9uRGVjb2RlcigpLFxuICAgIC8vIHJlYWQgZmlyc3QgYnl0ZSBvZiBoZWFkZXIsIGBudW1TaWduZXJBY2NvdW50c2BcbiAgICAvLyBwYWRSaWdodCB0byBza2lwIHRoZSBuZXh0IDIgYnl0ZXMsIGBudW1SZWFkT25seVNpZ25lZEFjY291bnRzYCBhbmQgYG51bVJlYWRPbmx5VW5zaWduZWRBY2NvdW50c2Agd2hpY2ggd2UgZG9uJ3QgbmVlZFxuICAgIHBhZFJpZ2h0RGVjb2RlcihnZXRVOERlY29kZXIoKSwgMiksXG4gICAgLy8gcmVhZCBzdGF0aWMgYWRkcmVzc2VzXG4gICAgZ2V0QXJyYXlEZWNvZGVyKGdldEFkZHJlc3NEZWNvZGVyKCksIHsgc2l6ZTogZ2V0U2hvcnRVMTZEZWNvZGVyKCkgfSlcbiAgXSk7XG4gIGNvbnN0IFtfdHhWZXJzaW9uLCBudW1SZXF1aXJlZFNpZ25hdHVyZXMsIHN0YXRpY0FkZHJlc3Nlc10gPSBzaWduZXJBZGRyZXNzZXNEZWNvZGVyLmRlY29kZShtZXNzYWdlQnl0ZXMpO1xuICBjb25zdCBzaWduZXJBZGRyZXNzZXMgPSBzdGF0aWNBZGRyZXNzZXMuc2xpY2UoMCwgbnVtUmVxdWlyZWRTaWduYXR1cmVzKTtcbiAgaWYgKHNpZ25lckFkZHJlc3Nlcy5sZW5ndGggIT09IHNpZ25hdHVyZXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX01FU1NBR0VfU0lHTkFUVVJFU19NSVNNQVRDSCwge1xuICAgICAgbnVtUmVxdWlyZWRTaWduYXR1cmVzLFxuICAgICAgc2lnbmF0dXJlc0xlbmd0aDogc2lnbmF0dXJlcy5sZW5ndGgsXG4gICAgICBzaWduZXJBZGRyZXNzZXNcbiAgICB9KTtcbiAgfVxuICBjb25zdCBzaWduYXR1cmVzTWFwID0ge307XG4gIHNpZ25lckFkZHJlc3Nlcy5mb3JFYWNoKChhZGRyZXNzLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IHNpZ25hdHVyZUZvckFkZHJlc3MgPSBzaWduYXR1cmVzW2luZGV4XTtcbiAgICBpZiAoc2lnbmF0dXJlRm9yQWRkcmVzcy5ldmVyeSgoYikgPT4gYiA9PT0gMCkpIHtcbiAgICAgIHNpZ25hdHVyZXNNYXBbYWRkcmVzc10gPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaWduYXR1cmVzTWFwW2FkZHJlc3NdID0gc2lnbmF0dXJlRm9yQWRkcmVzcztcbiAgICB9XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIG1lc3NhZ2VCeXRlcyxcbiAgICBzaWduYXR1cmVzOiBPYmplY3QuZnJlZXplKHNpZ25hdHVyZXNNYXApXG4gIH07XG59XG52YXIgU1lTVEVNX1BST0dSQU1fQUREUkVTUyA9IFwiMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTFcIjtcbmZ1bmN0aW9uIGNvbXBpbGVkSW5zdHJ1Y3Rpb25Jc0FkdmFuY2VOb25jZUluc3RydWN0aW9uKGluc3RydWN0aW9uLCBzdGF0aWNBZGRyZXNzZXMpIHtcbiAgcmV0dXJuIHN0YXRpY0FkZHJlc3Nlc1tpbnN0cnVjdGlvbi5wcm9ncmFtQWRkcmVzc0luZGV4XSA9PT0gU1lTVEVNX1BST0dSQU1fQUREUkVTUyAmJiAvLyBUZXN0IGZvciBgQWR2YW5jZU5vbmNlQWNjb3VudGAgaW5zdHJ1Y3Rpb24gZGF0YVxuICBpbnN0cnVjdGlvbi5kYXRhICE9IG51bGwgJiYgaXNBZHZhbmNlTm9uY2VBY2NvdW50SW5zdHJ1Y3Rpb25EYXRhKGluc3RydWN0aW9uLmRhdGEpICYmIC8vIFRlc3QgZm9yIGV4YWN0bHkgMyBhY2NvdW50c1xuICBpbnN0cnVjdGlvbi5hY2NvdW50SW5kaWNlcz8ubGVuZ3RoID09PSAzO1xufVxuZnVuY3Rpb24gaXNBZHZhbmNlTm9uY2VBY2NvdW50SW5zdHJ1Y3Rpb25EYXRhKGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEuYnl0ZUxlbmd0aCA9PT0gNCAmJiBkYXRhWzBdID09PSA0ICYmIGRhdGFbMV0gPT09IDAgJiYgZGF0YVsyXSA9PT0gMCAmJiBkYXRhWzNdID09PSAwO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0VHJhbnNhY3Rpb25MaWZldGltZUNvbnN0cmFpbnRGcm9tQ29tcGlsZWRUcmFuc2FjdGlvbk1lc3NhZ2UoY29tcGlsZWRUcmFuc2FjdGlvbk1lc3NhZ2UpIHtcbiAgY29uc3QgZmlyc3RJbnN0cnVjdGlvbiA9IGNvbXBpbGVkVHJhbnNhY3Rpb25NZXNzYWdlLmluc3RydWN0aW9uc1swXTtcbiAgY29uc3QgeyBzdGF0aWNBY2NvdW50cyB9ID0gY29tcGlsZWRUcmFuc2FjdGlvbk1lc3NhZ2U7XG4gIGlmIChmaXJzdEluc3RydWN0aW9uICYmIGNvbXBpbGVkSW5zdHJ1Y3Rpb25Jc0FkdmFuY2VOb25jZUluc3RydWN0aW9uKGZpcnN0SW5zdHJ1Y3Rpb24sIHN0YXRpY0FjY291bnRzKSkge1xuICAgIGNvbnN0IG5vbmNlQWNjb3VudEFkZHJlc3MgPSBzdGF0aWNBY2NvdW50c1tmaXJzdEluc3RydWN0aW9uLmFjY291bnRJbmRpY2VzWzBdXTtcbiAgICBpZiAoIW5vbmNlQWNjb3VudEFkZHJlc3MpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19OT05DRV9BQ0NPVU5UX0NBTk5PVF9CRV9JTl9MT09LVVBfVEFCTEUsIHtcbiAgICAgICAgbm9uY2U6IGNvbXBpbGVkVHJhbnNhY3Rpb25NZXNzYWdlLmxpZmV0aW1lVG9rZW5cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgbm9uY2U6IGNvbXBpbGVkVHJhbnNhY3Rpb25NZXNzYWdlLmxpZmV0aW1lVG9rZW4sXG4gICAgICBub25jZUFjY291bnRBZGRyZXNzXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgYmxvY2toYXNoOiBjb21waWxlZFRyYW5zYWN0aW9uTWVzc2FnZS5saWZldGltZVRva2VuLFxuICAgICAgLy8gVGhpcyBpcyBub3Qga25vd24gZnJvbSB0aGUgY29tcGlsZWQgbWVzc2FnZSwgc28gd2Ugc2V0IGl0IHRvIHRoZSBtYXhpbXVtIHBvc3NpYmxlIHZhbHVlXG4gICAgICBsYXN0VmFsaWRCbG9ja0hlaWdodDogMHhmZmZmZmZmZmZmZmZmZmZmblxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGlzVHJhbnNhY3Rpb25XaXRoQmxvY2toYXNoTGlmZXRpbWUodHJhbnNhY3Rpb24pIHtcbiAgcmV0dXJuIFwibGlmZXRpbWVDb25zdHJhaW50XCIgaW4gdHJhbnNhY3Rpb24gJiYgXCJibG9ja2hhc2hcIiBpbiB0cmFuc2FjdGlvbi5saWZldGltZUNvbnN0cmFpbnQgJiYgdHlwZW9mIHRyYW5zYWN0aW9uLmxpZmV0aW1lQ29uc3RyYWludC5ibG9ja2hhc2ggPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHRyYW5zYWN0aW9uLmxpZmV0aW1lQ29uc3RyYWludC5sYXN0VmFsaWRCbG9ja0hlaWdodCA9PT0gXCJiaWdpbnRcIiAmJiBpc0Jsb2NraGFzaCh0cmFuc2FjdGlvbi5saWZldGltZUNvbnN0cmFpbnQuYmxvY2toYXNoKTtcbn1cbmZ1bmN0aW9uIGFzc2VydElzVHJhbnNhY3Rpb25XaXRoQmxvY2toYXNoTGlmZXRpbWUodHJhbnNhY3Rpb24pIHtcbiAgaWYgKCFpc1RyYW5zYWN0aW9uV2l0aEJsb2NraGFzaExpZmV0aW1lKHRyYW5zYWN0aW9uKSkge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19FWFBFQ1RFRF9CTE9DS0hBU0hfTElGRVRJTUUpO1xuICB9XG59XG5mdW5jdGlvbiBpc1RyYW5zYWN0aW9uV2l0aER1cmFibGVOb25jZUxpZmV0aW1lKHRyYW5zYWN0aW9uKSB7XG4gIHJldHVybiBcImxpZmV0aW1lQ29uc3RyYWludFwiIGluIHRyYW5zYWN0aW9uICYmIFwibm9uY2VcIiBpbiB0cmFuc2FjdGlvbi5saWZldGltZUNvbnN0cmFpbnQgJiYgdHlwZW9mIHRyYW5zYWN0aW9uLmxpZmV0aW1lQ29uc3RyYWludC5ub25jZSA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgdHJhbnNhY3Rpb24ubGlmZXRpbWVDb25zdHJhaW50Lm5vbmNlQWNjb3VudEFkZHJlc3MgPT09IFwic3RyaW5nXCIgJiYgaXNBZGRyZXNzKHRyYW5zYWN0aW9uLmxpZmV0aW1lQ29uc3RyYWludC5ub25jZUFjY291bnRBZGRyZXNzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydElzVHJhbnNhY3Rpb25XaXRoRHVyYWJsZU5vbmNlTGlmZXRpbWUodHJhbnNhY3Rpb24pIHtcbiAgaWYgKCFpc1RyYW5zYWN0aW9uV2l0aER1cmFibGVOb25jZUxpZmV0aW1lKHRyYW5zYWN0aW9uKSkge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19FWFBFQ1RFRF9OT05DRV9MSUZFVElNRSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbXBpbGVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbk1lc3NhZ2UpIHtcbiAgY29uc3QgY29tcGlsZWRNZXNzYWdlID0gY29tcGlsZVRyYW5zYWN0aW9uTWVzc2FnZSh0cmFuc2FjdGlvbk1lc3NhZ2UpO1xuICBjb25zdCBtZXNzYWdlQnl0ZXMgPSBnZXRDb21waWxlZFRyYW5zYWN0aW9uTWVzc2FnZUVuY29kZXIoKS5lbmNvZGUoY29tcGlsZWRNZXNzYWdlKTtcbiAgY29uc3QgdHJhbnNhY3Rpb25TaWduZXJzID0gY29tcGlsZWRNZXNzYWdlLnN0YXRpY0FjY291bnRzLnNsaWNlKDAsIGNvbXBpbGVkTWVzc2FnZS5oZWFkZXIubnVtU2lnbmVyQWNjb3VudHMpO1xuICBjb25zdCBzaWduYXR1cmVzID0ge307XG4gIGZvciAoY29uc3Qgc2lnbmVyQWRkcmVzcyBvZiB0cmFuc2FjdGlvblNpZ25lcnMpIHtcbiAgICBzaWduYXR1cmVzW3NpZ25lckFkZHJlc3NdID0gbnVsbDtcbiAgfVxuICBsZXQgbGlmZXRpbWVDb25zdHJhaW50O1xuICBpZiAoaXNUcmFuc2FjdGlvbk1lc3NhZ2VXaXRoQmxvY2toYXNoTGlmZXRpbWUodHJhbnNhY3Rpb25NZXNzYWdlKSkge1xuICAgIGxpZmV0aW1lQ29uc3RyYWludCA9IHtcbiAgICAgIGJsb2NraGFzaDogdHJhbnNhY3Rpb25NZXNzYWdlLmxpZmV0aW1lQ29uc3RyYWludC5ibG9ja2hhc2gsXG4gICAgICBsYXN0VmFsaWRCbG9ja0hlaWdodDogdHJhbnNhY3Rpb25NZXNzYWdlLmxpZmV0aW1lQ29uc3RyYWludC5sYXN0VmFsaWRCbG9ja0hlaWdodFxuICAgIH07XG4gIH0gZWxzZSBpZiAoaXNUcmFuc2FjdGlvbk1lc3NhZ2VXaXRoRHVyYWJsZU5vbmNlTGlmZXRpbWUodHJhbnNhY3Rpb25NZXNzYWdlKSkge1xuICAgIGxpZmV0aW1lQ29uc3RyYWludCA9IHtcbiAgICAgIG5vbmNlOiB0cmFuc2FjdGlvbk1lc3NhZ2UubGlmZXRpbWVDb25zdHJhaW50Lm5vbmNlLFxuICAgICAgbm9uY2VBY2NvdW50QWRkcmVzczogdHJhbnNhY3Rpb25NZXNzYWdlLmluc3RydWN0aW9uc1swXS5hY2NvdW50c1swXS5hZGRyZXNzXG4gICAgfTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgLi4ubGlmZXRpbWVDb25zdHJhaW50ID8geyBsaWZldGltZUNvbnN0cmFpbnQgfSA6IHZvaWQgMCxcbiAgICBtZXNzYWdlQnl0ZXMsXG4gICAgc2lnbmF0dXJlczogT2JqZWN0LmZyZWV6ZShzaWduYXR1cmVzKVxuICB9KTtcbn1cbnZhciBiYXNlNThEZWNvZGVyO1xuZnVuY3Rpb24gZ2V0U2lnbmF0dXJlRnJvbVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gIGlmICghYmFzZTU4RGVjb2RlcikgYmFzZTU4RGVjb2RlciA9IGdldEJhc2U1OERlY29kZXIoKTtcbiAgY29uc3Qgc2lnbmF0dXJlQnl0ZXMgPSBPYmplY3QudmFsdWVzKHRyYW5zYWN0aW9uLnNpZ25hdHVyZXMpWzBdO1xuICBpZiAoIXNpZ25hdHVyZUJ5dGVzKSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZFRV9QQVlFUl9TSUdOQVRVUkVfTUlTU0lORyk7XG4gIH1cbiAgY29uc3QgdHJhbnNhY3Rpb25TaWduYXR1cmUgPSBiYXNlNThEZWNvZGVyLmRlY29kZShzaWduYXR1cmVCeXRlcyk7XG4gIHJldHVybiB0cmFuc2FjdGlvblNpZ25hdHVyZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHBhcnRpYWxseVNpZ25UcmFuc2FjdGlvbihrZXlQYWlycywgdHJhbnNhY3Rpb24pIHtcbiAgbGV0IG5ld1NpZ25hdHVyZXM7XG4gIGxldCB1bmV4cGVjdGVkU2lnbmVycztcbiAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAga2V5UGFpcnMubWFwKGFzeW5jIChrZXlQYWlyKSA9PiB7XG4gICAgICBjb25zdCBhZGRyZXNzID0gYXdhaXQgZ2V0QWRkcmVzc0Zyb21QdWJsaWNLZXkoa2V5UGFpci5wdWJsaWNLZXkpO1xuICAgICAgY29uc3QgZXhpc3RpbmdTaWduYXR1cmUgPSB0cmFuc2FjdGlvbi5zaWduYXR1cmVzW2FkZHJlc3NdO1xuICAgICAgaWYgKGV4aXN0aW5nU2lnbmF0dXJlID09PSB2b2lkIDApIHtcbiAgICAgICAgdW5leHBlY3RlZFNpZ25lcnMgfHw9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICAgIHVuZXhwZWN0ZWRTaWduZXJzLmFkZChhZGRyZXNzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHVuZXhwZWN0ZWRTaWduZXJzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5ld1NpZ25hdHVyZSA9IGF3YWl0IHNpZ25CeXRlcyhrZXlQYWlyLnByaXZhdGVLZXksIHRyYW5zYWN0aW9uLm1lc3NhZ2VCeXRlcyk7XG4gICAgICBpZiAoZXhpc3RpbmdTaWduYXR1cmUgIT09IG51bGwgJiYgYnl0ZXNFcXVhbChuZXdTaWduYXR1cmUsIGV4aXN0aW5nU2lnbmF0dXJlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBuZXdTaWduYXR1cmVzIHx8PSB7fTtcbiAgICAgIG5ld1NpZ25hdHVyZXNbYWRkcmVzc10gPSBuZXdTaWduYXR1cmU7XG4gICAgfSlcbiAgKTtcbiAgaWYgKHVuZXhwZWN0ZWRTaWduZXJzICYmIHVuZXhwZWN0ZWRTaWduZXJzLnNpemUgPiAwKSB7XG4gICAgY29uc3QgZXhwZWN0ZWRTaWduZXJzID0gT2JqZWN0LmtleXModHJhbnNhY3Rpb24uc2lnbmF0dXJlcyk7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0FERFJFU1NFU19DQU5OT1RfU0lHTl9UUkFOU0FDVElPTiwge1xuICAgICAgZXhwZWN0ZWRBZGRyZXNzZXM6IGV4cGVjdGVkU2lnbmVycyxcbiAgICAgIHVuZXhwZWN0ZWRBZGRyZXNzZXM6IFsuLi51bmV4cGVjdGVkU2lnbmVyc11cbiAgICB9KTtcbiAgfVxuICBpZiAoIW5ld1NpZ25hdHVyZXMpIHtcbiAgICByZXR1cm4gdHJhbnNhY3Rpb247XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgIC4uLnRyYW5zYWN0aW9uLFxuICAgIHNpZ25hdHVyZXM6IE9iamVjdC5mcmVlemUoe1xuICAgICAgLi4udHJhbnNhY3Rpb24uc2lnbmF0dXJlcyxcbiAgICAgIC4uLm5ld1NpZ25hdHVyZXNcbiAgICB9KVxuICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNpZ25UcmFuc2FjdGlvbihrZXlQYWlycywgdHJhbnNhY3Rpb24pIHtcbiAgY29uc3Qgb3V0ID0gYXdhaXQgcGFydGlhbGx5U2lnblRyYW5zYWN0aW9uKGtleVBhaXJzLCB0cmFuc2FjdGlvbik7XG4gIGFzc2VydElzRnVsbHlTaWduZWRUcmFuc2FjdGlvbihvdXQpO1xuICBPYmplY3QuZnJlZXplKG91dCk7XG4gIHJldHVybiBvdXQ7XG59XG5mdW5jdGlvbiBpc0Z1bGx5U2lnbmVkVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHRyYW5zYWN0aW9uLnNpZ25hdHVyZXMpLmV2ZXJ5KChbXywgc2lnbmF0dXJlQnl0ZXNdKSA9PiAhIXNpZ25hdHVyZUJ5dGVzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydElzRnVsbHlTaWduZWRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICBjb25zdCBtaXNzaW5nU2lncyA9IFtdO1xuICBPYmplY3QuZW50cmllcyh0cmFuc2FjdGlvbi5zaWduYXR1cmVzKS5mb3JFYWNoKChbYWRkcmVzcywgc2lnbmF0dXJlQnl0ZXNdKSA9PiB7XG4gICAgaWYgKCFzaWduYXR1cmVCeXRlcykge1xuICAgICAgbWlzc2luZ1NpZ3MucHVzaChhZGRyZXNzKTtcbiAgICB9XG4gIH0pO1xuICBpZiAobWlzc2luZ1NpZ3MubGVuZ3RoID4gMCkge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19TSUdOQVRVUkVTX01JU1NJTkcsIHtcbiAgICAgIGFkZHJlc3NlczogbWlzc2luZ1NpZ3NcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0QmFzZTY0RW5jb2RlZFdpcmVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICBjb25zdCB3aXJlVHJhbnNhY3Rpb25CeXRlcyA9IGdldFRyYW5zYWN0aW9uRW5jb2RlcigpLmVuY29kZSh0cmFuc2FjdGlvbik7XG4gIHJldHVybiBnZXRCYXNlNjREZWNvZGVyKCkuZGVjb2RlKHdpcmVUcmFuc2FjdGlvbkJ5dGVzKTtcbn1cbnZhciBUUkFOU0FDVElPTl9QQUNLRVRfU0laRSA9IDEyODA7XG52YXIgVFJBTlNBQ1RJT05fUEFDS0VUX0hFQURFUiA9IDQwICsgODtcbnZhciBUUkFOU0FDVElPTl9TSVpFX0xJTUlUID0gVFJBTlNBQ1RJT05fUEFDS0VUX1NJWkUgLSBUUkFOU0FDVElPTl9QQUNLRVRfSEVBREVSO1xuZnVuY3Rpb24gZ2V0VHJhbnNhY3Rpb25TaXplKHRyYW5zYWN0aW9uKSB7XG4gIHJldHVybiBnZXRUcmFuc2FjdGlvbkVuY29kZXIoKS5nZXRTaXplRnJvbVZhbHVlKHRyYW5zYWN0aW9uKTtcbn1cbmZ1bmN0aW9uIGlzVHJhbnNhY3Rpb25XaXRoaW5TaXplTGltaXQodHJhbnNhY3Rpb24pIHtcbiAgcmV0dXJuIGdldFRyYW5zYWN0aW9uU2l6ZSh0cmFuc2FjdGlvbikgPD0gVFJBTlNBQ1RJT05fU0laRV9MSU1JVDtcbn1cbmZ1bmN0aW9uIGFzc2VydElzVHJhbnNhY3Rpb25XaXRoaW5TaXplTGltaXQodHJhbnNhY3Rpb24pIHtcbiAgY29uc3QgdHJhbnNhY3Rpb25TaXplID0gZ2V0VHJhbnNhY3Rpb25TaXplKHRyYW5zYWN0aW9uKTtcbiAgaWYgKHRyYW5zYWN0aW9uU2l6ZSA+IFRSQU5TQUNUSU9OX1NJWkVfTElNSVQpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRVhDRUVEU19TSVpFX0xJTUlULCB7XG4gICAgICB0cmFuc2FjdGlvblNpemUsXG4gICAgICB0cmFuc2FjdGlvblNpemVMaW1pdDogVFJBTlNBQ1RJT05fU0laRV9MSU1JVFxuICAgIH0pO1xuICB9XG59XG5cbi8vIHNyYy9zZW5kYWJsZS10cmFuc2FjdGlvbi50c1xuZnVuY3Rpb24gaXNTZW5kYWJsZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gIHJldHVybiBpc0Z1bGx5U2lnbmVkVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pICYmIGlzVHJhbnNhY3Rpb25XaXRoaW5TaXplTGltaXQodHJhbnNhY3Rpb24pO1xufVxuZnVuY3Rpb24gYXNzZXJ0SXNTZW5kYWJsZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gIGFzc2VydElzRnVsbHlTaWduZWRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbik7XG4gIGFzc2VydElzVHJhbnNhY3Rpb25XaXRoaW5TaXplTGltaXQodHJhbnNhY3Rpb24pO1xufVxuZnVuY3Rpb24gZ2V0VHJhbnNhY3Rpb25NZXNzYWdlU2l6ZSh0cmFuc2FjdGlvbk1lc3NhZ2UpIHtcbiAgcmV0dXJuIGdldFRyYW5zYWN0aW9uU2l6ZShjb21waWxlVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25NZXNzYWdlKSk7XG59XG5mdW5jdGlvbiBpc1RyYW5zYWN0aW9uTWVzc2FnZVdpdGhpblNpemVMaW1pdCh0cmFuc2FjdGlvbk1lc3NhZ2UpIHtcbiAgcmV0dXJuIGdldFRyYW5zYWN0aW9uTWVzc2FnZVNpemUodHJhbnNhY3Rpb25NZXNzYWdlKSA8PSBUUkFOU0FDVElPTl9TSVpFX0xJTUlUO1xufVxuZnVuY3Rpb24gYXNzZXJ0SXNUcmFuc2FjdGlvbk1lc3NhZ2VXaXRoaW5TaXplTGltaXQodHJhbnNhY3Rpb25NZXNzYWdlKSB7XG4gIGNvbnN0IHRyYW5zYWN0aW9uU2l6ZSA9IGdldFRyYW5zYWN0aW9uTWVzc2FnZVNpemUodHJhbnNhY3Rpb25NZXNzYWdlKTtcbiAgaWYgKHRyYW5zYWN0aW9uU2l6ZSA+IFRSQU5TQUNUSU9OX1NJWkVfTElNSVQpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRVhDRUVEU19TSVpFX0xJTUlULCB7XG4gICAgICB0cmFuc2FjdGlvblNpemUsXG4gICAgICB0cmFuc2FjdGlvblNpemVMaW1pdDogVFJBTlNBQ1RJT05fU0laRV9MSU1JVFxuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCB7IFRSQU5TQUNUSU9OX1BBQ0tFVF9IRUFERVIsIFRSQU5TQUNUSU9OX1BBQ0tFVF9TSVpFLCBUUkFOU0FDVElPTl9TSVpFX0xJTUlULCBhc3NlcnRJc0Z1bGx5U2lnbmVkVHJhbnNhY3Rpb24sIGFzc2VydElzU2VuZGFibGVUcmFuc2FjdGlvbiwgYXNzZXJ0SXNUcmFuc2FjdGlvbk1lc3NhZ2VXaXRoaW5TaXplTGltaXQsIGFzc2VydElzVHJhbnNhY3Rpb25XaXRoQmxvY2toYXNoTGlmZXRpbWUsIGFzc2VydElzVHJhbnNhY3Rpb25XaXRoRHVyYWJsZU5vbmNlTGlmZXRpbWUsIGFzc2VydElzVHJhbnNhY3Rpb25XaXRoaW5TaXplTGltaXQsIGNvbXBpbGVUcmFuc2FjdGlvbiwgZ2V0QmFzZTY0RW5jb2RlZFdpcmVUcmFuc2FjdGlvbiwgZ2V0U2lnbmF0dXJlRnJvbVRyYW5zYWN0aW9uLCBnZXRUcmFuc2FjdGlvbkNvZGVjLCBnZXRUcmFuc2FjdGlvbkRlY29kZXIsIGdldFRyYW5zYWN0aW9uRW5jb2RlciwgZ2V0VHJhbnNhY3Rpb25MaWZldGltZUNvbnN0cmFpbnRGcm9tQ29tcGlsZWRUcmFuc2FjdGlvbk1lc3NhZ2UsIGdldFRyYW5zYWN0aW9uTWVzc2FnZVNpemUsIGdldFRyYW5zYWN0aW9uU2l6ZSwgaXNGdWxseVNpZ25lZFRyYW5zYWN0aW9uLCBpc1NlbmRhYmxlVHJhbnNhY3Rpb24sIGlzVHJhbnNhY3Rpb25NZXNzYWdlV2l0aGluU2l6ZUxpbWl0LCBpc1RyYW5zYWN0aW9uV2l0aEJsb2NraGFzaExpZmV0aW1lLCBpc1RyYW5zYWN0aW9uV2l0aER1cmFibGVOb25jZUxpZmV0aW1lLCBpc1RyYW5zYWN0aW9uV2l0aGluU2l6ZUxpbWl0LCBwYXJ0aWFsbHlTaWduVHJhbnNhY3Rpb24sIHNpZ25UcmFuc2FjdGlvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubm9kZS5tanMubWFwXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5ub2RlLm1qcy5tYXAiXSwibmFtZXMiOlsiZ2V0QWRkcmVzc0RlY29kZXIiLCJpc0FkZHJlc3MiLCJnZXRBZGRyZXNzRnJvbVB1YmxpY0tleSIsInRyYW5zZm9ybURlY29kZXIiLCJmaXhEZWNvZGVyU2l6ZSIsImNvbWJpbmVDb2RlYyIsInBhZFJpZ2h0RGVjb2RlciIsImJ5dGVzRXF1YWwiLCJ0cmFuc2Zvcm1FbmNvZGVyIiwiZml4RW5jb2RlclNpemUiLCJnZXRTdHJ1Y3RFbmNvZGVyIiwiZ2V0Qnl0ZXNFbmNvZGVyIiwiZ2V0U3RydWN0RGVjb2RlciIsImdldEFycmF5RGVjb2RlciIsImdldEJ5dGVzRGVjb2RlciIsImdldFR1cGxlRGVjb2RlciIsImdldEFycmF5RW5jb2RlciIsImdldFNob3J0VTE2RGVjb2RlciIsImdldFU4RGVjb2RlciIsImdldFNob3J0VTE2RW5jb2RlciIsIlNvbGFuYUVycm9yIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fTUVTU0FHRV9TSUdOQVRVUkVTX01JU01BVENIIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fTk9OQ0VfQUNDT1VOVF9DQU5OT1RfQkVfSU5fTE9PS1VQX1RBQkxFIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRVhQRUNURURfQkxPQ0tIQVNIX0xJRkVUSU1FIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRVhQRUNURURfTk9OQ0VfTElGRVRJTUUiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GRUVfUEFZRVJfU0lHTkFUVVJFX01JU1NJTkciLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19BRERSRVNTRVNfQ0FOTk9UX1NJR05fVFJBTlNBQ1RJT04iLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19TSUdOQVRVUkVTX01JU1NJTkciLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19FWENFRURTX1NJWkVfTElNSVQiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19DQU5OT1RfRU5DT0RFX1dJVEhfRU1QVFlfU0lHTkFUVVJFUyIsImdldFRyYW5zYWN0aW9uVmVyc2lvbkRlY29kZXIiLCJjb21waWxlVHJhbnNhY3Rpb25NZXNzYWdlIiwiZ2V0Q29tcGlsZWRUcmFuc2FjdGlvbk1lc3NhZ2VFbmNvZGVyIiwiaXNUcmFuc2FjdGlvbk1lc3NhZ2VXaXRoQmxvY2toYXNoTGlmZXRpbWUiLCJpc1RyYW5zYWN0aW9uTWVzc2FnZVdpdGhEdXJhYmxlTm9uY2VMaWZldGltZSIsImlzQmxvY2toYXNoIiwiZ2V0QmFzZTU4RGVjb2RlciIsImdldEJhc2U2NERlY29kZXIiLCJzaWduQnl0ZXMiLCJnZXRTaWduYXR1cmVzVG9FbmNvZGUiLCJzaWduYXR1cmVzTWFwIiwic2lnbmF0dXJlcyIsIk9iamVjdCIsInZhbHVlcyIsImxlbmd0aCIsIm1hcCIsInNpZ25hdHVyZSIsIlVpbnQ4QXJyYXkiLCJmaWxsIiwiZ2V0U2lnbmF0dXJlc0VuY29kZXIiLCJzaXplIiwiZ2V0VHJhbnNhY3Rpb25FbmNvZGVyIiwiZ2V0VHJhbnNhY3Rpb25EZWNvZGVyIiwiZGVjb2RlUGFydGlhbGx5RGVjb2RlZFRyYW5zYWN0aW9uIiwiZ2V0VHJhbnNhY3Rpb25Db2RlYyIsInRyYW5zYWN0aW9uIiwibWVzc2FnZUJ5dGVzIiwic2lnbmVyQWRkcmVzc2VzRGVjb2RlciIsIl90eFZlcnNpb24iLCJudW1SZXF1aXJlZFNpZ25hdHVyZXMiLCJzdGF0aWNBZGRyZXNzZXMiLCJkZWNvZGUiLCJzaWduZXJBZGRyZXNzZXMiLCJzbGljZSIsInNpZ25hdHVyZXNMZW5ndGgiLCJmb3JFYWNoIiwiYWRkcmVzcyIsImluZGV4Iiwic2lnbmF0dXJlRm9yQWRkcmVzcyIsImV2ZXJ5IiwiYiIsImZyZWV6ZSIsIlNZU1RFTV9QUk9HUkFNX0FERFJFU1MiLCJjb21waWxlZEluc3RydWN0aW9uSXNBZHZhbmNlTm9uY2VJbnN0cnVjdGlvbiIsImluc3RydWN0aW9uIiwicHJvZ3JhbUFkZHJlc3NJbmRleCIsImRhdGEiLCJpc0FkdmFuY2VOb25jZUFjY291bnRJbnN0cnVjdGlvbkRhdGEiLCJhY2NvdW50SW5kaWNlcyIsImJ5dGVMZW5ndGgiLCJnZXRUcmFuc2FjdGlvbkxpZmV0aW1lQ29uc3RyYWludEZyb21Db21waWxlZFRyYW5zYWN0aW9uTWVzc2FnZSIsImNvbXBpbGVkVHJhbnNhY3Rpb25NZXNzYWdlIiwiZmlyc3RJbnN0cnVjdGlvbiIsImluc3RydWN0aW9ucyIsInN0YXRpY0FjY291bnRzIiwibm9uY2VBY2NvdW50QWRkcmVzcyIsIm5vbmNlIiwibGlmZXRpbWVUb2tlbiIsImJsb2NraGFzaCIsImxhc3RWYWxpZEJsb2NrSGVpZ2h0IiwiaXNUcmFuc2FjdGlvbldpdGhCbG9ja2hhc2hMaWZldGltZSIsImxpZmV0aW1lQ29uc3RyYWludCIsImFzc2VydElzVHJhbnNhY3Rpb25XaXRoQmxvY2toYXNoTGlmZXRpbWUiLCJpc1RyYW5zYWN0aW9uV2l0aER1cmFibGVOb25jZUxpZmV0aW1lIiwiYXNzZXJ0SXNUcmFuc2FjdGlvbldpdGhEdXJhYmxlTm9uY2VMaWZldGltZSIsImNvbXBpbGVUcmFuc2FjdGlvbiIsInRyYW5zYWN0aW9uTWVzc2FnZSIsImNvbXBpbGVkTWVzc2FnZSIsImVuY29kZSIsInRyYW5zYWN0aW9uU2lnbmVycyIsImhlYWRlciIsIm51bVNpZ25lckFjY291bnRzIiwic2lnbmVyQWRkcmVzcyIsImFjY291bnRzIiwiYmFzZTU4RGVjb2RlciIsImdldFNpZ25hdHVyZUZyb21UcmFuc2FjdGlvbiIsInNpZ25hdHVyZUJ5dGVzIiwidHJhbnNhY3Rpb25TaWduYXR1cmUiLCJwYXJ0aWFsbHlTaWduVHJhbnNhY3Rpb24iLCJrZXlQYWlycyIsIm5ld1NpZ25hdHVyZXMiLCJ1bmV4cGVjdGVkU2lnbmVycyIsIlByb21pc2UiLCJhbGwiLCJrZXlQYWlyIiwicHVibGljS2V5IiwiZXhpc3RpbmdTaWduYXR1cmUiLCJTZXQiLCJhZGQiLCJuZXdTaWduYXR1cmUiLCJwcml2YXRlS2V5IiwiZXhwZWN0ZWRTaWduZXJzIiwia2V5cyIsImV4cGVjdGVkQWRkcmVzc2VzIiwidW5leHBlY3RlZEFkZHJlc3NlcyIsInNpZ25UcmFuc2FjdGlvbiIsIm91dCIsImFzc2VydElzRnVsbHlTaWduZWRUcmFuc2FjdGlvbiIsImlzRnVsbHlTaWduZWRUcmFuc2FjdGlvbiIsImVudHJpZXMiLCJfIiwibWlzc2luZ1NpZ3MiLCJwdXNoIiwiYWRkcmVzc2VzIiwiZ2V0QmFzZTY0RW5jb2RlZFdpcmVUcmFuc2FjdGlvbiIsIndpcmVUcmFuc2FjdGlvbkJ5dGVzIiwiVFJBTlNBQ1RJT05fUEFDS0VUX1NJWkUiLCJUUkFOU0FDVElPTl9QQUNLRVRfSEVBREVSIiwiVFJBTlNBQ1RJT05fU0laRV9MSU1JVCIsImdldFRyYW5zYWN0aW9uU2l6ZSIsImdldFNpemVGcm9tVmFsdWUiLCJpc1RyYW5zYWN0aW9uV2l0aGluU2l6ZUxpbWl0IiwiYXNzZXJ0SXNUcmFuc2FjdGlvbldpdGhpblNpemVMaW1pdCIsInRyYW5zYWN0aW9uU2l6ZSIsInRyYW5zYWN0aW9uU2l6ZUxpbWl0IiwiaXNTZW5kYWJsZVRyYW5zYWN0aW9uIiwiYXNzZXJ0SXNTZW5kYWJsZVRyYW5zYWN0aW9uIiwiZ2V0VHJhbnNhY3Rpb25NZXNzYWdlU2l6ZSIsImlzVHJhbnNhY3Rpb25NZXNzYWdlV2l0aGluU2l6ZUxpbWl0IiwiYXNzZXJ0SXNUcmFuc2FjdGlvbk1lc3NhZ2VXaXRoaW5TaXplTGltaXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/transactions/dist/index.node.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/_shortw_utils.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/_shortw_utils.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCurve: () => (/* binding */ createCurve),\n/* harmony export */   getHash: () => (/* binding */ getHash)\n/* harmony export */ });\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/**\n * Utilities for short weierstrass curves, combined with noble-hashes.\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n/** connects noble-curves to noble-hashes */ function getHash(hash) {\n    return {\n        hash\n    };\n}\n/** @deprecated use new `weierstrass()` and `ecdsa()` methods */ function createCurve(curveDef, defHash) {\n    const create = (hash)=>(0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_0__.weierstrass)({\n            ...curveDef,\n            hash: hash\n        });\n    return {\n        ...create(defHash),\n        create\n    };\n} //# sourceMappingURL=_shortw_utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9fc2hvcnR3X3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7Q0FHQyxHQUNELG9FQUFvRSxHQUNaO0FBQ3hELDBDQUEwQyxHQUNuQyxTQUFTQyxRQUFRQyxJQUFJO0lBQ3hCLE9BQU87UUFBRUE7SUFBSztBQUNsQjtBQUNBLDhEQUE4RCxHQUN2RCxTQUFTQyxZQUFZQyxRQUFRLEVBQUVDLE9BQU87SUFDekMsTUFBTUMsU0FBUyxDQUFDSixPQUFTRixxRUFBV0EsQ0FBQztZQUFFLEdBQUdJLFFBQVE7WUFBRUYsTUFBTUE7UUFBSztJQUMvRCxPQUFPO1FBQUUsR0FBR0ksT0FBT0QsUUFBUTtRQUFFQztJQUFPO0FBQ3hDLEVBQ0EseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xhdy13b3Jrcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dlYjMuanMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL19zaG9ydHdfdXRpbHMuanM/NTdhYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFV0aWxpdGllcyBmb3Igc2hvcnQgd2VpZXJzdHJhc3MgY3VydmVzLCBjb21iaW5lZCB3aXRoIG5vYmxlLWhhc2hlcy5cbiAqIEBtb2R1bGVcbiAqL1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHsgd2VpZXJzdHJhc3MgfSBmcm9tIFwiLi9hYnN0cmFjdC93ZWllcnN0cmFzcy5qc1wiO1xuLyoqIGNvbm5lY3RzIG5vYmxlLWN1cnZlcyB0byBub2JsZS1oYXNoZXMgKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRIYXNoKGhhc2gpIHtcbiAgICByZXR1cm4geyBoYXNoIH07XG59XG4vKiogQGRlcHJlY2F0ZWQgdXNlIG5ldyBgd2VpZXJzdHJhc3MoKWAgYW5kIGBlY2RzYSgpYCBtZXRob2RzICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ3VydmUoY3VydmVEZWYsIGRlZkhhc2gpIHtcbiAgICBjb25zdCBjcmVhdGUgPSAoaGFzaCkgPT4gd2VpZXJzdHJhc3MoeyAuLi5jdXJ2ZURlZiwgaGFzaDogaGFzaCB9KTtcbiAgICByZXR1cm4geyAuLi5jcmVhdGUoZGVmSGFzaCksIGNyZWF0ZSB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3Nob3J0d191dGlscy5qcy5tYXAiXSwibmFtZXMiOlsid2VpZXJzdHJhc3MiLCJnZXRIYXNoIiwiaGFzaCIsImNyZWF0ZUN1cnZlIiwiY3VydmVEZWYiLCJkZWZIYXNoIiwiY3JlYXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/_shortw_utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/curve.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/curve.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _createCurveFields: () => (/* binding */ _createCurveFields),\n/* harmony export */   mulEndoUnsafe: () => (/* binding */ mulEndoUnsafe),\n/* harmony export */   negateCt: () => (/* binding */ negateCt),\n/* harmony export */   normalizeZ: () => (/* binding */ normalizeZ),\n/* harmony export */   pippenger: () => (/* binding */ pippenger),\n/* harmony export */   precomputeMSMUnsafe: () => (/* binding */ precomputeMSMUnsafe),\n/* harmony export */   validateBasic: () => (/* binding */ validateBasic),\n/* harmony export */   wNAF: () => (/* binding */ wNAF)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/utils.js\");\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/modular.js\");\n/**\n * Methods for elliptic curve multiplication by scalars.\n * Contains wNAF, pippenger.\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nfunction negateCt(condition, item) {\n    const neg = item.negate();\n    return condition ? neg : item;\n}\n/**\n * Takes a bunch of Projective Points but executes only one\n * inversion on all of them. Inversion is very slow operation,\n * so this improves performance massively.\n * Optimization: converts a list of projective points to a list of identical points with Z=1.\n */ function normalizeZ(c, points) {\n    const invertedZs = (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.FpInvertBatch)(c.Fp, points.map((p)=>p.Z));\n    return points.map((p, i)=>c.fromAffine(p.toAffine(invertedZs[i])));\n}\nfunction validateW(W, bits) {\n    if (!Number.isSafeInteger(W) || W <= 0 || W > bits) throw new Error(\"invalid window size, expected [1..\" + bits + \"], got W=\" + W);\n}\nfunction calcWOpts(W, scalarBits) {\n    validateW(W, scalarBits);\n    const windows = Math.ceil(scalarBits / W) + 1; // W=8 33. Not 32, because we skip zero\n    const windowSize = 2 ** (W - 1); // W=8 128. Not 256, because we skip zero\n    const maxNumber = 2 ** W; // W=8 256\n    const mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.bitMask)(W); // W=8 255 == mask 0b11111111\n    const shiftBy = BigInt(W); // W=8 8\n    return {\n        windows,\n        windowSize,\n        mask,\n        maxNumber,\n        shiftBy\n    };\n}\nfunction calcOffsets(n, window, wOpts) {\n    const { windowSize, mask, maxNumber, shiftBy } = wOpts;\n    let wbits = Number(n & mask); // extract W bits.\n    let nextN = n >> shiftBy; // shift number by W bits.\n    // What actually happens here:\n    // const highestBit = Number(mask ^ (mask >> 1n));\n    // let wbits2 = wbits - 1; // skip zero\n    // if (wbits2 & highestBit) { wbits2 ^= Number(mask); // (~);\n    // split if bits > max: +224 => 256-32\n    if (wbits > windowSize) {\n        // we skip zero, which means instead of `>= size-1`, we do `> size`\n        wbits -= maxNumber; // -32, can be maxNumber - wbits, but then we need to set isNeg here.\n        nextN += _1n; // +256 (carry)\n    }\n    const offsetStart = window * windowSize;\n    const offset = offsetStart + Math.abs(wbits) - 1; // -1 because we skip zero\n    const isZero = wbits === 0; // is current window slice a 0?\n    const isNeg = wbits < 0; // is current window slice negative?\n    const isNegF = window % 2 !== 0; // fake random statement for noise\n    const offsetF = offsetStart; // fake offset for noise\n    return {\n        nextN,\n        offset,\n        isZero,\n        isNeg,\n        isNegF,\n        offsetF\n    };\n}\nfunction validateMSMPoints(points, c) {\n    if (!Array.isArray(points)) throw new Error(\"array expected\");\n    points.forEach((p, i)=>{\n        if (!(p instanceof c)) throw new Error(\"invalid point at index \" + i);\n    });\n}\nfunction validateMSMScalars(scalars, field) {\n    if (!Array.isArray(scalars)) throw new Error(\"array of scalars expected\");\n    scalars.forEach((s, i)=>{\n        if (!field.isValid(s)) throw new Error(\"invalid scalar at index \" + i);\n    });\n}\n// Since points in different groups cannot be equal (different object constructor),\n// we can have single place to store precomputes.\n// Allows to make points frozen / immutable.\nconst pointPrecomputes = new WeakMap();\nconst pointWindowSizes = new WeakMap();\nfunction getW(P) {\n    // To disable precomputes:\n    // return 1;\n    return pointWindowSizes.get(P) || 1;\n}\nfunction assert0(n) {\n    if (n !== _0n) throw new Error(\"invalid wNAF\");\n}\n/**\n * Elliptic curve multiplication of Point by scalar. Fragile.\n * Table generation takes **30MB of ram and 10ms on high-end CPU**,\n * but may take much longer on slow devices. Actual generation will happen on\n * first call of `multiply()`. By default, `BASE` point is precomputed.\n *\n * Scalars should always be less than curve order: this should be checked inside of a curve itself.\n * Creates precomputation tables for fast multiplication:\n * - private scalar is split by fixed size windows of W bits\n * - every window point is collected from window's table & added to accumulator\n * - since windows are different, same point inside tables won't be accessed more than once per calc\n * - each multiplication is 'Math.ceil(CURVE_ORDER / ) + 1' point additions (fixed for any scalar)\n * - +1 window is neccessary for wNAF\n * - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n *\n * @todo Research returning 2d JS array of windows, instead of a single window.\n * This would allow windows to be in different memory locations\n */ class wNAF {\n    // Parametrized with a given Point class (not individual point)\n    constructor(Point, bits){\n        this.BASE = Point.BASE;\n        this.ZERO = Point.ZERO;\n        this.Fn = Point.Fn;\n        this.bits = bits;\n    }\n    // non-const time multiplication ladder\n    _unsafeLadder(elm, n, p = this.ZERO) {\n        let d = elm;\n        while(n > _0n){\n            if (n & _1n) p = p.add(d);\n            d = d.double();\n            n >>= _1n;\n        }\n        return p;\n    }\n    /**\n     * Creates a wNAF precomputation window. Used for caching.\n     * Default window size is set by `utils.precompute()` and is equal to 8.\n     * Number of precomputed points depends on the curve size:\n     * 2^(1) * (Math.ceil( / ) + 1), where:\n     * -  is the window size\n     * -  is the bitlength of the curve order.\n     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n     * @param point Point instance\n     * @param W window size\n     * @returns precomputed point tables flattened to a single array\n     */ precomputeWindow(point, W) {\n        const { windows, windowSize } = calcWOpts(W, this.bits);\n        const points = [];\n        let p = point;\n        let base = p;\n        for(let window = 0; window < windows; window++){\n            base = p;\n            points.push(base);\n            // i=1, bc we skip 0\n            for(let i = 1; i < windowSize; i++){\n                base = base.add(p);\n                points.push(base);\n            }\n            p = base.double();\n        }\n        return points;\n    }\n    /**\n     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n     * More compact implementation:\n     * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541\n     * @returns real and fake (for const-time) points\n     */ wNAF(W, precomputes, n) {\n        // Scalar should be smaller than field order\n        if (!this.Fn.isValid(n)) throw new Error(\"invalid scalar\");\n        // Accumulators\n        let p = this.ZERO;\n        let f = this.BASE;\n        // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n        // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n        // there is negate now: it is possible that negated element from low value\n        // would be the same as high element, which will create carry into next window.\n        // It's not obvious how this can fail, but still worth investigating later.\n        const wo = calcWOpts(W, this.bits);\n        for(let window = 0; window < wo.windows; window++){\n            // (n === _0n) is handled and not early-exited. isEven and offsetF are used for noise\n            const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window, wo);\n            n = nextN;\n            if (isZero) {\n                // bits are 0: add garbage to fake point\n                // Important part for const-time getPublicKey: add random \"noise\" point to f.\n                f = f.add(negateCt(isNegF, precomputes[offsetF]));\n            } else {\n                // bits are 1: add to result point\n                p = p.add(negateCt(isNeg, precomputes[offset]));\n            }\n        }\n        assert0(n);\n        // Return both real and fake points: JIT won't eliminate f.\n        // At this point there is a way to F be infinity-point even if p is not,\n        // which makes it less const-time: around 1 bigint multiply.\n        return {\n            p,\n            f\n        };\n    }\n    /**\n     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.\n     * @param acc accumulator point to add result of multiplication\n     * @returns point\n     */ wNAFUnsafe(W, precomputes, n, acc = this.ZERO) {\n        const wo = calcWOpts(W, this.bits);\n        for(let window = 0; window < wo.windows; window++){\n            if (n === _0n) break; // Early-exit, skip 0 value\n            const { nextN, offset, isZero, isNeg } = calcOffsets(n, window, wo);\n            n = nextN;\n            if (isZero) {\n                continue;\n            } else {\n                const item = precomputes[offset];\n                acc = acc.add(isNeg ? item.negate() : item); // Re-using acc allows to save adds in MSM\n            }\n        }\n        assert0(n);\n        return acc;\n    }\n    getPrecomputes(W, point, transform) {\n        // Calculate precomputes on a first run, reuse them after\n        let comp = pointPrecomputes.get(point);\n        if (!comp) {\n            comp = this.precomputeWindow(point, W);\n            if (W !== 1) {\n                // Doing transform outside of if brings 15% perf hit\n                if (typeof transform === \"function\") comp = transform(comp);\n                pointPrecomputes.set(point, comp);\n            }\n        }\n        return comp;\n    }\n    cached(point, scalar, transform) {\n        const W = getW(point);\n        return this.wNAF(W, this.getPrecomputes(W, point, transform), scalar);\n    }\n    unsafe(point, scalar, transform, prev) {\n        const W = getW(point);\n        if (W === 1) return this._unsafeLadder(point, scalar, prev); // For W=1 ladder is ~x2 faster\n        return this.wNAFUnsafe(W, this.getPrecomputes(W, point, transform), scalar, prev);\n    }\n    // We calculate precomputes for elliptic curve point multiplication\n    // using windowed method. This specifies window size and\n    // stores precomputed values. Usually only base point would be precomputed.\n    createCache(P, W) {\n        validateW(W, this.bits);\n        pointWindowSizes.set(P, W);\n        pointPrecomputes.delete(P);\n    }\n    hasCache(elm) {\n        return getW(elm) !== 1;\n    }\n}\n/**\n * Endomorphism-specific multiplication for Koblitz curves.\n * Cost: 128 dbl, 0-256 adds.\n */ function mulEndoUnsafe(Point, point, k1, k2) {\n    let acc = point;\n    let p1 = Point.ZERO;\n    let p2 = Point.ZERO;\n    while(k1 > _0n || k2 > _0n){\n        if (k1 & _1n) p1 = p1.add(acc);\n        if (k2 & _1n) p2 = p2.add(acc);\n        acc = acc.double();\n        k1 >>= _1n;\n        k2 >>= _1n;\n    }\n    return {\n        p1,\n        p2\n    };\n}\n/**\n * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * 30x faster vs naive addition on L=4096, 10x faster than precomputes.\n * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.\n * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @param scalars array of L scalars (aka secret keys / bigints)\n */ function pippenger(c, fieldN, points, scalars) {\n    // If we split scalars by some window (let's say 8 bits), every chunk will only\n    // take 256 buckets even if there are 4096 scalars, also re-uses double.\n    // TODO:\n    // - https://eprint.iacr.org/2024/750.pdf\n    // - https://tches.iacr.org/index.php/TCHES/article/view/10287\n    // 0 is accepted in scalars\n    validateMSMPoints(points, c);\n    validateMSMScalars(scalars, fieldN);\n    const plength = points.length;\n    const slength = scalars.length;\n    if (plength !== slength) throw new Error(\"arrays of points and scalars must have equal length\");\n    // if (plength === 0) throw new Error('array must be of length >= 2');\n    const zero = c.ZERO;\n    const wbits = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.bitLen)(BigInt(plength));\n    let windowSize = 1; // bits\n    if (wbits > 12) windowSize = wbits - 3;\n    else if (wbits > 4) windowSize = wbits - 2;\n    else if (wbits > 0) windowSize = 2;\n    const MASK = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.bitMask)(windowSize);\n    const buckets = new Array(Number(MASK) + 1).fill(zero); // +1 for zero array\n    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;\n    let sum = zero;\n    for(let i = lastBits; i >= 0; i -= windowSize){\n        buckets.fill(zero);\n        for(let j = 0; j < slength; j++){\n            const scalar = scalars[j];\n            const wbits = Number(scalar >> BigInt(i) & MASK);\n            buckets[wbits] = buckets[wbits].add(points[j]);\n        }\n        let resI = zero; // not using this will do small speed-up, but will lose ct\n        // Skip first bucket, because it is zero\n        for(let j = buckets.length - 1, sumI = zero; j > 0; j--){\n            sumI = sumI.add(buckets[j]);\n            resI = resI.add(sumI);\n        }\n        sum = sum.add(resI);\n        if (i !== 0) for(let j = 0; j < windowSize; j++)sum = sum.double();\n    }\n    return sum;\n}\n/**\n * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @returns function which multiplies points with scaars\n */ function precomputeMSMUnsafe(c, fieldN, points, windowSize) {\n    /**\n     * Performance Analysis of Window-based Precomputation\n     *\n     * Base Case (256-bit scalar, 8-bit window):\n     * - Standard precomputation requires:\n     *   - 31 additions per scalar  256 scalars = 7,936 ops\n     *   - Plus 255 summary additions = 8,191 total ops\n     *   Note: Summary additions can be optimized via accumulator\n     *\n     * Chunked Precomputation Analysis:\n     * - Using 32 chunks requires:\n     *   - 255 additions per chunk\n     *   - 256 doublings\n     *   - Total: (255  32) + 256 = 8,416 ops\n     *\n     * Memory Usage Comparison:\n     * Window Size | Standard Points | Chunked Points\n     * ------------|-----------------|---------------\n     *     4-bit   |     520         |      15\n     *     8-bit   |    4,224        |     255\n     *    10-bit   |   13,824        |   1,023\n     *    16-bit   |  557,056        |  65,535\n     *\n     * Key Advantages:\n     * 1. Enables larger window sizes due to reduced memory overhead\n     * 2. More efficient for smaller scalar counts:\n     *    - 16 chunks: (16  255) + 256 = 4,336 ops\n     *    - ~2x faster than standard 8,191 ops\n     *\n     * Limitations:\n     * - Not suitable for plain precomputes (requires 256 constant doublings)\n     * - Performance degrades with larger scalar counts:\n     *   - Optimal for ~256 scalars\n     *   - Less efficient for 4096+ scalars (Pippenger preferred)\n     */ validateW(windowSize, fieldN.BITS);\n    validateMSMPoints(points, c);\n    const zero = c.ZERO;\n    const tableSize = 2 ** windowSize - 1; // table size (without zero)\n    const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item\n    const MASK = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.bitMask)(windowSize);\n    const tables = points.map((p)=>{\n        const res = [];\n        for(let i = 0, acc = p; i < tableSize; i++){\n            res.push(acc);\n            acc = acc.add(p);\n        }\n        return res;\n    });\n    return (scalars)=>{\n        validateMSMScalars(scalars, fieldN);\n        if (scalars.length > points.length) throw new Error(\"array of scalars must be smaller than array of points\");\n        let res = zero;\n        for(let i = 0; i < chunks; i++){\n            // No need to double if accumulator is still zero.\n            if (res !== zero) for(let j = 0; j < windowSize; j++)res = res.double();\n            const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);\n            for(let j = 0; j < scalars.length; j++){\n                const n = scalars[j];\n                const curr = Number(n >> shiftBy & MASK);\n                if (!curr) continue; // skip zero scalars chunks\n                res = res.add(tables[j][curr - 1]);\n            }\n        }\n        return res;\n    };\n}\n// TODO: remove\n/** @deprecated */ function validateBasic(curve) {\n    (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.validateField)(curve.Fp);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject)(curve, {\n        n: \"bigint\",\n        h: \"bigint\",\n        Gx: \"field\",\n        Gy: \"field\"\n    }, {\n        nBitLength: \"isSafeInteger\",\n        nByteLength: \"isSafeInteger\"\n    });\n    // Set defaults\n    return Object.freeze({\n        ...(0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.nLength)(curve.n, curve.nBitLength),\n        ...curve,\n        ...{\n            p: curve.Fp.ORDER\n        }\n    });\n}\nfunction createField(order, field, isLE) {\n    if (field) {\n        if (field.ORDER !== order) throw new Error(\"Field.ORDER must match order: Fp == p, Fn == n\");\n        (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.validateField)(field);\n        return field;\n    } else {\n        return (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(order, {\n            isLE\n        });\n    }\n}\n/** Validates CURVE opts and creates fields */ function _createCurveFields(type, CURVE, curveOpts = {}, FpFnLE) {\n    if (FpFnLE === undefined) FpFnLE = type === \"edwards\";\n    if (!CURVE || typeof CURVE !== \"object\") throw new Error(`expected valid ${type} CURVE object`);\n    for (const p of [\n        \"p\",\n        \"n\",\n        \"h\"\n    ]){\n        const val = CURVE[p];\n        if (!(typeof val === \"bigint\" && val > _0n)) throw new Error(`CURVE.${p} must be positive bigint`);\n    }\n    const Fp = createField(CURVE.p, curveOpts.Fp, FpFnLE);\n    const Fn = createField(CURVE.n, curveOpts.Fn, FpFnLE);\n    const _b = type === \"weierstrass\" ? \"b\" : \"d\";\n    const params = [\n        \"Gx\",\n        \"Gy\",\n        \"a\",\n        _b\n    ];\n    for (const p of params){\n        // @ts-ignore\n        if (!Fp.isValid(CURVE[p])) throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);\n    }\n    CURVE = Object.freeze(Object.assign({}, CURVE));\n    return {\n        CURVE,\n        Fp,\n        Fn\n    };\n} //# sourceMappingURL=curve.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9jdXJ2ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Q0FJQyxHQUNELG9FQUFvRSxHQUNOO0FBQ2M7QUFDNUUsTUFBTU8sTUFBTUMsT0FBTztBQUNuQixNQUFNQyxNQUFNRCxPQUFPO0FBQ1osU0FBU0UsU0FBU0MsU0FBUyxFQUFFQyxJQUFJO0lBQ3BDLE1BQU1DLE1BQU1ELEtBQUtFLE1BQU07SUFDdkIsT0FBT0gsWUFBWUUsTUFBTUQ7QUFDN0I7QUFDQTs7Ozs7Q0FLQyxHQUNNLFNBQVNHLFdBQVdDLENBQUMsRUFBRUMsTUFBTTtJQUNoQyxNQUFNQyxhQUFhZCwwREFBYUEsQ0FBQ1ksRUFBRUcsRUFBRSxFQUFFRixPQUFPRyxHQUFHLENBQUMsQ0FBQ0MsSUFBTUEsRUFBRUMsQ0FBQztJQUM1RCxPQUFPTCxPQUFPRyxHQUFHLENBQUMsQ0FBQ0MsR0FBR0UsSUFBTVAsRUFBRVEsVUFBVSxDQUFDSCxFQUFFSSxRQUFRLENBQUNQLFVBQVUsQ0FBQ0ssRUFBRTtBQUNyRTtBQUNBLFNBQVNHLFVBQVVDLENBQUMsRUFBRUMsSUFBSTtJQUN0QixJQUFJLENBQUNDLE9BQU9DLGFBQWEsQ0FBQ0gsTUFBTUEsS0FBSyxLQUFLQSxJQUFJQyxNQUMxQyxNQUFNLElBQUlHLE1BQU0sdUNBQXVDSCxPQUFPLGNBQWNEO0FBQ3BGO0FBQ0EsU0FBU0ssVUFBVUwsQ0FBQyxFQUFFTSxVQUFVO0lBQzVCUCxVQUFVQyxHQUFHTTtJQUNiLE1BQU1DLFVBQVVDLEtBQUtDLElBQUksQ0FBQ0gsYUFBYU4sS0FBSyxHQUFHLHVDQUF1QztJQUN0RixNQUFNVSxhQUFhLEtBQU1WLENBQUFBLElBQUksSUFBSSx5Q0FBeUM7SUFDMUUsTUFBTVcsWUFBWSxLQUFLWCxHQUFHLFVBQVU7SUFDcEMsTUFBTVksT0FBT3RDLGtEQUFPQSxDQUFDMEIs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SUFBSUEsV0FBV0MsV0FDWEQsU0FBU0gsU0FBUztJQUN0QixJQUFJLENBQUNDLFNBQVMsT0FBT0EsVUFBVSxVQUMzQixNQUFNLElBQUloSCxNQUFNLENBQUMsZUFBZSxFQUFFK0csS0FBSyxhQUFhLENBQUM7SUFDekQsS0FBSyxNQUFNekgsS0FBSztRQUFDO1FBQUs7UUFBSztLQUFJLENBQUU7UUFDN0IsTUFBTThILE1BQU1KLEtBQUssQ0FBQzFILEVBQUU7UUFDcEIsSUFBSSxDQUFFLFFBQU84SCxRQUFRLFlBQVlBLE1BQU01SSxHQUFFLEdBQ3JDLE1BQU0sSUFBSXdCLE1BQU0sQ0FBQyxNQUFNLEVBQUVWLEVBQUUsd0JBQXdCLENBQUM7SUFDNUQ7SUFDQSxNQUFNRixLQUFLdUgsWUFBWUssTUFBTTFILENBQUMsRUFBRTJILFVBQVU3SCxFQUFFLEVBQUU4SDtJQUM5QyxNQUFNdEUsS0FBSytELFlBQVlLLE1BQU1yRyxDQUFDLEVBQUVzRyxVQUFVckUsRUFBRSxFQUFFc0U7SUFDOUMsTUFBTUcsS0FBS04sU0FBUyxnQkFBZ0IsTUFBTTtJQUMxQyxNQUFNTyxTQUFTO1FBQUM7UUFBTTtRQUFNO1FBQUtEO0tBQUc7SUFDcEMsS0FBSyxNQUFNL0gsS0FBS2dJLE9BQVE7UUFDcEIsYUFBYTtRQUNiLElBQUksQ0FBQ2xJLEdBQUcyQyxPQUFPLENBQUNpRixLQUFLLENBQUMxSCxFQUFFLEdBQ3BCLE1BQU0sSUFBSVUsTUFBTSxDQUFDLE1BQU0sRUFBRVYsRUFBRSx3Q0FBd0MsQ0FBQztJQUM1RTtJQUNBMEgsUUFBUVIsT0FBT0MsTUFBTSxDQUFDRCxPQUFPZSxNQUFNLENBQUMsQ0FBQyxHQUFHUDtJQUN4QyxPQUFPO1FBQUVBO1FBQU81SDtRQUFJd0Q7SUFBRztBQUMzQixFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsYXctd29ya3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9jdXJ2ZS5qcz85NTg3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTWV0aG9kcyBmb3IgZWxsaXB0aWMgY3VydmUgbXVsdGlwbGljYXRpb24gYnkgc2NhbGFycy5cbiAqIENvbnRhaW5zIHdOQUYsIHBpcHBlbmdlci5cbiAqIEBtb2R1bGVcbiAqL1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHsgYml0TGVuLCBiaXRNYXNrLCB2YWxpZGF0ZU9iamVjdCB9IGZyb20gXCIuLi91dGlscy5qc1wiO1xuaW1wb3J0IHsgRmllbGQsIEZwSW52ZXJ0QmF0Y2gsIG5MZW5ndGgsIHZhbGlkYXRlRmllbGQgfSBmcm9tIFwiLi9tb2R1bGFyLmpzXCI7XG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSBCaWdJbnQoMSk7XG5leHBvcnQgZnVuY3Rpb24gbmVnYXRlQ3QoY29uZGl0aW9uLCBpdGVtKSB7XG4gICAgY29uc3QgbmVnID0gaXRlbS5uZWdhdGUoKTtcbiAgICByZXR1cm4gY29uZGl0aW9uID8gbmVnIDogaXRlbTtcbn1cbi8qKlxuICogVGFrZXMgYSBidW5jaCBvZiBQcm9qZWN0aXZlIFBvaW50cyBidXQgZXhlY3V0ZXMgb25seSBvbmVcbiAqIGludmVyc2lvbiBvbiBhbGwgb2YgdGhlbS4gSW52ZXJzaW9uIGlzIHZlcnkgc2xvdyBvcGVyYXRpb24sXG4gKiBzbyB0aGlzIGltcHJvdmVzIHBlcmZvcm1hbmNlIG1hc3NpdmVseS5cbiAqIE9wdGltaXphdGlvbjogY29udmVydHMgYSBsaXN0IG9mIHByb2plY3RpdmUgcG9pbnRzIHRvIGEgbGlzdCBvZiBpZGVudGljYWwgcG9pbnRzIHdpdGggWj0xLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplWihjLCBwb2ludHMpIHtcbiAgICBjb25zdCBpbnZlcnRlZFpzID0gRnBJbnZlcnRCYXRjaChjLkZwLCBwb2ludHMubWFwKChwKSA9PiBwLlopKTtcbiAgICByZXR1cm4gcG9pbnRzLm1hcCgocCwgaSkgPT4gYy5mcm9tQWZmaW5lKHAudG9BZmZpbmUoaW52ZXJ0ZWRac1tpXSkpKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlVyhXLCBiaXRzKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihXKSB8fCBXIDw9IDAgfHwgVyA+IGJpdHMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB3aW5kb3cgc2l6ZSwgZXhwZWN0ZWQgWzEuLicgKyBiaXRzICsgJ10sIGdvdCBXPScgKyBXKTtcbn1cbmZ1bmN0aW9uIGNhbGNXT3B0cyhXLCBzY2FsYXJCaXRzKSB7XG4gICAgdmFsaWRhdGVXKFcsIHNjYWxhckJpdHMpO1xuICAgIGNvbnN0IHdpbmRvd3MgPSBNYXRoLmNlaWwoc2NhbGFyQml0cyAvIFcpICsgMTsgLy8gVz04IDMzLiBOb3QgMzIsIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgY29uc3Qgd2luZG93U2l6ZSA9IDIgKiogKFcgLSAxKTsgLy8gVz04IDEyOC4gTm90IDI1NiwgYmVjYXVzZSB3ZSBza2lwIHplcm9cbiAgICBjb25zdCBtYXhOdW1iZXIgPSAyICoqIFc7IC8vIFc9OCAyNTZcbiAgICBjb25zdCBtYXNrID0gYml0TWFzayhXKTsgLy8gVz04IDI1NSA9PSBtYXNrIDBiMTExMTExMTFcbiAgICBjb25zdCBzaGlmdEJ5ID0gQmlnSW50KFcpOyAvLyBXPTggOFxuICAgIHJldHVybiB7IHdpbmRvd3MsIHdpbmRvd1NpemUsIG1hc2ssIG1heE51bWJlciwgc2hpZnRCeSB9O1xufVxuZnVuY3Rpb24gY2FsY09mZnNldHMobiwgd2luZG93LCB3T3B0cykge1xuICAgIGNvbnN0IHsgd2luZG93U2l6ZSwgbWFzaywgbWF4TnVtYmVyLCBzaGlmdEJ5IH0gPSB3T3B0cztcbiAgICBsZXQgd2JpdHMgPSBOdW1iZXIobiAmIG1hc2spOyAvLyBleHRyYWN0IFcgYml0cy5cbiAgICBsZXQgbmV4dE4gPSBuID4+IHNoaWZ0Qnk7IC8vIHNoaWZ0IG51bWJlciBieSBXIGJpdHMuXG4gICAgLy8gV2hhdCBhY3R1YWxseSBoYXBwZW5zIGhlcmU6XG4gICAgLy8gY29uc3QgaGlnaGVzdEJpdCA9IE51bWJlcihtYXNrIF4gKG1hc2sgPj4gMW4pKTtcbiAgICAvLyBsZXQgd2JpdHMyID0gd2JpdHMgLSAxOyAvLyBza2lwIHplcm9cbiAgICAvLyBpZiAod2JpdHMyICYgaGlnaGVzdEJpdCkgeyB3Yml0czIgXj0gTnVtYmVyKG1hc2spOyAvLyAofik7XG4gICAgLy8gc3BsaXQgaWYgYml0cyA+IG1heDogKzIyNCA9PiAyNTYtMzJcbiAgICBpZiAod2JpdHMgPiB3aW5kb3dTaXplKSB7XG4gICAgICAgIC8vIHdlIHNraXAgemVybywgd2hpY2ggbWVhbnMgaW5zdGVhZCBvZiBgPj0gc2l6ZS0xYCwgd2UgZG8gYD4gc2l6ZWBcbiAgICAgICAgd2JpdHMgLT0gbWF4TnVtYmVyOyAvLyAtMzIsIGNhbiBiZSBtYXhOdW1iZXIgLSB3Yml0cywgYnV0IHRoZW4gd2UgbmVlZCB0byBzZXQgaXNOZWcgaGVyZS5cbiAgICAgICAgbmV4dE4gKz0gXzFuOyAvLyArMjU2IChjYXJyeSlcbiAgICB9XG4gICAgY29uc3Qgb2Zmc2V0U3RhcnQgPSB3aW5kb3cgKiB3aW5kb3dTaXplO1xuICAgIGNvbnN0IG9mZnNldCA9IG9mZnNldFN0YXJ0ICsgTWF0aC5hYnMod2JpdHMpIC0gMTsgLy8gLTEgYmVjYXVzZSB3ZSBza2lwIHplcm9cbiAgICBjb25zdCBpc1plcm8gPSB3Yml0cyA9PT0gMDsgLy8gaXMgY3VycmVudCB3aW5kb3cgc2xpY2UgYSAwP1xuICAgIGNvbnN0IGlzTmVnID0gd2JpdHMgPCAwOyAvLyBpcyBjdXJyZW50IHdpbmRvdyBzbGljZSBuZWdhdGl2ZT9cbiAgICBjb25zdCBpc05lZ0YgPSB3aW5kb3cgJSAyICE9PSAwOyAvLyBmYWtlIHJhbmRvbSBzdGF0ZW1lbnQgZm9yIG5vaXNlXG4gICAgY29uc3Qgb2Zmc2V0RiA9IG9mZnNldFN0YXJ0OyAvLyBmYWtlIG9mZnNldCBmb3Igbm9pc2VcbiAgICByZXR1cm4geyBuZXh0Tiwgb2Zmc2V0LCBpc1plcm8sIGlzTmVnLCBpc05lZ0YsIG9mZnNldEYgfTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlTVNNUG9pbnRzKHBvaW50cywgYykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShwb2ludHMpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FycmF5IGV4cGVjdGVkJyk7XG4gICAgcG9pbnRzLmZvckVhY2goKHAsIGkpID0+IHtcbiAgICAgICAgaWYgKCEocCBpbnN0YW5jZW9mIGMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBvaW50IGF0IGluZGV4ICcgKyBpKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlTVNNU2NhbGFycyhzY2FsYXJzLCBmaWVsZCkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShzY2FsYXJzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcnJheSBvZiBzY2FsYXJzIGV4cGVjdGVkJyk7XG4gICAgc2NhbGFycy5mb3JFYWNoKChzLCBpKSA9PiB7XG4gICAgICAgIGlmICghZmllbGQuaXNWYWxpZChzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzY2FsYXIgYXQgaW5kZXggJyArIGkpO1xuICAgIH0pO1xufVxuLy8gU2luY2UgcG9pbnRzIGluIGRpZmZlcmVudCBncm91cHMgY2Fubm90IGJlIGVxdWFsIChkaWZmZXJlbnQgb2JqZWN0IGNvbnN0cnVjdG9yKSxcbi8vIHdlIGNhbiBoYXZlIHNpbmdsZSBwbGFjZSB0byBzdG9yZSBwcmVjb21wdXRlcy5cbi8vIEFsbG93cyB0byBtYWtlIHBvaW50cyBmcm96ZW4gLyBpbW11dGFibGUuXG5jb25zdCBwb2ludFByZWNvbXB1dGVzID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHBvaW50V2luZG93U2l6ZXMgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gZ2V0VyhQKSB7XG4gICAgLy8gVG8gZGlzYWJsZSBwcmVjb21wdXRlczpcbiAgICAvLyByZXR1cm4gMTtcbiAgICByZXR1cm4gcG9pbnRXaW5kb3dTaXplcy5nZXQoUCkgfHwgMTtcbn1cbmZ1bmN0aW9uIGFzc2VydDAobikge1xuICAgIGlmIChuICE9PSBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB3TkFGJyk7XG59XG4vKipcbiAqIEVsbGlwdGljIGN1cnZlIG11bHRpcGxpY2F0aW9uIG9mIFBvaW50IGJ5IHNjYWxhci4gRnJhZ2lsZS5cbiAqIFRhYmxlIGdlbmVyYXRpb24gdGFrZXMgKiozME1CIG9mIHJhbSBhbmQgMTBtcyBvbiBoaWdoLWVuZCBDUFUqKixcbiAqIGJ1dCBtYXkgdGFrZSBtdWNoIGxvbmdlciBvbiBzbG93IGRldmljZXMuIEFjdHVhbCBnZW5lcmF0aW9uIHdpbGwgaGFwcGVuIG9uXG4gKiBmaXJzdCBjYWxsIG9mIGBtdWx0aXBseSgpYC4gQnkgZGVmYXVsdCwgYEJBU0VgIHBvaW50IGlzIHByZWNvbXB1dGVkLlxuICpcbiAqIFNjYWxhcnMgc2hvdWxkIGFsd2F5cyBiZSBsZXNzIHRoYW4gY3VydmUgb3JkZXI6IHRoaXMgc2hvdWxkIGJlIGNoZWNrZWQgaW5zaWRlIG9mIGEgY3VydmUgaXRzZWxmLlxuICogQ3JlYXRlcyBwcmVjb21wdXRhdGlvbiB0YWJsZXMgZm9yIGZhc3QgbXVsdGlwbGljYXRpb246XG4gKiAtIHByaXZhdGUgc2NhbGFyIGlzIHNwbGl0IGJ5IGZpeGVkIHNpemUgd2luZG93cyBvZiBXIGJpdHNcbiAqIC0gZXZlcnkgd2luZG93IHBvaW50IGlzIGNvbGxlY3RlZCBmcm9tIHdpbmRvdydzIHRhYmxlICYgYWRkZWQgdG8gYWNjdW11bGF0b3JcbiAqIC0gc2luY2Ugd2luZG93cyBhcmUgZGlmZmVyZW50LCBzYW1lIHBvaW50IGluc2lkZSB0YWJsZXMgd29uJ3QgYmUgYWNjZXNzZWQgbW9yZSB0aGFuIG9uY2UgcGVyIGNhbGNcbiAqIC0gZWFjaCBtdWx0aXBsaWNhdGlvbiBpcyAnTWF0aC5jZWlsKENVUlZFX09SREVSIC8g8J2RiikgKyAxJyBwb2ludCBhZGRpdGlvbnMgKGZpeGVkIGZvciBhbnkgc2NhbGFyKVxuICogLSArMSB3aW5kb3cgaXMgbmVjY2Vzc2FyeSBmb3Igd05BRlxuICogLSB3TkFGIHJlZHVjZXMgdGFibGUgc2l6ZTogMnggbGVzcyBtZW1vcnkgKyAyeCBmYXN0ZXIgZ2VuZXJhdGlvbiwgYnV0IDEwJSBzbG93ZXIgbXVsdGlwbGljYXRpb25cbiAqXG4gKiBAdG9kbyBSZXNlYXJjaCByZXR1cm5pbmcgMmQgSlMgYXJyYXkgb2Ygd2luZG93cywgaW5zdGVhZCBvZiBhIHNpbmdsZSB3aW5kb3cuXG4gKiBUaGlzIHdvdWxkIGFsbG93IHdpbmRvd3MgdG8gYmUgaW4gZGlmZmVyZW50IG1lbW9yeSBsb2NhdGlvbnNcbiAqL1xuZXhwb3J0IGNsYXNzIHdOQUYge1xuICAgIC8vIFBhcmFtZXRyaXplZCB3aXRoIGEgZ2l2ZW4gUG9pbnQgY2xhc3MgKG5vdCBpbmRpdmlkdWFsIHBvaW50KVxuICAgIGNvbnN0cnVjdG9yKFBvaW50LCBiaXRzKSB7XG4gICAgICAgIHRoaXMuQkFTRSA9IFBvaW50LkJBU0U7XG4gICAgICAgIHRoaXMuWkVSTyA9IFBvaW50LlpFUk87XG4gICAgICAgIHRoaXMuRm4gPSBQb2ludC5GbjtcbiAgICAgICAgdGhpcy5iaXRzID0gYml0cztcbiAgICB9XG4gICAgLy8gbm9uLWNvbnN0IHRpbWUgbXVsdGlwbGljYXRpb24gbGFkZGVyXG4gICAgX3Vuc2FmZUxhZGRlcihlbG0sIG4sIHAgPSB0aGlzLlpFUk8pIHtcbiAgICAgICAgbGV0IGQgPSBlbG07XG4gICAgICAgIHdoaWxlIChuID4gXzBuKSB7XG4gICAgICAgICAgICBpZiAobiAmIF8xbilcbiAgICAgICAgICAgICAgICBwID0gcC5hZGQoZCk7XG4gICAgICAgICAgICBkID0gZC5kb3VibGUoKTtcbiAgICAgICAgICAgIG4gPj49IF8xbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHdOQUYgcHJlY29tcHV0YXRpb24gd2luZG93LiBVc2VkIGZvciBjYWNoaW5nLlxuICAgICAqIERlZmF1bHQgd2luZG93IHNpemUgaXMgc2V0IGJ5IGB1dGlscy5wcmVjb21wdXRlKClgIGFuZCBpcyBlcXVhbCB0byA4LlxuICAgICAqIE51bWJlciBvZiBwcmVjb21wdXRlZCBwb2ludHMgZGVwZW5kcyBvbiB0aGUgY3VydmUgc2l6ZTpcbiAgICAgKiAyXijwnZGK4oiSMSkgKiAoTWF0aC5jZWlsKPCdkZsgLyDwnZGKKSArIDEpLCB3aGVyZTpcbiAgICAgKiAtIPCdkYogaXMgdGhlIHdpbmRvdyBzaXplXG4gICAgICogLSDwnZGbIGlzIHRoZSBiaXRsZW5ndGggb2YgdGhlIGN1cnZlIG9yZGVyLlxuICAgICAqIEZvciBhIDI1Ni1iaXQgY3VydmUgYW5kIHdpbmRvdyBzaXplIDgsIHRoZSBudW1iZXIgb2YgcHJlY29tcHV0ZWQgcG9pbnRzIGlzIDEyOCAqIDMzID0gNDIyNC5cbiAgICAgKiBAcGFyYW0gcG9pbnQgUG9pbnQgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0gVyB3aW5kb3cgc2l6ZVxuICAgICAqIEByZXR1cm5zIHByZWNvbXB1dGVkIHBvaW50IHRhYmxlcyBmbGF0dGVuZWQgdG8gYSBzaW5nbGUgYXJyYXlcbiAgICAgKi9cbiAgICBwcmVjb21wdXRlV2luZG93KHBvaW50LCBXKSB7XG4gICAgICAgIGNvbnN0IHsgd2luZG93cywgd2luZG93U2l6ZSB9ID0gY2FsY1dPcHRzKFcsIHRoaXMuYml0cyk7XG4gICAgICAgIGNvbnN0IHBvaW50cyA9IFtdO1xuICAgICAgICBsZXQgcCA9IHBvaW50O1xuICAgICAgICBsZXQgYmFzZSA9IHA7XG4gICAgICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IHdpbmRvd3M7IHdpbmRvdysrKSB7XG4gICAgICAgICAgICBiYXNlID0gcDtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKGJhc2UpO1xuICAgICAgICAgICAgLy8gaT0xLCBiYyB3ZSBza2lwIDBcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgd2luZG93U2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYmFzZSA9IGJhc2UuYWRkKHApO1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGJhc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcCA9IGJhc2UuZG91YmxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW1wbGVtZW50cyBlYyBtdWx0aXBsaWNhdGlvbiB1c2luZyBwcmVjb21wdXRlZCB0YWJsZXMgYW5kIHctYXJ5IG5vbi1hZGphY2VudCBmb3JtLlxuICAgICAqIE1vcmUgY29tcGFjdCBpbXBsZW1lbnRhdGlvbjpcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vcGF1bG1pbGxyL25vYmxlLXNlY3AyNTZrMS9ibG9iLzQ3Y2IxNjY5YjZlNTA2YWQ2NmIzNWZlN2Q3NjEzMmFlOTc0NjVkYTIvaW5kZXgudHMjTDUwMi1MNTQxXG4gICAgICogQHJldHVybnMgcmVhbCBhbmQgZmFrZSAoZm9yIGNvbnN0LXRpbWUpIHBvaW50c1xuICAgICAqL1xuICAgIHdOQUYoVywgcHJlY29tcHV0ZXMsIG4pIHtcbiAgICAgICAgLy8gU2NhbGFyIHNob3VsZCBiZSBzbWFsbGVyIHRoYW4gZmllbGQgb3JkZXJcbiAgICAgICAgaWYgKCF0aGlzLkZuLmlzVmFsaWQobikpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2NhbGFyJyk7XG4gICAgICAgIC8vIEFjY3VtdWxhdG9yc1xuICAgICAgICBsZXQgcCA9IHRoaXMuWkVSTztcbiAgICAgICAgbGV0IGYgPSB0aGlzLkJBU0U7XG4gICAgICAgIC8vIFRoaXMgY29kZSB3YXMgZmlyc3Qgd3JpdHRlbiB3aXRoIGFzc3VtcHRpb24gdGhhdCAnZicgYW5kICdwJyB3aWxsIG5ldmVyIGJlIGluZmluaXR5IHBvaW50OlxuICAgICAgICAvLyBzaW5jZSBlYWNoIGFkZGl0aW9uIGlzIG11bHRpcGxpZWQgYnkgMiAqKiBXLCBpdCBjYW5ub3QgY2FuY2VsIGVhY2ggb3RoZXIuIEhvd2V2ZXIsXG4gICAgICAgIC8vIHRoZXJlIGlzIG5lZ2F0ZSBub3c6IGl0IGlzIHBvc3NpYmxlIHRoYXQgbmVnYXRlZCBlbGVtZW50IGZyb20gbG93IHZhbHVlXG4gICAgICAgIC8vIHdvdWxkIGJlIHRoZSBzYW1lIGFzIGhpZ2ggZWxlbWVudCwgd2hpY2ggd2lsbCBjcmVhdGUgY2FycnkgaW50byBuZXh0IHdpbmRvdy5cbiAgICAgICAgLy8gSXQncyBub3Qgb2J2aW91cyBob3cgdGhpcyBjYW4gZmFpbCwgYnV0IHN0aWxsIHdvcnRoIGludmVzdGlnYXRpbmcgbGF0ZXIuXG4gICAgICAgIGNvbnN0IHdvID0gY2FsY1dPcHRzKFcsIHRoaXMuYml0cyk7XG4gICAgICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IHdvLndpbmRvd3M7IHdpbmRvdysrKSB7XG4gICAgICAgICAgICAvLyAobiA9PT0gXzBuKSBpcyBoYW5kbGVkIGFuZCBub3QgZWFybHktZXhpdGVkLiBpc0V2ZW4gYW5kIG9mZnNldEYgYXJlIHVzZWQgZm9yIG5vaXNlXG4gICAgICAgICAgICBjb25zdCB7IG5leHROLCBvZmZzZXQsIGlzWmVybywgaXNOZWcsIGlzTmVnRiwgb2Zmc2V0RiB9ID0gY2FsY09mZnNldHMobiwgd2luZG93LCB3byk7XG4gICAgICAgICAgICBuID0gbmV4dE47XG4gICAgICAgICAgICBpZiAoaXNaZXJvKSB7XG4gICAgICAgICAgICAgICAgLy8gYml0cyBhcmUgMDogYWRkIGdhcmJhZ2UgdG8gZmFrZSBwb2ludFxuICAgICAgICAgICAgICAgIC8vIEltcG9ydGFudCBwYXJ0IGZvciBjb25zdC10aW1lIGdldFB1YmxpY0tleTogYWRkIHJhbmRvbSBcIm5vaXNlXCIgcG9pbnQgdG8gZi5cbiAgICAgICAgICAgICAgICBmID0gZi5hZGQobmVnYXRlQ3QoaXNOZWdGLCBwcmVjb21wdXRlc1tvZmZzZXRGXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gYml0cyBhcmUgMTogYWRkIHRvIHJlc3VsdCBwb2ludFxuICAgICAgICAgICAgICAgIHAgPSBwLmFkZChuZWdhdGVDdChpc05lZywgcHJlY29tcHV0ZXNbb2Zmc2V0XSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFzc2VydDAobik7XG4gICAgICAgIC8vIFJldHVybiBib3RoIHJlYWwgYW5kIGZha2UgcG9pbnRzOiBKSVQgd29uJ3QgZWxpbWluYXRlIGYuXG4gICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgdGhlcmUgaXMgYSB3YXkgdG8gRiBiZSBpbmZpbml0eS1wb2ludCBldmVuIGlmIHAgaXMgbm90LFxuICAgICAgICAvLyB3aGljaCBtYWtlcyBpdCBsZXNzIGNvbnN0LXRpbWU6IGFyb3VuZCAxIGJpZ2ludCBtdWx0aXBseS5cbiAgICAgICAgcmV0dXJuIHsgcCwgZiB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnRzIGVjIHVuc2FmZSAobm9uIGNvbnN0LXRpbWUpIG11bHRpcGxpY2F0aW9uIHVzaW5nIHByZWNvbXB1dGVkIHRhYmxlcyBhbmQgdy1hcnkgbm9uLWFkamFjZW50IGZvcm0uXG4gICAgICogQHBhcmFtIGFjYyBhY2N1bXVsYXRvciBwb2ludCB0byBhZGQgcmVzdWx0IG9mIG11bHRpcGxpY2F0aW9uXG4gICAgICogQHJldHVybnMgcG9pbnRcbiAgICAgKi9cbiAgICB3TkFGVW5zYWZlKFcsIHByZWNvbXB1dGVzLCBuLCBhY2MgPSB0aGlzLlpFUk8pIHtcbiAgICAgICAgY29uc3Qgd28gPSBjYWxjV09wdHMoVywgdGhpcy5iaXRzKTtcbiAgICAgICAgZm9yIChsZXQgd2luZG93ID0gMDsgd2luZG93IDwgd28ud2luZG93czsgd2luZG93KyspIHtcbiAgICAgICAgICAgIGlmIChuID09PSBfMG4pXG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vIEVhcmx5LWV4aXQsIHNraXAgMCB2YWx1ZVxuICAgICAgICAgICAgY29uc3QgeyBuZXh0Tiwgb2Zmc2V0LCBpc1plcm8sIGlzTmVnIH0gPSBjYWxjT2Zmc2V0cyhuLCB3aW5kb3csIHdvKTtcbiAgICAgICAgICAgIG4gPSBuZXh0TjtcbiAgICAgICAgICAgIGlmIChpc1plcm8pIHtcbiAgICAgICAgICAgICAgICAvLyBXaW5kb3cgYml0cyBhcmUgMDogc2tpcCBwcm9jZXNzaW5nLlxuICAgICAgICAgICAgICAgIC8vIE1vdmUgdG8gbmV4dCB3aW5kb3cuXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gcHJlY29tcHV0ZXNbb2Zmc2V0XTtcbiAgICAgICAgICAgICAgICBhY2MgPSBhY2MuYWRkKGlzTmVnID8gaXRlbS5uZWdhdGUoKSA6IGl0ZW0pOyAvLyBSZS11c2luZyBhY2MgYWxsb3dzIHRvIHNhdmUgYWRkcyBpbiBNU01cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQwKG4pO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH1cbiAgICBnZXRQcmVjb21wdXRlcyhXLCBwb2ludCwgdHJhbnNmb3JtKSB7XG4gICAgICAgIC8vIENhbGN1bGF0ZSBwcmVjb21wdXRlcyBvbiBhIGZpcnN0IHJ1biwgcmV1c2UgdGhlbSBhZnRlclxuICAgICAgICBsZXQgY29tcCA9IHBvaW50UHJlY29tcHV0ZXMuZ2V0KHBvaW50KTtcbiAgICAgICAgaWYgKCFjb21wKSB7XG4gICAgICAgICAgICBjb21wID0gdGhpcy5wcmVjb21wdXRlV2luZG93KHBvaW50LCBXKTtcbiAgICAgICAgICAgIGlmIChXICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgLy8gRG9pbmcgdHJhbnNmb3JtIG91dHNpZGUgb2YgaWYgYnJpbmdzIDE1JSBwZXJmIGhpdFxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgICAgICBjb21wID0gdHJhbnNmb3JtKGNvbXApO1xuICAgICAgICAgICAgICAgIHBvaW50UHJlY29tcHV0ZXMuc2V0KHBvaW50LCBjb21wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tcDtcbiAgICB9XG4gICAgY2FjaGVkKHBvaW50LCBzY2FsYXIsIHRyYW5zZm9ybSkge1xuICAgICAgICBjb25zdCBXID0gZ2V0Vyhwb2ludCk7XG4gICAgICAgIHJldHVybiB0aGlzLndOQUYoVywgdGhpcy5nZXRQcmVjb21wdXRlcyhXLCBwb2ludCwgdHJhbnNmb3JtKSwgc2NhbGFyKTtcbiAgICB9XG4gICAgdW5zYWZlKHBvaW50LCBzY2FsYXIsIHRyYW5zZm9ybSwgcHJldikge1xuICAgICAgICBjb25zdCBXID0gZ2V0Vyhwb2ludCk7XG4gICAgICAgIGlmIChXID09PSAxKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Vuc2FmZUxhZGRlcihwb2ludCwgc2NhbGFyLCBwcmV2KTsgLy8gRm9yIFc9MSBsYWRkZXIgaXMgfngyIGZhc3RlclxuICAgICAgICByZXR1cm4gdGhpcy53TkFGVW5zYWZlKFcsIHRoaXMuZ2V0UHJlY29tcHV0ZXMoVywgcG9pbnQsIHRyYW5zZm9ybSksIHNjYWxhciwgcHJldik7XG4gICAgfVxuICAgIC8vIFdlIGNhbGN1bGF0ZSBwcmVjb21wdXRlcyBmb3IgZWxsaXB0aWMgY3VydmUgcG9pbnQgbXVsdGlwbGljYXRpb25cbiAgICAvLyB1c2luZyB3aW5kb3dlZCBtZXRob2QuIFRoaXMgc3BlY2lmaWVzIHdpbmRvdyBzaXplIGFuZFxuICAgIC8vIHN0b3JlcyBwcmVjb21wdXRlZCB2YWx1ZXMuIFVzdWFsbHkgb25seSBiYXNlIHBvaW50IHdvdWxkIGJlIHByZWNvbXB1dGVkLlxuICAgIGNyZWF0ZUNhY2hlKFAsIFcpIHtcbiAgICAgICAgdmFsaWRhdGVXKFcsIHRoaXMuYml0cyk7XG4gICAgICAgIHBvaW50V2luZG93U2l6ZXMuc2V0KFAsIFcpO1xuICAgICAgICBwb2ludFByZWNvbXB1dGVzLmRlbGV0ZShQKTtcbiAgICB9XG4gICAgaGFzQ2FjaGUoZWxtKSB7XG4gICAgICAgIHJldHVybiBnZXRXKGVsbSkgIT09IDE7XG4gICAgfVxufVxuLyoqXG4gKiBFbmRvbW9ycGhpc20tc3BlY2lmaWMgbXVsdGlwbGljYXRpb24gZm9yIEtvYmxpdHogY3VydmVzLlxuICogQ29zdDogMTI4IGRibCwgMC0yNTYgYWRkcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG11bEVuZG9VbnNhZmUoUG9pbnQsIHBvaW50LCBrMSwgazIpIHtcbiAgICBsZXQgYWNjID0gcG9pbnQ7XG4gICAgbGV0IHAxID0gUG9pbnQuWkVSTztcbiAgICBsZXQgcDIgPSBQb2ludC5aRVJPO1xuICAgIHdoaWxlIChrMSA+IF8wbiB8fCBrMiA+IF8wbikge1xuICAgICAgICBpZiAoazEgJiBfMW4pXG4gICAgICAgICAgICBwMSA9IHAxLmFkZChhY2MpO1xuICAgICAgICBpZiAoazIgJiBfMW4pXG4gICAgICAgICAgICBwMiA9IHAyLmFkZChhY2MpO1xuICAgICAgICBhY2MgPSBhY2MuZG91YmxlKCk7XG4gICAgICAgIGsxID4+PSBfMW47XG4gICAgICAgIGsyID4+PSBfMW47XG4gICAgfVxuICAgIHJldHVybiB7IHAxLCBwMiB9O1xufVxuLyoqXG4gKiBQaXBwZW5nZXIgYWxnb3JpdGhtIGZvciBtdWx0aS1zY2FsYXIgbXVsdGlwbGljYXRpb24gKE1TTSwgUGEgKyBRYiArIFJjICsgLi4uKS5cbiAqIDMweCBmYXN0ZXIgdnMgbmFpdmUgYWRkaXRpb24gb24gTD00MDk2LCAxMHggZmFzdGVyIHRoYW4gcHJlY29tcHV0ZXMuXG4gKiBGb3IgTj0yNTRiaXQsIEw9MSwgaXQgZG9lczogMTAyNCBBREQgKyAyNTQgREJMLiBGb3IgTD01OiAxNTM2IEFERCArIDI1NCBEQkwuXG4gKiBBbGdvcml0aG1pY2FsbHkgY29uc3RhbnQtdGltZSAoZm9yIHNhbWUgTCksIGV2ZW4gd2hlbiAxIHBvaW50ICsgc2NhbGFyLCBvciB3aGVuIHNjYWxhciA9IDAuXG4gKiBAcGFyYW0gYyBDdXJ2ZSBQb2ludCBjb25zdHJ1Y3RvclxuICogQHBhcmFtIGZpZWxkTiBmaWVsZCBvdmVyIENVUlZFLk4gLSBpbXBvcnRhbnQgdGhhdCBpdCdzIG5vdCBvdmVyIENVUlZFLlBcbiAqIEBwYXJhbSBwb2ludHMgYXJyYXkgb2YgTCBjdXJ2ZSBwb2ludHNcbiAqIEBwYXJhbSBzY2FsYXJzIGFycmF5IG9mIEwgc2NhbGFycyAoYWthIHNlY3JldCBrZXlzIC8gYmlnaW50cylcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBpcHBlbmdlcihjLCBmaWVsZE4sIHBvaW50cywgc2NhbGFycykge1xuICAgIC8vIElmIHdlIHNwbGl0IHNjYWxhcnMgYnkgc29tZSB3aW5kb3cgKGxldCdzIHNheSA4IGJpdHMpLCBldmVyeSBjaHVuayB3aWxsIG9ubHlcbiAgICAvLyB0YWtlIDI1NiBidWNrZXRzIGV2ZW4gaWYgdGhlcmUgYXJlIDQwOTYgc2NhbGFycywgYWxzbyByZS11c2VzIGRvdWJsZS5cbiAgICAvLyBUT0RPOlxuICAgIC8vIC0gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAyNC83NTAucGRmXG4gICAgLy8gLSBodHRwczovL3RjaGVzLmlhY3Iub3JnL2luZGV4LnBocC9UQ0hFUy9hcnRpY2xlL3ZpZXcvMTAyODdcbiAgICAvLyAwIGlzIGFjY2VwdGVkIGluIHNjYWxhcnNcbiAgICB2YWxpZGF0ZU1TTVBvaW50cyhwb2ludHMsIGMpO1xuICAgIHZhbGlkYXRlTVNNU2NhbGFycyhzY2FsYXJzLCBmaWVsZE4pO1xuICAgIGNvbnN0IHBsZW5ndGggPSBwb2ludHMubGVuZ3RoO1xuICAgIGNvbnN0IHNsZW5ndGggPSBzY2FsYXJzLmxlbmd0aDtcbiAgICBpZiAocGxlbmd0aCAhPT0gc2xlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcnJheXMgb2YgcG9pbnRzIGFuZCBzY2FsYXJzIG11c3QgaGF2ZSBlcXVhbCBsZW5ndGgnKTtcbiAgICAvLyBpZiAocGxlbmd0aCA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKCdhcnJheSBtdXN0IGJlIG9mIGxlbmd0aCA+PSAyJyk7XG4gICAgY29uc3QgemVybyA9IGMuWkVSTztcbiAgICBjb25zdCB3Yml0cyA9IGJpdExlbihCaWdJbnQocGxlbmd0aCkpO1xuICAgIGxldCB3aW5kb3dTaXplID0gMTsgLy8gYml0c1xuICAgIGlmICh3Yml0cyA+IDEyKVxuICAgICAgICB3aW5kb3dTaXplID0gd2JpdHMgLSAzO1xuICAgIGVsc2UgaWYgKHdiaXRzID4gNClcbiAgICAgICAgd2luZG93U2l6ZSA9IHdiaXRzIC0gMjtcbiAgICBlbHNlIGlmICh3Yml0cyA+IDApXG4gICAgICAgIHdpbmRvd1NpemUgPSAyO1xuICAgIGNvbnN0IE1BU0sgPSBiaXRNYXNrKHdpbmRvd1NpemUpO1xuICAgIGNvbnN0IGJ1Y2tldHMgPSBuZXcgQXJyYXkoTnVtYmVyKE1BU0spICsgMSkuZmlsbCh6ZXJvKTsgLy8gKzEgZm9yIHplcm8gYXJyYXlcbiAgICBjb25zdCBsYXN0Qml0cyA9IE1hdGguZmxvb3IoKGZpZWxkTi5CSVRTIC0gMSkgLyB3aW5kb3dTaXplKSAqIHdpbmRvd1NpemU7XG4gICAgbGV0IHN1bSA9IHplcm87XG4gICAgZm9yIChsZXQgaSA9IGxhc3RCaXRzOyBpID49IDA7IGkgLT0gd2luZG93U2l6ZSkge1xuICAgICAgICBidWNrZXRzLmZpbGwoemVybyk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2xlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBzY2FsYXIgPSBzY2FsYXJzW2pdO1xuICAgICAgICAgICAgY29uc3Qgd2JpdHMgPSBOdW1iZXIoKHNjYWxhciA+PiBCaWdJbnQoaSkpICYgTUFTSyk7XG4gICAgICAgICAgICBidWNrZXRzW3diaXRzXSA9IGJ1Y2tldHNbd2JpdHNdLmFkZChwb2ludHNbal0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNJID0gemVybzsgLy8gbm90IHVzaW5nIHRoaXMgd2lsbCBkbyBzbWFsbCBzcGVlZC11cCwgYnV0IHdpbGwgbG9zZSBjdFxuICAgICAgICAvLyBTa2lwIGZpcnN0IGJ1Y2tldCwgYmVjYXVzZSBpdCBpcyB6ZXJvXG4gICAgICAgIGZvciAobGV0IGogPSBidWNrZXRzLmxlbmd0aCAtIDEsIHN1bUkgPSB6ZXJvOyBqID4gMDsgai0tKSB7XG4gICAgICAgICAgICBzdW1JID0gc3VtSS5hZGQoYnVja2V0c1tqXSk7XG4gICAgICAgICAgICByZXNJID0gcmVzSS5hZGQoc3VtSSk7XG4gICAgICAgIH1cbiAgICAgICAgc3VtID0gc3VtLmFkZChyZXNJKTtcbiAgICAgICAgaWYgKGkgIT09IDApXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHdpbmRvd1NpemU7IGorKylcbiAgICAgICAgICAgICAgICBzdW0gPSBzdW0uZG91YmxlKCk7XG4gICAgfVxuICAgIHJldHVybiBzdW07XG59XG4vKipcbiAqIFByZWNvbXB1dGVkIG11bHRpLXNjYWxhciBtdWx0aXBsaWNhdGlvbiAoTVNNLCBQYSArIFFiICsgUmMgKyAuLi4pLlxuICogQHBhcmFtIGMgQ3VydmUgUG9pbnQgY29uc3RydWN0b3JcbiAqIEBwYXJhbSBmaWVsZE4gZmllbGQgb3ZlciBDVVJWRS5OIC0gaW1wb3J0YW50IHRoYXQgaXQncyBub3Qgb3ZlciBDVVJWRS5QXG4gKiBAcGFyYW0gcG9pbnRzIGFycmF5IG9mIEwgY3VydmUgcG9pbnRzXG4gKiBAcmV0dXJucyBmdW5jdGlvbiB3aGljaCBtdWx0aXBsaWVzIHBvaW50cyB3aXRoIHNjYWFyc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcHJlY29tcHV0ZU1TTVVuc2FmZShjLCBmaWVsZE4sIHBvaW50cywgd2luZG93U2l6ZSkge1xuICAgIC8qKlxuICAgICAqIFBlcmZvcm1hbmNlIEFuYWx5c2lzIG9mIFdpbmRvdy1iYXNlZCBQcmVjb21wdXRhdGlvblxuICAgICAqXG4gICAgICogQmFzZSBDYXNlICgyNTYtYml0IHNjYWxhciwgOC1iaXQgd2luZG93KTpcbiAgICAgKiAtIFN0YW5kYXJkIHByZWNvbXB1dGF0aW9uIHJlcXVpcmVzOlxuICAgICAqICAgLSAzMSBhZGRpdGlvbnMgcGVyIHNjYWxhciDDlyAyNTYgc2NhbGFycyA9IDcsOTM2IG9wc1xuICAgICAqICAgLSBQbHVzIDI1NSBzdW1tYXJ5IGFkZGl0aW9ucyA9IDgsMTkxIHRvdGFsIG9wc1xuICAgICAqICAgTm90ZTogU3VtbWFyeSBhZGRpdGlvbnMgY2FuIGJlIG9wdGltaXplZCB2aWEgYWNjdW11bGF0b3JcbiAgICAgKlxuICAgICAqIENodW5rZWQgUHJlY29tcHV0YXRpb24gQW5hbHlzaXM6XG4gICAgICogLSBVc2luZyAzMiBjaHVua3MgcmVxdWlyZXM6XG4gICAgICogICAtIDI1NSBhZGRpdGlvbnMgcGVyIGNodW5rXG4gICAgICogICAtIDI1NiBkb3VibGluZ3NcbiAgICAgKiAgIC0gVG90YWw6ICgyNTUgw5cgMzIpICsgMjU2ID0gOCw0MTYgb3BzXG4gICAgICpcbiAgICAgKiBNZW1vcnkgVXNhZ2UgQ29tcGFyaXNvbjpcbiAgICAgKiBXaW5kb3cgU2l6ZSB8IFN0YW5kYXJkIFBvaW50cyB8IENodW5rZWQgUG9pbnRzXG4gICAgICogLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLVxuICAgICAqICAgICA0LWJpdCAgIHwgICAgIDUyMCAgICAgICAgIHwgICAgICAxNVxuICAgICAqICAgICA4LWJpdCAgIHwgICAgNCwyMjQgICAgICAgIHwgICAgIDI1NVxuICAgICAqICAgIDEwLWJpdCAgIHwgICAxMyw4MjQgICAgICAgIHwgICAxLDAyM1xuICAgICAqICAgIDE2LWJpdCAgIHwgIDU1NywwNTYgICAgICAgIHwgIDY1LDUzNVxuICAgICAqXG4gICAgICogS2V5IEFkdmFudGFnZXM6XG4gICAgICogMS4gRW5hYmxlcyBsYXJnZXIgd2luZG93IHNpemVzIGR1ZSB0byByZWR1Y2VkIG1lbW9yeSBvdmVyaGVhZFxuICAgICAqIDIuIE1vcmUgZWZmaWNpZW50IGZvciBzbWFsbGVyIHNjYWxhciBjb3VudHM6XG4gICAgICogICAgLSAxNiBjaHVua3M6ICgxNiDDlyAyNTUpICsgMjU2ID0gNCwzMzYgb3BzXG4gICAgICogICAgLSB+MnggZmFzdGVyIHRoYW4gc3RhbmRhcmQgOCwxOTEgb3BzXG4gICAgICpcbiAgICAgKiBMaW1pdGF0aW9uczpcbiAgICAgKiAtIE5vdCBzdWl0YWJsZSBmb3IgcGxhaW4gcHJlY29tcHV0ZXMgKHJlcXVpcmVzIDI1NiBjb25zdGFudCBkb3VibGluZ3MpXG4gICAgICogLSBQZXJmb3JtYW5jZSBkZWdyYWRlcyB3aXRoIGxhcmdlciBzY2FsYXIgY291bnRzOlxuICAgICAqICAgLSBPcHRpbWFsIGZvciB+MjU2IHNjYWxhcnNcbiAgICAgKiAgIC0gTGVzcyBlZmZpY2llbnQgZm9yIDQwOTYrIHNjYWxhcnMgKFBpcHBlbmdlciBwcmVmZXJyZWQpXG4gICAgICovXG4gICAgdmFsaWRhdGVXKHdpbmRvd1NpemUsIGZpZWxkTi5CSVRTKTtcbiAgICB2YWxpZGF0ZU1TTVBvaW50cyhwb2ludHMsIGMpO1xuICAgIGNvbnN0IHplcm8gPSBjLlpFUk87XG4gICAgY29uc3QgdGFibGVTaXplID0gMiAqKiB3aW5kb3dTaXplIC0gMTsgLy8gdGFibGUgc2l6ZSAod2l0aG91dCB6ZXJvKVxuICAgIGNvbnN0IGNodW5rcyA9IE1hdGguY2VpbChmaWVsZE4uQklUUyAvIHdpbmRvd1NpemUpOyAvLyBjaHVua3Mgb2YgaXRlbVxuICAgIGNvbnN0IE1BU0sgPSBiaXRNYXNrKHdpbmRvd1NpemUpO1xuICAgIGNvbnN0IHRhYmxlcyA9IHBvaW50cy5tYXAoKHApID0+IHtcbiAgICAgICAgY29uc3QgcmVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBhY2MgPSBwOyBpIDwgdGFibGVTaXplOyBpKyspIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKGFjYyk7XG4gICAgICAgICAgICBhY2MgPSBhY2MuYWRkKHApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSk7XG4gICAgcmV0dXJuIChzY2FsYXJzKSA9PiB7XG4gICAgICAgIHZhbGlkYXRlTVNNU2NhbGFycyhzY2FsYXJzLCBmaWVsZE4pO1xuICAgICAgICBpZiAoc2NhbGFycy5sZW5ndGggPiBwb2ludHMubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcnJheSBvZiBzY2FsYXJzIG11c3QgYmUgc21hbGxlciB0aGFuIGFycmF5IG9mIHBvaW50cycpO1xuICAgICAgICBsZXQgcmVzID0gemVybztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaHVua3M7IGkrKykge1xuICAgICAgICAgICAgLy8gTm8gbmVlZCB0byBkb3VibGUgaWYgYWNjdW11bGF0b3IgaXMgc3RpbGwgemVyby5cbiAgICAgICAgICAgIGlmIChyZXMgIT09IHplcm8pXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB3aW5kb3dTaXplOyBqKyspXG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IHJlcy5kb3VibGUoKTtcbiAgICAgICAgICAgIGNvbnN0IHNoaWZ0QnkgPSBCaWdJbnQoY2h1bmtzICogd2luZG93U2l6ZSAtIChpICsgMSkgKiB3aW5kb3dTaXplKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2NhbGFycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG4gPSBzY2FsYXJzW2pdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnIgPSBOdW1iZXIoKG4gPj4gc2hpZnRCeSkgJiBNQVNLKTtcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnIpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBza2lwIHplcm8gc2NhbGFycyBjaHVua3NcbiAgICAgICAgICAgICAgICByZXMgPSByZXMuYWRkKHRhYmxlc1tqXVtjdXJyIC0gMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbn1cbi8vIFRPRE86IHJlbW92ZVxuLyoqIEBkZXByZWNhdGVkICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVCYXNpYyhjdXJ2ZSkge1xuICAgIHZhbGlkYXRlRmllbGQoY3VydmUuRnApO1xuICAgIHZhbGlkYXRlT2JqZWN0KGN1cnZlLCB7XG4gICAgICAgIG46ICdiaWdpbnQnLFxuICAgICAgICBoOiAnYmlnaW50JyxcbiAgICAgICAgR3g6ICdmaWVsZCcsXG4gICAgICAgIEd5OiAnZmllbGQnLFxuICAgIH0sIHtcbiAgICAgICAgbkJpdExlbmd0aDogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBuQnl0ZUxlbmd0aDogJ2lzU2FmZUludGVnZXInLFxuICAgIH0pO1xuICAgIC8vIFNldCBkZWZhdWx0c1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgLi4ubkxlbmd0aChjdXJ2ZS5uLCBjdXJ2ZS5uQml0TGVuZ3RoKSxcbiAgICAgICAgLi4uY3VydmUsXG4gICAgICAgIC4uLnsgcDogY3VydmUuRnAuT1JERVIgfSxcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpZWxkKG9yZGVyLCBmaWVsZCwgaXNMRSkge1xuICAgIGlmIChmaWVsZCkge1xuICAgICAgICBpZiAoZmllbGQuT1JERVIgIT09IG9yZGVyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaWVsZC5PUkRFUiBtdXN0IG1hdGNoIG9yZGVyOiBGcCA9PSBwLCBGbiA9PSBuJyk7XG4gICAgICAgIHZhbGlkYXRlRmllbGQoZmllbGQpO1xuICAgICAgICByZXR1cm4gZmllbGQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gRmllbGQob3JkZXIsIHsgaXNMRSB9KTtcbiAgICB9XG59XG4vKiogVmFsaWRhdGVzIENVUlZFIG9wdHMgYW5kIGNyZWF0ZXMgZmllbGRzICovXG5leHBvcnQgZnVuY3Rpb24gX2NyZWF0ZUN1cnZlRmllbGRzKHR5cGUsIENVUlZFLCBjdXJ2ZU9wdHMgPSB7fSwgRnBGbkxFKSB7XG4gICAgaWYgKEZwRm5MRSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICBGcEZuTEUgPSB0eXBlID09PSAnZWR3YXJkcyc7XG4gICAgaWYgKCFDVVJWRSB8fCB0eXBlb2YgQ1VSVkUgIT09ICdvYmplY3QnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkIHZhbGlkICR7dHlwZX0gQ1VSVkUgb2JqZWN0YCk7XG4gICAgZm9yIChjb25zdCBwIG9mIFsncCcsICduJywgJ2gnXSkge1xuICAgICAgICBjb25zdCB2YWwgPSBDVVJWRVtwXTtcbiAgICAgICAgaWYgKCEodHlwZW9mIHZhbCA9PT0gJ2JpZ2ludCcgJiYgdmFsID4gXzBuKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ1VSVkUuJHtwfSBtdXN0IGJlIHBvc2l0aXZlIGJpZ2ludGApO1xuICAgIH1cbiAgICBjb25zdCBGcCA9IGNyZWF0ZUZpZWxkKENVUlZFLnAsIGN1cnZlT3B0cy5GcCwgRnBGbkxFKTtcbiAgICBjb25zdCBGbiA9IGNyZWF0ZUZpZWxkKENVUlZFLm4sIGN1cnZlT3B0cy5GbiwgRnBGbkxFKTtcbiAgICBjb25zdCBfYiA9IHR5cGUgPT09ICd3ZWllcnN0cmFzcycgPyAnYicgOiAnZCc7XG4gICAgY29uc3QgcGFyYW1zID0gWydHeCcsICdHeScsICdhJywgX2JdO1xuICAgIGZvciAoY29uc3QgcCBvZiBwYXJhbXMpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpZiAoIUZwLmlzVmFsaWQoQ1VSVkVbcF0pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDVVJWRS4ke3B9IG11c3QgYmUgdmFsaWQgZmllbGQgZWxlbWVudCBvZiBDVVJWRS5GcGApO1xuICAgIH1cbiAgICBDVVJWRSA9IE9iamVjdC5mcmVlemUoT2JqZWN0LmFzc2lnbih7fSwgQ1VSVkUpKTtcbiAgICByZXR1cm4geyBDVVJWRSwgRnAsIEZuIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jdXJ2ZS5qcy5tYXAiXSwibmFtZXMiOlsiYml0TGVuIiwiYml0TWFzayIsInZhbGlkYXRlT2JqZWN0IiwiRmllbGQiLCJGcEludmVydEJhdGNoIiwibkxlbmd0aCIsInZhbGlkYXRlRmllbGQiLCJfMG4iLCJCaWdJbnQiLCJfMW4iLCJuZWdhdGVDdCIsImNvbmRpdGlvbiIsIml0ZW0iLCJuZWciLCJuZWdhdGUiLCJub3JtYWxpemVaIiwiYyIsInBvaW50cyIsImludmVydGVkWnMiLCJGcCIsIm1hcCIsInAiLCJaIiwiaSIsImZyb21BZmZpbmUiLCJ0b0FmZmluZSIsInZhbGlkYXRlVyIsIlciLCJiaXRzIiwiTnVtYmVyIiwiaXNTYWZlSW50ZWdlciIsIkVycm9yIiwiY2FsY1dPcHRzIiwic2NhbGFyQml0cyIsIndpbmRvd3MiLCJNYXRoIiwiY2VpbCIsIndpbmRvd1NpemUiLCJtYXhOdW1iZXIiLCJtYXNrIiwic2hpZnRCeSIsImNhbGNPZmZzZXRzIiwibiIsIndpbmRvdyIsIndPcHRzIiwid2JpdHMiLCJuZXh0TiIsIm9mZnNldFN0YXJ0Iiwib2Zmc2V0IiwiYWJzIiwiaXNaZXJvIiwiaXNOZWciLCJpc05lZ0YiLCJvZmZzZXRGIiwidmFsaWRhdGVNU01Qb2ludHMiLCJBcnJheSIsImlzQXJyYXkiLCJmb3JFYWNoIiwidmFsaWRhdGVNU01TY2FsYXJzIiwic2NhbGFycyIsImZpZWxkIiwicyIsImlzVmFsaWQiLCJwb2ludFByZWNvbXB1dGVzIiwiV2Vha01hcCIsInBvaW50V2luZG93U2l6ZXMiLCJnZXRXIiwiUCIsImdldCIsImFzc2VydDAiLCJ3TkFGIiwiY29uc3RydWN0b3IiLCJQb2ludCIsIkJBU0UiLCJaRVJPIiwiRm4iLCJfdW5zYWZlTGFkZGVyIiwiZWxtIiwiZCIsImFkZCIsImRvdWJsZSIsInByZWNvbXB1dGVXaW5kb3ciLCJwb2ludCIsImJhc2UiLCJwdXNoIiwicHJlY29tcHV0ZXMiLCJmIiwid28iLCJ3TkFGVW5zYWZlIiwiYWNjIiwiZ2V0UHJlY29tcHV0ZXMiLCJ0cmFuc2Zvcm0iLCJjb21wIiwic2V0IiwiY2FjaGVkIiwic2NhbGFyIiwidW5zYWZlIiwicHJldiIsImNyZWF0ZUNhY2hlIiwiZGVsZXRlIiwiaGFzQ2FjaGUiLCJtdWxFbmRvVW5zYWZlIiwiazEiLCJrMiIsInAxIiwicDIiLCJwaXBwZW5nZXIiLCJmaWVsZE4iLCJwbGVuZ3RoIiwibGVuZ3RoIiwic2xlbmd0aCIsInplcm8iLCJNQVNLIiwiYnVja2V0cyIsImZpbGwiLCJsYXN0Qml0cyIsImZsb29yIiwiQklUUyIsInN1bSIsImoiLCJyZXNJIiwic3VtSSIsInByZWNvbXB1dGVNU01VbnNhZmUiLCJ0YWJsZVNpemUiLCJjaHVua3MiLCJ0YWJsZXMiLCJyZXMiLCJjdXJyIiwidmFsaWRhdGVCYXNpYyIsImN1cnZlIiwiaCIsIkd4IiwiR3kiLCJuQml0TGVuZ3RoIiwibkJ5dGVMZW5ndGgiLCJPYmplY3QiLCJmcmVlemUiLCJPUkRFUiIsImNyZWF0ZUZpZWxkIiwib3JkZXIiLCJpc0xFIiwiX2NyZWF0ZUN1cnZlRmllbGRzIiwidHlwZSIsIkNVUlZFIiwiY3VydmVPcHRzIiwiRnBGbkxFIiwidW5kZWZpbmVkIiwidmFsIiwiX2IiLCJwYXJhbXMiLCJhc3NpZ24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/curve.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/edwards.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/edwards.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PrimeEdwardsPoint: () => (/* binding */ PrimeEdwardsPoint),\n/* harmony export */   eddsa: () => (/* binding */ eddsa),\n/* harmony export */   edwards: () => (/* binding */ edwards),\n/* harmony export */   twistedEdwards: () => (/* binding */ twistedEdwards)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/utils.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curve.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/curve.js\");\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/modular.js\");\n/**\n * Twisted Edwards curve. The formula is: ax + y = 1 + dxy.\n * For design rationale of types / exports, see weierstrass module documentation.\n * Untwisted Edwards curves exist, but they aren't used in real-world protocols.\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _8n = BigInt(8);\nfunction isEdValidXY(Fp, CURVE, x, y) {\n    const x2 = Fp.sqr(x);\n    const y2 = Fp.sqr(y);\n    const left = Fp.add(Fp.mul(CURVE.a, x2), y2);\n    const right = Fp.add(Fp.ONE, Fp.mul(CURVE.d, Fp.mul(x2, y2)));\n    return Fp.eql(left, right);\n}\nfunction edwards(params, extraOpts = {}) {\n    const validated = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__._createCurveFields)(\"edwards\", params, extraOpts, extraOpts.FpFnLE);\n    const { Fp, Fn } = validated;\n    let CURVE = validated.CURVE;\n    const { h: cofactor } = CURVE;\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__._validateObject)(extraOpts, {}, {\n        uvRatio: \"function\"\n    });\n    // Important:\n    // There are some places where Fp.BYTES is used instead of nByteLength.\n    // So far, everything has been tested with curves of Fp.BYTES == nByteLength.\n    // TODO: test and find curves which behave otherwise.\n    const MASK = _2n << BigInt(Fn.BYTES * 8) - _1n;\n    const modP = (n)=>Fp.create(n); // Function overrides\n    // sqrt(u/v)\n    const uvRatio = extraOpts.uvRatio || ((u, v)=>{\n        try {\n            return {\n                isValid: true,\n                value: Fp.sqrt(Fp.div(u, v))\n            };\n        } catch (e) {\n            return {\n                isValid: false,\n                value: _0n\n            };\n        }\n    });\n    // Validate whether the passed curve params are valid.\n    // equation ax + y = 1 + dxy should work for generator point.\n    if (!isEdValidXY(Fp, CURVE, CURVE.Gx, CURVE.Gy)) throw new Error(\"bad curve params: generator point\");\n    /**\n     * Asserts coordinate is valid: 0 <= n < MASK.\n     * Coordinates >= Fp.ORDER are allowed for zip215.\n     */ function acoord(title, n, banZero = false) {\n        const min = banZero ? _1n : _0n;\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.aInRange)(\"coordinate \" + title, n, min, MASK);\n        return n;\n    }\n    function aextpoint(other) {\n        if (!(other instanceof Point)) throw new Error(\"ExtendedPoint expected\");\n    }\n    // Converts Extended point to default (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    const toAffineMemo = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.memoized)((p, iz)=>{\n        const { X, Y, Z } = p;\n        const is0 = p.is0();\n        if (iz == null) iz = is0 ? _8n : Fp.inv(Z); // 8 was chosen arbitrarily\n        const x = modP(X * iz);\n        const y = modP(Y * iz);\n        const zz = Fp.mul(Z, iz);\n        if (is0) return {\n            x: _0n,\n            y: _1n\n        };\n        if (zz !== _1n) throw new Error(\"invZ was invalid\");\n        return {\n            x,\n            y\n        };\n    });\n    const assertValidMemo = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.memoized)((p)=>{\n        const { a, d } = CURVE;\n        if (p.is0()) throw new Error(\"bad point: ZERO\"); // TODO: optimize, with vars below?\n        // Equation in affine coordinates: ax + y = 1 + dxy\n        // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX + Y)Z = Z + dXY\n        const { X, Y, Z, T } = p;\n        const X2 = modP(X * X); // X\n        const Y2 = modP(Y * Y); // Y\n        const Z2 = modP(Z * Z); // Z\n        const Z4 = modP(Z2 * Z2); // Z\n        const aX2 = modP(X2 * a); // aX\n        const left = modP(Z2 * modP(aX2 + Y2)); // (aX + Y)Z\n        const right = modP(Z4 + modP(d * modP(X2 * Y2))); // Z + dXY\n        if (left !== right) throw new Error(\"bad point: equation left != right (1)\");\n        // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T\n        const XY = modP(X * Y);\n        const ZT = modP(Z * T);\n        if (XY !== ZT) throw new Error(\"bad point: equation left != right (2)\");\n        return true;\n    });\n    // Extended Point works in extended coordinates: (X, Y, Z, T)  (x=X/Z, y=Y/Z, T=xy).\n    // https://en.wikipedia.org/wiki/Twisted_Edwards_curve#Extended_coordinates\n    class Point {\n        constructor(X, Y, Z, T){\n            this.X = acoord(\"x\", X);\n            this.Y = acoord(\"y\", Y);\n            this.Z = acoord(\"z\", Z, true);\n            this.T = acoord(\"t\", T);\n            Object.freeze(this);\n        }\n        static CURVE() {\n            return CURVE;\n        }\n        static fromAffine(p) {\n            if (p instanceof Point) throw new Error(\"extended point not allowed\");\n            const { x, y } = p || {};\n            acoord(\"x\", x);\n            acoord(\"y\", y);\n            return new Point(x, y, _1n, modP(x * y));\n        }\n        // Uses algo from RFC8032 5.1.3.\n        static fromBytes(bytes, zip215 = false) {\n            const len = Fp.BYTES;\n            const { a, d } = CURVE;\n            bytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.copyBytes)((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__._abytes2)(bytes, len, \"point\"));\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__._abool2)(zip215, \"zip215\");\n            const normed = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.copyBytes)(bytes); // copy again, we'll manipulate it\n            const lastByte = bytes[len - 1]; // select last byte\n            normed[len - 1] = lastByte & ~0x80; // clear last bit\n            const y = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberLE)(normed);\n            // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n            // RFC8032 prohibits >= p, but ZIP215 doesn't\n            // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n            // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n            const max = zip215 ? MASK : Fp.ORDER;\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.aInRange)(\"point.y\", y, _0n, max);\n            // Ed25519: x = (y-1)/(dy+1) mod p. Ed448: x = (y-1)/(dy-1) mod p. Generic case:\n            // ax+y=1+dxy => y-1=dxy-ax => y-1=x(dy-a) => x=(y-1)/(dy-a)\n            const y2 = modP(y * y); // denominator is always non-0 mod p.\n            const u = modP(y2 - _1n); // u = y - 1\n            const v = modP(d * y2 - a); // v = d y + 1.\n            let { isValid, value: x } = uvRatio(u, v); // (u/v)\n            if (!isValid) throw new Error(\"bad point: invalid y coordinate\");\n            const isXOdd = (x & _1n) === _1n; // There are 2 square roots. Use x_0 bit to select proper\n            const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n            if (!zip215 && x === _0n && isLastByteOdd) // if x=0 and x_0 = 1, fail\n            throw new Error(\"bad point: x=0 and x_0=1\");\n            if (isLastByteOdd !== isXOdd) x = modP(-x); // if x_0 != x mod 2, set x = p-x\n            return Point.fromAffine({\n                x,\n                y\n            });\n        }\n        static fromHex(bytes, zip215 = false) {\n            return Point.fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"point\", bytes), zip215);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        precompute(windowSize = 8, isLazy = true) {\n            wnaf.createCache(this, windowSize);\n            if (!isLazy) this.multiply(_2n); // random number\n            return this;\n        }\n        // Useful in fromAffine() - not for fromBytes(), which always created valid points.\n        assertValidity() {\n            assertValidMemo(this);\n        }\n        // Compare one point to another.\n        equals(other) {\n            aextpoint(other);\n            const { X: X1, Y: Y1, Z: Z1 } = this;\n            const { X: X2, Y: Y2, Z: Z2 } = other;\n            const X1Z2 = modP(X1 * Z2);\n            const X2Z1 = modP(X2 * Z1);\n            const Y1Z2 = modP(Y1 * Z2);\n            const Y2Z1 = modP(Y2 * Z1);\n            return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        negate() {\n            // Flips point sign to a negative one (-x, y in affine coords)\n            return new Point(modP(-this.X), this.Y, this.Z, modP(-this.T));\n        }\n        // Fast algo for doubling Extended Point.\n        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n        // Cost: 4M + 4S + 1*a + 6add + 1*2.\n        double() {\n            const { a } = CURVE;\n            const { X: X1, Y: Y1, Z: Z1 } = this;\n            const A = modP(X1 * X1); // A = X12\n            const B = modP(Y1 * Y1); // B = Y12\n            const C = modP(_2n * modP(Z1 * Z1)); // C = 2*Z12\n            const D = modP(a * A); // D = a*A\n            const x1y1 = X1 + Y1;\n            const E = modP(modP(x1y1 * x1y1) - A - B); // E = (X1+Y1)2-A-B\n            const G = D + B; // G = D+B\n            const F = G - C; // F = G-C\n            const H = D - B; // H = D-B\n            const X3 = modP(E * F); // X3 = E*F\n            const Y3 = modP(G * H); // Y3 = G*H\n            const T3 = modP(E * H); // T3 = E*H\n            const Z3 = modP(F * G); // Z3 = F*G\n            return new Point(X3, Y3, Z3, T3);\n        }\n        // Fast algo for adding 2 Extended Points.\n        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd\n        // Cost: 9M + 1*a + 1*d + 7add.\n        add(other) {\n            aextpoint(other);\n            const { a, d } = CURVE;\n            const { X: X1, Y: Y1, Z: Z1, T: T1 } = this;\n            const { X: X2, Y: Y2, Z: Z2, T: T2 } = other;\n            const A = modP(X1 * X2); // A = X1*X2\n            const B = modP(Y1 * Y2); // B = Y1*Y2\n            const C = modP(T1 * d * T2); // C = T1*d*T2\n            const D = modP(Z1 * Z2); // D = Z1*Z2\n            const E = modP((X1 + Y1) * (X2 + Y2) - A - B); // E = (X1+Y1)*(X2+Y2)-A-B\n            const F = D - C; // F = D-C\n            const G = D + C; // G = D+C\n            const H = modP(B - a * A); // H = B-a*A\n            const X3 = modP(E * F); // X3 = E*F\n            const Y3 = modP(G * H); // Y3 = G*H\n            const T3 = modP(E * H); // T3 = E*H\n            const Z3 = modP(F * G); // Z3 = F*G\n            return new Point(X3, Y3, Z3, T3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        // Constant-time multiplication.\n        multiply(scalar) {\n            // 1 <= scalar < L\n            if (!Fn.isValidNot0(scalar)) throw new Error(\"invalid scalar: expected 1 <= sc < curve.n\");\n            const { p, f } = wnaf.cached(this, scalar, (p)=>(0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.normalizeZ)(Point, p));\n            return (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.normalizeZ)(Point, [\n                p,\n                f\n            ])[0];\n        }\n        // Non-constant-time multiplication. Uses double-and-add algorithm.\n        // It's faster, but should only be used when you don't care about\n        // an exposed private key e.g. sig verification.\n        // Does NOT allow scalars higher than CURVE.n.\n        // Accepts optional accumulator to merge with multiply (important for sparse scalars)\n        multiplyUnsafe(scalar, acc = Point.ZERO) {\n            // 0 <= scalar < L\n            if (!Fn.isValid(scalar)) throw new Error(\"invalid scalar: expected 0 <= sc < curve.n\");\n            if (scalar === _0n) return Point.ZERO;\n            if (this.is0() || scalar === _1n) return this;\n            return wnaf.unsafe(this, scalar, (p)=>(0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.normalizeZ)(Point, p), acc);\n        }\n        // Checks if point is of small order.\n        // If you add something to small order point, you will have \"dirty\"\n        // point with torsion component.\n        // Multiplies point by cofactor and checks if the result is 0.\n        isSmallOrder() {\n            return this.multiplyUnsafe(cofactor).is0();\n        }\n        // Multiplies point by curve order and checks if the result is 0.\n        // Returns `false` is the point is dirty.\n        isTorsionFree() {\n            return wnaf.unsafe(this, CURVE.n).is0();\n        }\n        // Converts Extended point to default (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        toAffine(invertedZ) {\n            return toAffineMemo(this, invertedZ);\n        }\n        clearCofactor() {\n            if (cofactor === _1n) return this;\n            return this.multiplyUnsafe(cofactor);\n        }\n        toBytes() {\n            const { x, y } = this.toAffine();\n            // Fp.toBytes() allows non-canonical encoding of y (>= p).\n            const bytes = Fp.toBytes(y);\n            // Each y has 2 valid points: (x, y), (x,-y).\n            // When compressing, it's enough to store y and use the last byte to encode sign of x\n            bytes[bytes.length - 1] |= x & _1n ? 0x80 : 0;\n            return bytes;\n        }\n        toHex() {\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.bytesToHex)(this.toBytes());\n        }\n        toString() {\n            return `<Point ${this.is0() ? \"ZERO\" : this.toHex()}>`;\n        }\n        // TODO: remove\n        get ex() {\n            return this.X;\n        }\n        get ey() {\n            return this.Y;\n        }\n        get ez() {\n            return this.Z;\n        }\n        get et() {\n            return this.T;\n        }\n        static normalizeZ(points) {\n            return (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.normalizeZ)(Point, points);\n        }\n        static msm(points, scalars) {\n            return (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.pippenger)(Point, Fn, points, scalars);\n        }\n        _setWindowSize(windowSize) {\n            this.precompute(windowSize);\n        }\n        toRawBytes() {\n            return this.toBytes();\n        }\n    }\n    // base / generator point\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));\n    // zero / infinity / identity point\n    Point.ZERO = new Point(_0n, _1n, _1n, _0n); // 0, 1, 1, 0\n    // math field\n    Point.Fp = Fp;\n    // scalar field\n    Point.Fn = Fn;\n    const wnaf = new _curve_js__WEBPACK_IMPORTED_MODULE_0__.wNAF(Point, Fn.BITS);\n    Point.BASE.precompute(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n    return Point;\n}\n/**\n * Base class for prime-order points like Ristretto255 and Decaf448.\n * These points eliminate cofactor issues by representing equivalence classes\n * of Edwards curve points.\n */ class PrimeEdwardsPoint {\n    constructor(ep){\n        this.ep = ep;\n    }\n    // Static methods that must be implemented by subclasses\n    static fromBytes(_bytes) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.notImplemented)();\n    }\n    static fromHex(_hex) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.notImplemented)();\n    }\n    get x() {\n        return this.toAffine().x;\n    }\n    get y() {\n        return this.toAffine().y;\n    }\n    // Common implementations\n    clearCofactor() {\n        // no-op for prime-order groups\n        return this;\n    }\n    assertValidity() {\n        this.ep.assertValidity();\n    }\n    toAffine(invertedZ) {\n        return this.ep.toAffine(invertedZ);\n    }\n    toHex() {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.bytesToHex)(this.toBytes());\n    }\n    toString() {\n        return this.toHex();\n    }\n    isTorsionFree() {\n        return true;\n    }\n    isSmallOrder() {\n        return false;\n    }\n    add(other) {\n        this.assertSame(other);\n        return this.init(this.ep.add(other.ep));\n    }\n    subtract(other) {\n        this.assertSame(other);\n        return this.init(this.ep.subtract(other.ep));\n    }\n    multiply(scalar) {\n        return this.init(this.ep.multiply(scalar));\n    }\n    multiplyUnsafe(scalar) {\n        return this.init(this.ep.multiplyUnsafe(scalar));\n    }\n    double() {\n        return this.init(this.ep.double());\n    }\n    negate() {\n        return this.init(this.ep.negate());\n    }\n    precompute(windowSize, isLazy) {\n        return this.init(this.ep.precompute(windowSize, isLazy));\n    }\n    /** @deprecated use `toBytes` */ toRawBytes() {\n        return this.toBytes();\n    }\n}\n/**\n * Initializes EdDSA signatures over given Edwards curve.\n */ function eddsa(Point, cHash, eddsaOpts = {}) {\n    if (typeof cHash !== \"function\") throw new Error('\"hash\" function param is required');\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__._validateObject)(eddsaOpts, {}, {\n        adjustScalarBytes: \"function\",\n        randomBytes: \"function\",\n        domain: \"function\",\n        prehash: \"function\",\n        mapToCurve: \"function\"\n    });\n    const { prehash } = eddsaOpts;\n    const { BASE, Fp, Fn } = Point;\n    const randomBytes = eddsaOpts.randomBytes || _utils_js__WEBPACK_IMPORTED_MODULE_2__.randomBytes;\n    const adjustScalarBytes = eddsaOpts.adjustScalarBytes || ((bytes)=>bytes);\n    const domain = eddsaOpts.domain || ((data, ctx, phflag)=>{\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__._abool2)(phflag, \"phflag\");\n        if (ctx.length || phflag) throw new Error(\"Contexts/pre-hash are not supported\");\n        return data;\n    }); // NOOP\n    // Little-endian SHA512 with modulo n\n    function modN_LE(hash) {\n        return Fn.create((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberLE)(hash)); // Not Fn.fromBytes: it has length limit\n    }\n    // Get the hashed private scalar per RFC8032 5.1.5\n    function getPrivateScalar(key) {\n        const len = lengths.secretKey;\n        key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"private key\", key, len);\n        // Hash private key with curve's hash function to produce uniformingly random input\n        // Check byte lengths: ensure(64, h(ensure(32, key)))\n        const hashed = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"hashed private key\", cHash(key), 2 * len);\n        const head = adjustScalarBytes(hashed.slice(0, len)); // clear first half bits, produce FE\n        const prefix = hashed.slice(len, 2 * len); // second half is called key prefix (5.1.6)\n        const scalar = modN_LE(head); // The actual private scalar\n        return {\n            head,\n            prefix,\n            scalar\n        };\n    }\n    /** Convenience method that creates public key from scalar. RFC8032 5.1.5 */ function getExtendedPublicKey(secretKey) {\n        const { head, prefix, scalar } = getPrivateScalar(secretKey);\n        const point = BASE.multiply(scalar); // Point on Edwards curve aka public key\n        const pointBytes = point.toBytes();\n        return {\n            head,\n            prefix,\n            scalar,\n            point,\n            pointBytes\n        };\n    }\n    /** Calculates EdDSA pub key. RFC8032 5.1.5. */ function getPublicKey(secretKey) {\n        return getExtendedPublicKey(secretKey).pointBytes;\n    }\n    // int('LE', SHA512(dom2(F, C) || msgs)) mod N\n    function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {\n        const msg = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.concatBytes)(...msgs);\n        return modN_LE(cHash(domain(msg, (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"context\", context), !!prehash)));\n    }\n    /** Signs message with privateKey. RFC8032 5.1.6 */ function sign(msg, secretKey, options = {}) {\n        msg = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"message\", msg);\n        if (prehash) msg = prehash(msg); // for ed25519ph etc.\n        const { prefix, scalar, pointBytes } = getExtendedPublicKey(secretKey);\n        const r = hashDomainToScalar(options.context, prefix, msg); // r = dom2(F, C) || prefix || PH(M)\n        const R = BASE.multiply(r).toBytes(); // R = rG\n        const k = hashDomainToScalar(options.context, R, pointBytes, msg); // R || A || PH(M)\n        const s = Fn.create(r + k * scalar); // S = (r + k * s) mod L\n        if (!Fn.isValid(s)) throw new Error(\"sign failed: invalid s\"); // 0 <= s < L\n        const rs = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.concatBytes)(R, Fn.toBytes(s));\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__._abytes2)(rs, lengths.signature, \"result\");\n    }\n    // verification rule is either zip215 or rfc8032 / nist186-5. Consult fromHex:\n    const verifyOpts = {\n        zip215: true\n    };\n    /**\n     * Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n     * An extended group equation is checked.\n     */ function verify(sig, msg, publicKey, options = verifyOpts) {\n        const { context, zip215 } = options;\n        const len = lengths.signature;\n        sig = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"signature\", sig, len);\n        msg = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"message\", msg);\n        publicKey = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"publicKey\", publicKey, lengths.publicKey);\n        if (zip215 !== undefined) (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__._abool2)(zip215, \"zip215\");\n        if (prehash) msg = prehash(msg); // for ed25519ph, etc\n        const mid = len / 2;\n        const r = sig.subarray(0, mid);\n        const s = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberLE)(sig.subarray(mid, len));\n        let A, R, SB;\n        try {\n            // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n            // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n            // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n            A = Point.fromBytes(publicKey, zip215);\n            R = Point.fromBytes(r, zip215);\n            SB = BASE.multiplyUnsafe(s); // 0 <= s < l is done inside\n        } catch (error) {\n            return false;\n        }\n        if (!zip215 && A.isSmallOrder()) return false; // zip215 allows public keys of small order\n        const k = hashDomainToScalar(context, R.toBytes(), A.toBytes(), msg);\n        const RkA = R.add(A.multiplyUnsafe(k));\n        // Extended group equation\n        // [8][S]B = [8]R + [8][k]A'\n        return RkA.subtract(SB).clearCofactor().is0();\n    }\n    const _size = Fp.BYTES; // 32 for ed25519, 57 for ed448\n    const lengths = {\n        secretKey: _size,\n        publicKey: _size,\n        signature: 2 * _size,\n        seed: _size\n    };\n    function randomSecretKey(seed = randomBytes(lengths.seed)) {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__._abytes2)(seed, lengths.seed, \"seed\");\n    }\n    function keygen(seed) {\n        const secretKey = utils.randomSecretKey(seed);\n        return {\n            secretKey,\n            publicKey: getPublicKey(secretKey)\n        };\n    }\n    function isValidSecretKey(key) {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.isBytes)(key) && key.length === Fn.BYTES;\n    }\n    function isValidPublicKey(key, zip215) {\n        try {\n            return !!Point.fromBytes(key, zip215);\n        } catch (error) {\n            return false;\n        }\n    }\n    const utils = {\n        getExtendedPublicKey,\n        randomSecretKey,\n        isValidSecretKey,\n        isValidPublicKey,\n        /**\n         * Converts ed public key to x public key. Uses formula:\n         * - ed25519:\n         *   - `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`\n         *   - `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`\n         * - ed448:\n         *   - `(u, v) = ((y-1)/(y+1), sqrt(156324)*u/x)`\n         *   - `(x, y) = (sqrt(156324)*u/v, (1+u)/(1-u))`\n         */ toMontgomery (publicKey) {\n            const { y } = Point.fromBytes(publicKey);\n            const size = lengths.publicKey;\n            const is25519 = size === 32;\n            if (!is25519 && size !== 57) throw new Error(\"only defined for 25519 and 448\");\n            const u = is25519 ? Fp.div(_1n + y, _1n - y) : Fp.div(y - _1n, y + _1n);\n            return Fp.toBytes(u);\n        },\n        toMontgomerySecret (secretKey) {\n            const size = lengths.secretKey;\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__._abytes2)(secretKey, size);\n            const hashed = cHash(secretKey.subarray(0, size));\n            return adjustScalarBytes(hashed).subarray(0, size);\n        },\n        /** @deprecated */ randomPrivateKey: randomSecretKey,\n        /** @deprecated */ precompute (windowSize = 8, point = Point.BASE) {\n            return point.precompute(windowSize, false);\n        }\n    };\n    return Object.freeze({\n        keygen,\n        getPublicKey,\n        sign,\n        verify,\n        utils,\n        Point,\n        lengths\n    });\n}\nfunction _eddsa_legacy_opts_to_new(c) {\n    const CURVE = {\n        a: c.a,\n        d: c.d,\n        p: c.Fp.ORDER,\n        n: c.n,\n        h: c.h,\n        Gx: c.Gx,\n        Gy: c.Gy\n    };\n    const Fp = c.Fp;\n    const Fn = (0,_modular_js__WEBPACK_IMPORTED_MODULE_3__.Field)(CURVE.n, c.nBitLength, true);\n    const curveOpts = {\n        Fp,\n        Fn,\n        uvRatio: c.uvRatio\n    };\n    const eddsaOpts = {\n        randomBytes: c.randomBytes,\n        adjustScalarBytes: c.adjustScalarBytes,\n        domain: c.domain,\n        prehash: c.prehash,\n        mapToCurve: c.mapToCurve\n    };\n    return {\n        CURVE,\n        curveOpts,\n        hash: c.hash,\n        eddsaOpts\n    };\n}\nfunction _eddsa_new_output_to_legacy(c, eddsa) {\n    const Point = eddsa.Point;\n    const legacy = Object.assign({}, eddsa, {\n        ExtendedPoint: Point,\n        CURVE: c,\n        nBitLength: Point.Fn.BITS,\n        nByteLength: Point.Fn.BYTES\n    });\n    return legacy;\n}\n// TODO: remove. Use eddsa\nfunction twistedEdwards(c) {\n    const { CURVE, curveOpts, hash, eddsaOpts } = _eddsa_legacy_opts_to_new(c);\n    const Point = edwards(CURVE, curveOpts);\n    const EDDSA = eddsa(Point, hash, eddsaOpts);\n    return _eddsa_new_output_to_legacy(c, EDDSA);\n} //# sourceMappingURL=edwards.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9lZHdhcmRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7Ozs7O0NBS0MsR0FDRCxvRUFBb0UsR0FDK0o7QUFDcko7QUFDekM7QUFDckMscUVBQXFFO0FBQ3JFLGtCQUFrQjtBQUNsQixNQUFNcUIsTUFBTUMsT0FBTyxJQUFJQyxNQUFNRCxPQUFPLElBQUlFLE1BQU1GLE9BQU8sSUFBSUcsTUFBTUgsT0FBTztBQUN0RSxTQUFTSSxZQUFZQyxFQUFFLEVBQUVDLEtBQUssRUFBRUMsQ0FBQyxFQUFFQyxDQUFDO0lBQ2hDLE1BQU1DLEtBQUtKLEdBQUdLLEdBQUcsQ0FBQ0g7SUFDbEIsTUFBTUksS0FBS04sR0FBR0ssR0FBRyxDQUFDRjtJQUNsQixNQUFNSSxPQUFPUCxHQUFHUSxHQUFHLENBQUNSLEdBQUdTLEdBQUcsQ0FBQ1IsTUFBTVMsQ0FBQyxFQUFFTixLQUFLRTtJQUN6QyxNQUFNSyxRQUFRWCxHQUFHUSxHQUFHLENBQUNSLEdBQUdZLEdBQUcsRUFBRVosR0FBR1MsR0FBRyxDQUFDUixNQUFNWSxDQUFDLEVBQUViLEdBQUdTLEdBQUcsQ0FBQ0wsSUFBSUU7SUFDeEQsT0FBT04sR0FBR2MsR0FBRyxDQUFDUCxNQUFNSTtBQUN4QjtBQUNPLFNBQVNJLFFBQVFDLE1BQU0sRUFBRUMsWUFBWSxDQUFDLENBQUM7SUFDMUMsTUFBTUMsWUFBWTdCLDZEQUFrQkEsQ0FBQyxXQUFXMkIsUUFBUUMsV0FBV0EsVUFBVUUsTUFBTTtJQUNuRixNQUFNLEVBQUVuQixFQUFFLEVBQUVvQixFQUFFLEVBQUUsR0FBR0Y7SUFDbkIsSUFBSWpCLFFBQVFpQixVQUFVakIsS0FBSztJQUMzQixNQUFNLEVBQUVvQixHQUFHQyxRQUFRLEVBQUUsR0FBR3JCO0lBQ3hCNUIsMERBQWVBLENBQUM0QyxXQUFXLENBQUMsR0FBRztRQUFFTSxTQUFT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QUFFekQsTUFBTTtRQUNoQkMsU0FBU3dELEVBQUV4RCxPQUFPO1FBQ2xCQyxZQUFZdUQsRUFBRXZELFVBQVU7SUFDNUI7SUFDQSxPQUFPO1FBQUV2SjtRQUFPZ047UUFBV3BELE1BQU1rRCxFQUFFbEQsSUFBSTtRQUFFVDtJQUFVO0FBQ3ZEO0FBQ0EsU0FBUzhELDRCQUE0QkgsQ0FBQyxFQUFFN0QsS0FBSztJQUN6QyxNQUFNckcsUUFBUXFHLE1BQU1yRyxLQUFLO0lBQ3pCLE1BQU1zSyxTQUFTbEosT0FBT21KLE1BQU0sQ0FBQyxDQUFDLEdBQUdsRSxPQUFPO1FBQ3BDbUUsZUFBZXhLO1FBQ2Y1QyxPQUFPOE07UUFDUEMsWUFBWW5LLE1BQU16QixFQUFFLENBQUN1SCxJQUFJO1FBQ3pCMkUsYUFBYXpLLE1BQU16QixFQUFFLENBQUNLLEtBQUs7SUFDL0I7SUFDQSxPQUFPMEw7QUFDWDtBQUNBLDBCQUEwQjtBQUNuQixTQUFTSSxlQUFlUixDQUFDO0lBQzVCLE1BQU0sRUFBRTlNLEtBQUssRUFBRWdOLFNBQVMsRUFBRXBELElBQUksRUFBRVQsU0FBUyxFQUFFLEdBQUcwRCwwQkFBMEJDO0lBQ3hFLE1BQU1sSyxRQUFROUIsUUFBUWQsT0FBT2dOO0lBQzdCLE1BQU1PLFFBQVF0RSxNQUFNckcsT0FBT2dILE1BQU1UO0lBQ2pDLE9BQU84RCw0QkFBNEJILEdBQUdTO0FBQzFDLEVBQ0EsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xhdy13b3Jrcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dlYjMuanMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L2Vkd2FyZHMuanM/OWFkMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFR3aXN0ZWQgRWR3YXJkcyBjdXJ2ZS4gVGhlIGZvcm11bGEgaXM6IGF4wrIgKyB5wrIgPSAxICsgZHjCsnnCsi5cbiAqIEZvciBkZXNpZ24gcmF0aW9uYWxlIG9mIHR5cGVzIC8gZXhwb3J0cywgc2VlIHdlaWVyc3RyYXNzIG1vZHVsZSBkb2N1bWVudGF0aW9uLlxuICogVW50d2lzdGVkIEVkd2FyZHMgY3VydmVzIGV4aXN0LCBidXQgdGhleSBhcmVuJ3QgdXNlZCBpbiByZWFsLXdvcmxkIHByb3RvY29scy5cbiAqIEBtb2R1bGVcbiAqL1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHsgX3ZhbGlkYXRlT2JqZWN0LCBfYWJvb2wyIGFzIGFib29sLCBfYWJ5dGVzMiBhcyBhYnl0ZXMsIGFJblJhbmdlLCBieXRlc1RvSGV4LCBieXRlc1RvTnVtYmVyTEUsIGNvbmNhdEJ5dGVzLCBjb3B5Qnl0ZXMsIGVuc3VyZUJ5dGVzLCBpc0J5dGVzLCBtZW1vaXplZCwgbm90SW1wbGVtZW50ZWQsIHJhbmRvbUJ5dGVzIGFzIHJhbmRvbUJ5dGVzV2ViLCB9IGZyb20gXCIuLi91dGlscy5qc1wiO1xuaW1wb3J0IHsgX2NyZWF0ZUN1cnZlRmllbGRzLCBub3JtYWxpemVaLCBwaXBwZW5nZXIsIHdOQUYsIH0gZnJvbSBcIi4vY3VydmUuanNcIjtcbmltcG9ydCB7IEZpZWxkIH0gZnJvbSBcIi4vbW9kdWxhci5qc1wiO1xuLy8gQmUgZnJpZW5kbHkgdG8gYmFkIEVDTUFTY3JpcHQgcGFyc2VycyBieSBub3QgdXNpbmcgYmlnaW50IGxpdGVyYWxzXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKSwgXzFuID0gQmlnSW50KDEpLCBfMm4gPSBCaWdJbnQoMiksIF84biA9IEJpZ0ludCg4KTtcbmZ1bmN0aW9uIGlzRWRWYWxpZFhZKEZwLCBDVVJWRSwgeCwgeSkge1xuICAgIGNvbnN0IHgyID0gRnAuc3FyKHgpO1xuICAgIGNvbnN0IHkyID0gRnAuc3FyKHkpO1xuICAgIGNvbnN0IGxlZnQgPSBGcC5hZGQoRnAubXVsKENVUlZFLmEsIHgyKSwgeTIpO1xuICAgIGNvbnN0IHJpZ2h0ID0gRnAuYWRkKEZwLk9ORSwgRnAubXVsKENVUlZFLmQsIEZwLm11bCh4MiwgeTIpKSk7XG4gICAgcmV0dXJuIEZwLmVxbChsZWZ0LCByaWdodCk7XG59XG5leHBvcnQgZnVuY3Rpb24gZWR3YXJkcyhwYXJhbXMsIGV4dHJhT3B0cyA9IHt9KSB7XG4gICAgY29uc3QgdmFsaWRhdGVkID0gX2NyZWF0ZUN1cnZlRmllbGRzKCdlZHdhcmRzJywgcGFyYW1zLCBleHRyYU9wdHMsIGV4dHJhT3B0cy5GcEZuTEUpO1xuICAgIGNvbnN0IHsgRnAsIEZuIH0gPSB2YWxpZGF0ZWQ7XG4gICAgbGV0IENVUlZFID0gdmFsaWRhdGVkLkNVUlZFO1xuICAgIGNvbnN0IHsgaDogY29mYWN0b3IgfSA9IENVUlZFO1xuICAgIF92YWxpZGF0ZU9iamVjdChleHRyYU9wdHMsIHt9LCB7IHV2UmF0aW86ICdmdW5jdGlvbicgfSk7XG4gICAgLy8gSW1wb3J0YW50OlxuICAgIC8vIFRoZXJlIGFyZSBzb21lIHBsYWNlcyB3aGVyZSBGcC5CWVRFUyBpcyB1c2VkIGluc3RlYWQgb2YgbkJ5dGVMZW5ndGguXG4gICAgLy8gU28gZmFyLCBldmVyeXRoaW5nIGhhcyBiZWVuIHRlc3RlZCB3aXRoIGN1cnZlcyBvZiBGcC5CWVRFUyA9PSBuQnl0ZUxlbmd0aC5cbiAgICAvLyBUT0RPOiB0ZXN0IGFuZCBmaW5kIGN1cnZlcyB3aGljaCBiZWhhdmUgb3RoZXJ3aXNlLlxuICAgIGNvbnN0IE1BU0sgPSBfMm4gPDwgKEJpZ0ludChGbi5CWVRFUyAqIDgpIC0gXzFuKTtcbiAgICBjb25zdCBtb2RQID0gKG4pID0+IEZwLmNyZWF0ZShuKTsgLy8gRnVuY3Rpb24gb3ZlcnJpZGVzXG4gICAgLy8gc3FydCh1L3YpXG4gICAgY29uc3QgdXZSYXRpbyA9IGV4dHJhT3B0cy51dlJhdGlvIHx8XG4gICAgICAgICgodSwgdikgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBpc1ZhbGlkOiB0cnVlLCB2YWx1ZTogRnAuc3FydChGcC5kaXYodSwgdikpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGZhbHNlLCB2YWx1ZTogXzBuIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIC8vIFZhbGlkYXRlIHdoZXRoZXIgdGhlIHBhc3NlZCBjdXJ2ZSBwYXJhbXMgYXJlIHZhbGlkLlxuICAgIC8vIGVxdWF0aW9uIGF4wrIgKyB5wrIgPSAxICsgZHjCsnnCsiBzaG91bGQgd29yayBmb3IgZ2VuZXJhdG9yIHBvaW50LlxuICAgIGlmICghaXNFZFZhbGlkWFkoRnAsIENVUlZFLCBDVVJWRS5HeCwgQ1VSVkUuR3kpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBjdXJ2ZSBwYXJhbXM6IGdlbmVyYXRvciBwb2ludCcpO1xuICAgIC8qKlxuICAgICAqIEFzc2VydHMgY29vcmRpbmF0ZSBpcyB2YWxpZDogMCA8PSBuIDwgTUFTSy5cbiAgICAgKiBDb29yZGluYXRlcyA+PSBGcC5PUkRFUiBhcmUgYWxsb3dlZCBmb3IgemlwMjE1LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFjb29yZCh0aXRsZSwgbiwgYmFuWmVybyA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IG1pbiA9IGJhblplcm8gPyBfMW4gOiBfMG47XG4gICAgICAgIGFJblJhbmdlKCdjb29yZGluYXRlICcgKyB0aXRsZSwgbiwgbWluLCBNQVNLKTtcbiAgICAgICAgcmV0dXJuIG47XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFleHRwb2ludChvdGhlcikge1xuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFBvaW50KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXh0ZW5kZWRQb2ludCBleHBlY3RlZCcpO1xuICAgIH1cbiAgICAvLyBDb252ZXJ0cyBFeHRlbmRlZCBwb2ludCB0byBkZWZhdWx0ICh4LCB5KSBjb29yZGluYXRlcy5cbiAgICAvLyBDYW4gYWNjZXB0IHByZWNvbXB1dGVkIFpeLTEgLSBmb3IgZXhhbXBsZSwgZnJvbSBpbnZlcnRCYXRjaC5cbiAgICBjb25zdCB0b0FmZmluZU1lbW8gPSBtZW1vaXplZCgocCwgaXopID0+IHtcbiAgICAgICAgY29uc3QgeyBYLCBZLCBaIH0gPSBwO1xuICAgICAgICBjb25zdCBpczAgPSBwLmlzMCgpO1xuICAgICAgICBpZiAoaXogPT0gbnVsbClcbiAgICAgICAgICAgIGl6ID0gaXMwID8gXzhuIDogRnAuaW52KFopOyAvLyA4IHdhcyBjaG9zZW4gYXJiaXRyYXJpbHlcbiAgICAgICAgY29uc3QgeCA9IG1vZFAoWCAqIGl6KTtcbiAgICAgICAgY29uc3QgeSA9IG1vZFAoWSAqIGl6KTtcbiAgICAgICAgY29uc3QgenogPSBGcC5tdWwoWiwgaXopO1xuICAgICAgICBpZiAoaXMwKVxuICAgICAgICAgICAgcmV0dXJuIHsgeDogXzBuLCB5OiBfMW4gfTtcbiAgICAgICAgaWYgKHp6ICE9PSBfMW4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludlogd2FzIGludmFsaWQnKTtcbiAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgIH0pO1xuICAgIGNvbnN0IGFzc2VydFZhbGlkTWVtbyA9IG1lbW9pemVkKChwKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgYSwgZCB9ID0gQ1VSVkU7XG4gICAgICAgIGlmIChwLmlzMCgpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IFpFUk8nKTsgLy8gVE9ETzogb3B0aW1pemUsIHdpdGggdmFycyBiZWxvdz9cbiAgICAgICAgLy8gRXF1YXRpb24gaW4gYWZmaW5lIGNvb3JkaW5hdGVzOiBheMKyICsgecKyID0gMSArIGR4wrJ5wrJcbiAgICAgICAgLy8gRXF1YXRpb24gaW4gcHJvamVjdGl2ZSBjb29yZGluYXRlcyAoWC9aLCBZL1osIFopOiAgKGFYwrIgKyBZwrIpWsKyID0gWuKBtCArIGRYwrJZwrJcbiAgICAgICAgY29uc3QgeyBYLCBZLCBaLCBUIH0gPSBwO1xuICAgICAgICBjb25zdCBYMiA9IG1vZFAoWCAqIFgpOyAvLyBYwrJcbiAgICAgICAgY29uc3QgWTIgPSBtb2RQKFkgKiBZKTsgLy8gWcKyXG4gICAgICAgIGNvbnN0IFoyID0gbW9kUChaICogWik7IC8vIFrCslxuICAgICAgICBjb25zdCBaNCA9IG1vZFAoWjIgKiBaMik7IC8vIFrigbRcbiAgICAgICAgY29uc3QgYVgyID0gbW9kUChYMiAqIGEpOyAvLyBhWMKyXG4gICAgICAgIGNvbnN0IGxlZnQgPSBtb2RQKFoyICogbW9kUChhWDIgKyBZMikpOyAvLyAoYVjCsiArIFnCsilawrJcbiAgICAgICAgY29uc3QgcmlnaHQgPSBtb2RQKFo0ICsgbW9kUChkICogbW9kUChYMiAqIFkyKSkpOyAvLyBa4oG0ICsgZFjCslnCslxuICAgICAgICBpZiAobGVmdCAhPT0gcmlnaHQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogZXF1YXRpb24gbGVmdCAhPSByaWdodCAoMSknKTtcbiAgICAgICAgLy8gSW4gRXh0ZW5kZWQgY29vcmRpbmF0ZXMgd2UgYWxzbyBoYXZlIFQsIHdoaWNoIGlzIHgqeT1UL1o6IGNoZWNrIFgqWSA9PSBaKlRcbiAgICAgICAgY29uc3QgWFkgPSBtb2RQKFggKiBZKTtcbiAgICAgICAgY29uc3QgWlQgPSBtb2RQKFogKiBUKTtcbiAgICAgICAgaWYgKFhZICE9PSBaVClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBlcXVhdGlvbiBsZWZ0ICE9IHJpZ2h0ICgyKScpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgICAvLyBFeHRlbmRlZCBQb2ludCB3b3JrcyBpbiBleHRlbmRlZCBjb29yZGluYXRlczogKFgsIFksIFosIFQpIOKIiyAoeD1YL1osIHk9WS9aLCBUPXh5KS5cbiAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ud2lzdGVkX0Vkd2FyZHNfY3VydmUjRXh0ZW5kZWRfY29vcmRpbmF0ZXNcbiAgICBjbGFzcyBQb2ludCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKFgsIFksIFosIFQpIHtcbiAgICAgICAgICAgIHRoaXMuWCA9IGFjb29yZCgneCcsIFgpO1xuICAgICAgICAgICAgdGhpcy5ZID0gYWNvb3JkKCd5JywgWSk7XG4gICAgICAgICAgICB0aGlzLlogPSBhY29vcmQoJ3onLCBaLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuVCA9IGFjb29yZCgndCcsIFQpO1xuICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgQ1VSVkUoKSB7XG4gICAgICAgICAgICByZXR1cm4gQ1VSVkU7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGZyb21BZmZpbmUocCkge1xuICAgICAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4dGVuZGVkIHBvaW50IG5vdCBhbGxvd2VkJyk7XG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHAgfHwge307XG4gICAgICAgICAgICBhY29vcmQoJ3gnLCB4KTtcbiAgICAgICAgICAgIGFjb29yZCgneScsIHkpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh4LCB5LCBfMW4sIG1vZFAoeCAqIHkpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBVc2VzIGFsZ28gZnJvbSBSRkM4MDMyIDUuMS4zLlxuICAgICAgICBzdGF0aWMgZnJvbUJ5dGVzKGJ5dGVzLCB6aXAyMTUgPSBmYWxzZSkge1xuICAgICAgICAgICAgY29uc3QgbGVuID0gRnAuQllURVM7XG4gICAgICAgICAgICBjb25zdCB7IGEsIGQgfSA9IENVUlZFO1xuICAgICAgICAgICAgYnl0ZXMgPSBjb3B5Qnl0ZXMoYWJ5dGVzKGJ5dGVzLCBsZW4sICdwb2ludCcpKTtcbiAgICAgICAgICAgIGFib29sKHppcDIxNSwgJ3ppcDIxNScpO1xuICAgICAgICAgICAgY29uc3Qgbm9ybWVkID0gY29weUJ5dGVzKGJ5dGVzKTsgLy8gY29weSBhZ2Fpbiwgd2UnbGwgbWFuaXB1bGF0ZSBpdFxuICAgICAgICAgICAgY29uc3QgbGFzdEJ5dGUgPSBieXRlc1tsZW4gLSAxXTsgLy8gc2VsZWN0IGxhc3QgYnl0ZVxuICAgICAgICAgICAgbm9ybWVkW2xlbiAtIDFdID0gbGFzdEJ5dGUgJiB+MHg4MDsgLy8gY2xlYXIgbGFzdCBiaXRcbiAgICAgICAgICAgIGNvbnN0IHkgPSBieXRlc1RvTnVtYmVyTEUobm9ybWVkKTtcbiAgICAgICAgICAgIC8vIHppcDIxNT10cnVlIGlzIGdvb2QgZm9yIGNvbnNlbnN1cy1jcml0aWNhbCBhcHBzLiA9ZmFsc2UgZm9sbG93cyBSRkM4MDMyIC8gTklTVDE4Ni01LlxuICAgICAgICAgICAgLy8gUkZDODAzMiBwcm9oaWJpdHMgPj0gcCwgYnV0IFpJUDIxNSBkb2Vzbid0XG4gICAgICAgICAgICAvLyB6aXAyMTU9dHJ1ZTogIDAgPD0geSA8IE1BU0sgKDJeMjU2IGZvciBlZDI1NTE5KVxuICAgICAgICAgICAgLy8gemlwMjE1PWZhbHNlOiAwIDw9IHkgPCBQICgyXjI1NS0xOSBmb3IgZWQyNTUxOSlcbiAgICAgICAgICAgIGNvbnN0IG1heCA9IHppcDIxNSA/IE1BU0sgOiBGcC5PUkRFUjtcbiAgICAgICAgICAgIGFJblJhbmdlKCdwb2ludC55JywgeSwgXzBuLCBtYXgpO1xuICAgICAgICAgICAgLy8gRWQyNTUxOTogeMKyID0gKHnCsi0xKS8oZHnCsisxKSBtb2QgcC4gRWQ0NDg6IHjCsiA9ICh5wrItMSkvKGR5wrItMSkgbW9kIHAuIEdlbmVyaWMgY2FzZTpcbiAgICAgICAgICAgIC8vIGF4wrIrecKyPTErZHjCsnnCsiA9PiB5wrItMT1keMKyecKyLWF4wrIgPT4gecKyLTE9eMKyKGR5wrItYSkgPT4geMKyPSh5wrItMSkvKGR5wrItYSlcbiAgICAgICAgICAgIGNvbnN0IHkyID0gbW9kUCh5ICogeSk7IC8vIGRlbm9taW5hdG9yIGlzIGFsd2F5cyBub24tMCBtb2QgcC5cbiAgICAgICAgICAgIGNvbnN0IHUgPSBtb2RQKHkyIC0gXzFuKTsgLy8gdSA9IHnCsiAtIDFcbiAgICAgICAgICAgIGNvbnN0IHYgPSBtb2RQKGQgKiB5MiAtIGEpOyAvLyB2ID0gZCB5wrIgKyAxLlxuICAgICAgICAgICAgbGV0IHsgaXNWYWxpZCwgdmFsdWU6IHggfSA9IHV2UmF0aW8odSwgdik7IC8vIOKImih1L3YpXG4gICAgICAgICAgICBpZiAoIWlzVmFsaWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IGludmFsaWQgeSBjb29yZGluYXRlJyk7XG4gICAgICAgICAgICBjb25zdCBpc1hPZGQgPSAoeCAmIF8xbikgPT09IF8xbjsgLy8gVGhlcmUgYXJlIDIgc3F1YXJlIHJvb3RzLiBVc2UgeF8wIGJpdCB0byBzZWxlY3QgcHJvcGVyXG4gICAgICAgICAgICBjb25zdCBpc0xhc3RCeXRlT2RkID0gKGxhc3RCeXRlICYgMHg4MCkgIT09IDA7IC8vIHhfMCwgbGFzdCBiaXRcbiAgICAgICAgICAgIGlmICghemlwMjE1ICYmIHggPT09IF8wbiAmJiBpc0xhc3RCeXRlT2RkKVxuICAgICAgICAgICAgICAgIC8vIGlmIHg9MCBhbmQgeF8wID0gMSwgZmFpbFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiB4PTAgYW5kIHhfMD0xJyk7XG4gICAgICAgICAgICBpZiAoaXNMYXN0Qnl0ZU9kZCAhPT0gaXNYT2RkKVxuICAgICAgICAgICAgICAgIHggPSBtb2RQKC14KTsgLy8gaWYgeF8wICE9IHggbW9kIDIsIHNldCB4ID0gcC14XG4gICAgICAgICAgICByZXR1cm4gUG9pbnQuZnJvbUFmZmluZSh7IHgsIHkgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGZyb21IZXgoYnl0ZXMsIHppcDIxNSA9IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gUG9pbnQuZnJvbUJ5dGVzKGVuc3VyZUJ5dGVzKCdwb2ludCcsIGJ5dGVzKSwgemlwMjE1KTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueTtcbiAgICAgICAgfVxuICAgICAgICBwcmVjb21wdXRlKHdpbmRvd1NpemUgPSA4LCBpc0xhenkgPSB0cnVlKSB7XG4gICAgICAgICAgICB3bmFmLmNyZWF0ZUNhY2hlKHRoaXMsIHdpbmRvd1NpemUpO1xuICAgICAgICAgICAgaWYgKCFpc0xhenkpXG4gICAgICAgICAgICAgICAgdGhpcy5tdWx0aXBseShfMm4pOyAvLyByYW5kb20gbnVtYmVyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBVc2VmdWwgaW4gZnJvbUFmZmluZSgpIC0gbm90IGZvciBmcm9tQnl0ZXMoKSwgd2hpY2ggYWx3YXlzIGNyZWF0ZWQgdmFsaWQgcG9pbnRzLlxuICAgICAgICBhc3NlcnRWYWxpZGl0eSgpIHtcbiAgICAgICAgICAgIGFzc2VydFZhbGlkTWVtbyh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wYXJlIG9uZSBwb2ludCB0byBhbm90aGVyLlxuICAgICAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgICAgIGFleHRwb2ludChvdGhlcik7XG4gICAgICAgICAgICBjb25zdCB7IFg6IFgxLCBZOiBZMSwgWjogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IFg6IFgyLCBZOiBZMiwgWjogWjIgfSA9IG90aGVyO1xuICAgICAgICAgICAgY29uc3QgWDFaMiA9IG1vZFAoWDEgKiBaMik7XG4gICAgICAgICAgICBjb25zdCBYMloxID0gbW9kUChYMiAqIFoxKTtcbiAgICAgICAgICAgIGNvbnN0IFkxWjIgPSBtb2RQKFkxICogWjIpO1xuICAgICAgICAgICAgY29uc3QgWTJaMSA9IG1vZFAoWTIgKiBaMSk7XG4gICAgICAgICAgICByZXR1cm4gWDFaMiA9PT0gWDJaMSAmJiBZMVoyID09PSBZMloxO1xuICAgICAgICB9XG4gICAgICAgIGlzMCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVxdWFscyhQb2ludC5aRVJPKTtcbiAgICAgICAgfVxuICAgICAgICBuZWdhdGUoKSB7XG4gICAgICAgICAgICAvLyBGbGlwcyBwb2ludCBzaWduIHRvIGEgbmVnYXRpdmUgb25lICgteCwgeSBpbiBhZmZpbmUgY29vcmRzKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChtb2RQKC10aGlzLlgpLCB0aGlzLlksIHRoaXMuWiwgbW9kUCgtdGhpcy5UKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmFzdCBhbGdvIGZvciBkb3VibGluZyBFeHRlbmRlZCBQb2ludC5cbiAgICAgICAgLy8gaHR0cHM6Ly9oeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tdHdpc3RlZC1leHRlbmRlZC5odG1sI2RvdWJsaW5nLWRibC0yMDA4LWh3Y2RcbiAgICAgICAgLy8gQ29zdDogNE0gKyA0UyArIDEqYSArIDZhZGQgKyAxKjIuXG4gICAgICAgIGRvdWJsZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgYSB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBjb25zdCB7IFg6IFgxLCBZOiBZMSwgWjogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBBID0gbW9kUChYMSAqIFgxKTsgLy8gQSA9IFgxMlxuICAgICAgICAgICAgY29uc3QgQiA9IG1vZFAoWTEgKiBZMSk7IC8vIEIgPSBZMTJcbiAgICAgICAgICAgIGNvbnN0IEMgPSBtb2RQKF8ybiAqIG1vZFAoWjEgKiBaMSkpOyAvLyBDID0gMipaMTJcbiAgICAgICAgICAgIGNvbnN0IEQgPSBtb2RQKGEgKiBBKTsgLy8gRCA9IGEqQVxuICAgICAgICAgICAgY29uc3QgeDF5MSA9IFgxICsgWTE7XG4gICAgICAgICAgICBjb25zdCBFID0gbW9kUChtb2RQKHgxeTEgKiB4MXkxKSAtIEEgLSBCKTsgLy8gRSA9IChYMStZMSkyLUEtQlxuICAgICAgICAgICAgY29uc3QgRyA9IEQgKyBCOyAvLyBHID0gRCtCXG4gICAgICAgICAgICBjb25zdCBGID0gRyAtIEM7IC8vIEYgPSBHLUNcbiAgICAgICAgICAgIGNvbnN0IEggPSBEIC0gQjsgLy8gSCA9IEQtQlxuICAgICAgICAgICAgY29uc3QgWDMgPSBtb2RQKEUgKiBGKTsgLy8gWDMgPSBFKkZcbiAgICAgICAgICAgIGNvbnN0IFkzID0gbW9kUChHICogSCk7IC8vIFkzID0gRypIXG4gICAgICAgICAgICBjb25zdCBUMyA9IG1vZFAoRSAqIEgpOyAvLyBUMyA9IEUqSFxuICAgICAgICAgICAgY29uc3QgWjMgPSBtb2RQKEYgKiBHKTsgLy8gWjMgPSBGKkdcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWDMsIFkzLCBaMywgVDMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZhc3QgYWxnbyBmb3IgYWRkaW5nIDIgRXh0ZW5kZWQgUG9pbnRzLlxuICAgICAgICAvLyBodHRwczovL2h5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by10d2lzdGVkLWV4dGVuZGVkLmh0bWwjYWRkaXRpb24tYWRkLTIwMDgtaHdjZFxuICAgICAgICAvLyBDb3N0OiA5TSArIDEqYSArIDEqZCArIDdhZGQuXG4gICAgICAgIGFkZChvdGhlcikge1xuICAgICAgICAgICAgYWV4dHBvaW50KG90aGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgYSwgZCB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBjb25zdCB7IFg6IFgxLCBZOiBZMSwgWjogWjEsIFQ6IFQxIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgeyBYOiBYMiwgWTogWTIsIFo6IFoyLCBUOiBUMiB9ID0gb3RoZXI7XG4gICAgICAgICAgICBjb25zdCBBID0gbW9kUChYMSAqIFgyKTsgLy8gQSA9IFgxKlgyXG4gICAgICAgICAgICBjb25zdCBCID0gbW9kUChZMSAqIFkyKTsgLy8gQiA9IFkxKlkyXG4gICAgICAgICAgICBjb25zdCBDID0gbW9kUChUMSAqIGQgKiBUMik7IC8vIEMgPSBUMSpkKlQyXG4gICAgICAgICAgICBjb25zdCBEID0gbW9kUChaMSAqIFoyKTsgLy8gRCA9IFoxKloyXG4gICAgICAgICAgICBjb25zdCBFID0gbW9kUCgoWDEgKyBZMSkgKiAoWDIgKyBZMikgLSBBIC0gQik7IC8vIEUgPSAoWDErWTEpKihYMitZMiktQS1CXG4gICAgICAgICAgICBjb25zdCBGID0gRCAtIEM7IC8vIEYgPSBELUNcbiAgICAgICAgICAgIGNvbnN0IEcgPSBEICsgQzsgLy8gRyA9IEQrQ1xuICAgICAgICAgICAgY29uc3QgSCA9IG1vZFAoQiAtIGEgKiBBKTsgLy8gSCA9IEItYSpBXG4gICAgICAgICAgICBjb25zdCBYMyA9IG1vZFAoRSAqIEYpOyAvLyBYMyA9IEUqRlxuICAgICAgICAgICAgY29uc3QgWTMgPSBtb2RQKEcgKiBIKTsgLy8gWTMgPSBHKkhcbiAgICAgICAgICAgIGNvbnN0IFQzID0gbW9kUChFICogSCk7IC8vIFQzID0gRSpIXG4gICAgICAgICAgICBjb25zdCBaMyA9IG1vZFAoRiAqIEcpOyAvLyBaMyA9IEYqR1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozLCBUMyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VidHJhY3Qob3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChvdGhlci5uZWdhdGUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29uc3RhbnQtdGltZSBtdWx0aXBsaWNhdGlvbi5cbiAgICAgICAgbXVsdGlwbHkoc2NhbGFyKSB7XG4gICAgICAgICAgICAvLyAxIDw9IHNjYWxhciA8IExcbiAgICAgICAgICAgIGlmICghRm4uaXNWYWxpZE5vdDAoc2NhbGFyKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2NhbGFyOiBleHBlY3RlZCAxIDw9IHNjIDwgY3VydmUubicpO1xuICAgICAgICAgICAgY29uc3QgeyBwLCBmIH0gPSB3bmFmLmNhY2hlZCh0aGlzLCBzY2FsYXIsIChwKSA9PiBub3JtYWxpemVaKFBvaW50LCBwKSk7XG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplWihQb2ludCwgW3AsIGZdKVswXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb24tY29uc3RhbnQtdGltZSBtdWx0aXBsaWNhdGlvbi4gVXNlcyBkb3VibGUtYW5kLWFkZCBhbGdvcml0aG0uXG4gICAgICAgIC8vIEl0J3MgZmFzdGVyLCBidXQgc2hvdWxkIG9ubHkgYmUgdXNlZCB3aGVuIHlvdSBkb24ndCBjYXJlIGFib3V0XG4gICAgICAgIC8vIGFuIGV4cG9zZWQgcHJpdmF0ZSBrZXkgZS5nLiBzaWcgdmVyaWZpY2F0aW9uLlxuICAgICAgICAvLyBEb2VzIE5PVCBhbGxvdyBzY2FsYXJzIGhpZ2hlciB0aGFuIENVUlZFLm4uXG4gICAgICAgIC8vIEFjY2VwdHMgb3B0aW9uYWwgYWNjdW11bGF0b3IgdG8gbWVyZ2Ugd2l0aCBtdWx0aXBseSAoaW1wb3J0YW50IGZvciBzcGFyc2Ugc2NhbGFycylcbiAgICAgICAgbXVsdGlwbHlVbnNhZmUoc2NhbGFyLCBhY2MgPSBQb2ludC5aRVJPKSB7XG4gICAgICAgICAgICAvLyAwIDw9IHNjYWxhciA8IExcbiAgICAgICAgICAgIGlmICghRm4uaXNWYWxpZChzY2FsYXIpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzY2FsYXI6IGV4cGVjdGVkIDAgPD0gc2MgPCBjdXJ2ZS5uJyk7XG4gICAgICAgICAgICBpZiAoc2NhbGFyID09PSBfMG4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBvaW50LlpFUk87XG4gICAgICAgICAgICBpZiAodGhpcy5pczAoKSB8fCBzY2FsYXIgPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB3bmFmLnVuc2FmZSh0aGlzLCBzY2FsYXIsIChwKSA9PiBub3JtYWxpemVaKFBvaW50LCBwKSwgYWNjKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVja3MgaWYgcG9pbnQgaXMgb2Ygc21hbGwgb3JkZXIuXG4gICAgICAgIC8vIElmIHlvdSBhZGQgc29tZXRoaW5nIHRvIHNtYWxsIG9yZGVyIHBvaW50LCB5b3Ugd2lsbCBoYXZlIFwiZGlydHlcIlxuICAgICAgICAvLyBwb2ludCB3aXRoIHRvcnNpb24gY29tcG9uZW50LlxuICAgICAgICAvLyBNdWx0aXBsaWVzIHBvaW50IGJ5IGNvZmFjdG9yIGFuZCBjaGVja3MgaWYgdGhlIHJlc3VsdCBpcyAwLlxuICAgICAgICBpc1NtYWxsT3JkZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVVuc2FmZShjb2ZhY3RvcikuaXMwKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTXVsdGlwbGllcyBwb2ludCBieSBjdXJ2ZSBvcmRlciBhbmQgY2hlY2tzIGlmIHRoZSByZXN1bHQgaXMgMC5cbiAgICAgICAgLy8gUmV0dXJucyBgZmFsc2VgIGlzIHRoZSBwb2ludCBpcyBkaXJ0eS5cbiAgICAgICAgaXNUb3JzaW9uRnJlZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB3bmFmLnVuc2FmZSh0aGlzLCBDVVJWRS5uKS5pczAoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb252ZXJ0cyBFeHRlbmRlZCBwb2ludCB0byBkZWZhdWx0ICh4LCB5KSBjb29yZGluYXRlcy5cbiAgICAgICAgLy8gQ2FuIGFjY2VwdCBwcmVjb21wdXRlZCBaXi0xIC0gZm9yIGV4YW1wbGUsIGZyb20gaW52ZXJ0QmF0Y2guXG4gICAgICAgIHRvQWZmaW5lKGludmVydGVkWikge1xuICAgICAgICAgICAgcmV0dXJuIHRvQWZmaW5lTWVtbyh0aGlzLCBpbnZlcnRlZFopO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyQ29mYWN0b3IoKSB7XG4gICAgICAgICAgICBpZiAoY29mYWN0b3IgPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5VW5zYWZlKGNvZmFjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICB0b0J5dGVzKCkge1xuICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSB0aGlzLnRvQWZmaW5lKCk7XG4gICAgICAgICAgICAvLyBGcC50b0J5dGVzKCkgYWxsb3dzIG5vbi1jYW5vbmljYWwgZW5jb2Rpbmcgb2YgeSAoPj0gcCkuXG4gICAgICAgICAgICBjb25zdCBieXRlcyA9IEZwLnRvQnl0ZXMoeSk7XG4gICAgICAgICAgICAvLyBFYWNoIHkgaGFzIDIgdmFsaWQgcG9pbnRzOiAoeCwgeSksICh4LC15KS5cbiAgICAgICAgICAgIC8vIFdoZW4gY29tcHJlc3NpbmcsIGl0J3MgZW5vdWdoIHRvIHN0b3JlIHkgYW5kIHVzZSB0aGUgbGFzdCBieXRlIHRvIGVuY29kZSBzaWduIG9mIHhcbiAgICAgICAgICAgIGJ5dGVzW2J5dGVzLmxlbmd0aCAtIDFdIHw9IHggJiBfMW4gPyAweDgwIDogMDtcbiAgICAgICAgICAgIHJldHVybiBieXRlcztcbiAgICAgICAgfVxuICAgICAgICB0b0hleCgpIHtcbiAgICAgICAgICAgIHJldHVybiBieXRlc1RvSGV4KHRoaXMudG9CeXRlcygpKTtcbiAgICAgICAgfVxuICAgICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIHJldHVybiBgPFBvaW50ICR7dGhpcy5pczAoKSA/ICdaRVJPJyA6IHRoaXMudG9IZXgoKX0+YDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiByZW1vdmVcbiAgICAgICAgZ2V0IGV4KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuWDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgZXkoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ZO1xuICAgICAgICB9XG4gICAgICAgIGdldCBleigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLlo7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IGV0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuVDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgbm9ybWFsaXplWihwb2ludHMpIHtcbiAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVaKFBvaW50LCBwb2ludHMpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBtc20ocG9pbnRzLCBzY2FsYXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gcGlwcGVuZ2VyKFBvaW50LCBGbiwgcG9pbnRzLCBzY2FsYXJzKTtcbiAgICAgICAgfVxuICAgICAgICBfc2V0V2luZG93U2l6ZSh3aW5kb3dTaXplKSB7XG4gICAgICAgICAgICB0aGlzLnByZWNvbXB1dGUod2luZG93U2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9SYXdCeXRlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQnl0ZXMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBiYXNlIC8gZ2VuZXJhdG9yIHBvaW50XG4gICAgUG9pbnQuQkFTRSA9IG5ldyBQb2ludChDVVJWRS5HeCwgQ1VSVkUuR3ksIF8xbiwgbW9kUChDVVJWRS5HeCAqIENVUlZFLkd5KSk7XG4gICAgLy8gemVybyAvIGluZmluaXR5IC8gaWRlbnRpdHkgcG9pbnRcbiAgICBQb2ludC5aRVJPID0gbmV3IFBvaW50KF8wbiwgXzFuLCBfMW4sIF8wbik7IC8vIDAsIDEsIDEsIDBcbiAgICAvLyBtYXRoIGZpZWxkXG4gICAgUG9pbnQuRnAgPSBGcDtcbiAgICAvLyBzY2FsYXIgZmllbGRcbiAgICBQb2ludC5GbiA9IEZuO1xuICAgIGNvbnN0IHduYWYgPSBuZXcgd05BRihQb2ludCwgRm4uQklUUyk7XG4gICAgUG9pbnQuQkFTRS5wcmVjb21wdXRlKDgpOyAvLyBFbmFibGUgcHJlY29tcHV0ZXMuIFNsb3dzIGRvd24gZmlyc3QgcHVibGljS2V5IGNvbXB1dGF0aW9uIGJ5IDIwbXMuXG4gICAgcmV0dXJuIFBvaW50O1xufVxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBwcmltZS1vcmRlciBwb2ludHMgbGlrZSBSaXN0cmV0dG8yNTUgYW5kIERlY2FmNDQ4LlxuICogVGhlc2UgcG9pbnRzIGVsaW1pbmF0ZSBjb2ZhY3RvciBpc3N1ZXMgYnkgcmVwcmVzZW50aW5nIGVxdWl2YWxlbmNlIGNsYXNzZXNcbiAqIG9mIEVkd2FyZHMgY3VydmUgcG9pbnRzLlxuICovXG5leHBvcnQgY2xhc3MgUHJpbWVFZHdhcmRzUG9pbnQge1xuICAgIGNvbnN0cnVjdG9yKGVwKSB7XG4gICAgICAgIHRoaXMuZXAgPSBlcDtcbiAgICB9XG4gICAgLy8gU3RhdGljIG1ldGhvZHMgdGhhdCBtdXN0IGJlIGltcGxlbWVudGVkIGJ5IHN1YmNsYXNzZXNcbiAgICBzdGF0aWMgZnJvbUJ5dGVzKF9ieXRlcykge1xuICAgICAgICBub3RJbXBsZW1lbnRlZCgpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUhleChfaGV4KSB7XG4gICAgICAgIG5vdEltcGxlbWVudGVkKCk7XG4gICAgfVxuICAgIGdldCB4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0FmZmluZSgpLng7XG4gICAgfVxuICAgIGdldCB5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0FmZmluZSgpLnk7XG4gICAgfVxuICAgIC8vIENvbW1vbiBpbXBsZW1lbnRhdGlvbnNcbiAgICBjbGVhckNvZmFjdG9yKCkge1xuICAgICAgICAvLyBuby1vcCBmb3IgcHJpbWUtb3JkZXIgZ3JvdXBzXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhc3NlcnRWYWxpZGl0eSgpIHtcbiAgICAgICAgdGhpcy5lcC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgIH1cbiAgICB0b0FmZmluZShpbnZlcnRlZFopIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXAudG9BZmZpbmUoaW52ZXJ0ZWRaKTtcbiAgICB9XG4gICAgdG9IZXgoKSB7XG4gICAgICAgIHJldHVybiBieXRlc1RvSGV4KHRoaXMudG9CeXRlcygpKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvSGV4KCk7XG4gICAgfVxuICAgIGlzVG9yc2lvbkZyZWUoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpc1NtYWxsT3JkZXIoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYWRkKG90aGVyKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2FtZShvdGhlcik7XG4gICAgICAgIHJldHVybiB0aGlzLmluaXQodGhpcy5lcC5hZGQob3RoZXIuZXApKTtcbiAgICB9XG4gICAgc3VidHJhY3Qob3RoZXIpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRTYW1lKG90aGVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5pdCh0aGlzLmVwLnN1YnRyYWN0KG90aGVyLmVwKSk7XG4gICAgfVxuICAgIG11bHRpcGx5KHNjYWxhcikge1xuICAgICAgICByZXR1cm4gdGhpcy5pbml0KHRoaXMuZXAubXVsdGlwbHkoc2NhbGFyKSk7XG4gICAgfVxuICAgIG11bHRpcGx5VW5zYWZlKHNjYWxhcikge1xuICAgICAgICByZXR1cm4gdGhpcy5pbml0KHRoaXMuZXAubXVsdGlwbHlVbnNhZmUoc2NhbGFyKSk7XG4gICAgfVxuICAgIGRvdWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5pdCh0aGlzLmVwLmRvdWJsZSgpKTtcbiAgICB9XG4gICAgbmVnYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbml0KHRoaXMuZXAubmVnYXRlKCkpO1xuICAgIH1cbiAgICBwcmVjb21wdXRlKHdpbmRvd1NpemUsIGlzTGF6eSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbml0KHRoaXMuZXAucHJlY29tcHV0ZSh3aW5kb3dTaXplLCBpc0xhenkpKTtcbiAgICB9XG4gICAgLyoqIEBkZXByZWNhdGVkIHVzZSBgdG9CeXRlc2AgKi9cbiAgICB0b1Jhd0J5dGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0J5dGVzKCk7XG4gICAgfVxufVxuLyoqXG4gKiBJbml0aWFsaXplcyBFZERTQSBzaWduYXR1cmVzIG92ZXIgZ2l2ZW4gRWR3YXJkcyBjdXJ2ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVkZHNhKFBvaW50LCBjSGFzaCwgZWRkc2FPcHRzID0ge30pIHtcbiAgICBpZiAodHlwZW9mIGNIYXNoICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiaGFzaFwiIGZ1bmN0aW9uIHBhcmFtIGlzIHJlcXVpcmVkJyk7XG4gICAgX3ZhbGlkYXRlT2JqZWN0KGVkZHNhT3B0cywge30sIHtcbiAgICAgICAgYWRqdXN0U2NhbGFyQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgICAgIHJhbmRvbUJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgICAgICBkb21haW46ICdmdW5jdGlvbicsXG4gICAgICAgIHByZWhhc2g6ICdmdW5jdGlvbicsXG4gICAgICAgIG1hcFRvQ3VydmU6ICdmdW5jdGlvbicsXG4gICAgfSk7XG4gICAgY29uc3QgeyBwcmVoYXNoIH0gPSBlZGRzYU9wdHM7XG4gICAgY29uc3QgeyBCQVNFLCBGcCwgRm4gfSA9IFBvaW50O1xuICAgIGNvbnN0IHJhbmRvbUJ5dGVzID0gZWRkc2FPcHRzLnJhbmRvbUJ5dGVzIHx8IHJhbmRvbUJ5dGVzV2ViO1xuICAgIGNvbnN0IGFkanVzdFNjYWxhckJ5dGVzID0gZWRkc2FPcHRzLmFkanVzdFNjYWxhckJ5dGVzIHx8ICgoYnl0ZXMpID0+IGJ5dGVzKTtcbiAgICBjb25zdCBkb21haW4gPSBlZGRzYU9wdHMuZG9tYWluIHx8XG4gICAgICAgICgoZGF0YSwgY3R4LCBwaGZsYWcpID0+IHtcbiAgICAgICAgICAgIGFib29sKHBoZmxhZywgJ3BoZmxhZycpO1xuICAgICAgICAgICAgaWYgKGN0eC5sZW5ndGggfHwgcGhmbGFnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29udGV4dHMvcHJlLWhhc2ggYXJlIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9KTsgLy8gTk9PUFxuICAgIC8vIExpdHRsZS1lbmRpYW4gU0hBNTEyIHdpdGggbW9kdWxvIG5cbiAgICBmdW5jdGlvbiBtb2ROX0xFKGhhc2gpIHtcbiAgICAgICAgcmV0dXJuIEZuLmNyZWF0ZShieXRlc1RvTnVtYmVyTEUoaGFzaCkpOyAvLyBOb3QgRm4uZnJvbUJ5dGVzOiBpdCBoYXMgbGVuZ3RoIGxpbWl0XG4gICAgfVxuICAgIC8vIEdldCB0aGUgaGFzaGVkIHByaXZhdGUgc2NhbGFyIHBlciBSRkM4MDMyIDUuMS41XG4gICAgZnVuY3Rpb24gZ2V0UHJpdmF0ZVNjYWxhcihrZXkpIHtcbiAgICAgICAgY29uc3QgbGVuID0gbGVuZ3Rocy5zZWNyZXRLZXk7XG4gICAgICAgIGtleSA9IGVuc3VyZUJ5dGVzKCdwcml2YXRlIGtleScsIGtleSwgbGVuKTtcbiAgICAgICAgLy8gSGFzaCBwcml2YXRlIGtleSB3aXRoIGN1cnZlJ3MgaGFzaCBmdW5jdGlvbiB0byBwcm9kdWNlIHVuaWZvcm1pbmdseSByYW5kb20gaW5wdXRcbiAgICAgICAgLy8gQ2hlY2sgYnl0ZSBsZW5ndGhzOiBlbnN1cmUoNjQsIGgoZW5zdXJlKDMyLCBrZXkpKSlcbiAgICAgICAgY29uc3QgaGFzaGVkID0gZW5zdXJlQnl0ZXMoJ2hhc2hlZCBwcml2YXRlIGtleScsIGNIYXNoKGtleSksIDIgKiBsZW4pO1xuICAgICAgICBjb25zdCBoZWFkID0gYWRqdXN0U2NhbGFyQnl0ZXMoaGFzaGVkLnNsaWNlKDAsIGxlbikpOyAvLyBjbGVhciBmaXJzdCBoYWxmIGJpdHMsIHByb2R1Y2UgRkVcbiAgICAgICAgY29uc3QgcHJlZml4ID0gaGFzaGVkLnNsaWNlKGxlbiwgMiAqIGxlbik7IC8vIHNlY29uZCBoYWxmIGlzIGNhbGxlZCBrZXkgcHJlZml4ICg1LjEuNilcbiAgICAgICAgY29uc3Qgc2NhbGFyID0gbW9kTl9MRShoZWFkKTsgLy8gVGhlIGFjdHVhbCBwcml2YXRlIHNjYWxhclxuICAgICAgICByZXR1cm4geyBoZWFkLCBwcmVmaXgsIHNjYWxhciB9O1xuICAgIH1cbiAgICAvKiogQ29udmVuaWVuY2UgbWV0aG9kIHRoYXQgY3JlYXRlcyBwdWJsaWMga2V5IGZyb20gc2NhbGFyLiBSRkM4MDMyIDUuMS41ICovXG4gICAgZnVuY3Rpb24gZ2V0RXh0ZW5kZWRQdWJsaWNLZXkoc2VjcmV0S2V5KSB7XG4gICAgICAgIGNvbnN0IHsgaGVhZCwgcHJlZml4LCBzY2FsYXIgfSA9IGdldFByaXZhdGVTY2FsYXIoc2VjcmV0S2V5KTtcbiAgICAgICAgY29uc3QgcG9pbnQgPSBCQVNFLm11bHRpcGx5KHNjYWxhcik7IC8vIFBvaW50IG9uIEVkd2FyZHMgY3VydmUgYWthIHB1YmxpYyBrZXlcbiAgICAgICAgY29uc3QgcG9pbnRCeXRlcyA9IHBvaW50LnRvQnl0ZXMoKTtcbiAgICAgICAgcmV0dXJuIHsgaGVhZCwgcHJlZml4LCBzY2FsYXIsIHBvaW50LCBwb2ludEJ5dGVzIH07XG4gICAgfVxuICAgIC8qKiBDYWxjdWxhdGVzIEVkRFNBIHB1YiBrZXkuIFJGQzgwMzIgNS4xLjUuICovXG4gICAgZnVuY3Rpb24gZ2V0UHVibGljS2V5KHNlY3JldEtleSkge1xuICAgICAgICByZXR1cm4gZ2V0RXh0ZW5kZWRQdWJsaWNLZXkoc2VjcmV0S2V5KS5wb2ludEJ5dGVzO1xuICAgIH1cbiAgICAvLyBpbnQoJ0xFJywgU0hBNTEyKGRvbTIoRiwgQykgfHwgbXNncykpIG1vZCBOXG4gICAgZnVuY3Rpb24gaGFzaERvbWFpblRvU2NhbGFyKGNvbnRleHQgPSBVaW50OEFycmF5Lm9mKCksIC4uLm1zZ3MpIHtcbiAgICAgICAgY29uc3QgbXNnID0gY29uY2F0Qnl0ZXMoLi4ubXNncyk7XG4gICAgICAgIHJldHVybiBtb2ROX0xFKGNIYXNoKGRvbWFpbihtc2csIGVuc3VyZUJ5dGVzKCdjb250ZXh0JywgY29udGV4dCksICEhcHJlaGFzaCkpKTtcbiAgICB9XG4gICAgLyoqIFNpZ25zIG1lc3NhZ2Ugd2l0aCBwcml2YXRlS2V5LiBSRkM4MDMyIDUuMS42ICovXG4gICAgZnVuY3Rpb24gc2lnbihtc2csIHNlY3JldEtleSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIG1zZyA9IGVuc3VyZUJ5dGVzKCdtZXNzYWdlJywgbXNnKTtcbiAgICAgICAgaWYgKHByZWhhc2gpXG4gICAgICAgICAgICBtc2cgPSBwcmVoYXNoKG1zZyk7IC8vIGZvciBlZDI1NTE5cGggZXRjLlxuICAgICAgICBjb25zdCB7IHByZWZpeCwgc2NhbGFyLCBwb2ludEJ5dGVzIH0gPSBnZXRFeHRlbmRlZFB1YmxpY0tleShzZWNyZXRLZXkpO1xuICAgICAgICBjb25zdCByID0gaGFzaERvbWFpblRvU2NhbGFyKG9wdGlvbnMuY29udGV4dCwgcHJlZml4LCBtc2cpOyAvLyByID0gZG9tMihGLCBDKSB8fCBwcmVmaXggfHwgUEgoTSlcbiAgICAgICAgY29uc3QgUiA9IEJBU0UubXVsdGlwbHkocikudG9CeXRlcygpOyAvLyBSID0gckdcbiAgICAgICAgY29uc3QgayA9IGhhc2hEb21haW5Ub1NjYWxhcihvcHRpb25zLmNvbnRleHQsIFIsIHBvaW50Qnl0ZXMsIG1zZyk7IC8vIFIgfHwgQSB8fCBQSChNKVxuICAgICAgICBjb25zdCBzID0gRm4uY3JlYXRlKHIgKyBrICogc2NhbGFyKTsgLy8gUyA9IChyICsgayAqIHMpIG1vZCBMXG4gICAgICAgIGlmICghRm4uaXNWYWxpZChzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbiBmYWlsZWQ6IGludmFsaWQgcycpOyAvLyAwIDw9IHMgPCBMXG4gICAgICAgIGNvbnN0IHJzID0gY29uY2F0Qnl0ZXMoUiwgRm4udG9CeXRlcyhzKSk7XG4gICAgICAgIHJldHVybiBhYnl0ZXMocnMsIGxlbmd0aHMuc2lnbmF0dXJlLCAncmVzdWx0Jyk7XG4gICAgfVxuICAgIC8vIHZlcmlmaWNhdGlvbiBydWxlIGlzIGVpdGhlciB6aXAyMTUgb3IgcmZjODAzMiAvIG5pc3QxODYtNS4gQ29uc3VsdCBmcm9tSGV4OlxuICAgIGNvbnN0IHZlcmlmeU9wdHMgPSB7IHppcDIxNTogdHJ1ZSB9O1xuICAgIC8qKlxuICAgICAqIFZlcmlmaWVzIEVkRFNBIHNpZ25hdHVyZSBhZ2FpbnN0IG1lc3NhZ2UgYW5kIHB1YmxpYyBrZXkuIFJGQzgwMzIgNS4xLjcuXG4gICAgICogQW4gZXh0ZW5kZWQgZ3JvdXAgZXF1YXRpb24gaXMgY2hlY2tlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2ZXJpZnkoc2lnLCBtc2csIHB1YmxpY0tleSwgb3B0aW9ucyA9IHZlcmlmeU9wdHMpIHtcbiAgICAgICAgY29uc3QgeyBjb250ZXh0LCB6aXAyMTUgfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGxlbiA9IGxlbmd0aHMuc2lnbmF0dXJlO1xuICAgICAgICBzaWcgPSBlbnN1cmVCeXRlcygnc2lnbmF0dXJlJywgc2lnLCBsZW4pO1xuICAgICAgICBtc2cgPSBlbnN1cmVCeXRlcygnbWVzc2FnZScsIG1zZyk7XG4gICAgICAgIHB1YmxpY0tleSA9IGVuc3VyZUJ5dGVzKCdwdWJsaWNLZXknLCBwdWJsaWNLZXksIGxlbmd0aHMucHVibGljS2V5KTtcbiAgICAgICAgaWYgKHppcDIxNSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgYWJvb2woemlwMjE1LCAnemlwMjE1Jyk7XG4gICAgICAgIGlmIChwcmVoYXNoKVxuICAgICAgICAgICAgbXNnID0gcHJlaGFzaChtc2cpOyAvLyBmb3IgZWQyNTUxOXBoLCBldGNcbiAgICAgICAgY29uc3QgbWlkID0gbGVuIC8gMjtcbiAgICAgICAgY29uc3QgciA9IHNpZy5zdWJhcnJheSgwLCBtaWQpO1xuICAgICAgICBjb25zdCBzID0gYnl0ZXNUb051bWJlckxFKHNpZy5zdWJhcnJheShtaWQsIGxlbikpO1xuICAgICAgICBsZXQgQSwgUiwgU0I7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyB6aXAyMTU9dHJ1ZSBpcyBnb29kIGZvciBjb25zZW5zdXMtY3JpdGljYWwgYXBwcy4gPWZhbHNlIGZvbGxvd3MgUkZDODAzMiAvIE5JU1QxODYtNS5cbiAgICAgICAgICAgIC8vIHppcDIxNT10cnVlOiAgMCA8PSB5IDwgTUFTSyAoMl4yNTYgZm9yIGVkMjU1MTkpXG4gICAgICAgICAgICAvLyB6aXAyMTU9ZmFsc2U6IDAgPD0geSA8IFAgKDJeMjU1LTE5IGZvciBlZDI1NTE5KVxuICAgICAgICAgICAgQSA9IFBvaW50LmZyb21CeXRlcyhwdWJsaWNLZXksIHppcDIxNSk7XG4gICAgICAgICAgICBSID0gUG9pbnQuZnJvbUJ5dGVzKHIsIHppcDIxNSk7XG4gICAgICAgICAgICBTQiA9IEJBU0UubXVsdGlwbHlVbnNhZmUocyk7IC8vIDAgPD0gcyA8IGwgaXMgZG9uZSBpbnNpZGVcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXppcDIxNSAmJiBBLmlzU21hbGxPcmRlcigpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyB6aXAyMTUgYWxsb3dzIHB1YmxpYyBrZXlzIG9mIHNtYWxsIG9yZGVyXG4gICAgICAgIGNvbnN0IGsgPSBoYXNoRG9tYWluVG9TY2FsYXIoY29udGV4dCwgUi50b0J5dGVzKCksIEEudG9CeXRlcygpLCBtc2cpO1xuICAgICAgICBjb25zdCBSa0EgPSBSLmFkZChBLm11bHRpcGx5VW5zYWZlKGspKTtcbiAgICAgICAgLy8gRXh0ZW5kZWQgZ3JvdXAgZXF1YXRpb25cbiAgICAgICAgLy8gWzhdW1NdQiA9IFs4XVIgKyBbOF1ba11BJ1xuICAgICAgICByZXR1cm4gUmtBLnN1YnRyYWN0KFNCKS5jbGVhckNvZmFjdG9yKCkuaXMwKCk7XG4gICAgfVxuICAgIGNvbnN0IF9zaXplID0gRnAuQllURVM7IC8vIDMyIGZvciBlZDI1NTE5LCA1NyBmb3IgZWQ0NDhcbiAgICBjb25zdCBsZW5ndGhzID0ge1xuICAgICAgICBzZWNyZXRLZXk6IF9zaXplLFxuICAgICAgICBwdWJsaWNLZXk6IF9zaXplLFxuICAgICAgICBzaWduYXR1cmU6IDIgKiBfc2l6ZSxcbiAgICAgICAgc2VlZDogX3NpemUsXG4gICAgfTtcbiAgICBmdW5jdGlvbiByYW5kb21TZWNyZXRLZXkoc2VlZCA9IHJhbmRvbUJ5dGVzKGxlbmd0aHMuc2VlZCkpIHtcbiAgICAgICAgcmV0dXJuIGFieXRlcyhzZWVkLCBsZW5ndGhzLnNlZWQsICdzZWVkJyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGtleWdlbihzZWVkKSB7XG4gICAgICAgIGNvbnN0IHNlY3JldEtleSA9IHV0aWxzLnJhbmRvbVNlY3JldEtleShzZWVkKTtcbiAgICAgICAgcmV0dXJuIHsgc2VjcmV0S2V5LCBwdWJsaWNLZXk6IGdldFB1YmxpY0tleShzZWNyZXRLZXkpIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzVmFsaWRTZWNyZXRLZXkoa2V5KSB7XG4gICAgICAgIHJldHVybiBpc0J5dGVzKGtleSkgJiYga2V5Lmxlbmd0aCA9PT0gRm4uQllURVM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzVmFsaWRQdWJsaWNLZXkoa2V5LCB6aXAyMTUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiAhIVBvaW50LmZyb21CeXRlcyhrZXksIHppcDIxNSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdXRpbHMgPSB7XG4gICAgICAgIGdldEV4dGVuZGVkUHVibGljS2V5LFxuICAgICAgICByYW5kb21TZWNyZXRLZXksXG4gICAgICAgIGlzVmFsaWRTZWNyZXRLZXksXG4gICAgICAgIGlzVmFsaWRQdWJsaWNLZXksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyBlZCBwdWJsaWMga2V5IHRvIHggcHVibGljIGtleS4gVXNlcyBmb3JtdWxhOlxuICAgICAgICAgKiAtIGVkMjU1MTk6XG4gICAgICAgICAqICAgLSBgKHUsIHYpID0gKCgxK3kpLygxLXkpLCBzcXJ0KC00ODY2NjQpKnUveClgXG4gICAgICAgICAqICAgLSBgKHgsIHkpID0gKHNxcnQoLTQ4NjY2NCkqdS92LCAodS0xKS8odSsxKSlgXG4gICAgICAgICAqIC0gZWQ0NDg6XG4gICAgICAgICAqICAgLSBgKHUsIHYpID0gKCh5LTEpLyh5KzEpLCBzcXJ0KDE1NjMyNCkqdS94KWBcbiAgICAgICAgICogICAtIGAoeCwgeSkgPSAoc3FydCgxNTYzMjQpKnUvdiwgKDErdSkvKDEtdSkpYFxuICAgICAgICAgKi9cbiAgICAgICAgdG9Nb250Z29tZXJ5KHB1YmxpY0tleSkge1xuICAgICAgICAgICAgY29uc3QgeyB5IH0gPSBQb2ludC5mcm9tQnl0ZXMocHVibGljS2V5KTtcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSBsZW5ndGhzLnB1YmxpY0tleTtcbiAgICAgICAgICAgIGNvbnN0IGlzMjU1MTkgPSBzaXplID09PSAzMjtcbiAgICAgICAgICAgIGlmICghaXMyNTUxOSAmJiBzaXplICE9PSA1NylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29ubHkgZGVmaW5lZCBmb3IgMjU1MTkgYW5kIDQ0OCcpO1xuICAgICAgICAgICAgY29uc3QgdSA9IGlzMjU1MTkgPyBGcC5kaXYoXzFuICsgeSwgXzFuIC0geSkgOiBGcC5kaXYoeSAtIF8xbiwgeSArIF8xbik7XG4gICAgICAgICAgICByZXR1cm4gRnAudG9CeXRlcyh1KTtcbiAgICAgICAgfSxcbiAgICAgICAgdG9Nb250Z29tZXJ5U2VjcmV0KHNlY3JldEtleSkge1xuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IGxlbmd0aHMuc2VjcmV0S2V5O1xuICAgICAgICAgICAgYWJ5dGVzKHNlY3JldEtleSwgc2l6ZSk7XG4gICAgICAgICAgICBjb25zdCBoYXNoZWQgPSBjSGFzaChzZWNyZXRLZXkuc3ViYXJyYXkoMCwgc2l6ZSkpO1xuICAgICAgICAgICAgcmV0dXJuIGFkanVzdFNjYWxhckJ5dGVzKGhhc2hlZCkuc3ViYXJyYXkoMCwgc2l6ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgICAgICByYW5kb21Qcml2YXRlS2V5OiByYW5kb21TZWNyZXRLZXksXG4gICAgICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgICAgICBwcmVjb21wdXRlKHdpbmRvd1NpemUgPSA4LCBwb2ludCA9IFBvaW50LkJBU0UpIHtcbiAgICAgICAgICAgIHJldHVybiBwb2ludC5wcmVjb21wdXRlKHdpbmRvd1NpemUsIGZhbHNlKTtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAga2V5Z2VuLFxuICAgICAgICBnZXRQdWJsaWNLZXksXG4gICAgICAgIHNpZ24sXG4gICAgICAgIHZlcmlmeSxcbiAgICAgICAgdXRpbHMsXG4gICAgICAgIFBvaW50LFxuICAgICAgICBsZW5ndGhzLFxuICAgIH0pO1xufVxuZnVuY3Rpb24gX2VkZHNhX2xlZ2FjeV9vcHRzX3RvX25ldyhjKSB7XG4gICAgY29uc3QgQ1VSVkUgPSB7XG4gICAgICAgIGE6IGMuYSxcbiAgICAgICAgZDogYy5kLFxuICAgICAgICBwOiBjLkZwLk9SREVSLFxuICAgICAgICBuOiBjLm4sXG4gICAgICAgIGg6IGMuaCxcbiAgICAgICAgR3g6IGMuR3gsXG4gICAgICAgIEd5OiBjLkd5LFxuICAgIH07XG4gICAgY29uc3QgRnAgPSBjLkZwO1xuICAgIGNvbnN0IEZuID0gRmllbGQoQ1VSVkUubiwgYy5uQml0TGVuZ3RoLCB0cnVlKTtcbiAgICBjb25zdCBjdXJ2ZU9wdHMgPSB7IEZwLCBGbiwgdXZSYXRpbzogYy51dlJhdGlvIH07XG4gICAgY29uc3QgZWRkc2FPcHRzID0ge1xuICAgICAgICByYW5kb21CeXRlczogYy5yYW5kb21CeXRlcyxcbiAgICAgICAgYWRqdXN0U2NhbGFyQnl0ZXM6IGMuYWRqdXN0U2NhbGFyQnl0ZXMsXG4gICAgICAgIGRvbWFpbjogYy5kb21haW4sXG4gICAgICAgIHByZWhhc2g6IGMucHJlaGFzaCxcbiAgICAgICAgbWFwVG9DdXJ2ZTogYy5tYXBUb0N1cnZlLFxuICAgIH07XG4gICAgcmV0dXJuIHsgQ1VSVkUsIGN1cnZlT3B0cywgaGFzaDogYy5oYXNoLCBlZGRzYU9wdHMgfTtcbn1cbmZ1bmN0aW9uIF9lZGRzYV9uZXdfb3V0cHV0X3RvX2xlZ2FjeShjLCBlZGRzYSkge1xuICAgIGNvbnN0IFBvaW50ID0gZWRkc2EuUG9pbnQ7XG4gICAgY29uc3QgbGVnYWN5ID0gT2JqZWN0LmFzc2lnbih7fSwgZWRkc2EsIHtcbiAgICAgICAgRXh0ZW5kZWRQb2ludDogUG9pbnQsXG4gICAgICAgIENVUlZFOiBjLFxuICAgICAgICBuQml0TGVuZ3RoOiBQb2ludC5Gbi5CSVRTLFxuICAgICAgICBuQnl0ZUxlbmd0aDogUG9pbnQuRm4uQllURVMsXG4gICAgfSk7XG4gICAgcmV0dXJuIGxlZ2FjeTtcbn1cbi8vIFRPRE86IHJlbW92ZS4gVXNlIGVkZHNhXG5leHBvcnQgZnVuY3Rpb24gdHdpc3RlZEVkd2FyZHMoYykge1xuICAgIGNvbnN0IHsgQ1VSVkUsIGN1cnZlT3B0cywgaGFzaCwgZWRkc2FPcHRzIH0gPSBfZWRkc2FfbGVnYWN5X29wdHNfdG9fbmV3KGMpO1xuICAgIGNvbnN0IFBvaW50ID0gZWR3YXJkcyhDVVJWRSwgY3VydmVPcHRzKTtcbiAgICBjb25zdCBFRERTQSA9IGVkZHNhKFBvaW50LCBoYXNoLCBlZGRzYU9wdHMpO1xuICAgIHJldHVybiBfZWRkc2FfbmV3X291dHB1dF90b19sZWdhY3koYywgRUREU0EpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZWR3YXJkcy5qcy5tYXAiXSwibmFtZXMiOlsiX3ZhbGlkYXRlT2JqZWN0IiwiX2Fib29sMiIsImFib29sIiwiX2FieXRlczIiLCJhYnl0ZXMiLCJhSW5SYW5nZSIsImJ5dGVzVG9IZXgiLCJieXRlc1RvTnVtYmVyTEUiLCJjb25jYXRCeXRlcyIsImNvcHlCeXRlcyIsImVuc3VyZUJ5dGVzIiwiaXNCeXRlcyIsIm1lbW9pemVkIiwibm90SW1wbGVtZW50ZWQiLCJyYW5kb21CeXRlcyIsInJhbmRvbUJ5dGVzV2ViIiwiX2NyZWF0ZUN1cnZlRmllbGRzIiwibm9ybWFsaXplWiIsInBpcHBlbmdlciIsIndOQUYiLCJGaWVsZCIsIl8wbiIsIkJpZ0ludCIsIl8xbiIsIl8ybiIsIl84biIsImlzRWRWYWxpZFhZIiwiRnAiLCJDVVJWRSIsIngiLCJ5IiwieDIiLCJzcXIiLCJ5MiIsImxlZnQiLCJhZGQiLCJtdWwiLCJhIiwicmlnaHQiLCJPTkUiLCJkIiwiZXFsIiwiZWR3YXJkcyIsInBhcmFtcyIsImV4dHJhT3B0cyIsInZhbGlkYXRlZCIsIkZwRm5MRSIsIkZuIiwiaCIsImNvZmFjdG9yIiwidXZSYXRpbyIsIk1BU0siLCJCWVRFUyIsIm1vZFAiLCJuIiwiY3JlYXRlIiwidSIsInYiLCJpc1ZhbGlkIiwidmFsdWUiLCJzcXJ0IiwiZGl2IiwiZSIsIkd4IiwiR3kiLCJFcnJvciIsImFjb29yZCIsInRpdGxlIiwiYmFuWmVybyIsIm1pbiIsImFleHRwb2ludCIsIm90aGVyIiwiUG9pbnQiLCJ0b0FmZmluZU1lbW8iLCJwIiwiaXoiLCJYIiwiWSIsIloiLCJpczAiLCJpbnYiLCJ6eiIsImFzc2VydFZhbGlkTWVtbyIsIlQiLCJYMiIsIlkyIiwiWjIiLCJaNCIsImFYMiIsIlhZIiwiWlQiLCJjb25zdHJ1Y3RvciIsIk9iamVjdCIsImZyZWV6ZSIsImZyb21BZmZpbmUiLCJmcm9tQnl0ZXMiLCJieXRlcyIsInppcDIxNSIsImxlbiIsIm5vcm1lZCIsImxhc3RCeXRlIiwibWF4IiwiT1JERVIiLCJpc1hPZGQiLCJpc0xhc3RCeXRlT2RkIiwiZnJvbUhleCIsInRvQWZmaW5lIiwicHJlY29tcHV0ZSIsIndpbmRvd1NpemUiLCJpc0xhenkiLCJ3bmFmIiwiY3JlYXRlQ2FjaGUiLCJtdWx0aXBseSIsImFzc2VydFZhbGlkaXR5IiwiZXF1YWxzIiwiWDEiLCJZMSIsIloxIiwiWDFaMiIsIlgyWjEiLCJZMVoyIiwiWTJaMSIsIlpFUk8iLCJuZWdhdGUiLCJkb3VibGUiLCJBIiwiQiIsIkMiLCJEIiwieDF5MSIsIkUiLCJHIiwiRiIsIkgiLCJYMyIsIlkzIiwiVDMiLCJaMyIsIlQxIiwiVDIiLCJzdWJ0cmFjdCIsInNjYWxhciIsImlzVmFsaWROb3QwIiwiZiIsImNhY2hlZCIsIm11bHRpcGx5VW5zYWZlIiwiYWNjIiwidW5zYWZlIiwiaXNTbWFsbE9yZGVyIiwiaXNUb3JzaW9uRnJlZSIsImludmVydGVkWiIsImNsZWFyQ29mYWN0b3IiLCJ0b0J5dGVzIiwibGVuZ3RoIiwidG9IZXgiLCJ0b1N0cmluZyIsImV4IiwiZXkiLCJleiIsImV0IiwicG9pbnRzIiwibXNtIiwic2NhbGFycyIsIl9zZXRXaW5kb3dTaXplIiwidG9SYXdCeXRlcyIsIkJBU0UiLCJCSVRTIiwiUHJpbWVFZHdhcmRzUG9pbnQiLCJlcCIsIl9ieXRlcyIsIl9oZXgiLCJhc3NlcnRTYW1lIiwiaW5pdCIsImVkZHNhIiwiY0hhc2giLCJlZGRzYU9wdHMiLCJhZGp1c3RTY2FsYXJCeXRlcyIsImRvbWFpbiIsInByZWhhc2giLCJtYXBUb0N1cnZlIiwiZGF0YSIsImN0eCIsInBoZmxhZyIsIm1vZE5fTEUiLCJoYXNoIiwiZ2V0UHJpdmF0ZVNjYWxhciIsImtleSIsImxlbmd0aHMiLCJzZWNyZXRLZXkiLCJoYXNoZWQiLCJoZWFkIiwic2xpY2UiLCJwcmVmaXgiLCJnZXRFeHRlbmRlZFB1YmxpY0tleSIsInBvaW50IiwicG9pbnRCeXRlcyIsImdldFB1YmxpY0tleSIsImhhc2hEb21haW5Ub1NjYWxhciIsImNvbnRleHQiLCJVaW50OEFycmF5Iiwib2YiLCJtc2dzIiwibXNnIiwic2lnbiIsIm9wdGlvbnMiLCJyIiwiUiIsImsiLCJzIiwicnMiLCJzaWduYXR1cmUiLCJ2ZXJpZnlPcHRzIiwidmVyaWZ5Iiwic2lnIiwicHVibGljS2V5IiwidW5kZWZpbmVkIiwibWlkIiwic3ViYXJyYXkiLCJTQiIsImVycm9yIiwiUmtBIiwiX3NpemUiLCJzZWVkIiwicmFuZG9tU2VjcmV0S2V5Iiwia2V5Z2VuIiwidXRpbHMiLCJpc1ZhbGlkU2VjcmV0S2V5IiwiaXNWYWxpZFB1YmxpY0tleSIsInRvTW9udGdvbWVyeSIsInNpemUiLCJpczI1NTE5IiwidG9Nb250Z29tZXJ5U2VjcmV0IiwicmFuZG9tUHJpdmF0ZUtleSIsIl9lZGRzYV9sZWdhY3lfb3B0c190b19uZXciLCJjIiwibkJpdExlbmd0aCIsImN1cnZlT3B0cyIsIl9lZGRzYV9uZXdfb3V0cHV0X3RvX2xlZ2FjeSIsImxlZ2FjeSIsImFzc2lnbiIsIkV4dGVuZGVkUG9pbnQiLCJuQnl0ZUxlbmd0aCIsInR3aXN0ZWRFZHdhcmRzIiwiRUREU0EiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/edwards.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/hash-to-curve.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/hash-to-curve.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _DST_scalar: () => (/* binding */ _DST_scalar),\n/* harmony export */   createHasher: () => (/* binding */ createHasher),\n/* harmony export */   expand_message_xmd: () => (/* binding */ expand_message_xmd),\n/* harmony export */   expand_message_xof: () => (/* binding */ expand_message_xof),\n/* harmony export */   hash_to_field: () => (/* binding */ hash_to_field),\n/* harmony export */   isogenyMap: () => (/* binding */ isogenyMap)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/utils.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/modular.js\");\n\n\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n    anum(value);\n    anum(length);\n    if (value < 0 || value >= 1 << 8 * length) throw new Error(\"invalid I2OSP input: \" + value);\n    const res = Array.from({\n        length\n    }).fill(0);\n    for(let i = length - 1; i >= 0; i--){\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for(let i = 0; i < a.length; i++){\n        arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n}\nfunction anum(item) {\n    if (!Number.isSafeInteger(item)) throw new Error(\"number expected\");\n}\nfunction normDST(DST) {\n    if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isBytes)(DST) && typeof DST !== \"string\") throw new Error(\"DST must be Uint8Array or string\");\n    return typeof DST === \"string\" ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.utf8ToBytes)(DST) : DST;\n}\n/**\n * Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits.\n * [RFC 9380 5.3.1](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1).\n */ function expand_message_xmd(msg, DST, lenInBytes, H) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.abytes)(msg);\n    anum(lenInBytes);\n    DST = normDST(DST);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    if (DST.length > 255) DST = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.utf8ToBytes)(\"H2C-OVERSIZE-DST-\"), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (lenInBytes > 65535 || ell > 255) throw new Error(\"expand_message_xmd: invalid lenInBytes\");\n    const DST_prime = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(b_0, i2osp(1, 1), DST_prime));\n    for(let i = 1; i <= ell; i++){\n        const args = [\n            strxor(b_0, b[i - 1]),\n            i2osp(i + 1, 1),\n            DST_prime\n        ];\n        b[i] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(...args));\n    }\n    const pseudo_random_bytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\n/**\n * Produces a uniformly random byte string using an extendable-output function (XOF) H.\n * 1. The collision resistance of H MUST be at least k bits.\n * 2. H MUST be an XOF that has been proved indifferentiable from\n *    a random oracle under a reasonable cryptographic assumption.\n * [RFC 9380 5.3.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2).\n */ function expand_message_xof(msg, DST, lenInBytes, k, H) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.abytes)(msg);\n    anum(lenInBytes);\n    DST = normDST(DST);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil(2 * k / 8);\n        DST = H.create({\n            dkLen\n        }).update((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.utf8ToBytes)(\"H2C-OVERSIZE-DST-\")).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255) throw new Error(\"expand_message_xof: invalid lenInBytes\");\n    return H.create({\n        dkLen: lenInBytes\n    }).update(msg).update(i2osp(lenInBytes, 2))// 2. DST_prime = DST || I2OSP(len(DST), 1)\n    .update(DST).update(i2osp(DST.length, 1)).digest();\n}\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F.\n * [RFC 9380 5.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.2).\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */ function hash_to_field(msg, count, options) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._validateObject)(options, {\n        p: \"bigint\",\n        m: \"number\",\n        k: \"number\",\n        hash: \"function\"\n    });\n    const { p, k, m, hash, expand, DST } = options;\n    if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isHash)(options.hash)) throw new Error(\"expected valid hash\");\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.abytes)(msg);\n    anum(count);\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === \"xmd\") {\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n    } else if (expand === \"xof\") {\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    } else if (expand === \"_internal_pass\") {\n        // for internal tests only\n        prb = msg;\n    } else {\n        throw new Error('expand must be \"xmd\" or \"xof\"');\n    }\n    const u = new Array(count);\n    for(let i = 0; i < count; i++){\n        const e = new Array(m);\n        for(let j = 0; j < m; j++){\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.mod)(os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nfunction isogenyMap(field, map) {\n    // Make same order as in spec\n    const coeff = map.map((i)=>Array.from(i).reverse());\n    return (x, y)=>{\n        const [xn, xd, yn, yd] = coeff.map((val)=>val.reduce((acc, i)=>field.add(field.mul(acc, x), i)));\n        // 6.6.3\n        // Exceptional cases of iso_map are inputs that cause the denominator of\n        // either rational function to evaluate to zero; such cases MUST return\n        // the identity point on E.\n        const [xd_inv, yd_inv] = (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.FpInvertBatch)(field, [\n            xd,\n            yd\n        ], true);\n        x = field.mul(xn, xd_inv); // xNum / xDen\n        y = field.mul(y, field.mul(yn, yd_inv)); // y * (yNum / yDev)\n        return {\n            x,\n            y\n        };\n    };\n}\nconst _DST_scalar = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.utf8ToBytes)(\"HashToScalar-\");\n/** Creates hash-to-curve methods from EC Point and mapToCurve function. See {@link H2CHasher}. */ function createHasher(Point, mapToCurve, defaults) {\n    if (typeof mapToCurve !== \"function\") throw new Error(\"mapToCurve() must be defined\");\n    function map(num) {\n        return Point.fromAffine(mapToCurve(num));\n    }\n    function clear(initial) {\n        const P = initial.clearCofactor();\n        if (P.equals(Point.ZERO)) return Point.ZERO; // zero will throw in assert\n        P.assertValidity();\n        return P;\n    }\n    return {\n        defaults,\n        hashToCurve (msg, options) {\n            const opts = Object.assign({}, defaults, options);\n            const u = hash_to_field(msg, 2, opts);\n            const u0 = map(u[0]);\n            const u1 = map(u[1]);\n            return clear(u0.add(u1));\n        },\n        encodeToCurve (msg, options) {\n            const optsDst = defaults.encodeDST ? {\n                DST: defaults.encodeDST\n            } : {};\n            const opts = Object.assign({}, defaults, optsDst, options);\n            const u = hash_to_field(msg, 1, opts);\n            const u0 = map(u[0]);\n            return clear(u0);\n        },\n        /** See {@link H2CHasher} */ mapToCurve (scalars) {\n            if (!Array.isArray(scalars)) throw new Error(\"expected array of bigints\");\n            for (const i of scalars)if (typeof i !== \"bigint\") throw new Error(\"expected array of bigints\");\n            return clear(map(scalars));\n        },\n        // hash_to_scalar can produce 0: https://www.rfc-editor.org/errata/eid8393\n        // RFC 9380, draft-irtf-cfrg-bbs-signatures-08\n        hashToScalar (msg, options) {\n            // @ts-ignore\n            const N = Point.Fn.ORDER;\n            const opts = Object.assign({}, defaults, {\n                p: N,\n                m: 1,\n                DST: _DST_scalar\n            }, options);\n            return hash_to_field(msg, 1, opts)[0][0];\n        }\n    };\n} //# sourceMappingURL=hash-to-curve.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFtSDtBQUNqRTtBQUNsRCw2RkFBNkY7QUFDN0YsTUFBTVMsUUFBUVAsc0RBQWVBO0FBQzdCLDRDQUE0QztBQUM1QyxTQUFTUSxNQUFNQyxLQUFLLEVBQUVDLE1BQU07SUFDeEJDLEtBQUtGO0lBQ0xFLEtBQUtEO0lBQ0wsSUFBSUQsUUFBUSxLQUFLQSxTQUFTLEtBQU0sSUFBSUMsUUFDaEMsTUFBTSxJQUFJRSxNQUFNLDBCQUEwQkg7SUFDOUMsTUFBTUksTUFBTUMsTUFBTUMsSUFBSSxDQUFDO1FBQUVMO0lBQU8sR0FBR00sSUFBSSxDQUFDO0lBQ3hDLElBQUssSUFBSUMsSUFBSVAsU0FBUyxHQUFHTyxLQUFLLEdBQUdBLElBQUs7UUFDbENKLEdBQUcsQ0FBQ0ksRUFBRSxHQUFHUixRQUFRO1FBQ2pCQSxXQUFXO0lBQ2Y7SUFDQSxPQUFPLElBQUlTLFdBQVdMO0FBQzFCO0FBQ0EsU0FBU00sT0FBT0MsQ0FBQyxFQUFFQyxDQUFDO0lBQ2hCLE1BQU1DLE1BQU0sSUFBSUosV0FBV0UsRUFBRVYsTUFBTTtJQUNuQyxJQUFLLElBQUlPLElBQUksR0FBR0EsSUFBSUcsRUFBRVYsTUFBTSxFQUFFTyxJQUFLO1FBQy9CSyxHQUFHLENBQUNMLEVBQUUsR0FBR0csQ0FBQyxDQUFDSCxFQUFFLEdBQUdJLENBQUMsQ0FBQ0osRUFBRTtJQUN4QjtJQUNBLE9BQU9LO0FBQ1g7QUFDQSxTQUFTWCxLQUFLWSxJQUFJO0lBQ2QsSUFBSSxDQUFDQyxPQUFPQyxhQUFhLENBQUNGLE9BQ3RCLE1BQU0sSUFBSVgsTUFBTTtBQUN4QjtBQUNBLFNBQVNjLFFBQVFDLEdBQUc7SUFDaEIsSUFBSSxDQUFDekIsa0RBQU9BLENBQUN5QixRQUFRLE9BQU9BLFFBQVEsVUFDaEMsTUFB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LEVBQUUsQ0FBQ0MsS0FBSztZQUN4QixNQUFNYixPQUFPQyxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHYixVQUFVO2dCQUFFckMsR0FBRzJEO2dCQUFHMUQsR0FBRztnQkFBRzdCLEtBQUs2RDtZQUFZLEdBQUdsQztZQUMzRSxPQUFPRixjQUFjdkIsS0FBSyxHQUFHMEUsS0FBSyxDQUFDLEVBQUUsQ0FBQyxFQUFFO1FBQzVDO0lBQ0o7QUFDSixFQUNBLHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsYXctd29ya3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzP2E2ODciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX3ZhbGlkYXRlT2JqZWN0LCBhYnl0ZXMsIGJ5dGVzVG9OdW1iZXJCRSwgY29uY2F0Qnl0ZXMsIGlzQnl0ZXMsIGlzSGFzaCwgdXRmOFRvQnl0ZXMsIH0gZnJvbSBcIi4uL3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBGcEludmVydEJhdGNoLCBtb2QgfSBmcm9tIFwiLi9tb2R1bGFyLmpzXCI7XG4vLyBPY3RldCBTdHJlYW0gdG8gSW50ZWdlci4gXCJzcGVjXCIgaW1wbGVtZW50YXRpb24gb2Ygb3MyaXAgaXMgMi41eCBzbG93ZXIgdnMgYnl0ZXNUb051bWJlckJFLlxuY29uc3Qgb3MyaXAgPSBieXRlc1RvTnVtYmVyQkU7XG4vLyBJbnRlZ2VyIHRvIE9jdGV0IFN0cmVhbSAobnVtYmVyVG9CeXRlc0JFKVxuZnVuY3Rpb24gaTJvc3AodmFsdWUsIGxlbmd0aCkge1xuICAgIGFudW0odmFsdWUpO1xuICAgIGFudW0obGVuZ3RoKTtcbiAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID49IDEgPDwgKDggKiBsZW5ndGgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgSTJPU1AgaW5wdXQ6ICcgKyB2YWx1ZSk7XG4gICAgY29uc3QgcmVzID0gQXJyYXkuZnJvbSh7IGxlbmd0aCB9KS5maWxsKDApO1xuICAgIGZvciAobGV0IGkgPSBsZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICByZXNbaV0gPSB2YWx1ZSAmIDB4ZmY7XG4gICAgICAgIHZhbHVlID4+Pj0gODtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHJlcyk7XG59XG5mdW5jdGlvbiBzdHJ4b3IoYSwgYikge1xuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KGEubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gYVtpXSBeIGJbaV07XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG59XG5mdW5jdGlvbiBhbnVtKGl0ZW0pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGl0ZW0pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ251bWJlciBleHBlY3RlZCcpO1xufVxuZnVuY3Rpb24gbm9ybURTVChEU1QpIHtcbiAgICBpZiAoIWlzQnl0ZXMoRFNUKSAmJiB0eXBlb2YgRFNUICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEU1QgbXVzdCBiZSBVaW50OEFycmF5IG9yIHN0cmluZycpO1xuICAgIHJldHVybiB0eXBlb2YgRFNUID09PSAnc3RyaW5nJyA/IHV0ZjhUb0J5dGVzKERTVCkgOiBEU1Q7XG59XG4vKipcbiAqIFByb2R1Y2VzIGEgdW5pZm9ybWx5IHJhbmRvbSBieXRlIHN0cmluZyB1c2luZyBhIGNyeXB0b2dyYXBoaWMgaGFzaCBmdW5jdGlvbiBIIHRoYXQgb3V0cHV0cyBiIGJpdHMuXG4gKiBbUkZDIDkzODAgNS4zLjFdKGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjEpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhwYW5kX21lc3NhZ2VfeG1kKG1zZywgRFNULCBsZW5JbkJ5dGVzLCBIKSB7XG4gICAgYWJ5dGVzKG1zZyk7XG4gICAgYW51bShsZW5JbkJ5dGVzKTtcbiAgICBEU1QgPSBub3JtRFNUKERTVCk7XG4gICAgLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjMuM1xuICAgIGlmIChEU1QubGVuZ3RoID4gMjU1KVxuICAgICAgICBEU1QgPSBIKGNvbmNhdEJ5dGVzKHV0ZjhUb0J5dGVzKCdIMkMtT1ZFUlNJWkUtRFNULScpLCBEU1QpKTtcbiAgICBjb25zdCB7IG91dHB1dExlbjogYl9pbl9ieXRlcywgYmxvY2tMZW46IHJfaW5fYnl0ZXMgfSA9IEg7XG4gICAgY29uc3QgZWxsID0gTWF0aC5jZWlsKGxlbkluQnl0ZXMgLyBiX2luX2J5dGVzKTtcbiAgICBpZiAobGVuSW5CeXRlcyA+IDY1NTM1IHx8IGVsbCA+IDI1NSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBhbmRfbWVzc2FnZV94bWQ6IGludmFsaWQgbGVuSW5CeXRlcycpO1xuICAgIGNvbnN0IERTVF9wcmltZSA9IGNvbmNhdEJ5dGVzKERTVCwgaTJvc3AoRFNULmxlbmd0aCwgMSkpO1xuICAgIGNvbnN0IFpfcGFkID0gaTJvc3AoMCwgcl9pbl9ieXRlcyk7XG4gICAgY29uc3QgbF9pX2Jfc3RyID0gaTJvc3AobGVuSW5CeXRlcywgMik7IC8vIGxlbl9pbl9ieXRlc19zdHJcbiAgICBjb25zdCBiID0gbmV3IEFycmF5KGVsbCk7XG4gICAgY29uc3QgYl8wID0gSChjb25jYXRCeXRlcyhaX3BhZCwgbXNnLCBsX2lfYl9zdHIsIGkyb3NwKDAsIDEpLCBEU1RfcHJpbWUpKTtcbiAgICBiWzBdID0gSChjb25jYXRCeXRlcyhiXzAsIGkyb3NwKDEsIDEpLCBEU1RfcHJpbWUpKTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBlbGw7IGkrKykge1xuICAgICAgICBjb25zdCBhcmdzID0gW3N0cnhvcihiXzAsIGJbaSAtIDFdKSwgaTJvc3AoaSArIDEsIDEpLCBEU1RfcHJpbWVdO1xuICAgICAgICBiW2ldID0gSChjb25jYXRCeXRlcyguLi5hcmdzKSk7XG4gICAgfVxuICAgIGNvbnN0IHBzZXVkb19yYW5kb21fYnl0ZXMgPSBjb25jYXRCeXRlcyguLi5iKTtcbiAgICByZXR1cm4gcHNldWRvX3JhbmRvbV9ieXRlcy5zbGljZSgwLCBsZW5JbkJ5dGVzKTtcbn1cbi8qKlxuICogUHJvZHVjZXMgYSB1bmlmb3JtbHkgcmFuZG9tIGJ5dGUgc3RyaW5nIHVzaW5nIGFuIGV4dGVuZGFibGUtb3V0cHV0IGZ1bmN0aW9uIChYT0YpIEguXG4gKiAxLiBUaGUgY29sbGlzaW9uIHJlc2lzdGFuY2Ugb2YgSCBNVVNUIGJlIGF0IGxlYXN0IGsgYml0cy5cbiAqIDIuIEggTVVTVCBiZSBhbiBYT0YgdGhhdCBoYXMgYmVlbiBwcm92ZWQgaW5kaWZmZXJlbnRpYWJsZSBmcm9tXG4gKiAgICBhIHJhbmRvbSBvcmFjbGUgdW5kZXIgYSByZWFzb25hYmxlIGNyeXB0b2dyYXBoaWMgYXNzdW1wdGlvbi5cbiAqIFtSRkMgOTM4MCA1LjMuMl0oaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjMuMikuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHBhbmRfbWVzc2FnZV94b2YobXNnLCBEU1QsIGxlbkluQnl0ZXMsIGssIEgpIHtcbiAgICBhYnl0ZXMobXNnKTtcbiAgICBhbnVtKGxlbkluQnl0ZXMpO1xuICAgIERTVCA9IG5vcm1EU1QoRFNUKTtcbiAgICAvLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMy4zXG4gICAgLy8gRFNUID0gSCgnSDJDLU9WRVJTSVpFLURTVC0nIHx8IGFfdmVyeV9sb25nX0RTVCwgTWF0aC5jZWlsKChsZW5JbkJ5dGVzICogaykgLyA4KSk7XG4gICAgaWYgKERTVC5sZW5ndGggPiAyNTUpIHtcbiAgICAgICAgY29uc3QgZGtMZW4gPSBNYXRoLmNlaWwoKDIgKiBrKSAvIDgpO1xuICAgICAgICBEU1QgPSBILmNyZWF0ZSh7IGRrTGVuIH0pLnVwZGF0ZSh1dGY4VG9CeXRlcygnSDJDLU9WRVJTSVpFLURTVC0nKSkudXBkYXRlKERTVCkuZGlnZXN0KCk7XG4gICAgfVxuICAgIGlmIChsZW5JbkJ5dGVzID4gNjU1MzUgfHwgRFNULmxlbmd0aCA+IDI1NSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBhbmRfbWVzc2FnZV94b2Y6IGludmFsaWQgbGVuSW5CeXRlcycpO1xuICAgIHJldHVybiAoSC5jcmVhdGUoeyBka0xlbjogbGVuSW5CeXRlcyB9KVxuICAgICAgICAudXBkYXRlKG1zZylcbiAgICAgICAgLnVwZGF0ZShpMm9zcChsZW5JbkJ5dGVzLCAyKSlcbiAgICAgICAgLy8gMi4gRFNUX3ByaW1lID0gRFNUIHx8IEkyT1NQKGxlbihEU1QpLCAxKVxuICAgICAgICAudXBkYXRlKERTVClcbiAgICAgICAgLnVwZGF0ZShpMm9zcChEU1QubGVuZ3RoLCAxKSlcbiAgICAgICAgLmRpZ2VzdCgpKTtcbn1cbi8qKlxuICogSGFzaGVzIGFyYml0cmFyeS1sZW5ndGggYnl0ZSBzdHJpbmdzIHRvIGEgbGlzdCBvZiBvbmUgb3IgbW9yZSBlbGVtZW50cyBvZiBhIGZpbml0ZSBmaWVsZCBGLlxuICogW1JGQyA5MzgwIDUuMl0oaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjIpLlxuICogQHBhcmFtIG1zZyBhIGJ5dGUgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIG1lc3NhZ2UgdG8gaGFzaFxuICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgZWxlbWVudHMgb2YgRiB0byBvdXRwdXRcbiAqIEBwYXJhbSBvcHRpb25zIGB7RFNUOiBzdHJpbmcsIHA6IGJpZ2ludCwgbTogbnVtYmVyLCBrOiBudW1iZXIsIGV4cGFuZDogJ3htZCcgfCAneG9mJywgaGFzaDogSH1gLCBzZWUgYWJvdmVcbiAqIEByZXR1cm5zIFt1XzAsIC4uLiwgdV8oY291bnQgLSAxKV0sIGEgbGlzdCBvZiBmaWVsZCBlbGVtZW50cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2hfdG9fZmllbGQobXNnLCBjb3VudCwgb3B0aW9ucykge1xuICAgIF92YWxpZGF0ZU9iamVjdChvcHRpb25zLCB7XG4gICAgICAgIHA6ICdiaWdpbnQnLFxuICAgICAgICBtOiAnbnVtYmVyJyxcbiAgICAgICAgazogJ251bWJlcicsXG4gICAgICAgIGhhc2g6ICdmdW5jdGlvbicsXG4gICAgfSk7XG4gICAgY29uc3QgeyBwLCBrLCBtLCBoYXNoLCBleHBhbmQsIERTVCB9ID0gb3B0aW9ucztcbiAgICBpZiAoIWlzSGFzaChvcHRpb25zLmhhc2gpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIHZhbGlkIGhhc2gnKTtcbiAgICBhYnl0ZXMobXNnKTtcbiAgICBhbnVtKGNvdW50KTtcbiAgICBjb25zdCBsb2cycCA9IHAudG9TdHJpbmcoMikubGVuZ3RoO1xuICAgIGNvbnN0IEwgPSBNYXRoLmNlaWwoKGxvZzJwICsgaykgLyA4KTsgLy8gc2VjdGlvbiA1LjEgb2YgaWV0ZiBkcmFmdCBsaW5rIGFib3ZlXG4gICAgY29uc3QgbGVuX2luX2J5dGVzID0gY291bnQgKiBtICogTDtcbiAgICBsZXQgcHJiOyAvLyBwc2V1ZG9fcmFuZG9tX2J5dGVzXG4gICAgaWYgKGV4cGFuZCA9PT0gJ3htZCcpIHtcbiAgICAgICAgcHJiID0gZXhwYW5kX21lc3NhZ2VfeG1kKG1zZywgRFNULCBsZW5faW5fYnl0ZXMsIGhhc2gpO1xuICAgIH1cbiAgICBlbHNlIGlmIChleHBhbmQgPT09ICd4b2YnKSB7XG4gICAgICAgIHByYiA9IGV4cGFuZF9tZXNzYWdlX3hvZihtc2csIERTVCwgbGVuX2luX2J5dGVzLCBrLCBoYXNoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXhwYW5kID09PSAnX2ludGVybmFsX3Bhc3MnKSB7XG4gICAgICAgIC8vIGZvciBpbnRlcm5hbCB0ZXN0cyBvbmx5XG4gICAgICAgIHByYiA9IG1zZztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwYW5kIG11c3QgYmUgXCJ4bWRcIiBvciBcInhvZlwiJyk7XG4gICAgfVxuICAgIGNvbnN0IHUgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICBjb25zdCBlID0gbmV3IEFycmF5KG0pO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG07IGorKykge1xuICAgICAgICAgICAgY29uc3QgZWxtX29mZnNldCA9IEwgKiAoaiArIGkgKiBtKTtcbiAgICAgICAgICAgIGNvbnN0IHR2ID0gcHJiLnN1YmFycmF5KGVsbV9vZmZzZXQsIGVsbV9vZmZzZXQgKyBMKTtcbiAgICAgICAgICAgIGVbal0gPSBtb2Qob3MyaXAodHYpLCBwKTtcbiAgICAgICAgfVxuICAgICAgICB1W2ldID0gZTtcbiAgICB9XG4gICAgcmV0dXJuIHU7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNvZ2VueU1hcChmaWVsZCwgbWFwKSB7XG4gICAgLy8gTWFrZSBzYW1lIG9yZGVyIGFzIGluIHNwZWNcbiAgICBjb25zdCBjb2VmZiA9IG1hcC5tYXAoKGkpID0+IEFycmF5LmZyb20oaSkucmV2ZXJzZSgpKTtcbiAgICByZXR1cm4gKHgsIHkpID0+IHtcbiAgICAgICAgY29uc3QgW3huLCB4ZCwgeW4sIHlkXSA9IGNvZWZmLm1hcCgodmFsKSA9PiB2YWwucmVkdWNlKChhY2MsIGkpID0+IGZpZWxkLmFkZChmaWVsZC5tdWwoYWNjLCB4KSwgaSkpKTtcbiAgICAgICAgLy8gNi42LjNcbiAgICAgICAgLy8gRXhjZXB0aW9uYWwgY2FzZXMgb2YgaXNvX21hcCBhcmUgaW5wdXRzIHRoYXQgY2F1c2UgdGhlIGRlbm9taW5hdG9yIG9mXG4gICAgICAgIC8vIGVpdGhlciByYXRpb25hbCBmdW5jdGlvbiB0byBldmFsdWF0ZSB0byB6ZXJvOyBzdWNoIGNhc2VzIE1VU1QgcmV0dXJuXG4gICAgICAgIC8vIHRoZSBpZGVudGl0eSBwb2ludCBvbiBFLlxuICAgICAgICBjb25zdCBbeGRfaW52LCB5ZF9pbnZdID0gRnBJbnZlcnRCYXRjaChmaWVsZCwgW3hkLCB5ZF0sIHRydWUpO1xuICAgICAgICB4ID0gZmllbGQubXVsKHhuLCB4ZF9pbnYpOyAvLyB4TnVtIC8geERlblxuICAgICAgICB5ID0gZmllbGQubXVsKHksIGZpZWxkLm11bCh5biwgeWRfaW52KSk7IC8vIHkgKiAoeU51bSAvIHlEZXYpXG4gICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICB9O1xufVxuZXhwb3J0IGNvbnN0IF9EU1Rfc2NhbGFyID0gdXRmOFRvQnl0ZXMoJ0hhc2hUb1NjYWxhci0nKTtcbi8qKiBDcmVhdGVzIGhhc2gtdG8tY3VydmUgbWV0aG9kcyBmcm9tIEVDIFBvaW50IGFuZCBtYXBUb0N1cnZlIGZ1bmN0aW9uLiBTZWUge0BsaW5rIEgyQ0hhc2hlcn0uICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSGFzaGVyKFBvaW50LCBtYXBUb0N1cnZlLCBkZWZhdWx0cykge1xuICAgIGlmICh0eXBlb2YgbWFwVG9DdXJ2ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXBUb0N1cnZlKCkgbXVzdCBiZSBkZWZpbmVkJyk7XG4gICAgZnVuY3Rpb24gbWFwKG51bSkge1xuICAgICAgICByZXR1cm4gUG9pbnQuZnJvbUFmZmluZShtYXBUb0N1cnZlKG51bSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbGVhcihpbml0aWFsKSB7XG4gICAgICAgIGNvbnN0IFAgPSBpbml0aWFsLmNsZWFyQ29mYWN0b3IoKTtcbiAgICAgICAgaWYgKFAuZXF1YWxzKFBvaW50LlpFUk8pKVxuICAgICAgICAgICAgcmV0dXJuIFBvaW50LlpFUk87IC8vIHplcm8gd2lsbCB0aHJvdyBpbiBhc3NlcnRcbiAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICByZXR1cm4gUDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVmYXVsdHMsXG4gICAgICAgIGhhc2hUb0N1cnZlKG1zZywgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3Qgb3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IHUgPSBoYXNoX3RvX2ZpZWxkKG1zZywgMiwgb3B0cyk7XG4gICAgICAgICAgICBjb25zdCB1MCA9IG1hcCh1WzBdKTtcbiAgICAgICAgICAgIGNvbnN0IHUxID0gbWFwKHVbMV0pO1xuICAgICAgICAgICAgcmV0dXJuIGNsZWFyKHUwLmFkZCh1MSkpO1xuICAgICAgICB9LFxuICAgICAgICBlbmNvZGVUb0N1cnZlKG1zZywgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3Qgb3B0c0RzdCA9IGRlZmF1bHRzLmVuY29kZURTVCA/IHsgRFNUOiBkZWZhdWx0cy5lbmNvZGVEU1QgfSA6IHt9O1xuICAgICAgICAgICAgY29uc3Qgb3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRzLCBvcHRzRHN0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IHUgPSBoYXNoX3RvX2ZpZWxkKG1zZywgMSwgb3B0cyk7XG4gICAgICAgICAgICBjb25zdCB1MCA9IG1hcCh1WzBdKTtcbiAgICAgICAgICAgIHJldHVybiBjbGVhcih1MCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKiBTZWUge0BsaW5rIEgyQ0hhc2hlcn0gKi9cbiAgICAgICAgbWFwVG9DdXJ2ZShzY2FsYXJzKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NhbGFycykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCBhcnJheSBvZiBiaWdpbnRzJyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGkgb2Ygc2NhbGFycylcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGkgIT09ICdiaWdpbnQnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIGFycmF5IG9mIGJpZ2ludHMnKTtcbiAgICAgICAgICAgIHJldHVybiBjbGVhcihtYXAoc2NhbGFycykpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBoYXNoX3RvX3NjYWxhciBjYW4gcHJvZHVjZSAwOiBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9lcnJhdGEvZWlkODM5M1xuICAgICAgICAvLyBSRkMgOTM4MCwgZHJhZnQtaXJ0Zi1jZnJnLWJicy1zaWduYXR1cmVzLTA4XG4gICAgICAgIGhhc2hUb1NjYWxhcihtc2csIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IE4gPSBQb2ludC5Gbi5PUkRFUjtcbiAgICAgICAgICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0cywgeyBwOiBOLCBtOiAxLCBEU1Q6IF9EU1Rfc2NhbGFyIH0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIGhhc2hfdG9fZmllbGQobXNnLCAxLCBvcHRzKVswXVswXTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzaC10by1jdXJ2ZS5qcy5tYXAiXSwibmFtZXMiOlsiX3ZhbGlkYXRlT2JqZWN0IiwiYWJ5dGVzIiwiYnl0ZXNUb051bWJlckJFIiwiY29uY2F0Qnl0ZXMiLCJpc0J5dGVzIiwiaXNIYXNoIiwidXRmOFRvQnl0ZXMiLCJGcEludmVydEJhdGNoIiwibW9kIiwib3MyaXAiLCJpMm9zcCIsInZhbHVlIiwibGVuZ3RoIiwiYW51bSIsIkVycm9yIiwicmVzIiwiQXJyYXkiLCJmcm9tIiwiZmlsbCIsImkiLCJVaW50OEFycmF5Iiwic3RyeG9yIiwiYSIsImIiLCJhcnIiLCJpdGVtIiwiTnVtYmVyIiwiaXNTYWZlSW50ZWdlciIsIm5vcm1EU1QiLCJEU1QiLCJleHBhbmRfbWVzc2FnZV94bWQiLCJtc2ciLCJsZW5JbkJ5dGVzIiwiSCIsIm91dHB1dExlbiIsImJfaW5fYnl0ZXMiLCJibG9ja0xlbiIsInJfaW5fYnl0ZXMiLCJlbGwiLCJNYXRoIiwiY2VpbCIsIkRTVF9wcmltZSIsIlpfcGFkIiwibF9pX2Jfc3RyIiwiYl8wIiwiYXJncyIsInBzZXVkb19yYW5kb21fYnl0ZXMiLCJzbGljZSIsImV4cGFuZF9tZXNzYWdlX3hvZiIsImsiLCJka0xlbiIsImNyZWF0ZSIsInVwZGF0ZSIsImRpZ2VzdCIsImhhc2hfdG9fZmllbGQiLCJjb3VudCIsIm9wdGlvbnMiLCJwIiwibSIsImhhc2giLCJleHBhbmQiLCJsb2cycCIsInRvU3RyaW5nIiwiTCIsImxlbl9pbl9ieXRlcyIsInByYiIsInUiLCJlIiwiaiIsImVsbV9vZmZzZXQiLCJ0diIsInN1YmFycmF5IiwiaXNvZ2VueU1hcCIsImZpZWxkIiwibWFwIiwiY29lZmYiLCJyZXZlcnNlIiwieCIsInkiLCJ4biIsInhkIiwieW4iLCJ5ZCIsInZhbCIsInJlZHVjZSIsImFjYyIsImFkZCIsIm11bCIsInhkX2ludiIsInlkX2ludiIsIl9EU1Rfc2NhbGFyIiwiY3JlYXRlSGFzaGVyIiwiUG9pbnQiLCJtYXBUb0N1cnZlIiwiZGVmYXVsdHMiLCJudW0iLCJmcm9tQWZmaW5lIiwiY2xlYXIiLCJpbml0aWFsIiwiUCIsImNsZWFyQ29mYWN0b3IiLCJlcXVhbHMiLCJaRVJPIiwiYXNzZXJ0VmFsaWRpdHkiLCJoYXNoVG9DdXJ2ZSIsIm9wdHMiLCJPYmplY3QiLCJhc3NpZ24iLCJ1MCIsInUxIiwiZW5jb2RlVG9DdXJ2ZSIsIm9wdHNEc3QiLCJlbmNvZGVEU1QiLCJzY2FsYXJzIiwiaXNBcnJheSIsImhhc2hUb1NjYWxhciIsIk4iLCJGbiIsIk9SREVSIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/hash-to-curve.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/modular.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/modular.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Field: () => (/* binding */ Field),\n/* harmony export */   FpDiv: () => (/* binding */ FpDiv),\n/* harmony export */   FpInvertBatch: () => (/* binding */ FpInvertBatch),\n/* harmony export */   FpIsSquare: () => (/* binding */ FpIsSquare),\n/* harmony export */   FpLegendre: () => (/* binding */ FpLegendre),\n/* harmony export */   FpPow: () => (/* binding */ FpPow),\n/* harmony export */   FpSqrt: () => (/* binding */ FpSqrt),\n/* harmony export */   FpSqrtEven: () => (/* binding */ FpSqrtEven),\n/* harmony export */   FpSqrtOdd: () => (/* binding */ FpSqrtOdd),\n/* harmony export */   getFieldBytesLength: () => (/* binding */ getFieldBytesLength),\n/* harmony export */   getMinHashLength: () => (/* binding */ getMinHashLength),\n/* harmony export */   hashToPrivateScalar: () => (/* binding */ hashToPrivateScalar),\n/* harmony export */   invert: () => (/* binding */ invert),\n/* harmony export */   isNegativeLE: () => (/* binding */ isNegativeLE),\n/* harmony export */   mapHashToField: () => (/* binding */ mapHashToField),\n/* harmony export */   mod: () => (/* binding */ mod),\n/* harmony export */   nLength: () => (/* binding */ nLength),\n/* harmony export */   pow: () => (/* binding */ pow),\n/* harmony export */   pow2: () => (/* binding */ pow2),\n/* harmony export */   tonelliShanks: () => (/* binding */ tonelliShanks),\n/* harmony export */   validateField: () => (/* binding */ validateField)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/utils.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/utils.js\");\n/**\n * Utils for modular division and fields.\n * Field over 11 is a finite (Galois) field is integer number operations `mod 11`.\n * There is no division: it is replaced by modular multiplicative inverse.\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = /* @__PURE__ */ BigInt(2), _3n = /* @__PURE__ */ BigInt(3);\n// prettier-ignore\nconst _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5), _7n = /* @__PURE__ */ BigInt(7);\n// prettier-ignore\nconst _8n = /* @__PURE__ */ BigInt(8), _9n = /* @__PURE__ */ BigInt(9), _16n = /* @__PURE__ */ BigInt(16);\n// Calculates a modulo b\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */ function pow(num, power, modulo) {\n    return FpPow(Field(modulo), num, power);\n}\n/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */ function pow2(x, power, modulo) {\n    let res = x;\n    while(power-- > _0n){\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n/**\n * Inverses number over modulo.\n * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).\n */ function invert(number, modulo) {\n    if (number === _0n) throw new Error(\"invert: expected non-zero number\");\n    if (modulo <= _0n) throw new Error(\"invert: expected positive modulus, got \" + modulo);\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while(a !== _0n){\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n) throw new Error(\"invert: does not exist\");\n    return mod(x, modulo);\n}\nfunction assertIsSquare(Fp, root, n) {\n    if (!Fp.eql(Fp.sqr(root), n)) throw new Error(\"Cannot find square root\");\n}\n// Not all roots are possible! Example which will throw:\n// const NUM =\n// n = 72057594037927816n;\n// Fp = Field(BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab'));\nfunction sqrt3mod4(Fp, n) {\n    const p1div4 = (Fp.ORDER + _1n) / _4n;\n    const root = Fp.pow(n, p1div4);\n    assertIsSquare(Fp, root, n);\n    return root;\n}\nfunction sqrt5mod8(Fp, n) {\n    const p5div8 = (Fp.ORDER - _5n) / _8n;\n    const n2 = Fp.mul(n, _2n);\n    const v = Fp.pow(n2, p5div8);\n    const nv = Fp.mul(n, v);\n    const i = Fp.mul(Fp.mul(nv, _2n), v);\n    const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n    assertIsSquare(Fp, root, n);\n    return root;\n}\n// Based on RFC9380, Kong algorithm\n// prettier-ignore\nfunction sqrt9mod16(P) {\n    const Fp_ = Field(P);\n    const tn = tonelliShanks(P);\n    const c1 = tn(Fp_, Fp_.neg(Fp_.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n    const c2 = tn(Fp_, c1); //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n    const c3 = tn(Fp_, Fp_.neg(c1)); //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n    const c4 = (P + _7n) / _16n; //  4. c4 = (q + 7) / 16        # Integer arithmetic\n    return (Fp, n)=>{\n        let tv1 = Fp.pow(n, c4); //  1. tv1 = x^c4\n        let tv2 = Fp.mul(tv1, c1); //  2. tv2 = c1 * tv1\n        const tv3 = Fp.mul(tv1, c2); //  3. tv3 = c2 * tv1\n        const tv4 = Fp.mul(tv1, c3); //  4. tv4 = c3 * tv1\n        const e1 = Fp.eql(Fp.sqr(tv2), n); //  5.  e1 = (tv2^2) == x\n        const e2 = Fp.eql(Fp.sqr(tv3), n); //  6.  e2 = (tv3^2) == x\n        tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n        tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n        const e3 = Fp.eql(Fp.sqr(tv2), n); //  9.  e3 = (tv2^2) == x\n        const root = Fp.cmov(tv1, tv2, e3); // 10.  z = CMOV(tv1, tv2, e3)   # Select sqrt from tv1 & tv2\n        assertIsSquare(Fp, root, n);\n        return root;\n    };\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */ function tonelliShanks(P) {\n    // Initialization (precomputation).\n    // Caching initialization could boost perf by 7%.\n    if (P < _3n) throw new Error(\"sqrt is not defined for small field\");\n    // Factor P - 1 = Q * 2^S, where Q is odd\n    let Q = P - _1n;\n    let S = 0;\n    while(Q % _2n === _0n){\n        Q /= _2n;\n        S++;\n    }\n    // Find the first quadratic non-residue Z >= 2\n    let Z = _2n;\n    const _Fp = Field(P);\n    while(FpLegendre(_Fp, Z) === 1){\n        // Basic primality test for P. After x iterations, chance of\n        // not finding quadratic non-residue is 2^x, so 2^1000.\n        if (Z++ > 1000) throw new Error(\"Cannot find square root: probably non-prime P\");\n    }\n    // Fast-path; usually done before Z, but we do \"primality test\".\n    if (S === 1) return sqrt3mod4;\n    // Slow-path\n    // TODO: test on Fp2 and others\n    let cc = _Fp.pow(Z, Q); // c = z^Q\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        if (Fp.is0(n)) return n;\n        // Check if n is a quadratic residue using Legendre symbol\n        if (FpLegendre(Fp, n) !== 1) throw new Error(\"Cannot find square root\");\n        // Initialize variables for the main loop\n        let M = S;\n        let c = Fp.mul(Fp.ONE, cc); // c = z^Q, move cc from field _Fp into field Fp\n        let t = Fp.pow(n, Q); // t = n^Q, first guess at the fudge factor\n        let R = Fp.pow(n, Q1div2); // R = n^((Q+1)/2), first guess at the square root\n        // Main loop\n        // while t != 1\n        while(!Fp.eql(t, Fp.ONE)){\n            if (Fp.is0(t)) return Fp.ZERO; // if t=0 return R=0\n            let i = 1;\n            // Find the smallest i >= 1 such that t^(2^i)  1 (mod P)\n            let t_tmp = Fp.sqr(t); // t^(2^1)\n            while(!Fp.eql(t_tmp, Fp.ONE)){\n                i++;\n                t_tmp = Fp.sqr(t_tmp); // t^(2^2)...\n                if (i === M) throw new Error(\"Cannot find square root\");\n            }\n            // Calculate the exponent for b: 2^(M - i - 1)\n            const exponent = _1n << BigInt(M - i - 1); // bigint is important\n            const b = Fp.pow(c, exponent); // b = 2^(M - i - 1)\n            // Update variables\n            M = i;\n            c = Fp.sqr(b); // c = b^2\n            t = Fp.mul(t, c); // t = (t * b^2)\n            R = Fp.mul(R, b); // R = R*b\n        }\n        return R;\n    };\n}\n/**\n * Square root for a finite field. Will try optimized versions first:\n *\n * 1. P  3 (mod 4)\n * 2. P  5 (mod 8)\n * 3. P  9 (mod 16)\n * 4. Tonelli-Shanks algorithm\n *\n * Different algorithms can give different roots, it is up to user to decide which one they want.\n * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n */ function FpSqrt(P) {\n    // P  3 (mod 4) => n = n^((P+1)/4)\n    if (P % _4n === _3n) return sqrt3mod4;\n    // P  5 (mod 8) => Atkin algorithm, page 10 of https://eprint.iacr.org/2012/685.pdf\n    if (P % _8n === _5n) return sqrt5mod8;\n    // P  9 (mod 16) => Kong algorithm, page 11 of https://eprint.iacr.org/2012/685.pdf (algorithm 4)\n    if (P % _16n === _9n) return sqrt9mod16(P);\n    // Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nconst isNegativeLE = (num, modulo)=>(mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    \"create\",\n    \"isValid\",\n    \"is0\",\n    \"neg\",\n    \"inv\",\n    \"sqrt\",\n    \"sqr\",\n    \"eql\",\n    \"add\",\n    \"sub\",\n    \"mul\",\n    \"pow\",\n    \"div\",\n    \"addN\",\n    \"subN\",\n    \"mulN\",\n    \"sqrN\"\n];\nfunction validateField(field) {\n    const initial = {\n        ORDER: \"bigint\",\n        MASK: \"bigint\",\n        BYTES: \"number\",\n        BITS: \"number\"\n    };\n    const opts = FIELD_FIELDS.reduce((map, val)=>{\n        map[val] = \"function\";\n        return map;\n    }, initial);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._validateObject)(field, opts);\n    // const max = 16384;\n    // if (field.BYTES < 1 || field.BYTES > max) throw new Error('invalid field');\n    // if (field.BITS < 1 || field.BITS > 8 * max) throw new Error('invalid field');\n    return field;\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */ function FpPow(Fp, num, power) {\n    if (power < _0n) throw new Error(\"invalid exponent, negatives unsupported\");\n    if (power === _0n) return Fp.ONE;\n    if (power === _1n) return num;\n    let p = Fp.ONE;\n    let d = num;\n    while(power > _0n){\n        if (power & _1n) p = Fp.mul(p, d);\n        d = Fp.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * Exception-free. Will return `undefined` for 0 elements.\n * @param passZero map 0 to 0 (instead of undefined)\n */ function FpInvertBatch(Fp, nums, passZero = false) {\n    const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : undefined);\n    // Walk from first to last, multiply them by each other MOD p\n    const multipliedAcc = nums.reduce((acc, num, i)=>{\n        if (Fp.is0(num)) return acc;\n        inverted[i] = acc;\n        return Fp.mul(acc, num);\n    }, Fp.ONE);\n    // Invert last element\n    const invertedAcc = Fp.inv(multipliedAcc);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i)=>{\n        if (Fp.is0(num)) return acc;\n        inverted[i] = Fp.mul(acc, inverted[i]);\n        return Fp.mul(acc, num);\n    }, invertedAcc);\n    return inverted;\n}\n// TODO: remove\nfunction FpDiv(Fp, lhs, rhs) {\n    return Fp.mul(lhs, typeof rhs === \"bigint\" ? invert(rhs, Fp.ORDER) : Fp.inv(rhs));\n}\n/**\n * Legendre symbol.\n * Legendre constant is used to calculate Legendre symbol (a | p)\n * which denotes the value of a^((p-1)/2) (mod p).\n *\n * * (a | p)  1    if a is a square (mod p), quadratic residue\n * * (a | p)  -1   if a is not a square (mod p), quadratic non residue\n * * (a | p)  0    if a  0 (mod p)\n */ function FpLegendre(Fp, n) {\n    // We can use 3rd argument as optional cache of this value\n    // but seems unneeded for now. The operation is very fast.\n    const p1mod2 = (Fp.ORDER - _1n) / _2n;\n    const powered = Fp.pow(n, p1mod2);\n    const yes = Fp.eql(powered, Fp.ONE);\n    const zero = Fp.eql(powered, Fp.ZERO);\n    const no = Fp.eql(powered, Fp.neg(Fp.ONE));\n    if (!yes && !zero && !no) throw new Error(\"invalid Legendre symbol result\");\n    return yes ? 1 : zero ? 0 : -1;\n}\n// This function returns True whenever the value x is a square in the field F.\nfunction FpIsSquare(Fp, n) {\n    const l = FpLegendre(Fp, n);\n    return l === 1;\n}\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    if (nBitLength !== undefined) (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.anumber)(nBitLength);\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return {\n        nBitLength: _nBitLength,\n        nByteLength\n    };\n}\n/**\n * Creates a finite field. Major performance optimizations:\n * * 1. Denormalized operations like mulN instead of mul.\n * * 2. Identical object shape: never add or remove keys.\n * * 3. `Object.freeze`.\n * Fragile: always run a benchmark on a change.\n * Security note: operations don't check 'isValid' for all elements for performance reasons,\n * it is caller responsibility to check this.\n * This is low-level code, please make sure you know what you're doing.\n *\n * Note about field properties:\n * * CHARACTERISTIC p = prime number, number of elements in main subgroup.\n * * ORDER q = similar to cofactor in curves, may be composite `q = p^m`.\n *\n * @param ORDER field order, probably prime, or could be composite\n * @param bitLen how many bits the field consumes\n * @param isLE (default: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */ function Field(ORDER, bitLenOrOpts, isLE = false, opts = {}) {\n    if (ORDER <= _0n) throw new Error(\"invalid field: expected ORDER > 0, got \" + ORDER);\n    let _nbitLength = undefined;\n    let _sqrt = undefined;\n    let modFromBytes = false;\n    let allowedLengths = undefined;\n    if (typeof bitLenOrOpts === \"object\" && bitLenOrOpts != null) {\n        if (opts.sqrt || isLE) throw new Error(\"cannot specify opts in two arguments\");\n        const _opts = bitLenOrOpts;\n        if (_opts.BITS) _nbitLength = _opts.BITS;\n        if (_opts.sqrt) _sqrt = _opts.sqrt;\n        if (typeof _opts.isLE === \"boolean\") isLE = _opts.isLE;\n        if (typeof _opts.modFromBytes === \"boolean\") modFromBytes = _opts.modFromBytes;\n        allowedLengths = _opts.allowedLengths;\n    } else {\n        if (typeof bitLenOrOpts === \"number\") _nbitLength = bitLenOrOpts;\n        if (opts.sqrt) _sqrt = opts.sqrt;\n    }\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, _nbitLength);\n    if (BYTES > 2048) throw new Error(\"invalid field: expected ORDER of <= 2048 bytes\");\n    let sqrtP; // cached sqrtP\n    const f = Object.freeze({\n        ORDER,\n        isLE,\n        BITS,\n        BYTES,\n        MASK: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        allowedLengths: allowedLengths,\n        create: (num)=>mod(num, ORDER),\n        isValid: (num)=>{\n            if (typeof num !== \"bigint\") throw new Error(\"invalid field element: expected bigint, got \" + typeof num);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num)=>num === _0n,\n        // is valid and invertible\n        isValidNot0: (num)=>!f.is0(num) && f.isValid(num),\n        isOdd: (num)=>(num & _1n) === _1n,\n        neg: (num)=>mod(-num, ORDER),\n        eql: (lhs, rhs)=>lhs === rhs,\n        sqr: (num)=>mod(num * num, ORDER),\n        add: (lhs, rhs)=>mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs)=>mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs)=>mod(lhs * rhs, ORDER),\n        pow: (num, power)=>FpPow(f, num, power),\n        div: (lhs, rhs)=>mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num)=>num * num,\n        addN: (lhs, rhs)=>lhs + rhs,\n        subN: (lhs, rhs)=>lhs - rhs,\n        mulN: (lhs, rhs)=>lhs * rhs,\n        inv: (num)=>invert(num, ORDER),\n        sqrt: _sqrt || ((n)=>{\n            if (!sqrtP) sqrtP = FpSqrt(ORDER);\n            return sqrtP(f, n);\n        }),\n        toBytes: (num)=>isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(num, BYTES) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(num, BYTES),\n        fromBytes: (bytes, skipValidation = true)=>{\n            if (allowedLengths) {\n                if (!allowedLengths.includes(bytes.length) || bytes.length > BYTES) {\n                    throw new Error(\"Field.fromBytes: expected \" + allowedLengths + \" bytes, got \" + bytes.length);\n                }\n                const padded = new Uint8Array(BYTES);\n                // isLE add 0 to right, !isLE to the left.\n                padded.set(bytes, isLE ? 0 : padded.length - bytes.length);\n                bytes = padded;\n            }\n            if (bytes.length !== BYTES) throw new Error(\"Field.fromBytes: expected \" + BYTES + \" bytes, got \" + bytes.length);\n            let scalar = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(bytes) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(bytes);\n            if (modFromBytes) scalar = mod(scalar, ORDER);\n            if (!skipValidation) {\n                if (!f.isValid(scalar)) throw new Error(\"invalid field element: outside of range 0..ORDER\");\n            }\n            // NOTE: we don't validate scalar here, please use isValid. This done such way because some\n            // protocol may allow non-reduced scalar that reduced later or changed some other way.\n            return scalar;\n        },\n        // TODO: we don't need it here, move out to separate fn\n        invertBatch: (lst)=>FpInvertBatch(f, lst),\n        // We can't move this out because Fp6, Fp12 implement it\n        // and it's unclear what to return in there.\n        cmov: (a, b, c)=>c ? b : a\n    });\n    return Object.freeze(f);\n}\n// Generic random scalar, we can do same for other fields if via Fp2.mul(Fp2.ONE, Fp2.random)?\n// This allows unsafe methods like ignore bias or zero. These unsafe, but often used in different protocols (if deterministic RNG).\n// which mean we cannot force this via opts.\n// Not sure what to do with randomBytes, we can accept it inside opts if wanted.\n// Probably need to export getMinHashLength somewhere?\n// random(bytes?: Uint8Array, unsafeAllowZero = false, unsafeAllowBias = false) {\n//   const LEN = !unsafeAllowBias ? getMinHashLength(ORDER) : BYTES;\n//   if (bytes === undefined) bytes = randomBytes(LEN); // _opts.randomBytes?\n//   const num = isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n//   // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n//   const reduced = unsafeAllowZero ? mod(num, ORDER) : mod(num, ORDER - _1n) + _1n;\n//   return reduced;\n// },\nfunction FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nfunction FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use `mapKeyToField` instead\n */ function hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"privateHash\", hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024) throw new Error(\"hashToPrivateScalar: expected \" + minLen + \"-1024 bytes of input, got \" + hashLen);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(hash) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */ function getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== \"bigint\") throw new Error(\"field order must be bigint\");\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */ function getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */ function mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024) throw new Error(\"expected \" + minLen + \"-1024 bytes of input, got \" + len);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(key) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(reduced, fieldLen) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(reduced, fieldLen);\n} //# sourceMappingURL=modular.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9tb2R1bGFyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7O0NBS0MsR0FDRCxvRUFBb0UsR0FDOEU7QUFDbEosa0JBQWtCO0FBQ2xCLE1BQU1RLE1BQU1DLE9BQU8sSUFBSUMsTUFBTUQsT0FBTyxJQUFJRSxNQUFNLGFBQWEsR0FBR0YsT0FBTyxJQUFJRyxNQUFNLGFBQWEsR0FBR0gsT0FBTztBQUN0RyxrQkFBa0I7QUFDbEIsTUFBTUksTUFBTSxhQUFhLEdBQUdKLE9BQU8sSUFBSUssTUFBTSxhQUFhLEdBQUdMLE9BQU8sSUFBSU0sTUFBTSxhQUFhLEdBQUdOLE9BQU87QUFDckcsa0JBQWtCO0FBQ2xCLE1BQU1PLE1BQU0sYUFBYSxHQUFHUCxPQUFPLElBQUlRLE1BQU0sYUFBYSxHQUFHUixPQUFPLElBQUlTLE9BQU8sYUFBYSxHQUFHVCxPQUFPO0FBQ3RHLHdCQUF3QjtBQUNqQixTQUFTVSxJQUFJQyxDQUFDLEVBQUVDLENBQUM7SUFDcEIsTUFBTUMsU0FBU0YsSUFBSUM7SUFDbkIsT0FBT0MsVUFBVWQsTUFBTWMsU0FBU0QsSUFBSUM7QUFDeEM7QUFDQTs7Ozs7Q0FLQyxHQUNNLFNBQVNDLElBQUlDLEdBQUcsRUFBRUMsS0FBSyxFQUFFQyxNQUFNO0lBQ2xDLE9BQU9DLE1BQU1DLE1BQU1GLFNBQVNGLEtBQUtDO0FBQ3JDO0FBQ0EsMERBQTBELEdBQ25ELFNBQVNJLEtBQUtDLENBQUMsRUFBRUwsS0FBSyxFQUFFQyxNQUFNO0lBQ2pDLElBQUlLLE1BQU1EO0lBQ1YsTUFBT0wsVUFBVWpCLElBQUs7UUFDbEJ1QixPQUFPQTtRQUNQQSxPQUFPTDtJQUNYO0lBQ0EsT0FBT0s7QUFDWDtBQUNBOzs7Q0FHQyxHQUNNLFNBQVNDLE9BQU9DLE1BQU0sRUFBRVAsTUFBTTtJQUNqQyxJQUFJTyxXQUFXekIsS0FDWCxNQUFNLElBQUkwQixNQUFNO0lBQ3BCLElBQUlSLFVBQVVsQixLQUNWLE1BQU0sSUFBSTBCLE1BQU0sNENBQTRDUjtJQUNoRSxrRkFBa0Y7SUFDbEYsSUFBSU4sSUFBSUQsSUFBSWMsUUFBUVA7SUFDcEIsSUFBSUwsSUFBSUs7SUFDUixrQkFBa0I7SUFDbEIsSUFBSUksSUFBSXRCLEtBQUsyQixJQUFJekIsS0FBSzBCLElBQUkxQixLQUFLMkIsSUFBSTdCO0lBQ25DLE1BQU9ZLE1BQU1aLElBQUs7UUFDZCxnRUFBZ0U7UUFDaEUsTUFBTThCLElBQUlqQixJQUFJRDtRQUNkLE1BQU1tQixJQUFJbEIsSUFBSUQ7UUFDZCxNQUFNb0IsSUFBSVYsSUFBSU0sSUFBSUU7UUFDbEIsTUFBTUcsSUFBSU4sSUFBSUUsSUFBSUM7UUFDbEIsa0JBQWtCO1FBQ2xCakIsSUFBSUQsR0FBR0EsSUFBSW1CLEdBQUdULElBQUlNLEdBQUdELElBQUlFLEdBQUdELElBQUlJLEdBQUdILElBQUlJO0lBQzNDO0lBQ0EsTUFBTUMsTUFBTXJCO0lBQ1osSUFBSXFCLFFBQVFoQyxLQUNSLE1BQU0sSUFBSXdCLE1BQU07SUFDcEIsT0FBT2YsSUFBSVcsR0FBR0o7QUFDbEI7QUFDQSxTQUFTaUIsZUFBZUMsRUFBRSxFQUFFQyxJQUFJLEVBQUVKLENBQUM7SUFDL0IsSUFBSSxDQUFDRyxHQUFHRSxHQUFHLENBQUNGLEdBQUdHLEdBQUcsQ0FBQ0YsT0FBT0osSUFDdEIsTUFBTSxJQUFJUCxNQUFNO0FBQ3hCO0FBQ0Esd0RBQXdEO0FBQ3hELGNBQWM7QUFDZCwwQkFBMEI7QUFDMUIsNEhBQTRIO0FBQzVILFNBQVNjLFVBQVVKLEVBQUUsRUFBRUgsQ0FBQztJQUNwQixNQUFNUSxTQUFTLENBQUNMLEdBQUdNLEtBQUssR0FBR3hDLEdBQUUsSUFBS0c7SUFDbEMsTUFBTWdDLE9BQU9ELEdBQUdyQixHQUFHLENBQUNrQixHQUFHUTtJQUN2Qk4sZUFBZUMsSUFBSUMsTUFBTUo7SUFDekIsT0FBT0k7QUFDWDtBQUNBLFNBQVNNLFVBQVVQLEVBQUUsRUFBRUgsQ0FBQztJQUNwQixNQUFNVyxTQUFTLENBQUNSLEdBQUdNLEtBQUssR0FBR3BDLEdBQUUsSUFBS0U7SUFDbEMsTUFBTXFDLEtBQUtULEdBQUdVLEdBQUcsQ0FBQ2IsR0FBRzlCO0lBQ3JCLE1BQU0wQixJQUFJTyxHQUFHckIsR0FBRyxDQUFDOEIsSUFBSUQ7SUFDckIsTUFBTUcsS0FBS1gsR0FBR1UsR0FBRyxDQUFDYixHQUFHSjtJQUNyQixNQUFNbUIsSUFBSVosR0FBR1UsR0FBRyxDQUFDVixHQUFHVSxHQUFHLENBQUNDLElBQUk1QyxNQUFNMEI7SUFDbEMsTUFBTVEsT0FBT0QsR0FBR1UsR0FBRyxDQUFDQyxJQUFJWCxHQUFHYSxHQUFHLENBQUNELEdBQUdaLEdBQUdjLEdBQUc7SUFDeENmLGVBQWVDLElBQUlDLE1BQU1KO0lBQ3pCLE9BQU9JO0FBQ1g7QUFDQSxtQ0FBbUM7QUFDbkMsa0JBQWtCO0FBQ2xCLFNBQVNjLFdBQVdDLENBQUM7SUFDakIsTUFBTUMsTUFBTWpDLE1BQU1nQztJQUNsQixNQUFNRSxLQUFLQyxjQUFjSDtJQUN6QixNQUFNSSxLQUFLRixHQUFHRCxLQUFLQSxJQUFJSSxHQUFHLENBQUNKLElBQUlILEdBQUcsSUFBSSxrREFBa0Q7SUFDeEYsTUFBTVEsS0FBS0osR0FBR0QsS0FBS0csS0FBSyxrREFBa0Q7SUFDMUUsTUFBTUcsS0FBS0wsR0FBR0QsS0FBS0EsSUFBSUksR0FBRyxDQUFDRCxNQUFNLG9EQUFvRDtJQUNyRixNQUFNSSxLQUFLLENBQUNSLElBQUk3QyxHQUFFLElBQUtHLE1BQU0sb0RBQW9EO0lBQ2pGLE9BQU8sQ0FBQzBCLElBQUlIO1FBQ1IsSUFBSTRCLE1BQU16QixHQUFHckIsR0FBRyxDQUFDa0IsR0FBRzJCLEtBQUssaUJBQWlCO1FBQzFDLElBQUlFLE1BQU0xQixHQUFHVSxHQUFHLENBQUNlLEtBQUtMLEtBQUsscUJBQXFCO1FBQ2hELE1BQU1PLE1BQU0zQixHQUFHVSxHQUFHLENBQUNlLEtBQUtILEtBQUsscUJBQXFCO1FBQ2xELE1BQU1NLE1BQU01QixHQUFHVSxHQUFHLENBQUNlLEtBQUtGLEtBQUsscUJBQXFCO1FBQ2xELE1BQU1NLEtBQUs3QixHQUFHRSxHQUFHLENBQUNGLEdBQUdHLEdBQUcsQ0FBQ3VCLE1BQU03QixJQUFJLHlCQUF5QjtRQUM1RCxNQUFNaUMsS0FBSzlCLEdBQUdFLEdBQUcsQ0FBQ0YsR0FBR0csR0FBRyxDQUFDd0IsTUFBTTlCLElBQUkseUJBQXlCO1FBQzVENEIsTUFBTXpCLEdBQUcrQixJQUFJLENBQUNOLEtBQUtDLEtBQUtHLEtBQUssNkRBQTZEO1FBQzFGSCxNQUFNMUIsR0FBRytCLElBQUksQ0FBQ0gsS0FBS0QsS0FBS0csS0FBSyw2REFBNkQ7UUFDMUYsTUFBTUUsS0FBS2hDLEdBQUdFLEdBQUcsQ0FBQ0YsR0FBR0csR0FBRyxDQUFDdUIsTUFBTTdCLElBQUkseUJBQXlCO1FBQzVELE1BQU1JLE9BQU9ELEdBQUcrQixJQUFJLENBQUNOLEtBQUtDLEtBQUtNLEtBQUssNkRBQTZEO1FBQ2pHakMsZUFBZUMsSUFBSUMsTUFBTUo7UUFDekIsT0FBT0k7SUFDWDtBQUNKO0FBQ0E7Ozs7OztDQU1DLEdBQ00sU0FBU2tCLGNBQWNILENBQUM7SUFDM0IsbUNBQW1DO0lBQ25DLGlEQUFpRDtJQUNqRCxJQUFJQSxJQUFJaEQsS0FDSixNQUFNLElBQUlzQixNQUFNO0lBQ3BCLHlDQUF5QztJQUN6QyxJQUFJMkMsSUFBSWpCLElBQUlsRDtJQUNaLElBQUlvRSxJQUFJO0lBQ1IsTUFBT0QsSUFBSWxFLFFBQVFILElBQUs7UUFDcEJxRSxLQUFLbEU7UUFDTG1FO0lBQ0o7SUFDQSw4Q0FBOEM7SUFDOUMsSUFBSUMsSUFBSXBFO0lBQ1IsTUFBTXFFLE1BQU1wRCxNQUFNZ0M7SUFDbEIsTUFBT3FCLFdBQVdELEtBQUtELE9BQU8sRUFBRztRQUM3Qiw0REFBNEQ7UUFDNUQsdURBQXVEO1FBQ3ZELElBQUlBLE1BQU0sTUFDTixNQUFNLElBQUk3QyxNQUFNO0lBQ3hCO0lBQ0EsZ0VBQWdFO0lBQ2hFLElBQUk0QyxNQUFNLEdBQ04sT0FBTzlCO0lBQ1gsWUFBWTtJQUNaLCtCQUErQjtJQUMvQixJQUFJa0MsS0FBS0YsSUFBSXpELEdBQUcsQ0FBQ3dELEdBQUdGLElBQUksVUFBVTtJQUNsQyxNQUFNTSxTQUFTLENBQUNOLElBQUluRSxHQUFFLElBQUtDO0lBQzNCLE9BQU8sU0FBU3lFLFlBQVl4QyxFQUFFLEVBQUVILENBQUM7UUFDN0IsSUFBSUcsR0FBR3lDLEdBQUcsQ0FBQzVDLElBQ1AsT0FBT0E7UUFDWCwwREFBMEQ7UUFDMUQsSUFBSXdDLFdBQVdyQyxJQUFJSCxPQUFPLEdBQ3RCLE1BQU0sSUFBSVAsTUFBTTtRQUNwQix5Q0FBeUM7UUFDekMsSUFBSW9ELElBQUlSO1FBQ1IsSUFBSVMsSUFBSTNDLEdBQUdVLEdBQUcsQ0FBQ1YsR0FBR2MsR0FBRyxFQUFFd0IsS0FBSyxnREFBZ0Q7UUFDNUUsSUFBSU0sSUFBSTVDLEdBQUdyQixHQUFHLENBQUNrQixHQUFHb0MsSUFBSSwyQ0FBMkM7UUFDakUsSUFBSVksSUFBSTdDLEdBQUdyQixHQUFHLENBQUNrQixHQUFHMEMsU0FBUyxrREFBa0Q7UUFDN0UsWUFBWTtRQUNaLGVBQWU7UUFDZixNQUFPLENBQUN2QyxHQUFHRSxHQUFHLENBQUMwQyxHQUFHNUMsR0FBR2MsR0FBRyxFQUFHO1lBQ3ZCLElBQUlkLEdBQUd5QyxHQUFHLENBQUNHLElBQ1AsT0FBTzVDLEdBQUc4QyxJQUFJLEVBQUUsb0JBQW9CO1lBQ3hDLElBQUlsQyxJQUFJO1lBQ1IseURBQXlEO1lBQ3pELElBQUltQyxRQUFRL0MsR0FBR0csR0FBRyxDQUFDeUMsSUFBSSxVQUFVO1lBQ2pDLE1BQU8sQ0FBQzVDLEdBQUdFLEdBQUcsQ0FBQzZDLE9BQU8vQyxHQUFHYyxHQUFHLEVBQUc7Z0JBQzNCRjtnQkFDQW1DLFFBQVEvQyxHQUFHRyxHQUFHLENBQUM0QyxRQUFRLGFBQWE7Z0JBQ3BDLElBQUluQyxNQUFNOEIsR0FDTixNQUFNLElBQUlwRCxNQUFNO1lBQ3hCO1lBQ0EsOENBQThDO1lBQzlDLE1BQU0wRCxXQUFXbEYsT0FBT0QsT0FBTzZFLElBQUk5QixJQUFJLElBQUksc0JBQXNCO1lBQ2pFLE1BQU1uQyxJQUFJdUIsR0FBR3JCLEdBQUcsQ0FBQ2dFLEdBQUdLLFdBQVcsb0JBQW9CO1lBQ25ELG1CQUFtQjtZQUNuQk4sSUFBSTlCO1lBQ0orQixJQUFJM0MsR0FBR0csR0FBRyxDQUFDMUIsSUFBSSxVQUFVO1lBQ3pCbUUsSUFBSTVDLEdBQUdVLEdBQUcsQ0FBQ2tDLEdBQUdELElBQUksZ0JBQWdCO1lBQ2xDRSxJQUFJN0MsR0FBR1UsR0FBRyxDQUFDbUMsR0FBR3BFLElBQUksVUFBVTtRQUNoQztRQUNBLE9BQU9vRTtJQUNYO0FBQ0o7QUFDQTs7Ozs7Ozs7OztDQVVDLEdBQ00sU0FBU0ksT0FBT2pDLENBQUM7SUFDcEIsb0NBQW9DO0lBQ3BDLElBQUlBLElBQUkvQyxRQUFRRCxLQUNaLE9BQU9vQztJQUNYLG9GQUFvRjtJQUNwRixJQUFJWSxJQUFJNUMsUUFBUUYsS0FDWixPQUFPcUM7SUFDWCxrR0FBa0c7SUFDbEcsSUFBSVMsSUFBSTFDLFNBQVNELEtBQ2IsT0FBTzBDLFdBQVdDO0lBQ3RCLDJCQUEyQjtJQUMzQixPQUFPRyxjQUFjSDtBQUN6QjtBQUNBLHNEQUFzRDtBQUMvQyxNQUFNa0MsZUFBZSxDQUFDdEUsS0FBS0UsU0FBVyxDQUFDUCxJQUFJSyxLQUFLRSxVQUFVaEIsR0FBRSxNQUFPQSxJQUFJO0FBQzlFLGtCQUFrQjtBQUNsQixNQUFNcUYsZUFBZTtJQUNqQjtJQUFVO0lBQVc7SUFBTztJQUFPO0lBQU87SUFBUTtJQUNsRDtJQUFPO0lBQU87SUFBTztJQUFPO0lBQU87SUFDbkM7SUFBUTtJQUFRO0lBQVE7Q0FDM0I7QUFDTSxTQUFTQyxjQUFjQyxLQUFLO0lBQy9CLE1BQU1DLFVBQVU7UUFDWmhELE9BQU87UUFDUGlELE1BQU07UUFDTkMsT0FBTztRQUNQQyxNQUFNO0lBQ1Y7SUFDQSxNQUFNQyxPQUFPUCxhQUFhUSxNQUFNLENBQUMsQ0FBQ0MsS0FBS0M7UUFDbkNELEdBQUcsQ0FBQ0MsSUFBSSxHQUFHO1FBQ1gsT0FBT0Q7SUFDWCxHQUFHTjtJQUNIbEcsMERBQWVBLENBQUNpRyxPQUFPSztJQUN2QixxQkFBcUI7SUFDckIsOEVBQThFO0lBQzlFLGdGQUFnRjtJQUNoRixPQUFPTDtBQUNYO0FBQ0EsMEJBQTBCO0FBQzFCOzs7Q0FHQyxHQUNNLFNBQVN0RSxNQUFNaUIsRUFBRSxFQUFFcEIsR0FBRyxFQUFFQyxLQUFLO0lBQ2hDLElBQUlBLFFBQVFqQixLQUNSLE1BQU0sSUFBSTBCLE1BQU07SUFDcEIsSUFBSVQsVUFBVWpCLEtBQ1YsT0FBT29DLEdBQUdjLEdBQUc7SUFDakIsSUFBSWpDLFVBQVVmLEtBQ1YsT0FBT2M7SUFDWCxJQUFJa0YsSUFBSTlELEdBQUdjLEdBQUc7SUFDZCxJQUFJaUQsSUFBSW5GO0lBQ1IsTUFBT0MsUUFBUWpCLElBQUs7UUFDaEIsSUFBSWlCLFFBQVFmLEtBQ1JnRyxJQUFJOUQsR0FBR1UsR0FBRyxDQUFDb0QsR0FBR0M7UUFDbEJBLElBQUkvRCxHQUFHRyxHQUFHLENBQUM0RDtRQUNYbEYsVUFBVWY7SUFDZDtJQUNBLE9BQU9nRztBQUNYO0FBQ0E7Ozs7Q0FJQyxHQUNNLFNBQVNFLGNBQWNoRSxFQUFFLEVBQUVpRSxJQUFJLEVBQUVDLFdBQVcsS0FBSztJQUNwRCxNQUFNQyxXQUFXLElBQUlDLE1BQU1ILEtBQUtJLE1BQU0sRUFBRUMsSUFBSSxDQUFDSixXQUFXbEUsR0FBRzhDLElBQUksR0FBR3lCO0lBQ2xFLDZEQUE2RDtJQUM3RCxNQUFNQyxnQkFBZ0JQLEtBQUtOLE1BQU0sQ0FBQyxDQUFDYyxLQUFLN0YsS0FBS2dDO1FBQ3pDLElBQUlaLEdBQUd5QyxHQUFHLENBQUM3RCxNQUNQLE9BQU82RjtRQUNYTixRQUFRLENBQUN2RCxFQUFFLEdBQUc2RDtRQUNkLE9BQU96RSxHQUFHVSxHQUFHLENBQUMrRCxLQUFLN0Y7SUFDdkIsR0FBR29CLEdBQUdjLEdBQUc7SUFDVCxzQkFBc0I7SUFDdEIsTUFBTTRELGNBQWMxRSxHQUFHMkUsR0FBRyxDQUFDSDtJQUMzQixzRUFBc0U7SUFDdEVQLEtBQUtXLFdBQVcsQ0FBQyxDQUFDSCxLQUFLN0YsS0FBS2dDO1FBQ3hCLElBQUlaLEdBQUd5QyxHQUFHLENBQUM3RCxNQUNQLE9BQU82RjtRQUNYTixRQUFRLENBQUN2RCxFQUFFLEdBQUdaLEdBQUdVLEdBQUcsQ0FBQytELEtBQUtOLFFBQVEsQ0FBQ3ZELEVBQUU7UUFDckMsT0FBT1osR0FBR1UsR0FBRyxDQUFDK0QsS0FBSzdGO0lBQ3ZCLEdBQUc4RjtJQUNILE9BQU9QO0FBQ1g7QUFDQSxlQUFlO0FBQ1IsU0FBU1UsTUFBTTdFLEVBQUUsRUFBRThFLEdBQUcsRUFBRUMsR0FBRztJQUM5QixPQUFPL0UsR0FBR1UsR0FBRyxDQUFDb0UsS0FBSyxPQUFPQyxRQUFRLFdBQVczRixPQUFPMkYsS0FBSy9FLEdBQUdNLEtBQUssSUFBSU4sR0FBRzJFLEdBQUcsQ0FBQ0k7QUFDaEY7QUFDQTs7Ozs7Ozs7Q0FRQyxHQUNNLFNBQVMxQyxXQUFXckMsRUFBRSxFQUFFSCxDQUFDO0lBQzVCLDBEQUEwRDtJQUMxRCwwREFBMEQ7SUFDMUQsTUFBTW1GLFNBQVMsQ0FBQ2hGLEdBQUdNLEtBQUssR0FBR3hDLEdBQUUsSUFBS0M7SUFDbEMsTUFBTWtILFVBQVVqRixHQUFHckIsR0FBRyxDQUFDa0IsR0FBR21GO0lBQzFCLE1BQU1FLE1BQU1sRixHQUFHRSxHQUFHLENBQUMrRSxTQUFTakYsR0FBR2MsR0FBRztJQUNsQyxNQUFNcUUsT0FBT25GLEdBQUdFLEdBQUcsQ0FBQytFLFNBQVNqRixHQUFHOEMsSUFBSTtJQUNwQyxNQUFNc0MsS0FBS3BGLEdBQUdFLEdBQUcsQ0FBQytFLFNBQVNqRixHQUFHcUIsR0FBRyxDQUFDckIsR0FBR2MsR0FBRztJQUN4QyxJQUFJLENBQUNvRSxPQUFPLENBQUNDLFFBQVEsQ0FBQ0MsSUFDbEIsTUFBTSxJQUFJOUYsTUFBTTtJQUNwQixPQUFPNEYsTUFBTSxJQUFJQyxPQUFPLElBQUksQ0FBQztBQUNqQztBQUNBLDhFQUE4RTtBQUN2RSxTQUFTRSxXQUFXckYsRUFBRSxFQUFFSCxDQUFDO0lBQzVCLE1BQU15RixJQUFJakQsV0FBV3JDLElBQUlIO0lBQ3pCLE9BQU95RixNQUFNO0FBQ2pCO0FBQ0Esa0JBQWtCO0FBQ1gsU0FBU0MsUUFBUTFGLENBQUMsRUFBRTJGLFVBQVU7SUFDakMsaUNBQWlDO0lBQ2pDLElBQUlBLGVBQWVqQixXQUNmbEgsa0RBQU9BLENBQUNtSTtJQUNaLE1BQU1DLGNBQWNELGVBQWVqQixZQUFZaUIsYUFBYTNGLEVBQUU2RixRQUFRLENBQUMsR0FBR3JCLE1BQU07SUFDaEYsTUFBTXNCLGNBQWNDLEtBQUtDLElBQUksQ0FBQ0osY0FBYztJQUM1QyxPQUFPO1FBQUVELFlBQVlDO1FBQWFFO0lBQVk7QUFDbEQ7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBa0JDLEdBQ00sU0FBUzNHLE1BQU1zQixLQUFLLEVBQUV3RixZQUFZLEVBQ3pDQyxPQUFPLEtBQUssRUFBRXJDLE9BQU8sQ0FBQyxDQUFDO0lBQ25CLElBQUlwRCxTQUFTMUMsS0FDVCxNQUFNLElBQUkwQixNQUFNLDRDQUE0Q2dCO0lBQ2hFLElBQUkwRixjQUFjekI7SUFDbEIsSUFBSTBCLFFBQVExQjtJQUNaLElBQUkyQixlQUFlO0lBQ25CLElBQUlDLGlCQUFpQjVCO0lBQ3JCLElBQUksT0FBT3VCLGlCQUFpQixZQUFZQSxnQkFBZ0IsTUFBTTtRQUMxRCxJQUFJcEMsS0FBSzBDLElBQUksSUFBSUwsTUFDYixNQUFNLElBQUl6RyxNQUFNO1FBQ3BCLE1BQU0rRyxRQUFRUDtRQUNkLElBQUlPLE1BQU01QyxJQUFJLEVBQ1Z1QyxjQUFjSyxNQUFNNUMsSUFBSTtRQUM1QixJQUFJNEMsTUFBTUQsSUFBSSxFQUNWSCxRQUFRSSxNQUFNRCxJQUFJO1FBQ3RCLElBQUksT0FBT0MsTUFBTU4sSUFBSSxLQUFLLFdBQ3RCQSxPQUFPTSxNQUFNTixJQUFJO1FBQ3JCLElBQUksT0FBT00sTUFBTUgsWUFBWSxLQUFLLFdBQzlCQSxlQUFlRyxNQUFNSCxZQUFZO1FBQ3JDQyxpQkFBaUJFLE1BQU1GLGNBQWM7SUFDekMsT0FDSztRQUNELElBQUksT0FBT0wsaUJBQWlCLFVBQ3hCRSxjQUFjRjtRQUNsQixJQUFJcEMsS0FBSzBDLElBQUksRUFDVEgsUUFBUXZDLEtBQUswQyxJQUFJO0lBQ3pCO0lBQ0EsTUFBTSxFQUFFWixZQUFZL0IsSUFBSSxFQUFFa0MsYUFBYW5DLEtBQUssRUFBRSxHQUFHK0IsUUFBUWpGLE9BQU8wRjtJQUNoRSxJQUFJeEMsUUFBUSxNQUNSLE1BQU0sSUFBSWxFLE1BQU07SUFDcEIsSUFBSWdILE9BQU8sZUFBZTtJQUMxQixNQUFNQyxJQUFJQyxPQUFPQyxNQUFNLENBQUM7UUFDcEJuRztRQUNBeUY7UUFDQXRDO1FBQ0FEO1FBQ0FELE1BQU1qRyxrREFBT0EsQ0FBQ21HO1FBQ2RYLE1BQU1sRjtRQUNOa0QsS0FBS2hEO1FBQ0xxSSxnQkFBZ0JBO1FBQ2hCTyxRQUFRLENBQUM5SCxNQUFRTCxJQUFJSyxLQUFLMEI7UUFDMUJxRyxTQUFTLENBQUMvSDtZQUNOLElBQUksT0FBT0EsUUFBUSxVQUNmLE1BQU0sSUFBSVUsTUFBTSxpREFBaUQsT0FBT1Y7WUFDNUUsT0FBT2hCLE9BQU9nQixPQUFPQSxNQUFNMEIsT0FBTyw4Q0FBOEM7UUFDcEY7UUFDQW1DLEtBQUssQ0FBQzdELE1BQVFBLFFBQVFoQjtRQUN0QiwwQkFBMEI7UUFDMUJnSixhQUFhLENBQUNoSSxNQUFRLENBQUMySCxFQUFFOUQsR0FBRyxDQUFDN0QsUUFBUTJILEVBQUVJLE9BQU8sQ0FBQy9IO1FBQy9DaUksT0FBTyxDQUFDakksTUFBUSxDQUFDQSxNQUFNZCxHQUFFLE1BQU9BO1FBQ2hDdUQsS0FBSyxDQUFDekMsTUFBUUwsSUFBSSxDQUFDSyxLQUFLMEI7UUFDeEJKLEtBQUssQ0FBQzRFLEtBQUtDLE1BQVFELFFBQVFDO1FBQzNCNUUsS0FBSyxDQUFDdkIsTUFBUUwsSUFBSUssTUFBTUEsS0FBSzBCO1FBQzdCd0csS0FBSyxDQUFDaEMsS0FBS0MsTUFBUXhHLElBQUl1RyxNQUFNQyxLQUFLekU7UUFDbENPLEtBQUssQ0FBQ2lFLEtBQUtDLE1BQVF4RyxJQUFJdUcsTUFBTUMsS0FBS3pFO1FBQ2xDSSxLQUFLLENBQUNvRSxLQUFLQyxNQUFReEcsSUFBSXVHLE1BQU1DLEtBQUt6RTtRQUNsQzNCLEtBQUssQ0FBQ0MsS0FBS0MsUUFBVUUsTUFBTXdILEdBQUczSCxLQUFLQztRQUNuQ2tJLEtBQUssQ0FBQ2pDLEtBQUtDLE1BQVF4RyxJQUFJdUcsTUFBTTFGLE9BQU8yRixLQUFLekUsUUFBUUE7UUFDakQsdUNBQXVDO1FBQ3ZDMEcsTUFBTSxDQUFDcEksTUFBUUEsTUFBTUE7UUFDckJxSSxNQUFNLENBQUNuQyxLQUFLQyxNQUFRRCxNQUFNQztRQUMxQm1DLE1BQU0sQ0FBQ3BDLEtBQUtDLE1BQVFELE1BQU1DO1FBQzFCb0MsTUFBTSxDQUFDckMsS0FBS0MsTUFBUUQsTUFBTUM7UUFDMUJKLEtBQUssQ0FBQy9GLE1BQVFRLE9BQU9SLEtBQUswQjtRQUMxQjhGLE1BQU1ILFNBQ0QsRUFBQ3BHO1lBQ0UsSUFBSSxDQUFDeUcsT0FDREEsUUFBUXJELE9BQU8zQztZQUNuQixPQUFPZ0csTUFBTUMsR0FBRzFHO1FBQ3BCO1FBQ0p1SCxTQUFTLENBQUN4SSxNQUFTbUgsT0FBT3BJLDBEQUFlQSxDQUFDaUIsS0FBSzRFLFNBQVM5RiwwREFBZUEsQ0FBQ2tCLEtBQUs0RTtRQUM3RTZELFdBQVcsQ0FBQ0MsT0FBT0MsaUJBQWlCLElBQUk7WUFDcEMsSUFBSXBCLGdCQUFnQjtnQkFDaEIsSUFBSSxDQUFDQSxlQUFlcUIsUUFBUSxDQUFDRixNQUFNakQsTUFBTSxLQUFLaUQsTUFBTWpELE1BQU0sR0FBR2IsT0FBTztvQkFDaEUsTUFBTSxJQUFJbEUsTUFBTSwrQkFBK0I2RyxpQkFBaUIsaUJBQWlCbUIsTUFBTWpELE1BQU07Z0JBQ2pHO2dCQUNBLE1BQU1vRCxTQUFTLElBQUlDLFdBQVdsRTtnQkFDOUIsMENBQTBDO2dCQUMxQ2lFLE9BQU9FLEdBQUcsQ0FBQ0wsT0FBT3ZCLE9BQU8sSUFBSTBCLE9BQU9wRCxNQUFNLEdBQUdpRCxNQUFNakQsTUFBTTtnQkFDekRpRCxRQUFRRztZQUNaO1lBQ0EsSUFBSUgsTUFBTWpELE1BQU0sS0FBS2IsT0FDakIsTUFBTSxJQUFJbEUsTUFBTSwrQkFBK0JrRSxRQUFRLGlCQUFpQjhELE1BQU1qRCxNQUFNO1lBQ3hGLElBQUl1RCxTQUFTN0IsT0FBT3ZJLDBEQUFlQSxDQUFDOEosU0FBUy9KLDBEQUFlQSxDQUFDK0o7WUFDN0QsSUFBSXBCLGNBQ0EwQixTQUFTckosSUFBSXFKLFFBQVF0SDtZQUN6QixJQUFJLENBQUNpSCxnQkFDRDtnQkFBQSxJQUFJLENBQUNoQixFQUFFSSxPQUFPLENBQUNpQixTQUNYLE1BQU0sSUFBSXRJLE1BQU07WUFBbUQ7WUFDM0UsMkZBQTJGO1lBQzNGLHNGQUFzRjtZQUN0RixPQUFPc0k7UUFDWDtRQUNBLHVEQUF1RDtRQUN2REMsYUFBYSxDQUFDQyxNQUFROUQsY0FBY3VDLEdBQUd1QjtRQUN2Qyx3REFBd0Q7UUFDeEQsNENBQTRDO1FBQzVDL0YsTUFBTSxDQUFDdkQsR0FBR0MsR0FBR2tFLElBQU9BLElBQUlsRSxJQUFJRDtJQUNoQztJQUNBLE9BQU9nSSxPQUFPQyxNQUFNLENBQUNGO0FBQ3pCO0FBQ0EsOEZBQThGO0FBQzlGLG1JQUFtSTtBQUNuSSw0Q0FBNEM7QUFDNUMsZ0ZBQWdGO0FBQ2hGLHNEQUFzRDtBQUN0RCxpRkFBaUY7QUFDakYsb0VBQW9FO0FBQ3BFLDZFQUE2RTtBQUM3RSx3RUFBd0U7QUFDeEUsb0ZBQW9GO0FBQ3BGLHFGQUFxRjtBQUNyRixvQkFBb0I7QUFDcEIsS0FBSztBQUNFLFNBQVN3QixVQUFVL0gsRUFBRSxFQUFFZ0ksR0FBRztJQUM3QixJQUFJLENBQUNoSSxHQUFHNkcsS0FBSyxFQUNULE1BQU0sSUFBSXZILE1BQU07SUFDcEIsTUFBTVcsT0FBT0QsR0FBR29HLElBQUksQ0FBQzRCO0lBQ3JCLE9BQU9oSSxHQUFHNkcsS0FBSyxDQUFDNUcsUUFBUUEsT0FBT0QsR0FBR3FCLEdBQUcsQ0FBQ3BCO0FBQzFDO0FBQ08sU0FBU2dJLFdBQVdqSSxFQUFFLEVBQUVnSSxHQUFHO0lBQzlCLElBQUksQ0FBQ2hJLEdBQUc2RyxLQUFLLEVBQ1QsTUFBTSxJQUFJdkgsTUFBTTtJQUNwQixNQUFNVyxPQUFPRCxHQUFHb0csSUFBSSxDQUFDNEI7SUFDckIsT0FBT2hJLEdBQUc2RyxLQUFLLENBQUM1RyxRQUFRRCxHQUFHcUIsR0FBRyxDQUFDcEIsUUFBUUE7QUFDM0M7QUFDQTs7Ozs7Q0FLQyxHQUNNLFNBQVNpSSxvQkFBb0JDLElBQUksRUFBRUMsVUFBVSxFQUFFckMsT0FBTyxLQUFLO0lBQzlEb0MsT0FBTzFLLHNEQUFXQSxDQUFDLGVBQWUwSztJQUNsQyxNQUFNRSxVQUFVRixLQUFLOUQsTUFBTTtJQUMzQixNQUFNaUUsU0FBUy9DLFFBQVE2QyxZQUFZekMsV0FBVyxHQUFHO0lBQ2pELElBQUkyQyxTQUFTLE1BQU1ELFVBQVVDLFVBQVVELFVBQVUsTUFDN0MsTUFBTSxJQUFJL0ksTUFBTSxtQ0FBbUNnSixTQUFTLCtCQUErQkQ7SUFDL0YsTUFBTXpKLE1BQU1tSCxPQUFPdkksMERBQWVBLENBQUMySyxRQUFRNUssMERBQWVBLENBQUM0SztJQUMzRCxPQUFPNUosSUFBSUssS0FBS3dKLGFBQWF0SyxPQUFPQTtBQUN4QztBQUNBOzs7OztDQUtDLEdBQ00sU0FBU3lLLG9CQUFvQkMsVUFBVTtJQUMxQyxJQUFJLE9BQU9BLGVBQWUsVUFDdEIsTUFBTSxJQUFJbEosTUFBTTtJQUNwQixNQUFNbUosWUFBWUQsV0FBVzlDLFFBQVEsQ0FBQyxHQUFHckIsTUFBTTtJQUMvQyxPQUFPdUIsS0FBS0MsSUFBSSxDQUFDNEMsWUFBWTtBQUNqQztBQUNBOzs7Ozs7Q0FNQyxHQUNNLFNBQVNDLGlCQUFpQkYsVUFBVTtJQUN2QyxNQUFNbkUsU0FBU2tFLG9CQUFvQkM7SUFDbkMsT0FBT25FLFNBQVN1QixLQUFLQyxJQUFJLENBQUN4QixTQUFTO0FBQ3ZDO0FBQ0E7Ozs7Ozs7Ozs7OztDQVlDLEdBQ00sU0FBU3NFLGVBQWVDLEdBQUcsRUFBRUosVUFBVSxFQUFFekMsT0FBTyxLQUFLO0lBQ3hELE1BQU04QyxNQUFNRCxJQUFJdkUsTUFBTTtJQUN0QixNQUFNeUUsV0FBV1Asb0JBQW9CQztJQUNyQyxNQUFNRixTQUFTSSxpQkFBaUJGO0lBQ2hDLGlHQUFpRztJQUNqRyxJQUFJSyxNQUFNLE1BQU1BLE1BQU1QLFVBQVVPLE1BQU0sTUFDbEMsTUFBTSxJQUFJdkosTUFBTSxjQUFjZ0osU0FBUywrQkFBK0JPO0lBQzFFLE1BQU1qSyxNQUFNbUgsT0FBT3ZJLDBEQUFlQSxDQUFDb0wsT0FBT3JMLDBEQUFlQSxDQUFDcUw7SUFDMUQsK0VBQStFO0lBQy9FLE1BQU1HLFVBQVV4SyxJQUFJSyxLQUFLNEosYUFBYTFLLE9BQU9BO0lBQzdDLE9BQU9pSSxPQUFPcEksMERBQWVBLENBQUNvTCxTQUFTRCxZQUFZcEwsMERBQWVBLENBQUNxTCxTQUFTRDtBQUNoRixFQUNBLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsYXctd29ya3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9tb2R1bGFyLmpzP2ZkNDMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBVdGlscyBmb3IgbW9kdWxhciBkaXZpc2lvbiBhbmQgZmllbGRzLlxuICogRmllbGQgb3ZlciAxMSBpcyBhIGZpbml0ZSAoR2Fsb2lzKSBmaWVsZCBpcyBpbnRlZ2VyIG51bWJlciBvcGVyYXRpb25zIGBtb2QgMTFgLlxuICogVGhlcmUgaXMgbm8gZGl2aXNpb246IGl0IGlzIHJlcGxhY2VkIGJ5IG1vZHVsYXIgbXVsdGlwbGljYXRpdmUgaW52ZXJzZS5cbiAqIEBtb2R1bGVcbiAqL1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHsgX3ZhbGlkYXRlT2JqZWN0LCBhbnVtYmVyLCBiaXRNYXNrLCBieXRlc1RvTnVtYmVyQkUsIGJ5dGVzVG9OdW1iZXJMRSwgZW5zdXJlQnl0ZXMsIG51bWJlclRvQnl0ZXNCRSwgbnVtYmVyVG9CeXRlc0xFLCB9IGZyb20gXCIuLi91dGlscy5qc1wiO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfMG4gPSBCaWdJbnQoMCksIF8xbiA9IEJpZ0ludCgxKSwgXzJuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgyKSwgXzNuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgzKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzRuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCg0KSwgXzVuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCg1KSwgXzduID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCg3KTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzhuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCg4KSwgXzluID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCg5KSwgXzE2biA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMTYpO1xuLy8gQ2FsY3VsYXRlcyBhIG1vZHVsbyBiXG5leHBvcnQgZnVuY3Rpb24gbW9kKGEsIGIpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhICUgYjtcbiAgICByZXR1cm4gcmVzdWx0ID49IF8wbiA/IHJlc3VsdCA6IGIgKyByZXN1bHQ7XG59XG4vKipcbiAqIEVmZmljaWVudGx5IHJhaXNlIG51bSB0byBwb3dlciBhbmQgZG8gbW9kdWxhciBkaXZpc2lvbi5cbiAqIFVuc2FmZSBpbiBzb21lIGNvbnRleHRzOiB1c2VzIGxhZGRlciwgc28gY2FuIGV4cG9zZSBiaWdpbnQgYml0cy5cbiAqIEBleGFtcGxlXG4gKiBwb3coMm4sIDZuLCAxMW4pIC8vIDY0biAlIDExbiA9PSA5blxuICovXG5leHBvcnQgZnVuY3Rpb24gcG93KG51bSwgcG93ZXIsIG1vZHVsbykge1xuICAgIHJldHVybiBGcFBvdyhGaWVsZChtb2R1bG8pLCBudW0sIHBvd2VyKTtcbn1cbi8qKiBEb2VzIGB4XigyXnBvd2VyKWAgbW9kIHAuIGBwb3cyKDMwLCA0KWAgPT0gYDMwXigyXjQpYCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBvdzIoeCwgcG93ZXIsIG1vZHVsbykge1xuICAgIGxldCByZXMgPSB4O1xuICAgIHdoaWxlIChwb3dlci0tID4gXzBuKSB7XG4gICAgICAgIHJlcyAqPSByZXM7XG4gICAgICAgIHJlcyAlPSBtb2R1bG87XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vKipcbiAqIEludmVyc2VzIG51bWJlciBvdmVyIG1vZHVsby5cbiAqIEltcGxlbWVudGVkIHVzaW5nIFtFdWNsaWRlYW4gR0NEXShodHRwczovL2JyaWxsaWFudC5vcmcvd2lraS9leHRlbmRlZC1ldWNsaWRlYW4tYWxnb3JpdGhtLykuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQobnVtYmVyLCBtb2R1bG8pIHtcbiAgICBpZiAobnVtYmVyID09PSBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52ZXJ0OiBleHBlY3RlZCBub24temVybyBudW1iZXInKTtcbiAgICBpZiAobW9kdWxvIDw9IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZlcnQ6IGV4cGVjdGVkIHBvc2l0aXZlIG1vZHVsdXMsIGdvdCAnICsgbW9kdWxvKTtcbiAgICAvLyBGZXJtYXQncyBsaXR0bGUgdGhlb3JlbSBcIkNULWxpa2VcIiB2ZXJzaW9uIGludihuKSA9IG5eKG0tMikgbW9kIG0gaXMgMzB4IHNsb3dlci5cbiAgICBsZXQgYSA9IG1vZChudW1iZXIsIG1vZHVsbyk7XG4gICAgbGV0IGIgPSBtb2R1bG87XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgbGV0IHggPSBfMG4sIHkgPSBfMW4sIHUgPSBfMW4sIHYgPSBfMG47XG4gICAgd2hpbGUgKGEgIT09IF8wbikge1xuICAgICAgICAvLyBKSVQgYXBwbGllcyBvcHRpbWl6YXRpb24gaWYgdGhvc2UgdHdvIGxpbmVzIGZvbGxvdyBlYWNoIG90aGVyXG4gICAgICAgIGNvbnN0IHEgPSBiIC8gYTtcbiAgICAgICAgY29uc3QgciA9IGIgJSBhO1xuICAgICAgICBjb25zdCBtID0geCAtIHUgKiBxO1xuICAgICAgICBjb25zdCBuID0geSAtIHYgKiBxO1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgYiA9IGEsIGEgPSByLCB4ID0gdSwgeSA9IHYsIHUgPSBtLCB2ID0gbjtcbiAgICB9XG4gICAgY29uc3QgZ2NkID0gYjtcbiAgICBpZiAoZ2NkICE9PSBfMW4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52ZXJ0OiBkb2VzIG5vdCBleGlzdCcpO1xuICAgIHJldHVybiBtb2QoeCwgbW9kdWxvKTtcbn1cbmZ1bmN0aW9uIGFzc2VydElzU3F1YXJlKEZwLCByb290LCBuKSB7XG4gICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCBuKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xufVxuLy8gTm90IGFsbCByb290cyBhcmUgcG9zc2libGUhIEV4YW1wbGUgd2hpY2ggd2lsbCB0aHJvdzpcbi8vIGNvbnN0IE5VTSA9XG4vLyBuID0gNzIwNTc1OTQwMzc5Mjc4MTZuO1xuLy8gRnAgPSBGaWVsZChCaWdJbnQoJzB4MWEwMTExZWEzOTdmZTY5YTRiMWJhN2I2NDM0YmFjZDc2NDc3NGI4NGYzODUxMmJmNjczMGQyYTBmNmIwZjYyNDFlYWJmZmZlYjE1M2ZmZmZiOWZlZmZmZmZmZmZhYWFiJykpO1xuZnVuY3Rpb24gc3FydDNtb2Q0KEZwLCBuKSB7XG4gICAgY29uc3QgcDFkaXY0ID0gKEZwLk9SREVSICsgXzFuKSAvIF80bjtcbiAgICBjb25zdCByb290ID0gRnAucG93KG4sIHAxZGl2NCk7XG4gICAgYXNzZXJ0SXNTcXVhcmUoRnAsIHJvb3QsIG4pO1xuICAgIHJldHVybiByb290O1xufVxuZnVuY3Rpb24gc3FydDVtb2Q4KEZwLCBuKSB7XG4gICAgY29uc3QgcDVkaXY4ID0gKEZwLk9SREVSIC0gXzVuKSAvIF84bjtcbiAgICBjb25zdCBuMiA9IEZwLm11bChuLCBfMm4pO1xuICAgIGNvbnN0IHYgPSBGcC5wb3cobjIsIHA1ZGl2OCk7XG4gICAgY29uc3QgbnYgPSBGcC5tdWwobiwgdik7XG4gICAgY29uc3QgaSA9IEZwLm11bChGcC5tdWwobnYsIF8ybiksIHYpO1xuICAgIGNvbnN0IHJvb3QgPSBGcC5tdWwobnYsIEZwLnN1YihpLCBGcC5PTkUpKTtcbiAgICBhc3NlcnRJc1NxdWFyZShGcCwgcm9vdCwgbik7XG4gICAgcmV0dXJuIHJvb3Q7XG59XG4vLyBCYXNlZCBvbiBSRkM5MzgwLCBLb25nIGFsZ29yaXRobVxuLy8gcHJldHRpZXItaWdub3JlXG5mdW5jdGlvbiBzcXJ0OW1vZDE2KFApIHtcbiAgICBjb25zdCBGcF8gPSBGaWVsZChQKTtcbiAgICBjb25zdCB0biA9IHRvbmVsbGlTaGFua3MoUCk7XG4gICAgY29uc3QgYzEgPSB0bihGcF8sIEZwXy5uZWcoRnBfLk9ORSkpOyAvLyAgMS4gYzEgPSBzcXJ0KC0xKSBpbiBGLCBpLmUuLCAoYzFeMikgPT0gLTEgaW4gRlxuICAgIGNvbnN0IGMyID0gdG4oRnBfLCBjMSk7IC8vICAyLiBjMiA9IHNxcnQoYzEpIGluIEYsIGkuZS4sIChjMl4yKSA9PSBjMSBpbiBGXG4gICAgY29uc3QgYzMgPSB0bihGcF8sIEZwXy5uZWcoYzEpKTsgLy8gIDMuIGMzID0gc3FydCgtYzEpIGluIEYsIGkuZS4sIChjM14yKSA9PSAtYzEgaW4gRlxuICAgIGNvbnN0IGM0ID0gKFAgKyBfN24pIC8gXzE2bjsgLy8gIDQuIGM0ID0gKHEgKyA3KSAvIDE2ICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIHJldHVybiAoRnAsIG4pID0+IHtcbiAgICAgICAgbGV0IHR2MSA9IEZwLnBvdyhuLCBjNCk7IC8vICAxLiB0djEgPSB4XmM0XG4gICAgICAgIGxldCB0djIgPSBGcC5tdWwodHYxLCBjMSk7IC8vICAyLiB0djIgPSBjMSAqIHR2MVxuICAgICAgICBjb25zdCB0djMgPSBGcC5tdWwodHYxLCBjMik7IC8vICAzLiB0djMgPSBjMiAqIHR2MVxuICAgICAgICBjb25zdCB0djQgPSBGcC5tdWwodHYxLCBjMyk7IC8vICA0LiB0djQgPSBjMyAqIHR2MVxuICAgICAgICBjb25zdCBlMSA9IEZwLmVxbChGcC5zcXIodHYyKSwgbik7IC8vICA1LiAgZTEgPSAodHYyXjIpID09IHhcbiAgICAgICAgY29uc3QgZTIgPSBGcC5lcWwoRnAuc3FyKHR2MyksIG4pOyAvLyAgNi4gIGUyID0gKHR2M14yKSA9PSB4XG4gICAgICAgIHR2MSA9IEZwLmNtb3YodHYxLCB0djIsIGUxKTsgLy8gIDcuIHR2MSA9IENNT1YodHYxLCB0djIsIGUxKSAgIyBTZWxlY3QgdHYyIGlmICh0djJeMikgPT0geFxuICAgICAgICB0djIgPSBGcC5jbW92KHR2NCwgdHYzLCBlMik7IC8vICA4LiB0djIgPSBDTU9WKHR2NCwgdHYzLCBlMikgICMgU2VsZWN0IHR2MyBpZiAodHYzXjIpID09IHhcbiAgICAgICAgY29uc3QgZTMgPSBGcC5lcWwoRnAuc3FyKHR2MiksIG4pOyAvLyAgOS4gIGUzID0gKHR2Ml4yKSA9PSB4XG4gICAgICAgIGNvbnN0IHJvb3QgPSBGcC5jbW92KHR2MSwgdHYyLCBlMyk7IC8vIDEwLiAgeiA9IENNT1YodHYxLCB0djIsIGUzKSAgICMgU2VsZWN0IHNxcnQgZnJvbSB0djEgJiB0djJcbiAgICAgICAgYXNzZXJ0SXNTcXVhcmUoRnAsIHJvb3QsIG4pO1xuICAgICAgICByZXR1cm4gcm9vdDtcbiAgICB9O1xufVxuLyoqXG4gKiBUb25lbGxpLVNoYW5rcyBzcXVhcmUgcm9vdCBzZWFyY2ggYWxnb3JpdGhtLlxuICogMS4gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxMi82ODUucGRmIChwYWdlIDEyKVxuICogMi4gU3F1YXJlIFJvb3RzIGZyb20gMTsgMjQsIDUxLCAxMCB0byBEYW4gU2hhbmtzXG4gKiBAcGFyYW0gUCBmaWVsZCBvcmRlclxuICogQHJldHVybnMgZnVuY3Rpb24gdGhhdCB0YWtlcyBmaWVsZCBGcCAoY3JlYXRlZCBmcm9tIFApIGFuZCBudW1iZXIgblxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9uZWxsaVNoYW5rcyhQKSB7XG4gICAgLy8gSW5pdGlhbGl6YXRpb24gKHByZWNvbXB1dGF0aW9uKS5cbiAgICAvLyBDYWNoaW5nIGluaXRpYWxpemF0aW9uIGNvdWxkIGJvb3N0IHBlcmYgYnkgNyUuXG4gICAgaWYgKFAgPCBfM24pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc3FydCBpcyBub3QgZGVmaW5lZCBmb3Igc21hbGwgZmllbGQnKTtcbiAgICAvLyBGYWN0b3IgUCAtIDEgPSBRICogMl5TLCB3aGVyZSBRIGlzIG9kZFxuICAgIGxldCBRID0gUCAtIF8xbjtcbiAgICBsZXQgUyA9IDA7XG4gICAgd2hpbGUgKFEgJSBfMm4gPT09IF8wbikge1xuICAgICAgICBRIC89IF8ybjtcbiAgICAgICAgUysrO1xuICAgIH1cbiAgICAvLyBGaW5kIHRoZSBmaXJzdCBxdWFkcmF0aWMgbm9uLXJlc2lkdWUgWiA+PSAyXG4gICAgbGV0IFogPSBfMm47XG4gICAgY29uc3QgX0ZwID0gRmllbGQoUCk7XG4gICAgd2hpbGUgKEZwTGVnZW5kcmUoX0ZwLCBaKSA9PT0gMSkge1xuICAgICAgICAvLyBCYXNpYyBwcmltYWxpdHkgdGVzdCBmb3IgUC4gQWZ0ZXIgeCBpdGVyYXRpb25zLCBjaGFuY2Ugb2ZcbiAgICAgICAgLy8gbm90IGZpbmRpbmcgcXVhZHJhdGljIG5vbi1yZXNpZHVlIGlzIDJeeCwgc28gMl4xMDAwLlxuICAgICAgICBpZiAoWisrID4gMTAwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3Q6IHByb2JhYmx5IG5vbi1wcmltZSBQJyk7XG4gICAgfVxuICAgIC8vIEZhc3QtcGF0aDsgdXN1YWxseSBkb25lIGJlZm9yZSBaLCBidXQgd2UgZG8gXCJwcmltYWxpdHkgdGVzdFwiLlxuICAgIGlmIChTID09PSAxKVxuICAgICAgICByZXR1cm4gc3FydDNtb2Q0O1xuICAgIC8vIFNsb3ctcGF0aFxuICAgIC8vIFRPRE86IHRlc3Qgb24gRnAyIGFuZCBvdGhlcnNcbiAgICBsZXQgY2MgPSBfRnAucG93KFosIFEpOyAvLyBjID0gel5RXG4gICAgY29uc3QgUTFkaXYyID0gKFEgKyBfMW4pIC8gXzJuO1xuICAgIHJldHVybiBmdW5jdGlvbiB0b25lbGxpU2xvdyhGcCwgbikge1xuICAgICAgICBpZiAoRnAuaXMwKG4pKVxuICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIC8vIENoZWNrIGlmIG4gaXMgYSBxdWFkcmF0aWMgcmVzaWR1ZSB1c2luZyBMZWdlbmRyZSBzeW1ib2xcbiAgICAgICAgaWYgKEZwTGVnZW5kcmUoRnAsIG4pICE9PSAxKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICAvLyBJbml0aWFsaXplIHZhcmlhYmxlcyBmb3IgdGhlIG1haW4gbG9vcFxuICAgICAgICBsZXQgTSA9IFM7XG4gICAgICAgIGxldCBjID0gRnAubXVsKEZwLk9ORSwgY2MpOyAvLyBjID0gel5RLCBtb3ZlIGNjIGZyb20gZmllbGQgX0ZwIGludG8gZmllbGQgRnBcbiAgICAgICAgbGV0IHQgPSBGcC5wb3cobiwgUSk7IC8vIHQgPSBuXlEsIGZpcnN0IGd1ZXNzIGF0IHRoZSBmdWRnZSBmYWN0b3JcbiAgICAgICAgbGV0IFIgPSBGcC5wb3cobiwgUTFkaXYyKTsgLy8gUiA9IG5eKChRKzEpLzIpLCBmaXJzdCBndWVzcyBhdCB0aGUgc3F1YXJlIHJvb3RcbiAgICAgICAgLy8gTWFpbiBsb29wXG4gICAgICAgIC8vIHdoaWxlIHQgIT0gMVxuICAgICAgICB3aGlsZSAoIUZwLmVxbCh0LCBGcC5PTkUpKSB7XG4gICAgICAgICAgICBpZiAoRnAuaXMwKHQpKVxuICAgICAgICAgICAgICAgIHJldHVybiBGcC5aRVJPOyAvLyBpZiB0PTAgcmV0dXJuIFI9MFxuICAgICAgICAgICAgbGV0IGkgPSAxO1xuICAgICAgICAgICAgLy8gRmluZCB0aGUgc21hbGxlc3QgaSA+PSAxIHN1Y2ggdGhhdCB0XigyXmkpIOKJoSAxIChtb2QgUClcbiAgICAgICAgICAgIGxldCB0X3RtcCA9IEZwLnNxcih0KTsgLy8gdF4oMl4xKVxuICAgICAgICAgICAgd2hpbGUgKCFGcC5lcWwodF90bXAsIEZwLk9ORSkpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgdF90bXAgPSBGcC5zcXIodF90bXApOyAvLyB0XigyXjIpLi4uXG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IE0pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZXhwb25lbnQgZm9yIGI6IDJeKE0gLSBpIC0gMSlcbiAgICAgICAgICAgIGNvbnN0IGV4cG9uZW50ID0gXzFuIDw8IEJpZ0ludChNIC0gaSAtIDEpOyAvLyBiaWdpbnQgaXMgaW1wb3J0YW50XG4gICAgICAgICAgICBjb25zdCBiID0gRnAucG93KGMsIGV4cG9uZW50KTsgLy8gYiA9IDJeKE0gLSBpIC0gMSlcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB2YXJpYWJsZXNcbiAgICAgICAgICAgIE0gPSBpO1xuICAgICAgICAgICAgYyA9IEZwLnNxcihiKTsgLy8gYyA9IGJeMlxuICAgICAgICAgICAgdCA9IEZwLm11bCh0LCBjKTsgLy8gdCA9ICh0ICogYl4yKVxuICAgICAgICAgICAgUiA9IEZwLm11bChSLCBiKTsgLy8gUiA9IFIqYlxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSO1xuICAgIH07XG59XG4vKipcbiAqIFNxdWFyZSByb290IGZvciBhIGZpbml0ZSBmaWVsZC4gV2lsbCB0cnkgb3B0aW1pemVkIHZlcnNpb25zIGZpcnN0OlxuICpcbiAqIDEuIFAg4omhIDMgKG1vZCA0KVxuICogMi4gUCDiiaEgNSAobW9kIDgpXG4gKiAzLiBQIOKJoSA5IChtb2QgMTYpXG4gKiA0LiBUb25lbGxpLVNoYW5rcyBhbGdvcml0aG1cbiAqXG4gKiBEaWZmZXJlbnQgYWxnb3JpdGhtcyBjYW4gZ2l2ZSBkaWZmZXJlbnQgcm9vdHMsIGl0IGlzIHVwIHRvIHVzZXIgdG8gZGVjaWRlIHdoaWNoIG9uZSB0aGV5IHdhbnQuXG4gKiBGb3IgZXhhbXBsZSB0aGVyZSBpcyBGcFNxcnRPZGQvRnBTcXJ0RXZlbiB0byBjaG9pY2Ugcm9vdCBiYXNlZCBvbiBvZGRuZXNzICh1c2VkIGZvciBoYXNoLXRvLWN1cnZlKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZwU3FydChQKSB7XG4gICAgLy8gUCDiiaEgMyAobW9kIDQpID0+IOKImm4gPSBuXigoUCsxKS80KVxuICAgIGlmIChQICUgXzRuID09PSBfM24pXG4gICAgICAgIHJldHVybiBzcXJ0M21vZDQ7XG4gICAgLy8gUCDiiaEgNSAobW9kIDgpID0+IEF0a2luIGFsZ29yaXRobSwgcGFnZSAxMCBvZiBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDEyLzY4NS5wZGZcbiAgICBpZiAoUCAlIF84biA9PT0gXzVuKVxuICAgICAgICByZXR1cm4gc3FydDVtb2Q4O1xuICAgIC8vIFAg4omhIDkgKG1vZCAxNikgPT4gS29uZyBhbGdvcml0aG0sIHBhZ2UgMTEgb2YgaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxMi82ODUucGRmIChhbGdvcml0aG0gNClcbiAgICBpZiAoUCAlIF8xNm4gPT09IF85bilcbiAgICAgICAgcmV0dXJuIHNxcnQ5bW9kMTYoUCk7XG4gICAgLy8gVG9uZWxsaS1TaGFua3MgYWxnb3JpdGhtXG4gICAgcmV0dXJuIHRvbmVsbGlTaGFua3MoUCk7XG59XG4vLyBMaXR0bGUtZW5kaWFuIGNoZWNrIGZvciBmaXJzdCBMRSBiaXQgKGxhc3QgQkUgYml0KTtcbmV4cG9ydCBjb25zdCBpc05lZ2F0aXZlTEUgPSAobnVtLCBtb2R1bG8pID0+IChtb2QobnVtLCBtb2R1bG8pICYgXzFuKSA9PT0gXzFuO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBGSUVMRF9GSUVMRFMgPSBbXG4gICAgJ2NyZWF0ZScsICdpc1ZhbGlkJywgJ2lzMCcsICduZWcnLCAnaW52JywgJ3NxcnQnLCAnc3FyJyxcbiAgICAnZXFsJywgJ2FkZCcsICdzdWInLCAnbXVsJywgJ3BvdycsICdkaXYnLFxuICAgICdhZGROJywgJ3N1Yk4nLCAnbXVsTicsICdzcXJOJ1xuXTtcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUZpZWxkKGZpZWxkKSB7XG4gICAgY29uc3QgaW5pdGlhbCA9IHtcbiAgICAgICAgT1JERVI6ICdiaWdpbnQnLFxuICAgICAgICBNQVNLOiAnYmlnaW50JyxcbiAgICAgICAgQllURVM6ICdudW1iZXInLFxuICAgICAgICBCSVRTOiAnbnVtYmVyJyxcbiAgICB9O1xuICAgIGNvbnN0IG9wdHMgPSBGSUVMRF9GSUVMRFMucmVkdWNlKChtYXAsIHZhbCkgPT4ge1xuICAgICAgICBtYXBbdmFsXSA9ICdmdW5jdGlvbic7XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgfSwgaW5pdGlhbCk7XG4gICAgX3ZhbGlkYXRlT2JqZWN0KGZpZWxkLCBvcHRzKTtcbiAgICAvLyBjb25zdCBtYXggPSAxNjM4NDtcbiAgICAvLyBpZiAoZmllbGQuQllURVMgPCAxIHx8IGZpZWxkLkJZVEVTID4gbWF4KSB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZmllbGQnKTtcbiAgICAvLyBpZiAoZmllbGQuQklUUyA8IDEgfHwgZmllbGQuQklUUyA+IDggKiBtYXgpIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBmaWVsZCcpO1xuICAgIHJldHVybiBmaWVsZDtcbn1cbi8vIEdlbmVyaWMgZmllbGQgZnVuY3Rpb25zXG4vKipcbiAqIFNhbWUgYXMgYHBvd2AgYnV0IGZvciBGcDogbm9uLWNvbnN0YW50LXRpbWUuXG4gKiBVbnNhZmUgaW4gc29tZSBjb250ZXh0czogdXNlcyBsYWRkZXIsIHNvIGNhbiBleHBvc2UgYmlnaW50IGJpdHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGcFBvdyhGcCwgbnVtLCBwb3dlcikge1xuICAgIGlmIChwb3dlciA8IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGV4cG9uZW50LCBuZWdhdGl2ZXMgdW5zdXBwb3J0ZWQnKTtcbiAgICBpZiAocG93ZXIgPT09IF8wbilcbiAgICAgICAgcmV0dXJuIEZwLk9ORTtcbiAgICBpZiAocG93ZXIgPT09IF8xbilcbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICBsZXQgcCA9IEZwLk9ORTtcbiAgICBsZXQgZCA9IG51bTtcbiAgICB3aGlsZSAocG93ZXIgPiBfMG4pIHtcbiAgICAgICAgaWYgKHBvd2VyICYgXzFuKVxuICAgICAgICAgICAgcCA9IEZwLm11bChwLCBkKTtcbiAgICAgICAgZCA9IEZwLnNxcihkKTtcbiAgICAgICAgcG93ZXIgPj49IF8xbjtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG59XG4vKipcbiAqIEVmZmljaWVudGx5IGludmVydCBhbiBhcnJheSBvZiBGaWVsZCBlbGVtZW50cy5cbiAqIEV4Y2VwdGlvbi1mcmVlLiBXaWxsIHJldHVybiBgdW5kZWZpbmVkYCBmb3IgMCBlbGVtZW50cy5cbiAqIEBwYXJhbSBwYXNzWmVybyBtYXAgMCB0byAwIChpbnN0ZWFkIG9mIHVuZGVmaW5lZClcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZwSW52ZXJ0QmF0Y2goRnAsIG51bXMsIHBhc3NaZXJvID0gZmFsc2UpIHtcbiAgICBjb25zdCBpbnZlcnRlZCA9IG5ldyBBcnJheShudW1zLmxlbmd0aCkuZmlsbChwYXNzWmVybyA/IEZwLlpFUk8gOiB1bmRlZmluZWQpO1xuICAgIC8vIFdhbGsgZnJvbSBmaXJzdCB0byBsYXN0LCBtdWx0aXBseSB0aGVtIGJ5IGVhY2ggb3RoZXIgTU9EIHBcbiAgICBjb25zdCBtdWx0aXBsaWVkQWNjID0gbnVtcy5yZWR1Y2UoKGFjYywgbnVtLCBpKSA9PiB7XG4gICAgICAgIGlmIChGcC5pczAobnVtKSlcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIGludmVydGVkW2ldID0gYWNjO1xuICAgICAgICByZXR1cm4gRnAubXVsKGFjYywgbnVtKTtcbiAgICB9LCBGcC5PTkUpO1xuICAgIC8vIEludmVydCBsYXN0IGVsZW1lbnRcbiAgICBjb25zdCBpbnZlcnRlZEFjYyA9IEZwLmludihtdWx0aXBsaWVkQWNjKTtcbiAgICAvLyBXYWxrIGZyb20gbGFzdCB0byBmaXJzdCwgbXVsdGlwbHkgdGhlbSBieSBpbnZlcnRlZCBlYWNoIG90aGVyIE1PRCBwXG4gICAgbnVtcy5yZWR1Y2VSaWdodCgoYWNjLCBudW0sIGkpID0+IHtcbiAgICAgICAgaWYgKEZwLmlzMChudW0pKVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgaW52ZXJ0ZWRbaV0gPSBGcC5tdWwoYWNjLCBpbnZlcnRlZFtpXSk7XG4gICAgICAgIHJldHVybiBGcC5tdWwoYWNjLCBudW0pO1xuICAgIH0sIGludmVydGVkQWNjKTtcbiAgICByZXR1cm4gaW52ZXJ0ZWQ7XG59XG4vLyBUT0RPOiByZW1vdmVcbmV4cG9ydCBmdW5jdGlvbiBGcERpdihGcCwgbGhzLCByaHMpIHtcbiAgICByZXR1cm4gRnAubXVsKGxocywgdHlwZW9mIHJocyA9PT0gJ2JpZ2ludCcgPyBpbnZlcnQocmhzLCBGcC5PUkRFUikgOiBGcC5pbnYocmhzKSk7XG59XG4vKipcbiAqIExlZ2VuZHJlIHN5bWJvbC5cbiAqIExlZ2VuZHJlIGNvbnN0YW50IGlzIHVzZWQgdG8gY2FsY3VsYXRlIExlZ2VuZHJlIHN5bWJvbCAoYSB8IHApXG4gKiB3aGljaCBkZW5vdGVzIHRoZSB2YWx1ZSBvZiBhXigocC0xKS8yKSAobW9kIHApLlxuICpcbiAqICogKGEgfCBwKSDiiaEgMSAgICBpZiBhIGlzIGEgc3F1YXJlIChtb2QgcCksIHF1YWRyYXRpYyByZXNpZHVlXG4gKiAqIChhIHwgcCkg4omhIC0xICAgaWYgYSBpcyBub3QgYSBzcXVhcmUgKG1vZCBwKSwgcXVhZHJhdGljIG5vbiByZXNpZHVlXG4gKiAqIChhIHwgcCkg4omhIDAgICAgaWYgYSDiiaEgMCAobW9kIHApXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGcExlZ2VuZHJlKEZwLCBuKSB7XG4gICAgLy8gV2UgY2FuIHVzZSAzcmQgYXJndW1lbnQgYXMgb3B0aW9uYWwgY2FjaGUgb2YgdGhpcyB2YWx1ZVxuICAgIC8vIGJ1dCBzZWVtcyB1bm5lZWRlZCBmb3Igbm93LiBUaGUgb3BlcmF0aW9uIGlzIHZlcnkgZmFzdC5cbiAgICBjb25zdCBwMW1vZDIgPSAoRnAuT1JERVIgLSBfMW4pIC8gXzJuO1xuICAgIGNvbnN0IHBvd2VyZWQgPSBGcC5wb3cobiwgcDFtb2QyKTtcbiAgICBjb25zdCB5ZXMgPSBGcC5lcWwocG93ZXJlZCwgRnAuT05FKTtcbiAgICBjb25zdCB6ZXJvID0gRnAuZXFsKHBvd2VyZWQsIEZwLlpFUk8pO1xuICAgIGNvbnN0IG5vID0gRnAuZXFsKHBvd2VyZWQsIEZwLm5lZyhGcC5PTkUpKTtcbiAgICBpZiAoIXllcyAmJiAhemVybyAmJiAhbm8pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBMZWdlbmRyZSBzeW1ib2wgcmVzdWx0Jyk7XG4gICAgcmV0dXJuIHllcyA/IDEgOiB6ZXJvID8gMCA6IC0xO1xufVxuLy8gVGhpcyBmdW5jdGlvbiByZXR1cm5zIFRydWUgd2hlbmV2ZXIgdGhlIHZhbHVlIHggaXMgYSBzcXVhcmUgaW4gdGhlIGZpZWxkIEYuXG5leHBvcnQgZnVuY3Rpb24gRnBJc1NxdWFyZShGcCwgbikge1xuICAgIGNvbnN0IGwgPSBGcExlZ2VuZHJlKEZwLCBuKTtcbiAgICByZXR1cm4gbCA9PT0gMTtcbn1cbi8vIENVUlZFLm4gbGVuZ3Roc1xuZXhwb3J0IGZ1bmN0aW9uIG5MZW5ndGgobiwgbkJpdExlbmd0aCkge1xuICAgIC8vIEJpdCBzaXplLCBieXRlIHNpemUgb2YgQ1VSVkUublxuICAgIGlmIChuQml0TGVuZ3RoICE9PSB1bmRlZmluZWQpXG4gICAgICAgIGFudW1iZXIobkJpdExlbmd0aCk7XG4gICAgY29uc3QgX25CaXRMZW5ndGggPSBuQml0TGVuZ3RoICE9PSB1bmRlZmluZWQgPyBuQml0TGVuZ3RoIDogbi50b1N0cmluZygyKS5sZW5ndGg7XG4gICAgY29uc3QgbkJ5dGVMZW5ndGggPSBNYXRoLmNlaWwoX25CaXRMZW5ndGggLyA4KTtcbiAgICByZXR1cm4geyBuQml0TGVuZ3RoOiBfbkJpdExlbmd0aCwgbkJ5dGVMZW5ndGggfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGZpbml0ZSBmaWVsZC4gTWFqb3IgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uczpcbiAqICogMS4gRGVub3JtYWxpemVkIG9wZXJhdGlvbnMgbGlrZSBtdWxOIGluc3RlYWQgb2YgbXVsLlxuICogKiAyLiBJZGVudGljYWwgb2JqZWN0IHNoYXBlOiBuZXZlciBhZGQgb3IgcmVtb3ZlIGtleXMuXG4gKiAqIDMuIGBPYmplY3QuZnJlZXplYC5cbiAqIEZyYWdpbGU6IGFsd2F5cyBydW4gYSBiZW5jaG1hcmsgb24gYSBjaGFuZ2UuXG4gKiBTZWN1cml0eSBub3RlOiBvcGVyYXRpb25zIGRvbid0IGNoZWNrICdpc1ZhbGlkJyBmb3IgYWxsIGVsZW1lbnRzIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLFxuICogaXQgaXMgY2FsbGVyIHJlc3BvbnNpYmlsaXR5IHRvIGNoZWNrIHRoaXMuXG4gKiBUaGlzIGlzIGxvdy1sZXZlbCBjb2RlLCBwbGVhc2UgbWFrZSBzdXJlIHlvdSBrbm93IHdoYXQgeW91J3JlIGRvaW5nLlxuICpcbiAqIE5vdGUgYWJvdXQgZmllbGQgcHJvcGVydGllczpcbiAqICogQ0hBUkFDVEVSSVNUSUMgcCA9IHByaW1lIG51bWJlciwgbnVtYmVyIG9mIGVsZW1lbnRzIGluIG1haW4gc3ViZ3JvdXAuXG4gKiAqIE9SREVSIHEgPSBzaW1pbGFyIHRvIGNvZmFjdG9yIGluIGN1cnZlcywgbWF5IGJlIGNvbXBvc2l0ZSBgcSA9IHBebWAuXG4gKlxuICogQHBhcmFtIE9SREVSIGZpZWxkIG9yZGVyLCBwcm9iYWJseSBwcmltZSwgb3IgY291bGQgYmUgY29tcG9zaXRlXG4gKiBAcGFyYW0gYml0TGVuIGhvdyBtYW55IGJpdHMgdGhlIGZpZWxkIGNvbnN1bWVzXG4gKiBAcGFyYW0gaXNMRSAoZGVmYXVsdDogZmFsc2UpIGlmIGVuY29kaW5nIC8gZGVjb2Rpbmcgc2hvdWxkIGJlIGluIGxpdHRsZS1lbmRpYW5cbiAqIEBwYXJhbSByZWRlZiBvcHRpb25hbCBmYXN0ZXIgcmVkZWZpbml0aW9ucyBvZiBzcXJ0IGFuZCBvdGhlciBtZXRob2RzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGaWVsZChPUkRFUiwgYml0TGVuT3JPcHRzLCAvLyBUT0RPOiB1c2Ugb3B0cyBvbmx5IGluIHYyP1xuaXNMRSA9IGZhbHNlLCBvcHRzID0ge30pIHtcbiAgICBpZiAoT1JERVIgPD0gXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZmllbGQ6IGV4cGVjdGVkIE9SREVSID4gMCwgZ290ICcgKyBPUkRFUik7XG4gICAgbGV0IF9uYml0TGVuZ3RoID0gdW5kZWZpbmVkO1xuICAgIGxldCBfc3FydCA9IHVuZGVmaW5lZDtcbiAgICBsZXQgbW9kRnJvbUJ5dGVzID0gZmFsc2U7XG4gICAgbGV0IGFsbG93ZWRMZW5ndGhzID0gdW5kZWZpbmVkO1xuICAgIGlmICh0eXBlb2YgYml0TGVuT3JPcHRzID09PSAnb2JqZWN0JyAmJiBiaXRMZW5Pck9wdHMgIT0gbnVsbCkge1xuICAgICAgICBpZiAob3B0cy5zcXJ0IHx8IGlzTEUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBzcGVjaWZ5IG9wdHMgaW4gdHdvIGFyZ3VtZW50cycpO1xuICAgICAgICBjb25zdCBfb3B0cyA9IGJpdExlbk9yT3B0cztcbiAgICAgICAgaWYgKF9vcHRzLkJJVFMpXG4gICAgICAgICAgICBfbmJpdExlbmd0aCA9IF9vcHRzLkJJVFM7XG4gICAgICAgIGlmIChfb3B0cy5zcXJ0KVxuICAgICAgICAgICAgX3NxcnQgPSBfb3B0cy5zcXJ0O1xuICAgICAgICBpZiAodHlwZW9mIF9vcHRzLmlzTEUgPT09ICdib29sZWFuJylcbiAgICAgICAgICAgIGlzTEUgPSBfb3B0cy5pc0xFO1xuICAgICAgICBpZiAodHlwZW9mIF9vcHRzLm1vZEZyb21CeXRlcyA9PT0gJ2Jvb2xlYW4nKVxuICAgICAgICAgICAgbW9kRnJvbUJ5dGVzID0gX29wdHMubW9kRnJvbUJ5dGVzO1xuICAgICAgICBhbGxvd2VkTGVuZ3RocyA9IF9vcHRzLmFsbG93ZWRMZW5ndGhzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiaXRMZW5Pck9wdHMgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgX25iaXRMZW5ndGggPSBiaXRMZW5Pck9wdHM7XG4gICAgICAgIGlmIChvcHRzLnNxcnQpXG4gICAgICAgICAgICBfc3FydCA9IG9wdHMuc3FydDtcbiAgICB9XG4gICAgY29uc3QgeyBuQml0TGVuZ3RoOiBCSVRTLCBuQnl0ZUxlbmd0aDogQllURVMgfSA9IG5MZW5ndGgoT1JERVIsIF9uYml0TGVuZ3RoKTtcbiAgICBpZiAoQllURVMgPiAyMDQ4KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZmllbGQ6IGV4cGVjdGVkIE9SREVSIG9mIDw9IDIwNDggYnl0ZXMnKTtcbiAgICBsZXQgc3FydFA7IC8vIGNhY2hlZCBzcXJ0UFxuICAgIGNvbnN0IGYgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgT1JERVIsXG4gICAgICAgIGlzTEUsXG4gICAgICAgIEJJVFMsXG4gICAgICAgIEJZVEVTLFxuICAgICAgICBNQVNLOiBiaXRNYXNrKEJJVFMpLFxuICAgICAgICBaRVJPOiBfMG4sXG4gICAgICAgIE9ORTogXzFuLFxuICAgICAgICBhbGxvd2VkTGVuZ3RoczogYWxsb3dlZExlbmd0aHMsXG4gICAgICAgIGNyZWF0ZTogKG51bSkgPT4gbW9kKG51bSwgT1JERVIpLFxuICAgICAgICBpc1ZhbGlkOiAobnVtKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG51bSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGZpZWxkIGVsZW1lbnQ6IGV4cGVjdGVkIGJpZ2ludCwgZ290ICcgKyB0eXBlb2YgbnVtKTtcbiAgICAgICAgICAgIHJldHVybiBfMG4gPD0gbnVtICYmIG51bSA8IE9SREVSOyAvLyAwIGlzIHZhbGlkIGVsZW1lbnQsIGJ1dCBpdCdzIG5vdCBpbnZlcnRpYmxlXG4gICAgICAgIH0sXG4gICAgICAgIGlzMDogKG51bSkgPT4gbnVtID09PSBfMG4sXG4gICAgICAgIC8vIGlzIHZhbGlkIGFuZCBpbnZlcnRpYmxlXG4gICAgICAgIGlzVmFsaWROb3QwOiAobnVtKSA9PiAhZi5pczAobnVtKSAmJiBmLmlzVmFsaWQobnVtKSxcbiAgICAgICAgaXNPZGQ6IChudW0pID0+IChudW0gJiBfMW4pID09PSBfMW4sXG4gICAgICAgIG5lZzogKG51bSkgPT4gbW9kKC1udW0sIE9SREVSKSxcbiAgICAgICAgZXFsOiAobGhzLCByaHMpID0+IGxocyA9PT0gcmhzLFxuICAgICAgICBzcXI6IChudW0pID0+IG1vZChudW0gKiBudW0sIE9SREVSKSxcbiAgICAgICAgYWRkOiAobGhzLCByaHMpID0+IG1vZChsaHMgKyByaHMsIE9SREVSKSxcbiAgICAgICAgc3ViOiAobGhzLCByaHMpID0+IG1vZChsaHMgLSByaHMsIE9SREVSKSxcbiAgICAgICAgbXVsOiAobGhzLCByaHMpID0+IG1vZChsaHMgKiByaHMsIE9SREVSKSxcbiAgICAgICAgcG93OiAobnVtLCBwb3dlcikgPT4gRnBQb3coZiwgbnVtLCBwb3dlciksXG4gICAgICAgIGRpdjogKGxocywgcmhzKSA9PiBtb2QobGhzICogaW52ZXJ0KHJocywgT1JERVIpLCBPUkRFUiksXG4gICAgICAgIC8vIFNhbWUgYXMgYWJvdmUsIGJ1dCBkb2Vzbid0IG5vcm1hbGl6ZVxuICAgICAgICBzcXJOOiAobnVtKSA9PiBudW0gKiBudW0sXG4gICAgICAgIGFkZE46IChsaHMsIHJocykgPT4gbGhzICsgcmhzLFxuICAgICAgICBzdWJOOiAobGhzLCByaHMpID0+IGxocyAtIHJocyxcbiAgICAgICAgbXVsTjogKGxocywgcmhzKSA9PiBsaHMgKiByaHMsXG4gICAgICAgIGludjogKG51bSkgPT4gaW52ZXJ0KG51bSwgT1JERVIpLFxuICAgICAgICBzcXJ0OiBfc3FydCB8fFxuICAgICAgICAgICAgKChuKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFzcXJ0UClcbiAgICAgICAgICAgICAgICAgICAgc3FydFAgPSBGcFNxcnQoT1JERVIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzcXJ0UChmLCBuKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB0b0J5dGVzOiAobnVtKSA9PiAoaXNMRSA/IG51bWJlclRvQnl0ZXNMRShudW0sIEJZVEVTKSA6IG51bWJlclRvQnl0ZXNCRShudW0sIEJZVEVTKSksXG4gICAgICAgIGZyb21CeXRlczogKGJ5dGVzLCBza2lwVmFsaWRhdGlvbiA9IHRydWUpID0+IHtcbiAgICAgICAgICAgIGlmIChhbGxvd2VkTGVuZ3Rocykge1xuICAgICAgICAgICAgICAgIGlmICghYWxsb3dlZExlbmd0aHMuaW5jbHVkZXMoYnl0ZXMubGVuZ3RoKSB8fCBieXRlcy5sZW5ndGggPiBCWVRFUykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpZWxkLmZyb21CeXRlczogZXhwZWN0ZWQgJyArIGFsbG93ZWRMZW5ndGhzICsgJyBieXRlcywgZ290ICcgKyBieXRlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBwYWRkZWQgPSBuZXcgVWludDhBcnJheShCWVRFUyk7XG4gICAgICAgICAgICAgICAgLy8gaXNMRSBhZGQgMCB0byByaWdodCwgIWlzTEUgdG8gdGhlIGxlZnQuXG4gICAgICAgICAgICAgICAgcGFkZGVkLnNldChieXRlcywgaXNMRSA/IDAgOiBwYWRkZWQubGVuZ3RoIC0gYnl0ZXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBieXRlcyA9IHBhZGRlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggIT09IEJZVEVTKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmllbGQuZnJvbUJ5dGVzOiBleHBlY3RlZCAnICsgQllURVMgKyAnIGJ5dGVzLCBnb3QgJyArIGJ5dGVzLmxlbmd0aCk7XG4gICAgICAgICAgICBsZXQgc2NhbGFyID0gaXNMRSA/IGJ5dGVzVG9OdW1iZXJMRShieXRlcykgOiBieXRlc1RvTnVtYmVyQkUoYnl0ZXMpO1xuICAgICAgICAgICAgaWYgKG1vZEZyb21CeXRlcylcbiAgICAgICAgICAgICAgICBzY2FsYXIgPSBtb2Qoc2NhbGFyLCBPUkRFUik7XG4gICAgICAgICAgICBpZiAoIXNraXBWYWxpZGF0aW9uKVxuICAgICAgICAgICAgICAgIGlmICghZi5pc1ZhbGlkKHNjYWxhcikpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBmaWVsZCBlbGVtZW50OiBvdXRzaWRlIG9mIHJhbmdlIDAuLk9SREVSJyk7XG4gICAgICAgICAgICAvLyBOT1RFOiB3ZSBkb24ndCB2YWxpZGF0ZSBzY2FsYXIgaGVyZSwgcGxlYXNlIHVzZSBpc1ZhbGlkLiBUaGlzIGRvbmUgc3VjaCB3YXkgYmVjYXVzZSBzb21lXG4gICAgICAgICAgICAvLyBwcm90b2NvbCBtYXkgYWxsb3cgbm9uLXJlZHVjZWQgc2NhbGFyIHRoYXQgcmVkdWNlZCBsYXRlciBvciBjaGFuZ2VkIHNvbWUgb3RoZXIgd2F5LlxuICAgICAgICAgICAgcmV0dXJuIHNjYWxhcjtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gVE9ETzogd2UgZG9uJ3QgbmVlZCBpdCBoZXJlLCBtb3ZlIG91dCB0byBzZXBhcmF0ZSBmblxuICAgICAgICBpbnZlcnRCYXRjaDogKGxzdCkgPT4gRnBJbnZlcnRCYXRjaChmLCBsc3QpLFxuICAgICAgICAvLyBXZSBjYW4ndCBtb3ZlIHRoaXMgb3V0IGJlY2F1c2UgRnA2LCBGcDEyIGltcGxlbWVudCBpdFxuICAgICAgICAvLyBhbmQgaXQncyB1bmNsZWFyIHdoYXQgdG8gcmV0dXJuIGluIHRoZXJlLlxuICAgICAgICBjbW92OiAoYSwgYiwgYykgPT4gKGMgPyBiIDogYSksXG4gICAgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoZik7XG59XG4vLyBHZW5lcmljIHJhbmRvbSBzY2FsYXIsIHdlIGNhbiBkbyBzYW1lIGZvciBvdGhlciBmaWVsZHMgaWYgdmlhIEZwMi5tdWwoRnAyLk9ORSwgRnAyLnJhbmRvbSk/XG4vLyBUaGlzIGFsbG93cyB1bnNhZmUgbWV0aG9kcyBsaWtlIGlnbm9yZSBiaWFzIG9yIHplcm8uIFRoZXNlIHVuc2FmZSwgYnV0IG9mdGVuIHVzZWQgaW4gZGlmZmVyZW50IHByb3RvY29scyAoaWYgZGV0ZXJtaW5pc3RpYyBSTkcpLlxuLy8gd2hpY2ggbWVhbiB3ZSBjYW5ub3QgZm9yY2UgdGhpcyB2aWEgb3B0cy5cbi8vIE5vdCBzdXJlIHdoYXQgdG8gZG8gd2l0aCByYW5kb21CeXRlcywgd2UgY2FuIGFjY2VwdCBpdCBpbnNpZGUgb3B0cyBpZiB3YW50ZWQuXG4vLyBQcm9iYWJseSBuZWVkIHRvIGV4cG9ydCBnZXRNaW5IYXNoTGVuZ3RoIHNvbWV3aGVyZT9cbi8vIHJhbmRvbShieXRlcz86IFVpbnQ4QXJyYXksIHVuc2FmZUFsbG93WmVybyA9IGZhbHNlLCB1bnNhZmVBbGxvd0JpYXMgPSBmYWxzZSkge1xuLy8gICBjb25zdCBMRU4gPSAhdW5zYWZlQWxsb3dCaWFzID8gZ2V0TWluSGFzaExlbmd0aChPUkRFUikgOiBCWVRFUztcbi8vICAgaWYgKGJ5dGVzID09PSB1bmRlZmluZWQpIGJ5dGVzID0gcmFuZG9tQnl0ZXMoTEVOKTsgLy8gX29wdHMucmFuZG9tQnl0ZXM/XG4vLyAgIGNvbnN0IG51bSA9IGlzTEUgPyBieXRlc1RvTnVtYmVyTEUoYnl0ZXMpIDogYnl0ZXNUb051bWJlckJFKGJ5dGVzKTtcbi8vICAgLy8gYG1vZCh4LCAxMSlgIGNhbiBzb21ldGltZXMgcHJvZHVjZSAwLiBgbW9kKHgsIDEwKSArIDFgIGlzIHRoZSBzYW1lLCBidXQgbm8gMFxuLy8gICBjb25zdCByZWR1Y2VkID0gdW5zYWZlQWxsb3daZXJvID8gbW9kKG51bSwgT1JERVIpIDogbW9kKG51bSwgT1JERVIgLSBfMW4pICsgXzFuO1xuLy8gICByZXR1cm4gcmVkdWNlZDtcbi8vIH0sXG5leHBvcnQgZnVuY3Rpb24gRnBTcXJ0T2RkKEZwLCBlbG0pIHtcbiAgICBpZiAoIUZwLmlzT2RkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaWVsZCBkb2Vzbid0IGhhdmUgaXNPZGRcIik7XG4gICAgY29uc3Qgcm9vdCA9IEZwLnNxcnQoZWxtKTtcbiAgICByZXR1cm4gRnAuaXNPZGQocm9vdCkgPyByb290IDogRnAubmVnKHJvb3QpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIEZwU3FydEV2ZW4oRnAsIGVsbSkge1xuICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZpZWxkIGRvZXNuJ3QgaGF2ZSBpc09kZFwiKTtcbiAgICBjb25zdCByb290ID0gRnAuc3FydChlbG0pO1xuICAgIHJldHVybiBGcC5pc09kZChyb290KSA/IEZwLm5lZyhyb290KSA6IHJvb3Q7XG59XG4vKipcbiAqIFwiQ29uc3RhbnQtdGltZVwiIHByaXZhdGUga2V5IGdlbmVyYXRpb24gdXRpbGl0eS5cbiAqIFNhbWUgYXMgbWFwS2V5VG9GaWVsZCwgYnV0IGFjY2VwdHMgbGVzcyBieXRlcyAoNDAgaW5zdGVhZCBvZiA0OCBmb3IgMzItYnl0ZSBmaWVsZCkuXG4gKiBXaGljaCBtYWtlcyBpdCBzbGlnaHRseSBtb3JlIGJpYXNlZCwgbGVzcyBzZWN1cmUuXG4gKiBAZGVwcmVjYXRlZCB1c2UgYG1hcEtleVRvRmllbGRgIGluc3RlYWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2hUb1ByaXZhdGVTY2FsYXIoaGFzaCwgZ3JvdXBPcmRlciwgaXNMRSA9IGZhbHNlKSB7XG4gICAgaGFzaCA9IGVuc3VyZUJ5dGVzKCdwcml2YXRlSGFzaCcsIGhhc2gpO1xuICAgIGNvbnN0IGhhc2hMZW4gPSBoYXNoLmxlbmd0aDtcbiAgICBjb25zdCBtaW5MZW4gPSBuTGVuZ3RoKGdyb3VwT3JkZXIpLm5CeXRlTGVuZ3RoICsgODtcbiAgICBpZiAobWluTGVuIDwgMjQgfHwgaGFzaExlbiA8IG1pbkxlbiB8fCBoYXNoTGVuID4gMTAyNClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoYXNoVG9Qcml2YXRlU2NhbGFyOiBleHBlY3RlZCAnICsgbWluTGVuICsgJy0xMDI0IGJ5dGVzIG9mIGlucHV0LCBnb3QgJyArIGhhc2hMZW4pO1xuICAgIGNvbnN0IG51bSA9IGlzTEUgPyBieXRlc1RvTnVtYmVyTEUoaGFzaCkgOiBieXRlc1RvTnVtYmVyQkUoaGFzaCk7XG4gICAgcmV0dXJuIG1vZChudW0sIGdyb3VwT3JkZXIgLSBfMW4pICsgXzFuO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRvdGFsIG51bWJlciBvZiBieXRlcyBjb25zdW1lZCBieSB0aGUgZmllbGQgZWxlbWVudC5cbiAqIEZvciBleGFtcGxlLCAzMiBieXRlcyBmb3IgdXN1YWwgMjU2LWJpdCB3ZWllcnN0cmFzcyBjdXJ2ZS5cbiAqIEBwYXJhbSBmaWVsZE9yZGVyIG51bWJlciBvZiBmaWVsZCBlbGVtZW50cywgdXN1YWxseSBDVVJWRS5uXG4gKiBAcmV0dXJucyBieXRlIGxlbmd0aCBvZiBmaWVsZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmllbGRCeXRlc0xlbmd0aChmaWVsZE9yZGVyKSB7XG4gICAgaWYgKHR5cGVvZiBmaWVsZE9yZGVyICE9PSAnYmlnaW50JylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaWVsZCBvcmRlciBtdXN0IGJlIGJpZ2ludCcpO1xuICAgIGNvbnN0IGJpdExlbmd0aCA9IGZpZWxkT3JkZXIudG9TdHJpbmcoMikubGVuZ3RoO1xuICAgIHJldHVybiBNYXRoLmNlaWwoYml0TGVuZ3RoIC8gOCk7XG59XG4vKipcbiAqIFJldHVybnMgbWluaW1hbCBhbW91bnQgb2YgYnl0ZXMgdGhhdCBjYW4gYmUgc2FmZWx5IHJlZHVjZWRcbiAqIGJ5IGZpZWxkIG9yZGVyLlxuICogU2hvdWxkIGJlIDJeLTEyOCBmb3IgMTI4LWJpdCBjdXJ2ZSBzdWNoIGFzIFAyNTYuXG4gKiBAcGFyYW0gZmllbGRPcmRlciBudW1iZXIgb2YgZmllbGQgZWxlbWVudHMsIHVzdWFsbHkgQ1VSVkUublxuICogQHJldHVybnMgYnl0ZSBsZW5ndGggb2YgdGFyZ2V0IGhhc2hcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE1pbkhhc2hMZW5ndGgoZmllbGRPcmRlcikge1xuICAgIGNvbnN0IGxlbmd0aCA9IGdldEZpZWxkQnl0ZXNMZW5ndGgoZmllbGRPcmRlcik7XG4gICAgcmV0dXJuIGxlbmd0aCArIE1hdGguY2VpbChsZW5ndGggLyAyKTtcbn1cbi8qKlxuICogXCJDb25zdGFudC10aW1lXCIgcHJpdmF0ZSBrZXkgZ2VuZXJhdGlvbiB1dGlsaXR5LlxuICogQ2FuIHRha2UgKG4gKyBuLzIpIG9yIG1vcmUgYnl0ZXMgb2YgdW5pZm9ybSBpbnB1dCBlLmcuIGZyb20gQ1NQUk5HIG9yIEtERlxuICogYW5kIGNvbnZlcnQgdGhlbSBpbnRvIHByaXZhdGUgc2NhbGFyLCB3aXRoIHRoZSBtb2R1bG8gYmlhcyBiZWluZyBuZWdsaWdpYmxlLlxuICogTmVlZHMgYXQgbGVhc3QgNDggYnl0ZXMgb2YgaW5wdXQgZm9yIDMyLWJ5dGUgcHJpdmF0ZSBrZXkuXG4gKiBodHRwczovL3Jlc2VhcmNoLmt1ZGVsc2tpc2VjdXJpdHkuY29tLzIwMjAvMDcvMjgvdGhlLWRlZmluaXRpdmUtZ3VpZGUtdG8tbW9kdWxvLWJpYXMtYW5kLWhvdy10by1hdm9pZC1pdC9cbiAqIEZJUFMgMTg2LTUsIEEuMiBodHRwczovL2NzcmMubmlzdC5nb3YvcHVibGljYXRpb25zL2RldGFpbC9maXBzLzE4Ni81L2ZpbmFsXG4gKiBSRkMgOTM4MCwgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01XG4gKiBAcGFyYW0gaGFzaCBoYXNoIG91dHB1dCBmcm9tIFNIQTMgb3IgYSBzaW1pbGFyIGZ1bmN0aW9uXG4gKiBAcGFyYW0gZ3JvdXBPcmRlciBzaXplIG9mIHN1Ymdyb3VwIC0gKGUuZy4gc2VjcDI1NmsxLkNVUlZFLm4pXG4gKiBAcGFyYW0gaXNMRSBpbnRlcnByZXQgaGFzaCBieXRlcyBhcyBMRSBudW1cbiAqIEByZXR1cm5zIHZhbGlkIHByaXZhdGUgc2NhbGFyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBIYXNoVG9GaWVsZChrZXksIGZpZWxkT3JkZXIsIGlzTEUgPSBmYWxzZSkge1xuICAgIGNvbnN0IGxlbiA9IGtleS5sZW5ndGg7XG4gICAgY29uc3QgZmllbGRMZW4gPSBnZXRGaWVsZEJ5dGVzTGVuZ3RoKGZpZWxkT3JkZXIpO1xuICAgIGNvbnN0IG1pbkxlbiA9IGdldE1pbkhhc2hMZW5ndGgoZmllbGRPcmRlcik7XG4gICAgLy8gTm8gc21hbGwgbnVtYmVyczogbmVlZCB0byB1bmRlcnN0YW5kIGJpYXMgc3RvcnkuIE5vIGh1Z2UgbnVtYmVyczogZWFzaWVyIHRvIGRldGVjdCBKUyB0aW1pbmdzLlxuICAgIGlmIChsZW4gPCAxNiB8fCBsZW4gPCBtaW5MZW4gfHwgbGVuID4gMTAyNClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCAnICsgbWluTGVuICsgJy0xMDI0IGJ5dGVzIG9mIGlucHV0LCBnb3QgJyArIGxlbik7XG4gICAgY29uc3QgbnVtID0gaXNMRSA/IGJ5dGVzVG9OdW1iZXJMRShrZXkpIDogYnl0ZXNUb051bWJlckJFKGtleSk7XG4gICAgLy8gYG1vZCh4LCAxMSlgIGNhbiBzb21ldGltZXMgcHJvZHVjZSAwLiBgbW9kKHgsIDEwKSArIDFgIGlzIHRoZSBzYW1lLCBidXQgbm8gMFxuICAgIGNvbnN0IHJlZHVjZWQgPSBtb2QobnVtLCBmaWVsZE9yZGVyIC0gXzFuKSArIF8xbjtcbiAgICByZXR1cm4gaXNMRSA/IG51bWJlclRvQnl0ZXNMRShyZWR1Y2VkLCBmaWVsZExlbikgOiBudW1iZXJUb0J5dGVzQkUocmVkdWNlZCwgZmllbGRMZW4pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxhci5qcy5tYXAiXSwibmFtZXMiOlsiX3ZhbGlkYXRlT2JqZWN0IiwiYW51bWJlciIsImJpdE1hc2siLCJieXRlc1RvTnVtYmVyQkUiLCJieXRlc1RvTnVtYmVyTEUiLCJlbnN1cmVCeXRlcyIsIm51bWJlclRvQnl0ZXNCRSIsIm51bWJlclRvQnl0ZXNMRSIsIl8wbiIsIkJpZ0ludCIsIl8xbiIsIl8ybiIsIl8zbiIsIl80biIsIl81biIsIl83biIsIl84biIsIl85biIsIl8xNm4iLCJtb2QiLCJhIiwiYiIsInJlc3VsdCIsInBvdyIsIm51bSIsInBvd2VyIiwibW9kdWxvIiwiRnBQb3ciLCJGaWVsZCIsInBvdzIiLCJ4IiwicmVzIiwiaW52ZXJ0IiwibnVtYmVyIiwiRXJyb3IiLCJ5IiwidSIsInYiLCJxIiwiciIsIm0iLCJuIiwiZ2NkIiwiYXNzZXJ0SXNTcXVhcmUiLCJGcCIsInJvb3QiLCJlcWwiLCJzcXIiLCJzcXJ0M21vZDQiLCJwMWRpdjQiLCJPUkRFUiIsInNxcnQ1bW9kOCIsInA1ZGl2OCIsIm4yIiwibXVsIiwibnYiLCJpIiwic3ViIiwiT05FIiwic3FydDltb2QxNiIsIlAiLCJGcF8iLCJ0biIsInRvbmVsbGlTaGFua3MiLCJjMSIsIm5lZyIsImMyIiwiYzMiLCJjNCIsInR2MSIsInR2MiIsInR2MyIsInR2NCIsImUxIiwiZTIiLCJjbW92IiwiZTMiLCJRIiwiUyIsIloiLCJfRnAiLCJGcExlZ2VuZHJlIiwiY2MiLCJRMWRpdjIiLCJ0b25lbGxpU2xvdyIsImlzMCIsIk0iLCJjIiwidCIsIlIiLCJaRVJPIiwidF90bXAiLCJleHBvbmVudCIsIkZwU3FydCIsImlzTmVnYXRpdmVMRSIsIkZJRUxEX0ZJRUxEUyIsInZhbGlkYXRlRmllbGQiLCJmaWVsZCIsImluaXRpYWwiLCJNQVNLIiwiQllURVMiLCJCSVRTIiwib3B0cyIsInJlZHVjZSIsIm1hcCIsInZhbCIsInAiLCJkIiwiRnBJbnZlcnRCYXRjaCIsIm51bXMiLCJwYXNzWmVybyIsImludmVydGVkIiwiQXJyYXkiLCJsZW5ndGgiLCJmaWxsIiwidW5kZWZpbmVkIiwibXVsdGlwbGllZEFjYyIsImFjYyIsImludmVydGVkQWNjIiwiaW52IiwicmVkdWNlUmlnaHQiLCJGcERpdiIsImxocyIsInJocyIsInAxbW9kMiIsInBvd2VyZWQiLCJ5ZXMiLCJ6ZXJvIiwibm8iLCJGcElzU3F1YXJlIiwibCIsIm5MZW5ndGgiLCJuQml0TGVuZ3RoIiwiX25CaXRMZW5ndGgiLCJ0b1N0cmluZyIsIm5CeXRlTGVuZ3RoIiwiTWF0aCIsImNlaWwiLCJiaXRMZW5Pck9wdHMiLCJpc0xFIiwiX25iaXRMZW5ndGgiLCJfc3FydCIsIm1vZEZyb21CeXRlcyIsImFsbG93ZWRMZW5ndGhzIiwic3FydCIsIl9vcHRzIiwic3FydFAiLCJmIiwiT2JqZWN0IiwiZnJlZXplIiwiY3JlYXRlIiwiaXNWYWxpZCIsImlzVmFsaWROb3QwIiwiaXNPZGQiLCJhZGQiLCJkaXYiLCJzcXJOIiwiYWRkTiIsInN1Yk4iLCJtdWxOIiwidG9CeXRlcyIsImZyb21CeXRlcyIsImJ5dGVzIiwic2tpcFZhbGlkYXRpb24iLCJpbmNsdWRlcyIsInBhZGRlZCIsIlVpbnQ4QXJyYXkiLCJzZXQiLCJzY2FsYXIiLCJpbnZlcnRCYXRjaCIsImxzdCIsIkZwU3FydE9kZCIsImVsbSIsIkZwU3FydEV2ZW4iLCJoYXNoVG9Qcml2YXRlU2NhbGFyIiwiaGFzaCIsImdyb3VwT3JkZXIiLCJoYXNoTGVuIiwibWluTGVuIiwiZ2V0RmllbGRCeXRlc0xlbmd0aCIsImZpZWxkT3JkZXIiLCJiaXRMZW5ndGgiLCJnZXRNaW5IYXNoTGVuZ3RoIiwibWFwSGFzaFRvRmllbGQiLCJrZXkiLCJsZW4iLCJmaWVsZExlbiIsInJlZHVjZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/modular.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/montgomery.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/montgomery.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   montgomery: () => (/* binding */ montgomery)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/utils.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/modular.js\");\n/**\n * Montgomery curve methods. It's not really whole montgomery curve,\n * just bunch of very specific methods for X25519 / X448 from\n * [RFC 7748](https://www.rfc-editor.org/rfc/rfc7748)\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nfunction validateOpts(curve) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._validateObject)(curve, {\n        adjustScalarBytes: \"function\",\n        powPminus2: \"function\"\n    });\n    return Object.freeze({\n        ...curve\n    });\n}\nfunction montgomery(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { P, type, adjustScalarBytes, powPminus2, randomBytes: rand } = CURVE;\n    const is25519 = type === \"x25519\";\n    if (!is25519 && type !== \"x448\") throw new Error(\"invalid type\");\n    const randomBytes_ = rand || _utils_js__WEBPACK_IMPORTED_MODULE_1__.randomBytes;\n    const montgomeryBits = is25519 ? 255 : 448;\n    const fieldLen = is25519 ? 32 : 56;\n    const Gu = is25519 ? BigInt(9) : BigInt(5);\n    // RFC 7748 #5:\n    // The constant a24 is (486662 - 2) / 4 = 121665 for curve25519/X25519 and\n    // (156326 - 2) / 4 = 39081 for curve448/X448\n    // const a = is25519 ? 156326n : 486662n;\n    const a24 = is25519 ? BigInt(121665) : BigInt(39081);\n    // RFC: x25519 \"the resulting integer is of the form 2^254 plus\n    // eight times a value between 0 and 2^251 - 1 (inclusive)\"\n    // x448: \"2^447 plus four times a value between 0 and 2^445 - 1 (inclusive)\"\n    const minScalar = is25519 ? _2n ** BigInt(254) : _2n ** BigInt(447);\n    const maxAdded = is25519 ? BigInt(8) * _2n ** BigInt(251) - _1n : BigInt(4) * _2n ** BigInt(445) - _1n;\n    const maxScalar = minScalar + maxAdded + _1n; // (inclusive)\n    const modP = (n)=>(0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.mod)(n, P);\n    const GuBytes = encodeU(Gu);\n    function encodeU(u) {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(modP(u), fieldLen);\n    }\n    function decodeU(u) {\n        const _u = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"u coordinate\", u, fieldLen);\n        // RFC: When receiving such an array, implementations of X25519\n        // (but not X448) MUST mask the most significant bit in the final byte.\n        if (is25519) _u[31] &= 127; // 0b0111_1111\n        // RFC: Implementations MUST accept non-canonical values and process them as\n        // if they had been reduced modulo the field prime.  The non-canonical\n        // values are 2^255 - 19 through 2^255 - 1 for X25519 and 2^448 - 2^224\n        // - 1 through 2^448 - 1 for X448.\n        return modP((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(_u));\n    }\n    function decodeScalar(scalar) {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(adjustScalarBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"scalar\", scalar, fieldLen)));\n    }\n    function scalarMult(scalar, u) {\n        const pu = montgomeryLadder(decodeU(u), decodeScalar(scalar));\n        // Some public keys are useless, of low-order. Curve author doesn't think\n        // it needs to be validated, but we do it nonetheless.\n        // https://cr.yp.to/ecdh.html#validate\n        if (pu === _0n) throw new Error(\"invalid private or public key received\");\n        return encodeU(pu);\n    }\n    // Computes public key from private. By doing scalar multiplication of base point.\n    function scalarMultBase(scalar) {\n        return scalarMult(scalar, GuBytes);\n    }\n    // cswap from RFC7748 \"example code\"\n    function cswap(swap, x_2, x_3) {\n        // dummy = mask(swap) AND (x_2 XOR x_3)\n        // Where mask(swap) is the all-1 or all-0 word of the same length as x_2\n        // and x_3, computed, e.g., as mask(swap) = 0 - swap.\n        const dummy = modP(swap * (x_2 - x_3));\n        x_2 = modP(x_2 - dummy); // x_2 = x_2 XOR dummy\n        x_3 = modP(x_3 + dummy); // x_3 = x_3 XOR dummy\n        return {\n            x_2,\n            x_3\n        };\n    }\n    /**\n     * Montgomery x-only multiplication ladder.\n     * @param pointU u coordinate (x) on Montgomery Curve 25519\n     * @param scalar by which the point would be multiplied\n     * @returns new Point on Montgomery curve\n     */ function montgomeryLadder(u, scalar) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange)(\"u\", u, _0n, P);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange)(\"scalar\", scalar, minScalar, maxScalar);\n        const k = scalar;\n        const x_1 = u;\n        let x_2 = _1n;\n        let z_2 = _0n;\n        let x_3 = u;\n        let z_3 = _1n;\n        let swap = _0n;\n        for(let t = BigInt(montgomeryBits - 1); t >= _0n; t--){\n            const k_t = k >> t & _1n;\n            swap ^= k_t;\n            ({ x_2, x_3 } = cswap(swap, x_2, x_3));\n            ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));\n            swap = k_t;\n            const A = x_2 + z_2;\n            const AA = modP(A * A);\n            const B = x_2 - z_2;\n            const BB = modP(B * B);\n            const E = AA - BB;\n            const C = x_3 + z_3;\n            const D = x_3 - z_3;\n            const DA = modP(D * A);\n            const CB = modP(C * B);\n            const dacb = DA + CB;\n            const da_cb = DA - CB;\n            x_3 = modP(dacb * dacb);\n            z_3 = modP(x_1 * modP(da_cb * da_cb));\n            x_2 = modP(AA * BB);\n            z_2 = modP(E * (AA + modP(a24 * E)));\n        }\n        ({ x_2, x_3 } = cswap(swap, x_2, x_3));\n        ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));\n        const z2 = powPminus2(z_2); // `Fp.pow(x, P - _2n)` is much slower equivalent\n        return modP(x_2 * z2); // Return x_2 * (z_2^(p - 2))\n    }\n    const lengths = {\n        secretKey: fieldLen,\n        publicKey: fieldLen,\n        seed: fieldLen\n    };\n    const randomSecretKey = (seed = randomBytes_(fieldLen))=>{\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.abytes)(seed, lengths.seed);\n        return seed;\n    };\n    function keygen(seed) {\n        const secretKey = randomSecretKey(seed);\n        return {\n            secretKey,\n            publicKey: scalarMultBase(secretKey)\n        };\n    }\n    const utils = {\n        randomSecretKey,\n        randomPrivateKey: randomSecretKey\n    };\n    return {\n        keygen,\n        getSharedSecret: (secretKey, publicKey)=>scalarMult(secretKey, publicKey),\n        getPublicKey: (secretKey)=>scalarMultBase(secretKey),\n        scalarMult,\n        scalarMultBase,\n        utils,\n        GuBytes: GuBytes.slice(),\n        lengths\n    };\n} //# sourceMappingURL=montgomery.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9tb250Z29tZXJ5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7Ozs7Q0FLQyxHQUNELG9FQUFvRSxHQUN5RDtBQUMxRjtBQUNuQyxNQUFNUSxNQUFNQyxPQUFPO0FBQ25CLE1BQU1DLE1BQU1ELE9BQU87QUFDbkIsTUFBTUUsTUFBTUYsT0FBTztBQUNuQixTQUFTRyxhQUFhQyxLQUFLO0lBQ3ZCYiwwREFBZUEsQ0FBQ2EsT0FBTztRQUNuQkMsbUJBQW1CO1FBQ25CQyxZQUFZO0lBQ2hCO0lBQ0EsT0FBT0MsT0FBT0MsTUFBTSxDQUFDO1FBQUUsR0FBR0osS0FBSztJQUFDO0FBQ3BDO0FBQ08sU0FBU0ssV0FBV0MsUUFBUTtJQUMvQixNQUFNQyxRQUFRUixhQUFhTztJQUMzQixNQUFNLEVBQUVFLENBQUMsRUFBRUMsSUFBSSxFQUFFUixpQkFBaUIsRUFBRUMsVUFBVSxFQUFFVCxhQUFhaUIsSUFBSSxFQUFFLEdBQUdIO0lBQ3RFLE1BQU1JLFVBQVVGLFNBQVM7SUFDekIsSUFBSSxDQUFDRSxXQUFXRixTQUFTLFFBQ3JCLE1BQU0sSUFBSUcsTUFBTTtJQUNwQixNQUFNQyxlQUFlSCxRQUFRakIsa0RBQVdBO0lBQ3hDLE1BQU1xQixpQkFBaUJILFVBQVUsTUFBTTtJQUN2QyxNQUFNSSxXQUFXSixVQUFVLEtBQUs7SUFDaEMsTUFBTUssS0FBS0wsVUFBVWYsT0FBTyxLQUFLQSxPQUFPO0lBQ3hDLGVBQWU7SUFDZiwwRUFBMEU7SUFDMUUsNkNBQTZDO0lBQzdDLHlDQUF5QztJQUN6QyxNQUFNcUIsTUFBTU4sVUFBVWYsT0FBTyxVQUFVQSxPQUFPO0lBQzlDLCtEQUErRDtJQUMvRCwyREFBMkQ7SUFDM0QsNEVBQTRFO0lBQzVFLE1BQU1zQixZQUFZUCxVQUFVYixPQUFPRixPQUFPLE9BQU9FLE9BQU9GLE9BQU87SUFDL0QsTUFBTXVCLFdBQVdSLFVBQ1hmLE9BQU8sS0FBS0UsT0FBT0YsT0FBTyxPQUFPQyxNQUNqQ0QsT0FBTyxLQUFLRSxPQUFPRixPQUFPLE9BQU9DO0lBQ3ZDLE1BQU11QixZQUFZRixZQUFZQyxXQUFXdEIsS0FBSyxjQUFjO0lBQzVELE1BQU13QixPQUFPLENBQUNDLElBQU01QixnREFBR0EsQ0FBQzRCLEdBQUdkO0lBQzNCLE1BQU1lLFVBQVVDLFFBQVFSO0lBQ3hCLFNBQVNRLFFBQVFDLENBQUM7UUFDZCxPQUFPakMsMERBQWVBLENBQUM2QixLQUFLSSxJQUFJVjtJQUNwQztJQUNBLFNBQVNXLFFBQVFELENBQUM7UUFDZCxNQUFNRSxLQUFLcEMsc0RBQVdBLENBQUMsZ0JBQWdCa0MsR0FBR1Y7UUFDMUMsK0RBQStEO1FBQy9ELHVFQUF1RTtRQUN2RSxJQUFJSixTQUNBZ0IsRUFBRSxDQUFDLEdBQUcsSUFBSSxLQUFLLGNBQWM7UUFDakMsNEVBQTRFO1FBQzVFLHNFQUFzRTtRQUN0RSx1RUFBdUU7UUFDdkUsa0NBQWtDO1FBQ2xDLE9BQU9OLEtBQUsvQiwwREFBZUEsQ0FBQ3FDO0lBQ2hDO0lBQ0EsU0FBU0MsYUFBYUMsTUFBTTtRQUN4QixPQUFPdkMsMERBQWVBLENBQUNXLGtCQUFrQlYsc0RBQVdBLENBQUMsVUFBVXNDLFFBQVFkO0lBQzNFO0lBQ0EsU0FBU2UsV0FBV0QsTUFBTSxFQUFFSixDQUFDO1FBQ3pCLE1BQU1NLEtBQUtDLGlCQUFpQk4sUUFBUUQsSUFBSUcsYUFBYUM7UUFDckQseUVBQXlFO1FBQ3pFLHNEQUFzRDtRQUN0RCxzQ0FBc0M7UUFDdEMsSUFBSUUsT0FBT3BDLEtBQ1AsTUFBTSxJQUFJaUIsTUFBTTtRQUNwQixPQUFPWSxRQUFRTztJQUNuQjtJQUNBLGtGQUFrRjtJQUNsRixTQUFTRSxlQUFlSixNQUFNO1FBQzFCLE9BQU9DLFdBQVdELFFBQVFOO0lBQzlCO0lBQ0Esb0NBQW9DO0lBQ3BDLFNBQVNXLE1BQU1DLElBQUksRUFBRUMsR0FBRyxFQUFFQyxHQUFHO1FBQ3pCLHVDQUF1QztRQUN2Qyx3RUFBd0U7UUFDeEUscURBQXFEO1FBQ3JELE1BQU1DLFFBQVFqQixLQUFLYyxPQUFRQyxDQUFBQSxNQUFNQyxHQUFFO1FBQ25DRCxNQUFNZixLQUFLZSxNQUFNRSxRQUFRLHNCQUFzQjtRQUMvQ0QsTUFBTWhCLEtBQUtnQixNQUFNQyxRQUFRLHNCQUFzQjtRQUMvQyxPQUFPO1lBQUVGO1lBQUtDO1FBQUk7SUFDdEI7SUFDQTs7Ozs7S0FLQyxHQUNELFNBQVNMLGlCQUFpQlAsQ0FBQyxFQUFFSSxNQUFNO1FBQy9CeEMsbURBQVFBLENBQUMsS0FBS29DLEdBQUc5QixLQUFLYTtRQUN0Qm5CLG1EQUFRQSxDQUFDLFVBQVV3QyxRQUFRWCxXQUFXRTtRQUN0QyxNQUFNbUIsSUFBSVY7UUFDVixNQUFNVyxNQUFNZjtRQUNaLElBQUlXLE1BQU12QztRQUNWLElBQUk0QyxNQUFNOUM7UUFDVixJQUFJMEMsTUFBTVo7UUFDVixJQUFJaUIsTUFBTTdDO1FBQ1YsSUFBSXNDLE9BQU94QztRQUNYLElBQUssSUFBSWdELElBQUkvQyxPQUFPa0IsaUJBQWlCLElBQUk2QixLQUFLaEQsS0FBS2dELElBQUs7WUFDcEQsTUFBTUMsTUFBTSxLQUFNRCxJQUFLOUM7WUFDdkJzQyxRQUFRUztZQUNQLEdBQUVSLEdBQUcsRUFBRUMsR0FBRyxFQUFFLEdBQUdILE1BQU1DLE1BQU1DLEtBQUtDLElBQUc7WUFDbkMsR0FBRUQsS0FBS0ssR0FBRyxFQUFFSixLQUFLSyxHQUFHLEVBQUUsR0FBR1IsTUFBTUMsTUFBTU0sS0FBS0MsSUFBRztZQUM5Q1AsT0FBT1M7WUFDUCxNQUFNQyxJQUFJVCxNQUFNSztZQUNoQixNQUFNSyxLQUFLekIsS0FBS3dCLElBQUlBO1lBQ3BCLE1BQU1FLElBQUlYLE1BQU1LO1lBQ2hCLE1BQU1PLEtBQUszQixLQUFLMEIsSUFBSUE7WUFDcEIsTUFBTUUsSUFBSUgsS0FBS0U7WUFDZixNQUFNRSxJQUFJYixNQUFNSztZQUNoQixNQUFNUyxJQUFJZCxNQUFNSztZQUNoQixNQUFNVSxLQUFLL0IsS0FBSzhCLElBQUlOO1lBQ3BCLE1BQU1RLEtBQUtoQyxLQUFLNkIsSUFBSUg7WUFDcEIsTUFBTU8sT0FBT0YsS0FBS0M7WUFDbEIsTUFBTUUsUUFBUUgsS0FBS0M7WUFDbkJoQixNQUFNaEIsS0FBS2lDLE9BQU9BO1lBQ2xCWixNQUFNckIsS0FBS21CLE1BQU1uQixLQUFLa0MsUUFBUUE7WUFDOUJuQixNQUFNZixLQUFLeUIsS0FBS0U7WUFDaEJQLE1BQU1wQixLQUFLNEIsSUFBS0gsQ0FBQUEsS0FBS3pCLEtBQUtKLE1BQU1nQyxFQUFDO1FBQ3JDO1FBQ0MsR0FBRWIsR0FBRyxFQUFFQyxHQUFHLEVBQUUsR0FBR0gsTUFBTUMsTUFBTUMsS0FBS0MsSUFBRztRQUNuQyxHQUFFRCxLQUFLSyxHQUFHLEVBQUVKLEtBQUtLLEdBQUcsRUFBRSxHQUFHUixNQUFNQyxNQUFNTSxLQUFLQyxJQUFHO1FBQzlDLE1BQU1jLEtBQUt0RCxXQUFXdUMsTUFBTSxpREFBaUQ7UUFDN0UsT0FBT3BCLEtBQUtlLE1BQU1vQixLQUFLLDZCQUE2QjtJQUN4RDtJQUNBLE1BQU1DLFVBQVU7UUFDWkMsV0FBVzNDO1FBQ1g0QyxXQUFXNUM7UUFDWDZDLE1BQU03QztJQUNWO0lBQ0EsTUFBTThDLGtCQUFrQixDQUFDRCxPQUFPL0MsYUFBYUUsU0FBUztRQUNsRDNCLGlEQUFNQSxDQUFDd0UsTUFBTUgsUUFBUUcsSUFBSTtRQUN6QixPQUFPQTtJQUNYO0lBQ0EsU0FBU0UsT0FBT0YsSUFBSTtRQUNoQixNQUFNRixZQUFZRyxnQkFBZ0JEO1FBQ2xDLE9BQU87WUFBRUY7WUFBV0MsV0FBVzFCLGVBQWV5QjtRQUFXO0lBQzdEO0lBQ0EsTUFBTUssUUFBUTtRQUNWRjtRQUNBRyxrQkFBa0JIO0lBQ3RCO0lBQ0EsT0FBTztRQUNIQztRQUNBRyxpQkFBaUIsQ0FBQ1AsV0FBV0MsWUFBYzdCLFdBQVc0QixXQUFXQztRQUNqRU8sY0FBYyxDQUFDUixZQUFjekIsZUFBZXlCO1FBQzVDNUI7UUFDQUc7UUFDQThCO1FBQ0F4QyxTQUFTQSxRQUFRNEMsS0FBSztRQUN0QlY7SUFDSjtBQUNKLEVBQ0Esc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xhdy13b3Jrcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dlYjMuanMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L21vbnRnb21lcnkuanM/NDZhMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE1vbnRnb21lcnkgY3VydmUgbWV0aG9kcy4gSXQncyBub3QgcmVhbGx5IHdob2xlIG1vbnRnb21lcnkgY3VydmUsXG4gKiBqdXN0IGJ1bmNoIG9mIHZlcnkgc3BlY2lmaWMgbWV0aG9kcyBmb3IgWDI1NTE5IC8gWDQ0OCBmcm9tXG4gKiBbUkZDIDc3NDhdKGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM3NzQ4KVxuICogQG1vZHVsZVxuICovXG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5pbXBvcnQgeyBfdmFsaWRhdGVPYmplY3QsIGFieXRlcywgYUluUmFuZ2UsIGJ5dGVzVG9OdW1iZXJMRSwgZW5zdXJlQnl0ZXMsIG51bWJlclRvQnl0ZXNMRSwgcmFuZG9tQnl0ZXMsIH0gZnJvbSBcIi4uL3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBtb2QgfSBmcm9tIFwiLi9tb2R1bGFyLmpzXCI7XG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSBCaWdJbnQoMSk7XG5jb25zdCBfMm4gPSBCaWdJbnQoMik7XG5mdW5jdGlvbiB2YWxpZGF0ZU9wdHMoY3VydmUpIHtcbiAgICBfdmFsaWRhdGVPYmplY3QoY3VydmUsIHtcbiAgICAgICAgYWRqdXN0U2NhbGFyQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgICAgIHBvd1BtaW51czI6ICdmdW5jdGlvbicsXG4gICAgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyAuLi5jdXJ2ZSB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBtb250Z29tZXJ5KGN1cnZlRGVmKSB7XG4gICAgY29uc3QgQ1VSVkUgPSB2YWxpZGF0ZU9wdHMoY3VydmVEZWYpO1xuICAgIGNvbnN0IHsgUCwgdHlwZSwgYWRqdXN0U2NhbGFyQnl0ZXMsIHBvd1BtaW51czIsIHJhbmRvbUJ5dGVzOiByYW5kIH0gPSBDVVJWRTtcbiAgICBjb25zdCBpczI1NTE5ID0gdHlwZSA9PT0gJ3gyNTUxOSc7XG4gICAgaWYgKCFpczI1NTE5ICYmIHR5cGUgIT09ICd4NDQ4JylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHR5cGUnKTtcbiAgICBjb25zdCByYW5kb21CeXRlc18gPSByYW5kIHx8IHJhbmRvbUJ5dGVzO1xuICAgIGNvbnN0IG1vbnRnb21lcnlCaXRzID0gaXMyNTUxOSA/IDI1NSA6IDQ0ODtcbiAgICBjb25zdCBmaWVsZExlbiA9IGlzMjU1MTkgPyAzMiA6IDU2O1xuICAgIGNvbnN0IEd1ID0gaXMyNTUxOSA/IEJpZ0ludCg5KSA6IEJpZ0ludCg1KTtcbiAgICAvLyBSRkMgNzc0OCAjNTpcbiAgICAvLyBUaGUgY29uc3RhbnQgYTI0IGlzICg0ODY2NjIgLSAyKSAvIDQgPSAxMjE2NjUgZm9yIGN1cnZlMjU1MTkvWDI1NTE5IGFuZFxuICAgIC8vICgxNTYzMjYgLSAyKSAvIDQgPSAzOTA4MSBmb3IgY3VydmU0NDgvWDQ0OFxuICAgIC8vIGNvbnN0IGEgPSBpczI1NTE5ID8gMTU2MzI2biA6IDQ4NjY2Mm47XG4gICAgY29uc3QgYTI0ID0gaXMyNTUxOSA/IEJpZ0ludCgxMjE2NjUpIDogQmlnSW50KDM5MDgxKTtcbiAgICAvLyBSRkM6IHgyNTUxOSBcInRoZSByZXN1bHRpbmcgaW50ZWdlciBpcyBvZiB0aGUgZm9ybSAyXjI1NCBwbHVzXG4gICAgLy8gZWlnaHQgdGltZXMgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDJeMjUxIC0gMSAoaW5jbHVzaXZlKVwiXG4gICAgLy8geDQ0ODogXCIyXjQ0NyBwbHVzIGZvdXIgdGltZXMgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDJeNDQ1IC0gMSAoaW5jbHVzaXZlKVwiXG4gICAgY29uc3QgbWluU2NhbGFyID0gaXMyNTUxOSA/IF8ybiAqKiBCaWdJbnQoMjU0KSA6IF8ybiAqKiBCaWdJbnQoNDQ3KTtcbiAgICBjb25zdCBtYXhBZGRlZCA9IGlzMjU1MTlcbiAgICAgICAgPyBCaWdJbnQoOCkgKiBfMm4gKiogQmlnSW50KDI1MSkgLSBfMW5cbiAgICAgICAgOiBCaWdJbnQoNCkgKiBfMm4gKiogQmlnSW50KDQ0NSkgLSBfMW47XG4gICAgY29uc3QgbWF4U2NhbGFyID0gbWluU2NhbGFyICsgbWF4QWRkZWQgKyBfMW47IC8vIChpbmNsdXNpdmUpXG4gICAgY29uc3QgbW9kUCA9IChuKSA9PiBtb2QobiwgUCk7XG4gICAgY29uc3QgR3VCeXRlcyA9IGVuY29kZVUoR3UpO1xuICAgIGZ1bmN0aW9uIGVuY29kZVUodSkge1xuICAgICAgICByZXR1cm4gbnVtYmVyVG9CeXRlc0xFKG1vZFAodSksIGZpZWxkTGVuKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVjb2RlVSh1KSB7XG4gICAgICAgIGNvbnN0IF91ID0gZW5zdXJlQnl0ZXMoJ3UgY29vcmRpbmF0ZScsIHUsIGZpZWxkTGVuKTtcbiAgICAgICAgLy8gUkZDOiBXaGVuIHJlY2VpdmluZyBzdWNoIGFuIGFycmF5LCBpbXBsZW1lbnRhdGlvbnMgb2YgWDI1NTE5XG4gICAgICAgIC8vIChidXQgbm90IFg0NDgpIE1VU1QgbWFzayB0aGUgbW9zdCBzaWduaWZpY2FudCBiaXQgaW4gdGhlIGZpbmFsIGJ5dGUuXG4gICAgICAgIGlmIChpczI1NTE5KVxuICAgICAgICAgICAgX3VbMzFdICY9IDEyNzsgLy8gMGIwMTExXzExMTFcbiAgICAgICAgLy8gUkZDOiBJbXBsZW1lbnRhdGlvbnMgTVVTVCBhY2NlcHQgbm9uLWNhbm9uaWNhbCB2YWx1ZXMgYW5kIHByb2Nlc3MgdGhlbSBhc1xuICAgICAgICAvLyBpZiB0aGV5IGhhZCBiZWVuIHJlZHVjZWQgbW9kdWxvIHRoZSBmaWVsZCBwcmltZS4gIFRoZSBub24tY2Fub25pY2FsXG4gICAgICAgIC8vIHZhbHVlcyBhcmUgMl4yNTUgLSAxOSB0aHJvdWdoIDJeMjU1IC0gMSBmb3IgWDI1NTE5IGFuZCAyXjQ0OCAtIDJeMjI0XG4gICAgICAgIC8vIC0gMSB0aHJvdWdoIDJeNDQ4IC0gMSBmb3IgWDQ0OC5cbiAgICAgICAgcmV0dXJuIG1vZFAoYnl0ZXNUb051bWJlckxFKF91KSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlY29kZVNjYWxhcihzY2FsYXIpIHtcbiAgICAgICAgcmV0dXJuIGJ5dGVzVG9OdW1iZXJMRShhZGp1c3RTY2FsYXJCeXRlcyhlbnN1cmVCeXRlcygnc2NhbGFyJywgc2NhbGFyLCBmaWVsZExlbikpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NhbGFyTXVsdChzY2FsYXIsIHUpIHtcbiAgICAgICAgY29uc3QgcHUgPSBtb250Z29tZXJ5TGFkZGVyKGRlY29kZVUodSksIGRlY29kZVNjYWxhcihzY2FsYXIpKTtcbiAgICAgICAgLy8gU29tZSBwdWJsaWMga2V5cyBhcmUgdXNlbGVzcywgb2YgbG93LW9yZGVyLiBDdXJ2ZSBhdXRob3IgZG9lc24ndCB0aGlua1xuICAgICAgICAvLyBpdCBuZWVkcyB0byBiZSB2YWxpZGF0ZWQsIGJ1dCB3ZSBkbyBpdCBub25ldGhlbGVzcy5cbiAgICAgICAgLy8gaHR0cHM6Ly9jci55cC50by9lY2RoLmh0bWwjdmFsaWRhdGVcbiAgICAgICAgaWYgKHB1ID09PSBfMG4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcHJpdmF0ZSBvciBwdWJsaWMga2V5IHJlY2VpdmVkJyk7XG4gICAgICAgIHJldHVybiBlbmNvZGVVKHB1KTtcbiAgICB9XG4gICAgLy8gQ29tcHV0ZXMgcHVibGljIGtleSBmcm9tIHByaXZhdGUuIEJ5IGRvaW5nIHNjYWxhciBtdWx0aXBsaWNhdGlvbiBvZiBiYXNlIHBvaW50LlxuICAgIGZ1bmN0aW9uIHNjYWxhck11bHRCYXNlKHNjYWxhcikge1xuICAgICAgICByZXR1cm4gc2NhbGFyTXVsdChzY2FsYXIsIEd1Qnl0ZXMpO1xuICAgIH1cbiAgICAvLyBjc3dhcCBmcm9tIFJGQzc3NDggXCJleGFtcGxlIGNvZGVcIlxuICAgIGZ1bmN0aW9uIGNzd2FwKHN3YXAsIHhfMiwgeF8zKSB7XG4gICAgICAgIC8vIGR1bW15ID0gbWFzayhzd2FwKSBBTkQgKHhfMiBYT1IgeF8zKVxuICAgICAgICAvLyBXaGVyZSBtYXNrKHN3YXApIGlzIHRoZSBhbGwtMSBvciBhbGwtMCB3b3JkIG9mIHRoZSBzYW1lIGxlbmd0aCBhcyB4XzJcbiAgICAgICAgLy8gYW5kIHhfMywgY29tcHV0ZWQsIGUuZy4sIGFzIG1hc2soc3dhcCkgPSAwIC0gc3dhcC5cbiAgICAgICAgY29uc3QgZHVtbXkgPSBtb2RQKHN3YXAgKiAoeF8yIC0geF8zKSk7XG4gICAgICAgIHhfMiA9IG1vZFAoeF8yIC0gZHVtbXkpOyAvLyB4XzIgPSB4XzIgWE9SIGR1bW15XG4gICAgICAgIHhfMyA9IG1vZFAoeF8zICsgZHVtbXkpOyAvLyB4XzMgPSB4XzMgWE9SIGR1bW15XG4gICAgICAgIHJldHVybiB7IHhfMiwgeF8zIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1vbnRnb21lcnkgeC1vbmx5IG11bHRpcGxpY2F0aW9uIGxhZGRlci5cbiAgICAgKiBAcGFyYW0gcG9pbnRVIHUgY29vcmRpbmF0ZSAoeCkgb24gTW9udGdvbWVyeSBDdXJ2ZSAyNTUxOVxuICAgICAqIEBwYXJhbSBzY2FsYXIgYnkgd2hpY2ggdGhlIHBvaW50IHdvdWxkIGJlIG11bHRpcGxpZWRcbiAgICAgKiBAcmV0dXJucyBuZXcgUG9pbnQgb24gTW9udGdvbWVyeSBjdXJ2ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1vbnRnb21lcnlMYWRkZXIodSwgc2NhbGFyKSB7XG4gICAgICAgIGFJblJhbmdlKCd1JywgdSwgXzBuLCBQKTtcbiAgICAgICAgYUluUmFuZ2UoJ3NjYWxhcicsIHNjYWxhciwgbWluU2NhbGFyLCBtYXhTY2FsYXIpO1xuICAgICAgICBjb25zdCBrID0gc2NhbGFyO1xuICAgICAgICBjb25zdCB4XzEgPSB1O1xuICAgICAgICBsZXQgeF8yID0gXzFuO1xuICAgICAgICBsZXQgel8yID0gXzBuO1xuICAgICAgICBsZXQgeF8zID0gdTtcbiAgICAgICAgbGV0IHpfMyA9IF8xbjtcbiAgICAgICAgbGV0IHN3YXAgPSBfMG47XG4gICAgICAgIGZvciAobGV0IHQgPSBCaWdJbnQobW9udGdvbWVyeUJpdHMgLSAxKTsgdCA+PSBfMG47IHQtLSkge1xuICAgICAgICAgICAgY29uc3Qga190ID0gKGsgPj4gdCkgJiBfMW47XG4gICAgICAgICAgICBzd2FwIF49IGtfdDtcbiAgICAgICAgICAgICh7IHhfMiwgeF8zIH0gPSBjc3dhcChzd2FwLCB4XzIsIHhfMykpO1xuICAgICAgICAgICAgKHsgeF8yOiB6XzIsIHhfMzogel8zIH0gPSBjc3dhcChzd2FwLCB6XzIsIHpfMykpO1xuICAgICAgICAgICAgc3dhcCA9IGtfdDtcbiAgICAgICAgICAgIGNvbnN0IEEgPSB4XzIgKyB6XzI7XG4gICAgICAgICAgICBjb25zdCBBQSA9IG1vZFAoQSAqIEEpO1xuICAgICAgICAgICAgY29uc3QgQiA9IHhfMiAtIHpfMjtcbiAgICAgICAgICAgIGNvbnN0IEJCID0gbW9kUChCICogQik7XG4gICAgICAgICAgICBjb25zdCBFID0gQUEgLSBCQjtcbiAgICAgICAgICAgIGNvbnN0IEMgPSB4XzMgKyB6XzM7XG4gICAgICAgICAgICBjb25zdCBEID0geF8zIC0gel8zO1xuICAgICAgICAgICAgY29uc3QgREEgPSBtb2RQKEQgKiBBKTtcbiAgICAgICAgICAgIGNvbnN0IENCID0gbW9kUChDICogQik7XG4gICAgICAgICAgICBjb25zdCBkYWNiID0gREEgKyBDQjtcbiAgICAgICAgICAgIGNvbnN0IGRhX2NiID0gREEgLSBDQjtcbiAgICAgICAgICAgIHhfMyA9IG1vZFAoZGFjYiAqIGRhY2IpO1xuICAgICAgICAgICAgel8zID0gbW9kUCh4XzEgKiBtb2RQKGRhX2NiICogZGFfY2IpKTtcbiAgICAgICAgICAgIHhfMiA9IG1vZFAoQUEgKiBCQik7XG4gICAgICAgICAgICB6XzIgPSBtb2RQKEUgKiAoQUEgKyBtb2RQKGEyNCAqIEUpKSk7XG4gICAgICAgIH1cbiAgICAgICAgKHsgeF8yLCB4XzMgfSA9IGNzd2FwKHN3YXAsIHhfMiwgeF8zKSk7XG4gICAgICAgICh7IHhfMjogel8yLCB4XzM6IHpfMyB9ID0gY3N3YXAoc3dhcCwgel8yLCB6XzMpKTtcbiAgICAgICAgY29uc3QgejIgPSBwb3dQbWludXMyKHpfMik7IC8vIGBGcC5wb3coeCwgUCAtIF8ybilgIGlzIG11Y2ggc2xvd2VyIGVxdWl2YWxlbnRcbiAgICAgICAgcmV0dXJuIG1vZFAoeF8yICogejIpOyAvLyBSZXR1cm4geF8yICogKHpfMl4ocCAtIDIpKVxuICAgIH1cbiAgICBjb25zdCBsZW5ndGhzID0ge1xuICAgICAgICBzZWNyZXRLZXk6IGZpZWxkTGVuLFxuICAgICAgICBwdWJsaWNLZXk6IGZpZWxkTGVuLFxuICAgICAgICBzZWVkOiBmaWVsZExlbixcbiAgICB9O1xuICAgIGNvbnN0IHJhbmRvbVNlY3JldEtleSA9IChzZWVkID0gcmFuZG9tQnl0ZXNfKGZpZWxkTGVuKSkgPT4ge1xuICAgICAgICBhYnl0ZXMoc2VlZCwgbGVuZ3Rocy5zZWVkKTtcbiAgICAgICAgcmV0dXJuIHNlZWQ7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBrZXlnZW4oc2VlZCkge1xuICAgICAgICBjb25zdCBzZWNyZXRLZXkgPSByYW5kb21TZWNyZXRLZXkoc2VlZCk7XG4gICAgICAgIHJldHVybiB7IHNlY3JldEtleSwgcHVibGljS2V5OiBzY2FsYXJNdWx0QmFzZShzZWNyZXRLZXkpIH07XG4gICAgfVxuICAgIGNvbnN0IHV0aWxzID0ge1xuICAgICAgICByYW5kb21TZWNyZXRLZXksXG4gICAgICAgIHJhbmRvbVByaXZhdGVLZXk6IHJhbmRvbVNlY3JldEtleSxcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIGtleWdlbixcbiAgICAgICAgZ2V0U2hhcmVkU2VjcmV0OiAoc2VjcmV0S2V5LCBwdWJsaWNLZXkpID0+IHNjYWxhck11bHQoc2VjcmV0S2V5LCBwdWJsaWNLZXkpLFxuICAgICAgICBnZXRQdWJsaWNLZXk6IChzZWNyZXRLZXkpID0+IHNjYWxhck11bHRCYXNlKHNlY3JldEtleSksXG4gICAgICAgIHNjYWxhck11bHQsXG4gICAgICAgIHNjYWxhck11bHRCYXNlLFxuICAgICAgICB1dGlscyxcbiAgICAgICAgR3VCeXRlczogR3VCeXRlcy5zbGljZSgpLFxuICAgICAgICBsZW5ndGhzLFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb250Z29tZXJ5LmpzLm1hcCJdLCJuYW1lcyI6WyJfdmFsaWRhdGVPYmplY3QiLCJhYnl0ZXMiLCJhSW5SYW5nZSIsImJ5dGVzVG9OdW1iZXJMRSIsImVuc3VyZUJ5dGVzIiwibnVtYmVyVG9CeXRlc0xFIiwicmFuZG9tQnl0ZXMiLCJtb2QiLCJfMG4iLCJCaWdJbnQiLCJfMW4iLCJfMm4iLCJ2YWxpZGF0ZU9wdHMiLCJjdXJ2ZSIsImFkanVzdFNjYWxhckJ5dGVzIiwicG93UG1pbnVzMiIsIk9iamVjdCIsImZyZWV6ZSIsIm1vbnRnb21lcnkiLCJjdXJ2ZURlZiIsIkNVUlZFIiwiUCIsInR5cGUiLCJyYW5kIiwiaXMyNTUxOSIsIkVycm9yIiwicmFuZG9tQnl0ZXNfIiwibW9udGdvbWVyeUJpdHMiLCJmaWVsZExlbiIsIkd1IiwiYTI0IiwibWluU2NhbGFyIiwibWF4QWRkZWQiLCJtYXhTY2FsYXIiLCJtb2RQIiwibiIsIkd1Qnl0ZXMiLCJlbmNvZGVVIiwidSIsImRlY29kZVUiLCJfdSIsImRlY29kZVNjYWxhciIsInNjYWxhciIsInNjYWxhck11bHQiLCJwdSIsIm1vbnRnb21lcnlMYWRkZXIiLCJzY2FsYXJNdWx0QmFzZSIsImNzd2FwIiwic3dhcCIsInhfMiIsInhfMyIsImR1bW15IiwiayIsInhfMSIsInpfMiIsInpfMyIsInQiLCJrX3QiLCJBIiwiQUEiLCJCIiwiQkIiLCJFIiwiQyIsIkQiLCJEQSIsIkNCIiwiZGFjYiIsImRhX2NiIiwiejIiLCJsZW5ndGhzIiwic2VjcmV0S2V5IiwicHVibGljS2V5Iiwic2VlZCIsInJhbmRvbVNlY3JldEtleSIsImtleWdlbiIsInV0aWxzIiwicmFuZG9tUHJpdmF0ZUtleSIsImdldFNoYXJlZFNlY3JldCIsImdldFB1YmxpY0tleSIsInNsaWNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/montgomery.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/weierstrass.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/weierstrass.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DER: () => (/* binding */ DER),\n/* harmony export */   DERErr: () => (/* binding */ DERErr),\n/* harmony export */   SWUFpSqrtRatio: () => (/* binding */ SWUFpSqrtRatio),\n/* harmony export */   _legacyHelperEquat: () => (/* binding */ _legacyHelperEquat),\n/* harmony export */   _normFnElement: () => (/* binding */ _normFnElement),\n/* harmony export */   _splitEndoScalar: () => (/* binding */ _splitEndoScalar),\n/* harmony export */   ecdh: () => (/* binding */ ecdh),\n/* harmony export */   ecdsa: () => (/* binding */ ecdsa),\n/* harmony export */   mapToCurveSimpleSWU: () => (/* binding */ mapToCurveSimpleSWU),\n/* harmony export */   weierstrass: () => (/* binding */ weierstrass),\n/* harmony export */   weierstrassN: () => (/* binding */ weierstrassN),\n/* harmony export */   weierstrassPoints: () => (/* binding */ weierstrassPoints)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_hmac_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/hmac.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/utils.js\");\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/curve.js\");\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/modular.js\");\n/**\n * Short Weierstrass curve methods. The formula is: y = x + ax + b.\n *\n * ### Design rationale for types\n *\n * * Interaction between classes from different curves should fail:\n *   `k256.Point.BASE.add(p256.Point.BASE)`\n * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime\n * * Different calls of `curve()` would return different classes -\n *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,\n *   it won't affect others\n *\n * TypeScript can't infer types for classes created inside a function. Classes is one instance\n * of nominative types in TypeScript and interfaces only check for shape, so it's hard to create\n * unique type for every function call.\n *\n * We can use generic types via some param, like curve opts, but that would:\n *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)\n *     which is hard to debug.\n *     2. Params can be generic and we can't enforce them to be constant value:\n *     if somebody creates curve from non-constant params,\n *     it would be allowed to interact with other curves with non-constant params\n *\n * @todo https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\n\n\n\n// We construct basis in such way that den is always positive and equals n, but num sign depends on basis (not on secret value)\nconst divNearest = (num, den)=>(num + (num >= 0 ? den : -den) / _2n) / den;\n/**\n * Splits scalar for GLV endomorphism.\n */ function _splitEndoScalar(k, basis, n) {\n    // Split scalar into two such that part is ~half bits: `abs(part) < sqrt(N)`\n    // Since part can be negative, we need to do this on point.\n    // TODO: verifyScalar function which consumes lambda\n    const [[a1, b1], [a2, b2]] = basis;\n    const c1 = divNearest(b2 * k, n);\n    const c2 = divNearest(-b1 * k, n);\n    // |k1|/|k2| is < sqrt(N), but can be negative.\n    // If we do `k1 mod N`, we'll get big scalar (`> sqrt(N)`): so, we do cheaper negation instead.\n    let k1 = k - c1 * a1 - c2 * a2;\n    let k2 = -c1 * b1 - c2 * b2;\n    const k1neg = k1 < _0n;\n    const k2neg = k2 < _0n;\n    if (k1neg) k1 = -k1;\n    if (k2neg) k2 = -k2;\n    // Double check that resulting scalar less than half bits of N: otherwise wNAF will fail.\n    // This should only happen on wrong basises. Also, math inside is too complex and I don't trust it.\n    const MAX_NUM = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(Math.ceil((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitLen)(n) / 2)) + _1n; // Half bits of N\n    if (k1 < _0n || k1 >= MAX_NUM || k2 < _0n || k2 >= MAX_NUM) {\n        throw new Error(\"splitScalar (endomorphism): failed, k=\" + k);\n    }\n    return {\n        k1neg,\n        k1,\n        k2neg,\n        k2\n    };\n}\nfunction validateSigFormat(format) {\n    if (![\n        \"compact\",\n        \"recovered\",\n        \"der\"\n    ].includes(format)) throw new Error('Signature format must be \"compact\", \"recovered\", or \"der\"');\n    return format;\n}\nfunction validateSigOpts(opts, def) {\n    const optsn = {};\n    for (let optName of Object.keys(def)){\n        // @ts-ignore\n        optsn[optName] = opts[optName] === undefined ? def[optName] : opts[optName];\n    }\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._abool2)(optsn.lowS, \"lowS\");\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._abool2)(optsn.prehash, \"prehash\");\n    if (optsn.format !== undefined) validateSigFormat(optsn.format);\n    return optsn;\n}\nclass DERErr extends Error {\n    constructor(m = \"\"){\n        super(m);\n    }\n}\n/**\n * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:\n *\n *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]\n *\n * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html\n */ const DER = {\n    // asn.1 DER encoding utils\n    Err: DERErr,\n    // Basic building block is TLV (Tag-Length-Value)\n    _tlv: {\n        encode: (tag, data)=>{\n            const { Err: E } = DER;\n            if (tag < 0 || tag > 256) throw new E(\"tlv.encode: wrong tag\");\n            if (data.length & 1) throw new E(\"tlv.encode: unpadded data\");\n            const dataLen = data.length / 2;\n            const len = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToHexUnpadded)(dataLen);\n            if (len.length / 2 & 128) throw new E(\"tlv.encode: long form length too big\");\n            // length of length with long form flag\n            const lenLen = dataLen > 127 ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToHexUnpadded)(len.length / 2 | 128) : \"\";\n            const t = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToHexUnpadded)(tag);\n            return t + lenLen + len + data;\n        },\n        // v - value, l - left bytes (unparsed)\n        decode (tag, data) {\n            const { Err: E } = DER;\n            let pos = 0;\n            if (tag < 0 || tag > 256) throw new E(\"tlv.encode: wrong tag\");\n            if (data.length < 2 || data[pos++] !== tag) throw new E(\"tlv.decode: wrong tlv\");\n            const first = data[pos++];\n            const isLong = !!(first & 128); // First bit of first length byte is flag for short/long form\n            let length = 0;\n            if (!isLong) length = first;\n            else {\n                // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]\n                const lenLen = first & 127;\n                if (!lenLen) throw new E(\"tlv.decode(long): indefinite length not supported\");\n                if (lenLen > 4) throw new E(\"tlv.decode(long): byte length is too big\"); // this will overflow u32 in js\n                const lengthBytes = data.subarray(pos, pos + lenLen);\n                if (lengthBytes.length !== lenLen) throw new E(\"tlv.decode: length bytes not complete\");\n                if (lengthBytes[0] === 0) throw new E(\"tlv.decode(long): zero leftmost byte\");\n                for (const b of lengthBytes)length = length << 8 | b;\n                pos += lenLen;\n                if (length < 128) throw new E(\"tlv.decode(long): not minimal encoding\");\n            }\n            const v = data.subarray(pos, pos + length);\n            if (v.length !== length) throw new E(\"tlv.decode: wrong value length\");\n            return {\n                v,\n                l: data.subarray(pos + length)\n            };\n        }\n    },\n    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n    // since we always use positive integers here. It must always be empty:\n    // - add zero byte if exists\n    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n    _int: {\n        encode (num) {\n            const { Err: E } = DER;\n            if (num < _0n) throw new E(\"integer: negative integers are not allowed\");\n            let hex = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToHexUnpadded)(num);\n            // Pad with zero byte if negative flag is present\n            if (Number.parseInt(hex[0], 16) & 8) hex = \"00\" + hex;\n            if (hex.length & 1) throw new E(\"unexpected DER parsing assertion: unpadded hex\");\n            return hex;\n        },\n        decode (data) {\n            const { Err: E } = DER;\n            if (data[0] & 128) throw new E(\"invalid signature integer: negative\");\n            if (data[0] === 0x00 && !(data[1] & 128)) throw new E(\"invalid signature integer: unnecessary leading zero\");\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(data);\n        }\n    },\n    toSig (hex) {\n        // parse DER signature\n        const { Err: E, _int: int, _tlv: tlv } = DER;\n        const data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"signature\", hex);\n        const { v: seqBytes, l: seqLeftBytes } = tlv.decode(0x30, data);\n        if (seqLeftBytes.length) throw new E(\"invalid signature: left bytes after parsing\");\n        const { v: rBytes, l: rLeftBytes } = tlv.decode(0x02, seqBytes);\n        const { v: sBytes, l: sLeftBytes } = tlv.decode(0x02, rLeftBytes);\n        if (sLeftBytes.length) throw new E(\"invalid signature: left bytes after parsing\");\n        return {\n            r: int.decode(rBytes),\n            s: int.decode(sBytes)\n        };\n    },\n    hexFromSig (sig) {\n        const { _tlv: tlv, _int: int } = DER;\n        const rs = tlv.encode(0x02, int.encode(sig.r));\n        const ss = tlv.encode(0x02, int.encode(sig.s));\n        const seq = rs + ss;\n        return tlv.encode(0x30, seq);\n    }\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nfunction _normFnElement(Fn, key) {\n    const { BYTES: expected } = Fn;\n    let num;\n    if (typeof key === \"bigint\") {\n        num = key;\n    } else {\n        let bytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"private key\", key);\n        try {\n            num = Fn.fromBytes(bytes);\n        } catch (error) {\n            throw new Error(`invalid private key: expected ui8a of size ${expected}, got ${typeof key}`);\n        }\n    }\n    if (!Fn.isValidNot0(num)) throw new Error(\"invalid private key: out of range [1..N-1]\");\n    return num;\n}\n/**\n * Creates weierstrass Point constructor, based on specified curve options.\n *\n * @example\n```js\nconst opts = {\n  p: BigInt('0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff'),\n  n: BigInt('0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551'),\n  h: BigInt(1),\n  a: BigInt('0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc'),\n  b: BigInt('0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b'),\n  Gx: BigInt('0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296'),\n  Gy: BigInt('0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5'),\n};\nconst p256_Point = weierstrass(opts);\n```\n */ function weierstrassN(params, extraOpts = {}) {\n    const validated = (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__._createCurveFields)(\"weierstrass\", params, extraOpts);\n    const { Fp, Fn } = validated;\n    let CURVE = validated.CURVE;\n    const { h: cofactor, n: CURVE_ORDER } = CURVE;\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._validateObject)(extraOpts, {}, {\n        allowInfinityPoint: \"boolean\",\n        clearCofactor: \"function\",\n        isTorsionFree: \"function\",\n        fromBytes: \"function\",\n        toBytes: \"function\",\n        endo: \"object\",\n        wrapPrivateKey: \"boolean\"\n    });\n    const { endo } = extraOpts;\n    if (endo) {\n        // validateObject(endo, { beta: 'bigint', splitScalar: 'function' });\n        if (!Fp.is0(CURVE.a) || typeof endo.beta !== \"bigint\" || !Array.isArray(endo.basises)) {\n            throw new Error('invalid endo: expected \"beta\": bigint and \"basises\": array');\n        }\n    }\n    const lengths = getWLengths(Fp, Fn);\n    function assertCompressionIsSupported() {\n        if (!Fp.isOdd) throw new Error(\"compression is not supported: Field does not have .isOdd()\");\n    }\n    // Implements IEEE P1363 point encoding\n    function pointToBytes(_c, point, isCompressed) {\n        const { x, y } = point.toAffine();\n        const bx = Fp.toBytes(x);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._abool2)(isCompressed, \"isCompressed\");\n        if (isCompressed) {\n            assertCompressionIsSupported();\n            const hasEvenY = !Fp.isOdd(y);\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.concatBytes)(pprefix(hasEvenY), bx);\n        } else {\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.concatBytes)(Uint8Array.of(0x04), bx, Fp.toBytes(y));\n        }\n    }\n    function pointFromBytes(bytes) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._abytes2)(bytes, undefined, \"Point\");\n        const { publicKey: comp, publicKeyUncompressed: uncomp } = lengths; // e.g. for 32-byte: 33, 65\n        const length = bytes.length;\n        const head = bytes[0];\n        const tail = bytes.subarray(1);\n        // No actual validation is done here: use .assertValidity()\n        if (length === comp && (head === 0x02 || head === 0x03)) {\n            const x = Fp.fromBytes(tail);\n            if (!Fp.isValid(x)) throw new Error(\"bad point: is not on curve, wrong x\");\n            const y2 = weierstrassEquation(x); // y = x + ax + b\n            let y;\n            try {\n                y = Fp.sqrt(y2); // y = y ^ (p+1)/4\n            } catch (sqrtError) {\n                const err = sqrtError instanceof Error ? \": \" + sqrtError.message : \"\";\n                throw new Error(\"bad point: is not on curve, sqrt error\" + err);\n            }\n            assertCompressionIsSupported();\n            const isYOdd = Fp.isOdd(y); // (y & _1n) === _1n;\n            const isHeadOdd = (head & 1) === 1; // ECDSA-specific\n            if (isHeadOdd !== isYOdd) y = Fp.neg(y);\n            return {\n                x,\n                y\n            };\n        } else if (length === uncomp && head === 0x04) {\n            // TODO: more checks\n            const L = Fp.BYTES;\n            const x = Fp.fromBytes(tail.subarray(0, L));\n            const y = Fp.fromBytes(tail.subarray(L, L * 2));\n            if (!isValidXY(x, y)) throw new Error(\"bad point: is not on curve\");\n            return {\n                x,\n                y\n            };\n        } else {\n            throw new Error(`bad point: got length ${length}, expected compressed=${comp} or uncompressed=${uncomp}`);\n        }\n    }\n    const encodePoint = extraOpts.toBytes || pointToBytes;\n    const decodePoint = extraOpts.fromBytes || pointFromBytes;\n    function weierstrassEquation(x) {\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, CURVE.a)), CURVE.b); // x + a * x + b\n    }\n    // TODO: move top-level\n    /** Checks whether equation holds for given x, y: y == x + ax + b */ function isValidXY(x, y) {\n        const left = Fp.sqr(y); // y\n        const right = weierstrassEquation(x); // x + ax + b\n        return Fp.eql(left, right);\n    }\n    // Validate whether the passed curve params are valid.\n    // Test 1: equation y = x + ax + b should work for generator point.\n    if (!isValidXY(CURVE.Gx, CURVE.Gy)) throw new Error(\"bad curve params: generator point\");\n    // Test 2: discriminant  part should be non-zero: 4a + 27b != 0.\n    // Guarantees curve is genus-1, smooth (non-singular).\n    const _4a3 = Fp.mul(Fp.pow(CURVE.a, _3n), _4n);\n    const _27b2 = Fp.mul(Fp.sqr(CURVE.b), BigInt(27));\n    if (Fp.is0(Fp.add(_4a3, _27b2))) throw new Error(\"bad curve params: a or b\");\n    /** Asserts coordinate is valid: 0 <= n < Fp.ORDER. */ function acoord(title, n, banZero = false) {\n        if (!Fp.isValid(n) || banZero && Fp.is0(n)) throw new Error(`bad point coordinate ${title}`);\n        return n;\n    }\n    function aprjpoint(other) {\n        if (!(other instanceof Point)) throw new Error(\"ProjectivePoint expected\");\n    }\n    function splitEndoScalarN(k) {\n        if (!endo || !endo.basises) throw new Error(\"no endo\");\n        return _splitEndoScalar(k, endo.basises, Fn.ORDER);\n    }\n    // Memoized toAffine / validity check. They are heavy. Points are immutable.\n    // Converts Projective point to affine (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    // (X, Y, Z)  (x=X/Z, y=Y/Z)\n    const toAffineMemo = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memoized)((p, iz)=>{\n        const { X, Y, Z } = p;\n        // Fast-path for normalized points\n        if (Fp.eql(Z, Fp.ONE)) return {\n            x: X,\n            y: Y\n        };\n        const is0 = p.is0();\n        // If invZ was 0, we return zero point. However we still want to execute\n        // all operations, so we replace invZ with a random number, 1.\n        if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(Z);\n        const x = Fp.mul(X, iz);\n        const y = Fp.mul(Y, iz);\n        const zz = Fp.mul(Z, iz);\n        if (is0) return {\n            x: Fp.ZERO,\n            y: Fp.ZERO\n        };\n        if (!Fp.eql(zz, Fp.ONE)) throw new Error(\"invZ was invalid\");\n        return {\n            x,\n            y\n        };\n    });\n    // NOTE: on exception this will crash 'cached' and no value will be set.\n    // Otherwise true will be return\n    const assertValidMemo = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memoized)((p)=>{\n        if (p.is0()) {\n            // (0, 1, 0) aka ZERO is invalid in most contexts.\n            // In BLS, ZERO can be serialized, so we allow it.\n            // (0, 0, 0) is invalid representation of ZERO.\n            if (extraOpts.allowInfinityPoint && !Fp.is0(p.Y)) return;\n            throw new Error(\"bad point: ZERO\");\n        }\n        // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n        const { x, y } = p.toAffine();\n        if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error(\"bad point: x or y not field elements\");\n        if (!isValidXY(x, y)) throw new Error(\"bad point: equation left != right\");\n        if (!p.isTorsionFree()) throw new Error(\"bad point: not in prime-order subgroup\");\n        return true;\n    });\n    function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {\n        k2p = new Point(Fp.mul(k2p.X, endoBeta), k2p.Y, k2p.Z);\n        k1p = (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.negateCt)(k1neg, k1p);\n        k2p = (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.negateCt)(k2neg, k2p);\n        return k1p.add(k2p);\n    }\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates:(X, Y, Z)  (x=X/Z, y=Y/Z).\n     * Default Point works in 2d / affine coordinates: (x, y).\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */ class Point {\n        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */ constructor(X, Y, Z){\n            this.X = acoord(\"x\", X);\n            this.Y = acoord(\"y\", Y, true);\n            this.Z = acoord(\"z\", Z);\n            Object.freeze(this);\n        }\n        static CURVE() {\n            return CURVE;\n        }\n        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */ static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error(\"invalid affine point\");\n            if (p instanceof Point) throw new Error(\"projective point not allowed\");\n            // (0, 0) would've produced (0, 0, 1) - instead, we need (0, 1, 0)\n            if (Fp.is0(x) && Fp.is0(y)) return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        static fromBytes(bytes) {\n            const P = Point.fromAffine(decodePoint((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._abytes2)(bytes, undefined, \"point\")));\n            P.assertValidity();\n            return P;\n        }\n        static fromHex(hex) {\n            return Point.fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"pointHex\", hex));\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         *\n         * @param windowSize\n         * @param isLazy true will defer table computation until the first multiplication\n         * @returns\n         */ precompute(windowSize = 8, isLazy = true) {\n            wnaf.createCache(this, windowSize);\n            if (!isLazy) this.multiply(_3n); // random number\n            return this;\n        }\n        // TODO: return `this`\n        /** A point on curve is valid if it conforms to equation. */ assertValidity() {\n            assertValidMemo(this);\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (!Fp.isOdd) throw new Error(\"Field doesn't support isOdd\");\n            return !Fp.isOdd(y);\n        }\n        /** Compare one point to another. */ equals(other) {\n            aprjpoint(other);\n            const { X: X1, Y: Y1, Z: Z1 } = this;\n            const { X: X2, Y: Y2, Z: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /** Flips point to one corresponding to (x, -y) in Affine coordinates. */ negate() {\n            return new Point(this.X, Fp.neg(this.Y), this.Z);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { X: X1, Y: Y1, Z: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            aprjpoint(other);\n            const { X: X1, Y: Y1, Z: Z1 } = this;\n            const { X: X2, Y: Y2, Z: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */ multiply(scalar) {\n            const { endo } = extraOpts;\n            if (!Fn.isValidNot0(scalar)) throw new Error(\"invalid scalar: out of range\"); // 0 is invalid\n            let point, fake; // Fake point is used to const-time mult\n            const mul = (n)=>wnaf.cached(this, n, (p)=>(0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.normalizeZ)(Point, p));\n            /** See docs for {@link EndomorphismOpts} */ if (endo) {\n                const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(scalar);\n                const { p: k1p, f: k1f } = mul(k1);\n                const { p: k2p, f: k2f } = mul(k2);\n                fake = k1f.add(k2f);\n                point = finishEndo(endo.beta, k1p, k2p, k1neg, k2neg);\n            } else {\n                const { p, f } = mul(scalar);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.normalizeZ)(Point, [\n                point,\n                fake\n            ])[0];\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed secret key e.g. sig verification, which works over *public* keys.\n         */ multiplyUnsafe(sc) {\n            const { endo } = extraOpts;\n            const p = this;\n            if (!Fn.isValid(sc)) throw new Error(\"invalid scalar: out of range\"); // 0 is valid\n            if (sc === _0n || p.is0()) return Point.ZERO;\n            if (sc === _1n) return p; // fast-path\n            if (wnaf.hasCache(this)) return this.multiply(sc);\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(sc);\n                const { p1, p2 } = (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.mulEndoUnsafe)(Point, p, k1, k2); // 30% faster vs wnaf.unsafe\n                return finishEndo(endo.beta, p1, p2, k1neg, k2neg);\n            } else {\n                return wnaf.unsafe(p, sc);\n            }\n        }\n        multiplyAndAddUnsafe(Q, a, b) {\n            const sum = this.multiplyUnsafe(a).add(Q.multiplyUnsafe(b));\n            return sum.is0() ? undefined : sum;\n        }\n        /**\n         * Converts Projective point to affine (x, y) coordinates.\n         * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch\n         */ toAffine(invertedZ) {\n            return toAffineMemo(this, invertedZ);\n        }\n        /**\n         * Checks whether Point is free of torsion elements (is in prime subgroup).\n         * Always torsion-free for cofactor=1 curves.\n         */ isTorsionFree() {\n            const { isTorsionFree } = extraOpts;\n            if (cofactor === _1n) return true;\n            if (isTorsionFree) return isTorsionFree(Point, this);\n            return wnaf.unsafe(this, CURVE_ORDER).is0();\n        }\n        clearCofactor() {\n            const { clearCofactor } = extraOpts;\n            if (cofactor === _1n) return this; // Fast-path\n            if (clearCofactor) return clearCofactor(Point, this);\n            return this.multiplyUnsafe(cofactor);\n        }\n        isSmallOrder() {\n            // can we use this.clearCofactor()?\n            return this.multiplyUnsafe(cofactor).is0();\n        }\n        toBytes(isCompressed = true) {\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._abool2)(isCompressed, \"isCompressed\");\n            this.assertValidity();\n            return encodePoint(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.bytesToHex)(this.toBytes(isCompressed));\n        }\n        toString() {\n            return `<Point ${this.is0() ? \"ZERO\" : this.toHex()}>`;\n        }\n        // TODO: remove\n        get px() {\n            return this.X;\n        }\n        get py() {\n            return this.X;\n        }\n        get pz() {\n            return this.Z;\n        }\n        toRawBytes(isCompressed = true) {\n            return this.toBytes(isCompressed);\n        }\n        _setWindowSize(windowSize) {\n            this.precompute(windowSize);\n        }\n        static normalizeZ(points) {\n            return (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.normalizeZ)(Point, points);\n        }\n        static msm(points, scalars) {\n            return (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.pippenger)(Point, Fn, points, scalars);\n        }\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(_normFnElement(Fn, privateKey));\n        }\n    }\n    // base / generator point\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    // zero / infinity / identity point\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO); // 0, 1, 0\n    // math field\n    Point.Fp = Fp;\n    // scalar field\n    Point.Fn = Fn;\n    const bits = Fn.BITS;\n    const wnaf = new _curve_js__WEBPACK_IMPORTED_MODULE_1__.wNAF(Point, extraOpts.endo ? Math.ceil(bits / 2) : bits);\n    Point.BASE.precompute(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n    return Point;\n}\n// Points start with byte 0x02 when y is even; otherwise 0x03\nfunction pprefix(hasEvenY) {\n    return Uint8Array.of(hasEvenY ? 0x02 : 0x03);\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */ function SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for(let o = q - _1n; o % _2n === _0n; o /= _2n)l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << c1 - _1n - _1n;\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v)=>{\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for(let i = c1; i > _1n; i--){\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << tv5 - _1n; // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return {\n            isValid: isQR,\n            value: tv3\n        };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v)=>{\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return {\n                isValid: isQR,\n                value: y\n            }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */ function mapToCurveSimpleSWU(Fp, opts) {\n    (0,_modular_js__WEBPACK_IMPORTED_MODULE_3__.validateField)(Fp);\n    const { A, B, Z } = opts;\n    if (!Fp.isValid(A) || !Fp.isValid(B) || !Fp.isValid(Z)) throw new Error(\"mapToCurveSimpleSWU: invalid opts\");\n    const sqrtRatio = SWUFpSqrtRatio(Fp, Z);\n    if (!Fp.isOdd) throw new Error(\"Field does not have .isOdd()\");\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u)=>{\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        const tv4_inv = (0,_modular_js__WEBPACK_IMPORTED_MODULE_3__.FpInvertBatch)(Fp, [\n            tv4\n        ], true)[0];\n        x = Fp.mul(x, tv4_inv); // 25.   x = x / tv4\n        return {\n            x,\n            y\n        };\n    };\n}\nfunction getWLengths(Fp, Fn) {\n    return {\n        secretKey: Fn.BYTES,\n        publicKey: 1 + Fp.BYTES,\n        publicKeyUncompressed: 1 + 2 * Fp.BYTES,\n        publicKeyHasPrefix: true,\n        signature: 2 * Fn.BYTES\n    };\n}\n/**\n * Sometimes users only need getPublicKey, getSharedSecret, and secret key handling.\n * This helper ensures no signature functionality is present. Less code, smaller bundle size.\n */ function ecdh(Point, ecdhOpts = {}) {\n    const { Fn } = Point;\n    const randomBytes_ = ecdhOpts.randomBytes || _utils_js__WEBPACK_IMPORTED_MODULE_2__.randomBytes;\n    const lengths = Object.assign(getWLengths(Point.Fp, Fn), {\n        seed: (0,_modular_js__WEBPACK_IMPORTED_MODULE_3__.getMinHashLength)(Fn.ORDER)\n    });\n    function isValidSecretKey(secretKey) {\n        try {\n            return !!_normFnElement(Fn, secretKey);\n        } catch (error) {\n            return false;\n        }\n    }\n    function isValidPublicKey(publicKey, isCompressed) {\n        const { publicKey: comp, publicKeyUncompressed } = lengths;\n        try {\n            const l = publicKey.length;\n            if (isCompressed === true && l !== comp) return false;\n            if (isCompressed === false && l !== publicKeyUncompressed) return false;\n            return !!Point.fromBytes(publicKey);\n        } catch (error) {\n            return false;\n        }\n    }\n    /**\n     * Produces cryptographically secure secret key from random of size\n     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n     */ function randomSecretKey(seed = randomBytes_(lengths.seed)) {\n        return (0,_modular_js__WEBPACK_IMPORTED_MODULE_3__.mapHashToField)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._abytes2)(seed, lengths.seed, \"seed\"), Fn.ORDER);\n    }\n    /**\n     * Computes public key for a secret key. Checks for validity of the secret key.\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */ function getPublicKey(secretKey, isCompressed = true) {\n        return Point.BASE.multiply(_normFnElement(Fn, secretKey)).toBytes(isCompressed);\n    }\n    function keygen(seed) {\n        const secretKey = randomSecretKey(seed);\n        return {\n            secretKey,\n            publicKey: getPublicKey(secretKey)\n        };\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */ function isProbPub(item) {\n        if (typeof item === \"bigint\") return false;\n        if (item instanceof Point) return true;\n        const { secretKey, publicKey, publicKeyUncompressed } = lengths;\n        if (Fn.allowedLengths || secretKey === publicKey) return undefined;\n        const l = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"key\", item).length;\n        return l === publicKey || l === publicKeyUncompressed;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from secret key A and public key B.\n     * Checks: 1) secret key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */ function getSharedSecret(secretKeyA, publicKeyB, isCompressed = true) {\n        if (isProbPub(secretKeyA) === true) throw new Error(\"first arg must be private key\");\n        if (isProbPub(publicKeyB) === false) throw new Error(\"second arg must be public key\");\n        const s = _normFnElement(Fn, secretKeyA);\n        const b = Point.fromHex(publicKeyB); // checks for being on-curve\n        return b.multiply(s).toBytes(isCompressed);\n    }\n    const utils = {\n        isValidSecretKey,\n        isValidPublicKey,\n        randomSecretKey,\n        // TODO: remove\n        isValidPrivateKey: isValidSecretKey,\n        randomPrivateKey: randomSecretKey,\n        normPrivateKeyToScalar: (key)=>_normFnElement(Fn, key),\n        precompute (windowSize = 8, point = Point.BASE) {\n            return point.precompute(windowSize, false);\n        }\n    };\n    return Object.freeze({\n        getPublicKey,\n        getSharedSecret,\n        keygen,\n        Point,\n        utils,\n        lengths\n    });\n}\n/**\n * Creates ECDSA signing interface for given elliptic curve `Point` and `hash` function.\n * We need `hash` for 2 features:\n * 1. Message prehash-ing. NOT used if `sign` / `verify` are called with `prehash: false`\n * 2. k generation in `sign`, using HMAC-drbg(hash)\n *\n * ECDSAOpts are only rarely needed.\n *\n * @example\n * ```js\n * const p256_Point = weierstrass(...);\n * const p256_sha256 = ecdsa(p256_Point, sha256);\n * const p256_sha224 = ecdsa(p256_Point, sha224);\n * const p256_sha224_r = ecdsa(p256_Point, sha224, { randomBytes: (length) => { ... } });\n * ```\n */ function ecdsa(Point, hash, ecdsaOpts = {}) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.ahash)(hash);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._validateObject)(ecdsaOpts, {}, {\n        hmac: \"function\",\n        lowS: \"boolean\",\n        randomBytes: \"function\",\n        bits2int: \"function\",\n        bits2int_modN: \"function\"\n    });\n    const randomBytes = ecdsaOpts.randomBytes || _utils_js__WEBPACK_IMPORTED_MODULE_2__.randomBytes;\n    const hmac = ecdsaOpts.hmac || ((key, ...msgs)=>(0,_noble_hashes_hmac_js__WEBPACK_IMPORTED_MODULE_4__.hmac)(hash, key, (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.concatBytes)(...msgs)));\n    const { Fp, Fn } = Point;\n    const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn;\n    const { keygen, getPublicKey, getSharedSecret, utils, lengths } = ecdh(Point, ecdsaOpts);\n    const defaultSigOpts = {\n        prehash: false,\n        lowS: typeof ecdsaOpts.lowS === \"boolean\" ? ecdsaOpts.lowS : false,\n        format: undefined,\n        extraEntropy: false\n    };\n    const defaultSigOpts_format = \"compact\";\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function validateRS(title, num) {\n        if (!Fn.isValidNot0(num)) throw new Error(`invalid signature ${title}: out of range 1..Point.Fn.ORDER`);\n        return num;\n    }\n    function validateSigLength(bytes, format) {\n        validateSigFormat(format);\n        const size = lengths.signature;\n        const sizer = format === \"compact\" ? size : format === \"recovered\" ? size + 1 : undefined;\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._abytes2)(bytes, sizer, `${format} signature`);\n    }\n    /**\n     * ECDSA signature with its (r, s) properties. Supports compact, recovered & DER representations.\n     */ class Signature {\n        constructor(r, s, recovery){\n            this.r = validateRS(\"r\", r); // r in [1..N-1];\n            this.s = validateRS(\"s\", s); // s in [1..N-1];\n            if (recovery != null) this.recovery = recovery;\n            Object.freeze(this);\n        }\n        static fromBytes(bytes, format = defaultSigOpts_format) {\n            validateSigLength(bytes, format);\n            let recid;\n            if (format === \"der\") {\n                const { r, s } = DER.toSig((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._abytes2)(bytes));\n                return new Signature(r, s);\n            }\n            if (format === \"recovered\") {\n                recid = bytes[0];\n                format = \"compact\";\n                bytes = bytes.subarray(1);\n            }\n            const L = Fn.BYTES;\n            const r = bytes.subarray(0, L);\n            const s = bytes.subarray(L, L * 2);\n            return new Signature(Fn.fromBytes(r), Fn.fromBytes(s), recid);\n        }\n        static fromHex(hex, format) {\n            return this.fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.hexToBytes)(hex), format);\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(messageHash) {\n            const FIELD_ORDER = Fp.ORDER;\n            const { r, s, recovery: rec } = this;\n            if (rec == null || ![\n                0,\n                1,\n                2,\n                3\n            ].includes(rec)) throw new Error(\"recovery id invalid\");\n            // ECDSA recovery is hard for cofactor > 1 curves.\n            // In sign, `r = q.x mod n`, and here we recover q.x from r.\n            // While recovering q.x >= n, we need to add r+n for cofactor=1 curves.\n            // However, for cofactor>1, r+n may not get q.x:\n            // r+n*i would need to be done instead where i is unknown.\n            // To easily get i, we either need to:\n            // a. increase amount of valid recid values (4, 5...); OR\n            // b. prohibit non-prime-order signatures (recid > 1).\n            const hasCofactor = CURVE_ORDER * _2n < FIELD_ORDER;\n            if (hasCofactor && rec > 1) throw new Error(\"recovery id is ambiguous for h>1 curve\");\n            const radj = rec === 2 || rec === 3 ? r + CURVE_ORDER : r;\n            if (!Fp.isValid(radj)) throw new Error(\"recovery id 2 or 3 invalid\");\n            const x = Fp.toBytes(radj);\n            const R = Point.fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.concatBytes)(pprefix((rec & 1) === 0), x));\n            const ir = Fn.inv(radj); // r^-1\n            const h = bits2int_modN((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"msgHash\", messageHash)); // Truncate hash\n            const u1 = Fn.create(-h * ir); // -hr^-1\n            const u2 = Fn.create(s * ir); // sr^-1\n            // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1). unsafe is fine: there is no private data.\n            const Q = Point.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));\n            if (Q.is0()) throw new Error(\"point at infinify\");\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        toBytes(format = defaultSigOpts_format) {\n            validateSigFormat(format);\n            if (format === \"der\") return (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.hexToBytes)(DER.hexFromSig(this));\n            const r = Fn.toBytes(this.r);\n            const s = Fn.toBytes(this.s);\n            if (format === \"recovered\") {\n                if (this.recovery == null) throw new Error(\"recovery bit must be present\");\n                return (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.concatBytes)(Uint8Array.of(this.recovery), r, s);\n            }\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.concatBytes)(r, s);\n        }\n        toHex(format) {\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.bytesToHex)(this.toBytes(format));\n        }\n        // TODO: remove\n        assertValidity() {}\n        static fromCompact(hex) {\n            return Signature.fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"sig\", hex), \"compact\");\n        }\n        static fromDER(hex) {\n            return Signature.fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"sig\", hex), \"der\");\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, Fn.neg(this.s), this.recovery) : this;\n        }\n        toDERRawBytes() {\n            return this.toBytes(\"der\");\n        }\n        toDERHex() {\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.bytesToHex)(this.toBytes(\"der\"));\n        }\n        toCompactRawBytes() {\n            return this.toBytes(\"compact\");\n        }\n        toCompactHex() {\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.bytesToHex)(this.toBytes(\"compact\"));\n        }\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = ecdsaOpts.bits2int || function bits2int_def(bytes) {\n        // Our custom check \"just in case\", for protection against DoS\n        if (bytes.length > 8192) throw new Error(\"input is too large\");\n        // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n        // for some cases, since bytes.length * 8 is not actual bitLength.\n        const num = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(bytes); // check for == u8 done here\n        const delta = bytes.length * 8 - fnBits; // truncate to nBitLength leftmost bits\n        return delta > 0 ? num >> BigInt(delta) : num;\n    };\n    const bits2int_modN = ecdsaOpts.bits2int_modN || function bits2int_modN_def(bytes) {\n        return Fn.create(bits2int(bytes)); // can't use bytesToNumberBE here\n    };\n    // Pads output with zero as per spec\n    const ORDER_MASK = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(fnBits);\n    /** Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`. */ function int2octets(num) {\n        // IMPORTANT: the check ensures working for case `Fn.BYTES != Fn.BITS * 8`\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange)(\"num < 2^\" + fnBits, num, _0n, ORDER_MASK);\n        return Fn.toBytes(num);\n    }\n    function validateMsgAndHash(message, prehash) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._abytes2)(message, undefined, \"message\");\n        return prehash ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._abytes2)(hash(message), undefined, \"prehashed message\") : message;\n    }\n    /**\n     * Steps A, D of RFC6979 3.2.\n     * Creates RFC6979 seed; converts msg/privKey to numbers.\n     * Used only in sign, not in verify.\n     *\n     * Warning: we cannot assume here that message has same amount of bytes as curve order,\n     * this will be invalid at least for P521. Also it can be bigger for P224 + SHA256.\n     */ function prepSig(message, privateKey, opts) {\n        if ([\n            \"recovered\",\n            \"canonical\"\n        ].some((k)=>k in opts)) throw new Error(\"sign() legacy options not supported\");\n        const { lowS, prehash, extraEntropy } = validateSigOpts(opts, defaultSigOpts);\n        message = validateMsgAndHash(message, prehash); // RFC6979 3.2 A: h1 = H(m)\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with fnBits % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(message);\n        const d = _normFnElement(Fn, privateKey); // validate secret key, convert to bigint\n        const seedArgs = [\n            int2octets(d),\n            int2octets(h1int)\n        ];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (extraEntropy != null && extraEntropy !== false) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            // gen random bytes OR pass as-is\n            const e = extraEntropy === true ? randomBytes(lengths.secretKey) : extraEntropy;\n            seedArgs.push((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"extraEntropy\", e)); // check for being bytes\n        }\n        const seed = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.concatBytes)(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        // To transform k => Signature:\n        // q = kG\n        // r = q.x mod n\n        // s = k^-1(m + rd) mod n\n        // Can use scalar blinding b^-1(bm + bdr) where b  [1,q1] according to\n        // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n        // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            // Important: all mod() calls here must be done over N\n            const k = bits2int(kBytes); // mod n, not mod p\n            if (!Fn.isValidNot0(k)) return; // Valid scalars (including k) must be in 1..N-1\n            const ik = Fn.inv(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = kG\n            const r = Fn.create(q.x); // r = q.x mod n\n            if (r === _0n) return;\n            const s = Fn.create(ik * Fn.create(m + r * d)); // Not using blinding here, see comment above\n            if (s === _0n) return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = Fn.neg(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return {\n            seed,\n            k2sig\n        };\n    }\n    /**\n     * Signs message hash with a secret key.\n     *\n     * ```\n     * sign(m, d) where\n     *   k = rfc6979_hmac_drbg(m, d)\n     *   (x, y) = G  k\n     *   r = x mod n\n     *   s = (m + dr) / k mod n\n     * ```\n     */ function sign(message, secretKey, opts = {}) {\n        message = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"message\", message);\n        const { seed, k2sig } = prepSig(message, secretKey, opts); // Steps A, D of RFC6979 3.2.\n        const drbg = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createHmacDrbg)(hash.outputLen, Fn.BYTES, hmac);\n        const sig = drbg(seed, k2sig); // Steps B, C, D, E, F, G\n        return sig;\n    }\n    function tryParsingSig(sg) {\n        // Try to deduce format\n        let sig = undefined;\n        const isHex = typeof sg === \"string\" || (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.isBytes)(sg);\n        const isObj = !isHex && sg !== null && typeof sg === \"object\" && typeof sg.r === \"bigint\" && typeof sg.s === \"bigint\";\n        if (!isHex && !isObj) throw new Error(\"invalid signature, expected Uint8Array, hex string or Signature instance\");\n        if (isObj) {\n            sig = new Signature(sg.r, sg.s);\n        } else if (isHex) {\n            try {\n                sig = Signature.fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"sig\", sg), \"der\");\n            } catch (derError) {\n                if (!(derError instanceof DER.Err)) throw derError;\n            }\n            if (!sig) {\n                try {\n                    sig = Signature.fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"sig\", sg), \"compact\");\n                } catch (error) {\n                    return false;\n                }\n            }\n        }\n        if (!sig) return false;\n        return sig;\n    }\n    /**\n     * Verifies a signature against message and public key.\n     * Rejects lowS signatures by default: see {@link ECDSAVerifyOpts}.\n     * Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   u1 = hs^-1 mod n\n     *   u2 = rs^-1 mod n\n     *   R = u1G + u2P\n     *   mod(R.x, n) == r\n     * ```\n     */ function verify(signature, message, publicKey, opts = {}) {\n        const { lowS, prehash, format } = validateSigOpts(opts, defaultSigOpts);\n        publicKey = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"publicKey\", publicKey);\n        message = validateMsgAndHash((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"message\", message), prehash);\n        if (\"strict\" in opts) throw new Error(\"options.strict was renamed to lowS\");\n        const sig = format === undefined ? tryParsingSig(signature) : Signature.fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"sig\", signature), format);\n        if (sig === false) return false;\n        try {\n            const P = Point.fromBytes(publicKey);\n            if (lowS && sig.hasHighS()) return false;\n            const { r, s } = sig;\n            const h = bits2int_modN(message); // mod n, not mod p\n            const is = Fn.inv(s); // s^-1 mod n\n            const u1 = Fn.create(h * is); // u1 = hs^-1 mod n\n            const u2 = Fn.create(r * is); // u2 = rs^-1 mod n\n            const R = Point.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2)); // u1G + u2P\n            if (R.is0()) return false;\n            const v = Fn.create(R.x); // v = r.x mod n\n            return v === r;\n        } catch (e) {\n            return false;\n        }\n    }\n    function recoverPublicKey(signature, message, opts = {}) {\n        const { prehash } = validateSigOpts(opts, defaultSigOpts);\n        message = validateMsgAndHash(message, prehash);\n        return Signature.fromBytes(signature, \"recovered\").recoverPublicKey(message).toBytes();\n    }\n    return Object.freeze({\n        keygen,\n        getPublicKey,\n        getSharedSecret,\n        utils,\n        lengths,\n        Point,\n        sign,\n        verify,\n        recoverPublicKey,\n        Signature,\n        hash\n    });\n}\n/** @deprecated use `weierstrass` in newer releases */ function weierstrassPoints(c) {\n    const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);\n    const Point = weierstrassN(CURVE, curveOpts);\n    return _weierstrass_new_output_to_legacy(c, Point);\n}\nfunction _weierstrass_legacy_opts_to_new(c) {\n    const CURVE = {\n        a: c.a,\n        b: c.b,\n        p: c.Fp.ORDER,\n        n: c.n,\n        h: c.h,\n        Gx: c.Gx,\n        Gy: c.Gy\n    };\n    const Fp = c.Fp;\n    let allowedLengths = c.allowedPrivateKeyLengths ? Array.from(new Set(c.allowedPrivateKeyLengths.map((l)=>Math.ceil(l / 2)))) : undefined;\n    const Fn = (0,_modular_js__WEBPACK_IMPORTED_MODULE_3__.Field)(CURVE.n, {\n        BITS: c.nBitLength,\n        allowedLengths: allowedLengths,\n        modFromBytes: c.wrapPrivateKey\n    });\n    const curveOpts = {\n        Fp,\n        Fn,\n        allowInfinityPoint: c.allowInfinityPoint,\n        endo: c.endo,\n        isTorsionFree: c.isTorsionFree,\n        clearCofactor: c.clearCofactor,\n        fromBytes: c.fromBytes,\n        toBytes: c.toBytes\n    };\n    return {\n        CURVE,\n        curveOpts\n    };\n}\nfunction _ecdsa_legacy_opts_to_new(c) {\n    const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);\n    const ecdsaOpts = {\n        hmac: c.hmac,\n        randomBytes: c.randomBytes,\n        lowS: c.lowS,\n        bits2int: c.bits2int,\n        bits2int_modN: c.bits2int_modN\n    };\n    return {\n        CURVE,\n        curveOpts,\n        hash: c.hash,\n        ecdsaOpts\n    };\n}\nfunction _legacyHelperEquat(Fp, a, b) {\n    /**\n     * y = x + ax + b: Short weierstrass curve formula. Takes x, returns y.\n     * @returns y\n     */ function weierstrassEquation(x) {\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x + a * x + b\n    }\n    return weierstrassEquation;\n}\nfunction _weierstrass_new_output_to_legacy(c, Point) {\n    const { Fp, Fn } = Point;\n    function isWithinCurveOrder(num) {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.inRange)(num, _1n, Fn.ORDER);\n    }\n    const weierstrassEquation = _legacyHelperEquat(Fp, c.a, c.b);\n    return Object.assign({}, {\n        CURVE: c,\n        Point: Point,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar: (key)=>_normFnElement(Fn, key),\n        weierstrassEquation,\n        isWithinCurveOrder\n    });\n}\nfunction _ecdsa_new_output_to_legacy(c, _ecdsa) {\n    const Point = _ecdsa.Point;\n    return Object.assign({}, _ecdsa, {\n        ProjectivePoint: Point,\n        CURVE: Object.assign({}, c, (0,_modular_js__WEBPACK_IMPORTED_MODULE_3__.nLength)(Point.Fn.ORDER, Point.Fn.BITS))\n    });\n}\n// _ecdsa_legacy\nfunction weierstrass(c) {\n    const { CURVE, curveOpts, hash, ecdsaOpts } = _ecdsa_legacy_opts_to_new(c);\n    const Point = weierstrassN(CURVE, curveOpts);\n    const signs = ecdsa(Point, hash, ecdsaOpts);\n    return _ecdsa_new_output_to_legacy(c, signs);\n} //# sourceMappingURL=weierstrass.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC93ZWllcnN0cmFzcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBeUJDLEdBQ0Qsb0VBQW9FLEdBQ1Y7QUFDZDtBQUN1TztBQUM1SztBQUNRO0FBQy9HLCtIQUErSDtBQUMvSCxNQUFNbUMsYUFBYSxDQUFDQyxLQUFLQyxNQUFRLENBQUNELE1BQU0sQ0FBQ0EsT0FBTyxJQUFJQyxNQUFNLENBQUNBLEdBQUUsSUFBS0MsR0FBRSxJQUFLRDtBQUN6RTs7Q0FFQyxHQUNNLFNBQVNFLGlCQUFpQkMsQ0FBQyxFQUFFQyxLQUFLLEVBQUVDLENBQUM7SUFDeEMsNEVBQTRFO0lBQzVFLDJEQUEyRDtJQUMzRCxvREFBb0Q7SUFDcEQsTUFBTSxDQUFDLENBQUNDLElBQUlDLEdBQUcsRUFBRSxDQUFDQyxJQUFJQyxHQUFHLENBQUMsR0FBR0w7SUFDN0IsTUFBTU0sS0FBS1osV0FBV1csS0FBS04sR0FBR0U7SUFDOUIsTUFBTU0sS0FBS2IsV0FBVyxDQUFDUyxLQUFLSixHQUFHRTtJQUMvQiwrQ0FBK0M7SUFDL0MsK0ZBQStGO0lBQy9GLElBQUlPLEtBQUtULElBQUlPLEtBQUtKLEtBQUtLLEtBQUtIO0lBQzVCLElBQUlLLEtBQUssQ0FBQ0gsS0FBS0gsS0FBS0ksS0FBS0Y7SUFDekIsTUFBTUssUUFBUUYsS0FBS0c7SUFDbkIsTUFBTUMsUUFBUUgsS0FBS0U7SUFDbkIsSUFBSUQsT0FDQUYsS0FBSyxDQUFDQTtJQUNWLElBQUlJLE9BQ0FILEtBQUssQ0FBQ0E7SUFDVix5RkFBeUY7SUFDekYsbUdBQW1HO0lBQ25HLE1BQU1JLFVBQVU1QyxrREFBT0EsQ0FBQzZDLEtBQUtDLElBQUksQ0FBQy9DLGlEQUFNQSxDQUFDaUMsS0FBSyxNQUFNZSxLQUFLLGlCQUFpQjtJQUMx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RSxDQUFDdUssSUFBSTtJQUNyRTtBQUNKO0FBQ0EsZ0JBQWdCO0FBQ1QsU0FBU3lJLFlBQVloQixDQUFDO0lBQ3pCLE1BQU0sRUFBRW5SLEtBQUssRUFBRW9SLFNBQVMsRUFBRXBFLElBQUksRUFBRUMsU0FBUyxFQUFFLEdBQUc0RSwwQkFBMEJWO0lBQ3hFLE1BQU01TSxRQUFRNUUsYUFBYUssT0FBT29SO0lBQ2xDLE1BQU1nQixRQUFRckYsTUFBTXhJLE9BQU95SSxNQUFNQztJQUNqQyxPQUFPZ0YsNEJBQTRCZCxHQUFHaUI7QUFDMUMsRUFDQSx1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGF3LXdvcmtzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2ViMy5qcy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanM/ZjdjZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFNob3J0IFdlaWVyc3RyYXNzIGN1cnZlIG1ldGhvZHMuIFRoZSBmb3JtdWxhIGlzOiB5wrIgPSB4wrMgKyBheCArIGIuXG4gKlxuICogIyMjIERlc2lnbiByYXRpb25hbGUgZm9yIHR5cGVzXG4gKlxuICogKiBJbnRlcmFjdGlvbiBiZXR3ZWVuIGNsYXNzZXMgZnJvbSBkaWZmZXJlbnQgY3VydmVzIHNob3VsZCBmYWlsOlxuICogICBgazI1Ni5Qb2ludC5CQVNFLmFkZChwMjU2LlBvaW50LkJBU0UpYFxuICogKiBGb3IgdGhpcyBwdXJwb3NlIHdlIHdhbnQgdG8gdXNlIGBpbnN0YW5jZW9mYCBvcGVyYXRvciwgd2hpY2ggaXMgZmFzdCBhbmQgd29ya3MgZHVyaW5nIHJ1bnRpbWVcbiAqICogRGlmZmVyZW50IGNhbGxzIG9mIGBjdXJ2ZSgpYCB3b3VsZCByZXR1cm4gZGlmZmVyZW50IGNsYXNzZXMgLVxuICogICBgY3VydmUocGFyYW1zKSAhPT0gY3VydmUocGFyYW1zKWA6IGlmIHNvbWVib2R5IGRlY2lkZWQgdG8gbW9ua2V5LXBhdGNoIHRoZWlyIGN1cnZlLFxuICogICBpdCB3b24ndCBhZmZlY3Qgb3RoZXJzXG4gKlxuICogVHlwZVNjcmlwdCBjYW4ndCBpbmZlciB0eXBlcyBmb3IgY2xhc3NlcyBjcmVhdGVkIGluc2lkZSBhIGZ1bmN0aW9uLiBDbGFzc2VzIGlzIG9uZSBpbnN0YW5jZVxuICogb2Ygbm9taW5hdGl2ZSB0eXBlcyBpbiBUeXBlU2NyaXB0IGFuZCBpbnRlcmZhY2VzIG9ubHkgY2hlY2sgZm9yIHNoYXBlLCBzbyBpdCdzIGhhcmQgdG8gY3JlYXRlXG4gKiB1bmlxdWUgdHlwZSBmb3IgZXZlcnkgZnVuY3Rpb24gY2FsbC5cbiAqXG4gKiBXZSBjYW4gdXNlIGdlbmVyaWMgdHlwZXMgdmlhIHNvbWUgcGFyYW0sIGxpa2UgY3VydmUgb3B0cywgYnV0IHRoYXQgd291bGQ6XG4gKiAgICAgMS4gRW5hYmxlIGludGVyYWN0aW9uIGJldHdlZW4gYGN1cnZlKHBhcmFtcylgIGFuZCBgY3VydmUocGFyYW1zKWAgKGN1cnZlcyBvZiBzYW1lIHBhcmFtcylcbiAqICAgICB3aGljaCBpcyBoYXJkIHRvIGRlYnVnLlxuICogICAgIDIuIFBhcmFtcyBjYW4gYmUgZ2VuZXJpYyBhbmQgd2UgY2FuJ3QgZW5mb3JjZSB0aGVtIHRvIGJlIGNvbnN0YW50IHZhbHVlOlxuICogICAgIGlmIHNvbWVib2R5IGNyZWF0ZXMgY3VydmUgZnJvbSBub24tY29uc3RhbnQgcGFyYW1zLFxuICogICAgIGl0IHdvdWxkIGJlIGFsbG93ZWQgdG8gaW50ZXJhY3Qgd2l0aCBvdGhlciBjdXJ2ZXMgd2l0aCBub24tY29uc3RhbnQgcGFyYW1zXG4gKlxuICogQHRvZG8gaHR0cHM6Ly93d3cudHlwZXNjcmlwdGxhbmcub3JnL2RvY3MvaGFuZGJvb2svcmVsZWFzZS1ub3Rlcy90eXBlc2NyaXB0LTItNy5odG1sI3VuaXF1ZS1zeW1ib2xcbiAqIEBtb2R1bGVcbiAqL1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHsgaG1hYyBhcyBub2JsZUhtYWMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL2htYWMuanMnO1xuaW1wb3J0IHsgYWhhc2ggfSBmcm9tICdAbm9ibGUvaGFzaGVzL3V0aWxzJztcbmltcG9ydCB7IF92YWxpZGF0ZU9iamVjdCwgX2Fib29sMiBhcyBhYm9vbCwgX2FieXRlczIgYXMgYWJ5dGVzLCBhSW5SYW5nZSwgYml0TGVuLCBiaXRNYXNrLCBieXRlc1RvSGV4LCBieXRlc1RvTnVtYmVyQkUsIGNvbmNhdEJ5dGVzLCBjcmVhdGVIbWFjRHJiZywgZW5zdXJlQnl0ZXMsIGhleFRvQnl0ZXMsIGluUmFuZ2UsIGlzQnl0ZXMsIG1lbW9pemVkLCBudW1iZXJUb0hleFVucGFkZGVkLCByYW5kb21CeXRlcyBhcyByYW5kb21CeXRlc1dlYiwgfSBmcm9tIFwiLi4vdXRpbHMuanNcIjtcbmltcG9ydCB7IF9jcmVhdGVDdXJ2ZUZpZWxkcywgbXVsRW5kb1Vuc2FmZSwgbmVnYXRlQ3QsIG5vcm1hbGl6ZVosIHBpcHBlbmdlciwgd05BRiwgfSBmcm9tIFwiLi9jdXJ2ZS5qc1wiO1xuaW1wb3J0IHsgRmllbGQsIEZwSW52ZXJ0QmF0Y2gsIGdldE1pbkhhc2hMZW5ndGgsIG1hcEhhc2hUb0ZpZWxkLCBuTGVuZ3RoLCB2YWxpZGF0ZUZpZWxkLCB9IGZyb20gXCIuL21vZHVsYXIuanNcIjtcbi8vIFdlIGNvbnN0cnVjdCBiYXNpcyBpbiBzdWNoIHdheSB0aGF0IGRlbiBpcyBhbHdheXMgcG9zaXRpdmUgYW5kIGVxdWFscyBuLCBidXQgbnVtIHNpZ24gZGVwZW5kcyBvbiBiYXNpcyAobm90IG9uIHNlY3JldCB2YWx1ZSlcbmNvbnN0IGRpdk5lYXJlc3QgPSAobnVtLCBkZW4pID0+IChudW0gKyAobnVtID49IDAgPyBkZW4gOiAtZGVuKSAvIF8ybikgLyBkZW47XG4vKipcbiAqIFNwbGl0cyBzY2FsYXIgZm9yIEdMViBlbmRvbW9ycGhpc20uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfc3BsaXRFbmRvU2NhbGFyKGssIGJhc2lzLCBuKSB7XG4gICAgLy8gU3BsaXQgc2NhbGFyIGludG8gdHdvIHN1Y2ggdGhhdCBwYXJ0IGlzIH5oYWxmIGJpdHM6IGBhYnMocGFydCkgPCBzcXJ0KE4pYFxuICAgIC8vIFNpbmNlIHBhcnQgY2FuIGJlIG5lZ2F0aXZlLCB3ZSBuZWVkIHRvIGRvIHRoaXMgb24gcG9pbnQuXG4gICAgLy8gVE9ETzogdmVyaWZ5U2NhbGFyIGZ1bmN0aW9uIHdoaWNoIGNvbnN1bWVzIGxhbWJkYVxuICAgIGNvbnN0IFtbYTEsIGIxXSwgW2EyLCBiMl1dID0gYmFzaXM7XG4gICAgY29uc3QgYzEgPSBkaXZOZWFyZXN0KGIyICogaywgbik7XG4gICAgY29uc3QgYzIgPSBkaXZOZWFyZXN0KC1iMSAqIGssIG4pO1xuICAgIC8vIHxrMXwvfGsyfCBpcyA8IHNxcnQoTiksIGJ1dCBjYW4gYmUgbmVnYXRpdmUuXG4gICAgLy8gSWYgd2UgZG8gYGsxIG1vZCBOYCwgd2UnbGwgZ2V0IGJpZyBzY2FsYXIgKGA+IHNxcnQoTilgKTogc28sIHdlIGRvIGNoZWFwZXIgbmVnYXRpb24gaW5zdGVhZC5cbiAgICBsZXQgazEgPSBrIC0gYzEgKiBhMSAtIGMyICogYTI7XG4gICAgbGV0IGsyID0gLWMxICogYjEgLSBjMiAqIGIyO1xuICAgIGNvbnN0IGsxbmVnID0gazEgPCBfMG47XG4gICAgY29uc3QgazJuZWcgPSBrMiA8IF8wbjtcbiAgICBpZiAoazFuZWcpXG4gICAgICAgIGsxID0gLWsxO1xuICAgIGlmIChrMm5lZylcbiAgICAgICAgazIgPSAtazI7XG4gICAgLy8gRG91YmxlIGNoZWNrIHRoYXQgcmVzdWx0aW5nIHNjYWxhciBsZXNzIHRoYW4gaGFsZiBiaXRzIG9mIE46IG90aGVyd2lzZSB3TkFGIHdpbGwgZmFpbC5cbiAgICAvLyBUaGlzIHNob3VsZCBvbmx5IGhhcHBlbiBvbiB3cm9uZyBiYXNpc2VzLiBBbHNvLCBtYXRoIGluc2lkZSBpcyB0b28gY29tcGxleCBhbmQgSSBkb24ndCB0cnVzdCBpdC5cbiAgICBjb25zdCBNQVhfTlVNID0gYml0TWFzayhNYXRoLmNlaWwoYml0TGVuKG4pIC8gMikpICsgXzFuOyAvLyBIYWxmIGJpdHMgb2YgTlxuICAgIGlmIChrMSA8IF8wbiB8fCBrMSA+PSBNQVhfTlVNIHx8IGsyIDwgXzBuIHx8IGsyID49IE1BWF9OVU0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzcGxpdFNjYWxhciAoZW5kb21vcnBoaXNtKTogZmFpbGVkLCBrPScgKyBrKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgazFuZWcsIGsxLCBrMm5lZywgazIgfTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlU2lnRm9ybWF0KGZvcm1hdCkge1xuICAgIGlmICghWydjb21wYWN0JywgJ3JlY292ZXJlZCcsICdkZXInXS5pbmNsdWRlcyhmb3JtYXQpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NpZ25hdHVyZSBmb3JtYXQgbXVzdCBiZSBcImNvbXBhY3RcIiwgXCJyZWNvdmVyZWRcIiwgb3IgXCJkZXJcIicpO1xuICAgIHJldHVybiBmb3JtYXQ7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVNpZ09wdHMob3B0cywgZGVmKSB7XG4gICAgY29uc3Qgb3B0c24gPSB7fTtcbiAgICBmb3IgKGxldCBvcHROYW1lIG9mIE9iamVjdC5rZXlzKGRlZikpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBvcHRzbltvcHROYW1lXSA9IG9wdHNbb3B0TmFtZV0gPT09IHVuZGVmaW5lZCA/IGRlZltvcHROYW1lXSA6IG9wdHNbb3B0TmFtZV07XG4gICAgfVxuICAgIGFib29sKG9wdHNuLmxvd1MsICdsb3dTJyk7XG4gICAgYWJvb2wob3B0c24ucHJlaGFzaCwgJ3ByZWhhc2gnKTtcbiAgICBpZiAob3B0c24uZm9ybWF0ICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHZhbGlkYXRlU2lnRm9ybWF0KG9wdHNuLmZvcm1hdCk7XG4gICAgcmV0dXJuIG9wdHNuO1xufVxuZXhwb3J0IGNsYXNzIERFUkVyciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtID0gJycpIHtcbiAgICAgICAgc3VwZXIobSk7XG4gICAgfVxufVxuLyoqXG4gKiBBU04uMSBERVIgZW5jb2RpbmcgdXRpbGl0aWVzLiBBU04gaXMgdmVyeSBjb21wbGV4ICYgZnJhZ2lsZS4gRm9ybWF0OlxuICpcbiAqICAgICBbMHgzMCAoU0VRVUVOQ0UpLCBieXRlbGVuZ3RoLCAweDAyIChJTlRFR0VSKSwgaW50TGVuZ3RoLCBSLCAweDAyIChJTlRFR0VSKSwgaW50TGVuZ3RoLCBTXVxuICpcbiAqIERvY3M6IGh0dHBzOi8vbGV0c2VuY3J5cHQub3JnL2RvY3MvYS13YXJtLXdlbGNvbWUtdG8tYXNuMS1hbmQtZGVyLywgaHR0cHM6Ly9sdWNhLm50b3Aub3JnL1RlYWNoaW5nL0FwcHVudGkvYXNuMS5odG1sXG4gKi9cbmV4cG9ydCBjb25zdCBERVIgPSB7XG4gICAgLy8gYXNuLjEgREVSIGVuY29kaW5nIHV0aWxzXG4gICAgRXJyOiBERVJFcnIsXG4gICAgLy8gQmFzaWMgYnVpbGRpbmcgYmxvY2sgaXMgVExWIChUYWctTGVuZ3RoLVZhbHVlKVxuICAgIF90bHY6IHtcbiAgICAgICAgZW5jb2RlOiAodGFnLCBkYXRhKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IEVycjogRSB9ID0gREVSO1xuICAgICAgICAgICAgaWYgKHRhZyA8IDAgfHwgdGFnID4gMjU2KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZW5jb2RlOiB3cm9uZyB0YWcnKTtcbiAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCAmIDEpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5lbmNvZGU6IHVucGFkZGVkIGRhdGEnKTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFMZW4gPSBkYXRhLmxlbmd0aCAvIDI7XG4gICAgICAgICAgICBjb25zdCBsZW4gPSBudW1iZXJUb0hleFVucGFkZGVkKGRhdGFMZW4pO1xuICAgICAgICAgICAgaWYgKChsZW4ubGVuZ3RoIC8gMikgJiAxMjgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5lbmNvZGU6IGxvbmcgZm9ybSBsZW5ndGggdG9vIGJpZycpO1xuICAgICAgICAgICAgLy8gbGVuZ3RoIG9mIGxlbmd0aCB3aXRoIGxvbmcgZm9ybSBmbGFnXG4gICAgICAgICAgICBjb25zdCBsZW5MZW4gPSBkYXRhTGVuID4gMTI3ID8gbnVtYmVyVG9IZXhVbnBhZGRlZCgobGVuLmxlbmd0aCAvIDIpIHwgMTI4KSA6ICcnO1xuICAgICAgICAgICAgY29uc3QgdCA9IG51bWJlclRvSGV4VW5wYWRkZWQodGFnKTtcbiAgICAgICAgICAgIHJldHVybiB0ICsgbGVuTGVuICsgbGVuICsgZGF0YTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gdiAtIHZhbHVlLCBsIC0gbGVmdCBieXRlcyAodW5wYXJzZWQpXG4gICAgICAgIGRlY29kZSh0YWcsIGRhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgRXJyOiBFIH0gPSBERVI7XG4gICAgICAgICAgICBsZXQgcG9zID0gMDtcbiAgICAgICAgICAgIGlmICh0YWcgPCAwIHx8IHRhZyA+IDI1NilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmVuY29kZTogd3JvbmcgdGFnJyk7XG4gICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggPCAyIHx8IGRhdGFbcG9zKytdICE9PSB0YWcpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5kZWNvZGU6IHdyb25nIHRsdicpO1xuICAgICAgICAgICAgY29uc3QgZmlyc3QgPSBkYXRhW3BvcysrXTtcbiAgICAgICAgICAgIGNvbnN0IGlzTG9uZyA9ICEhKGZpcnN0ICYgMTI4KTsgLy8gRmlyc3QgYml0IG9mIGZpcnN0IGxlbmd0aCBieXRlIGlzIGZsYWcgZm9yIHNob3J0L2xvbmcgZm9ybVxuICAgICAgICAgICAgbGV0IGxlbmd0aCA9IDA7XG4gICAgICAgICAgICBpZiAoIWlzTG9uZylcbiAgICAgICAgICAgICAgICBsZW5ndGggPSBmaXJzdDtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIExvbmcgZm9ybTogW2xvbmdGbGFnKDFiaXQpLCBsZW5ndGhMZW5ndGgoN2JpdCksIGxlbmd0aCAoQkUpXVxuICAgICAgICAgICAgICAgIGNvbnN0IGxlbkxlbiA9IGZpcnN0ICYgMTI3O1xuICAgICAgICAgICAgICAgIGlmICghbGVuTGVuKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmRlY29kZShsb25nKTogaW5kZWZpbml0ZSBsZW5ndGggbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgICAgIGlmIChsZW5MZW4gPiA0KVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmRlY29kZShsb25nKTogYnl0ZSBsZW5ndGggaXMgdG9vIGJpZycpOyAvLyB0aGlzIHdpbGwgb3ZlcmZsb3cgdTMyIGluIGpzXG4gICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoQnl0ZXMgPSBkYXRhLnN1YmFycmF5KHBvcywgcG9zICsgbGVuTGVuKTtcbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoQnl0ZXMubGVuZ3RoICE9PSBsZW5MZW4pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZGVjb2RlOiBsZW5ndGggYnl0ZXMgbm90IGNvbXBsZXRlJyk7XG4gICAgICAgICAgICAgICAgaWYgKGxlbmd0aEJ5dGVzWzBdID09PSAwKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmRlY29kZShsb25nKTogemVybyBsZWZ0bW9zdCBieXRlJyk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBiIG9mIGxlbmd0aEJ5dGVzKVxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSAobGVuZ3RoIDw8IDgpIHwgYjtcbiAgICAgICAgICAgICAgICBwb3MgKz0gbGVuTGVuO1xuICAgICAgICAgICAgICAgIGlmIChsZW5ndGggPCAxMjgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZGVjb2RlKGxvbmcpOiBub3QgbWluaW1hbCBlbmNvZGluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdiA9IGRhdGEuc3ViYXJyYXkocG9zLCBwb3MgKyBsZW5ndGgpO1xuICAgICAgICAgICAgaWYgKHYubGVuZ3RoICE9PSBsZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5kZWNvZGU6IHdyb25nIHZhbHVlIGxlbmd0aCcpO1xuICAgICAgICAgICAgcmV0dXJuIHsgdiwgbDogZGF0YS5zdWJhcnJheShwb3MgKyBsZW5ndGgpIH07XG4gICAgICAgIH0sXG4gICAgfSxcbiAgICAvLyBodHRwczovL2NyeXB0by5zdGFja2V4Y2hhbmdlLmNvbS9hLzU3NzM0IExlZnRtb3N0IGJpdCBvZiBmaXJzdCBieXRlIGlzICduZWdhdGl2ZScgZmxhZyxcbiAgICAvLyBzaW5jZSB3ZSBhbHdheXMgdXNlIHBvc2l0aXZlIGludGVnZXJzIGhlcmUuIEl0IG11c3QgYWx3YXlzIGJlIGVtcHR5OlxuICAgIC8vIC0gYWRkIHplcm8gYnl0ZSBpZiBleGlzdHNcbiAgICAvLyAtIGlmIG5leHQgYnl0ZSBkb2Vzbid0IGhhdmUgYSBmbGFnLCBsZWFkaW5nIHplcm8gaXMgbm90IGFsbG93ZWQgKG1pbmltYWwgZW5jb2RpbmcpXG4gICAgX2ludDoge1xuICAgICAgICBlbmNvZGUobnVtKSB7XG4gICAgICAgICAgICBjb25zdCB7IEVycjogRSB9ID0gREVSO1xuICAgICAgICAgICAgaWYgKG51bSA8IF8wbilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgnaW50ZWdlcjogbmVnYXRpdmUgaW50ZWdlcnMgYXJlIG5vdCBhbGxvd2VkJyk7XG4gICAgICAgICAgICBsZXQgaGV4ID0gbnVtYmVyVG9IZXhVbnBhZGRlZChudW0pO1xuICAgICAgICAgICAgLy8gUGFkIHdpdGggemVybyBieXRlIGlmIG5lZ2F0aXZlIGZsYWcgaXMgcHJlc2VudFxuICAgICAgICAgICAgaWYgKE51bWJlci5wYXJzZUludChoZXhbMF0sIDE2KSAmIDBiMTAwMClcbiAgICAgICAgICAgICAgICBoZXggPSAnMDAnICsgaGV4O1xuICAgICAgICAgICAgaWYgKGhleC5sZW5ndGggJiAxKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd1bmV4cGVjdGVkIERFUiBwYXJzaW5nIGFzc2VydGlvbjogdW5wYWRkZWQgaGV4Jyk7XG4gICAgICAgICAgICByZXR1cm4gaGV4O1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGUoZGF0YSkge1xuICAgICAgICAgICAgY29uc3QgeyBFcnI6IEUgfSA9IERFUjtcbiAgICAgICAgICAgIGlmIChkYXRhWzBdICYgMTI4KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCdpbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiBuZWdhdGl2ZScpO1xuICAgICAgICAgICAgaWYgKGRhdGFbMF0gPT09IDB4MDAgJiYgIShkYXRhWzFdICYgMTI4KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgnaW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogdW5uZWNlc3NhcnkgbGVhZGluZyB6ZXJvJyk7XG4gICAgICAgICAgICByZXR1cm4gYnl0ZXNUb051bWJlckJFKGRhdGEpO1xuICAgICAgICB9LFxuICAgIH0sXG4gICAgdG9TaWcoaGV4KSB7XG4gICAgICAgIC8vIHBhcnNlIERFUiBzaWduYXR1cmVcbiAgICAgICAgY29uc3QgeyBFcnI6IEUsIF9pbnQ6IGludCwgX3RsdjogdGx2IH0gPSBERVI7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBlbnN1cmVCeXRlcygnc2lnbmF0dXJlJywgaGV4KTtcbiAgICAgICAgY29uc3QgeyB2OiBzZXFCeXRlcywgbDogc2VxTGVmdEJ5dGVzIH0gPSB0bHYuZGVjb2RlKDB4MzAsIGRhdGEpO1xuICAgICAgICBpZiAoc2VxTGVmdEJ5dGVzLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdpbnZhbGlkIHNpZ25hdHVyZTogbGVmdCBieXRlcyBhZnRlciBwYXJzaW5nJyk7XG4gICAgICAgIGNvbnN0IHsgdjogckJ5dGVzLCBsOiByTGVmdEJ5dGVzIH0gPSB0bHYuZGVjb2RlKDB4MDIsIHNlcUJ5dGVzKTtcbiAgICAgICAgY29uc3QgeyB2OiBzQnl0ZXMsIGw6IHNMZWZ0Qnl0ZXMgfSA9IHRsdi5kZWNvZGUoMHgwMiwgckxlZnRCeXRlcyk7XG4gICAgICAgIGlmIChzTGVmdEJ5dGVzLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdpbnZhbGlkIHNpZ25hdHVyZTogbGVmdCBieXRlcyBhZnRlciBwYXJzaW5nJyk7XG4gICAgICAgIHJldHVybiB7IHI6IGludC5kZWNvZGUockJ5dGVzKSwgczogaW50LmRlY29kZShzQnl0ZXMpIH07XG4gICAgfSxcbiAgICBoZXhGcm9tU2lnKHNpZykge1xuICAgICAgICBjb25zdCB7IF90bHY6IHRsdiwgX2ludDogaW50IH0gPSBERVI7XG4gICAgICAgIGNvbnN0IHJzID0gdGx2LmVuY29kZSgweDAyLCBpbnQuZW5jb2RlKHNpZy5yKSk7XG4gICAgICAgIGNvbnN0IHNzID0gdGx2LmVuY29kZSgweDAyLCBpbnQuZW5jb2RlKHNpZy5zKSk7XG4gICAgICAgIGNvbnN0IHNlcSA9IHJzICsgc3M7XG4gICAgICAgIHJldHVybiB0bHYuZW5jb2RlKDB4MzAsIHNlcSk7XG4gICAgfSxcbn07XG4vLyBCZSBmcmllbmRseSB0byBiYWQgRUNNQVNjcmlwdCBwYXJzZXJzIGJ5IG5vdCB1c2luZyBiaWdpbnQgbGl0ZXJhbHNcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzBuID0gQmlnSW50KDApLCBfMW4gPSBCaWdJbnQoMSksIF8ybiA9IEJpZ0ludCgyKSwgXzNuID0gQmlnSW50KDMpLCBfNG4gPSBCaWdJbnQoNCk7XG5leHBvcnQgZnVuY3Rpb24gX25vcm1GbkVsZW1lbnQoRm4sIGtleSkge1xuICAgIGNvbnN0IHsgQllURVM6IGV4cGVjdGVkIH0gPSBGbjtcbiAgICBsZXQgbnVtO1xuICAgIGlmICh0eXBlb2Yga2V5ID09PSAnYmlnaW50Jykge1xuICAgICAgICBudW0gPSBrZXk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgYnl0ZXMgPSBlbnN1cmVCeXRlcygncHJpdmF0ZSBrZXknLCBrZXkpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbnVtID0gRm4uZnJvbUJ5dGVzKGJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBwcml2YXRlIGtleTogZXhwZWN0ZWQgdWk4YSBvZiBzaXplICR7ZXhwZWN0ZWR9LCBnb3QgJHt0eXBlb2Yga2V5fWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghRm4uaXNWYWxpZE5vdDAobnVtKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHByaXZhdGUga2V5OiBvdXQgb2YgcmFuZ2UgWzEuLk4tMV0nKTtcbiAgICByZXR1cm4gbnVtO1xufVxuLyoqXG4gKiBDcmVhdGVzIHdlaWVyc3RyYXNzIFBvaW50IGNvbnN0cnVjdG9yLCBiYXNlZCBvbiBzcGVjaWZpZWQgY3VydmUgb3B0aW9ucy5cbiAqXG4gKiBAZXhhbXBsZVxuYGBganNcbmNvbnN0IG9wdHMgPSB7XG4gIHA6IEJpZ0ludCgnMHhmZmZmZmZmZjAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmJyksXG4gIG46IEJpZ0ludCgnMHhmZmZmZmZmZjAwMDAwMDAwZmZmZmZmZmZmZmZmZmZmZmJjZTZmYWFkYTcxNzllODRmM2I5Y2FjMmZjNjMyNTUxJyksXG4gIGg6IEJpZ0ludCgxKSxcbiAgYTogQmlnSW50KCcweGZmZmZmZmZmMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmMnKSxcbiAgYjogQmlnSW50KCcweDVhYzYzNWQ4YWEzYTkzZTdiM2ViYmQ1NTc2OTg4NmJjNjUxZDA2YjBjYzUzYjBmNjNiY2UzYzNlMjdkMjYwNGInKSxcbiAgR3g6IEJpZ0ludCgnMHg2YjE3ZDFmMmUxMmM0MjQ3ZjhiY2U2ZTU2M2E0NDBmMjc3MDM3ZDgxMmRlYjMzYTBmNGExMzk0NWQ4OThjMjk2JyksXG4gIEd5OiBCaWdJbnQoJzB4NGZlMzQyZTJmZTFhN2Y5YjhlZTdlYjRhN2MwZjllMTYyYmNlMzM1NzZiMzE1ZWNlY2JiNjQwNjgzN2JmNTFmNScpLFxufTtcbmNvbnN0IHAyNTZfUG9pbnQgPSB3ZWllcnN0cmFzcyhvcHRzKTtcbmBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gd2VpZXJzdHJhc3NOKHBhcmFtcywgZXh0cmFPcHRzID0ge30pIHtcbiAgICBjb25zdCB2YWxpZGF0ZWQgPSBfY3JlYXRlQ3VydmVGaWVsZHMoJ3dlaWVyc3RyYXNzJywgcGFyYW1zLCBleHRyYU9wdHMpO1xuICAgIGNvbnN0IHsgRnAsIEZuIH0gPSB2YWxpZGF0ZWQ7XG4gICAgbGV0IENVUlZFID0gdmFsaWRhdGVkLkNVUlZFO1xuICAgIGNvbnN0IHsgaDogY29mYWN0b3IsIG46IENVUlZFX09SREVSIH0gPSBDVVJWRTtcbiAgICBfdmFsaWRhdGVPYmplY3QoZXh0cmFPcHRzLCB7fSwge1xuICAgICAgICBhbGxvd0luZmluaXR5UG9pbnQ6ICdib29sZWFuJyxcbiAgICAgICAgY2xlYXJDb2ZhY3RvcjogJ2Z1bmN0aW9uJyxcbiAgICAgICAgaXNUb3JzaW9uRnJlZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgZnJvbUJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgICAgICB0b0J5dGVzOiAnZnVuY3Rpb24nLFxuICAgICAgICBlbmRvOiAnb2JqZWN0JyxcbiAgICAgICAgd3JhcFByaXZhdGVLZXk6ICdib29sZWFuJyxcbiAgICB9KTtcbiAgICBjb25zdCB7IGVuZG8gfSA9IGV4dHJhT3B0cztcbiAgICBpZiAoZW5kbykge1xuICAgICAgICAvLyB2YWxpZGF0ZU9iamVjdChlbmRvLCB7IGJldGE6ICdiaWdpbnQnLCBzcGxpdFNjYWxhcjogJ2Z1bmN0aW9uJyB9KTtcbiAgICAgICAgaWYgKCFGcC5pczAoQ1VSVkUuYSkgfHwgdHlwZW9mIGVuZG8uYmV0YSAhPT0gJ2JpZ2ludCcgfHwgIUFycmF5LmlzQXJyYXkoZW5kby5iYXNpc2VzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGVuZG86IGV4cGVjdGVkIFwiYmV0YVwiOiBiaWdpbnQgYW5kIFwiYmFzaXNlc1wiOiBhcnJheScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGxlbmd0aHMgPSBnZXRXTGVuZ3RocyhGcCwgRm4pO1xuICAgIGZ1bmN0aW9uIGFzc2VydENvbXByZXNzaW9uSXNTdXBwb3J0ZWQoKSB7XG4gICAgICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbXByZXNzaW9uIGlzIG5vdCBzdXBwb3J0ZWQ6IEZpZWxkIGRvZXMgbm90IGhhdmUgLmlzT2RkKCknKTtcbiAgICB9XG4gICAgLy8gSW1wbGVtZW50cyBJRUVFIFAxMzYzIHBvaW50IGVuY29kaW5nXG4gICAgZnVuY3Rpb24gcG9pbnRUb0J5dGVzKF9jLCBwb2ludCwgaXNDb21wcmVzc2VkKSB7XG4gICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gcG9pbnQudG9BZmZpbmUoKTtcbiAgICAgICAgY29uc3QgYnggPSBGcC50b0J5dGVzKHgpO1xuICAgICAgICBhYm9vbChpc0NvbXByZXNzZWQsICdpc0NvbXByZXNzZWQnKTtcbiAgICAgICAgaWYgKGlzQ29tcHJlc3NlZCkge1xuICAgICAgICAgICAgYXNzZXJ0Q29tcHJlc3Npb25Jc1N1cHBvcnRlZCgpO1xuICAgICAgICAgICAgY29uc3QgaGFzRXZlblkgPSAhRnAuaXNPZGQoeSk7XG4gICAgICAgICAgICByZXR1cm4gY29uY2F0Qnl0ZXMocHByZWZpeChoYXNFdmVuWSksIGJ4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjb25jYXRCeXRlcyhVaW50OEFycmF5Lm9mKDB4MDQpLCBieCwgRnAudG9CeXRlcyh5KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcG9pbnRGcm9tQnl0ZXMoYnl0ZXMpIHtcbiAgICAgICAgYWJ5dGVzKGJ5dGVzLCB1bmRlZmluZWQsICdQb2ludCcpO1xuICAgICAgICBjb25zdCB7IHB1YmxpY0tleTogY29tcCwgcHVibGljS2V5VW5jb21wcmVzc2VkOiB1bmNvbXAgfSA9IGxlbmd0aHM7IC8vIGUuZy4gZm9yIDMyLWJ5dGU6IDMzLCA2NVxuICAgICAgICBjb25zdCBsZW5ndGggPSBieXRlcy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGhlYWQgPSBieXRlc1swXTtcbiAgICAgICAgY29uc3QgdGFpbCA9IGJ5dGVzLnN1YmFycmF5KDEpO1xuICAgICAgICAvLyBObyBhY3R1YWwgdmFsaWRhdGlvbiBpcyBkb25lIGhlcmU6IHVzZSAuYXNzZXJ0VmFsaWRpdHkoKVxuICAgICAgICBpZiAobGVuZ3RoID09PSBjb21wICYmIChoZWFkID09PSAweDAyIHx8IGhlYWQgPT09IDB4MDMpKSB7XG4gICAgICAgICAgICBjb25zdCB4ID0gRnAuZnJvbUJ5dGVzKHRhaWwpO1xuICAgICAgICAgICAgaWYgKCFGcC5pc1ZhbGlkKHgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBpcyBub3Qgb24gY3VydmUsIHdyb25nIHgnKTtcbiAgICAgICAgICAgIGNvbnN0IHkyID0gd2VpZXJzdHJhc3NFcXVhdGlvbih4KTsgLy8gecKyID0geMKzICsgYXggKyBiXG4gICAgICAgICAgICBsZXQgeTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgeSA9IEZwLnNxcnQoeTIpOyAvLyB5ID0gecKyIF4gKHArMSkvNFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKHNxcnRFcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVyciA9IHNxcnRFcnJvciBpbnN0YW5jZW9mIEVycm9yID8gJzogJyArIHNxcnRFcnJvci5tZXNzYWdlIDogJyc7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IGlzIG5vdCBvbiBjdXJ2ZSwgc3FydCBlcnJvcicgKyBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0Q29tcHJlc3Npb25Jc1N1cHBvcnRlZCgpO1xuICAgICAgICAgICAgY29uc3QgaXNZT2RkID0gRnAuaXNPZGQoeSk7IC8vICh5ICYgXzFuKSA9PT0gXzFuO1xuICAgICAgICAgICAgY29uc3QgaXNIZWFkT2RkID0gKGhlYWQgJiAxKSA9PT0gMTsgLy8gRUNEU0Etc3BlY2lmaWNcbiAgICAgICAgICAgIGlmIChpc0hlYWRPZGQgIT09IGlzWU9kZClcbiAgICAgICAgICAgICAgICB5ID0gRnAubmVnKHkpO1xuICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5jb21wICYmIGhlYWQgPT09IDB4MDQpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IG1vcmUgY2hlY2tzXG4gICAgICAgICAgICBjb25zdCBMID0gRnAuQllURVM7XG4gICAgICAgICAgICBjb25zdCB4ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoMCwgTCkpO1xuICAgICAgICAgICAgY29uc3QgeSA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KEwsIEwgKiAyKSk7XG4gICAgICAgICAgICBpZiAoIWlzVmFsaWRYWSh4LCB5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogaXMgbm90IG9uIGN1cnZlJyk7XG4gICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJhZCBwb2ludDogZ290IGxlbmd0aCAke2xlbmd0aH0sIGV4cGVjdGVkIGNvbXByZXNzZWQ9JHtjb21wfSBvciB1bmNvbXByZXNzZWQ9JHt1bmNvbXB9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZW5jb2RlUG9pbnQgPSBleHRyYU9wdHMudG9CeXRlcyB8fCBwb2ludFRvQnl0ZXM7XG4gICAgY29uc3QgZGVjb2RlUG9pbnQgPSBleHRyYU9wdHMuZnJvbUJ5dGVzIHx8IHBvaW50RnJvbUJ5dGVzO1xuICAgIGZ1bmN0aW9uIHdlaWVyc3RyYXNzRXF1YXRpb24oeCkge1xuICAgICAgICBjb25zdCB4MiA9IEZwLnNxcih4KTsgLy8geCAqIHhcbiAgICAgICAgY29uc3QgeDMgPSBGcC5tdWwoeDIsIHgpOyAvLyB4wrIgKiB4XG4gICAgICAgIHJldHVybiBGcC5hZGQoRnAuYWRkKHgzLCBGcC5tdWwoeCwgQ1VSVkUuYSkpLCBDVVJWRS5iKTsgLy8geMKzICsgYSAqIHggKyBiXG4gICAgfVxuICAgIC8vIFRPRE86IG1vdmUgdG9wLWxldmVsXG4gICAgLyoqIENoZWNrcyB3aGV0aGVyIGVxdWF0aW9uIGhvbGRzIGZvciBnaXZlbiB4LCB5OiB5wrIgPT0geMKzICsgYXggKyBiICovXG4gICAgZnVuY3Rpb24gaXNWYWxpZFhZKHgsIHkpIHtcbiAgICAgICAgY29uc3QgbGVmdCA9IEZwLnNxcih5KTsgLy8gecKyXG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gd2VpZXJzdHJhc3NFcXVhdGlvbih4KTsgLy8geMKzICsgYXggKyBiXG4gICAgICAgIHJldHVybiBGcC5lcWwobGVmdCwgcmlnaHQpO1xuICAgIH1cbiAgICAvLyBWYWxpZGF0ZSB3aGV0aGVyIHRoZSBwYXNzZWQgY3VydmUgcGFyYW1zIGFyZSB2YWxpZC5cbiAgICAvLyBUZXN0IDE6IGVxdWF0aW9uIHnCsiA9IHjCsyArIGF4ICsgYiBzaG91bGQgd29yayBmb3IgZ2VuZXJhdG9yIHBvaW50LlxuICAgIGlmICghaXNWYWxpZFhZKENVUlZFLkd4LCBDVVJWRS5HeSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIGN1cnZlIHBhcmFtczogZ2VuZXJhdG9yIHBvaW50Jyk7XG4gICAgLy8gVGVzdCAyOiBkaXNjcmltaW5hbnQgzpQgcGFydCBzaG91bGQgYmUgbm9uLXplcm86IDRhwrMgKyAyN2LCsiAhPSAwLlxuICAgIC8vIEd1YXJhbnRlZXMgY3VydmUgaXMgZ2VudXMtMSwgc21vb3RoIChub24tc2luZ3VsYXIpLlxuICAgIGNvbnN0IF80YTMgPSBGcC5tdWwoRnAucG93KENVUlZFLmEsIF8zbiksIF80bik7XG4gICAgY29uc3QgXzI3YjIgPSBGcC5tdWwoRnAuc3FyKENVUlZFLmIpLCBCaWdJbnQoMjcpKTtcbiAgICBpZiAoRnAuaXMwKEZwLmFkZChfNGEzLCBfMjdiMikpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBjdXJ2ZSBwYXJhbXM6IGEgb3IgYicpO1xuICAgIC8qKiBBc3NlcnRzIGNvb3JkaW5hdGUgaXMgdmFsaWQ6IDAgPD0gbiA8IEZwLk9SREVSLiAqL1xuICAgIGZ1bmN0aW9uIGFjb29yZCh0aXRsZSwgbiwgYmFuWmVybyA9IGZhbHNlKSB7XG4gICAgICAgIGlmICghRnAuaXNWYWxpZChuKSB8fCAoYmFuWmVybyAmJiBGcC5pczAobikpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiYWQgcG9pbnQgY29vcmRpbmF0ZSAke3RpdGxlfWApO1xuICAgICAgICByZXR1cm4gbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXByanBvaW50KG90aGVyKSB7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgUG9pbnQpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9qZWN0aXZlUG9pbnQgZXhwZWN0ZWQnKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3BsaXRFbmRvU2NhbGFyTihrKSB7XG4gICAgICAgIGlmICghZW5kbyB8fCAhZW5kby5iYXNpc2VzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBlbmRvJyk7XG4gICAgICAgIHJldHVybiBfc3BsaXRFbmRvU2NhbGFyKGssIGVuZG8uYmFzaXNlcywgRm4uT1JERVIpO1xuICAgIH1cbiAgICAvLyBNZW1vaXplZCB0b0FmZmluZSAvIHZhbGlkaXR5IGNoZWNrLiBUaGV5IGFyZSBoZWF2eS4gUG9pbnRzIGFyZSBpbW11dGFibGUuXG4gICAgLy8gQ29udmVydHMgUHJvamVjdGl2ZSBwb2ludCB0byBhZmZpbmUgKHgsIHkpIGNvb3JkaW5hdGVzLlxuICAgIC8vIENhbiBhY2NlcHQgcHJlY29tcHV0ZWQgWl4tMSAtIGZvciBleGFtcGxlLCBmcm9tIGludmVydEJhdGNoLlxuICAgIC8vIChYLCBZLCBaKSDiiIsgKHg9WC9aLCB5PVkvWilcbiAgICBjb25zdCB0b0FmZmluZU1lbW8gPSBtZW1vaXplZCgocCwgaXopID0+IHtcbiAgICAgICAgY29uc3QgeyBYLCBZLCBaIH0gPSBwO1xuICAgICAgICAvLyBGYXN0LXBhdGggZm9yIG5vcm1hbGl6ZWQgcG9pbnRzXG4gICAgICAgIGlmIChGcC5lcWwoWiwgRnAuT05FKSlcbiAgICAgICAgICAgIHJldHVybiB7IHg6IFgsIHk6IFkgfTtcbiAgICAgICAgY29uc3QgaXMwID0gcC5pczAoKTtcbiAgICAgICAgLy8gSWYgaW52WiB3YXMgMCwgd2UgcmV0dXJuIHplcm8gcG9pbnQuIEhvd2V2ZXIgd2Ugc3RpbGwgd2FudCB0byBleGVjdXRlXG4gICAgICAgIC8vIGFsbCBvcGVyYXRpb25zLCBzbyB3ZSByZXBsYWNlIGludlogd2l0aCBhIHJhbmRvbSBudW1iZXIsIDEuXG4gICAgICAgIGlmIChpeiA9PSBudWxsKVxuICAgICAgICAgICAgaXogPSBpczAgPyBGcC5PTkUgOiBGcC5pbnYoWik7XG4gICAgICAgIGNvbnN0IHggPSBGcC5tdWwoWCwgaXopO1xuICAgICAgICBjb25zdCB5ID0gRnAubXVsKFksIGl6KTtcbiAgICAgICAgY29uc3QgenogPSBGcC5tdWwoWiwgaXopO1xuICAgICAgICBpZiAoaXMwKVxuICAgICAgICAgICAgcmV0dXJuIHsgeDogRnAuWkVSTywgeTogRnAuWkVSTyB9O1xuICAgICAgICBpZiAoIUZwLmVxbCh6eiwgRnAuT05FKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52WiB3YXMgaW52YWxpZCcpO1xuICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgfSk7XG4gICAgLy8gTk9URTogb24gZXhjZXB0aW9uIHRoaXMgd2lsbCBjcmFzaCAnY2FjaGVkJyBhbmQgbm8gdmFsdWUgd2lsbCBiZSBzZXQuXG4gICAgLy8gT3RoZXJ3aXNlIHRydWUgd2lsbCBiZSByZXR1cm5cbiAgICBjb25zdCBhc3NlcnRWYWxpZE1lbW8gPSBtZW1vaXplZCgocCkgPT4ge1xuICAgICAgICBpZiAocC5pczAoKSkge1xuICAgICAgICAgICAgLy8gKDAsIDEsIDApIGFrYSBaRVJPIGlzIGludmFsaWQgaW4gbW9zdCBjb250ZXh0cy5cbiAgICAgICAgICAgIC8vIEluIEJMUywgWkVSTyBjYW4gYmUgc2VyaWFsaXplZCwgc28gd2UgYWxsb3cgaXQuXG4gICAgICAgICAgICAvLyAoMCwgMCwgMCkgaXMgaW52YWxpZCByZXByZXNlbnRhdGlvbiBvZiBaRVJPLlxuICAgICAgICAgICAgaWYgKGV4dHJhT3B0cy5hbGxvd0luZmluaXR5UG9pbnQgJiYgIUZwLmlzMChwLlkpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBaRVJPJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29tZSAzcmQtcGFydHkgdGVzdCB2ZWN0b3JzIHJlcXVpcmUgZGlmZmVyZW50IHdvcmRpbmcgYmV0d2VlbiBoZXJlICYgYGZyb21Db21wcmVzc2VkSGV4YFxuICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHAudG9BZmZpbmUoKTtcbiAgICAgICAgaWYgKCFGcC5pc1ZhbGlkKHgpIHx8ICFGcC5pc1ZhbGlkKHkpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IHggb3IgeSBub3QgZmllbGQgZWxlbWVudHMnKTtcbiAgICAgICAgaWYgKCFpc1ZhbGlkWFkoeCwgeSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogZXF1YXRpb24gbGVmdCAhPSByaWdodCcpO1xuICAgICAgICBpZiAoIXAuaXNUb3JzaW9uRnJlZSgpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IG5vdCBpbiBwcmltZS1vcmRlciBzdWJncm91cCcpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBmaW5pc2hFbmRvKGVuZG9CZXRhLCBrMXAsIGsycCwgazFuZWcsIGsybmVnKSB7XG4gICAgICAgIGsycCA9IG5ldyBQb2ludChGcC5tdWwoazJwLlgsIGVuZG9CZXRhKSwgazJwLlksIGsycC5aKTtcbiAgICAgICAgazFwID0gbmVnYXRlQ3QoazFuZWcsIGsxcCk7XG4gICAgICAgIGsycCA9IG5lZ2F0ZUN0KGsybmVnLCBrMnApO1xuICAgICAgICByZXR1cm4gazFwLmFkZChrMnApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9qZWN0aXZlIFBvaW50IHdvcmtzIGluIDNkIC8gcHJvamVjdGl2ZSAoaG9tb2dlbmVvdXMpIGNvb3JkaW5hdGVzOihYLCBZLCBaKSDiiIsgKHg9WC9aLCB5PVkvWikuXG4gICAgICogRGVmYXVsdCBQb2ludCB3b3JrcyBpbiAyZCAvIGFmZmluZSBjb29yZGluYXRlczogKHgsIHkpLlxuICAgICAqIFdlJ3JlIGRvaW5nIGNhbGN1bGF0aW9ucyBpbiBwcm9qZWN0aXZlLCBiZWNhdXNlIGl0cyBvcGVyYXRpb25zIGRvbid0IHJlcXVpcmUgY29zdGx5IGludmVyc2lvbi5cbiAgICAgKi9cbiAgICBjbGFzcyBQb2ludCB7XG4gICAgICAgIC8qKiBEb2VzIE5PVCB2YWxpZGF0ZSBpZiB0aGUgcG9pbnQgaXMgdmFsaWQuIFVzZSBgLmFzc2VydFZhbGlkaXR5KClgLiAqL1xuICAgICAgICBjb25zdHJ1Y3RvcihYLCBZLCBaKSB7XG4gICAgICAgICAgICB0aGlzLlggPSBhY29vcmQoJ3gnLCBYKTtcbiAgICAgICAgICAgIHRoaXMuWSA9IGFjb29yZCgneScsIFksIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5aID0gYWNvb3JkKCd6JywgWik7XG4gICAgICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBDVVJWRSgpIHtcbiAgICAgICAgICAgIHJldHVybiBDVVJWRTtcbiAgICAgICAgfVxuICAgICAgICAvKiogRG9lcyBOT1QgdmFsaWRhdGUgaWYgdGhlIHBvaW50IGlzIHZhbGlkLiBVc2UgYC5hc3NlcnRWYWxpZGl0eSgpYC4gKi9cbiAgICAgICAgc3RhdGljIGZyb21BZmZpbmUocCkge1xuICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBwIHx8IHt9O1xuICAgICAgICAgICAgaWYgKCFwIHx8ICFGcC5pc1ZhbGlkKHgpIHx8ICFGcC5pc1ZhbGlkKHkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhZmZpbmUgcG9pbnQnKTtcbiAgICAgICAgICAgIGlmIChwIGluc3RhbmNlb2YgUG9pbnQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcm9qZWN0aXZlIHBvaW50IG5vdCBhbGxvd2VkJyk7XG4gICAgICAgICAgICAvLyAoMCwgMCkgd291bGQndmUgcHJvZHVjZWQgKDAsIDAsIDEpIC0gaW5zdGVhZCwgd2UgbmVlZCAoMCwgMSwgMClcbiAgICAgICAgICAgIGlmIChGcC5pczAoeCkgJiYgRnAuaXMwKHkpKVxuICAgICAgICAgICAgICAgIHJldHVybiBQb2ludC5aRVJPO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh4LCB5LCBGcC5PTkUpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBmcm9tQnl0ZXMoYnl0ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IFAgPSBQb2ludC5mcm9tQWZmaW5lKGRlY29kZVBvaW50KGFieXRlcyhieXRlcywgdW5kZWZpbmVkLCAncG9pbnQnKSkpO1xuICAgICAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFA7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGZyb21IZXgoaGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gUG9pbnQuZnJvbUJ5dGVzKGVuc3VyZUJ5dGVzKCdwb2ludEhleCcsIGhleCkpO1xuICAgICAgICB9XG4gICAgICAgIGdldCB4KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9BZmZpbmUoKS54O1xuICAgICAgICB9XG4gICAgICAgIGdldCB5KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9BZmZpbmUoKS55O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gd2luZG93U2l6ZVxuICAgICAgICAgKiBAcGFyYW0gaXNMYXp5IHRydWUgd2lsbCBkZWZlciB0YWJsZSBjb21wdXRhdGlvbiB1bnRpbCB0aGUgZmlyc3QgbXVsdGlwbGljYXRpb25cbiAgICAgICAgICogQHJldHVybnNcbiAgICAgICAgICovXG4gICAgICAgIHByZWNvbXB1dGUod2luZG93U2l6ZSA9IDgsIGlzTGF6eSA9IHRydWUpIHtcbiAgICAgICAgICAgIHduYWYuY3JlYXRlQ2FjaGUodGhpcywgd2luZG93U2l6ZSk7XG4gICAgICAgICAgICBpZiAoIWlzTGF6eSlcbiAgICAgICAgICAgICAgICB0aGlzLm11bHRpcGx5KF8zbik7IC8vIHJhbmRvbSBudW1iZXJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IHJldHVybiBgdGhpc2BcbiAgICAgICAgLyoqIEEgcG9pbnQgb24gY3VydmUgaXMgdmFsaWQgaWYgaXQgY29uZm9ybXMgdG8gZXF1YXRpb24uICovXG4gICAgICAgIGFzc2VydFZhbGlkaXR5KCkge1xuICAgICAgICAgICAgYXNzZXJ0VmFsaWRNZW1vKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGhhc0V2ZW5ZKCkge1xuICAgICAgICAgICAgY29uc3QgeyB5IH0gPSB0aGlzLnRvQWZmaW5lKCk7XG4gICAgICAgICAgICBpZiAoIUZwLmlzT2RkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZpZWxkIGRvZXNuJ3Qgc3VwcG9ydCBpc09kZFwiKTtcbiAgICAgICAgICAgIHJldHVybiAhRnAuaXNPZGQoeSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIENvbXBhcmUgb25lIHBvaW50IHRvIGFub3RoZXIuICovXG4gICAgICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICAgICAgYXByanBvaW50KG90aGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgWDogWDEsIFk6IFkxLCBaOiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgWDogWDIsIFk6IFkyLCBaOiBaMiB9ID0gb3RoZXI7XG4gICAgICAgICAgICBjb25zdCBVMSA9IEZwLmVxbChGcC5tdWwoWDEsIFoyKSwgRnAubXVsKFgyLCBaMSkpO1xuICAgICAgICAgICAgY29uc3QgVTIgPSBGcC5lcWwoRnAubXVsKFkxLCBaMiksIEZwLm11bChZMiwgWjEpKTtcbiAgICAgICAgICAgIHJldHVybiBVMSAmJiBVMjtcbiAgICAgICAgfVxuICAgICAgICAvKiogRmxpcHMgcG9pbnQgdG8gb25lIGNvcnJlc3BvbmRpbmcgdG8gKHgsIC15KSBpbiBBZmZpbmUgY29vcmRpbmF0ZXMuICovXG4gICAgICAgIG5lZ2F0ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy5YLCBGcC5uZWcodGhpcy5ZKSwgdGhpcy5aKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW5lcy1Db3N0ZWxsby1CYXRpbmEgZXhjZXB0aW9uLWZyZWUgZG91YmxpbmcgZm9ybXVsYS5cbiAgICAgICAgLy8gVGhlcmUgaXMgMzAlIGZhc3RlciBKYWNvYmlhbiBmb3JtdWxhLCBidXQgaXQgaXMgbm90IGNvbXBsZXRlLlxuICAgICAgICAvLyBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDE1LzEwNjAsIGFsZ29yaXRobSAzXG4gICAgICAgIC8vIENvc3Q6IDhNICsgM1MgKyAzKmEgKyAyKmIzICsgMTVhZGQuXG4gICAgICAgIGRvdWJsZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgYSwgYiB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBjb25zdCBiMyA9IEZwLm11bChiLCBfM24pO1xuICAgICAgICAgICAgY29uc3QgeyBYOiBYMSwgWTogWTEsIFo6IFoxIH0gPSB0aGlzO1xuICAgICAgICAgICAgbGV0IFgzID0gRnAuWkVSTywgWTMgPSBGcC5aRVJPLCBaMyA9IEZwLlpFUk87IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgbGV0IHQwID0gRnAubXVsKFgxLCBYMSk7IC8vIHN0ZXAgMVxuICAgICAgICAgICAgbGV0IHQxID0gRnAubXVsKFkxLCBZMSk7XG4gICAgICAgICAgICBsZXQgdDIgPSBGcC5tdWwoWjEsIFoxKTtcbiAgICAgICAgICAgIGxldCB0MyA9IEZwLm11bChYMSwgWTEpO1xuICAgICAgICAgICAgdDMgPSBGcC5hZGQodDMsIHQzKTsgLy8gc3RlcCA1XG4gICAgICAgICAgICBaMyA9IEZwLm11bChYMSwgWjEpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIFozKTtcbiAgICAgICAgICAgIFgzID0gRnAubXVsKGEsIFozKTtcbiAgICAgICAgICAgIFkzID0gRnAubXVsKGIzLCB0Mik7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZChYMywgWTMpOyAvLyBzdGVwIDEwXG4gICAgICAgICAgICBYMyA9IEZwLnN1Yih0MSwgWTMpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQodDEsIFkzKTtcbiAgICAgICAgICAgIFkzID0gRnAubXVsKFgzLCBZMyk7XG4gICAgICAgICAgICBYMyA9IEZwLm11bCh0MywgWDMpO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwoYjMsIFozKTsgLy8gc3RlcCAxNVxuICAgICAgICAgICAgdDIgPSBGcC5tdWwoYSwgdDIpO1xuICAgICAgICAgICAgdDMgPSBGcC5zdWIodDAsIHQyKTtcbiAgICAgICAgICAgIHQzID0gRnAubXVsKGEsIHQzKTtcbiAgICAgICAgICAgIHQzID0gRnAuYWRkKHQzLCBaMyk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZCh0MCwgdDApOyAvLyBzdGVwIDIwXG4gICAgICAgICAgICB0MCA9IEZwLmFkZChaMywgdDApO1xuICAgICAgICAgICAgdDAgPSBGcC5hZGQodDAsIHQyKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQwLCB0Myk7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZChZMywgdDApO1xuICAgICAgICAgICAgdDIgPSBGcC5tdWwoWTEsIFoxKTsgLy8gc3RlcCAyNVxuICAgICAgICAgICAgdDIgPSBGcC5hZGQodDIsIHQyKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQyLCB0Myk7XG4gICAgICAgICAgICBYMyA9IEZwLnN1YihYMywgdDApO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwodDIsIHQxKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCBaMyk7IC8vIHN0ZXAgMzBcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCBaMyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KFgzLCBZMywgWjMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbmVzLUNvc3RlbGxvLUJhdGluYSBleGNlcHRpb24tZnJlZSBhZGRpdGlvbiBmb3JtdWxhLlxuICAgICAgICAvLyBUaGVyZSBpcyAzMCUgZmFzdGVyIEphY29iaWFuIGZvcm11bGEsIGJ1dCBpdCBpcyBub3QgY29tcGxldGUuXG4gICAgICAgIC8vIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTUvMTA2MCwgYWxnb3JpdGhtIDFcbiAgICAgICAgLy8gQ29zdDogMTJNICsgMFMgKyAzKmEgKyAzKmIzICsgMjNhZGQuXG4gICAgICAgIGFkZChvdGhlcikge1xuICAgICAgICAgICAgYXByanBvaW50KG90aGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgWDogWDEsIFk6IFkxLCBaOiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgWDogWDIsIFk6IFkyLCBaOiBaMiB9ID0gb3RoZXI7XG4gICAgICAgICAgICBsZXQgWDMgPSBGcC5aRVJPLCBZMyA9IEZwLlpFUk8sIFozID0gRnAuWkVSTzsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBjb25zdCBhID0gQ1VSVkUuYTtcbiAgICAgICAgICAgIGNvbnN0IGIzID0gRnAubXVsKENVUlZFLmIsIF8zbik7XG4gICAgICAgICAgICBsZXQgdDAgPSBGcC5tdWwoWDEsIFgyKTsgLy8gc3RlcCAxXG4gICAgICAgICAgICBsZXQgdDEgPSBGcC5tdWwoWTEsIFkyKTtcbiAgICAgICAgICAgIGxldCB0MiA9IEZwLm11bChaMSwgWjIpO1xuICAgICAgICAgICAgbGV0IHQzID0gRnAuYWRkKFgxLCBZMSk7XG4gICAgICAgICAgICBsZXQgdDQgPSBGcC5hZGQoWDIsIFkyKTsgLy8gc3RlcCA1XG4gICAgICAgICAgICB0MyA9IEZwLm11bCh0MywgdDQpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQodDAsIHQxKTtcbiAgICAgICAgICAgIHQzID0gRnAuc3ViKHQzLCB0NCk7XG4gICAgICAgICAgICB0NCA9IEZwLmFkZChYMSwgWjEpO1xuICAgICAgICAgICAgbGV0IHQ1ID0gRnAuYWRkKFgyLCBaMik7IC8vIHN0ZXAgMTBcbiAgICAgICAgICAgIHQ0ID0gRnAubXVsKHQ0LCB0NSk7XG4gICAgICAgICAgICB0NSA9IEZwLmFkZCh0MCwgdDIpO1xuICAgICAgICAgICAgdDQgPSBGcC5zdWIodDQsIHQ1KTtcbiAgICAgICAgICAgIHQ1ID0gRnAuYWRkKFkxLCBaMSk7XG4gICAgICAgICAgICBYMyA9IEZwLmFkZChZMiwgWjIpOyAvLyBzdGVwIDE1XG4gICAgICAgICAgICB0NSA9IEZwLm11bCh0NSwgWDMpO1xuICAgICAgICAgICAgWDMgPSBGcC5hZGQodDEsIHQyKTtcbiAgICAgICAgICAgIHQ1ID0gRnAuc3ViKHQ1LCBYMyk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bChhLCB0NCk7XG4gICAgICAgICAgICBYMyA9IEZwLm11bChiMywgdDIpOyAvLyBzdGVwIDIwXG4gICAgICAgICAgICBaMyA9IEZwLmFkZChYMywgWjMpO1xuICAgICAgICAgICAgWDMgPSBGcC5zdWIodDEsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKHQxLCBaMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChYMywgWjMpO1xuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDAsIHQwKTsgLy8gc3RlcCAyNVxuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDEsIHQwKTtcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAubXVsKGIzLCB0NCk7XG4gICAgICAgICAgICB0MSA9IEZwLmFkZCh0MSwgdDIpO1xuICAgICAgICAgICAgdDIgPSBGcC5zdWIodDAsIHQyKTsgLy8gc3RlcCAzMFxuICAgICAgICAgICAgdDIgPSBGcC5tdWwoYSwgdDIpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQodDQsIHQyKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQxLCB0NCk7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZChZMywgdDApO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDUsIHQ0KTsgLy8gc3RlcCAzNVxuICAgICAgICAgICAgWDMgPSBGcC5tdWwodDMsIFgzKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKFgzLCB0MCk7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MywgdDEpO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwodDUsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCB0MCk7IC8vIHN0ZXAgNDBcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWDMsIFkzLCBaMyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VidHJhY3Qob3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChvdGhlci5uZWdhdGUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaXMwKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXF1YWxzKFBvaW50LlpFUk8pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdGFudCB0aW1lIG11bHRpcGxpY2F0aW9uLlxuICAgICAgICAgKiBVc2VzIHdOQUYgbWV0aG9kLiBXaW5kb3dlZCBtZXRob2QgbWF5IGJlIDEwJSBmYXN0ZXIsXG4gICAgICAgICAqIGJ1dCB0YWtlcyAyeCBsb25nZXIgdG8gZ2VuZXJhdGUgYW5kIGNvbnN1bWVzIDJ4IG1lbW9yeS5cbiAgICAgICAgICogVXNlcyBwcmVjb21wdXRlcyB3aGVuIGF2YWlsYWJsZS5cbiAgICAgICAgICogVXNlcyBlbmRvbW9ycGhpc20gZm9yIEtvYmxpdHogY3VydmVzLlxuICAgICAgICAgKiBAcGFyYW0gc2NhbGFyIGJ5IHdoaWNoIHRoZSBwb2ludCB3b3VsZCBiZSBtdWx0aXBsaWVkXG4gICAgICAgICAqIEByZXR1cm5zIE5ldyBwb2ludFxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHkoc2NhbGFyKSB7XG4gICAgICAgICAgICBjb25zdCB7IGVuZG8gfSA9IGV4dHJhT3B0cztcbiAgICAgICAgICAgIGlmICghRm4uaXNWYWxpZE5vdDAoc2NhbGFyKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2NhbGFyOiBvdXQgb2YgcmFuZ2UnKTsgLy8gMCBpcyBpbnZhbGlkXG4gICAgICAgICAgICBsZXQgcG9pbnQsIGZha2U7IC8vIEZha2UgcG9pbnQgaXMgdXNlZCB0byBjb25zdC10aW1lIG11bHRcbiAgICAgICAgICAgIGNvbnN0IG11bCA9IChuKSA9PiB3bmFmLmNhY2hlZCh0aGlzLCBuLCAocCkgPT4gbm9ybWFsaXplWihQb2ludCwgcCkpO1xuICAgICAgICAgICAgLyoqIFNlZSBkb2NzIGZvciB7QGxpbmsgRW5kb21vcnBoaXNtT3B0c30gKi9cbiAgICAgICAgICAgIGlmIChlbmRvKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBrMW5lZywgazEsIGsybmVnLCBrMiB9ID0gc3BsaXRFbmRvU2NhbGFyTihzY2FsYXIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcDogazFwLCBmOiBrMWYgfSA9IG11bChrMSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwOiBrMnAsIGY6IGsyZiB9ID0gbXVsKGsyKTtcbiAgICAgICAgICAgICAgICBmYWtlID0gazFmLmFkZChrMmYpO1xuICAgICAgICAgICAgICAgIHBvaW50ID0gZmluaXNoRW5kbyhlbmRvLmJldGEsIGsxcCwgazJwLCBrMW5lZywgazJuZWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwLCBmIH0gPSBtdWwoc2NhbGFyKTtcbiAgICAgICAgICAgICAgICBwb2ludCA9IHA7XG4gICAgICAgICAgICAgICAgZmFrZSA9IGY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgYHpgIGZvciBib3RoIHBvaW50cywgYnV0IHJldHVybiBvbmx5IHJlYWwgb25lXG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplWihQb2ludCwgW3BvaW50LCBmYWtlXSlbMF07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vbi1jb25zdGFudC10aW1lIG11bHRpcGxpY2F0aW9uLiBVc2VzIGRvdWJsZS1hbmQtYWRkIGFsZ29yaXRobS5cbiAgICAgICAgICogSXQncyBmYXN0ZXIsIGJ1dCBzaG91bGQgb25seSBiZSB1c2VkIHdoZW4geW91IGRvbid0IGNhcmUgYWJvdXRcbiAgICAgICAgICogYW4gZXhwb3NlZCBzZWNyZXQga2V5IGUuZy4gc2lnIHZlcmlmaWNhdGlvbiwgd2hpY2ggd29ya3Mgb3ZlciAqcHVibGljKiBrZXlzLlxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHlVbnNhZmUoc2MpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZW5kbyB9ID0gZXh0cmFPcHRzO1xuICAgICAgICAgICAgY29uc3QgcCA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoIUZuLmlzVmFsaWQoc2MpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzY2FsYXI6IG91dCBvZiByYW5nZScpOyAvLyAwIGlzIHZhbGlkXG4gICAgICAgICAgICBpZiAoc2MgPT09IF8wbiB8fCBwLmlzMCgpKVxuICAgICAgICAgICAgICAgIHJldHVybiBQb2ludC5aRVJPO1xuICAgICAgICAgICAgaWYgKHNjID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHA7IC8vIGZhc3QtcGF0aFxuICAgICAgICAgICAgaWYgKHduYWYuaGFzQ2FjaGUodGhpcykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHkoc2MpO1xuICAgICAgICAgICAgaWYgKGVuZG8pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGsxbmVnLCBrMSwgazJuZWcsIGsyIH0gPSBzcGxpdEVuZG9TY2FsYXJOKHNjKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHAxLCBwMiB9ID0gbXVsRW5kb1Vuc2FmZShQb2ludCwgcCwgazEsIGsyKTsgLy8gMzAlIGZhc3RlciB2cyB3bmFmLnVuc2FmZVxuICAgICAgICAgICAgICAgIHJldHVybiBmaW5pc2hFbmRvKGVuZG8uYmV0YSwgcDEsIHAyLCBrMW5lZywgazJuZWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHduYWYudW5zYWZlKHAsIHNjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtdWx0aXBseUFuZEFkZFVuc2FmZShRLCBhLCBiKSB7XG4gICAgICAgICAgICBjb25zdCBzdW0gPSB0aGlzLm11bHRpcGx5VW5zYWZlKGEpLmFkZChRLm11bHRpcGx5VW5zYWZlKGIpKTtcbiAgICAgICAgICAgIHJldHVybiBzdW0uaXMwKCkgPyB1bmRlZmluZWQgOiBzdW07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIFByb2plY3RpdmUgcG9pbnQgdG8gYWZmaW5lICh4LCB5KSBjb29yZGluYXRlcy5cbiAgICAgICAgICogQHBhcmFtIGludmVydGVkWiBaXi0xIChpbnZlcnRlZCB6ZXJvKSAtIG9wdGlvbmFsLCBwcmVjb21wdXRhdGlvbiBpcyB1c2VmdWwgZm9yIGludmVydEJhdGNoXG4gICAgICAgICAqL1xuICAgICAgICB0b0FmZmluZShpbnZlcnRlZFopIHtcbiAgICAgICAgICAgIHJldHVybiB0b0FmZmluZU1lbW8odGhpcywgaW52ZXJ0ZWRaKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2tzIHdoZXRoZXIgUG9pbnQgaXMgZnJlZSBvZiB0b3JzaW9uIGVsZW1lbnRzIChpcyBpbiBwcmltZSBzdWJncm91cCkuXG4gICAgICAgICAqIEFsd2F5cyB0b3JzaW9uLWZyZWUgZm9yIGNvZmFjdG9yPTEgY3VydmVzLlxuICAgICAgICAgKi9cbiAgICAgICAgaXNUb3JzaW9uRnJlZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaXNUb3JzaW9uRnJlZSB9ID0gZXh0cmFPcHRzO1xuICAgICAgICAgICAgaWYgKGNvZmFjdG9yID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpZiAoaXNUb3JzaW9uRnJlZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNUb3JzaW9uRnJlZShQb2ludCwgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gd25hZi51bnNhZmUodGhpcywgQ1VSVkVfT1JERVIpLmlzMCgpO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyQ29mYWN0b3IoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGNsZWFyQ29mYWN0b3IgfSA9IGV4dHJhT3B0cztcbiAgICAgICAgICAgIGlmIChjb2ZhY3RvciA9PT0gXzFuKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzOyAvLyBGYXN0LXBhdGhcbiAgICAgICAgICAgIGlmIChjbGVhckNvZmFjdG9yKVxuICAgICAgICAgICAgICAgIHJldHVybiBjbGVhckNvZmFjdG9yKFBvaW50LCB0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5VW5zYWZlKGNvZmFjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBpc1NtYWxsT3JkZXIoKSB7XG4gICAgICAgICAgICAvLyBjYW4gd2UgdXNlIHRoaXMuY2xlYXJDb2ZhY3RvcigpP1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlVbnNhZmUoY29mYWN0b3IpLmlzMCgpO1xuICAgICAgICB9XG4gICAgICAgIHRvQnl0ZXMoaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICAgICAgYWJvb2woaXNDb21wcmVzc2VkLCAnaXNDb21wcmVzc2VkJyk7XG4gICAgICAgICAgICB0aGlzLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gZW5jb2RlUG9pbnQoUG9pbnQsIHRoaXMsIGlzQ29tcHJlc3NlZCk7XG4gICAgICAgIH1cbiAgICAgICAgdG9IZXgoaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGJ5dGVzVG9IZXgodGhpcy50b0J5dGVzKGlzQ29tcHJlc3NlZCkpO1xuICAgICAgICB9XG4gICAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuIGA8UG9pbnQgJHt0aGlzLmlzMCgpID8gJ1pFUk8nIDogdGhpcy50b0hleCgpfT5gO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IHJlbW92ZVxuICAgICAgICBnZXQgcHgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5YO1xuICAgICAgICB9XG4gICAgICAgIGdldCBweSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLlg7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHB6KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuWjtcbiAgICAgICAgfVxuICAgICAgICB0b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQnl0ZXMoaXNDb21wcmVzc2VkKTtcbiAgICAgICAgfVxuICAgICAgICBfc2V0V2luZG93U2l6ZSh3aW5kb3dTaXplKSB7XG4gICAgICAgICAgICB0aGlzLnByZWNvbXB1dGUod2luZG93U2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIG5vcm1hbGl6ZVoocG9pbnRzKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplWihQb2ludCwgcG9pbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgbXNtKHBvaW50cywgc2NhbGFycykge1xuICAgICAgICAgICAgcmV0dXJuIHBpcHBlbmdlcihQb2ludCwgRm4sIHBvaW50cywgc2NhbGFycyk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBQb2ludC5CQVNFLm11bHRpcGx5KF9ub3JtRm5FbGVtZW50KEZuLCBwcml2YXRlS2V5KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYmFzZSAvIGdlbmVyYXRvciBwb2ludFxuICAgIFBvaW50LkJBU0UgPSBuZXcgUG9pbnQoQ1VSVkUuR3gsIENVUlZFLkd5LCBGcC5PTkUpO1xuICAgIC8vIHplcm8gLyBpbmZpbml0eSAvIGlkZW50aXR5IHBvaW50XG4gICAgUG9pbnQuWkVSTyA9IG5ldyBQb2ludChGcC5aRVJPLCBGcC5PTkUsIEZwLlpFUk8pOyAvLyAwLCAxLCAwXG4gICAgLy8gbWF0aCBmaWVsZFxuICAgIFBvaW50LkZwID0gRnA7XG4gICAgLy8gc2NhbGFyIGZpZWxkXG4gICAgUG9pbnQuRm4gPSBGbjtcbiAgICBjb25zdCBiaXRzID0gRm4uQklUUztcbiAgICBjb25zdCB3bmFmID0gbmV3IHdOQUYoUG9pbnQsIGV4dHJhT3B0cy5lbmRvID8gTWF0aC5jZWlsKGJpdHMgLyAyKSA6IGJpdHMpO1xuICAgIFBvaW50LkJBU0UucHJlY29tcHV0ZSg4KTsgLy8gRW5hYmxlIHByZWNvbXB1dGVzLiBTbG93cyBkb3duIGZpcnN0IHB1YmxpY0tleSBjb21wdXRhdGlvbiBieSAyMG1zLlxuICAgIHJldHVybiBQb2ludDtcbn1cbi8vIFBvaW50cyBzdGFydCB3aXRoIGJ5dGUgMHgwMiB3aGVuIHkgaXMgZXZlbjsgb3RoZXJ3aXNlIDB4MDNcbmZ1bmN0aW9uIHBwcmVmaXgoaGFzRXZlblkpIHtcbiAgICByZXR1cm4gVWludDhBcnJheS5vZihoYXNFdmVuWSA/IDB4MDIgOiAweDAzKTtcbn1cbi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgdGhlIFNoYWxsdWUgYW5kIHZhbiBkZSBXb2VzdGlqbmUgbWV0aG9kIGZvciBhbnkgd2VpZXJzdHJhc3MgY3VydmUuXG4gKiBUT0RPOiBjaGVjayBpZiB0aGVyZSBpcyBhIHdheSB0byBtZXJnZSB0aGlzIHdpdGggdXZSYXRpbyBpbiBFZHdhcmRzOyBtb3ZlIHRvIG1vZHVsYXIuXG4gKiBiID0gVHJ1ZSBhbmQgeSA9IHNxcnQodSAvIHYpIGlmICh1IC8gdikgaXMgc3F1YXJlIGluIEYsIGFuZFxuICogYiA9IEZhbHNlIGFuZCB5ID0gc3FydChaICogKHUgLyB2KSkgb3RoZXJ3aXNlLlxuICogQHBhcmFtIEZwXG4gKiBAcGFyYW0gWlxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFNXVUZwU3FydFJhdGlvKEZwLCBaKSB7XG4gICAgLy8gR2VuZXJpYyBpbXBsZW1lbnRhdGlvblxuICAgIGNvbnN0IHEgPSBGcC5PUkRFUjtcbiAgICBsZXQgbCA9IF8wbjtcbiAgICBmb3IgKGxldCBvID0gcSAtIF8xbjsgbyAlIF8ybiA9PT0gXzBuOyBvIC89IF8ybilcbiAgICAgICAgbCArPSBfMW47XG4gICAgY29uc3QgYzEgPSBsOyAvLyAxLiBjMSwgdGhlIGxhcmdlc3QgaW50ZWdlciBzdWNoIHRoYXQgMl5jMSBkaXZpZGVzIHEgLSAxLlxuICAgIC8vIFdlIG5lZWQgMm4gKiogYzEgYW5kIDJuICoqIChjMS0xKS4gV2UgY2FuJ3QgdXNlICoqOyBidXQgd2UgY2FuIHVzZSA8PC5cbiAgICAvLyAybiAqKiBjMSA9PSAybiA8PCAoYzEtMSlcbiAgICBjb25zdCBfMm5fcG93X2MxXzEgPSBfMm4gPDwgKGMxIC0gXzFuIC0gXzFuKTtcbiAgICBjb25zdCBfMm5fcG93X2MxID0gXzJuX3Bvd19jMV8xICogXzJuO1xuICAgIGNvbnN0IGMyID0gKHEgLSBfMW4pIC8gXzJuX3Bvd19jMTsgLy8gMi4gYzIgPSAocSAtIDEpIC8gKDJeYzEpICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGMzID0gKGMyIC0gXzFuKSAvIF8ybjsgLy8gMy4gYzMgPSAoYzIgLSAxKSAvIDIgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM0ID0gXzJuX3Bvd19jMSAtIF8xbjsgLy8gNC4gYzQgPSAyXmMxIC0gMSAgICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM1ID0gXzJuX3Bvd19jMV8xOyAvLyA1LiBjNSA9IDJeKGMxIC0gMSkgICAgICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM2ID0gRnAucG93KFosIGMyKTsgLy8gNi4gYzYgPSBaXmMyXG4gICAgY29uc3QgYzcgPSBGcC5wb3coWiwgKGMyICsgXzFuKSAvIF8ybik7IC8vIDcuIGM3ID0gWl4oKGMyICsgMSkgLyAyKVxuICAgIGxldCBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuICAgICAgICBsZXQgdHYxID0gYzY7IC8vIDEuIHR2MSA9IGM2XG4gICAgICAgIGxldCB0djIgPSBGcC5wb3codiwgYzQpOyAvLyAyLiB0djIgPSB2XmM0XG4gICAgICAgIGxldCB0djMgPSBGcC5zcXIodHYyKTsgLy8gMy4gdHYzID0gdHYyXjJcbiAgICAgICAgdHYzID0gRnAubXVsKHR2Mywgdik7IC8vIDQuIHR2MyA9IHR2MyAqIHZcbiAgICAgICAgbGV0IHR2NSA9IEZwLm11bCh1LCB0djMpOyAvLyA1LiB0djUgPSB1ICogdHYzXG4gICAgICAgIHR2NSA9IEZwLnBvdyh0djUsIGMzKTsgLy8gNi4gdHY1ID0gdHY1XmMzXG4gICAgICAgIHR2NSA9IEZwLm11bCh0djUsIHR2Mik7IC8vIDcuIHR2NSA9IHR2NSAqIHR2MlxuICAgICAgICB0djIgPSBGcC5tdWwodHY1LCB2KTsgLy8gOC4gdHYyID0gdHY1ICogdlxuICAgICAgICB0djMgPSBGcC5tdWwodHY1LCB1KTsgLy8gOS4gdHYzID0gdHY1ICogdVxuICAgICAgICBsZXQgdHY0ID0gRnAubXVsKHR2MywgdHYyKTsgLy8gMTAuIHR2NCA9IHR2MyAqIHR2MlxuICAgICAgICB0djUgPSBGcC5wb3codHY0LCBjNSk7IC8vIDExLiB0djUgPSB0djReYzVcbiAgICAgICAgbGV0IGlzUVIgPSBGcC5lcWwodHY1LCBGcC5PTkUpOyAvLyAxMi4gaXNRUiA9IHR2NSA9PSAxXG4gICAgICAgIHR2MiA9IEZwLm11bCh0djMsIGM3KTsgLy8gMTMuIHR2MiA9IHR2MyAqIGM3XG4gICAgICAgIHR2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDE0LiB0djUgPSB0djQgKiB0djFcbiAgICAgICAgdHYzID0gRnAuY21vdih0djIsIHR2MywgaXNRUik7IC8vIDE1LiB0djMgPSBDTU9WKHR2MiwgdHYzLCBpc1FSKVxuICAgICAgICB0djQgPSBGcC5jbW92KHR2NSwgdHY0LCBpc1FSKTsgLy8gMTYuIHR2NCA9IENNT1YodHY1LCB0djQsIGlzUVIpXG4gICAgICAgIC8vIDE3LiBmb3IgaSBpbiAoYzEsIGMxIC0gMSwgLi4uLCAyKTpcbiAgICAgICAgZm9yIChsZXQgaSA9IGMxOyBpID4gXzFuOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCB0djUgPSBpIC0gXzJuOyAvLyAxOC4gICAgdHY1ID0gaSAtIDJcbiAgICAgICAgICAgIHR2NSA9IF8ybiA8PCAodHY1IC0gXzFuKTsgLy8gMTkuICAgIHR2NSA9IDJedHY1XG4gICAgICAgICAgICBsZXQgdHZ2NSA9IEZwLnBvdyh0djQsIHR2NSk7IC8vIDIwLiAgICB0djUgPSB0djRedHY1XG4gICAgICAgICAgICBjb25zdCBlMSA9IEZwLmVxbCh0dnY1LCBGcC5PTkUpOyAvLyAyMS4gICAgZTEgPSB0djUgPT0gMVxuICAgICAgICAgICAgdHYyID0gRnAubXVsKHR2MywgdHYxKTsgLy8gMjIuICAgIHR2MiA9IHR2MyAqIHR2MVxuICAgICAgICAgICAgdHYxID0gRnAubXVsKHR2MSwgdHYxKTsgLy8gMjMuICAgIHR2MSA9IHR2MSAqIHR2MVxuICAgICAgICAgICAgdHZ2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDI0LiAgICB0djUgPSB0djQgKiB0djFcbiAgICAgICAgICAgIHR2MyA9IEZwLmNtb3YodHYyLCB0djMsIGUxKTsgLy8gMjUuICAgIHR2MyA9IENNT1YodHYyLCB0djMsIGUxKVxuICAgICAgICAgICAgdHY0ID0gRnAuY21vdih0dnY1LCB0djQsIGUxKTsgLy8gMjYuICAgIHR2NCA9IENNT1YodHY1LCB0djQsIGUxKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGlzUVIsIHZhbHVlOiB0djMgfTtcbiAgICB9O1xuICAgIGlmIChGcC5PUkRFUiAlIF80biA9PT0gXzNuKSB7XG4gICAgICAgIC8vIHNxcnRfcmF0aW9fM21vZDQodSwgdilcbiAgICAgICAgY29uc3QgYzEgPSAoRnAuT1JERVIgLSBfM24pIC8gXzRuOyAvLyAxLiBjMSA9IChxIC0gMykgLyA0ICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgICAgICBjb25zdCBjMiA9IEZwLnNxcnQoRnAubmVnKFopKTsgLy8gMi4gYzIgPSBzcXJ0KC1aKVxuICAgICAgICBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuICAgICAgICAgICAgbGV0IHR2MSA9IEZwLnNxcih2KTsgLy8gMS4gdHYxID0gdl4yXG4gICAgICAgICAgICBjb25zdCB0djIgPSBGcC5tdWwodSwgdik7IC8vIDIuIHR2MiA9IHUgKiB2XG4gICAgICAgICAgICB0djEgPSBGcC5tdWwodHYxLCB0djIpOyAvLyAzLiB0djEgPSB0djEgKiB0djJcbiAgICAgICAgICAgIGxldCB5MSA9IEZwLnBvdyh0djEsIGMxKTsgLy8gNC4geTEgPSB0djFeYzFcbiAgICAgICAgICAgIHkxID0gRnAubXVsKHkxLCB0djIpOyAvLyA1LiB5MSA9IHkxICogdHYyXG4gICAgICAgICAgICBjb25zdCB5MiA9IEZwLm11bCh5MSwgYzIpOyAvLyA2LiB5MiA9IHkxICogYzJcbiAgICAgICAgICAgIGNvbnN0IHR2MyA9IEZwLm11bChGcC5zcXIoeTEpLCB2KTsgLy8gNy4gdHYzID0geTFeMjsgOC4gdHYzID0gdHYzICogdlxuICAgICAgICAgICAgY29uc3QgaXNRUiA9IEZwLmVxbCh0djMsIHUpOyAvLyA5LiBpc1FSID0gdHYzID09IHVcbiAgICAgICAgICAgIGxldCB5ID0gRnAuY21vdih5MiwgeTEsIGlzUVIpOyAvLyAxMC4geSA9IENNT1YoeTIsIHkxLCBpc1FSKVxuICAgICAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogaXNRUiwgdmFsdWU6IHkgfTsgLy8gMTEuIHJldHVybiAoaXNRUiwgeSkgaXNRUiA/IHkgOiB5KmMyXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIE5vIGN1cnZlcyB1c2VzIHRoYXRcbiAgICAvLyBpZiAoRnAuT1JERVIgJSBfOG4gPT09IF81bikgLy8gc3FydF9yYXRpb181bW9kOFxuICAgIHJldHVybiBzcXJ0UmF0aW87XG59XG4vKipcbiAqIFNpbXBsaWZpZWQgU2hhbGx1ZS12YW4gZGUgV29lc3Rpam5lLVVsYXMgTWV0aG9kXG4gKiBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTYuNi4yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBUb0N1cnZlU2ltcGxlU1dVKEZwLCBvcHRzKSB7XG4gICAgdmFsaWRhdGVGaWVsZChGcCk7XG4gICAgY29uc3QgeyBBLCBCLCBaIH0gPSBvcHRzO1xuICAgIGlmICghRnAuaXNWYWxpZChBKSB8fCAhRnAuaXNWYWxpZChCKSB8fCAhRnAuaXNWYWxpZChaKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXBUb0N1cnZlU2ltcGxlU1dVOiBpbnZhbGlkIG9wdHMnKTtcbiAgICBjb25zdCBzcXJ0UmF0aW8gPSBTV1VGcFNxcnRSYXRpbyhGcCwgWik7XG4gICAgaWYgKCFGcC5pc09kZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaWVsZCBkb2VzIG5vdCBoYXZlIC5pc09kZCgpJyk7XG4gICAgLy8gSW5wdXQ6IHUsIGFuIGVsZW1lbnQgb2YgRi5cbiAgICAvLyBPdXRwdXQ6ICh4LCB5KSwgYSBwb2ludCBvbiBFLlxuICAgIHJldHVybiAodSkgPT4ge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgbGV0IHR2MSwgdHYyLCB0djMsIHR2NCwgdHY1LCB0djYsIHgsIHk7XG4gICAgICAgIHR2MSA9IEZwLnNxcih1KTsgLy8gMS4gIHR2MSA9IHVeMlxuICAgICAgICB0djEgPSBGcC5tdWwodHYxLCBaKTsgLy8gMi4gIHR2MSA9IFogKiB0djFcbiAgICAgICAgdHYyID0gRnAuc3FyKHR2MSk7IC8vIDMuICB0djIgPSB0djFeMlxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djEpOyAvLyA0LiAgdHYyID0gdHYyICsgdHYxXG4gICAgICAgIHR2MyA9IEZwLmFkZCh0djIsIEZwLk9ORSk7IC8vIDUuICB0djMgPSB0djIgKyAxXG4gICAgICAgIHR2MyA9IEZwLm11bCh0djMsIEIpOyAvLyA2LiAgdHYzID0gQiAqIHR2M1xuICAgICAgICB0djQgPSBGcC5jbW92KFosIEZwLm5lZyh0djIpLCAhRnAuZXFsKHR2MiwgRnAuWkVSTykpOyAvLyA3LiAgdHY0ID0gQ01PVihaLCAtdHYyLCB0djIgIT0gMClcbiAgICAgICAgdHY0ID0gRnAubXVsKHR2NCwgQSk7IC8vIDguICB0djQgPSBBICogdHY0XG4gICAgICAgIHR2MiA9IEZwLnNxcih0djMpOyAvLyA5LiAgdHYyID0gdHYzXjJcbiAgICAgICAgdHY2ID0gRnAuc3FyKHR2NCk7IC8vIDEwLiB0djYgPSB0djReMlxuICAgICAgICB0djUgPSBGcC5tdWwodHY2LCBBKTsgLy8gMTEuIHR2NSA9IEEgKiB0djZcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHY1KTsgLy8gMTIuIHR2MiA9IHR2MiArIHR2NVxuICAgICAgICB0djIgPSBGcC5tdWwodHYyLCB0djMpOyAvLyAxMy4gdHYyID0gdHYyICogdHYzXG4gICAgICAgIHR2NiA9IEZwLm11bCh0djYsIHR2NCk7IC8vIDE0LiB0djYgPSB0djYgKiB0djRcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2NiwgQik7IC8vIDE1LiB0djUgPSBCICogdHY2XG4gICAgICAgIHR2MiA9IEZwLmFkZCh0djIsIHR2NSk7IC8vIDE2LiB0djIgPSB0djIgKyB0djVcbiAgICAgICAgeCA9IEZwLm11bCh0djEsIHR2Myk7IC8vIDE3LiAgIHggPSB0djEgKiB0djNcbiAgICAgICAgY29uc3QgeyBpc1ZhbGlkLCB2YWx1ZSB9ID0gc3FydFJhdGlvKHR2MiwgdHY2KTsgLy8gMTguIChpc19neDFfc3F1YXJlLCB5MSkgPSBzcXJ0X3JhdGlvKHR2MiwgdHY2KVxuICAgICAgICB5ID0gRnAubXVsKHR2MSwgdSk7IC8vIDE5LiAgIHkgPSB0djEgKiB1ICAtPiBaICogdV4zICogeTFcbiAgICAgICAgeSA9IEZwLm11bCh5LCB2YWx1ZSk7IC8vIDIwLiAgIHkgPSB5ICogeTFcbiAgICAgICAgeCA9IEZwLmNtb3YoeCwgdHYzLCBpc1ZhbGlkKTsgLy8gMjEuICAgeCA9IENNT1YoeCwgdHYzLCBpc19neDFfc3F1YXJlKVxuICAgICAgICB5ID0gRnAuY21vdih5LCB2YWx1ZSwgaXNWYWxpZCk7IC8vIDIyLiAgIHkgPSBDTU9WKHksIHkxLCBpc19neDFfc3F1YXJlKVxuICAgICAgICBjb25zdCBlMSA9IEZwLmlzT2RkKHUpID09PSBGcC5pc09kZCh5KTsgLy8gMjMuICBlMSA9IHNnbjAodSkgPT0gc2duMCh5KVxuICAgICAgICB5ID0gRnAuY21vdihGcC5uZWcoeSksIHksIGUxKTsgLy8gMjQuICAgeSA9IENNT1YoLXksIHksIGUxKVxuICAgICAgICBjb25zdCB0djRfaW52ID0gRnBJbnZlcnRCYXRjaChGcCwgW3R2NF0sIHRydWUpWzBdO1xuICAgICAgICB4ID0gRnAubXVsKHgsIHR2NF9pbnYpOyAvLyAyNS4gICB4ID0geCAvIHR2NFxuICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldFdMZW5ndGhzKEZwLCBGbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHNlY3JldEtleTogRm4uQllURVMsXG4gICAgICAgIHB1YmxpY0tleTogMSArIEZwLkJZVEVTLFxuICAgICAgICBwdWJsaWNLZXlVbmNvbXByZXNzZWQ6IDEgKyAyICogRnAuQllURVMsXG4gICAgICAgIHB1YmxpY0tleUhhc1ByZWZpeDogdHJ1ZSxcbiAgICAgICAgc2lnbmF0dXJlOiAyICogRm4uQllURVMsXG4gICAgfTtcbn1cbi8qKlxuICogU29tZXRpbWVzIHVzZXJzIG9ubHkgbmVlZCBnZXRQdWJsaWNLZXksIGdldFNoYXJlZFNlY3JldCwgYW5kIHNlY3JldCBrZXkgaGFuZGxpbmcuXG4gKiBUaGlzIGhlbHBlciBlbnN1cmVzIG5vIHNpZ25hdHVyZSBmdW5jdGlvbmFsaXR5IGlzIHByZXNlbnQuIExlc3MgY29kZSwgc21hbGxlciBidW5kbGUgc2l6ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVjZGgoUG9pbnQsIGVjZGhPcHRzID0ge30pIHtcbiAgICBjb25zdCB7IEZuIH0gPSBQb2ludDtcbiAgICBjb25zdCByYW5kb21CeXRlc18gPSBlY2RoT3B0cy5yYW5kb21CeXRlcyB8fCByYW5kb21CeXRlc1dlYjtcbiAgICBjb25zdCBsZW5ndGhzID0gT2JqZWN0LmFzc2lnbihnZXRXTGVuZ3RocyhQb2ludC5GcCwgRm4pLCB7IHNlZWQ6IGdldE1pbkhhc2hMZW5ndGgoRm4uT1JERVIpIH0pO1xuICAgIGZ1bmN0aW9uIGlzVmFsaWRTZWNyZXRLZXkoc2VjcmV0S2V5KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gISFfbm9ybUZuRWxlbWVudChGbiwgc2VjcmV0S2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBpc1ZhbGlkUHVibGljS2V5KHB1YmxpY0tleSwgaXNDb21wcmVzc2VkKSB7XG4gICAgICAgIGNvbnN0IHsgcHVibGljS2V5OiBjb21wLCBwdWJsaWNLZXlVbmNvbXByZXNzZWQgfSA9IGxlbmd0aHM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBsID0gcHVibGljS2V5Lmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChpc0NvbXByZXNzZWQgPT09IHRydWUgJiYgbCAhPT0gY29tcClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoaXNDb21wcmVzc2VkID09PSBmYWxzZSAmJiBsICE9PSBwdWJsaWNLZXlVbmNvbXByZXNzZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuICEhUG9pbnQuZnJvbUJ5dGVzKHB1YmxpY0tleSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvZHVjZXMgY3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlIHNlY3JldCBrZXkgZnJvbSByYW5kb20gb2Ygc2l6ZVxuICAgICAqIChncm91cExlbiArIGNlaWwoZ3JvdXBMZW4gLyAyKSkgd2l0aCBtb2R1bG8gYmlhcyBiZWluZyBuZWdsaWdpYmxlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJhbmRvbVNlY3JldEtleShzZWVkID0gcmFuZG9tQnl0ZXNfKGxlbmd0aHMuc2VlZCkpIHtcbiAgICAgICAgcmV0dXJuIG1hcEhhc2hUb0ZpZWxkKGFieXRlcyhzZWVkLCBsZW5ndGhzLnNlZWQsICdzZWVkJyksIEZuLk9SREVSKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgcHVibGljIGtleSBmb3IgYSBzZWNyZXQga2V5LiBDaGVja3MgZm9yIHZhbGlkaXR5IG9mIHRoZSBzZWNyZXQga2V5LlxuICAgICAqIEBwYXJhbSBpc0NvbXByZXNzZWQgd2hldGhlciB0byByZXR1cm4gY29tcGFjdCAoZGVmYXVsdCksIG9yIGZ1bGwga2V5XG4gICAgICogQHJldHVybnMgUHVibGljIGtleSwgZnVsbCB3aGVuIGlzQ29tcHJlc3NlZD1mYWxzZTsgc2hvcnQgd2hlbiBpc0NvbXByZXNzZWQ9dHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFB1YmxpY0tleShzZWNyZXRLZXksIGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIFBvaW50LkJBU0UubXVsdGlwbHkoX25vcm1GbkVsZW1lbnQoRm4sIHNlY3JldEtleSkpLnRvQnl0ZXMoaXNDb21wcmVzc2VkKTtcbiAgICB9XG4gICAgZnVuY3Rpb24ga2V5Z2VuKHNlZWQpIHtcbiAgICAgICAgY29uc3Qgc2VjcmV0S2V5ID0gcmFuZG9tU2VjcmV0S2V5KHNlZWQpO1xuICAgICAgICByZXR1cm4geyBzZWNyZXRLZXksIHB1YmxpY0tleTogZ2V0UHVibGljS2V5KHNlY3JldEtleSkgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUXVpY2sgYW5kIGRpcnR5IGNoZWNrIGZvciBpdGVtIGJlaW5nIHB1YmxpYyBrZXkuIERvZXMgbm90IHZhbGlkYXRlIGhleCwgb3IgYmVpbmcgb24tY3VydmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNQcm9iUHViKGl0ZW0pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSAnYmlnaW50JylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjb25zdCB7IHNlY3JldEtleSwgcHVibGljS2V5LCBwdWJsaWNLZXlVbmNvbXByZXNzZWQgfSA9IGxlbmd0aHM7XG4gICAgICAgIGlmIChGbi5hbGxvd2VkTGVuZ3RocyB8fCBzZWNyZXRLZXkgPT09IHB1YmxpY0tleSlcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGwgPSBlbnN1cmVCeXRlcygna2V5JywgaXRlbSkubGVuZ3RoO1xuICAgICAgICByZXR1cm4gbCA9PT0gcHVibGljS2V5IHx8IGwgPT09IHB1YmxpY0tleVVuY29tcHJlc3NlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRUNESCAoRWxsaXB0aWMgQ3VydmUgRGlmZmllIEhlbGxtYW4pLlxuICAgICAqIENvbXB1dGVzIHNoYXJlZCBwdWJsaWMga2V5IGZyb20gc2VjcmV0IGtleSBBIGFuZCBwdWJsaWMga2V5IEIuXG4gICAgICogQ2hlY2tzOiAxKSBzZWNyZXQga2V5IHZhbGlkaXR5IDIpIHNoYXJlZCBrZXkgaXMgb24tY3VydmUuXG4gICAgICogRG9lcyBOT1QgaGFzaCB0aGUgcmVzdWx0LlxuICAgICAqIEBwYXJhbSBpc0NvbXByZXNzZWQgd2hldGhlciB0byByZXR1cm4gY29tcGFjdCAoZGVmYXVsdCksIG9yIGZ1bGwga2V5XG4gICAgICogQHJldHVybnMgc2hhcmVkIHB1YmxpYyBrZXlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRTaGFyZWRTZWNyZXQoc2VjcmV0S2V5QSwgcHVibGljS2V5QiwgaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICBpZiAoaXNQcm9iUHViKHNlY3JldEtleUEpID09PSB0cnVlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaXJzdCBhcmcgbXVzdCBiZSBwcml2YXRlIGtleScpO1xuICAgICAgICBpZiAoaXNQcm9iUHViKHB1YmxpY0tleUIpID09PSBmYWxzZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2Vjb25kIGFyZyBtdXN0IGJlIHB1YmxpYyBrZXknKTtcbiAgICAgICAgY29uc3QgcyA9IF9ub3JtRm5FbGVtZW50KEZuLCBzZWNyZXRLZXlBKTtcbiAgICAgICAgY29uc3QgYiA9IFBvaW50LmZyb21IZXgocHVibGljS2V5Qik7IC8vIGNoZWNrcyBmb3IgYmVpbmcgb24tY3VydmVcbiAgICAgICAgcmV0dXJuIGIubXVsdGlwbHkocykudG9CeXRlcyhpc0NvbXByZXNzZWQpO1xuICAgIH1cbiAgICBjb25zdCB1dGlscyA9IHtcbiAgICAgICAgaXNWYWxpZFNlY3JldEtleSxcbiAgICAgICAgaXNWYWxpZFB1YmxpY0tleSxcbiAgICAgICAgcmFuZG9tU2VjcmV0S2V5LFxuICAgICAgICAvLyBUT0RPOiByZW1vdmVcbiAgICAgICAgaXNWYWxpZFByaXZhdGVLZXk6IGlzVmFsaWRTZWNyZXRLZXksXG4gICAgICAgIHJhbmRvbVByaXZhdGVLZXk6IHJhbmRvbVNlY3JldEtleSxcbiAgICAgICAgbm9ybVByaXZhdGVLZXlUb1NjYWxhcjogKGtleSkgPT4gX25vcm1GbkVsZW1lbnQoRm4sIGtleSksXG4gICAgICAgIHByZWNvbXB1dGUod2luZG93U2l6ZSA9IDgsIHBvaW50ID0gUG9pbnQuQkFTRSkge1xuICAgICAgICAgICAgcmV0dXJuIHBvaW50LnByZWNvbXB1dGUod2luZG93U2l6ZSwgZmFsc2UpO1xuICAgICAgICB9LFxuICAgIH07XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyBnZXRQdWJsaWNLZXksIGdldFNoYXJlZFNlY3JldCwga2V5Z2VuLCBQb2ludCwgdXRpbHMsIGxlbmd0aHMgfSk7XG59XG4vKipcbiAqIENyZWF0ZXMgRUNEU0Egc2lnbmluZyBpbnRlcmZhY2UgZm9yIGdpdmVuIGVsbGlwdGljIGN1cnZlIGBQb2ludGAgYW5kIGBoYXNoYCBmdW5jdGlvbi5cbiAqIFdlIG5lZWQgYGhhc2hgIGZvciAyIGZlYXR1cmVzOlxuICogMS4gTWVzc2FnZSBwcmVoYXNoLWluZy4gTk9UIHVzZWQgaWYgYHNpZ25gIC8gYHZlcmlmeWAgYXJlIGNhbGxlZCB3aXRoIGBwcmVoYXNoOiBmYWxzZWBcbiAqIDIuIGsgZ2VuZXJhdGlvbiBpbiBgc2lnbmAsIHVzaW5nIEhNQUMtZHJiZyhoYXNoKVxuICpcbiAqIEVDRFNBT3B0cyBhcmUgb25seSByYXJlbHkgbmVlZGVkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogY29uc3QgcDI1Nl9Qb2ludCA9IHdlaWVyc3RyYXNzKC4uLik7XG4gKiBjb25zdCBwMjU2X3NoYTI1NiA9IGVjZHNhKHAyNTZfUG9pbnQsIHNoYTI1Nik7XG4gKiBjb25zdCBwMjU2X3NoYTIyNCA9IGVjZHNhKHAyNTZfUG9pbnQsIHNoYTIyNCk7XG4gKiBjb25zdCBwMjU2X3NoYTIyNF9yID0gZWNkc2EocDI1Nl9Qb2ludCwgc2hhMjI0LCB7IHJhbmRvbUJ5dGVzOiAobGVuZ3RoKSA9PiB7IC4uLiB9IH0pO1xuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlY2RzYShQb2ludCwgaGFzaCwgZWNkc2FPcHRzID0ge30pIHtcbiAgICBhaGFzaChoYXNoKTtcbiAgICBfdmFsaWRhdGVPYmplY3QoZWNkc2FPcHRzLCB7fSwge1xuICAgICAgICBobWFjOiAnZnVuY3Rpb24nLFxuICAgICAgICBsb3dTOiAnYm9vbGVhbicsXG4gICAgICAgIHJhbmRvbUJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgICAgICBiaXRzMmludDogJ2Z1bmN0aW9uJyxcbiAgICAgICAgYml0czJpbnRfbW9kTjogJ2Z1bmN0aW9uJyxcbiAgICB9KTtcbiAgICBjb25zdCByYW5kb21CeXRlcyA9IGVjZHNhT3B0cy5yYW5kb21CeXRlcyB8fCByYW5kb21CeXRlc1dlYjtcbiAgICBjb25zdCBobWFjID0gZWNkc2FPcHRzLmhtYWMgfHxcbiAgICAgICAgKChrZXksIC4uLm1zZ3MpID0+IG5vYmxlSG1hYyhoYXNoLCBrZXksIGNvbmNhdEJ5dGVzKC4uLm1zZ3MpKSk7XG4gICAgY29uc3QgeyBGcCwgRm4gfSA9IFBvaW50O1xuICAgIGNvbnN0IHsgT1JERVI6IENVUlZFX09SREVSLCBCSVRTOiBmbkJpdHMgfSA9IEZuO1xuICAgIGNvbnN0IHsga2V5Z2VuLCBnZXRQdWJsaWNLZXksIGdldFNoYXJlZFNlY3JldCwgdXRpbHMsIGxlbmd0aHMgfSA9IGVjZGgoUG9pbnQsIGVjZHNhT3B0cyk7XG4gICAgY29uc3QgZGVmYXVsdFNpZ09wdHMgPSB7XG4gICAgICAgIHByZWhhc2g6IGZhbHNlLFxuICAgICAgICBsb3dTOiB0eXBlb2YgZWNkc2FPcHRzLmxvd1MgPT09ICdib29sZWFuJyA/IGVjZHNhT3B0cy5sb3dTIDogZmFsc2UsXG4gICAgICAgIGZvcm1hdDogdW5kZWZpbmVkLCAvLydjb21wYWN0JyBhcyBFQ0RTQVNpZ0Zvcm1hdCxcbiAgICAgICAgZXh0cmFFbnRyb3B5OiBmYWxzZSxcbiAgICB9O1xuICAgIGNvbnN0IGRlZmF1bHRTaWdPcHRzX2Zvcm1hdCA9ICdjb21wYWN0JztcbiAgICBmdW5jdGlvbiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIobnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IEhBTEYgPSBDVVJWRV9PUkRFUiA+PiBfMW47XG4gICAgICAgIHJldHVybiBudW1iZXIgPiBIQUxGO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZVJTKHRpdGxlLCBudW0pIHtcbiAgICAgICAgaWYgKCFGbi5pc1ZhbGlkTm90MChudW0pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHNpZ25hdHVyZSAke3RpdGxlfTogb3V0IG9mIHJhbmdlIDEuLlBvaW50LkZuLk9SREVSYCk7XG4gICAgICAgIHJldHVybiBudW07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlU2lnTGVuZ3RoKGJ5dGVzLCBmb3JtYXQpIHtcbiAgICAgICAgdmFsaWRhdGVTaWdGb3JtYXQoZm9ybWF0KTtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IGxlbmd0aHMuc2lnbmF0dXJlO1xuICAgICAgICBjb25zdCBzaXplciA9IGZvcm1hdCA9PT0gJ2NvbXBhY3QnID8gc2l6ZSA6IGZvcm1hdCA9PT0gJ3JlY292ZXJlZCcgPyBzaXplICsgMSA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIGFieXRlcyhieXRlcywgc2l6ZXIsIGAke2Zvcm1hdH0gc2lnbmF0dXJlYCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVDRFNBIHNpZ25hdHVyZSB3aXRoIGl0cyAociwgcykgcHJvcGVydGllcy4gU3VwcG9ydHMgY29tcGFjdCwgcmVjb3ZlcmVkICYgREVSIHJlcHJlc2VudGF0aW9ucy5cbiAgICAgKi9cbiAgICBjbGFzcyBTaWduYXR1cmUge1xuICAgICAgICBjb25zdHJ1Y3RvcihyLCBzLCByZWNvdmVyeSkge1xuICAgICAgICAgICAgdGhpcy5yID0gdmFsaWRhdGVSUygncicsIHIpOyAvLyByIGluIFsxLi5OLTFdO1xuICAgICAgICAgICAgdGhpcy5zID0gdmFsaWRhdGVSUygncycsIHMpOyAvLyBzIGluIFsxLi5OLTFdO1xuICAgICAgICAgICAgaWYgKHJlY292ZXJ5ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvdmVyeSA9IHJlY292ZXJ5O1xuICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZnJvbUJ5dGVzKGJ5dGVzLCBmb3JtYXQgPSBkZWZhdWx0U2lnT3B0c19mb3JtYXQpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlU2lnTGVuZ3RoKGJ5dGVzLCBmb3JtYXQpO1xuICAgICAgICAgICAgbGV0IHJlY2lkO1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2RlcicpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHIsIHMgfSA9IERFUi50b1NpZyhhYnl0ZXMoYnl0ZXMpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShyLCBzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09ICdyZWNvdmVyZWQnKSB7XG4gICAgICAgICAgICAgICAgcmVjaWQgPSBieXRlc1swXTtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSAnY29tcGFjdCc7XG4gICAgICAgICAgICAgICAgYnl0ZXMgPSBieXRlcy5zdWJhcnJheSgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IEwgPSBGbi5CWVRFUztcbiAgICAgICAgICAgIGNvbnN0IHIgPSBieXRlcy5zdWJhcnJheSgwLCBMKTtcbiAgICAgICAgICAgIGNvbnN0IHMgPSBieXRlcy5zdWJhcnJheShMLCBMICogMik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShGbi5mcm9tQnl0ZXMociksIEZuLmZyb21CeXRlcyhzKSwgcmVjaWQpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBmcm9tSGV4KGhleCwgZm9ybWF0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mcm9tQnl0ZXMoaGV4VG9CeXRlcyhoZXgpLCBmb3JtYXQpO1xuICAgICAgICB9XG4gICAgICAgIGFkZFJlY292ZXJ5Qml0KHJlY292ZXJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZSh0aGlzLnIsIHRoaXMucywgcmVjb3ZlcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJlY292ZXJQdWJsaWNLZXkobWVzc2FnZUhhc2gpIHtcbiAgICAgICAgICAgIGNvbnN0IEZJRUxEX09SREVSID0gRnAuT1JERVI7XG4gICAgICAgICAgICBjb25zdCB7IHIsIHMsIHJlY292ZXJ5OiByZWMgfSA9IHRoaXM7XG4gICAgICAgICAgICBpZiAocmVjID09IG51bGwgfHwgIVswLCAxLCAyLCAzXS5pbmNsdWRlcyhyZWMpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVjb3ZlcnkgaWQgaW52YWxpZCcpO1xuICAgICAgICAgICAgLy8gRUNEU0EgcmVjb3ZlcnkgaXMgaGFyZCBmb3IgY29mYWN0b3IgPiAxIGN1cnZlcy5cbiAgICAgICAgICAgIC8vIEluIHNpZ24sIGByID0gcS54IG1vZCBuYCwgYW5kIGhlcmUgd2UgcmVjb3ZlciBxLnggZnJvbSByLlxuICAgICAgICAgICAgLy8gV2hpbGUgcmVjb3ZlcmluZyBxLnggPj0gbiwgd2UgbmVlZCB0byBhZGQgcituIGZvciBjb2ZhY3Rvcj0xIGN1cnZlcy5cbiAgICAgICAgICAgIC8vIEhvd2V2ZXIsIGZvciBjb2ZhY3Rvcj4xLCByK24gbWF5IG5vdCBnZXQgcS54OlxuICAgICAgICAgICAgLy8gcituKmkgd291bGQgbmVlZCB0byBiZSBkb25lIGluc3RlYWQgd2hlcmUgaSBpcyB1bmtub3duLlxuICAgICAgICAgICAgLy8gVG8gZWFzaWx5IGdldCBpLCB3ZSBlaXRoZXIgbmVlZCB0bzpcbiAgICAgICAgICAgIC8vIGEuIGluY3JlYXNlIGFtb3VudCBvZiB2YWxpZCByZWNpZCB2YWx1ZXMgKDQsIDUuLi4pOyBPUlxuICAgICAgICAgICAgLy8gYi4gcHJvaGliaXQgbm9uLXByaW1lLW9yZGVyIHNpZ25hdHVyZXMgKHJlY2lkID4gMSkuXG4gICAgICAgICAgICBjb25zdCBoYXNDb2ZhY3RvciA9IENVUlZFX09SREVSICogXzJuIDwgRklFTERfT1JERVI7XG4gICAgICAgICAgICBpZiAoaGFzQ29mYWN0b3IgJiYgcmVjID4gMSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY292ZXJ5IGlkIGlzIGFtYmlndW91cyBmb3IgaD4xIGN1cnZlJyk7XG4gICAgICAgICAgICBjb25zdCByYWRqID0gcmVjID09PSAyIHx8IHJlYyA9PT0gMyA/IHIgKyBDVVJWRV9PUkRFUiA6IHI7XG4gICAgICAgICAgICBpZiAoIUZwLmlzVmFsaWQocmFkaikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWNvdmVyeSBpZCAyIG9yIDMgaW52YWxpZCcpO1xuICAgICAgICAgICAgY29uc3QgeCA9IEZwLnRvQnl0ZXMocmFkaik7XG4gICAgICAgICAgICBjb25zdCBSID0gUG9pbnQuZnJvbUJ5dGVzKGNvbmNhdEJ5dGVzKHBwcmVmaXgoKHJlYyAmIDEpID09PSAwKSwgeCkpO1xuICAgICAgICAgICAgY29uc3QgaXIgPSBGbi5pbnYocmFkaik7IC8vIHJeLTFcbiAgICAgICAgICAgIGNvbnN0IGggPSBiaXRzMmludF9tb2ROKGVuc3VyZUJ5dGVzKCdtc2dIYXNoJywgbWVzc2FnZUhhc2gpKTsgLy8gVHJ1bmNhdGUgaGFzaFxuICAgICAgICAgICAgY29uc3QgdTEgPSBGbi5jcmVhdGUoLWggKiBpcik7IC8vIC1ocl4tMVxuICAgICAgICAgICAgY29uc3QgdTIgPSBGbi5jcmVhdGUocyAqIGlyKTsgLy8gc3JeLTFcbiAgICAgICAgICAgIC8vIChzcl4tMSlSLShocl4tMSlHID0gLShocl4tMSlHICsgKHNyXi0xKS4gdW5zYWZlIGlzIGZpbmU6IHRoZXJlIGlzIG5vIHByaXZhdGUgZGF0YS5cbiAgICAgICAgICAgIGNvbnN0IFEgPSBQb2ludC5CQVNFLm11bHRpcGx5VW5zYWZlKHUxKS5hZGQoUi5tdWx0aXBseVVuc2FmZSh1MikpO1xuICAgICAgICAgICAgaWYgKFEuaXMwKCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwb2ludCBhdCBpbmZpbmlmeScpO1xuICAgICAgICAgICAgUS5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2lnbmF0dXJlcyBzaG91bGQgYmUgbG93LXMsIHRvIHByZXZlbnQgbWFsbGVhYmlsaXR5LlxuICAgICAgICBoYXNIaWdoUygpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIodGhpcy5zKTtcbiAgICAgICAgfVxuICAgICAgICB0b0J5dGVzKGZvcm1hdCA9IGRlZmF1bHRTaWdPcHRzX2Zvcm1hdCkge1xuICAgICAgICAgICAgdmFsaWRhdGVTaWdGb3JtYXQoZm9ybWF0KTtcbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09ICdkZXInKVxuICAgICAgICAgICAgICAgIHJldHVybiBoZXhUb0J5dGVzKERFUi5oZXhGcm9tU2lnKHRoaXMpKTtcbiAgICAgICAgICAgIGNvbnN0IHIgPSBGbi50b0J5dGVzKHRoaXMucik7XG4gICAgICAgICAgICBjb25zdCBzID0gRm4udG9CeXRlcyh0aGlzLnMpO1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ3JlY292ZXJlZCcpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWNvdmVyeSA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY292ZXJ5IGJpdCBtdXN0IGJlIHByZXNlbnQnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uY2F0Qnl0ZXMoVWludDhBcnJheS5vZih0aGlzLnJlY292ZXJ5KSwgciwgcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29uY2F0Qnl0ZXMociwgcyk7XG4gICAgICAgIH1cbiAgICAgICAgdG9IZXgoZm9ybWF0KSB7XG4gICAgICAgICAgICByZXR1cm4gYnl0ZXNUb0hleCh0aGlzLnRvQnl0ZXMoZm9ybWF0KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogcmVtb3ZlXG4gICAgICAgIGFzc2VydFZhbGlkaXR5KCkgeyB9XG4gICAgICAgIHN0YXRpYyBmcm9tQ29tcGFjdChoZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBTaWduYXR1cmUuZnJvbUJ5dGVzKGVuc3VyZUJ5dGVzKCdzaWcnLCBoZXgpLCAnY29tcGFjdCcpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBmcm9tREVSKGhleCkge1xuICAgICAgICAgICAgcmV0dXJuIFNpZ25hdHVyZS5mcm9tQnl0ZXMoZW5zdXJlQnl0ZXMoJ3NpZycsIGhleCksICdkZXInKTtcbiAgICAgICAgfVxuICAgICAgICBub3JtYWxpemVTKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFzSGlnaFMoKSA/IG5ldyBTaWduYXR1cmUodGhpcy5yLCBGbi5uZWcodGhpcy5zKSwgdGhpcy5yZWNvdmVyeSkgOiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRvREVSUmF3Qnl0ZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0J5dGVzKCdkZXInKTtcbiAgICAgICAgfVxuICAgICAgICB0b0RFUkhleCgpIHtcbiAgICAgICAgICAgIHJldHVybiBieXRlc1RvSGV4KHRoaXMudG9CeXRlcygnZGVyJykpO1xuICAgICAgICB9XG4gICAgICAgIHRvQ29tcGFjdFJhd0J5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9CeXRlcygnY29tcGFjdCcpO1xuICAgICAgICB9XG4gICAgICAgIHRvQ29tcGFjdEhleCgpIHtcbiAgICAgICAgICAgIHJldHVybiBieXRlc1RvSGV4KHRoaXMudG9CeXRlcygnY29tcGFjdCcpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBSRkM2OTc5OiBlbnN1cmUgRUNEU0EgbXNnIGlzIFggYnl0ZXMgYW5kIDwgTi4gUkZDIHN1Z2dlc3RzIG9wdGlvbmFsIHRydW5jYXRpbmcgdmlhIGJpdHMyb2N0ZXRzLlxuICAgIC8vIEZJUFMgMTg2LTQgNC42IHN1Z2dlc3RzIHRoZSBsZWZ0bW9zdCBtaW4obkJpdExlbiwgb3V0TGVuKSBiaXRzLCB3aGljaCBtYXRjaGVzIGJpdHMyaW50LlxuICAgIC8vIGJpdHMyaW50IGNhbiBwcm9kdWNlIHJlcz5OLCB3ZSBjYW4gZG8gbW9kKHJlcywgTikgc2luY2UgdGhlIGJpdExlbiBpcyB0aGUgc2FtZS5cbiAgICAvLyBpbnQyb2N0ZXRzIGNhbid0IGJlIHVzZWQ7IHBhZHMgc21hbGwgbXNncyB3aXRoIDA6IHVuYWNjZXB0YXRibGUgZm9yIHRydW5jIGFzIHBlciBSRkMgdmVjdG9yc1xuICAgIGNvbnN0IGJpdHMyaW50ID0gZWNkc2FPcHRzLmJpdHMyaW50IHx8XG4gICAgICAgIGZ1bmN0aW9uIGJpdHMyaW50X2RlZihieXRlcykge1xuICAgICAgICAgICAgLy8gT3VyIGN1c3RvbSBjaGVjayBcImp1c3QgaW4gY2FzZVwiLCBmb3IgcHJvdGVjdGlvbiBhZ2FpbnN0IERvU1xuICAgICAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA+IDgxOTIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnB1dCBpcyB0b28gbGFyZ2UnKTtcbiAgICAgICAgICAgIC8vIEZvciBjdXJ2ZXMgd2l0aCBuQml0TGVuZ3RoICUgOCAhPT0gMDogYml0czJvY3RldHMoYml0czJvY3RldHMobSkpICE9PSBiaXRzMm9jdGV0cyhtKVxuICAgICAgICAgICAgLy8gZm9yIHNvbWUgY2FzZXMsIHNpbmNlIGJ5dGVzLmxlbmd0aCAqIDggaXMgbm90IGFjdHVhbCBiaXRMZW5ndGguXG4gICAgICAgICAgICBjb25zdCBudW0gPSBieXRlc1RvTnVtYmVyQkUoYnl0ZXMpOyAvLyBjaGVjayBmb3IgPT0gdTggZG9uZSBoZXJlXG4gICAgICAgICAgICBjb25zdCBkZWx0YSA9IGJ5dGVzLmxlbmd0aCAqIDggLSBmbkJpdHM7IC8vIHRydW5jYXRlIHRvIG5CaXRMZW5ndGggbGVmdG1vc3QgYml0c1xuICAgICAgICAgICAgcmV0dXJuIGRlbHRhID4gMCA/IG51bSA+PiBCaWdJbnQoZGVsdGEpIDogbnVtO1xuICAgICAgICB9O1xuICAgIGNvbnN0IGJpdHMyaW50X21vZE4gPSBlY2RzYU9wdHMuYml0czJpbnRfbW9kTiB8fFxuICAgICAgICBmdW5jdGlvbiBiaXRzMmludF9tb2ROX2RlZihieXRlcykge1xuICAgICAgICAgICAgcmV0dXJuIEZuLmNyZWF0ZShiaXRzMmludChieXRlcykpOyAvLyBjYW4ndCB1c2UgYnl0ZXNUb051bWJlckJFIGhlcmVcbiAgICAgICAgfTtcbiAgICAvLyBQYWRzIG91dHB1dCB3aXRoIHplcm8gYXMgcGVyIHNwZWNcbiAgICBjb25zdCBPUkRFUl9NQVNLID0gYml0TWFzayhmbkJpdHMpO1xuICAgIC8qKiBDb252ZXJ0cyB0byBieXRlcy4gQ2hlY2tzIGlmIG51bSBpbiBgWzAuLk9SREVSX01BU0stMV1gIGUuZy46IGBbMC4uMl4yNTYtMV1gLiAqL1xuICAgIGZ1bmN0aW9uIGludDJvY3RldHMobnVtKSB7XG4gICAgICAgIC8vIElNUE9SVEFOVDogdGhlIGNoZWNrIGVuc3VyZXMgd29ya2luZyBmb3IgY2FzZSBgRm4uQllURVMgIT0gRm4uQklUUyAqIDhgXG4gICAgICAgIGFJblJhbmdlKCdudW0gPCAyXicgKyBmbkJpdHMsIG51bSwgXzBuLCBPUkRFUl9NQVNLKTtcbiAgICAgICAgcmV0dXJuIEZuLnRvQnl0ZXMobnVtKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVNc2dBbmRIYXNoKG1lc3NhZ2UsIHByZWhhc2gpIHtcbiAgICAgICAgYWJ5dGVzKG1lc3NhZ2UsIHVuZGVmaW5lZCwgJ21lc3NhZ2UnKTtcbiAgICAgICAgcmV0dXJuIHByZWhhc2ggPyBhYnl0ZXMoaGFzaChtZXNzYWdlKSwgdW5kZWZpbmVkLCAncHJlaGFzaGVkIG1lc3NhZ2UnKSA6IG1lc3NhZ2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0ZXBzIEEsIEQgb2YgUkZDNjk3OSAzLjIuXG4gICAgICogQ3JlYXRlcyBSRkM2OTc5IHNlZWQ7IGNvbnZlcnRzIG1zZy9wcml2S2V5IHRvIG51bWJlcnMuXG4gICAgICogVXNlZCBvbmx5IGluIHNpZ24sIG5vdCBpbiB2ZXJpZnkuXG4gICAgICpcbiAgICAgKiBXYXJuaW5nOiB3ZSBjYW5ub3QgYXNzdW1lIGhlcmUgdGhhdCBtZXNzYWdlIGhhcyBzYW1lIGFtb3VudCBvZiBieXRlcyBhcyBjdXJ2ZSBvcmRlcixcbiAgICAgKiB0aGlzIHdpbGwgYmUgaW52YWxpZCBhdCBsZWFzdCBmb3IgUDUyMS4gQWxzbyBpdCBjYW4gYmUgYmlnZ2VyIGZvciBQMjI0ICsgU0hBMjU2LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByZXBTaWcobWVzc2FnZSwgcHJpdmF0ZUtleSwgb3B0cykge1xuICAgICAgICBpZiAoWydyZWNvdmVyZWQnLCAnY2Fub25pY2FsJ10uc29tZSgoaykgPT4gayBpbiBvcHRzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbigpIGxlZ2FjeSBvcHRpb25zIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgY29uc3QgeyBsb3dTLCBwcmVoYXNoLCBleHRyYUVudHJvcHkgfSA9IHZhbGlkYXRlU2lnT3B0cyhvcHRzLCBkZWZhdWx0U2lnT3B0cyk7XG4gICAgICAgIG1lc3NhZ2UgPSB2YWxpZGF0ZU1zZ0FuZEhhc2gobWVzc2FnZSwgcHJlaGFzaCk7IC8vIFJGQzY5NzkgMy4yIEE6IGgxID0gSChtKVxuICAgICAgICAvLyBXZSBjYW4ndCBsYXRlciBjYWxsIGJpdHMyb2N0ZXRzLCBzaW5jZSBuZXN0ZWQgYml0czJpbnQgaXMgYnJva2VuIGZvciBjdXJ2ZXNcbiAgICAgICAgLy8gd2l0aCBmbkJpdHMgJSA4ICE9PSAwLiBCZWNhdXNlIG9mIHRoYXQsIHdlIHVud3JhcCBpdCBoZXJlIGFzIGludDJvY3RldHMgY2FsbC5cbiAgICAgICAgLy8gY29uc3QgYml0czJvY3RldHMgPSAoYml0cykgPT4gaW50Mm9jdGV0cyhiaXRzMmludF9tb2ROKGJpdHMpKVxuICAgICAgICBjb25zdCBoMWludCA9IGJpdHMyaW50X21vZE4obWVzc2FnZSk7XG4gICAgICAgIGNvbnN0IGQgPSBfbm9ybUZuRWxlbWVudChGbiwgcHJpdmF0ZUtleSk7IC8vIHZhbGlkYXRlIHNlY3JldCBrZXksIGNvbnZlcnQgdG8gYmlnaW50XG4gICAgICAgIGNvbnN0IHNlZWRBcmdzID0gW2ludDJvY3RldHMoZCksIGludDJvY3RldHMoaDFpbnQpXTtcbiAgICAgICAgLy8gZXh0cmFFbnRyb3B5LiBSRkM2OTc5IDMuNjogYWRkaXRpb25hbCBrJyAob3B0aW9uYWwpLlxuICAgICAgICBpZiAoZXh0cmFFbnRyb3B5ICE9IG51bGwgJiYgZXh0cmFFbnRyb3B5ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgLy8gSyA9IEhNQUNfSyhWIHx8IDB4MDAgfHwgaW50Mm9jdGV0cyh4KSB8fCBiaXRzMm9jdGV0cyhoMSkgfHwgaycpXG4gICAgICAgICAgICAvLyBnZW4gcmFuZG9tIGJ5dGVzIE9SIHBhc3MgYXMtaXNcbiAgICAgICAgICAgIGNvbnN0IGUgPSBleHRyYUVudHJvcHkgPT09IHRydWUgPyByYW5kb21CeXRlcyhsZW5ndGhzLnNlY3JldEtleSkgOiBleHRyYUVudHJvcHk7XG4gICAgICAgICAgICBzZWVkQXJncy5wdXNoKGVuc3VyZUJ5dGVzKCdleHRyYUVudHJvcHknLCBlKSk7IC8vIGNoZWNrIGZvciBiZWluZyBieXRlc1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlZWQgPSBjb25jYXRCeXRlcyguLi5zZWVkQXJncyk7IC8vIFN0ZXAgRCBvZiBSRkM2OTc5IDMuMlxuICAgICAgICBjb25zdCBtID0gaDFpbnQ7IC8vIE5PVEU6IG5vIG5lZWQgdG8gY2FsbCBiaXRzMmludCBzZWNvbmQgdGltZSBoZXJlLCBpdCBpcyBpbnNpZGUgdHJ1bmNhdGVIYXNoIVxuICAgICAgICAvLyBDb252ZXJ0cyBzaWduYXR1cmUgcGFyYW1zIGludG8gcG9pbnQgdyByL3MsIGNoZWNrcyByZXN1bHQgZm9yIHZhbGlkaXR5LlxuICAgICAgICAvLyBUbyB0cmFuc2Zvcm0gayA9PiBTaWduYXR1cmU6XG4gICAgICAgIC8vIHEgPSBr4ouFR1xuICAgICAgICAvLyByID0gcS54IG1vZCBuXG4gICAgICAgIC8vIHMgPSBrXi0xKG0gKyByZCkgbW9kIG5cbiAgICAgICAgLy8gQ2FuIHVzZSBzY2FsYXIgYmxpbmRpbmcgYl4tMShibSArIGJkcikgd2hlcmUgYiDiiIggWzEsceKIkjFdIGFjY29yZGluZyB0b1xuICAgICAgICAvLyBodHRwczovL3RjaGVzLmlhY3Iub3JnL2luZGV4LnBocC9UQ0hFUy9hcnRpY2xlL3ZpZXcvNzMzNy82NTA5LiBXZSd2ZSBkZWNpZGVkIGFnYWluc3QgaXQ6XG4gICAgICAgIC8vIGEpIGRlcGVuZGVuY3kgb24gQ1NQUk5HIGIpIDE1JSBzbG93ZG93biBjKSBkb2Vzbid0IHJlYWxseSBoZWxwIHNpbmNlIGJpZ2ludHMgYXJlIG5vdCBDVFxuICAgICAgICBmdW5jdGlvbiBrMnNpZyhrQnl0ZXMpIHtcbiAgICAgICAgICAgIC8vIFJGQyA2OTc5IFNlY3Rpb24gMy4yLCBzdGVwIDM6IGsgPSBiaXRzMmludChUKVxuICAgICAgICAgICAgLy8gSW1wb3J0YW50OiBhbGwgbW9kKCkgY2FsbHMgaGVyZSBtdXN0IGJlIGRvbmUgb3ZlciBOXG4gICAgICAgICAgICBjb25zdCBrID0gYml0czJpbnQoa0J5dGVzKTsgLy8gbW9kIG4sIG5vdCBtb2QgcFxuICAgICAgICAgICAgaWYgKCFGbi5pc1ZhbGlkTm90MChrKSlcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIFZhbGlkIHNjYWxhcnMgKGluY2x1ZGluZyBrKSBtdXN0IGJlIGluIDEuLk4tMVxuICAgICAgICAgICAgY29uc3QgaWsgPSBGbi5pbnYoayk7IC8vIGteLTEgbW9kIG5cbiAgICAgICAgICAgIGNvbnN0IHEgPSBQb2ludC5CQVNFLm11bHRpcGx5KGspLnRvQWZmaW5lKCk7IC8vIHEgPSBr4ouFR1xuICAgICAgICAgICAgY29uc3QgciA9IEZuLmNyZWF0ZShxLngpOyAvLyByID0gcS54IG1vZCBuXG4gICAgICAgICAgICBpZiAociA9PT0gXzBuKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IHMgPSBGbi5jcmVhdGUoaWsgKiBGbi5jcmVhdGUobSArIHIgKiBkKSk7IC8vIE5vdCB1c2luZyBibGluZGluZyBoZXJlLCBzZWUgY29tbWVudCBhYm92ZVxuICAgICAgICAgICAgaWYgKHMgPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgcmVjb3ZlcnkgPSAocS54ID09PSByID8gMCA6IDIpIHwgTnVtYmVyKHEueSAmIF8xbik7IC8vIHJlY292ZXJ5IGJpdCAoMiBvciAzLCB3aGVuIHEueCA+IG4pXG4gICAgICAgICAgICBsZXQgbm9ybVMgPSBzO1xuICAgICAgICAgICAgaWYgKGxvd1MgJiYgaXNCaWdnZXJUaGFuSGFsZk9yZGVyKHMpKSB7XG4gICAgICAgICAgICAgICAgbm9ybVMgPSBGbi5uZWcocyk7IC8vIGlmIGxvd1Mgd2FzIHBhc3NlZCwgZW5zdXJlIHMgaXMgYWx3YXlzXG4gICAgICAgICAgICAgICAgcmVjb3ZlcnkgXj0gMTsgLy8gLy8gaW4gdGhlIGJvdHRvbSBoYWxmIG9mIE5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHIsIG5vcm1TLCByZWNvdmVyeSk7IC8vIHVzZSBub3JtUywgbm90IHNcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzZWVkLCBrMnNpZyB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaWducyBtZXNzYWdlIGhhc2ggd2l0aCBhIHNlY3JldCBrZXkuXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBzaWduKG0sIGQpIHdoZXJlXG4gICAgICogICBrID0gcmZjNjk3OV9obWFjX2RyYmcobSwgZClcbiAgICAgKiAgICh4LCB5KSA9IEcgw5cga1xuICAgICAqICAgciA9IHggbW9kIG5cbiAgICAgKiAgIHMgPSAobSArIGRyKSAvIGsgbW9kIG5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaWduKG1lc3NhZ2UsIHNlY3JldEtleSwgb3B0cyA9IHt9KSB7XG4gICAgICAgIG1lc3NhZ2UgPSBlbnN1cmVCeXRlcygnbWVzc2FnZScsIG1lc3NhZ2UpO1xuICAgICAgICBjb25zdCB7IHNlZWQsIGsyc2lnIH0gPSBwcmVwU2lnKG1lc3NhZ2UsIHNlY3JldEtleSwgb3B0cyk7IC8vIFN0ZXBzIEEsIEQgb2YgUkZDNjk3OSAzLjIuXG4gICAgICAgIGNvbnN0IGRyYmcgPSBjcmVhdGVIbWFjRHJiZyhoYXNoLm91dHB1dExlbiwgRm4uQllURVMsIGhtYWMpO1xuICAgICAgICBjb25zdCBzaWcgPSBkcmJnKHNlZWQsIGsyc2lnKTsgLy8gU3RlcHMgQiwgQywgRCwgRSwgRiwgR1xuICAgICAgICByZXR1cm4gc2lnO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0cnlQYXJzaW5nU2lnKHNnKSB7XG4gICAgICAgIC8vIFRyeSB0byBkZWR1Y2UgZm9ybWF0XG4gICAgICAgIGxldCBzaWcgPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGlzSGV4ID0gdHlwZW9mIHNnID09PSAnc3RyaW5nJyB8fCBpc0J5dGVzKHNnKTtcbiAgICAgICAgY29uc3QgaXNPYmogPSAhaXNIZXggJiZcbiAgICAgICAgICAgIHNnICE9PSBudWxsICYmXG4gICAgICAgICAgICB0eXBlb2Ygc2cgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICB0eXBlb2Ygc2cuciA9PT0gJ2JpZ2ludCcgJiZcbiAgICAgICAgICAgIHR5cGVvZiBzZy5zID09PSAnYmlnaW50JztcbiAgICAgICAgaWYgKCFpc0hleCAmJiAhaXNPYmopXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2lnbmF0dXJlLCBleHBlY3RlZCBVaW50OEFycmF5LCBoZXggc3RyaW5nIG9yIFNpZ25hdHVyZSBpbnN0YW5jZScpO1xuICAgICAgICBpZiAoaXNPYmopIHtcbiAgICAgICAgICAgIHNpZyA9IG5ldyBTaWduYXR1cmUoc2cuciwgc2cucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNIZXgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc2lnID0gU2lnbmF0dXJlLmZyb21CeXRlcyhlbnN1cmVCeXRlcygnc2lnJywgc2cpLCAnZGVyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZGVyRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShkZXJFcnJvciBpbnN0YW5jZW9mIERFUi5FcnIpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBkZXJFcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc2lnKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgc2lnID0gU2lnbmF0dXJlLmZyb21CeXRlcyhlbnN1cmVCeXRlcygnc2lnJywgc2cpLCAnY29tcGFjdCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNpZylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHNpZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgYSBzaWduYXR1cmUgYWdhaW5zdCBtZXNzYWdlIGFuZCBwdWJsaWMga2V5LlxuICAgICAqIFJlamVjdHMgbG93UyBzaWduYXR1cmVzIGJ5IGRlZmF1bHQ6IHNlZSB7QGxpbmsgRUNEU0FWZXJpZnlPcHRzfS5cbiAgICAgKiBJbXBsZW1lbnRzIHNlY3Rpb24gNC4xLjQgZnJvbSBodHRwczovL3d3dy5zZWNnLm9yZy9zZWMxLXYyLnBkZjpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIHZlcmlmeShyLCBzLCBoLCBQKSB3aGVyZVxuICAgICAqICAgdTEgPSBoc14tMSBtb2QgblxuICAgICAqICAgdTIgPSByc14tMSBtb2QgblxuICAgICAqICAgUiA9IHUx4ouFRyArIHUy4ouFUFxuICAgICAqICAgbW9kKFIueCwgbikgPT0gclxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZlcmlmeShzaWduYXR1cmUsIG1lc3NhZ2UsIHB1YmxpY0tleSwgb3B0cyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgbG93UywgcHJlaGFzaCwgZm9ybWF0IH0gPSB2YWxpZGF0ZVNpZ09wdHMob3B0cywgZGVmYXVsdFNpZ09wdHMpO1xuICAgICAgICBwdWJsaWNLZXkgPSBlbnN1cmVCeXRlcygncHVibGljS2V5JywgcHVibGljS2V5KTtcbiAgICAgICAgbWVzc2FnZSA9IHZhbGlkYXRlTXNnQW5kSGFzaChlbnN1cmVCeXRlcygnbWVzc2FnZScsIG1lc3NhZ2UpLCBwcmVoYXNoKTtcbiAgICAgICAgaWYgKCdzdHJpY3QnIGluIG9wdHMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMuc3RyaWN0IHdhcyByZW5hbWVkIHRvIGxvd1MnKTtcbiAgICAgICAgY29uc3Qgc2lnID0gZm9ybWF0ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gdHJ5UGFyc2luZ1NpZyhzaWduYXR1cmUpXG4gICAgICAgICAgICA6IFNpZ25hdHVyZS5mcm9tQnl0ZXMoZW5zdXJlQnl0ZXMoJ3NpZycsIHNpZ25hdHVyZSksIGZvcm1hdCk7XG4gICAgICAgIGlmIChzaWcgPT09IGZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgUCA9IFBvaW50LmZyb21CeXRlcyhwdWJsaWNLZXkpO1xuICAgICAgICAgICAgaWYgKGxvd1MgJiYgc2lnLmhhc0hpZ2hTKCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgeyByLCBzIH0gPSBzaWc7XG4gICAgICAgICAgICBjb25zdCBoID0gYml0czJpbnRfbW9kTihtZXNzYWdlKTsgLy8gbW9kIG4sIG5vdCBtb2QgcFxuICAgICAgICAgICAgY29uc3QgaXMgPSBGbi5pbnYocyk7IC8vIHNeLTEgbW9kIG5cbiAgICAgICAgICAgIGNvbnN0IHUxID0gRm4uY3JlYXRlKGggKiBpcyk7IC8vIHUxID0gaHNeLTEgbW9kIG5cbiAgICAgICAgICAgIGNvbnN0IHUyID0gRm4uY3JlYXRlKHIgKiBpcyk7IC8vIHUyID0gcnNeLTEgbW9kIG5cbiAgICAgICAgICAgIGNvbnN0IFIgPSBQb2ludC5CQVNFLm11bHRpcGx5VW5zYWZlKHUxKS5hZGQoUC5tdWx0aXBseVVuc2FmZSh1MikpOyAvLyB1MeKLhUcgKyB1MuKLhVBcbiAgICAgICAgICAgIGlmIChSLmlzMCgpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IHYgPSBGbi5jcmVhdGUoUi54KTsgLy8gdiA9IHIueCBtb2QgblxuICAgICAgICAgICAgcmV0dXJuIHYgPT09IHI7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZWNvdmVyUHVibGljS2V5KHNpZ25hdHVyZSwgbWVzc2FnZSwgb3B0cyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgcHJlaGFzaCB9ID0gdmFsaWRhdGVTaWdPcHRzKG9wdHMsIGRlZmF1bHRTaWdPcHRzKTtcbiAgICAgICAgbWVzc2FnZSA9IHZhbGlkYXRlTXNnQW5kSGFzaChtZXNzYWdlLCBwcmVoYXNoKTtcbiAgICAgICAgcmV0dXJuIFNpZ25hdHVyZS5mcm9tQnl0ZXMoc2lnbmF0dXJlLCAncmVjb3ZlcmVkJykucmVjb3ZlclB1YmxpY0tleShtZXNzYWdlKS50b0J5dGVzKCk7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAga2V5Z2VuLFxuICAgICAgICBnZXRQdWJsaWNLZXksXG4gICAgICAgIGdldFNoYXJlZFNlY3JldCxcbiAgICAgICAgdXRpbHMsXG4gICAgICAgIGxlbmd0aHMsXG4gICAgICAgIFBvaW50LFxuICAgICAgICBzaWduLFxuICAgICAgICB2ZXJpZnksXG4gICAgICAgIHJlY292ZXJQdWJsaWNLZXksXG4gICAgICAgIFNpZ25hdHVyZSxcbiAgICAgICAgaGFzaCxcbiAgICB9KTtcbn1cbi8qKiBAZGVwcmVjYXRlZCB1c2UgYHdlaWVyc3RyYXNzYCBpbiBuZXdlciByZWxlYXNlcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdlaWVyc3RyYXNzUG9pbnRzKGMpIHtcbiAgICBjb25zdCB7IENVUlZFLCBjdXJ2ZU9wdHMgfSA9IF93ZWllcnN0cmFzc19sZWdhY3lfb3B0c190b19uZXcoYyk7XG4gICAgY29uc3QgUG9pbnQgPSB3ZWllcnN0cmFzc04oQ1VSVkUsIGN1cnZlT3B0cyk7XG4gICAgcmV0dXJuIF93ZWllcnN0cmFzc19uZXdfb3V0cHV0X3RvX2xlZ2FjeShjLCBQb2ludCk7XG59XG5mdW5jdGlvbiBfd2VpZXJzdHJhc3NfbGVnYWN5X29wdHNfdG9fbmV3KGMpIHtcbiAgICBjb25zdCBDVVJWRSA9IHtcbiAgICAgICAgYTogYy5hLFxuICAgICAgICBiOiBjLmIsXG4gICAgICAgIHA6IGMuRnAuT1JERVIsXG4gICAgICAgIG46IGMubixcbiAgICAgICAgaDogYy5oLFxuICAgICAgICBHeDogYy5HeCxcbiAgICAgICAgR3k6IGMuR3ksXG4gICAgfTtcbiAgICBjb25zdCBGcCA9IGMuRnA7XG4gICAgbGV0IGFsbG93ZWRMZW5ndGhzID0gYy5hbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHNcbiAgICAgICAgPyBBcnJheS5mcm9tKG5ldyBTZXQoYy5hbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHMubWFwKChsKSA9PiBNYXRoLmNlaWwobCAvIDIpKSkpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IEZuID0gRmllbGQoQ1VSVkUubiwge1xuICAgICAgICBCSVRTOiBjLm5CaXRMZW5ndGgsXG4gICAgICAgIGFsbG93ZWRMZW5ndGhzOiBhbGxvd2VkTGVuZ3RocyxcbiAgICAgICAgbW9kRnJvbUJ5dGVzOiBjLndyYXBQcml2YXRlS2V5LFxuICAgIH0pO1xuICAgIGNvbnN0IGN1cnZlT3B0cyA9IHtcbiAgICAgICAgRnAsXG4gICAgICAgIEZuLFxuICAgICAgICBhbGxvd0luZmluaXR5UG9pbnQ6IGMuYWxsb3dJbmZpbml0eVBvaW50LFxuICAgICAgICBlbmRvOiBjLmVuZG8sXG4gICAgICAgIGlzVG9yc2lvbkZyZWU6IGMuaXNUb3JzaW9uRnJlZSxcbiAgICAgICAgY2xlYXJDb2ZhY3RvcjogYy5jbGVhckNvZmFjdG9yLFxuICAgICAgICBmcm9tQnl0ZXM6IGMuZnJvbUJ5dGVzLFxuICAgICAgICB0b0J5dGVzOiBjLnRvQnl0ZXMsXG4gICAgfTtcbiAgICByZXR1cm4geyBDVVJWRSwgY3VydmVPcHRzIH07XG59XG5mdW5jdGlvbiBfZWNkc2FfbGVnYWN5X29wdHNfdG9fbmV3KGMpIHtcbiAgICBjb25zdCB7IENVUlZFLCBjdXJ2ZU9wdHMgfSA9IF93ZWllcnN0cmFzc19sZWdhY3lfb3B0c190b19uZXcoYyk7XG4gICAgY29uc3QgZWNkc2FPcHRzID0ge1xuICAgICAgICBobWFjOiBjLmhtYWMsXG4gICAgICAgIHJhbmRvbUJ5dGVzOiBjLnJhbmRvbUJ5dGVzLFxuICAgICAgICBsb3dTOiBjLmxvd1MsXG4gICAgICAgIGJpdHMyaW50OiBjLmJpdHMyaW50LFxuICAgICAgICBiaXRzMmludF9tb2ROOiBjLmJpdHMyaW50X21vZE4sXG4gICAgfTtcbiAgICByZXR1cm4geyBDVVJWRSwgY3VydmVPcHRzLCBoYXNoOiBjLmhhc2gsIGVjZHNhT3B0cyB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIF9sZWdhY3lIZWxwZXJFcXVhdChGcCwgYSwgYikge1xuICAgIC8qKlxuICAgICAqIHnCsiA9IHjCsyArIGF4ICsgYjogU2hvcnQgd2VpZXJzdHJhc3MgY3VydmUgZm9ybXVsYS4gVGFrZXMgeCwgcmV0dXJucyB5wrIuXG4gICAgICogQHJldHVybnMgecKyXG4gICAgICovXG4gICAgZnVuY3Rpb24gd2VpZXJzdHJhc3NFcXVhdGlvbih4KSB7XG4gICAgICAgIGNvbnN0IHgyID0gRnAuc3FyKHgpOyAvLyB4ICogeFxuICAgICAgICBjb25zdCB4MyA9IEZwLm11bCh4MiwgeCk7IC8vIHjCsiAqIHhcbiAgICAgICAgcmV0dXJuIEZwLmFkZChGcC5hZGQoeDMsIEZwLm11bCh4LCBhKSksIGIpOyAvLyB4wrMgKyBhICogeCArIGJcbiAgICB9XG4gICAgcmV0dXJuIHdlaWVyc3RyYXNzRXF1YXRpb247XG59XG5mdW5jdGlvbiBfd2VpZXJzdHJhc3NfbmV3X291dHB1dF90b19sZWdhY3koYywgUG9pbnQpIHtcbiAgICBjb25zdCB7IEZwLCBGbiB9ID0gUG9pbnQ7XG4gICAgZnVuY3Rpb24gaXNXaXRoaW5DdXJ2ZU9yZGVyKG51bSkge1xuICAgICAgICByZXR1cm4gaW5SYW5nZShudW0sIF8xbiwgRm4uT1JERVIpO1xuICAgIH1cbiAgICBjb25zdCB3ZWllcnN0cmFzc0VxdWF0aW9uID0gX2xlZ2FjeUhlbHBlckVxdWF0KEZwLCBjLmEsIGMuYik7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHtcbiAgICAgICAgQ1VSVkU6IGMsXG4gICAgICAgIFBvaW50OiBQb2ludCxcbiAgICAgICAgUHJvamVjdGl2ZVBvaW50OiBQb2ludCxcbiAgICAgICAgbm9ybVByaXZhdGVLZXlUb1NjYWxhcjogKGtleSkgPT4gX25vcm1GbkVsZW1lbnQoRm4sIGtleSksXG4gICAgICAgIHdlaWVyc3RyYXNzRXF1YXRpb24sXG4gICAgICAgIGlzV2l0aGluQ3VydmVPcmRlcixcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIF9lY2RzYV9uZXdfb3V0cHV0X3RvX2xlZ2FjeShjLCBfZWNkc2EpIHtcbiAgICBjb25zdCBQb2ludCA9IF9lY2RzYS5Qb2ludDtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgX2VjZHNhLCB7XG4gICAgICAgIFByb2plY3RpdmVQb2ludDogUG9pbnQsXG4gICAgICAgIENVUlZFOiBPYmplY3QuYXNzaWduKHt9LCBjLCBuTGVuZ3RoKFBvaW50LkZuLk9SREVSLCBQb2ludC5Gbi5CSVRTKSksXG4gICAgfSk7XG59XG4vLyBfZWNkc2FfbGVnYWN5XG5leHBvcnQgZnVuY3Rpb24gd2VpZXJzdHJhc3MoYykge1xuICAgIGNvbnN0IHsgQ1VSVkUsIGN1cnZlT3B0cywgaGFzaCwgZWNkc2FPcHRzIH0gPSBfZWNkc2FfbGVnYWN5X29wdHNfdG9fbmV3KGMpO1xuICAgIGNvbnN0IFBvaW50ID0gd2VpZXJzdHJhc3NOKENVUlZFLCBjdXJ2ZU9wdHMpO1xuICAgIGNvbnN0IHNpZ25zID0gZWNkc2EoUG9pbnQsIGhhc2gsIGVjZHNhT3B0cyk7XG4gICAgcmV0dXJuIF9lY2RzYV9uZXdfb3V0cHV0X3RvX2xlZ2FjeShjLCBzaWducyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWllcnN0cmFzcy5qcy5tYXAiXSwibmFtZXMiOlsiaG1hYyIsIm5vYmxlSG1hYyIsImFoYXNoIiwiX3ZhbGlkYXRlT2JqZWN0IiwiX2Fib29sMiIsImFib29sIiwiX2FieXRlczIiLCJhYnl0ZXMiLCJhSW5SYW5nZSIsImJpdExlbiIsImJpdE1hc2siLCJieXRlc1RvSGV4IiwiYnl0ZXNUb051bWJlckJFIiwiY29uY2F0Qnl0ZXMiLCJjcmVhdGVIbWFjRHJiZyIsImVuc3VyZUJ5dGVzIiwiaGV4VG9CeXRlcyIsImluUmFuZ2UiLCJpc0J5dGVzIiwibWVtb2l6ZWQiLCJudW1iZXJUb0hleFVucGFkZGVkIiwicmFuZG9tQnl0ZXMiLCJyYW5kb21CeXRlc1dlYiIsIl9jcmVhdGVDdXJ2ZUZpZWxkcyIsIm11bEVuZG9VbnNhZmUiLCJuZWdhdGVDdCIsIm5vcm1hbGl6ZVoiLCJwaXBwZW5nZXIiLCJ3TkFGIiwiRmllbGQiLCJGcEludmVydEJhdGNoIiwiZ2V0TWluSGFzaExlbmd0aCIsIm1hcEhhc2hUb0ZpZWxkIiwibkxlbmd0aCIsInZhbGlkYXRlRmllbGQiLCJkaXZOZWFyZXN0IiwibnVtIiwiZGVuIiwiXzJuIiwiX3NwbGl0RW5kb1NjYWxhciIsImsiLCJiYXNpcyIsIm4iLCJhMSIsImIxIiwiYTIiLCJiMiIsImMxIiwiYzIiLCJrMSIsImsyIiwiazFuZWciLCJfMG4iLCJrMm5lZyIsIk1BWF9OVU0iLCJNYXRoIiwiY2VpbCIsIl8xbiIsIkVycm9yIiwidmFsaWRhdGVTaWdGb3JtYXQiLCJmb3JtYXQiLCJpbmNsdWRlcyIsInZhbGlkYXRlU2lnT3B0cyIsIm9wdHMiLCJkZWYiLCJvcHRzbiIsIm9wdE5hbWUiLCJPYmplY3QiLCJrZXlzIiwidW5kZWZpbmVkIiwibG93UyIsInByZWhhc2giLCJERVJFcnIiLCJjb25zdHJ1Y3RvciIsIm0iLCJERVIiLCJFcnIiLCJfdGx2IiwiZW5jb2RlIiwidGFnIiwiZGF0YSIsIkUiLCJsZW5ndGgiLCJkYXRhTGVuIiwibGVuIiwibGVuTGVuIiwidCIsImRlY29kZSIsInBvcyIsImZpcnN0IiwiaXNMb25nIiwibGVuZ3RoQnl0ZXMiLCJzdWJhcnJheSIsImIiLCJ2IiwibCIsIl9pbnQiLCJoZXgiLCJOdW1iZXIiLCJwYXJzZUludCIsInRvU2lnIiwiaW50IiwidGx2Iiwic2VxQnl0ZXMiLCJzZXFMZWZ0Qnl0ZXMiLCJyQnl0ZXMiLCJyTGVmdEJ5dGVzIiwic0J5dGVzIiwic0xlZnRCeXRlcyIsInIiLCJzIiwiaGV4RnJvbVNpZyIsInNpZyIsInJzIiwic3MiLCJzZXEiLCJCaWdJbnQiLCJfM24iLCJfNG4iLCJfbm9ybUZuRWxlbWVudCIsIkZuIiwia2V5IiwiQllURVMiLCJleHBlY3RlZCIsImJ5dGVzIiwiZnJvbUJ5dGVzIiwiZXJyb3IiLCJpc1ZhbGlkTm90MCIsIndlaWVyc3RyYXNzTiIsInBhcmFtcyIsImV4dHJhT3B0cyIsInZhbGlkYXRlZCIsIkZwIiwiQ1VSVkUiLCJoIiwiY29mYWN0b3IiLCJDVVJWRV9PUkRFUiIsImFsbG93SW5maW5pdHlQb2ludCIsImNsZWFyQ29mYWN0b3IiLCJpc1RvcnNpb25GcmVlIiwidG9CeXRlcyIsImVuZG8iLCJ3cmFwUHJpdmF0ZUtleSIsImlzMCIsImEiLCJiZXRhIiwiQXJyYXkiLCJpc0FycmF5IiwiYmFzaXNlcyIsImxlbmd0aHMiLCJnZXRXTGVuZ3RocyIsImFzc2VydENvbXByZXNzaW9uSXNTdXBwb3J0ZWQiLCJpc09kZCIsInBvaW50VG9CeXRlcyIsIl9jIiwicG9pbnQiLCJpc0NvbXByZXNzZWQiLCJ4IiwieSIsInRvQWZmaW5lIiwiYngiLCJoYXNFdmVuWSIsInBwcmVmaXgiLCJVaW50OEFycmF5Iiwib2YiLCJwb2ludEZyb21CeXRlcyIsInB1YmxpY0tleSIsImNvbXAiLCJwdWJsaWNLZXlVbmNvbXByZXNzZWQiLCJ1bmNvbXAiLCJoZWFkIiwidGFpbCIsImlzVmFsaWQiLCJ5MiIsIndlaWVyc3RyYXNzRXF1YXRpb24iLCJzcXJ0Iiwic3FydEVycm9yIiwiZXJyIiwibWVzc2FnZSIsImlzWU9kZCIsImlzSGVhZE9kZCIsIm5lZyIsIkwiLCJpc1ZhbGlkWFkiLCJlbmNvZGVQb2ludCIsImRlY29kZVBvaW50IiwieDIiLCJzcXIiLCJ4MyIsIm11bCIsImFkZCIsImxlZnQiLCJyaWdodCIsImVxbCIsIkd4IiwiR3kiLCJfNGEzIiwicG93IiwiXzI3YjIiLCJhY29vcmQiLCJ0aXRsZSIsImJhblplcm8iLCJhcHJqcG9pbnQiLCJvdGhlciIsIlBvaW50Iiwic3BsaXRFbmRvU2NhbGFyTiIsIk9SREVSIiwidG9BZmZpbmVNZW1vIiwicCIsIml6IiwiWCIsIlkiLCJaIiwiT05FIiwiaW52IiwienoiLCJaRVJPIiwiYXNzZXJ0VmFsaWRNZW1vIiwiZmluaXNoRW5kbyIsImVuZG9CZXRhIiwiazFwIiwiazJwIiwiZnJlZXplIiwiZnJvbUFmZmluZSIsIlAiLCJhc3NlcnRWYWxpZGl0eSIsImZyb21IZXgiLCJwcmVjb21wdXRlIiwid2luZG93U2l6ZSIsImlzTGF6eSIsInduYWYiLCJjcmVhdGVDYWNoZSIsIm11bHRpcGx5IiwiZXF1YWxzIiwiWDEiLCJZMSIsIloxIiwiWDIiLCJZMiIsIloyIiwiVTEiLCJVMiIsIm5lZ2F0ZSIsImRvdWJsZSIsImIzIiwiWDMiLCJZMyIsIlozIiwidDAiLCJ0MSIsInQyIiwidDMiLCJzdWIiLCJ0NCIsInQ1Iiwic3VidHJhY3QiLCJzY2FsYXIiLCJmYWtlIiwiY2FjaGVkIiwiZiIsImsxZiIsImsyZiIsIm11bHRpcGx5VW5zYWZlIiwic2MiLCJoYXNDYWNoZSIsInAxIiwicDIiLCJ1bnNhZmUiLCJtdWx0aXBseUFuZEFkZFVuc2FmZSIsIlEiLCJzdW0iLCJpbnZlcnRlZFoiLCJpc1NtYWxsT3JkZXIiLCJ0b0hleCIsInRvU3RyaW5nIiwicHgiLCJweSIsInB6IiwidG9SYXdCeXRlcyIsIl9zZXRXaW5kb3dTaXplIiwicG9pbnRzIiwibXNtIiwic2NhbGFycyIsImZyb21Qcml2YXRlS2V5IiwicHJpdmF0ZUtleSIsIkJBU0UiLCJiaXRzIiwiQklUUyIsIlNXVUZwU3FydFJhdGlvIiwicSIsIm8iLCJfMm5fcG93X2MxXzEiLCJfMm5fcG93X2MxIiwiYzMiLCJjNCIsImM1IiwiYzYiLCJjNyIsInNxcnRSYXRpbyIsInUiLCJ0djEiLCJ0djIiLCJ0djMiLCJ0djUiLCJ0djQiLCJpc1FSIiwiY21vdiIsImkiLCJ0dnY1IiwiZTEiLCJ2YWx1ZSIsInkxIiwibWFwVG9DdXJ2ZVNpbXBsZVNXVSIsIkEiLCJCIiwidHY2IiwidHY0X2ludiIsInNlY3JldEtleSIsInB1YmxpY0tleUhhc1ByZWZpeCIsInNpZ25hdHVyZSIsImVjZGgiLCJlY2RoT3B0cyIsInJhbmRvbUJ5dGVzXyIsImFzc2lnbiIsInNlZWQiLCJpc1ZhbGlkU2VjcmV0S2V5IiwiaXNWYWxpZFB1YmxpY0tleSIsInJhbmRvbVNlY3JldEtleSIsImdldFB1YmxpY0tleSIsImtleWdlbiIsImlzUHJvYlB1YiIsIml0ZW0iLCJhbGxvd2VkTGVuZ3RocyIsImdldFNoYXJlZFNlY3JldCIsInNlY3JldEtleUEiLCJwdWJsaWNLZXlCIiwidXRpbHMiLCJpc1ZhbGlkUHJpdmF0ZUtleSIsInJhbmRvbVByaXZhdGVLZXkiLCJub3JtUHJpdmF0ZUtleVRvU2NhbGFyIiwiZWNkc2EiLCJoYXNoIiwiZWNkc2FPcHRzIiwiYml0czJpbnQiLCJiaXRzMmludF9tb2ROIiwibXNncyIsImZuQml0cyIsImRlZmF1bHRTaWdPcHRzIiwiZXh0cmFFbnRyb3B5IiwiZGVmYXVsdFNpZ09wdHNfZm9ybWF0IiwiaXNCaWdnZXJUaGFuSGFsZk9yZGVyIiwibnVtYmVyIiwiSEFMRiIsInZhbGlkYXRlUlMiLCJ2YWxpZGF0ZVNpZ0xlbmd0aCIsInNpemUiLCJzaXplciIsIlNpZ25hdHVyZSIsInJlY292ZXJ5IiwicmVjaWQiLCJhZGRSZWNvdmVyeUJpdCIsInJlY292ZXJQdWJsaWNLZXkiLCJtZXNzYWdlSGFzaCIsIkZJRUxEX09SREVSIiwicmVjIiwiaGFzQ29mYWN0b3IiLCJyYWRqIiwiUiIsImlyIiwidTEiLCJjcmVhdGUiLCJ1MiIsImhhc0hpZ2hTIiwiZnJvbUNvbXBhY3QiLCJmcm9tREVSIiwibm9ybWFsaXplUyIsInRvREVSUmF3Qnl0ZXMiLCJ0b0RFUkhleCIsInRvQ29tcGFjdFJhd0J5dGVzIiwidG9Db21wYWN0SGV4IiwiYml0czJpbnRfZGVmIiwiZGVsdGEiLCJiaXRzMmludF9tb2ROX2RlZiIsIk9SREVSX01BU0siLCJpbnQyb2N0ZXRzIiwidmFsaWRhdGVNc2dBbmRIYXNoIiwicHJlcFNpZyIsInNvbWUiLCJoMWludCIsImQiLCJzZWVkQXJncyIsImUiLCJwdXNoIiwiazJzaWciLCJrQnl0ZXMiLCJpayIsIm5vcm1TIiwic2lnbiIsImRyYmciLCJvdXRwdXRMZW4iLCJ0cnlQYXJzaW5nU2lnIiwic2ciLCJpc0hleCIsImlzT2JqIiwiZGVyRXJyb3IiLCJ2ZXJpZnkiLCJpcyIsIndlaWVyc3RyYXNzUG9pbnRzIiwiYyIsImN1cnZlT3B0cyIsIl93ZWllcnN0cmFzc19sZWdhY3lfb3B0c190b19uZXciLCJfd2VpZXJzdHJhc3NfbmV3X291dHB1dF90b19sZWdhY3kiLCJhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHMiLCJmcm9tIiwiU2V0IiwibWFwIiwibkJpdExlbmd0aCIsIm1vZEZyb21CeXRlcyIsIl9lY2RzYV9sZWdhY3lfb3B0c190b19uZXciLCJfbGVnYWN5SGVscGVyRXF1YXQiLCJpc1dpdGhpbkN1cnZlT3JkZXIiLCJQcm9qZWN0aXZlUG9pbnQiLCJfZWNkc2FfbmV3X291dHB1dF90b19sZWdhY3kiLCJfZWNkc2EiLCJ3ZWllcnN0cmFzcyIsInNpZ25zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/weierstrass.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/ed25519.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/ed25519.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ED25519_TORSION_SUBGROUP: () => (/* binding */ ED25519_TORSION_SUBGROUP),\n/* harmony export */   RistrettoPoint: () => (/* binding */ RistrettoPoint),\n/* harmony export */   ed25519: () => (/* binding */ ed25519),\n/* harmony export */   ed25519_hasher: () => (/* binding */ ed25519_hasher),\n/* harmony export */   ed25519ctx: () => (/* binding */ ed25519ctx),\n/* harmony export */   ed25519ph: () => (/* binding */ ed25519ph),\n/* harmony export */   edwardsToMontgomery: () => (/* binding */ edwardsToMontgomery),\n/* harmony export */   edwardsToMontgomeryPriv: () => (/* binding */ edwardsToMontgomeryPriv),\n/* harmony export */   edwardsToMontgomeryPub: () => (/* binding */ edwardsToMontgomeryPub),\n/* harmony export */   encodeToCurve: () => (/* binding */ encodeToCurve),\n/* harmony export */   hashToCurve: () => (/* binding */ hashToCurve),\n/* harmony export */   hashToRistretto255: () => (/* binding */ hashToRistretto255),\n/* harmony export */   hash_to_ristretto255: () => (/* binding */ hash_to_ristretto255),\n/* harmony export */   ristretto255: () => (/* binding */ ristretto255),\n/* harmony export */   ristretto255_hasher: () => (/* binding */ ristretto255_hasher),\n/* harmony export */   x25519: () => (/* binding */ x25519)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/sha2.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/sha2.js\");\n/* harmony import */ var _noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/hashes/utils.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_curve_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./abstract/curve.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/curve.js\");\n/* harmony import */ var _abstract_edwards_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract/edwards.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/edwards.js\");\n/* harmony import */ var _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/* harmony import */ var _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract/modular.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _abstract_montgomery_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./abstract/montgomery.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/montgomery.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/utils.js\");\n/**\n * ed25519 Twisted Edwards curve with following addons:\n * - X25519 ECDH\n * - Ristretto cofactor elimination\n * - Elligator hash-to-group / point indistinguishability\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\n\n\n\n\n\n\n// prettier-ignore\nconst _0n = /* @__PURE__ */ BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _5n = BigInt(5), _8n = BigInt(8);\n// P = 2n**255n-19n\nconst ed25519_CURVE_p = BigInt(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed\");\n// N = 2n**252n + 27742317777372353535851937790883648493n\n// a = Fp.create(BigInt(-1))\n// d = -121665/121666 a.k.a. Fp.neg(121665 * Fp.inv(121666))\nconst ed25519_CURVE = /* @__PURE__ */ (()=>({\n        p: ed25519_CURVE_p,\n        n: BigInt(\"0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed\"),\n        h: _8n,\n        a: BigInt(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec\"),\n        d: BigInt(\"0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3\"),\n        Gx: BigInt(\"0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a\"),\n        Gy: BigInt(\"0x6666666666666666666666666666666666666666666666666666666666666658\")\n    }))();\nfunction ed25519_pow_2_252_3(x) {\n    // prettier-ignore\n    const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);\n    const P = ed25519_CURVE_p;\n    const x2 = x * x % P;\n    const b2 = x2 * x % P; // x^3, 11\n    const b4 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b2, _2n, P) * b2 % P; // x^15, 1111\n    const b5 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b4, _1n, P) * x % P; // x^31\n    const b10 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b5, _5n, P) * b5 % P;\n    const b20 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b10, _10n, P) * b10 % P;\n    const b40 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b20, _20n, P) * b20 % P;\n    const b80 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b40, _40n, P) * b40 % P;\n    const b160 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b80, _80n, P) * b80 % P;\n    const b240 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b160, _80n, P) * b80 % P;\n    const b250 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b240, _10n, P) * b10 % P;\n    const pow_p_5_8 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b250, _2n, P) * x % P;\n    // ^ To pow to (p+3)/8, multiply it by x.\n    return {\n        pow_p_5_8,\n        b2\n    };\n}\nfunction adjustScalarBytes(bytes) {\n    // Section 5: For X25519, in order to decode 32 random bytes as an integer scalar,\n    // set the three least significant bits of the first byte\n    bytes[0] &= 248; // 0b1111_1000\n    // and the most significant bit of the last to zero,\n    bytes[31] &= 127; // 0b0111_1111\n    // set the second most significant bit of the last byte to 1\n    bytes[31] |= 64; // 0b0100_0000\n    return bytes;\n}\n// (-1) aka (a) aka 2^((p-1)/4)\n// Fp.sqrt(Fp.neg(1))\nconst ED25519_SQRT_M1 = /* @__PURE__ */ BigInt(\"19681161376707505956807079304988542015446066515923890162744021073123829784752\");\n// sqrt(u/v)\nfunction uvRatio(u, v) {\n    const P = ed25519_CURVE_p;\n    const v3 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(v * v * v, P); // v\n    const v7 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(v3 * v3 * v, P); // v\n    // (p+3)/8 and (p-5)/8\n    const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;\n    let x = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(u * v3 * pow, P); // (uv)(uv)^(p-5)/8\n    const vx2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(v * x * x, P); // vx\n    const root1 = x; // First root candidate\n    const root2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x * ED25519_SQRT_M1, P); // Second root candidate\n    const useRoot1 = vx2 === u; // If vx = u (mod p), x is a square root\n    const useRoot2 = vx2 === (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-u, P); // If vx = -u, set x <-- x * 2^((p-1)/4)\n    const noRoot = vx2 === (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-u * ED25519_SQRT_M1, P); // There is no valid root, vx = -u(-1)\n    if (useRoot1) x = root1;\n    if (useRoot2 || noRoot) x = root2; // We return root2 anyway, for const-time\n    if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(x, P)) x = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-x, P);\n    return {\n        isValid: useRoot1 || useRoot2,\n        value: x\n    };\n}\nconst Fp = /* @__PURE__ */ (()=>(0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(ed25519_CURVE.p, {\n        isLE: true\n    }))();\nconst Fn = /* @__PURE__ */ (()=>(0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(ed25519_CURVE.n, {\n        isLE: true\n    }))();\nconst ed25519Defaults = /* @__PURE__ */ (()=>({\n        ...ed25519_CURVE,\n        Fp,\n        hash: _noble_hashes_sha2_js__WEBPACK_IMPORTED_MODULE_1__.sha512,\n        adjustScalarBytes,\n        // dom2\n        // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.\n        // Constant-time, u/v\n        uvRatio\n    }))();\n/**\n * ed25519 curve with EdDSA signatures.\n * @example\n * import { ed25519 } from '@noble/curves/ed25519';\n * const { secretKey, publicKey } = ed25519.keygen();\n * const msg = new TextEncoder().encode('hello');\n * const sig = ed25519.sign(msg, priv);\n * ed25519.verify(sig, msg, pub); // Default mode: follows ZIP215\n * ed25519.verify(sig, msg, pub, { zip215: false }); // RFC8032 / FIPS 186-5\n */ const ed25519 = /* @__PURE__ */ (()=>(0,_abstract_edwards_js__WEBPACK_IMPORTED_MODULE_2__.twistedEdwards)(ed25519Defaults))();\nfunction ed25519_domain(data, ctx, phflag) {\n    if (ctx.length > 255) throw new Error(\"Context is too big\");\n    return (0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)((0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_3__.utf8ToBytes)(\"SigEd25519 no Ed25519 collisions\"), new Uint8Array([\n        phflag ? 1 : 0,\n        ctx.length\n    ]), ctx, data);\n}\n/** Context of ed25519. Uses context for domain separation. */ const ed25519ctx = /* @__PURE__ */ (()=>(0,_abstract_edwards_js__WEBPACK_IMPORTED_MODULE_2__.twistedEdwards)({\n        ...ed25519Defaults,\n        domain: ed25519_domain\n    }))();\n/** Prehashed version of ed25519. Accepts already-hashed messages in sign() and verify(). */ const ed25519ph = /* @__PURE__ */ (()=>(0,_abstract_edwards_js__WEBPACK_IMPORTED_MODULE_2__.twistedEdwards)(Object.assign({}, ed25519Defaults, {\n        domain: ed25519_domain,\n        prehash: _noble_hashes_sha2_js__WEBPACK_IMPORTED_MODULE_1__.sha512\n    })))();\n/**\n * ECDH using curve25519 aka x25519.\n * @example\n * import { x25519 } from '@noble/curves/ed25519';\n * const priv = 'a546e36bf0527c9d3b16154b82465edd62144c0ac1fc5a18506a2244ba449ac4';\n * const pub = 'e6db6867583030db3594c1a424b15f7c726624ec26b3353b10a903a6d0ab1c4c';\n * x25519.getSharedSecret(priv, pub) === x25519.scalarMult(priv, pub); // aliases\n * x25519.getPublicKey(priv) === x25519.scalarMultBase(priv);\n * x25519.getPublicKey(x25519.utils.randomSecretKey());\n */ const x25519 = /* @__PURE__ */ (()=>{\n    const P = Fp.ORDER;\n    return (0,_abstract_montgomery_js__WEBPACK_IMPORTED_MODULE_4__.montgomery)({\n        P,\n        type: \"x25519\",\n        powPminus2: (x)=>{\n            // x^(p-2) aka x^(2^255-21)\n            const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);\n            return (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(pow_p_5_8, _3n, P) * b2, P);\n        },\n        adjustScalarBytes\n    });\n})();\n// Hash To Curve Elligator2 Map (NOTE: different from ristretto255 elligator)\n// NOTE: very important part is usage of FpSqrtEven for ELL2_C1_EDWARDS, since\n// SageMath returns different root first and everything falls apart\nconst ELL2_C1 = /* @__PURE__ */ (()=>(ed25519_CURVE_p + _3n) / _8n)(); // 1. c1 = (q + 3) / 8       # Integer arithmetic\nconst ELL2_C2 = /* @__PURE__ */ (()=>Fp.pow(_2n, ELL2_C1))(); // 2. c2 = 2^c1\nconst ELL2_C3 = /* @__PURE__ */ (()=>Fp.sqrt(Fp.neg(Fp.ONE)))(); // 3. c3 = sqrt(-1)\n// prettier-ignore\nfunction map_to_curve_elligator2_curve25519(u) {\n    const ELL2_C4 = (ed25519_CURVE_p - _5n) / _8n; // 4. c4 = (q - 5) / 8       # Integer arithmetic\n    const ELL2_J = BigInt(486662);\n    let tv1 = Fp.sqr(u); //  1.  tv1 = u^2\n    tv1 = Fp.mul(tv1, _2n); //  2.  tv1 = 2 * tv1\n    let xd = Fp.add(tv1, Fp.ONE); //  3.   xd = tv1 + 1         # Nonzero: -1 is square (mod p), tv1 is not\n    let x1n = Fp.neg(ELL2_J); //  4.  x1n = -J              # x1 = x1n / xd = -J / (1 + 2 * u^2)\n    let tv2 = Fp.sqr(xd); //  5.  tv2 = xd^2\n    let gxd = Fp.mul(tv2, xd); //  6.  gxd = tv2 * xd        # gxd = xd^3\n    let gx1 = Fp.mul(tv1, ELL2_J); //  7.  gx1 = J * tv1         # x1n + J * xd\n    gx1 = Fp.mul(gx1, x1n); //  8.  gx1 = gx1 * x1n       # x1n^2 + J * x1n * xd\n    gx1 = Fp.add(gx1, tv2); //  9.  gx1 = gx1 + tv2       # x1n^2 + J * x1n * xd + xd^2\n    gx1 = Fp.mul(gx1, x1n); //  10. gx1 = gx1 * x1n       # x1n^3 + J * x1n^2 * xd + x1n * xd^2\n    let tv3 = Fp.sqr(gxd); //  11. tv3 = gxd^2\n    tv2 = Fp.sqr(tv3); //  12. tv2 = tv3^2           # gxd^4\n    tv3 = Fp.mul(tv3, gxd); //  13. tv3 = tv3 * gxd       # gxd^3\n    tv3 = Fp.mul(tv3, gx1); //  14. tv3 = tv3 * gx1       # gx1 * gxd^3\n    tv2 = Fp.mul(tv2, tv3); //  15. tv2 = tv2 * tv3       # gx1 * gxd^7\n    let y11 = Fp.pow(tv2, ELL2_C4); //  16. y11 = tv2^c4        # (gx1 * gxd^7)^((p - 5) / 8)\n    y11 = Fp.mul(y11, tv3); //  17. y11 = y11 * tv3       # gx1*gxd^3*(gx1*gxd^7)^((p-5)/8)\n    let y12 = Fp.mul(y11, ELL2_C3); //  18. y12 = y11 * c3\n    tv2 = Fp.sqr(y11); //  19. tv2 = y11^2\n    tv2 = Fp.mul(tv2, gxd); //  20. tv2 = tv2 * gxd\n    let e1 = Fp.eql(tv2, gx1); //  21.  e1 = tv2 == gx1\n    let y1 = Fp.cmov(y12, y11, e1); //  22.  y1 = CMOV(y12, y11, e1)  # If g(x1) is square, this is its sqrt\n    let x2n = Fp.mul(x1n, tv1); //  23. x2n = x1n * tv1       # x2 = x2n / xd = 2 * u^2 * x1n / xd\n    let y21 = Fp.mul(y11, u); //  24. y21 = y11 * u\n    y21 = Fp.mul(y21, ELL2_C2); //  25. y21 = y21 * c2\n    let y22 = Fp.mul(y21, ELL2_C3); //  26. y22 = y21 * c3\n    let gx2 = Fp.mul(gx1, tv1); //  27. gx2 = gx1 * tv1       # g(x2) = gx2 / gxd = 2 * u^2 * g(x1)\n    tv2 = Fp.sqr(y21); //  28. tv2 = y21^2\n    tv2 = Fp.mul(tv2, gxd); //  29. tv2 = tv2 * gxd\n    let e2 = Fp.eql(tv2, gx2); //  30.  e2 = tv2 == gx2\n    let y2 = Fp.cmov(y22, y21, e2); //  31.  y2 = CMOV(y22, y21, e2)  # If g(x2) is square, this is its sqrt\n    tv2 = Fp.sqr(y1); //  32. tv2 = y1^2\n    tv2 = Fp.mul(tv2, gxd); //  33. tv2 = tv2 * gxd\n    let e3 = Fp.eql(tv2, gx1); //  34.  e3 = tv2 == gx1\n    let xn = Fp.cmov(x2n, x1n, e3); //  35.  xn = CMOV(x2n, x1n, e3)  # If e3, x = x1, else x = x2\n    let y = Fp.cmov(y2, y1, e3); //  36.   y = CMOV(y2, y1, e3)    # If e3, y = y1, else y = y2\n    let e4 = Fp.isOdd(y); //  37.  e4 = sgn0(y) == 1        # Fix sign of y\n    y = Fp.cmov(y, Fp.neg(y), e3 !== e4); //  38.   y = CMOV(y, -y, e3 XOR e4)\n    return {\n        xMn: xn,\n        xMd: xd,\n        yMn: y,\n        yMd: _1n\n    }; //  39. return (xn, xd, y, 1)\n}\nconst ELL2_C1_EDWARDS = /* @__PURE__ */ (()=>(0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.FpSqrtEven)(Fp, Fp.neg(BigInt(486664))))(); // sgn0(c1) MUST equal 0\nfunction map_to_curve_elligator2_edwards25519(u) {\n    const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u); //  1.  (xMn, xMd, yMn, yMd) =\n    // map_to_curve_elligator2_curve25519(u)\n    let xn = Fp.mul(xMn, yMd); //  2.  xn = xMn * yMd\n    xn = Fp.mul(xn, ELL2_C1_EDWARDS); //  3.  xn = xn * c1\n    let xd = Fp.mul(xMd, yMn); //  4.  xd = xMd * yMn    # xn / xd = c1 * xM / yM\n    let yn = Fp.sub(xMn, xMd); //  5.  yn = xMn - xMd\n    let yd = Fp.add(xMn, xMd); //  6.  yd = xMn + xMd    # (n / d - 1) / (n / d + 1) = (n - d) / (n + d)\n    let tv1 = Fp.mul(xd, yd); //  7. tv1 = xd * yd\n    let e = Fp.eql(tv1, Fp.ZERO); //  8.   e = tv1 == 0\n    xn = Fp.cmov(xn, Fp.ZERO, e); //  9.  xn = CMOV(xn, 0, e)\n    xd = Fp.cmov(xd, Fp.ONE, e); //  10. xd = CMOV(xd, 1, e)\n    yn = Fp.cmov(yn, Fp.ONE, e); //  11. yn = CMOV(yn, 1, e)\n    yd = Fp.cmov(yd, Fp.ONE, e); //  12. yd = CMOV(yd, 1, e)\n    const [xd_inv, yd_inv] = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.FpInvertBatch)(Fp, [\n        xd,\n        yd\n    ], true); // batch division\n    return {\n        x: Fp.mul(xn, xd_inv),\n        y: Fp.mul(yn, yd_inv)\n    }; //  13. return (xn, xd, yn, yd)\n}\n/** Hashing to ed25519 points / field. RFC 9380 methods. */ const ed25519_hasher = /* @__PURE__ */ (()=>(0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.createHasher)(ed25519.Point, (scalars)=>map_to_curve_elligator2_edwards25519(scalars[0]), {\n        DST: \"edwards25519_XMD:SHA-512_ELL2_RO_\",\n        encodeDST: \"edwards25519_XMD:SHA-512_ELL2_NU_\",\n        p: ed25519_CURVE_p,\n        m: 1,\n        k: 128,\n        expand: \"xmd\",\n        hash: _noble_hashes_sha2_js__WEBPACK_IMPORTED_MODULE_1__.sha512\n    }))();\n// (-1) aka (a) aka 2^((p-1)/4)\nconst SQRT_M1 = ED25519_SQRT_M1;\n// (ad - 1)\nconst SQRT_AD_MINUS_ONE = /* @__PURE__ */ BigInt(\"25063068953384623474111414158702152701244531502492656460079210482610430750235\");\n// 1 / (a-d)\nconst INVSQRT_A_MINUS_D = /* @__PURE__ */ BigInt(\"54469307008909316920995813868745141605393597292927456921205312896311721017578\");\n// 1-d\nconst ONE_MINUS_D_SQ = /* @__PURE__ */ BigInt(\"1159843021668779879193775521855586647937357759715417654439879720876111806838\");\n// (d-1)\nconst D_MINUS_ONE_SQ = /* @__PURE__ */ BigInt(\"40440834346308536858101042469323190826248399146238708352240133220865137265952\");\n// Calculates 1/(number)\nconst invertSqrt = (number)=>uvRatio(_1n, number);\nconst MAX_255B = /* @__PURE__ */ BigInt(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\nconst bytes255ToNumberLE = (bytes)=>ed25519.Point.Fp.create((0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.bytesToNumberLE)(bytes) & MAX_255B);\n/**\n * Computes Elligator map for Ristretto255.\n * Described in [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#appendix-B) and on\n * the [website](https://ristretto.group/formulas/elligator.html).\n */ function calcElligatorRistrettoMap(r0) {\n    const { d } = ed25519_CURVE;\n    const P = ed25519_CURVE_p;\n    const mod = (n)=>Fp.create(n);\n    const r = mod(SQRT_M1 * r0 * r0); // 1\n    const Ns = mod((r + _1n) * ONE_MINUS_D_SQ); // 2\n    let c = BigInt(-1); // 3\n    const D = mod((c - d * r) * mod(r + d)); // 4\n    let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D); // 5\n    let s_ = mod(s * r0); // 6\n    if (!(0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(s_, P)) s_ = mod(-s_);\n    if (!Ns_D_is_sq) s = s_; // 7\n    if (!Ns_D_is_sq) c = r; // 8\n    const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D); // 9\n    const s2 = s * s;\n    const W0 = mod((s + s) * D); // 10\n    const W1 = mod(Nt * SQRT_AD_MINUS_ONE); // 11\n    const W2 = mod(_1n - s2); // 12\n    const W3 = mod(_1n + s2); // 13\n    return new ed25519.Point(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));\n}\nfunction ristretto255_map(bytes) {\n    (0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_3__.abytes)(bytes, 64);\n    const r1 = bytes255ToNumberLE(bytes.subarray(0, 32));\n    const R1 = calcElligatorRistrettoMap(r1);\n    const r2 = bytes255ToNumberLE(bytes.subarray(32, 64));\n    const R2 = calcElligatorRistrettoMap(r2);\n    return new _RistrettoPoint(R1.add(R2));\n}\n/**\n * Wrapper over Edwards Point for ristretto255.\n *\n * Each ed25519/ExtendedPoint has 8 different equivalent points. This can be\n * a source of bugs for protocols like ring signatures. Ristretto was created to solve this.\n * Ristretto point operates in X:Y:Z:T extended coordinates like ExtendedPoint,\n * but it should work in its own namespace: do not combine those two.\n * See [RFC9496](https://www.rfc-editor.org/rfc/rfc9496).\n */ class _RistrettoPoint extends _abstract_edwards_js__WEBPACK_IMPORTED_MODULE_2__.PrimeEdwardsPoint {\n    constructor(ep){\n        super(ep);\n    }\n    static fromAffine(ap) {\n        return new _RistrettoPoint(ed25519.Point.fromAffine(ap));\n    }\n    assertSame(other) {\n        if (!(other instanceof _RistrettoPoint)) throw new Error(\"RistrettoPoint expected\");\n    }\n    init(ep) {\n        return new _RistrettoPoint(ep);\n    }\n    /** @deprecated use `import { ristretto255_hasher } from '@noble/curves/ed25519.js';` */ static hashToCurve(hex) {\n        return ristretto255_map((0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.ensureBytes)(\"ristrettoHash\", hex, 64));\n    }\n    static fromBytes(bytes) {\n        (0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_3__.abytes)(bytes, 32);\n        const { a, d } = ed25519_CURVE;\n        const P = ed25519_CURVE_p;\n        const mod = (n)=>Fp.create(n);\n        const s = bytes255ToNumberLE(bytes);\n        // 1. Check that s_bytes is the canonical encoding of a field element, or else abort.\n        // 3. Check that s is non-negative, or else abort\n        if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.equalBytes)(Fp.toBytes(s), bytes) || (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(s, P)) throw new Error(\"invalid ristretto255 encoding 1\");\n        const s2 = mod(s * s);\n        const u1 = mod(_1n + a * s2); // 4 (a is -1)\n        const u2 = mod(_1n - a * s2); // 5\n        const u1_2 = mod(u1 * u1);\n        const u2_2 = mod(u2 * u2);\n        const v = mod(a * d * u1_2 - u2_2); // 6\n        const { isValid, value: I } = invertSqrt(mod(v * u2_2)); // 7\n        const Dx = mod(I * u2); // 8\n        const Dy = mod(I * Dx * v); // 9\n        let x = mod((s + s) * Dx); // 10\n        if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(x, P)) x = mod(-x); // 10\n        const y = mod(u1 * Dy); // 11\n        const t = mod(x * y); // 12\n        if (!isValid || (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(t, P) || y === _0n) throw new Error(\"invalid ristretto255 encoding 2\");\n        return new _RistrettoPoint(new ed25519.Point(x, y, _1n, t));\n    }\n    /**\n     * Converts ristretto-encoded string to ristretto point.\n     * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-decode).\n     * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding\n     */ static fromHex(hex) {\n        return _RistrettoPoint.fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.ensureBytes)(\"ristrettoHex\", hex, 32));\n    }\n    static msm(points, scalars) {\n        return (0,_abstract_curve_js__WEBPACK_IMPORTED_MODULE_7__.pippenger)(_RistrettoPoint, ed25519.Point.Fn, points, scalars);\n    }\n    /**\n     * Encodes ristretto point to Uint8Array.\n     * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-encode).\n     */ toBytes() {\n        let { X, Y, Z, T } = this.ep;\n        const P = ed25519_CURVE_p;\n        const mod = (n)=>Fp.create(n);\n        const u1 = mod(mod(Z + Y) * mod(Z - Y)); // 1\n        const u2 = mod(X * Y); // 2\n        // Square root always exists\n        const u2sq = mod(u2 * u2);\n        const { value: invsqrt } = invertSqrt(mod(u1 * u2sq)); // 3\n        const D1 = mod(invsqrt * u1); // 4\n        const D2 = mod(invsqrt * u2); // 5\n        const zInv = mod(D1 * D2 * T); // 6\n        let D; // 7\n        if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(T * zInv, P)) {\n            let _x = mod(Y * SQRT_M1);\n            let _y = mod(X * SQRT_M1);\n            X = _x;\n            Y = _y;\n            D = mod(D1 * INVSQRT_A_MINUS_D);\n        } else {\n            D = D2; // 8\n        }\n        if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(X * zInv, P)) Y = mod(-Y); // 9\n        let s = mod((Z - Y) * D); // 10 (check footer's note, no sqrt(-a))\n        if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(s, P)) s = mod(-s);\n        return Fp.toBytes(s); // 11\n    }\n    /**\n     * Compares two Ristretto points.\n     * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-equals).\n     */ equals(other) {\n        this.assertSame(other);\n        const { X: X1, Y: Y1 } = this.ep;\n        const { X: X2, Y: Y2 } = other.ep;\n        const mod = (n)=>Fp.create(n);\n        // (x1 * y2 == y1 * x2) | (y1 * y2 == x1 * x2)\n        const one = mod(X1 * Y2) === mod(Y1 * X2);\n        const two = mod(Y1 * Y2) === mod(X1 * X2);\n        return one || two;\n    }\n    is0() {\n        return this.equals(_RistrettoPoint.ZERO);\n    }\n}\n// Do NOT change syntax: the following gymnastics is done,\n// because typescript strips comments, which makes bundlers disable tree-shaking.\n// prettier-ignore\n_RistrettoPoint.BASE = /* @__PURE__ */ (()=>new _RistrettoPoint(ed25519.Point.BASE))();\n// prettier-ignore\n_RistrettoPoint.ZERO = /* @__PURE__ */ (()=>new _RistrettoPoint(ed25519.Point.ZERO))();\n// prettier-ignore\n_RistrettoPoint.Fp = /* @__PURE__ */ (()=>Fp)();\n// prettier-ignore\n_RistrettoPoint.Fn = /* @__PURE__ */ (()=>Fn)();\nconst ristretto255 = {\n    Point: _RistrettoPoint\n};\n/** Hashing to ristretto255 points / field. RFC 9380 methods. */ const ristretto255_hasher = {\n    hashToCurve (msg, options) {\n        const DST = options?.DST || \"ristretto255_XMD:SHA-512_R255MAP_RO_\";\n        const xmd = (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.expand_message_xmd)(msg, DST, 64, _noble_hashes_sha2_js__WEBPACK_IMPORTED_MODULE_1__.sha512);\n        return ristretto255_map(xmd);\n    },\n    hashToScalar (msg, options = {\n        DST: _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__._DST_scalar\n    }) {\n        const xmd = (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.expand_message_xmd)(msg, options.DST, 64, _noble_hashes_sha2_js__WEBPACK_IMPORTED_MODULE_1__.sha512);\n        return Fn.create((0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.bytesToNumberLE)(xmd));\n    }\n};\n// export const ristretto255_oprf: OPRF = createORPF({\n//   name: 'ristretto255-SHA512',\n//   Point: RistrettoPoint,\n//   hash: sha512,\n//   hashToGroup: ristretto255_hasher.hashToCurve,\n//   hashToScalar: ristretto255_hasher.hashToScalar,\n// });\n/**\n * Weird / bogus points, useful for debugging.\n * All 8 ed25519 points of 8-torsion subgroup can be generated from the point\n * T = `26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05`.\n * T = { O, T, 2T, 3T, 4T, 5T, 6T, 7T }\n */ const ED25519_TORSION_SUBGROUP = [\n    \"0100000000000000000000000000000000000000000000000000000000000000\",\n    \"c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a\",\n    \"0000000000000000000000000000000000000000000000000000000000000080\",\n    \"26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05\",\n    \"ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f\",\n    \"26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85\",\n    \"0000000000000000000000000000000000000000000000000000000000000000\",\n    \"c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa\"\n];\n/** @deprecated use `ed25519.utils.toMontgomery` */ function edwardsToMontgomeryPub(edwardsPub) {\n    return ed25519.utils.toMontgomery((0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.ensureBytes)(\"pub\", edwardsPub));\n}\n/** @deprecated use `ed25519.utils.toMontgomery` */ const edwardsToMontgomery = edwardsToMontgomeryPub;\n/** @deprecated use `ed25519.utils.toMontgomerySecret` */ function edwardsToMontgomeryPriv(edwardsPriv) {\n    return ed25519.utils.toMontgomerySecret((0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.ensureBytes)(\"pub\", edwardsPriv));\n}\n/** @deprecated use `ristretto255.Point` */ const RistrettoPoint = _RistrettoPoint;\n/** @deprecated use `import { ed25519_hasher } from '@noble/curves/ed25519.js';` */ const hashToCurve = /* @__PURE__ */ (()=>ed25519_hasher.hashToCurve)();\n/** @deprecated use `import { ed25519_hasher } from '@noble/curves/ed25519.js';` */ const encodeToCurve = /* @__PURE__ */ (()=>ed25519_hasher.encodeToCurve)();\n/** @deprecated use `import { ristretto255_hasher } from '@noble/curves/ed25519.js';` */ const hashToRistretto255 = /* @__PURE__ */ (()=>ristretto255_hasher.hashToCurve)();\n/** @deprecated use `import { ristretto255_hasher } from '@noble/curves/ed25519.js';` */ const hash_to_ristretto255 = /* @__PURE__ */ (()=>ristretto255_hasher.hashToCurve)(); //# sourceMappingURL=ed25519.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9lZDI1NTE5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Q0FNQyxHQUNELG9FQUFvRSxHQUNyQjtBQUMyQjtBQUMxQjtBQUMyQjtBQUNrQjtBQUNNO0FBQzdDO0FBQ2dCO0FBQ3RFLGtCQUFrQjtBQUNsQixNQUFNb0IsTUFBTSxhQUFhLEdBQUdDLE9BQU8sSUFBSUMsTUFBTUQsT0FBTyxJQUFJRSxNQUFNRixPQUFPLElBQUlHLE1BQU1ILE9BQU87QUFDdEYsa0JBQWtCO0FBQ2xCLE1BQU1JLE1BQU1KLE9BQU8sSUFBSUssTUFBTUwsT0FBTztBQUNwQyxtQkFBbUI7QUFDbkIsTUFBTU0sa0JBQWtCTixPQUFPO0FBQy9CLHlEQUF5RDtBQUN6RCw0QkFBNEI7QUFDNUIsNERBQTREO0FBQzVELE1BQU1PLGdCQUFnQyxhQUFILEdBQUksS0FBTztRQUMxQ0MsR0FBR0Y7UUFDSEcsR0FBR1QsT0FBTztRQUNWVSxHQUFHTDtRQUNITSxHQUFHWCxPQUFPO1FBQ1ZZLEdBQUdaLE9BQU87UUFDVmEsSUFBSWIsT0FBTztRQUNYYyxJQUFJZCxPQUFPO0lBQ2YsRUFBQztBQUNELFNBQVNlLG9CQUFvQkMsQ0FBQztJQUMxQixrQkFBa0I7SUFDbEIsTUFBTUMsT0FBT2pCLE9BQU8sS0FBS2tCLE9BQU9sQixPQUFPLEtBQUttQixPQUFPbkIsT0FBTyxLQUFLb0IsT0FBT3BCLE9BQU87SUFDN0UsTUFBTXFCLElBQUlmO0lBQ1YsTUFBTWdCLEtBQUssSUFBS04sSUFBS0s7SUFDckIsTUFBTUUsS0FBSyxLQUFNUCxJQUFLSyxHQUFHLFVBQVU7SUFDbkMsTUFBTUcsS0FBSywyREFBTUQsSUFBSXJCLEtBQUttQixLQUFLRSxLQUFNRixHQUFHLGFBQWE7SUFDckQsTUFBTUksS0FBSywyREFBTUQsSUFBSXZCLEtBQUtvQixL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O0FBQzFELHVEQUF1RCxHQUNoRCxTQUFTSyx3QkFBd0JDLFdBQVc7SUFDL0MsT0FBT2xLLFFBQVE4SixLQUFLLENBQUNLLGtCQUFrQixDQUFDOU4sc0RBQVdBLENBQUMsT0FBTzZOO0FBQy9EO0FBQ0EseUNBQXlDLEdBQ2xDLE1BQU1FLGlCQUFpQjFELGdCQUFnQjtBQUM5QyxpRkFBaUYsR0FDMUUsTUFBTVEsY0FBOEIsYUFBSCxHQUFJLEtBQU0vQyxlQUFlK0MsV0FBVyxJQUFJO0FBQ2hGLGlGQUFpRixHQUMxRSxNQUFNbUQsZ0JBQWdDLGFBQUgsR0FBSSxLQUFNbEcsZUFBZWtHLGFBQWEsSUFBSTtBQUNwRixzRkFBc0YsR0FDL0UsTUFBTUMscUJBQXFDLGFBQUgsR0FBSSxLQUFNaEIsb0JBQW9CcEMsV0FBVyxJQUFJO0FBQzVGLHNGQUFzRixHQUMvRSxNQUFNcUQsdUJBQXVDLGFBQUgsR0FBSSxLQUFNakIsb0JBQW9CcEMsV0FBVyxJQUFJLENBQzlGLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsYXctd29ya3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9lZDI1NTE5LmpzPzM4MjAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBlZDI1NTE5IFR3aXN0ZWQgRWR3YXJkcyBjdXJ2ZSB3aXRoIGZvbGxvd2luZyBhZGRvbnM6XG4gKiAtIFgyNTUxOSBFQ0RIXG4gKiAtIFJpc3RyZXR0byBjb2ZhY3RvciBlbGltaW5hdGlvblxuICogLSBFbGxpZ2F0b3IgaGFzaC10by1ncm91cCAvIHBvaW50IGluZGlzdGluZ3Vpc2hhYmlsaXR5XG4gKiBAbW9kdWxlXG4gKi9cbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7IHNoYTUxMiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMi5qcyc7XG5pbXBvcnQgeyBhYnl0ZXMsIGNvbmNhdEJ5dGVzLCB1dGY4VG9CeXRlcyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvdXRpbHMuanMnO1xuaW1wb3J0IHsgcGlwcGVuZ2VyIH0gZnJvbSBcIi4vYWJzdHJhY3QvY3VydmUuanNcIjtcbmltcG9ydCB7IFByaW1lRWR3YXJkc1BvaW50LCB0d2lzdGVkRWR3YXJkcywgfSBmcm9tIFwiLi9hYnN0cmFjdC9lZHdhcmRzLmpzXCI7XG5pbXBvcnQgeyBfRFNUX3NjYWxhciwgY3JlYXRlSGFzaGVyLCBleHBhbmRfbWVzc2FnZV94bWQsIH0gZnJvbSBcIi4vYWJzdHJhY3QvaGFzaC10by1jdXJ2ZS5qc1wiO1xuaW1wb3J0IHsgRmllbGQsIEZwSW52ZXJ0QmF0Y2gsIEZwU3FydEV2ZW4sIGlzTmVnYXRpdmVMRSwgbW9kLCBwb3cyLCB9IGZyb20gXCIuL2Fic3RyYWN0L21vZHVsYXIuanNcIjtcbmltcG9ydCB7IG1vbnRnb21lcnkgfSBmcm9tIFwiLi9hYnN0cmFjdC9tb250Z29tZXJ5LmpzXCI7XG5pbXBvcnQgeyBieXRlc1RvTnVtYmVyTEUsIGVuc3VyZUJ5dGVzLCBlcXVhbEJ5dGVzIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzBuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgwKSwgXzFuID0gQmlnSW50KDEpLCBfMm4gPSBCaWdJbnQoMiksIF8zbiA9IEJpZ0ludCgzKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzVuID0gQmlnSW50KDUpLCBfOG4gPSBCaWdJbnQoOCk7XG4vLyBQID0gMm4qKjI1NW4tMTluXG5jb25zdCBlZDI1NTE5X0NVUlZFX3AgPSBCaWdJbnQoJzB4N2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZCcpO1xuLy8gTiA9IDJuKioyNTJuICsgMjc3NDIzMTc3NzczNzIzNTM1MzU4NTE5Mzc3OTA4ODM2NDg0OTNuXG4vLyBhID0gRnAuY3JlYXRlKEJpZ0ludCgtMSkpXG4vLyBkID0gLTEyMTY2NS8xMjE2NjYgYS5rLmEuIEZwLm5lZygxMjE2NjUgKiBGcC5pbnYoMTIxNjY2KSlcbmNvbnN0IGVkMjU1MTlfQ1VSVkUgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+ICh7XG4gICAgcDogZWQyNTUxOV9DVVJWRV9wLFxuICAgIG46IEJpZ0ludCgnMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDE0ZGVmOWRlYTJmNzljZDY1ODEyNjMxYTVjZjVkM2VkJyksXG4gICAgaDogXzhuLFxuICAgIGE6IEJpZ0ludCgnMHg3ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmVjJyksXG4gICAgZDogQmlnSW50KCcweDUyMDM2Y2VlMmI2ZmZlNzM4Y2M3NDA3OTc3NzllODk4MDA3MDBhNGQ0MTQxZDhhYjc1ZWI0ZGNhMTM1OTc4YTMnKSxcbiAgICBHeDogQmlnSW50KCcweDIxNjkzNmQzY2Q2ZTUzZmVjMGE0ZTIzMWZkZDZkYzVjNjkyY2M3NjA5NTI1YTdiMmM5NTYyZDYwOGYyNWQ1MWEnKSxcbiAgICBHeTogQmlnSW50KCcweDY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NTgnKSxcbn0pKSgpO1xuZnVuY3Rpb24gZWQyNTUxOV9wb3dfMl8yNTJfMyh4KSB7XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgY29uc3QgXzEwbiA9IEJpZ0ludCgxMCksIF8yMG4gPSBCaWdJbnQoMjApLCBfNDBuID0gQmlnSW50KDQwKSwgXzgwbiA9IEJpZ0ludCg4MCk7XG4gICAgY29uc3QgUCA9IGVkMjU1MTlfQ1VSVkVfcDtcbiAgICBjb25zdCB4MiA9ICh4ICogeCkgJSBQO1xuICAgIGNvbnN0IGIyID0gKHgyICogeCkgJSBQOyAvLyB4XjMsIDExXG4gICAgY29uc3QgYjQgPSAocG93MihiMiwgXzJuLCBQKSAqIGIyKSAlIFA7IC8vIHheMTUsIDExMTFcbiAgICBjb25zdCBiNSA9IChwb3cyKGI0LCBfMW4sIFApICogeCkgJSBQOyAvLyB4XjMxXG4gICAgY29uc3QgYjEwID0gKHBvdzIoYjUsIF81biwgUCkgKiBiNSkgJSBQO1xuICAgIGNvbnN0IGIyMCA9IChwb3cyKGIxMCwgXzEwbiwgUCkgKiBiMTApICUgUDtcbiAgICBjb25zdCBiNDAgPSAocG93MihiMjAsIF8yMG4sIFApICogYjIwKSAlIFA7XG4gICAgY29uc3QgYjgwID0gKHBvdzIoYjQwLCBfNDBuLCBQKSAqIGI0MCkgJSBQO1xuICAgIGNvbnN0IGIxNjAgPSAocG93MihiODAsIF84MG4sIFApICogYjgwKSAlIFA7XG4gICAgY29uc3QgYjI0MCA9IChwb3cyKGIxNjAsIF84MG4sIFApICogYjgwKSAlIFA7XG4gICAgY29uc3QgYjI1MCA9IChwb3cyKGIyNDAsIF8xMG4sIFApICogYjEwKSAlIFA7XG4gICAgY29uc3QgcG93X3BfNV84ID0gKHBvdzIoYjI1MCwgXzJuLCBQKSAqIHgpICUgUDtcbiAgICAvLyBeIFRvIHBvdyB0byAocCszKS84LCBtdWx0aXBseSBpdCBieSB4LlxuICAgIHJldHVybiB7IHBvd19wXzVfOCwgYjIgfTtcbn1cbmZ1bmN0aW9uIGFkanVzdFNjYWxhckJ5dGVzKGJ5dGVzKSB7XG4gICAgLy8gU2VjdGlvbiA1OiBGb3IgWDI1NTE5LCBpbiBvcmRlciB0byBkZWNvZGUgMzIgcmFuZG9tIGJ5dGVzIGFzIGFuIGludGVnZXIgc2NhbGFyLFxuICAgIC8vIHNldCB0aGUgdGhyZWUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0cyBvZiB0aGUgZmlyc3QgYnl0ZVxuICAgIGJ5dGVzWzBdICY9IDI0ODsgLy8gMGIxMTExXzEwMDBcbiAgICAvLyBhbmQgdGhlIG1vc3Qgc2lnbmlmaWNhbnQgYml0IG9mIHRoZSBsYXN0IHRvIHplcm8sXG4gICAgYnl0ZXNbMzFdICY9IDEyNzsgLy8gMGIwMTExXzExMTFcbiAgICAvLyBzZXQgdGhlIHNlY29uZCBtb3N0IHNpZ25pZmljYW50IGJpdCBvZiB0aGUgbGFzdCBieXRlIHRvIDFcbiAgICBieXRlc1szMV0gfD0gNjQ7IC8vIDBiMDEwMF8wMDAwXG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuLy8g4oiaKC0xKSBha2Eg4oiaKGEpIGFrYSAyXigocC0xKS80KVxuLy8gRnAuc3FydChGcC5uZWcoMSkpXG5jb25zdCBFRDI1NTE5X1NRUlRfTTEgPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KCcxOTY4MTE2MTM3NjcwNzUwNTk1NjgwNzA3OTMwNDk4ODU0MjAxNTQ0NjA2NjUxNTkyMzg5MDE2Mjc0NDAyMTA3MzEyMzgyOTc4NDc1MicpO1xuLy8gc3FydCh1L3YpXG5mdW5jdGlvbiB1dlJhdGlvKHUsIHYpIHtcbiAgICBjb25zdCBQID0gZWQyNTUxOV9DVVJWRV9wO1xuICAgIGNvbnN0IHYzID0gbW9kKHYgKiB2ICogdiwgUCk7IC8vIHbCs1xuICAgIGNvbnN0IHY3ID0gbW9kKHYzICogdjMgKiB2LCBQKTsgLy8gduKBt1xuICAgIC8vIChwKzMpLzggYW5kIChwLTUpLzhcbiAgICBjb25zdCBwb3cgPSBlZDI1NTE5X3Bvd18yXzI1Ml8zKHUgKiB2NykucG93X3BfNV84O1xuICAgIGxldCB4ID0gbW9kKHUgKiB2MyAqIHBvdywgUCk7IC8vICh1dsKzKSh1duKBtyleKHAtNSkvOFxuICAgIGNvbnN0IHZ4MiA9IG1vZCh2ICogeCAqIHgsIFApOyAvLyB2eMKyXG4gICAgY29uc3Qgcm9vdDEgPSB4OyAvLyBGaXJzdCByb290IGNhbmRpZGF0ZVxuICAgIGNvbnN0IHJvb3QyID0gbW9kKHggKiBFRDI1NTE5X1NRUlRfTTEsIFApOyAvLyBTZWNvbmQgcm9vdCBjYW5kaWRhdGVcbiAgICBjb25zdCB1c2VSb290MSA9IHZ4MiA9PT0gdTsgLy8gSWYgdnjCsiA9IHUgKG1vZCBwKSwgeCBpcyBhIHNxdWFyZSByb290XG4gICAgY29uc3QgdXNlUm9vdDIgPSB2eDIgPT09IG1vZCgtdSwgUCk7IC8vIElmIHZ4wrIgPSAtdSwgc2V0IHggPC0tIHggKiAyXigocC0xKS80KVxuICAgIGNvbnN0IG5vUm9vdCA9IHZ4MiA9PT0gbW9kKC11ICogRUQyNTUxOV9TUVJUX00xLCBQKTsgLy8gVGhlcmUgaXMgbm8gdmFsaWQgcm9vdCwgdnjCsiA9IC114oiaKC0xKVxuICAgIGlmICh1c2VSb290MSlcbiAgICAgICAgeCA9IHJvb3QxO1xuICAgIGlmICh1c2VSb290MiB8fCBub1Jvb3QpXG4gICAgICAgIHggPSByb290MjsgLy8gV2UgcmV0dXJuIHJvb3QyIGFueXdheSwgZm9yIGNvbnN0LXRpbWVcbiAgICBpZiAoaXNOZWdhdGl2ZUxFKHgsIFApKVxuICAgICAgICB4ID0gbW9kKC14LCBQKTtcbiAgICByZXR1cm4geyBpc1ZhbGlkOiB1c2VSb290MSB8fCB1c2VSb290MiwgdmFsdWU6IHggfTtcbn1cbmNvbnN0IEZwID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBGaWVsZChlZDI1NTE5X0NVUlZFLnAsIHsgaXNMRTogdHJ1ZSB9KSkoKTtcbmNvbnN0IEZuID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBGaWVsZChlZDI1NTE5X0NVUlZFLm4sIHsgaXNMRTogdHJ1ZSB9KSkoKTtcbmNvbnN0IGVkMjU1MTlEZWZhdWx0cyA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gKHtcbiAgICAuLi5lZDI1NTE5X0NVUlZFLFxuICAgIEZwLFxuICAgIGhhc2g6IHNoYTUxMixcbiAgICBhZGp1c3RTY2FsYXJCeXRlcyxcbiAgICAvLyBkb20yXG4gICAgLy8gUmF0aW8gb2YgdSB0byB2LiBBbGxvd3MgdXMgdG8gY29tYmluZSBpbnZlcnNpb24gYW5kIHNxdWFyZSByb290LiBVc2VzIGFsZ28gZnJvbSBSRkM4MDMyIDUuMS4zLlxuICAgIC8vIENvbnN0YW50LXRpbWUsIHUv4oiadlxuICAgIHV2UmF0aW8sXG59KSkoKTtcbi8qKlxuICogZWQyNTUxOSBjdXJ2ZSB3aXRoIEVkRFNBIHNpZ25hdHVyZXMuXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgZWQyNTUxOSB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvZWQyNTUxOSc7XG4gKiBjb25zdCB7IHNlY3JldEtleSwgcHVibGljS2V5IH0gPSBlZDI1NTE5LmtleWdlbigpO1xuICogY29uc3QgbXNnID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKCdoZWxsbycpO1xuICogY29uc3Qgc2lnID0gZWQyNTUxOS5zaWduKG1zZywgcHJpdik7XG4gKiBlZDI1NTE5LnZlcmlmeShzaWcsIG1zZywgcHViKTsgLy8gRGVmYXVsdCBtb2RlOiBmb2xsb3dzIFpJUDIxNVxuICogZWQyNTUxOS52ZXJpZnkoc2lnLCBtc2csIHB1YiwgeyB6aXAyMTU6IGZhbHNlIH0pOyAvLyBSRkM4MDMyIC8gRklQUyAxODYtNVxuICovXG5leHBvcnQgY29uc3QgZWQyNTUxOSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gdHdpc3RlZEVkd2FyZHMoZWQyNTUxOURlZmF1bHRzKSkoKTtcbmZ1bmN0aW9uIGVkMjU1MTlfZG9tYWluKGRhdGEsIGN0eCwgcGhmbGFnKSB7XG4gICAgaWYgKGN0eC5sZW5ndGggPiAyNTUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ29udGV4dCBpcyB0b28gYmlnJyk7XG4gICAgcmV0dXJuIGNvbmNhdEJ5dGVzKHV0ZjhUb0J5dGVzKCdTaWdFZDI1NTE5IG5vIEVkMjU1MTkgY29sbGlzaW9ucycpLCBuZXcgVWludDhBcnJheShbcGhmbGFnID8gMSA6IDAsIGN0eC5sZW5ndGhdKSwgY3R4LCBkYXRhKTtcbn1cbi8qKiBDb250ZXh0IG9mIGVkMjU1MTkuIFVzZXMgY29udGV4dCBmb3IgZG9tYWluIHNlcGFyYXRpb24uICovXG5leHBvcnQgY29uc3QgZWQyNTUxOWN0eCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gdHdpc3RlZEVkd2FyZHMoe1xuICAgIC4uLmVkMjU1MTlEZWZhdWx0cyxcbiAgICBkb21haW46IGVkMjU1MTlfZG9tYWluLFxufSkpKCk7XG4vKiogUHJlaGFzaGVkIHZlcnNpb24gb2YgZWQyNTUxOS4gQWNjZXB0cyBhbHJlYWR5LWhhc2hlZCBtZXNzYWdlcyBpbiBzaWduKCkgYW5kIHZlcmlmeSgpLiAqL1xuZXhwb3J0IGNvbnN0IGVkMjU1MTlwaCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gdHdpc3RlZEVkd2FyZHMoT2JqZWN0LmFzc2lnbih7fSwgZWQyNTUxOURlZmF1bHRzLCB7XG4gICAgZG9tYWluOiBlZDI1NTE5X2RvbWFpbixcbiAgICBwcmVoYXNoOiBzaGE1MTIsXG59KSkpKCk7XG4vKipcbiAqIEVDREggdXNpbmcgY3VydmUyNTUxOSBha2EgeDI1NTE5LlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IHgyNTUxOSB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvZWQyNTUxOSc7XG4gKiBjb25zdCBwcml2ID0gJ2E1NDZlMzZiZjA1MjdjOWQzYjE2MTU0YjgyNDY1ZWRkNjIxNDRjMGFjMWZjNWExODUwNmEyMjQ0YmE0NDlhYzQnO1xuICogY29uc3QgcHViID0gJ2U2ZGI2ODY3NTgzMDMwZGIzNTk0YzFhNDI0YjE1ZjdjNzI2NjI0ZWMyNmIzMzUzYjEwYTkwM2E2ZDBhYjFjNGMnO1xuICogeDI1NTE5LmdldFNoYXJlZFNlY3JldChwcml2LCBwdWIpID09PSB4MjU1MTkuc2NhbGFyTXVsdChwcml2LCBwdWIpOyAvLyBhbGlhc2VzXG4gKiB4MjU1MTkuZ2V0UHVibGljS2V5KHByaXYpID09PSB4MjU1MTkuc2NhbGFyTXVsdEJhc2UocHJpdik7XG4gKiB4MjU1MTkuZ2V0UHVibGljS2V5KHgyNTUxOS51dGlscy5yYW5kb21TZWNyZXRLZXkoKSk7XG4gKi9cbmV4cG9ydCBjb25zdCB4MjU1MTkgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHtcbiAgICBjb25zdCBQID0gRnAuT1JERVI7XG4gICAgcmV0dXJuIG1vbnRnb21lcnkoe1xuICAgICAgICBQLFxuICAgICAgICB0eXBlOiAneDI1NTE5JyxcbiAgICAgICAgcG93UG1pbnVzMjogKHgpID0+IHtcbiAgICAgICAgICAgIC8vIHheKHAtMikgYWthIHheKDJeMjU1LTIxKVxuICAgICAgICAgICAgY29uc3QgeyBwb3dfcF81XzgsIGIyIH0gPSBlZDI1NTE5X3Bvd18yXzI1Ml8zKHgpO1xuICAgICAgICAgICAgcmV0dXJuIG1vZChwb3cyKHBvd19wXzVfOCwgXzNuLCBQKSAqIGIyLCBQKTtcbiAgICAgICAgfSxcbiAgICAgICAgYWRqdXN0U2NhbGFyQnl0ZXMsXG4gICAgfSk7XG59KSgpO1xuLy8gSGFzaCBUbyBDdXJ2ZSBFbGxpZ2F0b3IyIE1hcCAoTk9URTogZGlmZmVyZW50IGZyb20gcmlzdHJldHRvMjU1IGVsbGlnYXRvcilcbi8vIE5PVEU6IHZlcnkgaW1wb3J0YW50IHBhcnQgaXMgdXNhZ2Ugb2YgRnBTcXJ0RXZlbiBmb3IgRUxMMl9DMV9FRFdBUkRTLCBzaW5jZVxuLy8gU2FnZU1hdGggcmV0dXJucyBkaWZmZXJlbnQgcm9vdCBmaXJzdCBhbmQgZXZlcnl0aGluZyBmYWxscyBhcGFydFxuY29uc3QgRUxMMl9DMSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gKGVkMjU1MTlfQ1VSVkVfcCArIF8zbikgLyBfOG4pKCk7IC8vIDEuIGMxID0gKHEgKyAzKSAvIDggICAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbmNvbnN0IEVMTDJfQzIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IEZwLnBvdyhfMm4sIEVMTDJfQzEpKSgpOyAvLyAyLiBjMiA9IDJeYzFcbmNvbnN0IEVMTDJfQzMgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IEZwLnNxcnQoRnAubmVnKEZwLk9ORSkpKSgpOyAvLyAzLiBjMyA9IHNxcnQoLTEpXG4vLyBwcmV0dGllci1pZ25vcmVcbmZ1bmN0aW9uIG1hcF90b19jdXJ2ZV9lbGxpZ2F0b3IyX2N1cnZlMjU1MTkodSkge1xuICAgIGNvbnN0IEVMTDJfQzQgPSAoZWQyNTUxOV9DVVJWRV9wIC0gXzVuKSAvIF84bjsgLy8gNC4gYzQgPSAocSAtIDUpIC8gOCAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IEVMTDJfSiA9IEJpZ0ludCg0ODY2NjIpO1xuICAgIGxldCB0djEgPSBGcC5zcXIodSk7IC8vICAxLiAgdHYxID0gdV4yXG4gICAgdHYxID0gRnAubXVsKHR2MSwgXzJuKTsgLy8gIDIuICB0djEgPSAyICogdHYxXG4gICAgbGV0IHhkID0gRnAuYWRkKHR2MSwgRnAuT05FKTsgLy8gIDMuICAgeGQgPSB0djEgKyAxICAgICAgICAgIyBOb256ZXJvOiAtMSBpcyBzcXVhcmUgKG1vZCBwKSwgdHYxIGlzIG5vdFxuICAgIGxldCB4MW4gPSBGcC5uZWcoRUxMMl9KKTsgLy8gIDQuICB4MW4gPSAtSiAgICAgICAgICAgICAgIyB4MSA9IHgxbiAvIHhkID0gLUogLyAoMSArIDIgKiB1XjIpXG4gICAgbGV0IHR2MiA9IEZwLnNxcih4ZCk7IC8vICA1LiAgdHYyID0geGReMlxuICAgIGxldCBneGQgPSBGcC5tdWwodHYyLCB4ZCk7IC8vICA2LiAgZ3hkID0gdHYyICogeGQgICAgICAgICMgZ3hkID0geGReM1xuICAgIGxldCBneDEgPSBGcC5tdWwodHYxLCBFTEwyX0opOyAvLyAgNy4gIGd4MSA9IEogKiB0djEgICAgICAgICAjIHgxbiArIEogKiB4ZFxuICAgIGd4MSA9IEZwLm11bChneDEsIHgxbik7IC8vICA4LiAgZ3gxID0gZ3gxICogeDFuICAgICAgICMgeDFuXjIgKyBKICogeDFuICogeGRcbiAgICBneDEgPSBGcC5hZGQoZ3gxLCB0djIpOyAvLyAgOS4gIGd4MSA9IGd4MSArIHR2MiAgICAgICAjIHgxbl4yICsgSiAqIHgxbiAqIHhkICsgeGReMlxuICAgIGd4MSA9IEZwLm11bChneDEsIHgxbik7IC8vICAxMC4gZ3gxID0gZ3gxICogeDFuICAgICAgICMgeDFuXjMgKyBKICogeDFuXjIgKiB4ZCArIHgxbiAqIHhkXjJcbiAgICBsZXQgdHYzID0gRnAuc3FyKGd4ZCk7IC8vICAxMS4gdHYzID0gZ3hkXjJcbiAgICB0djIgPSBGcC5zcXIodHYzKTsgLy8gIDEyLiB0djIgPSB0djNeMiAgICAgICAgICAgIyBneGReNFxuICAgIHR2MyA9IEZwLm11bCh0djMsIGd4ZCk7IC8vICAxMy4gdHYzID0gdHYzICogZ3hkICAgICAgICMgZ3hkXjNcbiAgICB0djMgPSBGcC5tdWwodHYzLCBneDEpOyAvLyAgMTQuIHR2MyA9IHR2MyAqIGd4MSAgICAgICAjIGd4MSAqIGd4ZF4zXG4gICAgdHYyID0gRnAubXVsKHR2MiwgdHYzKTsgLy8gIDE1LiB0djIgPSB0djIgKiB0djMgICAgICAgIyBneDEgKiBneGReN1xuICAgIGxldCB5MTEgPSBGcC5wb3codHYyLCBFTEwyX0M0KTsgLy8gIDE2LiB5MTEgPSB0djJeYzQgICAgICAgICMgKGd4MSAqIGd4ZF43KV4oKHAgLSA1KSAvIDgpXG4gICAgeTExID0gRnAubXVsKHkxMSwgdHYzKTsgLy8gIDE3LiB5MTEgPSB5MTEgKiB0djMgICAgICAgIyBneDEqZ3hkXjMqKGd4MSpneGReNyleKChwLTUpLzgpXG4gICAgbGV0IHkxMiA9IEZwLm11bCh5MTEsIEVMTDJfQzMpOyAvLyAgMTguIHkxMiA9IHkxMSAqIGMzXG4gICAgdHYyID0gRnAuc3FyKHkxMSk7IC8vICAxOS4gdHYyID0geTExXjJcbiAgICB0djIgPSBGcC5tdWwodHYyLCBneGQpOyAvLyAgMjAuIHR2MiA9IHR2MiAqIGd4ZFxuICAgIGxldCBlMSA9IEZwLmVxbCh0djIsIGd4MSk7IC8vICAyMS4gIGUxID0gdHYyID09IGd4MVxuICAgIGxldCB5MSA9IEZwLmNtb3YoeTEyLCB5MTEsIGUxKTsgLy8gIDIyLiAgeTEgPSBDTU9WKHkxMiwgeTExLCBlMSkgICMgSWYgZyh4MSkgaXMgc3F1YXJlLCB0aGlzIGlzIGl0cyBzcXJ0XG4gICAgbGV0IHgybiA9IEZwLm11bCh4MW4sIHR2MSk7IC8vICAyMy4geDJuID0geDFuICogdHYxICAgICAgICMgeDIgPSB4Mm4gLyB4ZCA9IDIgKiB1XjIgKiB4MW4gLyB4ZFxuICAgIGxldCB5MjEgPSBGcC5tdWwoeTExLCB1KTsgLy8gIDI0LiB5MjEgPSB5MTEgKiB1XG4gICAgeTIxID0gRnAubXVsKHkyMSwgRUxMMl9DMik7IC8vICAyNS4geTIxID0geTIxICogYzJcbiAgICBsZXQgeTIyID0gRnAubXVsKHkyMSwgRUxMMl9DMyk7IC8vICAyNi4geTIyID0geTIxICogYzNcbiAgICBsZXQgZ3gyID0gRnAubXVsKGd4MSwgdHYxKTsgLy8gIDI3LiBneDIgPSBneDEgKiB0djEgICAgICAgIyBnKHgyKSA9IGd4MiAvIGd4ZCA9IDIgKiB1XjIgKiBnKHgxKVxuICAgIHR2MiA9IEZwLnNxcih5MjEpOyAvLyAgMjguIHR2MiA9IHkyMV4yXG4gICAgdHYyID0gRnAubXVsKHR2MiwgZ3hkKTsgLy8gIDI5LiB0djIgPSB0djIgKiBneGRcbiAgICBsZXQgZTIgPSBGcC5lcWwodHYyLCBneDIpOyAvLyAgMzAuICBlMiA9IHR2MiA9PSBneDJcbiAgICBsZXQgeTIgPSBGcC5jbW92KHkyMiwgeTIxLCBlMik7IC8vICAzMS4gIHkyID0gQ01PVih5MjIsIHkyMSwgZTIpICAjIElmIGcoeDIpIGlzIHNxdWFyZSwgdGhpcyBpcyBpdHMgc3FydFxuICAgIHR2MiA9IEZwLnNxcih5MSk7IC8vICAzMi4gdHYyID0geTFeMlxuICAgIHR2MiA9IEZwLm11bCh0djIsIGd4ZCk7IC8vICAzMy4gdHYyID0gdHYyICogZ3hkXG4gICAgbGV0IGUzID0gRnAuZXFsKHR2MiwgZ3gxKTsgLy8gIDM0LiAgZTMgPSB0djIgPT0gZ3gxXG4gICAgbGV0IHhuID0gRnAuY21vdih4Mm4sIHgxbiwgZTMpOyAvLyAgMzUuICB4biA9IENNT1YoeDJuLCB4MW4sIGUzKSAgIyBJZiBlMywgeCA9IHgxLCBlbHNlIHggPSB4MlxuICAgIGxldCB5ID0gRnAuY21vdih5MiwgeTEsIGUzKTsgLy8gIDM2LiAgIHkgPSBDTU9WKHkyLCB5MSwgZTMpICAgICMgSWYgZTMsIHkgPSB5MSwgZWxzZSB5ID0geTJcbiAgICBsZXQgZTQgPSBGcC5pc09kZCh5KTsgLy8gIDM3LiAgZTQgPSBzZ24wKHkpID09IDEgICAgICAgICMgRml4IHNpZ24gb2YgeVxuICAgIHkgPSBGcC5jbW92KHksIEZwLm5lZyh5KSwgZTMgIT09IGU0KTsgLy8gIDM4LiAgIHkgPSBDTU9WKHksIC15LCBlMyBYT1IgZTQpXG4gICAgcmV0dXJuIHsgeE1uOiB4biwgeE1kOiB4ZCwgeU1uOiB5LCB5TWQ6IF8xbiB9OyAvLyAgMzkuIHJldHVybiAoeG4sIHhkLCB5LCAxKVxufVxuY29uc3QgRUxMMl9DMV9FRFdBUkRTID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBGcFNxcnRFdmVuKEZwLCBGcC5uZWcoQmlnSW50KDQ4NjY2NCkpKSkoKTsgLy8gc2duMChjMSkgTVVTVCBlcXVhbCAwXG5mdW5jdGlvbiBtYXBfdG9fY3VydmVfZWxsaWdhdG9yMl9lZHdhcmRzMjU1MTkodSkge1xuICAgIGNvbnN0IHsgeE1uLCB4TWQsIHlNbiwgeU1kIH0gPSBtYXBfdG9fY3VydmVfZWxsaWdhdG9yMl9jdXJ2ZTI1NTE5KHUpOyAvLyAgMS4gICh4TW4sIHhNZCwgeU1uLCB5TWQpID1cbiAgICAvLyBtYXBfdG9fY3VydmVfZWxsaWdhdG9yMl9jdXJ2ZTI1NTE5KHUpXG4gICAgbGV0IHhuID0gRnAubXVsKHhNbiwgeU1kKTsgLy8gIDIuICB4biA9IHhNbiAqIHlNZFxuICAgIHhuID0gRnAubXVsKHhuLCBFTEwyX0MxX0VEV0FSRFMpOyAvLyAgMy4gIHhuID0geG4gKiBjMVxuICAgIGxldCB4ZCA9IEZwLm11bCh4TWQsIHlNbik7IC8vICA0LiAgeGQgPSB4TWQgKiB5TW4gICAgIyB4biAvIHhkID0gYzEgKiB4TSAvIHlNXG4gICAgbGV0IHluID0gRnAuc3ViKHhNbiwgeE1kKTsgLy8gIDUuICB5biA9IHhNbiAtIHhNZFxuICAgIGxldCB5ZCA9IEZwLmFkZCh4TW4sIHhNZCk7IC8vICA2LiAgeWQgPSB4TW4gKyB4TWQgICAgIyAobiAvIGQgLSAxKSAvIChuIC8gZCArIDEpID0gKG4gLSBkKSAvIChuICsgZClcbiAgICBsZXQgdHYxID0gRnAubXVsKHhkLCB5ZCk7IC8vICA3LiB0djEgPSB4ZCAqIHlkXG4gICAgbGV0IGUgPSBGcC5lcWwodHYxLCBGcC5aRVJPKTsgLy8gIDguICAgZSA9IHR2MSA9PSAwXG4gICAgeG4gPSBGcC5jbW92KHhuLCBGcC5aRVJPLCBlKTsgLy8gIDkuICB4biA9IENNT1YoeG4sIDAsIGUpXG4gICAgeGQgPSBGcC5jbW92KHhkLCBGcC5PTkUsIGUpOyAvLyAgMTAuIHhkID0gQ01PVih4ZCwgMSwgZSlcbiAgICB5biA9IEZwLmNtb3YoeW4sIEZwLk9ORSwgZSk7IC8vICAxMS4geW4gPSBDTU9WKHluLCAxLCBlKVxuICAgIHlkID0gRnAuY21vdih5ZCwgRnAuT05FLCBlKTsgLy8gIDEyLiB5ZCA9IENNT1YoeWQsIDEsIGUpXG4gICAgY29uc3QgW3hkX2ludiwgeWRfaW52XSA9IEZwSW52ZXJ0QmF0Y2goRnAsIFt4ZCwgeWRdLCB0cnVlKTsgLy8gYmF0Y2ggZGl2aXNpb25cbiAgICByZXR1cm4geyB4OiBGcC5tdWwoeG4sIHhkX2ludiksIHk6IEZwLm11bCh5biwgeWRfaW52KSB9OyAvLyAgMTMuIHJldHVybiAoeG4sIHhkLCB5biwgeWQpXG59XG4vKiogSGFzaGluZyB0byBlZDI1NTE5IHBvaW50cyAvIGZpZWxkLiBSRkMgOTM4MCBtZXRob2RzLiAqL1xuZXhwb3J0IGNvbnN0IGVkMjU1MTlfaGFzaGVyID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBjcmVhdGVIYXNoZXIoZWQyNTUxOS5Qb2ludCwgKHNjYWxhcnMpID0+IG1hcF90b19jdXJ2ZV9lbGxpZ2F0b3IyX2Vkd2FyZHMyNTUxOShzY2FsYXJzWzBdKSwge1xuICAgIERTVDogJ2Vkd2FyZHMyNTUxOV9YTUQ6U0hBLTUxMl9FTEwyX1JPXycsXG4gICAgZW5jb2RlRFNUOiAnZWR3YXJkczI1NTE5X1hNRDpTSEEtNTEyX0VMTDJfTlVfJyxcbiAgICBwOiBlZDI1NTE5X0NVUlZFX3AsXG4gICAgbTogMSxcbiAgICBrOiAxMjgsXG4gICAgZXhwYW5kOiAneG1kJyxcbiAgICBoYXNoOiBzaGE1MTIsXG59KSkoKTtcbi8vIOKImigtMSkgYWthIOKImihhKSBha2EgMl4oKHAtMSkvNClcbmNvbnN0IFNRUlRfTTEgPSBFRDI1NTE5X1NRUlRfTTE7XG4vLyDiiJooYWQgLSAxKVxuY29uc3QgU1FSVF9BRF9NSU5VU19PTkUgPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KCcyNTA2MzA2ODk1MzM4NDYyMzQ3NDExMTQxNDE1ODcwMjE1MjcwMTI0NDUzMTUwMjQ5MjY1NjQ2MDA3OTIxMDQ4MjYxMDQzMDc1MDIzNScpO1xuLy8gMSAvIOKImihhLWQpXG5jb25zdCBJTlZTUVJUX0FfTUlOVVNfRCA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoJzU0NDY5MzA3MDA4OTA5MzE2OTIwOTk1ODEzODY4NzQ1MTQxNjA1MzkzNTk3MjkyOTI3NDU2OTIxMjA1MzEyODk2MzExNzIxMDE3NTc4Jyk7XG4vLyAxLWTCslxuY29uc3QgT05FX01JTlVTX0RfU1EgPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KCcxMTU5ODQzMDIxNjY4Nzc5ODc5MTkzNzc1NTIxODU1NTg2NjQ3OTM3MzU3NzU5NzE1NDE3NjU0NDM5ODc5NzIwODc2MTExODA2ODM4Jyk7XG4vLyAoZC0xKcKyXG5jb25zdCBEX01JTlVTX09ORV9TUSA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoJzQwNDQwODM0MzQ2MzA4NTM2ODU4MTAxMDQyNDY5MzIzMTkwODI2MjQ4Mzk5MTQ2MjM4NzA4MzUyMjQwMTMzMjIwODY1MTM3MjY1OTUyJyk7XG4vLyBDYWxjdWxhdGVzIDEv4oiaKG51bWJlcilcbmNvbnN0IGludmVydFNxcnQgPSAobnVtYmVyKSA9PiB1dlJhdGlvKF8xbiwgbnVtYmVyKTtcbmNvbnN0IE1BWF8yNTVCID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgnMHg3ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmJyk7XG5jb25zdCBieXRlczI1NVRvTnVtYmVyTEUgPSAoYnl0ZXMpID0+IGVkMjU1MTkuUG9pbnQuRnAuY3JlYXRlKGJ5dGVzVG9OdW1iZXJMRShieXRlcykgJiBNQVhfMjU1Qik7XG4vKipcbiAqIENvbXB1dGVzIEVsbGlnYXRvciBtYXAgZm9yIFJpc3RyZXR0bzI1NS5cbiAqIERlc2NyaWJlZCBpbiBbUkZDOTM4MF0oaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjYXBwZW5kaXgtQikgYW5kIG9uXG4gKiB0aGUgW3dlYnNpdGVdKGh0dHBzOi8vcmlzdHJldHRvLmdyb3VwL2Zvcm11bGFzL2VsbGlnYXRvci5odG1sKS5cbiAqL1xuZnVuY3Rpb24gY2FsY0VsbGlnYXRvclJpc3RyZXR0b01hcChyMCkge1xuICAgIGNvbnN0IHsgZCB9ID0gZWQyNTUxOV9DVVJWRTtcbiAgICBjb25zdCBQID0gZWQyNTUxOV9DVVJWRV9wO1xuICAgIGNvbnN0IG1vZCA9IChuKSA9PiBGcC5jcmVhdGUobik7XG4gICAgY29uc3QgciA9IG1vZChTUVJUX00xICogcjAgKiByMCk7IC8vIDFcbiAgICBjb25zdCBOcyA9IG1vZCgociArIF8xbikgKiBPTkVfTUlOVVNfRF9TUSk7IC8vIDJcbiAgICBsZXQgYyA9IEJpZ0ludCgtMSk7IC8vIDNcbiAgICBjb25zdCBEID0gbW9kKChjIC0gZCAqIHIpICogbW9kKHIgKyBkKSk7IC8vIDRcbiAgICBsZXQgeyBpc1ZhbGlkOiBOc19EX2lzX3NxLCB2YWx1ZTogcyB9ID0gdXZSYXRpbyhOcywgRCk7IC8vIDVcbiAgICBsZXQgc18gPSBtb2QocyAqIHIwKTsgLy8gNlxuICAgIGlmICghaXNOZWdhdGl2ZUxFKHNfLCBQKSlcbiAgICAgICAgc18gPSBtb2QoLXNfKTtcbiAgICBpZiAoIU5zX0RfaXNfc3EpXG4gICAgICAgIHMgPSBzXzsgLy8gN1xuICAgIGlmICghTnNfRF9pc19zcSlcbiAgICAgICAgYyA9IHI7IC8vIDhcbiAgICBjb25zdCBOdCA9IG1vZChjICogKHIgLSBfMW4pICogRF9NSU5VU19PTkVfU1EgLSBEKTsgLy8gOVxuICAgIGNvbnN0IHMyID0gcyAqIHM7XG4gICAgY29uc3QgVzAgPSBtb2QoKHMgKyBzKSAqIEQpOyAvLyAxMFxuICAgIGNvbnN0IFcxID0gbW9kKE50ICogU1FSVF9BRF9NSU5VU19PTkUpOyAvLyAxMVxuICAgIGNvbnN0IFcyID0gbW9kKF8xbiAtIHMyKTsgLy8gMTJcbiAgICBjb25zdCBXMyA9IG1vZChfMW4gKyBzMik7IC8vIDEzXG4gICAgcmV0dXJuIG5ldyBlZDI1NTE5LlBvaW50KG1vZChXMCAqIFczKSwgbW9kKFcyICogVzEpLCBtb2QoVzEgKiBXMyksIG1vZChXMCAqIFcyKSk7XG59XG5mdW5jdGlvbiByaXN0cmV0dG8yNTVfbWFwKGJ5dGVzKSB7XG4gICAgYWJ5dGVzKGJ5dGVzLCA2NCk7XG4gICAgY29uc3QgcjEgPSBieXRlczI1NVRvTnVtYmVyTEUoYnl0ZXMuc3ViYXJyYXkoMCwgMzIpKTtcbiAgICBjb25zdCBSMSA9IGNhbGNFbGxpZ2F0b3JSaXN0cmV0dG9NYXAocjEpO1xuICAgIGNvbnN0IHIyID0gYnl0ZXMyNTVUb051bWJlckxFKGJ5dGVzLnN1YmFycmF5KDMyLCA2NCkpO1xuICAgIGNvbnN0IFIyID0gY2FsY0VsbGlnYXRvclJpc3RyZXR0b01hcChyMik7XG4gICAgcmV0dXJuIG5ldyBfUmlzdHJldHRvUG9pbnQoUjEuYWRkKFIyKSk7XG59XG4vKipcbiAqIFdyYXBwZXIgb3ZlciBFZHdhcmRzIFBvaW50IGZvciByaXN0cmV0dG8yNTUuXG4gKlxuICogRWFjaCBlZDI1NTE5L0V4dGVuZGVkUG9pbnQgaGFzIDggZGlmZmVyZW50IGVxdWl2YWxlbnQgcG9pbnRzLiBUaGlzIGNhbiBiZVxuICogYSBzb3VyY2Ugb2YgYnVncyBmb3IgcHJvdG9jb2xzIGxpa2UgcmluZyBzaWduYXR1cmVzLiBSaXN0cmV0dG8gd2FzIGNyZWF0ZWQgdG8gc29sdmUgdGhpcy5cbiAqIFJpc3RyZXR0byBwb2ludCBvcGVyYXRlcyBpbiBYOlk6WjpUIGV4dGVuZGVkIGNvb3JkaW5hdGVzIGxpa2UgRXh0ZW5kZWRQb2ludCxcbiAqIGJ1dCBpdCBzaG91bGQgd29yayBpbiBpdHMgb3duIG5hbWVzcGFjZTogZG8gbm90IGNvbWJpbmUgdGhvc2UgdHdvLlxuICogU2VlIFtSRkM5NDk2XShodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTQ5NikuXG4gKi9cbmNsYXNzIF9SaXN0cmV0dG9Qb2ludCBleHRlbmRzIFByaW1lRWR3YXJkc1BvaW50IHtcbiAgICBjb25zdHJ1Y3RvcihlcCkge1xuICAgICAgICBzdXBlcihlcCk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQWZmaW5lKGFwKSB7XG4gICAgICAgIHJldHVybiBuZXcgX1Jpc3RyZXR0b1BvaW50KGVkMjU1MTkuUG9pbnQuZnJvbUFmZmluZShhcCkpO1xuICAgIH1cbiAgICBhc3NlcnRTYW1lKG90aGVyKSB7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgX1Jpc3RyZXR0b1BvaW50KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmlzdHJldHRvUG9pbnQgZXhwZWN0ZWQnKTtcbiAgICB9XG4gICAgaW5pdChlcCkge1xuICAgICAgICByZXR1cm4gbmV3IF9SaXN0cmV0dG9Qb2ludChlcCk7XG4gICAgfVxuICAgIC8qKiBAZGVwcmVjYXRlZCB1c2UgYGltcG9ydCB7IHJpc3RyZXR0bzI1NV9oYXNoZXIgfSBmcm9tICdAbm9ibGUvY3VydmVzL2VkMjU1MTkuanMnO2AgKi9cbiAgICBzdGF0aWMgaGFzaFRvQ3VydmUoaGV4KSB7XG4gICAgICAgIHJldHVybiByaXN0cmV0dG8yNTVfbWFwKGVuc3VyZUJ5dGVzKCdyaXN0cmV0dG9IYXNoJywgaGV4LCA2NCkpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUJ5dGVzKGJ5dGVzKSB7XG4gICAgICAgIGFieXRlcyhieXRlcywgMzIpO1xuICAgICAgICBjb25zdCB7IGEsIGQgfSA9IGVkMjU1MTlfQ1VSVkU7XG4gICAgICAgIGNvbnN0IFAgPSBlZDI1NTE5X0NVUlZFX3A7XG4gICAgICAgIGNvbnN0IG1vZCA9IChuKSA9PiBGcC5jcmVhdGUobik7XG4gICAgICAgIGNvbnN0IHMgPSBieXRlczI1NVRvTnVtYmVyTEUoYnl0ZXMpO1xuICAgICAgICAvLyAxLiBDaGVjayB0aGF0IHNfYnl0ZXMgaXMgdGhlIGNhbm9uaWNhbCBlbmNvZGluZyBvZiBhIGZpZWxkIGVsZW1lbnQsIG9yIGVsc2UgYWJvcnQuXG4gICAgICAgIC8vIDMuIENoZWNrIHRoYXQgcyBpcyBub24tbmVnYXRpdmUsIG9yIGVsc2UgYWJvcnRcbiAgICAgICAgaWYgKCFlcXVhbEJ5dGVzKEZwLnRvQnl0ZXMocyksIGJ5dGVzKSB8fCBpc05lZ2F0aXZlTEUocywgUCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcmlzdHJldHRvMjU1IGVuY29kaW5nIDEnKTtcbiAgICAgICAgY29uc3QgczIgPSBtb2QocyAqIHMpO1xuICAgICAgICBjb25zdCB1MSA9IG1vZChfMW4gKyBhICogczIpOyAvLyA0IChhIGlzIC0xKVxuICAgICAgICBjb25zdCB1MiA9IG1vZChfMW4gLSBhICogczIpOyAvLyA1XG4gICAgICAgIGNvbnN0IHUxXzIgPSBtb2QodTEgKiB1MSk7XG4gICAgICAgIGNvbnN0IHUyXzIgPSBtb2QodTIgKiB1Mik7XG4gICAgICAgIGNvbnN0IHYgPSBtb2QoYSAqIGQgKiB1MV8yIC0gdTJfMik7IC8vIDZcbiAgICAgICAgY29uc3QgeyBpc1ZhbGlkLCB2YWx1ZTogSSB9ID0gaW52ZXJ0U3FydChtb2QodiAqIHUyXzIpKTsgLy8gN1xuICAgICAgICBjb25zdCBEeCA9IG1vZChJICogdTIpOyAvLyA4XG4gICAgICAgIGNvbnN0IER5ID0gbW9kKEkgKiBEeCAqIHYpOyAvLyA5XG4gICAgICAgIGxldCB4ID0gbW9kKChzICsgcykgKiBEeCk7IC8vIDEwXG4gICAgICAgIGlmIChpc05lZ2F0aXZlTEUoeCwgUCkpXG4gICAgICAgICAgICB4ID0gbW9kKC14KTsgLy8gMTBcbiAgICAgICAgY29uc3QgeSA9IG1vZCh1MSAqIER5KTsgLy8gMTFcbiAgICAgICAgY29uc3QgdCA9IG1vZCh4ICogeSk7IC8vIDEyXG4gICAgICAgIGlmICghaXNWYWxpZCB8fCBpc05lZ2F0aXZlTEUodCwgUCkgfHwgeSA9PT0gXzBuKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHJpc3RyZXR0bzI1NSBlbmNvZGluZyAyJyk7XG4gICAgICAgIHJldHVybiBuZXcgX1Jpc3RyZXR0b1BvaW50KG5ldyBlZDI1NTE5LlBvaW50KHgsIHksIF8xbiwgdCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyByaXN0cmV0dG8tZW5jb2RlZCBzdHJpbmcgdG8gcmlzdHJldHRvIHBvaW50LlxuICAgICAqIERlc2NyaWJlZCBpbiBbUkZDOTQ5Nl0oaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzk0OTYjbmFtZS1kZWNvZGUpLlxuICAgICAqIEBwYXJhbSBoZXggUmlzdHJldHRvLWVuY29kZWQgMzIgYnl0ZXMuIE5vdCBldmVyeSAzMi1ieXRlIHN0cmluZyBpcyB2YWxpZCByaXN0cmV0dG8gZW5jb2RpbmdcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUhleChoZXgpIHtcbiAgICAgICAgcmV0dXJuIF9SaXN0cmV0dG9Qb2ludC5mcm9tQnl0ZXMoZW5zdXJlQnl0ZXMoJ3Jpc3RyZXR0b0hleCcsIGhleCwgMzIpKTtcbiAgICB9XG4gICAgc3RhdGljIG1zbShwb2ludHMsIHNjYWxhcnMpIHtcbiAgICAgICAgcmV0dXJuIHBpcHBlbmdlcihfUmlzdHJldHRvUG9pbnQsIGVkMjU1MTkuUG9pbnQuRm4sIHBvaW50cywgc2NhbGFycyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuY29kZXMgcmlzdHJldHRvIHBvaW50IHRvIFVpbnQ4QXJyYXkuXG4gICAgICogRGVzY3JpYmVkIGluIFtSRkM5NDk2XShodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTQ5NiNuYW1lLWVuY29kZSkuXG4gICAgICovXG4gICAgdG9CeXRlcygpIHtcbiAgICAgICAgbGV0IHsgWCwgWSwgWiwgVCB9ID0gdGhpcy5lcDtcbiAgICAgICAgY29uc3QgUCA9IGVkMjU1MTlfQ1VSVkVfcDtcbiAgICAgICAgY29uc3QgbW9kID0gKG4pID0+IEZwLmNyZWF0ZShuKTtcbiAgICAgICAgY29uc3QgdTEgPSBtb2QobW9kKFogKyBZKSAqIG1vZChaIC0gWSkpOyAvLyAxXG4gICAgICAgIGNvbnN0IHUyID0gbW9kKFggKiBZKTsgLy8gMlxuICAgICAgICAvLyBTcXVhcmUgcm9vdCBhbHdheXMgZXhpc3RzXG4gICAgICAgIGNvbnN0IHUyc3EgPSBtb2QodTIgKiB1Mik7XG4gICAgICAgIGNvbnN0IHsgdmFsdWU6IGludnNxcnQgfSA9IGludmVydFNxcnQobW9kKHUxICogdTJzcSkpOyAvLyAzXG4gICAgICAgIGNvbnN0IEQxID0gbW9kKGludnNxcnQgKiB1MSk7IC8vIDRcbiAgICAgICAgY29uc3QgRDIgPSBtb2QoaW52c3FydCAqIHUyKTsgLy8gNVxuICAgICAgICBjb25zdCB6SW52ID0gbW9kKEQxICogRDIgKiBUKTsgLy8gNlxuICAgICAgICBsZXQgRDsgLy8gN1xuICAgICAgICBpZiAoaXNOZWdhdGl2ZUxFKFQgKiB6SW52LCBQKSkge1xuICAgICAgICAgICAgbGV0IF94ID0gbW9kKFkgKiBTUVJUX00xKTtcbiAgICAgICAgICAgIGxldCBfeSA9IG1vZChYICogU1FSVF9NMSk7XG4gICAgICAgICAgICBYID0gX3g7XG4gICAgICAgICAgICBZID0gX3k7XG4gICAgICAgICAgICBEID0gbW9kKEQxICogSU5WU1FSVF9BX01JTlVTX0QpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgRCA9IEQyOyAvLyA4XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTmVnYXRpdmVMRShYICogekludiwgUCkpXG4gICAgICAgICAgICBZID0gbW9kKC1ZKTsgLy8gOVxuICAgICAgICBsZXQgcyA9IG1vZCgoWiAtIFkpICogRCk7IC8vIDEwIChjaGVjayBmb290ZXIncyBub3RlLCBubyBzcXJ0KC1hKSlcbiAgICAgICAgaWYgKGlzTmVnYXRpdmVMRShzLCBQKSlcbiAgICAgICAgICAgIHMgPSBtb2QoLXMpO1xuICAgICAgICByZXR1cm4gRnAudG9CeXRlcyhzKTsgLy8gMTFcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcGFyZXMgdHdvIFJpc3RyZXR0byBwb2ludHMuXG4gICAgICogRGVzY3JpYmVkIGluIFtSRkM5NDk2XShodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTQ5NiNuYW1lLWVxdWFscykuXG4gICAgICovXG4gICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2FtZShvdGhlcik7XG4gICAgICAgIGNvbnN0IHsgWDogWDEsIFk6IFkxIH0gPSB0aGlzLmVwO1xuICAgICAgICBjb25zdCB7IFg6IFgyLCBZOiBZMiB9ID0gb3RoZXIuZXA7XG4gICAgICAgIGNvbnN0IG1vZCA9IChuKSA9PiBGcC5jcmVhdGUobik7XG4gICAgICAgIC8vICh4MSAqIHkyID09IHkxICogeDIpIHwgKHkxICogeTIgPT0geDEgKiB4MilcbiAgICAgICAgY29uc3Qgb25lID0gbW9kKFgxICogWTIpID09PSBtb2QoWTEgKiBYMik7XG4gICAgICAgIGNvbnN0IHR3byA9IG1vZChZMSAqIFkyKSA9PT0gbW9kKFgxICogWDIpO1xuICAgICAgICByZXR1cm4gb25lIHx8IHR3bztcbiAgICB9XG4gICAgaXMwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lcXVhbHMoX1Jpc3RyZXR0b1BvaW50LlpFUk8pO1xuICAgIH1cbn1cbi8vIERvIE5PVCBjaGFuZ2Ugc3ludGF4OiB0aGUgZm9sbG93aW5nIGd5bW5hc3RpY3MgaXMgZG9uZSxcbi8vIGJlY2F1c2UgdHlwZXNjcmlwdCBzdHJpcHMgY29tbWVudHMsIHdoaWNoIG1ha2VzIGJ1bmRsZXJzIGRpc2FibGUgdHJlZS1zaGFraW5nLlxuLy8gcHJldHRpZXItaWdub3JlXG5fUmlzdHJldHRvUG9pbnQuQkFTRSA9IFxuLyogQF9fUFVSRV9fICovICgoKSA9PiBuZXcgX1Jpc3RyZXR0b1BvaW50KGVkMjU1MTkuUG9pbnQuQkFTRSkpKCk7XG4vLyBwcmV0dGllci1pZ25vcmVcbl9SaXN0cmV0dG9Qb2ludC5aRVJPID0gXG4vKiBAX19QVVJFX18gKi8gKCgpID0+IG5ldyBfUmlzdHJldHRvUG9pbnQoZWQyNTUxOS5Qb2ludC5aRVJPKSkoKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuX1Jpc3RyZXR0b1BvaW50LkZwID0gXG4vKiBAX19QVVJFX18gKi8gKCgpID0+IEZwKSgpO1xuLy8gcHJldHRpZXItaWdub3JlXG5fUmlzdHJldHRvUG9pbnQuRm4gPSBcbi8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gRm4pKCk7XG5leHBvcnQgY29uc3QgcmlzdHJldHRvMjU1ID0geyBQb2ludDogX1Jpc3RyZXR0b1BvaW50IH07XG4vKiogSGFzaGluZyB0byByaXN0cmV0dG8yNTUgcG9pbnRzIC8gZmllbGQuIFJGQyA5MzgwIG1ldGhvZHMuICovXG5leHBvcnQgY29uc3QgcmlzdHJldHRvMjU1X2hhc2hlciA9IHtcbiAgICBoYXNoVG9DdXJ2ZShtc2csIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgRFNUID0gb3B0aW9ucz8uRFNUIHx8ICdyaXN0cmV0dG8yNTVfWE1EOlNIQS01MTJfUjI1NU1BUF9ST18nO1xuICAgICAgICBjb25zdCB4bWQgPSBleHBhbmRfbWVzc2FnZV94bWQobXNnLCBEU1QsIDY0LCBzaGE1MTIpO1xuICAgICAgICByZXR1cm4gcmlzdHJldHRvMjU1X21hcCh4bWQpO1xuICAgIH0sXG4gICAgaGFzaFRvU2NhbGFyKG1zZywgb3B0aW9ucyA9IHsgRFNUOiBfRFNUX3NjYWxhciB9KSB7XG4gICAgICAgIGNvbnN0IHhtZCA9IGV4cGFuZF9tZXNzYWdlX3htZChtc2csIG9wdGlvbnMuRFNULCA2NCwgc2hhNTEyKTtcbiAgICAgICAgcmV0dXJuIEZuLmNyZWF0ZShieXRlc1RvTnVtYmVyTEUoeG1kKSk7XG4gICAgfSxcbn07XG4vLyBleHBvcnQgY29uc3QgcmlzdHJldHRvMjU1X29wcmY6IE9QUkYgPSBjcmVhdGVPUlBGKHtcbi8vICAgbmFtZTogJ3Jpc3RyZXR0bzI1NS1TSEE1MTInLFxuLy8gICBQb2ludDogUmlzdHJldHRvUG9pbnQsXG4vLyAgIGhhc2g6IHNoYTUxMixcbi8vICAgaGFzaFRvR3JvdXA6IHJpc3RyZXR0bzI1NV9oYXNoZXIuaGFzaFRvQ3VydmUsXG4vLyAgIGhhc2hUb1NjYWxhcjogcmlzdHJldHRvMjU1X2hhc2hlci5oYXNoVG9TY2FsYXIsXG4vLyB9KTtcbi8qKlxuICogV2VpcmQgLyBib2d1cyBwb2ludHMsIHVzZWZ1bCBmb3IgZGVidWdnaW5nLlxuICogQWxsIDggZWQyNTUxOSBwb2ludHMgb2YgOC10b3JzaW9uIHN1Ymdyb3VwIGNhbiBiZSBnZW5lcmF0ZWQgZnJvbSB0aGUgcG9pbnRcbiAqIFQgPSBgMjZlODk1OGZjMmIyMjdiMDQ1YzNmNDg5ZjJlZjk4ZjBkNWRmYWMwNWQzYzYzMzM5YjEzODAyODg2ZDUzZmMwNWAuXG4gKiDin6hU4p+pID0geyBPLCBULCAyVCwgM1QsIDRULCA1VCwgNlQsIDdUIH1cbiAqL1xuZXhwb3J0IGNvbnN0IEVEMjU1MTlfVE9SU0lPTl9TVUJHUk9VUCA9IFtcbiAgICAnMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJ2M3MTc2YTcwM2Q0ZGQ4NGZiYTNjMGI3NjBkMTA2NzBmMmEyMDUzZmEyYzM5Y2NjNjRlYzdmZDc3OTJhYzAzN2EnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDgwJyxcbiAgICAnMjZlODk1OGZjMmIyMjdiMDQ1YzNmNDg5ZjJlZjk4ZjBkNWRmYWMwNWQzYzYzMzM5YjEzODAyODg2ZDUzZmMwNScsXG4gICAgJ2VjZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmN2YnLFxuICAgICcyNmU4OTU4ZmMyYjIyN2IwNDVjM2Y0ODlmMmVmOThmMGQ1ZGZhYzA1ZDNjNjMzMzliMTM4MDI4ODZkNTNmYzg1JyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJ2M3MTc2YTcwM2Q0ZGQ4NGZiYTNjMGI3NjBkMTA2NzBmMmEyMDUzZmEyYzM5Y2NjNjRlYzdmZDc3OTJhYzAzZmEnLFxuXTtcbi8qKiBAZGVwcmVjYXRlZCB1c2UgYGVkMjU1MTkudXRpbHMudG9Nb250Z29tZXJ5YCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVkd2FyZHNUb01vbnRnb21lcnlQdWIoZWR3YXJkc1B1Yikge1xuICAgIHJldHVybiBlZDI1NTE5LnV0aWxzLnRvTW9udGdvbWVyeShlbnN1cmVCeXRlcygncHViJywgZWR3YXJkc1B1YikpO1xufVxuLyoqIEBkZXByZWNhdGVkIHVzZSBgZWQyNTUxOS51dGlscy50b01vbnRnb21lcnlgICovXG5leHBvcnQgY29uc3QgZWR3YXJkc1RvTW9udGdvbWVyeSA9IGVkd2FyZHNUb01vbnRnb21lcnlQdWI7XG4vKiogQGRlcHJlY2F0ZWQgdXNlIGBlZDI1NTE5LnV0aWxzLnRvTW9udGdvbWVyeVNlY3JldGAgKi9cbmV4cG9ydCBmdW5jdGlvbiBlZHdhcmRzVG9Nb250Z29tZXJ5UHJpdihlZHdhcmRzUHJpdikge1xuICAgIHJldHVybiBlZDI1NTE5LnV0aWxzLnRvTW9udGdvbWVyeVNlY3JldChlbnN1cmVCeXRlcygncHViJywgZWR3YXJkc1ByaXYpKTtcbn1cbi8qKiBAZGVwcmVjYXRlZCB1c2UgYHJpc3RyZXR0bzI1NS5Qb2ludGAgKi9cbmV4cG9ydCBjb25zdCBSaXN0cmV0dG9Qb2ludCA9IF9SaXN0cmV0dG9Qb2ludDtcbi8qKiBAZGVwcmVjYXRlZCB1c2UgYGltcG9ydCB7IGVkMjU1MTlfaGFzaGVyIH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9lZDI1NTE5LmpzJztgICovXG5leHBvcnQgY29uc3QgaGFzaFRvQ3VydmUgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGVkMjU1MTlfaGFzaGVyLmhhc2hUb0N1cnZlKSgpO1xuLyoqIEBkZXByZWNhdGVkIHVzZSBgaW1wb3J0IHsgZWQyNTUxOV9oYXNoZXIgfSBmcm9tICdAbm9ibGUvY3VydmVzL2VkMjU1MTkuanMnO2AgKi9cbmV4cG9ydCBjb25zdCBlbmNvZGVUb0N1cnZlID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBlZDI1NTE5X2hhc2hlci5lbmNvZGVUb0N1cnZlKSgpO1xuLyoqIEBkZXByZWNhdGVkIHVzZSBgaW1wb3J0IHsgcmlzdHJldHRvMjU1X2hhc2hlciB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvZWQyNTUxOS5qcyc7YCAqL1xuZXhwb3J0IGNvbnN0IGhhc2hUb1Jpc3RyZXR0bzI1NSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gcmlzdHJldHRvMjU1X2hhc2hlci5oYXNoVG9DdXJ2ZSkoKTtcbi8qKiBAZGVwcmVjYXRlZCB1c2UgYGltcG9ydCB7IHJpc3RyZXR0bzI1NV9oYXNoZXIgfSBmcm9tICdAbm9ibGUvY3VydmVzL2VkMjU1MTkuanMnO2AgKi9cbmV4cG9ydCBjb25zdCBoYXNoX3RvX3Jpc3RyZXR0bzI1NSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gcmlzdHJldHRvMjU1X2hhc2hlci5oYXNoVG9DdXJ2ZSkoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVkMjU1MTkuanMubWFwIl0sIm5hbWVzIjpbInNoYTUxMiIsImFieXRlcyIsImNvbmNhdEJ5dGVzIiwidXRmOFRvQnl0ZXMiLCJwaXBwZW5nZXIiLCJQcmltZUVkd2FyZHNQb2ludCIsInR3aXN0ZWRFZHdhcmRzIiwiX0RTVF9zY2FsYXIiLCJjcmVhdGVIYXNoZXIiLCJleHBhbmRfbWVzc2FnZV94bWQiLCJGaWVsZCIsIkZwSW52ZXJ0QmF0Y2giLCJGcFNxcnRFdmVuIiwiaXNOZWdhdGl2ZUxFIiwibW9kIiwicG93MiIsIm1vbnRnb21lcnkiLCJieXRlc1RvTnVtYmVyTEUiLCJlbnN1cmVCeXRlcyIsImVxdWFsQnl0ZXMiLCJfMG4iLCJCaWdJbnQiLCJfMW4iLCJfMm4iLCJfM24iLCJfNW4iLCJfOG4iLCJlZDI1NTE5X0NVUlZFX3AiLCJlZDI1NTE5X0NVUlZFIiwicCIsIm4iLCJoIiwiYSIsImQiLCJHeCIsIkd5IiwiZWQyNTUxOV9wb3dfMl8yNTJfMyIsIngiLCJfMTBuIiwiXzIwbiIsIl80MG4iLCJfODBuIiwiUCIsIngyIiwiYjIiLCJiNCIsImI1IiwiYjEwIiwiYjIwIiwiYjQwIiwiYjgwIiwiYjE2MCIsImIyNDAiLCJiMjUwIiwicG93X3BfNV84IiwiYWRqdXN0U2NhbGFyQnl0ZXMiLCJieXRlcyIsIkVEMjU1MTlfU1FSVF9NMSIsInV2UmF0aW8iLCJ1IiwidiIsInYzIiwidjciLCJwb3ciLCJ2eDIiLCJyb290MSIsInJvb3QyIiwidXNlUm9vdDEiLCJ1c2VSb290MiIsIm5vUm9vdCIsImlzVmFsaWQiLCJ2YWx1ZSIsIkZwIiwiaXNMRSIsIkZuIiwiZWQyNTUxOURlZmF1bHRzIiwiaGFzaCIsImVkMjU1MTkiLCJlZDI1NTE5X2RvbWFpbiIsImRhdGEiLCJjdHgiLCJwaGZsYWciLCJsZW5ndGgiLCJFcnJvciIsIlVpbnQ4QXJyYXkiLCJlZDI1NTE5Y3R4IiwiZG9tYWluIiwiZWQyNTUxOXBoIiwiT2JqZWN0IiwiYXNzaWduIiwicHJlaGFzaCIsIngyNTUxOSIsIk9SREVSIiwidHlwZSIsInBvd1BtaW51czIiLCJFTEwyX0MxIiwiRUxMMl9DMiIsIkVMTDJfQzMiLCJzcXJ0IiwibmVnIiwiT05FIiwibWFwX3RvX2N1cnZlX2VsbGlnYXRvcjJfY3VydmUyNTUxOSIsIkVMTDJfQzQiLCJFTEwyX0oiLCJ0djEiLCJzcXIiLCJtdWwiLCJ4ZCIsImFkZCIsIngxbiIsInR2MiIsImd4ZCIsImd4MSIsInR2MyIsInkxMSIsInkxMiIsImUxIiwiZXFsIiwieTEiLCJjbW92IiwieDJuIiwieTIxIiwieTIyIiwiZ3gyIiwiZTIiLCJ5MiIsImUzIiwieG4iLCJ5IiwiZTQiLCJpc09kZCIsInhNbiIsInhNZCIsInlNbiIsInlNZCIsIkVMTDJfQzFfRURXQVJEUyIsIm1hcF90b19jdXJ2ZV9lbGxpZ2F0b3IyX2Vkd2FyZHMyNTUxOSIsInluIiwic3ViIiwieWQiLCJlIiwiWkVSTyIsInhkX2ludiIsInlkX2ludiIsImVkMjU1MTlfaGFzaGVyIiwiUG9pbnQiLCJzY2FsYXJzIiwiRFNUIiwiZW5jb2RlRFNUIiwibSIsImsiLCJleHBhbmQiLCJTUVJUX00xIiwiU1FSVF9BRF9NSU5VU19PTkUiLCJJTlZTUVJUX0FfTUlOVVNfRCIsIk9ORV9NSU5VU19EX1NRIiwiRF9NSU5VU19PTkVfU1EiLCJpbnZlcnRTcXJ0IiwibnVtYmVyIiwiTUFYXzI1NUIiLCJieXRlczI1NVRvTnVtYmVyTEUiLCJjcmVhdGUiLCJjYWxjRWxsaWdhdG9yUmlzdHJldHRvTWFwIiwicjAiLCJyIiwiTnMiLCJjIiwiRCIsIk5zX0RfaXNfc3EiLCJzIiwic18iLCJOdCIsInMyIiwiVzAiLCJXMSIsIlcyIiwiVzMiLCJyaXN0cmV0dG8yNTVfbWFwIiwicjEiLCJzdWJhcnJheSIsIlIxIiwicjIiLCJSMiIsIl9SaXN0cmV0dG9Qb2ludCIsImNvbnN0cnVjdG9yIiwiZXAiLCJmcm9tQWZmaW5lIiwiYXAiLCJhc3NlcnRTYW1lIiwib3RoZXIiLCJpbml0IiwiaGFzaFRvQ3VydmUiLCJoZXgiLCJmcm9tQnl0ZXMiLCJ0b0J5dGVzIiwidTEiLCJ1MiIsInUxXzIiLCJ1Ml8yIiwiSSIsIkR4IiwiRHkiLCJ0IiwiZnJvbUhleCIsIm1zbSIsInBvaW50cyIsIlgiLCJZIiwiWiIsIlQiLCJ1MnNxIiwiaW52c3FydCIsIkQxIiwiRDIiLCJ6SW52IiwiX3giLCJfeSIsImVxdWFscyIsIlgxIiwiWTEiLCJYMiIsIlkyIiwib25lIiwidHdvIiwiaXMwIiwiQkFTRSIsInJpc3RyZXR0bzI1NSIsInJpc3RyZXR0bzI1NV9oYXNoZXIiLCJtc2ciLCJvcHRpb25zIiwieG1kIiwiaGFzaFRvU2NhbGFyIiwiRUQyNTUxOV9UT1JTSU9OX1NVQkdST1VQIiwiZWR3YXJkc1RvTW9udGdvbWVyeVB1YiIsImVkd2FyZHNQdWIiLCJ1dGlscyIsInRvTW9udGdvbWVyeSIsImVkd2FyZHNUb01vbnRnb21lcnkiLCJlZHdhcmRzVG9Nb250Z29tZXJ5UHJpdiIsImVkd2FyZHNQcml2IiwidG9Nb250Z29tZXJ5U2VjcmV0IiwiUmlzdHJldHRvUG9pbnQiLCJlbmNvZGVUb0N1cnZlIiwiaGFzaFRvUmlzdHJldHRvMjU1IiwiaGFzaF90b19yaXN0cmV0dG8yNTUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/ed25519.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/secp256k1.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/secp256k1.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeToCurve: () => (/* binding */ encodeToCurve),\n/* harmony export */   hashToCurve: () => (/* binding */ hashToCurve),\n/* harmony export */   schnorr: () => (/* binding */ schnorr),\n/* harmony export */   secp256k1: () => (/* binding */ secp256k1),\n/* harmony export */   secp256k1_hasher: () => (/* binding */ secp256k1_hasher)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha2_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/sha2.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/sha2.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_shortw_utils.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/_shortw_utils.js\");\n/* harmony import */ var _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/* harmony import */ var _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract/modular.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/utils.js\");\n/**\n * SECG secp256k1. See [pdf](https://www.secg.org/sec2-v2.pdf).\n *\n * Belongs to Koblitz curves: it has efficiently-computable GLV endomorphism ,\n * check out {@link EndomorphismOpts}. Seems to be rigid (not backdoored).\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\n\n\n\n\n\n// Seems like generator was produced from some seed:\n// `Point.BASE.multiply(Point.Fn.inv(2n, N)).toAffine().x`\n// // gives short x 0x3b78ce563f89a0ed9414f5aa28ad0d96d6795f9c63n\nconst secp256k1_CURVE = {\n    p: BigInt(\"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f\"),\n    n: BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\"),\n    h: BigInt(1),\n    a: BigInt(0),\n    b: BigInt(7),\n    Gx: BigInt(\"0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798\"),\n    Gy: BigInt(\"0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8\")\n};\nconst secp256k1_ENDO = {\n    beta: BigInt(\"0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\"),\n    basises: [\n        [\n            BigInt(\"0x3086d221a7d46bcde86c90e49284eb15\"),\n            -BigInt(\"0xe4437ed6010e88286f547fa90abfe4c3\")\n        ],\n        [\n            BigInt(\"0x114ca50f7a8e2f3f657c1108d9d44cfd8\"),\n            BigInt(\"0x3086d221a7d46bcde86c90e49284eb15\")\n        ]\n    ]\n};\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\n/**\n * n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */ function sqrtMod(y) {\n    const P = secp256k1_CURVE.p;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = y * y * y % P; // x^3, 11\n    const b3 = b2 * b2 * y % P; // x^7\n    const b6 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b3, _3n, P) * b3 % P;\n    const b9 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b6, _3n, P) * b3 % P;\n    const b11 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b9, _2n, P) * b2 % P;\n    const b22 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b11, _11n, P) * b11 % P;\n    const b44 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b22, _22n, P) * b22 % P;\n    const b88 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b44, _44n, P) * b44 % P;\n    const b176 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b88, _88n, P) * b88 % P;\n    const b220 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b176, _44n, P) * b44 % P;\n    const b223 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b220, _3n, P) * b3 % P;\n    const t1 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b223, _23n, P) * b22 % P;\n    const t2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t1, _6n, P) * b2 % P;\n    const root = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t2, _2n, P);\n    if (!Fpk1.eql(Fpk1.sqr(root), y)) throw new Error(\"Cannot find square root\");\n    return root;\n}\nconst Fpk1 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(secp256k1_CURVE.p, {\n    sqrt: sqrtMod\n});\n/**\n * secp256k1 curve, ECDSA and ECDH methods.\n *\n * Field: `2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n`\n *\n * @example\n * ```js\n * import { secp256k1 } from '@noble/curves/secp256k1';\n * const { secretKey, publicKey } = secp256k1.keygen();\n * const msg = new TextEncoder().encode('hello');\n * const sig = secp256k1.sign(msg, secretKey);\n * const isValid = secp256k1.verify(sig, msg, publicKey) === true;\n * ```\n */ const secp256k1 = (0,_shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__.createCurve)({\n    ...secp256k1_CURVE,\n    Fp: Fpk1,\n    lowS: true,\n    endo: secp256k1_ENDO\n}, _noble_hashes_sha2_js__WEBPACK_IMPORTED_MODULE_2__.sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */ const TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag, ...messages) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = (0,_noble_hashes_sha2_js__WEBPACK_IMPORTED_MODULE_2__.sha256)((0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.utf8ToBytes)(tag));\n        tagP = (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return (0,_noble_hashes_sha2_js__WEBPACK_IMPORTED_MODULE_2__.sha256)((0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point)=>point.toBytes(true).slice(1);\nconst Pointk1 = /* @__PURE__ */ (()=>secp256k1.Point)();\nconst hasEven = (y)=>y % _2n === _0n;\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    const { Fn, BASE } = Pointk1;\n    const d_ = (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_4__._normFnElement)(Fn, priv);\n    const p = BASE.multiply(d_); // P = d'G; 0 < d' < n check is done inside\n    const scalar = hasEven(p.y) ? d_ : Fn.neg(d_);\n    return {\n        scalar,\n        bytes: pointToBytes(p)\n    };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */ function lift_x(x) {\n    const Fp = Fpk1;\n    if (!Fp.isValidNot0(x)) throw new Error(\"invalid x: Fail if x  p\");\n    const xx = Fp.create(x * x);\n    const c = Fp.create(xx * x + BigInt(7)); // Let c = x + 7 mod p.\n    let y = Fp.sqrt(c); // Let y = c^(p+1)/4 mod p. Same as sqrt().\n    // Return the unique point P such that x(P) = x and\n    // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    if (!hasEven(y)) y = Fp.neg(y);\n    const p = Pointk1.fromAffine({\n        x,\n        y\n    });\n    p.assertValidity();\n    return p;\n}\nconst num = _utils_js__WEBPACK_IMPORTED_MODULE_5__.bytesToNumberBE;\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */ function challenge(...args) {\n    return Pointk1.Fn.create(num(taggedHash(\"BIP0340/challenge\", ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */ function schnorrGetPublicKey(secretKey) {\n    return schnorrGetExtPubKey(secretKey).bytes; // d'=int(sk). Fail if d'=0 or d'n. Ret bytes(d'G)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */ function schnorrSign(message, secretKey, auxRand = (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.randomBytes)(32)) {\n    const { Fn } = Pointk1;\n    const m = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.ensureBytes)(\"message\", message);\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(secretKey); // checks for isWithinCurveOrder\n    const a = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.ensureBytes)(\"auxRand\", auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = Fn.toBytes(d ^ num(taggedHash(\"BIP0340/aux\", a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash(\"BIP0340/nonce\", t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    // Let k' = int(rand) mod n. Fail if k' = 0. Let R = k'G\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(rand);\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(Fn.toBytes(Fn.create(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px)) throw new Error(\"sign: Invalid signature produced\");\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */ function schnorrVerify(signature, message, publicKey) {\n    const { Fn, BASE } = Pointk1;\n    const sig = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.ensureBytes)(\"signature\", signature, 64);\n    const m = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.ensureBytes)(\"message\", message);\n    const pub = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.ensureBytes)(\"publicKey\", publicKey, 32);\n    try {\n        const P = lift_x(num(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = num(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r  p.\n        if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.inRange)(r, _1n, secp256k1_CURVE.p)) return false;\n        const s = num(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s  n.\n        if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.inRange)(s, _1n, secp256k1_CURVE.n)) return false;\n        // int(challenge(bytes(r)||bytes(P)||m))%n\n        const e = challenge(Fn.toBytes(r), pointToBytes(P), m);\n        // R = sG - eP, where -eP == (n-e)P\n        const R = BASE.multiplyUnsafe(s).add(P.multiplyUnsafe(Fn.neg(e)));\n        const { x, y } = R.toAffine();\n        // Fail if is_infinite(R) / not has_even_y(R) / x(R)  r.\n        if (R.is0() || !hasEven(y) || x !== r) return false;\n        return true;\n    } catch (error) {\n        return false;\n    }\n}\n/**\n * Schnorr signatures over secp256k1.\n * https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n * @example\n * ```js\n * import { schnorr } from '@noble/curves/secp256k1';\n * const { secretKey, publicKey } = schnorr.keygen();\n * // const publicKey = schnorr.getPublicKey(secretKey);\n * const msg = new TextEncoder().encode('hello');\n * const sig = schnorr.sign(msg, secretKey);\n * const isValid = schnorr.verify(sig, msg, publicKey);\n * ```\n */ const schnorr = /* @__PURE__ */ (()=>{\n    const size = 32;\n    const seedLength = 48;\n    const randomSecretKey = (seed = (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.randomBytes)(seedLength))=>{\n        return (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mapHashToField)(seed, secp256k1_CURVE.n);\n    };\n    // TODO: remove\n    secp256k1.utils.randomSecretKey;\n    function keygen(seed) {\n        const secretKey = randomSecretKey(seed);\n        return {\n            secretKey,\n            publicKey: schnorrGetPublicKey(secretKey)\n        };\n    }\n    return {\n        keygen,\n        getPublicKey: schnorrGetPublicKey,\n        sign: schnorrSign,\n        verify: schnorrVerify,\n        Point: Pointk1,\n        utils: {\n            randomSecretKey: randomSecretKey,\n            randomPrivateKey: randomSecretKey,\n            taggedHash,\n            // TODO: remove\n            lift_x,\n            pointToBytes,\n            numberToBytesBE: _utils_js__WEBPACK_IMPORTED_MODULE_5__.numberToBytesBE,\n            bytesToNumberBE: _utils_js__WEBPACK_IMPORTED_MODULE_5__.bytesToNumberBE,\n            mod: _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod\n        },\n        lengths: {\n            secretKey: size,\n            publicKey: size,\n            publicKeyHasPrefix: false,\n            signature: size * 2,\n            seed: seedLength\n        }\n    };\n})();\nconst isoMap = /* @__PURE__ */ (()=>(0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_6__.isogenyMap)(Fpk1, [\n        // xNum\n        [\n            \"0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7\",\n            \"0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581\",\n            \"0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262\",\n            \"0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c\"\n        ],\n        // xDen\n        [\n            \"0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b\",\n            \"0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14\",\n            \"0x0000000000000000000000000000000000000000000000000000000000000001\"\n        ],\n        // yNum\n        [\n            \"0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c\",\n            \"0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3\",\n            \"0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931\",\n            \"0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84\"\n        ],\n        // yDen\n        [\n            \"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b\",\n            \"0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573\",\n            \"0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f\",\n            \"0x0000000000000000000000000000000000000000000000000000000000000001\"\n        ]\n    ].map((i)=>i.map((j)=>BigInt(j)))))();\nconst mapSWU = /* @__PURE__ */ (()=>(0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_4__.mapToCurveSimpleSWU)(Fpk1, {\n        A: BigInt(\"0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533\"),\n        B: BigInt(\"1771\"),\n        Z: Fpk1.create(BigInt(\"-11\"))\n    }))();\n/** Hashing / encoding to secp256k1 points / field. RFC 9380 methods. */ const secp256k1_hasher = /* @__PURE__ */ (()=>(0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_6__.createHasher)(secp256k1.Point, (scalars)=>{\n        const { x, y } = mapSWU(Fpk1.create(scalars[0]));\n        return isoMap(x, y);\n    }, {\n        DST: \"secp256k1_XMD:SHA-256_SSWU_RO_\",\n        encodeDST: \"secp256k1_XMD:SHA-256_SSWU_NU_\",\n        p: Fpk1.ORDER,\n        m: 1,\n        k: 128,\n        expand: \"xmd\",\n        hash: _noble_hashes_sha2_js__WEBPACK_IMPORTED_MODULE_2__.sha256\n    }))();\n/** @deprecated use `import { secp256k1_hasher } from '@noble/curves/secp256k1.js';` */ const hashToCurve = /* @__PURE__ */ (()=>secp256k1_hasher.hashToCurve)();\n/** @deprecated use `import { secp256k1_hasher } from '@noble/curves/secp256k1.js';` */ const encodeToCurve = /* @__PURE__ */ (()=>secp256k1_hasher.encodeToCurve)(); //# sourceMappingURL=secp256k1.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9zZWNwMjU2azEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7OztDQU1DLEdBQ0Qsb0VBQW9FLEdBQ3JCO0FBQ007QUFDSjtBQUN1QjtBQUNDO0FBQ1E7QUFDOEI7QUFDL0csb0RBQW9EO0FBQ3BELDBEQUEwRDtBQUMxRCxpRUFBaUU7QUFDakUsTUFBTWlCLGtCQUFrQjtJQUNwQkMsR0FBR0MsT0FBTztJQUNWQyxHQUFHRCxPQUFPO0lBQ1ZFLEdBQUdGLE9BQU87SUFDVkcsR0FBR0gsT0FBTztJQUNWSSxHQUFHSixPQUFPO0lBQ1ZLLElBQUlMLE9BQU87SUFDWE0sSUFBSU4sT0FBTztBQUNmO0FBQ0EsTUFBTU8saUJBQWlCO0lBQ25CQyxNQUFNUixPQUFPO0lBQ2JTLFNBQVM7UUFDTDtZQUFDVCxPQUFPO1lBQXVDLENBQUNBLE9BQU87U0FBc0M7UUFDN0Y7WUFBQ0EsT0FBTztZQUF3Q0EsT0FBTztTQUFzQztLQUNoRztBQUNMO0FBQ0EsTUFBTVUsTUFBTSxhQUFhLEdBQUdWLE9BQU87QUFDbkMsTUFBTVcsTUFBTSxhQUFhLEdBQUdYLE9BQU87QUFDbkMsTUFBTVksTUFBTSxhQUFhLEdBQUdaLE9BQU87QUFDbkM7OztDQUdDLEdBQ0QsU0FBU2EsUUFBUUMsQ0FBQztJQUNkLE1BQU1DLElBQUlqQixnQkFBZ0JDLENBQUM7SUFDM0Isa0JBQWtCO0lBQ2xCLE1BQU1pQixNQUFNaEIsT0FBTyxJQUFJaUIsTUFBTWpCLE9BQU8sSUFBSWtCLE9BQU9sQixPQUFPLEtBQUttQixPQUFPbkIsT0FBTztJQUN6RSxrQkFBa0I7SUFDbEIsTUFBTW9CLE9BQU9wQixPQUFPLEtBQUtxQixPQUFPckIsT0FBTyxLQUFLc0IsT0FBT3RCLE9BQU87SUFDMUQsTUFBTXVCLEtBQUssSUFBS1QsSUFBSUEsSUFBS0MsR0FBRyxVQUFVO0lBQ3RDLE1BQU1TLEtBQUssS0FBTUQsS0FBS1QsSUFBS0MsR0FBRyxNQUFNO0lBQ3BDLE1BQU1VLEtBQUssMkRBQU1ELElBQUlSLEtBQUtELEtBQUtTLEtBQU1UO0lBQ3JDLE1BQU1XLEtBQUssMkRBQU1ELElBQUlULEtBQUtELEtBQUtTLEtBQU1UO0lBQ3JDLE1BQU1ZLE1BQU0sMkRBQU1ELElBQUlkLEtBQUtHLEtBQUtRLEtBQU1SO0lBQ3RDLE1BQU1hLE1BQU0sMkRBQU1ELEtBQUtULE1BQU1ILEtBQUtZLE1BQU9aO0lBQ3pDLE1BQU1jLE1BQU0sMkRBQU1ELEtBQUtULE1BQU1KLEtBQUthLE1BQU9iO0lBQ3pDLE1BQU1lLE1BQU0sMkRBQU1ELEtBQUtSLE1BQU1OLEtBQUtjLE1BQU9kO0lBQ3pDLE1BQU1nQixPQUFPLDJEQUFNRCxLQUFLUixNQUFNUCxLQUFLZSxNQUFPZjtJQUMxQyxNQUFNaUIsT0FBTywyREFBTUQsTUFBTVYsTUFBTU4sS0FBS2MsTUFBT2Q7SUFDM0MsTUFBTWtCLE9BQU8sMkRBQU1ELE1BQU1oQixLQUFLRCxLQUFLUyxLQUFNVDtJQUN6QyxNQUFNbUIsS0FBSywyREFBTUQsTUFBTWIsTUFBTUwsS0FBS2EsTUFBT2I7SUFDekMsTUFBTW9CLEtBQUssMkRBQU1ELElBQUlqQixLQUFLRixLQUFLUSxLQUFNUjtJQUNyQyxNQUFNcUIsT0FBTy9DLDBEQUFJQSxDQUFDOEMsSUFBSXZCLEtBQUtHO0lBQzNCLElBQUksQ0FBQ3NCLEtBQUtDLEdBQUcsQ0FBQ0QsS0FBS0UsR0FBRyxDQUFDSCxPQUFPdEIsSUFDMUIsTUFBTSxJQUFJMEIsTUFBTTtJQUNwQixPQUFPSjtBQUNYO0FBQ0EsTUFBTUMsT0FBT25ELDJEQUFLQSxDQUFDWSxnQkFBZ0JDLENBQUMsRUFBRTtJQUFFMEMsTUFBTTVCO0FBQVE7QUFDdEQ7Ozs7Ozs7Ozs7Ozs7Q0FhQyxHQUNNLE1BQU02QixZQUFZM0QsNkRBQVdBLENBQUM7SUFBRSxHQUFHZSxlQUFlO0lBQUU2QyxJQUFJTjtJQUFNTyxNQUFNO0lBQU1DLE1BQU10QztBQUFlLEdBQUcxQix5REFBTUEsRUFBRTtBQUNqSCwrRkFBK0Y7QUFDL0YsaUVBQWlFO0FBQ2pFLHNGQUFzRixHQUN0RixNQUFNaUUsdUJBQXVCLENBQUM7QUFDOUIsU0FBU0MsV0FBV0MsR0FBRyxFQUFFLEdBQUdDLFFBQVE7SUFDaEMsSUFBSUMsT0FBT0osb0JBQW9CLENBQUNFLElBQUk7SUFDcEMsSUFBSUUsU0FBU0MsV0FBVztRQUNwQixNQUFNQyxPQUFPdkUsNkRBQU1BLENBQUNnQixzREFBV0EsQ0FBQ21EO1FBQ2hDRSxPQUFPekQsc0RBQVdBLENBQUMyRCxNQUFNQTtRQUN6Qk4sb0JBQW9CLENBQUNFLElBQUksR0FBR0U7SUFDaEM7SUFDQSxPQUFPckUsNkRBQU1BLENBQUNZLHNEQUFXQSxDQUFDeUQsU0FBU0Q7QUFDdkM7QUFDQSxvRkFBb0Y7QUFDcEYsTUFBTUksZUFBZSxDQUFDQyxRQUFVQSxNQUFNQyxPQUFPLENBQUMsTUFBTUMsS0FBSyxDQUFDO0FBQzFELE1BQU1DLFVBQTBCLGFBQUgsR0FBSSxLQUFNZixVQUFVZ0IsS0FBSztBQUN0RCxNQUFNQyxVQUFVLENBQUM3QyxJQUFNQSxJQUFJRixRQUFRRjtBQUNuQyxvQ0FBb0M7QUFDcEMsU0FBU2tELG9CQUFvQkMsSUFBSTtJQUM3QixNQUFNLEVBQUVDLEVBQUUsRUFBRUMsSUFBSSxFQUFFLEdBQUdOO0lBQ3JCLE1BQU1PLEtBQUsxRSx3RUFBY0EsQ0FBQ3dFLElBQUlEO0lBQzlCLE1BQU05RCxJQUFJZ0UsS0FBS0UsUUFBUSxDQUFDRCxLQUFLLDRDQUE0QztJQUN6RSxNQUFNRSxTQUFTUCxRQUFRNUQsRUFBRWUsQ0FBQyxJQUFJa0QsS0FBS0YsR0FBR0ssR0FBRyxDQUFDSDtJQUMxQyxPQUFPO1FBQUVFO1FBQVFFLE9BQU9mLGFBQWF0RDtJQUFHO0FBQzVDO0FBQ0E7OztDQUdDLEdBQ0QsU0FBU3NFLE9BQU9DLENBQUM7SUFDYixNQUFNM0IsS0FBS047SUFDWCxJQUFJLENBQUNNLEdBQUc0QixXQUFXLENBQUNELElBQ2hCLE1BQU0sSUFBSTlCLE1BQU07SUFDcEIsTUFBTWdDLEtBQUs3QixHQUFHOEIsTUFBTSxDQUFDSCxJQUFJQTtJQUN6QixNQUFNSSxJQUFJL0IsR0FBRzhCLE1BQU0sQ0FBQ0QsS0FBS0YsSUFBSXRFLE9BQU8sS0FBSyx3QkFBd0I7SUFDakUsSUFBSWMsSUFBSTZCLEdBQUdGLElBQUksQ0FBQ2lDLElBQUksMkNBQTJDO0lBQy9ELG1EQUFtRDtJQUNuRCxtREFBbUQ7SUFDbkQsSUFBSSxDQUFDZixRQUFRN0MsSUFDVEEsSUFBSTZCLEdBQUd3QixHQUFHLENBQUNyRDtJQUNmLE1BQU1mLElBQUkwRCxRQUFRa0IsVUFBVSxDQUFDO1FBQUVMO1FBQUd4RDtJQUFFO0lBQ3BDZixFQUFFNkUsY0FBYztJQUNoQixPQUFPN0U7QUFDWDtBQUNBLE1BQU04RSxNQUFNckYsc0RBQWVBO0FBQzNCOztDQUVDLEdBQ0QsU0FBU3NGLFVBQVUsR0FBR0MsSUFBSTtJQUN0QixPQUFPdEIsUUFBUUssRUFBRSxDQUFDVyxNQUFNLENBQUNJLElBQUk5QixXQUFXLHdCQUF3QmdDO0FBQ3BFO0FBQ0E7O0NBRUMsR0FDRCxTQUFTQyxvQkFBb0JDLFNBQVM7SUFDbEMsT0FBT3JCLG9CQUFvQnFCLFdBQVdiLEtBQUssRUFBRSxvREFBb0Q7QUFDckc7QUFDQTs7O0NBR0MsR0FDRCxTQUFTYyxZQUFZQyxPQUFPLEVBQUVGLFNBQVMsRUFBRUcsVUFBVXRHLHNEQUFXQSxDQUFDLEdBQUc7SUFDOUQsTUFBTSxFQUFFZ0YsRUFBRSxFQUFFLEdBQUdMO0lBQ2YsTUFBTTRCLElBQUkzRixzREFBV0EsQ0FBQyxXQUFXeUY7SUFDakMsTUFBTSxFQUFFZixPQUFPa0IsRUFBRSxFQUFFcEIsUUFBUXFCLENBQUMsRUFBRSxHQUFHM0Isb0JBQW9CcUIsWUFBWSxnQ0FBZ0M7SUFDakcsTUFBTTlFLElBQUlULHNEQUFXQSxDQUFDLFdBQVcwRixTQUFTLEtBQUssMkNBQTJDO0lBQzFGLE1BQU1JLElBQUkxQixHQUFHUCxPQUFPLENBQUNnQyxJQUFJVixJQUFJOUIsV0FBVyxlQUFlNUMsTUFBTSx5REFBeUQ7SUFDdEgsTUFBTXNGLE9BQU8xQyxXQUFXLGlCQUFpQnlDLEdBQUdGLElBQUlELElBQUksNENBQTRDO0lBQ2hHLHlEQUF5RDtJQUN6RCxNQUFNLEVBQUVqQixPQUFPc0IsRUFBRSxFQUFFeEIsUUFBUXlCLENBQUMsRUFBRSxHQUFHL0Isb0JBQW9CNkI7SUFDckQsTUFBTUcsSUFBSWQsVUFBVVksSUFBSUosSUFBSUQsSUFBSSxnRUFBZ0U7SUFDaEcsTUFBTVEsTUFBTSxJQUFJQyxXQUFXLEtBQUssK0NBQStDO0lBQy9FRCxJQUFJRSxHQUFHLENBQUNMLElBQUk7SUFDWkcsSUFBSUUsR0FBRyxDQUFDakMsR0FBR1AsT0FBTyxDQUFDTyxHQUFHVyxNQUFNLENBQUNrQixJQUFJQyxJQUFJTCxLQUFLO0lBQzFDLGlFQUFpRTtJQUNqRSxJQUFJLENBQUNTLGNBQWNILEtBQUtSLEdBQUdDLEtBQ3ZCLE1BQU0sSUFBSTlDLE1BQU07SUFDcEIsT0FBT3FEO0FBQ1g7QUFDQTs7O0NBR0MsR0FDRCxTQUFTRyxjQUFjQyxTQUFTLEVBQUVkLE9BQU8sRUFBRWUsU0FBUztJQUNoRCxNQUFNLEVBQUVwQyxFQUFFLEVBQUVDLElBQUksRUFBRSxHQUFHTjtJQUNyQixNQUFNb0MsTUFBTW5HLHNEQUFXQSxDQUFDLGFBQWF1RyxXQUFXO0lBQ2hELE1BQU1aLElBQUkzRixzREFBV0EsQ0FBQyxXQUFXeUY7SUFDakMsTUFBTWdCLE1BQU16RyxzREFBV0EsQ0FBQyxhQUFhd0csV0FBVztJQUNoRCxJQUFJO1FBQ0EsTUFBTW5GLElBQUlzRCxPQUFPUSxJQUFJc0IsT0FBTywwQ0FBMEM7UUFDdEUsTUFBTUMsSUFBSXZCLElBQUlnQixJQUFJUSxRQUFRLENBQUMsR0FBRyxNQUFNLHlDQUF5QztRQUM3RSxJQUFJLENBQUMxRyxrREFBT0EsQ0FBQ3lHLEdBQUd6RixLQUFLYixnQkFBZ0JDLENBQUMsR0FDbEMsT0FBTztRQUNYLE1BQU11RyxJQUFJekIsSUFBSWdCLElBQUlRLFFBQVEsQ0FBQyxJQUFJLE1BQU0sMENBQTBDO1FBQy9FLElBQUksQ0FBQzFHLGtEQUFPQSxDQUFDMkcsR0FBRzNGLEtBQUtiLGdCQUFnQkcsQ0FBQyxHQUNsQyxPQUFPO1FBQ1gsMENBQTBDO1FBQzFDLE1BQU0yRixJQUFJZCxVQUFVaEIsR0FBR1AsT0FBTyxDQUFDNkMsSUFBSS9DLGFBQWF0QyxJQUFJc0U7UUFDcEQscUNBQXFDO1FBQ3JDLE1BQU1rQixJQUFJeEMsS0FBS3lDLGNBQWMsQ0FBQ0YsR0FBR0csR0FBRyxDQUFDMUYsRUFBRXlGLGNBQWMsQ0FBQzFDLEdBQUdLLEdBQUcsQ0FBQ3lCO1FBQzdELE1BQU0sRUFBRXRCLENBQUMsRUFBRXhELENBQUMsRUFBRSxHQUFHeUYsRUFBRUcsUUFBUTtRQUMzQix5REFBeUQ7UUFDekQsSUFBSUgsRUFBRUksR0FBRyxNQUFNLENBQUNoRCxRQUFRN0MsTUFBTXdELE1BQU04QixHQUNoQyxPQUFPO1FBQ1gsT0FBTztJQUNYLEVBQ0EsT0FBT1EsT0FBTztRQUNWLE9BQU87SUFDWDtBQUNKO0FBQ0E7Ozs7Ozs7Ozs7OztDQVlDLEdBQ00sTUFBTUMsVUFBMEIsYUFBSCxHQUFJO0lBQ3BDLE1BQU1DLE9BQU87SUFDYixNQUFNQyxhQUFhO0lBQ25CLE1BQU1DLGtCQUFrQixDQUFDQyxPQUFPbkksc0RBQVdBLENBQUNpSSxXQUFXO1FBQ25ELE9BQU81SCxvRUFBY0EsQ0FBQzhILE1BQU1uSCxnQkFBZ0JHLENBQUM7SUFDakQ7SUFDQSxlQUFlO0lBQ2Z5QyxVQUFVd0UsS0FBSyxDQUFDRixlQUFlO0lBQy9CLFNBQVNHLE9BQU9GLElBQUk7UUFDaEIsTUFBTWhDLFlBQVkrQixnQkFBZ0JDO1FBQ2xDLE9BQU87WUFBRWhDO1lBQVdpQixXQUFXbEIsb0JBQW9CQztRQUFXO0lBQ2xFO0lBQ0EsT0FBTztRQUNIa0M7UUFDQUMsY0FBY3BDO1FBQ2RxQyxNQUFNbkM7UUFDTm9DLFFBQVF0QjtRQUNSdEMsT0FBT0Q7UUFDUHlELE9BQU87WUFDSEYsaUJBQWlCQTtZQUNqQk8sa0JBQWtCUDtZQUNsQmpFO1lBQ0EsZUFBZTtZQUNmc0I7WUFDQWhCO1lBQ0F6RCxlQUFlQSx3REFBQUE7WUFDZkosZUFBZUEsd0RBQUFBO1lBQ2ZKLEdBQUdBLHVEQUFBQTtRQUNQO1FBQ0FvSSxTQUFTO1lBQ0x2QyxXQUFXNkI7WUFDWFosV0FBV1k7WUFDWFcsb0JBQW9CO1lBQ3BCeEIsV0FBV2EsT0FBTztZQUNsQkcsTUFBTUY7UUFDVjtJQUNKO0FBQ0osS0FBSztBQUNMLE1BQU1XLFNBQXlCLGFBQUgsR0FBSSxLQUFNekksc0VBQVVBLENBQUNvRCxNQUFNO1FBQ25ELE9BQU87UUFDUDtZQUNJO1lBQ0E7WUFDQTtZQUNBO1NBQ0g7UUFDRCxPQUFPO1FBQ1A7WUFDSTtZQUNBO1lBQ0E7U0FDSDtRQUNELE9BQU87UUFDUDtZQUNJO1lBQ0E7WUFDQTtZQUNBO1NBQ0g7UUFDRCxPQUFPO1FBQ1A7WUFDSTtZQUNBO1lBQ0E7WUFDQTtTQUNIO0tBQ0osQ0FBQ3NGLEdBQUcsQ0FBQyxDQUFDQyxJQUFNQSxFQUFFRCxHQUFHLENBQUMsQ0FBQ0UsSUFBTTdILE9BQU82SCxLQUFJO0FBQ3JDLE1BQU1DLFNBQXlCLGFBQUgsR0FBSSxLQUFNdkksNkVBQW1CQSxDQUFDOEMsTUFBTTtRQUM1RDBGLEdBQUcvSCxPQUFPO1FBQ1ZnSSxHQUFHaEksT0FBTztRQUNWaUksR0FBRzVGLEtBQUtvQyxNQUFNLENBQUN6RSxPQUFPO0lBQzFCLEVBQUM7QUFDRCxzRUFBc0UsR0FDL0QsTUFBTWtJLG1CQUFtQyxhQUFILEdBQUksS0FBTWxKLHdFQUFZQSxDQUFDMEQsVUFBVWdCLEtBQUssRUFBRSxDQUFDeUU7UUFDbEYsTUFBTSxFQUFFN0QsQ0FBQyxFQUFFeEQsQ0FBQyxFQUFFLEdBQUdnSCxPQUFPekYsS0FBS29DLE1BQU0sQ0FBQzBELE9BQU8sQ0FBQyxFQUFFO1FBQzlDLE9BQU9ULE9BQU9wRCxHQUFHeEQ7SUFDckIsR0FBRztRQUNDc0gsS0FBSztRQUNMQyxXQUFXO1FBQ1h0SSxHQUFHc0MsS0FBS2lHLEtBQUs7UUFDYmpELEdBQUc7UUFDSE0sR0FBRztRQUNINEMsUUFBUTtRQUNSQyxNQUFNM0oseURBQU1BO0lBQ2hCLEVBQUMsSUFBSztBQUNOLHFGQUFxRixHQUM5RSxNQUFNNEosY0FBOEIsYUFBSCxHQUFJLEtBQU1QLGlCQUFpQk8sV0FBVyxJQUFJO0FBQ2xGLHFGQUFxRixHQUM5RSxNQUFNQyxnQkFBZ0MsYUFBSCxHQUFJLEtBQU1SLGlCQUFpQlEsYUFBYSxJQUFJLENBQ3RGLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsYXctd29ya3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9zZWNwMjU2azEuanM/MjkzZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFNFQ0cgc2VjcDI1NmsxLiBTZWUgW3BkZl0oaHR0cHM6Ly93d3cuc2VjZy5vcmcvc2VjMi12Mi5wZGYpLlxuICpcbiAqIEJlbG9uZ3MgdG8gS29ibGl0eiBjdXJ2ZXM6IGl0IGhhcyBlZmZpY2llbnRseS1jb21wdXRhYmxlIEdMViBlbmRvbW9ycGhpc20gz4gsXG4gKiBjaGVjayBvdXQge0BsaW5rIEVuZG9tb3JwaGlzbU9wdHN9LiBTZWVtcyB0byBiZSByaWdpZCAobm90IGJhY2tkb29yZWQpLlxuICogQG1vZHVsZVxuICovXG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5pbXBvcnQgeyBzaGEyNTYgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3NoYTIuanMnO1xuaW1wb3J0IHsgcmFuZG9tQnl0ZXMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3V0aWxzLmpzJztcbmltcG9ydCB7IGNyZWF0ZUN1cnZlIH0gZnJvbSBcIi4vX3Nob3J0d191dGlscy5qc1wiO1xuaW1wb3J0IHsgY3JlYXRlSGFzaGVyLCBpc29nZW55TWFwLCB9IGZyb20gXCIuL2Fic3RyYWN0L2hhc2gtdG8tY3VydmUuanNcIjtcbmltcG9ydCB7IEZpZWxkLCBtYXBIYXNoVG9GaWVsZCwgbW9kLCBwb3cyIH0gZnJvbSBcIi4vYWJzdHJhY3QvbW9kdWxhci5qc1wiO1xuaW1wb3J0IHsgX25vcm1GbkVsZW1lbnQsIG1hcFRvQ3VydmVTaW1wbGVTV1UsIH0gZnJvbSBcIi4vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanNcIjtcbmltcG9ydCB7IGJ5dGVzVG9OdW1iZXJCRSwgY29uY2F0Qnl0ZXMsIGVuc3VyZUJ5dGVzLCBpblJhbmdlLCBudW1iZXJUb0J5dGVzQkUsIHV0ZjhUb0J5dGVzLCB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG4vLyBTZWVtcyBsaWtlIGdlbmVyYXRvciB3YXMgcHJvZHVjZWQgZnJvbSBzb21lIHNlZWQ6XG4vLyBgUG9pbnQuQkFTRS5tdWx0aXBseShQb2ludC5Gbi5pbnYoMm4sIE4pKS50b0FmZmluZSgpLnhgXG4vLyAvLyBnaXZlcyBzaG9ydCB4IDB4M2I3OGNlNTYzZjg5YTBlZDk0MTRmNWFhMjhhZDBkOTZkNjc5NWY5YzYzblxuY29uc3Qgc2VjcDI1NmsxX0NVUlZFID0ge1xuICAgIHA6IEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZmYzJmJyksXG4gICAgbjogQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlYmFhZWRjZTZhZjQ4YTAzYmJmZDI1ZThjZDAzNjQxNDEnKSxcbiAgICBoOiBCaWdJbnQoMSksXG4gICAgYTogQmlnSW50KDApLFxuICAgIGI6IEJpZ0ludCg3KSxcbiAgICBHeDogQmlnSW50KCcweDc5YmU2NjdlZjlkY2JiYWM1NWEwNjI5NWNlODcwYjA3MDI5YmZjZGIyZGNlMjhkOTU5ZjI4MTViMTZmODE3OTgnKSxcbiAgICBHeTogQmlnSW50KCcweDQ4M2FkYTc3MjZhM2M0NjU1ZGE0ZmJmYzBlMTEwOGE4ZmQxN2I0NDhhNjg1NTQxOTljNDdkMDhmZmIxMGQ0YjgnKSxcbn07XG5jb25zdCBzZWNwMjU2azFfRU5ETyA9IHtcbiAgICBiZXRhOiBCaWdJbnQoJzB4N2FlOTZhMmI2NTdjMDcxMDZlNjQ0NzllYWMzNDM0ZTk5Y2YwNDk3NTEyZjU4OTk1YzEzOTZjMjg3MTk1MDFlZScpLFxuICAgIGJhc2lzZXM6IFtcbiAgICAgICAgW0JpZ0ludCgnMHgzMDg2ZDIyMWE3ZDQ2YmNkZTg2YzkwZTQ5Mjg0ZWIxNScpLCAtQmlnSW50KCcweGU0NDM3ZWQ2MDEwZTg4Mjg2ZjU0N2ZhOTBhYmZlNGMzJyldLFxuICAgICAgICBbQmlnSW50KCcweDExNGNhNTBmN2E4ZTJmM2Y2NTdjMTEwOGQ5ZDQ0Y2ZkOCcpLCBCaWdJbnQoJzB4MzA4NmQyMjFhN2Q0NmJjZGU4NmM5MGU0OTI4NGViMTUnKV0sXG4gICAgXSxcbn07XG5jb25zdCBfMG4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDApO1xuY29uc3QgXzFuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMik7XG4vKipcbiAqIOKImm4gPSBuXigocCsxKS80KSBmb3IgZmllbGRzIHAgPSAzIG1vZCA0LiBXZSB1bndyYXAgdGhlIGxvb3AgYW5kIG11bHRpcGx5IGJpdC1ieS1iaXQuXG4gKiAoUCsxbi80bikudG9TdHJpbmcoMikgd291bGQgcHJvZHVjZSBiaXRzIFsyMjN4IDEsIDAsIDIyeCAxLCA0eCAwLCAxMSwgMDBdXG4gKi9cbmZ1bmN0aW9uIHNxcnRNb2QoeSkge1xuICAgIGNvbnN0IFAgPSBzZWNwMjU2azFfQ1VSVkUucDtcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBjb25zdCBfM24gPSBCaWdJbnQoMyksIF82biA9IEJpZ0ludCg2KSwgXzExbiA9IEJpZ0ludCgxMSksIF8yMm4gPSBCaWdJbnQoMjIpO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGNvbnN0IF8yM24gPSBCaWdJbnQoMjMpLCBfNDRuID0gQmlnSW50KDQ0KSwgXzg4biA9IEJpZ0ludCg4OCk7XG4gICAgY29uc3QgYjIgPSAoeSAqIHkgKiB5KSAlIFA7IC8vIHheMywgMTFcbiAgICBjb25zdCBiMyA9IChiMiAqIGIyICogeSkgJSBQOyAvLyB4XjdcbiAgICBjb25zdCBiNiA9IChwb3cyKGIzLCBfM24sIFApICogYjMpICUgUDtcbiAgICBjb25zdCBiOSA9IChwb3cyKGI2LCBfM24sIFApICogYjMpICUgUDtcbiAgICBjb25zdCBiMTEgPSAocG93MihiOSwgXzJuLCBQKSAqIGIyKSAlIFA7XG4gICAgY29uc3QgYjIyID0gKHBvdzIoYjExLCBfMTFuLCBQKSAqIGIxMSkgJSBQO1xuICAgIGNvbnN0IGI0NCA9IChwb3cyKGIyMiwgXzIybiwgUCkgKiBiMjIpICUgUDtcbiAgICBjb25zdCBiODggPSAocG93MihiNDQsIF80NG4sIFApICogYjQ0KSAlIFA7XG4gICAgY29uc3QgYjE3NiA9IChwb3cyKGI4OCwgXzg4biwgUCkgKiBiODgpICUgUDtcbiAgICBjb25zdCBiMjIwID0gKHBvdzIoYjE3NiwgXzQ0biwgUCkgKiBiNDQpICUgUDtcbiAgICBjb25zdCBiMjIzID0gKHBvdzIoYjIyMCwgXzNuLCBQKSAqIGIzKSAlIFA7XG4gICAgY29uc3QgdDEgPSAocG93MihiMjIzLCBfMjNuLCBQKSAqIGIyMikgJSBQO1xuICAgIGNvbnN0IHQyID0gKHBvdzIodDEsIF82biwgUCkgKiBiMikgJSBQO1xuICAgIGNvbnN0IHJvb3QgPSBwb3cyKHQyLCBfMm4sIFApO1xuICAgIGlmICghRnBrMS5lcWwoRnBrMS5zcXIocm9vdCksIHkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgcmV0dXJuIHJvb3Q7XG59XG5jb25zdCBGcGsxID0gRmllbGQoc2VjcDI1NmsxX0NVUlZFLnAsIHsgc3FydDogc3FydE1vZCB9KTtcbi8qKlxuICogc2VjcDI1NmsxIGN1cnZlLCBFQ0RTQSBhbmQgRUNESCBtZXRob2RzLlxuICpcbiAqIEZpZWxkOiBgMm4qKjI1Nm4gLSAybioqMzJuIC0gMm4qKjluIC0gMm4qKjhuIC0gMm4qKjduIC0gMm4qKjZuIC0gMm4qKjRuIC0gMW5gXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBpbXBvcnQgeyBzZWNwMjU2azEgfSBmcm9tICdAbm9ibGUvY3VydmVzL3NlY3AyNTZrMSc7XG4gKiBjb25zdCB7IHNlY3JldEtleSwgcHVibGljS2V5IH0gPSBzZWNwMjU2azEua2V5Z2VuKCk7XG4gKiBjb25zdCBtc2cgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoJ2hlbGxvJyk7XG4gKiBjb25zdCBzaWcgPSBzZWNwMjU2azEuc2lnbihtc2csIHNlY3JldEtleSk7XG4gKiBjb25zdCBpc1ZhbGlkID0gc2VjcDI1NmsxLnZlcmlmeShzaWcsIG1zZywgcHVibGljS2V5KSA9PT0gdHJ1ZTtcbiAqIGBgYFxuICovXG5leHBvcnQgY29uc3Qgc2VjcDI1NmsxID0gY3JlYXRlQ3VydmUoeyAuLi5zZWNwMjU2azFfQ1VSVkUsIEZwOiBGcGsxLCBsb3dTOiB0cnVlLCBlbmRvOiBzZWNwMjU2azFfRU5ETyB9LCBzaGEyNTYpO1xuLy8gU2Nobm9yciBzaWduYXR1cmVzIGFyZSBzdXBlcmlvciB0byBFQ0RTQSBmcm9tIGFib3ZlLiBCZWxvdyBpcyBTY2hub3JyLXNwZWNpZmljIEJJUDAzNDAgY29kZS5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpcHMvYmxvYi9tYXN0ZXIvYmlwLTAzNDAubWVkaWF3aWtpXG4vKiogQW4gb2JqZWN0IG1hcHBpbmcgdGFncyB0byB0aGVpciB0YWdnZWQgaGFzaCBwcmVmaXggb2YgW1NIQTI1Nih0YWcpIHwgU0hBMjU2KHRhZyldICovXG5jb25zdCBUQUdHRURfSEFTSF9QUkVGSVhFUyA9IHt9O1xuZnVuY3Rpb24gdGFnZ2VkSGFzaCh0YWcsIC4uLm1lc3NhZ2VzKSB7XG4gICAgbGV0IHRhZ1AgPSBUQUdHRURfSEFTSF9QUkVGSVhFU1t0YWddO1xuICAgIGlmICh0YWdQID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgdGFnSCA9IHNoYTI1Nih1dGY4VG9CeXRlcyh0YWcpKTtcbiAgICAgICAgdGFnUCA9IGNvbmNhdEJ5dGVzKHRhZ0gsIHRhZ0gpO1xuICAgICAgICBUQUdHRURfSEFTSF9QUkVGSVhFU1t0YWddID0gdGFnUDtcbiAgICB9XG4gICAgcmV0dXJuIHNoYTI1Nihjb25jYXRCeXRlcyh0YWdQLCAuLi5tZXNzYWdlcykpO1xufVxuLy8gRUNEU0EgY29tcGFjdCBwb2ludHMgYXJlIDMzLWJ5dGUuIFNjaG5vcnIgaXMgMzI6IHdlIHN0cmlwIGZpcnN0IGJ5dGUgMHgwMiBvciAweDAzXG5jb25zdCBwb2ludFRvQnl0ZXMgPSAocG9pbnQpID0+IHBvaW50LnRvQnl0ZXModHJ1ZSkuc2xpY2UoMSk7XG5jb25zdCBQb2ludGsxID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBzZWNwMjU2azEuUG9pbnQpKCk7XG5jb25zdCBoYXNFdmVuID0gKHkpID0+IHkgJSBfMm4gPT09IF8wbjtcbi8vIENhbGN1bGF0ZSBwb2ludCwgc2NhbGFyIGFuZCBieXRlc1xuZnVuY3Rpb24gc2Nobm9yckdldEV4dFB1YktleShwcml2KSB7XG4gICAgY29uc3QgeyBGbiwgQkFTRSB9ID0gUG9pbnRrMTtcbiAgICBjb25zdCBkXyA9IF9ub3JtRm5FbGVtZW50KEZuLCBwcml2KTtcbiAgICBjb25zdCBwID0gQkFTRS5tdWx0aXBseShkXyk7IC8vIFAgPSBkJ+KLhUc7IDAgPCBkJyA8IG4gY2hlY2sgaXMgZG9uZSBpbnNpZGVcbiAgICBjb25zdCBzY2FsYXIgPSBoYXNFdmVuKHAueSkgPyBkXyA6IEZuLm5lZyhkXyk7XG4gICAgcmV0dXJuIHsgc2NhbGFyLCBieXRlczogcG9pbnRUb0J5dGVzKHApIH07XG59XG4vKipcbiAqIGxpZnRfeCBmcm9tIEJJUDM0MC4gQ29udmVydCAzMi1ieXRlIHggY29vcmRpbmF0ZSB0byBlbGxpcHRpYyBjdXJ2ZSBwb2ludC5cbiAqIEByZXR1cm5zIHZhbGlkIHBvaW50IGNoZWNrZWQgZm9yIGJlaW5nIG9uLWN1cnZlXG4gKi9cbmZ1bmN0aW9uIGxpZnRfeCh4KSB7XG4gICAgY29uc3QgRnAgPSBGcGsxO1xuICAgIGlmICghRnAuaXNWYWxpZE5vdDAoeCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB4OiBGYWlsIGlmIHgg4omlIHAnKTtcbiAgICBjb25zdCB4eCA9IEZwLmNyZWF0ZSh4ICogeCk7XG4gICAgY29uc3QgYyA9IEZwLmNyZWF0ZSh4eCAqIHggKyBCaWdJbnQoNykpOyAvLyBMZXQgYyA9IHjCsyArIDcgbW9kIHAuXG4gICAgbGV0IHkgPSBGcC5zcXJ0KGMpOyAvLyBMZXQgeSA9IGNeKHArMSkvNCBtb2QgcC4gU2FtZSBhcyBzcXJ0KCkuXG4gICAgLy8gUmV0dXJuIHRoZSB1bmlxdWUgcG9pbnQgUCBzdWNoIHRoYXQgeChQKSA9IHggYW5kXG4gICAgLy8geShQKSA9IHkgaWYgeSBtb2QgMiA9IDAgb3IgeShQKSA9IHAteSBvdGhlcndpc2UuXG4gICAgaWYgKCFoYXNFdmVuKHkpKVxuICAgICAgICB5ID0gRnAubmVnKHkpO1xuICAgIGNvbnN0IHAgPSBQb2ludGsxLmZyb21BZmZpbmUoeyB4LCB5IH0pO1xuICAgIHAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICByZXR1cm4gcDtcbn1cbmNvbnN0IG51bSA9IGJ5dGVzVG9OdW1iZXJCRTtcbi8qKlxuICogQ3JlYXRlIHRhZ2dlZCBoYXNoLCBjb252ZXJ0IGl0IHRvIGJpZ2ludCwgcmVkdWNlIG1vZHVsby1uLlxuICovXG5mdW5jdGlvbiBjaGFsbGVuZ2UoLi4uYXJncykge1xuICAgIHJldHVybiBQb2ludGsxLkZuLmNyZWF0ZShudW0odGFnZ2VkSGFzaCgnQklQMDM0MC9jaGFsbGVuZ2UnLCAuLi5hcmdzKSkpO1xufVxuLyoqXG4gKiBTY2hub3JyIHB1YmxpYyBrZXkgaXMganVzdCBgeGAgY29vcmRpbmF0ZSBvZiBQb2ludCBhcyBwZXIgQklQMzQwLlxuICovXG5mdW5jdGlvbiBzY2hub3JyR2V0UHVibGljS2V5KHNlY3JldEtleSkge1xuICAgIHJldHVybiBzY2hub3JyR2V0RXh0UHViS2V5KHNlY3JldEtleSkuYnl0ZXM7IC8vIGQnPWludChzaykuIEZhaWwgaWYgZCc9MCBvciBkJ+KJpW4uIFJldCBieXRlcyhkJ+KLhUcpXG59XG4vKipcbiAqIENyZWF0ZXMgU2Nobm9yciBzaWduYXR1cmUgYXMgcGVyIEJJUDM0MC4gVmVyaWZpZXMgaXRzZWxmIGJlZm9yZSByZXR1cm5pbmcgYW55dGhpbmcuXG4gKiBhdXhSYW5kIGlzIG9wdGlvbmFsIGFuZCBpcyBub3QgdGhlIHNvbGUgc291cmNlIG9mIGsgZ2VuZXJhdGlvbjogYmFkIENTUFJORyB3b24ndCBiZSBkYW5nZXJvdXMuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJTaWduKG1lc3NhZ2UsIHNlY3JldEtleSwgYXV4UmFuZCA9IHJhbmRvbUJ5dGVzKDMyKSkge1xuICAgIGNvbnN0IHsgRm4gfSA9IFBvaW50azE7XG4gICAgY29uc3QgbSA9IGVuc3VyZUJ5dGVzKCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgY29uc3QgeyBieXRlczogcHgsIHNjYWxhcjogZCB9ID0gc2Nobm9yckdldEV4dFB1YktleShzZWNyZXRLZXkpOyAvLyBjaGVja3MgZm9yIGlzV2l0aGluQ3VydmVPcmRlclxuICAgIGNvbnN0IGEgPSBlbnN1cmVCeXRlcygnYXV4UmFuZCcsIGF1eFJhbmQsIDMyKTsgLy8gQXV4aWxpYXJ5IHJhbmRvbSBkYXRhIGE6IGEgMzItYnl0ZSBhcnJheVxuICAgIGNvbnN0IHQgPSBGbi50b0J5dGVzKGQgXiBudW0odGFnZ2VkSGFzaCgnQklQMDM0MC9hdXgnLCBhKSkpOyAvLyBMZXQgdCBiZSB0aGUgYnl0ZS13aXNlIHhvciBvZiBieXRlcyhkKSBhbmQgaGFzaC9hdXgoYSlcbiAgICBjb25zdCByYW5kID0gdGFnZ2VkSGFzaCgnQklQMDM0MC9ub25jZScsIHQsIHB4LCBtKTsgLy8gTGV0IHJhbmQgPSBoYXNoL25vbmNlKHQgfHwgYnl0ZXMoUCkgfHwgbSlcbiAgICAvLyBMZXQgaycgPSBpbnQocmFuZCkgbW9kIG4uIEZhaWwgaWYgaycgPSAwLiBMZXQgUiA9IGsn4ouFR1xuICAgIGNvbnN0IHsgYnl0ZXM6IHJ4LCBzY2FsYXI6IGsgfSA9IHNjaG5vcnJHZXRFeHRQdWJLZXkocmFuZCk7XG4gICAgY29uc3QgZSA9IGNoYWxsZW5nZShyeCwgcHgsIG0pOyAvLyBMZXQgZSA9IGludChoYXNoL2NoYWxsZW5nZShieXRlcyhSKSB8fCBieXRlcyhQKSB8fCBtKSkgbW9kIG4uXG4gICAgY29uc3Qgc2lnID0gbmV3IFVpbnQ4QXJyYXkoNjQpOyAvLyBMZXQgc2lnID0gYnl0ZXMoUikgfHwgYnl0ZXMoKGsgKyBlZCkgbW9kIG4pLlxuICAgIHNpZy5zZXQocngsIDApO1xuICAgIHNpZy5zZXQoRm4udG9CeXRlcyhGbi5jcmVhdGUoayArIGUgKiBkKSksIDMyKTtcbiAgICAvLyBJZiBWZXJpZnkoYnl0ZXMoUCksIG0sIHNpZykgKHNlZSBiZWxvdykgcmV0dXJucyBmYWlsdXJlLCBhYm9ydFxuICAgIGlmICghc2Nobm9yclZlcmlmeShzaWcsIG0sIHB4KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduOiBJbnZhbGlkIHNpZ25hdHVyZSBwcm9kdWNlZCcpO1xuICAgIHJldHVybiBzaWc7XG59XG4vKipcbiAqIFZlcmlmaWVzIFNjaG5vcnIgc2lnbmF0dXJlLlxuICogV2lsbCBzd2FsbG93IGVycm9ycyAmIHJldHVybiBmYWxzZSBleGNlcHQgZm9yIGluaXRpYWwgdHlwZSB2YWxpZGF0aW9uIG9mIGFyZ3VtZW50cy5cbiAqL1xuZnVuY3Rpb24gc2Nobm9yclZlcmlmeShzaWduYXR1cmUsIG1lc3NhZ2UsIHB1YmxpY0tleSkge1xuICAgIGNvbnN0IHsgRm4sIEJBU0UgfSA9IFBvaW50azE7XG4gICAgY29uc3Qgc2lnID0gZW5zdXJlQnl0ZXMoJ3NpZ25hdHVyZScsIHNpZ25hdHVyZSwgNjQpO1xuICAgIGNvbnN0IG0gPSBlbnN1cmVCeXRlcygnbWVzc2FnZScsIG1lc3NhZ2UpO1xuICAgIGNvbnN0IHB1YiA9IGVuc3VyZUJ5dGVzKCdwdWJsaWNLZXknLCBwdWJsaWNLZXksIDMyKTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBQID0gbGlmdF94KG51bShwdWIpKTsgLy8gUCA9IGxpZnRfeChpbnQocGspKTsgZmFpbCBpZiB0aGF0IGZhaWxzXG4gICAgICAgIGNvbnN0IHIgPSBudW0oc2lnLnN1YmFycmF5KDAsIDMyKSk7IC8vIExldCByID0gaW50KHNpZ1swOjMyXSk7IGZhaWwgaWYgciDiiaUgcC5cbiAgICAgICAgaWYgKCFpblJhbmdlKHIsIF8xbiwgc2VjcDI1NmsxX0NVUlZFLnApKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBzID0gbnVtKHNpZy5zdWJhcnJheSgzMiwgNjQpKTsgLy8gTGV0IHMgPSBpbnQoc2lnWzMyOjY0XSk7IGZhaWwgaWYgcyDiiaUgbi5cbiAgICAgICAgaWYgKCFpblJhbmdlKHMsIF8xbiwgc2VjcDI1NmsxX0NVUlZFLm4pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyBpbnQoY2hhbGxlbmdlKGJ5dGVzKHIpfHxieXRlcyhQKXx8bSkpJW5cbiAgICAgICAgY29uc3QgZSA9IGNoYWxsZW5nZShGbi50b0J5dGVzKHIpLCBwb2ludFRvQnl0ZXMoUCksIG0pO1xuICAgICAgICAvLyBSID0gc+KLhUcgLSBl4ouFUCwgd2hlcmUgLWVQID09IChuLWUpUFxuICAgICAgICBjb25zdCBSID0gQkFTRS5tdWx0aXBseVVuc2FmZShzKS5hZGQoUC5tdWx0aXBseVVuc2FmZShGbi5uZWcoZSkpKTtcbiAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBSLnRvQWZmaW5lKCk7XG4gICAgICAgIC8vIEZhaWwgaWYgaXNfaW5maW5pdGUoUikgLyBub3QgaGFzX2V2ZW5feShSKSAvIHgoUikg4omgIHIuXG4gICAgICAgIGlmIChSLmlzMCgpIHx8ICFoYXNFdmVuKHkpIHx8IHggIT09IHIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogU2Nobm9yciBzaWduYXR1cmVzIG92ZXIgc2VjcDI1NmsxLlxuICogaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDM0MC5tZWRpYXdpa2lcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogaW1wb3J0IHsgc2Nobm9yciB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxJztcbiAqIGNvbnN0IHsgc2VjcmV0S2V5LCBwdWJsaWNLZXkgfSA9IHNjaG5vcnIua2V5Z2VuKCk7XG4gKiAvLyBjb25zdCBwdWJsaWNLZXkgPSBzY2hub3JyLmdldFB1YmxpY0tleShzZWNyZXRLZXkpO1xuICogY29uc3QgbXNnID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKCdoZWxsbycpO1xuICogY29uc3Qgc2lnID0gc2Nobm9yci5zaWduKG1zZywgc2VjcmV0S2V5KTtcbiAqIGNvbnN0IGlzVmFsaWQgPSBzY2hub3JyLnZlcmlmeShzaWcsIG1zZywgcHVibGljS2V5KTtcbiAqIGBgYFxuICovXG5leHBvcnQgY29uc3Qgc2Nobm9yciA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4ge1xuICAgIGNvbnN0IHNpemUgPSAzMjtcbiAgICBjb25zdCBzZWVkTGVuZ3RoID0gNDg7XG4gICAgY29uc3QgcmFuZG9tU2VjcmV0S2V5ID0gKHNlZWQgPSByYW5kb21CeXRlcyhzZWVkTGVuZ3RoKSkgPT4ge1xuICAgICAgICByZXR1cm4gbWFwSGFzaFRvRmllbGQoc2VlZCwgc2VjcDI1NmsxX0NVUlZFLm4pO1xuICAgIH07XG4gICAgLy8gVE9ETzogcmVtb3ZlXG4gICAgc2VjcDI1NmsxLnV0aWxzLnJhbmRvbVNlY3JldEtleTtcbiAgICBmdW5jdGlvbiBrZXlnZW4oc2VlZCkge1xuICAgICAgICBjb25zdCBzZWNyZXRLZXkgPSByYW5kb21TZWNyZXRLZXkoc2VlZCk7XG4gICAgICAgIHJldHVybiB7IHNlY3JldEtleSwgcHVibGljS2V5OiBzY2hub3JyR2V0UHVibGljS2V5KHNlY3JldEtleSkgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAga2V5Z2VuLFxuICAgICAgICBnZXRQdWJsaWNLZXk6IHNjaG5vcnJHZXRQdWJsaWNLZXksXG4gICAgICAgIHNpZ246IHNjaG5vcnJTaWduLFxuICAgICAgICB2ZXJpZnk6IHNjaG5vcnJWZXJpZnksXG4gICAgICAgIFBvaW50OiBQb2ludGsxLFxuICAgICAgICB1dGlsczoge1xuICAgICAgICAgICAgcmFuZG9tU2VjcmV0S2V5OiByYW5kb21TZWNyZXRLZXksXG4gICAgICAgICAgICByYW5kb21Qcml2YXRlS2V5OiByYW5kb21TZWNyZXRLZXksXG4gICAgICAgICAgICB0YWdnZWRIYXNoLFxuICAgICAgICAgICAgLy8gVE9ETzogcmVtb3ZlXG4gICAgICAgICAgICBsaWZ0X3gsXG4gICAgICAgICAgICBwb2ludFRvQnl0ZXMsXG4gICAgICAgICAgICBudW1iZXJUb0J5dGVzQkUsXG4gICAgICAgICAgICBieXRlc1RvTnVtYmVyQkUsXG4gICAgICAgICAgICBtb2QsXG4gICAgICAgIH0sXG4gICAgICAgIGxlbmd0aHM6IHtcbiAgICAgICAgICAgIHNlY3JldEtleTogc2l6ZSxcbiAgICAgICAgICAgIHB1YmxpY0tleTogc2l6ZSxcbiAgICAgICAgICAgIHB1YmxpY0tleUhhc1ByZWZpeDogZmFsc2UsXG4gICAgICAgICAgICBzaWduYXR1cmU6IHNpemUgKiAyLFxuICAgICAgICAgICAgc2VlZDogc2VlZExlbmd0aCxcbiAgICAgICAgfSxcbiAgICB9O1xufSkoKTtcbmNvbnN0IGlzb01hcCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gaXNvZ2VueU1hcChGcGsxLCBbXG4gICAgLy8geE51bVxuICAgIFtcbiAgICAgICAgJzB4OGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGRhYWFhYThjNycsXG4gICAgICAgICcweDdkM2Q0YzgwYmMzMjFkNWI5ZjMxNWNlYTdmZDQ0YzVkNTk1ZDJmYzBiZjYzYjkyZGZmZjEwNDRmMTdjNjU4MScsXG4gICAgICAgICcweDUzNGMzMjhkMjNmMjM0ZTZlMmE0MTNkZWNhMjVjYWVjZTQ1MDYxNDQwMzdjNDAzMTRlY2JkMGI1M2Q5ZGQyNjInLFxuICAgICAgICAnMHg4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZGFhYWFhODhjJyxcbiAgICBdLFxuICAgIC8vIHhEZW5cbiAgICBbXG4gICAgICAgICcweGQzNTc3MTE5M2Q5NDkxOGE5Y2EzNGNjYmI3YjY0MGRkODZjZDQwOTU0MmY4NDg3ZDlmZTZiNzQ1NzgxZWI0OWInLFxuICAgICAgICAnMHhlZGFkYzZmNjQzODNkYzFkZjdjNGIyZDUxYjU0MjI1NDA2ZDM2YjY0MWY1ZTQxYmJjNTJhNTY2MTJhOGM2ZDE0JyxcbiAgICAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsIC8vIExBU1QgMVxuICAgIF0sXG4gICAgLy8geU51bVxuICAgIFtcbiAgICAgICAgJzB4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGI4ZTM4ZTIzYycsXG4gICAgICAgICcweGM3NWUwYzMyZDVjYjdjMGZhOWQwYTU0YjEyYTBhNmQ1NjQ3YWIwNDZkNjg2ZGE2ZmRmZmM5MGZjMjAxZDcxYTMnLFxuICAgICAgICAnMHgyOWE2MTk0NjkxZjkxYTczNzE1MjA5ZWY2NTEyZTU3NjcyMjgzMGEyMDFiZTIwMThhNzY1ZTg1YTllY2VlOTMxJyxcbiAgICAgICAgJzB4MmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmYzOGUzOGQ4NCcsXG4gICAgXSxcbiAgICAvLyB5RGVuXG4gICAgW1xuICAgICAgICAnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZmOTNiJyxcbiAgICAgICAgJzB4N2EwNjUzNGJiOGJkYjQ5ZmQ1ZTllNjYzMjcyMmMyOTg5NDY3YzFiZmM4ZThkOTc4ZGZiNDI1ZDI2ODVjMjU3MycsXG4gICAgICAgICcweDY0ODRhYTcxNjU0NWNhMmNmM2E3MGMzZmE4ZmUzMzdlMGEzZDIxMTYyZjBkNjI5OWE3YmY4MTkyYmZkMmE3NmYnLFxuICAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJywgLy8gTEFTVCAxXG4gICAgXSxcbl0ubWFwKChpKSA9PiBpLm1hcCgoaikgPT4gQmlnSW50KGopKSkpKSgpO1xuY29uc3QgbWFwU1dVID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBtYXBUb0N1cnZlU2ltcGxlU1dVKEZwazEsIHtcbiAgICBBOiBCaWdJbnQoJzB4M2Y4NzMxYWJkZDY2MWFkY2EwOGE1NTU4ZjBmNWQyNzJlOTUzZDM2M2NiNmYwZTVkNDA1NDQ3YzAxYTQ0NDUzMycpLFxuICAgIEI6IEJpZ0ludCgnMTc3MScpLFxuICAgIFo6IEZwazEuY3JlYXRlKEJpZ0ludCgnLTExJykpLFxufSkpKCk7XG4vKiogSGFzaGluZyAvIGVuY29kaW5nIHRvIHNlY3AyNTZrMSBwb2ludHMgLyBmaWVsZC4gUkZDIDkzODAgbWV0aG9kcy4gKi9cbmV4cG9ydCBjb25zdCBzZWNwMjU2azFfaGFzaGVyID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBjcmVhdGVIYXNoZXIoc2VjcDI1NmsxLlBvaW50LCAoc2NhbGFycykgPT4ge1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gbWFwU1dVKEZwazEuY3JlYXRlKHNjYWxhcnNbMF0pKTtcbiAgICByZXR1cm4gaXNvTWFwKHgsIHkpO1xufSwge1xuICAgIERTVDogJ3NlY3AyNTZrMV9YTUQ6U0hBLTI1Nl9TU1dVX1JPXycsXG4gICAgZW5jb2RlRFNUOiAnc2VjcDI1NmsxX1hNRDpTSEEtMjU2X1NTV1VfTlVfJyxcbiAgICBwOiBGcGsxLk9SREVSLFxuICAgIG06IDEsXG4gICAgazogMTI4LFxuICAgIGV4cGFuZDogJ3htZCcsXG4gICAgaGFzaDogc2hhMjU2LFxufSkpKCk7XG4vKiogQGRlcHJlY2F0ZWQgdXNlIGBpbXBvcnQgeyBzZWNwMjU2azFfaGFzaGVyIH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9zZWNwMjU2azEuanMnO2AgKi9cbmV4cG9ydCBjb25zdCBoYXNoVG9DdXJ2ZSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gc2VjcDI1NmsxX2hhc2hlci5oYXNoVG9DdXJ2ZSkoKTtcbi8qKiBAZGVwcmVjYXRlZCB1c2UgYGltcG9ydCB7IHNlY3AyNTZrMV9oYXNoZXIgfSBmcm9tICdAbm9ibGUvY3VydmVzL3NlY3AyNTZrMS5qcyc7YCAqL1xuZXhwb3J0IGNvbnN0IGVuY29kZVRvQ3VydmUgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHNlY3AyNTZrMV9oYXNoZXIuZW5jb2RlVG9DdXJ2ZSkoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlY3AyNTZrMS5qcy5tYXAiXSwibmFtZXMiOlsic2hhMjU2IiwicmFuZG9tQnl0ZXMiLCJjcmVhdGVDdXJ2ZSIsImNyZWF0ZUhhc2hlciIsImlzb2dlbnlNYXAiLCJGaWVsZCIsIm1hcEhhc2hUb0ZpZWxkIiwibW9kIiwicG93MiIsIl9ub3JtRm5FbGVtZW50IiwibWFwVG9DdXJ2ZVNpbXBsZVNXVSIsImJ5dGVzVG9OdW1iZXJCRSIsImNvbmNhdEJ5dGVzIiwiZW5zdXJlQnl0ZXMiLCJpblJhbmdlIiwibnVtYmVyVG9CeXRlc0JFIiwidXRmOFRvQnl0ZXMiLCJzZWNwMjU2azFfQ1VSVkUiLCJwIiwiQmlnSW50IiwibiIsImgiLCJhIiwiYiIsIkd4IiwiR3kiLCJzZWNwMjU2azFfRU5ETyIsImJldGEiLCJiYXNpc2VzIiwiXzBuIiwiXzFuIiwiXzJuIiwic3FydE1vZCIsInkiLCJQIiwiXzNuIiwiXzZuIiwiXzExbiIsIl8yMm4iLCJfMjNuIiwiXzQ0biIsIl84OG4iLCJiMiIsImIzIiwiYjYiLCJiOSIsImIxMSIsImIyMiIsImI0NCIsImI4OCIsImIxNzYiLCJiMjIwIiwiYjIyMyIsInQxIiwidDIiLCJyb290IiwiRnBrMSIsImVxbCIsInNxciIsIkVycm9yIiwic3FydCIsInNlY3AyNTZrMSIsIkZwIiwibG93UyIsImVuZG8iLCJUQUdHRURfSEFTSF9QUkVGSVhFUyIsInRhZ2dlZEhhc2giLCJ0YWciLCJtZXNzYWdlcyIsInRhZ1AiLCJ1bmRlZmluZWQiLCJ0YWdIIiwicG9pbnRUb0J5dGVzIiwicG9pbnQiLCJ0b0J5dGVzIiwic2xpY2UiLCJQb2ludGsxIiwiUG9pbnQiLCJoYXNFdmVuIiwic2Nobm9yckdldEV4dFB1YktleSIsInByaXYiLCJGbiIsIkJBU0UiLCJkXyIsIm11bHRpcGx5Iiwic2NhbGFyIiwibmVnIiwiYnl0ZXMiLCJsaWZ0X3giLCJ4IiwiaXNWYWxpZE5vdDAiLCJ4eCIsImNyZWF0ZSIsImMiLCJmcm9tQWZmaW5lIiwiYXNzZXJ0VmFsaWRpdHkiLCJudW0iLCJjaGFsbGVuZ2UiLCJhcmdzIiwic2Nobm9yckdldFB1YmxpY0tleSIsInNlY3JldEtleSIsInNjaG5vcnJTaWduIiwibWVzc2FnZSIsImF1eFJhbmQiLCJtIiwicHgiLCJkIiwidCIsInJhbmQiLCJyeCIsImsiLCJlIiwic2lnIiwiVWludDhBcnJheSIsInNldCIsInNjaG5vcnJWZXJpZnkiLCJzaWduYXR1cmUiLCJwdWJsaWNLZXkiLCJwdWIiLCJyIiwic3ViYXJyYXkiLCJzIiwiUiIsIm11bHRpcGx5VW5zYWZlIiwiYWRkIiwidG9BZmZpbmUiLCJpczAiLCJlcnJvciIsInNjaG5vcnIiLCJzaXplIiwic2VlZExlbmd0aCIsInJhbmRvbVNlY3JldEtleSIsInNlZWQiLCJ1dGlscyIsImtleWdlbiIsImdldFB1YmxpY0tleSIsInNpZ24iLCJ2ZXJpZnkiLCJyYW5kb21Qcml2YXRlS2V5IiwibGVuZ3RocyIsInB1YmxpY0tleUhhc1ByZWZpeCIsImlzb01hcCIsIm1hcCIsImkiLCJqIiwibWFwU1dVIiwiQSIsIkIiLCJaIiwic2VjcDI1NmsxX2hhc2hlciIsInNjYWxhcnMiLCJEU1QiLCJlbmNvZGVEU1QiLCJPUkRFUiIsImV4cGFuZCIsImhhc2giLCJoYXNoVG9DdXJ2ZSIsImVuY29kZVRvQ3VydmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/secp256k1.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/utils.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/utils.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _abool2: () => (/* binding */ _abool2),\n/* harmony export */   _abytes2: () => (/* binding */ _abytes2),\n/* harmony export */   _validateObject: () => (/* binding */ _validateObject),\n/* harmony export */   aInRange: () => (/* binding */ aInRange),\n/* harmony export */   abool: () => (/* binding */ abool),\n/* harmony export */   abytes: () => (/* reexport safe */ _noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes),\n/* harmony export */   anumber: () => (/* reexport safe */ _noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.anumber),\n/* harmony export */   asciiToBytes: () => (/* binding */ asciiToBytes),\n/* harmony export */   bitGet: () => (/* binding */ bitGet),\n/* harmony export */   bitLen: () => (/* binding */ bitLen),\n/* harmony export */   bitMask: () => (/* binding */ bitMask),\n/* harmony export */   bitSet: () => (/* binding */ bitSet),\n/* harmony export */   bytesToHex: () => (/* reexport safe */ _noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToHex),\n/* harmony export */   bytesToNumberBE: () => (/* binding */ bytesToNumberBE),\n/* harmony export */   bytesToNumberLE: () => (/* binding */ bytesToNumberLE),\n/* harmony export */   bytesToUtf8: () => (/* reexport safe */ _noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToUtf8),\n/* harmony export */   concatBytes: () => (/* reexport safe */ _noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes),\n/* harmony export */   copyBytes: () => (/* binding */ copyBytes),\n/* harmony export */   createHmacDrbg: () => (/* binding */ createHmacDrbg),\n/* harmony export */   ensureBytes: () => (/* binding */ ensureBytes),\n/* harmony export */   equalBytes: () => (/* binding */ equalBytes),\n/* harmony export */   hexToBytes: () => (/* reexport safe */ _noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.hexToBytes),\n/* harmony export */   hexToNumber: () => (/* binding */ hexToNumber),\n/* harmony export */   inRange: () => (/* binding */ inRange),\n/* harmony export */   isBytes: () => (/* reexport safe */ _noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.isBytes),\n/* harmony export */   isHash: () => (/* binding */ isHash),\n/* harmony export */   memoized: () => (/* binding */ memoized),\n/* harmony export */   notImplemented: () => (/* binding */ notImplemented),\n/* harmony export */   numberToBytesBE: () => (/* binding */ numberToBytesBE),\n/* harmony export */   numberToBytesLE: () => (/* binding */ numberToBytesLE),\n/* harmony export */   numberToHexUnpadded: () => (/* binding */ numberToHexUnpadded),\n/* harmony export */   numberToVarBytesBE: () => (/* binding */ numberToVarBytesBE),\n/* harmony export */   randomBytes: () => (/* reexport safe */ _noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.randomBytes),\n/* harmony export */   utf8ToBytes: () => (/* reexport safe */ _noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes),\n/* harmony export */   validateObject: () => (/* binding */ validateObject)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/utils.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/utils.js\");\n/**\n * Hex, bytes and number utilities.\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nfunction abool(title, value) {\n    if (typeof value !== \"boolean\") throw new Error(title + \" boolean expected, got \" + value);\n}\n// tmp name until v2\nfunction _abool2(value, title = \"\") {\n    if (typeof value !== \"boolean\") {\n        const prefix = title && `\"${title}\"`;\n        throw new Error(prefix + \"expected boolean, got type=\" + typeof value);\n    }\n    return value;\n}\n// tmp name until v2\n/** Asserts something is Uint8Array. */ function _abytes2(value, length, title = \"\") {\n    const bytes = (0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.isBytes)(value);\n    const len = value?.length;\n    const needsLen = length !== undefined;\n    if (!bytes || needsLen && len !== length) {\n        const prefix = title && `\"${title}\" `;\n        const ofLen = needsLen ? ` of length ${length}` : \"\";\n        const got = bytes ? `length=${len}` : `type=${typeof value}`;\n        throw new Error(prefix + \"expected Uint8Array\" + ofLen + \", got \" + got);\n    }\n    return value;\n}\n// Used in weierstrass, der\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? \"0\" + hex : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    return hex === \"\" ? _0n : BigInt(\"0x\" + hex); // Big Endian\n}\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber((0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(bytes));\n}\nfunction bytesToNumberLE(bytes) {\n    (0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(bytes);\n    return hexToNumber((0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(Uint8Array.from(bytes).reverse()));\n}\nfunction numberToBytesBE(n, len) {\n    return (0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(n.toString(16).padStart(len * 2, \"0\"));\n}\nfunction numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n    return (0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'secret key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */ function ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === \"string\") {\n        try {\n            res = (0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(hex);\n        } catch (e) {\n            throw new Error(title + \" must be hex string or Uint8Array, cause: \" + e);\n        }\n    } else if ((0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.isBytes)(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    } else {\n        throw new Error(title + \" must be hex string or Uint8Array\");\n    }\n    const len = res.length;\n    if (typeof expectedLength === \"number\" && len !== expectedLength) throw new Error(title + \" of length \" + expectedLength + \" expected, got \" + len);\n    return res;\n}\n// Compares 2 u8a-s in kinda constant time\nfunction equalBytes(a, b) {\n    if (a.length !== b.length) return false;\n    let diff = 0;\n    for(let i = 0; i < a.length; i++)diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n/**\n * Copies Uint8Array. We can't use u8a.slice(), because u8a can be Buffer,\n * and Buffer#slice creates mutable copy. Never use Buffers!\n */ function copyBytes(bytes) {\n    return Uint8Array.from(bytes);\n}\n/**\n * Decodes 7-bit ASCII string to Uint8Array, throws on non-ascii symbols\n * Should be safe to use for things expected to be ASCII.\n * Returns exact same result as utf8ToBytes for ASCII or throws.\n */ function asciiToBytes(ascii) {\n    return Uint8Array.from(ascii, (c, i)=>{\n        const charCode = c.charCodeAt(0);\n        if (c.length !== 1 || charCode > 127) {\n            throw new Error(`string contains non-ASCII character \"${ascii[i]}\" with code ${charCode} at position ${i}`);\n        }\n        return charCode;\n    });\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */ // export const utf8ToBytes: typeof utf8ToBytes_ = utf8ToBytes_;\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */ // export const bytesToUtf8: typeof bytesToUtf8_ = bytesToUtf8_;\n// Is positive bigint\nconst isPosBig = (n)=>typeof n === \"bigint\" && _0n <= n;\nfunction inRange(n, min, max) {\n    return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n}\n/**\n * Asserts min <= n < max. NOTE: It's < max and not <= max.\n * @example\n * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\n */ function aInRange(title, n, min, max) {\n    // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\n    // consider P=256n, min=0n, max=P\n    // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\n    // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\n    // - our way is the cleanest:               `inRange('x', x, 0n, P)\n    if (!inRange(n, min, max)) throw new Error(\"expected valid \" + title + \": \" + min + \" <= n < \" + max + \", got \" + n);\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n * TODO: merge with nLength in modular\n */ function bitLen(n) {\n    let len;\n    for(len = 0; n > _0n; n >>= _1n, len += 1);\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */ function bitGet(n, pos) {\n    return n >> BigInt(pos) & _1n;\n}\n/**\n * Sets single bit at position.\n */ function bitSet(n, pos, value) {\n    return n | (value ? _1n : _0n) << BigInt(pos);\n}\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */ const bitMask = (n)=>(_1n << BigInt(n)) - _1n;\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */ function createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== \"number\" || hashLen < 2) throw new Error(\"hashLen must be a number\");\n    if (typeof qByteLen !== \"number\" || qByteLen < 2) throw new Error(\"qByteLen must be a number\");\n    if (typeof hmacFn !== \"function\") throw new Error(\"hmacFn must be a function\");\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    const u8n = (len)=>new Uint8Array(len); // creates Uint8Array\n    const u8of = (byte)=>Uint8Array.of(byte); // another shortcut\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = ()=>{\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b)=>hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n(0))=>{\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8of(0x00), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0) return;\n        k = h(u8of(0x01), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = ()=>{\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000) throw new Error(\"drbg: tried 1000 values\");\n        let len = 0;\n        const out = [];\n        while(len < qByteLen){\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return (0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...out);\n    };\n    const genUntil = (seed, pred)=>{\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while(!(res = pred(gen())))reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val)=>typeof val === \"bigint\",\n    function: (val)=>typeof val === \"function\",\n    boolean: (val)=>typeof val === \"boolean\",\n    string: (val)=>typeof val === \"string\",\n    stringOrUint8Array: (val)=>typeof val === \"string\" || (0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.isBytes)(val),\n    isSafeInteger: (val)=>Number.isSafeInteger(val),\n    array: (val)=>Array.isArray(val),\n    field: (val, object)=>object.Fp.isValid(val),\n    hash: (val)=>typeof val === \"function\" && Number.isSafeInteger(val.outputLen)\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional)=>{\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== \"function\") throw new Error(\"invalid validator function\");\n        const val = object[fieldName];\n        if (isOptional && val === undefined) return;\n        if (!checkVal(val, object)) {\n            throw new Error(\"param \" + String(fieldName) + \" is invalid. Expected \" + type + \", got \" + val);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))checkField(fieldName, type, true);\n    return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\nfunction isHash(val) {\n    return typeof val === \"function\" && Number.isSafeInteger(val.outputLen);\n}\nfunction _validateObject(object, fields, optFields = {}) {\n    if (!object || typeof object !== \"object\") throw new Error(\"expected valid options object\");\n    function checkField(fieldName, expectedType, isOpt) {\n        const val = object[fieldName];\n        if (isOpt && val === undefined) return;\n        const current = typeof val;\n        if (current !== expectedType || val === null) throw new Error(`param \"${fieldName}\" is invalid: expected ${expectedType}, got ${current}`);\n    }\n    Object.entries(fields).forEach(([k, v])=>checkField(k, v, false));\n    Object.entries(optFields).forEach(([k, v])=>checkField(k, v, true));\n}\n/**\n * throws not implemented error\n */ const notImplemented = ()=>{\n    throw new Error(\"not implemented\");\n};\n/**\n * Memoizes (caches) computation result.\n * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\n */ function memoized(fn) {\n    const map = new WeakMap();\n    return (arg, ...args)=>{\n        const val = map.get(arg);\n        if (val !== undefined) return val;\n        const computed = fn(arg, ...args);\n        map.set(arg, computed);\n        return computed;\n    };\n} //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7O0NBR0MsR0FDRCxvRUFBb0UsR0FDZ0c7QUFDckI7QUFDL0ksTUFBTWMsTUFBTSxhQUFhLEdBQUdDLE9BQU87QUFDbkMsTUFBTUMsTUFBTSxhQUFhLEdBQUdELE9BQU87QUFDNUIsU0FBU0UsTUFBTUMsS0FBSyxFQUFFQyxLQUFLO0lBQzlCLElBQUksT0FBT0EsVUFBVSxXQUNqQixNQUFNLElBQUlDLE1BQU1GLFFBQVEsNEJBQTRCQztBQUM1RDtBQUNBLG9CQUFvQjtBQUNiLFNBQVNFLFFBQVFGLEtBQUssRUFBRUQsUUFBUSxFQUFFO0lBQ3JDLElBQUksT0FBT0MsVUFBVSxXQUFXO1FBQzVCLE1BQU1HLFNBQVNKLFNBQVMsQ0FBQyxDQUFDLEVBQUVBLE1BQU0sQ0FBQyxDQUFDO1FBQ3BDLE1BQU0sSUFBSUUsTUFBTUUsU0FBUyxnQ0FBZ0MsT0FBT0g7SUFDcEU7SUFDQSxPQUFPQTtBQUNYO0FBQ0Esb0JBQW9CO0FBQ3BCLHFDQUFxQyxHQUM5QixTQUFTSSxTQUFTSixLQUFLLEVBQUVLLE1BQU0sRUFBRU4sUUFBUSxFQUFFO0lBQzlDLE1BQU1PLFFBQVFoQiwrREFBUUEsQ0FBQ1U7SUFDdkIsTUFBTU8sTUFBTVAsT0FBT0s7SUFDbkIsTUFBTUcsV0FBV0gsV0FBV0k7SUFDNUIsSUFBSSxDQUFDSCxTQUFVRSxZQUFZRCxRQUFRRixRQUFTO1FBQ3hDLE1BQU1GLFNBQVNKLFNBQVMsQ0FBQyxDQUFDLEVBQUVBLE1BQU0sRUFBRSxDQUFDO1FBQ3JDLE1BQU1XLFFBQVFGLFdBQVcsQ0FBQyxXQUFXLEVBQUVILE9BQU8sQ0FBQyxHQUFHO1FBQ2xELE1BQU1NLE1BQU1MLFFBQVEsQ0FBQyxPQUFPLEVBQUVDLElBQUksQ0FBQyxHQUFH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QUFNaEMsTUFBTVcsTUFBTSxDQUFDUyxVQUFVO1FBQzdCLElBQUlZLFNBQVNoQyxRQUFRbkUsV0FDakI7UUFDSixNQUFNb0csVUFBVSxPQUFPakM7UUFDdkIsSUFBSWlDLFlBQVlGLGdCQUFnQi9CLFFBQVEsTUFDcEMsTUFBTSxJQUFJM0UsTUFBTSxDQUFDLE9BQU8sRUFBRStGLFVBQVUsdUJBQXVCLEVBQUVXLGFBQWEsTUFBTSxFQUFFRSxRQUFRLENBQUM7SUFDbkc7SUFDQVIsT0FBT0MsT0FBTyxDQUFDRyxRQUFRSyxPQUFPLENBQUMsQ0FBQyxDQUFDakQsR0FBR0QsRUFBRSxHQUFLbUMsV0FBV2xDLEdBQUdELEdBQUc7SUFDNUR5QyxPQUFPQyxPQUFPLENBQUNJLFdBQVdJLE9BQU8sQ0FBQyxDQUFDLENBQUNqRCxHQUFHRCxFQUFFLEdBQUttQyxXQUFXbEMsR0FBR0QsR0FBRztBQUNuRTtBQUNBOztDQUVDLEdBQ00sTUFBTW1ELGlCQUFpQjtJQUMxQixNQUFNLElBQUk5RyxNQUFNO0FBQ3BCLEVBQUU7QUFDRjs7O0NBR0MsR0FDTSxTQUFTK0csU0FBU0MsRUFBRTtJQUN2QixNQUFNQyxNQUFNLElBQUlDO0lBQ2hCLE9BQU8sQ0FBQ0MsS0FBSyxHQUFHQztRQUNaLE1BQU16QyxNQUFNc0MsSUFBSUksR0FBRyxDQUFDRjtRQUNwQixJQUFJeEMsUUFBUW5FLFdBQ1IsT0FBT21FO1FBQ1gsTUFBTTJDLFdBQVdOLEdBQUdHLFFBQVFDO1FBQzVCSCxJQUFJTSxHQUFHLENBQUNKLEtBQUtHO1FBQ2IsT0FBT0E7SUFDWDtBQUNKLEVBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xhdy13b3Jrcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dlYjMuanMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL3V0aWxzLmpzPzNjMGIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBIZXgsIGJ5dGVzIGFuZCBudW1iZXIgdXRpbGl0aWVzLlxuICogQG1vZHVsZVxuICovXG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5pbXBvcnQgeyBhYnl0ZXMgYXMgYWJ5dGVzXywgYnl0ZXNUb0hleCBhcyBieXRlc1RvSGV4XywgY29uY2F0Qnl0ZXMgYXMgY29uY2F0Qnl0ZXNfLCBoZXhUb0J5dGVzIGFzIGhleFRvQnl0ZXNfLCBpc0J5dGVzIGFzIGlzQnl0ZXNfLCB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvdXRpbHMuanMnO1xuZXhwb3J0IHsgYWJ5dGVzLCBhbnVtYmVyLCBieXRlc1RvSGV4LCBieXRlc1RvVXRmOCwgY29uY2F0Qnl0ZXMsIGhleFRvQnl0ZXMsIGlzQnl0ZXMsIHJhbmRvbUJ5dGVzLCB1dGY4VG9CeXRlcywgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3V0aWxzLmpzJztcbmNvbnN0IF8wbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDEpO1xuZXhwb3J0IGZ1bmN0aW9uIGFib29sKHRpdGxlLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRpdGxlICsgJyBib29sZWFuIGV4cGVjdGVkLCBnb3QgJyArIHZhbHVlKTtcbn1cbi8vIHRtcCBuYW1lIHVudGlsIHYyXG5leHBvcnQgZnVuY3Rpb24gX2Fib29sMih2YWx1ZSwgdGl0bGUgPSAnJykge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJykge1xuICAgICAgICBjb25zdCBwcmVmaXggPSB0aXRsZSAmJiBgXCIke3RpdGxlfVwiYDtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByZWZpeCArICdleHBlY3RlZCBib29sZWFuLCBnb3QgdHlwZT0nICsgdHlwZW9mIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuLy8gdG1wIG5hbWUgdW50aWwgdjJcbi8qKiBBc3NlcnRzIHNvbWV0aGluZyBpcyBVaW50OEFycmF5LiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9hYnl0ZXMyKHZhbHVlLCBsZW5ndGgsIHRpdGxlID0gJycpIHtcbiAgICBjb25zdCBieXRlcyA9IGlzQnl0ZXNfKHZhbHVlKTtcbiAgICBjb25zdCBsZW4gPSB2YWx1ZT8ubGVuZ3RoO1xuICAgIGNvbnN0IG5lZWRzTGVuID0gbGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgaWYgKCFieXRlcyB8fCAobmVlZHNMZW4gJiYgbGVuICE9PSBsZW5ndGgpKSB7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IHRpdGxlICYmIGBcIiR7dGl0bGV9XCIgYDtcbiAgICAgICAgY29uc3Qgb2ZMZW4gPSBuZWVkc0xlbiA/IGAgb2YgbGVuZ3RoICR7bGVuZ3RofWAgOiAnJztcbiAgICAgICAgY29uc3QgZ290ID0gYnl0ZXMgPyBgbGVuZ3RoPSR7bGVufWAgOiBgdHlwZT0ke3R5cGVvZiB2YWx1ZX1gO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJlZml4ICsgJ2V4cGVjdGVkIFVpbnQ4QXJyYXknICsgb2ZMZW4gKyAnLCBnb3QgJyArIGdvdCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8vIFVzZWQgaW4gd2VpZXJzdHJhc3MsIGRlclxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclRvSGV4VW5wYWRkZWQobnVtKSB7XG4gICAgY29uc3QgaGV4ID0gbnVtLnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gaGV4Lmxlbmd0aCAmIDEgPyAnMCcgKyBoZXggOiBoZXg7XG59XG5leHBvcnQgZnVuY3Rpb24gaGV4VG9OdW1iZXIoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgcmV0dXJuIGhleCA9PT0gJycgPyBfMG4gOiBCaWdJbnQoJzB4JyArIGhleCk7IC8vIEJpZyBFbmRpYW5cbn1cbi8vIEJFOiBCaWcgRW5kaWFuLCBMRTogTGl0dGxlIEVuZGlhblxuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXJCRShieXRlcykge1xuICAgIHJldHVybiBoZXhUb051bWJlcihieXRlc1RvSGV4XyhieXRlcykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXJMRShieXRlcykge1xuICAgIGFieXRlc18oYnl0ZXMpO1xuICAgIHJldHVybiBoZXhUb051bWJlcihieXRlc1RvSGV4XyhVaW50OEFycmF5LmZyb20oYnl0ZXMpLnJldmVyc2UoKSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclRvQnl0ZXNCRShuLCBsZW4pIHtcbiAgICByZXR1cm4gaGV4VG9CeXRlc18obi50b1N0cmluZygxNikucGFkU3RhcnQobGVuICogMiwgJzAnKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9CeXRlc0xFKG4sIGxlbikge1xuICAgIHJldHVybiBudW1iZXJUb0J5dGVzQkUobiwgbGVuKS5yZXZlcnNlKCk7XG59XG4vLyBVbnBhZGRlZCwgcmFyZWx5IHVzZWRcbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb1ZhckJ5dGVzQkUobikge1xuICAgIHJldHVybiBoZXhUb0J5dGVzXyhudW1iZXJUb0hleFVucGFkZGVkKG4pKTtcbn1cbi8qKlxuICogVGFrZXMgaGV4IHN0cmluZyBvciBVaW50OEFycmF5LCBjb252ZXJ0cyB0byBVaW50OEFycmF5LlxuICogVmFsaWRhdGVzIG91dHB1dCBsZW5ndGguXG4gKiBXaWxsIHRocm93IGVycm9yIGZvciBvdGhlciB0eXBlcy5cbiAqIEBwYXJhbSB0aXRsZSBkZXNjcmlwdGl2ZSB0aXRsZSBmb3IgYW4gZXJyb3IgZS5nLiAnc2VjcmV0IGtleSdcbiAqIEBwYXJhbSBoZXggaGV4IHN0cmluZyBvciBVaW50OEFycmF5XG4gKiBAcGFyYW0gZXhwZWN0ZWRMZW5ndGggb3B0aW9uYWwsIHdpbGwgY29tcGFyZSB0byByZXN1bHQgYXJyYXkncyBsZW5ndGhcbiAqIEByZXR1cm5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVCeXRlcyh0aXRsZSwgaGV4LCBleHBlY3RlZExlbmd0aCkge1xuICAgIGxldCByZXM7XG4gICAgaWYgKHR5cGVvZiBoZXggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXMgPSBoZXhUb0J5dGVzXyhoZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGl0bGUgKyAnIG11c3QgYmUgaGV4IHN0cmluZyBvciBVaW50OEFycmF5LCBjYXVzZTogJyArIGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQnl0ZXNfKGhleCkpIHtcbiAgICAgICAgLy8gVWludDhBcnJheS5mcm9tKCkgaW5zdGVhZCBvZiBoYXNoLnNsaWNlKCkgYmVjYXVzZSBub2RlLmpzIEJ1ZmZlclxuICAgICAgICAvLyBpcyBpbnN0YW5jZSBvZiBVaW50OEFycmF5LCBhbmQgaXRzIHNsaWNlKCkgY3JlYXRlcyAqKm11dGFibGUqKiBjb3B5XG4gICAgICAgIHJlcyA9IFVpbnQ4QXJyYXkuZnJvbShoZXgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRpdGxlICsgJyBtdXN0IGJlIGhleCBzdHJpbmcgb3IgVWludDhBcnJheScpO1xuICAgIH1cbiAgICBjb25zdCBsZW4gPSByZXMubGVuZ3RoO1xuICAgIGlmICh0eXBlb2YgZXhwZWN0ZWRMZW5ndGggPT09ICdudW1iZXInICYmIGxlbiAhPT0gZXhwZWN0ZWRMZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcih0aXRsZSArICcgb2YgbGVuZ3RoICcgKyBleHBlY3RlZExlbmd0aCArICcgZXhwZWN0ZWQsIGdvdCAnICsgbGVuKTtcbiAgICByZXR1cm4gcmVzO1xufVxuLy8gQ29tcGFyZXMgMiB1OGEtcyBpbiBraW5kYSBjb25zdGFudCB0aW1lXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxCeXRlcyhhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBkaWZmID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICAgIGRpZmYgfD0gYVtpXSBeIGJbaV07XG4gICAgcmV0dXJuIGRpZmYgPT09IDA7XG59XG4vKipcbiAqIENvcGllcyBVaW50OEFycmF5LiBXZSBjYW4ndCB1c2UgdThhLnNsaWNlKCksIGJlY2F1c2UgdThhIGNhbiBiZSBCdWZmZXIsXG4gKiBhbmQgQnVmZmVyI3NsaWNlIGNyZWF0ZXMgbXV0YWJsZSBjb3B5LiBOZXZlciB1c2UgQnVmZmVycyFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvcHlCeXRlcyhieXRlcykge1xuICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oYnl0ZXMpO1xufVxuLyoqXG4gKiBEZWNvZGVzIDctYml0IEFTQ0lJIHN0cmluZyB0byBVaW50OEFycmF5LCB0aHJvd3Mgb24gbm9uLWFzY2lpIHN5bWJvbHNcbiAqIFNob3VsZCBiZSBzYWZlIHRvIHVzZSBmb3IgdGhpbmdzIGV4cGVjdGVkIHRvIGJlIEFTQ0lJLlxuICogUmV0dXJucyBleGFjdCBzYW1lIHJlc3VsdCBhcyB1dGY4VG9CeXRlcyBmb3IgQVNDSUkgb3IgdGhyb3dzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNjaWlUb0J5dGVzKGFzY2lpKSB7XG4gICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShhc2NpaSwgKGMsIGkpID0+IHtcbiAgICAgICAgY29uc3QgY2hhckNvZGUgPSBjLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIGlmIChjLmxlbmd0aCAhPT0gMSB8fCBjaGFyQ29kZSA+IDEyNykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzdHJpbmcgY29udGFpbnMgbm9uLUFTQ0lJIGNoYXJhY3RlciBcIiR7YXNjaWlbaV19XCIgd2l0aCBjb2RlICR7Y2hhckNvZGV9IGF0IHBvc2l0aW9uICR7aX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhckNvZGU7XG4gICAgfSk7XG59XG4vKipcbiAqIEBleGFtcGxlIHV0ZjhUb0J5dGVzKCdhYmMnKSAvLyBuZXcgVWludDhBcnJheShbOTcsIDk4LCA5OV0pXG4gKi9cbi8vIGV4cG9ydCBjb25zdCB1dGY4VG9CeXRlczogdHlwZW9mIHV0ZjhUb0J5dGVzXyA9IHV0ZjhUb0J5dGVzXztcbi8qKlxuICogQ29udmVydHMgYnl0ZXMgdG8gc3RyaW5nIHVzaW5nIFVURjggZW5jb2RpbmcuXG4gKiBAZXhhbXBsZSBieXRlc1RvVXRmOChVaW50OEFycmF5LmZyb20oWzk3LCA5OCwgOTldKSkgLy8gJ2FiYydcbiAqL1xuLy8gZXhwb3J0IGNvbnN0IGJ5dGVzVG9VdGY4OiB0eXBlb2YgYnl0ZXNUb1V0ZjhfID0gYnl0ZXNUb1V0ZjhfO1xuLy8gSXMgcG9zaXRpdmUgYmlnaW50XG5jb25zdCBpc1Bvc0JpZyA9IChuKSA9PiB0eXBlb2YgbiA9PT0gJ2JpZ2ludCcgJiYgXzBuIDw9IG47XG5leHBvcnQgZnVuY3Rpb24gaW5SYW5nZShuLCBtaW4sIG1heCkge1xuICAgIHJldHVybiBpc1Bvc0JpZyhuKSAmJiBpc1Bvc0JpZyhtaW4pICYmIGlzUG9zQmlnKG1heCkgJiYgbWluIDw9IG4gJiYgbiA8IG1heDtcbn1cbi8qKlxuICogQXNzZXJ0cyBtaW4gPD0gbiA8IG1heC4gTk9URTogSXQncyA8IG1heCBhbmQgbm90IDw9IG1heC5cbiAqIEBleGFtcGxlXG4gKiBhSW5SYW5nZSgneCcsIHgsIDFuLCAyNTZuKTsgLy8gd291bGQgYXNzdW1lIHggaXMgaW4gKDFuLi4yNTVuKVxuICovXG5leHBvcnQgZnVuY3Rpb24gYUluUmFuZ2UodGl0bGUsIG4sIG1pbiwgbWF4KSB7XG4gICAgLy8gV2h5IG1pbiA8PSBuIDwgbWF4IGFuZCBub3QgYSAobWluIDwgbiA8IG1heCkgT1IgYiAobWluIDw9IG4gPD0gbWF4KT9cbiAgICAvLyBjb25zaWRlciBQPTI1Nm4sIG1pbj0wbiwgbWF4PVBcbiAgICAvLyAtIGEgZm9yIG1pbj0wIHdvdWxkIHJlcXVpcmUgLTE6ICAgICAgICAgIGBpblJhbmdlKCd4JywgeCwgLTFuLCBQKWBcbiAgICAvLyAtIGIgd291bGQgY29tbW9ubHkgcmVxdWlyZSBzdWJ0cmFjdGlvbjogIGBpblJhbmdlKCd4JywgeCwgMG4sIFAgLSAxbilgXG4gICAgLy8gLSBvdXIgd2F5IGlzIHRoZSBjbGVhbmVzdDogICAgICAgICAgICAgICBgaW5SYW5nZSgneCcsIHgsIDBuLCBQKVxuICAgIGlmICghaW5SYW5nZShuLCBtaW4sIG1heCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgdmFsaWQgJyArIHRpdGxlICsgJzogJyArIG1pbiArICcgPD0gbiA8ICcgKyBtYXggKyAnLCBnb3QgJyArIG4pO1xufVxuLy8gQml0IG9wZXJhdGlvbnNcbi8qKlxuICogQ2FsY3VsYXRlcyBhbW91bnQgb2YgYml0cyBpbiBhIGJpZ2ludC5cbiAqIFNhbWUgYXMgYG4udG9TdHJpbmcoMikubGVuZ3RoYFxuICogVE9ETzogbWVyZ2Ugd2l0aCBuTGVuZ3RoIGluIG1vZHVsYXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpdExlbihuKSB7XG4gICAgbGV0IGxlbjtcbiAgICBmb3IgKGxlbiA9IDA7IG4gPiBfMG47IG4gPj49IF8xbiwgbGVuICs9IDEpXG4gICAgICAgIDtcbiAgICByZXR1cm4gbGVuO1xufVxuLyoqXG4gKiBHZXRzIHNpbmdsZSBiaXQgYXQgcG9zaXRpb24uXG4gKiBOT1RFOiBmaXJzdCBiaXQgcG9zaXRpb24gaXMgMCAoc2FtZSBhcyBhcnJheXMpXG4gKiBTYW1lIGFzIGAhIStBcnJheS5mcm9tKG4udG9TdHJpbmcoMikpLnJldmVyc2UoKVtwb3NdYFxuICovXG5leHBvcnQgZnVuY3Rpb24gYml0R2V0KG4sIHBvcykge1xuICAgIHJldHVybiAobiA+PiBCaWdJbnQocG9zKSkgJiBfMW47XG59XG4vKipcbiAqIFNldHMgc2luZ2xlIGJpdCBhdCBwb3NpdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpdFNldChuLCBwb3MsIHZhbHVlKSB7XG4gICAgcmV0dXJuIG4gfCAoKHZhbHVlID8gXzFuIDogXzBuKSA8PCBCaWdJbnQocG9zKSk7XG59XG4vKipcbiAqIENhbGN1bGF0ZSBtYXNrIGZvciBOIGJpdHMuIE5vdCB1c2luZyAqKiBvcGVyYXRvciB3aXRoIGJpZ2ludHMgYmVjYXVzZSBvZiBvbGQgZW5naW5lcy5cbiAqIFNhbWUgYXMgQmlnSW50KGAwYiR7QXJyYXkoaSkuZmlsbCgnMScpLmpvaW4oJycpfWApXG4gKi9cbmV4cG9ydCBjb25zdCBiaXRNYXNrID0gKG4pID0+IChfMW4gPDwgQmlnSW50KG4pKSAtIF8xbjtcbi8qKlxuICogTWluaW1hbCBITUFDLURSQkcgZnJvbSBOSVNUIDgwMC05MCBmb3IgUkZDNjk3OSBzaWdzLlxuICogQHJldHVybnMgZnVuY3Rpb24gdGhhdCB3aWxsIGNhbGwgRFJCRyB1bnRpbCAybmQgYXJnIHJldHVybnMgc29tZXRoaW5nIG1lYW5pbmdmdWxcbiAqIEBleGFtcGxlXG4gKiAgIGNvbnN0IGRyYmcgPSBjcmVhdGVIbWFjRFJCRzxLZXk+KDMyLCAzMiwgaG1hYyk7XG4gKiAgIGRyYmcoc2VlZCwgYnl0ZXNUb0tleSk7IC8vIGJ5dGVzVG9LZXkgbXVzdCByZXR1cm4gS2V5IG9yIHVuZGVmaW5lZFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSG1hY0RyYmcoaGFzaExlbiwgcUJ5dGVMZW4sIGhtYWNGbikge1xuICAgIGlmICh0eXBlb2YgaGFzaExlbiAhPT0gJ251bWJlcicgfHwgaGFzaExlbiA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGFzaExlbiBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgaWYgKHR5cGVvZiBxQnl0ZUxlbiAhPT0gJ251bWJlcicgfHwgcUJ5dGVMZW4gPCAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3FCeXRlTGVuIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICBpZiAodHlwZW9mIGhtYWNGbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdobWFjRm4gbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgLy8gU3RlcCBCLCBTdGVwIEM6IHNldCBoYXNoTGVuIHRvIDgqY2VpbChobGVuLzgpXG4gICAgY29uc3QgdThuID0gKGxlbikgPT4gbmV3IFVpbnQ4QXJyYXkobGVuKTsgLy8gY3JlYXRlcyBVaW50OEFycmF5XG4gICAgY29uc3QgdThvZiA9IChieXRlKSA9PiBVaW50OEFycmF5Lm9mKGJ5dGUpOyAvLyBhbm90aGVyIHNob3J0Y3V0XG4gICAgbGV0IHYgPSB1OG4oaGFzaExlbik7IC8vIE1pbmltYWwgbm9uLWZ1bGwtc3BlYyBITUFDLURSQkcgZnJvbSBOSVNUIDgwMC05MCBmb3IgUkZDNjk3OSBzaWdzLlxuICAgIGxldCBrID0gdThuKGhhc2hMZW4pOyAvLyBTdGVwcyBCIGFuZCBDIG9mIFJGQzY5NzkgMy4yOiBzZXQgaGFzaExlbiwgaW4gb3VyIGNhc2UgYWx3YXlzIHNhbWVcbiAgICBsZXQgaSA9IDA7IC8vIEl0ZXJhdGlvbnMgY291bnRlciwgd2lsbCB0aHJvdyB3aGVuIG92ZXIgMTAwMFxuICAgIGNvbnN0IHJlc2V0ID0gKCkgPT4ge1xuICAgICAgICB2LmZpbGwoMSk7XG4gICAgICAgIGsuZmlsbCgwKTtcbiAgICAgICAgaSA9IDA7XG4gICAgfTtcbiAgICBjb25zdCBoID0gKC4uLmIpID0+IGhtYWNGbihrLCB2LCAuLi5iKTsgLy8gaG1hYyhrKSh2LCAuLi52YWx1ZXMpXG4gICAgY29uc3QgcmVzZWVkID0gKHNlZWQgPSB1OG4oMCkpID0+IHtcbiAgICAgICAgLy8gSE1BQy1EUkJHIHJlc2VlZCgpIGZ1bmN0aW9uLiBTdGVwcyBELUdcbiAgICAgICAgayA9IGgodThvZigweDAwKSwgc2VlZCk7IC8vIGsgPSBobWFjKGsgfHwgdiB8fCAweDAwIHx8IHNlZWQpXG4gICAgICAgIHYgPSBoKCk7IC8vIHYgPSBobWFjKGsgfHwgdilcbiAgICAgICAgaWYgKHNlZWQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBrID0gaCh1OG9mKDB4MDEpLCBzZWVkKTsgLy8gayA9IGhtYWMoayB8fCB2IHx8IDB4MDEgfHwgc2VlZClcbiAgICAgICAgdiA9IGgoKTsgLy8gdiA9IGhtYWMoayB8fCB2KVxuICAgIH07XG4gICAgY29uc3QgZ2VuID0gKCkgPT4ge1xuICAgICAgICAvLyBITUFDLURSQkcgZ2VuZXJhdGUoKSBmdW5jdGlvblxuICAgICAgICBpZiAoaSsrID49IDEwMDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RyYmc6IHRyaWVkIDEwMDAgdmFsdWVzJyk7XG4gICAgICAgIGxldCBsZW4gPSAwO1xuICAgICAgICBjb25zdCBvdXQgPSBbXTtcbiAgICAgICAgd2hpbGUgKGxlbiA8IHFCeXRlTGVuKSB7XG4gICAgICAgICAgICB2ID0gaCgpO1xuICAgICAgICAgICAgY29uc3Qgc2wgPSB2LnNsaWNlKCk7XG4gICAgICAgICAgICBvdXQucHVzaChzbCk7XG4gICAgICAgICAgICBsZW4gKz0gdi5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbmNhdEJ5dGVzXyguLi5vdXQpO1xuICAgIH07XG4gICAgY29uc3QgZ2VuVW50aWwgPSAoc2VlZCwgcHJlZCkgPT4ge1xuICAgICAgICByZXNldCgpO1xuICAgICAgICByZXNlZWQoc2VlZCk7IC8vIFN0ZXBzIEQtR1xuICAgICAgICBsZXQgcmVzID0gdW5kZWZpbmVkOyAvLyBTdGVwIEg6IGdyaW5kIHVudGlsIGsgaXMgaW4gWzEuLm4tMV1cbiAgICAgICAgd2hpbGUgKCEocmVzID0gcHJlZChnZW4oKSkpKVxuICAgICAgICAgICAgcmVzZWVkKCk7XG4gICAgICAgIHJlc2V0KCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICByZXR1cm4gZ2VuVW50aWw7XG59XG4vLyBWYWxpZGF0aW5nIGN1cnZlcyBhbmQgZmllbGRzXG5jb25zdCB2YWxpZGF0b3JGbnMgPSB7XG4gICAgYmlnaW50OiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnYmlnaW50JyxcbiAgICBmdW5jdGlvbjogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyxcbiAgICBib29sZWFuOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnYm9vbGVhbicsXG4gICAgc3RyaW5nOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyxcbiAgICBzdHJpbmdPclVpbnQ4QXJyYXk6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnIHx8IGlzQnl0ZXNfKHZhbCksXG4gICAgaXNTYWZlSW50ZWdlcjogKHZhbCkgPT4gTnVtYmVyLmlzU2FmZUludGVnZXIodmFsKSxcbiAgICBhcnJheTogKHZhbCkgPT4gQXJyYXkuaXNBcnJheSh2YWwpLFxuICAgIGZpZWxkOiAodmFsLCBvYmplY3QpID0+IG9iamVjdC5GcC5pc1ZhbGlkKHZhbCksXG4gICAgaGFzaDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyAmJiBOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWwub3V0cHV0TGVuKSxcbn07XG4vLyB0eXBlIFJlY29yZDxLIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyIHwgc3ltYm9sLCBUPiA9IHsgW1AgaW4gS106IFQ7IH1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZU9iamVjdChvYmplY3QsIHZhbGlkYXRvcnMsIG9wdFZhbGlkYXRvcnMgPSB7fSkge1xuICAgIGNvbnN0IGNoZWNrRmllbGQgPSAoZmllbGROYW1lLCB0eXBlLCBpc09wdGlvbmFsKSA9PiB7XG4gICAgICAgIGNvbnN0IGNoZWNrVmFsID0gdmFsaWRhdG9yRm5zW3R5cGVdO1xuICAgICAgICBpZiAodHlwZW9mIGNoZWNrVmFsICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHZhbGlkYXRvciBmdW5jdGlvbicpO1xuICAgICAgICBjb25zdCB2YWwgPSBvYmplY3RbZmllbGROYW1lXTtcbiAgICAgICAgaWYgKGlzT3B0aW9uYWwgJiYgdmFsID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghY2hlY2tWYWwodmFsLCBvYmplY3QpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhcmFtICcgKyBTdHJpbmcoZmllbGROYW1lKSArICcgaXMgaW52YWxpZC4gRXhwZWN0ZWQgJyArIHR5cGUgKyAnLCBnb3QgJyArIHZhbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgdHlwZV0gb2YgT2JqZWN0LmVudHJpZXModmFsaWRhdG9ycykpXG4gICAgICAgIGNoZWNrRmllbGQoZmllbGROYW1lLCB0eXBlLCBmYWxzZSk7XG4gICAgZm9yIChjb25zdCBbZmllbGROYW1lLCB0eXBlXSBvZiBPYmplY3QuZW50cmllcyhvcHRWYWxpZGF0b3JzKSlcbiAgICAgICAgY2hlY2tGaWVsZChmaWVsZE5hbWUsIHR5cGUsIHRydWUpO1xuICAgIHJldHVybiBvYmplY3Q7XG59XG4vLyB2YWxpZGF0ZSB0eXBlIHRlc3RzXG4vLyBjb25zdCBvOiB7IGE6IG51bWJlcjsgYjogbnVtYmVyOyBjOiBudW1iZXIgfSA9IHsgYTogMSwgYjogNSwgYzogNiB9O1xuLy8gY29uc3QgejAgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdpc1NhZmVJbnRlZ2VyJyB9LCB7IGM6ICdiaWdpbnQnIH0pOyAvLyBPayFcbi8vIC8vIFNob3VsZCBmYWlsIHR5cGUtY2hlY2tcbi8vIGNvbnN0IHoxID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAndG1wJyB9LCB7IGM6ICd6eicgfSk7XG4vLyBjb25zdCB6MiA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2lzU2FmZUludGVnZXInIH0sIHsgYzogJ3p6JyB9KTtcbi8vIGNvbnN0IHozID0gdmFsaWRhdGVPYmplY3QobywgeyB0ZXN0OiAnYm9vbGVhbicsIHo6ICdidWcnIH0pO1xuLy8gY29uc3QgejQgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdib29sZWFuJywgejogJ2J1ZycgfSk7XG5leHBvcnQgZnVuY3Rpb24gaXNIYXNoKHZhbCkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nICYmIE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbC5vdXRwdXRMZW4pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIF92YWxpZGF0ZU9iamVjdChvYmplY3QsIGZpZWxkcywgb3B0RmllbGRzID0ge30pIHtcbiAgICBpZiAoIW9iamVjdCB8fCB0eXBlb2Ygb2JqZWN0ICE9PSAnb2JqZWN0JylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCB2YWxpZCBvcHRpb25zIG9iamVjdCcpO1xuICAgIGZ1bmN0aW9uIGNoZWNrRmllbGQoZmllbGROYW1lLCBleHBlY3RlZFR5cGUsIGlzT3B0KSB7XG4gICAgICAgIGNvbnN0IHZhbCA9IG9iamVjdFtmaWVsZE5hbWVdO1xuICAgICAgICBpZiAoaXNPcHQgJiYgdmFsID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSB0eXBlb2YgdmFsO1xuICAgICAgICBpZiAoY3VycmVudCAhPT0gZXhwZWN0ZWRUeXBlIHx8IHZhbCA9PT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcGFyYW0gXCIke2ZpZWxkTmFtZX1cIiBpcyBpbnZhbGlkOiBleHBlY3RlZCAke2V4cGVjdGVkVHlwZX0sIGdvdCAke2N1cnJlbnR9YCk7XG4gICAgfVxuICAgIE9iamVjdC5lbnRyaWVzKGZpZWxkcykuZm9yRWFjaCgoW2ssIHZdKSA9PiBjaGVja0ZpZWxkKGssIHYsIGZhbHNlKSk7XG4gICAgT2JqZWN0LmVudHJpZXMob3B0RmllbGRzKS5mb3JFYWNoKChbaywgdl0pID0+IGNoZWNrRmllbGQoaywgdiwgdHJ1ZSkpO1xufVxuLyoqXG4gKiB0aHJvd3Mgbm90IGltcGxlbWVudGVkIGVycm9yXG4gKi9cbmV4cG9ydCBjb25zdCBub3RJbXBsZW1lbnRlZCA9ICgpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xufTtcbi8qKlxuICogTWVtb2l6ZXMgKGNhY2hlcykgY29tcHV0YXRpb24gcmVzdWx0LlxuICogVXNlcyBXZWFrTWFwOiB0aGUgdmFsdWUgaXMgZ29pbmcgYXV0by1jbGVhbmVkIGJ5IEdDIGFmdGVyIGxhc3QgcmVmZXJlbmNlIGlzIHJlbW92ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZW1vaXplZChmbikge1xuICAgIGNvbnN0IG1hcCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgcmV0dXJuIChhcmcsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgY29uc3QgdmFsID0gbWFwLmdldChhcmcpO1xuICAgICAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICBjb25zdCBjb21wdXRlZCA9IGZuKGFyZywgLi4uYXJncyk7XG4gICAgICAgIG1hcC5zZXQoYXJnLCBjb21wdXRlZCk7XG4gICAgICAgIHJldHVybiBjb21wdXRlZDtcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbImFieXRlcyIsImFieXRlc18iLCJieXRlc1RvSGV4IiwiYnl0ZXNUb0hleF8iLCJjb25jYXRCeXRlcyIsImNvbmNhdEJ5dGVzXyIsImhleFRvQnl0ZXMiLCJoZXhUb0J5dGVzXyIsImlzQnl0ZXMiLCJpc0J5dGVzXyIsImFudW1iZXIiLCJieXRlc1RvVXRmOCIsInJhbmRvbUJ5dGVzIiwidXRmOFRvQnl0ZXMiLCJfMG4iLCJCaWdJbnQiLCJfMW4iLCJhYm9vbCIsInRpdGxlIiwidmFsdWUiLCJFcnJvciIsIl9hYm9vbDIiLCJwcmVmaXgiLCJfYWJ5dGVzMiIsImxlbmd0aCIsImJ5dGVzIiwibGVuIiwibmVlZHNMZW4iLCJ1bmRlZmluZWQiLCJvZkxlbiIsImdvdCIsIm51bWJlclRvSGV4VW5wYWRkZWQiLCJudW0iLCJoZXgiLCJ0b1N0cmluZyIsImhleFRvTnVtYmVyIiwiYnl0ZXNUb051bWJlckJFIiwiYnl0ZXNUb051bWJlckxFIiwiVWludDhBcnJheSIsImZyb20iLCJyZXZlcnNlIiwibnVtYmVyVG9CeXRlc0JFIiwibiIsInBhZFN0YXJ0IiwibnVtYmVyVG9CeXRlc0xFIiwibnVtYmVyVG9WYXJCeXRlc0JFIiwiZW5zdXJlQnl0ZXMiLCJleHBlY3RlZExlbmd0aCIsInJlcyIsImUiLCJlcXVhbEJ5dGVzIiwiYSIsImIiLCJkaWZmIiwiaSIsImNvcHlCeXRlcyIsImFzY2lpVG9CeXRlcyIsImFzY2lpIiwiYyIsImNoYXJDb2RlIiwiY2hhckNvZGVBdCIsImlzUG9zQmlnIiwiaW5SYW5nZSIsIm1pbiIsIm1heCIsImFJblJhbmdlIiwiYml0TGVuIiwiYml0R2V0IiwicG9zIiwiYml0U2V0IiwiYml0TWFzayIsImNyZWF0ZUhtYWNEcmJnIiwiaGFzaExlbiIsInFCeXRlTGVuIiwiaG1hY0ZuIiwidThuIiwidThvZiIsImJ5dGUiLCJvZiIsInYiLCJrIiwicmVzZXQiLCJmaWxsIiwiaCIsInJlc2VlZCIsInNlZWQiLCJnZW4iLCJvdXQiLCJzbCIsInNsaWNlIiwicHVzaCIsImdlblVudGlsIiwicHJlZCIsInZhbGlkYXRvckZucyIsImJpZ2ludCIsInZhbCIsImZ1bmN0aW9uIiwiYm9vbGVhbiIsInN0cmluZyIsInN0cmluZ09yVWludDhBcnJheSIsImlzU2FmZUludGVnZXIiLCJOdW1iZXIiLCJhcnJheSIsIkFycmF5IiwiaXNBcnJheSIsImZpZWxkIiwib2JqZWN0IiwiRnAiLCJpc1ZhbGlkIiwiaGFzaCIsIm91dHB1dExlbiIsInZhbGlkYXRlT2JqZWN0IiwidmFsaWRhdG9ycyIsIm9wdFZhbGlkYXRvcnMiLCJjaGVja0ZpZWxkIiwiZmllbGROYW1lIiwidHlwZSIsImlzT3B0aW9uYWwiLCJjaGVja1ZhbCIsIlN0cmluZyIsIk9iamVjdCIsImVudHJpZXMiLCJpc0hhc2giLCJfdmFsaWRhdGVPYmplY3QiLCJmaWVsZHMiLCJvcHRGaWVsZHMiLCJleHBlY3RlZFR5cGUiLCJpc09wdCIsImN1cnJlbnQiLCJmb3JFYWNoIiwibm90SW1wbGVtZW50ZWQiLCJtZW1vaXplZCIsImZuIiwibWFwIiwiV2Vha01hcCIsImFyZyIsImFyZ3MiLCJnZXQiLCJjb21wdXRlZCIsInNldCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/curves/esm/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/_md.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/_md.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Chi: () => (/* binding */ Chi),\n/* harmony export */   HashMD: () => (/* binding */ HashMD),\n/* harmony export */   Maj: () => (/* binding */ Maj),\n/* harmony export */   SHA224_IV: () => (/* binding */ SHA224_IV),\n/* harmony export */   SHA256_IV: () => (/* binding */ SHA256_IV),\n/* harmony export */   SHA384_IV: () => (/* binding */ SHA384_IV),\n/* harmony export */   SHA512_IV: () => (/* binding */ SHA512_IV),\n/* harmony export */   setBigUint64: () => (/* binding */ setBigUint64)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/utils.js\");\n/**\n * Internal Merkle-Damgard hash utils.\n * @module\n */ \n/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */ function setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === \"function\") return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number(value >> _32n & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n/** Choice: a ? b : c */ function Chi(a, b, c) {\n    return a & b ^ ~a & c;\n}\n/** Majority function, true if any two inputs is true. */ function Maj(a, b, c) {\n    return a & b ^ a & c ^ b & c;\n}\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */ class HashMD extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE){\n        super();\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(this.buffer);\n    }\n    update(data) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aexists)(this);\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(data);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(data);\n        const { view, buffer, blockLen } = this;\n        const len = data.length;\n        for(let pos = 0; pos < len;){\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(data);\n                for(; blockLen <= len - pos; pos += blockLen)this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aexists)(this);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aoutput)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 128;\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.clean)(this.buffer.subarray(pos));\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for(let i = pos; i < blockLen; i++)buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4) throw new Error(\"_sha2: outputLen should be aligned to 32bit\");\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length) throw new Error(\"_sha2: outputLen bigger than state\");\n        for(let i = 0; i < outLen; i++)oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.destroyed = destroyed;\n        to.finished = finished;\n        to.length = length;\n        to.pos = pos;\n        if (length % blockLen) to.buffer.set(buffer);\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n}\n/**\n * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.\n * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.\n */ /** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */ const SHA256_IV = /* @__PURE__ */ Uint32Array.from([\n    0x6a09e667,\n    0xbb67ae85,\n    0x3c6ef372,\n    0xa54ff53a,\n    0x510e527f,\n    0x9b05688c,\n    0x1f83d9ab,\n    0x5be0cd19\n]);\n/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */ const SHA224_IV = /* @__PURE__ */ Uint32Array.from([\n    0xc1059ed8,\n    0x367cd507,\n    0x3070dd17,\n    0xf70e5939,\n    0xffc00b31,\n    0x68581511,\n    0x64f98fa7,\n    0xbefa4fa4\n]);\n/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */ const SHA384_IV = /* @__PURE__ */ Uint32Array.from([\n    0xcbbb9d5d,\n    0xc1059ed8,\n    0x629a292a,\n    0x367cd507,\n    0x9159015a,\n    0x3070dd17,\n    0x152fecd8,\n    0xf70e5939,\n    0x67332667,\n    0xffc00b31,\n    0x8eb44a87,\n    0x68581511,\n    0xdb0c2e0d,\n    0x64f98fa7,\n    0x47b5481d,\n    0xbefa4fa4\n]);\n/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */ const SHA512_IV = /* @__PURE__ */ Uint32Array.from([\n    0x6a09e667,\n    0xf3bcc908,\n    0xbb67ae85,\n    0x84caa73b,\n    0x3c6ef372,\n    0xfe94f82b,\n    0xa54ff53a,\n    0x5f1d36f1,\n    0x510e527f,\n    0xade682d1,\n    0x9b05688c,\n    0x2b3e6c1f,\n    0x1f83d9ab,\n    0xfb41bd6b,\n    0x5be0cd19,\n    0x137e2179\n]); //# sourceMappingURL=_md.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fbWQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7OztDQUdDLEdBQ3VGO0FBQ3hGLDhGQUE4RixHQUN2RixTQUFTTyxhQUFhQyxJQUFJLEVBQUVDLFVBQVUsRUFBRUMsS0FBSyxFQUFFQyxJQUFJO0lBQ3RELElBQUksT0FBT0gsS0FBS0QsWUFBWSxLQUFLLFlBQzdCLE9BQU9DLEtBQUtELFlBQVksQ0FBQ0UsWUFBWUMsT0FBT0M7SUFDaEQsTUFBTUMsT0FBT0MsT0FBTztJQUNwQixNQUFNQyxXQUFXRCxPQUFPO0lBQ3hCLE1BQU1FLEtBQUtDLE9BQU8sU0FBVUosT0FBUUU7SUFDcEMsTUFBTUcsS0FBS0QsT0FBT04sUUFBUUk7SUFDMUIsTUFBTUksSUFBSVAsT0FBTyxJQUFJO0lBQ3JCLE1BQU1RLElBQUlSLE9BQU8sSUFBSTtJQUNyQkgsS0FBS1ksU0FBUyxDQUFDWCxhQUFhUyxHQUFHSCxJQUFJSjtJQUNuQ0gsS0FBS1ksU0FBUyxDQUFDWCxhQUFhVSxHQUFHRixJQUFJTjtBQUN2QztBQUNBLHNCQUFzQixHQUNmLFNBQVNVLElBQUlDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDO0lBQ3ZCLE9BQU8sSUFBS0QsSUFBTSxDQUFDRCxJQUFJRTtBQUMzQjtBQUNBLHVEQUF1RCxHQUNoRCxTQUFTQyxJQUFJSCxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQztJQUN2QixPQUFPLElBQUtELElBQU1ELElBQUlFLElBQU1ELElBQUlDO0FBQ3BDO0FBQ0E7OztDQUdDLEdBQ00sTUFBTUUsZUFBZTFCLDJDQUFJQTtJQUM1QjJCLFlBQVlDLFFBQVEsRUFBRUMsU0FBUyxFQUFFQyxTQUFTLEVBQUVuQixJQUFJLENBQUU7UUFDOUMsS0FBSztRQUNMLElBQUksQ0FBQ29CLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNDLE1BQU0sR0FBRztR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SUFBSSxDQUFDO0lBQ3REO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7Q0FDdkYsRUFBRTtBQUNILDRFQUE0RSxHQUNyRSxNQUFNQyxZQUFZLGFBQWEsR0FBR0YsWUFBWUMsSUFBSSxDQUFDO0lBQ3REO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7Q0FDdkYsRUFBRTtBQUNILDJFQUEyRSxHQUNwRSxNQUFNRSxZQUFZLGFBQWEsR0FBR0gsWUFBWUMsSUFBSSxDQUFDO0lBQ3REO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFDcEY7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtDQUN2RixFQUFFO0FBQ0gsMEVBQTBFLEdBQ25FLE1BQU1HLFlBQVksYUFBYSxHQUFHSixZQUFZQyxJQUFJLENBQUM7SUFDdEQ7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUNwRjtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0NBQ3ZGLEVBQUUsQ0FDSCwrQkFBK0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGF3LXdvcmtzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2ViMy5qcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX21kLmpzP2YzMjEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBJbnRlcm5hbCBNZXJrbGUtRGFtZ2FyZCBoYXNoIHV0aWxzLlxuICogQG1vZHVsZVxuICovXG5pbXBvcnQgeyBIYXNoLCBhYnl0ZXMsIGFleGlzdHMsIGFvdXRwdXQsIGNsZWFuLCBjcmVhdGVWaWV3LCB0b0J5dGVzIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbi8qKiBQb2x5ZmlsbCBmb3IgU2FmYXJpIDE0LiBodHRwczovL2Nhbml1c2UuY29tL21kbi1qYXZhc2NyaXB0X2J1aWx0aW5zX2RhdGF2aWV3X3NldGJpZ3VpbnQ2NCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldEJpZ1VpbnQ2NCh2aWV3LCBieXRlT2Zmc2V0LCB2YWx1ZSwgaXNMRSkge1xuICAgIGlmICh0eXBlb2Ygdmlldy5zZXRCaWdVaW50NjQgPT09ICdmdW5jdGlvbicpXG4gICAgICAgIHJldHVybiB2aWV3LnNldEJpZ1VpbnQ2NChieXRlT2Zmc2V0LCB2YWx1ZSwgaXNMRSk7XG4gICAgY29uc3QgXzMybiA9IEJpZ0ludCgzMik7XG4gICAgY29uc3QgX3UzMl9tYXggPSBCaWdJbnQoMHhmZmZmZmZmZik7XG4gICAgY29uc3Qgd2ggPSBOdW1iZXIoKHZhbHVlID4+IF8zMm4pICYgX3UzMl9tYXgpO1xuICAgIGNvbnN0IHdsID0gTnVtYmVyKHZhbHVlICYgX3UzMl9tYXgpO1xuICAgIGNvbnN0IGggPSBpc0xFID8gNCA6IDA7XG4gICAgY29uc3QgbCA9IGlzTEUgPyAwIDogNDtcbiAgICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgaCwgd2gsIGlzTEUpO1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBsLCB3bCwgaXNMRSk7XG59XG4vKiogQ2hvaWNlOiBhID8gYiA6IGMgKi9cbmV4cG9ydCBmdW5jdGlvbiBDaGkoYSwgYiwgYykge1xuICAgIHJldHVybiAoYSAmIGIpIF4gKH5hICYgYyk7XG59XG4vKiogTWFqb3JpdHkgZnVuY3Rpb24sIHRydWUgaWYgYW55IHR3byBpbnB1dHMgaXMgdHJ1ZS4gKi9cbmV4cG9ydCBmdW5jdGlvbiBNYWooYSwgYiwgYykge1xuICAgIHJldHVybiAoYSAmIGIpIF4gKGEgJiBjKSBeIChiICYgYyk7XG59XG4vKipcbiAqIE1lcmtsZS1EYW1nYXJkIGhhc2ggY29uc3RydWN0aW9uIGJhc2UgY2xhc3MuXG4gKiBDb3VsZCBiZSB1c2VkIHRvIGNyZWF0ZSBNRDUsIFJJUEVNRCwgU0hBMSwgU0hBMi5cbiAqL1xuZXhwb3J0IGNsYXNzIEhhc2hNRCBleHRlbmRzIEhhc2gge1xuICAgIGNvbnN0cnVjdG9yKGJsb2NrTGVuLCBvdXRwdXRMZW4sIHBhZE9mZnNldCwgaXNMRSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0aGlzLnBhZE9mZnNldCA9IHBhZE9mZnNldDtcbiAgICAgICAgdGhpcy5pc0xFID0gaXNMRTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XG4gICAgICAgIHRoaXMudmlldyA9IGNyZWF0ZVZpZXcodGhpcy5idWZmZXIpO1xuICAgIH1cbiAgICB1cGRhdGUoZGF0YSkge1xuICAgICAgICBhZXhpc3RzKHRoaXMpO1xuICAgICAgICBkYXRhID0gdG9CeXRlcyhkYXRhKTtcbiAgICAgICAgYWJ5dGVzKGRhdGEpO1xuICAgICAgICBjb25zdCB7IHZpZXcsIGJ1ZmZlciwgYmxvY2tMZW4gfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvcywgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIC8vIEZhc3QgcGF0aDogd2UgaGF2ZSBhdCBsZWFzdCBvbmUgYmxvY2sgaW4gaW5wdXQsIGNhc3QgaXQgdG8gdmlldyBhbmQgcHJvY2Vzc1xuICAgICAgICAgICAgaWYgKHRha2UgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YVZpZXcgPSBjcmVhdGVWaWV3KGRhdGEpO1xuICAgICAgICAgICAgICAgIGZvciAoOyBibG9ja0xlbiA8PSBsZW4gLSBwb3M7IHBvcyArPSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKGRhdGFWaWV3LCBwb3MpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyLnNldChkYXRhLnN1YmFycmF5KHBvcywgcG9zICsgdGFrZSksIHRoaXMucG9zKTtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IHRha2U7XG4gICAgICAgICAgICBwb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGVuZ3RoICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICB0aGlzLnJvdW5kQ2xlYW4oKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgIGFleGlzdHModGhpcyk7XG4gICAgICAgIGFvdXRwdXQob3V0LCB0aGlzKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIC8vIFBhZGRpbmdcbiAgICAgICAgLy8gV2UgY2FuIGF2b2lkIGFsbG9jYXRpb24gb2YgYnVmZmVyIGZvciBwYWRkaW5nIGNvbXBsZXRlbHkgaWYgaXRcbiAgICAgICAgLy8gd2FzIHByZXZpb3VzbHkgbm90IGFsbG9jYXRlZCBoZXJlLiBCdXQgaXQgd29uJ3QgY2hhbmdlIHBlcmZvcm1hbmNlLlxuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgdmlldywgYmxvY2tMZW4sIGlzTEUgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IHBvcyB9ID0gdGhpcztcbiAgICAgICAgLy8gYXBwZW5kIHRoZSBiaXQgJzEnIHRvIHRoZSBtZXNzYWdlXG4gICAgICAgIGJ1ZmZlcltwb3MrK10gPSAwYjEwMDAwMDAwO1xuICAgICAgICBjbGVhbih0aGlzLmJ1ZmZlci5zdWJhcnJheShwb3MpKTtcbiAgICAgICAgLy8gd2UgaGF2ZSBsZXNzIHRoYW4gcGFkT2Zmc2V0IGxlZnQgaW4gYnVmZmVyLCBzbyB3ZSBjYW5ub3QgcHV0IGxlbmd0aCBpblxuICAgICAgICAvLyBjdXJyZW50IGJsb2NrLCBuZWVkIHByb2Nlc3MgaXQgYW5kIHBhZCBhZ2FpblxuICAgICAgICBpZiAodGhpcy5wYWRPZmZzZXQgPiBibG9ja0xlbiAtIHBvcykge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgcG9zID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYWQgdW50aWwgZnVsbCBibG9jayBieXRlIHdpdGggemVyb3NcbiAgICAgICAgZm9yIChsZXQgaSA9IHBvczsgaSA8IGJsb2NrTGVuOyBpKyspXG4gICAgICAgICAgICBidWZmZXJbaV0gPSAwO1xuICAgICAgICAvLyBOb3RlOiBzaGE1MTIgcmVxdWlyZXMgbGVuZ3RoIHRvIGJlIDEyOGJpdCBpbnRlZ2VyLCBidXQgbGVuZ3RoIGluIEpTIHdpbGwgb3ZlcmZsb3cgYmVmb3JlIHRoYXRcbiAgICAgICAgLy8gWW91IG5lZWQgdG8gd3JpdGUgYXJvdW5kIDIgZXhhYnl0ZXMgKHU2NF9tYXggLyA4IC8gKDEwMjQqKjYpKSBmb3IgdGhpcyB0byBoYXBwZW4uXG4gICAgICAgIC8vIFNvIHdlIGp1c3Qgd3JpdGUgbG93ZXN0IDY0IGJpdHMgb2YgdGhhdCB2YWx1ZS5cbiAgICAgICAgc2V0QmlnVWludDY0KHZpZXcsIGJsb2NrTGVuIC0gOCwgQmlnSW50KHRoaXMubGVuZ3RoICogOCksIGlzTEUpO1xuICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgIGNvbnN0IG92aWV3ID0gY3JlYXRlVmlldyhvdXQpO1xuICAgICAgICBjb25zdCBsZW4gPSB0aGlzLm91dHB1dExlbjtcbiAgICAgICAgLy8gTk9URTogd2UgZG8gZGl2aXNpb24gYnkgNCBsYXRlciwgd2hpY2ggc2hvdWxkIGJlIGZ1c2VkIGluIHNpbmdsZSBvcCB3aXRoIG1vZHVsbyBieSBKSVRcbiAgICAgICAgaWYgKGxlbiAlIDQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ19zaGEyOiBvdXRwdXRMZW4gc2hvdWxkIGJlIGFsaWduZWQgdG8gMzJiaXQnKTtcbiAgICAgICAgY29uc3Qgb3V0TGVuID0gbGVuIC8gNDtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldCgpO1xuICAgICAgICBpZiAob3V0TGVuID4gc3RhdGUubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIGJpZ2dlciB0aGFuIHN0YXRlJyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0TGVuOyBpKyspXG4gICAgICAgICAgICBvdmlldy5zZXRVaW50MzIoNCAqIGksIHN0YXRlW2ldLCBpc0xFKTtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLmRpZ2VzdEludG8oYnVmZmVyKTtcbiAgICAgICAgY29uc3QgcmVzID0gYnVmZmVyLnNsaWNlKDAsIG91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIHRvIHx8ICh0byA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkpO1xuICAgICAgICB0by5zZXQoLi4udGhpcy5nZXQoKSk7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIGJ1ZmZlciwgbGVuZ3RoLCBmaW5pc2hlZCwgZGVzdHJveWVkLCBwb3MgfSA9IHRoaXM7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8ubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0by5wb3MgPSBwb3M7XG4gICAgICAgIGlmIChsZW5ndGggJSBibG9ja0xlbilcbiAgICAgICAgICAgIHRvLmJ1ZmZlci5zZXQoYnVmZmVyKTtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb25lSW50bygpO1xuICAgIH1cbn1cbi8qKlxuICogSW5pdGlhbCBTSEEtMiBzdGF0ZTogZnJhY3Rpb25hbCBwYXJ0cyBvZiBzcXVhcmUgcm9vdHMgb2YgZmlyc3QgMTYgcHJpbWVzIDIuLjUzLlxuICogQ2hlY2sgb3V0IGB0ZXN0L21pc2Mvc2hhMi1nZW4taXYuanNgIGZvciByZWNvbXB1dGF0aW9uIGd1aWRlLlxuICovXG4vKiogSW5pdGlhbCBTSEEyNTYgc3RhdGUuIEJpdHMgMC4uMzIgb2YgZnJhYyBwYXJ0IG9mIHNxcnQgb2YgcHJpbWVzIDIuLjE5ICovXG5leHBvcnQgY29uc3QgU0hBMjU2X0lWID0gLyogQF9fUFVSRV9fICovIFVpbnQzMkFycmF5LmZyb20oW1xuICAgIDB4NmEwOWU2NjcsIDB4YmI2N2FlODUsIDB4M2M2ZWYzNzIsIDB4YTU0ZmY1M2EsIDB4NTEwZTUyN2YsIDB4OWIwNTY4OGMsIDB4MWY4M2Q5YWIsIDB4NWJlMGNkMTksXG5dKTtcbi8qKiBJbml0aWFsIFNIQTIyNCBzdGF0ZS4gQml0cyAzMi4uNjQgb2YgZnJhYyBwYXJ0IG9mIHNxcnQgb2YgcHJpbWVzIDIzLi41MyAqL1xuZXhwb3J0IGNvbnN0IFNIQTIyNF9JViA9IC8qIEBfX1BVUkVfXyAqLyBVaW50MzJBcnJheS5mcm9tKFtcbiAgICAweGMxMDU5ZWQ4LCAweDM2N2NkNTA3LCAweDMwNzBkZDE3LCAweGY3MGU1OTM5LCAweGZmYzAwYjMxLCAweDY4NTgxNTExLCAweDY0Zjk4ZmE3LCAweGJlZmE0ZmE0LFxuXSk7XG4vKiogSW5pdGlhbCBTSEEzODQgc3RhdGUuIEJpdHMgMC4uNjQgb2YgZnJhYyBwYXJ0IG9mIHNxcnQgb2YgcHJpbWVzIDIzLi41MyAqL1xuZXhwb3J0IGNvbnN0IFNIQTM4NF9JViA9IC8qIEBfX1BVUkVfXyAqLyBVaW50MzJBcnJheS5mcm9tKFtcbiAgICAweGNiYmI5ZDVkLCAweGMxMDU5ZWQ4LCAweDYyOWEyOTJhLCAweDM2N2NkNTA3LCAweDkxNTkwMTVhLCAweDMwNzBkZDE3LCAweDE1MmZlY2Q4LCAweGY3MGU1OTM5LFxuICAgIDB4NjczMzI2NjcsIDB4ZmZjMDBiMzEsIDB4OGViNDRhODcsIDB4Njg1ODE1MTEsIDB4ZGIwYzJlMGQsIDB4NjRmOThmYTcsIDB4NDdiNTQ4MWQsIDB4YmVmYTRmYTQsXG5dKTtcbi8qKiBJbml0aWFsIFNIQTUxMiBzdGF0ZS4gQml0cyAwLi42NCBvZiBmcmFjIHBhcnQgb2Ygc3FydCBvZiBwcmltZXMgMi4uMTkgKi9cbmV4cG9ydCBjb25zdCBTSEE1MTJfSVYgPSAvKiBAX19QVVJFX18gKi8gVWludDMyQXJyYXkuZnJvbShbXG4gICAgMHg2YTA5ZTY2NywgMHhmM2JjYzkwOCwgMHhiYjY3YWU4NSwgMHg4NGNhYTczYiwgMHgzYzZlZjM3MiwgMHhmZTk0ZjgyYiwgMHhhNTRmZjUzYSwgMHg1ZjFkMzZmMSxcbiAgICAweDUxMGU1MjdmLCAweGFkZTY4MmQxLCAweDliMDU2ODhjLCAweDJiM2U2YzFmLCAweDFmODNkOWFiLCAweGZiNDFiZDZiLCAweDViZTBjZDE5LCAweDEzN2UyMTc5LFxuXSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fbWQuanMubWFwIl0sIm5hbWVzIjpbIkhhc2giLCJhYnl0ZXMiLCJhZXhpc3RzIiwiYW91dHB1dCIsImNsZWFuIiwiY3JlYXRlVmlldyIsInRvQnl0ZXMiLCJzZXRCaWdVaW50NjQiLCJ2aWV3IiwiYnl0ZU9mZnNldCIsInZhbHVlIiwiaXNMRSIsIl8zMm4iLCJCaWdJbnQiLCJfdTMyX21heCIsIndoIiwiTnVtYmVyIiwid2wiLCJoIiwibCIsInNldFVpbnQzMiIsIkNoaSIsImEiLCJiIiwiYyIsIk1haiIsIkhhc2hNRCIsImNvbnN0cnVjdG9yIiwiYmxvY2tMZW4iLCJvdXRwdXRMZW4iLCJwYWRPZmZzZXQiLCJmaW5pc2hlZCIsImxlbmd0aCIsInBvcyIsImRlc3Ryb3llZCIsImJ1ZmZlciIsIlVpbnQ4QXJyYXkiLCJ1cGRhdGUiLCJkYXRhIiwibGVuIiwidGFrZSIsIk1hdGgiLCJtaW4iLCJkYXRhVmlldyIsInByb2Nlc3MiLCJzZXQiLCJzdWJhcnJheSIsInJvdW5kQ2xlYW4iLCJkaWdlc3RJbnRvIiwib3V0IiwiaSIsIm92aWV3IiwiRXJyb3IiLCJvdXRMZW4iLCJzdGF0ZSIsImdldCIsImRpZ2VzdCIsInJlcyIsInNsaWNlIiwiZGVzdHJveSIsIl9jbG9uZUludG8iLCJ0byIsImNsb25lIiwiU0hBMjU2X0lWIiwiVWludDMyQXJyYXkiLCJmcm9tIiwiU0hBMjI0X0lWIiwiU0hBMzg0X0lWIiwiU0hBNTEyX0lWIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/_md.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/_u64.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/_u64.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   add: () => (/* binding */ add),\n/* harmony export */   add3H: () => (/* binding */ add3H),\n/* harmony export */   add3L: () => (/* binding */ add3L),\n/* harmony export */   add4H: () => (/* binding */ add4H),\n/* harmony export */   add4L: () => (/* binding */ add4L),\n/* harmony export */   add5H: () => (/* binding */ add5H),\n/* harmony export */   add5L: () => (/* binding */ add5L),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   fromBig: () => (/* binding */ fromBig),\n/* harmony export */   rotlBH: () => (/* binding */ rotlBH),\n/* harmony export */   rotlBL: () => (/* binding */ rotlBL),\n/* harmony export */   rotlSH: () => (/* binding */ rotlSH),\n/* harmony export */   rotlSL: () => (/* binding */ rotlSL),\n/* harmony export */   rotr32H: () => (/* binding */ rotr32H),\n/* harmony export */   rotr32L: () => (/* binding */ rotr32L),\n/* harmony export */   rotrBH: () => (/* binding */ rotrBH),\n/* harmony export */   rotrBL: () => (/* binding */ rotrBL),\n/* harmony export */   rotrSH: () => (/* binding */ rotrSH),\n/* harmony export */   rotrSL: () => (/* binding */ rotrSL),\n/* harmony export */   shrSH: () => (/* binding */ shrSH),\n/* harmony export */   shrSL: () => (/* binding */ shrSL),\n/* harmony export */   split: () => (/* binding */ split),\n/* harmony export */   toBig: () => (/* binding */ toBig)\n/* harmony export */ });\n/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */ const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\nfunction fromBig(n, le = false) {\n    if (le) return {\n        h: Number(n & U32_MASK64),\n        l: Number(n >> _32n & U32_MASK64)\n    };\n    return {\n        h: Number(n >> _32n & U32_MASK64) | 0,\n        l: Number(n & U32_MASK64) | 0\n    };\n}\nfunction split(lst, le = false) {\n    const len = lst.length;\n    let Ah = new Uint32Array(len);\n    let Al = new Uint32Array(len);\n    for(let i = 0; i < len; i++){\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [\n            h,\n            l\n        ];\n    }\n    return [\n        Ah,\n        Al\n    ];\n}\nconst toBig = (h, l)=>BigInt(h >>> 0) << _32n | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s)=>h >>> s;\nconst shrSL = (h, l, s)=>h << 32 - s | l >>> s;\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s)=>h >>> s | l << 32 - s;\nconst rotrSL = (h, l, s)=>h << 32 - s | l >>> s;\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s)=>h << 64 - s | l >>> s - 32;\nconst rotrBL = (h, l, s)=>h >>> s - 32 | l << 64 - s;\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l)=>l;\nconst rotr32L = (h, _l)=>h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s)=>h << s | l >>> 32 - s;\nconst rotlSL = (h, l, s)=>l << s | h >>> 32 - s;\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s)=>l << s - 32 | h >>> 64 - s;\nconst rotlBL = (h, l, s)=>h << s - 32 | l >>> 64 - s;\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return {\n        h: Ah + Bh + (l / 2 ** 32 | 0) | 0,\n        l: l | 0\n    };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch)=>Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;\nconst add4L = (Al, Bl, Cl, Dl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh)=>Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh)=>Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;\n// prettier-ignore\n\n// prettier-ignore\nconst u64 = {\n    fromBig,\n    split,\n    toBig,\n    shrSH,\n    shrSL,\n    rotrSH,\n    rotrSL,\n    rotrBH,\n    rotrBL,\n    rotr32H,\n    rotr32L,\n    rotlSH,\n    rotlSL,\n    rotlBH,\n    rotlBL,\n    add,\n    add3L,\n    add3H,\n    add4L,\n    add4H,\n    add5H,\n    add5L\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (u64); //# sourceMappingURL=_u64.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fdTY0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Q0FJQyxHQUNELE1BQU1BLGFBQWEsYUFBYSxHQUFHQyxPQUFPLEtBQUssS0FBSztBQUNwRCxNQUFNQyxPQUFPLGFBQWEsR0FBR0QsT0FBTztBQUNwQyxTQUFTRSxRQUFRQyxDQUFDLEVBQUVDLEtBQUssS0FBSztJQUMxQixJQUFJQSxJQUNBLE9BQU87UUFBRUMsR0FBR0MsT0FBT0gsSUFBSUo7UUFBYVEsR0FBR0QsT0FBTyxLQUFNTCxPQUFRRjtJQUFZO0lBQzVFLE9BQU87UUFBRU0sR0FBR0MsT0FBTyxLQUFNTCxPQUFRRixjQUFjO1FBQUdRLEdBQUdELE9BQU9ILElBQUlKLGNBQWM7SUFBRTtBQUNwRjtBQUNBLFNBQVNTLE1BQU1DLEdBQUcsRUFBRUwsS0FBSyxLQUFLO0lBQzFCLE1BQU1NLE1BQU1ELElBQUlFLE1BQU07SUFDdEIsSUFBSUMsS0FBSyxJQUFJQyxZQUFZSDtJQUN6QixJQUFJSSxLQUFLLElBQUlELFlBQVlIO0lBQ3pCLElBQUssSUFBSUssSUFBSSxHQUFHQSxJQUFJTCxLQUFLSyxJQUFLO1FBQzFCLE1BQU0sRUFBRVYsQ0FBQyxFQUFFRSxDQUFDLEVBQUUsR0FBR0wsUUFBUU8sR0FBRyxDQUFDTSxFQUFFLEVBQUVYO1FBQ2pDLENBQUNRLEVBQUUsQ0FBQ0csRUFBRSxFQUFFRCxFQUFFLENBQUNDLEVBQUUsQ0FBQyxHQUFHO1lBQUNWO1lBQUdFO1NBQUU7SUFDM0I7SUFDQSxPQUFPO1FBQUNLO1FBQUlFO0tBQUc7QUFDbkI7QUFDQSxNQUFNRSxRQUFRLENBQUNYLEdBQUdFLElBQU0sT0FBUUYsTUFBTSxNQUFNSixPQUFRRCxPQUFPTyxNQUFNO0FBQ2pFLHVCQUF1QjtBQUN2QixNQUFNVSxRQUFRLENBQUNaLEdBQUdhLElBQUlD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QUFlSSxHQUFHQSxFQUFDLENBQ25CLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsYXctd29ya3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fdTY0LmpzPzgyMGIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBJbnRlcm5hbCBoZWxwZXJzIGZvciB1NjQuIEJpZ1VpbnQ2NEFycmF5IGlzIHRvbyBzbG93IGFzIHBlciAyMDI1LCBzbyB3ZSBpbXBsZW1lbnQgaXQgdXNpbmcgVWludDMyQXJyYXkuXG4gKiBAdG9kbyByZS1jaGVjayBodHRwczovL2lzc3Vlcy5jaHJvbWl1bS5vcmcvaXNzdWVzLzQyMjEyNTg4XG4gKiBAbW9kdWxlXG4gKi9cbmNvbnN0IFUzMl9NQVNLNjQgPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDIgKiogMzIgLSAxKTtcbmNvbnN0IF8zMm4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDMyKTtcbmZ1bmN0aW9uIGZyb21CaWcobiwgbGUgPSBmYWxzZSkge1xuICAgIGlmIChsZSlcbiAgICAgICAgcmV0dXJuIHsgaDogTnVtYmVyKG4gJiBVMzJfTUFTSzY0KSwgbDogTnVtYmVyKChuID4+IF8zMm4pICYgVTMyX01BU0s2NCkgfTtcbiAgICByZXR1cm4geyBoOiBOdW1iZXIoKG4gPj4gXzMybikgJiBVMzJfTUFTSzY0KSB8IDAsIGw6IE51bWJlcihuICYgVTMyX01BU0s2NCkgfCAwIH07XG59XG5mdW5jdGlvbiBzcGxpdChsc3QsIGxlID0gZmFsc2UpIHtcbiAgICBjb25zdCBsZW4gPSBsc3QubGVuZ3RoO1xuICAgIGxldCBBaCA9IG5ldyBVaW50MzJBcnJheShsZW4pO1xuICAgIGxldCBBbCA9IG5ldyBVaW50MzJBcnJheShsZW4pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgeyBoLCBsIH0gPSBmcm9tQmlnKGxzdFtpXSwgbGUpO1xuICAgICAgICBbQWhbaV0sIEFsW2ldXSA9IFtoLCBsXTtcbiAgICB9XG4gICAgcmV0dXJuIFtBaCwgQWxdO1xufVxuY29uc3QgdG9CaWcgPSAoaCwgbCkgPT4gKEJpZ0ludChoID4+PiAwKSA8PCBfMzJuKSB8IEJpZ0ludChsID4+PiAwKTtcbi8vIGZvciBTaGlmdCBpbiBbMCwgMzIpXG5jb25zdCBzaHJTSCA9IChoLCBfbCwgcykgPT4gaCA+Pj4gcztcbmNvbnN0IHNoclNMID0gKGgsIGwsIHMpID0+IChoIDw8ICgzMiAtIHMpKSB8IChsID4+PiBzKTtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gWzEsIDMyKVxuY29uc3Qgcm90clNIID0gKGgsIGwsIHMpID0+IChoID4+PiBzKSB8IChsIDw8ICgzMiAtIHMpKTtcbmNvbnN0IHJvdHJTTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoMzIgLSBzKSkgfCAobCA+Pj4gcyk7XG4vLyBSaWdodCByb3RhdGUgZm9yIFNoaWZ0IGluICgzMiwgNjQpLCBOT1RFOiAzMiBpcyBzcGVjaWFsIGNhc2UuXG5jb25zdCByb3RyQkggPSAoaCwgbCwgcykgPT4gKGggPDwgKDY0IC0gcykpIHwgKGwgPj4+IChzIC0gMzIpKTtcbmNvbnN0IHJvdHJCTCA9IChoLCBsLCBzKSA9PiAoaCA+Pj4gKHMgLSAzMikpIHwgKGwgPDwgKDY0IC0gcykpO1xuLy8gUmlnaHQgcm90YXRlIGZvciBzaGlmdD09PTMyIChqdXN0IHN3YXBzIGwmaClcbmNvbnN0IHJvdHIzMkggPSAoX2gsIGwpID0+IGw7XG5jb25zdCByb3RyMzJMID0gKGgsIF9sKSA9PiBoO1xuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluIFsxLCAzMilcbmNvbnN0IHJvdGxTSCA9IChoLCBsLCBzKSA9PiAoaCA8PCBzKSB8IChsID4+PiAoMzIgLSBzKSk7XG5jb25zdCByb3RsU0wgPSAoaCwgbCwgcykgPT4gKGwgPDwgcykgfCAoaCA+Pj4gKDMyIC0gcykpO1xuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluICgzMiwgNjQpLCBOT1RFOiAzMiBpcyBzcGVjaWFsIGNhc2UuXG5jb25zdCByb3RsQkggPSAoaCwgbCwgcykgPT4gKGwgPDwgKHMgLSAzMikpIHwgKGggPj4+ICg2NCAtIHMpKTtcbmNvbnN0IHJvdGxCTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAocyAtIDMyKSkgfCAobCA+Pj4gKDY0IC0gcykpO1xuLy8gSlMgdXNlcyAzMi1iaXQgc2lnbmVkIGludGVnZXJzIGZvciBiaXR3aXNlIG9wZXJhdGlvbnMgd2hpY2ggbWVhbnMgd2UgY2Fubm90XG4vLyBzaW1wbGUgdGFrZSBjYXJyeSBvdXQgb2YgbG93IGJpdCBzdW0gYnkgc2hpZnQsIHdlIG5lZWQgdG8gdXNlIGRpdmlzaW9uLlxuZnVuY3Rpb24gYWRkKEFoLCBBbCwgQmgsIEJsKSB7XG4gICAgY29uc3QgbCA9IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApO1xuICAgIHJldHVybiB7IGg6IChBaCArIEJoICsgKChsIC8gMiAqKiAzMikgfCAwKSkgfCAwLCBsOiBsIHwgMCB9O1xufVxuLy8gQWRkaXRpb24gd2l0aCBtb3JlIHRoYW4gMiBlbGVtZW50c1xuY29uc3QgYWRkM0wgPSAoQWwsIEJsLCBDbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApO1xuY29uc3QgYWRkM0ggPSAobG93LCBBaCwgQmgsIENoKSA9PiAoQWggKyBCaCArIENoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG5jb25zdCBhZGQ0TCA9IChBbCwgQmwsIENsLCBEbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApICsgKERsID4+PiAwKTtcbmNvbnN0IGFkZDRIID0gKGxvdywgQWgsIEJoLCBDaCwgRGgpID0+IChBaCArIEJoICsgQ2ggKyBEaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuY29uc3QgYWRkNUwgPSAoQWwsIEJsLCBDbCwgRGwsIEVsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCkgKyAoRGwgPj4+IDApICsgKEVsID4+PiAwKTtcbmNvbnN0IGFkZDVIID0gKGxvdywgQWgsIEJoLCBDaCwgRGgsIEVoKSA9PiAoQWggKyBCaCArIENoICsgRGggKyBFaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuLy8gcHJldHRpZXItaWdub3JlXG5leHBvcnQgeyBhZGQsIGFkZDNILCBhZGQzTCwgYWRkNEgsIGFkZDRMLCBhZGQ1SCwgYWRkNUwsIGZyb21CaWcsIHJvdGxCSCwgcm90bEJMLCByb3RsU0gsIHJvdGxTTCwgcm90cjMySCwgcm90cjMyTCwgcm90ckJILCByb3RyQkwsIHJvdHJTSCwgcm90clNMLCBzaHJTSCwgc2hyU0wsIHNwbGl0LCB0b0JpZyB9O1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCB1NjQgPSB7XG4gICAgZnJvbUJpZywgc3BsaXQsIHRvQmlnLFxuICAgIHNoclNILCBzaHJTTCxcbiAgICByb3RyU0gsIHJvdHJTTCwgcm90ckJILCByb3RyQkwsXG4gICAgcm90cjMySCwgcm90cjMyTCxcbiAgICByb3RsU0gsIHJvdGxTTCwgcm90bEJILCByb3RsQkwsXG4gICAgYWRkLCBhZGQzTCwgYWRkM0gsIGFkZDRMLCBhZGQ0SCwgYWRkNUgsIGFkZDVMLFxufTtcbmV4cG9ydCBkZWZhdWx0IHU2NDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV91NjQuanMubWFwIl0sIm5hbWVzIjpbIlUzMl9NQVNLNjQiLCJCaWdJbnQiLCJfMzJuIiwiZnJvbUJpZyIsIm4iLCJsZSIsImgiLCJOdW1iZXIiLCJsIiwic3BsaXQiLCJsc3QiLCJsZW4iLCJsZW5ndGgiLCJBaCIsIlVpbnQzMkFycmF5IiwiQWwiLCJpIiwidG9CaWciLCJzaHJTSCIsIl9sIiwicyIsInNoclNMIiwicm90clNIIiwicm90clNMIiwicm90ckJIIiwicm90ckJMIiwicm90cjMySCIsIl9oIiwicm90cjMyTCIsInJvdGxTSCIsInJvdGxTTCIsInJvdGxCSCIsInJvdGxCTCIsImFkZCIsIkJoIiwiQmwiLCJhZGQzTCIsIkNsIiwiYWRkM0giLCJsb3ciLCJDaCIsImFkZDRMIiwiRGwiLCJhZGQ0SCIsIkRoIiwiYWRkNUwiLCJFbCIsImFkZDVIIiwiRWgiLCJ1NjQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/_u64.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/cryptoNode.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/cryptoNode.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crypto: () => (/* binding */ crypto)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n/**\n * Internal webcrypto alias.\n * We prefer WebCrypto aka globalThis.crypto, which exists in node.js 16+.\n * Falls back to Node.js built-in crypto for Node.js <=v14.\n * See utils.ts for details.\n * @module\n */ // @ts-ignore\n\nconst crypto = /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) && typeof /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) === \"object\" && \"webcrypto\" in /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) ? node_crypto__WEBPACK_IMPORTED_MODULE_0__.webcrypto : /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) && typeof /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) === \"object\" && \"randomBytes\" in /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) ? /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) : undefined; //# sourceMappingURL=cryptoNode.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9jcnlwdG9Ob2RlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7Ozs7Q0FNQyxHQUNELGFBQWE7QUFDcUI7QUFDM0IsTUFBTUMsU0FBU0QsMk1BQUVBLElBQUksT0FBT0EsMk1BQUVBLEtBQUssWUFBWSwwTkFBaUJBLEdBQ2pFQSxrREFBWSxHQUNaQSwyTUFBRUEsSUFBSSxPQUFPQSwyTUFBRUEsS0FBSyxZQUFZLDROQUFtQkEsR0FDL0NBLDJNQUFFQSxHQUNGRyxVQUFVLENBQ3BCLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsYXctd29ya3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9jcnlwdG9Ob2RlLmpzP2NmZGEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBJbnRlcm5hbCB3ZWJjcnlwdG8gYWxpYXMuXG4gKiBXZSBwcmVmZXIgV2ViQ3J5cHRvIGFrYSBnbG9iYWxUaGlzLmNyeXB0bywgd2hpY2ggZXhpc3RzIGluIG5vZGUuanMgMTYrLlxuICogRmFsbHMgYmFjayB0byBOb2RlLmpzIGJ1aWx0LWluIGNyeXB0byBmb3IgTm9kZS5qcyA8PXYxNC5cbiAqIFNlZSB1dGlscy50cyBmb3IgZGV0YWlscy5cbiAqIEBtb2R1bGVcbiAqL1xuLy8gQHRzLWlnbm9yZVxuaW1wb3J0ICogYXMgbmMgZnJvbSAnbm9kZTpjcnlwdG8nO1xuZXhwb3J0IGNvbnN0IGNyeXB0byA9IG5jICYmIHR5cGVvZiBuYyA9PT0gJ29iamVjdCcgJiYgJ3dlYmNyeXB0bycgaW4gbmNcbiAgICA/IG5jLndlYmNyeXB0b1xuICAgIDogbmMgJiYgdHlwZW9mIG5jID09PSAnb2JqZWN0JyAmJiAncmFuZG9tQnl0ZXMnIGluIG5jXG4gICAgICAgID8gbmNcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcnlwdG9Ob2RlLmpzLm1hcCJdLCJuYW1lcyI6WyJuYyIsImNyeXB0byIsIndlYmNyeXB0byIsInVuZGVmaW5lZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/cryptoNode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/hmac.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/hmac.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HMAC: () => (/* binding */ HMAC),\n/* harmony export */   hmac: () => (/* binding */ hmac)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/utils.js\");\n/**\n * HMAC: RFC2104 message authentication code.\n * @module\n */ \nclass HMAC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(hash, _key){\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ahash)(hash);\n        const key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== \"function\") throw new Error(\"Expected instance of class which extends utils.Hash\");\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for(let i = 0; i < pad.length; i++)pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for(let i = 0; i < pad.length; i++)pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.clean)(pad);\n    }\n    update(buf) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aexists)(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aexists)(this);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n * @example\n * import { hmac } from '@noble/hashes/hmac';\n * import { sha256 } from '@noble/hashes/sha2';\n * const mac1 = hmac(sha256, 'key', 'message');\n */ const hmac = (hash, key, message)=>new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key)=>new HMAC(hash, key); //# sourceMappingURL=hmac.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9obWFjLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7Q0FHQyxHQUN5RTtBQUNuRSxNQUFNTSxhQUFhRiwyQ0FBSUE7SUFDMUJHLFlBQVlDLElBQUksRUFBRUMsSUFBSSxDQUFFO1FBQ3BCLEtBQUs7UUFDTCxJQUFJLENBQUNDLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNDLFNBQVMsR0FBRztRQUNqQlQsZ0RBQUtBLENBQUNNO1FBQ04sTUFBTUksTUFBTVAsa0RBQU9BLENBQUNJO1FBQ3BCLElBQUksQ0FBQ0ksS0FBSyxHQUFHTCxLQUFLTSxNQUFNO1FBQ3hCLElBQUksT0FBTyxJQUFJLENBQUNELEtBQUssQ0FBQ0UsTUFBTSxLQUFLLFlBQzdCLE1BQU0sSUFBSUMsTUFBTTtRQUNwQixJQUFJLENBQUNDLFFBQVEsR0FBRyxJQUFJLENBQUNKLEtBQUssQ0FBQ0ksUUFBUTtRQUNuQyxJQUFJLENBQUNDLFNBQVMsR0FBRyxJQUFJLENBQUNMLEtBQUssQ0FBQ0ssU0FBUztRQUNyQyxNQUFNRCxXQUFXLElBQUksQ0FBQ0EsUUFBUTtRQUM5QixNQUFNRSxNQUFNLElBQUlDLFdBQVdIO1FBQzNCLHdDQUF3QztRQUN4Q0UsSUFBSUUsR0FBRyxDQUFDVCxJQUFJVSxNQUFNLEdBQUdMLFdBQVdULEtBQUtNLE1BQU0sR0FBR0MsTUFBTSxDQUFDSCxLQUFLVyxNQUFNLEtBQUtYO1FBQ3JFLElBQUssSUFBSVksSUFBSSxHQUFHQSxJQUFJTCxJQUFJRyxNQUFNLEVBQUVFLElBQzVCTCxHQUFHLENBQUNLLEVBQUUsSUFBSTtRQUNkLElBQUksQ0FBQ1gsS0FBSyxDQUFDRSxNQUFNLENBQUNJO1FBQ2xCLG1IQUFtSDtRQUNuSCxJQUFJLENBQUNNLEtBQUssR0FBR2pCLEtBQUtNLE1BQU07UUFDeEIsdUNBQXVDO1FBQ3ZDLElBQUssSUFBSVUsSUFBSSxHQUFHQSxJQUFJTCxJQUFJRyxNQUFNLEVBQUVFLElBQzVCTCxHQUFHLENBQUNLLEVBQUUsSUFBSSxPQUFPO1FBQ3JCLElBQUksQ0FBQ0MsS0FBSyxDQUFDVixNQUFNLENBQUNJO1FBQ2xCaEIsZ0RBQUtBLENBQUNnQjtJQUNWO0lBQ0FKLE9BQU9XLEdBQUcsRUFBRTtRQUNSekIsa0RBQU9BLENBQUMsSUFBSTtRQUNaLElBQUksQ0FBQ1ksS0FBSyxDQUFDRSxNQUFNLENBQUNXO1FBQ2xCLE9BQU8sSUFBSTtJQUNmO0lBQ0FDLFdBQVdDLEdBQUcsRUFBRTtRQUNaM0Isa0RBQU9BLENBQUMsSUFBSTtRQUNaRCxpREFBTUEsQ0FBQzRCLEtBQUssSUFBSSxDQUFDVixTQUFTO1FBQzFCLElBQUksQ0FBQ1IsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0csS0FBSyxDQUFDYyxVQUFVLENBQUNDO1FBQ3RCLElBQUksQ0FBQ0gsS0FBSyxDQUFDVixNQUFNLENBQUNhO1FBQ2xCLElBQUksQ0FBQ0gsS0FBSyxDQUFDRSxVQUFVLENBQUNDO1FBQ3RCLElBQUksQ0FBQ0MsT0FBTztJQUNoQjtJQUNBTixTQUFTO1FBQ0wsTUFBTUssTUFBTSxJQUFJUixXQUFXLElBQUksQ0FBQ0ssS0FBSyxDQUFDUCxTQUFTO1FBQy9DLElBQUksQ0FBQ1MsVUFBVSxDQUFDQztRQUNoQixPQUFPQTtJQUNYO0lBQ0FFLFdBQVdDLEVBQUUsRUFBRTtRQUNYLG1HQUFtRztRQUNuR0EsTUFBT0EsQ0FBQUEsS0FBS0MsT0FBT2xCLE1BQU0sQ0FBQ2tCLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxFQUFDO1FBQ3pELE1BQU0sRUFBRVIsS0FBSyxFQUFFWixLQUFLLEVBQUVILFFBQVEsRUFBRUMsU0FBUyxFQUFFTSxRQUFRLEVBQUVDLFNBQVMsRUFBRSxHQUFHLElBQUk7UUFDdkVhLEtBQUtBO1FBQ0xBLEdBQUdyQixRQUFRLEdBQUdBO1FBQ2RxQixHQUFHcEIsU0FBUyxHQUFHQTtRQUNmb0IsR0FBR2QsUUFBUSxHQUFHQTtRQUNkYyxHQUFHYixTQUFTLEdBQUdBO1FBQ2ZhLEdBQUdOLEtBQUssR0FBR0EsTUFBTUssVUFBVSxDQUFDQyxHQUFHTixLQUFLO1FBQ3BDTSxHQUFHbEIsS0FBSyxHQUFHQSxNQUFNaUIsVUFBVSxDQUFDQyxHQUFHbEIsS0FBSztRQUNwQyxPQUFPa0I7SUFDWDtJQUNBRyxRQUFRO1FBQ0osT0FBTyxJQUFJLENBQUNKLFVBQVU7SUFDMUI7SUFDQUQsVUFBVTtRQUNOLElBQUksQ0FBQ2xCLFNBQVMsR0FBRztRQUNqQixJQUFJLENBQUNjLEtBQUssQ0FBQ0ksT0FBTztRQUNsQixJQUFJLENBQUNoQixLQUFLLENBQUNnQixPQUFPO0lBQ3RCO0FBQ0o7QUFDQTs7Ozs7Ozs7O0NBU0MsR0FDTSxNQUFNTSxPQUFPLENBQUMzQixNQUFNSSxLQUFLd0IsVUFBWSxJQUFJOUIsS0FBS0UsTUFBTUksS0FBS0csTUFBTSxDQUFDcUIsU0FBU2IsTUFBTSxHQUFHO0FBQ3pGWSxLQUFLckIsTUFBTSxHQUFHLENBQUNOLE1BQU1JLE1BQVEsSUFBSU4sS0FBS0UsTUFBTUksTUFDNUMsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xhdy13b3Jrcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dlYjMuanMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2htYWMuanM/YWYwYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEhNQUM6IFJGQzIxMDQgbWVzc2FnZSBhdXRoZW50aWNhdGlvbiBjb2RlLlxuICogQG1vZHVsZVxuICovXG5pbXBvcnQgeyBhYnl0ZXMsIGFleGlzdHMsIGFoYXNoLCBjbGVhbiwgSGFzaCwgdG9CeXRlcyB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG5leHBvcnQgY2xhc3MgSE1BQyBleHRlbmRzIEhhc2gge1xuICAgIGNvbnN0cnVjdG9yKGhhc2gsIF9rZXkpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICBhaGFzaChoYXNoKTtcbiAgICAgICAgY29uc3Qga2V5ID0gdG9CeXRlcyhfa2V5KTtcbiAgICAgICAgdGhpcy5pSGFzaCA9IGhhc2guY3JlYXRlKCk7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5pSGFzaC51cGRhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGluc3RhbmNlIG9mIGNsYXNzIHdoaWNoIGV4dGVuZHMgdXRpbHMuSGFzaCcpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gdGhpcy5pSGFzaC5ibG9ja0xlbjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSB0aGlzLmlIYXNoLm91dHB1dExlbjtcbiAgICAgICAgY29uc3QgYmxvY2tMZW4gPSB0aGlzLmJsb2NrTGVuO1xuICAgICAgICBjb25zdCBwYWQgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XG4gICAgICAgIC8vIGJsb2NrTGVuIGNhbiBiZSBiaWdnZXIgdGhhbiBvdXRwdXRMZW5cbiAgICAgICAgcGFkLnNldChrZXkubGVuZ3RoID4gYmxvY2tMZW4gPyBoYXNoLmNyZWF0ZSgpLnVwZGF0ZShrZXkpLmRpZ2VzdCgpIDoga2V5KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBwYWRbaV0gXj0gMHgzNjtcbiAgICAgICAgdGhpcy5pSGFzaC51cGRhdGUocGFkKTtcbiAgICAgICAgLy8gQnkgZG9pbmcgdXBkYXRlIChwcm9jZXNzaW5nIG9mIGZpcnN0IGJsb2NrKSBvZiBvdXRlciBoYXNoIGhlcmUgd2UgY2FuIHJlLXVzZSBpdCBiZXR3ZWVuIG11bHRpcGxlIGNhbGxzIHZpYSBjbG9uZVxuICAgICAgICB0aGlzLm9IYXNoID0gaGFzaC5jcmVhdGUoKTtcbiAgICAgICAgLy8gVW5kbyBpbnRlcm5hbCBYT1IgJiYgYXBwbHkgb3V0ZXIgWE9SXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcGFkW2ldIF49IDB4MzYgXiAweDVjO1xuICAgICAgICB0aGlzLm9IYXNoLnVwZGF0ZShwYWQpO1xuICAgICAgICBjbGVhbihwYWQpO1xuICAgIH1cbiAgICB1cGRhdGUoYnVmKSB7XG4gICAgICAgIGFleGlzdHModGhpcyk7XG4gICAgICAgIHRoaXMuaUhhc2gudXBkYXRlKGJ1Zik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBhZXhpc3RzKHRoaXMpO1xuICAgICAgICBhYnl0ZXMob3V0LCB0aGlzLm91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmlIYXNoLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgdGhpcy5vSGFzaC51cGRhdGUob3V0KTtcbiAgICAgICAgdGhpcy5vSGFzaC5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIGNvbnN0IG91dCA9IG5ldyBVaW50OEFycmF5KHRoaXMub0hhc2gub3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIF9jbG9uZUludG8odG8pIHtcbiAgICAgICAgLy8gQ3JlYXRlIG5ldyBpbnN0YW5jZSB3aXRob3V0IGNhbGxpbmcgY29uc3RydWN0b3Igc2luY2Uga2V5IGFscmVhZHkgaW4gc3RhdGUgYW5kIHdlIGRvbid0IGtub3cgaXQuXG4gICAgICAgIHRvIHx8ICh0byA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLCB7fSkpO1xuICAgICAgICBjb25zdCB7IG9IYXNoLCBpSGFzaCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgYmxvY2tMZW4sIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdG8gPSB0bztcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gZGVzdHJveWVkO1xuICAgICAgICB0by5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0by5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRvLm9IYXNoID0gb0hhc2guX2Nsb25lSW50byh0by5vSGFzaCk7XG4gICAgICAgIHRvLmlIYXNoID0gaUhhc2guX2Nsb25lSW50byh0by5pSGFzaCk7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9uZUludG8oKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm9IYXNoLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5pSGFzaC5kZXN0cm95KCk7XG4gICAgfVxufVxuLyoqXG4gKiBITUFDOiBSRkMyMTA0IG1lc3NhZ2UgYXV0aGVudGljYXRpb24gY29kZS5cbiAqIEBwYXJhbSBoYXNoIC0gZnVuY3Rpb24gdGhhdCB3b3VsZCBiZSB1c2VkIGUuZy4gc2hhMjU2XG4gKiBAcGFyYW0ga2V5IC0gbWVzc2FnZSBrZXlcbiAqIEBwYXJhbSBtZXNzYWdlIC0gbWVzc2FnZSBkYXRhXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgaG1hYyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvaG1hYyc7XG4gKiBpbXBvcnQgeyBzaGEyNTYgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3NoYTInO1xuICogY29uc3QgbWFjMSA9IGhtYWMoc2hhMjU2LCAna2V5JywgJ21lc3NhZ2UnKTtcbiAqL1xuZXhwb3J0IGNvbnN0IGhtYWMgPSAoaGFzaCwga2V5LCBtZXNzYWdlKSA9PiBuZXcgSE1BQyhoYXNoLCBrZXkpLnVwZGF0ZShtZXNzYWdlKS5kaWdlc3QoKTtcbmhtYWMuY3JlYXRlID0gKGhhc2gsIGtleSkgPT4gbmV3IEhNQUMoaGFzaCwga2V5KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhtYWMuanMubWFwIl0sIm5hbWVzIjpbImFieXRlcyIsImFleGlzdHMiLCJhaGFzaCIsImNsZWFuIiwiSGFzaCIsInRvQnl0ZXMiLCJITUFDIiwiY29uc3RydWN0b3IiLCJoYXNoIiwiX2tleSIsImZpbmlzaGVkIiwiZGVzdHJveWVkIiwia2V5IiwiaUhhc2giLCJjcmVhdGUiLCJ1cGRhdGUiLCJFcnJvciIsImJsb2NrTGVuIiwib3V0cHV0TGVuIiwicGFkIiwiVWludDhBcnJheSIsInNldCIsImxlbmd0aCIsImRpZ2VzdCIsImkiLCJvSGFzaCIsImJ1ZiIsImRpZ2VzdEludG8iLCJvdXQiLCJkZXN0cm95IiwiX2Nsb25lSW50byIsInRvIiwiT2JqZWN0IiwiZ2V0UHJvdG90eXBlT2YiLCJjbG9uZSIsImhtYWMiLCJtZXNzYWdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/hmac.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/sha2.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/sha2.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA224: () => (/* binding */ SHA224),\n/* harmony export */   SHA256: () => (/* binding */ SHA256),\n/* harmony export */   SHA384: () => (/* binding */ SHA384),\n/* harmony export */   SHA512: () => (/* binding */ SHA512),\n/* harmony export */   SHA512_224: () => (/* binding */ SHA512_224),\n/* harmony export */   SHA512_256: () => (/* binding */ SHA512_256),\n/* harmony export */   sha224: () => (/* binding */ sha224),\n/* harmony export */   sha256: () => (/* binding */ sha256),\n/* harmony export */   sha384: () => (/* binding */ sha384),\n/* harmony export */   sha512: () => (/* binding */ sha512),\n/* harmony export */   sha512_224: () => (/* binding */ sha512_224),\n/* harmony export */   sha512_256: () => (/* binding */ sha512_256)\n/* harmony export */ });\n/* harmony import */ var _md_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_md.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/_md.js\");\n/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_u64.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/_u64.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/utils.js\");\n/**\n * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.\n * SHA256 is the fastest hash implementable in JS, even faster than Blake3.\n * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and\n * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n */ \n\n\n/**\n * Round constants:\n * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)\n */ // prettier-ignore\nconst SHA256_K = /* @__PURE__ */ Uint32Array.from([\n    0x428a2f98,\n    0x71374491,\n    0xb5c0fbcf,\n    0xe9b5dba5,\n    0x3956c25b,\n    0x59f111f1,\n    0x923f82a4,\n    0xab1c5ed5,\n    0xd807aa98,\n    0x12835b01,\n    0x243185be,\n    0x550c7dc3,\n    0x72be5d74,\n    0x80deb1fe,\n    0x9bdc06a7,\n    0xc19bf174,\n    0xe49b69c1,\n    0xefbe4786,\n    0x0fc19dc6,\n    0x240ca1cc,\n    0x2de92c6f,\n    0x4a7484aa,\n    0x5cb0a9dc,\n    0x76f988da,\n    0x983e5152,\n    0xa831c66d,\n    0xb00327c8,\n    0xbf597fc7,\n    0xc6e00bf3,\n    0xd5a79147,\n    0x06ca6351,\n    0x14292967,\n    0x27b70a85,\n    0x2e1b2138,\n    0x4d2c6dfc,\n    0x53380d13,\n    0x650a7354,\n    0x766a0abb,\n    0x81c2c92e,\n    0x92722c85,\n    0xa2bfe8a1,\n    0xa81a664b,\n    0xc24b8b70,\n    0xc76c51a3,\n    0xd192e819,\n    0xd6990624,\n    0xf40e3585,\n    0x106aa070,\n    0x19a4c116,\n    0x1e376c08,\n    0x2748774c,\n    0x34b0bcb5,\n    0x391c0cb3,\n    0x4ed8aa4a,\n    0x5b9cca4f,\n    0x682e6ff3,\n    0x748f82ee,\n    0x78a5636f,\n    0x84c87814,\n    0x8cc70208,\n    0x90befffa,\n    0xa4506ceb,\n    0xbef9a3f7,\n    0xc67178f2\n]);\n/** Reusable temporary buffer. \"W\" comes straight from spec. */ const SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _md_js__WEBPACK_IMPORTED_MODULE_0__.HashMD {\n    constructor(outputLen = 32){\n        super(64, outputLen, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[0] | 0;\n        this.B = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[1] | 0;\n        this.C = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[2] | 0;\n        this.D = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[3] | 0;\n        this.E = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[4] | 0;\n        this.F = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[5] | 0;\n        this.G = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[6] | 0;\n        this.H = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [\n            A,\n            B,\n            C,\n            D,\n            E,\n            F,\n            G,\n            H\n        ];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for(let i = 0; i < 16; i++, offset += 4)SHA256_W[i] = view.getUint32(offset, false);\n        for(let i = 16; i < 64; i++){\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ W15 >>> 3;\n            const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ W2 >>> 10;\n            SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for(let i = 0; i < 64; i++){\n            const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);\n            const T1 = H + sigma1 + (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;\n            const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);\n            const T2 = sigma0 + (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Maj)(A, B, C) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = D + T1 | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = T1 + T2 | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = A + this.A | 0;\n        B = B + this.B | 0;\n        C = C + this.C | 0;\n        D = D + this.D | 0;\n        E = E + this.E | 0;\n        F = F + this.F | 0;\n        G = G + this.G | 0;\n        H = H + this.H | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(SHA256_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(this.buffer);\n    }\n}\nclass SHA224 extends SHA256 {\n    constructor(){\n        super(28);\n        this.A = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[0] | 0;\n        this.B = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[1] | 0;\n        this.C = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[2] | 0;\n        this.D = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[3] | 0;\n        this.E = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[4] | 0;\n        this.F = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[5] | 0;\n        this.G = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[6] | 0;\n        this.H = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[7] | 0;\n    }\n}\n// SHA2-512 is slower than sha256 in js because u64 operations are slow.\n// Round contants\n// First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409\n// prettier-ignore\nconst K512 = /* @__PURE__ */ (()=>_u64_js__WEBPACK_IMPORTED_MODULE_2__.split([\n        \"0x428a2f98d728ae22\",\n        \"0x7137449123ef65cd\",\n        \"0xb5c0fbcfec4d3b2f\",\n        \"0xe9b5dba58189dbbc\",\n        \"0x3956c25bf348b538\",\n        \"0x59f111f1b605d019\",\n        \"0x923f82a4af194f9b\",\n        \"0xab1c5ed5da6d8118\",\n        \"0xd807aa98a3030242\",\n        \"0x12835b0145706fbe\",\n        \"0x243185be4ee4b28c\",\n        \"0x550c7dc3d5ffb4e2\",\n        \"0x72be5d74f27b896f\",\n        \"0x80deb1fe3b1696b1\",\n        \"0x9bdc06a725c71235\",\n        \"0xc19bf174cf692694\",\n        \"0xe49b69c19ef14ad2\",\n        \"0xefbe4786384f25e3\",\n        \"0x0fc19dc68b8cd5b5\",\n        \"0x240ca1cc77ac9c65\",\n        \"0x2de92c6f592b0275\",\n        \"0x4a7484aa6ea6e483\",\n        \"0x5cb0a9dcbd41fbd4\",\n        \"0x76f988da831153b5\",\n        \"0x983e5152ee66dfab\",\n        \"0xa831c66d2db43210\",\n        \"0xb00327c898fb213f\",\n        \"0xbf597fc7beef0ee4\",\n        \"0xc6e00bf33da88fc2\",\n        \"0xd5a79147930aa725\",\n        \"0x06ca6351e003826f\",\n        \"0x142929670a0e6e70\",\n        \"0x27b70a8546d22ffc\",\n        \"0x2e1b21385c26c926\",\n        \"0x4d2c6dfc5ac42aed\",\n        \"0x53380d139d95b3df\",\n        \"0x650a73548baf63de\",\n        \"0x766a0abb3c77b2a8\",\n        \"0x81c2c92e47edaee6\",\n        \"0x92722c851482353b\",\n        \"0xa2bfe8a14cf10364\",\n        \"0xa81a664bbc423001\",\n        \"0xc24b8b70d0f89791\",\n        \"0xc76c51a30654be30\",\n        \"0xd192e819d6ef5218\",\n        \"0xd69906245565a910\",\n        \"0xf40e35855771202a\",\n        \"0x106aa07032bbd1b8\",\n        \"0x19a4c116b8d2d0c8\",\n        \"0x1e376c085141ab53\",\n        \"0x2748774cdf8eeb99\",\n        \"0x34b0bcb5e19b48a8\",\n        \"0x391c0cb3c5c95a63\",\n        \"0x4ed8aa4ae3418acb\",\n        \"0x5b9cca4f7763e373\",\n        \"0x682e6ff3d6b2b8a3\",\n        \"0x748f82ee5defb2fc\",\n        \"0x78a5636f43172f60\",\n        \"0x84c87814a1f0ab72\",\n        \"0x8cc702081a6439ec\",\n        \"0x90befffa23631e28\",\n        \"0xa4506cebde82bde9\",\n        \"0xbef9a3f7b2c67915\",\n        \"0xc67178f2e372532b\",\n        \"0xca273eceea26619c\",\n        \"0xd186b8c721c0c207\",\n        \"0xeada7dd6cde0eb1e\",\n        \"0xf57d4f7fee6ed178\",\n        \"0x06f067aa72176fba\",\n        \"0x0a637dc5a2c898a6\",\n        \"0x113f9804bef90dae\",\n        \"0x1b710b35131c471b\",\n        \"0x28db77f523047d84\",\n        \"0x32caab7b40c72493\",\n        \"0x3c9ebe0a15c9bebc\",\n        \"0x431d67c49c100d4c\",\n        \"0x4cc5d4becb3e42b6\",\n        \"0x597f299cfc657e2a\",\n        \"0x5fcb6fab3ad6faec\",\n        \"0x6c44198c4a475817\"\n    ].map((n)=>BigInt(n))))();\nconst SHA512_Kh = /* @__PURE__ */ (()=>K512[0])();\nconst SHA512_Kl = /* @__PURE__ */ (()=>K512[1])();\n// Reusable temporary buffers\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nclass SHA512 extends _md_js__WEBPACK_IMPORTED_MODULE_0__.HashMD {\n    constructor(outputLen = 64){\n        super(128, outputLen, 16, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[0] | 0;\n        this.Al = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[1] | 0;\n        this.Bh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[2] | 0;\n        this.Bl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[3] | 0;\n        this.Ch = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[4] | 0;\n        this.Cl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[5] | 0;\n        this.Dh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[6] | 0;\n        this.Dl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[7] | 0;\n        this.Eh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[8] | 0;\n        this.El = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[9] | 0;\n        this.Fh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[10] | 0;\n        this.Fl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[11] | 0;\n        this.Gh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[12] | 0;\n        this.Gl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[13] | 0;\n        this.Hh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[14] | 0;\n        this.Hl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[15] | 0;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [\n            Ah,\n            Al,\n            Bh,\n            Bl,\n            Ch,\n            Cl,\n            Dh,\n            Dl,\n            Eh,\n            El,\n            Fh,\n            Fl,\n            Gh,\n            Gl,\n            Hh,\n            Hl\n        ];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for(let i = 0; i < 16; i++, offset += 4){\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32(offset += 4);\n        }\n        for(let i = 16; i < 80; i++){\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSH(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSH(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.shrSH(W15h, W15l, 7);\n            const s0l = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSL(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSL(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSH(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBH(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.shrSH(W2h, W2l, 6);\n            const s1l = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSL(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBL(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for(let i = 0; i < 80; i++){\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSH(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSH(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBH(Eh, El, 41);\n            const sigma1l = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSL(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSL(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = Eh & Fh ^ ~Eh & Gh;\n            const CHIl = El & Fl ^ ~El & Gl;\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSH(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBH(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBH(Ah, Al, 39);\n            const sigma0l = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSL(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBL(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBL(Ah, Al, 39);\n            const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;\n            const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add3L(T1l, sigma0l, MAJl);\n            Ah = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(SHA512_W_H, SHA512_W_L);\n    }\n    destroy() {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(this.buffer);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nclass SHA384 extends SHA512 {\n    constructor(){\n        super(48);\n        this.Ah = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[0] | 0;\n        this.Al = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[1] | 0;\n        this.Bh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[2] | 0;\n        this.Bl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[3] | 0;\n        this.Ch = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[4] | 0;\n        this.Cl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[5] | 0;\n        this.Dh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[6] | 0;\n        this.Dl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[7] | 0;\n        this.Eh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[8] | 0;\n        this.El = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[9] | 0;\n        this.Fh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[10] | 0;\n        this.Fl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[11] | 0;\n        this.Gh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[12] | 0;\n        this.Gl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[13] | 0;\n        this.Hh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[14] | 0;\n        this.Hl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[15] | 0;\n    }\n}\n/**\n * Truncated SHA512/256 and SHA512/224.\n * SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as \"intermediary\" IV of SHA512/t.\n * Then t hashes string to produce result IV.\n * See `test/misc/sha2-gen-iv.js`.\n */ /** SHA512/224 IV */ const T224_IV = /* @__PURE__ */ Uint32Array.from([\n    0x8c3d37c8,\n    0x19544da2,\n    0x73e19966,\n    0x89dcd4d6,\n    0x1dfab7ae,\n    0x32ff9c82,\n    0x679dd514,\n    0x582f9fcf,\n    0x0f6d2b69,\n    0x7bd44da8,\n    0x77e36f73,\n    0x04c48942,\n    0x3f9d85a8,\n    0x6a1d36c8,\n    0x1112e6ad,\n    0x91d692a1\n]);\n/** SHA512/256 IV */ const T256_IV = /* @__PURE__ */ Uint32Array.from([\n    0x22312194,\n    0xfc2bf72c,\n    0x9f555fa3,\n    0xc84c64c2,\n    0x2393b86b,\n    0x6f53b151,\n    0x96387719,\n    0x5940eabd,\n    0x96283ee2,\n    0xa88effe3,\n    0xbe5e1e25,\n    0x53863992,\n    0x2b0199fc,\n    0x2c85b8aa,\n    0x0eb72ddc,\n    0x81c52ca2\n]);\nclass SHA512_224 extends SHA512 {\n    constructor(){\n        super(28);\n        this.Ah = T224_IV[0] | 0;\n        this.Al = T224_IV[1] | 0;\n        this.Bh = T224_IV[2] | 0;\n        this.Bl = T224_IV[3] | 0;\n        this.Ch = T224_IV[4] | 0;\n        this.Cl = T224_IV[5] | 0;\n        this.Dh = T224_IV[6] | 0;\n        this.Dl = T224_IV[7] | 0;\n        this.Eh = T224_IV[8] | 0;\n        this.El = T224_IV[9] | 0;\n        this.Fh = T224_IV[10] | 0;\n        this.Fl = T224_IV[11] | 0;\n        this.Gh = T224_IV[12] | 0;\n        this.Gl = T224_IV[13] | 0;\n        this.Hh = T224_IV[14] | 0;\n        this.Hl = T224_IV[15] | 0;\n    }\n}\nclass SHA512_256 extends SHA512 {\n    constructor(){\n        super(32);\n        this.Ah = T256_IV[0] | 0;\n        this.Al = T256_IV[1] | 0;\n        this.Bh = T256_IV[2] | 0;\n        this.Bl = T256_IV[3] | 0;\n        this.Ch = T256_IV[4] | 0;\n        this.Cl = T256_IV[5] | 0;\n        this.Dh = T256_IV[6] | 0;\n        this.Dl = T256_IV[7] | 0;\n        this.Eh = T256_IV[8] | 0;\n        this.El = T256_IV[9] | 0;\n        this.Fh = T256_IV[10] | 0;\n        this.Fl = T256_IV[11] | 0;\n        this.Gh = T256_IV[12] | 0;\n        this.Gl = T256_IV[13] | 0;\n        this.Hh = T256_IV[14] | 0;\n        this.Hl = T256_IV[15] | 0;\n    }\n}\n/**\n * SHA2-256 hash function from RFC 4634.\n *\n * It is the fastest JS hash, even faster than Blake3.\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n */ const sha256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(()=>new SHA256());\n/** SHA2-224 hash function from RFC 4634 */ const sha224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(()=>new SHA224());\n/** SHA2-512 hash function from RFC 4634. */ const sha512 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(()=>new SHA512());\n/** SHA2-384 hash function from RFC 4634. */ const sha384 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(()=>new SHA384());\n/**\n * SHA2-512/256 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */ const sha512_256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(()=>new SHA512_256());\n/**\n * SHA2-512/224 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */ const sha512_224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(()=>new SHA512_224()); //# sourceMappingURL=sha2.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Q0FNQyxHQUN1RjtBQUN2RDtBQUNzQjtBQUN2RDs7O0NBR0MsR0FDRCxrQkFBa0I7QUFDbEIsTUFBTVcsV0FBVyxhQUFhLEdBQUdDLFlBQVlDLElBQUksQ0FBQztJQUM5QztJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQ3BGO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFDcEY7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUNwRjtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQ3BGO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFDcEY7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUNwRjtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQ3BGO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7Q0FDdkY7QUFDRCw2REFBNkQsR0FDN0QsTUFBTUMsV0FBVyxhQUFhLEdBQUcsSUFBSUYsWUFBWTtBQUMxQyxNQUFNRyxlQUFlZCwwQ0FBTUE7SUFDOUJlLFlBQVlDLFlBQVksRUFBRSxDQUFFO1FBQ3hCLEtBQUssQ0FBQyxJQUFJQSxXQUFXLEdBQUc7UUFDeEIsbUVBQW1FO1FBQ25FLHVEQUF1RDtRQUN2RCxJQUFJLENBQUNDLENBQUMsR0FBR2QsNkNBQVMsQ0FBQyxFQUFFLEdBQUc7UUFDeEIsSUFBSSxDQUFDZSxDQUFDLEdBQUdmLDZDQUFTLENBQUMsRUFBRSxHQUFHO1FBQ3hCLElBQUksQ0FBQ2dCLENBQUMsR0FBR2hCLDZDQUFTLENBQUMsRUFBRSxHQUFHO1FBQ3hCLElBQUksQ0FBQ2lCLENBQUMsR0FB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LEVBQUUsR0FBRzhDLE9BQU8sQ0FBQyxFQUFFLEdBQUc7UUFDdkIsSUFBSSxDQUFDN0MsRUFBRSxHQUFHNkMsT0FBTyxDQUFDLEdBQUcsR0FBRztRQUN4QixJQUFJLENBQUM1QyxFQUFFLEdBQUc0QyxPQUFPLENBQUMsR0FBRyxHQUFHO1FBQ3hCLElBQUksQ0FBQzNDLEVBQUUsR0FBRzJDLE9BQU8sQ0FBQyxHQUFHLEdBQUc7UUFDeEIsSUFBSSxDQUFDMUMsRUFBRSxHQUFHMEMsT0FBTyxDQUFDLEdBQUcsR0FBRztRQUN4QixJQUFJLENBQUN6QyxFQUFFLEdBQUd5QyxPQUFPLENBQUMsR0FBRyxHQUFHO1FBQ3hCLElBQUksQ0FBQ3hDLEVBQUUsR0FBR3dDLE9BQU8sQ0FBQyxHQUFHLEdBQUc7SUFDNUI7QUFDSjtBQUNBOzs7Ozs7Q0FNQyxHQUNNLE1BQU1HLFNBQVMsYUFBYSxHQUFHeEcsdURBQVlBLENBQUMsSUFBTSxJQUFJTSxVQUFVO0FBQ3ZFLHlDQUF5QyxHQUNsQyxNQUFNbUcsU0FBUyxhQUFhLEdBQUd6Ryx1REFBWUEsQ0FBQyxJQUFNLElBQUltQyxVQUFVO0FBQ3ZFLDBDQUEwQyxHQUNuQyxNQUFNdUUsU0FBUyxhQUFhLEdBQUcxRyx1REFBWUEsQ0FBQyxJQUFNLElBQUk2QyxVQUFVO0FBQ3ZFLDBDQUEwQyxHQUNuQyxNQUFNOEQsU0FBUyxhQUFhLEdBQUczRyx1REFBWUEsQ0FBQyxJQUFNLElBQUltRyxVQUFVO0FBQ3ZFOzs7Q0FHQyxHQUNNLE1BQU1TLGFBQWEsYUFBYSxHQUFHNUcsdURBQVlBLENBQUMsSUFBTSxJQUFJdUcsY0FBYztBQUMvRTs7O0NBR0MsR0FDTSxNQUFNTSxhQUFhLGFBQWEsR0FBRzdHLHVEQUFZQSxDQUFDLElBQU0sSUFBSXNHLGNBQWMsQ0FDL0UsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xhdy13b3Jrcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dlYjMuanMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTIuanM/MTAwMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFNIQTIgaGFzaCBmdW5jdGlvbi4gQS5rLmEuIHNoYTI1Niwgc2hhMzg0LCBzaGE1MTIsIHNoYTUxMl8yMjQsIHNoYTUxMl8yNTYuXG4gKiBTSEEyNTYgaXMgdGhlIGZhc3Rlc3QgaGFzaCBpbXBsZW1lbnRhYmxlIGluIEpTLCBldmVuIGZhc3RlciB0aGFuIEJsYWtlMy5cbiAqIENoZWNrIG91dCBbUkZDIDQ2MzRdKGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNDYzNCkgYW5kXG4gKiBbRklQUyAxODAtNF0oaHR0cHM6Ly9udmxwdWJzLm5pc3QuZ292L25pc3RwdWJzL0ZJUFMvTklTVC5GSVBTLjE4MC00LnBkZikuXG4gKiBAbW9kdWxlXG4gKi9cbmltcG9ydCB7IENoaSwgSGFzaE1ELCBNYWosIFNIQTIyNF9JViwgU0hBMjU2X0lWLCBTSEEzODRfSVYsIFNIQTUxMl9JViB9IGZyb20gXCIuL19tZC5qc1wiO1xuaW1wb3J0ICogYXMgdTY0IGZyb20gXCIuL191NjQuanNcIjtcbmltcG9ydCB7IGNsZWFuLCBjcmVhdGVIYXNoZXIsIHJvdHIgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuLyoqXG4gKiBSb3VuZCBjb25zdGFudHM6XG4gKiBGaXJzdCAzMiBiaXRzIG9mIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIGN1YmUgcm9vdHMgb2YgdGhlIGZpcnN0IDY0IHByaW1lcyAyLi4zMTEpXG4gKi9cbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgU0hBMjU2X0sgPSAvKiBAX19QVVJFX18gKi8gVWludDMyQXJyYXkuZnJvbShbXG4gICAgMHg0MjhhMmY5OCwgMHg3MTM3NDQ5MSwgMHhiNWMwZmJjZiwgMHhlOWI1ZGJhNSwgMHgzOTU2YzI1YiwgMHg1OWYxMTFmMSwgMHg5MjNmODJhNCwgMHhhYjFjNWVkNSxcbiAgICAweGQ4MDdhYTk4LCAweDEyODM1YjAxLCAweDI0MzE4NWJlLCAweDU1MGM3ZGMzLCAweDcyYmU1ZDc0LCAweDgwZGViMWZlLCAweDliZGMwNmE3LCAweGMxOWJmMTc0LFxuICAgIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG4gICAgMHg5ODNlNTE1MiwgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCwgMHhiZjU5N2ZjNywgMHhjNmUwMGJmMywgMHhkNWE3OTE0NywgMHgwNmNhNjM1MSwgMHgxNDI5Mjk2NyxcbiAgICAweDI3YjcwYTg1LCAweDJlMWIyMTM4LCAweDRkMmM2ZGZjLCAweDUzMzgwZDEzLCAweDY1MGE3MzU0LCAweDc2NmEwYWJiLCAweDgxYzJjOTJlLCAweDkyNzIyYzg1LFxuICAgIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gICAgMHgxOWE0YzExNiwgMHgxZTM3NmMwOCwgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSwgMHgzOTFjMGNiMywgMHg0ZWQ4YWE0YSwgMHg1YjljY2E0ZiwgMHg2ODJlNmZmMyxcbiAgICAweDc0OGY4MmVlLCAweDc4YTU2MzZmLCAweDg0Yzg3ODE0LCAweDhjYzcwMjA4LCAweDkwYmVmZmZhLCAweGE0NTA2Y2ViLCAweGJlZjlhM2Y3LCAweGM2NzE3OGYyXG5dKTtcbi8qKiBSZXVzYWJsZSB0ZW1wb3JhcnkgYnVmZmVyLiBcIldcIiBjb21lcyBzdHJhaWdodCBmcm9tIHNwZWMuICovXG5jb25zdCBTSEEyNTZfVyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoNjQpO1xuZXhwb3J0IGNsYXNzIFNIQTI1NiBleHRlbmRzIEhhc2hNRCB7XG4gICAgY29uc3RydWN0b3Iob3V0cHV0TGVuID0gMzIpIHtcbiAgICAgICAgc3VwZXIoNjQsIG91dHB1dExlbiwgOCwgZmFsc2UpO1xuICAgICAgICAvLyBXZSBjYW5ub3QgdXNlIGFycmF5IGhlcmUgc2luY2UgYXJyYXkgYWxsb3dzIGluZGV4aW5nIGJ5IHZhcmlhYmxlXG4gICAgICAgIC8vIHdoaWNoIG1lYW5zIG9wdGltaXplci9jb21waWxlciBjYW5ub3QgdXNlIHJlZ2lzdGVycy5cbiAgICAgICAgdGhpcy5BID0gU0hBMjU2X0lWWzBdIHwgMDtcbiAgICAgICAgdGhpcy5CID0gU0hBMjU2X0lWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5DID0gU0hBMjU2X0lWWzJdIHwgMDtcbiAgICAgICAgdGhpcy5EID0gU0hBMjU2X0lWWzNdIHwgMDtcbiAgICAgICAgdGhpcy5FID0gU0hBMjU2X0lWWzRdIHwgMDtcbiAgICAgICAgdGhpcy5GID0gU0hBMjU2X0lWWzVdIHwgMDtcbiAgICAgICAgdGhpcy5HID0gU0hBMjU2X0lWWzZdIHwgMDtcbiAgICAgICAgdGhpcy5IID0gU0hBMjU2X0lWWzddIHwgMDtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbQSwgQiwgQywgRCwgRSwgRiwgRywgSF07XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKSB7XG4gICAgICAgIHRoaXMuQSA9IEEgfCAwO1xuICAgICAgICB0aGlzLkIgPSBCIHwgMDtcbiAgICAgICAgdGhpcy5DID0gQyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IEQgfCAwO1xuICAgICAgICB0aGlzLkUgPSBFIHwgMDtcbiAgICAgICAgdGhpcy5GID0gRiB8IDA7XG4gICAgICAgIHRoaXMuRyA9IEcgfCAwO1xuICAgICAgICB0aGlzLkggPSBIIHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgLy8gRXh0ZW5kIHRoZSBmaXJzdCAxNiB3b3JkcyBpbnRvIHRoZSByZW1haW5pbmcgNDggd29yZHMgd1sxNi4uNjNdIG9mIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGFycmF5XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpXG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCwgZmFsc2UpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBXMTUgPSBTSEEyNTZfV1tpIC0gMTVdO1xuICAgICAgICAgICAgY29uc3QgVzIgPSBTSEEyNTZfV1tpIC0gMl07XG4gICAgICAgICAgICBjb25zdCBzMCA9IHJvdHIoVzE1LCA3KSBeIHJvdHIoVzE1LCAxOCkgXiAoVzE1ID4+PiAzKTtcbiAgICAgICAgICAgIGNvbnN0IHMxID0gcm90cihXMiwgMTcpIF4gcm90cihXMiwgMTkpIF4gKFcyID4+PiAxMCk7XG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IChzMSArIFNIQTI1Nl9XW2kgLSA3XSArIHMwICsgU0hBMjU2X1dbaSAtIDE2XSkgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXByZXNzaW9uIGZ1bmN0aW9uIG1haW4gbG9vcCwgNjQgcm91bmRzXG4gICAgICAgIGxldCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc2lnbWExID0gcm90cihFLCA2KSBeIHJvdHIoRSwgMTEpIF4gcm90cihFLCAyNSk7XG4gICAgICAgICAgICBjb25zdCBUMSA9IChIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBMjU2X0tbaV0gKyBTSEEyNTZfV1tpXSkgfCAwO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWEwID0gcm90cihBLCAyKSBeIHJvdHIoQSwgMTMpIF4gcm90cihBLCAyMik7XG4gICAgICAgICAgICBjb25zdCBUMiA9IChzaWdtYTAgKyBNYWooQSwgQiwgQykpIHwgMDtcbiAgICAgICAgICAgIEggPSBHO1xuICAgICAgICAgICAgRyA9IEY7XG4gICAgICAgICAgICBGID0gRTtcbiAgICAgICAgICAgIEUgPSAoRCArIFQxKSB8IDA7XG4gICAgICAgICAgICBEID0gQztcbiAgICAgICAgICAgIEMgPSBCO1xuICAgICAgICAgICAgQiA9IEE7XG4gICAgICAgICAgICBBID0gKFQxICsgVDIpIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICBBID0gKEEgKyB0aGlzLkEpIHwgMDtcbiAgICAgICAgQiA9IChCICsgdGhpcy5CKSB8IDA7XG4gICAgICAgIEMgPSAoQyArIHRoaXMuQykgfCAwO1xuICAgICAgICBEID0gKEQgKyB0aGlzLkQpIHwgMDtcbiAgICAgICAgRSA9IChFICsgdGhpcy5FKSB8IDA7XG4gICAgICAgIEYgPSAoRiArIHRoaXMuRikgfCAwO1xuICAgICAgICBHID0gKEcgKyB0aGlzLkcpIHwgMDtcbiAgICAgICAgSCA9IChIICsgdGhpcy5IKSB8IDA7XG4gICAgICAgIHRoaXMuc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICBjbGVhbihTSEEyNTZfVyk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgICAgICBjbGVhbih0aGlzLmJ1ZmZlcik7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFNIQTIyNCBleHRlbmRzIFNIQTI1NiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDI4KTtcbiAgICAgICAgdGhpcy5BID0gU0hBMjI0X0lWWzBdIHwgMDtcbiAgICAgICAgdGhpcy5CID0gU0hBMjI0X0lWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5DID0gU0hBMjI0X0lWWzJdIHwgMDtcbiAgICAgICAgdGhpcy5EID0gU0hBMjI0X0lWWzNdIHwgMDtcbiAgICAgICAgdGhpcy5FID0gU0hBMjI0X0lWWzRdIHwgMDtcbiAgICAgICAgdGhpcy5GID0gU0hBMjI0X0lWWzVdIHwgMDtcbiAgICAgICAgdGhpcy5HID0gU0hBMjI0X0lWWzZdIHwgMDtcbiAgICAgICAgdGhpcy5IID0gU0hBMjI0X0lWWzddIHwgMDtcbiAgICB9XG59XG4vLyBTSEEyLTUxMiBpcyBzbG93ZXIgdGhhbiBzaGEyNTYgaW4ganMgYmVjYXVzZSB1NjQgb3BlcmF0aW9ucyBhcmUgc2xvdy5cbi8vIFJvdW5kIGNvbnRhbnRzXG4vLyBGaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBjdWJlIHJvb3RzIG9mIHRoZSBmaXJzdCA4MCBwcmltZXMgMi4uNDA5XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IEs1MTIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHU2NC5zcGxpdChbXG4gICAgJzB4NDI4YTJmOThkNzI4YWUyMicsICcweDcxMzc0NDkxMjNlZjY1Y2QnLCAnMHhiNWMwZmJjZmVjNGQzYjJmJywgJzB4ZTliNWRiYTU4MTg5ZGJiYycsXG4gICAgJzB4Mzk1NmMyNWJmMzQ4YjUzOCcsICcweDU5ZjExMWYxYjYwNWQwMTknLCAnMHg5MjNmODJhNGFmMTk0ZjliJywgJzB4YWIxYzVlZDVkYTZkODExOCcsXG4gICAgJzB4ZDgwN2FhOThhMzAzMDI0MicsICcweDEyODM1YjAxNDU3MDZmYmUnLCAnMHgyNDMxODViZTRlZTRiMjhjJywgJzB4NTUwYzdkYzNkNWZmYjRlMicsXG4gICAgJzB4NzJiZTVkNzRmMjdiODk2ZicsICcweDgwZGViMWZlM2IxNjk2YjEnLCAnMHg5YmRjMDZhNzI1YzcxMjM1JywgJzB4YzE5YmYxNzRjZjY5MjY5NCcsXG4gICAgJzB4ZTQ5YjY5YzE5ZWYxNGFkMicsICcweGVmYmU0Nzg2Mzg0ZjI1ZTMnLCAnMHgwZmMxOWRjNjhiOGNkNWI1JywgJzB4MjQwY2ExY2M3N2FjOWM2NScsXG4gICAgJzB4MmRlOTJjNmY1OTJiMDI3NScsICcweDRhNzQ4NGFhNmVhNmU0ODMnLCAnMHg1Y2IwYTlkY2JkNDFmYmQ0JywgJzB4NzZmOTg4ZGE4MzExNTNiNScsXG4gICAgJzB4OTgzZTUxNTJlZTY2ZGZhYicsICcweGE4MzFjNjZkMmRiNDMyMTAnLCAnMHhiMDAzMjdjODk4ZmIyMTNmJywgJzB4YmY1OTdmYzdiZWVmMGVlNCcsXG4gICAgJzB4YzZlMDBiZjMzZGE4OGZjMicsICcweGQ1YTc5MTQ3OTMwYWE3MjUnLCAnMHgwNmNhNjM1MWUwMDM4MjZmJywgJzB4MTQyOTI5NjcwYTBlNmU3MCcsXG4gICAgJzB4MjdiNzBhODU0NmQyMmZmYycsICcweDJlMWIyMTM4NWMyNmM5MjYnLCAnMHg0ZDJjNmRmYzVhYzQyYWVkJywgJzB4NTMzODBkMTM5ZDk1YjNkZicsXG4gICAgJzB4NjUwYTczNTQ4YmFmNjNkZScsICcweDc2NmEwYWJiM2M3N2IyYTgnLCAnMHg4MWMyYzkyZTQ3ZWRhZWU2JywgJzB4OTI3MjJjODUxNDgyMzUzYicsXG4gICAgJzB4YTJiZmU4YTE0Y2YxMDM2NCcsICcweGE4MWE2NjRiYmM0MjMwMDEnLCAnMHhjMjRiOGI3MGQwZjg5NzkxJywgJzB4Yzc2YzUxYTMwNjU0YmUzMCcsXG4gICAgJzB4ZDE5MmU4MTlkNmVmNTIxOCcsICcweGQ2OTkwNjI0NTU2NWE5MTAnLCAnMHhmNDBlMzU4NTU3NzEyMDJhJywgJzB4MTA2YWEwNzAzMmJiZDFiOCcsXG4gICAgJzB4MTlhNGMxMTZiOGQyZDBjOCcsICcweDFlMzc2YzA4NTE0MWFiNTMnLCAnMHgyNzQ4Nzc0Y2RmOGVlYjk5JywgJzB4MzRiMGJjYjVlMTliNDhhOCcsXG4gICAgJzB4MzkxYzBjYjNjNWM5NWE2MycsICcweDRlZDhhYTRhZTM0MThhY2InLCAnMHg1YjljY2E0Zjc3NjNlMzczJywgJzB4NjgyZTZmZjNkNmIyYjhhMycsXG4gICAgJzB4NzQ4ZjgyZWU1ZGVmYjJmYycsICcweDc4YTU2MzZmNDMxNzJmNjAnLCAnMHg4NGM4NzgxNGExZjBhYjcyJywgJzB4OGNjNzAyMDgxYTY0MzllYycsXG4gICAgJzB4OTBiZWZmZmEyMzYzMWUyOCcsICcweGE0NTA2Y2ViZGU4MmJkZTknLCAnMHhiZWY5YTNmN2IyYzY3OTE1JywgJzB4YzY3MTc4ZjJlMzcyNTMyYicsXG4gICAgJzB4Y2EyNzNlY2VlYTI2NjE5YycsICcweGQxODZiOGM3MjFjMGMyMDcnLCAnMHhlYWRhN2RkNmNkZTBlYjFlJywgJzB4ZjU3ZDRmN2ZlZTZlZDE3OCcsXG4gICAgJzB4MDZmMDY3YWE3MjE3NmZiYScsICcweDBhNjM3ZGM1YTJjODk4YTYnLCAnMHgxMTNmOTgwNGJlZjkwZGFlJywgJzB4MWI3MTBiMzUxMzFjNDcxYicsXG4gICAgJzB4MjhkYjc3ZjUyMzA0N2Q4NCcsICcweDMyY2FhYjdiNDBjNzI0OTMnLCAnMHgzYzllYmUwYTE1YzliZWJjJywgJzB4NDMxZDY3YzQ5YzEwMGQ0YycsXG4gICAgJzB4NGNjNWQ0YmVjYjNlNDJiNicsICcweDU5N2YyOTljZmM2NTdlMmEnLCAnMHg1ZmNiNmZhYjNhZDZmYWVjJywgJzB4NmM0NDE5OGM0YTQ3NTgxNydcbl0ubWFwKG4gPT4gQmlnSW50KG4pKSkpKCk7XG5jb25zdCBTSEE1MTJfS2ggPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IEs1MTJbMF0pKCk7XG5jb25zdCBTSEE1MTJfS2wgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IEs1MTJbMV0pKCk7XG4vLyBSZXVzYWJsZSB0ZW1wb3JhcnkgYnVmZmVyc1xuY29uc3QgU0hBNTEyX1dfSCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoODApO1xuY29uc3QgU0hBNTEyX1dfTCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoODApO1xuZXhwb3J0IGNsYXNzIFNIQTUxMiBleHRlbmRzIEhhc2hNRCB7XG4gICAgY29uc3RydWN0b3Iob3V0cHV0TGVuID0gNjQpIHtcbiAgICAgICAgc3VwZXIoMTI4LCBvdXRwdXRMZW4sIDE2LCBmYWxzZSk7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB1c2UgYXJyYXkgaGVyZSBzaW5jZSBhcnJheSBhbGxvd3MgaW5kZXhpbmcgYnkgdmFyaWFibGVcbiAgICAgICAgLy8gd2hpY2ggbWVhbnMgb3B0aW1pemVyL2NvbXBpbGVyIGNhbm5vdCB1c2UgcmVnaXN0ZXJzLlxuICAgICAgICAvLyBoIC0tIGhpZ2ggMzIgYml0cywgbCAtLSBsb3cgMzIgYml0c1xuICAgICAgICB0aGlzLkFoID0gU0hBNTEyX0lWWzBdIHwgMDtcbiAgICAgICAgdGhpcy5BbCA9IFNIQTUxMl9JVlsxXSB8IDA7XG4gICAgICAgIHRoaXMuQmggPSBTSEE1MTJfSVZbMl0gfCAwO1xuICAgICAgICB0aGlzLkJsID0gU0hBNTEyX0lWWzNdIHwgMDtcbiAgICAgICAgdGhpcy5DaCA9IFNIQTUxMl9JVls0XSB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSBTSEE1MTJfSVZbNV0gfCAwO1xuICAgICAgICB0aGlzLkRoID0gU0hBNTEyX0lWWzZdIHwgMDtcbiAgICAgICAgdGhpcy5EbCA9IFNIQTUxMl9JVls3XSB8IDA7XG4gICAgICAgIHRoaXMuRWggPSBTSEE1MTJfSVZbOF0gfCAwO1xuICAgICAgICB0aGlzLkVsID0gU0hBNTEyX0lWWzldIHwgMDtcbiAgICAgICAgdGhpcy5GaCA9IFNIQTUxMl9JVlsxMF0gfCAwO1xuICAgICAgICB0aGlzLkZsID0gU0hBNTEyX0lWWzExXSB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSBTSEE1MTJfSVZbMTJdIHwgMDtcbiAgICAgICAgdGhpcy5HbCA9IFNIQTUxMl9JVlsxM10gfCAwO1xuICAgICAgICB0aGlzLkhoID0gU0hBNTEyX0lWWzE0XSB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSBTSEE1MTJfSVZbMTVdIHwgMDtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEFoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW0FoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsXTtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgc2V0KEFoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsKSB7XG4gICAgICAgIHRoaXMuQWggPSBBaCB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSBBbCB8IDA7XG4gICAgICAgIHRoaXMuQmggPSBCaCB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSBCbCB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSBDaCB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSBDbCB8IDA7XG4gICAgICAgIHRoaXMuRGggPSBEaCB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSBEbCB8IDA7XG4gICAgICAgIHRoaXMuRWggPSBFaCB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSBFbCB8IDA7XG4gICAgICAgIHRoaXMuRmggPSBGaCB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSBGbCB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSBHaCB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSBHbCB8IDA7XG4gICAgICAgIHRoaXMuSGggPSBIaCB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSBIbCB8IDA7XG4gICAgfVxuICAgIHByb2Nlc3Modmlldywgb2Zmc2V0KSB7XG4gICAgICAgIC8vIEV4dGVuZCB0aGUgZmlyc3QgMTYgd29yZHMgaW50byB0aGUgcmVtYWluaW5nIDY0IHdvcmRzIHdbMTYuLjc5XSBvZiB0aGUgbWVzc2FnZSBzY2hlZHVsZSBhcnJheVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyssIG9mZnNldCArPSA0KSB7XG4gICAgICAgICAgICBTSEE1MTJfV19IW2ldID0gdmlldy5nZXRVaW50MzIob2Zmc2V0KTtcbiAgICAgICAgICAgIFNIQTUxMl9XX0xbaV0gPSB2aWV3LmdldFVpbnQzMigob2Zmc2V0ICs9IDQpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA4MDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBzMCA6PSAod1tpLTE1XSByaWdodHJvdGF0ZSAxKSB4b3IgKHdbaS0xNV0gcmlnaHRyb3RhdGUgOCkgeG9yICh3W2ktMTVdIHJpZ2h0c2hpZnQgNylcbiAgICAgICAgICAgIGNvbnN0IFcxNWggPSBTSEE1MTJfV19IW2kgLSAxNV0gfCAwO1xuICAgICAgICAgICAgY29uc3QgVzE1bCA9IFNIQTUxMl9XX0xbaSAtIDE1XSB8IDA7XG4gICAgICAgICAgICBjb25zdCBzMGggPSB1NjQucm90clNIKFcxNWgsIFcxNWwsIDEpIF4gdTY0LnJvdHJTSChXMTVoLCBXMTVsLCA4KSBeIHU2NC5zaHJTSChXMTVoLCBXMTVsLCA3KTtcbiAgICAgICAgICAgIGNvbnN0IHMwbCA9IHU2NC5yb3RyU0woVzE1aCwgVzE1bCwgMSkgXiB1NjQucm90clNMKFcxNWgsIFcxNWwsIDgpIF4gdTY0LnNoclNMKFcxNWgsIFcxNWwsIDcpO1xuICAgICAgICAgICAgLy8gczEgOj0gKHdbaS0yXSByaWdodHJvdGF0ZSAxOSkgeG9yICh3W2ktMl0gcmlnaHRyb3RhdGUgNjEpIHhvciAod1tpLTJdIHJpZ2h0c2hpZnQgNilcbiAgICAgICAgICAgIGNvbnN0IFcyaCA9IFNIQTUxMl9XX0hbaSAtIDJdIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IFcybCA9IFNIQTUxMl9XX0xbaSAtIDJdIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHMxaCA9IHU2NC5yb3RyU0goVzJoLCBXMmwsIDE5KSBeIHU2NC5yb3RyQkgoVzJoLCBXMmwsIDYxKSBeIHU2NC5zaHJTSChXMmgsIFcybCwgNik7XG4gICAgICAgICAgICBjb25zdCBzMWwgPSB1NjQucm90clNMKFcyaCwgVzJsLCAxOSkgXiB1NjQucm90ckJMKFcyaCwgVzJsLCA2MSkgXiB1NjQuc2hyU0woVzJoLCBXMmwsIDYpO1xuICAgICAgICAgICAgLy8gU0hBMjU2X1dbaV0gPSBzMCArIHMxICsgU0hBMjU2X1dbaSAtIDddICsgU0hBMjU2X1dbaSAtIDE2XTtcbiAgICAgICAgICAgIGNvbnN0IFNVTWwgPSB1NjQuYWRkNEwoczBsLCBzMWwsIFNIQTUxMl9XX0xbaSAtIDddLCBTSEE1MTJfV19MW2kgLSAxNl0pO1xuICAgICAgICAgICAgY29uc3QgU1VNaCA9IHU2NC5hZGQ0SChTVU1sLCBzMGgsIHMxaCwgU0hBNTEyX1dfSFtpIC0gN10sIFNIQTUxMl9XX0hbaSAtIDE2XSk7XG4gICAgICAgICAgICBTSEE1MTJfV19IW2ldID0gU1VNaCB8IDA7XG4gICAgICAgICAgICBTSEE1MTJfV19MW2ldID0gU1VNbCB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwgfSA9IHRoaXM7XG4gICAgICAgIC8vIENvbXByZXNzaW9uIGZ1bmN0aW9uIG1haW4gbG9vcCwgODAgcm91bmRzXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODA7IGkrKykge1xuICAgICAgICAgICAgLy8gUzEgOj0gKGUgcmlnaHRyb3RhdGUgMTQpIHhvciAoZSByaWdodHJvdGF0ZSAxOCkgeG9yIChlIHJpZ2h0cm90YXRlIDQxKVxuICAgICAgICAgICAgY29uc3Qgc2lnbWExaCA9IHU2NC5yb3RyU0goRWgsIEVsLCAxNCkgXiB1NjQucm90clNIKEVoLCBFbCwgMTgpIF4gdTY0LnJvdHJCSChFaCwgRWwsIDQxKTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMWwgPSB1NjQucm90clNMKEVoLCBFbCwgMTQpIF4gdTY0LnJvdHJTTChFaCwgRWwsIDE4KSBeIHU2NC5yb3RyQkwoRWgsIEVsLCA0MSk7XG4gICAgICAgICAgICAvL2NvbnN0IFQxID0gKEggKyBzaWdtYTEgKyBDaGkoRSwgRiwgRykgKyBTSEEyNTZfS1tpXSArIFNIQTI1Nl9XW2ldKSB8IDA7XG4gICAgICAgICAgICBjb25zdCBDSEloID0gKEVoICYgRmgpIF4gKH5FaCAmIEdoKTtcbiAgICAgICAgICAgIGNvbnN0IENISWwgPSAoRWwgJiBGbCkgXiAofkVsICYgR2wpO1xuICAgICAgICAgICAgLy8gVDEgPSBIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBNTEyX0tbaV0gKyBTSEE1MTJfV1tpXVxuICAgICAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBjb25zdCBUMWxsID0gdTY0LmFkZDVMKEhsLCBzaWdtYTFsLCBDSElsLCBTSEE1MTJfS2xbaV0sIFNIQTUxMl9XX0xbaV0pO1xuICAgICAgICAgICAgY29uc3QgVDFoID0gdTY0LmFkZDVIKFQxbGwsIEhoLCBzaWdtYTFoLCBDSEloLCBTSEE1MTJfS2hbaV0sIFNIQTUxMl9XX0hbaV0pO1xuICAgICAgICAgICAgY29uc3QgVDFsID0gVDFsbCB8IDA7XG4gICAgICAgICAgICAvLyBTMCA6PSAoYSByaWdodHJvdGF0ZSAyOCkgeG9yIChhIHJpZ2h0cm90YXRlIDM0KSB4b3IgKGEgcmlnaHRyb3RhdGUgMzkpXG4gICAgICAgICAgICBjb25zdCBzaWdtYTBoID0gdTY0LnJvdHJTSChBaCwgQWwsIDI4KSBeIHU2NC5yb3RyQkgoQWgsIEFsLCAzNCkgXiB1NjQucm90ckJIKEFoLCBBbCwgMzkpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWEwbCA9IHU2NC5yb3RyU0woQWgsIEFsLCAyOCkgXiB1NjQucm90ckJMKEFoLCBBbCwgMzQpIF4gdTY0LnJvdHJCTChBaCwgQWwsIDM5KTtcbiAgICAgICAgICAgIGNvbnN0IE1BSmggPSAoQWggJiBCaCkgXiAoQWggJiBDaCkgXiAoQmggJiBDaCk7XG4gICAgICAgICAgICBjb25zdCBNQUpsID0gKEFsICYgQmwpIF4gKEFsICYgQ2wpIF4gKEJsICYgQ2wpO1xuICAgICAgICAgICAgSGggPSBHaCB8IDA7XG4gICAgICAgICAgICBIbCA9IEdsIHwgMDtcbiAgICAgICAgICAgIEdoID0gRmggfCAwO1xuICAgICAgICAgICAgR2wgPSBGbCB8IDA7XG4gICAgICAgICAgICBGaCA9IEVoIHwgMDtcbiAgICAgICAgICAgIEZsID0gRWwgfCAwO1xuICAgICAgICAgICAgKHsgaDogRWgsIGw6IEVsIH0gPSB1NjQuYWRkKERoIHwgMCwgRGwgfCAwLCBUMWggfCAwLCBUMWwgfCAwKSk7XG4gICAgICAgICAgICBEaCA9IENoIHwgMDtcbiAgICAgICAgICAgIERsID0gQ2wgfCAwO1xuICAgICAgICAgICAgQ2ggPSBCaCB8IDA7XG4gICAgICAgICAgICBDbCA9IEJsIHwgMDtcbiAgICAgICAgICAgIEJoID0gQWggfCAwO1xuICAgICAgICAgICAgQmwgPSBBbCB8IDA7XG4gICAgICAgICAgICBjb25zdCBBbGwgPSB1NjQuYWRkM0woVDFsLCBzaWdtYTBsLCBNQUpsKTtcbiAgICAgICAgICAgIEFoID0gdTY0LmFkZDNIKEFsbCwgVDFoLCBzaWdtYTBoLCBNQUpoKTtcbiAgICAgICAgICAgIEFsID0gQWxsIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICAoeyBoOiBBaCwgbDogQWwgfSA9IHU2NC5hZGQodGhpcy5BaCB8IDAsIHRoaXMuQWwgfCAwLCBBaCB8IDAsIEFsIHwgMCkpO1xuICAgICAgICAoeyBoOiBCaCwgbDogQmwgfSA9IHU2NC5hZGQodGhpcy5CaCB8IDAsIHRoaXMuQmwgfCAwLCBCaCB8IDAsIEJsIHwgMCkpO1xuICAgICAgICAoeyBoOiBDaCwgbDogQ2wgfSA9IHU2NC5hZGQodGhpcy5DaCB8IDAsIHRoaXMuQ2wgfCAwLCBDaCB8IDAsIENsIHwgMCkpO1xuICAgICAgICAoeyBoOiBEaCwgbDogRGwgfSA9IHU2NC5hZGQodGhpcy5EaCB8IDAsIHRoaXMuRGwgfCAwLCBEaCB8IDAsIERsIHwgMCkpO1xuICAgICAgICAoeyBoOiBFaCwgbDogRWwgfSA9IHU2NC5hZGQodGhpcy5FaCB8IDAsIHRoaXMuRWwgfCAwLCBFaCB8IDAsIEVsIHwgMCkpO1xuICAgICAgICAoeyBoOiBGaCwgbDogRmwgfSA9IHU2NC5hZGQodGhpcy5GaCB8IDAsIHRoaXMuRmwgfCAwLCBGaCB8IDAsIEZsIHwgMCkpO1xuICAgICAgICAoeyBoOiBHaCwgbDogR2wgfSA9IHU2NC5hZGQodGhpcy5HaCB8IDAsIHRoaXMuR2wgfCAwLCBHaCB8IDAsIEdsIHwgMCkpO1xuICAgICAgICAoeyBoOiBIaCwgbDogSGwgfSA9IHU2NC5hZGQodGhpcy5IaCB8IDAsIHRoaXMuSGwgfCAwLCBIaCB8IDAsIEhsIHwgMCkpO1xuICAgICAgICB0aGlzLnNldChBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCk7XG4gICAgfVxuICAgIHJvdW5kQ2xlYW4oKSB7XG4gICAgICAgIGNsZWFuKFNIQTUxMl9XX0gsIFNIQTUxMl9XX0wpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBjbGVhbih0aGlzLmJ1ZmZlcik7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBTSEEzODQgZXh0ZW5kcyBTSEE1MTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcig0OCk7XG4gICAgICAgIHRoaXMuQWggPSBTSEEzODRfSVZbMF0gfCAwO1xuICAgICAgICB0aGlzLkFsID0gU0hBMzg0X0lWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IFNIQTM4NF9JVlsyXSB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSBTSEEzODRfSVZbM10gfCAwO1xuICAgICAgICB0aGlzLkNoID0gU0hBMzg0X0lWWzRdIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IFNIQTM4NF9JVls1XSB8IDA7XG4gICAgICAgIHRoaXMuRGggPSBTSEEzODRfSVZbNl0gfCAwO1xuICAgICAgICB0aGlzLkRsID0gU0hBMzg0X0lWWzddIHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IFNIQTM4NF9JVls4XSB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSBTSEEzODRfSVZbOV0gfCAwO1xuICAgICAgICB0aGlzLkZoID0gU0hBMzg0X0lWWzEwXSB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSBTSEEzODRfSVZbMTFdIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IFNIQTM4NF9JVlsxMl0gfCAwO1xuICAgICAgICB0aGlzLkdsID0gU0hBMzg0X0lWWzEzXSB8IDA7XG4gICAgICAgIHRoaXMuSGggPSBTSEEzODRfSVZbMTRdIHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IFNIQTM4NF9JVlsxNV0gfCAwO1xuICAgIH1cbn1cbi8qKlxuICogVHJ1bmNhdGVkIFNIQTUxMi8yNTYgYW5kIFNIQTUxMi8yMjQuXG4gKiBTSEE1MTJfSVYgaXMgWE9SZWQgd2l0aCAweGE1YTVhNWE1YTVhNWE1YTUsIHRoZW4gdXNlZCBhcyBcImludGVybWVkaWFyeVwiIElWIG9mIFNIQTUxMi90LlxuICogVGhlbiB0IGhhc2hlcyBzdHJpbmcgdG8gcHJvZHVjZSByZXN1bHQgSVYuXG4gKiBTZWUgYHRlc3QvbWlzYy9zaGEyLWdlbi1pdi5qc2AuXG4gKi9cbi8qKiBTSEE1MTIvMjI0IElWICovXG5jb25zdCBUMjI0X0lWID0gLyogQF9fUFVSRV9fICovIFVpbnQzMkFycmF5LmZyb20oW1xuICAgIDB4OGMzZDM3YzgsIDB4MTk1NDRkYTIsIDB4NzNlMTk5NjYsIDB4ODlkY2Q0ZDYsIDB4MWRmYWI3YWUsIDB4MzJmZjljODIsIDB4Njc5ZGQ1MTQsIDB4NTgyZjlmY2YsXG4gICAgMHgwZjZkMmI2OSwgMHg3YmQ0NGRhOCwgMHg3N2UzNmY3MywgMHgwNGM0ODk0MiwgMHgzZjlkODVhOCwgMHg2YTFkMzZjOCwgMHgxMTEyZTZhZCwgMHg5MWQ2OTJhMSxcbl0pO1xuLyoqIFNIQTUxMi8yNTYgSVYgKi9cbmNvbnN0IFQyNTZfSVYgPSAvKiBAX19QVVJFX18gKi8gVWludDMyQXJyYXkuZnJvbShbXG4gICAgMHgyMjMxMjE5NCwgMHhmYzJiZjcyYywgMHg5ZjU1NWZhMywgMHhjODRjNjRjMiwgMHgyMzkzYjg2YiwgMHg2ZjUzYjE1MSwgMHg5NjM4NzcxOSwgMHg1OTQwZWFiZCxcbiAgICAweDk2MjgzZWUyLCAweGE4OGVmZmUzLCAweGJlNWUxZTI1LCAweDUzODYzOTkyLCAweDJiMDE5OWZjLCAweDJjODViOGFhLCAweDBlYjcyZGRjLCAweDgxYzUyY2EyLFxuXSk7XG5leHBvcnQgY2xhc3MgU0hBNTEyXzIyNCBleHRlbmRzIFNIQTUxMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDI4KTtcbiAgICAgICAgdGhpcy5BaCA9IFQyMjRfSVZbMF0gfCAwO1xuICAgICAgICB0aGlzLkFsID0gVDIyNF9JVlsxXSB8IDA7XG4gICAgICAgIHRoaXMuQmggPSBUMjI0X0lWWzJdIHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IFQyMjRfSVZbM10gfCAwO1xuICAgICAgICB0aGlzLkNoID0gVDIyNF9JVls0XSB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSBUMjI0X0lWWzVdIHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IFQyMjRfSVZbNl0gfCAwO1xuICAgICAgICB0aGlzLkRsID0gVDIyNF9JVls3XSB8IDA7XG4gICAgICAgIHRoaXMuRWggPSBUMjI0X0lWWzhdIHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IFQyMjRfSVZbOV0gfCAwO1xuICAgICAgICB0aGlzLkZoID0gVDIyNF9JVlsxMF0gfCAwO1xuICAgICAgICB0aGlzLkZsID0gVDIyNF9JVlsxMV0gfCAwO1xuICAgICAgICB0aGlzLkdoID0gVDIyNF9JVlsxMl0gfCAwO1xuICAgICAgICB0aGlzLkdsID0gVDIyNF9JVlsxM10gfCAwO1xuICAgICAgICB0aGlzLkhoID0gVDIyNF9JVlsxNF0gfCAwO1xuICAgICAgICB0aGlzLkhsID0gVDIyNF9JVlsxNV0gfCAwO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBTSEE1MTJfMjU2IGV4dGVuZHMgU0hBNTEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoMzIpO1xuICAgICAgICB0aGlzLkFoID0gVDI1Nl9JVlswXSB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSBUMjU2X0lWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IFQyNTZfSVZbMl0gfCAwO1xuICAgICAgICB0aGlzLkJsID0gVDI1Nl9JVlszXSB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSBUMjU2X0lWWzRdIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IFQyNTZfSVZbNV0gfCAwO1xuICAgICAgICB0aGlzLkRoID0gVDI1Nl9JVls2XSB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSBUMjU2X0lWWzddIHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IFQyNTZfSVZbOF0gfCAwO1xuICAgICAgICB0aGlzLkVsID0gVDI1Nl9JVls5XSB8IDA7XG4gICAgICAgIHRoaXMuRmggPSBUMjU2X0lWWzEwXSB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSBUMjU2X0lWWzExXSB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSBUMjU2X0lWWzEyXSB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSBUMjU2X0lWWzEzXSB8IDA7XG4gICAgICAgIHRoaXMuSGggPSBUMjU2X0lWWzE0XSB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSBUMjU2X0lWWzE1XSB8IDA7XG4gICAgfVxufVxuLyoqXG4gKiBTSEEyLTI1NiBoYXNoIGZ1bmN0aW9uIGZyb20gUkZDIDQ2MzQuXG4gKlxuICogSXQgaXMgdGhlIGZhc3Rlc3QgSlMgaGFzaCwgZXZlbiBmYXN0ZXIgdGhhbiBCbGFrZTMuXG4gKiBUbyBicmVhayBzaGEyNTYgdXNpbmcgYmlydGhkYXkgYXR0YWNrLCBhdHRhY2tlcnMgbmVlZCB0byB0cnkgMl4xMjggaGFzaGVzLlxuICogQlRDIG5ldHdvcmsgaXMgZG9pbmcgMl43MCBoYXNoZXMvc2VjICgyXjk1IGhhc2hlcy95ZWFyKSBhcyBwZXIgMjAyNS5cbiAqL1xuZXhwb3J0IGNvbnN0IHNoYTI1NiA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVIYXNoZXIoKCkgPT4gbmV3IFNIQTI1NigpKTtcbi8qKiBTSEEyLTIyNCBoYXNoIGZ1bmN0aW9uIGZyb20gUkZDIDQ2MzQgKi9cbmV4cG9ydCBjb25zdCBzaGEyMjQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlSGFzaGVyKCgpID0+IG5ldyBTSEEyMjQoKSk7XG4vKiogU0hBMi01MTIgaGFzaCBmdW5jdGlvbiBmcm9tIFJGQyA0NjM0LiAqL1xuZXhwb3J0IGNvbnN0IHNoYTUxMiA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVIYXNoZXIoKCkgPT4gbmV3IFNIQTUxMigpKTtcbi8qKiBTSEEyLTM4NCBoYXNoIGZ1bmN0aW9uIGZyb20gUkZDIDQ2MzQuICovXG5leHBvcnQgY29uc3Qgc2hhMzg0ID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUhhc2hlcigoKSA9PiBuZXcgU0hBMzg0KCkpO1xuLyoqXG4gKiBTSEEyLTUxMi8yNTYgXCJ0cnVuY2F0ZWRcIiBoYXNoIGZ1bmN0aW9uLCB3aXRoIGltcHJvdmVkIHJlc2lzdGFuY2UgdG8gbGVuZ3RoIGV4dGVuc2lvbiBhdHRhY2tzLlxuICogU2VlIHRoZSBwYXBlciBvbiBbdHJ1bmNhdGVkIFNIQTUxMl0oaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxMC81NDgucGRmKS5cbiAqL1xuZXhwb3J0IGNvbnN0IHNoYTUxMl8yNTYgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlSGFzaGVyKCgpID0+IG5ldyBTSEE1MTJfMjU2KCkpO1xuLyoqXG4gKiBTSEEyLTUxMi8yMjQgXCJ0cnVuY2F0ZWRcIiBoYXNoIGZ1bmN0aW9uLCB3aXRoIGltcHJvdmVkIHJlc2lzdGFuY2UgdG8gbGVuZ3RoIGV4dGVuc2lvbiBhdHRhY2tzLlxuICogU2VlIHRoZSBwYXBlciBvbiBbdHJ1bmNhdGVkIFNIQTUxMl0oaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxMC81NDgucGRmKS5cbiAqL1xuZXhwb3J0IGNvbnN0IHNoYTUxMl8yMjQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlSGFzaGVyKCgpID0+IG5ldyBTSEE1MTJfMjI0KCkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhMi5qcy5tYXAiXSwibmFtZXMiOlsiQ2hpIiwiSGFzaE1EIiwiTWFqIiwiU0hBMjI0X0lWIiwiU0hBMjU2X0lWIiwiU0hBMzg0X0lWIiwiU0hBNTEyX0lWIiwidTY0IiwiY2xlYW4iLCJjcmVhdGVIYXNoZXIiLCJyb3RyIiwiU0hBMjU2X0siLCJVaW50MzJBcnJheSIsImZyb20iLCJTSEEyNTZfVyIsIlNIQTI1NiIsImNvbnN0cnVjdG9yIiwib3V0cHV0TGVuIiwiQSIsIkIiLCJDIiwiRCIsIkUiLCJGIiwiRyIsIkgiLCJnZXQiLCJzZXQiLCJwcm9jZXNzIiwidmlldyIsIm9mZnNldCIsImkiLCJnZXRVaW50MzIiLCJXMTUiLCJXMiIsInMwIiwiczEiLCJzaWdtYTEiLCJUMSIsInNpZ21hMCIsIlQyIiwicm91bmRDbGVhbiIsImRlc3Ryb3kiLCJidWZmZXIiLCJTSEEyMjQiLCJLNTEyIiwic3BsaXQiLCJtYXAiLCJuIiwiQmlnSW50IiwiU0hBNTEyX0toIiwiU0hBNTEyX0tsIiwiU0hBNTEyX1dfSCIsIlNIQTUxMl9XX0wiLCJTSEE1MTIiLCJBaCIsIkFsIiwiQmgiLCJCbCIsIkNoIiwiQ2wiLCJEaCIsIkRsIiwiRWgiLCJFbCIsIkZoIiwiRmwiLCJHaCIsIkdsIiwiSGgiLCJIbCIsIlcxNWgiLCJXMTVsIiwiczBoIiwicm90clNIIiwic2hyU0giLCJzMGwiLCJyb3RyU0wiLCJzaHJTTCIsIlcyaCIsIlcybCIsInMxaCIsInJvdHJCSCIsInMxbCIsInJvdHJCTCIsIlNVTWwiLCJhZGQ0TCIsIlNVTWgiLCJhZGQ0SCIsInNpZ21hMWgiLCJzaWdtYTFsIiwiQ0hJaCIsIkNISWwiLCJUMWxsIiwiYWRkNUwiLCJUMWgiLCJhZGQ1SCIsIlQxbCIsInNpZ21hMGgiLCJzaWdtYTBsIiwiTUFKaCIsIk1BSmwiLCJoIiwibCIsImFkZCIsIkFsbCIsImFkZDNMIiwiYWRkM0giLCJTSEEzODQiLCJUMjI0X0lWIiwiVDI1Nl9JViIsIlNIQTUxMl8yMjQiLCJTSEE1MTJfMjU2Iiwic2hhMjU2Iiwic2hhMjI0Iiwic2hhNTEyIiwic2hhMzg0Iiwic2hhNTEyXzI1NiIsInNoYTUxMl8yMjQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/sha2.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/sha256.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/sha256.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA224: () => (/* binding */ SHA224),\n/* harmony export */   SHA256: () => (/* binding */ SHA256),\n/* harmony export */   sha224: () => (/* binding */ sha224),\n/* harmony export */   sha256: () => (/* binding */ sha256)\n/* harmony export */ });\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sha2.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/sha2.js\");\n/**\n * SHA2-256 a.k.a. sha256. In JS, it is the fastest hash, even faster than Blake3.\n *\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n *\n * Check out [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n * @deprecated\n */ \n/** @deprecated Use import from `noble/hashes/sha2` module */ const SHA256 = _sha2_js__WEBPACK_IMPORTED_MODULE_0__.SHA256;\n/** @deprecated Use import from `noble/hashes/sha2` module */ const sha256 = _sha2_js__WEBPACK_IMPORTED_MODULE_0__.sha256;\n/** @deprecated Use import from `noble/hashes/sha2` module */ const SHA224 = _sha2_js__WEBPACK_IMPORTED_MODULE_0__.SHA224;\n/** @deprecated Use import from `noble/hashes/sha2` module */ const sha224 = _sha2_js__WEBPACK_IMPORTED_MODULE_0__.sha224; //# sourceMappingURL=sha256.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEyNTYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7O0NBU0MsR0FDdUc7QUFDeEcsMkRBQTJELEdBQ3BELE1BQU1JLFNBQVNDLDRDQUFPQSxDQUFDO0FBQzlCLDJEQUEyRCxHQUNwRCxNQUFNQyxTQUFTQyw0Q0FBT0EsQ0FBQztBQUM5QiwyREFBMkQsR0FDcEQsTUFBTVAsU0FBU0MsNENBQU9BLENBQUM7QUFDOUIsMkRBQTJELEdBQ3BELE1BQU1DLFNBQVNDLDRDQUFPQSxDQUFDLENBQzlCLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsYXctd29ya3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEyNTYuanM/MzdjZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFNIQTItMjU2IGEuay5hLiBzaGEyNTYuIEluIEpTLCBpdCBpcyB0aGUgZmFzdGVzdCBoYXNoLCBldmVuIGZhc3RlciB0aGFuIEJsYWtlMy5cbiAqXG4gKiBUbyBicmVhayBzaGEyNTYgdXNpbmcgYmlydGhkYXkgYXR0YWNrLCBhdHRhY2tlcnMgbmVlZCB0byB0cnkgMl4xMjggaGFzaGVzLlxuICogQlRDIG5ldHdvcmsgaXMgZG9pbmcgMl43MCBoYXNoZXMvc2VjICgyXjk1IGhhc2hlcy95ZWFyKSBhcyBwZXIgMjAyNS5cbiAqXG4gKiBDaGVjayBvdXQgW0ZJUFMgMTgwLTRdKGh0dHBzOi8vbnZscHVicy5uaXN0Lmdvdi9uaXN0cHVicy9GSVBTL05JU1QuRklQUy4xODAtNC5wZGYpLlxuICogQG1vZHVsZVxuICogQGRlcHJlY2F0ZWRcbiAqL1xuaW1wb3J0IHsgU0hBMjI0IGFzIFNIQTIyNG4sIHNoYTIyNCBhcyBzaGEyMjRuLCBTSEEyNTYgYXMgU0hBMjU2biwgc2hhMjU2IGFzIHNoYTI1Nm4sIH0gZnJvbSBcIi4vc2hhMi5qc1wiO1xuLyoqIEBkZXByZWNhdGVkIFVzZSBpbXBvcnQgZnJvbSBgbm9ibGUvaGFzaGVzL3NoYTJgIG1vZHVsZSAqL1xuZXhwb3J0IGNvbnN0IFNIQTI1NiA9IFNIQTI1Nm47XG4vKiogQGRlcHJlY2F0ZWQgVXNlIGltcG9ydCBmcm9tIGBub2JsZS9oYXNoZXMvc2hhMmAgbW9kdWxlICovXG5leHBvcnQgY29uc3Qgc2hhMjU2ID0gc2hhMjU2bjtcbi8qKiBAZGVwcmVjYXRlZCBVc2UgaW1wb3J0IGZyb20gYG5vYmxlL2hhc2hlcy9zaGEyYCBtb2R1bGUgKi9cbmV4cG9ydCBjb25zdCBTSEEyMjQgPSBTSEEyMjRuO1xuLyoqIEBkZXByZWNhdGVkIFVzZSBpbXBvcnQgZnJvbSBgbm9ibGUvaGFzaGVzL3NoYTJgIG1vZHVsZSAqL1xuZXhwb3J0IGNvbnN0IHNoYTIyNCA9IHNoYTIyNG47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEyNTYuanMubWFwIl0sIm5hbWVzIjpbIlNIQTIyNCIsIlNIQTIyNG4iLCJzaGEyMjQiLCJzaGEyMjRuIiwiU0hBMjU2IiwiU0hBMjU2biIsInNoYTI1NiIsInNoYTI1Nm4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/sha256.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/sha3.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/sha3.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Keccak: () => (/* binding */ Keccak),\n/* harmony export */   keccakP: () => (/* binding */ keccakP),\n/* harmony export */   keccak_224: () => (/* binding */ keccak_224),\n/* harmony export */   keccak_256: () => (/* binding */ keccak_256),\n/* harmony export */   keccak_384: () => (/* binding */ keccak_384),\n/* harmony export */   keccak_512: () => (/* binding */ keccak_512),\n/* harmony export */   sha3_224: () => (/* binding */ sha3_224),\n/* harmony export */   sha3_256: () => (/* binding */ sha3_256),\n/* harmony export */   sha3_384: () => (/* binding */ sha3_384),\n/* harmony export */   sha3_512: () => (/* binding */ sha3_512),\n/* harmony export */   shake128: () => (/* binding */ shake128),\n/* harmony export */   shake256: () => (/* binding */ shake256)\n/* harmony export */ });\n/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_u64.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/_u64.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/utils.js\");\n/**\n * SHA3 (keccak) hash function, based on a new \"Sponge function\" design.\n * Different from older hashes, the internal state is bigger than output size.\n *\n * Check out [FIPS-202](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf),\n * [Website](https://keccak.team/keccak.html),\n * [the differences between SHA-3 and Keccak](https://crypto.stackexchange.com/questions/15727/what-are-the-key-differences-between-the-draft-sha-3-standard-and-the-keccak-sub).\n *\n * Check out `sha3-addons` module for cSHAKE, k12, and others.\n * @module\n */ \n// prettier-ignore\n\n// No __PURE__ annotations in sha3 header:\n// EVERYTHING is in fact used on every export.\n// Various per round constants calculations\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _7n = BigInt(7);\nconst _256n = BigInt(256);\nconst _0x71n = BigInt(0x71);\nconst SHA3_PI = [];\nconst SHA3_ROTL = [];\nconst _SHA3_IOTA = [];\nfor(let round = 0, R = _1n, x = 1, y = 0; round < 24; round++){\n    // Pi\n    [x, y] = [\n        y,\n        (2 * x + 3 * y) % 5\n    ];\n    SHA3_PI.push(2 * (5 * y + x));\n    // Rotational\n    SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);\n    // Iota\n    let t = _0n;\n    for(let j = 0; j < 7; j++){\n        R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;\n        if (R & _2n) t ^= _1n << (_1n << /* @__PURE__ */ BigInt(j)) - _1n;\n    }\n    _SHA3_IOTA.push(t);\n}\nconst IOTAS = (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.split)(_SHA3_IOTA, true);\nconst SHA3_IOTA_H = IOTAS[0];\nconst SHA3_IOTA_L = IOTAS[1];\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h, l, s)=>s > 32 ? (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlBH)(h, l, s) : (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlSH)(h, l, s);\nconst rotlL = (h, l, s)=>s > 32 ? (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlBL)(h, l, s) : (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlSL)(h, l, s);\n/** `keccakf1600` internal function, additionally allows to adjust round count. */ function keccakP(s, rounds = 24) {\n    const B = new Uint32Array(5 * 2);\n    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n    for(let round = 24 - rounds; round < 24; round++){\n        // Theta \n        for(let x = 0; x < 10; x++)B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n        for(let x = 0; x < 10; x += 2){\n            const idx1 = (x + 8) % 10;\n            const idx0 = (x + 2) % 10;\n            const B0 = B[idx0];\n            const B1 = B[idx0 + 1];\n            const Th = rotlH(B0, B1, 1) ^ B[idx1];\n            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n            for(let y = 0; y < 50; y += 10){\n                s[x + y] ^= Th;\n                s[x + y + 1] ^= Tl;\n            }\n        }\n        // Rho () and Pi ()\n        let curH = s[2];\n        let curL = s[3];\n        for(let t = 0; t < 24; t++){\n            const shift = SHA3_ROTL[t];\n            const Th = rotlH(curH, curL, shift);\n            const Tl = rotlL(curH, curL, shift);\n            const PI = SHA3_PI[t];\n            curH = s[PI];\n            curL = s[PI + 1];\n            s[PI] = Th;\n            s[PI + 1] = Tl;\n        }\n        // Chi ()\n        for(let y = 0; y < 50; y += 10){\n            for(let x = 0; x < 10; x++)B[x] = s[y + x];\n            for(let x = 0; x < 10; x++)s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n        }\n        // Iota ()\n        s[0] ^= SHA3_IOTA_H[round];\n        s[1] ^= SHA3_IOTA_L[round];\n    }\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(B);\n}\n/** Keccak sponge function. */ class Keccak extends _utils_js__WEBPACK_IMPORTED_MODULE_1__.Hash {\n    // NOTE: we accept arguments in bytes instead of bits here.\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24){\n        super();\n        this.pos = 0;\n        this.posOut = 0;\n        this.finished = false;\n        this.destroyed = false;\n        this.enableXOF = false;\n        this.blockLen = blockLen;\n        this.suffix = suffix;\n        this.outputLen = outputLen;\n        this.enableXOF = enableXOF;\n        this.rounds = rounds;\n        // Can be passed from user as dkLen\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.anumber)(outputLen);\n        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n        // 0 < blockLen < 200\n        if (!(0 < blockLen && blockLen < 200)) throw new Error(\"only keccak-f1600 function is supported\");\n        this.state = new Uint8Array(200);\n        this.state32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(this.state);\n    }\n    clone() {\n        return this._cloneInto();\n    }\n    keccak() {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.swap32IfBE)(this.state32);\n        keccakP(this.state32, this.rounds);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.swap32IfBE)(this.state32);\n        this.posOut = 0;\n        this.pos = 0;\n    }\n    update(data) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.aexists)(this);\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(data);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.abytes)(data);\n        const { blockLen, state } = this;\n        const len = data.length;\n        for(let pos = 0; pos < len;){\n            const take = Math.min(blockLen - this.pos, len - pos);\n            for(let i = 0; i < take; i++)state[this.pos++] ^= data[pos++];\n            if (this.pos === blockLen) this.keccak();\n        }\n        return this;\n    }\n    finish() {\n        if (this.finished) return;\n        this.finished = true;\n        const { state, suffix, pos, blockLen } = this;\n        // Do the padding\n        state[pos] ^= suffix;\n        if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();\n        state[blockLen - 1] ^= 0x80;\n        this.keccak();\n    }\n    writeInto(out) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.aexists)(this, false);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.abytes)(out);\n        this.finish();\n        const bufferOut = this.state;\n        const { blockLen } = this;\n        for(let pos = 0, len = out.length; pos < len;){\n            if (this.posOut >= blockLen) this.keccak();\n            const take = Math.min(blockLen - this.posOut, len - pos);\n            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n            this.posOut += take;\n            pos += take;\n        }\n        return out;\n    }\n    xofInto(out) {\n        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n        if (!this.enableXOF) throw new Error(\"XOF is not possible for this instance\");\n        return this.writeInto(out);\n    }\n    xof(bytes) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.anumber)(bytes);\n        return this.xofInto(new Uint8Array(bytes));\n    }\n    digestInto(out) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.aoutput)(out, this);\n        if (this.finished) throw new Error(\"digest() was already called\");\n        this.writeInto(out);\n        this.destroy();\n        return out;\n    }\n    digest() {\n        return this.digestInto(new Uint8Array(this.outputLen));\n    }\n    destroy() {\n        this.destroyed = true;\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(this.state);\n    }\n    _cloneInto(to) {\n        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n        to.state32.set(this.state32);\n        to.pos = this.pos;\n        to.posOut = this.posOut;\n        to.finished = this.finished;\n        to.rounds = rounds;\n        // Suffix can change in cSHAKE\n        to.suffix = suffix;\n        to.outputLen = outputLen;\n        to.enableXOF = enableXOF;\n        to.destroyed = this.destroyed;\n        return to;\n    }\n}\nconst gen = (suffix, blockLen, outputLen)=>(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(()=>new Keccak(blockLen, suffix, outputLen));\n/** SHA3-224 hash function. */ const sha3_224 = /* @__PURE__ */ (()=>gen(0x06, 144, 224 / 8))();\n/** SHA3-256 hash function. Different from keccak-256. */ const sha3_256 = /* @__PURE__ */ (()=>gen(0x06, 136, 256 / 8))();\n/** SHA3-384 hash function. */ const sha3_384 = /* @__PURE__ */ (()=>gen(0x06, 104, 384 / 8))();\n/** SHA3-512 hash function. */ const sha3_512 = /* @__PURE__ */ (()=>gen(0x06, 72, 512 / 8))();\n/** keccak-224 hash function. */ const keccak_224 = /* @__PURE__ */ (()=>gen(0x01, 144, 224 / 8))();\n/** keccak-256 hash function. Different from SHA3-256. */ const keccak_256 = /* @__PURE__ */ (()=>gen(0x01, 136, 256 / 8))();\n/** keccak-384 hash function. */ const keccak_384 = /* @__PURE__ */ (()=>gen(0x01, 104, 384 / 8))();\n/** keccak-512 hash function. */ const keccak_512 = /* @__PURE__ */ (()=>gen(0x01, 72, 512 / 8))();\nconst genShake = (suffix, blockLen, outputLen)=>(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createXOFer)((opts = {})=>new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));\n/** SHAKE128 XOF with 128-bit security. */ const shake128 = /* @__PURE__ */ (()=>genShake(0x1f, 168, 128 / 8))();\n/** SHAKE256 XOF with 256-bit security. */ const shake256 = /* @__PURE__ */ (()=>genShake(0x1f, 136, 256 / 8))(); //# sourceMappingURL=sha3.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Q0FVQyxHQUNpRTtBQUNsRSxrQkFBa0I7QUFDK0c7QUFDakksMENBQTBDO0FBQzFDLDhDQUE4QztBQUM5QywyQ0FBMkM7QUFDM0MsTUFBTWdCLE1BQU1DLE9BQU87QUFDbkIsTUFBTUMsTUFBTUQsT0FBTztBQUNuQixNQUFNRSxNQUFNRixPQUFPO0FBQ25CLE1BQU1HLE1BQU1ILE9BQU87QUFDbkIsTUFBTUksUUFBUUosT0FBTztBQUNyQixNQUFNSyxTQUFTTCxPQUFPO0FBQ3RCLE1BQU1NLFVBQVUsRUFBRTtBQUNsQixNQUFNQyxZQUFZLEVBQUU7QUFDcEIsTUFBTUMsYUFBYSxFQUFFO0FBQ3JCLElBQUssSUFBSUMsUUFBUSxHQUFHQyxJQUFJVCxLQUFLVSxJQUFJLEdBQUdDLElBQUksR0FBR0gsUUFBUSxJQUFJQSxRQUFTO0lBQzVELEtBQUs7SUFDTCxDQUFDRSxHQUFHQyxFQUFFLEdBQUc7UUFBQ0E7UUFBSSxLQUFJRCxJQUFJLElBQUlDLENBQUFBLElBQUs7S0FBRTtJQUNqQ04sUUFBUU8sSUFBSSxDQUFDLElBQUssS0FBSUQsSUFBSUQsQ0FBQUE7SUFDMUIsYUFBYTtJQUNiSixVQUFVTSxJQUFJLENBQUMsQ0FBR0osUUFBUSxLQUFNQSxDQUFBQSxRQUFRLEtBQU0sSUFBSztJQUNuRCxPQUFPO0lBQ1AsSUFBSUssSUFBSWY7SUFDUixJQUFLLElBQUlnQixJQUFJLEdBQUdBLElBQUksR0FBR0EsSUFBSztRQUN4QkwsSUFBSSxDQUFDLEtBQU1ULE1BQVEsQ0FBQ1MsS0FBS1AsR0FBRSxJQUFLRSxNQUFNLElBQUtEO1FBQzNDLElBQUlNLElBQUlSLEtBQ0pZLEtBQUtiLE9BQVEsQ0FBQ0EsT0FBTyxhQUFhLEdBQUdELE9BQU9lLEVBQUMsSUFBS2Q7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ZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEzLmpzPzJiOGMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBTSEEzIChrZWNjYWspIGhhc2ggZnVuY3Rpb24sIGJhc2VkIG9uIGEgbmV3IFwiU3BvbmdlIGZ1bmN0aW9uXCIgZGVzaWduLlxuICogRGlmZmVyZW50IGZyb20gb2xkZXIgaGFzaGVzLCB0aGUgaW50ZXJuYWwgc3RhdGUgaXMgYmlnZ2VyIHRoYW4gb3V0cHV0IHNpemUuXG4gKlxuICogQ2hlY2sgb3V0IFtGSVBTLTIwMl0oaHR0cHM6Ly9udmxwdWJzLm5pc3QuZ292L25pc3RwdWJzL0ZJUFMvTklTVC5GSVBTLjIwMi5wZGYpLFxuICogW1dlYnNpdGVdKGh0dHBzOi8va2VjY2FrLnRlYW0va2VjY2FrLmh0bWwpLFxuICogW3RoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIFNIQS0zIGFuZCBLZWNjYWtdKGh0dHBzOi8vY3J5cHRvLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy8xNTcyNy93aGF0LWFyZS10aGUta2V5LWRpZmZlcmVuY2VzLWJldHdlZW4tdGhlLWRyYWZ0LXNoYS0zLXN0YW5kYXJkLWFuZC10aGUta2VjY2FrLXN1YikuXG4gKlxuICogQ2hlY2sgb3V0IGBzaGEzLWFkZG9uc2AgbW9kdWxlIGZvciBjU0hBS0UsIGsxMiwgYW5kIG90aGVycy5cbiAqIEBtb2R1bGVcbiAqL1xuaW1wb3J0IHsgcm90bEJILCByb3RsQkwsIHJvdGxTSCwgcm90bFNMLCBzcGxpdCB9IGZyb20gXCIuL191NjQuanNcIjtcbi8vIHByZXR0aWVyLWlnbm9yZVxuaW1wb3J0IHsgYWJ5dGVzLCBhZXhpc3RzLCBhbnVtYmVyLCBhb3V0cHV0LCBjbGVhbiwgY3JlYXRlSGFzaGVyLCBjcmVhdGVYT0ZlciwgSGFzaCwgc3dhcDMySWZCRSwgdG9CeXRlcywgdTMyIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbi8vIE5vIF9fUFVSRV9fIGFubm90YXRpb25zIGluIHNoYTMgaGVhZGVyOlxuLy8gRVZFUllUSElORyBpcyBpbiBmYWN0IHVzZWQgb24gZXZlcnkgZXhwb3J0LlxuLy8gVmFyaW91cyBwZXIgcm91bmQgY29uc3RhbnRzIGNhbGN1bGF0aW9uc1xuY29uc3QgXzBuID0gQmlnSW50KDApO1xuY29uc3QgXzFuID0gQmlnSW50KDEpO1xuY29uc3QgXzJuID0gQmlnSW50KDIpO1xuY29uc3QgXzduID0gQmlnSW50KDcpO1xuY29uc3QgXzI1Nm4gPSBCaWdJbnQoMjU2KTtcbmNvbnN0IF8weDcxbiA9IEJpZ0ludCgweDcxKTtcbmNvbnN0IFNIQTNfUEkgPSBbXTtcbmNvbnN0IFNIQTNfUk9UTCA9IFtdO1xuY29uc3QgX1NIQTNfSU9UQSA9IFtdO1xuZm9yIChsZXQgcm91bmQgPSAwLCBSID0gXzFuLCB4ID0gMSwgeSA9IDA7IHJvdW5kIDwgMjQ7IHJvdW5kKyspIHtcbiAgICAvLyBQaVxuICAgIFt4LCB5XSA9IFt5LCAoMiAqIHggKyAzICogeSkgJSA1XTtcbiAgICBTSEEzX1BJLnB1c2goMiAqICg1ICogeSArIHgpKTtcbiAgICAvLyBSb3RhdGlvbmFsXG4gICAgU0hBM19ST1RMLnB1c2goKCgocm91bmQgKyAxKSAqIChyb3VuZCArIDIpKSAvIDIpICUgNjQpO1xuICAgIC8vIElvdGFcbiAgICBsZXQgdCA9IF8wbjtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IDc7IGorKykge1xuICAgICAgICBSID0gKChSIDw8IF8xbikgXiAoKFIgPj4gXzduKSAqIF8weDcxbikpICUgXzI1Nm47XG4gICAgICAgIGlmIChSICYgXzJuKVxuICAgICAgICAgICAgdCBePSBfMW4gPDwgKChfMW4gPDwgLyogQF9fUFVSRV9fICovIEJpZ0ludChqKSkgLSBfMW4pO1xuICAgIH1cbiAgICBfU0hBM19JT1RBLnB1c2godCk7XG59XG5jb25zdCBJT1RBUyA9IHNwbGl0KF9TSEEzX0lPVEEsIHRydWUpO1xuY29uc3QgU0hBM19JT1RBX0ggPSBJT1RBU1swXTtcbmNvbnN0IFNIQTNfSU9UQV9MID0gSU9UQVNbMV07XG4vLyBMZWZ0IHJvdGF0aW9uICh3aXRob3V0IDAsIDMyLCA2NClcbmNvbnN0IHJvdGxIID0gKGgsIGwsIHMpID0+IChzID4gMzIgPyByb3RsQkgoaCwgbCwgcykgOiByb3RsU0goaCwgbCwgcykpO1xuY29uc3Qgcm90bEwgPSAoaCwgbCwgcykgPT4gKHMgPiAzMiA/IHJvdGxCTChoLCBsLCBzKSA6IHJvdGxTTChoLCBsLCBzKSk7XG4vKiogYGtlY2Nha2YxNjAwYCBpbnRlcm5hbCBmdW5jdGlvbiwgYWRkaXRpb25hbGx5IGFsbG93cyB0byBhZGp1c3Qgcm91bmQgY291bnQuICovXG5leHBvcnQgZnVuY3Rpb24ga2VjY2FrUChzLCByb3VuZHMgPSAyNCkge1xuICAgIGNvbnN0IEIgPSBuZXcgVWludDMyQXJyYXkoNSAqIDIpO1xuICAgIC8vIE5PVEU6IGFsbCBpbmRpY2VzIGFyZSB4MiBzaW5jZSB3ZSBzdG9yZSBzdGF0ZSBhcyB1MzIgaW5zdGVhZCBvZiB1NjQgKGJpZ2ludHMgdG8gc2xvdyBpbiBqcylcbiAgICBmb3IgKGxldCByb3VuZCA9IDI0IC0gcm91bmRzOyByb3VuZCA8IDI0OyByb3VuZCsrKSB7XG4gICAgICAgIC8vIFRoZXRhIM64XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHgrKylcbiAgICAgICAgICAgIEJbeF0gPSBzW3hdIF4gc1t4ICsgMTBdIF4gc1t4ICsgMjBdIF4gc1t4ICsgMzBdIF4gc1t4ICsgNDBdO1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4ICs9IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkeDEgPSAoeCArIDgpICUgMTA7XG4gICAgICAgICAgICBjb25zdCBpZHgwID0gKHggKyAyKSAlIDEwO1xuICAgICAgICAgICAgY29uc3QgQjAgPSBCW2lkeDBdO1xuICAgICAgICAgICAgY29uc3QgQjEgPSBCW2lkeDAgKyAxXTtcbiAgICAgICAgICAgIGNvbnN0IFRoID0gcm90bEgoQjAsIEIxLCAxKSBeIEJbaWR4MV07XG4gICAgICAgICAgICBjb25zdCBUbCA9IHJvdGxMKEIwLCBCMSwgMSkgXiBCW2lkeDEgKyAxXTtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgNTA7IHkgKz0gMTApIHtcbiAgICAgICAgICAgICAgICBzW3ggKyB5XSBePSBUaDtcbiAgICAgICAgICAgICAgICBzW3ggKyB5ICsgMV0gXj0gVGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmhvICjPgSkgYW5kIFBpICjPgClcbiAgICAgICAgbGV0IGN1ckggPSBzWzJdO1xuICAgICAgICBsZXQgY3VyTCA9IHNbM107XG4gICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgMjQ7IHQrKykge1xuICAgICAgICAgICAgY29uc3Qgc2hpZnQgPSBTSEEzX1JPVExbdF07XG4gICAgICAgICAgICBjb25zdCBUaCA9IHJvdGxIKGN1ckgsIGN1ckwsIHNoaWZ0KTtcbiAgICAgICAgICAgIGNvbnN0IFRsID0gcm90bEwoY3VySCwgY3VyTCwgc2hpZnQpO1xuICAgICAgICAgICAgY29uc3QgUEkgPSBTSEEzX1BJW3RdO1xuICAgICAgICAgICAgY3VySCA9IHNbUEldO1xuICAgICAgICAgICAgY3VyTCA9IHNbUEkgKyAxXTtcbiAgICAgICAgICAgIHNbUEldID0gVGg7XG4gICAgICAgICAgICBzW1BJICsgMV0gPSBUbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGkgKM+HKVxuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IDUwOyB5ICs9IDEwKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4KyspXG4gICAgICAgICAgICAgICAgQlt4XSA9IHNbeSArIHhdO1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCsrKVxuICAgICAgICAgICAgICAgIHNbeSArIHhdIF49IH5CWyh4ICsgMikgJSAxMF0gJiBCWyh4ICsgNCkgJSAxMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW90YSAozrkpXG4gICAgICAgIHNbMF0gXj0gU0hBM19JT1RBX0hbcm91bmRdO1xuICAgICAgICBzWzFdIF49IFNIQTNfSU9UQV9MW3JvdW5kXTtcbiAgICB9XG4gICAgY2xlYW4oQik7XG59XG4vKiogS2VjY2FrIHNwb25nZSBmdW5jdGlvbi4gKi9cbmV4cG9ydCBjbGFzcyBLZWNjYWsgZXh0ZW5kcyBIYXNoIHtcbiAgICAvLyBOT1RFOiB3ZSBhY2NlcHQgYXJndW1lbnRzIGluIGJ5dGVzIGluc3RlYWQgb2YgYml0cyBoZXJlLlxuICAgIGNvbnN0cnVjdG9yKGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbiwgZW5hYmxlWE9GID0gZmFsc2UsIHJvdW5kcyA9IDI0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5wb3NPdXQgPSAwO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZW5hYmxlWE9GID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdGhpcy5zdWZmaXggPSBzdWZmaXg7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0aGlzLmVuYWJsZVhPRiA9IGVuYWJsZVhPRjtcbiAgICAgICAgdGhpcy5yb3VuZHMgPSByb3VuZHM7XG4gICAgICAgIC8vIENhbiBiZSBwYXNzZWQgZnJvbSB1c2VyIGFzIGRrTGVuXG4gICAgICAgIGFudW1iZXIob3V0cHV0TGVuKTtcbiAgICAgICAgLy8gMTYwMCA9IDV4NSBtYXRyaXggb2YgNjRiaXQuICAxNjAwIGJpdHMgPT09IDIwMCBieXRlc1xuICAgICAgICAvLyAwIDwgYmxvY2tMZW4gPCAyMDBcbiAgICAgICAgaWYgKCEoMCA8IGJsb2NrTGVuICYmIGJsb2NrTGVuIDwgMjAwKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb25seSBrZWNjYWstZjE2MDAgZnVuY3Rpb24gaXMgc3VwcG9ydGVkJyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBuZXcgVWludDhBcnJheSgyMDApO1xuICAgICAgICB0aGlzLnN0YXRlMzIgPSB1MzIodGhpcy5zdGF0ZSk7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvbmVJbnRvKCk7XG4gICAgfVxuICAgIGtlY2NhaygpIHtcbiAgICAgICAgc3dhcDMySWZCRSh0aGlzLnN0YXRlMzIpO1xuICAgICAgICBrZWNjYWtQKHRoaXMuc3RhdGUzMiwgdGhpcy5yb3VuZHMpO1xuICAgICAgICBzd2FwMzJJZkJFKHRoaXMuc3RhdGUzMik7XG4gICAgICAgIHRoaXMucG9zT3V0ID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgIH1cbiAgICB1cGRhdGUoZGF0YSkge1xuICAgICAgICBhZXhpc3RzKHRoaXMpO1xuICAgICAgICBkYXRhID0gdG9CeXRlcyhkYXRhKTtcbiAgICAgICAgYWJ5dGVzKGRhdGEpO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBzdGF0ZSB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IGxlbjspIHtcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zLCBsZW4gLSBwb3MpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YWtlOyBpKyspXG4gICAgICAgICAgICAgICAgc3RhdGVbdGhpcy5wb3MrK10gXj0gZGF0YVtwb3MrK107XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGZpbmlzaCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZmluaXNoZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCB7IHN0YXRlLCBzdWZmaXgsIHBvcywgYmxvY2tMZW4gfSA9IHRoaXM7XG4gICAgICAgIC8vIERvIHRoZSBwYWRkaW5nXG4gICAgICAgIHN0YXRlW3Bvc10gXj0gc3VmZml4O1xuICAgICAgICBpZiAoKHN1ZmZpeCAmIDB4ODApICE9PSAwICYmIHBvcyA9PT0gYmxvY2tMZW4gLSAxKVxuICAgICAgICAgICAgdGhpcy5rZWNjYWsoKTtcbiAgICAgICAgc3RhdGVbYmxvY2tMZW4gLSAxXSBePSAweDgwO1xuICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgIH1cbiAgICB3cml0ZUludG8ob3V0KSB7XG4gICAgICAgIGFleGlzdHModGhpcywgZmFsc2UpO1xuICAgICAgICBhYnl0ZXMob3V0KTtcbiAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgY29uc3QgYnVmZmVyT3V0ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMCwgbGVuID0gb3V0Lmxlbmd0aDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zT3V0ID49IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvc091dCwgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIG91dC5zZXQoYnVmZmVyT3V0LnN1YmFycmF5KHRoaXMucG9zT3V0LCB0aGlzLnBvc091dCArIHRha2UpLCBwb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3NPdXQgKz0gdGFrZTtcbiAgICAgICAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIHhvZkludG8ob3V0KSB7XG4gICAgICAgIC8vIFNoYTMvS2VjY2FrIHVzYWdlIHdpdGggWE9GIGlzIHByb2JhYmx5IG1pc3Rha2UsIG9ubHkgU0hBS0UgaW5zdGFuY2VzIGNhbiBkbyBYT0ZcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZVhPRilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWE9GIGlzIG5vdCBwb3NzaWJsZSBmb3IgdGhpcyBpbnN0YW5jZScpO1xuICAgICAgICByZXR1cm4gdGhpcy53cml0ZUludG8ob3V0KTtcbiAgICB9XG4gICAgeG9mKGJ5dGVzKSB7XG4gICAgICAgIGFudW1iZXIoYnl0ZXMpO1xuICAgICAgICByZXR1cm4gdGhpcy54b2ZJbnRvKG5ldyBVaW50OEFycmF5KGJ5dGVzKSk7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgIGFvdXRwdXQob3V0LCB0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuZmluaXNoZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpZ2VzdCgpIHdhcyBhbHJlYWR5IGNhbGxlZCcpO1xuICAgICAgICB0aGlzLndyaXRlSW50byhvdXQpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaWdlc3RJbnRvKG5ldyBVaW50OEFycmF5KHRoaXMub3V0cHV0TGVuKSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgY2xlYW4odGhpcy5zdGF0ZSk7XG4gICAgfVxuICAgIF9jbG9uZUludG8odG8pIHtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4sIHJvdW5kcywgZW5hYmxlWE9GIH0gPSB0aGlzO1xuICAgICAgICB0byB8fCAodG8gPSBuZXcgS2VjY2FrKGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbiwgZW5hYmxlWE9GLCByb3VuZHMpKTtcbiAgICAgICAgdG8uc3RhdGUzMi5zZXQodGhpcy5zdGF0ZTMyKTtcbiAgICAgICAgdG8ucG9zID0gdGhpcy5wb3M7XG4gICAgICAgIHRvLnBvc091dCA9IHRoaXMucG9zT3V0O1xuICAgICAgICB0by5maW5pc2hlZCA9IHRoaXMuZmluaXNoZWQ7XG4gICAgICAgIHRvLnJvdW5kcyA9IHJvdW5kcztcbiAgICAgICAgLy8gU3VmZml4IGNhbiBjaGFuZ2UgaW4gY1NIQUtFXG4gICAgICAgIHRvLnN1ZmZpeCA9IHN1ZmZpeDtcbiAgICAgICAgdG8ub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0by5lbmFibGVYT0YgPSBlbmFibGVYT0Y7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IHRoaXMuZGVzdHJveWVkO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxufVxuY29uc3QgZ2VuID0gKHN1ZmZpeCwgYmxvY2tMZW4sIG91dHB1dExlbikgPT4gY3JlYXRlSGFzaGVyKCgpID0+IG5ldyBLZWNjYWsoYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuKSk7XG4vKiogU0hBMy0yMjQgaGFzaCBmdW5jdGlvbi4gKi9cbmV4cG9ydCBjb25zdCBzaGEzXzIyNCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gZ2VuKDB4MDYsIDE0NCwgMjI0IC8gOCkpKCk7XG4vKiogU0hBMy0yNTYgaGFzaCBmdW5jdGlvbi4gRGlmZmVyZW50IGZyb20ga2VjY2FrLTI1Ni4gKi9cbmV4cG9ydCBjb25zdCBzaGEzXzI1NiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gZ2VuKDB4MDYsIDEzNiwgMjU2IC8gOCkpKCk7XG4vKiogU0hBMy0zODQgaGFzaCBmdW5jdGlvbi4gKi9cbmV4cG9ydCBjb25zdCBzaGEzXzM4NCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gZ2VuKDB4MDYsIDEwNCwgMzg0IC8gOCkpKCk7XG4vKiogU0hBMy01MTIgaGFzaCBmdW5jdGlvbi4gKi9cbmV4cG9ydCBjb25zdCBzaGEzXzUxMiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gZ2VuKDB4MDYsIDcyLCA1MTIgLyA4KSkoKTtcbi8qKiBrZWNjYWstMjI0IGhhc2ggZnVuY3Rpb24uICovXG5leHBvcnQgY29uc3Qga2VjY2FrXzIyNCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gZ2VuKDB4MDEsIDE0NCwgMjI0IC8gOCkpKCk7XG4vKioga2VjY2FrLTI1NiBoYXNoIGZ1bmN0aW9uLiBEaWZmZXJlbnQgZnJvbSBTSEEzLTI1Ni4gKi9cbmV4cG9ydCBjb25zdCBrZWNjYWtfMjU2ID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBnZW4oMHgwMSwgMTM2LCAyNTYgLyA4KSkoKTtcbi8qKiBrZWNjYWstMzg0IGhhc2ggZnVuY3Rpb24uICovXG5leHBvcnQgY29uc3Qga2VjY2FrXzM4NCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gZ2VuKDB4MDEsIDEwNCwgMzg0IC8gOCkpKCk7XG4vKioga2VjY2FrLTUxMiBoYXNoIGZ1bmN0aW9uLiAqL1xuZXhwb3J0IGNvbnN0IGtlY2Nha181MTIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGdlbigweDAxLCA3MiwgNTEyIC8gOCkpKCk7XG5jb25zdCBnZW5TaGFrZSA9IChzdWZmaXgsIGJsb2NrTGVuLCBvdXRwdXRMZW4pID0+IGNyZWF0ZVhPRmVyKChvcHRzID0ge30pID0+IG5ldyBLZWNjYWsoYmxvY2tMZW4sIHN1ZmZpeCwgb3B0cy5ka0xlbiA9PT0gdW5kZWZpbmVkID8gb3V0cHV0TGVuIDogb3B0cy5ka0xlbiwgdHJ1ZSkpO1xuLyoqIFNIQUtFMTI4IFhPRiB3aXRoIDEyOC1iaXQgc2VjdXJpdHkuICovXG5leHBvcnQgY29uc3Qgc2hha2UxMjggPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGdlblNoYWtlKDB4MWYsIDE2OCwgMTI4IC8gOCkpKCk7XG4vKiogU0hBS0UyNTYgWE9GIHdpdGggMjU2LWJpdCBzZWN1cml0eS4gKi9cbmV4cG9ydCBjb25zdCBzaGFrZTI1NiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gZ2VuU2hha2UoMHgxZiwgMTM2LCAyNTYgLyA4KSkoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYTMuanMubWFwIl0sIm5hbWVzIjpbInJvdGxCSCIsInJvdGxCTCIsInJvdGxTSCIsInJvdGxTTCIsInNwbGl0IiwiYWJ5dGVzIiwiYWV4aXN0cyIsImFudW1iZXIiLCJhb3V0cHV0IiwiY2xlYW4iLCJjcmVhdGVIYXNoZXIiLCJjcmVhdGVYT0ZlciIsIkhhc2giLCJzd2FwMzJJZkJFIiwidG9CeXRlcyIsInUzMiIsIl8wbiIsIkJpZ0ludCIsIl8xbiIsIl8ybiIsIl83biIsIl8yNTZuIiwiXzB4NzFuIiwiU0hBM19QSSIsIlNIQTNfUk9UTCIsIl9TSEEzX0lPVEEiLCJyb3VuZCIsIlIiLCJ4IiwieSIsInB1c2giLCJ0IiwiaiIsIklPVEFTIiwiU0hBM19JT1RBX0giLCJTSEEzX0lPVEFfTCIsInJvdGxIIiwiaCIsImwiLCJzIiwicm90bEwiLCJrZWNjYWtQIiwicm91bmRzIiwiQiIsIlVpbnQzMkFycmF5IiwiaWR4MSIsImlkeDAiLCJCMCIsIkIxIiwiVGgiLCJUbCIsImN1ckgiLCJjdXJMIiwic2hpZnQiLCJQSSIsIktlY2NhayIsImNvbnN0cnVjdG9yIiwiYmxvY2tMZW4iLCJzdWZmaXgiLCJvdXRwdXRMZW4iLCJlbmFibGVYT0YiLCJwb3MiLCJwb3NPdXQiLCJmaW5pc2hlZCIsImRlc3Ryb3llZCIsIkVycm9yIiwic3RhdGUiLCJVaW50OEFycmF5Iiwic3RhdGUzMiIsImNsb25lIiwiX2Nsb25lSW50byIsImtlY2NhayIsInVwZGF0ZSIsImRhdGEiLCJsZW4iLCJsZW5ndGgiLCJ0YWtlIiwiTWF0aCIsIm1pbiIsImkiLCJmaW5pc2giLCJ3cml0ZUludG8iLCJvdXQiLCJidWZmZXJPdXQiLCJzZXQiLCJzdWJhcnJheSIsInhvZkludG8iLCJ4b2YiLCJieXRlcyIsImRpZ2VzdEludG8iLCJkZXN0cm95IiwiZGlnZXN0IiwidG8iLCJnZW4iLCJzaGEzXzIyNCIsInNoYTNfMjU2Iiwic2hhM18zODQiLCJzaGEzXzUxMiIsImtlY2Nha18yMjQiLCJrZWNjYWtfMjU2Iiwia2VjY2FrXzM4NCIsImtlY2Nha181MTIiLCJnZW5TaGFrZSIsIm9wdHMiLCJka0xlbiIsInVuZGVmaW5lZCIsInNoYWtlMTI4Iiwic2hha2UyNTYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/sha3.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/utils.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/utils.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: () => (/* binding */ Hash),\n/* harmony export */   abytes: () => (/* binding */ abytes),\n/* harmony export */   aexists: () => (/* binding */ aexists),\n/* harmony export */   ahash: () => (/* binding */ ahash),\n/* harmony export */   anumber: () => (/* binding */ anumber),\n/* harmony export */   aoutput: () => (/* binding */ aoutput),\n/* harmony export */   asyncLoop: () => (/* binding */ asyncLoop),\n/* harmony export */   byteSwap: () => (/* binding */ byteSwap),\n/* harmony export */   byteSwap32: () => (/* binding */ byteSwap32),\n/* harmony export */   byteSwapIfBE: () => (/* binding */ byteSwapIfBE),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   bytesToUtf8: () => (/* binding */ bytesToUtf8),\n/* harmony export */   checkOpts: () => (/* binding */ checkOpts),\n/* harmony export */   clean: () => (/* binding */ clean),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createHasher: () => (/* binding */ createHasher),\n/* harmony export */   createOptHasher: () => (/* binding */ createOptHasher),\n/* harmony export */   createView: () => (/* binding */ createView),\n/* harmony export */   createXOFer: () => (/* binding */ createXOFer),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   isBytes: () => (/* binding */ isBytes),\n/* harmony export */   isLE: () => (/* binding */ isLE),\n/* harmony export */   kdfInputToBytes: () => (/* binding */ kdfInputToBytes),\n/* harmony export */   nextTick: () => (/* binding */ nextTick),\n/* harmony export */   randomBytes: () => (/* binding */ randomBytes),\n/* harmony export */   rotl: () => (/* binding */ rotl),\n/* harmony export */   rotr: () => (/* binding */ rotr),\n/* harmony export */   swap32IfBE: () => (/* binding */ swap32IfBE),\n/* harmony export */   swap8IfBE: () => (/* binding */ swap8IfBE),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   u32: () => (/* binding */ u32),\n/* harmony export */   u8: () => (/* binding */ u8),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   wrapConstructor: () => (/* binding */ wrapConstructor),\n/* harmony export */   wrapConstructorWithOpts: () => (/* binding */ wrapConstructorWithOpts),\n/* harmony export */   wrapXOFConstructorWithOpts: () => (/* binding */ wrapXOFConstructorWithOpts)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/crypto */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/cryptoNode.js\");\n/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */ /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\n\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */ function isBytes(a) {\n    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === \"Uint8Array\";\n}\n/** Asserts something is positive integer. */ function anumber(n) {\n    if (!Number.isSafeInteger(n) || n < 0) throw new Error(\"positive integer expected, got \" + n);\n}\n/** Asserts something is Uint8Array. */ function abytes(b, ...lengths) {\n    if (!isBytes(b)) throw new Error(\"Uint8Array expected\");\n    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error(\"Uint8Array expected of length \" + lengths + \", got length=\" + b.length);\n}\n/** Asserts something is hash */ function ahash(h) {\n    if (typeof h !== \"function\" || typeof h.create !== \"function\") throw new Error(\"Hash should be wrapped by utils.createHasher\");\n    anumber(h.outputLen);\n    anumber(h.blockLen);\n}\n/** Asserts a hash instance has not been destroyed / finished */ function aexists(instance, checkFinished = true) {\n    if (instance.destroyed) throw new Error(\"Hash instance has been destroyed\");\n    if (checkFinished && instance.finished) throw new Error(\"Hash#digest() has already been called\");\n}\n/** Asserts output is properly-sized byte array */ function aoutput(out, instance) {\n    abytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(\"digestInto() expects output buffer of length at least \" + min);\n    }\n}\n/** Cast u8 / u16 / u32 to u8. */ function u8(arr) {\n    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** Cast u8 / u16 / u32 to u32. */ function u32(arr) {\n    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n/** Zeroize a byte array. Warning: JS provides no guarantees. */ function clean(...arrays) {\n    for(let i = 0; i < arrays.length; i++){\n        arrays[i].fill(0);\n    }\n}\n/** Create DataView of an array for easy byte-level manipulation. */ function createView(arr) {\n    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** The rotate right (circular right shift) operation for uint32 */ function rotr(word, shift) {\n    return word << 32 - shift | word >>> shift;\n}\n/** The rotate left (circular left shift) operation for uint32 */ function rotl(word, shift) {\n    return word << shift | word >>> 32 - shift >>> 0;\n}\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */ const isLE = /* @__PURE__ */ (()=>new Uint8Array(new Uint32Array([\n        0x11223344\n    ]).buffer)[0] === 0x44)();\n/** The byte swap operation for uint32 */ function byteSwap(word) {\n    return word << 24 & 0xff000000 | word << 8 & 0xff0000 | word >>> 8 & 0xff00 | word >>> 24 & 0xff;\n}\n/** Conditionally byte swap if on a big-endian platform */ const swap8IfBE = isLE ? (n)=>n : (n)=>byteSwap(n);\n/** @deprecated */ const byteSwapIfBE = swap8IfBE;\n/** In place byte swap for Uint32Array */ function byteSwap32(arr) {\n    for(let i = 0; i < arr.length; i++){\n        arr[i] = byteSwap(arr[i]);\n    }\n    return arr;\n}\nconst swap32IfBE = isLE ? (u)=>u : byteSwap32;\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin = /* @__PURE__ */ (()=>// @ts-ignore\n    typeof Uint8Array.from([]).toHex === \"function\" && typeof Uint8Array.fromHex === \"function\")();\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({\n    length: 256\n}, (_, i)=>i.toString(16).padStart(2, \"0\"));\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */ function bytesToHex(bytes) {\n    abytes(bytes);\n    // @ts-ignore\n    if (hasHexBuiltin) return bytes.toHex();\n    // pre-caching improves the speed 6x\n    let hex = \"\";\n    for(let i = 0; i < bytes.length; i++){\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = {\n    _0: 48,\n    _9: 57,\n    A: 65,\n    F: 70,\n    a: 97,\n    f: 102\n};\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */ function hexToBytes(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    // @ts-ignore\n    if (hasHexBuiltin) return Uint8Array.fromHex(hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2) throw new Error(\"hex string expected, got unpadded hex of length \" + hl);\n    const array = new Uint8Array(al);\n    for(let ai = 0, hi = 0; ai < al; ai++, hi += 2){\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */ const nextTick = async ()=>{};\n/** Returns control to thread each 'tick' ms to avoid blocking. */ async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for(let i = 0; i < iters; i++){\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick) continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */ function utf8ToBytes(str) {\n    if (typeof str !== \"string\") throw new Error(\"string expected\");\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */ function bytesToUtf8(bytes) {\n    return new TextDecoder().decode(bytes);\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */ function toBytes(data) {\n    if (typeof data === \"string\") data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */ function kdfInputToBytes(data) {\n    if (typeof data === \"string\") data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/** Copies several Uint8Arrays into one. */ function concatBytes(...arrays) {\n    let sum = 0;\n    for(let i = 0; i < arrays.length; i++){\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for(let i = 0, pad = 0; i < arrays.length; i++){\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && ({}).toString.call(opts) !== \"[object Object]\") throw new Error(\"options should be object or undefined\");\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\n/** For runtime check if class implements interface */ class Hash {\n}\n/** Wraps hash function, creating an interface on top of it */ function createHasher(hashCons) {\n    const hashC = (msg)=>hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = ()=>hashCons();\n    return hashC;\n}\nfunction createOptHasher(hashCons) {\n    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts)=>hashCons(opts);\n    return hashC;\n}\nfunction createXOFer(hashCons) {\n    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts)=>hashCons(opts);\n    return hashC;\n}\nconst wrapConstructor = createHasher;\nconst wrapConstructorWithOpts = createOptHasher;\nconst wrapXOFConstructorWithOpts = createXOFer;\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */ function randomBytes(bytesLength = 32) {\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues === \"function\") {\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    // Legacy Node.js compatibility\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.randomBytes === \"function\") {\n        return Uint8Array.from(_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.randomBytes(bytesLength));\n    }\n    throw new Error(\"crypto.getRandomValues must be defined\");\n} //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7OztDQUdDLEdBQ0Qsb0VBQW9FLEdBQ3BFLG9GQUFvRjtBQUNwRixzRUFBc0U7QUFDdEUsa0VBQWtFO0FBQ2xFLDhEQUE4RDtBQUM5RCwrREFBK0Q7QUFDL0QsMkVBQTJFO0FBQzdCO0FBQzlDLG1GQUFtRixHQUM1RSxTQUFTQyxRQUFRQyxDQUFDO0lBQ3JCLE9BQU9BLGFBQWFDLGNBQWVDLFlBQVlDLE1BQU0sQ0FBQ0gsTUFBTUEsRUFBRUksV0FBVyxDQUFDQyxJQUFJLEtBQUs7QUFDdkY7QUFDQSwyQ0FBMkMsR0FDcEMsU0FBU0MsUUFBUUMsQ0FBQztJQUNyQixJQUFJLENBQUNDLE9BQU9DLGFBQWEsQ0FBQ0YsTUFBTUEsSUFBSSxHQUNoQyxNQUFNLElBQUlHLE1BQU0sb0NBQW9DSDtBQUM1RDtBQUNBLHFDQUFxQyxHQUM5QixTQUFTSSxPQUFPQyxDQUFDLEVBQUUsR0FBR0MsT0FBTztJQUNoQyxJQUFJLENBQUNkLFFBQVFhLElBQ1QsTUFBTSxJQUFJRixNQUFNO0lBQ3BCLElBQUlHLFFBQVFDLE1BQU0sR0FBRyxLQUFLLENBQUNELFFBQVFFLFFBQVEsQ0FBQ0gsRUFBRUUsTUFBTSxHQUNoRCxNQUFNLElBQUlKLE1BQU0sbUNBQW1DRyxVQUFVLGtCQUFrQkQsRUFBRUUsTUFBTTtBQUMvRjtBQUNBLDhCQUE4QixHQUN2QixTQUFTRSxNQUFNQyxDQUFDO0lBQ25CLElBQUksT0FBT0EsTUFBTSxjQUFjLE9BQU9BLEVBQUVDLE1BQU0sS0FBSyxZQUMvQyxNQUFNLElBQUlSLE1BQU07SUFDcEJKLFFBQVFXLEVBQUVFLFNBQVM7SUFDbkJiLFFBQVFXLEVBQUVHLFFBQVE7QUFDdEI7QUFDQSw4REFBOEQsR0FDdkQsU0FBU0MsUUFB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U0ksWUFBWUMsY0FBYyxFQUFFO0lBQ3hDLElBQUlySSx3REFBTUEsSUFBSSxPQUFPQSx3REFBTUEsQ0FBQ3NJLGVBQWUsS0FBSyxZQUFZO1FBQ3hELE9BQU90SSx3REFBTUEsQ0FBQ3NJLGVBQWUsQ0FBQyxJQUFJbkksV0FBV2tJO0lBQ2pEO0lBQ0EsK0JBQStCO0lBQy9CLElBQUlySSx3REFBTUEsSUFBSSxPQUFPQSx3REFBTUEsQ0FBQ29JLFdBQVcsS0FBSyxZQUFZO1FBQ3BELE9BQU9qSSxXQUFXdUQsSUFBSSxDQUFDMUQsd0RBQU1BLENBQUNvSSxXQUFXLENBQUNDO0lBQzlDO0lBQ0EsTUFBTSxJQUFJekgsTUFBTTtBQUNwQixFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsYXctd29ya3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS91dGlscy5qcz81OWUyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVXRpbGl0aWVzIGZvciBoZXgsIGJ5dGVzLCBDU1BSTkcuXG4gKiBAbW9kdWxlXG4gKi9cbi8qISBub2JsZS1oYXNoZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIFdlIHVzZSBXZWJDcnlwdG8gYWthIGdsb2JhbFRoaXMuY3J5cHRvLCB3aGljaCBleGlzdHMgaW4gYnJvd3NlcnMgYW5kIG5vZGUuanMgMTYrLlxuLy8gbm9kZS5qcyB2ZXJzaW9ucyBlYXJsaWVyIHRoYW4gdjE5IGRvbid0IGRlY2xhcmUgaXQgaW4gZ2xvYmFsIHNjb3BlLlxuLy8gRm9yIG5vZGUuanMsIHBhY2thZ2UuanNvbiNleHBvcnRzIGZpZWxkIG1hcHBpbmcgcmV3cml0ZXMgaW1wb3J0XG4vLyBmcm9tIGBjcnlwdG9gIHRvIGBjcnlwdG9Ob2RlYCwgd2hpY2ggaW1wb3J0cyBuYXRpdmUgbW9kdWxlLlxuLy8gTWFrZXMgdGhlIHV0aWxzIHVuLWltcG9ydGFibGUgaW4gYnJvd3NlcnMgd2l0aG91dCBhIGJ1bmRsZXIuXG4vLyBPbmNlIG5vZGUuanMgMTggaXMgZGVwcmVjYXRlZCAoMjAyNS0wNC0zMCksIHdlIGNhbiBqdXN0IGRyb3AgdGhlIGltcG9ydC5cbmltcG9ydCB7IGNyeXB0byB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvY3J5cHRvJztcbi8qKiBDaGVja3MgaWYgc29tZXRoaW5nIGlzIFVpbnQ4QXJyYXkuIEJlIGNhcmVmdWw6IG5vZGVqcyBCdWZmZXIgd2lsbCByZXR1cm4gdHJ1ZS4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0J5dGVzKGEpIHtcbiAgICByZXR1cm4gYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgKEFycmF5QnVmZmVyLmlzVmlldyhhKSAmJiBhLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdVaW50OEFycmF5Jyk7XG59XG4vKiogQXNzZXJ0cyBzb21ldGhpbmcgaXMgcG9zaXRpdmUgaW50ZWdlci4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhbnVtYmVyKG4pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG4pIHx8IG4gPCAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Bvc2l0aXZlIGludGVnZXIgZXhwZWN0ZWQsIGdvdCAnICsgbik7XG59XG4vKiogQXNzZXJ0cyBzb21ldGhpbmcgaXMgVWludDhBcnJheS4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhYnl0ZXMoYiwgLi4ubGVuZ3Rocykge1xuICAgIGlmICghaXNCeXRlcyhiKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgaWYgKGxlbmd0aHMubGVuZ3RoID4gMCAmJiAhbGVuZ3Rocy5pbmNsdWRlcyhiLmxlbmd0aCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCBvZiBsZW5ndGggJyArIGxlbmd0aHMgKyAnLCBnb3QgbGVuZ3RoPScgKyBiLmxlbmd0aCk7XG59XG4vKiogQXNzZXJ0cyBzb21ldGhpbmcgaXMgaGFzaCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFoYXNoKGgpIHtcbiAgICBpZiAodHlwZW9mIGggIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGguY3JlYXRlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggc2hvdWxkIGJlIHdyYXBwZWQgYnkgdXRpbHMuY3JlYXRlSGFzaGVyJyk7XG4gICAgYW51bWJlcihoLm91dHB1dExlbik7XG4gICAgYW51bWJlcihoLmJsb2NrTGVuKTtcbn1cbi8qKiBBc3NlcnRzIGEgaGFzaCBpbnN0YW5jZSBoYXMgbm90IGJlZW4gZGVzdHJveWVkIC8gZmluaXNoZWQgKi9cbmV4cG9ydCBmdW5jdGlvbiBhZXhpc3RzKGluc3RhbmNlLCBjaGVja0ZpbmlzaGVkID0gdHJ1ZSkge1xuICAgIGlmIChpbnN0YW5jZS5kZXN0cm95ZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQnKTtcbiAgICBpZiAoY2hlY2tGaW5pc2hlZCAmJiBpbnN0YW5jZS5maW5pc2hlZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoI2RpZ2VzdCgpIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkJyk7XG59XG4vKiogQXNzZXJ0cyBvdXRwdXQgaXMgcHJvcGVybHktc2l6ZWQgYnl0ZSBhcnJheSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFvdXRwdXQob3V0LCBpbnN0YW5jZSkge1xuICAgIGFieXRlcyhvdXQpO1xuICAgIGNvbnN0IG1pbiA9IGluc3RhbmNlLm91dHB1dExlbjtcbiAgICBpZiAob3V0Lmxlbmd0aCA8IG1pbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpZ2VzdEludG8oKSBleHBlY3RzIG91dHB1dCBidWZmZXIgb2YgbGVuZ3RoIGF0IGxlYXN0ICcgKyBtaW4pO1xuICAgIH1cbn1cbi8qKiBDYXN0IHU4IC8gdTE2IC8gdTMyIHRvIHU4LiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHU4KGFycikge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xufVxuLyoqIENhc3QgdTggLyB1MTYgLyB1MzIgdG8gdTMyLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHUzMihhcnIpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQzMkFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBNYXRoLmZsb29yKGFyci5ieXRlTGVuZ3RoIC8gNCkpO1xufVxuLyoqIFplcm9pemUgYSBieXRlIGFycmF5LiBXYXJuaW5nOiBKUyBwcm92aWRlcyBubyBndWFyYW50ZWVzLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFuKC4uLmFycmF5cykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycmF5c1tpXS5maWxsKDApO1xuICAgIH1cbn1cbi8qKiBDcmVhdGUgRGF0YVZpZXcgb2YgYW4gYXJyYXkgZm9yIGVhc3kgYnl0ZS1sZXZlbCBtYW5pcHVsYXRpb24uICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVmlldyhhcnIpIHtcbiAgICByZXR1cm4gbmV3IERhdGFWaWV3KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG59XG4vKiogVGhlIHJvdGF0ZSByaWdodCAoY2lyY3VsYXIgcmlnaHQgc2hpZnQpIG9wZXJhdGlvbiBmb3IgdWludDMyICovXG5leHBvcnQgZnVuY3Rpb24gcm90cih3b3JkLCBzaGlmdCkge1xuICAgIHJldHVybiAod29yZCA8PCAoMzIgLSBzaGlmdCkpIHwgKHdvcmQgPj4+IHNoaWZ0KTtcbn1cbi8qKiBUaGUgcm90YXRlIGxlZnQgKGNpcmN1bGFyIGxlZnQgc2hpZnQpIG9wZXJhdGlvbiBmb3IgdWludDMyICovXG5leHBvcnQgZnVuY3Rpb24gcm90bCh3b3JkLCBzaGlmdCkge1xuICAgIHJldHVybiAod29yZCA8PCBzaGlmdCkgfCAoKHdvcmQgPj4+ICgzMiAtIHNoaWZ0KSkgPj4+IDApO1xufVxuLyoqIElzIGN1cnJlbnQgcGxhdGZvcm0gbGl0dGxlLWVuZGlhbj8gTW9zdCBhcmUuIEJpZy1FbmRpYW4gcGxhdGZvcm06IElCTSAqL1xuZXhwb3J0IGNvbnN0IGlzTEUgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IG5ldyBVaW50OEFycmF5KG5ldyBVaW50MzJBcnJheShbMHgxMTIyMzM0NF0pLmJ1ZmZlcilbMF0gPT09IDB4NDQpKCk7XG4vKiogVGhlIGJ5dGUgc3dhcCBvcGVyYXRpb24gZm9yIHVpbnQzMiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVTd2FwKHdvcmQpIHtcbiAgICByZXR1cm4gKCgod29yZCA8PCAyNCkgJiAweGZmMDAwMDAwKSB8XG4gICAgICAgICgod29yZCA8PCA4KSAmIDB4ZmYwMDAwKSB8XG4gICAgICAgICgod29yZCA+Pj4gOCkgJiAweGZmMDApIHxcbiAgICAgICAgKCh3b3JkID4+PiAyNCkgJiAweGZmKSk7XG59XG4vKiogQ29uZGl0aW9uYWxseSBieXRlIHN3YXAgaWYgb24gYSBiaWctZW5kaWFuIHBsYXRmb3JtICovXG5leHBvcnQgY29uc3Qgc3dhcDhJZkJFID0gaXNMRVxuICAgID8gKG4pID0+IG5cbiAgICA6IChuKSA9PiBieXRlU3dhcChuKTtcbi8qKiBAZGVwcmVjYXRlZCAqL1xuZXhwb3J0IGNvbnN0IGJ5dGVTd2FwSWZCRSA9IHN3YXA4SWZCRTtcbi8qKiBJbiBwbGFjZSBieXRlIHN3YXAgZm9yIFVpbnQzMkFycmF5ICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZVN3YXAzMihhcnIpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJbaV0gPSBieXRlU3dhcChhcnJbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufVxuZXhwb3J0IGNvbnN0IHN3YXAzMklmQkUgPSBpc0xFXG4gICAgPyAodSkgPT4gdVxuICAgIDogYnl0ZVN3YXAzMjtcbi8vIEJ1aWx0LWluIGhleCBjb252ZXJzaW9uIGh0dHBzOi8vY2FuaXVzZS5jb20vbWRuLWphdmFzY3JpcHRfYnVpbHRpbnNfdWludDhhcnJheV9mcm9taGV4XG5jb25zdCBoYXNIZXhCdWlsdGluID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBcbi8vIEB0cy1pZ25vcmVcbnR5cGVvZiBVaW50OEFycmF5LmZyb20oW10pLnRvSGV4ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBVaW50OEFycmF5LmZyb21IZXggPT09ICdmdW5jdGlvbicpKCk7XG4vLyBBcnJheSB3aGVyZSBpbmRleCAweGYwICgyNDApIGlzIG1hcHBlZCB0byBzdHJpbmcgJ2YwJ1xuY29uc3QgaGV4ZXMgPSAvKiBAX19QVVJFX18gKi8gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sIChfLCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbi8qKlxuICogQ29udmVydCBieXRlIGFycmF5IHRvIGhleCBzdHJpbmcuIFVzZXMgYnVpbHQtaW4gZnVuY3Rpb24sIHdoZW4gYXZhaWxhYmxlLlxuICogQGV4YW1wbGUgYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKSkgLy8gJ2NhZmUwMTIzJ1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgIGFieXRlcyhieXRlcyk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmIChoYXNIZXhCdWlsdGluKVxuICAgICAgICByZXR1cm4gYnl0ZXMudG9IZXgoKTtcbiAgICAvLyBwcmUtY2FjaGluZyBpbXByb3ZlcyB0aGUgc3BlZWQgNnhcbiAgICBsZXQgaGV4ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBoZXggKz0gaGV4ZXNbYnl0ZXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuLy8gV2UgdXNlIG9wdGltaXplZCB0ZWNobmlxdWUgdG8gY29udmVydCBoZXggc3RyaW5nIHRvIGJ5dGUgYXJyYXlcbmNvbnN0IGFzY2lpcyA9IHsgXzA6IDQ4LCBfOTogNTcsIEE6IDY1LCBGOiA3MCwgYTogOTcsIGY6IDEwMiB9O1xuZnVuY3Rpb24gYXNjaWlUb0Jhc2UxNihjaCkge1xuICAgIGlmIChjaCA+PSBhc2NpaXMuXzAgJiYgY2ggPD0gYXNjaWlzLl85KVxuICAgICAgICByZXR1cm4gY2ggLSBhc2NpaXMuXzA7IC8vICcyJyA9PiA1MC00OFxuICAgIGlmIChjaCA+PSBhc2NpaXMuQSAmJiBjaCA8PSBhc2NpaXMuRilcbiAgICAgICAgcmV0dXJuIGNoIC0gKGFzY2lpcy5BIC0gMTApOyAvLyAnQicgPT4gNjYtKDY1LTEwKVxuICAgIGlmIChjaCA+PSBhc2NpaXMuYSAmJiBjaCA8PSBhc2NpaXMuZilcbiAgICAgICAgcmV0dXJuIGNoIC0gKGFzY2lpcy5hIC0gMTApOyAvLyAnYicgPT4gOTgtKDk3LTEwKVxuICAgIHJldHVybjtcbn1cbi8qKlxuICogQ29udmVydCBoZXggc3RyaW5nIHRvIGJ5dGUgYXJyYXkuIFVzZXMgYnVpbHQtaW4gZnVuY3Rpb24sIHdoZW4gYXZhaWxhYmxlLlxuICogQGV4YW1wbGUgaGV4VG9CeXRlcygnY2FmZTAxMjMnKSAvLyBVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKGhhc0hleEJ1aWx0aW4pXG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb21IZXgoaGV4KTtcbiAgICBjb25zdCBobCA9IGhleC5sZW5ndGg7XG4gICAgY29uc3QgYWwgPSBobCAvIDI7XG4gICAgaWYgKGhsICUgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgdW5wYWRkZWQgaGV4IG9mIGxlbmd0aCAnICsgaGwpO1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYWwpO1xuICAgIGZvciAobGV0IGFpID0gMCwgaGkgPSAwOyBhaSA8IGFsOyBhaSsrLCBoaSArPSAyKSB7XG4gICAgICAgIGNvbnN0IG4xID0gYXNjaWlUb0Jhc2UxNihoZXguY2hhckNvZGVBdChoaSkpO1xuICAgICAgICBjb25zdCBuMiA9IGFzY2lpVG9CYXNlMTYoaGV4LmNoYXJDb2RlQXQoaGkgKyAxKSk7XG4gICAgICAgIGlmIChuMSA9PT0gdW5kZWZpbmVkIHx8IG4yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXIgPSBoZXhbaGldICsgaGV4W2hpICsgMV07XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCBub24taGV4IGNoYXJhY3RlciBcIicgKyBjaGFyICsgJ1wiIGF0IGluZGV4ICcgKyBoaSk7XG4gICAgICAgIH1cbiAgICAgICAgYXJyYXlbYWldID0gbjEgKiAxNiArIG4yOyAvLyBtdWx0aXBseSBmaXJzdCBvY3RldCwgZS5nLiAnYTMnID0+IDEwKjE2KzMgPT4gMTYwICsgMyA9PiAxNjNcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuLyoqXG4gKiBUaGVyZSBpcyBubyBzZXRJbW1lZGlhdGUgaW4gYnJvd3NlciBhbmQgc2V0VGltZW91dCBpcyBzbG93LlxuICogQ2FsbCBvZiBhc3luYyBmbiB3aWxsIHJldHVybiBQcm9taXNlLCB3aGljaCB3aWxsIGJlIGZ1bGxmaWxlZCBvbmx5IG9uXG4gKiBuZXh0IHNjaGVkdWxlciBxdWV1ZSBwcm9jZXNzaW5nIHN0ZXAgYW5kIHRoaXMgaXMgZXhhY3RseSB3aGF0IHdlIG5lZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBuZXh0VGljayA9IGFzeW5jICgpID0+IHsgfTtcbi8qKiBSZXR1cm5zIGNvbnRyb2wgdG8gdGhyZWFkIGVhY2ggJ3RpY2snIG1zIHRvIGF2b2lkIGJsb2NraW5nLiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFzeW5jTG9vcChpdGVycywgdGljaywgY2IpIHtcbiAgICBsZXQgdHMgPSBEYXRlLm5vdygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcnM7IGkrKykge1xuICAgICAgICBjYihpKTtcbiAgICAgICAgLy8gRGF0ZS5ub3coKSBpcyBub3QgbW9ub3RvbmljLCBzbyBpbiBjYXNlIGlmIGNsb2NrIGdvZXMgYmFja3dhcmRzIHdlIHJldHVybiByZXR1cm4gY29udHJvbCB0b29cbiAgICAgICAgY29uc3QgZGlmZiA9IERhdGUubm93KCkgLSB0cztcbiAgICAgICAgaWYgKGRpZmYgPj0gMCAmJiBkaWZmIDwgdGljaylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBhd2FpdCBuZXh0VGljaygpO1xuICAgICAgICB0cyArPSBkaWZmO1xuICAgIH1cbn1cbi8qKlxuICogQ29udmVydHMgc3RyaW5nIHRvIGJ5dGVzIHVzaW5nIFVURjggZW5jb2RpbmcuXG4gKiBAZXhhbXBsZSB1dGY4VG9CeXRlcygnYWJjJykgLy8gVWludDhBcnJheS5mcm9tKFs5NywgOTgsIDk5XSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdHJpbmcgZXhwZWN0ZWQnKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cikpOyAvLyBodHRwczovL2J1Z3ppbC5sYS8xNjgxODA5XG59XG4vKipcbiAqIENvbnZlcnRzIGJ5dGVzIHRvIHN0cmluZyB1c2luZyBVVEY4IGVuY29kaW5nLlxuICogQGV4YW1wbGUgYnl0ZXNUb1V0ZjgoVWludDhBcnJheS5mcm9tKFs5NywgOTgsIDk5XSkpIC8vICdhYmMnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvVXRmOChieXRlcykge1xuICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoYnl0ZXMpO1xufVxuLyoqXG4gKiBOb3JtYWxpemVzIChub24taGV4KSBzdHJpbmcgb3IgVWludDhBcnJheSB0byBVaW50OEFycmF5LlxuICogV2FybmluZzogd2hlbiBVaW50OEFycmF5IGlzIHBhc3NlZCwgaXQgd291bGQgTk9UIGdldCBjb3BpZWQuXG4gKiBLZWVwIGluIG1pbmQgZm9yIGZ1dHVyZSBtdXRhYmxlIG9wZXJhdGlvbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0J5dGVzKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKVxuICAgICAgICBkYXRhID0gdXRmOFRvQnl0ZXMoZGF0YSk7XG4gICAgYWJ5dGVzKGRhdGEpO1xuICAgIHJldHVybiBkYXRhO1xufVxuLyoqXG4gKiBIZWxwZXIgZm9yIEtERnM6IGNvbnN1bWVzIHVpbnQ4YXJyYXkgb3Igc3RyaW5nLlxuICogV2hlbiBzdHJpbmcgaXMgcGFzc2VkLCBkb2VzIHV0ZjggZGVjb2RpbmcsIHVzaW5nIFRleHREZWNvZGVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24ga2RmSW5wdXRUb0J5dGVzKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKVxuICAgICAgICBkYXRhID0gdXRmOFRvQnl0ZXMoZGF0YSk7XG4gICAgYWJ5dGVzKGRhdGEpO1xuICAgIHJldHVybiBkYXRhO1xufVxuLyoqIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGxldCBzdW0gPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBhcnJheXNbaV07XG4gICAgICAgIGFieXRlcyhhKTtcbiAgICAgICAgc3VtICs9IGEubGVuZ3RoO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShzdW0pO1xuICAgIGZvciAobGV0IGkgPSAwLCBwYWQgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBhcnJheXNbaV07XG4gICAgICAgIHJlcy5zZXQoYSwgcGFkKTtcbiAgICAgICAgcGFkICs9IGEubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrT3B0cyhkZWZhdWx0cywgb3B0cykge1xuICAgIGlmIChvcHRzICE9PSB1bmRlZmluZWQgJiYge30udG9TdHJpbmcuY2FsbChvcHRzKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucyBzaG91bGQgYmUgb2JqZWN0IG9yIHVuZGVmaW5lZCcpO1xuICAgIGNvbnN0IG1lcmdlZCA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdHMsIG9wdHMpO1xuICAgIHJldHVybiBtZXJnZWQ7XG59XG4vKiogRm9yIHJ1bnRpbWUgY2hlY2sgaWYgY2xhc3MgaW1wbGVtZW50cyBpbnRlcmZhY2UgKi9cbmV4cG9ydCBjbGFzcyBIYXNoIHtcbn1cbi8qKiBXcmFwcyBoYXNoIGZ1bmN0aW9uLCBjcmVhdGluZyBhbiBpbnRlcmZhY2Ugb24gdG9wIG9mIGl0ICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSGFzaGVyKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnKSA9PiBoYXNoQ29ucygpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKCk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAoKSA9PiBoYXNoQ29ucygpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVPcHRIYXNoZXIoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlWE9GZXIoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnQgY29uc3Qgd3JhcENvbnN0cnVjdG9yID0gY3JlYXRlSGFzaGVyO1xuZXhwb3J0IGNvbnN0IHdyYXBDb25zdHJ1Y3RvcldpdGhPcHRzID0gY3JlYXRlT3B0SGFzaGVyO1xuZXhwb3J0IGNvbnN0IHdyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzID0gY3JlYXRlWE9GZXI7XG4vKiogQ3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlIFBSTkcuIFVzZXMgaW50ZXJuYWwgT1MtbGV2ZWwgYGNyeXB0by5nZXRSYW5kb21WYWx1ZXNgLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbUJ5dGVzKGJ5dGVzTGVuZ3RoID0gMzIpIHtcbiAgICBpZiAoY3J5cHRvICYmIHR5cGVvZiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KGJ5dGVzTGVuZ3RoKSk7XG4gICAgfVxuICAgIC8vIExlZ2FjeSBOb2RlLmpzIGNvbXBhdGliaWxpdHlcbiAgICBpZiAoY3J5cHRvICYmIHR5cGVvZiBjcnlwdG8ucmFuZG9tQnl0ZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShjcnlwdG8ucmFuZG9tQnl0ZXMoYnl0ZXNMZW5ndGgpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIG11c3QgYmUgZGVmaW5lZCcpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbImNyeXB0byIsImlzQnl0ZXMiLCJhIiwiVWludDhBcnJheSIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwiY29uc3RydWN0b3IiLCJuYW1lIiwiYW51bWJlciIsIm4iLCJOdW1iZXIiLCJpc1NhZmVJbnRlZ2VyIiwiRXJyb3IiLCJhYnl0ZXMiLCJiIiwibGVuZ3RocyIsImxlbmd0aCIsImluY2x1ZGVzIiwiYWhhc2giLCJoIiwiY3JlYXRlIiwib3V0cHV0TGVuIiwiYmxvY2tMZW4iLCJhZXhpc3RzIiwiaW5zdGFuY2UiLCJjaGVja0ZpbmlzaGVkIiwiZGVzdHJveWVkIiwiZmluaXNoZWQiLCJhb3V0cHV0Iiwib3V0IiwibWluIiwidTgiLCJhcnIiLCJidWZmZXIiLCJieXRlT2Zmc2V0IiwiYnl0ZUxlbmd0aCIsInUzMiIsIlVpbnQzMkFycmF5IiwiTWF0aCIsImZsb29yIiwiY2xlYW4iLCJhcnJheXMiLCJpIiwiZmlsbCIsImNyZWF0ZVZpZXciLCJEYXRhVmlldyIsInJvdHIiLCJ3b3JkIiwic2hpZnQiLCJyb3RsIiwiaXNMRSIsImJ5dGVTd2FwIiwic3dhcDhJZkJFIiwiYnl0ZVN3YXBJZkJFIiwiYnl0ZVN3YXAzMiIsInN3YXAzMklmQkUiLCJ1IiwiaGFzSGV4QnVpbHRpbiIsImZyb20iLCJ0b0hleCIsImZyb21IZXgiLCJoZXhlcyIsIkFycmF5IiwiXyIsInRvU3RyaW5nIiwicGFkU3RhcnQiLCJieXRlc1RvSGV4IiwiYnl0ZXMiLCJoZXgiLCJhc2NpaXMiLCJfMCIsIl85IiwiQSIsIkYiLCJmIiwiYXNjaWlUb0Jhc2UxNiIsImNoIiwiaGV4VG9CeXRlcyIsImhsIiwiYWwiLCJhcnJheSIsImFpIiwiaGkiLCJuMSIsImNoYXJDb2RlQXQiLCJuMiIsInVuZGVmaW5lZCIsImNoYXIiLCJuZXh0VGljayIsImFzeW5jTG9vcCIsIml0ZXJzIiwidGljayIsImNiIiwidHMiLCJEYXRlIiwibm93IiwiZGlmZiIsInV0ZjhUb0J5dGVzIiwic3RyIiwiVGV4dEVuY29kZXIiLCJlbmNvZGUiLCJieXRlc1RvVXRmOCIsIlRleHREZWNvZGVyIiwiZGVjb2RlIiwidG9CeXRlcyIsImRhdGEiLCJrZGZJbnB1dFRvQnl0ZXMiLCJjb25jYXRCeXRlcyIsInN1bSIsInJlcyIsInBhZCIsInNldCIsImNoZWNrT3B0cyIsImRlZmF1bHRzIiwib3B0cyIsImNhbGwiLCJtZXJnZWQiLCJPYmplY3QiLCJhc3NpZ24iLCJIYXNoIiwiY3JlYXRlSGFzaGVyIiwiaGFzaENvbnMiLCJoYXNoQyIsIm1zZyIsInVwZGF0ZSIsImRpZ2VzdCIsInRtcCIsImNyZWF0ZU9wdEhhc2hlciIsImNyZWF0ZVhPRmVyIiwid3JhcENvbnN0cnVjdG9yIiwid3JhcENvbnN0cnVjdG9yV2l0aE9wdHMiLCJ3cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cyIsInJhbmRvbUJ5dGVzIiwiYnl0ZXNMZW5ndGgiLCJnZXRSYW5kb21WYWx1ZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/web3.js/node_modules/@solana/codecs-core/dist/index.node.mjs":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@solana/web3.js/node_modules/@solana/codecs-core/dist/index.node.mjs ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addCodecSentinel: () => (/* binding */ addCodecSentinel),\n/* harmony export */   addCodecSizePrefix: () => (/* binding */ addCodecSizePrefix),\n/* harmony export */   addDecoderSentinel: () => (/* binding */ addDecoderSentinel),\n/* harmony export */   addDecoderSizePrefix: () => (/* binding */ addDecoderSizePrefix),\n/* harmony export */   addEncoderSentinel: () => (/* binding */ addEncoderSentinel),\n/* harmony export */   addEncoderSizePrefix: () => (/* binding */ addEncoderSizePrefix),\n/* harmony export */   assertByteArrayHasEnoughBytesForCodec: () => (/* binding */ assertByteArrayHasEnoughBytesForCodec),\n/* harmony export */   assertByteArrayIsNotEmptyForCodec: () => (/* binding */ assertByteArrayIsNotEmptyForCodec),\n/* harmony export */   assertByteArrayOffsetIsNotOutOfRange: () => (/* binding */ assertByteArrayOffsetIsNotOutOfRange),\n/* harmony export */   assertIsFixedSize: () => (/* binding */ assertIsFixedSize),\n/* harmony export */   assertIsVariableSize: () => (/* binding */ assertIsVariableSize),\n/* harmony export */   combineCodec: () => (/* binding */ combineCodec),\n/* harmony export */   containsBytes: () => (/* binding */ containsBytes),\n/* harmony export */   createCodec: () => (/* binding */ createCodec),\n/* harmony export */   createDecoder: () => (/* binding */ createDecoder),\n/* harmony export */   createEncoder: () => (/* binding */ createEncoder),\n/* harmony export */   fixBytes: () => (/* binding */ fixBytes),\n/* harmony export */   fixCodecSize: () => (/* binding */ fixCodecSize),\n/* harmony export */   fixDecoderSize: () => (/* binding */ fixDecoderSize),\n/* harmony export */   fixEncoderSize: () => (/* binding */ fixEncoderSize),\n/* harmony export */   getEncodedSize: () => (/* binding */ getEncodedSize),\n/* harmony export */   isFixedSize: () => (/* binding */ isFixedSize),\n/* harmony export */   isVariableSize: () => (/* binding */ isVariableSize),\n/* harmony export */   mergeBytes: () => (/* binding */ mergeBytes),\n/* harmony export */   offsetCodec: () => (/* binding */ offsetCodec),\n/* harmony export */   offsetDecoder: () => (/* binding */ offsetDecoder),\n/* harmony export */   offsetEncoder: () => (/* binding */ offsetEncoder),\n/* harmony export */   padBytes: () => (/* binding */ padBytes),\n/* harmony export */   padLeftCodec: () => (/* binding */ padLeftCodec),\n/* harmony export */   padLeftDecoder: () => (/* binding */ padLeftDecoder),\n/* harmony export */   padLeftEncoder: () => (/* binding */ padLeftEncoder),\n/* harmony export */   padRightCodec: () => (/* binding */ padRightCodec),\n/* harmony export */   padRightDecoder: () => (/* binding */ padRightDecoder),\n/* harmony export */   padRightEncoder: () => (/* binding */ padRightEncoder),\n/* harmony export */   resizeCodec: () => (/* binding */ resizeCodec),\n/* harmony export */   resizeDecoder: () => (/* binding */ resizeDecoder),\n/* harmony export */   resizeEncoder: () => (/* binding */ resizeEncoder),\n/* harmony export */   reverseCodec: () => (/* binding */ reverseCodec),\n/* harmony export */   reverseDecoder: () => (/* binding */ reverseDecoder),\n/* harmony export */   reverseEncoder: () => (/* binding */ reverseEncoder),\n/* harmony export */   transformCodec: () => (/* binding */ transformCodec),\n/* harmony export */   transformDecoder: () => (/* binding */ transformDecoder),\n/* harmony export */   transformEncoder: () => (/* binding */ transformEncoder)\n/* harmony export */ });\n/* harmony import */ var _solana_errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/errors */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@solana/errors/dist/index.node.mjs\");\n\n// src/add-codec-sentinel.ts\n// src/bytes.ts\nvar mergeBytes = (byteArrays)=>{\n    const nonEmptyByteArrays = byteArrays.filter((arr)=>arr.length);\n    if (nonEmptyByteArrays.length === 0) {\n        return byteArrays.length ? byteArrays[0] : new Uint8Array();\n    }\n    if (nonEmptyByteArrays.length === 1) {\n        return nonEmptyByteArrays[0];\n    }\n    const totalLength = nonEmptyByteArrays.reduce((total, arr)=>total + arr.length, 0);\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    nonEmptyByteArrays.forEach((arr)=>{\n        result.set(arr, offset);\n        offset += arr.length;\n    });\n    return result;\n};\nvar padBytes = (bytes, length)=>{\n    if (bytes.length >= length) return bytes;\n    const paddedBytes = new Uint8Array(length).fill(0);\n    paddedBytes.set(bytes);\n    return paddedBytes;\n};\nvar fixBytes = (bytes, length)=>padBytes(bytes.length <= length ? bytes : bytes.slice(0, length), length);\nfunction containsBytes(data, bytes, offset) {\n    const slice = offset === 0 && data.length === bytes.length ? data : data.slice(offset, offset + bytes.length);\n    if (slice.length !== bytes.length) return false;\n    return bytes.every((b, i)=>b === slice[i]);\n}\nfunction getEncodedSize(value, encoder) {\n    return \"fixedSize\" in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);\n}\nfunction createEncoder(encoder) {\n    return Object.freeze({\n        ...encoder,\n        encode: (value)=>{\n            const bytes = new Uint8Array(getEncodedSize(value, encoder));\n            encoder.write(value, bytes, 0);\n            return bytes;\n        }\n    });\n}\nfunction createDecoder(decoder) {\n    return Object.freeze({\n        ...decoder,\n        decode: (bytes, offset = 0)=>decoder.read(bytes, offset)[0]\n    });\n}\nfunction createCodec(codec) {\n    return Object.freeze({\n        ...codec,\n        decode: (bytes, offset = 0)=>codec.read(bytes, offset)[0],\n        encode: (value)=>{\n            const bytes = new Uint8Array(getEncodedSize(value, codec));\n            codec.write(value, bytes, 0);\n            return bytes;\n        }\n    });\n}\nfunction isFixedSize(codec) {\n    return \"fixedSize\" in codec && typeof codec.fixedSize === \"number\";\n}\nfunction assertIsFixedSize(codec) {\n    if (!isFixedSize(codec)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH);\n    }\n}\nfunction isVariableSize(codec) {\n    return !isFixedSize(codec);\n}\nfunction assertIsVariableSize(codec) {\n    if (!isVariableSize(codec)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH);\n    }\n}\nfunction combineCodec(encoder, decoder) {\n    if (isFixedSize(encoder) !== isFixedSize(decoder)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH);\n    }\n    if (isFixedSize(encoder) && isFixedSize(decoder) && encoder.fixedSize !== decoder.fixedSize) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, {\n            decoderFixedSize: decoder.fixedSize,\n            encoderFixedSize: encoder.fixedSize\n        });\n    }\n    if (!isFixedSize(encoder) && !isFixedSize(decoder) && encoder.maxSize !== decoder.maxSize) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, {\n            decoderMaxSize: decoder.maxSize,\n            encoderMaxSize: encoder.maxSize\n        });\n    }\n    return {\n        ...decoder,\n        ...encoder,\n        decode: decoder.decode,\n        encode: encoder.encode,\n        read: decoder.read,\n        write: encoder.write\n    };\n}\n// src/add-codec-sentinel.ts\nfunction addEncoderSentinel(encoder, sentinel) {\n    const write = (value, bytes, offset)=>{\n        const encoderBytes = encoder.encode(value);\n        if (findSentinelIndex(encoderBytes, sentinel) >= 0) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL, {\n                encodedBytes: encoderBytes,\n                hexEncodedBytes: hexBytes(encoderBytes),\n                hexSentinel: hexBytes(sentinel),\n                sentinel\n            });\n        }\n        bytes.set(encoderBytes, offset);\n        offset += encoderBytes.length;\n        bytes.set(sentinel, offset);\n        offset += sentinel.length;\n        return offset;\n    };\n    if (isFixedSize(encoder)) {\n        return createEncoder({\n            ...encoder,\n            fixedSize: encoder.fixedSize + sentinel.length,\n            write\n        });\n    }\n    return createEncoder({\n        ...encoder,\n        ...encoder.maxSize != null ? {\n            maxSize: encoder.maxSize + sentinel.length\n        } : {},\n        getSizeFromValue: (value)=>encoder.getSizeFromValue(value) + sentinel.length,\n        write\n    });\n}\nfunction addDecoderSentinel(decoder, sentinel) {\n    const read = (bytes, offset)=>{\n        const candidateBytes = offset === 0 ? bytes : bytes.slice(offset);\n        const sentinelIndex = findSentinelIndex(candidateBytes, sentinel);\n        if (sentinelIndex === -1) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES, {\n                decodedBytes: candidateBytes,\n                hexDecodedBytes: hexBytes(candidateBytes),\n                hexSentinel: hexBytes(sentinel),\n                sentinel\n            });\n        }\n        const preSentinelBytes = candidateBytes.slice(0, sentinelIndex);\n        return [\n            decoder.decode(preSentinelBytes),\n            offset + preSentinelBytes.length + sentinel.length\n        ];\n    };\n    if (isFixedSize(decoder)) {\n        return createDecoder({\n            ...decoder,\n            fixedSize: decoder.fixedSize + sentinel.length,\n            read\n        });\n    }\n    return createDecoder({\n        ...decoder,\n        ...decoder.maxSize != null ? {\n            maxSize: decoder.maxSize + sentinel.length\n        } : {},\n        read\n    });\n}\nfunction addCodecSentinel(codec, sentinel) {\n    return combineCodec(addEncoderSentinel(codec, sentinel), addDecoderSentinel(codec, sentinel));\n}\nfunction findSentinelIndex(bytes, sentinel) {\n    return bytes.findIndex((byte, index, arr)=>{\n        if (sentinel.length === 1) return byte === sentinel[0];\n        return containsBytes(arr, sentinel, index);\n    });\n}\nfunction hexBytes(bytes) {\n    return bytes.reduce((str, byte)=>str + byte.toString(16).padStart(2, \"0\"), \"\");\n}\nfunction assertByteArrayIsNotEmptyForCodec(codecDescription, bytes, offset = 0) {\n    if (bytes.length - offset <= 0) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, {\n            codecDescription\n        });\n    }\n}\nfunction assertByteArrayHasEnoughBytesForCodec(codecDescription, expected, bytes, offset = 0) {\n    const bytesLength = bytes.length - offset;\n    if (bytesLength < expected) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {\n            bytesLength,\n            codecDescription,\n            expected\n        });\n    }\n}\nfunction assertByteArrayOffsetIsNotOutOfRange(codecDescription, offset, bytesLength) {\n    if (offset < 0 || offset > bytesLength) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE, {\n            bytesLength,\n            codecDescription,\n            offset\n        });\n    }\n}\n// src/add-codec-size-prefix.ts\nfunction addEncoderSizePrefix(encoder, prefix) {\n    const write = (value, bytes, offset)=>{\n        const encoderBytes = encoder.encode(value);\n        offset = prefix.write(encoderBytes.length, bytes, offset);\n        bytes.set(encoderBytes, offset);\n        return offset + encoderBytes.length;\n    };\n    if (isFixedSize(prefix) && isFixedSize(encoder)) {\n        return createEncoder({\n            ...encoder,\n            fixedSize: prefix.fixedSize + encoder.fixedSize,\n            write\n        });\n    }\n    const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : prefix.maxSize ?? null;\n    const encoderMaxSize = isFixedSize(encoder) ? encoder.fixedSize : encoder.maxSize ?? null;\n    const maxSize = prefixMaxSize !== null && encoderMaxSize !== null ? prefixMaxSize + encoderMaxSize : null;\n    return createEncoder({\n        ...encoder,\n        ...maxSize !== null ? {\n            maxSize\n        } : {},\n        getSizeFromValue: (value)=>{\n            const encoderSize = getEncodedSize(value, encoder);\n            return getEncodedSize(encoderSize, prefix) + encoderSize;\n        },\n        write\n    });\n}\nfunction addDecoderSizePrefix(decoder, prefix) {\n    const read = (bytes, offset)=>{\n        const [bigintSize, decoderOffset] = prefix.read(bytes, offset);\n        const size = Number(bigintSize);\n        offset = decoderOffset;\n        if (offset > 0 || bytes.length > size) {\n            bytes = bytes.slice(offset, offset + size);\n        }\n        assertByteArrayHasEnoughBytesForCodec(\"addDecoderSizePrefix\", size, bytes);\n        return [\n            decoder.decode(bytes),\n            offset + size\n        ];\n    };\n    if (isFixedSize(prefix) && isFixedSize(decoder)) {\n        return createDecoder({\n            ...decoder,\n            fixedSize: prefix.fixedSize + decoder.fixedSize,\n            read\n        });\n    }\n    const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : prefix.maxSize ?? null;\n    const decoderMaxSize = isFixedSize(decoder) ? decoder.fixedSize : decoder.maxSize ?? null;\n    const maxSize = prefixMaxSize !== null && decoderMaxSize !== null ? prefixMaxSize + decoderMaxSize : null;\n    return createDecoder({\n        ...decoder,\n        ...maxSize !== null ? {\n            maxSize\n        } : {},\n        read\n    });\n}\nfunction addCodecSizePrefix(codec, prefix) {\n    return combineCodec(addEncoderSizePrefix(codec, prefix), addDecoderSizePrefix(codec, prefix));\n}\n// src/fix-codec-size.ts\nfunction fixEncoderSize(encoder, fixedBytes) {\n    return createEncoder({\n        fixedSize: fixedBytes,\n        write: (value, bytes, offset)=>{\n            const variableByteArray = encoder.encode(value);\n            const fixedByteArray = variableByteArray.length > fixedBytes ? variableByteArray.slice(0, fixedBytes) : variableByteArray;\n            bytes.set(fixedByteArray, offset);\n            return offset + fixedBytes;\n        }\n    });\n}\nfunction fixDecoderSize(decoder, fixedBytes) {\n    return createDecoder({\n        fixedSize: fixedBytes,\n        read: (bytes, offset)=>{\n            assertByteArrayHasEnoughBytesForCodec(\"fixCodecSize\", fixedBytes, bytes, offset);\n            if (offset > 0 || bytes.length > fixedBytes) {\n                bytes = bytes.slice(offset, offset + fixedBytes);\n            }\n            if (isFixedSize(decoder)) {\n                bytes = fixBytes(bytes, decoder.fixedSize);\n            }\n            const [value] = decoder.read(bytes, 0);\n            return [\n                value,\n                offset + fixedBytes\n            ];\n        }\n    });\n}\nfunction fixCodecSize(codec, fixedBytes) {\n    return combineCodec(fixEncoderSize(codec, fixedBytes), fixDecoderSize(codec, fixedBytes));\n}\n// src/offset-codec.ts\nfunction offsetEncoder(encoder, config) {\n    return createEncoder({\n        ...encoder,\n        write: (value, bytes, preOffset)=>{\n            const wrapBytes = (offset)=>modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({\n                bytes,\n                preOffset,\n                wrapBytes\n            }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange(\"offsetEncoder\", newPreOffset, bytes.length);\n            const postOffset = encoder.write(value, bytes, newPreOffset);\n            const newPostOffset = config.postOffset ? config.postOffset({\n                bytes,\n                newPreOffset,\n                postOffset,\n                preOffset,\n                wrapBytes\n            }) : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange(\"offsetEncoder\", newPostOffset, bytes.length);\n            return newPostOffset;\n        }\n    });\n}\nfunction offsetDecoder(decoder, config) {\n    return createDecoder({\n        ...decoder,\n        read: (bytes, preOffset)=>{\n            const wrapBytes = (offset)=>modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({\n                bytes,\n                preOffset,\n                wrapBytes\n            }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange(\"offsetDecoder\", newPreOffset, bytes.length);\n            const [value, postOffset] = decoder.read(bytes, newPreOffset);\n            const newPostOffset = config.postOffset ? config.postOffset({\n                bytes,\n                newPreOffset,\n                postOffset,\n                preOffset,\n                wrapBytes\n            }) : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange(\"offsetDecoder\", newPostOffset, bytes.length);\n            return [\n                value,\n                newPostOffset\n            ];\n        }\n    });\n}\nfunction offsetCodec(codec, config) {\n    return combineCodec(offsetEncoder(codec, config), offsetDecoder(codec, config));\n}\nfunction modulo(dividend, divisor) {\n    if (divisor === 0) return 0;\n    return (dividend % divisor + divisor) % divisor;\n}\nfunction resizeEncoder(encoder, resize) {\n    if (isFixedSize(encoder)) {\n        const fixedSize = resize(encoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: \"resizeEncoder\"\n            });\n        }\n        return createEncoder({\n            ...encoder,\n            fixedSize\n        });\n    }\n    return createEncoder({\n        ...encoder,\n        getSizeFromValue: (value)=>{\n            const newSize = resize(encoder.getSizeFromValue(value));\n            if (newSize < 0) {\n                throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                    bytesLength: newSize,\n                    codecDescription: \"resizeEncoder\"\n                });\n            }\n            return newSize;\n        }\n    });\n}\nfunction resizeDecoder(decoder, resize) {\n    if (isFixedSize(decoder)) {\n        const fixedSize = resize(decoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: \"resizeDecoder\"\n            });\n        }\n        return createDecoder({\n            ...decoder,\n            fixedSize\n        });\n    }\n    return decoder;\n}\nfunction resizeCodec(codec, resize) {\n    return combineCodec(resizeEncoder(codec, resize), resizeDecoder(codec, resize));\n}\n// src/pad-codec.ts\nfunction padLeftEncoder(encoder, offset) {\n    return offsetEncoder(resizeEncoder(encoder, (size)=>size + offset), {\n        preOffset: ({ preOffset })=>preOffset + offset\n    });\n}\nfunction padRightEncoder(encoder, offset) {\n    return offsetEncoder(resizeEncoder(encoder, (size)=>size + offset), {\n        postOffset: ({ postOffset })=>postOffset + offset\n    });\n}\nfunction padLeftDecoder(decoder, offset) {\n    return offsetDecoder(resizeDecoder(decoder, (size)=>size + offset), {\n        preOffset: ({ preOffset })=>preOffset + offset\n    });\n}\nfunction padRightDecoder(decoder, offset) {\n    return offsetDecoder(resizeDecoder(decoder, (size)=>size + offset), {\n        postOffset: ({ postOffset })=>postOffset + offset\n    });\n}\nfunction padLeftCodec(codec, offset) {\n    return combineCodec(padLeftEncoder(codec, offset), padLeftDecoder(codec, offset));\n}\nfunction padRightCodec(codec, offset) {\n    return combineCodec(padRightEncoder(codec, offset), padRightDecoder(codec, offset));\n}\n// src/reverse-codec.ts\nfunction copySourceToTargetInReverse(source, target_WILL_MUTATE, sourceOffset, sourceLength, targetOffset = 0) {\n    while(sourceOffset < --sourceLength){\n        const leftValue = source[sourceOffset];\n        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceLength];\n        target_WILL_MUTATE[sourceLength + targetOffset] = leftValue;\n        sourceOffset++;\n    }\n    if (sourceOffset === sourceLength) {\n        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceOffset];\n    }\n}\nfunction reverseEncoder(encoder) {\n    assertIsFixedSize(encoder);\n    return createEncoder({\n        ...encoder,\n        write: (value, bytes, offset)=>{\n            const newOffset = encoder.write(value, bytes, offset);\n            copySourceToTargetInReverse(bytes, bytes, offset, offset + encoder.fixedSize);\n            return newOffset;\n        }\n    });\n}\nfunction reverseDecoder(decoder) {\n    assertIsFixedSize(decoder);\n    return createDecoder({\n        ...decoder,\n        read: (bytes, offset)=>{\n            const reversedBytes = bytes.slice();\n            copySourceToTargetInReverse(bytes, reversedBytes, offset, offset + decoder.fixedSize);\n            return decoder.read(reversedBytes, offset);\n        }\n    });\n}\nfunction reverseCodec(codec) {\n    return combineCodec(reverseEncoder(codec), reverseDecoder(codec));\n}\n// src/transform-codec.ts\nfunction transformEncoder(encoder, unmap) {\n    return createEncoder({\n        ...isVariableSize(encoder) ? {\n            ...encoder,\n            getSizeFromValue: (value)=>encoder.getSizeFromValue(unmap(value))\n        } : encoder,\n        write: (value, bytes, offset)=>encoder.write(unmap(value), bytes, offset)\n    });\n}\nfunction transformDecoder(decoder, map) {\n    return createDecoder({\n        ...decoder,\n        read: (bytes, offset)=>{\n            const [value, newOffset] = decoder.read(bytes, offset);\n            return [\n                map(value, bytes, offset),\n                newOffset\n            ];\n        }\n    });\n}\nfunction transformCodec(codec, unmap, map) {\n    return createCodec({\n        ...transformEncoder(codec, unmap),\n        read: map ? transformDecoder(codec, map).read : codec.read\n    });\n}\n //# sourceMappingURL=index.node.mjs.map\n //# sourceMappingURL=index.node.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Ac29sYW5hL2NvZGVjcy1jb3JlL2Rpc3QvaW5kZXgubm9kZS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMG5CO0FBRTFuQiw0QkFBNEI7QUFFNUIsZUFBZTtBQUNmLElBQUlZLGFBQWEsQ0FBQ0M7SUFDaEIsTUFBTUMscUJBQXFCRCxXQUFXRSxNQUFNLENBQUMsQ0FBQ0MsTUFBUUEsSUFBSUMsTUFBTTtJQUNoRSxJQUFJSCxtQkFBbUJHLE1BQU0sS0FBSyxHQUFHO1FBQ25DLE9BQU9KLFdBQVdJLE1BQU0sR0FBR0osVUFBVSxDQUFDLEVBQUUsR0FBRyxJQUFJSztJQUNqRDtJQUNBLElBQUlKLG1CQUFtQkcsTUFBTSxLQUFLLEdBQUc7UUFDbkMsT0FBT0gsa0JBQWtCLENBQUMsRUFBRTtJQUM5QjtJQUNBLE1BQU1LLGNBQWNMLG1CQUFtQk0sTUFBTSxDQUFDLENBQUNDLE9BQU9MLE1BQVFLLFFBQVFMLElBQUlDLE1BQU0sRUFBRTtJQUNsRixNQUFNSyxTQUFTLElBQUlKLFdBQVdDO0lBQzlCLElBQUlJLFNBQVM7SUFDYlQsbUJBQW1CVSxPQUFPLENBQUMsQ0FBQ1I7UUFDMUJNLE9BQU9HLEdBQUcsQ0FBQ1QsS0FBS087UUFDaEJBLFVBQVVQLElBQUlDLE1BQU07SUFDdEI7SUFDQSxPQUFPSztBQUNUO0FBQ0EsSUFBSUksV0FBVyxDQUFDQyxPQUFPVjtJQUNyQixJQUFJVSxNQUFNVixNQUFNLElBQUlBLFFBQVEsT0FBT1U7SUFDbkMsTUFBTUMsY0FBYyxJQUFJVixXQUFXRCxRQUFRWSxJQUFJLENBQUM7SUFDaERELFlBQVlILEdBQUcsQ0FBQ0U7SUFDaEIsT0FBT0M7QUFDVDtBQUNBLElBQUlFLFdBQVcsQ0FBQ0gsT0FBT1YsU0FBV1MsU0FBU0MsTUFBTVYsTUFBTSxJQUFJQSxTQUFTVSxRQUFRQSxNQUFNSSxLQUFLLENBQUMsR0FBR2QsU0FBU0E7QUFDcEcsU0FBU2UsY0FBY0MsSUFBSSxFQUFFTixLQUFLLEVBQUVKLE1BQU07SUFDeEMsTUFBTVEsUUFBUVIsV0FBVyxLQUFLVSxLQUFLaEIsTUFBTSxLQUFLVSxNQUFNVixNQUFNLEdBQUdnQixPQUFPQSxLQUFLRixLQUFLLENBQUNSLFFBQVFBLFNBQVNJLE1BQU1WLE1BQU07SUFDNUcsSUFBSWMsTUFBTWQsTUFBTSxLQUFLVSxNQUFNVixNQUFNLEVBQUUsT0FBTztJQUMxQyxPQUFPVSxNQUFNTyxLQUFLLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTUQsTUFBTUosS0FBSyxDQUFDSyxFQUFFO0FBQzdDO0FBQ0EsU0FBU0MsZUFBZUMsS0FBSyxFQUFFQyxPQUFPO0lBQ3BDLE9BQU8sZUFBZUEsVUFBVUEsUUFBUUMsU0FBUyxHQUFHRCxRQUFRRSxnQkFBZ0IsQ0FBQ0g7QUFDL0U7QUFDQSxTQUFTSSxjQUFjSCxPQUFPO0lBQzVCLE9BQU9JLE9BQU9DLE1BQU0sQ0FBQztRQUNuQixHQUFHTCxPQUFPO1FBQ1ZNLFFBQVEsQ0FBQ1A7WUFDUCxNQUFNWCxRQUFRLElBQUlULFdBQVdtQixlQUFlQyxPQUFPQztZQUNuREEsUUFBUU8sS0FBSyxDQUFDUixPQUFPWCxPQUFPO1lBQzVCLE9BQU9BO1FBQ1Q7SUFDRjtBQUNGO0FBQ0EsU0FBU29CLGNBQWNDLE9BQU87SUFDNUIsT0FBT0wsT0FBT0MsTUFBTSxDQUFDO1FBQ25CLEdBQUdJLE9BQU87UUFDVkMsUUFBUSxDQUFDdEIsT0FBT0osU0FBUyxDQUFDLEdBQUt5QixRQUFRRSxJQUFJLENBQUN2QixPQUFPSixPQUFPLENBQUMsRUFBRTtJQUMvRDtBQUNGO0FBQ0EsU0FBUzRCLFlBQVlDLEtBQUs7SUFDeEIsT0FBT1QsT0FBT0MsTUFBTSxDQUFDO1FBQ25CLEdBQUdRLEtBQUs7UUFDUkgsUUFBUSxDQUFDdEIsT0FBT0osU0FBUyxDQUFDLEdBQUs2QixNQUFNRixJQUFJLENBQUN2QixPQUFPSixPQUFPLENBQUMsRUFBRTtRQUMzRHNCLFFBQVEsQ0FBQ1A7WUFDUCxNQUFNWCxRQUFRLElBQUlULFdBQVdtQixlQUFlQyxPQUFPYztZQUNuREEsTUFBTU4sS0FBSyxDQUFDUixPQUFPWCxPQUFPO1lBQzFCLE9BQU9BO1FBQ1Q7SUFDRjtBQUNGO0FBQ0EsU0FBUzBCLFlBQVlELEtBQUs7SUFDeEIsT0FBTyxlQUFlQSxTQUFTLE9BQU9BLE1BQU1aLFNBQVMsS0FBSztBQUM1RDtBQUNBLFNBQVNjLGtCQUFrQkYsS0FBSztJQUM5QixJQUFJLENBQUNDLFlBQVlELFFBQVE7UUFDdkIsTUFBTSxJQUFJcEQsdURBQVdBLENBQUNDLHVGQUEyQ0E7SUFDbkU7QUFDRjtBQUNBLFNBQVNzRCxlQUFlSCxLQUFLO0lBQzNCLE9BQU8sQ0FBQ0MsWUFBWUQ7QUFDdEI7QUFDQSxTQUFTSSxxQkFBcUJKLEtBQUs7SUFDakMsSUFBSSxDQUFDRyxlQUFlSCxRQUFRO1FBQzFCLE1BQU0sSUFBSXBELHVEQUFXQSxDQUFDRSwwRkFBOENBO0lBQ3RFO0FBQ0Y7QUFDQSxTQUFTdUQsYUFBYWxCLE9BQU8sRUFBRVMsT0FBTztJQUNwQyxJQUFJSyxZQUFZZCxhQUFhYyxZQUFZTCxVQUFVO1FBQ2pELE1BQU0sSUFBSWhELHVEQUFXQSxDQUFDRyw2R0FBaUVBO0lBQ3pGO0lBQ0EsSUFBSWtELFlBQVlkLFlBQVljLFlBQVlMLFlBQVlULFFBQVFDLFNBQVMsS0FBS1EsUUFBUVIsU0FBUyxFQUFFO1FBQzNGLE1BQU0sSUFBSXhDLHVEQUFXQSxDQUFDSSxxR0FBeURBLEVBQUU7WUFDL0VzRCxrQkFBa0JWLFFBQVFSLFNBQVM7WUFDbkNtQixrQkFBa0JwQixRQUFRQyxTQUFTO1FBQ3JDO0lBQ0Y7SUFDQSxJQUFJLENBQUNhLFlBQVlkLFlBQVksQ0FBQ2MsWUFBWUwsWUFBWVQsUUFBUXFCLE9BQU8sS0FBS1osUUFBUVksT0FBTyxFQUFFO1FBQ3pGLE1BQU0sSUFBSTVELHVEQUFXQSxDQUFDSyxtR0FBdURBLEVBQUU7WUFDN0V3RCxnQkFBZ0JiLFFBQVFZLE9BQU87WUFDL0JFLGdCQUFnQnZCLFFBQVFxQixPQUFPO1FBQ2pDO0lBQ0Y7SUFDQSxPQUFPO1FBQ0wsR0FBR1osT0FBTztRQUNWLEdBQUdULE9BQU87UUFDVlUsUUFBUUQsUUFBUUMsTUFBTTtRQUN0QkosUUFBUU4sUUFBUU0sTUFBTTtRQUN0QkssTUFBTUYsUUFBUUUsSUFBSTtRQUNsQkosT0FBT1AsUUFBUU8sS0FBSztJQUN0QjtBQUNGO0FBRUEsNEJBQTRCO0FBQzVCLFNBQVNpQixtQkFBbUJ4QixPQUFPLEVBQUV5QixRQUFRO0lBQzNDLE1BQU1sQixRQUFRLENBQUNSLE9BQU9YLE9BQU9KO1FBQzNCLE1BQU0wQyxlQUFlMUIsUUFBUU0sTUFBTSxDQUFDUDtRQUNwQyxJQUFJNEIsa0JBQWtCRCxjQUFjRCxhQUFhLEdBQUc7WUFDbEQsTUFBTSxJQUFJaEUsdURBQVdBLENBQUNXLHlHQUE2REEsRUFBRTtnQkFDbkZ3RCxjQUFjRjtnQkFDZEcsaUJBQWlCQyxTQUFTSjtnQkFDMUJLLGFBQWFELFNBQVNMO2dCQUN0QkE7WUFDRjtRQUNGO1FBQ0FyQyxNQUFNRixHQUFHLENBQUN3QyxjQUFjMUM7UUFDeEJBLFVBQVUwQyxhQUFhaEQsTUFBTTtRQUM3QlUsTUFBTUYsR0FBRyxDQUFDdUMsVUFBVXpDO1FBQ3BCQSxVQUFVeUMsU0FBUy9DLE1BQU07UUFDekIsT0FBT007SUFDVDtJQUNBLElBQUk4QixZQUFZZCxVQUFVO1FBQ3hCLE9BQU9HLGNBQWM7WUFBRSxHQUFHSCxPQUFPO1lBQUVDLFdBQVdELFFBQVFDLFNBQVMsR0FBR3dCLFNBQVMvQyxNQUFNO1lBQUU2QjtRQUFNO0lBQzNGO0lBQ0EsT0FBT0osY0FBYztRQUNuQixHQUFHSCxPQUFPO1FBQ1YsR0FBR0EsUUFBUXFCLE9BQU8sSUFBSSxPQUFPO1lBQUVBLFNBQVNyQixRQUFRcUIsT0FBTyxHQUFHSSxTQUFTL0MsTUFBTTtRQUFDLElBQUksQ0FBQyxDQUFDO1FBQ2hGd0Isa0JBQWtCLENBQUNILFFBQVVDLFFBQVFFLGdCQUFnQixDQUFDSCxTQUFTMEIsU0FBUy9DLE1BQU07UUFDOUU2QjtJQUNGO0FBQ0Y7QUFDQSxTQUFTeUIsbUJBQW1CdkIsT0FBTyxFQUFFZ0IsUUFBUTtJQUMzQyxNQUFNZCxPQUFPLENBQUN2QixPQUFPSjtRQUNuQixNQUFNaUQsaUJBQWlCakQsV0FBVyxJQUFJSSxRQUFRQSxNQUFNSSxLQUFLLENBQUNSO1FBQzFELE1BQU1rRCxnQkFBZ0JQLGtCQUFrQk0sZ0JBQWdCUjtRQUN4RCxJQUFJUyxrQkFBa0IsQ0FBQyxHQUFHO1lBQ3hCLE1BQU0sSUFBSXpFLHVEQUFXQSxDQUFDVSxtR0FBdURBLEVBQUU7Z0JBQzdFZ0UsY0FBY0Y7Z0JBQ2RHLGlCQUFpQk4sU0FBU0c7Z0JBQzFCRixhQUFhRCxTQUFTTDtnQkFDdEJBO1lBQ0Y7UUFDRjtRQUNBLE1BQU1ZLG1CQUFtQkosZUFBZXpDLEtBQUssQ0FBQyxHQUFHMEM7UUFDakQsT0FBTztZQUFDekIsUUFBUUMsTUFBTSxDQUFDMkI7WUFBbUJyRCxTQUFTcUQsaUJBQWlCM0QsTUFBTSxHQUFHK0MsU0FBUy9DLE1BQU07U0FBQztJQUMvRjtJQUNBLElBQUlvQyxZQUFZTCxVQUFVO1FBQ3hCLE9BQU9ELGNBQWM7WUFBRSxHQUFHQyxPQUFPO1lBQUVSLFdBQVdRLFFBQVFSLFNBQVMsR0FBR3dCLFNBQVMvQyxNQUFNO1lBQUVpQztRQUFLO0lBQzFGO0lBQ0EsT0FBT0gsY0FBYztRQUNuQixHQUFHQyxPQUFPO1FBQ1YsR0FBR0EsUUFBUVksT0FBTyxJQUFJLE9BQU87WUFBRUEsU0FBU1osUUFBUVksT0FBTyxHQUFHSSxTQUFTL0MsTUFBTTtRQUFDLElBQUksQ0FBQyxDQUFDO1FBQ2hGaUM7SUFDRjtBQUNGO0FBQ0EsU0FBUzJCLGlCQUFpQnpCLEtBQUssRUFBRVksUUFBUTtJQUN2QyxPQUFPUCxhQUFhTSxtQkFBbUJYLE9BQU9ZLFdBQVdPLG1CQUFtQm5CLE9BQU9ZO0FBQ3JGO0FBQ0EsU0FBU0Usa0JBQWtCdkMsS0FBSyxFQUFFcUMsUUFBUTtJQUN4QyxPQUFPckMsTUFBTW1ELFNBQVMsQ0FBQyxDQUFDQyxNQUFNQyxPQUFPaEU7UUFDbkMsSUFBSWdELFNBQVMvQyxNQUFNLEtBQUssR0FBRyxPQUFPOEQsU0FBU2YsUUFBUSxDQUFDLEVBQUU7UUFDdEQsT0FBT2hDLGNBQWNoQixLQUFLZ0QsVUFBVWdCO0lBQ3RDO0FBQ0Y7QUFDQSxTQUFTWCxTQUFTMUMsS0FBSztJQUNyQixPQUFPQSxNQUFNUCxNQUFNLENBQUMsQ0FBQzZELEtBQUtGLE9BQVNFLE1BQU1GLEtBQUtHLFFBQVEsQ0FBQyxJQUFJQyxRQUFRLENBQUMsR0FBRyxNQUFNO0FBQy9FO0FBQ0EsU0FBU0Msa0NBQWtDQyxnQkFBZ0IsRUFBRTFELEtBQUssRUFBRUosU0FBUyxDQUFDO0lBQzVFLElBQUlJLE1BQU1WLE1BQU0sR0FBR00sVUFBVSxHQUFHO1FBQzlCLE1BQU0sSUFBSXZCLHVEQUFXQSxDQUFDTSxnR0FBb0RBLEVBQUU7WUFDMUUrRTtRQUNGO0lBQ0Y7QUFDRjtBQUNBLFNBQVNDLHNDQUFzQ0QsZ0JBQWdCLEVBQUVFLFFBQVEsRUFBRTVELEtBQUssRUFBRUosU0FBUyxDQUFDO0lBQzFGLE1BQU1pRSxjQUFjN0QsTUFBTVYsTUFBTSxHQUFHTTtJQUNuQyxJQUFJaUUsY0FBY0QsVUFBVTtRQUMxQixNQUFNLElBQUl2Rix1REFBV0EsQ0FBQ08scUZBQXlDQSxFQUFFO1lBQy9EaUY7WUFDQUg7WUFDQUU7UUFDRjtJQUNGO0FBQ0Y7QUFDQSxTQUFTRSxxQ0FBcUNKLGdCQUFnQixFQUFFOUQsTUFBTSxFQUFFaUUsV0FBVztJQUNqRixJQUFJakUsU0FBUyxLQUFLQSxTQUFTaUUsYUFBYTtRQUN0QyxNQUFNLElBQUl4Rix1REFBV0EsQ0FBQ1EscUZBQXlDQSxFQUFFO1lBQy9EZ0Y7WUFDQUg7WUFDQTlEO1FBQ0Y7SUFDRjtBQUNGO0FBRUEsK0JBQStCO0FBQy9CLFNBQVNtRSxxQkFBcUJuRCxPQUFPLEVBQUVvRCxNQUFNO0lBQzNDLE1BQU03QyxRQUFRLENBQUNSLE9BQU9YLE9BQU9KO1FBQzNCLE1BQU0wQyxlQUFlMUIsUUFBUU0sTUFBTSxDQUFDUDtRQUNwQ2YsU0FBU29FLE9BQU83QyxLQUFLLENBQUNtQixhQUFhaEQsTUFBTSxFQUFFVSxPQUFPSjtRQUNsREksTUFBTUYsR0FBRyxDQUFDd0MsY0FBYzFDO1FBQ3hCLE9BQU9BLFNBQVMwQyxhQUFhaEQsTUFBTTtJQUNyQztJQUNBLElBQUlvQyxZQUFZc0MsV0FBV3RDLFlBQVlkLFVBQVU7UUFDL0MsT0FBT0csY0FBYztZQUFFLEdBQUdILE9BQU87WUFBRUMsV0FBV21ELE9BQU9uRCxTQUFTLEdBQUdELFFBQVFDLFNBQVM7WUFBRU07UUFBTTtJQUM1RjtJQUNBLE1BQU04QyxnQkFBZ0J2QyxZQUFZc0MsVUFBVUEsT0FBT25ELFNBQVMsR0FBR21ELE9BQU8vQixPQUFPLElBQUk7SUFDakYsTUFBTUUsaUJBQWlCVCxZQUFZZCxXQUFXQSxRQUFRQyxTQUFTLEdBQUdELFFBQVFxQixPQUFPLElBQUk7SUFDckYsTUFBTUEsVUFBVWdDLGtCQUFrQixRQUFROUIsbUJBQW1CLE9BQU84QixnQkFBZ0I5QixpQkFBaUI7SUFDckcsT0FBT3BCLGNBQWM7UUFDbkIsR0FBR0gsT0FBTztRQUNWLEdBQUdxQixZQUFZLE9BQU87WUFBRUE7UUFBUSxJQUFJLENBQUMsQ0FBQztRQUN0Q25CLGtCQUFrQixDQUFDSDtZQUNqQixNQUFNdUQsY0FBY3hELGVBQWVDLE9BQU9DO1lBQzFDLE9BQU9GLGVBQWV3RCxhQUFhRixVQUFVRTtRQUMvQztRQUNBL0M7SUFDRjtBQUNGO0FBQ0EsU0FBU2dELHFCQUFxQjlDLE9BQU8sRUFBRTJDLE1BQU07SUFDM0MsTUFBTXpDLE9BQU8sQ0FBQ3ZCLE9BQU9KO1FBQ25CLE1BQU0sQ0FBQ3dFLFlBQVlDLGNBQWMsR0FBR0wsT0FBT3pDLElBQUksQ0FBQ3ZCLE9BQU9KO1FBQ3ZELE1BQU0wRSxPQUFPQyxPQUFPSDtRQUNwQnhFLFNBQVN5RTtRQUNULElBQUl6RSxTQUFTLEtBQUtJLE1BQU1WLE1BQU0sR0FBR2dGLE1BQU07WUFDckN0RSxRQUFRQSxNQUFNSSxLQUFLLENBQUNSLFFBQVFBLFNBQVMwRTtRQUN2QztRQUNBWCxzQ0FBc0Msd0JBQXdCVyxNQUFNdEU7UUFDcEUsT0FBTztZQUFDcUIsUUFBUUMsTUFBTSxDQUFDdEI7WUFBUUosU0FBUzBFO1NBQUs7SUFDL0M7SUFDQSxJQUFJNUMsWUFBWXNDLFdBQVd0QyxZQUFZTCxVQUFVO1FBQy9DLE9BQU9ELGNBQWM7WUFBRSxHQUFHQyxPQUFPO1lBQUVSLFdBQVdtRCxPQUFPbkQsU0FBUyxHQUFHUSxRQUFRUixTQUFTO1lBQUVVO1FBQUs7SUFDM0Y7SUFDQSxNQUFNMEMsZ0JBQWdCdkMsWUFBWXNDLFVBQVVBLE9BQU9uRCxTQUFTLEdBQUdtRCxPQUFPL0IsT0FBTyxJQUFJO0lBQ2pGLE1BQU1DLGlCQUFpQlIsWUFBWUwsV0FBV0EsUUFBUVIsU0FBUyxHQUFHUSxRQUFRWSxPQUFPLElBQUk7SUFDckYsTUFBTUEsVUFBVWdDLGtCQUFrQixRQUFRL0IsbUJBQW1CLE9BQU8rQixnQkFBZ0IvQixpQkFBaUI7SUFDckcsT0FBT2QsY0FBYztRQUFFLEdBQUdDLE9BQU87UUFBRSxHQUFHWSxZQUFZLE9BQU87WUFBRUE7UUFBUSxJQUFJLENBQUMsQ0FBQztRQUFFVjtJQUFLO0FBQ2xGO0FBQ0EsU0FBU2lELG1CQUFtQi9DLEtBQUssRUFBRXVDLE1BQU07SUFDdkMsT0FBT2xDLGFBQWFpQyxxQkFBcUJ0QyxPQUFPdUMsU0FBU0cscUJBQXFCMUMsT0FBT3VDO0FBQ3ZGO0FBRUEsd0JBQXdCO0FBQ3hCLFNBQVNTLGVBQWU3RCxPQUFPLEVBQUU4RCxVQUFVO0lBQ3pDLE9BQU8zRCxjQUFjO1FBQ25CRixXQUFXNkQ7UUFDWHZELE9BQU8sQ0FBQ1IsT0FBT1gsT0FBT0o7WUFDcEIsTUFBTStFLG9CQUFvQi9ELFFBQVFNLE1BQU0sQ0FBQ1A7WUFDekMsTUFBTWlFLGlCQUFpQkQsa0JBQWtCckYsTUFBTSxHQUFHb0YsYUFBYUMsa0JBQWtCdkUsS0FBSyxDQUFDLEdBQUdzRSxjQUFjQztZQUN4RzNFLE1BQU1GLEdBQUcsQ0FBQzhFLGdCQUFnQmhGO1lBQzFCLE9BQU9BLFNBQVM4RTtRQUNsQjtJQUNGO0FBQ0Y7QUFDQSxTQUFTRyxlQUFleEQsT0FBTyxFQUFFcUQsVUFBVTtJQUN6QyxPQUFPdEQsY0FBYztRQUNuQlAsV0FBVzZEO1FBQ1huRCxNQUFNLENBQUN2QixPQUFPSjtZQUNaK0Qsc0NBQXNDLGdCQUFnQmUsWUFBWTFFLE9BQU9KO1lBQ3pFLElBQUlBLFNBQVMsS0FBS0ksTUFBTVYsTUFBTSxHQUFHb0YsWUFBWTtnQkFDM0MxRSxRQUFRQSxNQUFNSSxLQUFLLENBQUNSLFFBQVFBLFNBQVM4RTtZQUN2QztZQUNBLElBQUloRCxZQUFZTCxVQUFVO2dCQUN4QnJCLFFBQVFHLFNBQVNILE9BQU9xQixRQUFRUixTQUFTO1lBQzNDO1lBQ0EsTUFBTSxDQUFDRixNQUFNLEdBQUdVLFFBQVFFLElBQUksQ0FBQ3ZCLE9BQU87WUFDcEMsT0FBTztnQkFBQ1c7Z0JBQU9mLFNBQVM4RTthQUFXO1FBQ3JDO0lBQ0Y7QUFDRjtBQUNBLFNBQVNJLGFBQWFyRCxLQUFLLEVBQUVpRCxVQUFVO0lBQ3JDLE9BQU81QyxhQUFhMkMsZUFBZWhELE9BQU9pRCxhQUFhRyxlQUFlcEQsT0FBT2lEO0FBQy9FO0FBRUEsc0JBQXNCO0FBQ3RCLFNBQVNLLGNBQWNuRSxPQUFPLEVBQUVvRSxNQUFNO0lBQ3BDLE9BQU9qRSxjQUFjO1FBQ25CLEdBQUdILE9BQU87UUFDVk8sT0FBTyxDQUFDUixPQUFPWCxPQUFPaUY7WUFDcEIsTUFBTUMsWUFBWSxDQUFDdEYsU0FBV3VGLE9BQU92RixRQUFRSSxNQUFNVixNQUFNO1lBQ3pELE1BQU04RixlQUFlSixPQUFPQyxTQUFTLEdBQUdELE9BQU9DLFNBQVMsQ0FBQztnQkFBRWpGO2dCQUFPaUY7Z0JBQVdDO1lBQVUsS0FBS0Q7WUFDNUZuQixxQ0FBcUMsaUJBQWlCc0IsY0FBY3BGLE1BQU1WLE1BQU07WUFDaEYsTUFBTStGLGFBQWF6RSxRQUFRTyxLQUFLLENBQUNSLE9BQU9YLE9BQU9vRjtZQUMvQyxNQUFNRSxnQkFBZ0JOLE9BQU9LLFVBQVUsR0FBR0wsT0FBT0ssVUFBVSxDQUFDO2dCQUFFckY7Z0JBQU9vRjtnQkFBY0M7Z0JBQVlKO2dCQUFXQztZQUFVLEtBQUtHO1lBQ3pIdkIscUNBQXFDLGlCQUFpQndCLGVBQWV0RixNQUFNVixNQUFNO1lBQ2pGLE9BQU9nRztRQUNUO0lBQ0Y7QUFDRjtBQUNBLFNBQVNDLGNBQWNsRSxPQUFPLEVBQUUyRCxNQUFNO0lBQ3BDLE9BQU81RCxjQUFjO1FBQ25CLEdBQUdDLE9BQU87UUFDVkUsTUFBTSxDQUFDdkIsT0FBT2lGO1lBQ1osTUFBTUMsWUFBWSxDQUFDdEYsU0FBV3VGLE9BQU92RixRQUFRSSxNQUFNVixNQUFNO1lBQ3pELE1BQU04RixlQUFlSixPQUFPQyxTQUFTLEdBQUdELE9BQU9DLFNBQVMsQ0FBQztnQkFBRWpGO2dCQUFPaUY7Z0JBQVdDO1lBQVUsS0FBS0Q7WUFDNUZuQixxQ0FBcUMsaUJBQWlCc0IsY0FBY3BGLE1BQU1WLE1BQU07WUFDaEYsTUFBTSxDQUFDcUIsT0FBTzBFLFdBQVcsR0FBR2hFLFFBQVFFLElBQUksQ0FBQ3ZCLE9BQU9vRjtZQUNoRCxNQUFNRSxnQkFBZ0JOLE9BQU9LLFVBQVUsR0FBR0wsT0FBT0ssVUFBVSxDQUFDO2dCQUFFckY7Z0JBQU9vRjtnQkFBY0M7Z0JBQVlKO2dCQUFXQztZQUFVLEtBQUtHO1lBQ3pIdkIscUNBQXFDLGlCQUFpQndCLGVBQWV0RixNQUFNVixNQUFNO1lBQ2pGLE9BQU87Z0JBQUNxQjtnQkFBTzJFO2FBQWM7UUFDL0I7SUFDRjtBQUNGO0FBQ0EsU0FBU0UsWUFBWS9ELEtBQUssRUFBRXVELE1BQU07SUFDaEMsT0FBT2xELGFBQWFpRCxjQUFjdEQsT0FBT3VELFNBQVNPLGNBQWM5RCxPQUFPdUQ7QUFDekU7QUFDQSxTQUFTRyxPQUFPTSxRQUFRLEVBQUVDLE9BQU87SUFDL0IsSUFBSUEsWUFBWSxHQUFHLE9BQU87SUFDMUIsT0FBTyxDQUFDRCxXQUFXQyxVQUFVQSxPQUFNLElBQUtBO0FBQzFDO0FBQ0EsU0FBU0MsY0FBYy9FLE9BQU8sRUFBRWdGLE1BQU07SUFDcEMsSUFBSWxFLFlBQVlkLFVBQVU7UUFDeEIsTUFBTUMsWUFBWStFLE9BQU9oRixRQUFRQyxTQUFTO1FBQzFDLElBQUlBLFlBQVksR0FBRztZQUNqQixNQUFNLElBQUl4Qyx1REFBV0EsQ0FBQ1MsK0ZBQW1EQSxFQUFFO2dCQUN6RStFLGFBQWFoRDtnQkFDYjZDLGtCQUFrQjtZQUNwQjtRQUNGO1FBQ0EsT0FBTzNDLGNBQWM7WUFBRSxHQUFHSCxPQUFPO1lBQUVDO1FBQVU7SUFDL0M7SUFDQSxPQUFPRSxjQUFjO1FBQ25CLEdBQUdILE9BQU87UUFDVkUsa0JBQWtCLENBQUNIO1lBQ2pCLE1BQU1rRixVQUFVRCxPQUFPaEYsUUFBUUUsZ0JBQWdCLENBQUNIO1lBQ2hELElBQUlrRixVQUFVLEdBQUc7Z0JBQ2YsTUFBTSxJQUFJeEgsdURBQVdBLENBQUNTLCtGQUFtREEsRUFBRTtvQkFDekUrRSxhQUFhZ0M7b0JBQ2JuQyxrQkFBa0I7Z0JBQ3BCO1lBQ0Y7WUFDQSxPQUFPbUM7UUFDVDtJQUNGO0FBQ0Y7QUFDQSxTQUFTQyxjQUFjekUsT0FBTyxFQUFFdUUsTUFBTTtJQUNwQyxJQUFJbEUsWUFBWUwsVUFBVTtRQUN4QixNQUFNUixZQUFZK0UsT0FBT3ZFLFFBQVFSLFNBQVM7UUFDMUMsSUFBSUEsWUFBWSxHQUFHO1lBQ2pCLE1BQU0sSUFBSXhDLHVEQUFXQSxDQUFDUywrRkFBbURBLEVBQUU7Z0JBQ3pFK0UsYUFBYWhEO2dCQUNiNkMsa0JBQWtCO1lBQ3BCO1FBQ0Y7UUFDQSxPQUFPdEMsY0FBYztZQUFFLEdBQUdDLE9BQU87WUFBRVI7UUFBVTtJQUMvQztJQUNBLE9BQU9RO0FBQ1Q7QUFDQSxTQUFTMEUsWUFBWXRFLEtBQUssRUFBRW1FLE1BQU07SUFDaEMsT0FBTzlELGFBQWE2RCxjQUFjbEUsT0FBT21FLFNBQVNFLGNBQWNyRSxPQUFPbUU7QUFDekU7QUFFQSxtQkFBbUI7QUFDbkIsU0FBU0ksZUFBZXBGLE9BQU8sRUFBRWhCLE1BQU07SUFDckMsT0FBT21GLGNBQ0xZLGNBQWMvRSxTQUFTLENBQUMwRCxPQUFTQSxPQUFPMUUsU0FDeEM7UUFBRXFGLFdBQVcsQ0FBQyxFQUFFQSxTQUFTLEVBQUUsR0FBS0EsWUFBWXJGO0lBQU87QUFFdkQ7QUFDQSxTQUFTcUcsZ0JBQWdCckYsT0FBTyxFQUFFaEIsTUFBTTtJQUN0QyxPQUFPbUYsY0FDTFksY0FBYy9FLFNBQVMsQ0FBQzBELE9BQVNBLE9BQU8xRSxTQUN4QztRQUFFeUYsWUFBWSxDQUFDLEVBQUVBLFVBQVUsRUFBRSxHQUFLQSxhQUFhekY7SUFBTztBQUUxRDtBQUNBLFNBQVNzRyxlQUFlN0UsT0FBTyxFQUFFekIsTUFBTTtJQUNyQyxPQUFPMkYsY0FDTE8sY0FBY3pFLFNBQVMsQ0FBQ2lELE9BQVNBLE9BQU8xRSxTQUN4QztRQUFFcUYsV0FBVyxDQUFDLEVBQUVBLFNBQVMsRUFBRSxHQUFLQSxZQUFZckY7SUFBTztBQUV2RDtBQUNBLFNBQVN1RyxnQkFBZ0I5RSxPQUFPLEVBQUV6QixNQUFNO0lBQ3RDLE9BQU8yRixjQUNMTyxjQUFjekUsU0FBUyxDQUFDaUQsT0FBU0EsT0FBTzFFLFNBQ3hDO1FBQUV5RixZQUFZLENBQUMsRUFBRUEsVUFBVSxFQUFFLEdBQUtBLGFBQWF6RjtJQUFPO0FBRTFEO0FBQ0EsU0FBU3dHLGFBQWEzRSxLQUFLLEVBQUU3QixNQUFNO0lBQ2pDLE9BQU9rQyxhQUFha0UsZUFBZXZFLE9BQU83QixTQUFTc0csZUFBZXpFLE9BQU83QjtBQUMzRTtBQUNBLFNBQVN5RyxjQUFjNUUsS0FBSyxFQUFFN0IsTUFBTTtJQUNsQyxPQUFPa0MsYUFBYW1FLGdCQUFnQnhFLE9BQU83QixTQUFTdUcsZ0JBQWdCMUUsT0FBTzdCO0FBQzdFO0FBRUEsdUJBQXVCO0FBQ3ZCLFNBQVMwRyw0QkFBNEJDLE1BQU0sRUFBRUMsa0JBQWtCLEVBQUVDLFlBQVksRUFBRUMsWUFBWSxFQUFFQyxlQUFlLENBQUM7SUFDM0csTUFBT0YsZUFBZSxFQUFFQyxhQUFjO1FBQ3BDLE1BQU1FLFlBQVlMLE1BQU0sQ0FBQ0UsYUFBYTtRQUN0Q0Qsa0JBQWtCLENBQUNDLGVBQWVFLGFBQWEsR0FBR0osTUFBTSxDQUFDRyxhQUFhO1FBQ3RFRixrQkFBa0IsQ0FBQ0UsZUFBZUMsYUFBYSxHQUFHQztRQUNsREg7SUFDRjtJQUNBLElBQUlBLGlCQUFpQkMsY0FBYztRQUNqQ0Ysa0JBQWtCLENBQUNDLGVBQWVFLGFBQWEsR0FBR0osTUFBTSxDQUFDRSxhQUFhO0lBQ3hFO0FBQ0Y7QUFDQSxTQUFTSSxlQUFlakcsT0FBTztJQUM3QmUsa0JBQWtCZjtJQUNsQixPQUFPRyxjQUFjO1FBQ25CLEdBQUdILE9BQU87UUFDVk8sT0FBTyxDQUFDUixPQUFPWCxPQUFPSjtZQUNwQixNQUFNa0gsWUFBWWxHLFFBQVFPLEtBQUssQ0FBQ1IsT0FBT1gsT0FBT0o7WUFDOUMwRyw0QkFDRXRHLE9BQ0FBLE9BQ0FKLFFBQ0FBLFNBQVNnQixRQUFRQyxTQUFTO1lBRTVCLE9BQU9pRztRQUNUO0lBQ0Y7QUFDRjtBQUNBLFNBQVNDLGVBQWUxRixPQUFPO0lBQzdCTSxrQkFBa0JOO0lBQ2xCLE9BQU9ELGNBQWM7UUFDbkIsR0FBR0MsT0FBTztRQUNWRSxNQUFNLENBQUN2QixPQUFPSjtZQUNaLE1BQU1vSCxnQkFBZ0JoSCxNQUFNSSxLQUFLO1lBQ2pDa0csNEJBQ0V0RyxPQUNBZ0gsZUFDQXBILFFBQ0FBLFNBQVN5QixRQUFRUixTQUFTO1lBRTVCLE9BQU9RLFFBQVFFLElBQUksQ0FBQ3lGLGVBQWVwSDtRQUNyQztJQUNGO0FBQ0Y7QUFDQSxTQUFTcUgsYUFBYXhGLEtBQUs7SUFDekIsT0FBT0ssYUFBYStFLGVBQWVwRixRQUFRc0YsZUFBZXRGO0FBQzVEO0FBRUEseUJBQXlCO0FBQ3pCLFNBQVN5RixpQkFBaUJ0RyxPQUFPLEVBQUV1RyxLQUFLO0lBQ3RDLE9BQU9wRyxjQUFjO1FBQ25CLEdBQUdhLGVBQWVoQixXQUFXO1lBQUUsR0FBR0EsT0FBTztZQUFFRSxrQkFBa0IsQ0FBQ0gsUUFBVUMsUUFBUUUsZ0JBQWdCLENBQUNxRyxNQUFNeEc7UUFBUSxJQUFJQyxPQUFPO1FBQzFITyxPQUFPLENBQUNSLE9BQU9YLE9BQU9KLFNBQVdnQixRQUFRTyxLQUFLLENBQUNnRyxNQUFNeEcsUUFBUVgsT0FBT0o7SUFDdEU7QUFDRjtBQUNBLFNBQVN3SCxpQkFBaUIvRixPQUFPLEVBQUVnRyxHQUFHO0lBQ3BDLE9BQU9qRyxjQUFjO1FBQ25CLEdBQUdDLE9BQU87UUFDVkUsTUFBTSxDQUFDdkIsT0FBT0o7WUFDWixNQUFNLENBQUNlLE9BQU9tRyxVQUFVLEdBQUd6RixRQUFRRSxJQUFJLENBQUN2QixPQUFPSjtZQUMvQyxPQUFPO2dCQUFDeUgsSUFBSTFHLE9BQU9YLE9BQU9KO2dCQUFTa0g7YUFBVTtRQUMvQztJQUNGO0FBQ0Y7QUFDQSxTQUFTUSxlQUFlN0YsS0FBSyxFQUFFMEYsS0FBSyxFQUFFRSxHQUFHO0lBQ3ZDLE9BQU83RixZQUFZO1FBQ2pCLEdBQUcwRixpQkFBaUJ6RixPQUFPMEYsTUFBTTtRQUNqQzVGLE1BQU04RixNQUFNRCxpQkFBaUIzRixPQUFPNEYsS0FBSzlGLElBQUksR0FBR0UsTUFBTUYsSUFBSTtJQUM1RDtBQUNGO0FBRXV2QixDQUN2dkIsdUNBQXVDO0NBQ3ZDLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsYXctd29ya3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Ac29sYW5hL2NvZGVjcy1jb3JlL2Rpc3QvaW5kZXgubm9kZS5tanM/ZWY4OCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTb2xhbmFFcnJvciwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX0ZJWEVEX0xFTkdUSCwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX1ZBUklBQkxFX0xFTkdUSCwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9TSVpFX0NPTVBBVElCSUxJVFlfTUlTTUFUQ0gsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfRklYRURfU0laRV9NSVNNQVRDSCwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9NQVhfU0laRV9NSVNNQVRDSCwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0NBTk5PVF9ERUNPREVfRU1QVFlfQllURV9BUlJBWSwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfQllURV9MRU5HVEgsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19PRkZTRVRfT1VUX09GX1JBTkdFLCBTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfUE9TSVRJVkVfQllURV9MRU5HVEgsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19TRU5USU5FTF9NSVNTSU5HX0lOX0RFQ09ERURfQllURVMsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVEX0JZVEVTX01VU1RfTk9UX0lOQ0xVREVfU0VOVElORUwgfSBmcm9tICdAc29sYW5hL2Vycm9ycyc7XG5cbi8vIHNyYy9hZGQtY29kZWMtc2VudGluZWwudHNcblxuLy8gc3JjL2J5dGVzLnRzXG52YXIgbWVyZ2VCeXRlcyA9IChieXRlQXJyYXlzKSA9PiB7XG4gIGNvbnN0IG5vbkVtcHR5Qnl0ZUFycmF5cyA9IGJ5dGVBcnJheXMuZmlsdGVyKChhcnIpID0+IGFyci5sZW5ndGgpO1xuICBpZiAobm9uRW1wdHlCeXRlQXJyYXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBieXRlQXJyYXlzLmxlbmd0aCA/IGJ5dGVBcnJheXNbMF0gOiBuZXcgVWludDhBcnJheSgpO1xuICB9XG4gIGlmIChub25FbXB0eUJ5dGVBcnJheXMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIG5vbkVtcHR5Qnl0ZUFycmF5c1swXTtcbiAgfVxuICBjb25zdCB0b3RhbExlbmd0aCA9IG5vbkVtcHR5Qnl0ZUFycmF5cy5yZWR1Y2UoKHRvdGFsLCBhcnIpID0+IHRvdGFsICsgYXJyLmxlbmd0aCwgMCk7XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KHRvdGFsTGVuZ3RoKTtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIG5vbkVtcHR5Qnl0ZUFycmF5cy5mb3JFYWNoKChhcnIpID0+IHtcbiAgICByZXN1bHQuc2V0KGFyciwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gYXJyLmxlbmd0aDtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xudmFyIHBhZEJ5dGVzID0gKGJ5dGVzLCBsZW5ndGgpID0+IHtcbiAgaWYgKGJ5dGVzLmxlbmd0aCA+PSBsZW5ndGgpIHJldHVybiBieXRlcztcbiAgY29uc3QgcGFkZGVkQnl0ZXMgPSBuZXcgVWludDhBcnJheShsZW5ndGgpLmZpbGwoMCk7XG4gIHBhZGRlZEJ5dGVzLnNldChieXRlcyk7XG4gIHJldHVybiBwYWRkZWRCeXRlcztcbn07XG52YXIgZml4Qnl0ZXMgPSAoYnl0ZXMsIGxlbmd0aCkgPT4gcGFkQnl0ZXMoYnl0ZXMubGVuZ3RoIDw9IGxlbmd0aCA/IGJ5dGVzIDogYnl0ZXMuc2xpY2UoMCwgbGVuZ3RoKSwgbGVuZ3RoKTtcbmZ1bmN0aW9uIGNvbnRhaW5zQnl0ZXMoZGF0YSwgYnl0ZXMsIG9mZnNldCkge1xuICBjb25zdCBzbGljZSA9IG9mZnNldCA9PT0gMCAmJiBkYXRhLmxlbmd0aCA9PT0gYnl0ZXMubGVuZ3RoID8gZGF0YSA6IGRhdGEuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBieXRlcy5sZW5ndGgpO1xuICBpZiAoc2xpY2UubGVuZ3RoICE9PSBieXRlcy5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIGJ5dGVzLmV2ZXJ5KChiLCBpKSA9PiBiID09PSBzbGljZVtpXSk7XG59XG5mdW5jdGlvbiBnZXRFbmNvZGVkU2l6ZSh2YWx1ZSwgZW5jb2Rlcikge1xuICByZXR1cm4gXCJmaXhlZFNpemVcIiBpbiBlbmNvZGVyID8gZW5jb2Rlci5maXhlZFNpemUgOiBlbmNvZGVyLmdldFNpemVGcm9tVmFsdWUodmFsdWUpO1xufVxuZnVuY3Rpb24gY3JlYXRlRW5jb2RlcihlbmNvZGVyKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAuLi5lbmNvZGVyLFxuICAgIGVuY29kZTogKHZhbHVlKSA9PiB7XG4gICAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGdldEVuY29kZWRTaXplKHZhbHVlLCBlbmNvZGVyKSk7XG4gICAgICBlbmNvZGVyLndyaXRlKHZhbHVlLCBieXRlcywgMCk7XG4gICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZURlY29kZXIoZGVjb2Rlcikge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgLi4uZGVjb2RlcixcbiAgICBkZWNvZGU6IChieXRlcywgb2Zmc2V0ID0gMCkgPT4gZGVjb2Rlci5yZWFkKGJ5dGVzLCBvZmZzZXQpWzBdXG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlQ29kZWMoY29kZWMpIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgIC4uLmNvZGVjLFxuICAgIGRlY29kZTogKGJ5dGVzLCBvZmZzZXQgPSAwKSA9PiBjb2RlYy5yZWFkKGJ5dGVzLCBvZmZzZXQpWzBdLFxuICAgIGVuY29kZTogKHZhbHVlKSA9PiB7XG4gICAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGdldEVuY29kZWRTaXplKHZhbHVlLCBjb2RlYykpO1xuICAgICAgY29kZWMud3JpdGUodmFsdWUsIGJ5dGVzLCAwKTtcbiAgICAgIHJldHVybiBieXRlcztcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gaXNGaXhlZFNpemUoY29kZWMpIHtcbiAgcmV0dXJuIFwiZml4ZWRTaXplXCIgaW4gY29kZWMgJiYgdHlwZW9mIGNvZGVjLmZpeGVkU2l6ZSA9PT0gXCJudW1iZXJcIjtcbn1cbmZ1bmN0aW9uIGFzc2VydElzRml4ZWRTaXplKGNvZGVjKSB7XG4gIGlmICghaXNGaXhlZFNpemUoY29kZWMpKSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9GSVhFRF9MRU5HVEgpO1xuICB9XG59XG5mdW5jdGlvbiBpc1ZhcmlhYmxlU2l6ZShjb2RlYykge1xuICByZXR1cm4gIWlzRml4ZWRTaXplKGNvZGVjKTtcbn1cbmZ1bmN0aW9uIGFzc2VydElzVmFyaWFibGVTaXplKGNvZGVjKSB7XG4gIGlmICghaXNWYXJpYWJsZVNpemUoY29kZWMpKSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9WQVJJQUJMRV9MRU5HVEgpO1xuICB9XG59XG5mdW5jdGlvbiBjb21iaW5lQ29kZWMoZW5jb2RlciwgZGVjb2Rlcikge1xuICBpZiAoaXNGaXhlZFNpemUoZW5jb2RlcikgIT09IGlzRml4ZWRTaXplKGRlY29kZXIpKSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfU0laRV9DT01QQVRJQklMSVRZX01JU01BVENIKTtcbiAgfVxuICBpZiAoaXNGaXhlZFNpemUoZW5jb2RlcikgJiYgaXNGaXhlZFNpemUoZGVjb2RlcikgJiYgZW5jb2Rlci5maXhlZFNpemUgIT09IGRlY29kZXIuZml4ZWRTaXplKSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfRklYRURfU0laRV9NSVNNQVRDSCwge1xuICAgICAgZGVjb2RlckZpeGVkU2l6ZTogZGVjb2Rlci5maXhlZFNpemUsXG4gICAgICBlbmNvZGVyRml4ZWRTaXplOiBlbmNvZGVyLmZpeGVkU2l6ZVxuICAgIH0pO1xuICB9XG4gIGlmICghaXNGaXhlZFNpemUoZW5jb2RlcikgJiYgIWlzRml4ZWRTaXplKGRlY29kZXIpICYmIGVuY29kZXIubWF4U2l6ZSAhPT0gZGVjb2Rlci5tYXhTaXplKSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfTUFYX1NJWkVfTUlTTUFUQ0gsIHtcbiAgICAgIGRlY29kZXJNYXhTaXplOiBkZWNvZGVyLm1heFNpemUsXG4gICAgICBlbmNvZGVyTWF4U2l6ZTogZW5jb2Rlci5tYXhTaXplXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5kZWNvZGVyLFxuICAgIC4uLmVuY29kZXIsXG4gICAgZGVjb2RlOiBkZWNvZGVyLmRlY29kZSxcbiAgICBlbmNvZGU6IGVuY29kZXIuZW5jb2RlLFxuICAgIHJlYWQ6IGRlY29kZXIucmVhZCxcbiAgICB3cml0ZTogZW5jb2Rlci53cml0ZVxuICB9O1xufVxuXG4vLyBzcmMvYWRkLWNvZGVjLXNlbnRpbmVsLnRzXG5mdW5jdGlvbiBhZGRFbmNvZGVyU2VudGluZWwoZW5jb2Rlciwgc2VudGluZWwpIHtcbiAgY29uc3Qgd3JpdGUgPSAodmFsdWUsIGJ5dGVzLCBvZmZzZXQpID0+IHtcbiAgICBjb25zdCBlbmNvZGVyQnl0ZXMgPSBlbmNvZGVyLmVuY29kZSh2YWx1ZSk7XG4gICAgaWYgKGZpbmRTZW50aW5lbEluZGV4KGVuY29kZXJCeXRlcywgc2VudGluZWwpID49IDApIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFRF9CWVRFU19NVVNUX05PVF9JTkNMVURFX1NFTlRJTkVMLCB7XG4gICAgICAgIGVuY29kZWRCeXRlczogZW5jb2RlckJ5dGVzLFxuICAgICAgICBoZXhFbmNvZGVkQnl0ZXM6IGhleEJ5dGVzKGVuY29kZXJCeXRlcyksXG4gICAgICAgIGhleFNlbnRpbmVsOiBoZXhCeXRlcyhzZW50aW5lbCksXG4gICAgICAgIHNlbnRpbmVsXG4gICAgICB9KTtcbiAgICB9XG4gICAgYnl0ZXMuc2V0KGVuY29kZXJCeXRlcywgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gZW5jb2RlckJ5dGVzLmxlbmd0aDtcbiAgICBieXRlcy5zZXQoc2VudGluZWwsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IHNlbnRpbmVsLmxlbmd0aDtcbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9O1xuICBpZiAoaXNGaXhlZFNpemUoZW5jb2RlcikpIHtcbiAgICByZXR1cm4gY3JlYXRlRW5jb2Rlcih7IC4uLmVuY29kZXIsIGZpeGVkU2l6ZTogZW5jb2Rlci5maXhlZFNpemUgKyBzZW50aW5lbC5sZW5ndGgsIHdyaXRlIH0pO1xuICB9XG4gIHJldHVybiBjcmVhdGVFbmNvZGVyKHtcbiAgICAuLi5lbmNvZGVyLFxuICAgIC4uLmVuY29kZXIubWF4U2l6ZSAhPSBudWxsID8geyBtYXhTaXplOiBlbmNvZGVyLm1heFNpemUgKyBzZW50aW5lbC5sZW5ndGggfSA6IHt9LFxuICAgIGdldFNpemVGcm9tVmFsdWU6ICh2YWx1ZSkgPT4gZW5jb2Rlci5nZXRTaXplRnJvbVZhbHVlKHZhbHVlKSArIHNlbnRpbmVsLmxlbmd0aCxcbiAgICB3cml0ZVxuICB9KTtcbn1cbmZ1bmN0aW9uIGFkZERlY29kZXJTZW50aW5lbChkZWNvZGVyLCBzZW50aW5lbCkge1xuICBjb25zdCByZWFkID0gKGJ5dGVzLCBvZmZzZXQpID0+IHtcbiAgICBjb25zdCBjYW5kaWRhdGVCeXRlcyA9IG9mZnNldCA9PT0gMCA/IGJ5dGVzIDogYnl0ZXMuc2xpY2Uob2Zmc2V0KTtcbiAgICBjb25zdCBzZW50aW5lbEluZGV4ID0gZmluZFNlbnRpbmVsSW5kZXgoY2FuZGlkYXRlQnl0ZXMsIHNlbnRpbmVsKTtcbiAgICBpZiAoc2VudGluZWxJbmRleCA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fU0VOVElORUxfTUlTU0lOR19JTl9ERUNPREVEX0JZVEVTLCB7XG4gICAgICAgIGRlY29kZWRCeXRlczogY2FuZGlkYXRlQnl0ZXMsXG4gICAgICAgIGhleERlY29kZWRCeXRlczogaGV4Qnl0ZXMoY2FuZGlkYXRlQnl0ZXMpLFxuICAgICAgICBoZXhTZW50aW5lbDogaGV4Qnl0ZXMoc2VudGluZWwpLFxuICAgICAgICBzZW50aW5lbFxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHByZVNlbnRpbmVsQnl0ZXMgPSBjYW5kaWRhdGVCeXRlcy5zbGljZSgwLCBzZW50aW5lbEluZGV4KTtcbiAgICByZXR1cm4gW2RlY29kZXIuZGVjb2RlKHByZVNlbnRpbmVsQnl0ZXMpLCBvZmZzZXQgKyBwcmVTZW50aW5lbEJ5dGVzLmxlbmd0aCArIHNlbnRpbmVsLmxlbmd0aF07XG4gIH07XG4gIGlmIChpc0ZpeGVkU2l6ZShkZWNvZGVyKSkge1xuICAgIHJldHVybiBjcmVhdGVEZWNvZGVyKHsgLi4uZGVjb2RlciwgZml4ZWRTaXplOiBkZWNvZGVyLmZpeGVkU2l6ZSArIHNlbnRpbmVsLmxlbmd0aCwgcmVhZCB9KTtcbiAgfVxuICByZXR1cm4gY3JlYXRlRGVjb2Rlcih7XG4gICAgLi4uZGVjb2RlcixcbiAgICAuLi5kZWNvZGVyLm1heFNpemUgIT0gbnVsbCA/IHsgbWF4U2l6ZTogZGVjb2Rlci5tYXhTaXplICsgc2VudGluZWwubGVuZ3RoIH0gOiB7fSxcbiAgICByZWFkXG4gIH0pO1xufVxuZnVuY3Rpb24gYWRkQ29kZWNTZW50aW5lbChjb2RlYywgc2VudGluZWwpIHtcbiAgcmV0dXJuIGNvbWJpbmVDb2RlYyhhZGRFbmNvZGVyU2VudGluZWwoY29kZWMsIHNlbnRpbmVsKSwgYWRkRGVjb2RlclNlbnRpbmVsKGNvZGVjLCBzZW50aW5lbCkpO1xufVxuZnVuY3Rpb24gZmluZFNlbnRpbmVsSW5kZXgoYnl0ZXMsIHNlbnRpbmVsKSB7XG4gIHJldHVybiBieXRlcy5maW5kSW5kZXgoKGJ5dGUsIGluZGV4LCBhcnIpID0+IHtcbiAgICBpZiAoc2VudGluZWwubGVuZ3RoID09PSAxKSByZXR1cm4gYnl0ZSA9PT0gc2VudGluZWxbMF07XG4gICAgcmV0dXJuIGNvbnRhaW5zQnl0ZXMoYXJyLCBzZW50aW5lbCwgaW5kZXgpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGhleEJ5dGVzKGJ5dGVzKSB7XG4gIHJldHVybiBieXRlcy5yZWR1Y2UoKHN0ciwgYnl0ZSkgPT4gc3RyICsgYnl0ZS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpLCBcIlwiKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEJ5dGVBcnJheUlzTm90RW1wdHlGb3JDb2RlYyhjb2RlY0Rlc2NyaXB0aW9uLCBieXRlcywgb2Zmc2V0ID0gMCkge1xuICBpZiAoYnl0ZXMubGVuZ3RoIC0gb2Zmc2V0IDw9IDApIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX0NBTk5PVF9ERUNPREVfRU1QVFlfQllURV9BUlJBWSwge1xuICAgICAgY29kZWNEZXNjcmlwdGlvblxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBhc3NlcnRCeXRlQXJyYXlIYXNFbm91Z2hCeXRlc0ZvckNvZGVjKGNvZGVjRGVzY3JpcHRpb24sIGV4cGVjdGVkLCBieXRlcywgb2Zmc2V0ID0gMCkge1xuICBjb25zdCBieXRlc0xlbmd0aCA9IGJ5dGVzLmxlbmd0aCAtIG9mZnNldDtcbiAgaWYgKGJ5dGVzTGVuZ3RoIDwgZXhwZWN0ZWQpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfQllURV9MRU5HVEgsIHtcbiAgICAgIGJ5dGVzTGVuZ3RoLFxuICAgICAgY29kZWNEZXNjcmlwdGlvbixcbiAgICAgIGV4cGVjdGVkXG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGFzc2VydEJ5dGVBcnJheU9mZnNldElzTm90T3V0T2ZSYW5nZShjb2RlY0Rlc2NyaXB0aW9uLCBvZmZzZXQsIGJ5dGVzTGVuZ3RoKSB7XG4gIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCA+IGJ5dGVzTGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQ09ERUNTX19PRkZTRVRfT1VUX09GX1JBTkdFLCB7XG4gICAgICBieXRlc0xlbmd0aCxcbiAgICAgIGNvZGVjRGVzY3JpcHRpb24sXG4gICAgICBvZmZzZXRcbiAgICB9KTtcbiAgfVxufVxuXG4vLyBzcmMvYWRkLWNvZGVjLXNpemUtcHJlZml4LnRzXG5mdW5jdGlvbiBhZGRFbmNvZGVyU2l6ZVByZWZpeChlbmNvZGVyLCBwcmVmaXgpIHtcbiAgY29uc3Qgd3JpdGUgPSAodmFsdWUsIGJ5dGVzLCBvZmZzZXQpID0+IHtcbiAgICBjb25zdCBlbmNvZGVyQnl0ZXMgPSBlbmNvZGVyLmVuY29kZSh2YWx1ZSk7XG4gICAgb2Zmc2V0ID0gcHJlZml4LndyaXRlKGVuY29kZXJCeXRlcy5sZW5ndGgsIGJ5dGVzLCBvZmZzZXQpO1xuICAgIGJ5dGVzLnNldChlbmNvZGVyQnl0ZXMsIG9mZnNldCk7XG4gICAgcmV0dXJuIG9mZnNldCArIGVuY29kZXJCeXRlcy5sZW5ndGg7XG4gIH07XG4gIGlmIChpc0ZpeGVkU2l6ZShwcmVmaXgpICYmIGlzRml4ZWRTaXplKGVuY29kZXIpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVuY29kZXIoeyAuLi5lbmNvZGVyLCBmaXhlZFNpemU6IHByZWZpeC5maXhlZFNpemUgKyBlbmNvZGVyLmZpeGVkU2l6ZSwgd3JpdGUgfSk7XG4gIH1cbiAgY29uc3QgcHJlZml4TWF4U2l6ZSA9IGlzRml4ZWRTaXplKHByZWZpeCkgPyBwcmVmaXguZml4ZWRTaXplIDogcHJlZml4Lm1heFNpemUgPz8gbnVsbDtcbiAgY29uc3QgZW5jb2Rlck1heFNpemUgPSBpc0ZpeGVkU2l6ZShlbmNvZGVyKSA/IGVuY29kZXIuZml4ZWRTaXplIDogZW5jb2Rlci5tYXhTaXplID8/IG51bGw7XG4gIGNvbnN0IG1heFNpemUgPSBwcmVmaXhNYXhTaXplICE9PSBudWxsICYmIGVuY29kZXJNYXhTaXplICE9PSBudWxsID8gcHJlZml4TWF4U2l6ZSArIGVuY29kZXJNYXhTaXplIDogbnVsbDtcbiAgcmV0dXJuIGNyZWF0ZUVuY29kZXIoe1xuICAgIC4uLmVuY29kZXIsXG4gICAgLi4ubWF4U2l6ZSAhPT0gbnVsbCA/IHsgbWF4U2l6ZSB9IDoge30sXG4gICAgZ2V0U2l6ZUZyb21WYWx1ZTogKHZhbHVlKSA9PiB7XG4gICAgICBjb25zdCBlbmNvZGVyU2l6ZSA9IGdldEVuY29kZWRTaXplKHZhbHVlLCBlbmNvZGVyKTtcbiAgICAgIHJldHVybiBnZXRFbmNvZGVkU2l6ZShlbmNvZGVyU2l6ZSwgcHJlZml4KSArIGVuY29kZXJTaXplO1xuICAgIH0sXG4gICAgd3JpdGVcbiAgfSk7XG59XG5mdW5jdGlvbiBhZGREZWNvZGVyU2l6ZVByZWZpeChkZWNvZGVyLCBwcmVmaXgpIHtcbiAgY29uc3QgcmVhZCA9IChieXRlcywgb2Zmc2V0KSA9PiB7XG4gICAgY29uc3QgW2JpZ2ludFNpemUsIGRlY29kZXJPZmZzZXRdID0gcHJlZml4LnJlYWQoYnl0ZXMsIG9mZnNldCk7XG4gICAgY29uc3Qgc2l6ZSA9IE51bWJlcihiaWdpbnRTaXplKTtcbiAgICBvZmZzZXQgPSBkZWNvZGVyT2Zmc2V0O1xuICAgIGlmIChvZmZzZXQgPiAwIHx8IGJ5dGVzLmxlbmd0aCA+IHNpemUpIHtcbiAgICAgIGJ5dGVzID0gYnl0ZXMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBzaXplKTtcbiAgICB9XG4gICAgYXNzZXJ0Qnl0ZUFycmF5SGFzRW5vdWdoQnl0ZXNGb3JDb2RlYyhcImFkZERlY29kZXJTaXplUHJlZml4XCIsIHNpemUsIGJ5dGVzKTtcbiAgICByZXR1cm4gW2RlY29kZXIuZGVjb2RlKGJ5dGVzKSwgb2Zmc2V0ICsgc2l6ZV07XG4gIH07XG4gIGlmIChpc0ZpeGVkU2l6ZShwcmVmaXgpICYmIGlzRml4ZWRTaXplKGRlY29kZXIpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZURlY29kZXIoeyAuLi5kZWNvZGVyLCBmaXhlZFNpemU6IHByZWZpeC5maXhlZFNpemUgKyBkZWNvZGVyLmZpeGVkU2l6ZSwgcmVhZCB9KTtcbiAgfVxuICBjb25zdCBwcmVmaXhNYXhTaXplID0gaXNGaXhlZFNpemUocHJlZml4KSA/IHByZWZpeC5maXhlZFNpemUgOiBwcmVmaXgubWF4U2l6ZSA/PyBudWxsO1xuICBjb25zdCBkZWNvZGVyTWF4U2l6ZSA9IGlzRml4ZWRTaXplKGRlY29kZXIpID8gZGVjb2Rlci5maXhlZFNpemUgOiBkZWNvZGVyLm1heFNpemUgPz8gbnVsbDtcbiAgY29uc3QgbWF4U2l6ZSA9IHByZWZpeE1heFNpemUgIT09IG51bGwgJiYgZGVjb2Rlck1heFNpemUgIT09IG51bGwgPyBwcmVmaXhNYXhTaXplICsgZGVjb2Rlck1heFNpemUgOiBudWxsO1xuICByZXR1cm4gY3JlYXRlRGVjb2Rlcih7IC4uLmRlY29kZXIsIC4uLm1heFNpemUgIT09IG51bGwgPyB7IG1heFNpemUgfSA6IHt9LCByZWFkIH0pO1xufVxuZnVuY3Rpb24gYWRkQ29kZWNTaXplUHJlZml4KGNvZGVjLCBwcmVmaXgpIHtcbiAgcmV0dXJuIGNvbWJpbmVDb2RlYyhhZGRFbmNvZGVyU2l6ZVByZWZpeChjb2RlYywgcHJlZml4KSwgYWRkRGVjb2RlclNpemVQcmVmaXgoY29kZWMsIHByZWZpeCkpO1xufVxuXG4vLyBzcmMvZml4LWNvZGVjLXNpemUudHNcbmZ1bmN0aW9uIGZpeEVuY29kZXJTaXplKGVuY29kZXIsIGZpeGVkQnl0ZXMpIHtcbiAgcmV0dXJuIGNyZWF0ZUVuY29kZXIoe1xuICAgIGZpeGVkU2l6ZTogZml4ZWRCeXRlcyxcbiAgICB3cml0ZTogKHZhbHVlLCBieXRlcywgb2Zmc2V0KSA9PiB7XG4gICAgICBjb25zdCB2YXJpYWJsZUJ5dGVBcnJheSA9IGVuY29kZXIuZW5jb2RlKHZhbHVlKTtcbiAgICAgIGNvbnN0IGZpeGVkQnl0ZUFycmF5ID0gdmFyaWFibGVCeXRlQXJyYXkubGVuZ3RoID4gZml4ZWRCeXRlcyA/IHZhcmlhYmxlQnl0ZUFycmF5LnNsaWNlKDAsIGZpeGVkQnl0ZXMpIDogdmFyaWFibGVCeXRlQXJyYXk7XG4gICAgICBieXRlcy5zZXQoZml4ZWRCeXRlQXJyYXksIG9mZnNldCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ICsgZml4ZWRCeXRlcztcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gZml4RGVjb2RlclNpemUoZGVjb2RlciwgZml4ZWRCeXRlcykge1xuICByZXR1cm4gY3JlYXRlRGVjb2Rlcih7XG4gICAgZml4ZWRTaXplOiBmaXhlZEJ5dGVzLFxuICAgIHJlYWQ6IChieXRlcywgb2Zmc2V0KSA9PiB7XG4gICAgICBhc3NlcnRCeXRlQXJyYXlIYXNFbm91Z2hCeXRlc0ZvckNvZGVjKFwiZml4Q29kZWNTaXplXCIsIGZpeGVkQnl0ZXMsIGJ5dGVzLCBvZmZzZXQpO1xuICAgICAgaWYgKG9mZnNldCA+IDAgfHwgYnl0ZXMubGVuZ3RoID4gZml4ZWRCeXRlcykge1xuICAgICAgICBieXRlcyA9IGJ5dGVzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgZml4ZWRCeXRlcyk7XG4gICAgICB9XG4gICAgICBpZiAoaXNGaXhlZFNpemUoZGVjb2RlcikpIHtcbiAgICAgICAgYnl0ZXMgPSBmaXhCeXRlcyhieXRlcywgZGVjb2Rlci5maXhlZFNpemUpO1xuICAgICAgfVxuICAgICAgY29uc3QgW3ZhbHVlXSA9IGRlY29kZXIucmVhZChieXRlcywgMCk7XG4gICAgICByZXR1cm4gW3ZhbHVlLCBvZmZzZXQgKyBmaXhlZEJ5dGVzXTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gZml4Q29kZWNTaXplKGNvZGVjLCBmaXhlZEJ5dGVzKSB7XG4gIHJldHVybiBjb21iaW5lQ29kZWMoZml4RW5jb2RlclNpemUoY29kZWMsIGZpeGVkQnl0ZXMpLCBmaXhEZWNvZGVyU2l6ZShjb2RlYywgZml4ZWRCeXRlcykpO1xufVxuXG4vLyBzcmMvb2Zmc2V0LWNvZGVjLnRzXG5mdW5jdGlvbiBvZmZzZXRFbmNvZGVyKGVuY29kZXIsIGNvbmZpZykge1xuICByZXR1cm4gY3JlYXRlRW5jb2Rlcih7XG4gICAgLi4uZW5jb2RlcixcbiAgICB3cml0ZTogKHZhbHVlLCBieXRlcywgcHJlT2Zmc2V0KSA9PiB7XG4gICAgICBjb25zdCB3cmFwQnl0ZXMgPSAob2Zmc2V0KSA9PiBtb2R1bG8ob2Zmc2V0LCBieXRlcy5sZW5ndGgpO1xuICAgICAgY29uc3QgbmV3UHJlT2Zmc2V0ID0gY29uZmlnLnByZU9mZnNldCA/IGNvbmZpZy5wcmVPZmZzZXQoeyBieXRlcywgcHJlT2Zmc2V0LCB3cmFwQnl0ZXMgfSkgOiBwcmVPZmZzZXQ7XG4gICAgICBhc3NlcnRCeXRlQXJyYXlPZmZzZXRJc05vdE91dE9mUmFuZ2UoXCJvZmZzZXRFbmNvZGVyXCIsIG5ld1ByZU9mZnNldCwgYnl0ZXMubGVuZ3RoKTtcbiAgICAgIGNvbnN0IHBvc3RPZmZzZXQgPSBlbmNvZGVyLndyaXRlKHZhbHVlLCBieXRlcywgbmV3UHJlT2Zmc2V0KTtcbiAgICAgIGNvbnN0IG5ld1Bvc3RPZmZzZXQgPSBjb25maWcucG9zdE9mZnNldCA/IGNvbmZpZy5wb3N0T2Zmc2V0KHsgYnl0ZXMsIG5ld1ByZU9mZnNldCwgcG9zdE9mZnNldCwgcHJlT2Zmc2V0LCB3cmFwQnl0ZXMgfSkgOiBwb3N0T2Zmc2V0O1xuICAgICAgYXNzZXJ0Qnl0ZUFycmF5T2Zmc2V0SXNOb3RPdXRPZlJhbmdlKFwib2Zmc2V0RW5jb2RlclwiLCBuZXdQb3N0T2Zmc2V0LCBieXRlcy5sZW5ndGgpO1xuICAgICAgcmV0dXJuIG5ld1Bvc3RPZmZzZXQ7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIG9mZnNldERlY29kZXIoZGVjb2RlciwgY29uZmlnKSB7XG4gIHJldHVybiBjcmVhdGVEZWNvZGVyKHtcbiAgICAuLi5kZWNvZGVyLFxuICAgIHJlYWQ6IChieXRlcywgcHJlT2Zmc2V0KSA9PiB7XG4gICAgICBjb25zdCB3cmFwQnl0ZXMgPSAob2Zmc2V0KSA9PiBtb2R1bG8ob2Zmc2V0LCBieXRlcy5sZW5ndGgpO1xuICAgICAgY29uc3QgbmV3UHJlT2Zmc2V0ID0gY29uZmlnLnByZU9mZnNldCA/IGNvbmZpZy5wcmVPZmZzZXQoeyBieXRlcywgcHJlT2Zmc2V0LCB3cmFwQnl0ZXMgfSkgOiBwcmVPZmZzZXQ7XG4gICAgICBhc3NlcnRCeXRlQXJyYXlPZmZzZXRJc05vdE91dE9mUmFuZ2UoXCJvZmZzZXREZWNvZGVyXCIsIG5ld1ByZU9mZnNldCwgYnl0ZXMubGVuZ3RoKTtcbiAgICAgIGNvbnN0IFt2YWx1ZSwgcG9zdE9mZnNldF0gPSBkZWNvZGVyLnJlYWQoYnl0ZXMsIG5ld1ByZU9mZnNldCk7XG4gICAgICBjb25zdCBuZXdQb3N0T2Zmc2V0ID0gY29uZmlnLnBvc3RPZmZzZXQgPyBjb25maWcucG9zdE9mZnNldCh7IGJ5dGVzLCBuZXdQcmVPZmZzZXQsIHBvc3RPZmZzZXQsIHByZU9mZnNldCwgd3JhcEJ5dGVzIH0pIDogcG9zdE9mZnNldDtcbiAgICAgIGFzc2VydEJ5dGVBcnJheU9mZnNldElzTm90T3V0T2ZSYW5nZShcIm9mZnNldERlY29kZXJcIiwgbmV3UG9zdE9mZnNldCwgYnl0ZXMubGVuZ3RoKTtcbiAgICAgIHJldHVybiBbdmFsdWUsIG5ld1Bvc3RPZmZzZXRdO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBvZmZzZXRDb2RlYyhjb2RlYywgY29uZmlnKSB7XG4gIHJldHVybiBjb21iaW5lQ29kZWMob2Zmc2V0RW5jb2Rlcihjb2RlYywgY29uZmlnKSwgb2Zmc2V0RGVjb2Rlcihjb2RlYywgY29uZmlnKSk7XG59XG5mdW5jdGlvbiBtb2R1bG8oZGl2aWRlbmQsIGRpdmlzb3IpIHtcbiAgaWYgKGRpdmlzb3IgPT09IDApIHJldHVybiAwO1xuICByZXR1cm4gKGRpdmlkZW5kICUgZGl2aXNvciArIGRpdmlzb3IpICUgZGl2aXNvcjtcbn1cbmZ1bmN0aW9uIHJlc2l6ZUVuY29kZXIoZW5jb2RlciwgcmVzaXplKSB7XG4gIGlmIChpc0ZpeGVkU2l6ZShlbmNvZGVyKSkge1xuICAgIGNvbnN0IGZpeGVkU2l6ZSA9IHJlc2l6ZShlbmNvZGVyLmZpeGVkU2l6ZSk7XG4gICAgaWYgKGZpeGVkU2l6ZSA8IDApIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfUE9TSVRJVkVfQllURV9MRU5HVEgsIHtcbiAgICAgICAgYnl0ZXNMZW5ndGg6IGZpeGVkU2l6ZSxcbiAgICAgICAgY29kZWNEZXNjcmlwdGlvbjogXCJyZXNpemVFbmNvZGVyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlRW5jb2Rlcih7IC4uLmVuY29kZXIsIGZpeGVkU2l6ZSB9KTtcbiAgfVxuICByZXR1cm4gY3JlYXRlRW5jb2Rlcih7XG4gICAgLi4uZW5jb2RlcixcbiAgICBnZXRTaXplRnJvbVZhbHVlOiAodmFsdWUpID0+IHtcbiAgICAgIGNvbnN0IG5ld1NpemUgPSByZXNpemUoZW5jb2Rlci5nZXRTaXplRnJvbVZhbHVlKHZhbHVlKSk7XG4gICAgICBpZiAobmV3U2l6ZSA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9QT1NJVElWRV9CWVRFX0xFTkdUSCwge1xuICAgICAgICAgIGJ5dGVzTGVuZ3RoOiBuZXdTaXplLFxuICAgICAgICAgIGNvZGVjRGVzY3JpcHRpb246IFwicmVzaXplRW5jb2RlclwiXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld1NpemU7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHJlc2l6ZURlY29kZXIoZGVjb2RlciwgcmVzaXplKSB7XG4gIGlmIChpc0ZpeGVkU2l6ZShkZWNvZGVyKSkge1xuICAgIGNvbnN0IGZpeGVkU2l6ZSA9IHJlc2l6ZShkZWNvZGVyLmZpeGVkU2l6ZSk7XG4gICAgaWYgKGZpeGVkU2l6ZSA8IDApIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfUE9TSVRJVkVfQllURV9MRU5HVEgsIHtcbiAgICAgICAgYnl0ZXNMZW5ndGg6IGZpeGVkU2l6ZSxcbiAgICAgICAgY29kZWNEZXNjcmlwdGlvbjogXCJyZXNpemVEZWNvZGVyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlRGVjb2Rlcih7IC4uLmRlY29kZXIsIGZpeGVkU2l6ZSB9KTtcbiAgfVxuICByZXR1cm4gZGVjb2Rlcjtcbn1cbmZ1bmN0aW9uIHJlc2l6ZUNvZGVjKGNvZGVjLCByZXNpemUpIHtcbiAgcmV0dXJuIGNvbWJpbmVDb2RlYyhyZXNpemVFbmNvZGVyKGNvZGVjLCByZXNpemUpLCByZXNpemVEZWNvZGVyKGNvZGVjLCByZXNpemUpKTtcbn1cblxuLy8gc3JjL3BhZC1jb2RlYy50c1xuZnVuY3Rpb24gcGFkTGVmdEVuY29kZXIoZW5jb2Rlciwgb2Zmc2V0KSB7XG4gIHJldHVybiBvZmZzZXRFbmNvZGVyKFxuICAgIHJlc2l6ZUVuY29kZXIoZW5jb2RlciwgKHNpemUpID0+IHNpemUgKyBvZmZzZXQpLFxuICAgIHsgcHJlT2Zmc2V0OiAoeyBwcmVPZmZzZXQgfSkgPT4gcHJlT2Zmc2V0ICsgb2Zmc2V0IH1cbiAgKTtcbn1cbmZ1bmN0aW9uIHBhZFJpZ2h0RW5jb2RlcihlbmNvZGVyLCBvZmZzZXQpIHtcbiAgcmV0dXJuIG9mZnNldEVuY29kZXIoXG4gICAgcmVzaXplRW5jb2RlcihlbmNvZGVyLCAoc2l6ZSkgPT4gc2l6ZSArIG9mZnNldCksXG4gICAgeyBwb3N0T2Zmc2V0OiAoeyBwb3N0T2Zmc2V0IH0pID0+IHBvc3RPZmZzZXQgKyBvZmZzZXQgfVxuICApO1xufVxuZnVuY3Rpb24gcGFkTGVmdERlY29kZXIoZGVjb2Rlciwgb2Zmc2V0KSB7XG4gIHJldHVybiBvZmZzZXREZWNvZGVyKFxuICAgIHJlc2l6ZURlY29kZXIoZGVjb2RlciwgKHNpemUpID0+IHNpemUgKyBvZmZzZXQpLFxuICAgIHsgcHJlT2Zmc2V0OiAoeyBwcmVPZmZzZXQgfSkgPT4gcHJlT2Zmc2V0ICsgb2Zmc2V0IH1cbiAgKTtcbn1cbmZ1bmN0aW9uIHBhZFJpZ2h0RGVjb2RlcihkZWNvZGVyLCBvZmZzZXQpIHtcbiAgcmV0dXJuIG9mZnNldERlY29kZXIoXG4gICAgcmVzaXplRGVjb2RlcihkZWNvZGVyLCAoc2l6ZSkgPT4gc2l6ZSArIG9mZnNldCksXG4gICAgeyBwb3N0T2Zmc2V0OiAoeyBwb3N0T2Zmc2V0IH0pID0+IHBvc3RPZmZzZXQgKyBvZmZzZXQgfVxuICApO1xufVxuZnVuY3Rpb24gcGFkTGVmdENvZGVjKGNvZGVjLCBvZmZzZXQpIHtcbiAgcmV0dXJuIGNvbWJpbmVDb2RlYyhwYWRMZWZ0RW5jb2Rlcihjb2RlYywgb2Zmc2V0KSwgcGFkTGVmdERlY29kZXIoY29kZWMsIG9mZnNldCkpO1xufVxuZnVuY3Rpb24gcGFkUmlnaHRDb2RlYyhjb2RlYywgb2Zmc2V0KSB7XG4gIHJldHVybiBjb21iaW5lQ29kZWMocGFkUmlnaHRFbmNvZGVyKGNvZGVjLCBvZmZzZXQpLCBwYWRSaWdodERlY29kZXIoY29kZWMsIG9mZnNldCkpO1xufVxuXG4vLyBzcmMvcmV2ZXJzZS1jb2RlYy50c1xuZnVuY3Rpb24gY29weVNvdXJjZVRvVGFyZ2V0SW5SZXZlcnNlKHNvdXJjZSwgdGFyZ2V0X1dJTExfTVVUQVRFLCBzb3VyY2VPZmZzZXQsIHNvdXJjZUxlbmd0aCwgdGFyZ2V0T2Zmc2V0ID0gMCkge1xuICB3aGlsZSAoc291cmNlT2Zmc2V0IDwgLS1zb3VyY2VMZW5ndGgpIHtcbiAgICBjb25zdCBsZWZ0VmFsdWUgPSBzb3VyY2Vbc291cmNlT2Zmc2V0XTtcbiAgICB0YXJnZXRfV0lMTF9NVVRBVEVbc291cmNlT2Zmc2V0ICsgdGFyZ2V0T2Zmc2V0XSA9IHNvdXJjZVtzb3VyY2VMZW5ndGhdO1xuICAgIHRhcmdldF9XSUxMX01VVEFURVtzb3VyY2VMZW5ndGggKyB0YXJnZXRPZmZzZXRdID0gbGVmdFZhbHVlO1xuICAgIHNvdXJjZU9mZnNldCsrO1xuICB9XG4gIGlmIChzb3VyY2VPZmZzZXQgPT09IHNvdXJjZUxlbmd0aCkge1xuICAgIHRhcmdldF9XSUxMX01VVEFURVtzb3VyY2VPZmZzZXQgKyB0YXJnZXRPZmZzZXRdID0gc291cmNlW3NvdXJjZU9mZnNldF07XG4gIH1cbn1cbmZ1bmN0aW9uIHJldmVyc2VFbmNvZGVyKGVuY29kZXIpIHtcbiAgYXNzZXJ0SXNGaXhlZFNpemUoZW5jb2Rlcik7XG4gIHJldHVybiBjcmVhdGVFbmNvZGVyKHtcbiAgICAuLi5lbmNvZGVyLFxuICAgIHdyaXRlOiAodmFsdWUsIGJ5dGVzLCBvZmZzZXQpID0+IHtcbiAgICAgIGNvbnN0IG5ld09mZnNldCA9IGVuY29kZXIud3JpdGUodmFsdWUsIGJ5dGVzLCBvZmZzZXQpO1xuICAgICAgY29weVNvdXJjZVRvVGFyZ2V0SW5SZXZlcnNlKFxuICAgICAgICBieXRlcyxcbiAgICAgICAgYnl0ZXMsXG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgb2Zmc2V0ICsgZW5jb2Rlci5maXhlZFNpemVcbiAgICAgICk7XG4gICAgICByZXR1cm4gbmV3T2Zmc2V0O1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiByZXZlcnNlRGVjb2RlcihkZWNvZGVyKSB7XG4gIGFzc2VydElzRml4ZWRTaXplKGRlY29kZXIpO1xuICByZXR1cm4gY3JlYXRlRGVjb2Rlcih7XG4gICAgLi4uZGVjb2RlcixcbiAgICByZWFkOiAoYnl0ZXMsIG9mZnNldCkgPT4ge1xuICAgICAgY29uc3QgcmV2ZXJzZWRCeXRlcyA9IGJ5dGVzLnNsaWNlKCk7XG4gICAgICBjb3B5U291cmNlVG9UYXJnZXRJblJldmVyc2UoXG4gICAgICAgIGJ5dGVzLFxuICAgICAgICByZXZlcnNlZEJ5dGVzLFxuICAgICAgICBvZmZzZXQsXG4gICAgICAgIG9mZnNldCArIGRlY29kZXIuZml4ZWRTaXplXG4gICAgICApO1xuICAgICAgcmV0dXJuIGRlY29kZXIucmVhZChyZXZlcnNlZEJ5dGVzLCBvZmZzZXQpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiByZXZlcnNlQ29kZWMoY29kZWMpIHtcbiAgcmV0dXJuIGNvbWJpbmVDb2RlYyhyZXZlcnNlRW5jb2Rlcihjb2RlYyksIHJldmVyc2VEZWNvZGVyKGNvZGVjKSk7XG59XG5cbi8vIHNyYy90cmFuc2Zvcm0tY29kZWMudHNcbmZ1bmN0aW9uIHRyYW5zZm9ybUVuY29kZXIoZW5jb2RlciwgdW5tYXApIHtcbiAgcmV0dXJuIGNyZWF0ZUVuY29kZXIoe1xuICAgIC4uLmlzVmFyaWFibGVTaXplKGVuY29kZXIpID8geyAuLi5lbmNvZGVyLCBnZXRTaXplRnJvbVZhbHVlOiAodmFsdWUpID0+IGVuY29kZXIuZ2V0U2l6ZUZyb21WYWx1ZSh1bm1hcCh2YWx1ZSkpIH0gOiBlbmNvZGVyLFxuICAgIHdyaXRlOiAodmFsdWUsIGJ5dGVzLCBvZmZzZXQpID0+IGVuY29kZXIud3JpdGUodW5tYXAodmFsdWUpLCBieXRlcywgb2Zmc2V0KVxuICB9KTtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybURlY29kZXIoZGVjb2RlciwgbWFwKSB7XG4gIHJldHVybiBjcmVhdGVEZWNvZGVyKHtcbiAgICAuLi5kZWNvZGVyLFxuICAgIHJlYWQ6IChieXRlcywgb2Zmc2V0KSA9PiB7XG4gICAgICBjb25zdCBbdmFsdWUsIG5ld09mZnNldF0gPSBkZWNvZGVyLnJlYWQoYnl0ZXMsIG9mZnNldCk7XG4gICAgICByZXR1cm4gW21hcCh2YWx1ZSwgYnl0ZXMsIG9mZnNldCksIG5ld09mZnNldF07XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybUNvZGVjKGNvZGVjLCB1bm1hcCwgbWFwKSB7XG4gIHJldHVybiBjcmVhdGVDb2RlYyh7XG4gICAgLi4udHJhbnNmb3JtRW5jb2Rlcihjb2RlYywgdW5tYXApLFxuICAgIHJlYWQ6IG1hcCA/IHRyYW5zZm9ybURlY29kZXIoY29kZWMsIG1hcCkucmVhZCA6IGNvZGVjLnJlYWRcbiAgfSk7XG59XG5cbmV4cG9ydCB7IGFkZENvZGVjU2VudGluZWwsIGFkZENvZGVjU2l6ZVByZWZpeCwgYWRkRGVjb2RlclNlbnRpbmVsLCBhZGREZWNvZGVyU2l6ZVByZWZpeCwgYWRkRW5jb2RlclNlbnRpbmVsLCBhZGRFbmNvZGVyU2l6ZVByZWZpeCwgYXNzZXJ0Qnl0ZUFycmF5SGFzRW5vdWdoQnl0ZXNGb3JDb2RlYywgYXNzZXJ0Qnl0ZUFycmF5SXNOb3RFbXB0eUZvckNvZGVjLCBhc3NlcnRCeXRlQXJyYXlPZmZzZXRJc05vdE91dE9mUmFuZ2UsIGFzc2VydElzRml4ZWRTaXplLCBhc3NlcnRJc1ZhcmlhYmxlU2l6ZSwgY29tYmluZUNvZGVjLCBjb250YWluc0J5dGVzLCBjcmVhdGVDb2RlYywgY3JlYXRlRGVjb2RlciwgY3JlYXRlRW5jb2RlciwgZml4Qnl0ZXMsIGZpeENvZGVjU2l6ZSwgZml4RGVjb2RlclNpemUsIGZpeEVuY29kZXJTaXplLCBnZXRFbmNvZGVkU2l6ZSwgaXNGaXhlZFNpemUsIGlzVmFyaWFibGVTaXplLCBtZXJnZUJ5dGVzLCBvZmZzZXRDb2RlYywgb2Zmc2V0RGVjb2Rlciwgb2Zmc2V0RW5jb2RlciwgcGFkQnl0ZXMsIHBhZExlZnRDb2RlYywgcGFkTGVmdERlY29kZXIsIHBhZExlZnRFbmNvZGVyLCBwYWRSaWdodENvZGVjLCBwYWRSaWdodERlY29kZXIsIHBhZFJpZ2h0RW5jb2RlciwgcmVzaXplQ29kZWMsIHJlc2l6ZURlY29kZXIsIHJlc2l6ZUVuY29kZXIsIHJldmVyc2VDb2RlYywgcmV2ZXJzZURlY29kZXIsIHJldmVyc2VFbmNvZGVyLCB0cmFuc2Zvcm1Db2RlYywgdHJhbnNmb3JtRGVjb2RlciwgdHJhbnNmb3JtRW5jb2RlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubm9kZS5tanMubWFwXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5ub2RlLm1qcy5tYXAiXSwibmFtZXMiOlsiU29sYW5hRXJyb3IiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfRklYRURfTEVOR1RIIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX1ZBUklBQkxFX0xFTkdUSCIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfU0laRV9DT01QQVRJQklMSVRZX01JU01BVENIIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9GSVhFRF9TSVpFX01JU01BVENIIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9NQVhfU0laRV9NSVNNQVRDSCIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19DQU5OT1RfREVDT0RFX0VNUFRZX0JZVEVfQVJSQVkiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9CWVRFX0xFTkdUSCIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19PRkZTRVRfT1VUX09GX1JBTkdFIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX1BPU0lUSVZFX0JZVEVfTEVOR1RIIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX1NFTlRJTkVMX01JU1NJTkdfSU5fREVDT0RFRF9CWVRFUyIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVEX0JZVEVTX01VU1RfTk9UX0lOQ0xVREVfU0VOVElORUwiLCJtZXJnZUJ5dGVzIiwiYnl0ZUFycmF5cyIsIm5vbkVtcHR5Qnl0ZUFycmF5cyIsImZpbHRlciIsImFyciIsImxlbmd0aCIsIlVpbnQ4QXJyYXkiLCJ0b3RhbExlbmd0aCIsInJlZHVjZSIsInRvdGFsIiwicmVzdWx0Iiwib2Zmc2V0IiwiZm9yRWFjaCIsInNldCIsInBhZEJ5dGVzIiwiYnl0ZXMiLCJwYWRkZWRCeXRlcyIsImZpbGwiLCJmaXhCeXRlcyIsInNsaWNlIiwiY29udGFpbnNCeXRlcyIsImRhdGEiLCJldmVyeSIsImIiLCJpIiwiZ2V0RW5jb2RlZFNpemUiLCJ2YWx1ZSIsImVuY29kZXIiLCJmaXhlZFNpemUiLCJnZXRTaXplRnJvbVZhbHVlIiwiY3JlYXRlRW5jb2RlciIsIk9iamVjdCIsImZyZWV6ZSIsImVuY29kZSIsIndyaXRlIiwiY3JlYXRlRGVjb2RlciIsImRlY29kZXIiLCJkZWNvZGUiLCJyZWFkIiwiY3JlYXRlQ29kZWMiLCJjb2RlYyIsImlzRml4ZWRTaXplIiwiYXNzZXJ0SXNGaXhlZFNpemUiLCJpc1ZhcmlhYmxlU2l6ZSIsImFzc2VydElzVmFyaWFibGVTaXplIiwiY29tYmluZUNvZGVjIiwiZGVjb2RlckZpeGVkU2l6ZSIsImVuY29kZXJGaXhlZFNpemUiLCJtYXhTaXplIiwiZGVjb2Rlck1heFNpemUiLCJlbmNvZGVyTWF4U2l6ZSIsImFkZEVuY29kZXJTZW50aW5lbCIsInNlbnRpbmVsIiwiZW5jb2RlckJ5dGVzIiwiZmluZFNlbnRpbmVsSW5kZXgiLCJlbmNvZGVkQnl0ZXMiLCJoZXhFbmNvZGVkQnl0ZXMiLCJoZXhCeXRlcyIsImhleFNlbnRpbmVsIiwiYWRkRGVjb2RlclNlbnRpbmVsIiwiY2FuZGlkYXRlQnl0ZXMiLCJzZW50aW5lbEluZGV4IiwiZGVjb2RlZEJ5dGVzIiwiaGV4RGVjb2RlZEJ5dGVzIiwicHJlU2VudGluZWxCeXRlcyIsImFkZENvZGVjU2VudGluZWwiLCJmaW5kSW5kZXgiLCJieXRlIiwiaW5kZXgiLCJzdHIiLCJ0b1N0cmluZyIsInBhZFN0YXJ0IiwiYXNzZXJ0Qnl0ZUFycmF5SXNOb3RFbXB0eUZvckNvZGVjIiwiY29kZWNEZXNjcmlwdGlvbiIsImFzc2VydEJ5dGVBcnJheUhhc0Vub3VnaEJ5dGVzRm9yQ29kZWMiLCJleHBlY3RlZCIsImJ5dGVzTGVuZ3RoIiwiYXNzZXJ0Qnl0ZUFycmF5T2Zmc2V0SXNOb3RPdXRPZlJhbmdlIiwiYWRkRW5jb2RlclNpemVQcmVmaXgiLCJwcmVmaXgiLCJwcmVmaXhNYXhTaXplIiwiZW5jb2RlclNpemUiLCJhZGREZWNvZGVyU2l6ZVByZWZpeCIsImJpZ2ludFNpemUiLCJkZWNvZGVyT2Zmc2V0Iiwic2l6ZSIsIk51bWJlciIsImFkZENvZGVjU2l6ZVByZWZpeCIsImZpeEVuY29kZXJTaXplIiwiZml4ZWRCeXRlcyIsInZhcmlhYmxlQnl0ZUFycmF5IiwiZml4ZWRCeXRlQXJyYXkiLCJmaXhEZWNvZGVyU2l6ZSIsImZpeENvZGVjU2l6ZSIsIm9mZnNldEVuY29kZXIiLCJjb25maWciLCJwcmVPZmZzZXQiLCJ3cmFwQnl0ZXMiLCJtb2R1bG8iLCJuZXdQcmVPZmZzZXQiLCJwb3N0T2Zmc2V0IiwibmV3UG9zdE9mZnNldCIsIm9mZnNldERlY29kZXIiLCJvZmZzZXRDb2RlYyIsImRpdmlkZW5kIiwiZGl2aXNvciIsInJlc2l6ZUVuY29kZXIiLCJyZXNpemUiLCJuZXdTaXplIiwicmVzaXplRGVjb2RlciIsInJlc2l6ZUNvZGVjIiwicGFkTGVmdEVuY29kZXIiLCJwYWRSaWdodEVuY29kZXIiLCJwYWRMZWZ0RGVjb2RlciIsInBhZFJpZ2h0RGVjb2RlciIsInBhZExlZnRDb2RlYyIsInBhZFJpZ2h0Q29kZWMiLCJjb3B5U291cmNlVG9UYXJnZXRJblJldmVyc2UiLCJzb3VyY2UiLCJ0YXJnZXRfV0lMTF9NVVRBVEUiLCJzb3VyY2VPZmZzZXQiLCJzb3VyY2VMZW5ndGgiLCJ0YXJnZXRPZmZzZXQiLCJsZWZ0VmFsdWUiLCJyZXZlcnNlRW5jb2RlciIsIm5ld09mZnNldCIsInJldmVyc2VEZWNvZGVyIiwicmV2ZXJzZWRCeXRlcyIsInJldmVyc2VDb2RlYyIsInRyYW5zZm9ybUVuY29kZXIiLCJ1bm1hcCIsInRyYW5zZm9ybURlY29kZXIiLCJtYXAiLCJ0cmFuc2Zvcm1Db2RlYyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/web3.js/node_modules/@solana/codecs-core/dist/index.node.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/web3.js/node_modules/@solana/codecs-numbers/dist/index.node.mjs":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@solana/web3.js/node_modules/@solana/codecs-numbers/dist/index.node.mjs ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Endian: () => (/* binding */ Endian),\n/* harmony export */   assertNumberIsBetweenForCodec: () => (/* binding */ assertNumberIsBetweenForCodec),\n/* harmony export */   getF32Codec: () => (/* binding */ getF32Codec),\n/* harmony export */   getF32Decoder: () => (/* binding */ getF32Decoder),\n/* harmony export */   getF32Encoder: () => (/* binding */ getF32Encoder),\n/* harmony export */   getF64Codec: () => (/* binding */ getF64Codec),\n/* harmony export */   getF64Decoder: () => (/* binding */ getF64Decoder),\n/* harmony export */   getF64Encoder: () => (/* binding */ getF64Encoder),\n/* harmony export */   getI128Codec: () => (/* binding */ getI128Codec),\n/* harmony export */   getI128Decoder: () => (/* binding */ getI128Decoder),\n/* harmony export */   getI128Encoder: () => (/* binding */ getI128Encoder),\n/* harmony export */   getI16Codec: () => (/* binding */ getI16Codec),\n/* harmony export */   getI16Decoder: () => (/* binding */ getI16Decoder),\n/* harmony export */   getI16Encoder: () => (/* binding */ getI16Encoder),\n/* harmony export */   getI32Codec: () => (/* binding */ getI32Codec),\n/* harmony export */   getI32Decoder: () => (/* binding */ getI32Decoder),\n/* harmony export */   getI32Encoder: () => (/* binding */ getI32Encoder),\n/* harmony export */   getI64Codec: () => (/* binding */ getI64Codec),\n/* harmony export */   getI64Decoder: () => (/* binding */ getI64Decoder),\n/* harmony export */   getI64Encoder: () => (/* binding */ getI64Encoder),\n/* harmony export */   getI8Codec: () => (/* binding */ getI8Codec),\n/* harmony export */   getI8Decoder: () => (/* binding */ getI8Decoder),\n/* harmony export */   getI8Encoder: () => (/* binding */ getI8Encoder),\n/* harmony export */   getShortU16Codec: () => (/* binding */ getShortU16Codec),\n/* harmony export */   getShortU16Decoder: () => (/* binding */ getShortU16Decoder),\n/* harmony export */   getShortU16Encoder: () => (/* binding */ getShortU16Encoder),\n/* harmony export */   getU128Codec: () => (/* binding */ getU128Codec),\n/* harmony export */   getU128Decoder: () => (/* binding */ getU128Decoder),\n/* harmony export */   getU128Encoder: () => (/* binding */ getU128Encoder),\n/* harmony export */   getU16Codec: () => (/* binding */ getU16Codec),\n/* harmony export */   getU16Decoder: () => (/* binding */ getU16Decoder),\n/* harmony export */   getU16Encoder: () => (/* binding */ getU16Encoder),\n/* harmony export */   getU32Codec: () => (/* binding */ getU32Codec),\n/* harmony export */   getU32Decoder: () => (/* binding */ getU32Decoder),\n/* harmony export */   getU32Encoder: () => (/* binding */ getU32Encoder),\n/* harmony export */   getU64Codec: () => (/* binding */ getU64Codec),\n/* harmony export */   getU64Decoder: () => (/* binding */ getU64Decoder),\n/* harmony export */   getU64Encoder: () => (/* binding */ getU64Encoder),\n/* harmony export */   getU8Codec: () => (/* binding */ getU8Codec),\n/* harmony export */   getU8Decoder: () => (/* binding */ getU8Decoder),\n/* harmony export */   getU8Encoder: () => (/* binding */ getU8Encoder)\n/* harmony export */ });\n/* harmony import */ var _solana_errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/errors */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@solana/errors/dist/index.node.mjs\");\n/* harmony import */ var _solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana/codecs-core */ \"(ssr)/./node_modules/@solana/web3.js/node_modules/@solana/codecs-core/dist/index.node.mjs\");\n\n\n// src/assertions.ts\nfunction assertNumberIsBetweenForCodec(codecDescription, min, max, value) {\n    if (value < min || value > max) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, {\n            codecDescription,\n            max,\n            min,\n            value\n        });\n    }\n}\n// src/common.ts\nvar Endian = /* @__PURE__ */ ((Endian2)=>{\n    Endian2[Endian2[\"Little\"] = 0] = \"Little\";\n    Endian2[Endian2[\"Big\"] = 1] = \"Big\";\n    return Endian2;\n})(Endian || {});\nfunction isLittleEndian(config) {\n    return config?.endian === 1 /* Big */  ? false : true;\n}\nfunction numberEncoderFactory(input) {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.createEncoder)({\n        fixedSize: input.size,\n        write (value, bytes, offset) {\n            if (input.range) {\n                assertNumberIsBetweenForCodec(input.name, input.range[0], input.range[1], value);\n            }\n            const arrayBuffer = new ArrayBuffer(input.size);\n            input.set(new DataView(arrayBuffer), value, isLittleEndian(input.config));\n            bytes.set(new Uint8Array(arrayBuffer), offset);\n            return offset + input.size;\n        }\n    });\n}\nfunction numberDecoderFactory(input) {\n    return (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.createDecoder)({\n        fixedSize: input.size,\n        read (bytes, offset = 0) {\n            (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.assertByteArrayIsNotEmptyForCodec)(input.name, bytes, offset);\n            (0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.assertByteArrayHasEnoughBytesForCodec)(input.name, input.size, bytes, offset);\n            const view = new DataView(toArrayBuffer(bytes, offset, input.size));\n            return [\n                input.get(view, isLittleEndian(input.config)),\n                offset + input.size\n            ];\n        }\n    });\n}\nfunction toArrayBuffer(bytes, offset, length) {\n    const bytesOffset = bytes.byteOffset + (offset ?? 0);\n    const bytesLength = length ?? bytes.byteLength;\n    return bytes.buffer.slice(bytesOffset, bytesOffset + bytesLength);\n}\n// src/f32.ts\nvar getF32Encoder = (config = {})=>numberEncoderFactory({\n        config,\n        name: \"f32\",\n        set: (view, value, le)=>view.setFloat32(0, Number(value), le),\n        size: 4\n    });\nvar getF32Decoder = (config = {})=>numberDecoderFactory({\n        config,\n        get: (view, le)=>view.getFloat32(0, le),\n        name: \"f32\",\n        size: 4\n    });\nvar getF32Codec = (config = {})=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getF32Encoder(config), getF32Decoder(config));\nvar getF64Encoder = (config = {})=>numberEncoderFactory({\n        config,\n        name: \"f64\",\n        set: (view, value, le)=>view.setFloat64(0, Number(value), le),\n        size: 8\n    });\nvar getF64Decoder = (config = {})=>numberDecoderFactory({\n        config,\n        get: (view, le)=>view.getFloat64(0, le),\n        name: \"f64\",\n        size: 8\n    });\nvar getF64Codec = (config = {})=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getF64Encoder(config), getF64Decoder(config));\nvar getI128Encoder = (config = {})=>numberEncoderFactory({\n        config,\n        name: \"i128\",\n        range: [\n            -BigInt(\"0x7fffffffffffffffffffffffffffffff\") - 1n,\n            BigInt(\"0x7fffffffffffffffffffffffffffffff\")\n        ],\n        set: (view, value, le)=>{\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const rightMask = 0xffffffffffffffffn;\n            view.setBigInt64(leftOffset, BigInt(value) >> 64n, le);\n            view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);\n        },\n        size: 16\n    });\nvar getI128Decoder = (config = {})=>numberDecoderFactory({\n        config,\n        get: (view, le)=>{\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const left = view.getBigInt64(leftOffset, le);\n            const right = view.getBigUint64(rightOffset, le);\n            return (left << 64n) + right;\n        },\n        name: \"i128\",\n        size: 16\n    });\nvar getI128Codec = (config = {})=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getI128Encoder(config), getI128Decoder(config));\nvar getI16Encoder = (config = {})=>numberEncoderFactory({\n        config,\n        name: \"i16\",\n        range: [\n            -Number(\"0x7fff\") - 1,\n            Number(\"0x7fff\")\n        ],\n        set: (view, value, le)=>view.setInt16(0, Number(value), le),\n        size: 2\n    });\nvar getI16Decoder = (config = {})=>numberDecoderFactory({\n        config,\n        get: (view, le)=>view.getInt16(0, le),\n        name: \"i16\",\n        size: 2\n    });\nvar getI16Codec = (config = {})=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getI16Encoder(config), getI16Decoder(config));\nvar getI32Encoder = (config = {})=>numberEncoderFactory({\n        config,\n        name: \"i32\",\n        range: [\n            -Number(\"0x7fffffff\") - 1,\n            Number(\"0x7fffffff\")\n        ],\n        set: (view, value, le)=>view.setInt32(0, Number(value), le),\n        size: 4\n    });\nvar getI32Decoder = (config = {})=>numberDecoderFactory({\n        config,\n        get: (view, le)=>view.getInt32(0, le),\n        name: \"i32\",\n        size: 4\n    });\nvar getI32Codec = (config = {})=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getI32Encoder(config), getI32Decoder(config));\nvar getI64Encoder = (config = {})=>numberEncoderFactory({\n        config,\n        name: \"i64\",\n        range: [\n            -BigInt(\"0x7fffffffffffffff\") - 1n,\n            BigInt(\"0x7fffffffffffffff\")\n        ],\n        set: (view, value, le)=>view.setBigInt64(0, BigInt(value), le),\n        size: 8\n    });\nvar getI64Decoder = (config = {})=>numberDecoderFactory({\n        config,\n        get: (view, le)=>view.getBigInt64(0, le),\n        name: \"i64\",\n        size: 8\n    });\nvar getI64Codec = (config = {})=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getI64Encoder(config), getI64Decoder(config));\nvar getI8Encoder = ()=>numberEncoderFactory({\n        name: \"i8\",\n        range: [\n            -Number(\"0x7f\") - 1,\n            Number(\"0x7f\")\n        ],\n        set: (view, value)=>view.setInt8(0, Number(value)),\n        size: 1\n    });\nvar getI8Decoder = ()=>numberDecoderFactory({\n        get: (view)=>view.getInt8(0),\n        name: \"i8\",\n        size: 1\n    });\nvar getI8Codec = ()=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getI8Encoder(), getI8Decoder());\nvar getShortU16Encoder = ()=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.createEncoder)({\n        getSizeFromValue: (value)=>{\n            if (value <= 127) return 1;\n            if (value <= 16383) return 2;\n            return 3;\n        },\n        maxSize: 3,\n        write: (value, bytes, offset)=>{\n            assertNumberIsBetweenForCodec(\"shortU16\", 0, 65535, value);\n            const shortU16Bytes = [\n                0\n            ];\n            for(let ii = 0;; ii += 1){\n                const alignedValue = Number(value) >> ii * 7;\n                if (alignedValue === 0) {\n                    break;\n                }\n                const nextSevenBits = 127 & alignedValue;\n                shortU16Bytes[ii] = nextSevenBits;\n                if (ii > 0) {\n                    shortU16Bytes[ii - 1] |= 128;\n                }\n            }\n            bytes.set(shortU16Bytes, offset);\n            return offset + shortU16Bytes.length;\n        }\n    });\nvar getShortU16Decoder = ()=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.createDecoder)({\n        maxSize: 3,\n        read: (bytes, offset)=>{\n            let value = 0;\n            let byteCount = 0;\n            while(++byteCount){\n                const byteIndex = byteCount - 1;\n                const currentByte = bytes[offset + byteIndex];\n                const nextSevenBits = 127 & currentByte;\n                value |= nextSevenBits << byteIndex * 7;\n                if ((currentByte & 128) === 0) {\n                    break;\n                }\n            }\n            return [\n                value,\n                offset + byteCount\n            ];\n        }\n    });\nvar getShortU16Codec = ()=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getShortU16Encoder(), getShortU16Decoder());\nvar getU128Encoder = (config = {})=>numberEncoderFactory({\n        config,\n        name: \"u128\",\n        range: [\n            0n,\n            BigInt(\"0xffffffffffffffffffffffffffffffff\")\n        ],\n        set: (view, value, le)=>{\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const rightMask = 0xffffffffffffffffn;\n            view.setBigUint64(leftOffset, BigInt(value) >> 64n, le);\n            view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);\n        },\n        size: 16\n    });\nvar getU128Decoder = (config = {})=>numberDecoderFactory({\n        config,\n        get: (view, le)=>{\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const left = view.getBigUint64(leftOffset, le);\n            const right = view.getBigUint64(rightOffset, le);\n            return (left << 64n) + right;\n        },\n        name: \"u128\",\n        size: 16\n    });\nvar getU128Codec = (config = {})=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getU128Encoder(config), getU128Decoder(config));\nvar getU16Encoder = (config = {})=>numberEncoderFactory({\n        config,\n        name: \"u16\",\n        range: [\n            0,\n            Number(\"0xffff\")\n        ],\n        set: (view, value, le)=>view.setUint16(0, Number(value), le),\n        size: 2\n    });\nvar getU16Decoder = (config = {})=>numberDecoderFactory({\n        config,\n        get: (view, le)=>view.getUint16(0, le),\n        name: \"u16\",\n        size: 2\n    });\nvar getU16Codec = (config = {})=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getU16Encoder(config), getU16Decoder(config));\nvar getU32Encoder = (config = {})=>numberEncoderFactory({\n        config,\n        name: \"u32\",\n        range: [\n            0,\n            Number(\"0xffffffff\")\n        ],\n        set: (view, value, le)=>view.setUint32(0, Number(value), le),\n        size: 4\n    });\nvar getU32Decoder = (config = {})=>numberDecoderFactory({\n        config,\n        get: (view, le)=>view.getUint32(0, le),\n        name: \"u32\",\n        size: 4\n    });\nvar getU32Codec = (config = {})=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getU32Encoder(config), getU32Decoder(config));\nvar getU64Encoder = (config = {})=>numberEncoderFactory({\n        config,\n        name: \"u64\",\n        range: [\n            0n,\n            BigInt(\"0xffffffffffffffff\")\n        ],\n        set: (view, value, le)=>view.setBigUint64(0, BigInt(value), le),\n        size: 8\n    });\nvar getU64Decoder = (config = {})=>numberDecoderFactory({\n        config,\n        get: (view, le)=>view.getBigUint64(0, le),\n        name: \"u64\",\n        size: 8\n    });\nvar getU64Codec = (config = {})=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getU64Encoder(config), getU64Decoder(config));\nvar getU8Encoder = ()=>numberEncoderFactory({\n        name: \"u8\",\n        range: [\n            0,\n            Number(\"0xff\")\n        ],\n        set: (view, value)=>view.setUint8(0, Number(value)),\n        size: 1\n    });\nvar getU8Decoder = ()=>numberDecoderFactory({\n        get: (view)=>view.getUint8(0),\n        name: \"u8\",\n        size: 1\n    });\nvar getU8Codec = ()=>(0,_solana_codecs_core__WEBPACK_IMPORTED_MODULE_1__.combineCodec)(getU8Encoder(), getU8Decoder());\n //# sourceMappingURL=index.node.mjs.map\n //# sourceMappingURL=index.node.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Ac29sYW5hL2NvZGVjcy1udW1iZXJzL2Rpc3QvaW5kZXgubm9kZS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF3RjtBQUNtRTtBQUUzSixvQkFBb0I7QUFDcEIsU0FBU08sOEJBQThCQyxnQkFBZ0IsRUFBRUMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEtBQUs7SUFDdEUsSUFBSUEsUUFBUUYsT0FBT0UsUUFBUUQsS0FBSztRQUM5QixNQUFNLElBQUlWLHVEQUFXQSxDQUFDQyxxRkFBeUNBLEVBQUU7WUFDL0RPO1lBQ0FFO1lBQ0FEO1lBQ0FFO1FBQ0Y7SUFDRjtBQUNGO0FBRUEsZ0JBQWdCO0FBQ2hCLElBQUlDLFNBQXlCLGFBQUgsR0FBSSxFQUFDQztJQUM3QkEsT0FBTyxDQUFDQSxPQUFPLENBQUMsU0FBUyxHQUFHLEVBQUUsR0FBRztJQUNqQ0EsT0FBTyxDQUFDQSxPQUFPLENBQUMsTUFBTSxHQUFHLEVBQUUsR0FBRztJQUM5QixPQUFPQTtBQUNULEdBQUdELFVBQVUsQ0FBQztBQUNkLFNBQVNFLGVBQWVDLE1BQU07SUFDNUIsT0FBT0EsUUFBUUMsV0FBVyxFQUFFLE9BQU8sTUFBSyxRQUFRO0FBQ2xEO0FBQ0EsU0FBU0MscUJBQXFCQyxLQUFLO0lBQ2pDLE9BQU9kLGtFQUFhQSxDQUFDO1FBQ25CZSxXQUFXRCxNQUFNRSxJQUFJO1FBQ3JCQyxPQUFNVixLQUFLLEVBQUVXLEtBQUssRUFBRUMsTUFBTTtZQUN4QixJQUFJTCxNQUFNTSxLQUFLLEVBQUU7Z0JBQ2ZqQiw4QkFBOEJXLE1BQU1PLElBQUksRUFBRVAsTUFBTU0sS0FBSyxDQUFDLEVBQUUsRUFBRU4sTUFBTU0sS0FBSyxDQUFDLEVBQUUsRUFBRWI7WUFDNUU7WUFDQSxNQUFNZSxjQUFjLElBQUlDLFlBQVlULE1BQU1FLElBQUk7WUFDOUNG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Q3ZDLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsYXctd29ya3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Ac29sYW5hL2NvZGVjcy1udW1iZXJzL2Rpc3QvaW5kZXgubm9kZS5tanM/NTllZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTb2xhbmFFcnJvciwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX05VTUJFUl9PVVRfT0ZfUkFOR0UgfSBmcm9tICdAc29sYW5hL2Vycm9ycyc7XG5pbXBvcnQgeyBjb21iaW5lQ29kZWMsIGNyZWF0ZURlY29kZXIsIGNyZWF0ZUVuY29kZXIsIGFzc2VydEJ5dGVBcnJheUlzTm90RW1wdHlGb3JDb2RlYywgYXNzZXJ0Qnl0ZUFycmF5SGFzRW5vdWdoQnl0ZXNGb3JDb2RlYyB9IGZyb20gJ0Bzb2xhbmEvY29kZWNzLWNvcmUnO1xuXG4vLyBzcmMvYXNzZXJ0aW9ucy50c1xuZnVuY3Rpb24gYXNzZXJ0TnVtYmVySXNCZXR3ZWVuRm9yQ29kZWMoY29kZWNEZXNjcmlwdGlvbiwgbWluLCBtYXgsIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA8IG1pbiB8fCB2YWx1ZSA+IG1heCkge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fTlVNQkVSX09VVF9PRl9SQU5HRSwge1xuICAgICAgY29kZWNEZXNjcmlwdGlvbixcbiAgICAgIG1heCxcbiAgICAgIG1pbixcbiAgICAgIHZhbHVlXG4gICAgfSk7XG4gIH1cbn1cblxuLy8gc3JjL2NvbW1vbi50c1xudmFyIEVuZGlhbiA9IC8qIEBfX1BVUkVfXyAqLyAoKEVuZGlhbjIpID0+IHtcbiAgRW5kaWFuMltFbmRpYW4yW1wiTGl0dGxlXCJdID0gMF0gPSBcIkxpdHRsZVwiO1xuICBFbmRpYW4yW0VuZGlhbjJbXCJCaWdcIl0gPSAxXSA9IFwiQmlnXCI7XG4gIHJldHVybiBFbmRpYW4yO1xufSkoRW5kaWFuIHx8IHt9KTtcbmZ1bmN0aW9uIGlzTGl0dGxlRW5kaWFuKGNvbmZpZykge1xuICByZXR1cm4gY29uZmlnPy5lbmRpYW4gPT09IDEgLyogQmlnICovID8gZmFsc2UgOiB0cnVlO1xufVxuZnVuY3Rpb24gbnVtYmVyRW5jb2RlckZhY3RvcnkoaW5wdXQpIHtcbiAgcmV0dXJuIGNyZWF0ZUVuY29kZXIoe1xuICAgIGZpeGVkU2l6ZTogaW5wdXQuc2l6ZSxcbiAgICB3cml0ZSh2YWx1ZSwgYnl0ZXMsIG9mZnNldCkge1xuICAgICAgaWYgKGlucHV0LnJhbmdlKSB7XG4gICAgICAgIGFzc2VydE51bWJlcklzQmV0d2VlbkZvckNvZGVjKGlucHV0Lm5hbWUsIGlucHV0LnJhbmdlWzBdLCBpbnB1dC5yYW5nZVsxXSwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgY29uc3QgYXJyYXlCdWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoaW5wdXQuc2l6ZSk7XG4gICAgICBpbnB1dC5zZXQobmV3IERhdGFWaWV3KGFycmF5QnVmZmVyKSwgdmFsdWUsIGlzTGl0dGxlRW5kaWFuKGlucHV0LmNvbmZpZykpO1xuICAgICAgYnl0ZXMuc2V0KG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKSwgb2Zmc2V0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgKyBpbnB1dC5zaXplO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBudW1iZXJEZWNvZGVyRmFjdG9yeShpbnB1dCkge1xuICByZXR1cm4gY3JlYXRlRGVjb2Rlcih7XG4gICAgZml4ZWRTaXplOiBpbnB1dC5zaXplLFxuICAgIHJlYWQoYnl0ZXMsIG9mZnNldCA9IDApIHtcbiAgICAgIGFzc2VydEJ5dGVBcnJheUlzTm90RW1wdHlGb3JDb2RlYyhpbnB1dC5uYW1lLCBieXRlcywgb2Zmc2V0KTtcbiAgICAgIGFzc2VydEJ5dGVBcnJheUhhc0Vub3VnaEJ5dGVzRm9yQ29kZWMoaW5wdXQubmFtZSwgaW5wdXQuc2l6ZSwgYnl0ZXMsIG9mZnNldCk7XG4gICAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KHRvQXJyYXlCdWZmZXIoYnl0ZXMsIG9mZnNldCwgaW5wdXQuc2l6ZSkpO1xuICAgICAgcmV0dXJuIFtpbnB1dC5nZXQodmlldywgaXNMaXR0bGVFbmRpYW4oaW5wdXQuY29uZmlnKSksIG9mZnNldCArIGlucHV0LnNpemVdO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiB0b0FycmF5QnVmZmVyKGJ5dGVzLCBvZmZzZXQsIGxlbmd0aCkge1xuICBjb25zdCBieXRlc09mZnNldCA9IGJ5dGVzLmJ5dGVPZmZzZXQgKyAob2Zmc2V0ID8/IDApO1xuICBjb25zdCBieXRlc0xlbmd0aCA9IGxlbmd0aCA/PyBieXRlcy5ieXRlTGVuZ3RoO1xuICByZXR1cm4gYnl0ZXMuYnVmZmVyLnNsaWNlKGJ5dGVzT2Zmc2V0LCBieXRlc09mZnNldCArIGJ5dGVzTGVuZ3RoKTtcbn1cblxuLy8gc3JjL2YzMi50c1xudmFyIGdldEYzMkVuY29kZXIgPSAoY29uZmlnID0ge30pID0+IG51bWJlckVuY29kZXJGYWN0b3J5KHtcbiAgY29uZmlnLFxuICBuYW1lOiBcImYzMlwiLFxuICBzZXQ6ICh2aWV3LCB2YWx1ZSwgbGUpID0+IHZpZXcuc2V0RmxvYXQzMigwLCBOdW1iZXIodmFsdWUpLCBsZSksXG4gIHNpemU6IDRcbn0pO1xudmFyIGdldEYzMkRlY29kZXIgPSAoY29uZmlnID0ge30pID0+IG51bWJlckRlY29kZXJGYWN0b3J5KHtcbiAgY29uZmlnLFxuICBnZXQ6ICh2aWV3LCBsZSkgPT4gdmlldy5nZXRGbG9hdDMyKDAsIGxlKSxcbiAgbmFtZTogXCJmMzJcIixcbiAgc2l6ZTogNFxufSk7XG52YXIgZ2V0RjMyQ29kZWMgPSAoY29uZmlnID0ge30pID0+IGNvbWJpbmVDb2RlYyhnZXRGMzJFbmNvZGVyKGNvbmZpZyksIGdldEYzMkRlY29kZXIoY29uZmlnKSk7XG52YXIgZ2V0RjY0RW5jb2RlciA9IChjb25maWcgPSB7fSkgPT4gbnVtYmVyRW5jb2RlckZhY3Rvcnkoe1xuICBjb25maWcsXG4gIG5hbWU6IFwiZjY0XCIsXG4gIHNldDogKHZpZXcsIHZhbHVlLCBsZSkgPT4gdmlldy5zZXRGbG9hdDY0KDAsIE51bWJlcih2YWx1ZSksIGxlKSxcbiAgc2l6ZTogOFxufSk7XG52YXIgZ2V0RjY0RGVjb2RlciA9IChjb25maWcgPSB7fSkgPT4gbnVtYmVyRGVjb2RlckZhY3Rvcnkoe1xuICBjb25maWcsXG4gIGdldDogKHZpZXcsIGxlKSA9PiB2aWV3LmdldEZsb2F0NjQoMCwgbGUpLFxuICBuYW1lOiBcImY2NFwiLFxuICBzaXplOiA4XG59KTtcbnZhciBnZXRGNjRDb2RlYyA9IChjb25maWcgPSB7fSkgPT4gY29tYmluZUNvZGVjKGdldEY2NEVuY29kZXIoY29uZmlnKSwgZ2V0RjY0RGVjb2Rlcihjb25maWcpKTtcbnZhciBnZXRJMTI4RW5jb2RlciA9IChjb25maWcgPSB7fSkgPT4gbnVtYmVyRW5jb2RlckZhY3Rvcnkoe1xuICBjb25maWcsXG4gIG5hbWU6IFwiaTEyOFwiLFxuICByYW5nZTogWy1CaWdJbnQoXCIweDdmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmXCIpIC0gMW4sIEJpZ0ludChcIjB4N2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZcIildLFxuICBzZXQ6ICh2aWV3LCB2YWx1ZSwgbGUpID0+IHtcbiAgICBjb25zdCBsZWZ0T2Zmc2V0ID0gbGUgPyA4IDogMDtcbiAgICBjb25zdCByaWdodE9mZnNldCA9IGxlID8gMCA6IDg7XG4gICAgY29uc3QgcmlnaHRNYXNrID0gMHhmZmZmZmZmZmZmZmZmZmZmbjtcbiAgICB2aWV3LnNldEJpZ0ludDY0KGxlZnRPZmZzZXQsIEJpZ0ludCh2YWx1ZSkgPj4gNjRuLCBsZSk7XG4gICAgdmlldy5zZXRCaWdVaW50NjQocmlnaHRPZmZzZXQsIEJpZ0ludCh2YWx1ZSkgJiByaWdodE1hc2ssIGxlKTtcbiAgfSxcbiAgc2l6ZTogMTZcbn0pO1xudmFyIGdldEkxMjhEZWNvZGVyID0gKGNvbmZpZyA9IHt9KSA9PiBudW1iZXJEZWNvZGVyRmFjdG9yeSh7XG4gIGNvbmZpZyxcbiAgZ2V0OiAodmlldywgbGUpID0+IHtcbiAgICBjb25zdCBsZWZ0T2Zmc2V0ID0gbGUgPyA4IDogMDtcbiAgICBjb25zdCByaWdodE9mZnNldCA9IGxlID8gMCA6IDg7XG4gICAgY29uc3QgbGVmdCA9IHZpZXcuZ2V0QmlnSW50NjQobGVmdE9mZnNldCwgbGUpO1xuICAgIGNvbnN0IHJpZ2h0ID0gdmlldy5nZXRCaWdVaW50NjQocmlnaHRPZmZzZXQsIGxlKTtcbiAgICByZXR1cm4gKGxlZnQgPDwgNjRuKSArIHJpZ2h0O1xuICB9LFxuICBuYW1lOiBcImkxMjhcIixcbiAgc2l6ZTogMTZcbn0pO1xudmFyIGdldEkxMjhDb2RlYyA9IChjb25maWcgPSB7fSkgPT4gY29tYmluZUNvZGVjKGdldEkxMjhFbmNvZGVyKGNvbmZpZyksIGdldEkxMjhEZWNvZGVyKGNvbmZpZykpO1xudmFyIGdldEkxNkVuY29kZXIgPSAoY29uZmlnID0ge30pID0+IG51bWJlckVuY29kZXJGYWN0b3J5KHtcbiAgY29uZmlnLFxuICBuYW1lOiBcImkxNlwiLFxuICByYW5nZTogWy1OdW1iZXIoXCIweDdmZmZcIikgLSAxLCBOdW1iZXIoXCIweDdmZmZcIildLFxuICBzZXQ6ICh2aWV3LCB2YWx1ZSwgbGUpID0+IHZpZXcuc2V0SW50MTYoMCwgTnVtYmVyKHZhbHVlKSwgbGUpLFxuICBzaXplOiAyXG59KTtcbnZhciBnZXRJMTZEZWNvZGVyID0gKGNvbmZpZyA9IHt9KSA9PiBudW1iZXJEZWNvZGVyRmFjdG9yeSh7XG4gIGNvbmZpZyxcbiAgZ2V0OiAodmlldywgbGUpID0+IHZpZXcuZ2V0SW50MTYoMCwgbGUpLFxuICBuYW1lOiBcImkxNlwiLFxuICBzaXplOiAyXG59KTtcbnZhciBnZXRJMTZDb2RlYyA9IChjb25maWcgPSB7fSkgPT4gY29tYmluZUNvZGVjKGdldEkxNkVuY29kZXIoY29uZmlnKSwgZ2V0STE2RGVjb2Rlcihjb25maWcpKTtcbnZhciBnZXRJMzJFbmNvZGVyID0gKGNvbmZpZyA9IHt9KSA9PiBudW1iZXJFbmNvZGVyRmFjdG9yeSh7XG4gIGNvbmZpZyxcbiAgbmFtZTogXCJpMzJcIixcbiAgcmFuZ2U6IFstTnVtYmVyKFwiMHg3ZmZmZmZmZlwiKSAtIDEsIE51bWJlcihcIjB4N2ZmZmZmZmZcIildLFxuICBzZXQ6ICh2aWV3LCB2YWx1ZSwgbGUpID0+IHZpZXcuc2V0SW50MzIoMCwgTnVtYmVyKHZhbHVlKSwgbGUpLFxuICBzaXplOiA0XG59KTtcbnZhciBnZXRJMzJEZWNvZGVyID0gKGNvbmZpZyA9IHt9KSA9PiBudW1iZXJEZWNvZGVyRmFjdG9yeSh7XG4gIGNvbmZpZyxcbiAgZ2V0OiAodmlldywgbGUpID0+IHZpZXcuZ2V0SW50MzIoMCwgbGUpLFxuICBuYW1lOiBcImkzMlwiLFxuICBzaXplOiA0XG59KTtcbnZhciBnZXRJMzJDb2RlYyA9IChjb25maWcgPSB7fSkgPT4gY29tYmluZUNvZGVjKGdldEkzMkVuY29kZXIoY29uZmlnKSwgZ2V0STMyRGVjb2Rlcihjb25maWcpKTtcbnZhciBnZXRJNjRFbmNvZGVyID0gKGNvbmZpZyA9IHt9KSA9PiBudW1iZXJFbmNvZGVyRmFjdG9yeSh7XG4gIGNvbmZpZyxcbiAgbmFtZTogXCJpNjRcIixcbiAgcmFuZ2U6IFstQmlnSW50KFwiMHg3ZmZmZmZmZmZmZmZmZmZmXCIpIC0gMW4sIEJpZ0ludChcIjB4N2ZmZmZmZmZmZmZmZmZmZlwiKV0sXG4gIHNldDogKHZpZXcsIHZhbHVlLCBsZSkgPT4gdmlldy5zZXRCaWdJbnQ2NCgwLCBCaWdJbnQodmFsdWUpLCBsZSksXG4gIHNpemU6IDhcbn0pO1xudmFyIGdldEk2NERlY29kZXIgPSAoY29uZmlnID0ge30pID0+IG51bWJlckRlY29kZXJGYWN0b3J5KHtcbiAgY29uZmlnLFxuICBnZXQ6ICh2aWV3LCBsZSkgPT4gdmlldy5nZXRCaWdJbnQ2NCgwLCBsZSksXG4gIG5hbWU6IFwiaTY0XCIsXG4gIHNpemU6IDhcbn0pO1xudmFyIGdldEk2NENvZGVjID0gKGNvbmZpZyA9IHt9KSA9PiBjb21iaW5lQ29kZWMoZ2V0STY0RW5jb2Rlcihjb25maWcpLCBnZXRJNjREZWNvZGVyKGNvbmZpZykpO1xudmFyIGdldEk4RW5jb2RlciA9ICgpID0+IG51bWJlckVuY29kZXJGYWN0b3J5KHtcbiAgbmFtZTogXCJpOFwiLFxuICByYW5nZTogWy1OdW1iZXIoXCIweDdmXCIpIC0gMSwgTnVtYmVyKFwiMHg3ZlwiKV0sXG4gIHNldDogKHZpZXcsIHZhbHVlKSA9PiB2aWV3LnNldEludDgoMCwgTnVtYmVyKHZhbHVlKSksXG4gIHNpemU6IDFcbn0pO1xudmFyIGdldEk4RGVjb2RlciA9ICgpID0+IG51bWJlckRlY29kZXJGYWN0b3J5KHtcbiAgZ2V0OiAodmlldykgPT4gdmlldy5nZXRJbnQ4KDApLFxuICBuYW1lOiBcImk4XCIsXG4gIHNpemU6IDFcbn0pO1xudmFyIGdldEk4Q29kZWMgPSAoKSA9PiBjb21iaW5lQ29kZWMoZ2V0SThFbmNvZGVyKCksIGdldEk4RGVjb2RlcigpKTtcbnZhciBnZXRTaG9ydFUxNkVuY29kZXIgPSAoKSA9PiBjcmVhdGVFbmNvZGVyKHtcbiAgZ2V0U2l6ZUZyb21WYWx1ZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlIDw9IDEyNykgcmV0dXJuIDE7XG4gICAgaWYgKHZhbHVlIDw9IDE2MzgzKSByZXR1cm4gMjtcbiAgICByZXR1cm4gMztcbiAgfSxcbiAgbWF4U2l6ZTogMyxcbiAgd3JpdGU6ICh2YWx1ZSwgYnl0ZXMsIG9mZnNldCkgPT4ge1xuICAgIGFzc2VydE51bWJlcklzQmV0d2VlbkZvckNvZGVjKFwic2hvcnRVMTZcIiwgMCwgNjU1MzUsIHZhbHVlKTtcbiAgICBjb25zdCBzaG9ydFUxNkJ5dGVzID0gWzBdO1xuICAgIGZvciAobGV0IGlpID0gMDsgOyBpaSArPSAxKSB7XG4gICAgICBjb25zdCBhbGlnbmVkVmFsdWUgPSBOdW1iZXIodmFsdWUpID4+IGlpICogNztcbiAgICAgIGlmIChhbGlnbmVkVmFsdWUgPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjb25zdCBuZXh0U2V2ZW5CaXRzID0gMTI3ICYgYWxpZ25lZFZhbHVlO1xuICAgICAgc2hvcnRVMTZCeXRlc1tpaV0gPSBuZXh0U2V2ZW5CaXRzO1xuICAgICAgaWYgKGlpID4gMCkge1xuICAgICAgICBzaG9ydFUxNkJ5dGVzW2lpIC0gMV0gfD0gMTI4O1xuICAgICAgfVxuICAgIH1cbiAgICBieXRlcy5zZXQoc2hvcnRVMTZCeXRlcywgb2Zmc2V0KTtcbiAgICByZXR1cm4gb2Zmc2V0ICsgc2hvcnRVMTZCeXRlcy5sZW5ndGg7XG4gIH1cbn0pO1xudmFyIGdldFNob3J0VTE2RGVjb2RlciA9ICgpID0+IGNyZWF0ZURlY29kZXIoe1xuICBtYXhTaXplOiAzLFxuICByZWFkOiAoYnl0ZXMsIG9mZnNldCkgPT4ge1xuICAgIGxldCB2YWx1ZSA9IDA7XG4gICAgbGV0IGJ5dGVDb3VudCA9IDA7XG4gICAgd2hpbGUgKCsrYnl0ZUNvdW50KSB7XG4gICAgICBjb25zdCBieXRlSW5kZXggPSBieXRlQ291bnQgLSAxO1xuICAgICAgY29uc3QgY3VycmVudEJ5dGUgPSBieXRlc1tvZmZzZXQgKyBieXRlSW5kZXhdO1xuICAgICAgY29uc3QgbmV4dFNldmVuQml0cyA9IDEyNyAmIGN1cnJlbnRCeXRlO1xuICAgICAgdmFsdWUgfD0gbmV4dFNldmVuQml0cyA8PCBieXRlSW5kZXggKiA3O1xuICAgICAgaWYgKChjdXJyZW50Qnl0ZSAmIDEyOCkgPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbdmFsdWUsIG9mZnNldCArIGJ5dGVDb3VudF07XG4gIH1cbn0pO1xudmFyIGdldFNob3J0VTE2Q29kZWMgPSAoKSA9PiBjb21iaW5lQ29kZWMoZ2V0U2hvcnRVMTZFbmNvZGVyKCksIGdldFNob3J0VTE2RGVjb2RlcigpKTtcbnZhciBnZXRVMTI4RW5jb2RlciA9IChjb25maWcgPSB7fSkgPT4gbnVtYmVyRW5jb2RlckZhY3Rvcnkoe1xuICBjb25maWcsXG4gIG5hbWU6IFwidTEyOFwiLFxuICByYW5nZTogWzBuLCBCaWdJbnQoXCIweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmXCIpXSxcbiAgc2V0OiAodmlldywgdmFsdWUsIGxlKSA9PiB7XG4gICAgY29uc3QgbGVmdE9mZnNldCA9IGxlID8gOCA6IDA7XG4gICAgY29uc3QgcmlnaHRPZmZzZXQgPSBsZSA/IDAgOiA4O1xuICAgIGNvbnN0IHJpZ2h0TWFzayA9IDB4ZmZmZmZmZmZmZmZmZmZmZm47XG4gICAgdmlldy5zZXRCaWdVaW50NjQobGVmdE9mZnNldCwgQmlnSW50KHZhbHVlKSA+PiA2NG4sIGxlKTtcbiAgICB2aWV3LnNldEJpZ1VpbnQ2NChyaWdodE9mZnNldCwgQmlnSW50KHZhbHVlKSAmIHJpZ2h0TWFzaywgbGUpO1xuICB9LFxuICBzaXplOiAxNlxufSk7XG52YXIgZ2V0VTEyOERlY29kZXIgPSAoY29uZmlnID0ge30pID0+IG51bWJlckRlY29kZXJGYWN0b3J5KHtcbiAgY29uZmlnLFxuICBnZXQ6ICh2aWV3LCBsZSkgPT4ge1xuICAgIGNvbnN0IGxlZnRPZmZzZXQgPSBsZSA/IDggOiAwO1xuICAgIGNvbnN0IHJpZ2h0T2Zmc2V0ID0gbGUgPyAwIDogODtcbiAgICBjb25zdCBsZWZ0ID0gdmlldy5nZXRCaWdVaW50NjQobGVmdE9mZnNldCwgbGUpO1xuICAgIGNvbnN0IHJpZ2h0ID0gdmlldy5nZXRCaWdVaW50NjQocmlnaHRPZmZzZXQsIGxlKTtcbiAgICByZXR1cm4gKGxlZnQgPDwgNjRuKSArIHJpZ2h0O1xuICB9LFxuICBuYW1lOiBcInUxMjhcIixcbiAgc2l6ZTogMTZcbn0pO1xudmFyIGdldFUxMjhDb2RlYyA9IChjb25maWcgPSB7fSkgPT4gY29tYmluZUNvZGVjKGdldFUxMjhFbmNvZGVyKGNvbmZpZyksIGdldFUxMjhEZWNvZGVyKGNvbmZpZykpO1xudmFyIGdldFUxNkVuY29kZXIgPSAoY29uZmlnID0ge30pID0+IG51bWJlckVuY29kZXJGYWN0b3J5KHtcbiAgY29uZmlnLFxuICBuYW1lOiBcInUxNlwiLFxuICByYW5nZTogWzAsIE51bWJlcihcIjB4ZmZmZlwiKV0sXG4gIHNldDogKHZpZXcsIHZhbHVlLCBsZSkgPT4gdmlldy5zZXRVaW50MTYoMCwgTnVtYmVyKHZhbHVlKSwgbGUpLFxuICBzaXplOiAyXG59KTtcbnZhciBnZXRVMTZEZWNvZGVyID0gKGNvbmZpZyA9IHt9KSA9PiBudW1iZXJEZWNvZGVyRmFjdG9yeSh7XG4gIGNvbmZpZyxcbiAgZ2V0OiAodmlldywgbGUpID0+IHZpZXcuZ2V0VWludDE2KDAsIGxlKSxcbiAgbmFtZTogXCJ1MTZcIixcbiAgc2l6ZTogMlxufSk7XG52YXIgZ2V0VTE2Q29kZWMgPSAoY29uZmlnID0ge30pID0+IGNvbWJpbmVDb2RlYyhnZXRVMTZFbmNvZGVyKGNvbmZpZyksIGdldFUxNkRlY29kZXIoY29uZmlnKSk7XG52YXIgZ2V0VTMyRW5jb2RlciA9IChjb25maWcgPSB7fSkgPT4gbnVtYmVyRW5jb2RlckZhY3Rvcnkoe1xuICBjb25maWcsXG4gIG5hbWU6IFwidTMyXCIsXG4gIHJhbmdlOiBbMCwgTnVtYmVyKFwiMHhmZmZmZmZmZlwiKV0sXG4gIHNldDogKHZpZXcsIHZhbHVlLCBsZSkgPT4gdmlldy5zZXRVaW50MzIoMCwgTnVtYmVyKHZhbHVlKSwgbGUpLFxuICBzaXplOiA0XG59KTtcbnZhciBnZXRVMzJEZWNvZGVyID0gKGNvbmZpZyA9IHt9KSA9PiBudW1iZXJEZWNvZGVyRmFjdG9yeSh7XG4gIGNvbmZpZyxcbiAgZ2V0OiAodmlldywgbGUpID0+IHZpZXcuZ2V0VWludDMyKDAsIGxlKSxcbiAgbmFtZTogXCJ1MzJcIixcbiAgc2l6ZTogNFxufSk7XG52YXIgZ2V0VTMyQ29kZWMgPSAoY29uZmlnID0ge30pID0+IGNvbWJpbmVDb2RlYyhnZXRVMzJFbmNvZGVyKGNvbmZpZyksIGdldFUzMkRlY29kZXIoY29uZmlnKSk7XG52YXIgZ2V0VTY0RW5jb2RlciA9IChjb25maWcgPSB7fSkgPT4gbnVtYmVyRW5jb2RlckZhY3Rvcnkoe1xuICBjb25maWcsXG4gIG5hbWU6IFwidTY0XCIsXG4gIHJhbmdlOiBbMG4sIEJpZ0ludChcIjB4ZmZmZmZmZmZmZmZmZmZmZlwiKV0sXG4gIHNldDogKHZpZXcsIHZhbHVlLCBsZSkgPT4gdmlldy5zZXRCaWdVaW50NjQoMCwgQmlnSW50KHZhbHVlKSwgbGUpLFxuICBzaXplOiA4XG59KTtcbnZhciBnZXRVNjREZWNvZGVyID0gKGNvbmZpZyA9IHt9KSA9PiBudW1iZXJEZWNvZGVyRmFjdG9yeSh7XG4gIGNvbmZpZyxcbiAgZ2V0OiAodmlldywgbGUpID0+IHZpZXcuZ2V0QmlnVWludDY0KDAsIGxlKSxcbiAgbmFtZTogXCJ1NjRcIixcbiAgc2l6ZTogOFxufSk7XG52YXIgZ2V0VTY0Q29kZWMgPSAoY29uZmlnID0ge30pID0+IGNvbWJpbmVDb2RlYyhnZXRVNjRFbmNvZGVyKGNvbmZpZyksIGdldFU2NERlY29kZXIoY29uZmlnKSk7XG52YXIgZ2V0VThFbmNvZGVyID0gKCkgPT4gbnVtYmVyRW5jb2RlckZhY3Rvcnkoe1xuICBuYW1lOiBcInU4XCIsXG4gIHJhbmdlOiBbMCwgTnVtYmVyKFwiMHhmZlwiKV0sXG4gIHNldDogKHZpZXcsIHZhbHVlKSA9PiB2aWV3LnNldFVpbnQ4KDAsIE51bWJlcih2YWx1ZSkpLFxuICBzaXplOiAxXG59KTtcbnZhciBnZXRVOERlY29kZXIgPSAoKSA9PiBudW1iZXJEZWNvZGVyRmFjdG9yeSh7XG4gIGdldDogKHZpZXcpID0+IHZpZXcuZ2V0VWludDgoMCksXG4gIG5hbWU6IFwidThcIixcbiAgc2l6ZTogMVxufSk7XG52YXIgZ2V0VThDb2RlYyA9ICgpID0+IGNvbWJpbmVDb2RlYyhnZXRVOEVuY29kZXIoKSwgZ2V0VThEZWNvZGVyKCkpO1xuXG5leHBvcnQgeyBFbmRpYW4sIGFzc2VydE51bWJlcklzQmV0d2VlbkZvckNvZGVjLCBnZXRGMzJDb2RlYywgZ2V0RjMyRGVjb2RlciwgZ2V0RjMyRW5jb2RlciwgZ2V0RjY0Q29kZWMsIGdldEY2NERlY29kZXIsIGdldEY2NEVuY29kZXIsIGdldEkxMjhDb2RlYywgZ2V0STEyOERlY29kZXIsIGdldEkxMjhFbmNvZGVyLCBnZXRJMTZDb2RlYywgZ2V0STE2RGVjb2RlciwgZ2V0STE2RW5jb2RlciwgZ2V0STMyQ29kZWMsIGdldEkzMkRlY29kZXIsIGdldEkzMkVuY29kZXIsIGdldEk2NENvZGVjLCBnZXRJNjREZWNvZGVyLCBnZXRJNjRFbmNvZGVyLCBnZXRJOENvZGVjLCBnZXRJOERlY29kZXIsIGdldEk4RW5jb2RlciwgZ2V0U2hvcnRVMTZDb2RlYywgZ2V0U2hvcnRVMTZEZWNvZGVyLCBnZXRTaG9ydFUxNkVuY29kZXIsIGdldFUxMjhDb2RlYywgZ2V0VTEyOERlY29kZXIsIGdldFUxMjhFbmNvZGVyLCBnZXRVMTZDb2RlYywgZ2V0VTE2RGVjb2RlciwgZ2V0VTE2RW5jb2RlciwgZ2V0VTMyQ29kZWMsIGdldFUzMkRlY29kZXIsIGdldFUzMkVuY29kZXIsIGdldFU2NENvZGVjLCBnZXRVNjREZWNvZGVyLCBnZXRVNjRFbmNvZGVyLCBnZXRVOENvZGVjLCBnZXRVOERlY29kZXIsIGdldFU4RW5jb2RlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubm9kZS5tanMubWFwXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5ub2RlLm1qcy5tYXAiXSwibmFtZXMiOlsiU29sYW5hRXJyb3IiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fTlVNQkVSX09VVF9PRl9SQU5HRSIsImNvbWJpbmVDb2RlYyIsImNyZWF0ZURlY29kZXIiLCJjcmVhdGVFbmNvZGVyIiwiYXNzZXJ0Qnl0ZUFycmF5SXNOb3RFbXB0eUZvckNvZGVjIiwiYXNzZXJ0Qnl0ZUFycmF5SGFzRW5vdWdoQnl0ZXNGb3JDb2RlYyIsImFzc2VydE51bWJlcklzQmV0d2VlbkZvckNvZGVjIiwiY29kZWNEZXNjcmlwdGlvbiIsIm1pbiIsIm1heCIsInZhbHVlIiwiRW5kaWFuIiwiRW5kaWFuMiIsImlzTGl0dGxlRW5kaWFuIiwiY29uZmlnIiwiZW5kaWFuIiwibnVtYmVyRW5jb2RlckZhY3RvcnkiLCJpbnB1dCIsImZpeGVkU2l6ZSIsInNpemUiLCJ3cml0ZSIsImJ5dGVzIiwib2Zmc2V0IiwicmFuZ2UiLCJuYW1lIiwiYXJyYXlCdWZmZXIiLCJBcnJheUJ1ZmZlciIsInNldCIsIkRhdGFWaWV3IiwiVWludDhBcnJheSIsIm51bWJlckRlY29kZXJGYWN0b3J5IiwicmVhZCIsInZpZXciLCJ0b0FycmF5QnVmZmVyIiwiZ2V0IiwibGVuZ3RoIiwiYnl0ZXNPZmZzZXQiLCJieXRlT2Zmc2V0IiwiYnl0ZXNMZW5ndGgiLCJieXRlTGVuZ3RoIiwiYnVmZmVyIiwic2xpY2UiLCJnZXRGMzJFbmNvZGVyIiwibGUiLCJzZXRGbG9hdDMyIiwiTnVtYmVyIiwiZ2V0RjMyRGVjb2RlciIsImdldEZsb2F0MzIiLCJnZXRGMzJDb2RlYyIsImdldEY2NEVuY29kZXIiLCJzZXRGbG9hdDY0IiwiZ2V0RjY0RGVjb2RlciIsImdldEZsb2F0NjQiLCJnZXRGNjRDb2RlYyIsImdldEkxMjhFbmNvZGVyIiwiQmlnSW50IiwibGVmdE9mZnNldCIsInJpZ2h0T2Zmc2V0IiwicmlnaHRNYXNrIiwic2V0QmlnSW50NjQiLCJzZXRCaWdVaW50NjQiLCJnZXRJMTI4RGVjb2RlciIsImxlZnQiLCJnZXRCaWdJbnQ2NCIsInJpZ2h0IiwiZ2V0QmlnVWludDY0IiwiZ2V0STEyOENvZGVjIiwiZ2V0STE2RW5jb2RlciIsInNldEludDE2IiwiZ2V0STE2RGVjb2RlciIsImdldEludDE2IiwiZ2V0STE2Q29kZWMiLCJnZXRJMzJFbmNvZGVyIiwic2V0SW50MzIiLCJnZXRJMzJEZWNvZGVyIiwiZ2V0SW50MzIiLCJnZXRJMzJDb2RlYyIsImdldEk2NEVuY29kZXIiLCJnZXRJNjREZWNvZGVyIiwiZ2V0STY0Q29kZWMiLCJnZXRJOEVuY29kZXIiLCJzZXRJbnQ4IiwiZ2V0SThEZWNvZGVyIiwiZ2V0SW50OCIsImdldEk4Q29kZWMiLCJnZXRTaG9ydFUxNkVuY29kZXIiLCJnZXRTaXplRnJvbVZhbHVlIiwibWF4U2l6ZSIsInNob3J0VTE2Qnl0ZXMiLCJpaSIsImFsaWduZWRWYWx1ZSIsIm5leHRTZXZlbkJpdHMiLCJnZXRTaG9ydFUxNkRlY29kZXIiLCJieXRlQ291bnQiLCJieXRlSW5kZXgiLCJjdXJyZW50Qnl0ZSIsImdldFNob3J0VTE2Q29kZWMiLCJnZXRVMTI4RW5jb2RlciIsImdldFUxMjhEZWNvZGVyIiwiZ2V0VTEyOENvZGVjIiwiZ2V0VTE2RW5jb2RlciIsInNldFVpbnQxNiIsImdldFUxNkRlY29kZXIiLCJnZXRVaW50MTYiLCJnZXRVMTZDb2RlYyIsImdldFUzMkVuY29kZXIiLCJzZXRVaW50MzIiLCJnZXRVMzJEZWNvZGVyIiwiZ2V0VWludDMyIiwiZ2V0VTMyQ29kZWMiLCJnZXRVNjRFbmNvZGVyIiwiZ2V0VTY0RGVjb2RlciIsImdldFU2NENvZGVjIiwiZ2V0VThFbmNvZGVyIiwic2V0VWludDgiLCJnZXRVOERlY29kZXIiLCJnZXRVaW50OCIsImdldFU4Q29kZWMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/web3.js/node_modules/@solana/codecs-numbers/dist/index.node.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@solana/web3.js/node_modules/@solana/errors/dist/index.node.mjs":
/*!**************************************************************************************!*\
  !*** ./node_modules/@solana/web3.js/node_modules/@solana/errors/dist/index.node.mjs ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND: () => (/* binding */ SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND),\n/* harmony export */   SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED: () => (/* binding */ SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED),\n/* harmony export */   SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT: () => (/* binding */ SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT),\n/* harmony export */   SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT: () => (/* binding */ SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT),\n/* harmony export */   SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND: () => (/* binding */ SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED: () => (/* binding */ SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS: () => (/* binding */ SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH: () => (/* binding */ SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY: () => (/* binding */ SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS: () => (/* binding */ SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE: () => (/* binding */ SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__MALFORMED_PDA: () => (/* binding */ SOLANA_ERROR__ADDRESSES__MALFORMED_PDA),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED: () => (/* binding */ SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED: () => (/* binding */ SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER: () => (/* binding */ SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER),\n/* harmony export */   SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED: () => (/* binding */ SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED),\n/* harmony export */   SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY: () => (/* binding */ SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY),\n/* harmony export */   SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS: () => (/* binding */ SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS),\n/* harmony export */   SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL: () => (/* binding */ SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL),\n/* harmony export */   SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH: () => (/* binding */ SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH),\n/* harmony export */   SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH: () => (/* binding */ SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH),\n/* harmony export */   SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH: () => (/* binding */ SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH),\n/* harmony export */   SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH: () => (/* binding */ SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH),\n/* harmony export */   SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH: () => (/* binding */ SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH),\n/* harmony export */   SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH: () => (/* binding */ SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH),\n/* harmony export */   SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE: () => (/* binding */ SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE),\n/* harmony export */   SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH: () => (/* binding */ SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH),\n/* harmony export */   SOLANA_ERROR__CODECS__INVALID_CONSTANT: () => (/* binding */ SOLANA_ERROR__CODECS__INVALID_CONSTANT),\n/* harmony export */   SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT: () => (/* binding */ SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT),\n/* harmony export */   SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT: () => (/* binding */ SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT),\n/* harmony export */   SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT: () => (/* binding */ SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT),\n/* harmony export */   SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS: () => (/* binding */ SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS),\n/* harmony export */   SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE: () => (/* binding */ SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE),\n/* harmony export */   SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES: () => (/* binding */ SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES),\n/* harmony export */   SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED: () => (/* binding */ SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR: () => (/* binding */ SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS: () => (/* binding */ SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA: () => (/* binding */ SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA),\n/* harmony export */   SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH: () => (/* binding */ SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH),\n/* harmony export */   SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH: () => (/* binding */ SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH),\n/* harmony export */   SOLANA_ERROR__INVALID_NONCE: () => (/* binding */ SOLANA_ERROR__INVALID_NONCE),\n/* harmony export */   SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING: () => (/* binding */ SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING),\n/* harmony export */   SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED: () => (/* binding */ SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED),\n/* harmony export */   SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE: () => (/* binding */ SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE),\n/* harmony export */   SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING: () => (/* binding */ SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING),\n/* harmony export */   SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE: () => (/* binding */ SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR: () => (/* binding */ SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__INVALID_PARAMS: () => (/* binding */ SOLANA_ERROR__JSON_RPC__INVALID_PARAMS),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__INVALID_REQUEST: () => (/* binding */ SOLANA_ERROR__JSON_RPC__INVALID_REQUEST),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND: () => (/* binding */ SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__PARSE_ERROR: () => (/* binding */ SOLANA_ERROR__JSON_RPC__PARSE_ERROR),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SCAN_ERROR: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SCAN_ERROR),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE),\n/* harmony export */   SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION: () => (/* binding */ SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION),\n/* harmony export */   SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH: () => (/* binding */ SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH),\n/* harmony export */   SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH: () => (/* binding */ SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH),\n/* harmony export */   SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH: () => (/* binding */ SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH),\n/* harmony export */   SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY: () => (/* binding */ SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY),\n/* harmony export */   SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__MALFORMED_BIGINT_STRING: () => (/* binding */ SOLANA_ERROR__MALFORMED_BIGINT_STRING),\n/* harmony export */   SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR: () => (/* binding */ SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR),\n/* harmony export */   SOLANA_ERROR__MALFORMED_NUMBER_STRING: () => (/* binding */ SOLANA_ERROR__MALFORMED_NUMBER_STRING),\n/* harmony export */   SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND: () => (/* binding */ SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND),\n/* harmony export */   SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN: () => (/* binding */ SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN),\n/* harmony export */   SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED: () => (/* binding */ SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED),\n/* harmony export */   SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED: () => (/* binding */ SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED),\n/* harmony export */   SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT: () => (/* binding */ SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT),\n/* harmony export */   SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID: () => (/* binding */ SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID),\n/* harmony export */   SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD: () => (/* binding */ SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD),\n/* harmony export */   SOLANA_ERROR__RPC__INTEGER_OVERFLOW: () => (/* binding */ SOLANA_ERROR__RPC__INTEGER_OVERFLOW),\n/* harmony export */   SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR: () => (/* binding */ SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR),\n/* harmony export */   SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN: () => (/* binding */ SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN),\n/* harmony export */   SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS: () => (/* binding */ SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS),\n/* harmony export */   SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER: () => (/* binding */ SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER),\n/* harmony export */   SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER: () => (/* binding */ SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER),\n/* harmony export */   SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER: () => (/* binding */ SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER),\n/* harmony export */   SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER: () => (/* binding */ SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER),\n/* harmony export */   SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER: () => (/* binding */ SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER),\n/* harmony export */   SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER: () => (/* binding */ SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER),\n/* harmony export */   SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER: () => (/* binding */ SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER),\n/* harmony export */   SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER: () => (/* binding */ SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER),\n/* harmony export */   SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS: () => (/* binding */ SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS),\n/* harmony export */   SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING: () => (/* binding */ SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING),\n/* harmony export */   SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED: () => (/* binding */ SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED),\n/* harmony export */   SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY: () => (/* binding */ SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY),\n/* harmony export */   SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED: () => (/* binding */ SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED),\n/* harmony export */   SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT: () => (/* binding */ SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT),\n/* harmony export */   SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED: () => (/* binding */ SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED),\n/* harmony export */   SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED: () => (/* binding */ SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED),\n/* harmony export */   SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED: () => (/* binding */ SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED),\n/* harmony export */   SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED: () => (/* binding */ SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED),\n/* harmony export */   SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED: () => (/* binding */ SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED),\n/* harmony export */   SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT: () => (/* binding */ SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION: () => (/* binding */ SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING: () => (/* binding */ SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES: () => (/* binding */ SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT: () => (/* binding */ SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME: () => (/* binding */ SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME: () => (/* binding */ SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING: () => (/* binding */ SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING: () => (/* binding */ SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND: () => (/* binding */ SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT: () => (/* binding */ SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT: () => (/* binding */ SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING: () => (/* binding */ SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING: () => (/* binding */ SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE: () => (/* binding */ SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING: () => (/* binding */ SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES: () => (/* binding */ SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE: () => (/* binding */ SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH: () => (/* binding */ SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING: () => (/* binding */ SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING),\n/* harmony export */   SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE: () => (/* binding */ SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE),\n/* harmony export */   SolanaError: () => (/* binding */ SolanaError),\n/* harmony export */   getSolanaErrorFromInstructionError: () => (/* binding */ getSolanaErrorFromInstructionError),\n/* harmony export */   getSolanaErrorFromJsonRpcError: () => (/* binding */ getSolanaErrorFromJsonRpcError),\n/* harmony export */   getSolanaErrorFromTransactionError: () => (/* binding */ getSolanaErrorFromTransactionError),\n/* harmony export */   isSolanaError: () => (/* binding */ isSolanaError),\n/* harmony export */   safeCaptureStackTrace: () => (/* binding */ safeCaptureStackTrace)\n/* harmony export */ });\n// src/codes.ts\nvar SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED = 1;\nvar SOLANA_ERROR__INVALID_NONCE = 2;\nvar SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND = 3;\nvar SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE = 4;\nvar SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH = 5;\nvar SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE = 6;\nvar SOLANA_ERROR__MALFORMED_BIGINT_STRING = 7;\nvar SOLANA_ERROR__MALFORMED_NUMBER_STRING = 8;\nvar SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE = 9;\nvar SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR = 10;\nvar SOLANA_ERROR__JSON_RPC__PARSE_ERROR = -32700;\nvar SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR = -32603;\nvar SOLANA_ERROR__JSON_RPC__INVALID_PARAMS = -32602;\nvar SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND = -32601;\nvar SOLANA_ERROR__JSON_RPC__INVALID_REQUEST = -32600;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED = -32016;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION = -32015;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET = -32014;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH = -32013;\nvar SOLANA_ERROR__JSON_RPC__SCAN_ERROR = -32012;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE = -32011;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX = -32010;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED = -32009;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT = -32008;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED = -32007;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE = -32006;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY = -32005;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE = -32004;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE = -32003;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE = -32002;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP = -32001;\nvar SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH = 28e5;\nvar SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE = 2800001;\nvar SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS = 2800002;\nvar SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY = 2800003;\nvar SOLANA_ERROR__ADDRESSES__MALFORMED_PDA = 2800004;\nvar SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE = 2800005;\nvar SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED = 2800006;\nvar SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED = 2800007;\nvar SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE = 2800008;\nvar SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED = 2800009;\nvar SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER = 2800010;\nvar SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS = 2800011;\nvar SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND = 323e4;\nvar SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND = 32300001;\nvar SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT = 3230002;\nvar SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT = 3230003;\nvar SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED = 3230004;\nvar SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT = 361e4;\nvar SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED = 3610001;\nvar SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED = 3610002;\nvar SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED = 3610003;\nvar SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED = 3610004;\nvar SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED = 3610005;\nvar SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED = 3610006;\nvar SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY = 3610007;\nvar SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED = 3611e3;\nvar SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH = 3704e3;\nvar SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH = 3704001;\nvar SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH = 3704002;\nvar SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE = 3704003;\nvar SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY = 3704004;\nvar SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS = 4128e3;\nvar SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA = 4128001;\nvar SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH = 4128002;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN = 4615e3;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR = 4615001;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT = 4615002;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA = 4615003;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA = 4615004;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL = 4615005;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS = 4615006;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID = 4615007;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE = 4615008;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED = 4615009;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT = 4615010;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION = 4615011;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID = 4615012;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND = 4615013;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED = 4615014;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE = 4615015;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED = 4615016;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX = 4615017;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED = 4615018;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED = 4615019;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS = 4615020;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED = 4615021;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE = 4615022;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED = 4615023;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 4615024;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC = 4615025;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM = 4615026;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR = 4615027;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED = 4615028;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE = 4615029;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT = 4615030;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID = 4615031;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH = 4615032;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT = 4615033;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED = 4615034;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED = 4615035;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS = 4615036;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC = 4615037;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED = 4615038;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION = 4615039;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE = 4615040;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE = 4615041;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE = 4615042;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE = 4615043;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY = 4615044;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR = 4615045;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT = 4615046;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER = 4615047;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW = 4615048;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR = 4615049;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER = 4615050;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED = 4615051;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED = 4615052;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED = 4615053;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS = 4615054;\nvar SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS = 5508e3;\nvar SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER = 5508001;\nvar SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER = 5508002;\nvar SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER = 5508003;\nvar SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER = 5508004;\nvar SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER = 5508005;\nvar SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER = 5508006;\nvar SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER = 5508007;\nvar SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER = 5508008;\nvar SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS = 5508009;\nvar SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING = 5508010;\nvar SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED = 5508011;\nvar SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES = 5663e3;\nvar SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE = 5663001;\nvar SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME = 5663002;\nvar SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME = 5663003;\nvar SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE = 5663004;\nvar SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING = 5663005;\nvar SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE = 5663006;\nvar SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND = 5663007;\nvar SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING = 5663008;\nvar SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING = 5663009;\nvar SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING = 5663010;\nvar SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING = 5663011;\nvar SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING = 5663012;\nvar SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING = 5663013;\nvar SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE = 5663014;\nvar SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION = 5663015;\nvar SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES = 5663016;\nvar SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH = 5663017;\nvar SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT = 5663018;\nvar SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT = 5663019;\nvar SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT = 5663020;\nvar SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN = 705e4;\nvar SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE = 7050001;\nvar SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE = 7050002;\nvar SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND = 7050003;\nvar SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND = 7050004;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE = 7050005;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE = 7050006;\nvar SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED = 7050007;\nvar SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND = 7050008;\nvar SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP = 7050009;\nvar SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE = 7050010;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX = 7050011;\nvar SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE = 7050012;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION = 7050013;\nvar SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE = 7050014;\nvar SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE = 7050015;\nvar SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 7050016;\nvar SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT = 7050017;\nvar SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION = 7050018;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT = 7050019;\nvar SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT = 7050020;\nvar SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT = 7050021;\nvar SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS = 7050022;\nvar SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND = 7050023;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER = 7050024;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA = 7050025;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX = 7050026;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT = 7050027;\nvar SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT = 7050028;\nvar SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT = 7050029;\nvar SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION = 7050030;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT = 7050031;\nvar SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED = 7050032;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT = 7050033;\nvar SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED = 7050034;\nvar SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED = 7050035;\nvar SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION = 7050036;\nvar SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY = 8078e3;\nvar SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH = 8078001;\nvar SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH = 8078002;\nvar SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH = 8078003;\nvar SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH = 8078004;\nvar SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH = 8078005;\nvar SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH = 8078006;\nvar SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS = 8078007;\nvar SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE = 8078008;\nvar SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT = 8078009;\nvar SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT = 8078010;\nvar SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE = 8078011;\nvar SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE = 8078012;\nvar SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH = 8078013;\nvar SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE = 8078014;\nvar SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT = 8078015;\nvar SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE = 8078016;\nvar SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE = 8078017;\nvar SOLANA_ERROR__CODECS__INVALID_CONSTANT = 8078018;\nvar SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE = 8078019;\nvar SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL = 8078020;\nvar SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES = 8078021;\nvar SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS = 8078022;\nvar SOLANA_ERROR__RPC__INTEGER_OVERFLOW = 81e5;\nvar SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN = 8100001;\nvar SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR = 8100002;\nvar SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD = 8100003;\nvar SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN = 819e4;\nvar SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID = 8190001;\nvar SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED = 8190002;\nvar SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED = 8190003;\nvar SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT = 8190004;\nvar SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING = 99e5;\nvar SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE = 9900001;\nvar SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING = 9900002;\nvar SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE = 9900003;\nvar SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED = 9900004;\n// src/context.ts\nfunction encodeValue(value) {\n    if (Array.isArray(value)) {\n        const commaSeparatedValues = value.map(encodeValue).join(\"%2C%20\");\n        return \"%5B\" + commaSeparatedValues + /* \"]\" */ \"%5D\";\n    } else if (typeof value === \"bigint\") {\n        return `${value}n`;\n    } else {\n        return encodeURIComponent(String(value != null && Object.getPrototypeOf(value) === null ? // Plain objects with no prototype don't have a `toString` method.\n        // Convert them before stringifying them.\n        {\n            ...value\n        } : value));\n    }\n}\nfunction encodeObjectContextEntry([key, value]) {\n    return `${key}=${encodeValue(value)}`;\n}\nfunction encodeContextObject(context) {\n    const searchParamsString = Object.entries(context).map(encodeObjectContextEntry).join(\"&\");\n    return Buffer.from(searchParamsString, \"utf8\").toString(\"base64\");\n}\n// src/messages.ts\nvar SolanaErrorMessages = {\n    [SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND]: \"Account not found at address: $address\",\n    [SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED]: \"Not all accounts were decoded. Encoded accounts found at addresses: $addresses.\",\n    [SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT]: \"Expected decoded account at address: $address\",\n    [SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT]: \"Failed to decode account data at address: $address\",\n    [SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND]: \"Accounts not found at addresses: $addresses\",\n    [SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED]: \"Unable to find a viable program address bump seed.\",\n    [SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS]: \"$putativeAddress is not a base58-encoded address.\",\n    [SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH]: \"Expected base58 encoded address to decode to a byte array of length 32. Actual length: $actualLength.\",\n    [SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY]: \"The `CryptoKey` must be an `Ed25519` public key.\",\n    [SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS]: \"$putativeOffCurveAddress is not a base58-encoded off-curve address.\",\n    [SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE]: \"Invalid seeds; point must fall off the Ed25519 curve.\",\n    [SOLANA_ERROR__ADDRESSES__MALFORMED_PDA]: \"Expected given program derived address to have the following format: [Address, ProgramDerivedAddressBump].\",\n    [SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED]: \"A maximum of $maxSeeds seeds, including the bump seed, may be supplied when creating an address. Received: $actual.\",\n    [SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED]: \"The seed at index $index with length $actual exceeds the maximum length of $maxSeedLength bytes.\",\n    [SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE]: \"Expected program derived address bump to be in the range [0, 255], got: $bump.\",\n    [SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER]: \"Program address cannot end with PDA marker.\",\n    [SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE]: \"Expected base58-encoded address string of length in the range [32, 44]. Actual length: $actualLength.\",\n    [SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE]: \"Expected base58-encoded blockash string of length in the range [32, 44]. Actual length: $actualLength.\",\n    [SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED]: \"The network has progressed past the last block for which this transaction could have been committed.\",\n    [SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY]: \"Codec [$codecDescription] cannot decode empty byte arrays.\",\n    [SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS]: \"Enum codec cannot use lexical values [$stringValues] as discriminators. Either remove all lexical values or set `useValuesAsDiscriminators` to `false`.\",\n    [SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL]: \"Sentinel [$hexSentinel] must not be present in encoded bytes [$hexEncodedBytes].\",\n    [SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH]: \"Encoder and decoder must have the same fixed size, got [$encoderFixedSize] and [$decoderFixedSize].\",\n    [SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH]: \"Encoder and decoder must have the same max size, got [$encoderMaxSize] and [$decoderMaxSize].\",\n    [SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH]: \"Encoder and decoder must either both be fixed-size or variable-size.\",\n    [SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE]: \"Enum discriminator out of range. Expected a number in [$formattedValidDiscriminators], got $discriminator.\",\n    [SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH]: \"Expected a fixed-size codec, got a variable-size one.\",\n    [SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH]: \"Codec [$codecDescription] expected a positive byte length, got $bytesLength.\",\n    [SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH]: \"Expected a variable-size codec, got a fixed-size one.\",\n    [SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE]: \"Codec [$codecDescription] expected zero-value [$hexZeroValue] to have the same size as the provided fixed-size item [$expectedSize bytes].\",\n    [SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH]: \"Codec [$codecDescription] expected $expected bytes, got $bytesLength.\",\n    [SOLANA_ERROR__CODECS__INVALID_CONSTANT]: \"Expected byte array constant [$hexConstant] to be present in data [$hexData] at offset [$offset].\",\n    [SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT]: \"Invalid discriminated union variant. Expected one of [$variants], got $value.\",\n    [SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT]: \"Invalid enum variant. Expected one of [$stringValues] or a number in [$formattedNumericalValues], got $variant.\",\n    [SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT]: \"Invalid literal union variant. Expected one of [$variants], got $value.\",\n    [SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS]: \"Expected [$codecDescription] to have $expected items, got $actual.\",\n    [SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE]: \"Invalid value $value for base $base with alphabet $alphabet.\",\n    [SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE]: \"Literal union discriminator out of range. Expected a number between $minRange and $maxRange, got $discriminator.\",\n    [SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE]: \"Codec [$codecDescription] expected number to be in the range [$min, $max], got $value.\",\n    [SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE]: \"Codec [$codecDescription] expected offset to be in the range [0, $bytesLength], got $offset.\",\n    [SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES]: \"Expected sentinel [$hexSentinel] to be present in decoded bytes [$hexDecodedBytes].\",\n    [SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE]: \"Union variant out of range. Expected an index between $minRange and $maxRange, got $variant.\",\n    [SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED]: \"No random values implementation could be found.\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED]: \"instruction requires an uninitialized account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED]: \"instruction tries to borrow reference for an account which is already borrowed\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]: \"instruction left account with an outstanding borrowed reference\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED]: \"program other than the account's owner changed the size of the account data\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL]: \"account data too small for instruction\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE]: \"instruction expected an executable account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT]: \"An account does not have enough lamports to be rent-exempt\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW]: \"Program arithmetic overflowed\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR]: \"Failed to serialize or deserialize account data: $encodedData\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS]: \"Builtin programs must consume compute units\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH]: \"Cross-program invocation call depth too deep\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED]: \"Computational budget exceeded\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM]: \"custom program error: #$code\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX]: \"instruction contains duplicate accounts\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC]: \"instruction modifications of multiply-passed account differ\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT]: \"executable accounts must be rent exempt\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED]: \"instruction changed executable accounts data\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE]: \"instruction changed the balance of an executable account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED]: \"instruction changed executable bit of an account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED]: \"instruction modified data of an account it does not own\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND]: \"instruction spent from the balance of an account it does not own\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR]: \"generic instruction error\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER]: \"Provided owner is not allowed\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE]: \"Account is immutable\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY]: \"Incorrect authority provided\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID]: \"incorrect program id for instruction\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS]: \"insufficient funds for instruction\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA]: \"invalid account data for instruction\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER]: \"Invalid account owner\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT]: \"invalid program argument\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR]: \"program returned invalid error code\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA]: \"invalid instruction data\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC]: \"Failed to reallocate account data\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS]: \"Provided seeds do not result in a valid address\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED]: \"Accounts data allocations exceeded the maximum allowed per transaction\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED]: \"Max accounts exceeded\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED]: \"Max instruction trace length exceeded\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED]: \"Length of the seed is too long for address generation\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT]: \"An account required by the instruction is missing\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE]: \"missing required signature for instruction\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID]: \"instruction illegally modified the program id of an account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS]: \"insufficient account keys for instruction\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION]: \"Cross-program invocation with unauthorized signer or writable account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE]: \"Failed to create program execution environment\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE]: \"Program failed to compile\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE]: \"Program failed to complete\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED]: \"instruction modified data of a read-only account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE]: \"instruction changed the balance of a read-only account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED]: \"Cross-program invocation reentrancy not allowed for this instruction\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED]: \"instruction modified rent epoch of an account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION]: \"sum of account balances before and after instruction do not match\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT]: \"instruction requires an initialized account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN]: \"\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID]: \"Unsupported program id\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR]: \"Unsupported sysvar\",\n    [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS]: \"The instruction does not have any accounts.\",\n    [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA]: \"The instruction does not have any data.\",\n    [SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH]: \"Expected instruction to have progress address $expectedProgramAddress, got $actualProgramAddress.\",\n    [SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH]: \"Expected base58 encoded blockhash to decode to a byte array of length 32. Actual length: $actualLength.\",\n    [SOLANA_ERROR__INVALID_NONCE]: \"The nonce `$expectedNonceValue` is no longer valid. It has advanced to `$actualNonceValue`\",\n    [SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING]: \"Invariant violation: Found no abortable iterable cache entry for key `$cacheKey`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant\",\n    [SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED]: \"Invariant violation: This data publisher does not publish to the channel named `$channelName`. Supported channels include $supportedChannelNames.\",\n    [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE]: \"Invariant violation: WebSocket message iterator state is corrupt; iterated without first resolving existing message promise. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant\",\n    [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING]: \"Invariant violation: WebSocket message iterator is missing state storage. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant\",\n    [SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE]: \"Invariant violation: Switch statement non-exhaustive. Received unexpected value `$unexpectedValue`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant\",\n    [SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR]: \"JSON-RPC error: Internal JSON-RPC error ($__serverMessage)\",\n    [SOLANA_ERROR__JSON_RPC__INVALID_PARAMS]: \"JSON-RPC error: Invalid method parameter(s) ($__serverMessage)\",\n    [SOLANA_ERROR__JSON_RPC__INVALID_REQUEST]: \"JSON-RPC error: The JSON sent is not a valid `Request` object ($__serverMessage)\",\n    [SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND]: \"JSON-RPC error: The method does not exist / is not available ($__serverMessage)\",\n    [SOLANA_ERROR__JSON_RPC__PARSE_ERROR]: \"JSON-RPC error: An error occurred on the server while parsing the JSON text ($__serverMessage)\",\n    [SOLANA_ERROR__JSON_RPC__SCAN_ERROR]: \"$__serverMessage\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP]: \"$__serverMessage\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE]: \"$__serverMessage\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET]: \"$__serverMessage\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX]: \"$__serverMessage\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED]: \"$__serverMessage\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED]: \"Minimum context slot has not been reached\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY]: \"Node is unhealthy; behind by $numSlotsBehind slots\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT]: \"No snapshot\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE]: \"Transaction simulation failed\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED]: \"$__serverMessage\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE]: \"Transaction history is not available from this node\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE]: \"$__serverMessage\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH]: \"Transaction signature length mismatch\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE]: \"Transaction signature verification failure\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION]: \"$__serverMessage\",\n    [SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH]: \"Key pair bytes must be of length 64, got $byteLength.\",\n    [SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH]: \"Expected private key bytes with length 32. Actual length: $actualLength.\",\n    [SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH]: \"Expected base58-encoded signature to decode to a byte array of length 64. Actual length: $actualLength.\",\n    [SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY]: \"The provided private key does not match the provided public key.\",\n    [SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE]: \"Expected base58-encoded signature string of length in the range [64, 88]. Actual length: $actualLength.\",\n    [SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE]: \"Lamports value must be in the range [0, 2e64-1]\",\n    [SOLANA_ERROR__MALFORMED_BIGINT_STRING]: \"`$value` cannot be parsed as a `BigInt`\",\n    [SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR]: \"$message\",\n    [SOLANA_ERROR__MALFORMED_NUMBER_STRING]: \"`$value` cannot be parsed as a `Number`\",\n    [SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND]: \"No nonce account could be found at address `$nonceAccountAddress`\",\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN]: \"The notification name must end in 'Notifications' and the API must supply a subscription plan creator function for the notification '$notificationName'.\",\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED]: \"WebSocket was closed before payload could be added to the send buffer\",\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED]: \"WebSocket connection closed\",\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT]: \"WebSocket failed to connect\",\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID]: \"Failed to obtain a subscription id from the server\",\n    [SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD]: \"Could not find an API plan for RPC method: `$method`\",\n    [SOLANA_ERROR__RPC__INTEGER_OVERFLOW]: \"The $argumentLabel argument to the `$methodName` RPC method$optionalPathLabel was `$value`. This number is unsafe for use with the Solana JSON-RPC because it exceeds `Number.MAX_SAFE_INTEGER`.\",\n    [SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR]: \"HTTP error ($statusCode): $message\",\n    [SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN]: \"HTTP header(s) forbidden: $headers. Learn more at https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name.\",\n    [SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS]: \"Multiple distinct signers were identified for address `$address`. Please ensure that you are using the same signer instance for each address.\",\n    [SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER]: \"The provided value does not implement the `KeyPairSigner` interface\",\n    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER]: \"The provided value does not implement the `MessageModifyingSigner` interface\",\n    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER]: \"The provided value does not implement the `MessagePartialSigner` interface\",\n    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER]: \"The provided value does not implement any of the `MessageSigner` interfaces\",\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER]: \"The provided value does not implement the `TransactionModifyingSigner` interface\",\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER]: \"The provided value does not implement the `TransactionPartialSigner` interface\",\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER]: \"The provided value does not implement the `TransactionSendingSigner` interface\",\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER]: \"The provided value does not implement any of the `TransactionSigner` interfaces\",\n    [SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS]: \"More than one `TransactionSendingSigner` was identified.\",\n    [SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING]: \"No `TransactionSendingSigner` was identified. Please provide a valid `TransactionWithSingleSendingSigner` transaction.\",\n    [SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED]: \"Wallet account signers do not support signing multiple messages/transactions in a single operation\",\n    [SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY]: \"Cannot export a non-extractable key.\",\n    [SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED]: \"No digest implementation could be found.\",\n    [SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT]: \"Cryptographic operations are only allowed in secure browser contexts. Read more here: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts.\",\n    [SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED]: \"This runtime does not support the generation of Ed25519 key pairs.\\n\\nInstall @solana/webcrypto-ed25519-polyfill and call its `install` function before generating keys in environments that do not support Ed25519.\\n\\nFor a list of runtimes that currently support Ed25519 operations, visit https://github.com/WICG/webcrypto-secure-curves/issues/20.\",\n    [SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED]: \"No signature verification implementation could be found.\",\n    [SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED]: \"No key generation implementation could be found.\",\n    [SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED]: \"No signing implementation could be found.\",\n    [SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED]: \"No key export implementation could be found.\",\n    [SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE]: \"Timestamp value must be in the range [-(2n ** 63n), (2n ** 63n) - 1]. `$value` given\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]: \"Transaction processing left an account with an outstanding borrowed reference\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE]: \"Account in use\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE]: \"Account loaded twice\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND]: \"Attempt to debit an account but found no record of a prior credit.\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND]: \"Transaction loads an address table account that doesn't exist\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED]: \"This transaction has already been processed\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND]: \"Blockhash not found\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP]: \"Loader call chain is too deep\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE]: \"Transactions are currently disabled due to cluster maintenance\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION]: \"Transaction contains a duplicate instruction ($index) that is not allowed\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE]: \"Insufficient funds for fee\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT]: \"Transaction results in an account ($accountIndex) with insufficient funds for rent\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE]: \"This account may not be used to pay transaction fees\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX]: \"Transaction contains an invalid account reference\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA]: \"Transaction loads an address table account with invalid data\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX]: \"Transaction address table lookup uses an invalid index\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER]: \"Transaction loads an address table account with an invalid owner\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT]: \"LoadedAccountsDataSizeLimit set for transaction must be greater than 0.\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION]: \"This program may not be used for executing instructions\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT]: \"Transaction leaves an account with a lower balance than rent-exempt minimum\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT]: \"Transaction loads a writable account that cannot be written\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED]: \"Transaction exceeded max loaded accounts data size cap\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE]: \"Transaction requires a fee but has no signature present\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND]: \"Attempt to load a program that does not exist\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED]: \"Execution of the program referenced by account at index $accountIndex is temporarily restricted.\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED]: \"ResanitizationNeeded\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE]: \"Transaction failed to sanitize accounts offsets correctly\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE]: \"Transaction did not pass signature verification\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS]: \"Transaction locked too many accounts\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION]: \"Sum of account balances before and after transaction do not match\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN]: \"The transaction failed with the error `$errorName`\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION]: \"Transaction version is unsupported\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT]: \"Transaction would exceed account data limit within the block\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT]: \"Transaction would exceed total account data limit\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT]: \"Transaction would exceed max account limit within the block\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT]: \"Transaction would exceed max Block Cost Limit\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT]: \"Transaction would exceed max Vote Cost Limit\",\n    [SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION]: \"Attempted to sign a transaction with an address that is not a signer for it\",\n    [SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING]: \"Transaction is missing an address at index: $index.\",\n    [SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES]: \"Transaction has no expected signers therefore it cannot be encoded\",\n    [SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT]: \"Transaction size $transactionSize exceeds limit of $transactionSizeLimit bytes\",\n    [SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME]: \"Transaction does not have a blockhash lifetime\",\n    [SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME]: \"Transaction is not a durable nonce transaction\",\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING]: \"Contents of these address lookup tables unknown: $lookupTableAddresses\",\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE]: \"Lookup of address at index $highestRequestedIndex failed for lookup table `$lookupTableAddress`. Highest known index is $highestKnownIndex. The lookup table may have been extended since its contents were retrieved\",\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING]: \"No fee payer set in CompiledTransaction\",\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND]: \"Could not find program address at index $index\",\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT]: \"Failed to estimate the compute unit consumption for this transaction message. This is likely because simulating the transaction failed. Inspect the `cause` property of this error to learn more\",\n    [SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT]: \"Transaction failed when it was simulated in order to estimate the compute unit consumption. The compute unit estimate provided is for a transaction that failed when simulated and may not be representative of the compute units this transaction would consume if successful. Inspect the `cause` property of this error to learn more\",\n    [SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING]: \"Transaction is missing a fee payer.\",\n    [SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING]: \"Could not determine this transaction's signature. Make sure that the transaction has been signed by its fee payer.\",\n    [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE]: \"Transaction first instruction is not advance nonce account instruction.\",\n    [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING]: \"Transaction with no instructions cannot be durable nonce transaction.\",\n    [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES]: \"This transaction includes an address (`$programAddress`) which is both invoked and set as the fee payer. Program addresses may not pay fees\",\n    [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE]: \"This transaction includes an address (`$programAddress`) which is both invoked and marked writable. Program addresses may not be writable\",\n    [SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH]: \"The transaction message expected the transaction to have $signerAddressesLength signatures, got $signaturesLength.\",\n    [SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING]: \"Transaction is missing signatures for addresses: $addresses.\",\n    [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE]: \"Transaction version must be in the range [0, 127]. `$actualVersion` given\"\n};\n// src/message-formatter.ts\nvar START_INDEX = \"i\";\nvar TYPE = \"t\";\nfunction getHumanReadableErrorMessage(code, context = {}) {\n    const messageFormatString = SolanaErrorMessages[code];\n    if (messageFormatString.length === 0) {\n        return \"\";\n    }\n    let state;\n    function commitStateUpTo(endIndex) {\n        if (state[TYPE] === 2 /* Variable */ ) {\n            const variableName = messageFormatString.slice(state[START_INDEX] + 1, endIndex);\n            fragments.push(variableName in context ? // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n            `${context[variableName]}` : `$${variableName}`);\n        } else if (state[TYPE] === 1 /* Text */ ) {\n            fragments.push(messageFormatString.slice(state[START_INDEX], endIndex));\n        }\n    }\n    const fragments = [];\n    messageFormatString.split(\"\").forEach((char, ii)=>{\n        if (ii === 0) {\n            state = {\n                [START_INDEX]: 0,\n                [TYPE]: messageFormatString[0] === \"\\\\\" ? 0 /* EscapeSequence */  : messageFormatString[0] === \"$\" ? 2 /* Variable */  : 1 /* Text */ \n            };\n            return;\n        }\n        let nextState;\n        switch(state[TYPE]){\n            case 0 /* EscapeSequence */ :\n                nextState = {\n                    [START_INDEX]: ii,\n                    [TYPE]: 1 /* Text */ \n                };\n                break;\n            case 1 /* Text */ :\n                if (char === \"\\\\\") {\n                    nextState = {\n                        [START_INDEX]: ii,\n                        [TYPE]: 0 /* EscapeSequence */ \n                    };\n                } else if (char === \"$\") {\n                    nextState = {\n                        [START_INDEX]: ii,\n                        [TYPE]: 2 /* Variable */ \n                    };\n                }\n                break;\n            case 2 /* Variable */ :\n                if (char === \"\\\\\") {\n                    nextState = {\n                        [START_INDEX]: ii,\n                        [TYPE]: 0 /* EscapeSequence */ \n                    };\n                } else if (char === \"$\") {\n                    nextState = {\n                        [START_INDEX]: ii,\n                        [TYPE]: 2 /* Variable */ \n                    };\n                } else if (!char.match(/\\w/)) {\n                    nextState = {\n                        [START_INDEX]: ii,\n                        [TYPE]: 1 /* Text */ \n                    };\n                }\n                break;\n        }\n        if (nextState) {\n            if (state !== nextState) {\n                commitStateUpTo(ii);\n            }\n            state = nextState;\n        }\n    });\n    commitStateUpTo();\n    return fragments.join(\"\");\n}\nfunction getErrorMessage(code, context = {}) {\n    if (true) {\n        return getHumanReadableErrorMessage(code, context);\n    } else {}\n}\n// src/error.ts\nfunction isSolanaError(e, code) {\n    const isSolanaError2 = e instanceof Error && e.name === \"SolanaError\";\n    if (isSolanaError2) {\n        if (code !== void 0) {\n            return e.context.__code === code;\n        }\n        return true;\n    }\n    return false;\n}\nvar SolanaError = class extends Error {\n    constructor(...[code, contextAndErrorOptions]){\n        let context;\n        let errorOptions;\n        if (contextAndErrorOptions) {\n            const { cause, ...contextRest } = contextAndErrorOptions;\n            if (cause) {\n                errorOptions = {\n                    cause\n                };\n            }\n            if (Object.keys(contextRest).length > 0) {\n                context = contextRest;\n            }\n        }\n        const message = getErrorMessage(code, context);\n        super(message, errorOptions);\n        /**\n   * Indicates the root cause of this {@link SolanaError}, if any.\n   *\n   * For example, a transaction error might have an instruction error as its root cause. In this\n   * case, you will be able to access the instruction error on the transaction error as `cause`.\n   */ this.cause = this.cause;\n        this.context = {\n            __code: code,\n            ...context\n        };\n        this.name = \"SolanaError\";\n    }\n};\n// src/stack-trace.ts\nfunction safeCaptureStackTrace(...args) {\n    if (\"captureStackTrace\" in Error && typeof Error.captureStackTrace === \"function\") {\n        Error.captureStackTrace(...args);\n    }\n}\n// src/rpc-enum-errors.ts\nfunction getSolanaErrorFromRpcError({ errorCodeBaseOffset, getErrorContext, orderedErrorNames, rpcEnumError }, constructorOpt) {\n    let rpcErrorName;\n    let rpcErrorContext;\n    if (typeof rpcEnumError === \"string\") {\n        rpcErrorName = rpcEnumError;\n    } else {\n        rpcErrorName = Object.keys(rpcEnumError)[0];\n        rpcErrorContext = rpcEnumError[rpcErrorName];\n    }\n    const codeOffset = orderedErrorNames.indexOf(rpcErrorName);\n    const errorCode = errorCodeBaseOffset + codeOffset;\n    const errorContext = getErrorContext(errorCode, rpcErrorName, rpcErrorContext);\n    const err = new SolanaError(errorCode, errorContext);\n    safeCaptureStackTrace(err, constructorOpt);\n    return err;\n}\n// src/instruction-error.ts\nvar ORDERED_ERROR_NAMES = [\n    // Keep synced with RPC source: https://github.com/anza-xyz/agave/blob/master/sdk/program/src/instruction.rs\n    // If this list ever gets too large, consider implementing a compression strategy like this:\n    // https://gist.github.com/steveluscher/aaa7cbbb5433b1197983908a40860c47\n    \"GenericError\",\n    \"InvalidArgument\",\n    \"InvalidInstructionData\",\n    \"InvalidAccountData\",\n    \"AccountDataTooSmall\",\n    \"InsufficientFunds\",\n    \"IncorrectProgramId\",\n    \"MissingRequiredSignature\",\n    \"AccountAlreadyInitialized\",\n    \"UninitializedAccount\",\n    \"UnbalancedInstruction\",\n    \"ModifiedProgramId\",\n    \"ExternalAccountLamportSpend\",\n    \"ExternalAccountDataModified\",\n    \"ReadonlyLamportChange\",\n    \"ReadonlyDataModified\",\n    \"DuplicateAccountIndex\",\n    \"ExecutableModified\",\n    \"RentEpochModified\",\n    \"NotEnoughAccountKeys\",\n    \"AccountDataSizeChanged\",\n    \"AccountNotExecutable\",\n    \"AccountBorrowFailed\",\n    \"AccountBorrowOutstanding\",\n    \"DuplicateAccountOutOfSync\",\n    \"Custom\",\n    \"InvalidError\",\n    \"ExecutableDataModified\",\n    \"ExecutableLamportChange\",\n    \"ExecutableAccountNotRentExempt\",\n    \"UnsupportedProgramId\",\n    \"CallDepth\",\n    \"MissingAccount\",\n    \"ReentrancyNotAllowed\",\n    \"MaxSeedLengthExceeded\",\n    \"InvalidSeeds\",\n    \"InvalidRealloc\",\n    \"ComputationalBudgetExceeded\",\n    \"PrivilegeEscalation\",\n    \"ProgramEnvironmentSetupFailure\",\n    \"ProgramFailedToComplete\",\n    \"ProgramFailedToCompile\",\n    \"Immutable\",\n    \"IncorrectAuthority\",\n    \"BorshIoError\",\n    \"AccountNotRentExempt\",\n    \"InvalidAccountOwner\",\n    \"ArithmeticOverflow\",\n    \"UnsupportedSysvar\",\n    \"IllegalOwner\",\n    \"MaxAccountsDataAllocationsExceeded\",\n    \"MaxAccountsExceeded\",\n    \"MaxInstructionTraceLengthExceeded\",\n    \"BuiltinProgramsMustConsumeComputeUnits\"\n];\nfunction getSolanaErrorFromInstructionError(index, instructionError) {\n    const numberIndex = Number(index);\n    return getSolanaErrorFromRpcError({\n        errorCodeBaseOffset: 4615001,\n        getErrorContext (errorCode, rpcErrorName, rpcErrorContext) {\n            if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN) {\n                return {\n                    errorName: rpcErrorName,\n                    index: numberIndex,\n                    ...rpcErrorContext !== void 0 ? {\n                        instructionErrorContext: rpcErrorContext\n                    } : null\n                };\n            } else if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM) {\n                return {\n                    code: Number(rpcErrorContext),\n                    index: numberIndex\n                };\n            } else if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR) {\n                return {\n                    encodedData: rpcErrorContext,\n                    index: numberIndex\n                };\n            }\n            return {\n                index: numberIndex\n            };\n        },\n        orderedErrorNames: ORDERED_ERROR_NAMES,\n        rpcEnumError: instructionError\n    }, getSolanaErrorFromInstructionError);\n}\n// src/transaction-error.ts\nvar ORDERED_ERROR_NAMES2 = [\n    // Keep synced with RPC source: https://github.com/anza-xyz/agave/blob/master/sdk/src/transaction/error.rs\n    // If this list ever gets too large, consider implementing a compression strategy like this:\n    // https://gist.github.com/steveluscher/aaa7cbbb5433b1197983908a40860c47\n    \"AccountInUse\",\n    \"AccountLoadedTwice\",\n    \"AccountNotFound\",\n    \"ProgramAccountNotFound\",\n    \"InsufficientFundsForFee\",\n    \"InvalidAccountForFee\",\n    \"AlreadyProcessed\",\n    \"BlockhashNotFound\",\n    // `InstructionError` intentionally omitted; delegated to `getSolanaErrorFromInstructionError`\n    \"CallChainTooDeep\",\n    \"MissingSignatureForFee\",\n    \"InvalidAccountIndex\",\n    \"SignatureFailure\",\n    \"InvalidProgramForExecution\",\n    \"SanitizeFailure\",\n    \"ClusterMaintenance\",\n    \"AccountBorrowOutstanding\",\n    \"WouldExceedMaxBlockCostLimit\",\n    \"UnsupportedVersion\",\n    \"InvalidWritableAccount\",\n    \"WouldExceedMaxAccountCostLimit\",\n    \"WouldExceedAccountDataBlockLimit\",\n    \"TooManyAccountLocks\",\n    \"AddressLookupTableNotFound\",\n    \"InvalidAddressLookupTableOwner\",\n    \"InvalidAddressLookupTableData\",\n    \"InvalidAddressLookupTableIndex\",\n    \"InvalidRentPayingAccount\",\n    \"WouldExceedMaxVoteCostLimit\",\n    \"WouldExceedAccountDataTotalLimit\",\n    \"DuplicateInstruction\",\n    \"InsufficientFundsForRent\",\n    \"MaxLoadedAccountsDataSizeExceeded\",\n    \"InvalidLoadedAccountsDataSizeLimit\",\n    \"ResanitizationNeeded\",\n    \"ProgramExecutionTemporarilyRestricted\",\n    \"UnbalancedTransaction\"\n];\nfunction getSolanaErrorFromTransactionError(transactionError) {\n    if (typeof transactionError === \"object\" && \"InstructionError\" in transactionError) {\n        return getSolanaErrorFromInstructionError(...transactionError.InstructionError);\n    }\n    return getSolanaErrorFromRpcError({\n        errorCodeBaseOffset: 7050001,\n        getErrorContext (errorCode, rpcErrorName, rpcErrorContext) {\n            if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN) {\n                return {\n                    errorName: rpcErrorName,\n                    ...rpcErrorContext !== void 0 ? {\n                        transactionErrorContext: rpcErrorContext\n                    } : null\n                };\n            } else if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION) {\n                return {\n                    index: Number(rpcErrorContext)\n                };\n            } else if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT || errorCode === SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED) {\n                return {\n                    accountIndex: Number(rpcErrorContext.account_index)\n                };\n            }\n        },\n        orderedErrorNames: ORDERED_ERROR_NAMES2,\n        rpcEnumError: transactionError\n    }, getSolanaErrorFromTransactionError);\n}\n// src/json-rpc-error.ts\nfunction getSolanaErrorFromJsonRpcError(putativeErrorResponse) {\n    let out;\n    if (isRpcErrorResponse(putativeErrorResponse)) {\n        const { code: rawCode, data, message } = putativeErrorResponse;\n        const code = Number(rawCode);\n        if (code === SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE) {\n            const { err, ...preflightErrorContext } = data;\n            const causeObject = err ? {\n                cause: getSolanaErrorFromTransactionError(err)\n            } : null;\n            out = new SolanaError(SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE, {\n                ...preflightErrorContext,\n                ...causeObject\n            });\n        } else {\n            let errorContext;\n            switch(code){\n                case SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR:\n                case SOLANA_ERROR__JSON_RPC__INVALID_PARAMS:\n                case SOLANA_ERROR__JSON_RPC__INVALID_REQUEST:\n                case SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND:\n                case SOLANA_ERROR__JSON_RPC__PARSE_ERROR:\n                case SOLANA_ERROR__JSON_RPC__SCAN_ERROR:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION:\n                    errorContext = {\n                        __serverMessage: message\n                    };\n                    break;\n                default:\n                    if (typeof data === \"object\" && !Array.isArray(data)) {\n                        errorContext = data;\n                    }\n            }\n            out = new SolanaError(code, errorContext);\n        }\n    } else {\n        const message = typeof putativeErrorResponse === \"object\" && putativeErrorResponse !== null && \"message\" in putativeErrorResponse && typeof putativeErrorResponse.message === \"string\" ? putativeErrorResponse.message : \"Malformed JSON-RPC error with no message attribute\";\n        out = new SolanaError(SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR, {\n            error: putativeErrorResponse,\n            message\n        });\n    }\n    safeCaptureStackTrace(out, getSolanaErrorFromJsonRpcError);\n    return out;\n}\nfunction isRpcErrorResponse(value) {\n    return typeof value === \"object\" && value !== null && \"code\" in value && \"message\" in value && (typeof value.code === \"number\" || typeof value.code === \"bigint\") && typeof value.message === \"string\";\n}\n //# sourceMappingURL=index.node.mjs.map\n //# sourceMappingURL=index.node.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Ac29sYW5hL2Vycm9ycy9kaXN0L2luZGV4Lm5vZGUubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsZUFBZTtBQUNmLElBQUlBLHNDQUFzQztBQUMxQyxJQUFJQyw4QkFBOEI7QUFDbEMsSUFBSUMsd0NBQXdDO0FBQzVDLElBQUlDLHFEQUFxRDtBQUN6RCxJQUFJQyw4Q0FBOEM7QUFDbEQsSUFBSUMsc0NBQXNDO0FBQzFDLElBQUlDLHdDQUF3QztBQUM1QyxJQUFJQyx3Q0FBd0M7QUFDNUMsSUFBSUMsdUNBQXVDO0FBQzNDLElBQUlDLHlDQUF5QztBQUM3QyxJQUFJQyxzQ0FBc0MsQ0FBQztBQUMzQyxJQUFJQyx5Q0FBeUMsQ0FBQztBQUM5QyxJQUFJQyx5Q0FBeUMsQ0FBQztBQUM5QyxJQUFJQywyQ0FBMkMsQ0FBQztBQUNoRCxJQUFJQywwQ0FBMEMsQ0FBQztBQUMvQyxJQUFJQyxvRUFBb0UsQ0FBQztBQUN6RSxJQUFJQyx1RUFBdUUsQ0FBQztBQUM1RSxJQUFJQyxzRUFBc0UsQ0FBQztBQUMzRSxJQUFJQywwRUFBMEUsQ0FBQztBQUMvRSxJQUFJQyxxQ0FBcUMsQ0FBQztBQUMxQyxJQUFJQyx5RUFBeUUsQ0FBQztBQUM5RSxJQUFJQyx5RUFBeUUsQ0FBQztBQUM5RSxJQUFJQyxzRUFBc0UsQ0FBQztBQUMzRSxJQUFJQyxtREFBbUQsQ0FBQztBQUN4RCxJQUFJ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Q0wsS0FBS0k7Z0JBQ0wsS0FBS0M7Z0JBQ0wsS0FBS0U7Z0JBQ0wsS0FBS0M7Z0JBQ0wsS0FBS1Q7b0JBQ0gwUixlQUFlO3dCQUFFMEIsaUJBQWlCekM7b0JBQVE7b0JBQzFDO2dCQUNGO29CQUNFLElBQUksT0FBT3NDLFNBQVMsWUFBWSxDQUFDNUYsTUFBTUMsT0FBTyxDQUFDMkYsT0FBTzt3QkFDcER2QixlQUFldUI7b0JBQ2pCO1lBQ0o7WUFDQUgsTUFBTSxJQUFJekMsWUFBWTFCLE1BQU0rQztRQUM5QjtJQUNGLE9BQU87UUFDTCxNQUFNZixVQUFVLE9BQU9rQywwQkFBMEIsWUFBWUEsMEJBQTBCLFFBQVEsYUFBYUEseUJBQXlCLE9BQU9BLHNCQUFzQmxDLE9BQU8sS0FBSyxXQUFXa0Msc0JBQXNCbEMsT0FBTyxHQUFHO1FBQ3pObUMsTUFBTSxJQUFJekMsWUFBWTVRLHdDQUF3QztZQUFFNFQsT0FBT1I7WUFBdUJsQztRQUFRO0lBQ3hHO0lBQ0FDLHNCQUFzQmtDLEtBQUtGO0lBQzNCLE9BQU9FO0FBQ1Q7QUFDQSxTQUFTQyxtQkFBbUIzRixLQUFLO0lBQy9CLE9BQU8sT0FBT0EsVUFBVSxZQUFZQSxVQUFVLFFBQVEsVUFBVUEsU0FBUyxhQUFhQSxTQUFVLFFBQU9BLE1BQU11QixJQUFJLEtBQUssWUFBWSxPQUFPdkIsTUFBTXVCLElBQUksS0FBSyxRQUFPLEtBQU0sT0FBT3ZCLE1BQU11RCxPQUFPLEtBQUs7QUFDaE07QUFFdTNaLENBQ3YzWix1Q0FBdUM7Q0FDdkMsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xhdy13b3Jrcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dlYjMuanMvbm9kZV9tb2R1bGVzL0Bzb2xhbmEvZXJyb3JzL2Rpc3QvaW5kZXgubm9kZS5tanM/MmVlNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvY29kZXMudHNcbnZhciBTT0xBTkFfRVJST1JfX0JMT0NLX0hFSUdIVF9FWENFRURFRCA9IDE7XG52YXIgU09MQU5BX0VSUk9SX19JTlZBTElEX05PTkNFID0gMjtcbnZhciBTT0xBTkFfRVJST1JfX05PTkNFX0FDQ09VTlRfTk9UX0ZPVU5EID0gMztcbnZhciBTT0xBTkFfRVJST1JfX0JMT0NLSEFTSF9TVFJJTkdfTEVOR1RIX09VVF9PRl9SQU5HRSA9IDQ7XG52YXIgU09MQU5BX0VSUk9SX19JTlZBTElEX0JMT0NLSEFTSF9CWVRFX0xFTkdUSCA9IDU7XG52YXIgU09MQU5BX0VSUk9SX19MQU1QT1JUU19PVVRfT0ZfUkFOR0UgPSA2O1xudmFyIFNPTEFOQV9FUlJPUl9fTUFMRk9STUVEX0JJR0lOVF9TVFJJTkcgPSA3O1xudmFyIFNPTEFOQV9FUlJPUl9fTUFMRk9STUVEX05VTUJFUl9TVFJJTkcgPSA4O1xudmFyIFNPTEFOQV9FUlJPUl9fVElNRVNUQU1QX09VVF9PRl9SQU5HRSA9IDk7XG52YXIgU09MQU5BX0VSUk9SX19NQUxGT1JNRURfSlNPTl9SUENfRVJST1IgPSAxMDtcbnZhciBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19QQVJTRV9FUlJPUiA9IC0zMjcwMDtcbnZhciBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19JTlRFUk5BTF9FUlJPUiA9IC0zMjYwMztcbnZhciBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19JTlZBTElEX1BBUkFNUyA9IC0zMjYwMjtcbnZhciBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19NRVRIT0RfTk9UX0ZPVU5EID0gLTMyNjAxO1xudmFyIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX0lOVkFMSURfUkVRVUVTVCA9IC0zMjYwMDtcbnZhciBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfTUlOX0NPTlRFWFRfU0xPVF9OT1RfUkVBQ0hFRCA9IC0zMjAxNjtcbnZhciBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfVU5TVVBQT1JURURfVFJBTlNBQ1RJT05fVkVSU0lPTiA9IC0zMjAxNTtcbnZhciBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfQkxPQ0tfU1RBVFVTX05PVF9BVkFJTEFCTEVfWUVUID0gLTMyMDE0O1xudmFyIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9TSUdOQVRVUkVfTEVOX01JU01BVENIID0gLTMyMDEzO1xudmFyIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NDQU5fRVJST1IgPSAtMzIwMTI7XG52YXIgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX0hJU1RPUllfTk9UX0FWQUlMQUJMRSA9IC0zMjAxMTtcbnZhciBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfS0VZX0VYQ0xVREVEX0ZST01fU0VDT05EQVJZX0lOREVYID0gLTMyMDEwO1xudmFyIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9MT05HX1RFUk1fU1RPUkFHRV9TTE9UX1NLSVBQRUQgPSAtMzIwMDk7XG52YXIgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX05PX1NOQVBTSE9UID0gLTMyMDA4O1xudmFyIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9TTE9UX1NLSVBQRUQgPSAtMzIwMDc7XG52YXIgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX1BSRUNPTVBJTEVfVkVSSUZJQ0FUSU9OX0ZBSUxVUkUgPSAtMzIwMDY7XG52YXIgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX05PREVfVU5IRUFMVEhZID0gLTMyMDA1O1xudmFyIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9CTE9DS19OT1RfQVZBSUxBQkxFID0gLTMyMDA0O1xudmFyIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9TSUdOQVRVUkVfVkVSSUZJQ0FUSU9OX0ZBSUxVUkUgPSAtMzIwMDM7XG52YXIgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1NFTkRfVFJBTlNBQ1RJT05fUFJFRkxJR0hUX0ZBSUxVUkUgPSAtMzIwMDI7XG52YXIgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0JMT0NLX0NMRUFORURfVVAgPSAtMzIwMDE7XG52YXIgU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX0lOVkFMSURfQllURV9MRU5HVEggPSAyOGU1O1xudmFyIFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19TVFJJTkdfTEVOR1RIX09VVF9PRl9SQU5HRSA9IDI4MDAwMDE7XG52YXIgU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX0lOVkFMSURfQkFTRTU4X0VOQ09ERURfQUREUkVTUyA9IDI4MDAwMDI7XG52YXIgU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX0lOVkFMSURfRUQyNTUxOV9QVUJMSUNfS0VZID0gMjgwMDAwMztcbnZhciBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fTUFMRk9STUVEX1BEQSA9IDI4MDAwMDQ7XG52YXIgU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX1BEQV9CVU1QX1NFRURfT1VUX09GX1JBTkdFID0gMjgwMDAwNTtcbnZhciBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fTUFYX05VTUJFUl9PRl9QREFfU0VFRFNfRVhDRUVERUQgPSAyODAwMDA2O1xudmFyIFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19NQVhfUERBX1NFRURfTEVOR1RIX0VYQ0VFREVEID0gMjgwMDAwNztcbnZhciBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fSU5WQUxJRF9TRUVEU19QT0lOVF9PTl9DVVJWRSA9IDI4MDAwMDg7XG52YXIgU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX0ZBSUxFRF9UT19GSU5EX1ZJQUJMRV9QREFfQlVNUF9TRUVEID0gMjgwMDAwOTtcbnZhciBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fUERBX0VORFNfV0lUSF9QREFfTUFSS0VSID0gMjgwMDAxMDtcbnZhciBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fSU5WQUxJRF9PRkZfQ1VSVkVfQUREUkVTUyA9IDI4MDAwMTE7XG52YXIgU09MQU5BX0VSUk9SX19BQ0NPVU5UU19fQUNDT1VOVF9OT1RfRk9VTkQgPSAzMjNlNDtcbnZhciBTT0xBTkFfRVJST1JfX0FDQ09VTlRTX19PTkVfT1JfTU9SRV9BQ0NPVU5UU19OT1RfRk9VTkQgPSAzMjMwMDAwMTtcbnZhciBTT0xBTkFfRVJST1JfX0FDQ09VTlRTX19GQUlMRURfVE9fREVDT0RFX0FDQ09VTlQgPSAzMjMwMDAyO1xudmFyIFNPTEFOQV9FUlJPUl9fQUNDT1VOVFNfX0VYUEVDVEVEX0RFQ09ERURfQUNDT1VOVCA9IDMyMzAwMDM7XG52YXIgU09MQU5BX0VSUk9SX19BQ0NPVU5UU19fRVhQRUNURURfQUxMX0FDQ09VTlRTX1RPX0JFX0RFQ09ERUQgPSAzMjMwMDA0O1xudmFyIFNPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fRElTQUxMT1dFRF9JTl9JTlNFQ1VSRV9DT05URVhUID0gMzYxZTQ7XG52YXIgU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19ESUdFU1RfVU5JTVBMRU1FTlRFRCA9IDM2MTAwMDE7XG52YXIgU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19FRDI1NTE5X0FMR09SSVRITV9VTklNUExFTUVOVEVEID0gMzYxMDAwMjtcbnZhciBTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX0VYUE9SVF9GVU5DVElPTl9VTklNUExFTUVOVEVEID0gMzYxMDAwMztcbnZhciBTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX0dFTkVSQVRFX0ZVTkNUSU9OX1VOSU1QTEVNRU5URUQgPSAzNjEwMDA0O1xudmFyIFNPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fU0lHTl9GVU5DVElPTl9VTklNUExFTUVOVEVEID0gMzYxMDAwNTtcbnZhciBTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX1ZFUklGWV9GVU5DVElPTl9VTklNUExFTUVOVEVEID0gMzYxMDAwNjtcbnZhciBTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX0NBTk5PVF9FWFBPUlRfTk9OX0VYVFJBQ1RBQkxFX0tFWSA9IDM2MTAwMDc7XG52YXIgU09MQU5BX0VSUk9SX19DUllQVE9fX1JBTkRPTV9WQUxVRVNfRlVOQ1RJT05fVU5JTVBMRU1FTlRFRCA9IDM2MTFlMztcbnZhciBTT0xBTkFfRVJST1JfX0tFWVNfX0lOVkFMSURfS0VZX1BBSVJfQllURV9MRU5HVEggPSAzNzA0ZTM7XG52YXIgU09MQU5BX0VSUk9SX19LRVlTX19JTlZBTElEX1BSSVZBVEVfS0VZX0JZVEVfTEVOR1RIID0gMzcwNDAwMTtcbnZhciBTT0xBTkFfRVJST1JfX0tFWVNfX0lOVkFMSURfU0lHTkFUVVJFX0JZVEVfTEVOR1RIID0gMzcwNDAwMjtcbnZhciBTT0xBTkFfRVJST1JfX0tFWVNfX1NJR05BVFVSRV9TVFJJTkdfTEVOR1RIX09VVF9PRl9SQU5HRSA9IDM3MDQwMDM7XG52YXIgU09MQU5BX0VSUk9SX19LRVlTX19QVUJMSUNfS0VZX01VU1RfTUFUQ0hfUFJJVkFURV9LRVkgPSAzNzA0MDA0O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fX0VYUEVDVEVEX1RPX0hBVkVfQUNDT1VOVFMgPSA0MTI4ZTM7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9fRVhQRUNURURfVE9fSEFWRV9EQVRBID0gNDEyODAwMTtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX19QUk9HUkFNX0lEX01JU01BVENIID0gNDEyODAwMjtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19VTktOT1dOID0gNDYxNWUzO1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0dFTkVSSUNfRVJST1IgPSA0NjE1MDAxO1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfQVJHVU1FTlQgPSA0NjE1MDAyO1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfSU5TVFJVQ1RJT05fREFUQSA9IDQ2MTUwMDM7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9BQ0NPVU5UX0RBVEEgPSA0NjE1MDA0O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfREFUQV9UT09fU01BTEwgPSA0NjE1MDA1O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOU1VGRklDSUVOVF9GVU5EUyA9IDQ2MTUwMDY7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5DT1JSRUNUX1BST0dSQU1fSUQgPSA0NjE1MDA3O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01JU1NJTkdfUkVRVUlSRURfU0lHTkFUVVJFID0gNDYxNTAwODtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BQ0NPVU5UX0FMUkVBRFlfSU5JVElBTElaRUQgPSA0NjE1MDA5O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1VOSU5JVElBTElaRURfQUNDT1VOVCA9IDQ2MTUwMTA7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fVU5CQUxBTkNFRF9JTlNUUlVDVElPTiA9IDQ2MTUwMTE7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTU9ESUZJRURfUFJPR1JBTV9JRCA9IDQ2MTUwMTI7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRVhURVJOQUxfQUNDT1VOVF9MQU1QT1JUX1NQRU5EID0gNDYxNTAxMztcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19FWFRFUk5BTF9BQ0NPVU5UX0RBVEFfTU9ESUZJRUQgPSA0NjE1MDE0O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1JFQURPTkxZX0xBTVBPUlRfQ0hBTkdFID0gNDYxNTAxNTtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19SRUFET05MWV9EQVRBX01PRElGSUVEID0gNDYxNTAxNjtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19EVVBMSUNBVEVfQUNDT1VOVF9JTkRFWCA9IDQ2MTUwMTc7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRVhFQ1VUQUJMRV9NT0RJRklFRCA9IDQ2MTUwMTg7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUkVOVF9FUE9DSF9NT0RJRklFRCA9IDQ2MTUwMTk7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTk9UX0VOT1VHSF9BQ0NPVU5UX0tFWVMgPSA0NjE1MDIwO1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfREFUQV9TSVpFX0NIQU5HRUQgPSA0NjE1MDIxO1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfTk9UX0VYRUNVVEFCTEUgPSA0NjE1MDIyO1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfQk9SUk9XX0ZBSUxFRCA9IDQ2MTUwMjM7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9CT1JST1dfT1VUU1RBTkRJTkcgPSA0NjE1MDI0O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0RVUExJQ0FURV9BQ0NPVU5UX09VVF9PRl9TWU5DID0gNDYxNTAyNTtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19DVVNUT00gPSA0NjE1MDI2O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfRVJST1IgPSA0NjE1MDI3O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0VYRUNVVEFCTEVfREFUQV9NT0RJRklFRCA9IDQ2MTUwMjg7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRVhFQ1VUQUJMRV9MQU1QT1JUX0NIQU5HRSA9IDQ2MTUwMjk7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRVhFQ1VUQUJMRV9BQ0NPVU5UX05PVF9SRU5UX0VYRU1QVCA9IDQ2MTUwMzA7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fVU5TVVBQT1JURURfUFJPR1JBTV9JRCA9IDQ2MTUwMzE7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQ0FMTF9ERVBUSCA9IDQ2MTUwMzI7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTUlTU0lOR19BQ0NPVU5UID0gNDYxNTAzMztcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19SRUVOVFJBTkNZX05PVF9BTExPV0VEID0gNDYxNTAzNDtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19NQVhfU0VFRF9MRU5HVEhfRVhDRUVERUQgPSA0NjE1MDM1O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfU0VFRFMgPSA0NjE1MDM2O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfUkVBTExPQyA9IDQ2MTUwMzc7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQ09NUFVUQVRJT05BTF9CVURHRVRfRVhDRUVERUQgPSA0NjE1MDM4O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1BSSVZJTEVHRV9FU0NBTEFUSU9OID0gNDYxNTAzOTtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19QUk9HUkFNX0VOVklST05NRU5UX1NFVFVQX0ZBSUxVUkUgPSA0NjE1MDQwO1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1BST0dSQU1fRkFJTEVEX1RPX0NPTVBMRVRFID0gNDYxNTA0MTtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19QUk9HUkFNX0ZBSUxFRF9UT19DT01QSUxFID0gNDYxNTA0MjtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTU1VVEFCTEUgPSA0NjE1MDQzO1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOQ09SUkVDVF9BVVRIT1JJVFkgPSA0NjE1MDQ0O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0JPUlNIX0lPX0VSUk9SID0gNDYxNTA0NTtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BQ0NPVU5UX05PVF9SRU5UX0VYRU1QVCA9IDQ2MTUwNDY7XG52YXIgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9BQ0NPVU5UX09XTkVSID0gNDYxNTA0NztcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BUklUSE1FVElDX09WRVJGTE9XID0gNDYxNTA0ODtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19VTlNVUFBPUlRFRF9TWVNWQVIgPSA0NjE1MDQ5O1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lMTEVHQUxfT1dORVIgPSA0NjE1MDUwO1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01BWF9BQ0NPVU5UU19EQVRBX0FMTE9DQVRJT05TX0VYQ0VFREVEID0gNDYxNTA1MTtcbnZhciBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19NQVhfQUNDT1VOVFNfRVhDRUVERUQgPSA0NjE1MDUyO1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01BWF9JTlNUUlVDVElPTl9UUkFDRV9MRU5HVEhfRVhDRUVERUQgPSA0NjE1MDUzO1xudmFyIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0JVSUxUSU5fUFJPR1JBTVNfTVVTVF9DT05TVU1FX0NPTVBVVEVfVU5JVFMgPSA0NjE1MDU0O1xudmFyIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19BRERSRVNTX0NBTk5PVF9IQVZFX01VTFRJUExFX1NJR05FUlMgPSA1NTA4ZTM7XG52YXIgU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX0tFWV9QQUlSX1NJR05FUiA9IDU1MDgwMDE7XG52YXIgU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX01FU1NBR0VfU0lHTkVSID0gNTUwODAwMjtcbnZhciBTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfTUVTU0FHRV9NT0RJRllJTkdfU0lHTkVSID0gNTUwODAwMztcbnZhciBTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfTUVTU0FHRV9QQVJUSUFMX1NJR05FUiA9IDU1MDgwMDQ7XG52YXIgU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX1RSQU5TQUNUSU9OX1NJR05FUiA9IDU1MDgwMDU7XG52YXIgU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX1RSQU5TQUNUSU9OX01PRElGWUlOR19TSUdORVIgPSA1NTA4MDA2O1xudmFyIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9UUkFOU0FDVElPTl9QQVJUSUFMX1NJR05FUiA9IDU1MDgwMDc7XG52YXIgU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX1RSQU5TQUNUSU9OX1NFTkRJTkdfU0lHTkVSID0gNTUwODAwODtcbnZhciBTT0xBTkFfRVJST1JfX1NJR05FUl9fVFJBTlNBQ1RJT05fQ0FOTk9UX0hBVkVfTVVMVElQTEVfU0VORElOR19TSUdORVJTID0gNTUwODAwOTtcbnZhciBTT0xBTkFfRVJST1JfX1NJR05FUl9fVFJBTlNBQ1RJT05fU0VORElOR19TSUdORVJfTUlTU0lORyA9IDU1MDgwMTA7XG52YXIgU09MQU5BX0VSUk9SX19TSUdORVJfX1dBTExFVF9NVUxUSVNJR05fVU5JTVBMRU1FTlRFRCA9IDU1MDgwMTE7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fSU5WT0tFRF9QUk9HUkFNU19DQU5OT1RfUEFZX0ZFRVMgPSA1NjYzZTM7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fSU5WT0tFRF9QUk9HUkFNU19NVVNUX05PVF9CRV9XUklUQUJMRSA9IDU2NjMwMDE7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRVhQRUNURURfQkxPQ0tIQVNIX0xJRkVUSU1FID0gNTY2MzAwMjtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19FWFBFQ1RFRF9OT05DRV9MSUZFVElNRSA9IDU2NjMwMDM7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fVkVSU0lPTl9OVU1CRVJfT1VUX09GX1JBTkdFID0gNTY2MzAwNDtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GQUlMRURfVE9fREVDT01QSUxFX0FERFJFU1NfTE9PS1VQX1RBQkxFX0NPTlRFTlRTX01JU1NJTkcgPSA1NjYzMDA1O1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9UT19ERUNPTVBJTEVfQUREUkVTU19MT09LVVBfVEFCTEVfSU5ERVhfT1VUX09GX1JBTkdFID0gNTY2MzAwNjtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GQUlMRURfVE9fREVDT01QSUxFX0lOU1RSVUNUSU9OX1BST0dSQU1fQUREUkVTU19OT1RfRk9VTkQgPSA1NjYzMDA3O1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9UT19ERUNPTVBJTEVfRkVFX1BBWUVSX01JU1NJTkcgPSA1NjYzMDA4O1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX1NJR05BVFVSRVNfTUlTU0lORyA9IDU2NjMwMDk7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fQUREUkVTU19NSVNTSU5HID0gNTY2MzAxMDtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GRUVfUEFZRVJfTUlTU0lORyA9IDU2NjMwMTE7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkVFX1BBWUVSX1NJR05BVFVSRV9NSVNTSU5HID0gNTY2MzAxMjtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19JTlZBTElEX05PTkNFX1RSQU5TQUNUSU9OX0lOU1RSVUNUSU9OU19NSVNTSU5HID0gNTY2MzAxMztcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19JTlZBTElEX05PTkNFX1RSQU5TQUNUSU9OX0ZJUlNUX0lOU1RSVUNUSU9OX01VU1RfQkVfQURWQU5DRV9OT05DRSA9IDU2NjMwMTQ7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fQUREUkVTU0VTX0NBTk5PVF9TSUdOX1RSQU5TQUNUSU9OID0gNTY2MzAxNTtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19DQU5OT1RfRU5DT0RFX1dJVEhfRU1QVFlfU0lHTkFUVVJFUyA9IDU2NjMwMTY7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fTUVTU0FHRV9TSUdOQVRVUkVTX01JU01BVENIID0gNTY2MzAxNztcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GQUlMRURfVE9fRVNUSU1BVEVfQ09NUFVURV9MSU1JVCA9IDU2NjMwMTg7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkFJTEVEX1dIRU5fU0lNVUxBVElOR19UT19FU1RJTUFURV9DT01QVVRFX0xJTUlUID0gNTY2MzAxOTtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19FWENFRURTX1NJWkVfTElNSVQgPSA1NjYzMDIwO1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1VOS05PV04gPSA3MDVlNDtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19BQ0NPVU5UX0lOX1VTRSA9IDcwNTAwMDE7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQUNDT1VOVF9MT0FERURfVFdJQ0UgPSA3MDUwMDAyO1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0FDQ09VTlRfTk9UX0ZPVU5EID0gNzA1MDAwMztcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19QUk9HUkFNX0FDQ09VTlRfTk9UX0ZPVU5EID0gNzA1MDAwNDtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlNVRkZJQ0lFTlRfRlVORFNfRk9SX0ZFRSA9IDcwNTAwMDU7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9BQ0NPVU5UX0ZPUl9GRUUgPSA3MDUwMDA2O1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0FMUkVBRFlfUFJPQ0VTU0VEID0gNzA1MDAwNztcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19CTE9DS0hBU0hfTk9UX0ZPVU5EID0gNzA1MDAwODtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19DQUxMX0NIQUlOX1RPT19ERUVQID0gNzA1MDAwOTtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19NSVNTSU5HX1NJR05BVFVSRV9GT1JfRkVFID0gNzA1MDAxMDtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX0FDQ09VTlRfSU5ERVggPSA3MDUwMDExO1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1NJR05BVFVSRV9GQUlMVVJFID0gNzA1MDAxMjtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX1BST0dSQU1fRk9SX0VYRUNVVElPTiA9IDcwNTAwMTM7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fU0FOSVRJWkVfRkFJTFVSRSA9IDcwNTAwMTQ7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQ0xVU1RFUl9NQUlOVEVOQU5DRSA9IDcwNTAwMTU7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQUNDT1VOVF9CT1JST1dfT1VUU1RBTkRJTkcgPSA3MDUwMDE2O1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1dPVUxEX0VYQ0VFRF9NQVhfQkxPQ0tfQ09TVF9MSU1JVCA9IDcwNTAwMTc7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fVU5TVVBQT1JURURfVkVSU0lPTiA9IDcwNTAwMTg7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9XUklUQUJMRV9BQ0NPVU5UID0gNzA1MDAxOTtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19XT1VMRF9FWENFRURfTUFYX0FDQ09VTlRfQ09TVF9MSU1JVCA9IDcwNTAwMjA7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fV09VTERfRVhDRUVEX0FDQ09VTlRfREFUQV9CTE9DS19MSU1JVCA9IDcwNTAwMjE7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fVE9PX01BTllfQUNDT1VOVF9MT0NLUyA9IDcwNTAwMjI7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQUREUkVTU19MT09LVVBfVEFCTEVfTk9UX0ZPVU5EID0gNzA1MDAyMztcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX0FERFJFU1NfTE9PS1VQX1RBQkxFX09XTkVSID0gNzA1MDAyNDtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX0FERFJFU1NfTE9PS1VQX1RBQkxFX0RBVEEgPSA3MDUwMDI1O1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfQUREUkVTU19MT09LVVBfVEFCTEVfSU5ERVggPSA3MDUwMDI2O1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfUkVOVF9QQVlJTkdfQUNDT1VOVCA9IDcwNTAwMjc7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fV09VTERfRVhDRUVEX01BWF9WT1RFX0NPU1RfTElNSVQgPSA3MDUwMDI4O1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1dPVUxEX0VYQ0VFRF9BQ0NPVU5UX0RBVEFfVE9UQUxfTElNSVQgPSA3MDUwMDI5O1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0RVUExJQ0FURV9JTlNUUlVDVElPTiA9IDcwNTAwMzA7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5TVUZGSUNJRU5UX0ZVTkRTX0ZPUl9SRU5UID0gNzA1MDAzMTtcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19NQVhfTE9BREVEX0FDQ09VTlRTX0RBVEFfU0laRV9FWENFRURFRCA9IDcwNTAwMzI7XG52YXIgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9MT0FERURfQUNDT1VOVFNfREFUQV9TSVpFX0xJTUlUID0gNzA1MDAzMztcbnZhciBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19SRVNBTklUSVpBVElPTl9ORUVERUQgPSA3MDUwMDM0O1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1BST0dSQU1fRVhFQ1VUSU9OX1RFTVBPUkFSSUxZX1JFU1RSSUNURUQgPSA3MDUwMDM1O1xudmFyIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1VOQkFMQU5DRURfVFJBTlNBQ1RJT04gPSA3MDUwMDM2O1xudmFyIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19DQU5OT1RfREVDT0RFX0VNUFRZX0JZVEVfQVJSQVkgPSA4MDc4ZTM7XG52YXIgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfQllURV9MRU5HVEggPSA4MDc4MDAxO1xudmFyIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9GSVhFRF9MRU5HVEggPSA4MDc4MDAyO1xudmFyIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9WQVJJQUJMRV9MRU5HVEggPSA4MDc4MDAzO1xudmFyIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfU0laRV9DT01QQVRJQklMSVRZX01JU01BVENIID0gODA3ODAwNDtcbnZhciBTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFUl9ERUNPREVSX0ZJWEVEX1NJWkVfTUlTTUFUQ0ggPSA4MDc4MDA1O1xudmFyIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfTUFYX1NJWkVfTUlTTUFUQ0ggPSA4MDc4MDA2O1xudmFyIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX05VTUJFUl9PRl9JVEVNUyA9IDgwNzgwMDc7XG52YXIgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOVU1fRElTQ1JJTUlOQVRPUl9PVVRfT0ZfUkFOR0UgPSA4MDc4MDA4O1xudmFyIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0RJU0NSSU1JTkFURURfVU5JT05fVkFSSUFOVCA9IDgwNzgwMDk7XG52YXIgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfRU5VTV9WQVJJQU5UID0gODA3ODAxMDtcbnZhciBTT0xBTkFfRVJST1JfX0NPREVDU19fTlVNQkVSX09VVF9PRl9SQU5HRSA9IDgwNzgwMTE7XG52YXIgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfU1RSSU5HX0ZPUl9CQVNFID0gODA3ODAxMjtcbnZhciBTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfUE9TSVRJVkVfQllURV9MRU5HVEggPSA4MDc4MDEzO1xudmFyIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19PRkZTRVRfT1VUX09GX1JBTkdFID0gODA3ODAxNDtcbnZhciBTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9MSVRFUkFMX1VOSU9OX1ZBUklBTlQgPSA4MDc4MDE1O1xudmFyIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19MSVRFUkFMX1VOSU9OX0RJU0NSSU1JTkFUT1JfT1VUX09GX1JBTkdFID0gODA3ODAxNjtcbnZhciBTT0xBTkFfRVJST1JfX0NPREVDU19fVU5JT05fVkFSSUFOVF9PVVRfT0ZfUkFOR0UgPSA4MDc4MDE3O1xudmFyIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0NPTlNUQU5UID0gODA3ODAxODtcbnZhciBTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfWkVST19WQUxVRV9UT19NQVRDSF9JVEVNX0ZJWEVEX1NJWkUgPSA4MDc4MDE5O1xudmFyIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVEX0JZVEVTX01VU1RfTk9UX0lOQ0xVREVfU0VOVElORUwgPSA4MDc4MDIwO1xudmFyIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19TRU5USU5FTF9NSVNTSU5HX0lOX0RFQ09ERURfQllURVMgPSA4MDc4MDIxO1xudmFyIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19DQU5OT1RfVVNFX0xFWElDQUxfVkFMVUVTX0FTX0VOVU1fRElTQ1JJTUlOQVRPUlMgPSA4MDc4MDIyO1xudmFyIFNPTEFOQV9FUlJPUl9fUlBDX19JTlRFR0VSX09WRVJGTE9XID0gODFlNTtcbnZhciBTT0xBTkFfRVJST1JfX1JQQ19fVFJBTlNQT1JUX0hUVFBfSEVBREVSX0ZPUkJJRERFTiA9IDgxMDAwMDE7XG52YXIgU09MQU5BX0VSUk9SX19SUENfX1RSQU5TUE9SVF9IVFRQX0VSUk9SID0gODEwMDAwMjtcbnZhciBTT0xBTkFfRVJST1JfX1JQQ19fQVBJX1BMQU5fTUlTU0lOR19GT1JfUlBDX01FVEhPRCA9IDgxMDAwMDM7XG52YXIgU09MQU5BX0VSUk9SX19SUENfU1VCU0NSSVBUSU9OU19fQ0FOTk9UX0NSRUFURV9TVUJTQ1JJUFRJT05fUExBTiA9IDgxOWU0O1xudmFyIFNPTEFOQV9FUlJPUl9fUlBDX1NVQlNDUklQVElPTlNfX0VYUEVDVEVEX1NFUlZFUl9TVUJTQ1JJUFRJT05fSUQgPSA4MTkwMDAxO1xudmFyIFNPTEFOQV9FUlJPUl9fUlBDX1NVQlNDUklQVElPTlNfX0NIQU5ORUxfQ0xPU0VEX0JFRk9SRV9NRVNTQUdFX0JVRkZFUkVEID0gODE5MDAwMjtcbnZhciBTT0xBTkFfRVJST1JfX1JQQ19TVUJTQ1JJUFRJT05TX19DSEFOTkVMX0NPTk5FQ1RJT05fQ0xPU0VEID0gODE5MDAwMztcbnZhciBTT0xBTkFfRVJST1JfX1JQQ19TVUJTQ1JJUFRJT05TX19DSEFOTkVMX0ZBSUxFRF9UT19DT05ORUNUID0gODE5MDAwNDtcbnZhciBTT0xBTkFfRVJST1JfX0lOVkFSSUFOVF9WSU9MQVRJT05fX1NVQlNDUklQVElPTl9JVEVSQVRPUl9TVEFURV9NSVNTSU5HID0gOTllNTtcbnZhciBTT0xBTkFfRVJST1JfX0lOVkFSSUFOVF9WSU9MQVRJT05fX1NVQlNDUklQVElPTl9JVEVSQVRPUl9NVVNUX05PVF9QT0xMX0JFRk9SRV9SRVNPTFZJTkdfRVhJU1RJTkdfTUVTU0FHRV9QUk9NSVNFID0gOTkwMDAwMTtcbnZhciBTT0xBTkFfRVJST1JfX0lOVkFSSUFOVF9WSU9MQVRJT05fX0NBQ0hFRF9BQk9SVEFCTEVfSVRFUkFCTEVfQ0FDSEVfRU5UUllfTUlTU0lORyA9IDk5MDAwMDI7XG52YXIgU09MQU5BX0VSUk9SX19JTlZBUklBTlRfVklPTEFUSU9OX19TV0lUQ0hfTVVTVF9CRV9FWEhBVVNUSVZFID0gOTkwMDAwMztcbnZhciBTT0xBTkFfRVJST1JfX0lOVkFSSUFOVF9WSU9MQVRJT05fX0RBVEFfUFVCTElTSEVSX0NIQU5ORUxfVU5JTVBMRU1FTlRFRCA9IDk5MDAwMDQ7XG5cbi8vIHNyYy9jb250ZXh0LnRzXG5mdW5jdGlvbiBlbmNvZGVWYWx1ZSh2YWx1ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBjb25zdCBjb21tYVNlcGFyYXRlZFZhbHVlcyA9IHZhbHVlLm1hcChlbmNvZGVWYWx1ZSkuam9pbihcbiAgICAgIFwiJTJDJTIwXCJcbiAgICAgIC8qIFwiLCBcIiAqL1xuICAgICk7XG4gICAgcmV0dXJuIFwiJTVCXCIgKyBjb21tYVNlcGFyYXRlZFZhbHVlcyArIC8qIFwiXVwiICovXG4gICAgXCIlNURcIjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYmlnaW50XCIpIHtcbiAgICByZXR1cm4gYCR7dmFsdWV9bmA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChcbiAgICAgIFN0cmluZyhcbiAgICAgICAgdmFsdWUgIT0gbnVsbCAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpID09PSBudWxsID8gKFxuICAgICAgICAgIC8vIFBsYWluIG9iamVjdHMgd2l0aCBubyBwcm90b3R5cGUgZG9uJ3QgaGF2ZSBhIGB0b1N0cmluZ2AgbWV0aG9kLlxuICAgICAgICAgIC8vIENvbnZlcnQgdGhlbSBiZWZvcmUgc3RyaW5naWZ5aW5nIHRoZW0uXG4gICAgICAgICAgeyAuLi52YWx1ZSB9XG4gICAgICAgICkgOiB2YWx1ZVxuICAgICAgKVxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVuY29kZU9iamVjdENvbnRleHRFbnRyeShba2V5LCB2YWx1ZV0pIHtcbiAgcmV0dXJuIGAke2tleX09JHtlbmNvZGVWYWx1ZSh2YWx1ZSl9YDtcbn1cbmZ1bmN0aW9uIGVuY29kZUNvbnRleHRPYmplY3QoY29udGV4dCkge1xuICBjb25zdCBzZWFyY2hQYXJhbXNTdHJpbmcgPSBPYmplY3QuZW50cmllcyhjb250ZXh0KS5tYXAoZW5jb2RlT2JqZWN0Q29udGV4dEVudHJ5KS5qb2luKFwiJlwiKTtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlYXJjaFBhcmFtc1N0cmluZywgXCJ1dGY4XCIpLnRvU3RyaW5nKFwiYmFzZTY0XCIpIDtcbn1cblxuLy8gc3JjL21lc3NhZ2VzLnRzXG52YXIgU29sYW5hRXJyb3JNZXNzYWdlcyA9IHtcbiAgW1NPTEFOQV9FUlJPUl9fQUNDT1VOVFNfX0FDQ09VTlRfTk9UX0ZPVU5EXTogXCJBY2NvdW50IG5vdCBmb3VuZCBhdCBhZGRyZXNzOiAkYWRkcmVzc1wiLFxuICBbU09MQU5BX0VSUk9SX19BQ0NPVU5UU19fRVhQRUNURURfQUxMX0FDQ09VTlRTX1RPX0JFX0RFQ09ERURdOiBcIk5vdCBhbGwgYWNjb3VudHMgd2VyZSBkZWNvZGVkLiBFbmNvZGVkIGFjY291bnRzIGZvdW5kIGF0IGFkZHJlc3NlczogJGFkZHJlc3Nlcy5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQUNDT1VOVFNfX0VYUEVDVEVEX0RFQ09ERURfQUNDT1VOVF06IFwiRXhwZWN0ZWQgZGVjb2RlZCBhY2NvdW50IGF0IGFkZHJlc3M6ICRhZGRyZXNzXCIsXG4gIFtTT0xBTkFfRVJST1JfX0FDQ09VTlRTX19GQUlMRURfVE9fREVDT0RFX0FDQ09VTlRdOiBcIkZhaWxlZCB0byBkZWNvZGUgYWNjb3VudCBkYXRhIGF0IGFkZHJlc3M6ICRhZGRyZXNzXCIsXG4gIFtTT0xBTkFfRVJST1JfX0FDQ09VTlRTX19PTkVfT1JfTU9SRV9BQ0NPVU5UU19OT1RfRk9VTkRdOiBcIkFjY291bnRzIG5vdCBmb3VuZCBhdCBhZGRyZXNzZXM6ICRhZGRyZXNzZXNcIixcbiAgW1NPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19GQUlMRURfVE9fRklORF9WSUFCTEVfUERBX0JVTVBfU0VFRF06IFwiVW5hYmxlIHRvIGZpbmQgYSB2aWFibGUgcHJvZ3JhbSBhZGRyZXNzIGJ1bXAgc2VlZC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19JTlZBTElEX0JBU0U1OF9FTkNPREVEX0FERFJFU1NdOiBcIiRwdXRhdGl2ZUFkZHJlc3MgaXMgbm90IGEgYmFzZTU4LWVuY29kZWQgYWRkcmVzcy5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19JTlZBTElEX0JZVEVfTEVOR1RIXTogXCJFeHBlY3RlZCBiYXNlNTggZW5jb2RlZCBhZGRyZXNzIHRvIGRlY29kZSB0byBhIGJ5dGUgYXJyYXkgb2YgbGVuZ3RoIDMyLiBBY3R1YWwgbGVuZ3RoOiAkYWN0dWFsTGVuZ3RoLlwiLFxuICBbU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX0lOVkFMSURfRUQyNTUxOV9QVUJMSUNfS0VZXTogXCJUaGUgYENyeXB0b0tleWAgbXVzdCBiZSBhbiBgRWQyNTUxOWAgcHVibGljIGtleS5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19JTlZBTElEX09GRl9DVVJWRV9BRERSRVNTXTogXCIkcHV0YXRpdmVPZmZDdXJ2ZUFkZHJlc3MgaXMgbm90IGEgYmFzZTU4LWVuY29kZWQgb2ZmLWN1cnZlIGFkZHJlc3MuXCIsXG4gIFtTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fSU5WQUxJRF9TRUVEU19QT0lOVF9PTl9DVVJWRV06IFwiSW52YWxpZCBzZWVkczsgcG9pbnQgbXVzdCBmYWxsIG9mZiB0aGUgRWQyNTUxOSBjdXJ2ZS5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19NQUxGT1JNRURfUERBXTogXCJFeHBlY3RlZCBnaXZlbiBwcm9ncmFtIGRlcml2ZWQgYWRkcmVzcyB0byBoYXZlIHRoZSBmb2xsb3dpbmcgZm9ybWF0OiBbQWRkcmVzcywgUHJvZ3JhbURlcml2ZWRBZGRyZXNzQnVtcF0uXCIsXG4gIFtTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fTUFYX05VTUJFUl9PRl9QREFfU0VFRFNfRVhDRUVERURdOiBcIkEgbWF4aW11bSBvZiAkbWF4U2VlZHMgc2VlZHMsIGluY2x1ZGluZyB0aGUgYnVtcCBzZWVkLCBtYXkgYmUgc3VwcGxpZWQgd2hlbiBjcmVhdGluZyBhbiBhZGRyZXNzLiBSZWNlaXZlZDogJGFjdHVhbC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19NQVhfUERBX1NFRURfTEVOR1RIX0VYQ0VFREVEXTogXCJUaGUgc2VlZCBhdCBpbmRleCAkaW5kZXggd2l0aCBsZW5ndGggJGFjdHVhbCBleGNlZWRzIHRoZSBtYXhpbXVtIGxlbmd0aCBvZiAkbWF4U2VlZExlbmd0aCBieXRlcy5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19QREFfQlVNUF9TRUVEX09VVF9PRl9SQU5HRV06IFwiRXhwZWN0ZWQgcHJvZ3JhbSBkZXJpdmVkIGFkZHJlc3MgYnVtcCB0byBiZSBpbiB0aGUgcmFuZ2UgWzAsIDI1NV0sIGdvdDogJGJ1bXAuXCIsXG4gIFtTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fUERBX0VORFNfV0lUSF9QREFfTUFSS0VSXTogXCJQcm9ncmFtIGFkZHJlc3MgY2Fubm90IGVuZCB3aXRoIFBEQSBtYXJrZXIuXCIsXG4gIFtTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fU1RSSU5HX0xFTkdUSF9PVVRfT0ZfUkFOR0VdOiBcIkV4cGVjdGVkIGJhc2U1OC1lbmNvZGVkIGFkZHJlc3Mgc3RyaW5nIG9mIGxlbmd0aCBpbiB0aGUgcmFuZ2UgWzMyLCA0NF0uIEFjdHVhbCBsZW5ndGg6ICRhY3R1YWxMZW5ndGguXCIsXG4gIFtTT0xBTkFfRVJST1JfX0JMT0NLSEFTSF9TVFJJTkdfTEVOR1RIX09VVF9PRl9SQU5HRV06IFwiRXhwZWN0ZWQgYmFzZTU4LWVuY29kZWQgYmxvY2thc2ggc3RyaW5nIG9mIGxlbmd0aCBpbiB0aGUgcmFuZ2UgWzMyLCA0NF0uIEFjdHVhbCBsZW5ndGg6ICRhY3R1YWxMZW5ndGguXCIsXG4gIFtTT0xBTkFfRVJST1JfX0JMT0NLX0hFSUdIVF9FWENFRURFRF06IFwiVGhlIG5ldHdvcmsgaGFzIHByb2dyZXNzZWQgcGFzdCB0aGUgbGFzdCBibG9jayBmb3Igd2hpY2ggdGhpcyB0cmFuc2FjdGlvbiBjb3VsZCBoYXZlIGJlZW4gY29tbWl0dGVkLlwiLFxuICBbU09MQU5BX0VSUk9SX19DT0RFQ1NfX0NBTk5PVF9ERUNPREVfRU1QVFlfQllURV9BUlJBWV06IFwiQ29kZWMgWyRjb2RlY0Rlc2NyaXB0aW9uXSBjYW5ub3QgZGVjb2RlIGVtcHR5IGJ5dGUgYXJyYXlzLlwiLFxuICBbU09MQU5BX0VSUk9SX19DT0RFQ1NfX0NBTk5PVF9VU0VfTEVYSUNBTF9WQUxVRVNfQVNfRU5VTV9ESVNDUklNSU5BVE9SU106IFwiRW51bSBjb2RlYyBjYW5ub3QgdXNlIGxleGljYWwgdmFsdWVzIFskc3RyaW5nVmFsdWVzXSBhcyBkaXNjcmltaW5hdG9ycy4gRWl0aGVyIHJlbW92ZSBhbGwgbGV4aWNhbCB2YWx1ZXMgb3Igc2V0IGB1c2VWYWx1ZXNBc0Rpc2NyaW1pbmF0b3JzYCB0byBgZmFsc2VgLlwiLFxuICBbU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERURfQllURVNfTVVTVF9OT1RfSU5DTFVERV9TRU5USU5FTF06IFwiU2VudGluZWwgWyRoZXhTZW50aW5lbF0gbXVzdCBub3QgYmUgcHJlc2VudCBpbiBlbmNvZGVkIGJ5dGVzIFskaGV4RW5jb2RlZEJ5dGVzXS5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfRklYRURfU0laRV9NSVNNQVRDSF06IFwiRW5jb2RlciBhbmQgZGVjb2RlciBtdXN0IGhhdmUgdGhlIHNhbWUgZml4ZWQgc2l6ZSwgZ290IFskZW5jb2RlckZpeGVkU2l6ZV0gYW5kIFskZGVjb2RlckZpeGVkU2l6ZV0uXCIsXG4gIFtTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFUl9ERUNPREVSX01BWF9TSVpFX01JU01BVENIXTogXCJFbmNvZGVyIGFuZCBkZWNvZGVyIG11c3QgaGF2ZSB0aGUgc2FtZSBtYXggc2l6ZSwgZ290IFskZW5jb2Rlck1heFNpemVdIGFuZCBbJGRlY29kZXJNYXhTaXplXS5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfU0laRV9DT01QQVRJQklMSVRZX01JU01BVENIXTogXCJFbmNvZGVyIGFuZCBkZWNvZGVyIG11c3QgZWl0aGVyIGJvdGggYmUgZml4ZWQtc2l6ZSBvciB2YXJpYWJsZS1zaXplLlwiLFxuICBbU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOVU1fRElTQ1JJTUlOQVRPUl9PVVRfT0ZfUkFOR0VdOiBcIkVudW0gZGlzY3JpbWluYXRvciBvdXQgb2YgcmFuZ2UuIEV4cGVjdGVkIGEgbnVtYmVyIGluIFskZm9ybWF0dGVkVmFsaWREaXNjcmltaW5hdG9yc10sIGdvdCAkZGlzY3JpbWluYXRvci5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9GSVhFRF9MRU5HVEhdOiBcIkV4cGVjdGVkIGEgZml4ZWQtc2l6ZSBjb2RlYywgZ290IGEgdmFyaWFibGUtc2l6ZSBvbmUuXCIsXG4gIFtTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfUE9TSVRJVkVfQllURV9MRU5HVEhdOiBcIkNvZGVjIFskY29kZWNEZXNjcmlwdGlvbl0gZXhwZWN0ZWQgYSBwb3NpdGl2ZSBieXRlIGxlbmd0aCwgZ290ICRieXRlc0xlbmd0aC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9WQVJJQUJMRV9MRU5HVEhdOiBcIkV4cGVjdGVkIGEgdmFyaWFibGUtc2l6ZSBjb2RlYywgZ290IGEgZml4ZWQtc2l6ZSBvbmUuXCIsXG4gIFtTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfWkVST19WQUxVRV9UT19NQVRDSF9JVEVNX0ZJWEVEX1NJWkVdOiBcIkNvZGVjIFskY29kZWNEZXNjcmlwdGlvbl0gZXhwZWN0ZWQgemVyby12YWx1ZSBbJGhleFplcm9WYWx1ZV0gdG8gaGF2ZSB0aGUgc2FtZSBzaXplIGFzIHRoZSBwcm92aWRlZCBmaXhlZC1zaXplIGl0ZW0gWyRleHBlY3RlZFNpemUgYnl0ZXNdLlwiLFxuICBbU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfQllURV9MRU5HVEhdOiBcIkNvZGVjIFskY29kZWNEZXNjcmlwdGlvbl0gZXhwZWN0ZWQgJGV4cGVjdGVkIGJ5dGVzLCBnb3QgJGJ5dGVzTGVuZ3RoLlwiLFxuICBbU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfQ09OU1RBTlRdOiBcIkV4cGVjdGVkIGJ5dGUgYXJyYXkgY29uc3RhbnQgWyRoZXhDb25zdGFudF0gdG8gYmUgcHJlc2VudCBpbiBkYXRhIFskaGV4RGF0YV0gYXQgb2Zmc2V0IFskb2Zmc2V0XS5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0RJU0NSSU1JTkFURURfVU5JT05fVkFSSUFOVF06IFwiSW52YWxpZCBkaXNjcmltaW5hdGVkIHVuaW9uIHZhcmlhbnQuIEV4cGVjdGVkIG9uZSBvZiBbJHZhcmlhbnRzXSwgZ290ICR2YWx1ZS5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0VOVU1fVkFSSUFOVF06IFwiSW52YWxpZCBlbnVtIHZhcmlhbnQuIEV4cGVjdGVkIG9uZSBvZiBbJHN0cmluZ1ZhbHVlc10gb3IgYSBudW1iZXIgaW4gWyRmb3JtYXR0ZWROdW1lcmljYWxWYWx1ZXNdLCBnb3QgJHZhcmlhbnQuXCIsXG4gIFtTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9MSVRFUkFMX1VOSU9OX1ZBUklBTlRdOiBcIkludmFsaWQgbGl0ZXJhbCB1bmlvbiB2YXJpYW50LiBFeHBlY3RlZCBvbmUgb2YgWyR2YXJpYW50c10sIGdvdCAkdmFsdWUuXCIsXG4gIFtTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9OVU1CRVJfT0ZfSVRFTVNdOiBcIkV4cGVjdGVkIFskY29kZWNEZXNjcmlwdGlvbl0gdG8gaGF2ZSAkZXhwZWN0ZWQgaXRlbXMsIGdvdCAkYWN0dWFsLlwiLFxuICBbU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfU1RSSU5HX0ZPUl9CQVNFXTogXCJJbnZhbGlkIHZhbHVlICR2YWx1ZSBmb3IgYmFzZSAkYmFzZSB3aXRoIGFscGhhYmV0ICRhbHBoYWJldC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQ09ERUNTX19MSVRFUkFMX1VOSU9OX0RJU0NSSU1JTkFUT1JfT1VUX09GX1JBTkdFXTogXCJMaXRlcmFsIHVuaW9uIGRpc2NyaW1pbmF0b3Igb3V0IG9mIHJhbmdlLiBFeHBlY3RlZCBhIG51bWJlciBiZXR3ZWVuICRtaW5SYW5nZSBhbmQgJG1heFJhbmdlLCBnb3QgJGRpc2NyaW1pbmF0b3IuXCIsXG4gIFtTT0xBTkFfRVJST1JfX0NPREVDU19fTlVNQkVSX09VVF9PRl9SQU5HRV06IFwiQ29kZWMgWyRjb2RlY0Rlc2NyaXB0aW9uXSBleHBlY3RlZCBudW1iZXIgdG8gYmUgaW4gdGhlIHJhbmdlIFskbWluLCAkbWF4XSwgZ290ICR2YWx1ZS5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQ09ERUNTX19PRkZTRVRfT1VUX09GX1JBTkdFXTogXCJDb2RlYyBbJGNvZGVjRGVzY3JpcHRpb25dIGV4cGVjdGVkIG9mZnNldCB0byBiZSBpbiB0aGUgcmFuZ2UgWzAsICRieXRlc0xlbmd0aF0sIGdvdCAkb2Zmc2V0LlwiLFxuICBbU09MQU5BX0VSUk9SX19DT0RFQ1NfX1NFTlRJTkVMX01JU1NJTkdfSU5fREVDT0RFRF9CWVRFU106IFwiRXhwZWN0ZWQgc2VudGluZWwgWyRoZXhTZW50aW5lbF0gdG8gYmUgcHJlc2VudCBpbiBkZWNvZGVkIGJ5dGVzIFskaGV4RGVjb2RlZEJ5dGVzXS5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQ09ERUNTX19VTklPTl9WQVJJQU5UX09VVF9PRl9SQU5HRV06IFwiVW5pb24gdmFyaWFudCBvdXQgb2YgcmFuZ2UuIEV4cGVjdGVkIGFuIGluZGV4IGJldHdlZW4gJG1pblJhbmdlIGFuZCAkbWF4UmFuZ2UsIGdvdCAkdmFyaWFudC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fQ1JZUFRPX19SQU5ET01fVkFMVUVTX0ZVTkNUSU9OX1VOSU1QTEVNRU5URURdOiBcIk5vIHJhbmRvbSB2YWx1ZXMgaW1wbGVtZW50YXRpb24gY291bGQgYmUgZm91bmQuXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BQ0NPVU5UX0FMUkVBRFlfSU5JVElBTElaRURdOiBcImluc3RydWN0aW9uIHJlcXVpcmVzIGFuIHVuaW5pdGlhbGl6ZWQgYWNjb3VudFwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9CT1JST1dfRkFJTEVEXTogXCJpbnN0cnVjdGlvbiB0cmllcyB0byBib3Jyb3cgcmVmZXJlbmNlIGZvciBhbiBhY2NvdW50IHdoaWNoIGlzIGFscmVhZHkgYm9ycm93ZWRcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfQk9SUk9XX09VVFNUQU5ESU5HXTogXCJpbnN0cnVjdGlvbiBsZWZ0IGFjY291bnQgd2l0aCBhbiBvdXRzdGFuZGluZyBib3Jyb3dlZCByZWZlcmVuY2VcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfREFUQV9TSVpFX0NIQU5HRURdOiBcInByb2dyYW0gb3RoZXIgdGhhbiB0aGUgYWNjb3VudCdzIG93bmVyIGNoYW5nZWQgdGhlIHNpemUgb2YgdGhlIGFjY291bnQgZGF0YVwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9EQVRBX1RPT19TTUFMTF06IFwiYWNjb3VudCBkYXRhIHRvbyBzbWFsbCBmb3IgaW5zdHJ1Y3Rpb25cIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfTk9UX0VYRUNVVEFCTEVdOiBcImluc3RydWN0aW9uIGV4cGVjdGVkIGFuIGV4ZWN1dGFibGUgYWNjb3VudFwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9OT1RfUkVOVF9FWEVNUFRdOiBcIkFuIGFjY291bnQgZG9lcyBub3QgaGF2ZSBlbm91Z2ggbGFtcG9ydHMgdG8gYmUgcmVudC1leGVtcHRcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FSSVRITUVUSUNfT1ZFUkZMT1ddOiBcIlByb2dyYW0gYXJpdGhtZXRpYyBvdmVyZmxvd2VkXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19CT1JTSF9JT19FUlJPUl06IFwiRmFpbGVkIHRvIHNlcmlhbGl6ZSBvciBkZXNlcmlhbGl6ZSBhY2NvdW50IGRhdGE6ICRlbmNvZGVkRGF0YVwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQlVJTFRJTl9QUk9HUkFNU19NVVNUX0NPTlNVTUVfQ09NUFVURV9VTklUU106IFwiQnVpbHRpbiBwcm9ncmFtcyBtdXN0IGNvbnN1bWUgY29tcHV0ZSB1bml0c1wiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQ0FMTF9ERVBUSF06IFwiQ3Jvc3MtcHJvZ3JhbSBpbnZvY2F0aW9uIGNhbGwgZGVwdGggdG9vIGRlZXBcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0NPTVBVVEFUSU9OQUxfQlVER0VUX0VYQ0VFREVEXTogXCJDb21wdXRhdGlvbmFsIGJ1ZGdldCBleGNlZWRlZFwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQ1VTVE9NXTogXCJjdXN0b20gcHJvZ3JhbSBlcnJvcjogIyRjb2RlXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19EVVBMSUNBVEVfQUNDT1VOVF9JTkRFWF06IFwiaW5zdHJ1Y3Rpb24gY29udGFpbnMgZHVwbGljYXRlIGFjY291bnRzXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19EVVBMSUNBVEVfQUNDT1VOVF9PVVRfT0ZfU1lOQ106IFwiaW5zdHJ1Y3Rpb24gbW9kaWZpY2F0aW9ucyBvZiBtdWx0aXBseS1wYXNzZWQgYWNjb3VudCBkaWZmZXJcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0VYRUNVVEFCTEVfQUNDT1VOVF9OT1RfUkVOVF9FWEVNUFRdOiBcImV4ZWN1dGFibGUgYWNjb3VudHMgbXVzdCBiZSByZW50IGV4ZW1wdFwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRVhFQ1VUQUJMRV9EQVRBX01PRElGSUVEXTogXCJpbnN0cnVjdGlvbiBjaGFuZ2VkIGV4ZWN1dGFibGUgYWNjb3VudHMgZGF0YVwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRVhFQ1VUQUJMRV9MQU1QT1JUX0NIQU5HRV06IFwiaW5zdHJ1Y3Rpb24gY2hhbmdlZCB0aGUgYmFsYW5jZSBvZiBhbiBleGVjdXRhYmxlIGFjY291bnRcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0VYRUNVVEFCTEVfTU9ESUZJRURdOiBcImluc3RydWN0aW9uIGNoYW5nZWQgZXhlY3V0YWJsZSBiaXQgb2YgYW4gYWNjb3VudFwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRVhURVJOQUxfQUNDT1VOVF9EQVRBX01PRElGSUVEXTogXCJpbnN0cnVjdGlvbiBtb2RpZmllZCBkYXRhIG9mIGFuIGFjY291bnQgaXQgZG9lcyBub3Qgb3duXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19FWFRFUk5BTF9BQ0NPVU5UX0xBTVBPUlRfU1BFTkRdOiBcImluc3RydWN0aW9uIHNwZW50IGZyb20gdGhlIGJhbGFuY2Ugb2YgYW4gYWNjb3VudCBpdCBkb2VzIG5vdCBvd25cIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0dFTkVSSUNfRVJST1JdOiBcImdlbmVyaWMgaW5zdHJ1Y3Rpb24gZXJyb3JcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lMTEVHQUxfT1dORVJdOiBcIlByb3ZpZGVkIG93bmVyIGlzIG5vdCBhbGxvd2VkXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTU1VVEFCTEVdOiBcIkFjY291bnQgaXMgaW1tdXRhYmxlXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTkNPUlJFQ1RfQVVUSE9SSVRZXTogXCJJbmNvcnJlY3QgYXV0aG9yaXR5IHByb3ZpZGVkXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTkNPUlJFQ1RfUFJPR1JBTV9JRF06IFwiaW5jb3JyZWN0IHByb2dyYW0gaWQgZm9yIGluc3RydWN0aW9uXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlNVRkZJQ0lFTlRfRlVORFNdOiBcImluc3VmZmljaWVudCBmdW5kcyBmb3IgaW5zdHJ1Y3Rpb25cIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfQUNDT1VOVF9EQVRBXTogXCJpbnZhbGlkIGFjY291bnQgZGF0YSBmb3IgaW5zdHJ1Y3Rpb25cIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfQUNDT1VOVF9PV05FUl06IFwiSW52YWxpZCBhY2NvdW50IG93bmVyXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX0FSR1VNRU5UXTogXCJpbnZhbGlkIHByb2dyYW0gYXJndW1lbnRcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfRVJST1JdOiBcInByb2dyYW0gcmV0dXJuZWQgaW52YWxpZCBlcnJvciBjb2RlXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX0lOU1RSVUNUSU9OX0RBVEFdOiBcImludmFsaWQgaW5zdHJ1Y3Rpb24gZGF0YVwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9SRUFMTE9DXTogXCJGYWlsZWQgdG8gcmVhbGxvY2F0ZSBhY2NvdW50IGRhdGFcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfU0VFRFNdOiBcIlByb3ZpZGVkIHNlZWRzIGRvIG5vdCByZXN1bHQgaW4gYSB2YWxpZCBhZGRyZXNzXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19NQVhfQUNDT1VOVFNfREFUQV9BTExPQ0FUSU9OU19FWENFRURFRF06IFwiQWNjb3VudHMgZGF0YSBhbGxvY2F0aW9ucyBleGNlZWRlZCB0aGUgbWF4aW11bSBhbGxvd2VkIHBlciB0cmFuc2FjdGlvblwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTUFYX0FDQ09VTlRTX0VYQ0VFREVEXTogXCJNYXggYWNjb3VudHMgZXhjZWVkZWRcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01BWF9JTlNUUlVDVElPTl9UUkFDRV9MRU5HVEhfRVhDRUVERURdOiBcIk1heCBpbnN0cnVjdGlvbiB0cmFjZSBsZW5ndGggZXhjZWVkZWRcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01BWF9TRUVEX0xFTkdUSF9FWENFRURFRF06IFwiTGVuZ3RoIG9mIHRoZSBzZWVkIGlzIHRvbyBsb25nIGZvciBhZGRyZXNzIGdlbmVyYXRpb25cIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01JU1NJTkdfQUNDT1VOVF06IFwiQW4gYWNjb3VudCByZXF1aXJlZCBieSB0aGUgaW5zdHJ1Y3Rpb24gaXMgbWlzc2luZ1wiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTUlTU0lOR19SRVFVSVJFRF9TSUdOQVRVUkVdOiBcIm1pc3NpbmcgcmVxdWlyZWQgc2lnbmF0dXJlIGZvciBpbnN0cnVjdGlvblwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTU9ESUZJRURfUFJPR1JBTV9JRF06IFwiaW5zdHJ1Y3Rpb24gaWxsZWdhbGx5IG1vZGlmaWVkIHRoZSBwcm9ncmFtIGlkIG9mIGFuIGFjY291bnRcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX05PVF9FTk9VR0hfQUNDT1VOVF9LRVlTXTogXCJpbnN1ZmZpY2llbnQgYWNjb3VudCBrZXlzIGZvciBpbnN0cnVjdGlvblwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUFJJVklMRUdFX0VTQ0FMQVRJT05dOiBcIkNyb3NzLXByb2dyYW0gaW52b2NhdGlvbiB3aXRoIHVuYXV0aG9yaXplZCBzaWduZXIgb3Igd3JpdGFibGUgYWNjb3VudFwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUFJPR1JBTV9FTlZJUk9OTUVOVF9TRVRVUF9GQUlMVVJFXTogXCJGYWlsZWQgdG8gY3JlYXRlIHByb2dyYW0gZXhlY3V0aW9uIGVudmlyb25tZW50XCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19QUk9HUkFNX0ZBSUxFRF9UT19DT01QSUxFXTogXCJQcm9ncmFtIGZhaWxlZCB0byBjb21waWxlXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19QUk9HUkFNX0ZBSUxFRF9UT19DT01QTEVURV06IFwiUHJvZ3JhbSBmYWlsZWQgdG8gY29tcGxldGVcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1JFQURPTkxZX0RBVEFfTU9ESUZJRURdOiBcImluc3RydWN0aW9uIG1vZGlmaWVkIGRhdGEgb2YgYSByZWFkLW9ubHkgYWNjb3VudFwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUkVBRE9OTFlfTEFNUE9SVF9DSEFOR0VdOiBcImluc3RydWN0aW9uIGNoYW5nZWQgdGhlIGJhbGFuY2Ugb2YgYSByZWFkLW9ubHkgYWNjb3VudFwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUkVFTlRSQU5DWV9OT1RfQUxMT1dFRF06IFwiQ3Jvc3MtcHJvZ3JhbSBpbnZvY2F0aW9uIHJlZW50cmFuY3kgbm90IGFsbG93ZWQgZm9yIHRoaXMgaW5zdHJ1Y3Rpb25cIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1JFTlRfRVBPQ0hfTU9ESUZJRURdOiBcImluc3RydWN0aW9uIG1vZGlmaWVkIHJlbnQgZXBvY2ggb2YgYW4gYWNjb3VudFwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fVU5CQUxBTkNFRF9JTlNUUlVDVElPTl06IFwic3VtIG9mIGFjY291bnQgYmFsYW5jZXMgYmVmb3JlIGFuZCBhZnRlciBpbnN0cnVjdGlvbiBkbyBub3QgbWF0Y2hcIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1VOSU5JVElBTElaRURfQUNDT1VOVF06IFwiaW5zdHJ1Y3Rpb24gcmVxdWlyZXMgYW4gaW5pdGlhbGl6ZWQgYWNjb3VudFwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fVU5LTk9XTl06IFwiXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19VTlNVUFBPUlRFRF9QUk9HUkFNX0lEXTogXCJVbnN1cHBvcnRlZCBwcm9ncmFtIGlkXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19VTlNVUFBPUlRFRF9TWVNWQVJdOiBcIlVuc3VwcG9ydGVkIHN5c3ZhclwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9fRVhQRUNURURfVE9fSEFWRV9BQ0NPVU5UU106IFwiVGhlIGluc3RydWN0aW9uIGRvZXMgbm90IGhhdmUgYW55IGFjY291bnRzLlwiLFxuICBbU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9fRVhQRUNURURfVE9fSEFWRV9EQVRBXTogXCJUaGUgaW5zdHJ1Y3Rpb24gZG9lcyBub3QgaGF2ZSBhbnkgZGF0YS5cIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fX1BST0dSQU1fSURfTUlTTUFUQ0hdOiBcIkV4cGVjdGVkIGluc3RydWN0aW9uIHRvIGhhdmUgcHJvZ3Jlc3MgYWRkcmVzcyAkZXhwZWN0ZWRQcm9ncmFtQWRkcmVzcywgZ290ICRhY3R1YWxQcm9ncmFtQWRkcmVzcy5cIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5WQUxJRF9CTE9DS0hBU0hfQllURV9MRU5HVEhdOiBcIkV4cGVjdGVkIGJhc2U1OCBlbmNvZGVkIGJsb2NraGFzaCB0byBkZWNvZGUgdG8gYSBieXRlIGFycmF5IG9mIGxlbmd0aCAzMi4gQWN0dWFsIGxlbmd0aDogJGFjdHVhbExlbmd0aC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5WQUxJRF9OT05DRV06IFwiVGhlIG5vbmNlIGAkZXhwZWN0ZWROb25jZVZhbHVlYCBpcyBubyBsb25nZXIgdmFsaWQuIEl0IGhhcyBhZHZhbmNlZCB0byBgJGFjdHVhbE5vbmNlVmFsdWVgXCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOVkFSSUFOVF9WSU9MQVRJT05fX0NBQ0hFRF9BQk9SVEFCTEVfSVRFUkFCTEVfQ0FDSEVfRU5UUllfTUlTU0lOR106IFwiSW52YXJpYW50IHZpb2xhdGlvbjogRm91bmQgbm8gYWJvcnRhYmxlIGl0ZXJhYmxlIGNhY2hlIGVudHJ5IGZvciBrZXkgYCRjYWNoZUtleWAuIEl0IHNob3VsZCBiZSBpbXBvc3NpYmxlIHRvIGhpdCB0aGlzIGVycm9yOyBwbGVhc2UgZmlsZSBhbiBpc3N1ZSBhdCBodHRwczovL3NvbGEubmEvd2ViM2ludmFyaWFudFwiLFxuICBbU09MQU5BX0VSUk9SX19JTlZBUklBTlRfVklPTEFUSU9OX19EQVRBX1BVQkxJU0hFUl9DSEFOTkVMX1VOSU1QTEVNRU5URURdOiBcIkludmFyaWFudCB2aW9sYXRpb246IFRoaXMgZGF0YSBwdWJsaXNoZXIgZG9lcyBub3QgcHVibGlzaCB0byB0aGUgY2hhbm5lbCBuYW1lZCBgJGNoYW5uZWxOYW1lYC4gU3VwcG9ydGVkIGNoYW5uZWxzIGluY2x1ZGUgJHN1cHBvcnRlZENoYW5uZWxOYW1lcy5cIixcbiAgW1NPTEFOQV9FUlJPUl9fSU5WQVJJQU5UX1ZJT0xBVElPTl9fU1VCU0NSSVBUSU9OX0lURVJBVE9SX01VU1RfTk9UX1BPTExfQkVGT1JFX1JFU09MVklOR19FWElTVElOR19NRVNTQUdFX1BST01JU0VdOiBcIkludmFyaWFudCB2aW9sYXRpb246IFdlYlNvY2tldCBtZXNzYWdlIGl0ZXJhdG9yIHN0YXRlIGlzIGNvcnJ1cHQ7IGl0ZXJhdGVkIHdpdGhvdXQgZmlyc3QgcmVzb2x2aW5nIGV4aXN0aW5nIG1lc3NhZ2UgcHJvbWlzZS4gSXQgc2hvdWxkIGJlIGltcG9zc2libGUgdG8gaGl0IHRoaXMgZXJyb3I7IHBsZWFzZSBmaWxlIGFuIGlzc3VlIGF0IGh0dHBzOi8vc29sYS5uYS93ZWIzaW52YXJpYW50XCIsXG4gIFtTT0xBTkFfRVJST1JfX0lOVkFSSUFOVF9WSU9MQVRJT05fX1NVQlNDUklQVElPTl9JVEVSQVRPUl9TVEFURV9NSVNTSU5HXTogXCJJbnZhcmlhbnQgdmlvbGF0aW9uOiBXZWJTb2NrZXQgbWVzc2FnZSBpdGVyYXRvciBpcyBtaXNzaW5nIHN0YXRlIHN0b3JhZ2UuIEl0IHNob3VsZCBiZSBpbXBvc3NpYmxlIHRvIGhpdCB0aGlzIGVycm9yOyBwbGVhc2UgZmlsZSBhbiBpc3N1ZSBhdCBodHRwczovL3NvbGEubmEvd2ViM2ludmFyaWFudFwiLFxuICBbU09MQU5BX0VSUk9SX19JTlZBUklBTlRfVklPTEFUSU9OX19TV0lUQ0hfTVVTVF9CRV9FWEhBVVNUSVZFXTogXCJJbnZhcmlhbnQgdmlvbGF0aW9uOiBTd2l0Y2ggc3RhdGVtZW50IG5vbi1leGhhdXN0aXZlLiBSZWNlaXZlZCB1bmV4cGVjdGVkIHZhbHVlIGAkdW5leHBlY3RlZFZhbHVlYC4gSXQgc2hvdWxkIGJlIGltcG9zc2libGUgdG8gaGl0IHRoaXMgZXJyb3I7IHBsZWFzZSBmaWxlIGFuIGlzc3VlIGF0IGh0dHBzOi8vc29sYS5uYS93ZWIzaW52YXJpYW50XCIsXG4gIFtTT0xBTkFfRVJST1JfX0pTT05fUlBDX19JTlRFUk5BTF9FUlJPUl06IFwiSlNPTi1SUEMgZXJyb3I6IEludGVybmFsIEpTT04tUlBDIGVycm9yICgkX19zZXJ2ZXJNZXNzYWdlKVwiLFxuICBbU09MQU5BX0VSUk9SX19KU09OX1JQQ19fSU5WQUxJRF9QQVJBTVNdOiBcIkpTT04tUlBDIGVycm9yOiBJbnZhbGlkIG1ldGhvZCBwYXJhbWV0ZXIocykgKCRfX3NlcnZlck1lc3NhZ2UpXCIsXG4gIFtTT0xBTkFfRVJST1JfX0pTT05fUlBDX19JTlZBTElEX1JFUVVFU1RdOiBcIkpTT04tUlBDIGVycm9yOiBUaGUgSlNPTiBzZW50IGlzIG5vdCBhIHZhbGlkIGBSZXF1ZXN0YCBvYmplY3QgKCRfX3NlcnZlck1lc3NhZ2UpXCIsXG4gIFtTT0xBTkFfRVJST1JfX0pTT05fUlBDX19NRVRIT0RfTk9UX0ZPVU5EXTogXCJKU09OLVJQQyBlcnJvcjogVGhlIG1ldGhvZCBkb2VzIG5vdCBleGlzdCAvIGlzIG5vdCBhdmFpbGFibGUgKCRfX3NlcnZlck1lc3NhZ2UpXCIsXG4gIFtTT0xBTkFfRVJST1JfX0pTT05fUlBDX19QQVJTRV9FUlJPUl06IFwiSlNPTi1SUEMgZXJyb3I6IEFuIGVycm9yIG9jY3VycmVkIG9uIHRoZSBzZXJ2ZXIgd2hpbGUgcGFyc2luZyB0aGUgSlNPTiB0ZXh0ICgkX19zZXJ2ZXJNZXNzYWdlKVwiLFxuICBbU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0NBTl9FUlJPUl06IFwiJF9fc2VydmVyTWVzc2FnZVwiLFxuICBbU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0JMT0NLX0NMRUFORURfVVBdOiBcIiRfX3NlcnZlck1lc3NhZ2VcIixcbiAgW1NPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9CTE9DS19OT1RfQVZBSUxBQkxFXTogXCIkX19zZXJ2ZXJNZXNzYWdlXCIsXG4gIFtTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfQkxPQ0tfU1RBVFVTX05PVF9BVkFJTEFCTEVfWUVUXTogXCIkX19zZXJ2ZXJNZXNzYWdlXCIsXG4gIFtTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfS0VZX0VYQ0xVREVEX0ZST01fU0VDT05EQVJZX0lOREVYXTogXCIkX19zZXJ2ZXJNZXNzYWdlXCIsXG4gIFtTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfTE9OR19URVJNX1NUT1JBR0VfU0xPVF9TS0lQUEVEXTogXCIkX19zZXJ2ZXJNZXNzYWdlXCIsXG4gIFtTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfTUlOX0NPTlRFWFRfU0xPVF9OT1RfUkVBQ0hFRF06IFwiTWluaW11bSBjb250ZXh0IHNsb3QgaGFzIG5vdCBiZWVuIHJlYWNoZWRcIixcbiAgW1NPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9OT0RFX1VOSEVBTFRIWV06IFwiTm9kZSBpcyB1bmhlYWx0aHk7IGJlaGluZCBieSAkbnVtU2xvdHNCZWhpbmQgc2xvdHNcIixcbiAgW1NPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9OT19TTkFQU0hPVF06IFwiTm8gc25hcHNob3RcIixcbiAgW1NPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9TRU5EX1RSQU5TQUNUSU9OX1BSRUZMSUdIVF9GQUlMVVJFXTogXCJUcmFuc2FjdGlvbiBzaW11bGF0aW9uIGZhaWxlZFwiLFxuICBbU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1NMT1RfU0tJUFBFRF06IFwiJF9fc2VydmVyTWVzc2FnZVwiLFxuICBbU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX0hJU1RPUllfTk9UX0FWQUlMQUJMRV06IFwiVHJhbnNhY3Rpb24gaGlzdG9yeSBpcyBub3QgYXZhaWxhYmxlIGZyb20gdGhpcyBub2RlXCIsXG4gIFtTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fUFJFQ09NUElMRV9WRVJJRklDQVRJT05fRkFJTFVSRV06IFwiJF9fc2VydmVyTWVzc2FnZVwiLFxuICBbU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX1NJR05BVFVSRV9MRU5fTUlTTUFUQ0hdOiBcIlRyYW5zYWN0aW9uIHNpZ25hdHVyZSBsZW5ndGggbWlzbWF0Y2hcIixcbiAgW1NPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9TSUdOQVRVUkVfVkVSSUZJQ0FUSU9OX0ZBSUxVUkVdOiBcIlRyYW5zYWN0aW9uIHNpZ25hdHVyZSB2ZXJpZmljYXRpb24gZmFpbHVyZVwiLFxuICBbU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1VOU1VQUE9SVEVEX1RSQU5TQUNUSU9OX1ZFUlNJT05dOiBcIiRfX3NlcnZlck1lc3NhZ2VcIixcbiAgW1NPTEFOQV9FUlJPUl9fS0VZU19fSU5WQUxJRF9LRVlfUEFJUl9CWVRFX0xFTkdUSF06IFwiS2V5IHBhaXIgYnl0ZXMgbXVzdCBiZSBvZiBsZW5ndGggNjQsIGdvdCAkYnl0ZUxlbmd0aC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fS0VZU19fSU5WQUxJRF9QUklWQVRFX0tFWV9CWVRFX0xFTkdUSF06IFwiRXhwZWN0ZWQgcHJpdmF0ZSBrZXkgYnl0ZXMgd2l0aCBsZW5ndGggMzIuIEFjdHVhbCBsZW5ndGg6ICRhY3R1YWxMZW5ndGguXCIsXG4gIFtTT0xBTkFfRVJST1JfX0tFWVNfX0lOVkFMSURfU0lHTkFUVVJFX0JZVEVfTEVOR1RIXTogXCJFeHBlY3RlZCBiYXNlNTgtZW5jb2RlZCBzaWduYXR1cmUgdG8gZGVjb2RlIHRvIGEgYnl0ZSBhcnJheSBvZiBsZW5ndGggNjQuIEFjdHVhbCBsZW5ndGg6ICRhY3R1YWxMZW5ndGguXCIsXG4gIFtTT0xBTkFfRVJST1JfX0tFWVNfX1BVQkxJQ19LRVlfTVVTVF9NQVRDSF9QUklWQVRFX0tFWV06IFwiVGhlIHByb3ZpZGVkIHByaXZhdGUga2V5IGRvZXMgbm90IG1hdGNoIHRoZSBwcm92aWRlZCBwdWJsaWMga2V5LlwiLFxuICBbU09MQU5BX0VSUk9SX19LRVlTX19TSUdOQVRVUkVfU1RSSU5HX0xFTkdUSF9PVVRfT0ZfUkFOR0VdOiBcIkV4cGVjdGVkIGJhc2U1OC1lbmNvZGVkIHNpZ25hdHVyZSBzdHJpbmcgb2YgbGVuZ3RoIGluIHRoZSByYW5nZSBbNjQsIDg4XS4gQWN0dWFsIGxlbmd0aDogJGFjdHVhbExlbmd0aC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fTEFNUE9SVFNfT1VUX09GX1JBTkdFXTogXCJMYW1wb3J0cyB2YWx1ZSBtdXN0IGJlIGluIHRoZSByYW5nZSBbMCwgMmU2NC0xXVwiLFxuICBbU09MQU5BX0VSUk9SX19NQUxGT1JNRURfQklHSU5UX1NUUklOR106IFwiYCR2YWx1ZWAgY2Fubm90IGJlIHBhcnNlZCBhcyBhIGBCaWdJbnRgXCIsXG4gIFtTT0xBTkFfRVJST1JfX01BTEZPUk1FRF9KU09OX1JQQ19FUlJPUl06IFwiJG1lc3NhZ2VcIixcbiAgW1NPTEFOQV9FUlJPUl9fTUFMRk9STUVEX05VTUJFUl9TVFJJTkddOiBcImAkdmFsdWVgIGNhbm5vdCBiZSBwYXJzZWQgYXMgYSBgTnVtYmVyYFwiLFxuICBbU09MQU5BX0VSUk9SX19OT05DRV9BQ0NPVU5UX05PVF9GT1VORF06IFwiTm8gbm9uY2UgYWNjb3VudCBjb3VsZCBiZSBmb3VuZCBhdCBhZGRyZXNzIGAkbm9uY2VBY2NvdW50QWRkcmVzc2BcIixcbiAgW1NPTEFOQV9FUlJPUl9fUlBDX1NVQlNDUklQVElPTlNfX0NBTk5PVF9DUkVBVEVfU1VCU0NSSVBUSU9OX1BMQU5dOiBcIlRoZSBub3RpZmljYXRpb24gbmFtZSBtdXN0IGVuZCBpbiAnTm90aWZpY2F0aW9ucycgYW5kIHRoZSBBUEkgbXVzdCBzdXBwbHkgYSBzdWJzY3JpcHRpb24gcGxhbiBjcmVhdG9yIGZ1bmN0aW9uIGZvciB0aGUgbm90aWZpY2F0aW9uICckbm90aWZpY2F0aW9uTmFtZScuXCIsXG4gIFtTT0xBTkFfRVJST1JfX1JQQ19TVUJTQ1JJUFRJT05TX19DSEFOTkVMX0NMT1NFRF9CRUZPUkVfTUVTU0FHRV9CVUZGRVJFRF06IFwiV2ViU29ja2V0IHdhcyBjbG9zZWQgYmVmb3JlIHBheWxvYWQgY291bGQgYmUgYWRkZWQgdG8gdGhlIHNlbmQgYnVmZmVyXCIsXG4gIFtTT0xBTkFfRVJST1JfX1JQQ19TVUJTQ1JJUFRJT05TX19DSEFOTkVMX0NPTk5FQ1RJT05fQ0xPU0VEXTogXCJXZWJTb2NrZXQgY29ubmVjdGlvbiBjbG9zZWRcIixcbiAgW1NPTEFOQV9FUlJPUl9fUlBDX1NVQlNDUklQVElPTlNfX0NIQU5ORUxfRkFJTEVEX1RPX0NPTk5FQ1RdOiBcIldlYlNvY2tldCBmYWlsZWQgdG8gY29ubmVjdFwiLFxuICBbU09MQU5BX0VSUk9SX19SUENfU1VCU0NSSVBUSU9OU19fRVhQRUNURURfU0VSVkVSX1NVQlNDUklQVElPTl9JRF06IFwiRmFpbGVkIHRvIG9idGFpbiBhIHN1YnNjcmlwdGlvbiBpZCBmcm9tIHRoZSBzZXJ2ZXJcIixcbiAgW1NPTEFOQV9FUlJPUl9fUlBDX19BUElfUExBTl9NSVNTSU5HX0ZPUl9SUENfTUVUSE9EXTogXCJDb3VsZCBub3QgZmluZCBhbiBBUEkgcGxhbiBmb3IgUlBDIG1ldGhvZDogYCRtZXRob2RgXCIsXG4gIFtTT0xBTkFfRVJST1JfX1JQQ19fSU5URUdFUl9PVkVSRkxPV106IFwiVGhlICRhcmd1bWVudExhYmVsIGFyZ3VtZW50IHRvIHRoZSBgJG1ldGhvZE5hbWVgIFJQQyBtZXRob2Qkb3B0aW9uYWxQYXRoTGFiZWwgd2FzIGAkdmFsdWVgLiBUaGlzIG51bWJlciBpcyB1bnNhZmUgZm9yIHVzZSB3aXRoIHRoZSBTb2xhbmEgSlNPTi1SUEMgYmVjYXVzZSBpdCBleGNlZWRzIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXCIsXG4gIFtTT0xBTkFfRVJST1JfX1JQQ19fVFJBTlNQT1JUX0hUVFBfRVJST1JdOiBcIkhUVFAgZXJyb3IgKCRzdGF0dXNDb2RlKTogJG1lc3NhZ2VcIixcbiAgW1NPTEFOQV9FUlJPUl9fUlBDX19UUkFOU1BPUlRfSFRUUF9IRUFERVJfRk9SQklEREVOXTogXCJIVFRQIGhlYWRlcihzKSBmb3JiaWRkZW46ICRoZWFkZXJzLiBMZWFybiBtb3JlIGF0IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvR2xvc3NhcnkvRm9yYmlkZGVuX2hlYWRlcl9uYW1lLlwiLFxuICBbU09MQU5BX0VSUk9SX19TSUdORVJfX0FERFJFU1NfQ0FOTk9UX0hBVkVfTVVMVElQTEVfU0lHTkVSU106IFwiTXVsdGlwbGUgZGlzdGluY3Qgc2lnbmVycyB3ZXJlIGlkZW50aWZpZWQgZm9yIGFkZHJlc3MgYCRhZGRyZXNzYC4gUGxlYXNlIGVuc3VyZSB0aGF0IHlvdSBhcmUgdXNpbmcgdGhlIHNhbWUgc2lnbmVyIGluc3RhbmNlIGZvciBlYWNoIGFkZHJlc3MuXCIsXG4gIFtTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfS0VZX1BBSVJfU0lHTkVSXTogXCJUaGUgcHJvdmlkZWQgdmFsdWUgZG9lcyBub3QgaW1wbGVtZW50IHRoZSBgS2V5UGFpclNpZ25lcmAgaW50ZXJmYWNlXCIsXG4gIFtTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfTUVTU0FHRV9NT0RJRllJTkdfU0lHTkVSXTogXCJUaGUgcHJvdmlkZWQgdmFsdWUgZG9lcyBub3QgaW1wbGVtZW50IHRoZSBgTWVzc2FnZU1vZGlmeWluZ1NpZ25lcmAgaW50ZXJmYWNlXCIsXG4gIFtTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfTUVTU0FHRV9QQVJUSUFMX1NJR05FUl06IFwiVGhlIHByb3ZpZGVkIHZhbHVlIGRvZXMgbm90IGltcGxlbWVudCB0aGUgYE1lc3NhZ2VQYXJ0aWFsU2lnbmVyYCBpbnRlcmZhY2VcIixcbiAgW1NPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9NRVNTQUdFX1NJR05FUl06IFwiVGhlIHByb3ZpZGVkIHZhbHVlIGRvZXMgbm90IGltcGxlbWVudCBhbnkgb2YgdGhlIGBNZXNzYWdlU2lnbmVyYCBpbnRlcmZhY2VzXCIsXG4gIFtTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfVFJBTlNBQ1RJT05fTU9ESUZZSU5HX1NJR05FUl06IFwiVGhlIHByb3ZpZGVkIHZhbHVlIGRvZXMgbm90IGltcGxlbWVudCB0aGUgYFRyYW5zYWN0aW9uTW9kaWZ5aW5nU2lnbmVyYCBpbnRlcmZhY2VcIixcbiAgW1NPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9UUkFOU0FDVElPTl9QQVJUSUFMX1NJR05FUl06IFwiVGhlIHByb3ZpZGVkIHZhbHVlIGRvZXMgbm90IGltcGxlbWVudCB0aGUgYFRyYW5zYWN0aW9uUGFydGlhbFNpZ25lcmAgaW50ZXJmYWNlXCIsXG4gIFtTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfVFJBTlNBQ1RJT05fU0VORElOR19TSUdORVJdOiBcIlRoZSBwcm92aWRlZCB2YWx1ZSBkb2VzIG5vdCBpbXBsZW1lbnQgdGhlIGBUcmFuc2FjdGlvblNlbmRpbmdTaWduZXJgIGludGVyZmFjZVwiLFxuICBbU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX1RSQU5TQUNUSU9OX1NJR05FUl06IFwiVGhlIHByb3ZpZGVkIHZhbHVlIGRvZXMgbm90IGltcGxlbWVudCBhbnkgb2YgdGhlIGBUcmFuc2FjdGlvblNpZ25lcmAgaW50ZXJmYWNlc1wiLFxuICBbU09MQU5BX0VSUk9SX19TSUdORVJfX1RSQU5TQUNUSU9OX0NBTk5PVF9IQVZFX01VTFRJUExFX1NFTkRJTkdfU0lHTkVSU106IFwiTW9yZSB0aGFuIG9uZSBgVHJhbnNhY3Rpb25TZW5kaW5nU2lnbmVyYCB3YXMgaWRlbnRpZmllZC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fU0lHTkVSX19UUkFOU0FDVElPTl9TRU5ESU5HX1NJR05FUl9NSVNTSU5HXTogXCJObyBgVHJhbnNhY3Rpb25TZW5kaW5nU2lnbmVyYCB3YXMgaWRlbnRpZmllZC4gUGxlYXNlIHByb3ZpZGUgYSB2YWxpZCBgVHJhbnNhY3Rpb25XaXRoU2luZ2xlU2VuZGluZ1NpZ25lcmAgdHJhbnNhY3Rpb24uXCIsXG4gIFtTT0xBTkFfRVJST1JfX1NJR05FUl9fV0FMTEVUX01VTFRJU0lHTl9VTklNUExFTUVOVEVEXTogXCJXYWxsZXQgYWNjb3VudCBzaWduZXJzIGRvIG5vdCBzdXBwb3J0IHNpZ25pbmcgbXVsdGlwbGUgbWVzc2FnZXMvdHJhbnNhY3Rpb25zIGluIGEgc2luZ2xlIG9wZXJhdGlvblwiLFxuICBbU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19DQU5OT1RfRVhQT1JUX05PTl9FWFRSQUNUQUJMRV9LRVldOiBcIkNhbm5vdCBleHBvcnQgYSBub24tZXh0cmFjdGFibGUga2V5LlwiLFxuICBbU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19ESUdFU1RfVU5JTVBMRU1FTlRFRF06IFwiTm8gZGlnZXN0IGltcGxlbWVudGF0aW9uIGNvdWxkIGJlIGZvdW5kLlwiLFxuICBbU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19ESVNBTExPV0VEX0lOX0lOU0VDVVJFX0NPTlRFWFRdOiBcIkNyeXB0b2dyYXBoaWMgb3BlcmF0aW9ucyBhcmUgb25seSBhbGxvd2VkIGluIHNlY3VyZSBicm93c2VyIGNvbnRleHRzLiBSZWFkIG1vcmUgaGVyZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvU2VjdXJpdHkvU2VjdXJlX0NvbnRleHRzLlwiLFxuICBbU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19FRDI1NTE5X0FMR09SSVRITV9VTklNUExFTUVOVEVEXTogXCJUaGlzIHJ1bnRpbWUgZG9lcyBub3Qgc3VwcG9ydCB0aGUgZ2VuZXJhdGlvbiBvZiBFZDI1NTE5IGtleSBwYWlycy5cXG5cXG5JbnN0YWxsIEBzb2xhbmEvd2ViY3J5cHRvLWVkMjU1MTktcG9seWZpbGwgYW5kIGNhbGwgaXRzIGBpbnN0YWxsYCBmdW5jdGlvbiBiZWZvcmUgZ2VuZXJhdGluZyBrZXlzIGluIGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCBzdXBwb3J0IEVkMjU1MTkuXFxuXFxuRm9yIGEgbGlzdCBvZiBydW50aW1lcyB0aGF0IGN1cnJlbnRseSBzdXBwb3J0IEVkMjU1MTkgb3BlcmF0aW9ucywgdmlzaXQgaHR0cHM6Ly9naXRodWIuY29tL1dJQ0cvd2ViY3J5cHRvLXNlY3VyZS1jdXJ2ZXMvaXNzdWVzLzIwLlwiLFxuICBbU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19FWFBPUlRfRlVOQ1RJT05fVU5JTVBMRU1FTlRFRF06IFwiTm8gc2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBpbXBsZW1lbnRhdGlvbiBjb3VsZCBiZSBmb3VuZC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fR0VORVJBVEVfRlVOQ1RJT05fVU5JTVBMRU1FTlRFRF06IFwiTm8ga2V5IGdlbmVyYXRpb24gaW1wbGVtZW50YXRpb24gY291bGQgYmUgZm91bmQuXCIsXG4gIFtTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX1NJR05fRlVOQ1RJT05fVU5JTVBMRU1FTlRFRF06IFwiTm8gc2lnbmluZyBpbXBsZW1lbnRhdGlvbiBjb3VsZCBiZSBmb3VuZC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fVkVSSUZZX0ZVTkNUSU9OX1VOSU1QTEVNRU5URURdOiBcIk5vIGtleSBleHBvcnQgaW1wbGVtZW50YXRpb24gY291bGQgYmUgZm91bmQuXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RJTUVTVEFNUF9PVVRfT0ZfUkFOR0VdOiBcIlRpbWVzdGFtcCB2YWx1ZSBtdXN0IGJlIGluIHRoZSByYW5nZSBbLSgybiAqKiA2M24pLCAoMm4gKiogNjNuKSAtIDFdLiBgJHZhbHVlYCBnaXZlblwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQUNDT1VOVF9CT1JST1dfT1VUU1RBTkRJTkddOiBcIlRyYW5zYWN0aW9uIHByb2Nlc3NpbmcgbGVmdCBhbiBhY2NvdW50IHdpdGggYW4gb3V0c3RhbmRpbmcgYm9ycm93ZWQgcmVmZXJlbmNlXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19BQ0NPVU5UX0lOX1VTRV06IFwiQWNjb3VudCBpbiB1c2VcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0FDQ09VTlRfTE9BREVEX1RXSUNFXTogXCJBY2NvdW50IGxvYWRlZCB0d2ljZVwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQUNDT1VOVF9OT1RfRk9VTkRdOiBcIkF0dGVtcHQgdG8gZGViaXQgYW4gYWNjb3VudCBidXQgZm91bmQgbm8gcmVjb3JkIG9mIGEgcHJpb3IgY3JlZGl0LlwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQUREUkVTU19MT09LVVBfVEFCTEVfTk9UX0ZPVU5EXTogXCJUcmFuc2FjdGlvbiBsb2FkcyBhbiBhZGRyZXNzIHRhYmxlIGFjY291bnQgdGhhdCBkb2Vzbid0IGV4aXN0XCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19BTFJFQURZX1BST0NFU1NFRF06IFwiVGhpcyB0cmFuc2FjdGlvbiBoYXMgYWxyZWFkeSBiZWVuIHByb2Nlc3NlZFwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQkxPQ0tIQVNIX05PVF9GT1VORF06IFwiQmxvY2toYXNoIG5vdCBmb3VuZFwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQ0FMTF9DSEFJTl9UT09fREVFUF06IFwiTG9hZGVyIGNhbGwgY2hhaW4gaXMgdG9vIGRlZXBcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0NMVVNURVJfTUFJTlRFTkFOQ0VdOiBcIlRyYW5zYWN0aW9ucyBhcmUgY3VycmVudGx5IGRpc2FibGVkIGR1ZSB0byBjbHVzdGVyIG1haW50ZW5hbmNlXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19EVVBMSUNBVEVfSU5TVFJVQ1RJT05dOiBcIlRyYW5zYWN0aW9uIGNvbnRhaW5zIGEgZHVwbGljYXRlIGluc3RydWN0aW9uICgkaW5kZXgpIHRoYXQgaXMgbm90IGFsbG93ZWRcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOU1VGRklDSUVOVF9GVU5EU19GT1JfRkVFXTogXCJJbnN1ZmZpY2llbnQgZnVuZHMgZm9yIGZlZVwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5TVUZGSUNJRU5UX0ZVTkRTX0ZPUl9SRU5UXTogXCJUcmFuc2FjdGlvbiByZXN1bHRzIGluIGFuIGFjY291bnQgKCRhY2NvdW50SW5kZXgpIHdpdGggaW5zdWZmaWNpZW50IGZ1bmRzIGZvciByZW50XCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX0FDQ09VTlRfRk9SX0ZFRV06IFwiVGhpcyBhY2NvdW50IG1heSBub3QgYmUgdXNlZCB0byBwYXkgdHJhbnNhY3Rpb24gZmVlc1wiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9BQ0NPVU5UX0lOREVYXTogXCJUcmFuc2FjdGlvbiBjb250YWlucyBhbiBpbnZhbGlkIGFjY291bnQgcmVmZXJlbmNlXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX0FERFJFU1NfTE9PS1VQX1RBQkxFX0RBVEFdOiBcIlRyYW5zYWN0aW9uIGxvYWRzIGFuIGFkZHJlc3MgdGFibGUgYWNjb3VudCB3aXRoIGludmFsaWQgZGF0YVwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9BRERSRVNTX0xPT0tVUF9UQUJMRV9JTkRFWF06IFwiVHJhbnNhY3Rpb24gYWRkcmVzcyB0YWJsZSBsb29rdXAgdXNlcyBhbiBpbnZhbGlkIGluZGV4XCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX0FERFJFU1NfTE9PS1VQX1RBQkxFX09XTkVSXTogXCJUcmFuc2FjdGlvbiBsb2FkcyBhbiBhZGRyZXNzIHRhYmxlIGFjY291bnQgd2l0aCBhbiBpbnZhbGlkIG93bmVyXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX0xPQURFRF9BQ0NPVU5UU19EQVRBX1NJWkVfTElNSVRdOiBcIkxvYWRlZEFjY291bnRzRGF0YVNpemVMaW1pdCBzZXQgZm9yIHRyYW5zYWN0aW9uIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAuXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX1BST0dSQU1fRk9SX0VYRUNVVElPTl06IFwiVGhpcyBwcm9ncmFtIG1heSBub3QgYmUgdXNlZCBmb3IgZXhlY3V0aW5nIGluc3RydWN0aW9uc1wiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9SRU5UX1BBWUlOR19BQ0NPVU5UXTogXCJUcmFuc2FjdGlvbiBsZWF2ZXMgYW4gYWNjb3VudCB3aXRoIGEgbG93ZXIgYmFsYW5jZSB0aGFuIHJlbnQtZXhlbXB0IG1pbmltdW1cIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfV1JJVEFCTEVfQUNDT1VOVF06IFwiVHJhbnNhY3Rpb24gbG9hZHMgYSB3cml0YWJsZSBhY2NvdW50IHRoYXQgY2Fubm90IGJlIHdyaXR0ZW5cIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX01BWF9MT0FERURfQUNDT1VOVFNfREFUQV9TSVpFX0VYQ0VFREVEXTogXCJUcmFuc2FjdGlvbiBleGNlZWRlZCBtYXggbG9hZGVkIGFjY291bnRzIGRhdGEgc2l6ZSBjYXBcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX01JU1NJTkdfU0lHTkFUVVJFX0ZPUl9GRUVdOiBcIlRyYW5zYWN0aW9uIHJlcXVpcmVzIGEgZmVlIGJ1dCBoYXMgbm8gc2lnbmF0dXJlIHByZXNlbnRcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1BST0dSQU1fQUNDT1VOVF9OT1RfRk9VTkRdOiBcIkF0dGVtcHQgdG8gbG9hZCBhIHByb2dyYW0gdGhhdCBkb2VzIG5vdCBleGlzdFwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fUFJPR1JBTV9FWEVDVVRJT05fVEVNUE9SQVJJTFlfUkVTVFJJQ1RFRF06IFwiRXhlY3V0aW9uIG9mIHRoZSBwcm9ncmFtIHJlZmVyZW5jZWQgYnkgYWNjb3VudCBhdCBpbmRleCAkYWNjb3VudEluZGV4IGlzIHRlbXBvcmFyaWx5IHJlc3RyaWN0ZWQuXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19SRVNBTklUSVpBVElPTl9ORUVERURdOiBcIlJlc2FuaXRpemF0aW9uTmVlZGVkXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19TQU5JVElaRV9GQUlMVVJFXTogXCJUcmFuc2FjdGlvbiBmYWlsZWQgdG8gc2FuaXRpemUgYWNjb3VudHMgb2Zmc2V0cyBjb3JyZWN0bHlcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1NJR05BVFVSRV9GQUlMVVJFXTogXCJUcmFuc2FjdGlvbiBkaWQgbm90IHBhc3Mgc2lnbmF0dXJlIHZlcmlmaWNhdGlvblwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fVE9PX01BTllfQUNDT1VOVF9MT0NLU106IFwiVHJhbnNhY3Rpb24gbG9ja2VkIHRvbyBtYW55IGFjY291bnRzXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19VTkJBTEFOQ0VEX1RSQU5TQUNUSU9OXTogXCJTdW0gb2YgYWNjb3VudCBiYWxhbmNlcyBiZWZvcmUgYW5kIGFmdGVyIHRyYW5zYWN0aW9uIGRvIG5vdCBtYXRjaFwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fVU5LTk9XTl06IFwiVGhlIHRyYW5zYWN0aW9uIGZhaWxlZCB3aXRoIHRoZSBlcnJvciBgJGVycm9yTmFtZWBcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1VOU1VQUE9SVEVEX1ZFUlNJT05dOiBcIlRyYW5zYWN0aW9uIHZlcnNpb24gaXMgdW5zdXBwb3J0ZWRcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1dPVUxEX0VYQ0VFRF9BQ0NPVU5UX0RBVEFfQkxPQ0tfTElNSVRdOiBcIlRyYW5zYWN0aW9uIHdvdWxkIGV4Y2VlZCBhY2NvdW50IGRhdGEgbGltaXQgd2l0aGluIHRoZSBibG9ja1wiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fV09VTERfRVhDRUVEX0FDQ09VTlRfREFUQV9UT1RBTF9MSU1JVF06IFwiVHJhbnNhY3Rpb24gd291bGQgZXhjZWVkIHRvdGFsIGFjY291bnQgZGF0YSBsaW1pdFwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fV09VTERfRVhDRUVEX01BWF9BQ0NPVU5UX0NPU1RfTElNSVRdOiBcIlRyYW5zYWN0aW9uIHdvdWxkIGV4Y2VlZCBtYXggYWNjb3VudCBsaW1pdCB3aXRoaW4gdGhlIGJsb2NrXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19XT1VMRF9FWENFRURfTUFYX0JMT0NLX0NPU1RfTElNSVRdOiBcIlRyYW5zYWN0aW9uIHdvdWxkIGV4Y2VlZCBtYXggQmxvY2sgQ29zdCBMaW1pdFwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fV09VTERfRVhDRUVEX01BWF9WT1RFX0NPU1RfTElNSVRdOiBcIlRyYW5zYWN0aW9uIHdvdWxkIGV4Y2VlZCBtYXggVm90ZSBDb3N0IExpbWl0XCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19BRERSRVNTRVNfQ0FOTk9UX1NJR05fVFJBTlNBQ1RJT05dOiBcIkF0dGVtcHRlZCB0byBzaWduIGEgdHJhbnNhY3Rpb24gd2l0aCBhbiBhZGRyZXNzIHRoYXQgaXMgbm90IGEgc2lnbmVyIGZvciBpdFwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fQUREUkVTU19NSVNTSU5HXTogXCJUcmFuc2FjdGlvbiBpcyBtaXNzaW5nIGFuIGFkZHJlc3MgYXQgaW5kZXg6ICRpbmRleC5cIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0NBTk5PVF9FTkNPREVfV0lUSF9FTVBUWV9TSUdOQVRVUkVTXTogXCJUcmFuc2FjdGlvbiBoYXMgbm8gZXhwZWN0ZWQgc2lnbmVycyB0aGVyZWZvcmUgaXQgY2Fubm90IGJlIGVuY29kZWRcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0VYQ0VFRFNfU0laRV9MSU1JVF06IFwiVHJhbnNhY3Rpb24gc2l6ZSAkdHJhbnNhY3Rpb25TaXplIGV4Y2VlZHMgbGltaXQgb2YgJHRyYW5zYWN0aW9uU2l6ZUxpbWl0IGJ5dGVzXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19FWFBFQ1RFRF9CTE9DS0hBU0hfTElGRVRJTUVdOiBcIlRyYW5zYWN0aW9uIGRvZXMgbm90IGhhdmUgYSBibG9ja2hhc2ggbGlmZXRpbWVcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0VYUEVDVEVEX05PTkNFX0xJRkVUSU1FXTogXCJUcmFuc2FjdGlvbiBpcyBub3QgYSBkdXJhYmxlIG5vbmNlIHRyYW5zYWN0aW9uXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GQUlMRURfVE9fREVDT01QSUxFX0FERFJFU1NfTE9PS1VQX1RBQkxFX0NPTlRFTlRTX01JU1NJTkddOiBcIkNvbnRlbnRzIG9mIHRoZXNlIGFkZHJlc3MgbG9va3VwIHRhYmxlcyB1bmtub3duOiAkbG9va3VwVGFibGVBZGRyZXNzZXNcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9UT19ERUNPTVBJTEVfQUREUkVTU19MT09LVVBfVEFCTEVfSU5ERVhfT1VUX09GX1JBTkdFXTogXCJMb29rdXAgb2YgYWRkcmVzcyBhdCBpbmRleCAkaGlnaGVzdFJlcXVlc3RlZEluZGV4IGZhaWxlZCBmb3IgbG9va3VwIHRhYmxlIGAkbG9va3VwVGFibGVBZGRyZXNzYC4gSGlnaGVzdCBrbm93biBpbmRleCBpcyAkaGlnaGVzdEtub3duSW5kZXguIFRoZSBsb29rdXAgdGFibGUgbWF5IGhhdmUgYmVlbiBleHRlbmRlZCBzaW5jZSBpdHMgY29udGVudHMgd2VyZSByZXRyaWV2ZWRcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9UT19ERUNPTVBJTEVfRkVFX1BBWUVSX01JU1NJTkddOiBcIk5vIGZlZSBwYXllciBzZXQgaW4gQ29tcGlsZWRUcmFuc2FjdGlvblwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkFJTEVEX1RPX0RFQ09NUElMRV9JTlNUUlVDVElPTl9QUk9HUkFNX0FERFJFU1NfTk9UX0ZPVU5EXTogXCJDb3VsZCBub3QgZmluZCBwcm9ncmFtIGFkZHJlc3MgYXQgaW5kZXggJGluZGV4XCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GQUlMRURfVE9fRVNUSU1BVEVfQ09NUFVURV9MSU1JVF06IFwiRmFpbGVkIHRvIGVzdGltYXRlIHRoZSBjb21wdXRlIHVuaXQgY29uc3VtcHRpb24gZm9yIHRoaXMgdHJhbnNhY3Rpb24gbWVzc2FnZS4gVGhpcyBpcyBsaWtlbHkgYmVjYXVzZSBzaW11bGF0aW5nIHRoZSB0cmFuc2FjdGlvbiBmYWlsZWQuIEluc3BlY3QgdGhlIGBjYXVzZWAgcHJvcGVydHkgb2YgdGhpcyBlcnJvciB0byBsZWFybiBtb3JlXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GQUlMRURfV0hFTl9TSU1VTEFUSU5HX1RPX0VTVElNQVRFX0NPTVBVVEVfTElNSVRdOiBcIlRyYW5zYWN0aW9uIGZhaWxlZCB3aGVuIGl0IHdhcyBzaW11bGF0ZWQgaW4gb3JkZXIgdG8gZXN0aW1hdGUgdGhlIGNvbXB1dGUgdW5pdCBjb25zdW1wdGlvbi4gVGhlIGNvbXB1dGUgdW5pdCBlc3RpbWF0ZSBwcm92aWRlZCBpcyBmb3IgYSB0cmFuc2FjdGlvbiB0aGF0IGZhaWxlZCB3aGVuIHNpbXVsYXRlZCBhbmQgbWF5IG5vdCBiZSByZXByZXNlbnRhdGl2ZSBvZiB0aGUgY29tcHV0ZSB1bml0cyB0aGlzIHRyYW5zYWN0aW9uIHdvdWxkIGNvbnN1bWUgaWYgc3VjY2Vzc2Z1bC4gSW5zcGVjdCB0aGUgYGNhdXNlYCBwcm9wZXJ0eSBvZiB0aGlzIGVycm9yIHRvIGxlYXJuIG1vcmVcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZFRV9QQVlFUl9NSVNTSU5HXTogXCJUcmFuc2FjdGlvbiBpcyBtaXNzaW5nIGEgZmVlIHBheWVyLlwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkVFX1BBWUVSX1NJR05BVFVSRV9NSVNTSU5HXTogXCJDb3VsZCBub3QgZGV0ZXJtaW5lIHRoaXMgdHJhbnNhY3Rpb24ncyBzaWduYXR1cmUuIE1ha2Ugc3VyZSB0aGF0IHRoZSB0cmFuc2FjdGlvbiBoYXMgYmVlbiBzaWduZWQgYnkgaXRzIGZlZSBwYXllci5cIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0lOVkFMSURfTk9OQ0VfVFJBTlNBQ1RJT05fRklSU1RfSU5TVFJVQ1RJT05fTVVTVF9CRV9BRFZBTkNFX05PTkNFXTogXCJUcmFuc2FjdGlvbiBmaXJzdCBpbnN0cnVjdGlvbiBpcyBub3QgYWR2YW5jZSBub25jZSBhY2NvdW50IGluc3RydWN0aW9uLlwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fSU5WQUxJRF9OT05DRV9UUkFOU0FDVElPTl9JTlNUUlVDVElPTlNfTUlTU0lOR106IFwiVHJhbnNhY3Rpb24gd2l0aCBubyBpbnN0cnVjdGlvbnMgY2Fubm90IGJlIGR1cmFibGUgbm9uY2UgdHJhbnNhY3Rpb24uXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19JTlZPS0VEX1BST0dSQU1TX0NBTk5PVF9QQVlfRkVFU106IFwiVGhpcyB0cmFuc2FjdGlvbiBpbmNsdWRlcyBhbiBhZGRyZXNzIChgJHByb2dyYW1BZGRyZXNzYCkgd2hpY2ggaXMgYm90aCBpbnZva2VkIGFuZCBzZXQgYXMgdGhlIGZlZSBwYXllci4gUHJvZ3JhbSBhZGRyZXNzZXMgbWF5IG5vdCBwYXkgZmVlc1wiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fSU5WT0tFRF9QUk9HUkFNU19NVVNUX05PVF9CRV9XUklUQUJMRV06IFwiVGhpcyB0cmFuc2FjdGlvbiBpbmNsdWRlcyBhbiBhZGRyZXNzIChgJHByb2dyYW1BZGRyZXNzYCkgd2hpY2ggaXMgYm90aCBpbnZva2VkIGFuZCBtYXJrZWQgd3JpdGFibGUuIFByb2dyYW0gYWRkcmVzc2VzIG1heSBub3QgYmUgd3JpdGFibGVcIixcbiAgW1NPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX01FU1NBR0VfU0lHTkFUVVJFU19NSVNNQVRDSF06IFwiVGhlIHRyYW5zYWN0aW9uIG1lc3NhZ2UgZXhwZWN0ZWQgdGhlIHRyYW5zYWN0aW9uIHRvIGhhdmUgJHNpZ25lckFkZHJlc3Nlc0xlbmd0aCBzaWduYXR1cmVzLCBnb3QgJHNpZ25hdHVyZXNMZW5ndGguXCIsXG4gIFtTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19TSUdOQVRVUkVTX01JU1NJTkddOiBcIlRyYW5zYWN0aW9uIGlzIG1pc3Npbmcgc2lnbmF0dXJlcyBmb3IgYWRkcmVzc2VzOiAkYWRkcmVzc2VzLlwiLFxuICBbU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fVkVSU0lPTl9OVU1CRVJfT1VUX09GX1JBTkdFXTogXCJUcmFuc2FjdGlvbiB2ZXJzaW9uIG11c3QgYmUgaW4gdGhlIHJhbmdlIFswLCAxMjddLiBgJGFjdHVhbFZlcnNpb25gIGdpdmVuXCJcbn07XG5cbi8vIHNyYy9tZXNzYWdlLWZvcm1hdHRlci50c1xudmFyIFNUQVJUX0lOREVYID0gXCJpXCI7XG52YXIgVFlQRSA9IFwidFwiO1xuZnVuY3Rpb24gZ2V0SHVtYW5SZWFkYWJsZUVycm9yTWVzc2FnZShjb2RlLCBjb250ZXh0ID0ge30pIHtcbiAgY29uc3QgbWVzc2FnZUZvcm1hdFN0cmluZyA9IFNvbGFuYUVycm9yTWVzc2FnZXNbY29kZV07XG4gIGlmIChtZXNzYWdlRm9ybWF0U3RyaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIGxldCBzdGF0ZTtcbiAgZnVuY3Rpb24gY29tbWl0U3RhdGVVcFRvKGVuZEluZGV4KSB7XG4gICAgaWYgKHN0YXRlW1RZUEVdID09PSAyIC8qIFZhcmlhYmxlICovKSB7XG4gICAgICBjb25zdCB2YXJpYWJsZU5hbWUgPSBtZXNzYWdlRm9ybWF0U3RyaW5nLnNsaWNlKHN0YXRlW1NUQVJUX0lOREVYXSArIDEsIGVuZEluZGV4KTtcbiAgICAgIGZyYWdtZW50cy5wdXNoKFxuICAgICAgICB2YXJpYWJsZU5hbWUgaW4gY29udGV4dCA/IChcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXRlbXBsYXRlLWV4cHJlc3Npb25zXG4gICAgICAgICAgYCR7Y29udGV4dFt2YXJpYWJsZU5hbWVdfWBcbiAgICAgICAgKSA6IGAkJHt2YXJpYWJsZU5hbWV9YFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlW1RZUEVdID09PSAxIC8qIFRleHQgKi8pIHtcbiAgICAgIGZyYWdtZW50cy5wdXNoKG1lc3NhZ2VGb3JtYXRTdHJpbmcuc2xpY2Uoc3RhdGVbU1RBUlRfSU5ERVhdLCBlbmRJbmRleCkpO1xuICAgIH1cbiAgfVxuICBjb25zdCBmcmFnbWVudHMgPSBbXTtcbiAgbWVzc2FnZUZvcm1hdFN0cmluZy5zcGxpdChcIlwiKS5mb3JFYWNoKChjaGFyLCBpaSkgPT4ge1xuICAgIGlmIChpaSA9PT0gMCkge1xuICAgICAgc3RhdGUgPSB7XG4gICAgICAgIFtTVEFSVF9JTkRFWF06IDAsXG4gICAgICAgIFtUWVBFXTogbWVzc2FnZUZvcm1hdFN0cmluZ1swXSA9PT0gXCJcXFxcXCIgPyAwIC8qIEVzY2FwZVNlcXVlbmNlICovIDogbWVzc2FnZUZvcm1hdFN0cmluZ1swXSA9PT0gXCIkXCIgPyAyIC8qIFZhcmlhYmxlICovIDogMSAvKiBUZXh0ICovXG4gICAgICB9O1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgbmV4dFN0YXRlO1xuICAgIHN3aXRjaCAoc3RhdGVbVFlQRV0pIHtcbiAgICAgIGNhc2UgMCAvKiBFc2NhcGVTZXF1ZW5jZSAqLzpcbiAgICAgICAgbmV4dFN0YXRlID0geyBbU1RBUlRfSU5ERVhdOiBpaSwgW1RZUEVdOiAxIC8qIFRleHQgKi8gfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEgLyogVGV4dCAqLzpcbiAgICAgICAgaWYgKGNoYXIgPT09IFwiXFxcXFwiKSB7XG4gICAgICAgICAgbmV4dFN0YXRlID0geyBbU1RBUlRfSU5ERVhdOiBpaSwgW1RZUEVdOiAwIC8qIEVzY2FwZVNlcXVlbmNlICovIH07XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gXCIkXCIpIHtcbiAgICAgICAgICBuZXh0U3RhdGUgPSB7IFtTVEFSVF9JTkRFWF06IGlpLCBbVFlQRV06IDIgLyogVmFyaWFibGUgKi8gfTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMiAvKiBWYXJpYWJsZSAqLzpcbiAgICAgICAgaWYgKGNoYXIgPT09IFwiXFxcXFwiKSB7XG4gICAgICAgICAgbmV4dFN0YXRlID0geyBbU1RBUlRfSU5ERVhdOiBpaSwgW1RZUEVdOiAwIC8qIEVzY2FwZVNlcXVlbmNlICovIH07XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gXCIkXCIpIHtcbiAgICAgICAgICBuZXh0U3RhdGUgPSB7IFtTVEFSVF9JTkRFWF06IGlpLCBbVFlQRV06IDIgLyogVmFyaWFibGUgKi8gfTtcbiAgICAgICAgfSBlbHNlIGlmICghY2hhci5tYXRjaCgvXFx3LykpIHtcbiAgICAgICAgICBuZXh0U3RhdGUgPSB7IFtTVEFSVF9JTkRFWF06IGlpLCBbVFlQRV06IDEgLyogVGV4dCAqLyB9O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAobmV4dFN0YXRlKSB7XG4gICAgICBpZiAoc3RhdGUgIT09IG5leHRTdGF0ZSkge1xuICAgICAgICBjb21taXRTdGF0ZVVwVG8oaWkpO1xuICAgICAgfVxuICAgICAgc3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgfVxuICB9KTtcbiAgY29tbWl0U3RhdGVVcFRvKCk7XG4gIHJldHVybiBmcmFnbWVudHMuam9pbihcIlwiKTtcbn1cbmZ1bmN0aW9uIGdldEVycm9yTWVzc2FnZShjb2RlLCBjb250ZXh0ID0ge30pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHJldHVybiBnZXRIdW1hblJlYWRhYmxlRXJyb3JNZXNzYWdlKGNvZGUsIGNvbnRleHQpO1xuICB9IGVsc2Uge1xuICAgIGxldCBkZWNvZGluZ0FkdmljZU1lc3NhZ2UgPSBgU29sYW5hIGVycm9yICMke2NvZGV9OyBEZWNvZGUgdGhpcyBlcnJvciBieSBydW5uaW5nIFxcYG5weCBAc29sYW5hL2Vycm9ycyBkZWNvZGUgLS0gJHtjb2RlfWA7XG4gICAgaWYgKE9iamVjdC5rZXlzKGNvbnRleHQpLmxlbmd0aCkge1xuICAgICAgZGVjb2RpbmdBZHZpY2VNZXNzYWdlICs9IGAgJyR7ZW5jb2RlQ29udGV4dE9iamVjdChjb250ZXh0KX0nYDtcbiAgICB9XG4gICAgcmV0dXJuIGAke2RlY29kaW5nQWR2aWNlTWVzc2FnZX1cXGBgO1xuICB9XG59XG5cbi8vIHNyYy9lcnJvci50c1xuZnVuY3Rpb24gaXNTb2xhbmFFcnJvcihlLCBjb2RlKSB7XG4gIGNvbnN0IGlzU29sYW5hRXJyb3IyID0gZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubmFtZSA9PT0gXCJTb2xhbmFFcnJvclwiO1xuICBpZiAoaXNTb2xhbmFFcnJvcjIpIHtcbiAgICBpZiAoY29kZSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gZS5jb250ZXh0Ll9fY29kZSA9PT0gY29kZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxudmFyIFNvbGFuYUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgdGhlIHJvb3QgY2F1c2Ugb2YgdGhpcyB7QGxpbmsgU29sYW5hRXJyb3J9LCBpZiBhbnkuXG4gICAqXG4gICAqIEZvciBleGFtcGxlLCBhIHRyYW5zYWN0aW9uIGVycm9yIG1pZ2h0IGhhdmUgYW4gaW5zdHJ1Y3Rpb24gZXJyb3IgYXMgaXRzIHJvb3QgY2F1c2UuIEluIHRoaXNcbiAgICogY2FzZSwgeW91IHdpbGwgYmUgYWJsZSB0byBhY2Nlc3MgdGhlIGluc3RydWN0aW9uIGVycm9yIG9uIHRoZSB0cmFuc2FjdGlvbiBlcnJvciBhcyBgY2F1c2VgLlxuICAgKi9cbiAgY2F1c2UgPSB0aGlzLmNhdXNlO1xuICAvKipcbiAgICogQ29udGFpbnMgY29udGV4dCB0aGF0IGNhbiBhc3Npc3QgaW4gdW5kZXJzdGFuZGluZyBvciByZWNvdmVyaW5nIGZyb20gYSB7QGxpbmsgU29sYW5hRXJyb3J9LlxuICAgKi9cbiAgY29udGV4dDtcbiAgY29uc3RydWN0b3IoLi4uW2NvZGUsIGNvbnRleHRBbmRFcnJvck9wdGlvbnNdKSB7XG4gICAgbGV0IGNvbnRleHQ7XG4gICAgbGV0IGVycm9yT3B0aW9ucztcbiAgICBpZiAoY29udGV4dEFuZEVycm9yT3B0aW9ucykge1xuICAgICAgY29uc3QgeyBjYXVzZSwgLi4uY29udGV4dFJlc3QgfSA9IGNvbnRleHRBbmRFcnJvck9wdGlvbnM7XG4gICAgICBpZiAoY2F1c2UpIHtcbiAgICAgICAgZXJyb3JPcHRpb25zID0geyBjYXVzZSB9O1xuICAgICAgfVxuICAgICAgaWYgKE9iamVjdC5rZXlzKGNvbnRleHRSZXN0KS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnRleHQgPSBjb250ZXh0UmVzdDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZSA9IGdldEVycm9yTWVzc2FnZShjb2RlLCBjb250ZXh0KTtcbiAgICBzdXBlcihtZXNzYWdlLCBlcnJvck9wdGlvbnMpO1xuICAgIHRoaXMuY29udGV4dCA9IHtcbiAgICAgIF9fY29kZTogY29kZSxcbiAgICAgIC4uLmNvbnRleHRcbiAgICB9O1xuICAgIHRoaXMubmFtZSA9IFwiU29sYW5hRXJyb3JcIjtcbiAgfVxufTtcblxuLy8gc3JjL3N0YWNrLXRyYWNlLnRzXG5mdW5jdGlvbiBzYWZlQ2FwdHVyZVN0YWNrVHJhY2UoLi4uYXJncykge1xuICBpZiAoXCJjYXB0dXJlU3RhY2tUcmFjZVwiIGluIEVycm9yICYmIHR5cGVvZiBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoLi4uYXJncyk7XG4gIH1cbn1cblxuLy8gc3JjL3JwYy1lbnVtLWVycm9ycy50c1xuZnVuY3Rpb24gZ2V0U29sYW5hRXJyb3JGcm9tUnBjRXJyb3IoeyBlcnJvckNvZGVCYXNlT2Zmc2V0LCBnZXRFcnJvckNvbnRleHQsIG9yZGVyZWRFcnJvck5hbWVzLCBycGNFbnVtRXJyb3IgfSwgY29uc3RydWN0b3JPcHQpIHtcbiAgbGV0IHJwY0Vycm9yTmFtZTtcbiAgbGV0IHJwY0Vycm9yQ29udGV4dDtcbiAgaWYgKHR5cGVvZiBycGNFbnVtRXJyb3IgPT09IFwic3RyaW5nXCIpIHtcbiAgICBycGNFcnJvck5hbWUgPSBycGNFbnVtRXJyb3I7XG4gIH0gZWxzZSB7XG4gICAgcnBjRXJyb3JOYW1lID0gT2JqZWN0LmtleXMocnBjRW51bUVycm9yKVswXTtcbiAgICBycGNFcnJvckNvbnRleHQgPSBycGNFbnVtRXJyb3JbcnBjRXJyb3JOYW1lXTtcbiAgfVxuICBjb25zdCBjb2RlT2Zmc2V0ID0gb3JkZXJlZEVycm9yTmFtZXMuaW5kZXhPZihycGNFcnJvck5hbWUpO1xuICBjb25zdCBlcnJvckNvZGUgPSBlcnJvckNvZGVCYXNlT2Zmc2V0ICsgY29kZU9mZnNldDtcbiAgY29uc3QgZXJyb3JDb250ZXh0ID0gZ2V0RXJyb3JDb250ZXh0KGVycm9yQ29kZSwgcnBjRXJyb3JOYW1lLCBycGNFcnJvckNvbnRleHQpO1xuICBjb25zdCBlcnIgPSBuZXcgU29sYW5hRXJyb3IoZXJyb3JDb2RlLCBlcnJvckNvbnRleHQpO1xuICBzYWZlQ2FwdHVyZVN0YWNrVHJhY2UoZXJyLCBjb25zdHJ1Y3Rvck9wdCk7XG4gIHJldHVybiBlcnI7XG59XG5cbi8vIHNyYy9pbnN0cnVjdGlvbi1lcnJvci50c1xudmFyIE9SREVSRURfRVJST1JfTkFNRVMgPSBbXG4gIC8vIEtlZXAgc3luY2VkIHdpdGggUlBDIHNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL2FuemEteHl6L2FnYXZlL2Jsb2IvbWFzdGVyL3Nkay9wcm9ncmFtL3NyYy9pbnN0cnVjdGlvbi5yc1xuICAvLyBJZiB0aGlzIGxpc3QgZXZlciBnZXRzIHRvbyBsYXJnZSwgY29uc2lkZXIgaW1wbGVtZW50aW5nIGEgY29tcHJlc3Npb24gc3RyYXRlZ3kgbGlrZSB0aGlzOlxuICAvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9zdGV2ZWx1c2NoZXIvYWFhN2NiYmI1NDMzYjExOTc5ODM5MDhhNDA4NjBjNDdcbiAgXCJHZW5lcmljRXJyb3JcIixcbiAgXCJJbnZhbGlkQXJndW1lbnRcIixcbiAgXCJJbnZhbGlkSW5zdHJ1Y3Rpb25EYXRhXCIsXG4gIFwiSW52YWxpZEFjY291bnREYXRhXCIsXG4gIFwiQWNjb3VudERhdGFUb29TbWFsbFwiLFxuICBcIkluc3VmZmljaWVudEZ1bmRzXCIsXG4gIFwiSW5jb3JyZWN0UHJvZ3JhbUlkXCIsXG4gIFwiTWlzc2luZ1JlcXVpcmVkU2lnbmF0dXJlXCIsXG4gIFwiQWNjb3VudEFscmVhZHlJbml0aWFsaXplZFwiLFxuICBcIlVuaW5pdGlhbGl6ZWRBY2NvdW50XCIsXG4gIFwiVW5iYWxhbmNlZEluc3RydWN0aW9uXCIsXG4gIFwiTW9kaWZpZWRQcm9ncmFtSWRcIixcbiAgXCJFeHRlcm5hbEFjY291bnRMYW1wb3J0U3BlbmRcIixcbiAgXCJFeHRlcm5hbEFjY291bnREYXRhTW9kaWZpZWRcIixcbiAgXCJSZWFkb25seUxhbXBvcnRDaGFuZ2VcIixcbiAgXCJSZWFkb25seURhdGFNb2RpZmllZFwiLFxuICBcIkR1cGxpY2F0ZUFjY291bnRJbmRleFwiLFxuICBcIkV4ZWN1dGFibGVNb2RpZmllZFwiLFxuICBcIlJlbnRFcG9jaE1vZGlmaWVkXCIsXG4gIFwiTm90RW5vdWdoQWNjb3VudEtleXNcIixcbiAgXCJBY2NvdW50RGF0YVNpemVDaGFuZ2VkXCIsXG4gIFwiQWNjb3VudE5vdEV4ZWN1dGFibGVcIixcbiAgXCJBY2NvdW50Qm9ycm93RmFpbGVkXCIsXG4gIFwiQWNjb3VudEJvcnJvd091dHN0YW5kaW5nXCIsXG4gIFwiRHVwbGljYXRlQWNjb3VudE91dE9mU3luY1wiLFxuICBcIkN1c3RvbVwiLFxuICBcIkludmFsaWRFcnJvclwiLFxuICBcIkV4ZWN1dGFibGVEYXRhTW9kaWZpZWRcIixcbiAgXCJFeGVjdXRhYmxlTGFtcG9ydENoYW5nZVwiLFxuICBcIkV4ZWN1dGFibGVBY2NvdW50Tm90UmVudEV4ZW1wdFwiLFxuICBcIlVuc3VwcG9ydGVkUHJvZ3JhbUlkXCIsXG4gIFwiQ2FsbERlcHRoXCIsXG4gIFwiTWlzc2luZ0FjY291bnRcIixcbiAgXCJSZWVudHJhbmN5Tm90QWxsb3dlZFwiLFxuICBcIk1heFNlZWRMZW5ndGhFeGNlZWRlZFwiLFxuICBcIkludmFsaWRTZWVkc1wiLFxuICBcIkludmFsaWRSZWFsbG9jXCIsXG4gIFwiQ29tcHV0YXRpb25hbEJ1ZGdldEV4Y2VlZGVkXCIsXG4gIFwiUHJpdmlsZWdlRXNjYWxhdGlvblwiLFxuICBcIlByb2dyYW1FbnZpcm9ubWVudFNldHVwRmFpbHVyZVwiLFxuICBcIlByb2dyYW1GYWlsZWRUb0NvbXBsZXRlXCIsXG4gIFwiUHJvZ3JhbUZhaWxlZFRvQ29tcGlsZVwiLFxuICBcIkltbXV0YWJsZVwiLFxuICBcIkluY29ycmVjdEF1dGhvcml0eVwiLFxuICBcIkJvcnNoSW9FcnJvclwiLFxuICBcIkFjY291bnROb3RSZW50RXhlbXB0XCIsXG4gIFwiSW52YWxpZEFjY291bnRPd25lclwiLFxuICBcIkFyaXRobWV0aWNPdmVyZmxvd1wiLFxuICBcIlVuc3VwcG9ydGVkU3lzdmFyXCIsXG4gIFwiSWxsZWdhbE93bmVyXCIsXG4gIFwiTWF4QWNjb3VudHNEYXRhQWxsb2NhdGlvbnNFeGNlZWRlZFwiLFxuICBcIk1heEFjY291bnRzRXhjZWVkZWRcIixcbiAgXCJNYXhJbnN0cnVjdGlvblRyYWNlTGVuZ3RoRXhjZWVkZWRcIixcbiAgXCJCdWlsdGluUHJvZ3JhbXNNdXN0Q29uc3VtZUNvbXB1dGVVbml0c1wiXG5dO1xuZnVuY3Rpb24gZ2V0U29sYW5hRXJyb3JGcm9tSW5zdHJ1Y3Rpb25FcnJvcihpbmRleCwgaW5zdHJ1Y3Rpb25FcnJvcikge1xuICBjb25zdCBudW1iZXJJbmRleCA9IE51bWJlcihpbmRleCk7XG4gIHJldHVybiBnZXRTb2xhbmFFcnJvckZyb21ScGNFcnJvcihcbiAgICB7XG4gICAgICBlcnJvckNvZGVCYXNlT2Zmc2V0OiA0NjE1MDAxLFxuICAgICAgZ2V0RXJyb3JDb250ZXh0KGVycm9yQ29kZSwgcnBjRXJyb3JOYW1lLCBycGNFcnJvckNvbnRleHQpIHtcbiAgICAgICAgaWYgKGVycm9yQ29kZSA9PT0gU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fVU5LTk9XTikge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlcnJvck5hbWU6IHJwY0Vycm9yTmFtZSxcbiAgICAgICAgICAgIGluZGV4OiBudW1iZXJJbmRleCxcbiAgICAgICAgICAgIC4uLnJwY0Vycm9yQ29udGV4dCAhPT0gdm9pZCAwID8geyBpbnN0cnVjdGlvbkVycm9yQ29udGV4dDogcnBjRXJyb3JDb250ZXh0IH0gOiBudWxsXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChlcnJvckNvZGUgPT09IFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0NVU1RPTSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2RlOiBOdW1iZXIocnBjRXJyb3JDb250ZXh0KSxcbiAgICAgICAgICAgIGluZGV4OiBudW1iZXJJbmRleFxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoZXJyb3JDb2RlID09PSBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19CT1JTSF9JT19FUlJPUikge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlbmNvZGVkRGF0YTogcnBjRXJyb3JDb250ZXh0LFxuICAgICAgICAgICAgaW5kZXg6IG51bWJlckluZGV4XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBpbmRleDogbnVtYmVySW5kZXggfTtcbiAgICAgIH0sXG4gICAgICBvcmRlcmVkRXJyb3JOYW1lczogT1JERVJFRF9FUlJPUl9OQU1FUyxcbiAgICAgIHJwY0VudW1FcnJvcjogaW5zdHJ1Y3Rpb25FcnJvclxuICAgIH0sXG4gICAgZ2V0U29sYW5hRXJyb3JGcm9tSW5zdHJ1Y3Rpb25FcnJvclxuICApO1xufVxuXG4vLyBzcmMvdHJhbnNhY3Rpb24tZXJyb3IudHNcbnZhciBPUkRFUkVEX0VSUk9SX05BTUVTMiA9IFtcbiAgLy8gS2VlcCBzeW5jZWQgd2l0aCBSUEMgc291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vYW56YS14eXovYWdhdmUvYmxvYi9tYXN0ZXIvc2RrL3NyYy90cmFuc2FjdGlvbi9lcnJvci5yc1xuICAvLyBJZiB0aGlzIGxpc3QgZXZlciBnZXRzIHRvbyBsYXJnZSwgY29uc2lkZXIgaW1wbGVtZW50aW5nIGEgY29tcHJlc3Npb24gc3RyYXRlZ3kgbGlrZSB0aGlzOlxuICAvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9zdGV2ZWx1c2NoZXIvYWFhN2NiYmI1NDMzYjExOTc5ODM5MDhhNDA4NjBjNDdcbiAgXCJBY2NvdW50SW5Vc2VcIixcbiAgXCJBY2NvdW50TG9hZGVkVHdpY2VcIixcbiAgXCJBY2NvdW50Tm90Rm91bmRcIixcbiAgXCJQcm9ncmFtQWNjb3VudE5vdEZvdW5kXCIsXG4gIFwiSW5zdWZmaWNpZW50RnVuZHNGb3JGZWVcIixcbiAgXCJJbnZhbGlkQWNjb3VudEZvckZlZVwiLFxuICBcIkFscmVhZHlQcm9jZXNzZWRcIixcbiAgXCJCbG9ja2hhc2hOb3RGb3VuZFwiLFxuICAvLyBgSW5zdHJ1Y3Rpb25FcnJvcmAgaW50ZW50aW9uYWxseSBvbWl0dGVkOyBkZWxlZ2F0ZWQgdG8gYGdldFNvbGFuYUVycm9yRnJvbUluc3RydWN0aW9uRXJyb3JgXG4gIFwiQ2FsbENoYWluVG9vRGVlcFwiLFxuICBcIk1pc3NpbmdTaWduYXR1cmVGb3JGZWVcIixcbiAgXCJJbnZhbGlkQWNjb3VudEluZGV4XCIsXG4gIFwiU2lnbmF0dXJlRmFpbHVyZVwiLFxuICBcIkludmFsaWRQcm9ncmFtRm9yRXhlY3V0aW9uXCIsXG4gIFwiU2FuaXRpemVGYWlsdXJlXCIsXG4gIFwiQ2x1c3Rlck1haW50ZW5hbmNlXCIsXG4gIFwiQWNjb3VudEJvcnJvd091dHN0YW5kaW5nXCIsXG4gIFwiV291bGRFeGNlZWRNYXhCbG9ja0Nvc3RMaW1pdFwiLFxuICBcIlVuc3VwcG9ydGVkVmVyc2lvblwiLFxuICBcIkludmFsaWRXcml0YWJsZUFjY291bnRcIixcbiAgXCJXb3VsZEV4Y2VlZE1heEFjY291bnRDb3N0TGltaXRcIixcbiAgXCJXb3VsZEV4Y2VlZEFjY291bnREYXRhQmxvY2tMaW1pdFwiLFxuICBcIlRvb01hbnlBY2NvdW50TG9ja3NcIixcbiAgXCJBZGRyZXNzTG9va3VwVGFibGVOb3RGb3VuZFwiLFxuICBcIkludmFsaWRBZGRyZXNzTG9va3VwVGFibGVPd25lclwiLFxuICBcIkludmFsaWRBZGRyZXNzTG9va3VwVGFibGVEYXRhXCIsXG4gIFwiSW52YWxpZEFkZHJlc3NMb29rdXBUYWJsZUluZGV4XCIsXG4gIFwiSW52YWxpZFJlbnRQYXlpbmdBY2NvdW50XCIsXG4gIFwiV291bGRFeGNlZWRNYXhWb3RlQ29zdExpbWl0XCIsXG4gIFwiV291bGRFeGNlZWRBY2NvdW50RGF0YVRvdGFsTGltaXRcIixcbiAgXCJEdXBsaWNhdGVJbnN0cnVjdGlvblwiLFxuICBcIkluc3VmZmljaWVudEZ1bmRzRm9yUmVudFwiLFxuICBcIk1heExvYWRlZEFjY291bnRzRGF0YVNpemVFeGNlZWRlZFwiLFxuICBcIkludmFsaWRMb2FkZWRBY2NvdW50c0RhdGFTaXplTGltaXRcIixcbiAgXCJSZXNhbml0aXphdGlvbk5lZWRlZFwiLFxuICBcIlByb2dyYW1FeGVjdXRpb25UZW1wb3JhcmlseVJlc3RyaWN0ZWRcIixcbiAgXCJVbmJhbGFuY2VkVHJhbnNhY3Rpb25cIlxuXTtcbmZ1bmN0aW9uIGdldFNvbGFuYUVycm9yRnJvbVRyYW5zYWN0aW9uRXJyb3IodHJhbnNhY3Rpb25FcnJvcikge1xuICBpZiAodHlwZW9mIHRyYW5zYWN0aW9uRXJyb3IgPT09IFwib2JqZWN0XCIgJiYgXCJJbnN0cnVjdGlvbkVycm9yXCIgaW4gdHJhbnNhY3Rpb25FcnJvcikge1xuICAgIHJldHVybiBnZXRTb2xhbmFFcnJvckZyb21JbnN0cnVjdGlvbkVycm9yKFxuICAgICAgLi4udHJhbnNhY3Rpb25FcnJvci5JbnN0cnVjdGlvbkVycm9yXG4gICAgKTtcbiAgfVxuICByZXR1cm4gZ2V0U29sYW5hRXJyb3JGcm9tUnBjRXJyb3IoXG4gICAge1xuICAgICAgZXJyb3JDb2RlQmFzZU9mZnNldDogNzA1MDAwMSxcbiAgICAgIGdldEVycm9yQ29udGV4dChlcnJvckNvZGUsIHJwY0Vycm9yTmFtZSwgcnBjRXJyb3JDb250ZXh0KSB7XG4gICAgICAgIGlmIChlcnJvckNvZGUgPT09IFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1VOS05PV04pIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXJyb3JOYW1lOiBycGNFcnJvck5hbWUsXG4gICAgICAgICAgICAuLi5ycGNFcnJvckNvbnRleHQgIT09IHZvaWQgMCA/IHsgdHJhbnNhY3Rpb25FcnJvckNvbnRleHQ6IHJwY0Vycm9yQ29udGV4dCB9IDogbnVsbFxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoZXJyb3JDb2RlID09PSBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19EVVBMSUNBVEVfSU5TVFJVQ1RJT04pIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5kZXg6IE51bWJlcihycGNFcnJvckNvbnRleHQpXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChlcnJvckNvZGUgPT09IFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOU1VGRklDSUVOVF9GVU5EU19GT1JfUkVOVCB8fCBlcnJvckNvZGUgPT09IFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1BST0dSQU1fRVhFQ1VUSU9OX1RFTVBPUkFSSUxZX1JFU1RSSUNURUQpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWNjb3VudEluZGV4OiBOdW1iZXIocnBjRXJyb3JDb250ZXh0LmFjY291bnRfaW5kZXgpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9yZGVyZWRFcnJvck5hbWVzOiBPUkRFUkVEX0VSUk9SX05BTUVTMixcbiAgICAgIHJwY0VudW1FcnJvcjogdHJhbnNhY3Rpb25FcnJvclxuICAgIH0sXG4gICAgZ2V0U29sYW5hRXJyb3JGcm9tVHJhbnNhY3Rpb25FcnJvclxuICApO1xufVxuXG4vLyBzcmMvanNvbi1ycGMtZXJyb3IudHNcbmZ1bmN0aW9uIGdldFNvbGFuYUVycm9yRnJvbUpzb25ScGNFcnJvcihwdXRhdGl2ZUVycm9yUmVzcG9uc2UpIHtcbiAgbGV0IG91dDtcbiAgaWYgKGlzUnBjRXJyb3JSZXNwb25zZShwdXRhdGl2ZUVycm9yUmVzcG9uc2UpKSB7XG4gICAgY29uc3QgeyBjb2RlOiByYXdDb2RlLCBkYXRhLCBtZXNzYWdlIH0gPSBwdXRhdGl2ZUVycm9yUmVzcG9uc2U7XG4gICAgY29uc3QgY29kZSA9IE51bWJlcihyYXdDb2RlKTtcbiAgICBpZiAoY29kZSA9PT0gU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1NFTkRfVFJBTlNBQ1RJT05fUFJFRkxJR0hUX0ZBSUxVUkUpIHtcbiAgICAgIGNvbnN0IHsgZXJyLCAuLi5wcmVmbGlnaHRFcnJvckNvbnRleHQgfSA9IGRhdGE7XG4gICAgICBjb25zdCBjYXVzZU9iamVjdCA9IGVyciA/IHsgY2F1c2U6IGdldFNvbGFuYUVycm9yRnJvbVRyYW5zYWN0aW9uRXJyb3IoZXJyKSB9IDogbnVsbDtcbiAgICAgIG91dCA9IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfU0VORF9UUkFOU0FDVElPTl9QUkVGTElHSFRfRkFJTFVSRSwge1xuICAgICAgICAuLi5wcmVmbGlnaHRFcnJvckNvbnRleHQsXG4gICAgICAgIC4uLmNhdXNlT2JqZWN0XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGVycm9yQ29udGV4dDtcbiAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICBjYXNlIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX0lOVEVSTkFMX0VSUk9SOlxuICAgICAgICBjYXNlIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX0lOVkFMSURfUEFSQU1TOlxuICAgICAgICBjYXNlIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX0lOVkFMSURfUkVRVUVTVDpcbiAgICAgICAgY2FzZSBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19NRVRIT0RfTk9UX0ZPVU5EOlxuICAgICAgICBjYXNlIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1BBUlNFX0VSUk9SOlxuICAgICAgICBjYXNlIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NDQU5fRVJST1I6XG4gICAgICAgIGNhc2UgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0JMT0NLX0NMRUFORURfVVA6XG4gICAgICAgIGNhc2UgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0JMT0NLX05PVF9BVkFJTEFCTEU6XG4gICAgICAgIGNhc2UgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0JMT0NLX1NUQVRVU19OT1RfQVZBSUxBQkxFX1lFVDpcbiAgICAgICAgY2FzZSBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfS0VZX0VYQ0xVREVEX0ZST01fU0VDT05EQVJZX0lOREVYOlxuICAgICAgICBjYXNlIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9MT05HX1RFUk1fU1RPUkFHRV9TTE9UX1NLSVBQRUQ6XG4gICAgICAgIGNhc2UgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1NMT1RfU0tJUFBFRDpcbiAgICAgICAgY2FzZSBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fUFJFQ09NUElMRV9WRVJJRklDQVRJT05fRkFJTFVSRTpcbiAgICAgICAgY2FzZSBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfVU5TVVBQT1JURURfVFJBTlNBQ1RJT05fVkVSU0lPTjpcbiAgICAgICAgICBlcnJvckNvbnRleHQgPSB7IF9fc2VydmVyTWVzc2FnZTogbWVzc2FnZSB9O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgZXJyb3JDb250ZXh0ID0gZGF0YTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBvdXQgPSBuZXcgU29sYW5hRXJyb3IoY29kZSwgZXJyb3JDb250ZXh0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IHR5cGVvZiBwdXRhdGl2ZUVycm9yUmVzcG9uc2UgPT09IFwib2JqZWN0XCIgJiYgcHV0YXRpdmVFcnJvclJlc3BvbnNlICE9PSBudWxsICYmIFwibWVzc2FnZVwiIGluIHB1dGF0aXZlRXJyb3JSZXNwb25zZSAmJiB0eXBlb2YgcHV0YXRpdmVFcnJvclJlc3BvbnNlLm1lc3NhZ2UgPT09IFwic3RyaW5nXCIgPyBwdXRhdGl2ZUVycm9yUmVzcG9uc2UubWVzc2FnZSA6IFwiTWFsZm9ybWVkIEpTT04tUlBDIGVycm9yIHdpdGggbm8gbWVzc2FnZSBhdHRyaWJ1dGVcIjtcbiAgICBvdXQgPSBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19NQUxGT1JNRURfSlNPTl9SUENfRVJST1IsIHsgZXJyb3I6IHB1dGF0aXZlRXJyb3JSZXNwb25zZSwgbWVzc2FnZSB9KTtcbiAgfVxuICBzYWZlQ2FwdHVyZVN0YWNrVHJhY2Uob3V0LCBnZXRTb2xhbmFFcnJvckZyb21Kc29uUnBjRXJyb3IpO1xuICByZXR1cm4gb3V0O1xufVxuZnVuY3Rpb24gaXNScGNFcnJvclJlc3BvbnNlKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwgJiYgXCJjb2RlXCIgaW4gdmFsdWUgJiYgXCJtZXNzYWdlXCIgaW4gdmFsdWUgJiYgKHR5cGVvZiB2YWx1ZS5jb2RlID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiB2YWx1ZS5jb2RlID09PSBcImJpZ2ludFwiKSAmJiB0eXBlb2YgdmFsdWUubWVzc2FnZSA9PT0gXCJzdHJpbmdcIjtcbn1cblxuZXhwb3J0IHsgU09MQU5BX0VSUk9SX19BQ0NPVU5UU19fQUNDT1VOVF9OT1RfRk9VTkQsIFNPTEFOQV9FUlJPUl9fQUNDT1VOVFNfX0VYUEVDVEVEX0FMTF9BQ0NPVU5UU19UT19CRV9ERUNPREVELCBTT0xBTkFfRVJST1JfX0FDQ09VTlRTX19FWFBFQ1RFRF9ERUNPREVEX0FDQ09VTlQsIFNPTEFOQV9FUlJPUl9fQUNDT1VOVFNfX0ZBSUxFRF9UT19ERUNPREVfQUNDT1VOVCwgU09MQU5BX0VSUk9SX19BQ0NPVU5UU19fT05FX09SX01PUkVfQUNDT1VOVFNfTk9UX0ZPVU5ELCBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fRkFJTEVEX1RPX0ZJTkRfVklBQkxFX1BEQV9CVU1QX1NFRUQsIFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19JTlZBTElEX0JBU0U1OF9FTkNPREVEX0FERFJFU1MsIFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19JTlZBTElEX0JZVEVfTEVOR1RILCBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fSU5WQUxJRF9FRDI1NTE5X1BVQkxJQ19LRVksIFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19JTlZBTElEX09GRl9DVVJWRV9BRERSRVNTLCBTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fSU5WQUxJRF9TRUVEU19QT0lOVF9PTl9DVVJWRSwgU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX01BTEZPUk1FRF9QREEsIFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19NQVhfTlVNQkVSX09GX1BEQV9TRUVEU19FWENFRURFRCwgU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX01BWF9QREFfU0VFRF9MRU5HVEhfRVhDRUVERUQsIFNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19QREFfQlVNUF9TRUVEX09VVF9PRl9SQU5HRSwgU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX1BEQV9FTkRTX1dJVEhfUERBX01BUktFUiwgU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX1NUUklOR19MRU5HVEhfT1VUX09GX1JBTkdFLCBTT0xBTkFfRVJST1JfX0JMT0NLSEFTSF9TVFJJTkdfTEVOR1RIX09VVF9PRl9SQU5HRSwgU09MQU5BX0VSUk9SX19CTE9DS19IRUlHSFRfRVhDRUVERUQsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19DQU5OT1RfREVDT0RFX0VNUFRZX0JZVEVfQVJSQVksIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19DQU5OT1RfVVNFX0xFWElDQUxfVkFMVUVTX0FTX0VOVU1fRElTQ1JJTUlOQVRPUlMsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVEX0JZVEVTX01VU1RfTk9UX0lOQ0xVREVfU0VOVElORUwsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfRklYRURfU0laRV9NSVNNQVRDSCwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9NQVhfU0laRV9NSVNNQVRDSCwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9TSVpFX0NPTVBBVElCSUxJVFlfTUlTTUFUQ0gsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTlVNX0RJU0NSSU1JTkFUT1JfT1VUX09GX1JBTkdFLCBTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfRklYRURfTEVOR1RILCBTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfUE9TSVRJVkVfQllURV9MRU5HVEgsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9WQVJJQUJMRV9MRU5HVEgsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9aRVJPX1ZBTFVFX1RPX01BVENIX0lURU1fRklYRURfU0laRSwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfQllURV9MRU5HVEgsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0NPTlNUQU5ULCBTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9ESVNDUklNSU5BVEVEX1VOSU9OX1ZBUklBTlQsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0VOVU1fVkFSSUFOVCwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfTElURVJBTF9VTklPTl9WQVJJQU5ULCBTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9OVU1CRVJfT0ZfSVRFTVMsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX1NUUklOR19GT1JfQkFTRSwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0xJVEVSQUxfVU5JT05fRElTQ1JJTUlOQVRPUl9PVVRfT0ZfUkFOR0UsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19OVU1CRVJfT1VUX09GX1JBTkdFLCBTT0xBTkFfRVJST1JfX0NPREVDU19fT0ZGU0VUX09VVF9PRl9SQU5HRSwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX1NFTlRJTkVMX01JU1NJTkdfSU5fREVDT0RFRF9CWVRFUywgU09MQU5BX0VSUk9SX19DT0RFQ1NfX1VOSU9OX1ZBUklBTlRfT1VUX09GX1JBTkdFLCBTT0xBTkFfRVJST1JfX0NSWVBUT19fUkFORE9NX1ZBTFVFU19GVU5DVElPTl9VTklNUExFTUVOVEVELCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BQ0NPVU5UX0FMUkVBRFlfSU5JVElBTElaRUQsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfQk9SUk9XX0ZBSUxFRCwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9CT1JST1dfT1VUU1RBTkRJTkcsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfREFUQV9TSVpFX0NIQU5HRUQsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfREFUQV9UT09fU01BTEwsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfTk9UX0VYRUNVVEFCTEUsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfTk9UX1JFTlRfRVhFTVBULCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BUklUSE1FVElDX09WRVJGTE9XLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19CT1JTSF9JT19FUlJPUiwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQlVJTFRJTl9QUk9HUkFNU19NVVNUX0NPTlNVTUVfQ09NUFVURV9VTklUUywgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQ0FMTF9ERVBUSCwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQ09NUFVUQVRJT05BTF9CVURHRVRfRVhDRUVERUQsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0NVU1RPTSwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRFVQTElDQVRFX0FDQ09VTlRfSU5ERVgsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0RVUExJQ0FURV9BQ0NPVU5UX09VVF9PRl9TWU5DLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19FWEVDVVRBQkxFX0FDQ09VTlRfTk9UX1JFTlRfRVhFTVBULCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19FWEVDVVRBQkxFX0RBVEFfTU9ESUZJRUQsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0VYRUNVVEFCTEVfTEFNUE9SVF9DSEFOR0UsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0VYRUNVVEFCTEVfTU9ESUZJRUQsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0VYVEVSTkFMX0FDQ09VTlRfREFUQV9NT0RJRklFRCwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRVhURVJOQUxfQUNDT1VOVF9MQU1QT1JUX1NQRU5ELCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19HRU5FUklDX0VSUk9SLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTExFR0FMX09XTkVSLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTU1VVEFCTEUsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOQ09SUkVDVF9BVVRIT1JJVFksIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOQ09SUkVDVF9QUk9HUkFNX0lELCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlNVRkZJQ0lFTlRfRlVORFMsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfQUNDT1VOVF9EQVRBLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX0FDQ09VTlRfT1dORVIsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfQVJHVU1FTlQsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfRVJST1IsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfSU5TVFJVQ1RJT05fREFUQSwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9SRUFMTE9DLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX1NFRURTLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19NQVhfQUNDT1VOVFNfREFUQV9BTExPQ0FUSU9OU19FWENFRURFRCwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTUFYX0FDQ09VTlRTX0VYQ0VFREVELCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19NQVhfSU5TVFJVQ1RJT05fVFJBQ0VfTEVOR1RIX0VYQ0VFREVELCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19NQVhfU0VFRF9MRU5HVEhfRVhDRUVERUQsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01JU1NJTkdfQUNDT1VOVCwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTUlTU0lOR19SRVFVSVJFRF9TSUdOQVRVUkUsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01PRElGSUVEX1BST0dSQU1fSUQsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX05PVF9FTk9VR0hfQUNDT1VOVF9LRVlTLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19QUklWSUxFR0VfRVNDQUxBVElPTiwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUFJPR1JBTV9FTlZJUk9OTUVOVF9TRVRVUF9GQUlMVVJFLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19QUk9HUkFNX0ZBSUxFRF9UT19DT01QSUxFLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19QUk9HUkFNX0ZBSUxFRF9UT19DT01QTEVURSwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUkVBRE9OTFlfREFUQV9NT0RJRklFRCwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUkVBRE9OTFlfTEFNUE9SVF9DSEFOR0UsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1JFRU5UUkFOQ1lfTk9UX0FMTE9XRUQsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1JFTlRfRVBPQ0hfTU9ESUZJRUQsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1VOQkFMQU5DRURfSU5TVFJVQ1RJT04sIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1VOSU5JVElBTElaRURfQUNDT1VOVCwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fVU5LTk9XTiwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fVU5TVVBQT1JURURfUFJPR1JBTV9JRCwgU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fVU5TVVBQT1JURURfU1lTVkFSLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX19FWFBFQ1RFRF9UT19IQVZFX0FDQ09VTlRTLCBTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX19FWFBFQ1RFRF9UT19IQVZFX0RBVEEsIFNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fX1BST0dSQU1fSURfTUlTTUFUQ0gsIFNPTEFOQV9FUlJPUl9fSU5WQUxJRF9CTE9DS0hBU0hfQllURV9MRU5HVEgsIFNPTEFOQV9FUlJPUl9fSU5WQUxJRF9OT05DRSwgU09MQU5BX0VSUk9SX19JTlZBUklBTlRfVklPTEFUSU9OX19DQUNIRURfQUJPUlRBQkxFX0lURVJBQkxFX0NBQ0hFX0VOVFJZX01JU1NJTkcsIFNPTEFOQV9FUlJPUl9fSU5WQVJJQU5UX1ZJT0xBVElPTl9fREFUQV9QVUJMSVNIRVJfQ0hBTk5FTF9VTklNUExFTUVOVEVELCBTT0xBTkFfRVJST1JfX0lOVkFSSUFOVF9WSU9MQVRJT05fX1NVQlNDUklQVElPTl9JVEVSQVRPUl9NVVNUX05PVF9QT0xMX0JFRk9SRV9SRVNPTFZJTkdfRVhJU1RJTkdfTUVTU0FHRV9QUk9NSVNFLCBTT0xBTkFfRVJST1JfX0lOVkFSSUFOVF9WSU9MQVRJT05fX1NVQlNDUklQVElPTl9JVEVSQVRPUl9TVEFURV9NSVNTSU5HLCBTT0xBTkFfRVJST1JfX0lOVkFSSUFOVF9WSU9MQVRJT05fX1NXSVRDSF9NVVNUX0JFX0VYSEFVU1RJVkUsIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX0lOVEVSTkFMX0VSUk9SLCBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19JTlZBTElEX1BBUkFNUywgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fSU5WQUxJRF9SRVFVRVNULCBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19NRVRIT0RfTk9UX0ZPVU5ELCBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19QQVJTRV9FUlJPUiwgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0NBTl9FUlJPUiwgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0JMT0NLX0NMRUFORURfVVAsIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9CTE9DS19OT1RfQVZBSUxBQkxFLCBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfQkxPQ0tfU1RBVFVTX05PVF9BVkFJTEFCTEVfWUVULCBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfS0VZX0VYQ0xVREVEX0ZST01fU0VDT05EQVJZX0lOREVYLCBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfTE9OR19URVJNX1NUT1JBR0VfU0xPVF9TS0lQUEVELCBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfTUlOX0NPTlRFWFRfU0xPVF9OT1RfUkVBQ0hFRCwgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX05PREVfVU5IRUFMVEhZLCBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfTk9fU05BUFNIT1QsIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9TRU5EX1RSQU5TQUNUSU9OX1BSRUZMSUdIVF9GQUlMVVJFLCBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfU0xPVF9TS0lQUEVELCBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fSElTVE9SWV9OT1RfQVZBSUxBQkxFLCBTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fUFJFQ09NUElMRV9WRVJJRklDQVRJT05fRkFJTFVSRSwgU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX1NJR05BVFVSRV9MRU5fTUlTTUFUQ0gsIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9TSUdOQVRVUkVfVkVSSUZJQ0FUSU9OX0ZBSUxVUkUsIFNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9VTlNVUFBPUlRFRF9UUkFOU0FDVElPTl9WRVJTSU9OLCBTT0xBTkFfRVJST1JfX0tFWVNfX0lOVkFMSURfS0VZX1BBSVJfQllURV9MRU5HVEgsIFNPTEFOQV9FUlJPUl9fS0VZU19fSU5WQUxJRF9QUklWQVRFX0tFWV9CWVRFX0xFTkdUSCwgU09MQU5BX0VSUk9SX19LRVlTX19JTlZBTElEX1NJR05BVFVSRV9CWVRFX0xFTkdUSCwgU09MQU5BX0VSUk9SX19LRVlTX19QVUJMSUNfS0VZX01VU1RfTUFUQ0hfUFJJVkFURV9LRVksIFNPTEFOQV9FUlJPUl9fS0VZU19fU0lHTkFUVVJFX1NUUklOR19MRU5HVEhfT1VUX09GX1JBTkdFLCBTT0xBTkFfRVJST1JfX0xBTVBPUlRTX09VVF9PRl9SQU5HRSwgU09MQU5BX0VSUk9SX19NQUxGT1JNRURfQklHSU5UX1NUUklORywgU09MQU5BX0VSUk9SX19NQUxGT1JNRURfSlNPTl9SUENfRVJST1IsIFNPTEFOQV9FUlJPUl9fTUFMRk9STUVEX05VTUJFUl9TVFJJTkcsIFNPTEFOQV9FUlJPUl9fTk9OQ0VfQUNDT1VOVF9OT1RfRk9VTkQsIFNPTEFOQV9FUlJPUl9fUlBDX1NVQlNDUklQVElPTlNfX0NBTk5PVF9DUkVBVEVfU1VCU0NSSVBUSU9OX1BMQU4sIFNPTEFOQV9FUlJPUl9fUlBDX1NVQlNDUklQVElPTlNfX0NIQU5ORUxfQ0xPU0VEX0JFRk9SRV9NRVNTQUdFX0JVRkZFUkVELCBTT0xBTkFfRVJST1JfX1JQQ19TVUJTQ1JJUFRJT05TX19DSEFOTkVMX0NPTk5FQ1RJT05fQ0xPU0VELCBTT0xBTkFfRVJST1JfX1JQQ19TVUJTQ1JJUFRJT05TX19DSEFOTkVMX0ZBSUxFRF9UT19DT05ORUNULCBTT0xBTkFfRVJST1JfX1JQQ19TVUJTQ1JJUFRJT05TX19FWFBFQ1RFRF9TRVJWRVJfU1VCU0NSSVBUSU9OX0lELCBTT0xBTkFfRVJST1JfX1JQQ19fQVBJX1BMQU5fTUlTU0lOR19GT1JfUlBDX01FVEhPRCwgU09MQU5BX0VSUk9SX19SUENfX0lOVEVHRVJfT1ZFUkZMT1csIFNPTEFOQV9FUlJPUl9fUlBDX19UUkFOU1BPUlRfSFRUUF9FUlJPUiwgU09MQU5BX0VSUk9SX19SUENfX1RSQU5TUE9SVF9IVFRQX0hFQURFUl9GT1JCSURERU4sIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19BRERSRVNTX0NBTk5PVF9IQVZFX01VTFRJUExFX1NJR05FUlMsIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9LRVlfUEFJUl9TSUdORVIsIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9NRVNTQUdFX01PRElGWUlOR19TSUdORVIsIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9NRVNTQUdFX1BBUlRJQUxfU0lHTkVSLCBTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfTUVTU0FHRV9TSUdORVIsIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9UUkFOU0FDVElPTl9NT0RJRllJTkdfU0lHTkVSLCBTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfVFJBTlNBQ1RJT05fUEFSVElBTF9TSUdORVIsIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9UUkFOU0FDVElPTl9TRU5ESU5HX1NJR05FUiwgU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX1RSQU5TQUNUSU9OX1NJR05FUiwgU09MQU5BX0VSUk9SX19TSUdORVJfX1RSQU5TQUNUSU9OX0NBTk5PVF9IQVZFX01VTFRJUExFX1NFTkRJTkdfU0lHTkVSUywgU09MQU5BX0VSUk9SX19TSUdORVJfX1RSQU5TQUNUSU9OX1NFTkRJTkdfU0lHTkVSX01JU1NJTkcsIFNPTEFOQV9FUlJPUl9fU0lHTkVSX19XQUxMRVRfTVVMVElTSUdOX1VOSU1QTEVNRU5URUQsIFNPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fQ0FOTk9UX0VYUE9SVF9OT05fRVhUUkFDVEFCTEVfS0VZLCBTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX0RJR0VTVF9VTklNUExFTUVOVEVELCBTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX0RJU0FMTE9XRURfSU5fSU5TRUNVUkVfQ09OVEVYVCwgU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19FRDI1NTE5X0FMR09SSVRITV9VTklNUExFTUVOVEVELCBTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX0VYUE9SVF9GVU5DVElPTl9VTklNUExFTUVOVEVELCBTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX0dFTkVSQVRFX0ZVTkNUSU9OX1VOSU1QTEVNRU5URUQsIFNPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fU0lHTl9GVU5DVElPTl9VTklNUExFTUVOVEVELCBTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX1ZFUklGWV9GVU5DVElPTl9VTklNUExFTUVOVEVELCBTT0xBTkFfRVJST1JfX1RJTUVTVEFNUF9PVVRfT0ZfUkFOR0UsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0FDQ09VTlRfQk9SUk9XX09VVFNUQU5ESU5HLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19BQ0NPVU5UX0lOX1VTRSwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQUNDT1VOVF9MT0FERURfVFdJQ0UsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0FDQ09VTlRfTk9UX0ZPVU5ELCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19BRERSRVNTX0xPT0tVUF9UQUJMRV9OT1RfRk9VTkQsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0FMUkVBRFlfUFJPQ0VTU0VELCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19CTE9DS0hBU0hfTk9UX0ZPVU5ELCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19DQUxMX0NIQUlOX1RPT19ERUVQLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19DTFVTVEVSX01BSU5URU5BTkNFLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19EVVBMSUNBVEVfSU5TVFJVQ1RJT04sIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOU1VGRklDSUVOVF9GVU5EU19GT1JfRkVFLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlNVRkZJQ0lFTlRfRlVORFNfRk9SX1JFTlQsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfQUNDT1VOVF9GT1JfRkVFLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX0FDQ09VTlRfSU5ERVgsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfQUREUkVTU19MT09LVVBfVEFCTEVfREFUQSwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9BRERSRVNTX0xPT0tVUF9UQUJMRV9JTkRFWCwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9BRERSRVNTX0xPT0tVUF9UQUJMRV9PV05FUiwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9MT0FERURfQUNDT1VOVFNfREFUQV9TSVpFX0xJTUlULCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX1BST0dSQU1fRk9SX0VYRUNVVElPTiwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9SRU5UX1BBWUlOR19BQ0NPVU5ULCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX1dSSVRBQkxFX0FDQ09VTlQsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX01BWF9MT0FERURfQUNDT1VOVFNfREFUQV9TSVpFX0VYQ0VFREVELCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19NSVNTSU5HX1NJR05BVFVSRV9GT1JfRkVFLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19QUk9HUkFNX0FDQ09VTlRfTk9UX0ZPVU5ELCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19QUk9HUkFNX0VYRUNVVElPTl9URU1QT1JBUklMWV9SRVNUUklDVEVELCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19SRVNBTklUSVpBVElPTl9ORUVERUQsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1NBTklUSVpFX0ZBSUxVUkUsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1NJR05BVFVSRV9GQUlMVVJFLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19UT09fTUFOWV9BQ0NPVU5UX0xPQ0tTLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19VTkJBTEFOQ0VEX1RSQU5TQUNUSU9OLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19VTktOT1dOLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19VTlNVUFBPUlRFRF9WRVJTSU9OLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19XT1VMRF9FWENFRURfQUNDT1VOVF9EQVRBX0JMT0NLX0xJTUlULCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19XT1VMRF9FWENFRURfQUNDT1VOVF9EQVRBX1RPVEFMX0xJTUlULCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19XT1VMRF9FWENFRURfTUFYX0FDQ09VTlRfQ09TVF9MSU1JVCwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fV09VTERfRVhDRUVEX01BWF9CTE9DS19DT1NUX0xJTUlULCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19XT1VMRF9FWENFRURfTUFYX1ZPVEVfQ09TVF9MSU1JVCwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fQUREUkVTU0VTX0NBTk5PVF9TSUdOX1RSQU5TQUNUSU9OLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19BRERSRVNTX01JU1NJTkcsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0NBTk5PVF9FTkNPREVfV0lUSF9FTVBUWV9TSUdOQVRVUkVTLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19FWENFRURTX1NJWkVfTElNSVQsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0VYUEVDVEVEX0JMT0NLSEFTSF9MSUZFVElNRSwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRVhQRUNURURfTk9OQ0VfTElGRVRJTUUsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9UT19ERUNPTVBJTEVfQUREUkVTU19MT09LVVBfVEFCTEVfQ09OVEVOVFNfTUlTU0lORywgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkFJTEVEX1RPX0RFQ09NUElMRV9BRERSRVNTX0xPT0tVUF9UQUJMRV9JTkRFWF9PVVRfT0ZfUkFOR0UsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9UT19ERUNPTVBJTEVfRkVFX1BBWUVSX01JU1NJTkcsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9UT19ERUNPTVBJTEVfSU5TVFJVQ1RJT05fUFJPR1JBTV9BRERSRVNTX05PVF9GT1VORCwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkFJTEVEX1RPX0VTVElNQVRFX0NPTVBVVEVfTElNSVQsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9XSEVOX1NJTVVMQVRJTkdfVE9fRVNUSU1BVEVfQ09NUFVURV9MSU1JVCwgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkVFX1BBWUVSX01JU1NJTkcsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZFRV9QQVlFUl9TSUdOQVRVUkVfTUlTU0lORywgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fSU5WQUxJRF9OT05DRV9UUkFOU0FDVElPTl9GSVJTVF9JTlNUUlVDVElPTl9NVVNUX0JFX0FEVkFOQ0VfTk9OQ0UsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0lOVkFMSURfTk9OQ0VfVFJBTlNBQ1RJT05fSU5TVFJVQ1RJT05TX01JU1NJTkcsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0lOVk9LRURfUFJPR1JBTVNfQ0FOTk9UX1BBWV9GRUVTLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19JTlZPS0VEX1BST0dSQU1TX01VU1RfTk9UX0JFX1dSSVRBQkxFLCBTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19NRVNTQUdFX1NJR05BVFVSRVNfTUlTTUFUQ0gsIFNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX1NJR05BVFVSRVNfTUlTU0lORywgU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fVkVSU0lPTl9OVU1CRVJfT1VUX09GX1JBTkdFLCBTb2xhbmFFcnJvciwgZ2V0U29sYW5hRXJyb3JGcm9tSW5zdHJ1Y3Rpb25FcnJvciwgZ2V0U29sYW5hRXJyb3JGcm9tSnNvblJwY0Vycm9yLCBnZXRTb2xhbmFFcnJvckZyb21UcmFuc2FjdGlvbkVycm9yLCBpc1NvbGFuYUVycm9yLCBzYWZlQ2FwdHVyZVN0YWNrVHJhY2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm5vZGUubWpzLm1hcFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubm9kZS5tanMubWFwIl0sIm5hbWVzIjpbIlNPTEFOQV9FUlJPUl9fQkxPQ0tfSEVJR0hUX0VYQ0VFREVEIiwiU09MQU5BX0VSUk9SX19JTlZBTElEX05PTkNFIiwiU09MQU5BX0VSUk9SX19OT05DRV9BQ0NPVU5UX05PVF9GT1VORCIsIlNPTEFOQV9FUlJPUl9fQkxPQ0tIQVNIX1NUUklOR19MRU5HVEhfT1VUX09GX1JBTkdFIiwiU09MQU5BX0VSUk9SX19JTlZBTElEX0JMT0NLSEFTSF9CWVRFX0xFTkdUSCIsIlNPTEFOQV9FUlJPUl9fTEFNUE9SVFNfT1VUX09GX1JBTkdFIiwiU09MQU5BX0VSUk9SX19NQUxGT1JNRURfQklHSU5UX1NUUklORyIsIlNPTEFOQV9FUlJPUl9fTUFMRk9STUVEX05VTUJFUl9TVFJJTkciLCJTT0xBTkFfRVJST1JfX1RJTUVTVEFNUF9PVVRfT0ZfUkFOR0UiLCJTT0xBTkFfRVJST1JfX01BTEZPUk1FRF9KU09OX1JQQ19FUlJPUiIsIlNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1BBUlNFX0VSUk9SIiwiU09MQU5BX0VSUk9SX19KU09OX1JQQ19fSU5URVJOQUxfRVJST1IiLCJTT0xBTkFfRVJST1JfX0pTT05fUlBDX19JTlZBTElEX1BBUkFNUyIsIlNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX01FVEhPRF9OT1RfRk9VTkQiLCJTT0xBTkFfRVJST1JfX0pTT05fUlBDX19JTlZBTElEX1JFUVVFU1QiLCJTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfTUlOX0NPTlRFWFRfU0xPVF9OT1RfUkVBQ0hFRCIsIlNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9VTlNVUFBPUlRFRF9UUkFOU0FDVElPTl9WRVJTSU9OIiwiU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0JMT0NLX1NUQVRVU19OT1RfQVZBSUxBQkxFX1lFVCIsIlNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9TSUdOQVRVUkVfTEVOX01JU01BVENIIiwiU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0NBTl9FUlJPUiIsIlNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9ISVNUT1JZX05PVF9BVkFJTEFCTEUiLCJTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfS0VZX0VYQ0xVREVEX0ZST01fU0VDT05EQVJZX0lOREVYIiwiU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0xPTkdfVEVSTV9TVE9SQUdFX1NMT1RfU0tJUFBFRCIsIlNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9OT19TTkFQU0hPVCIsIlNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9TTE9UX1NLSVBQRUQiLCJTT0xBTkFfRVJST1JfX0pTT05fUlBDX19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fUFJFQ09NUElMRV9WRVJJRklDQVRJT05fRkFJTFVSRSIsIlNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9OT0RFX1VOSEVBTFRIWSIsIlNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9CTE9DS19OT1RfQVZBSUxBQkxFIiwiU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX1NJR05BVFVSRV9WRVJJRklDQVRJT05fRkFJTFVSRSIsIlNPTEFOQV9FUlJPUl9fSlNPTl9SUENfX1NFUlZFUl9FUlJPUl9TRU5EX1RSQU5TQUNUSU9OX1BSRUZMSUdIVF9GQUlMVVJFIiwiU09MQU5BX0VSUk9SX19KU09OX1JQQ19fU0VSVkVSX0VSUk9SX0JMT0NLX0NMRUFORURfVVAiLCJTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fSU5WQUxJRF9CWVRFX0xFTkdUSCIsIlNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19TVFJJTkdfTEVOR1RIX09VVF9PRl9SQU5HRSIsIlNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19JTlZBTElEX0JBU0U1OF9FTkNPREVEX0FERFJFU1MiLCJTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fSU5WQUxJRF9FRDI1NTE5X1BVQkxJQ19LRVkiLCJTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fTUFMRk9STUVEX1BEQSIsIlNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19QREFfQlVNUF9TRUVEX09VVF9PRl9SQU5HRSIsIlNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19NQVhfTlVNQkVSX09GX1BEQV9TRUVEU19FWENFRURFRCIsIlNPTEFOQV9FUlJPUl9fQUREUkVTU0VTX19NQVhfUERBX1NFRURfTEVOR1RIX0VYQ0VFREVEIiwiU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX0lOVkFMSURfU0VFRFNfUE9JTlRfT05fQ1VSVkUiLCJTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fRkFJTEVEX1RPX0ZJTkRfVklBQkxFX1BEQV9CVU1QX1NFRUQiLCJTT0xBTkFfRVJST1JfX0FERFJFU1NFU19fUERBX0VORFNfV0lUSF9QREFfTUFSS0VSIiwiU09MQU5BX0VSUk9SX19BRERSRVNTRVNfX0lOVkFMSURfT0ZGX0NVUlZFX0FERFJFU1MiLCJTT0xBTkFfRVJST1JfX0FDQ09VTlRTX19BQ0NPVU5UX05PVF9GT1VORCIsIlNPTEFOQV9FUlJPUl9fQUNDT1VOVFNfX09ORV9PUl9NT1JFX0FDQ09VTlRTX05PVF9GT1VORCIsIlNPTEFOQV9FUlJPUl9fQUNDT1VOVFNfX0ZBSUxFRF9UT19ERUNPREVfQUNDT1VOVCIsIlNPTEFOQV9FUlJPUl9fQUNDT1VOVFNfX0VYUEVDVEVEX0RFQ09ERURfQUNDT1VOVCIsIlNPTEFOQV9FUlJPUl9fQUNDT1VOVFNfX0VYUEVDVEVEX0FMTF9BQ0NPVU5UU19UT19CRV9ERUNPREVEIiwiU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19ESVNBTExPV0VEX0lOX0lOU0VDVVJFX0NPTlRFWFQiLCJTT0xBTkFfRVJST1JfX1NVQlRMRV9DUllQVE9fX0RJR0VTVF9VTklNUExFTUVOVEVEIiwiU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19FRDI1NTE5X0FMR09SSVRITV9VTklNUExFTUVOVEVEIiwiU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19FWFBPUlRfRlVOQ1RJT05fVU5JTVBMRU1FTlRFRCIsIlNPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fR0VORVJBVEVfRlVOQ1RJT05fVU5JTVBMRU1FTlRFRCIsIlNPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fU0lHTl9GVU5DVElPTl9VTklNUExFTUVOVEVEIiwiU09MQU5BX0VSUk9SX19TVUJUTEVfQ1JZUFRPX19WRVJJRllfRlVOQ1RJT05fVU5JTVBMRU1FTlRFRCIsIlNPTEFOQV9FUlJPUl9fU1VCVExFX0NSWVBUT19fQ0FOTk9UX0VYUE9SVF9OT05fRVhUUkFDVEFCTEVfS0VZIiwiU09MQU5BX0VSUk9SX19DUllQVE9fX1JBTkRPTV9WQUxVRVNfRlVOQ1RJT05fVU5JTVBMRU1FTlRFRCIsIlNPTEFOQV9FUlJPUl9fS0VZU19fSU5WQUxJRF9LRVlfUEFJUl9CWVRFX0xFTkdUSCIsIlNPTEFOQV9FUlJPUl9fS0VZU19fSU5WQUxJRF9QUklWQVRFX0tFWV9CWVRFX0xFTkdUSCIsIlNPTEFOQV9FUlJPUl9fS0VZU19fSU5WQUxJRF9TSUdOQVRVUkVfQllURV9MRU5HVEgiLCJTT0xBTkFfRVJST1JfX0tFWVNfX1NJR05BVFVSRV9TVFJJTkdfTEVOR1RIX09VVF9PRl9SQU5HRSIsIlNPTEFOQV9FUlJPUl9fS0VZU19fUFVCTElDX0tFWV9NVVNUX01BVENIX1BSSVZBVEVfS0VZIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9fRVhQRUNURURfVE9fSEFWRV9BQ0NPVU5UUyIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fX0VYUEVDVEVEX1RPX0hBVkVfREFUQSIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fX1BST0dSQU1fSURfTUlTTUFUQ0giLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19VTktOT1dOIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fR0VORVJJQ19FUlJPUiIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOVkFMSURfQVJHVU1FTlQiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX0lOU1RSVUNUSU9OX0RBVEEiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX0FDQ09VTlRfREFUQSIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfREFUQV9UT09fU01BTEwiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlNVRkZJQ0lFTlRfRlVORFMiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTkNPUlJFQ1RfUFJPR1JBTV9JRCIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01JU1NJTkdfUkVRVUlSRURfU0lHTkFUVVJFIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9BTFJFQURZX0lOSVRJQUxJWkVEIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fVU5JTklUSUFMSVpFRF9BQ0NPVU5UIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fVU5CQUxBTkNFRF9JTlNUUlVDVElPTiIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01PRElGSUVEX1BST0dSQU1fSUQiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19FWFRFUk5BTF9BQ0NPVU5UX0xBTVBPUlRfU1BFTkQiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19FWFRFUk5BTF9BQ0NPVU5UX0RBVEFfTU9ESUZJRUQiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19SRUFET05MWV9MQU1QT1JUX0NIQU5HRSIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1JFQURPTkxZX0RBVEFfTU9ESUZJRUQiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19EVVBMSUNBVEVfQUNDT1VOVF9JTkRFWCIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0VYRUNVVEFCTEVfTU9ESUZJRUQiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19SRU5UX0VQT0NIX01PRElGSUVEIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fTk9UX0VOT1VHSF9BQ0NPVU5UX0tFWVMiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19BQ0NPVU5UX0RBVEFfU0laRV9DSEFOR0VEIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQUNDT1VOVF9OT1RfRVhFQ1VUQUJMRSIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfQk9SUk9XX0ZBSUxFRCIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfQk9SUk9XX09VVFNUQU5ESU5HIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRFVQTElDQVRFX0FDQ09VTlRfT1VUX09GX1NZTkMiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19DVVNUT00iLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX0VSUk9SIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRVhFQ1VUQUJMRV9EQVRBX01PRElGSUVEIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fRVhFQ1VUQUJMRV9MQU1QT1JUX0NIQU5HRSIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0VYRUNVVEFCTEVfQUNDT1VOVF9OT1RfUkVOVF9FWEVNUFQiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19VTlNVUFBPUlRFRF9QUk9HUkFNX0lEIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQ0FMTF9ERVBUSCIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01JU1NJTkdfQUNDT1VOVCIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1JFRU5UUkFOQ1lfTk9UX0FMTE9XRUQiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19NQVhfU0VFRF9MRU5HVEhfRVhDRUVERUQiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19JTlZBTElEX1NFRURTIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9SRUFMTE9DIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQ09NUFVUQVRJT05BTF9CVURHRVRfRVhDRUVERUQiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19QUklWSUxFR0VfRVNDQUxBVElPTiIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1BST0dSQU1fRU5WSVJPTk1FTlRfU0VUVVBfRkFJTFVSRSIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1BST0dSQU1fRkFJTEVEX1RPX0NPTVBMRVRFIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fUFJPR1JBTV9GQUlMRURfVE9fQ09NUElMRSIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lNTVVUQUJMRSIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lOQ09SUkVDVF9BVVRIT1JJVFkiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19CT1JTSF9JT19FUlJPUiIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0FDQ09VTlRfTk9UX1JFTlRfRVhFTVBUIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fSU5WQUxJRF9BQ0NPVU5UX09XTkVSIiwiU09MQU5BX0VSUk9SX19JTlNUUlVDVElPTl9FUlJPUl9fQVJJVEhNRVRJQ19PVkVSRkxPVyIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX1VOU1VQUE9SVEVEX1NZU1ZBUiIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX0lMTEVHQUxfT1dORVIiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19NQVhfQUNDT1VOVFNfREFUQV9BTExPQ0FUSU9OU19FWENFRURFRCIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01BWF9BQ0NPVU5UU19FWENFRURFRCIsIlNPTEFOQV9FUlJPUl9fSU5TVFJVQ1RJT05fRVJST1JfX01BWF9JTlNUUlVDVElPTl9UUkFDRV9MRU5HVEhfRVhDRUVERUQiLCJTT0xBTkFfRVJST1JfX0lOU1RSVUNUSU9OX0VSUk9SX19CVUlMVElOX1BST0dSQU1TX01VU1RfQ09OU1VNRV9DT01QVVRFX1VOSVRTIiwiU09MQU5BX0VSUk9SX19TSUdORVJfX0FERFJFU1NfQ0FOTk9UX0hBVkVfTVVMVElQTEVfU0lHTkVSUyIsIlNPTEFOQV9FUlJPUl9fU0lHTkVSX19FWFBFQ1RFRF9LRVlfUEFJUl9TSUdORVIiLCJTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfTUVTU0FHRV9TSUdORVIiLCJTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfTUVTU0FHRV9NT0RJRllJTkdfU0lHTkVSIiwiU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX01FU1NBR0VfUEFSVElBTF9TSUdORVIiLCJTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfVFJBTlNBQ1RJT05fU0lHTkVSIiwiU09MQU5BX0VSUk9SX19TSUdORVJfX0VYUEVDVEVEX1RSQU5TQUNUSU9OX01PRElGWUlOR19TSUdORVIiLCJTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfVFJBTlNBQ1RJT05fUEFSVElBTF9TSUdORVIiLCJTT0xBTkFfRVJST1JfX1NJR05FUl9fRVhQRUNURURfVFJBTlNBQ1RJT05fU0VORElOR19TSUdORVIiLCJTT0xBTkFfRVJST1JfX1NJR05FUl9fVFJBTlNBQ1RJT05fQ0FOTk9UX0hBVkVfTVVMVElQTEVfU0VORElOR19TSUdORVJTIiwiU09MQU5BX0VSUk9SX19TSUdORVJfX1RSQU5TQUNUSU9OX1NFTkRJTkdfU0lHTkVSX01JU1NJTkciLCJTT0xBTkFfRVJST1JfX1NJR05FUl9fV0FMTEVUX01VTFRJU0lHTl9VTklNUExFTUVOVEVEIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fSU5WT0tFRF9QUk9HUkFNU19DQU5OT1RfUEFZX0ZFRVMiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19JTlZPS0VEX1BST0dSQU1TX01VU1RfTk9UX0JFX1dSSVRBQkxFIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRVhQRUNURURfQkxPQ0tIQVNIX0xJRkVUSU1FIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRVhQRUNURURfTk9OQ0VfTElGRVRJTUUiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19WRVJTSU9OX05VTUJFUl9PVVRfT0ZfUkFOR0UiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GQUlMRURfVE9fREVDT01QSUxFX0FERFJFU1NfTE9PS1VQX1RBQkxFX0NPTlRFTlRTX01JU1NJTkciLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GQUlMRURfVE9fREVDT01QSUxFX0FERFJFU1NfTE9PS1VQX1RBQkxFX0lOREVYX09VVF9PRl9SQU5HRSIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9UT19ERUNPTVBJTEVfSU5TVFJVQ1RJT05fUFJPR1JBTV9BRERSRVNTX05PVF9GT1VORCIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZBSUxFRF9UT19ERUNPTVBJTEVfRkVFX1BBWUVSX01JU1NJTkciLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19TSUdOQVRVUkVTX01JU1NJTkciLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19BRERSRVNTX01JU1NJTkciLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GRUVfUEFZRVJfTUlTU0lORyIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0ZFRV9QQVlFUl9TSUdOQVRVUkVfTUlTU0lORyIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0lOVkFMSURfTk9OQ0VfVFJBTlNBQ1RJT05fSU5TVFJVQ1RJT05TX01JU1NJTkciLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19JTlZBTElEX05PTkNFX1RSQU5TQUNUSU9OX0ZJUlNUX0lOU1RSVUNUSU9OX01VU1RfQkVfQURWQU5DRV9OT05DRSIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0FERFJFU1NFU19DQU5OT1RfU0lHTl9UUkFOU0FDVElPTiIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fX0NBTk5PVF9FTkNPREVfV0lUSF9FTVBUWV9TSUdOQVRVUkVTIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fTUVTU0FHRV9TSUdOQVRVUkVTX01JU01BVENIIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9fRkFJTEVEX1RPX0VTVElNQVRFX0NPTVBVVEVfTElNSVQiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19GQUlMRURfV0hFTl9TSU1VTEFUSU5HX1RPX0VTVElNQVRFX0NPTVBVVEVfTElNSVQiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX19FWENFRURTX1NJWkVfTElNSVQiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19VTktOT1dOIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQUNDT1VOVF9JTl9VU0UiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19BQ0NPVU5UX0xPQURFRF9UV0lDRSIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0FDQ09VTlRfTk9UX0ZPVU5EIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fUFJPR1JBTV9BQ0NPVU5UX05PVF9GT1VORCIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOU1VGRklDSUVOVF9GVU5EU19GT1JfRkVFIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9BQ0NPVU5UX0ZPUl9GRUUiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19BTFJFQURZX1BST0NFU1NFRCIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0JMT0NLSEFTSF9OT1RfRk9VTkQiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19DQUxMX0NIQUlOX1RPT19ERUVQIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fTUlTU0lOR19TSUdOQVRVUkVfRk9SX0ZFRSIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfQUNDT1VOVF9JTkRFWCIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1NJR05BVFVSRV9GQUlMVVJFIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9QUk9HUkFNX0ZPUl9FWEVDVVRJT04iLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19TQU5JVElaRV9GQUlMVVJFIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fQ0xVU1RFUl9NQUlOVEVOQU5DRSIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0FDQ09VTlRfQk9SUk9XX09VVFNUQU5ESU5HIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fV09VTERfRVhDRUVEX01BWF9CTE9DS19DT1NUX0xJTUlUIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fVU5TVVBQT1JURURfVkVSU0lPTiIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfV1JJVEFCTEVfQUNDT1VOVCIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1dPVUxEX0VYQ0VFRF9NQVhfQUNDT1VOVF9DT1NUX0xJTUlUIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fV09VTERfRVhDRUVEX0FDQ09VTlRfREFUQV9CTE9DS19MSU1JVCIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1RPT19NQU5ZX0FDQ09VTlRfTE9DS1MiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19BRERSRVNTX0xPT0tVUF9UQUJMRV9OT1RfRk9VTkQiLCJTT0xBTkFfRVJST1JfX1RSQU5TQUNUSU9OX0VSUk9SX19JTlZBTElEX0FERFJFU1NfTE9PS1VQX1RBQkxFX09XTkVSIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9BRERSRVNTX0xPT0tVUF9UQUJMRV9EQVRBIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9BRERSRVNTX0xPT0tVUF9UQUJMRV9JTkRFWCIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOVkFMSURfUkVOVF9QQVlJTkdfQUNDT1VOVCIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1dPVUxEX0VYQ0VFRF9NQVhfVk9URV9DT1NUX0xJTUlUIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fV09VTERfRVhDRUVEX0FDQ09VTlRfREFUQV9UT1RBTF9MSU1JVCIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0RVUExJQ0FURV9JTlNUUlVDVElPTiIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX0lOU1VGRklDSUVOVF9GVU5EU19GT1JfUkVOVCIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX01BWF9MT0FERURfQUNDT1VOVFNfREFUQV9TSVpFX0VYQ0VFREVEIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fSU5WQUxJRF9MT0FERURfQUNDT1VOVFNfREFUQV9TSVpFX0xJTUlUIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fUkVTQU5JVElaQVRJT05fTkVFREVEIiwiU09MQU5BX0VSUk9SX19UUkFOU0FDVElPTl9FUlJPUl9fUFJPR1JBTV9FWEVDVVRJT05fVEVNUE9SQVJJTFlfUkVTVFJJQ1RFRCIsIlNPTEFOQV9FUlJPUl9fVFJBTlNBQ1RJT05fRVJST1JfX1VOQkFMQU5DRURfVFJBTlNBQ1RJT04iLCJTT0xBTkFfRVJST1JfX0NPREVDU19fQ0FOTk9UX0RFQ09ERV9FTVBUWV9CWVRFX0FSUkFZIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfQllURV9MRU5HVEgiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfRklYRURfTEVOR1RIIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX1ZBUklBQkxFX0xFTkdUSCIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfU0laRV9DT01QQVRJQklMSVRZX01JU01BVENIIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9GSVhFRF9TSVpFX01JU01BVENIIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9NQVhfU0laRV9NSVNNQVRDSCIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX05VTUJFUl9PRl9JVEVNUyIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTlVNX0RJU0NSSU1JTkFUT1JfT1VUX09GX1JBTkdFIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfRElTQ1JJTUlOQVRFRF9VTklPTl9WQVJJQU5UIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfRU5VTV9WQVJJQU5UIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX05VTUJFUl9PVVRfT0ZfUkFOR0UiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9TVFJJTkdfRk9SX0JBU0UiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfUE9TSVRJVkVfQllURV9MRU5HVEgiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fT0ZGU0VUX09VVF9PRl9SQU5HRSIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0xJVEVSQUxfVU5JT05fVkFSSUFOVCIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19MSVRFUkFMX1VOSU9OX0RJU0NSSU1JTkFUT1JfT1VUX09GX1JBTkdFIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX1VOSU9OX1ZBUklBTlRfT1VUX09GX1JBTkdFIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfQ09OU1RBTlQiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfWkVST19WQUxVRV9UT19NQVRDSF9JVEVNX0ZJWEVEX1NJWkUiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFRF9CWVRFU19NVVNUX05PVF9JTkNMVURFX1NFTlRJTkVMIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX1NFTlRJTkVMX01JU1NJTkdfSU5fREVDT0RFRF9CWVRFUyIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19DQU5OT1RfVVNFX0xFWElDQUxfVkFMVUVTX0FTX0VOVU1fRElTQ1JJTUlOQVRPUlMiLCJTT0xBTkFfRVJST1JfX1JQQ19fSU5URUdFUl9PVkVSRkxPVyIsIlNPTEFOQV9FUlJPUl9fUlBDX19UUkFOU1BPUlRfSFRUUF9IRUFERVJfRk9SQklEREVOIiwiU09MQU5BX0VSUk9SX19SUENfX1RSQU5TUE9SVF9IVFRQX0VSUk9SIiwiU09MQU5BX0VSUk9SX19SUENfX0FQSV9QTEFOX01JU1NJTkdfRk9SX1JQQ19NRVRIT0QiLCJTT0xBTkFfRVJST1JfX1JQQ19TVUJTQ1JJUFRJT05TX19DQU5OT1RfQ1JFQVRFX1NVQlNDUklQVElPTl9QTEFOIiwiU09MQU5BX0VSUk9SX19SUENfU1VCU0NSSVBUSU9OU19fRVhQRUNURURfU0VSVkVSX1NVQlNDUklQVElPTl9JRCIsIlNPTEFOQV9FUlJPUl9fUlBDX1NVQlNDUklQVElPTlNfX0NIQU5ORUxfQ0xPU0VEX0JFRk9SRV9NRVNTQUdFX0JVRkZFUkVEIiwiU09MQU5BX0VSUk9SX19SUENfU1VCU0NSSVBUSU9OU19fQ0hBTk5FTF9DT05ORUNUSU9OX0NMT1NFRCIsIlNPTEFOQV9FUlJPUl9fUlBDX1NVQlNDUklQVElPTlNfX0NIQU5ORUxfRkFJTEVEX1RPX0NPTk5FQ1QiLCJTT0xBTkFfRVJST1JfX0lOVkFSSUFOVF9WSU9MQVRJT05fX1NVQlNDUklQVElPTl9JVEVSQVRPUl9TVEFURV9NSVNTSU5HIiwiU09MQU5BX0VSUk9SX19JTlZBUklBTlRfVklPTEFUSU9OX19TVUJTQ1JJUFRJT05fSVRFUkFUT1JfTVVTVF9OT1RfUE9MTF9CRUZPUkVfUkVTT0xWSU5HX0VYSVNUSU5HX01FU1NBR0VfUFJPTUlTRSIsIlNPTEFOQV9FUlJPUl9fSU5WQVJJQU5UX1ZJT0xBVElPTl9fQ0FDSEVEX0FCT1JUQUJMRV9JVEVSQUJMRV9DQUNIRV9FTlRSWV9NSVNTSU5HIiwiU09MQU5BX0VSUk9SX19JTlZBUklBTlRfVklPTEFUSU9OX19TV0lUQ0hfTVVTVF9CRV9FWEhBVVNUSVZFIiwiU09MQU5BX0VSUk9SX19JTlZBUklBTlRfVklPTEFUSU9OX19EQVRBX1BVQkxJU0hFUl9DSEFOTkVMX1VOSU1QTEVNRU5URUQiLCJlbmNvZGVWYWx1ZSIsInZhbHVlIiwiQXJyYXkiLCJpc0FycmF5IiwiY29tbWFTZXBhcmF0ZWRWYWx1ZXMiLCJtYXAiLCJqb2luIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiU3RyaW5nIiwiT2JqZWN0IiwiZ2V0UHJvdG90eXBlT2YiLCJlbmNvZGVPYmplY3RDb250ZXh0RW50cnkiLCJrZXkiLCJlbmNvZGVDb250ZXh0T2JqZWN0IiwiY29udGV4dCIsInNlYXJjaFBhcmFtc1N0cmluZyIsImVudHJpZXMiLCJCdWZmZXIiLCJmcm9tIiwidG9TdHJpbmciLCJTb2xhbmFFcnJvck1lc3NhZ2VzIiwiU1RBUlRfSU5ERVgiLCJUWVBFIiwiZ2V0SHVtYW5SZWFkYWJsZUVycm9yTWVzc2FnZSIsImNvZGUiLCJtZXNzYWdlRm9ybWF0U3RyaW5nIiwibGVuZ3RoIiwic3RhdGUiLCJjb21taXRTdGF0ZVVwVG8iLCJlbmRJbmRleCIsInZhcmlhYmxlTmFtZSIsInNsaWNlIiwiZnJhZ21lbnRzIiwicHVzaCIsInNwbGl0IiwiZm9yRWFjaCIsImNoYXIiLCJpaSIsIm5leHRTdGF0ZSIsIm1hdGNoIiwiZ2V0RXJyb3JNZXNzYWdlIiwicHJvY2VzcyIsImRlY29kaW5nQWR2aWNlTWVzc2FnZSIsImtleXMiLCJpc1NvbGFuYUVycm9yIiwiZSIsImlzU29sYW5hRXJyb3IyIiwiRXJyb3IiLCJuYW1lIiwiX19jb2RlIiwiU29sYW5hRXJyb3IiLCJjb25zdHJ1Y3RvciIsImNvbnRleHRBbmRFcnJvck9wdGlvbnMiLCJlcnJvck9wdGlvbnMiLCJjYXVzZSIsImNvbnRleHRSZXN0IiwibWVzc2FnZSIsInNhZmVDYXB0dXJlU3RhY2tUcmFjZSIsImFyZ3MiLCJjYXB0dXJlU3RhY2tUcmFjZSIsImdldFNvbGFuYUVycm9yRnJvbVJwY0Vycm9yIiwiZXJyb3JDb2RlQmFzZU9mZnNldCIsImdldEVycm9yQ29udGV4dCIsIm9yZGVyZWRFcnJvck5hbWVzIiwicnBjRW51bUVycm9yIiwiY29uc3RydWN0b3JPcHQiLCJycGNFcnJvck5hbWUiLCJycGNFcnJvckNvbnRleHQiLCJjb2RlT2Zmc2V0IiwiaW5kZXhPZiIsImVycm9yQ29kZSIsImVycm9yQ29udGV4dCIsImVyciIsIk9SREVSRURfRVJST1JfTkFNRVMiLCJnZXRTb2xhbmFFcnJvckZyb21JbnN0cnVjdGlvbkVycm9yIiwiaW5kZXgiLCJpbnN0cnVjdGlvbkVycm9yIiwibnVtYmVySW5kZXgiLCJOdW1iZXIiLCJlcnJvck5hbWUiLCJpbnN0cnVjdGlvbkVycm9yQ29udGV4dCIsImVuY29kZWREYXRhIiwiT1JERVJFRF9FUlJPUl9OQU1FUzIiLCJnZXRTb2xhbmFFcnJvckZyb21UcmFuc2FjdGlvbkVycm9yIiwidHJhbnNhY3Rpb25FcnJvciIsIkluc3RydWN0aW9uRXJyb3IiLCJ0cmFuc2FjdGlvbkVycm9yQ29udGV4dCIsImFjY291bnRJbmRleCIsImFjY291bnRfaW5kZXgiLCJnZXRTb2xhbmFFcnJvckZyb21Kc29uUnBjRXJyb3IiLCJwdXRhdGl2ZUVycm9yUmVzcG9uc2UiLCJvdXQiLCJpc1JwY0Vycm9yUmVzcG9uc2UiLCJyYXdDb2RlIiwiZGF0YSIsInByZWZsaWdodEVycm9yQ29udGV4dCIsImNhdXNlT2JqZWN0IiwiX19zZXJ2ZXJNZXNzYWdlIiwiZXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@solana/web3.js/node_modules/@solana/errors/dist/index.node.mjs\n");

/***/ })

};
;