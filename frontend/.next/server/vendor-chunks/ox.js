"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ox";
exports.ids = ["vendor-chunks/ox"];
exports.modules = {

/***/ "(ssr)/./node_modules/ox/node_modules/@noble/curves/_shortw_utils.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ox/node_modules/@noble/curves/_shortw_utils.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getHash = getHash;\nexports.createCurve = createCurve;\n/**\n * Utilities for short weierstrass curves, combined with noble-hashes.\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const hmac_1 = __webpack_require__(/*! @noble/hashes/hmac */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/hmac.js\");\nconst utils_1 = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/utils.js\");\nconst weierstrass_ts_1 = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/abstract/weierstrass.js\");\n/** connects noble-curves to noble-hashes */ function getHash(hash) {\n    return {\n        hash,\n        hmac: (key, ...msgs)=>(0, hmac_1.hmac)(hash, key, (0, utils_1.concatBytes)(...msgs)),\n        randomBytes: utils_1.randomBytes\n    };\n}\nfunction createCurve(curveDef, defHash) {\n    const create = (hash)=>(0, weierstrass_ts_1.weierstrass)({\n            ...curveDef,\n            ...getHash(hash)\n        });\n    return {\n        ...create(defHash),\n        create\n    };\n} //# sourceMappingURL=_shortw_utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvX3Nob3J0d191dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsZUFBZSxHQUFHRTtBQUNsQkYsbUJBQW1CLEdBQUdHO0FBQ3RCOzs7Q0FHQyxHQUNELG9FQUFvRSxHQUNwRSxNQUFNQyxTQUFTQyxtQkFBT0EsQ0FBQyxzRkFBb0I7QUFDM0MsTUFBTUMsVUFBVUQsbUJBQU9BLENBQUMsd0ZBQXFCO0FBQzdDLE1BQU1FLG1CQUFtQkYsbUJBQU9BLENBQUMsNkdBQTJCO0FBQzVELDBDQUEwQyxHQUMxQyxTQUFTSCxRQUFRTSxJQUFJO0lBQ2pCLE9BQU87UUFDSEE7UUFDQUMsTUFBTSxDQUFDQyxLQUFLLEdBQUdDLE9BQVMsQ0FBQyxHQUFHUCxPQUFPSyxJQUFJLEVBQUVELE1BQU1FLEtBQUssQ0FBQyxHQUFHSixRQUFRTSxXQUFXLEtBQUtEO1FBQ2hGRSxhQUFhUCxRQUFRTyxXQUFXO0lBQ3BDO0FBQ0o7QUFDQSxTQUFTVixZQUFZVyxRQUFRLEVBQUVDLE9BQU87SUFDbEMsTUFBTUMsU0FBUyxDQUFDUixPQUFTLENBQUMsR0FBR0QsaUJBQWlCVSxXQUFXLEVBQUU7WUFBRSxHQUFHSCxRQUFRO1lBQUUsR0FBR1osUUFBUU0sS0FBSztRQUFDO0lBQzNGLE9BQU87UUFBRSxHQUFHUSxPQUFPRCxRQUFRO1FBQUVDO0lBQU87QUFDeEMsRUFDQSx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGF3LXdvcmtzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL19zaG9ydHdfdXRpbHMuanM/YzgzMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0SGFzaCA9IGdldEhhc2g7XG5leHBvcnRzLmNyZWF0ZUN1cnZlID0gY3JlYXRlQ3VydmU7XG4vKipcbiAqIFV0aWxpdGllcyBmb3Igc2hvcnQgd2VpZXJzdHJhc3MgY3VydmVzLCBjb21iaW5lZCB3aXRoIG5vYmxlLWhhc2hlcy5cbiAqIEBtb2R1bGVcbiAqL1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuY29uc3QgaG1hY18xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvaG1hY1wiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy91dGlsc1wiKTtcbmNvbnN0IHdlaWVyc3RyYXNzX3RzXzEgPSByZXF1aXJlKFwiLi9hYnN0cmFjdC93ZWllcnN0cmFzcy5qc1wiKTtcbi8qKiBjb25uZWN0cyBub2JsZS1jdXJ2ZXMgdG8gbm9ibGUtaGFzaGVzICovXG5mdW5jdGlvbiBnZXRIYXNoKGhhc2gpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBoYXNoLFxuICAgICAgICBobWFjOiAoa2V5LCAuLi5tc2dzKSA9PiAoMCwgaG1hY18xLmhtYWMpKGhhc2gsIGtleSwgKDAsIHV0aWxzXzEuY29uY2F0Qnl0ZXMpKC4uLm1zZ3MpKSxcbiAgICAgICAgcmFuZG9tQnl0ZXM6IHV0aWxzXzEucmFuZG9tQnl0ZXMsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUN1cnZlKGN1cnZlRGVmLCBkZWZIYXNoKSB7XG4gICAgY29uc3QgY3JlYXRlID0gKGhhc2gpID0+ICgwLCB3ZWllcnN0cmFzc190c18xLndlaWVyc3RyYXNzKSh7IC4uLmN1cnZlRGVmLCAuLi5nZXRIYXNoKGhhc2gpIH0pO1xuICAgIHJldHVybiB7IC4uLmNyZWF0ZShkZWZIYXNoKSwgY3JlYXRlIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fc2hvcnR3X3V0aWxzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImdldEhhc2giLCJjcmVhdGVDdXJ2ZSIsImhtYWNfMSIsInJlcXVpcmUiLCJ1dGlsc18xIiwid2VpZXJzdHJhc3NfdHNfMSIsImhhc2giLCJobWFjIiwia2V5IiwibXNncyIsImNvbmNhdEJ5dGVzIiwicmFuZG9tQnl0ZXMiLCJjdXJ2ZURlZiIsImRlZkhhc2giLCJjcmVhdGUiLCJ3ZWllcnN0cmFzcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/@noble/curves/_shortw_utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/@noble/curves/abstract/curve.js":
/*!**********************************************************************!*\
  !*** ./node_modules/ox/node_modules/@noble/curves/abstract/curve.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.wNAF = wNAF;\nexports.pippenger = pippenger;\nexports.precomputeMSMUnsafe = precomputeMSMUnsafe;\nexports.validateBasic = validateBasic;\n/**\n * Methods for elliptic curve multiplication by scalars.\n * Contains wNAF, pippenger\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const modular_ts_1 = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/abstract/modular.js\");\nconst utils_ts_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/abstract/utils.js\");\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nfunction constTimeNegate(condition, item) {\n    const neg = item.negate();\n    return condition ? neg : item;\n}\nfunction validateW(W, bits) {\n    if (!Number.isSafeInteger(W) || W <= 0 || W > bits) throw new Error(\"invalid window size, expected [1..\" + bits + \"], got W=\" + W);\n}\nfunction calcWOpts(W, scalarBits) {\n    validateW(W, scalarBits);\n    const windows = Math.ceil(scalarBits / W) + 1; // W=8 33. Not 32, because we skip zero\n    const windowSize = 2 ** (W - 1); // W=8 128. Not 256, because we skip zero\n    const maxNumber = 2 ** W; // W=8 256\n    const mask = (0, utils_ts_1.bitMask)(W); // W=8 255 == mask 0b11111111\n    const shiftBy = BigInt(W); // W=8 8\n    return {\n        windows,\n        windowSize,\n        mask,\n        maxNumber,\n        shiftBy\n    };\n}\nfunction calcOffsets(n, window, wOpts) {\n    const { windowSize, mask, maxNumber, shiftBy } = wOpts;\n    let wbits = Number(n & mask); // extract W bits.\n    let nextN = n >> shiftBy; // shift number by W bits.\n    // What actually happens here:\n    // const highestBit = Number(mask ^ (mask >> 1n));\n    // let wbits2 = wbits - 1; // skip zero\n    // if (wbits2 & highestBit) { wbits2 ^= Number(mask); // (~);\n    // split if bits > max: +224 => 256-32\n    if (wbits > windowSize) {\n        // we skip zero, which means instead of `>= size-1`, we do `> size`\n        wbits -= maxNumber; // -32, can be maxNumber - wbits, but then we need to set isNeg here.\n        nextN += _1n; // +256 (carry)\n    }\n    const offsetStart = window * windowSize;\n    const offset = offsetStart + Math.abs(wbits) - 1; // -1 because we skip zero\n    const isZero = wbits === 0; // is current window slice a 0?\n    const isNeg = wbits < 0; // is current window slice negative?\n    const isNegF = window % 2 !== 0; // fake random statement for noise\n    const offsetF = offsetStart; // fake offset for noise\n    return {\n        nextN,\n        offset,\n        isZero,\n        isNeg,\n        isNegF,\n        offsetF\n    };\n}\nfunction validateMSMPoints(points, c) {\n    if (!Array.isArray(points)) throw new Error(\"array expected\");\n    points.forEach((p, i)=>{\n        if (!(p instanceof c)) throw new Error(\"invalid point at index \" + i);\n    });\n}\nfunction validateMSMScalars(scalars, field) {\n    if (!Array.isArray(scalars)) throw new Error(\"array of scalars expected\");\n    scalars.forEach((s, i)=>{\n        if (!field.isValid(s)) throw new Error(\"invalid scalar at index \" + i);\n    });\n}\n// Since points in different groups cannot be equal (different object constructor),\n// we can have single place to store precomputes.\n// Allows to make points frozen / immutable.\nconst pointPrecomputes = new WeakMap();\nconst pointWindowSizes = new WeakMap();\nfunction getW(P) {\n    return pointWindowSizes.get(P) || 1;\n}\n/**\n * Elliptic curve multiplication of Point by scalar. Fragile.\n * Scalars should always be less than curve order: this should be checked inside of a curve itself.\n * Creates precomputation tables for fast multiplication:\n * - private scalar is split by fixed size windows of W bits\n * - every window point is collected from window's table & added to accumulator\n * - since windows are different, same point inside tables won't be accessed more than once per calc\n * - each multiplication is 'Math.ceil(CURVE_ORDER / ùëä) + 1' point additions (fixed for any scalar)\n * - +1 window is neccessary for wNAF\n * - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n *\n * @todo Research returning 2d JS array of windows, instead of a single window.\n * This would allow windows to be in different memory locations\n */ function wNAF(c, bits) {\n    return {\n        constTimeNegate,\n        hasPrecomputes (elm) {\n            return getW(elm) !== 1;\n        },\n        // non-const time multiplication ladder\n        unsafeLadder (elm, n, p = c.ZERO) {\n            let d = elm;\n            while(n > _0n){\n                if (n & _1n) p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(ùëä‚àí1) * (Math.ceil(ùëõ / ùëä) + 1), where:\n         * - ùëä is the window size\n         * - ùëõ is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @param elm Point instance\n         * @param W window size\n         * @returns precomputed point tables flattened to a single array\n         */ precomputeWindow (elm, W) {\n            const { windows, windowSize } = calcWOpts(W, bits);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for(let window = 0; window < windows; window++){\n                base = p;\n                points.push(base);\n                // i=1, bc we skip 0\n                for(let i = 1; i < windowSize; i++){\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */ wNAF (W, precomputes, n) {\n            // Smaller version:\n            // https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541\n            // TODO: check the scalar is less than group order?\n            // wNAF behavior is undefined otherwise. But have to carefully remove\n            // other checks before wNAF. ORDER == bits here.\n            // Accumulators\n            let p = c.ZERO;\n            let f = c.BASE;\n            // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n            // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n            // there is negate now: it is possible that negated element from low value\n            // would be the same as high element, which will create carry into next window.\n            // It's not obvious how this can fail, but still worth investigating later.\n            const wo = calcWOpts(W, bits);\n            for(let window = 0; window < wo.windows; window++){\n                // (n === _0n) is handled and not early-exited. isEven and offsetF are used for noise\n                const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window, wo);\n                n = nextN;\n                if (isZero) {\n                    // bits are 0: add garbage to fake point\n                    // Important part for const-time getPublicKey: add random \"noise\" point to f.\n                    f = f.add(constTimeNegate(isNegF, precomputes[offsetF]));\n                } else {\n                    // bits are 1: add to result point\n                    p = p.add(constTimeNegate(isNeg, precomputes[offset]));\n                }\n            }\n            // Return both real and fake points: JIT won't eliminate f.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return {\n                p,\n                f\n            };\n        },\n        /**\n         * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @param acc accumulator point to add result of multiplication\n         * @returns point\n         */ wNAFUnsafe (W, precomputes, n, acc = c.ZERO) {\n            const wo = calcWOpts(W, bits);\n            for(let window = 0; window < wo.windows; window++){\n                if (n === _0n) break; // Early-exit, skip 0 value\n                const { nextN, offset, isZero, isNeg } = calcOffsets(n, window, wo);\n                n = nextN;\n                if (isZero) {\n                    continue;\n                } else {\n                    const item = precomputes[offset];\n                    acc = acc.add(isNeg ? item.negate() : item); // Re-using acc allows to save adds in MSM\n                }\n            }\n            return acc;\n        },\n        getPrecomputes (W, P, transform) {\n            // Calculate precomputes on a first run, reuse them after\n            let comp = pointPrecomputes.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1) pointPrecomputes.set(P, transform(comp));\n            }\n            return comp;\n        },\n        wNAFCached (P, n, transform) {\n            const W = getW(P);\n            return this.wNAF(W, this.getPrecomputes(W, P, transform), n);\n        },\n        wNAFCachedUnsafe (P, n, transform, prev) {\n            const W = getW(P);\n            if (W === 1) return this.unsafeLadder(P, n, prev); // For W=1 ladder is ~x2 faster\n            return this.wNAFUnsafe(W, this.getPrecomputes(W, P, transform), n, prev);\n        },\n        // We calculate precomputes for elliptic curve point multiplication\n        // using windowed method. This specifies window size and\n        // stores precomputed values. Usually only base point would be precomputed.\n        setWindowSize (P, W) {\n            validateW(W, bits);\n            pointWindowSizes.set(P, W);\n            pointPrecomputes.delete(P);\n        }\n    };\n}\n/**\n * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * 30x faster vs naive addition on L=4096, 10x faster than precomputes.\n * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.\n * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @param scalars array of L scalars (aka private keys / bigints)\n */ function pippenger(c, fieldN, points, scalars) {\n    // If we split scalars by some window (let's say 8 bits), every chunk will only\n    // take 256 buckets even if there are 4096 scalars, also re-uses double.\n    // TODO:\n    // - https://eprint.iacr.org/2024/750.pdf\n    // - https://tches.iacr.org/index.php/TCHES/article/view/10287\n    // 0 is accepted in scalars\n    validateMSMPoints(points, c);\n    validateMSMScalars(scalars, fieldN);\n    const plength = points.length;\n    const slength = scalars.length;\n    if (plength !== slength) throw new Error(\"arrays of points and scalars must have equal length\");\n    // if (plength === 0) throw new Error('array must be of length >= 2');\n    const zero = c.ZERO;\n    const wbits = (0, utils_ts_1.bitLen)(BigInt(plength));\n    let windowSize = 1; // bits\n    if (wbits > 12) windowSize = wbits - 3;\n    else if (wbits > 4) windowSize = wbits - 2;\n    else if (wbits > 0) windowSize = 2;\n    const MASK = (0, utils_ts_1.bitMask)(windowSize);\n    const buckets = new Array(Number(MASK) + 1).fill(zero); // +1 for zero array\n    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;\n    let sum = zero;\n    for(let i = lastBits; i >= 0; i -= windowSize){\n        buckets.fill(zero);\n        for(let j = 0; j < slength; j++){\n            const scalar = scalars[j];\n            const wbits = Number(scalar >> BigInt(i) & MASK);\n            buckets[wbits] = buckets[wbits].add(points[j]);\n        }\n        let resI = zero; // not using this will do small speed-up, but will lose ct\n        // Skip first bucket, because it is zero\n        for(let j = buckets.length - 1, sumI = zero; j > 0; j--){\n            sumI = sumI.add(buckets[j]);\n            resI = resI.add(sumI);\n        }\n        sum = sum.add(resI);\n        if (i !== 0) for(let j = 0; j < windowSize; j++)sum = sum.double();\n    }\n    return sum;\n}\n/**\n * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @returns function which multiplies points with scaars\n */ function precomputeMSMUnsafe(c, fieldN, points, windowSize) {\n    /**\n     * Performance Analysis of Window-based Precomputation\n     *\n     * Base Case (256-bit scalar, 8-bit window):\n     * - Standard precomputation requires:\n     *   - 31 additions per scalar √ó 256 scalars = 7,936 ops\n     *   - Plus 255 summary additions = 8,191 total ops\n     *   Note: Summary additions can be optimized via accumulator\n     *\n     * Chunked Precomputation Analysis:\n     * - Using 32 chunks requires:\n     *   - 255 additions per chunk\n     *   - 256 doublings\n     *   - Total: (255 √ó 32) + 256 = 8,416 ops\n     *\n     * Memory Usage Comparison:\n     * Window Size | Standard Points | Chunked Points\n     * ------------|-----------------|---------------\n     *     4-bit   |     520         |      15\n     *     8-bit   |    4,224        |     255\n     *    10-bit   |   13,824        |   1,023\n     *    16-bit   |  557,056        |  65,535\n     *\n     * Key Advantages:\n     * 1. Enables larger window sizes due to reduced memory overhead\n     * 2. More efficient for smaller scalar counts:\n     *    - 16 chunks: (16 √ó 255) + 256 = 4,336 ops\n     *    - ~2x faster than standard 8,191 ops\n     *\n     * Limitations:\n     * - Not suitable for plain precomputes (requires 256 constant doublings)\n     * - Performance degrades with larger scalar counts:\n     *   - Optimal for ~256 scalars\n     *   - Less efficient for 4096+ scalars (Pippenger preferred)\n     */ validateW(windowSize, fieldN.BITS);\n    validateMSMPoints(points, c);\n    const zero = c.ZERO;\n    const tableSize = 2 ** windowSize - 1; // table size (without zero)\n    const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item\n    const MASK = (0, utils_ts_1.bitMask)(windowSize);\n    const tables = points.map((p)=>{\n        const res = [];\n        for(let i = 0, acc = p; i < tableSize; i++){\n            res.push(acc);\n            acc = acc.add(p);\n        }\n        return res;\n    });\n    return (scalars)=>{\n        validateMSMScalars(scalars, fieldN);\n        if (scalars.length > points.length) throw new Error(\"array of scalars must be smaller than array of points\");\n        let res = zero;\n        for(let i = 0; i < chunks; i++){\n            // No need to double if accumulator is still zero.\n            if (res !== zero) for(let j = 0; j < windowSize; j++)res = res.double();\n            const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);\n            for(let j = 0; j < scalars.length; j++){\n                const n = scalars[j];\n                const curr = Number(n >> shiftBy & MASK);\n                if (!curr) continue; // skip zero scalars chunks\n                res = res.add(tables[j][curr - 1]);\n            }\n        }\n        return res;\n    };\n}\nfunction validateBasic(curve) {\n    (0, modular_ts_1.validateField)(curve.Fp);\n    (0, utils_ts_1.validateObject)(curve, {\n        n: \"bigint\",\n        h: \"bigint\",\n        Gx: \"field\",\n        Gy: \"field\"\n    }, {\n        nBitLength: \"isSafeInteger\",\n        nByteLength: \"isSafeInteger\"\n    });\n    // Set defaults\n    return Object.freeze({\n        ...(0, modular_ts_1.nLength)(curve.n, curve.nBitLength),\n        ...curve,\n        ...{\n            p: curve.Fp.ORDER\n        }\n    });\n} //# sourceMappingURL=curve.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvYWJzdHJhY3QvY3VydmUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELFlBQVksR0FBR0U7QUFDZkYsaUJBQWlCLEdBQUdHO0FBQ3BCSCwyQkFBMkIsR0FBR0k7QUFDOUJKLHFCQUFxQixHQUFHSztBQUN4Qjs7OztDQUlDLEdBQ0Qsb0VBQW9FLEdBQ3BFLE1BQU1DLGVBQWVDLG1CQUFPQSxDQUFDLDRGQUFjO0FBQzNDLE1BQU1DLGFBQWFELG1CQUFPQSxDQUFDLHdGQUFZO0FBQ3ZDLE1BQU1FLE1BQU1DLE9BQU87QUFDbkIsTUFBTUMsTUFBTUQsT0FBTztBQUNuQixTQUFTRSxnQkFBZ0JDLFNBQVMsRUFBRUMsSUFBSTtJQUNwQyxNQUFNQyxNQUFNRCxLQUFLRSxNQUFNO0lBQ3ZCLE9BQU9ILFlBQVlFLE1BQU1EO0FBQzdCO0FBQ0EsU0FBU0csVUFBVUMsQ0FBQyxFQUFFQyxJQUFJO0lBQ3RCLElBQUksQ0FBQ0MsT0FBT0MsYUFBYSxDQUFDSCxNQUFNQSxLQUFLLEtBQUtBLElBQUlDLE1BQzFDLE1BQU0sSUFBSUcsTUFBTSx1Q0FBdUNILE9BQU8sY0FBY0Q7QUFDcEY7QUFDQSxTQUFTSyxVQUFVTCxDQUFDLEVBQUVNLFVBQVU7SUFDNUJQLFVBQVVDLEdBQUdNO0lBQ2IsTUFBTUMsVUFBVUMsS0FBS0MsSUFBSSxDQUFDSCxhQUFhTixLQUFLLEdBQUcsdUNBQXVDO0lBQ3RGLE1BQU1VLGFBQWEsS0FBTVYsQ0FBQUEsSUFBSSxJQUFJLHlDQUF5QztJQUMxRSxNQUFNVyxZQUFZLEtBQUtYLEdBQUcsVUFBVTtJQUNwQyxNQUFNWSxPQUFPLENBQUMsR0FBR3RCLFdBQVd1QixPQUFPLEVBQUViLElBQUksNkJBQTZCO0lBQ3RFLE1BQU1jLFVBQVV0QixPQUFPUSxJQUFJLFFBQVE7SUFDbkMsT0FBTztRQUFFTztR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LFNBQVNoRixhQUFhLENBQUN5QixJQUFJLEtBQUt6QjtZQUN2RCxJQUFLLElBQUkyRSxJQUFJLEdBQUdBLElBQUloRCxRQUFRcUMsTUFBTSxFQUFFVyxJQUFLO2dCQUNyQyxNQUFNckUsSUFBSXFCLE9BQU8sQ0FBQ2dELEVBQUU7Z0JBQ3BCLE1BQU1TLE9BQU81RixPQUFPLEtBQU1ZLFVBQVdnRTtnQkFDckMsSUFBSSxDQUFDZ0IsTUFDRCxVQUFVLDJCQUEyQjtnQkFDekNELE1BQU1BLElBQUl6QyxHQUFHLENBQUN1QyxNQUFNLENBQUNOLEVBQUUsQ0FBQ1MsT0FBTyxFQUFFO1lBQ3JDO1FBQ0o7UUFDQSxPQUFPRDtJQUNYO0FBQ0o7QUFDQSxTQUFTMUcsY0FBYzRHLEtBQUs7SUFDdkIsSUFBRzNHLGFBQWE0RyxhQUFhLEVBQUVELE1BQU1FLEVBQUU7SUFDdkMsSUFBRzNHLFdBQVc0RyxjQUFjLEVBQUVILE9BQU87UUFDbEMvRSxHQUFHO1FBQ0htRixHQUFHO1FBQ0hDLElBQUk7UUFDSkMsSUFBSTtJQUNSLEdBQUc7UUFDQ0MsWUFBWTtRQUNaQyxhQUFhO0lBQ2pCO0lBQ0EsZUFBZTtJQUNmLE9BQU8zSCxPQUFPNEgsTUFBTSxDQUFDO1FBQ2pCLEdBQUcsQ0FBQyxHQUFHcEgsYUFBYXFILE9BQU8sRUFBRVYsTUFBTS9FLENBQUMsRUFBRStFLE1BQU1PLFVBQVUsQ0FBQztRQUN2RCxHQUFHUCxLQUFLO1FBQ1IsR0FBRztZQUFFN0QsR0FBRzZELE1BQU1FLEVBQUUsQ0FBQ1MsS0FBSztRQUFDLENBQUM7SUFDNUI7QUFDSixFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsYXctd29ya3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvYWJzdHJhY3QvY3VydmUuanM/MDZhYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMud05BRiA9IHdOQUY7XG5leHBvcnRzLnBpcHBlbmdlciA9IHBpcHBlbmdlcjtcbmV4cG9ydHMucHJlY29tcHV0ZU1TTVVuc2FmZSA9IHByZWNvbXB1dGVNU01VbnNhZmU7XG5leHBvcnRzLnZhbGlkYXRlQmFzaWMgPSB2YWxpZGF0ZUJhc2ljO1xuLyoqXG4gKiBNZXRob2RzIGZvciBlbGxpcHRpYyBjdXJ2ZSBtdWx0aXBsaWNhdGlvbiBieSBzY2FsYXJzLlxuICogQ29udGFpbnMgd05BRiwgcGlwcGVuZ2VyXG4gKiBAbW9kdWxlXG4gKi9cbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmNvbnN0IG1vZHVsYXJfdHNfMSA9IHJlcXVpcmUoXCIuL21vZHVsYXIuanNcIik7XG5jb25zdCB1dGlsc190c18xID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSBCaWdJbnQoMSk7XG5mdW5jdGlvbiBjb25zdFRpbWVOZWdhdGUoY29uZGl0aW9uLCBpdGVtKSB7XG4gICAgY29uc3QgbmVnID0gaXRlbS5uZWdhdGUoKTtcbiAgICByZXR1cm4gY29uZGl0aW9uID8gbmVnIDogaXRlbTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlVyhXLCBiaXRzKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihXKSB8fCBXIDw9IDAgfHwgVyA+IGJpdHMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB3aW5kb3cgc2l6ZSwgZXhwZWN0ZWQgWzEuLicgKyBiaXRzICsgJ10sIGdvdCBXPScgKyBXKTtcbn1cbmZ1bmN0aW9uIGNhbGNXT3B0cyhXLCBzY2FsYXJCaXRzKSB7XG4gICAgdmFsaWRhdGVXKFcsIHNjYWxhckJpdHMpO1xuICAgIGNvbnN0IHdpbmRvd3MgPSBNYXRoLmNlaWwoc2NhbGFyQml0cyAvIFcpICsgMTsgLy8gVz04IDMzLiBOb3QgMzIsIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgY29uc3Qgd2luZG93U2l6ZSA9IDIgKiogKFcgLSAxKTsgLy8gVz04IDEyOC4gTm90IDI1NiwgYmVjYXVzZSB3ZSBza2lwIHplcm9cbiAgICBjb25zdCBtYXhOdW1iZXIgPSAyICoqIFc7IC8vIFc9OCAyNTZcbiAgICBjb25zdCBtYXNrID0gKDAsIHV0aWxzX3RzXzEuYml0TWFzaykoVyk7IC8vIFc9OCAyNTUgPT0gbWFzayAwYjExMTExMTExXG4gICAgY29uc3Qgc2hpZnRCeSA9IEJpZ0ludChXKTsgLy8gVz04IDhcbiAgICByZXR1cm4geyB3aW5kb3dzLCB3aW5kb3dTaXplLCBtYXNrLCBtYXhOdW1iZXIsIHNoaWZ0QnkgfTtcbn1cbmZ1bmN0aW9uIGNhbGNPZmZzZXRzKG4sIHdpbmRvdywgd09wdHMpIHtcbiAgICBjb25zdCB7IHdpbmRvd1NpemUsIG1hc2ssIG1heE51bWJlciwgc2hpZnRCeSB9ID0gd09wdHM7XG4gICAgbGV0IHdiaXRzID0gTnVtYmVyKG4gJiBtYXNrKTsgLy8gZXh0cmFjdCBXIGJpdHMuXG4gICAgbGV0IG5leHROID0gbiA+PiBzaGlmdEJ5OyAvLyBzaGlmdCBudW1iZXIgYnkgVyBiaXRzLlxuICAgIC8vIFdoYXQgYWN0dWFsbHkgaGFwcGVucyBoZXJlOlxuICAgIC8vIGNvbnN0IGhpZ2hlc3RCaXQgPSBOdW1iZXIobWFzayBeIChtYXNrID4+IDFuKSk7XG4gICAgLy8gbGV0IHdiaXRzMiA9IHdiaXRzIC0gMTsgLy8gc2tpcCB6ZXJvXG4gICAgLy8gaWYgKHdiaXRzMiAmIGhpZ2hlc3RCaXQpIHsgd2JpdHMyIF49IE51bWJlcihtYXNrKTsgLy8gKH4pO1xuICAgIC8vIHNwbGl0IGlmIGJpdHMgPiBtYXg6ICsyMjQgPT4gMjU2LTMyXG4gICAgaWYgKHdiaXRzID4gd2luZG93U2l6ZSkge1xuICAgICAgICAvLyB3ZSBza2lwIHplcm8sIHdoaWNoIG1lYW5zIGluc3RlYWQgb2YgYD49IHNpemUtMWAsIHdlIGRvIGA+IHNpemVgXG4gICAgICAgIHdiaXRzIC09IG1heE51bWJlcjsgLy8gLTMyLCBjYW4gYmUgbWF4TnVtYmVyIC0gd2JpdHMsIGJ1dCB0aGVuIHdlIG5lZWQgdG8gc2V0IGlzTmVnIGhlcmUuXG4gICAgICAgIG5leHROICs9IF8xbjsgLy8gKzI1NiAoY2FycnkpXG4gICAgfVxuICAgIGNvbnN0IG9mZnNldFN0YXJ0ID0gd2luZG93ICogd2luZG93U2l6ZTtcbiAgICBjb25zdCBvZmZzZXQgPSBvZmZzZXRTdGFydCArIE1hdGguYWJzKHdiaXRzKSAtIDE7IC8vIC0xIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgY29uc3QgaXNaZXJvID0gd2JpdHMgPT09IDA7IC8vIGlzIGN1cnJlbnQgd2luZG93IHNsaWNlIGEgMD9cbiAgICBjb25zdCBpc05lZyA9IHdiaXRzIDwgMDsgLy8gaXMgY3VycmVudCB3aW5kb3cgc2xpY2UgbmVnYXRpdmU/XG4gICAgY29uc3QgaXNOZWdGID0gd2luZG93ICUgMiAhPT0gMDsgLy8gZmFrZSByYW5kb20gc3RhdGVtZW50IGZvciBub2lzZVxuICAgIGNvbnN0IG9mZnNldEYgPSBvZmZzZXRTdGFydDsgLy8gZmFrZSBvZmZzZXQgZm9yIG5vaXNlXG4gICAgcmV0dXJuIHsgbmV4dE4sIG9mZnNldCwgaXNaZXJvLCBpc05lZywgaXNOZWdGLCBvZmZzZXRGIH07XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU1TTVBvaW50cyhwb2ludHMsIGMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocG9pbnRzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcnJheSBleHBlY3RlZCcpO1xuICAgIHBvaW50cy5mb3JFYWNoKChwLCBpKSA9PiB7XG4gICAgICAgIGlmICghKHAgaW5zdGFuY2VvZiBjKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwb2ludCBhdCBpbmRleCAnICsgaSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU1TTVNjYWxhcnMoc2NhbGFycywgZmllbGQpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NhbGFycykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYXJyYXkgb2Ygc2NhbGFycyBleHBlY3RlZCcpO1xuICAgIHNjYWxhcnMuZm9yRWFjaCgocywgaSkgPT4ge1xuICAgICAgICBpZiAoIWZpZWxkLmlzVmFsaWQocykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2NhbGFyIGF0IGluZGV4ICcgKyBpKTtcbiAgICB9KTtcbn1cbi8vIFNpbmNlIHBvaW50cyBpbiBkaWZmZXJlbnQgZ3JvdXBzIGNhbm5vdCBiZSBlcXVhbCAoZGlmZmVyZW50IG9iamVjdCBjb25zdHJ1Y3RvciksXG4vLyB3ZSBjYW4gaGF2ZSBzaW5nbGUgcGxhY2UgdG8gc3RvcmUgcHJlY29tcHV0ZXMuXG4vLyBBbGxvd3MgdG8gbWFrZSBwb2ludHMgZnJvemVuIC8gaW1tdXRhYmxlLlxuY29uc3QgcG9pbnRQcmVjb21wdXRlcyA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCBwb2ludFdpbmRvd1NpemVzID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIGdldFcoUCkge1xuICAgIHJldHVybiBwb2ludFdpbmRvd1NpemVzLmdldChQKSB8fCAxO1xufVxuLyoqXG4gKiBFbGxpcHRpYyBjdXJ2ZSBtdWx0aXBsaWNhdGlvbiBvZiBQb2ludCBieSBzY2FsYXIuIEZyYWdpbGUuXG4gKiBTY2FsYXJzIHNob3VsZCBhbHdheXMgYmUgbGVzcyB0aGFuIGN1cnZlIG9yZGVyOiB0aGlzIHNob3VsZCBiZSBjaGVja2VkIGluc2lkZSBvZiBhIGN1cnZlIGl0c2VsZi5cbiAqIENyZWF0ZXMgcHJlY29tcHV0YXRpb24gdGFibGVzIGZvciBmYXN0IG11bHRpcGxpY2F0aW9uOlxuICogLSBwcml2YXRlIHNjYWxhciBpcyBzcGxpdCBieSBmaXhlZCBzaXplIHdpbmRvd3Mgb2YgVyBiaXRzXG4gKiAtIGV2ZXJ5IHdpbmRvdyBwb2ludCBpcyBjb2xsZWN0ZWQgZnJvbSB3aW5kb3cncyB0YWJsZSAmIGFkZGVkIHRvIGFjY3VtdWxhdG9yXG4gKiAtIHNpbmNlIHdpbmRvd3MgYXJlIGRpZmZlcmVudCwgc2FtZSBwb2ludCBpbnNpZGUgdGFibGVzIHdvbid0IGJlIGFjY2Vzc2VkIG1vcmUgdGhhbiBvbmNlIHBlciBjYWxjXG4gKiAtIGVhY2ggbXVsdGlwbGljYXRpb24gaXMgJ01hdGguY2VpbChDVVJWRV9PUkRFUiAvIPCdkYopICsgMScgcG9pbnQgYWRkaXRpb25zIChmaXhlZCBmb3IgYW55IHNjYWxhcilcbiAqIC0gKzEgd2luZG93IGlzIG5lY2Nlc3NhcnkgZm9yIHdOQUZcbiAqIC0gd05BRiByZWR1Y2VzIHRhYmxlIHNpemU6IDJ4IGxlc3MgbWVtb3J5ICsgMnggZmFzdGVyIGdlbmVyYXRpb24sIGJ1dCAxMCUgc2xvd2VyIG11bHRpcGxpY2F0aW9uXG4gKlxuICogQHRvZG8gUmVzZWFyY2ggcmV0dXJuaW5nIDJkIEpTIGFycmF5IG9mIHdpbmRvd3MsIGluc3RlYWQgb2YgYSBzaW5nbGUgd2luZG93LlxuICogVGhpcyB3b3VsZCBhbGxvdyB3aW5kb3dzIHRvIGJlIGluIGRpZmZlcmVudCBtZW1vcnkgbG9jYXRpb25zXG4gKi9cbmZ1bmN0aW9uIHdOQUYoYywgYml0cykge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbnN0VGltZU5lZ2F0ZSxcbiAgICAgICAgaGFzUHJlY29tcHV0ZXMoZWxtKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0VyhlbG0pICE9PSAxO1xuICAgICAgICB9LFxuICAgICAgICAvLyBub24tY29uc3QgdGltZSBtdWx0aXBsaWNhdGlvbiBsYWRkZXJcbiAgICAgICAgdW5zYWZlTGFkZGVyKGVsbSwgbiwgcCA9IGMuWkVSTykge1xuICAgICAgICAgICAgbGV0IGQgPSBlbG07XG4gICAgICAgICAgICB3aGlsZSAobiA+IF8wbikge1xuICAgICAgICAgICAgICAgIGlmIChuICYgXzFuKVxuICAgICAgICAgICAgICAgICAgICBwID0gcC5hZGQoZCk7XG4gICAgICAgICAgICAgICAgZCA9IGQuZG91YmxlKCk7XG4gICAgICAgICAgICAgICAgbiA+Pj0gXzFuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgd05BRiBwcmVjb21wdXRhdGlvbiB3aW5kb3cuIFVzZWQgZm9yIGNhY2hpbmcuXG4gICAgICAgICAqIERlZmF1bHQgd2luZG93IHNpemUgaXMgc2V0IGJ5IGB1dGlscy5wcmVjb21wdXRlKClgIGFuZCBpcyBlcXVhbCB0byA4LlxuICAgICAgICAgKiBOdW1iZXIgb2YgcHJlY29tcHV0ZWQgcG9pbnRzIGRlcGVuZHMgb24gdGhlIGN1cnZlIHNpemU6XG4gICAgICAgICAqIDJeKPCdkYriiJIxKSAqIChNYXRoLmNlaWwo8J2RmyAvIPCdkYopICsgMSksIHdoZXJlOlxuICAgICAgICAgKiAtIPCdkYogaXMgdGhlIHdpbmRvdyBzaXplXG4gICAgICAgICAqIC0g8J2RmyBpcyB0aGUgYml0bGVuZ3RoIG9mIHRoZSBjdXJ2ZSBvcmRlci5cbiAgICAgICAgICogRm9yIGEgMjU2LWJpdCBjdXJ2ZSBhbmQgd2luZG93IHNpemUgOCwgdGhlIG51bWJlciBvZiBwcmVjb21wdXRlZCBwb2ludHMgaXMgMTI4ICogMzMgPSA0MjI0LlxuICAgICAgICAgKiBAcGFyYW0gZWxtIFBvaW50IGluc3RhbmNlXG4gICAgICAgICAqIEBwYXJhbSBXIHdpbmRvdyBzaXplXG4gICAgICAgICAqIEByZXR1cm5zIHByZWNvbXB1dGVkIHBvaW50IHRhYmxlcyBmbGF0dGVuZWQgdG8gYSBzaW5nbGUgYXJyYXlcbiAgICAgICAgICovXG4gICAgICAgIHByZWNvbXB1dGVXaW5kb3coZWxtLCBXKSB7XG4gICAgICAgICAgICBjb25zdCB7IHdpbmRvd3MsIHdpbmRvd1NpemUgfSA9IGNhbGNXT3B0cyhXLCBiaXRzKTtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50cyA9IFtdO1xuICAgICAgICAgICAgbGV0IHAgPSBlbG07XG4gICAgICAgICAgICBsZXQgYmFzZSA9IHA7XG4gICAgICAgICAgICBmb3IgKGxldCB3aW5kb3cgPSAwOyB3aW5kb3cgPCB3aW5kb3dzOyB3aW5kb3crKykge1xuICAgICAgICAgICAgICAgIGJhc2UgPSBwO1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGJhc2UpO1xuICAgICAgICAgICAgICAgIC8vIGk9MSwgYmMgd2Ugc2tpcCAwXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB3aW5kb3dTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZSA9IGJhc2UuYWRkKHApO1xuICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChiYXNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcCA9IGJhc2UuZG91YmxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcG9pbnRzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogSW1wbGVtZW50cyBlYyBtdWx0aXBsaWNhdGlvbiB1c2luZyBwcmVjb21wdXRlZCB0YWJsZXMgYW5kIHctYXJ5IG5vbi1hZGphY2VudCBmb3JtLlxuICAgICAgICAgKiBAcGFyYW0gVyB3aW5kb3cgc2l6ZVxuICAgICAgICAgKiBAcGFyYW0gcHJlY29tcHV0ZXMgcHJlY29tcHV0ZWQgdGFibGVzXG4gICAgICAgICAqIEBwYXJhbSBuIHNjYWxhciAod2UgZG9uJ3QgY2hlY2sgaGVyZSwgYnV0IHNob3VsZCBiZSBsZXNzIHRoYW4gY3VydmUgb3JkZXIpXG4gICAgICAgICAqIEByZXR1cm5zIHJlYWwgYW5kIGZha2UgKGZvciBjb25zdC10aW1lKSBwb2ludHNcbiAgICAgICAgICovXG4gICAgICAgIHdOQUYoVywgcHJlY29tcHV0ZXMsIG4pIHtcbiAgICAgICAgICAgIC8vIFNtYWxsZXIgdmVyc2lvbjpcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wYXVsbWlsbHIvbm9ibGUtc2VjcDI1NmsxL2Jsb2IvNDdjYjE2NjliNmU1MDZhZDY2YjM1ZmU3ZDc2MTMyYWU5NzQ2NWRhMi9pbmRleC50cyNMNTAyLUw1NDFcbiAgICAgICAgICAgIC8vIFRPRE86IGNoZWNrIHRoZSBzY2FsYXIgaXMgbGVzcyB0aGFuIGdyb3VwIG9yZGVyP1xuICAgICAgICAgICAgLy8gd05BRiBiZWhhdmlvciBpcyB1bmRlZmluZWQgb3RoZXJ3aXNlLiBCdXQgaGF2ZSB0byBjYXJlZnVsbHkgcmVtb3ZlXG4gICAgICAgICAgICAvLyBvdGhlciBjaGVja3MgYmVmb3JlIHdOQUYuIE9SREVSID09IGJpdHMgaGVyZS5cbiAgICAgICAgICAgIC8vIEFjY3VtdWxhdG9yc1xuICAgICAgICAgICAgbGV0IHAgPSBjLlpFUk87XG4gICAgICAgICAgICBsZXQgZiA9IGMuQkFTRTtcbiAgICAgICAgICAgIC8vIFRoaXMgY29kZSB3YXMgZmlyc3Qgd3JpdHRlbiB3aXRoIGFzc3VtcHRpb24gdGhhdCAnZicgYW5kICdwJyB3aWxsIG5ldmVyIGJlIGluZmluaXR5IHBvaW50OlxuICAgICAgICAgICAgLy8gc2luY2UgZWFjaCBhZGRpdGlvbiBpcyBtdWx0aXBsaWVkIGJ5IDIgKiogVywgaXQgY2Fubm90IGNhbmNlbCBlYWNoIG90aGVyLiBIb3dldmVyLFxuICAgICAgICAgICAgLy8gdGhlcmUgaXMgbmVnYXRlIG5vdzogaXQgaXMgcG9zc2libGUgdGhhdCBuZWdhdGVkIGVsZW1lbnQgZnJvbSBsb3cgdmFsdWVcbiAgICAgICAgICAgIC8vIHdvdWxkIGJlIHRoZSBzYW1lIGFzIGhpZ2ggZWxlbWVudCwgd2hpY2ggd2lsbCBjcmVhdGUgY2FycnkgaW50byBuZXh0IHdpbmRvdy5cbiAgICAgICAgICAgIC8vIEl0J3Mgbm90IG9idmlvdXMgaG93IHRoaXMgY2FuIGZhaWwsIGJ1dCBzdGlsbCB3b3J0aCBpbnZlc3RpZ2F0aW5nIGxhdGVyLlxuICAgICAgICAgICAgY29uc3Qgd28gPSBjYWxjV09wdHMoVywgYml0cyk7XG4gICAgICAgICAgICBmb3IgKGxldCB3aW5kb3cgPSAwOyB3aW5kb3cgPCB3by53aW5kb3dzOyB3aW5kb3crKykge1xuICAgICAgICAgICAgICAgIC8vIChuID09PSBfMG4pIGlzIGhhbmRsZWQgYW5kIG5vdCBlYXJseS1leGl0ZWQuIGlzRXZlbiBhbmQgb2Zmc2V0RiBhcmUgdXNlZCBmb3Igbm9pc2VcbiAgICAgICAgICAgICAgICBjb25zdCB7IG5leHROLCBvZmZzZXQsIGlzWmVybywgaXNOZWcsIGlzTmVnRiwgb2Zmc2V0RiB9ID0gY2FsY09mZnNldHMobiwgd2luZG93LCB3byk7XG4gICAgICAgICAgICAgICAgbiA9IG5leHROO1xuICAgICAgICAgICAgICAgIGlmIChpc1plcm8pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYml0cyBhcmUgMDogYWRkIGdhcmJhZ2UgdG8gZmFrZSBwb2ludFxuICAgICAgICAgICAgICAgICAgICAvLyBJbXBvcnRhbnQgcGFydCBmb3IgY29uc3QtdGltZSBnZXRQdWJsaWNLZXk6IGFkZCByYW5kb20gXCJub2lzZVwiIHBvaW50IHRvIGYuXG4gICAgICAgICAgICAgICAgICAgIGYgPSBmLmFkZChjb25zdFRpbWVOZWdhdGUoaXNOZWdGLCBwcmVjb21wdXRlc1tvZmZzZXRGXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYml0cyBhcmUgMTogYWRkIHRvIHJlc3VsdCBwb2ludFxuICAgICAgICAgICAgICAgICAgICBwID0gcC5hZGQoY29uc3RUaW1lTmVnYXRlKGlzTmVnLCBwcmVjb21wdXRlc1tvZmZzZXRdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmV0dXJuIGJvdGggcmVhbCBhbmQgZmFrZSBwb2ludHM6IEpJVCB3b24ndCBlbGltaW5hdGUgZi5cbiAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgdGhlcmUgaXMgYSB3YXkgdG8gRiBiZSBpbmZpbml0eS1wb2ludCBldmVuIGlmIHAgaXMgbm90LFxuICAgICAgICAgICAgLy8gd2hpY2ggbWFrZXMgaXQgbGVzcyBjb25zdC10aW1lOiBhcm91bmQgMSBiaWdpbnQgbXVsdGlwbHkuXG4gICAgICAgICAgICByZXR1cm4geyBwLCBmIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbXBsZW1lbnRzIGVjIHVuc2FmZSAobm9uIGNvbnN0LXRpbWUpIG11bHRpcGxpY2F0aW9uIHVzaW5nIHByZWNvbXB1dGVkIHRhYmxlcyBhbmQgdy1hcnkgbm9uLWFkamFjZW50IGZvcm0uXG4gICAgICAgICAqIEBwYXJhbSBXIHdpbmRvdyBzaXplXG4gICAgICAgICAqIEBwYXJhbSBwcmVjb21wdXRlcyBwcmVjb21wdXRlZCB0YWJsZXNcbiAgICAgICAgICogQHBhcmFtIG4gc2NhbGFyICh3ZSBkb24ndCBjaGVjayBoZXJlLCBidXQgc2hvdWxkIGJlIGxlc3MgdGhhbiBjdXJ2ZSBvcmRlcilcbiAgICAgICAgICogQHBhcmFtIGFjYyBhY2N1bXVsYXRvciBwb2ludCB0byBhZGQgcmVzdWx0IG9mIG11bHRpcGxpY2F0aW9uXG4gICAgICAgICAqIEByZXR1cm5zIHBvaW50XG4gICAgICAgICAqL1xuICAgICAgICB3TkFGVW5zYWZlKFcsIHByZWNvbXB1dGVzLCBuLCBhY2MgPSBjLlpFUk8pIHtcbiAgICAgICAgICAgIGNvbnN0IHdvID0gY2FsY1dPcHRzKFcsIGJpdHMpO1xuICAgICAgICAgICAgZm9yIChsZXQgd2luZG93ID0gMDsgd2luZG93IDwgd28ud2luZG93czsgd2luZG93KyspIHtcbiAgICAgICAgICAgICAgICBpZiAobiA9PT0gXzBuKVxuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gRWFybHktZXhpdCwgc2tpcCAwIHZhbHVlXG4gICAgICAgICAgICAgICAgY29uc3QgeyBuZXh0Tiwgb2Zmc2V0LCBpc1plcm8sIGlzTmVnIH0gPSBjYWxjT2Zmc2V0cyhuLCB3aW5kb3csIHdvKTtcbiAgICAgICAgICAgICAgICBuID0gbmV4dE47XG4gICAgICAgICAgICAgICAgaWYgKGlzWmVybykge1xuICAgICAgICAgICAgICAgICAgICAvLyBXaW5kb3cgYml0cyBhcmUgMDogc2tpcCBwcm9jZXNzaW5nLlxuICAgICAgICAgICAgICAgICAgICAvLyBNb3ZlIHRvIG5leHQgd2luZG93LlxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBwcmVjb21wdXRlc1tvZmZzZXRdO1xuICAgICAgICAgICAgICAgICAgICBhY2MgPSBhY2MuYWRkKGlzTmVnID8gaXRlbS5uZWdhdGUoKSA6IGl0ZW0pOyAvLyBSZS11c2luZyBhY2MgYWxsb3dzIHRvIHNhdmUgYWRkcyBpbiBNU01cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LFxuICAgICAgICBnZXRQcmVjb21wdXRlcyhXLCBQLCB0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBwcmVjb21wdXRlcyBvbiBhIGZpcnN0IHJ1biwgcmV1c2UgdGhlbSBhZnRlclxuICAgICAgICAgICAgbGV0IGNvbXAgPSBwb2ludFByZWNvbXB1dGVzLmdldChQKTtcbiAgICAgICAgICAgIGlmICghY29tcCkge1xuICAgICAgICAgICAgICAgIGNvbXAgPSB0aGlzLnByZWNvbXB1dGVXaW5kb3coUCwgVyk7XG4gICAgICAgICAgICAgICAgaWYgKFcgIT09IDEpXG4gICAgICAgICAgICAgICAgICAgIHBvaW50UHJlY29tcHV0ZXMuc2V0KFAsIHRyYW5zZm9ybShjb21wKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29tcDtcbiAgICAgICAgfSxcbiAgICAgICAgd05BRkNhY2hlZChQLCBuLCB0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIGNvbnN0IFcgPSBnZXRXKFApO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud05BRihXLCB0aGlzLmdldFByZWNvbXB1dGVzKFcsIFAsIHRyYW5zZm9ybSksIG4pO1xuICAgICAgICB9LFxuICAgICAgICB3TkFGQ2FjaGVkVW5zYWZlKFAsIG4sIHRyYW5zZm9ybSwgcHJldikge1xuICAgICAgICAgICAgY29uc3QgVyA9IGdldFcoUCk7XG4gICAgICAgICAgICBpZiAoVyA9PT0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy51bnNhZmVMYWRkZXIoUCwgbiwgcHJldik7IC8vIEZvciBXPTEgbGFkZGVyIGlzIH54MiBmYXN0ZXJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndOQUZVbnNhZmUoVywgdGhpcy5nZXRQcmVjb21wdXRlcyhXLCBQLCB0cmFuc2Zvcm0pLCBuLCBwcmV2KTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gV2UgY2FsY3VsYXRlIHByZWNvbXB1dGVzIGZvciBlbGxpcHRpYyBjdXJ2ZSBwb2ludCBtdWx0aXBsaWNhdGlvblxuICAgICAgICAvLyB1c2luZyB3aW5kb3dlZCBtZXRob2QuIFRoaXMgc3BlY2lmaWVzIHdpbmRvdyBzaXplIGFuZFxuICAgICAgICAvLyBzdG9yZXMgcHJlY29tcHV0ZWQgdmFsdWVzLiBVc3VhbGx5IG9ubHkgYmFzZSBwb2ludCB3b3VsZCBiZSBwcmVjb21wdXRlZC5cbiAgICAgICAgc2V0V2luZG93U2l6ZShQLCBXKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZVcoVywgYml0cyk7XG4gICAgICAgICAgICBwb2ludFdpbmRvd1NpemVzLnNldChQLCBXKTtcbiAgICAgICAgICAgIHBvaW50UHJlY29tcHV0ZXMuZGVsZXRlKFApO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIFBpcHBlbmdlciBhbGdvcml0aG0gZm9yIG11bHRpLXNjYWxhciBtdWx0aXBsaWNhdGlvbiAoTVNNLCBQYSArIFFiICsgUmMgKyAuLi4pLlxuICogMzB4IGZhc3RlciB2cyBuYWl2ZSBhZGRpdGlvbiBvbiBMPTQwOTYsIDEweCBmYXN0ZXIgdGhhbiBwcmVjb21wdXRlcy5cbiAqIEZvciBOPTI1NGJpdCwgTD0xLCBpdCBkb2VzOiAxMDI0IEFERCArIDI1NCBEQkwuIEZvciBMPTU6IDE1MzYgQUREICsgMjU0IERCTC5cbiAqIEFsZ29yaXRobWljYWxseSBjb25zdGFudC10aW1lIChmb3Igc2FtZSBMKSwgZXZlbiB3aGVuIDEgcG9pbnQgKyBzY2FsYXIsIG9yIHdoZW4gc2NhbGFyID0gMC5cbiAqIEBwYXJhbSBjIEN1cnZlIFBvaW50IGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gZmllbGROIGZpZWxkIG92ZXIgQ1VSVkUuTiAtIGltcG9ydGFudCB0aGF0IGl0J3Mgbm90IG92ZXIgQ1VSVkUuUFxuICogQHBhcmFtIHBvaW50cyBhcnJheSBvZiBMIGN1cnZlIHBvaW50c1xuICogQHBhcmFtIHNjYWxhcnMgYXJyYXkgb2YgTCBzY2FsYXJzIChha2EgcHJpdmF0ZSBrZXlzIC8gYmlnaW50cylcbiAqL1xuZnVuY3Rpb24gcGlwcGVuZ2VyKGMsIGZpZWxkTiwgcG9pbnRzLCBzY2FsYXJzKSB7XG4gICAgLy8gSWYgd2Ugc3BsaXQgc2NhbGFycyBieSBzb21lIHdpbmRvdyAobGV0J3Mgc2F5IDggYml0cyksIGV2ZXJ5IGNodW5rIHdpbGwgb25seVxuICAgIC8vIHRha2UgMjU2IGJ1Y2tldHMgZXZlbiBpZiB0aGVyZSBhcmUgNDA5NiBzY2FsYXJzLCBhbHNvIHJlLXVzZXMgZG91YmxlLlxuICAgIC8vIFRPRE86XG4gICAgLy8gLSBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDI0Lzc1MC5wZGZcbiAgICAvLyAtIGh0dHBzOi8vdGNoZXMuaWFjci5vcmcvaW5kZXgucGhwL1RDSEVTL2FydGljbGUvdmlldy8xMDI4N1xuICAgIC8vIDAgaXMgYWNjZXB0ZWQgaW4gc2NhbGFyc1xuICAgIHZhbGlkYXRlTVNNUG9pbnRzKHBvaW50cywgYyk7XG4gICAgdmFsaWRhdGVNU01TY2FsYXJzKHNjYWxhcnMsIGZpZWxkTik7XG4gICAgY29uc3QgcGxlbmd0aCA9IHBvaW50cy5sZW5ndGg7XG4gICAgY29uc3Qgc2xlbmd0aCA9IHNjYWxhcnMubGVuZ3RoO1xuICAgIGlmIChwbGVuZ3RoICE9PSBzbGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FycmF5cyBvZiBwb2ludHMgYW5kIHNjYWxhcnMgbXVzdCBoYXZlIGVxdWFsIGxlbmd0aCcpO1xuICAgIC8vIGlmIChwbGVuZ3RoID09PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ2FycmF5IG11c3QgYmUgb2YgbGVuZ3RoID49IDInKTtcbiAgICBjb25zdCB6ZXJvID0gYy5aRVJPO1xuICAgIGNvbnN0IHdiaXRzID0gKDAsIHV0aWxzX3RzXzEuYml0TGVuKShCaWdJbnQocGxlbmd0aCkpO1xuICAgIGxldCB3aW5kb3dTaXplID0gMTsgLy8gYml0c1xuICAgIGlmICh3Yml0cyA+IDEyKVxuICAgICAgICB3aW5kb3dTaXplID0gd2JpdHMgLSAzO1xuICAgIGVsc2UgaWYgKHdiaXRzID4gNClcbiAgICAgICAgd2luZG93U2l6ZSA9IHdiaXRzIC0gMjtcbiAgICBlbHNlIGlmICh3Yml0cyA+IDApXG4gICAgICAgIHdpbmRvd1NpemUgPSAyO1xuICAgIGNvbnN0IE1BU0sgPSAoMCwgdXRpbHNfdHNfMS5iaXRNYXNrKSh3aW5kb3dTaXplKTtcbiAgICBjb25zdCBidWNrZXRzID0gbmV3IEFycmF5KE51bWJlcihNQVNLKSArIDEpLmZpbGwoemVybyk7IC8vICsxIGZvciB6ZXJvIGFycmF5XG4gICAgY29uc3QgbGFzdEJpdHMgPSBNYXRoLmZsb29yKChmaWVsZE4uQklUUyAtIDEpIC8gd2luZG93U2l6ZSkgKiB3aW5kb3dTaXplO1xuICAgIGxldCBzdW0gPSB6ZXJvO1xuICAgIGZvciAobGV0IGkgPSBsYXN0Qml0czsgaSA+PSAwOyBpIC09IHdpbmRvd1NpemUpIHtcbiAgICAgICAgYnVja2V0cy5maWxsKHplcm8pO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNsZW5ndGg7IGorKykge1xuICAgICAgICAgICAgY29uc3Qgc2NhbGFyID0gc2NhbGFyc1tqXTtcbiAgICAgICAgICAgIGNvbnN0IHdiaXRzID0gTnVtYmVyKChzY2FsYXIgPj4gQmlnSW50KGkpKSAmIE1BU0spO1xuICAgICAgICAgICAgYnVja2V0c1t3Yml0c10gPSBidWNrZXRzW3diaXRzXS5hZGQocG9pbnRzW2pdKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzSSA9IHplcm87IC8vIG5vdCB1c2luZyB0aGlzIHdpbGwgZG8gc21hbGwgc3BlZWQtdXAsIGJ1dCB3aWxsIGxvc2UgY3RcbiAgICAgICAgLy8gU2tpcCBmaXJzdCBidWNrZXQsIGJlY2F1c2UgaXQgaXMgemVyb1xuICAgICAgICBmb3IgKGxldCBqID0gYnVja2V0cy5sZW5ndGggLSAxLCBzdW1JID0gemVybzsgaiA+IDA7IGotLSkge1xuICAgICAgICAgICAgc3VtSSA9IHN1bUkuYWRkKGJ1Y2tldHNbal0pO1xuICAgICAgICAgICAgcmVzSSA9IHJlc0kuYWRkKHN1bUkpO1xuICAgICAgICB9XG4gICAgICAgIHN1bSA9IHN1bS5hZGQocmVzSSk7XG4gICAgICAgIGlmIChpICE9PSAwKVxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB3aW5kb3dTaXplOyBqKyspXG4gICAgICAgICAgICAgICAgc3VtID0gc3VtLmRvdWJsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gc3VtO1xufVxuLyoqXG4gKiBQcmVjb21wdXRlZCBtdWx0aS1zY2FsYXIgbXVsdGlwbGljYXRpb24gKE1TTSwgUGEgKyBRYiArIFJjICsgLi4uKS5cbiAqIEBwYXJhbSBjIEN1cnZlIFBvaW50IGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gZmllbGROIGZpZWxkIG92ZXIgQ1VSVkUuTiAtIGltcG9ydGFudCB0aGF0IGl0J3Mgbm90IG92ZXIgQ1VSVkUuUFxuICogQHBhcmFtIHBvaW50cyBhcnJheSBvZiBMIGN1cnZlIHBvaW50c1xuICogQHJldHVybnMgZnVuY3Rpb24gd2hpY2ggbXVsdGlwbGllcyBwb2ludHMgd2l0aCBzY2FhcnNcbiAqL1xuZnVuY3Rpb24gcHJlY29tcHV0ZU1TTVVuc2FmZShjLCBmaWVsZE4sIHBvaW50cywgd2luZG93U2l6ZSkge1xuICAgIC8qKlxuICAgICAqIFBlcmZvcm1hbmNlIEFuYWx5c2lzIG9mIFdpbmRvdy1iYXNlZCBQcmVjb21wdXRhdGlvblxuICAgICAqXG4gICAgICogQmFzZSBDYXNlICgyNTYtYml0IHNjYWxhciwgOC1iaXQgd2luZG93KTpcbiAgICAgKiAtIFN0YW5kYXJkIHByZWNvbXB1dGF0aW9uIHJlcXVpcmVzOlxuICAgICAqICAgLSAzMSBhZGRpdGlvbnMgcGVyIHNjYWxhciDDlyAyNTYgc2NhbGFycyA9IDcsOTM2IG9wc1xuICAgICAqICAgLSBQbHVzIDI1NSBzdW1tYXJ5IGFkZGl0aW9ucyA9IDgsMTkxIHRvdGFsIG9wc1xuICAgICAqICAgTm90ZTogU3VtbWFyeSBhZGRpdGlvbnMgY2FuIGJlIG9wdGltaXplZCB2aWEgYWNjdW11bGF0b3JcbiAgICAgKlxuICAgICAqIENodW5rZWQgUHJlY29tcHV0YXRpb24gQW5hbHlzaXM6XG4gICAgICogLSBVc2luZyAzMiBjaHVua3MgcmVxdWlyZXM6XG4gICAgICogICAtIDI1NSBhZGRpdGlvbnMgcGVyIGNodW5rXG4gICAgICogICAtIDI1NiBkb3VibGluZ3NcbiAgICAgKiAgIC0gVG90YWw6ICgyNTUgw5cgMzIpICsgMjU2ID0gOCw0MTYgb3BzXG4gICAgICpcbiAgICAgKiBNZW1vcnkgVXNhZ2UgQ29tcGFyaXNvbjpcbiAgICAgKiBXaW5kb3cgU2l6ZSB8IFN0YW5kYXJkIFBvaW50cyB8IENodW5rZWQgUG9pbnRzXG4gICAgICogLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLVxuICAgICAqICAgICA0LWJpdCAgIHwgICAgIDUyMCAgICAgICAgIHwgICAgICAxNVxuICAgICAqICAgICA4LWJpdCAgIHwgICAgNCwyMjQgICAgICAgIHwgICAgIDI1NVxuICAgICAqICAgIDEwLWJpdCAgIHwgICAxMyw4MjQgICAgICAgIHwgICAxLDAyM1xuICAgICAqICAgIDE2LWJpdCAgIHwgIDU1NywwNTYgICAgICAgIHwgIDY1LDUzNVxuICAgICAqXG4gICAgICogS2V5IEFkdmFudGFnZXM6XG4gICAgICogMS4gRW5hYmxlcyBsYXJnZXIgd2luZG93IHNpemVzIGR1ZSB0byByZWR1Y2VkIG1lbW9yeSBvdmVyaGVhZFxuICAgICAqIDIuIE1vcmUgZWZmaWNpZW50IGZvciBzbWFsbGVyIHNjYWxhciBjb3VudHM6XG4gICAgICogICAgLSAxNiBjaHVua3M6ICgxNiDDlyAyNTUpICsgMjU2ID0gNCwzMzYgb3BzXG4gICAgICogICAgLSB+MnggZmFzdGVyIHRoYW4gc3RhbmRhcmQgOCwxOTEgb3BzXG4gICAgICpcbiAgICAgKiBMaW1pdGF0aW9uczpcbiAgICAgKiAtIE5vdCBzdWl0YWJsZSBmb3IgcGxhaW4gcHJlY29tcHV0ZXMgKHJlcXVpcmVzIDI1NiBjb25zdGFudCBkb3VibGluZ3MpXG4gICAgICogLSBQZXJmb3JtYW5jZSBkZWdyYWRlcyB3aXRoIGxhcmdlciBzY2FsYXIgY291bnRzOlxuICAgICAqICAgLSBPcHRpbWFsIGZvciB+MjU2IHNjYWxhcnNcbiAgICAgKiAgIC0gTGVzcyBlZmZpY2llbnQgZm9yIDQwOTYrIHNjYWxhcnMgKFBpcHBlbmdlciBwcmVmZXJyZWQpXG4gICAgICovXG4gICAgdmFsaWRhdGVXKHdpbmRvd1NpemUsIGZpZWxkTi5CSVRTKTtcbiAgICB2YWxpZGF0ZU1TTVBvaW50cyhwb2ludHMsIGMpO1xuICAgIGNvbnN0IHplcm8gPSBjLlpFUk87XG4gICAgY29uc3QgdGFibGVTaXplID0gMiAqKiB3aW5kb3dTaXplIC0gMTsgLy8gdGFibGUgc2l6ZSAod2l0aG91dCB6ZXJvKVxuICAgIGNvbnN0IGNodW5rcyA9IE1hdGguY2VpbChmaWVsZE4uQklUUyAvIHdpbmRvd1NpemUpOyAvLyBjaHVua3Mgb2YgaXRlbVxuICAgIGNvbnN0IE1BU0sgPSAoMCwgdXRpbHNfdHNfMS5iaXRNYXNrKSh3aW5kb3dTaXplKTtcbiAgICBjb25zdCB0YWJsZXMgPSBwb2ludHMubWFwKChwKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgYWNjID0gcDsgaSA8IHRhYmxlU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICByZXMucHVzaChhY2MpO1xuICAgICAgICAgICAgYWNjID0gYWNjLmFkZChwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0pO1xuICAgIHJldHVybiAoc2NhbGFycykgPT4ge1xuICAgICAgICB2YWxpZGF0ZU1TTVNjYWxhcnMoc2NhbGFycywgZmllbGROKTtcbiAgICAgICAgaWYgKHNjYWxhcnMubGVuZ3RoID4gcG9pbnRzLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXJyYXkgb2Ygc2NhbGFycyBtdXN0IGJlIHNtYWxsZXIgdGhhbiBhcnJheSBvZiBwb2ludHMnKTtcbiAgICAgICAgbGV0IHJlcyA9IHplcm87XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2h1bmtzOyBpKyspIHtcbiAgICAgICAgICAgIC8vIE5vIG5lZWQgdG8gZG91YmxlIGlmIGFjY3VtdWxhdG9yIGlzIHN0aWxsIHplcm8uXG4gICAgICAgICAgICBpZiAocmVzICE9PSB6ZXJvKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgd2luZG93U2l6ZTsgaisrKVxuICAgICAgICAgICAgICAgICAgICByZXMgPSByZXMuZG91YmxlKCk7XG4gICAgICAgICAgICBjb25zdCBzaGlmdEJ5ID0gQmlnSW50KGNodW5rcyAqIHdpbmRvd1NpemUgLSAoaSArIDEpICogd2luZG93U2l6ZSk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNjYWxhcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuID0gc2NhbGFyc1tqXTtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyID0gTnVtYmVyKChuID4+IHNoaWZ0QnkpICYgTUFTSyk7XG4gICAgICAgICAgICAgICAgaWYgKCFjdXJyKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gc2tpcCB6ZXJvIHNjYWxhcnMgY2h1bmtzXG4gICAgICAgICAgICAgICAgcmVzID0gcmVzLmFkZCh0YWJsZXNbal1bY3VyciAtIDFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUJhc2ljKGN1cnZlKSB7XG4gICAgKDAsIG1vZHVsYXJfdHNfMS52YWxpZGF0ZUZpZWxkKShjdXJ2ZS5GcCk7XG4gICAgKDAsIHV0aWxzX3RzXzEudmFsaWRhdGVPYmplY3QpKGN1cnZlLCB7XG4gICAgICAgIG46ICdiaWdpbnQnLFxuICAgICAgICBoOiAnYmlnaW50JyxcbiAgICAgICAgR3g6ICdmaWVsZCcsXG4gICAgICAgIEd5OiAnZmllbGQnLFxuICAgIH0sIHtcbiAgICAgICAgbkJpdExlbmd0aDogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBuQnl0ZUxlbmd0aDogJ2lzU2FmZUludGVnZXInLFxuICAgIH0pO1xuICAgIC8vIFNldCBkZWZhdWx0c1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgLi4uKDAsIG1vZHVsYXJfdHNfMS5uTGVuZ3RoKShjdXJ2ZS5uLCBjdXJ2ZS5uQml0TGVuZ3RoKSxcbiAgICAgICAgLi4uY3VydmUsXG4gICAgICAgIC4uLnsgcDogY3VydmUuRnAuT1JERVIgfSxcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWN1cnZlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIndOQUYiLCJwaXBwZW5nZXIiLCJwcmVjb21wdXRlTVNNVW5zYWZlIiwidmFsaWRhdGVCYXNpYyIsIm1vZHVsYXJfdHNfMSIsInJlcXVpcmUiLCJ1dGlsc190c18xIiwiXzBuIiwiQmlnSW50IiwiXzFuIiwiY29uc3RUaW1lTmVnYXRlIiwiY29uZGl0aW9uIiwiaXRlbSIsIm5lZyIsIm5lZ2F0ZSIsInZhbGlkYXRlVyIsIlciLCJiaXRzIiwiTnVtYmVyIiwiaXNTYWZlSW50ZWdlciIsIkVycm9yIiwiY2FsY1dPcHRzIiwic2NhbGFyQml0cyIsIndpbmRvd3MiLCJNYXRoIiwiY2VpbCIsIndpbmRvd1NpemUiLCJtYXhOdW1iZXIiLCJtYXNrIiwiYml0TWFzayIsInNoaWZ0QnkiLCJjYWxjT2Zmc2V0cyIsIm4iLCJ3aW5kb3ciLCJ3T3B0cyIsIndiaXRzIiwibmV4dE4iLCJvZmZzZXRTdGFydCIsIm9mZnNldCIsImFicyIsImlzWmVybyIsImlzTmVnIiwiaXNOZWdGIiwib2Zmc2V0RiIsInZhbGlkYXRlTVNNUG9pbnRzIiwicG9pbnRzIiwiYyIsIkFycmF5IiwiaXNBcnJheSIsImZvckVhY2giLCJwIiwiaSIsInZhbGlkYXRlTVNNU2NhbGFycyIsInNjYWxhcnMiLCJmaWVsZCIsInMiLCJpc1ZhbGlkIiwicG9pbnRQcmVjb21wdXRlcyIsIldlYWtNYXAiLCJwb2ludFdpbmRvd1NpemVzIiwiZ2V0VyIsIlAiLCJnZXQiLCJoYXNQcmVjb21wdXRlcyIsImVsbSIsInVuc2FmZUxhZGRlciIsIlpFUk8iLCJkIiwiYWRkIiwiZG91YmxlIiwicHJlY29tcHV0ZVdpbmRvdyIsImJhc2UiLCJwdXNoIiwicHJlY29tcHV0ZXMiLCJmIiwiQkFTRSIsIndvIiwid05BRlVuc2FmZSIsImFjYyIsImdldFByZWNvbXB1dGVzIiwidHJhbnNmb3JtIiwiY29tcCIsInNldCIsIndOQUZDYWNoZWQiLCJ3TkFGQ2FjaGVkVW5zYWZlIiwicHJldiIsInNldFdpbmRvd1NpemUiLCJkZWxldGUiLCJmaWVsZE4iLCJwbGVuZ3RoIiwibGVuZ3RoIiwic2xlbmd0aCIsInplcm8iLCJiaXRMZW4iLCJNQVNLIiwiYnVja2V0cyIsImZpbGwiLCJsYXN0Qml0cyIsImZsb29yIiwiQklUUyIsInN1bSIsImoiLCJzY2FsYXIiLCJyZXNJIiwic3VtSSIsInRhYmxlU2l6ZSIsImNodW5rcyIsInRhYmxlcyIsIm1hcCIsInJlcyIsImN1cnIiLCJjdXJ2ZSIsInZhbGlkYXRlRmllbGQiLCJGcCIsInZhbGlkYXRlT2JqZWN0IiwiaCIsIkd4IiwiR3kiLCJuQml0TGVuZ3RoIiwibkJ5dGVMZW5ndGgiLCJmcmVlemUiLCJuTGVuZ3RoIiwiT1JERVIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/@noble/curves/abstract/curve.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/@noble/curves/abstract/hash-to-curve.js":
/*!******************************************************************************!*\
  !*** ./node_modules/ox/node_modules/@noble/curves/abstract/hash-to-curve.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.expand_message_xmd = expand_message_xmd;\nexports.expand_message_xof = expand_message_xof;\nexports.hash_to_field = hash_to_field;\nexports.isogenyMap = isogenyMap;\nexports.createHasher = createHasher;\nconst modular_ts_1 = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/abstract/modular.js\");\nconst utils_ts_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/abstract/utils.js\");\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = utils_ts_1.bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n    anum(value);\n    anum(length);\n    if (value < 0 || value >= 1 << 8 * length) throw new Error(\"invalid I2OSP input: \" + value);\n    const res = Array.from({\n        length\n    }).fill(0);\n    for(let i = length - 1; i >= 0; i--){\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for(let i = 0; i < a.length; i++){\n        arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n}\nfunction anum(item) {\n    if (!Number.isSafeInteger(item)) throw new Error(\"number expected\");\n}\n/**\n * Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits.\n * [RFC 9380 5.3.1](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1).\n */ function expand_message_xmd(msg, DST, lenInBytes, H) {\n    (0, utils_ts_1.abytes)(msg);\n    (0, utils_ts_1.abytes)(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    if (DST.length > 255) DST = H((0, utils_ts_1.concatBytes)((0, utils_ts_1.utf8ToBytes)(\"H2C-OVERSIZE-DST-\"), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (lenInBytes > 65535 || ell > 255) throw new Error(\"expand_message_xmd: invalid lenInBytes\");\n    const DST_prime = (0, utils_ts_1.concatBytes)(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H((0, utils_ts_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H((0, utils_ts_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));\n    for(let i = 1; i <= ell; i++){\n        const args = [\n            strxor(b_0, b[i - 1]),\n            i2osp(i + 1, 1),\n            DST_prime\n        ];\n        b[i] = H((0, utils_ts_1.concatBytes)(...args));\n    }\n    const pseudo_random_bytes = (0, utils_ts_1.concatBytes)(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\n/**\n * Produces a uniformly random byte string using an extendable-output function (XOF) H.\n * 1. The collision resistance of H MUST be at least k bits.\n * 2. H MUST be an XOF that has been proved indifferentiable from\n *    a random oracle under a reasonable cryptographic assumption.\n * [RFC 9380 5.3.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2).\n */ function expand_message_xof(msg, DST, lenInBytes, k, H) {\n    (0, utils_ts_1.abytes)(msg);\n    (0, utils_ts_1.abytes)(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil(2 * k / 8);\n        DST = H.create({\n            dkLen\n        }).update((0, utils_ts_1.utf8ToBytes)(\"H2C-OVERSIZE-DST-\")).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255) throw new Error(\"expand_message_xof: invalid lenInBytes\");\n    return H.create({\n        dkLen: lenInBytes\n    }).update(msg).update(i2osp(lenInBytes, 2))// 2. DST_prime = DST || I2OSP(len(DST), 1)\n    .update(DST).update(i2osp(DST.length, 1)).digest();\n}\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F.\n * [RFC 9380 5.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.2).\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */ function hash_to_field(msg, count, options) {\n    (0, utils_ts_1.validateObject)(options, {\n        DST: \"stringOrUint8Array\",\n        p: \"bigint\",\n        m: \"isSafeInteger\",\n        k: \"isSafeInteger\",\n        hash: \"hash\"\n    });\n    const { p, k, m, hash, expand, DST: _DST } = options;\n    (0, utils_ts_1.abytes)(msg);\n    anum(count);\n    const DST = typeof _DST === \"string\" ? (0, utils_ts_1.utf8ToBytes)(_DST) : _DST;\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === \"xmd\") {\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n    } else if (expand === \"xof\") {\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    } else if (expand === \"_internal_pass\") {\n        // for internal tests only\n        prb = msg;\n    } else {\n        throw new Error('expand must be \"xmd\" or \"xof\"');\n    }\n    const u = new Array(count);\n    for(let i = 0; i < count; i++){\n        const e = new Array(m);\n        for(let j = 0; j < m; j++){\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = (0, modular_ts_1.mod)(os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nfunction isogenyMap(field, map) {\n    // Make same order as in spec\n    const coeff = map.map((i)=>Array.from(i).reverse());\n    return (x, y)=>{\n        const [xn, xd, yn, yd] = coeff.map((val)=>val.reduce((acc, i)=>field.add(field.mul(acc, x), i)));\n        // 6.6.3\n        // Exceptional cases of iso_map are inputs that cause the denominator of\n        // either rational function to evaluate to zero; such cases MUST return\n        // the identity point on E.\n        const [xd_inv, yd_inv] = (0, modular_ts_1.FpInvertBatch)(field, [\n            xd,\n            yd\n        ], true);\n        x = field.mul(xn, xd_inv); // xNum / xDen\n        y = field.mul(y, field.mul(yn, yd_inv)); // y * (yNum / yDev)\n        return {\n            x,\n            y\n        };\n    };\n}\n/** Creates hash-to-curve methods from EC Point and mapToCurve function. */ function createHasher(Point, mapToCurve, defaults) {\n    if (typeof mapToCurve !== \"function\") throw new Error(\"mapToCurve() must be defined\");\n    function map(num) {\n        return Point.fromAffine(mapToCurve(num));\n    }\n    function clear(initial) {\n        const P = initial.clearCofactor();\n        if (P.equals(Point.ZERO)) return Point.ZERO; // zero will throw in assert\n        P.assertValidity();\n        return P;\n    }\n    return {\n        defaults,\n        // Encodes byte string to elliptic curve.\n        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        hashToCurve (msg, options) {\n            const u = hash_to_field(msg, 2, {\n                ...defaults,\n                DST: defaults.DST,\n                ...options\n            });\n            const u0 = map(u[0]);\n            const u1 = map(u[1]);\n            return clear(u0.add(u1));\n        },\n        // Encodes byte string to elliptic curve.\n        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        encodeToCurve (msg, options) {\n            const u = hash_to_field(msg, 1, {\n                ...defaults,\n                DST: defaults.encodeDST,\n                ...options\n            });\n            return clear(map(u[0]));\n        },\n        // Same as encodeToCurve, but without hash\n        mapToCurve (scalars) {\n            if (!Array.isArray(scalars)) throw new Error(\"expected array of bigints\");\n            for (const i of scalars)if (typeof i !== \"bigint\") throw new Error(\"expected array of bigints\");\n            return clear(map(scalars));\n        }\n    };\n} //# sourceMappingURL=hash-to-curve.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvYWJzdHJhY3QvaGFzaC10by1jdXJ2ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsMEJBQTBCLEdBQUdFO0FBQzdCRiwwQkFBMEIsR0FBR0c7QUFDN0JILHFCQUFxQixHQUFHSTtBQUN4Qkosa0JBQWtCLEdBQUdLO0FBQ3JCTCxvQkFBb0IsR0FBR007QUFDdkIsTUFBTUMsZUFBZUMsbUJBQU9BLENBQUMsNEZBQWM7QUFDM0MsTUFBTUMsYUFBYUQsbUJBQU9BLENBQUMsd0ZBQVk7QUFDdkMsNkZBQTZGO0FBQzdGLE1BQU1FLFFBQVFELFdBQVdFLGVBQWU7QUFDeEMsNENBQTRDO0FBQzVDLFNBQVNDLE1BQU1YLEtBQUssRUFBRVksTUFBTTtJQUN4QkMsS0FBS2I7SUFDTGEsS0FBS0Q7SUFDTCxJQUFJWixRQUFRLEtBQUtBLFNBQVMsS0FBTSxJQUFJWSxRQUNoQyxNQUFNLElBQUlFLE1BQU0sMEJBQTBCZDtJQUM5QyxNQUFNZSxNQUFNQyxNQUFNQyxJQUFJLENBQUM7UUFBRUw7SUFBTyxHQUFHTSxJQUFJLENBQUM7SUFDeEMsSUFBSyxJQUFJQyxJQUFJUCxTQUFTLEdBQUdPLEtBQUssR0FBR0EsSUFBSztRQUNsQ0osR0FBRyxDQUFDSSxFQUFFLEdBQUduQixRQUFRO1FBQ2pCQSxXQUFXO0lBQ2Y7SUFDQSxPQUFPLElBQUlvQixXQUFXTDtBQUMxQjtBQUNBLFNBQVNNLE9BQU9DLENBQUMsRUFBRUMsQ0FBQztJQUNoQixNQUFNQyxNQUFNLElBQUlKLFdBQVdFLEVBQUVWLE1BQU07SUFDbkMsSUFBSyxJQUFJTyxJQUFJLEdBQUdBLElBQUlHLEVBQUVWLE1BQU0sRUFBRU8sSUFBSztRQUMvQkssR0FBRyxDQUFDTCxFQUFFLEdBQUdHLENBQUMsQ0FBQ0gsRUFBRSxHQUFHSSxDQUFDLENBQUNKLEVBQUU7SUFD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QUFDRCxVQUNmLE1BQU0sSUFBSS9GLE1BQU07WUFDcEIsS0FBSyxNQUFNSyxLQUFLMEYsUUFDWixJQUFJLE9BQU8xRixNQUFNLFVBQ2IsTUFBTSxJQUFJTCxNQUFNO1lBQ3hCLE9BQU9tRixNQUFNdEIsSUFBSWtDO1FBQ3JCO0lBQ0o7QUFDSixFQUNBLHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsYXctd29ya3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvYWJzdHJhY3QvaGFzaC10by1jdXJ2ZS5qcz9iMzEyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5leHBhbmRfbWVzc2FnZV94bWQgPSBleHBhbmRfbWVzc2FnZV94bWQ7XG5leHBvcnRzLmV4cGFuZF9tZXNzYWdlX3hvZiA9IGV4cGFuZF9tZXNzYWdlX3hvZjtcbmV4cG9ydHMuaGFzaF90b19maWVsZCA9IGhhc2hfdG9fZmllbGQ7XG5leHBvcnRzLmlzb2dlbnlNYXAgPSBpc29nZW55TWFwO1xuZXhwb3J0cy5jcmVhdGVIYXNoZXIgPSBjcmVhdGVIYXNoZXI7XG5jb25zdCBtb2R1bGFyX3RzXzEgPSByZXF1aXJlKFwiLi9tb2R1bGFyLmpzXCIpO1xuY29uc3QgdXRpbHNfdHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuLy8gT2N0ZXQgU3RyZWFtIHRvIEludGVnZXIuIFwic3BlY1wiIGltcGxlbWVudGF0aW9uIG9mIG9zMmlwIGlzIDIuNXggc2xvd2VyIHZzIGJ5dGVzVG9OdW1iZXJCRS5cbmNvbnN0IG9zMmlwID0gdXRpbHNfdHNfMS5ieXRlc1RvTnVtYmVyQkU7XG4vLyBJbnRlZ2VyIHRvIE9jdGV0IFN0cmVhbSAobnVtYmVyVG9CeXRlc0JFKVxuZnVuY3Rpb24gaTJvc3AodmFsdWUsIGxlbmd0aCkge1xuICAgIGFudW0odmFsdWUpO1xuICAgIGFudW0obGVuZ3RoKTtcbiAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID49IDEgPDwgKDggKiBsZW5ndGgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgSTJPU1AgaW5wdXQ6ICcgKyB2YWx1ZSk7XG4gICAgY29uc3QgcmVzID0gQXJyYXkuZnJvbSh7IGxlbmd0aCB9KS5maWxsKDApO1xuICAgIGZvciAobGV0IGkgPSBsZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICByZXNbaV0gPSB2YWx1ZSAmIDB4ZmY7XG4gICAgICAgIHZhbHVlID4+Pj0gODtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHJlcyk7XG59XG5mdW5jdGlvbiBzdHJ4b3IoYSwgYikge1xuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KGEubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gYVtpXSBeIGJbaV07XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG59XG5mdW5jdGlvbiBhbnVtKGl0ZW0pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGl0ZW0pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ251bWJlciBleHBlY3RlZCcpO1xufVxuLyoqXG4gKiBQcm9kdWNlcyBhIHVuaWZvcm1seSByYW5kb20gYnl0ZSBzdHJpbmcgdXNpbmcgYSBjcnlwdG9ncmFwaGljIGhhc2ggZnVuY3Rpb24gSCB0aGF0IG91dHB1dHMgYiBiaXRzLlxuICogW1JGQyA5MzgwIDUuMy4xXShodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMy4xKS5cbiAqL1xuZnVuY3Rpb24gZXhwYW5kX21lc3NhZ2VfeG1kKG1zZywgRFNULCBsZW5JbkJ5dGVzLCBIKSB7XG4gICAgKDAsIHV0aWxzX3RzXzEuYWJ5dGVzKShtc2cpO1xuICAgICgwLCB1dGlsc190c18xLmFieXRlcykoRFNUKTtcbiAgICBhbnVtKGxlbkluQnl0ZXMpO1xuICAgIC8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjNcbiAgICBpZiAoRFNULmxlbmd0aCA+IDI1NSlcbiAgICAgICAgRFNUID0gSCgoMCwgdXRpbHNfdHNfMS5jb25jYXRCeXRlcykoKDAsIHV0aWxzX3RzXzEudXRmOFRvQnl0ZXMpKCdIMkMtT1ZFUlNJWkUtRFNULScpLCBEU1QpKTtcbiAgICBjb25zdCB7IG91dHB1dExlbjogYl9pbl9ieXRlcywgYmxvY2tMZW46IHJfaW5fYnl0ZXMgfSA9IEg7XG4gICAgY29uc3QgZWxsID0gTWF0aC5jZWlsKGxlbkluQnl0ZXMgLyBiX2luX2J5dGVzKTtcbiAgICBpZiAobGVuSW5CeXRlcyA+IDY1NTM1IHx8IGVsbCA+IDI1NSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBhbmRfbWVzc2FnZV94bWQ6IGludmFsaWQgbGVuSW5CeXRlcycpO1xuICAgIGNvbnN0IERTVF9wcmltZSA9ICgwLCB1dGlsc190c18xLmNvbmNhdEJ5dGVzKShEU1QsIGkyb3NwKERTVC5sZW5ndGgsIDEpKTtcbiAgICBjb25zdCBaX3BhZCA9IGkyb3NwKDAsIHJfaW5fYnl0ZXMpO1xuICAgIGNvbnN0IGxfaV9iX3N0ciA9IGkyb3NwKGxlbkluQnl0ZXMsIDIpOyAvLyBsZW5faW5fYnl0ZXNfc3RyXG4gICAgY29uc3QgYiA9IG5ldyBBcnJheShlbGwpO1xuICAgIGNvbnN0IGJfMCA9IEgoKDAsIHV0aWxzX3RzXzEuY29uY2F0Qnl0ZXMpKFpfcGFkLCBtc2csIGxfaV9iX3N0ciwgaTJvc3AoMCwgMSksIERTVF9wcmltZSkpO1xuICAgIGJbMF0gPSBIKCgwLCB1dGlsc190c18xLmNvbmNhdEJ5dGVzKShiXzAsIGkyb3NwKDEsIDEpLCBEU1RfcHJpbWUpKTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBlbGw7IGkrKykge1xuICAgICAgICBjb25zdCBhcmdzID0gW3N0cnhvcihiXzAsIGJbaSAtIDFdKSwgaTJvc3AoaSArIDEsIDEpLCBEU1RfcHJpbWVdO1xuICAgICAgICBiW2ldID0gSCgoMCwgdXRpbHNfdHNfMS5jb25jYXRCeXRlcykoLi4uYXJncykpO1xuICAgIH1cbiAgICBjb25zdCBwc2V1ZG9fcmFuZG9tX2J5dGVzID0gKDAsIHV0aWxzX3RzXzEuY29uY2F0Qnl0ZXMpKC4uLmIpO1xuICAgIHJldHVybiBwc2V1ZG9fcmFuZG9tX2J5dGVzLnNsaWNlKDAsIGxlbkluQnl0ZXMpO1xufVxuLyoqXG4gKiBQcm9kdWNlcyBhIHVuaWZvcm1seSByYW5kb20gYnl0ZSBzdHJpbmcgdXNpbmcgYW4gZXh0ZW5kYWJsZS1vdXRwdXQgZnVuY3Rpb24gKFhPRikgSC5cbiAqIDEuIFRoZSBjb2xsaXNpb24gcmVzaXN0YW5jZSBvZiBIIE1VU1QgYmUgYXQgbGVhc3QgayBiaXRzLlxuICogMi4gSCBNVVNUIGJlIGFuIFhPRiB0aGF0IGhhcyBiZWVuIHByb3ZlZCBpbmRpZmZlcmVudGlhYmxlIGZyb21cbiAqICAgIGEgcmFuZG9tIG9yYWNsZSB1bmRlciBhIHJlYXNvbmFibGUgY3J5cHRvZ3JhcGhpYyBhc3N1bXB0aW9uLlxuICogW1JGQyA5MzgwIDUuMy4yXShodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMy4yKS5cbiAqL1xuZnVuY3Rpb24gZXhwYW5kX21lc3NhZ2VfeG9mKG1zZywgRFNULCBsZW5JbkJ5dGVzLCBrLCBIKSB7XG4gICAgKDAsIHV0aWxzX3RzXzEuYWJ5dGVzKShtc2cpO1xuICAgICgwLCB1dGlsc190c18xLmFieXRlcykoRFNUKTtcbiAgICBhbnVtKGxlbkluQnl0ZXMpO1xuICAgIC8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjNcbiAgICAvLyBEU1QgPSBIKCdIMkMtT1ZFUlNJWkUtRFNULScgfHwgYV92ZXJ5X2xvbmdfRFNULCBNYXRoLmNlaWwoKGxlbkluQnl0ZXMgKiBrKSAvIDgpKTtcbiAgICBpZiAoRFNULmxlbmd0aCA+IDI1NSkge1xuICAgICAgICBjb25zdCBka0xlbiA9IE1hdGguY2VpbCgoMiAqIGspIC8gOCk7XG4gICAgICAgIERTVCA9IEguY3JlYXRlKHsgZGtMZW4gfSkudXBkYXRlKCgwLCB1dGlsc190c18xLnV0ZjhUb0J5dGVzKSgnSDJDLU9WRVJTSVpFLURTVC0nKSkudXBkYXRlKERTVCkuZGlnZXN0KCk7XG4gICAgfVxuICAgIGlmIChsZW5JbkJ5dGVzID4gNjU1MzUgfHwgRFNULmxlbmd0aCA+IDI1NSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBhbmRfbWVzc2FnZV94b2Y6IGludmFsaWQgbGVuSW5CeXRlcycpO1xuICAgIHJldHVybiAoSC5jcmVhdGUoeyBka0xlbjogbGVuSW5CeXRlcyB9KVxuICAgICAgICAudXBkYXRlKG1zZylcbiAgICAgICAgLnVwZGF0ZShpMm9zcChsZW5JbkJ5dGVzLCAyKSlcbiAgICAgICAgLy8gMi4gRFNUX3ByaW1lID0gRFNUIHx8IEkyT1NQKGxlbihEU1QpLCAxKVxuICAgICAgICAudXBkYXRlKERTVClcbiAgICAgICAgLnVwZGF0ZShpMm9zcChEU1QubGVuZ3RoLCAxKSlcbiAgICAgICAgLmRpZ2VzdCgpKTtcbn1cbi8qKlxuICogSGFzaGVzIGFyYml0cmFyeS1sZW5ndGggYnl0ZSBzdHJpbmdzIHRvIGEgbGlzdCBvZiBvbmUgb3IgbW9yZSBlbGVtZW50cyBvZiBhIGZpbml0ZSBmaWVsZCBGLlxuICogW1JGQyA5MzgwIDUuMl0oaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjIpLlxuICogQHBhcmFtIG1zZyBhIGJ5dGUgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIG1lc3NhZ2UgdG8gaGFzaFxuICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgZWxlbWVudHMgb2YgRiB0byBvdXRwdXRcbiAqIEBwYXJhbSBvcHRpb25zIGB7RFNUOiBzdHJpbmcsIHA6IGJpZ2ludCwgbTogbnVtYmVyLCBrOiBudW1iZXIsIGV4cGFuZDogJ3htZCcgfCAneG9mJywgaGFzaDogSH1gLCBzZWUgYWJvdmVcbiAqIEByZXR1cm5zIFt1XzAsIC4uLiwgdV8oY291bnQgLSAxKV0sIGEgbGlzdCBvZiBmaWVsZCBlbGVtZW50cy5cbiAqL1xuZnVuY3Rpb24gaGFzaF90b19maWVsZChtc2csIGNvdW50LCBvcHRpb25zKSB7XG4gICAgKDAsIHV0aWxzX3RzXzEudmFsaWRhdGVPYmplY3QpKG9wdGlvbnMsIHtcbiAgICAgICAgRFNUOiAnc3RyaW5nT3JVaW50OEFycmF5JyxcbiAgICAgICAgcDogJ2JpZ2ludCcsXG4gICAgICAgIG06ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgazogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBoYXNoOiAnaGFzaCcsXG4gICAgfSk7XG4gICAgY29uc3QgeyBwLCBrLCBtLCBoYXNoLCBleHBhbmQsIERTVDogX0RTVCB9ID0gb3B0aW9ucztcbiAgICAoMCwgdXRpbHNfdHNfMS5hYnl0ZXMpKG1zZyk7XG4gICAgYW51bShjb3VudCk7XG4gICAgY29uc3QgRFNUID0gdHlwZW9mIF9EU1QgPT09ICdzdHJpbmcnID8gKDAsIHV0aWxzX3RzXzEudXRmOFRvQnl0ZXMpKF9EU1QpIDogX0RTVDtcbiAgICBjb25zdCBsb2cycCA9IHAudG9TdHJpbmcoMikubGVuZ3RoO1xuICAgIGNvbnN0IEwgPSBNYXRoLmNlaWwoKGxvZzJwICsgaykgLyA4KTsgLy8gc2VjdGlvbiA1LjEgb2YgaWV0ZiBkcmFmdCBsaW5rIGFib3ZlXG4gICAgY29uc3QgbGVuX2luX2J5dGVzID0gY291bnQgKiBtICogTDtcbiAgICBsZXQgcHJiOyAvLyBwc2V1ZG9fcmFuZG9tX2J5dGVzXG4gICAgaWYgKGV4cGFuZCA9PT0gJ3htZCcpIHtcbiAgICAgICAgcHJiID0gZXhwYW5kX21lc3NhZ2VfeG1kKG1zZywgRFNULCBsZW5faW5fYnl0ZXMsIGhhc2gpO1xuICAgIH1cbiAgICBlbHNlIGlmIChleHBhbmQgPT09ICd4b2YnKSB7XG4gICAgICAgIHByYiA9IGV4cGFuZF9tZXNzYWdlX3hvZihtc2csIERTVCwgbGVuX2luX2J5dGVzLCBrLCBoYXNoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXhwYW5kID09PSAnX2ludGVybmFsX3Bhc3MnKSB7XG4gICAgICAgIC8vIGZvciBpbnRlcm5hbCB0ZXN0cyBvbmx5XG4gICAgICAgIHByYiA9IG1zZztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwYW5kIG11c3QgYmUgXCJ4bWRcIiBvciBcInhvZlwiJyk7XG4gICAgfVxuICAgIGNvbnN0IHUgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICBjb25zdCBlID0gbmV3IEFycmF5KG0pO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG07IGorKykge1xuICAgICAgICAgICAgY29uc3QgZWxtX29mZnNldCA9IEwgKiAoaiArIGkgKiBtKTtcbiAgICAgICAgICAgIGNvbnN0IHR2ID0gcHJiLnN1YmFycmF5KGVsbV9vZmZzZXQsIGVsbV9vZmZzZXQgKyBMKTtcbiAgICAgICAgICAgIGVbal0gPSAoMCwgbW9kdWxhcl90c18xLm1vZCkob3MyaXAodHYpLCBwKTtcbiAgICAgICAgfVxuICAgICAgICB1W2ldID0gZTtcbiAgICB9XG4gICAgcmV0dXJuIHU7XG59XG5mdW5jdGlvbiBpc29nZW55TWFwKGZpZWxkLCBtYXApIHtcbiAgICAvLyBNYWtlIHNhbWUgb3JkZXIgYXMgaW4gc3BlY1xuICAgIGNvbnN0IGNvZWZmID0gbWFwLm1hcCgoaSkgPT4gQXJyYXkuZnJvbShpKS5yZXZlcnNlKCkpO1xuICAgIHJldHVybiAoeCwgeSkgPT4ge1xuICAgICAgICBjb25zdCBbeG4sIHhkLCB5biwgeWRdID0gY29lZmYubWFwKCh2YWwpID0+IHZhbC5yZWR1Y2UoKGFjYywgaSkgPT4gZmllbGQuYWRkKGZpZWxkLm11bChhY2MsIHgpLCBpKSkpO1xuICAgICAgICAvLyA2LjYuM1xuICAgICAgICAvLyBFeGNlcHRpb25hbCBjYXNlcyBvZiBpc29fbWFwIGFyZSBpbnB1dHMgdGhhdCBjYXVzZSB0aGUgZGVub21pbmF0b3Igb2ZcbiAgICAgICAgLy8gZWl0aGVyIHJhdGlvbmFsIGZ1bmN0aW9uIHRvIGV2YWx1YXRlIHRvIHplcm87IHN1Y2ggY2FzZXMgTVVTVCByZXR1cm5cbiAgICAgICAgLy8gdGhlIGlkZW50aXR5IHBvaW50IG9uIEUuXG4gICAgICAgIGNvbnN0IFt4ZF9pbnYsIHlkX2ludl0gPSAoMCwgbW9kdWxhcl90c18xLkZwSW52ZXJ0QmF0Y2gpKGZpZWxkLCBbeGQsIHlkXSwgdHJ1ZSk7XG4gICAgICAgIHggPSBmaWVsZC5tdWwoeG4sIHhkX2ludik7IC8vIHhOdW0gLyB4RGVuXG4gICAgICAgIHkgPSBmaWVsZC5tdWwoeSwgZmllbGQubXVsKHluLCB5ZF9pbnYpKTsgLy8geSAqICh5TnVtIC8geURldilcbiAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgIH07XG59XG4vKiogQ3JlYXRlcyBoYXNoLXRvLWN1cnZlIG1ldGhvZHMgZnJvbSBFQyBQb2ludCBhbmQgbWFwVG9DdXJ2ZSBmdW5jdGlvbi4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUhhc2hlcihQb2ludCwgbWFwVG9DdXJ2ZSwgZGVmYXVsdHMpIHtcbiAgICBpZiAodHlwZW9mIG1hcFRvQ3VydmUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWFwVG9DdXJ2ZSgpIG11c3QgYmUgZGVmaW5lZCcpO1xuICAgIGZ1bmN0aW9uIG1hcChudW0pIHtcbiAgICAgICAgcmV0dXJuIFBvaW50LmZyb21BZmZpbmUobWFwVG9DdXJ2ZShudW0pKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xlYXIoaW5pdGlhbCkge1xuICAgICAgICBjb25zdCBQID0gaW5pdGlhbC5jbGVhckNvZmFjdG9yKCk7XG4gICAgICAgIGlmIChQLmVxdWFscyhQb2ludC5aRVJPKSlcbiAgICAgICAgICAgIHJldHVybiBQb2ludC5aRVJPOyAvLyB6ZXJvIHdpbGwgdGhyb3cgaW4gYXNzZXJ0XG4gICAgICAgIFAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgcmV0dXJuIFA7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGRlZmF1bHRzLFxuICAgICAgICAvLyBFbmNvZGVzIGJ5dGUgc3RyaW5nIHRvIGVsbGlwdGljIGN1cnZlLlxuICAgICAgICAvLyBoYXNoX3RvX2N1cnZlIGZyb20gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi0zXG4gICAgICAgIGhhc2hUb0N1cnZlKG1zZywgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgdSA9IGhhc2hfdG9fZmllbGQobXNnLCAyLCB7IC4uLmRlZmF1bHRzLCBEU1Q6IGRlZmF1bHRzLkRTVCwgLi4ub3B0aW9ucyB9KTtcbiAgICAgICAgICAgIGNvbnN0IHUwID0gbWFwKHVbMF0pO1xuICAgICAgICAgICAgY29uc3QgdTEgPSBtYXAodVsxXSk7XG4gICAgICAgICAgICByZXR1cm4gY2xlYXIodTAuYWRkKHUxKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEVuY29kZXMgYnl0ZSBzdHJpbmcgdG8gZWxsaXB0aWMgY3VydmUuXG4gICAgICAgIC8vIGVuY29kZV90b19jdXJ2ZSBmcm9tIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tM1xuICAgICAgICBlbmNvZGVUb0N1cnZlKG1zZywgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgdSA9IGhhc2hfdG9fZmllbGQobXNnLCAxLCB7IC4uLmRlZmF1bHRzLCBEU1Q6IGRlZmF1bHRzLmVuY29kZURTVCwgLi4ub3B0aW9ucyB9KTtcbiAgICAgICAgICAgIHJldHVybiBjbGVhcihtYXAodVswXSkpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBTYW1lIGFzIGVuY29kZVRvQ3VydmUsIGJ1dCB3aXRob3V0IGhhc2hcbiAgICAgICAgbWFwVG9DdXJ2ZShzY2FsYXJzKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NhbGFycykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCBhcnJheSBvZiBiaWdpbnRzJyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGkgb2Ygc2NhbGFycylcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGkgIT09ICdiaWdpbnQnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIGFycmF5IG9mIGJpZ2ludHMnKTtcbiAgICAgICAgICAgIHJldHVybiBjbGVhcihtYXAoc2NhbGFycykpO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXNoLXRvLWN1cnZlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImV4cGFuZF9tZXNzYWdlX3htZCIsImV4cGFuZF9tZXNzYWdlX3hvZiIsImhhc2hfdG9fZmllbGQiLCJpc29nZW55TWFwIiwiY3JlYXRlSGFzaGVyIiwibW9kdWxhcl90c18xIiwicmVxdWlyZSIsInV0aWxzX3RzXzEiLCJvczJpcCIsImJ5dGVzVG9OdW1iZXJCRSIsImkyb3NwIiwibGVuZ3RoIiwiYW51bSIsIkVycm9yIiwicmVzIiwiQXJyYXkiLCJmcm9tIiwiZmlsbCIsImkiLCJVaW50OEFycmF5Iiwic3RyeG9yIiwiYSIsImIiLCJhcnIiLCJpdGVtIiwiTnVtYmVyIiwiaXNTYWZlSW50ZWdlciIsIm1zZyIsIkRTVCIsImxlbkluQnl0ZXMiLCJIIiwiYWJ5dGVzIiwiY29uY2F0Qnl0ZXMiLCJ1dGY4VG9CeXRlcyIsIm91dHB1dExlbiIsImJfaW5fYnl0ZXMiLCJibG9ja0xlbiIsInJfaW5fYnl0ZXMiLCJlbGwiLCJNYXRoIiwiY2VpbCIsIkRTVF9wcmltZSIsIlpfcGFkIiwibF9pX2Jfc3RyIiwiYl8wIiwiYXJncyIsInBzZXVkb19yYW5kb21fYnl0ZXMiLCJzbGljZSIsImsiLCJka0xlbiIsImNyZWF0ZSIsInVwZGF0ZSIsImRpZ2VzdCIsImNvdW50Iiwib3B0aW9ucyIsInZhbGlkYXRlT2JqZWN0IiwicCIsIm0iLCJoYXNoIiwiZXhwYW5kIiwiX0RTVCIsImxvZzJwIiwidG9TdHJpbmciLCJMIiwibGVuX2luX2J5dGVzIiwicHJiIiwidSIsImUiLCJqIiwiZWxtX29mZnNldCIsInR2Iiwic3ViYXJyYXkiLCJtb2QiLCJmaWVsZCIsIm1hcCIsImNvZWZmIiwicmV2ZXJzZSIsIngiLCJ5IiwieG4iLCJ4ZCIsInluIiwieWQiLCJ2YWwiLCJyZWR1Y2UiLCJhY2MiLCJhZGQiLCJtdWwiLCJ4ZF9pbnYiLCJ5ZF9pbnYiLCJGcEludmVydEJhdGNoIiwiUG9pbnQiLCJtYXBUb0N1cnZlIiwiZGVmYXVsdHMiLCJudW0iLCJmcm9tQWZmaW5lIiwiY2xlYXIiLCJpbml0aWFsIiwiUCIsImNsZWFyQ29mYWN0b3IiLCJlcXVhbHMiLCJaRVJPIiwiYXNzZXJ0VmFsaWRpdHkiLCJoYXNoVG9DdXJ2ZSIsInUwIiwidTEiLCJlbmNvZGVUb0N1cnZlIiwiZW5jb2RlRFNUIiwic2NhbGFycyIsImlzQXJyYXkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/@noble/curves/abstract/hash-to-curve.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/@noble/curves/abstract/modular.js":
/*!************************************************************************!*\
  !*** ./node_modules/ox/node_modules/@noble/curves/abstract/modular.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.isNegativeLE = void 0;\nexports.mod = mod;\nexports.pow = pow;\nexports.pow2 = pow2;\nexports.invert = invert;\nexports.tonelliShanks = tonelliShanks;\nexports.FpSqrt = FpSqrt;\nexports.validateField = validateField;\nexports.FpPow = FpPow;\nexports.FpInvertBatch = FpInvertBatch;\nexports.FpDiv = FpDiv;\nexports.FpLegendre = FpLegendre;\nexports.FpIsSquare = FpIsSquare;\nexports.nLength = nLength;\nexports.Field = Field;\nexports.FpSqrtOdd = FpSqrtOdd;\nexports.FpSqrtEven = FpSqrtEven;\nexports.hashToPrivateScalar = hashToPrivateScalar;\nexports.getFieldBytesLength = getFieldBytesLength;\nexports.getMinHashLength = getMinHashLength;\nexports.mapHashToField = mapHashToField;\n/**\n * Utils for modular division and finite fields.\n * A finite field over 11 is integer number operations `mod 11`.\n * There is no division: it is replaced by modular multiplicative inverse.\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const utils_1 = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/utils.js\");\nconst utils_ts_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/abstract/utils.js\");\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = /* @__PURE__ */ BigInt(2), _3n = /* @__PURE__ */ BigInt(3);\n// prettier-ignore\nconst _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5), _8n = /* @__PURE__ */ BigInt(8);\n// Calculates a modulo b\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * TODO: remove.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */ function pow(num, power, modulo) {\n    return FpPow(Field(modulo), num, power);\n}\n/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */ function pow2(x, power, modulo) {\n    let res = x;\n    while(power-- > _0n){\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n/**\n * Inverses number over modulo.\n * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).\n */ function invert(number, modulo) {\n    if (number === _0n) throw new Error(\"invert: expected non-zero number\");\n    if (modulo <= _0n) throw new Error(\"invert: expected positive modulus, got \" + modulo);\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while(a !== _0n){\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n) throw new Error(\"invert: does not exist\");\n    return mod(x, modulo);\n}\n// Not all roots are possible! Example which will throw:\n// const NUM =\n// n = 72057594037927816n;\n// Fp = Field(BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab'));\nfunction sqrt3mod4(Fp, n) {\n    const p1div4 = (Fp.ORDER + _1n) / _4n;\n    const root = Fp.pow(n, p1div4);\n    // Throw if root^2 != n\n    if (!Fp.eql(Fp.sqr(root), n)) throw new Error(\"Cannot find square root\");\n    return root;\n}\nfunction sqrt5mod8(Fp, n) {\n    const p5div8 = (Fp.ORDER - _5n) / _8n;\n    const n2 = Fp.mul(n, _2n);\n    const v = Fp.pow(n2, p5div8);\n    const nv = Fp.mul(n, v);\n    const i = Fp.mul(Fp.mul(nv, _2n), v);\n    const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n    if (!Fp.eql(Fp.sqr(root), n)) throw new Error(\"Cannot find square root\");\n    return root;\n}\n// TODO: Commented-out for now. Provide test vectors.\n// Tonelli is too slow for extension fields Fp2.\n// That means we can't use sqrt (c1, c2...) even for initialization constants.\n// if (P % _16n === _9n) return sqrt9mod16;\n// // prettier-ignore\n// function sqrt9mod16<T>(Fp: IField<T>, n: T, p7div16?: bigint) {\n//   if (p7div16 === undefined) p7div16 = (Fp.ORDER + BigInt(7)) / _16n;\n//   const c1 = Fp.sqrt(Fp.neg(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n//   const c2 = Fp.sqrt(c1);             //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n//   const c3 = Fp.sqrt(Fp.neg(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n//   const c4 = p7div16;                 //  4. c4 = (q + 7) / 16        # Integer arithmetic\n//   let tv1 = Fp.pow(n, c4);            //  1. tv1 = x^c4\n//   let tv2 = Fp.mul(c1, tv1);          //  2. tv2 = c1 * tv1\n//   const tv3 = Fp.mul(c2, tv1);        //  3. tv3 = c2 * tv1\n//   let tv4 = Fp.mul(c3, tv1);          //  4. tv4 = c3 * tv1\n//   const e1 = Fp.eql(Fp.sqr(tv2), n);  //  5.  e1 = (tv2^2) == x\n//   const e2 = Fp.eql(Fp.sqr(tv3), n);  //  6.  e2 = (tv3^2) == x\n//   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n//   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n//   const e3 = Fp.eql(Fp.sqr(tv2), n);  //  9.  e3 = (tv2^2) == x\n//   return Fp.cmov(tv1, tv2, e3); // 10.  z = CMOV(tv1, tv2, e3) # Select the sqrt from tv1 and tv2\n// }\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */ function tonelliShanks(P) {\n    // Initialization (precomputation).\n    if (P < BigInt(3)) throw new Error(\"sqrt is not defined for small field\");\n    // Factor P - 1 = Q * 2^S, where Q is odd\n    let Q = P - _1n;\n    let S = 0;\n    while(Q % _2n === _0n){\n        Q /= _2n;\n        S++;\n    }\n    // Find the first quadratic non-residue Z >= 2\n    let Z = _2n;\n    const _Fp = Field(P);\n    while(FpLegendre(_Fp, Z) === 1){\n        // Basic primality test for P. After x iterations, chance of\n        // not finding quadratic non-residue is 2^x, so 2^1000.\n        if (Z++ > 1000) throw new Error(\"Cannot find square root: probably non-prime P\");\n    }\n    // Fast-path; usually done before Z, but we do \"primality test\".\n    if (S === 1) return sqrt3mod4;\n    // Slow-path\n    // TODO: test on Fp2 and others\n    let cc = _Fp.pow(Z, Q); // c = z^Q\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        if (Fp.is0(n)) return n;\n        // Check if n is a quadratic residue using Legendre symbol\n        if (FpLegendre(Fp, n) !== 1) throw new Error(\"Cannot find square root\");\n        // Initialize variables for the main loop\n        let M = S;\n        let c = Fp.mul(Fp.ONE, cc); // c = z^Q, move cc from field _Fp into field Fp\n        let t = Fp.pow(n, Q); // t = n^Q, first guess at the fudge factor\n        let R = Fp.pow(n, Q1div2); // R = n^((Q+1)/2), first guess at the square root\n        // Main loop\n        // while t != 1\n        while(!Fp.eql(t, Fp.ONE)){\n            if (Fp.is0(t)) return Fp.ZERO; // if t=0 return R=0\n            let i = 1;\n            // Find the smallest i >= 1 such that t^(2^i) ‚â° 1 (mod P)\n            let t_tmp = Fp.sqr(t); // t^(2^1)\n            while(!Fp.eql(t_tmp, Fp.ONE)){\n                i++;\n                t_tmp = Fp.sqr(t_tmp); // t^(2^2)...\n                if (i === M) throw new Error(\"Cannot find square root\");\n            }\n            // Calculate the exponent for b: 2^(M - i - 1)\n            const exponent = _1n << BigInt(M - i - 1); // bigint is important\n            const b = Fp.pow(c, exponent); // b = 2^(M - i - 1)\n            // Update variables\n            M = i;\n            c = Fp.sqr(b); // c = b^2\n            t = Fp.mul(t, c); // t = (t * b^2)\n            R = Fp.mul(R, b); // R = R*b\n        }\n        return R;\n    };\n}\n/**\n * Square root for a finite field. Will try optimized versions first:\n *\n * 1. P ‚â° 3 (mod 4)\n * 2. P ‚â° 5 (mod 8)\n * 3. Tonelli-Shanks algorithm\n *\n * Different algorithms can give different roots, it is up to user to decide which one they want.\n * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n */ function FpSqrt(P) {\n    // P ‚â° 3 (mod 4) => ‚àön = n^((P+1)/4)\n    if (P % _4n === _3n) return sqrt3mod4;\n    // P ‚â° 5 (mod 8) => Atkin algorithm, page 10 of https://eprint.iacr.org/2012/685.pdf\n    if (P % _8n === _5n) return sqrt5mod8;\n    // P ‚â° 9 (mod 16) not implemented, see above\n    // Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nconst isNegativeLE = (num, modulo)=>(mod(num, modulo) & _1n) === _1n;\nexports.isNegativeLE = isNegativeLE;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    \"create\",\n    \"isValid\",\n    \"is0\",\n    \"neg\",\n    \"inv\",\n    \"sqrt\",\n    \"sqr\",\n    \"eql\",\n    \"add\",\n    \"sub\",\n    \"mul\",\n    \"pow\",\n    \"div\",\n    \"addN\",\n    \"subN\",\n    \"mulN\",\n    \"sqrN\"\n];\nfunction validateField(field) {\n    const initial = {\n        ORDER: \"bigint\",\n        MASK: \"bigint\",\n        BYTES: \"isSafeInteger\",\n        BITS: \"isSafeInteger\"\n    };\n    const opts = FIELD_FIELDS.reduce((map, val)=>{\n        map[val] = \"function\";\n        return map;\n    }, initial);\n    return (0, utils_ts_1.validateObject)(field, opts);\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */ function FpPow(Fp, num, power) {\n    if (power < _0n) throw new Error(\"invalid exponent, negatives unsupported\");\n    if (power === _0n) return Fp.ONE;\n    if (power === _1n) return num;\n    let p = Fp.ONE;\n    let d = num;\n    while(power > _0n){\n        if (power & _1n) p = Fp.mul(p, d);\n        d = Fp.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * Exception-free. Will return `undefined` for 0 elements.\n * @param passZero map 0 to 0 (instead of undefined)\n */ function FpInvertBatch(Fp, nums, passZero = false) {\n    const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : undefined);\n    // Walk from first to last, multiply them by each other MOD p\n    const multipliedAcc = nums.reduce((acc, num, i)=>{\n        if (Fp.is0(num)) return acc;\n        inverted[i] = acc;\n        return Fp.mul(acc, num);\n    }, Fp.ONE);\n    // Invert last element\n    const invertedAcc = Fp.inv(multipliedAcc);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i)=>{\n        if (Fp.is0(num)) return acc;\n        inverted[i] = Fp.mul(acc, inverted[i]);\n        return Fp.mul(acc, num);\n    }, invertedAcc);\n    return inverted;\n}\n// TODO: remove\nfunction FpDiv(Fp, lhs, rhs) {\n    return Fp.mul(lhs, typeof rhs === \"bigint\" ? invert(rhs, Fp.ORDER) : Fp.inv(rhs));\n}\n/**\n * Legendre symbol.\n * Legendre constant is used to calculate Legendre symbol (a | p)\n * which denotes the value of a^((p-1)/2) (mod p).\n *\n * * (a | p) ‚â° 1    if a is a square (mod p), quadratic residue\n * * (a | p) ‚â° -1   if a is not a square (mod p), quadratic non residue\n * * (a | p) ‚â° 0    if a ‚â° 0 (mod p)\n */ function FpLegendre(Fp, n) {\n    // We can use 3rd argument as optional cache of this value\n    // but seems unneeded for now. The operation is very fast.\n    const p1mod2 = (Fp.ORDER - _1n) / _2n;\n    const powered = Fp.pow(n, p1mod2);\n    const yes = Fp.eql(powered, Fp.ONE);\n    const zero = Fp.eql(powered, Fp.ZERO);\n    const no = Fp.eql(powered, Fp.neg(Fp.ONE));\n    if (!yes && !zero && !no) throw new Error(\"invalid Legendre symbol result\");\n    return yes ? 1 : zero ? 0 : -1;\n}\n// This function returns True whenever the value x is a square in the field F.\nfunction FpIsSquare(Fp, n) {\n    const l = FpLegendre(Fp, n);\n    return l === 1;\n}\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    if (nBitLength !== undefined) (0, utils_1.anumber)(nBitLength);\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return {\n        nBitLength: _nBitLength,\n        nByteLength\n    };\n}\n/**\n * Initializes a finite field over prime.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * Fragile: always run a benchmark on a change.\n * Security note: operations don't check 'isValid' for all elements for performance reasons,\n * it is caller responsibility to check this.\n * This is low-level code, please make sure you know what you're doing.\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */ function Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n) throw new Error(\"invalid field: expected ORDER > 0, got \" + ORDER);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048) throw new Error(\"invalid field: expected ORDER of <= 2048 bytes\");\n    let sqrtP; // cached sqrtP\n    const f = Object.freeze({\n        ORDER,\n        isLE,\n        BITS,\n        BYTES,\n        MASK: (0, utils_ts_1.bitMask)(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num)=>mod(num, ORDER),\n        isValid: (num)=>{\n            if (typeof num !== \"bigint\") throw new Error(\"invalid field element: expected bigint, got \" + typeof num);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num)=>num === _0n,\n        isOdd: (num)=>(num & _1n) === _1n,\n        neg: (num)=>mod(-num, ORDER),\n        eql: (lhs, rhs)=>lhs === rhs,\n        sqr: (num)=>mod(num * num, ORDER),\n        add: (lhs, rhs)=>mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs)=>mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs)=>mod(lhs * rhs, ORDER),\n        pow: (num, power)=>FpPow(f, num, power),\n        div: (lhs, rhs)=>mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num)=>num * num,\n        addN: (lhs, rhs)=>lhs + rhs,\n        subN: (lhs, rhs)=>lhs - rhs,\n        mulN: (lhs, rhs)=>lhs * rhs,\n        inv: (num)=>invert(num, ORDER),\n        sqrt: redef.sqrt || ((n)=>{\n            if (!sqrtP) sqrtP = FpSqrt(ORDER);\n            return sqrtP(f, n);\n        }),\n        toBytes: (num)=>isLE ? (0, utils_ts_1.numberToBytesLE)(num, BYTES) : (0, utils_ts_1.numberToBytesBE)(num, BYTES),\n        fromBytes: (bytes)=>{\n            if (bytes.length !== BYTES) throw new Error(\"Field.fromBytes: expected \" + BYTES + \" bytes, got \" + bytes.length);\n            return isLE ? (0, utils_ts_1.bytesToNumberLE)(bytes) : (0, utils_ts_1.bytesToNumberBE)(bytes);\n        },\n        // TODO: we don't need it here, move out to separate fn\n        invertBatch: (lst)=>FpInvertBatch(f, lst),\n        // We can't move this out because Fp6, Fp12 implement it\n        // and it's unclear what to return in there.\n        cmov: (a, b, c)=>c ? b : a\n    });\n    return Object.freeze(f);\n}\nfunction FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nfunction FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use `mapKeyToField` instead\n */ function hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = (0, utils_ts_1.ensureBytes)(\"privateHash\", hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024) throw new Error(\"hashToPrivateScalar: expected \" + minLen + \"-1024 bytes of input, got \" + hashLen);\n    const num = isLE ? (0, utils_ts_1.bytesToNumberLE)(hash) : (0, utils_ts_1.bytesToNumberBE)(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */ function getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== \"bigint\") throw new Error(\"field order must be bigint\");\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */ function getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */ function mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024) throw new Error(\"expected \" + minLen + \"-1024 bytes of input, got \" + len);\n    const num = isLE ? (0, utils_ts_1.bytesToNumberLE)(key) : (0, utils_ts_1.bytesToNumberBE)(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? (0, utils_ts_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_ts_1.numberToBytesBE)(reduced, fieldLen);\n} //# sourceMappingURL=modular.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvYWJzdHJhY3QvbW9kdWxhci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsb0JBQW9CLEdBQUcsS0FBSztBQUM1QkEsV0FBVyxHQUFHRztBQUNkSCxXQUFXLEdBQUdJO0FBQ2RKLFlBQVksR0FBR0s7QUFDZkwsY0FBYyxHQUFHTTtBQUNqQk4scUJBQXFCLEdBQUdPO0FBQ3hCUCxjQUFjLEdBQUdRO0FBQ2pCUixxQkFBcUIsR0FBR1M7QUFDeEJULGFBQWEsR0FBR1U7QUFDaEJWLHFCQUFxQixHQUFHVztBQUN4QlgsYUFBYSxHQUFHWTtBQUNoQlosa0JBQWtCLEdBQUdhO0FBQ3JCYixrQkFBa0IsR0FBR2M7QUFDckJkLGVBQWUsR0FBR2U7QUFDbEJmLGFBQWEsR0FBR2dCO0FBQ2hCaEIsaUJBQWlCLEdBQUdpQjtBQUNwQmpCLGtCQUFrQixHQUFHa0I7QUFDckJsQiwyQkFBMkIsR0FBR21CO0FBQzlCbkIsMkJBQTJCLEdBQUdvQjtBQUM5QnBCLHdCQUF3QixHQUFHcUI7QUFDM0JyQixzQkFBc0IsR0FBR3NCO0FBQ3pCOzs7OztDQUtDLEdBQ0Qsb0VBQW9FLEdBQ3BFLE1BQU1DLFVBQVVDLG1CQUFPQSxDQUFDLHdGQUFxQjtBQUM3QyxNQUFNQyxhQUFhRCxtQkFBT0EsQ0FBQyx3RkFBWTtBQUN2QyxrQkFBa0I7QUFDbEIsTUFBTUUsTUFBTUMsT0FBTyxJQUFJQyxNQUFNRCxPQUFPLElBQUlFLE1BQU0sYUFBYSxHQUFHRixPQUFPLElBQUlHLE1BQU0sYUFBYSxHQUFHSCxPQUFPO0FBQ3RHLGtCQUFrQjtBQUNsQixNQUFNSSxNQUFNLGFBQWEsR0FBR0osT0FBTyxJQUFJSyxNQUFNLGFBQWEsR0FBR0wsT0FBTyxJQUFJTSxNQUFNLGFBQWEsR0FBR04sT0FBTztBQUNyRyx3QkFBd0I7QUFDeEIsU0FBU3hCLElB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QUFNO0lBQy9DLE9BQU9zQixLQUFLQyxJQUFJLENBQUNtQyxZQUFZO0FBQ2pDO0FBQ0E7Ozs7OztDQU1DLEdBQ0QsU0FBU3pJLGlCQUFpQndJLFVBQVU7SUFDaEMsTUFBTXpELFNBQVNoRixvQkFBb0J5STtJQUNuQyxPQUFPekQsU0FBU3NCLEtBQUtDLElBQUksQ0FBQ3ZCLFNBQVM7QUFDdkM7QUFDQTs7Ozs7Ozs7Ozs7O0NBWUMsR0FDRCxTQUFTOUUsZUFBZXlJLEdBQUcsRUFBRUYsVUFBVSxFQUFFaEMsT0FBTyxLQUFLO0lBQ2pELE1BQU1tQyxNQUFNRCxJQUFJM0QsTUFBTTtJQUN0QixNQUFNNkQsV0FBVzdJLG9CQUFvQnlJO0lBQ3JDLE1BQU1ELFNBQVN2SSxpQkFBaUJ3STtJQUNoQyxpR0FBaUc7SUFDakcsSUFBSUcsTUFBTSxNQUFNQSxNQUFNSixVQUFVSSxNQUFNLE1BQ2xDLE1BQU0sSUFBSXJILE1BQU0sY0FBY2lILFNBQVMsK0JBQStCSTtJQUMxRSxNQUFNM0gsTUFBTXdGLE9BQU8sQ0FBQyxHQUFHcEcsV0FBV3lILGVBQWUsRUFBRWEsT0FBTyxDQUFDLEdBQUd0SSxXQUFXMEgsZUFBZSxFQUFFWTtJQUMxRiwrRUFBK0U7SUFDL0UsTUFBTUcsVUFBVS9KLElBQUlrQyxLQUFLd0gsYUFBYWpJLE9BQU9BO0lBQzdDLE9BQU9pRyxPQUFPLENBQUMsR0FBR3BHLFdBQVdxSCxlQUFlLEVBQUVvQixTQUFTRCxZQUFZLENBQUMsR0FBR3hJLFdBQVdzSCxlQUFlLEVBQUVtQixTQUFTRDtBQUNoSCxFQUNBLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsYXctd29ya3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvYWJzdHJhY3QvbW9kdWxhci5qcz8xNTEyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc05lZ2F0aXZlTEUgPSB2b2lkIDA7XG5leHBvcnRzLm1vZCA9IG1vZDtcbmV4cG9ydHMucG93ID0gcG93O1xuZXhwb3J0cy5wb3cyID0gcG93MjtcbmV4cG9ydHMuaW52ZXJ0ID0gaW52ZXJ0O1xuZXhwb3J0cy50b25lbGxpU2hhbmtzID0gdG9uZWxsaVNoYW5rcztcbmV4cG9ydHMuRnBTcXJ0ID0gRnBTcXJ0O1xuZXhwb3J0cy52YWxpZGF0ZUZpZWxkID0gdmFsaWRhdGVGaWVsZDtcbmV4cG9ydHMuRnBQb3cgPSBGcFBvdztcbmV4cG9ydHMuRnBJbnZlcnRCYXRjaCA9IEZwSW52ZXJ0QmF0Y2g7XG5leHBvcnRzLkZwRGl2ID0gRnBEaXY7XG5leHBvcnRzLkZwTGVnZW5kcmUgPSBGcExlZ2VuZHJlO1xuZXhwb3J0cy5GcElzU3F1YXJlID0gRnBJc1NxdWFyZTtcbmV4cG9ydHMubkxlbmd0aCA9IG5MZW5ndGg7XG5leHBvcnRzLkZpZWxkID0gRmllbGQ7XG5leHBvcnRzLkZwU3FydE9kZCA9IEZwU3FydE9kZDtcbmV4cG9ydHMuRnBTcXJ0RXZlbiA9IEZwU3FydEV2ZW47XG5leHBvcnRzLmhhc2hUb1ByaXZhdGVTY2FsYXIgPSBoYXNoVG9Qcml2YXRlU2NhbGFyO1xuZXhwb3J0cy5nZXRGaWVsZEJ5dGVzTGVuZ3RoID0gZ2V0RmllbGRCeXRlc0xlbmd0aDtcbmV4cG9ydHMuZ2V0TWluSGFzaExlbmd0aCA9IGdldE1pbkhhc2hMZW5ndGg7XG5leHBvcnRzLm1hcEhhc2hUb0ZpZWxkID0gbWFwSGFzaFRvRmllbGQ7XG4vKipcbiAqIFV0aWxzIGZvciBtb2R1bGFyIGRpdmlzaW9uIGFuZCBmaW5pdGUgZmllbGRzLlxuICogQSBmaW5pdGUgZmllbGQgb3ZlciAxMSBpcyBpbnRlZ2VyIG51bWJlciBvcGVyYXRpb25zIGBtb2QgMTFgLlxuICogVGhlcmUgaXMgbm8gZGl2aXNpb246IGl0IGlzIHJlcGxhY2VkIGJ5IG1vZHVsYXIgbXVsdGlwbGljYXRpdmUgaW52ZXJzZS5cbiAqIEBtb2R1bGVcbiAqL1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL3V0aWxzXCIpO1xuY29uc3QgdXRpbHNfdHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfMG4gPSBCaWdJbnQoMCksIF8xbiA9IEJpZ0ludCgxKSwgXzJuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgyKSwgXzNuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgzKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzRuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCg0KSwgXzVuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCg1KSwgXzhuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCg4KTtcbi8vIENhbGN1bGF0ZXMgYSBtb2R1bG8gYlxuZnVuY3Rpb24gbW9kKGEsIGIpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhICUgYjtcbiAgICByZXR1cm4gcmVzdWx0ID49IF8wbiA/IHJlc3VsdCA6IGIgKyByZXN1bHQ7XG59XG4vKipcbiAqIEVmZmljaWVudGx5IHJhaXNlIG51bSB0byBwb3dlciBhbmQgZG8gbW9kdWxhciBkaXZpc2lvbi5cbiAqIFVuc2FmZSBpbiBzb21lIGNvbnRleHRzOiB1c2VzIGxhZGRlciwgc28gY2FuIGV4cG9zZSBiaWdpbnQgYml0cy5cbiAqIFRPRE86IHJlbW92ZS5cbiAqIEBleGFtcGxlXG4gKiBwb3coMm4sIDZuLCAxMW4pIC8vIDY0biAlIDExbiA9PSA5blxuICovXG5mdW5jdGlvbiBwb3cobnVtLCBwb3dlciwgbW9kdWxvKSB7XG4gICAgcmV0dXJuIEZwUG93KEZpZWxkKG1vZHVsbyksIG51bSwgcG93ZXIpO1xufVxuLyoqIERvZXMgYHheKDJecG93ZXIpYCBtb2QgcC4gYHBvdzIoMzAsIDQpYCA9PSBgMzBeKDJeNClgICovXG5mdW5jdGlvbiBwb3cyKHgsIHBvd2VyLCBtb2R1bG8pIHtcbiAgICBsZXQgcmVzID0geDtcbiAgICB3aGlsZSAocG93ZXItLSA+IF8wbikge1xuICAgICAgICByZXMgKj0gcmVzO1xuICAgICAgICByZXMgJT0gbW9kdWxvO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLyoqXG4gKiBJbnZlcnNlcyBudW1iZXIgb3ZlciBtb2R1bG8uXG4gKiBJbXBsZW1lbnRlZCB1c2luZyBbRXVjbGlkZWFuIEdDRF0oaHR0cHM6Ly9icmlsbGlhbnQub3JnL3dpa2kvZXh0ZW5kZWQtZXVjbGlkZWFuLWFsZ29yaXRobS8pLlxuICovXG5mdW5jdGlvbiBpbnZlcnQobnVtYmVyLCBtb2R1bG8pIHtcbiAgICBpZiAobnVtYmVyID09PSBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52ZXJ0OiBleHBlY3RlZCBub24temVybyBudW1iZXInKTtcbiAgICBpZiAobW9kdWxvIDw9IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZlcnQ6IGV4cGVjdGVkIHBvc2l0aXZlIG1vZHVsdXMsIGdvdCAnICsgbW9kdWxvKTtcbiAgICAvLyBGZXJtYXQncyBsaXR0bGUgdGhlb3JlbSBcIkNULWxpa2VcIiB2ZXJzaW9uIGludihuKSA9IG5eKG0tMikgbW9kIG0gaXMgMzB4IHNsb3dlci5cbiAgICBsZXQgYSA9IG1vZChudW1iZXIsIG1vZHVsbyk7XG4gICAgbGV0IGIgPSBtb2R1bG87XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgbGV0IHggPSBfMG4sIHkgPSBfMW4sIHUgPSBfMW4sIHYgPSBfMG47XG4gICAgd2hpbGUgKGEgIT09IF8wbikge1xuICAgICAgICAvLyBKSVQgYXBwbGllcyBvcHRpbWl6YXRpb24gaWYgdGhvc2UgdHdvIGxpbmVzIGZvbGxvdyBlYWNoIG90aGVyXG4gICAgICAgIGNvbnN0IHEgPSBiIC8gYTtcbiAgICAgICAgY29uc3QgciA9IGIgJSBhO1xuICAgICAgICBjb25zdCBtID0geCAtIHUgKiBxO1xuICAgICAgICBjb25zdCBuID0geSAtIHYgKiBxO1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgYiA9IGEsIGEgPSByLCB4ID0gdSwgeSA9IHYsIHUgPSBtLCB2ID0gbjtcbiAgICB9XG4gICAgY29uc3QgZ2NkID0gYjtcbiAgICBpZiAoZ2NkICE9PSBfMW4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52ZXJ0OiBkb2VzIG5vdCBleGlzdCcpO1xuICAgIHJldHVybiBtb2QoeCwgbW9kdWxvKTtcbn1cbi8vIE5vdCBhbGwgcm9vdHMgYXJlIHBvc3NpYmxlISBFeGFtcGxlIHdoaWNoIHdpbGwgdGhyb3c6XG4vLyBjb25zdCBOVU0gPVxuLy8gbiA9IDcyMDU3NTk0MDM3OTI3ODE2bjtcbi8vIEZwID0gRmllbGQoQmlnSW50KCcweDFhMDExMWVhMzk3ZmU2OWE0YjFiYTdiNjQzNGJhY2Q3NjQ3NzRiODRmMzg1MTJiZjY3MzBkMmEwZjZiMGY2MjQxZWFiZmZmZWIxNTNmZmZmYjlmZWZmZmZmZmZmYWFhYicpKTtcbmZ1bmN0aW9uIHNxcnQzbW9kNChGcCwgbikge1xuICAgIGNvbnN0IHAxZGl2NCA9IChGcC5PUkRFUiArIF8xbikgLyBfNG47XG4gICAgY29uc3Qgcm9vdCA9IEZwLnBvdyhuLCBwMWRpdjQpO1xuICAgIC8vIFRocm93IGlmIHJvb3ReMiAhPSBuXG4gICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCBuKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgIHJldHVybiByb290O1xufVxuZnVuY3Rpb24gc3FydDVtb2Q4KEZwLCBuKSB7XG4gICAgY29uc3QgcDVkaXY4ID0gKEZwLk9SREVSIC0gXzVuKSAvIF84bjtcbiAgICBjb25zdCBuMiA9IEZwLm11bChuLCBfMm4pO1xuICAgIGNvbnN0IHYgPSBGcC5wb3cobjIsIHA1ZGl2OCk7XG4gICAgY29uc3QgbnYgPSBGcC5tdWwobiwgdik7XG4gICAgY29uc3QgaSA9IEZwLm11bChGcC5tdWwobnYsIF8ybiksIHYpO1xuICAgIGNvbnN0IHJvb3QgPSBGcC5tdWwobnYsIEZwLnN1YihpLCBGcC5PTkUpKTtcbiAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIG4pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgcmV0dXJuIHJvb3Q7XG59XG4vLyBUT0RPOiBDb21tZW50ZWQtb3V0IGZvciBub3cuIFByb3ZpZGUgdGVzdCB2ZWN0b3JzLlxuLy8gVG9uZWxsaSBpcyB0b28gc2xvdyBmb3IgZXh0ZW5zaW9uIGZpZWxkcyBGcDIuXG4vLyBUaGF0IG1lYW5zIHdlIGNhbid0IHVzZSBzcXJ0IChjMSwgYzIuLi4pIGV2ZW4gZm9yIGluaXRpYWxpemF0aW9uIGNvbnN0YW50cy5cbi8vIGlmIChQICUgXzE2biA9PT0gXzluKSByZXR1cm4gc3FydDltb2QxNjtcbi8vIC8vIHByZXR0aWVyLWlnbm9yZVxuLy8gZnVuY3Rpb24gc3FydDltb2QxNjxUPihGcDogSUZpZWxkPFQ+LCBuOiBULCBwN2RpdjE2PzogYmlnaW50KSB7XG4vLyAgIGlmIChwN2RpdjE2ID09PSB1bmRlZmluZWQpIHA3ZGl2MTYgPSAoRnAuT1JERVIgKyBCaWdJbnQoNykpIC8gXzE2bjtcbi8vICAgY29uc3QgYzEgPSBGcC5zcXJ0KEZwLm5lZyhGcC5PTkUpKTsgLy8gIDEuIGMxID0gc3FydCgtMSkgaW4gRiwgaS5lLiwgKGMxXjIpID09IC0xIGluIEZcbi8vICAgY29uc3QgYzIgPSBGcC5zcXJ0KGMxKTsgICAgICAgICAgICAgLy8gIDIuIGMyID0gc3FydChjMSkgaW4gRiwgaS5lLiwgKGMyXjIpID09IGMxIGluIEZcbi8vICAgY29uc3QgYzMgPSBGcC5zcXJ0KEZwLm5lZyhjMSkpOyAgICAgLy8gIDMuIGMzID0gc3FydCgtYzEpIGluIEYsIGkuZS4sIChjM14yKSA9PSAtYzEgaW4gRlxuLy8gICBjb25zdCBjNCA9IHA3ZGl2MTY7ICAgICAgICAgICAgICAgICAvLyAgNC4gYzQgPSAocSArIDcpIC8gMTYgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4vLyAgIGxldCB0djEgPSBGcC5wb3cobiwgYzQpOyAgICAgICAgICAgIC8vICAxLiB0djEgPSB4XmM0XG4vLyAgIGxldCB0djIgPSBGcC5tdWwoYzEsIHR2MSk7ICAgICAgICAgIC8vICAyLiB0djIgPSBjMSAqIHR2MVxuLy8gICBjb25zdCB0djMgPSBGcC5tdWwoYzIsIHR2MSk7ICAgICAgICAvLyAgMy4gdHYzID0gYzIgKiB0djFcbi8vICAgbGV0IHR2NCA9IEZwLm11bChjMywgdHYxKTsgICAgICAgICAgLy8gIDQuIHR2NCA9IGMzICogdHYxXG4vLyAgIGNvbnN0IGUxID0gRnAuZXFsKEZwLnNxcih0djIpLCBuKTsgIC8vICA1LiAgZTEgPSAodHYyXjIpID09IHhcbi8vICAgY29uc3QgZTIgPSBGcC5lcWwoRnAuc3FyKHR2MyksIG4pOyAgLy8gIDYuICBlMiA9ICh0djNeMikgPT0geFxuLy8gICB0djEgPSBGcC5jbW92KHR2MSwgdHYyLCBlMSk7IC8vICA3LiB0djEgPSBDTU9WKHR2MSwgdHYyLCBlMSkgICMgU2VsZWN0IHR2MiBpZiAodHYyXjIpID09IHhcbi8vICAgdHYyID0gRnAuY21vdih0djQsIHR2MywgZTIpOyAvLyAgOC4gdHYyID0gQ01PVih0djQsIHR2MywgZTIpICAjIFNlbGVjdCB0djMgaWYgKHR2M14yKSA9PSB4XG4vLyAgIGNvbnN0IGUzID0gRnAuZXFsKEZwLnNxcih0djIpLCBuKTsgIC8vICA5LiAgZTMgPSAodHYyXjIpID09IHhcbi8vICAgcmV0dXJuIEZwLmNtb3YodHYxLCB0djIsIGUzKTsgLy8gMTAuICB6ID0gQ01PVih0djEsIHR2MiwgZTMpICMgU2VsZWN0IHRoZSBzcXJ0IGZyb20gdHYxIGFuZCB0djJcbi8vIH1cbi8qKlxuICogVG9uZWxsaS1TaGFua3Mgc3F1YXJlIHJvb3Qgc2VhcmNoIGFsZ29yaXRobS5cbiAqIDEuIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTIvNjg1LnBkZiAocGFnZSAxMilcbiAqIDIuIFNxdWFyZSBSb290cyBmcm9tIDE7IDI0LCA1MSwgMTAgdG8gRGFuIFNoYW5rc1xuICogQHBhcmFtIFAgZmllbGQgb3JkZXJcbiAqIEByZXR1cm5zIGZ1bmN0aW9uIHRoYXQgdGFrZXMgZmllbGQgRnAgKGNyZWF0ZWQgZnJvbSBQKSBhbmQgbnVtYmVyIG5cbiAqL1xuZnVuY3Rpb24gdG9uZWxsaVNoYW5rcyhQKSB7XG4gICAgLy8gSW5pdGlhbGl6YXRpb24gKHByZWNvbXB1dGF0aW9uKS5cbiAgICBpZiAoUCA8IEJpZ0ludCgzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzcXJ0IGlzIG5vdCBkZWZpbmVkIGZvciBzbWFsbCBmaWVsZCcpO1xuICAgIC8vIEZhY3RvciBQIC0gMSA9IFEgKiAyXlMsIHdoZXJlIFEgaXMgb2RkXG4gICAgbGV0IFEgPSBQIC0gXzFuO1xuICAgIGxldCBTID0gMDtcbiAgICB3aGlsZSAoUSAlIF8ybiA9PT0gXzBuKSB7XG4gICAgICAgIFEgLz0gXzJuO1xuICAgICAgICBTKys7XG4gICAgfVxuICAgIC8vIEZpbmQgdGhlIGZpcnN0IHF1YWRyYXRpYyBub24tcmVzaWR1ZSBaID49IDJcbiAgICBsZXQgWiA9IF8ybjtcbiAgICBjb25zdCBfRnAgPSBGaWVsZChQKTtcbiAgICB3aGlsZSAoRnBMZWdlbmRyZShfRnAsIFopID09PSAxKSB7XG4gICAgICAgIC8vIEJhc2ljIHByaW1hbGl0eSB0ZXN0IGZvciBQLiBBZnRlciB4IGl0ZXJhdGlvbnMsIGNoYW5jZSBvZlxuICAgICAgICAvLyBub3QgZmluZGluZyBxdWFkcmF0aWMgbm9uLXJlc2lkdWUgaXMgMl54LCBzbyAyXjEwMDAuXG4gICAgICAgIGlmIChaKysgPiAxMDAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdDogcHJvYmFibHkgbm9uLXByaW1lIFAnKTtcbiAgICB9XG4gICAgLy8gRmFzdC1wYXRoOyB1c3VhbGx5IGRvbmUgYmVmb3JlIFosIGJ1dCB3ZSBkbyBcInByaW1hbGl0eSB0ZXN0XCIuXG4gICAgaWYgKFMgPT09IDEpXG4gICAgICAgIHJldHVybiBzcXJ0M21vZDQ7XG4gICAgLy8gU2xvdy1wYXRoXG4gICAgLy8gVE9ETzogdGVzdCBvbiBGcDIgYW5kIG90aGVyc1xuICAgIGxldCBjYyA9IF9GcC5wb3coWiwgUSk7IC8vIGMgPSB6XlFcbiAgICBjb25zdCBRMWRpdjIgPSAoUSArIF8xbikgLyBfMm47XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHRvbmVsbGlTbG93KEZwLCBuKSB7XG4gICAgICAgIGlmIChGcC5pczAobikpXG4gICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgLy8gQ2hlY2sgaWYgbiBpcyBhIHF1YWRyYXRpYyByZXNpZHVlIHVzaW5nIExlZ2VuZHJlIHN5bWJvbFxuICAgICAgICBpZiAoRnBMZWdlbmRyZShGcCwgbikgIT09IDEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgIC8vIEluaXRpYWxpemUgdmFyaWFibGVzIGZvciB0aGUgbWFpbiBsb29wXG4gICAgICAgIGxldCBNID0gUztcbiAgICAgICAgbGV0IGMgPSBGcC5tdWwoRnAuT05FLCBjYyk7IC8vIGMgPSB6XlEsIG1vdmUgY2MgZnJvbSBmaWVsZCBfRnAgaW50byBmaWVsZCBGcFxuICAgICAgICBsZXQgdCA9IEZwLnBvdyhuLCBRKTsgLy8gdCA9IG5eUSwgZmlyc3QgZ3Vlc3MgYXQgdGhlIGZ1ZGdlIGZhY3RvclxuICAgICAgICBsZXQgUiA9IEZwLnBvdyhuLCBRMWRpdjIpOyAvLyBSID0gbl4oKFErMSkvMiksIGZpcnN0IGd1ZXNzIGF0IHRoZSBzcXVhcmUgcm9vdFxuICAgICAgICAvLyBNYWluIGxvb3BcbiAgICAgICAgLy8gd2hpbGUgdCAhPSAxXG4gICAgICAgIHdoaWxlICghRnAuZXFsKHQsIEZwLk9ORSkpIHtcbiAgICAgICAgICAgIGlmIChGcC5pczAodCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEZwLlpFUk87IC8vIGlmIHQ9MCByZXR1cm4gUj0wXG4gICAgICAgICAgICBsZXQgaSA9IDE7XG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBzbWFsbGVzdCBpID49IDEgc3VjaCB0aGF0IHReKDJeaSkg4omhIDEgKG1vZCBQKVxuICAgICAgICAgICAgbGV0IHRfdG1wID0gRnAuc3FyKHQpOyAvLyB0XigyXjEpXG4gICAgICAgICAgICB3aGlsZSAoIUZwLmVxbCh0X3RtcCwgRnAuT05FKSkge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICB0X3RtcCA9IEZwLnNxcih0X3RtcCk7IC8vIHReKDJeMikuLi5cbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gTSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBleHBvbmVudCBmb3IgYjogMl4oTSAtIGkgLSAxKVxuICAgICAgICAgICAgY29uc3QgZXhwb25lbnQgPSBfMW4gPDwgQmlnSW50KE0gLSBpIC0gMSk7IC8vIGJpZ2ludCBpcyBpbXBvcnRhbnRcbiAgICAgICAgICAgIGNvbnN0IGIgPSBGcC5wb3coYywgZXhwb25lbnQpOyAvLyBiID0gMl4oTSAtIGkgLSAxKVxuICAgICAgICAgICAgLy8gVXBkYXRlIHZhcmlhYmxlc1xuICAgICAgICAgICAgTSA9IGk7XG4gICAgICAgICAgICBjID0gRnAuc3FyKGIpOyAvLyBjID0gYl4yXG4gICAgICAgICAgICB0ID0gRnAubXVsKHQsIGMpOyAvLyB0ID0gKHQgKiBiXjIpXG4gICAgICAgICAgICBSID0gRnAubXVsKFIsIGIpOyAvLyBSID0gUipiXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFI7XG4gICAgfTtcbn1cbi8qKlxuICogU3F1YXJlIHJvb3QgZm9yIGEgZmluaXRlIGZpZWxkLiBXaWxsIHRyeSBvcHRpbWl6ZWQgdmVyc2lvbnMgZmlyc3Q6XG4gKlxuICogMS4gUCDiiaEgMyAobW9kIDQpXG4gKiAyLiBQIOKJoSA1IChtb2QgOClcbiAqIDMuIFRvbmVsbGktU2hhbmtzIGFsZ29yaXRobVxuICpcbiAqIERpZmZlcmVudCBhbGdvcml0aG1zIGNhbiBnaXZlIGRpZmZlcmVudCByb290cywgaXQgaXMgdXAgdG8gdXNlciB0byBkZWNpZGUgd2hpY2ggb25lIHRoZXkgd2FudC5cbiAqIEZvciBleGFtcGxlIHRoZXJlIGlzIEZwU3FydE9kZC9GcFNxcnRFdmVuIHRvIGNob2ljZSByb290IGJhc2VkIG9uIG9kZG5lc3MgKHVzZWQgZm9yIGhhc2gtdG8tY3VydmUpLlxuICovXG5mdW5jdGlvbiBGcFNxcnQoUCkge1xuICAgIC8vIFAg4omhIDMgKG1vZCA0KSA9PiDiiJpuID0gbl4oKFArMSkvNClcbiAgICBpZiAoUCAlIF80biA9PT0gXzNuKVxuICAgICAgICByZXR1cm4gc3FydDNtb2Q0O1xuICAgIC8vIFAg4omhIDUgKG1vZCA4KSA9PiBBdGtpbiBhbGdvcml0aG0sIHBhZ2UgMTAgb2YgaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxMi82ODUucGRmXG4gICAgaWYgKFAgJSBfOG4gPT09IF81bilcbiAgICAgICAgcmV0dXJuIHNxcnQ1bW9kODtcbiAgICAvLyBQIOKJoSA5IChtb2QgMTYpIG5vdCBpbXBsZW1lbnRlZCwgc2VlIGFib3ZlXG4gICAgLy8gVG9uZWxsaS1TaGFua3MgYWxnb3JpdGhtXG4gICAgcmV0dXJuIHRvbmVsbGlTaGFua3MoUCk7XG59XG4vLyBMaXR0bGUtZW5kaWFuIGNoZWNrIGZvciBmaXJzdCBMRSBiaXQgKGxhc3QgQkUgYml0KTtcbmNvbnN0IGlzTmVnYXRpdmVMRSA9IChudW0sIG1vZHVsbykgPT4gKG1vZChudW0sIG1vZHVsbykgJiBfMW4pID09PSBfMW47XG5leHBvcnRzLmlzTmVnYXRpdmVMRSA9IGlzTmVnYXRpdmVMRTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgRklFTERfRklFTERTID0gW1xuICAgICdjcmVhdGUnLCAnaXNWYWxpZCcsICdpczAnLCAnbmVnJywgJ2ludicsICdzcXJ0JywgJ3NxcicsXG4gICAgJ2VxbCcsICdhZGQnLCAnc3ViJywgJ211bCcsICdwb3cnLCAnZGl2JyxcbiAgICAnYWRkTicsICdzdWJOJywgJ211bE4nLCAnc3FyTidcbl07XG5mdW5jdGlvbiB2YWxpZGF0ZUZpZWxkKGZpZWxkKSB7XG4gICAgY29uc3QgaW5pdGlhbCA9IHtcbiAgICAgICAgT1JERVI6ICdiaWdpbnQnLFxuICAgICAgICBNQVNLOiAnYmlnaW50JyxcbiAgICAgICAgQllURVM6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgQklUUzogJ2lzU2FmZUludGVnZXInLFxuICAgIH07XG4gICAgY29uc3Qgb3B0cyA9IEZJRUxEX0ZJRUxEUy5yZWR1Y2UoKG1hcCwgdmFsKSA9PiB7XG4gICAgICAgIG1hcFt2YWxdID0gJ2Z1bmN0aW9uJztcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9LCBpbml0aWFsKTtcbiAgICByZXR1cm4gKDAsIHV0aWxzX3RzXzEudmFsaWRhdGVPYmplY3QpKGZpZWxkLCBvcHRzKTtcbn1cbi8vIEdlbmVyaWMgZmllbGQgZnVuY3Rpb25zXG4vKipcbiAqIFNhbWUgYXMgYHBvd2AgYnV0IGZvciBGcDogbm9uLWNvbnN0YW50LXRpbWUuXG4gKiBVbnNhZmUgaW4gc29tZSBjb250ZXh0czogdXNlcyBsYWRkZXIsIHNvIGNhbiBleHBvc2UgYmlnaW50IGJpdHMuXG4gKi9cbmZ1bmN0aW9uIEZwUG93KEZwLCBudW0sIHBvd2VyKSB7XG4gICAgaWYgKHBvd2VyIDwgXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZXhwb25lbnQsIG5lZ2F0aXZlcyB1bnN1cHBvcnRlZCcpO1xuICAgIGlmIChwb3dlciA9PT0gXzBuKVxuICAgICAgICByZXR1cm4gRnAuT05FO1xuICAgIGlmIChwb3dlciA9PT0gXzFuKVxuICAgICAgICByZXR1cm4gbnVtO1xuICAgIGxldCBwID0gRnAuT05FO1xuICAgIGxldCBkID0gbnVtO1xuICAgIHdoaWxlIChwb3dlciA+IF8wbikge1xuICAgICAgICBpZiAocG93ZXIgJiBfMW4pXG4gICAgICAgICAgICBwID0gRnAubXVsKHAsIGQpO1xuICAgICAgICBkID0gRnAuc3FyKGQpO1xuICAgICAgICBwb3dlciA+Pj0gXzFuO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbn1cbi8qKlxuICogRWZmaWNpZW50bHkgaW52ZXJ0IGFuIGFycmF5IG9mIEZpZWxkIGVsZW1lbnRzLlxuICogRXhjZXB0aW9uLWZyZWUuIFdpbGwgcmV0dXJuIGB1bmRlZmluZWRgIGZvciAwIGVsZW1lbnRzLlxuICogQHBhcmFtIHBhc3NaZXJvIG1hcCAwIHRvIDAgKGluc3RlYWQgb2YgdW5kZWZpbmVkKVxuICovXG5mdW5jdGlvbiBGcEludmVydEJhdGNoKEZwLCBudW1zLCBwYXNzWmVybyA9IGZhbHNlKSB7XG4gICAgY29uc3QgaW52ZXJ0ZWQgPSBuZXcgQXJyYXkobnVtcy5sZW5ndGgpLmZpbGwocGFzc1plcm8gPyBGcC5aRVJPIDogdW5kZWZpbmVkKTtcbiAgICAvLyBXYWxrIGZyb20gZmlyc3QgdG8gbGFzdCwgbXVsdGlwbHkgdGhlbSBieSBlYWNoIG90aGVyIE1PRCBwXG4gICAgY29uc3QgbXVsdGlwbGllZEFjYyA9IG51bXMucmVkdWNlKChhY2MsIG51bSwgaSkgPT4ge1xuICAgICAgICBpZiAoRnAuaXMwKG51bSkpXG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICBpbnZlcnRlZFtpXSA9IGFjYztcbiAgICAgICAgcmV0dXJuIEZwLm11bChhY2MsIG51bSk7XG4gICAgfSwgRnAuT05FKTtcbiAgICAvLyBJbnZlcnQgbGFzdCBlbGVtZW50XG4gICAgY29uc3QgaW52ZXJ0ZWRBY2MgPSBGcC5pbnYobXVsdGlwbGllZEFjYyk7XG4gICAgLy8gV2FsayBmcm9tIGxhc3QgdG8gZmlyc3QsIG11bHRpcGx5IHRoZW0gYnkgaW52ZXJ0ZWQgZWFjaCBvdGhlciBNT0QgcFxuICAgIG51bXMucmVkdWNlUmlnaHQoKGFjYywgbnVtLCBpKSA9PiB7XG4gICAgICAgIGlmIChGcC5pczAobnVtKSlcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIGludmVydGVkW2ldID0gRnAubXVsKGFjYywgaW52ZXJ0ZWRbaV0pO1xuICAgICAgICByZXR1cm4gRnAubXVsKGFjYywgbnVtKTtcbiAgICB9LCBpbnZlcnRlZEFjYyk7XG4gICAgcmV0dXJuIGludmVydGVkO1xufVxuLy8gVE9ETzogcmVtb3ZlXG5mdW5jdGlvbiBGcERpdihGcCwgbGhzLCByaHMpIHtcbiAgICByZXR1cm4gRnAubXVsKGxocywgdHlwZW9mIHJocyA9PT0gJ2JpZ2ludCcgPyBpbnZlcnQocmhzLCBGcC5PUkRFUikgOiBGcC5pbnYocmhzKSk7XG59XG4vKipcbiAqIExlZ2VuZHJlIHN5bWJvbC5cbiAqIExlZ2VuZHJlIGNvbnN0YW50IGlzIHVzZWQgdG8gY2FsY3VsYXRlIExlZ2VuZHJlIHN5bWJvbCAoYSB8IHApXG4gKiB3aGljaCBkZW5vdGVzIHRoZSB2YWx1ZSBvZiBhXigocC0xKS8yKSAobW9kIHApLlxuICpcbiAqICogKGEgfCBwKSDiiaEgMSAgICBpZiBhIGlzIGEgc3F1YXJlIChtb2QgcCksIHF1YWRyYXRpYyByZXNpZHVlXG4gKiAqIChhIHwgcCkg4omhIC0xICAgaWYgYSBpcyBub3QgYSBzcXVhcmUgKG1vZCBwKSwgcXVhZHJhdGljIG5vbiByZXNpZHVlXG4gKiAqIChhIHwgcCkg4omhIDAgICAgaWYgYSDiiaEgMCAobW9kIHApXG4gKi9cbmZ1bmN0aW9uIEZwTGVnZW5kcmUoRnAsIG4pIHtcbiAgICAvLyBXZSBjYW4gdXNlIDNyZCBhcmd1bWVudCBhcyBvcHRpb25hbCBjYWNoZSBvZiB0aGlzIHZhbHVlXG4gICAgLy8gYnV0IHNlZW1zIHVubmVlZGVkIGZvciBub3cuIFRoZSBvcGVyYXRpb24gaXMgdmVyeSBmYXN0LlxuICAgIGNvbnN0IHAxbW9kMiA9IChGcC5PUkRFUiAtIF8xbikgLyBfMm47XG4gICAgY29uc3QgcG93ZXJlZCA9IEZwLnBvdyhuLCBwMW1vZDIpO1xuICAgIGNvbnN0IHllcyA9IEZwLmVxbChwb3dlcmVkLCBGcC5PTkUpO1xuICAgIGNvbnN0IHplcm8gPSBGcC5lcWwocG93ZXJlZCwgRnAuWkVSTyk7XG4gICAgY29uc3Qgbm8gPSBGcC5lcWwocG93ZXJlZCwgRnAubmVnKEZwLk9ORSkpO1xuICAgIGlmICgheWVzICYmICF6ZXJvICYmICFubylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIExlZ2VuZHJlIHN5bWJvbCByZXN1bHQnKTtcbiAgICByZXR1cm4geWVzID8gMSA6IHplcm8gPyAwIDogLTE7XG59XG4vLyBUaGlzIGZ1bmN0aW9uIHJldHVybnMgVHJ1ZSB3aGVuZXZlciB0aGUgdmFsdWUgeCBpcyBhIHNxdWFyZSBpbiB0aGUgZmllbGQgRi5cbmZ1bmN0aW9uIEZwSXNTcXVhcmUoRnAsIG4pIHtcbiAgICBjb25zdCBsID0gRnBMZWdlbmRyZShGcCwgbik7XG4gICAgcmV0dXJuIGwgPT09IDE7XG59XG4vLyBDVVJWRS5uIGxlbmd0aHNcbmZ1bmN0aW9uIG5MZW5ndGgobiwgbkJpdExlbmd0aCkge1xuICAgIC8vIEJpdCBzaXplLCBieXRlIHNpemUgb2YgQ1VSVkUublxuICAgIGlmIChuQml0TGVuZ3RoICE9PSB1bmRlZmluZWQpXG4gICAgICAgICgwLCB1dGlsc18xLmFudW1iZXIpKG5CaXRMZW5ndGgpO1xuICAgIGNvbnN0IF9uQml0TGVuZ3RoID0gbkJpdExlbmd0aCAhPT0gdW5kZWZpbmVkID8gbkJpdExlbmd0aCA6IG4udG9TdHJpbmcoMikubGVuZ3RoO1xuICAgIGNvbnN0IG5CeXRlTGVuZ3RoID0gTWF0aC5jZWlsKF9uQml0TGVuZ3RoIC8gOCk7XG4gICAgcmV0dXJuIHsgbkJpdExlbmd0aDogX25CaXRMZW5ndGgsIG5CeXRlTGVuZ3RoIH07XG59XG4vKipcbiAqIEluaXRpYWxpemVzIGEgZmluaXRlIGZpZWxkIG92ZXIgcHJpbWUuXG4gKiBNYWpvciBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb25zOlxuICogKiBhKSBkZW5vcm1hbGl6ZWQgb3BlcmF0aW9ucyBsaWtlIG11bE4gaW5zdGVhZCBvZiBtdWxcbiAqICogYikgc2FtZSBvYmplY3Qgc2hhcGU6IG5ldmVyIGFkZCBvciByZW1vdmUga2V5c1xuICogKiBjKSBPYmplY3QuZnJlZXplXG4gKiBGcmFnaWxlOiBhbHdheXMgcnVuIGEgYmVuY2htYXJrIG9uIGEgY2hhbmdlLlxuICogU2VjdXJpdHkgbm90ZTogb3BlcmF0aW9ucyBkb24ndCBjaGVjayAnaXNWYWxpZCcgZm9yIGFsbCBlbGVtZW50cyBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucyxcbiAqIGl0IGlzIGNhbGxlciByZXNwb25zaWJpbGl0eSB0byBjaGVjayB0aGlzLlxuICogVGhpcyBpcyBsb3ctbGV2ZWwgY29kZSwgcGxlYXNlIG1ha2Ugc3VyZSB5b3Uga25vdyB3aGF0IHlvdSdyZSBkb2luZy5cbiAqIEBwYXJhbSBPUkRFUiBwcmltZSBwb3NpdGl2ZSBiaWdpbnRcbiAqIEBwYXJhbSBiaXRMZW4gaG93IG1hbnkgYml0cyB0aGUgZmllbGQgY29uc3VtZXNcbiAqIEBwYXJhbSBpc0xFIChkZWY6IGZhbHNlKSBpZiBlbmNvZGluZyAvIGRlY29kaW5nIHNob3VsZCBiZSBpbiBsaXR0bGUtZW5kaWFuXG4gKiBAcGFyYW0gcmVkZWYgb3B0aW9uYWwgZmFzdGVyIHJlZGVmaW5pdGlvbnMgb2Ygc3FydCBhbmQgb3RoZXIgbWV0aG9kc1xuICovXG5mdW5jdGlvbiBGaWVsZChPUkRFUiwgYml0TGVuLCBpc0xFID0gZmFsc2UsIHJlZGVmID0ge30pIHtcbiAgICBpZiAoT1JERVIgPD0gXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZmllbGQ6IGV4cGVjdGVkIE9SREVSID4gMCwgZ290ICcgKyBPUkRFUik7XG4gICAgY29uc3QgeyBuQml0TGVuZ3RoOiBCSVRTLCBuQnl0ZUxlbmd0aDogQllURVMgfSA9IG5MZW5ndGgoT1JERVIsIGJpdExlbik7XG4gICAgaWYgKEJZVEVTID4gMjA0OClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGZpZWxkOiBleHBlY3RlZCBPUkRFUiBvZiA8PSAyMDQ4IGJ5dGVzJyk7XG4gICAgbGV0IHNxcnRQOyAvLyBjYWNoZWQgc3FydFBcbiAgICBjb25zdCBmID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIE9SREVSLFxuICAgICAgICBpc0xFLFxuICAgICAgICBCSVRTLFxuICAgICAgICBCWVRFUyxcbiAgICAgICAgTUFTSzogKDAsIHV0aWxzX3RzXzEuYml0TWFzaykoQklUUyksXG4gICAgICAgIFpFUk86IF8wbixcbiAgICAgICAgT05FOiBfMW4sXG4gICAgICAgIGNyZWF0ZTogKG51bSkgPT4gbW9kKG51bSwgT1JERVIpLFxuICAgICAgICBpc1ZhbGlkOiAobnVtKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG51bSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGZpZWxkIGVsZW1lbnQ6IGV4cGVjdGVkIGJpZ2ludCwgZ290ICcgKyB0eXBlb2YgbnVtKTtcbiAgICAgICAgICAgIHJldHVybiBfMG4gPD0gbnVtICYmIG51bSA8IE9SREVSOyAvLyAwIGlzIHZhbGlkIGVsZW1lbnQsIGJ1dCBpdCdzIG5vdCBpbnZlcnRpYmxlXG4gICAgICAgIH0sXG4gICAgICAgIGlzMDogKG51bSkgPT4gbnVtID09PSBfMG4sXG4gICAgICAgIGlzT2RkOiAobnVtKSA9PiAobnVtICYgXzFuKSA9PT0gXzFuLFxuICAgICAgICBuZWc6IChudW0pID0+IG1vZCgtbnVtLCBPUkRFUiksXG4gICAgICAgIGVxbDogKGxocywgcmhzKSA9PiBsaHMgPT09IHJocyxcbiAgICAgICAgc3FyOiAobnVtKSA9PiBtb2QobnVtICogbnVtLCBPUkRFUiksXG4gICAgICAgIGFkZDogKGxocywgcmhzKSA9PiBtb2QobGhzICsgcmhzLCBPUkRFUiksXG4gICAgICAgIHN1YjogKGxocywgcmhzKSA9PiBtb2QobGhzIC0gcmhzLCBPUkRFUiksXG4gICAgICAgIG11bDogKGxocywgcmhzKSA9PiBtb2QobGhzICogcmhzLCBPUkRFUiksXG4gICAgICAgIHBvdzogKG51bSwgcG93ZXIpID0+IEZwUG93KGYsIG51bSwgcG93ZXIpLFxuICAgICAgICBkaXY6IChsaHMsIHJocykgPT4gbW9kKGxocyAqIGludmVydChyaHMsIE9SREVSKSwgT1JERVIpLFxuICAgICAgICAvLyBTYW1lIGFzIGFib3ZlLCBidXQgZG9lc24ndCBub3JtYWxpemVcbiAgICAgICAgc3FyTjogKG51bSkgPT4gbnVtICogbnVtLFxuICAgICAgICBhZGROOiAobGhzLCByaHMpID0+IGxocyArIHJocyxcbiAgICAgICAgc3ViTjogKGxocywgcmhzKSA9PiBsaHMgLSByaHMsXG4gICAgICAgIG11bE46IChsaHMsIHJocykgPT4gbGhzICogcmhzLFxuICAgICAgICBpbnY6IChudW0pID0+IGludmVydChudW0sIE9SREVSKSxcbiAgICAgICAgc3FydDogcmVkZWYuc3FydCB8fFxuICAgICAgICAgICAgKChuKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFzcXJ0UClcbiAgICAgICAgICAgICAgICAgICAgc3FydFAgPSBGcFNxcnQoT1JERVIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzcXJ0UChmLCBuKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB0b0J5dGVzOiAobnVtKSA9PiAoaXNMRSA/ICgwLCB1dGlsc190c18xLm51bWJlclRvQnl0ZXNMRSkobnVtLCBCWVRFUykgOiAoMCwgdXRpbHNfdHNfMS5udW1iZXJUb0J5dGVzQkUpKG51bSwgQllURVMpKSxcbiAgICAgICAgZnJvbUJ5dGVzOiAoYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggIT09IEJZVEVTKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmllbGQuZnJvbUJ5dGVzOiBleHBlY3RlZCAnICsgQllURVMgKyAnIGJ5dGVzLCBnb3QgJyArIGJ5dGVzLmxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gaXNMRSA/ICgwLCB1dGlsc190c18xLmJ5dGVzVG9OdW1iZXJMRSkoYnl0ZXMpIDogKDAsIHV0aWxzX3RzXzEuYnl0ZXNUb051bWJlckJFKShieXRlcyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFRPRE86IHdlIGRvbid0IG5lZWQgaXQgaGVyZSwgbW92ZSBvdXQgdG8gc2VwYXJhdGUgZm5cbiAgICAgICAgaW52ZXJ0QmF0Y2g6IChsc3QpID0+IEZwSW52ZXJ0QmF0Y2goZiwgbHN0KSxcbiAgICAgICAgLy8gV2UgY2FuJ3QgbW92ZSB0aGlzIG91dCBiZWNhdXNlIEZwNiwgRnAxMiBpbXBsZW1lbnQgaXRcbiAgICAgICAgLy8gYW5kIGl0J3MgdW5jbGVhciB3aGF0IHRvIHJldHVybiBpbiB0aGVyZS5cbiAgICAgICAgY21vdjogKGEsIGIsIGMpID0+IChjID8gYiA6IGEpLFxuICAgIH0pO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKGYpO1xufVxuZnVuY3Rpb24gRnBTcXJ0T2RkKEZwLCBlbG0pIHtcbiAgICBpZiAoIUZwLmlzT2RkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaWVsZCBkb2Vzbid0IGhhdmUgaXNPZGRcIik7XG4gICAgY29uc3Qgcm9vdCA9IEZwLnNxcnQoZWxtKTtcbiAgICByZXR1cm4gRnAuaXNPZGQocm9vdCkgPyByb290IDogRnAubmVnKHJvb3QpO1xufVxuZnVuY3Rpb24gRnBTcXJ0RXZlbihGcCwgZWxtKSB7XG4gICAgaWYgKCFGcC5pc09kZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmllbGQgZG9lc24ndCBoYXZlIGlzT2RkXCIpO1xuICAgIGNvbnN0IHJvb3QgPSBGcC5zcXJ0KGVsbSk7XG4gICAgcmV0dXJuIEZwLmlzT2RkKHJvb3QpID8gRnAubmVnKHJvb3QpIDogcm9vdDtcbn1cbi8qKlxuICogXCJDb25zdGFudC10aW1lXCIgcHJpdmF0ZSBrZXkgZ2VuZXJhdGlvbiB1dGlsaXR5LlxuICogU2FtZSBhcyBtYXBLZXlUb0ZpZWxkLCBidXQgYWNjZXB0cyBsZXNzIGJ5dGVzICg0MCBpbnN0ZWFkIG9mIDQ4IGZvciAzMi1ieXRlIGZpZWxkKS5cbiAqIFdoaWNoIG1ha2VzIGl0IHNsaWdodGx5IG1vcmUgYmlhc2VkLCBsZXNzIHNlY3VyZS5cbiAqIEBkZXByZWNhdGVkIHVzZSBgbWFwS2V5VG9GaWVsZGAgaW5zdGVhZFxuICovXG5mdW5jdGlvbiBoYXNoVG9Qcml2YXRlU2NhbGFyKGhhc2gsIGdyb3VwT3JkZXIsIGlzTEUgPSBmYWxzZSkge1xuICAgIGhhc2ggPSAoMCwgdXRpbHNfdHNfMS5lbnN1cmVCeXRlcykoJ3ByaXZhdGVIYXNoJywgaGFzaCk7XG4gICAgY29uc3QgaGFzaExlbiA9IGhhc2gubGVuZ3RoO1xuICAgIGNvbnN0IG1pbkxlbiA9IG5MZW5ndGgoZ3JvdXBPcmRlcikubkJ5dGVMZW5ndGggKyA4O1xuICAgIGlmIChtaW5MZW4gPCAyNCB8fCBoYXNoTGVuIDwgbWluTGVuIHx8IGhhc2hMZW4gPiAxMDI0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hhc2hUb1ByaXZhdGVTY2FsYXI6IGV4cGVjdGVkICcgKyBtaW5MZW4gKyAnLTEwMjQgYnl0ZXMgb2YgaW5wdXQsIGdvdCAnICsgaGFzaExlbik7XG4gICAgY29uc3QgbnVtID0gaXNMRSA/ICgwLCB1dGlsc190c18xLmJ5dGVzVG9OdW1iZXJMRSkoaGFzaCkgOiAoMCwgdXRpbHNfdHNfMS5ieXRlc1RvTnVtYmVyQkUpKGhhc2gpO1xuICAgIHJldHVybiBtb2QobnVtLCBncm91cE9yZGVyIC0gXzFuKSArIF8xbjtcbn1cbi8qKlxuICogUmV0dXJucyB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgY29uc3VtZWQgYnkgdGhlIGZpZWxkIGVsZW1lbnQuXG4gKiBGb3IgZXhhbXBsZSwgMzIgYnl0ZXMgZm9yIHVzdWFsIDI1Ni1iaXQgd2VpZXJzdHJhc3MgY3VydmUuXG4gKiBAcGFyYW0gZmllbGRPcmRlciBudW1iZXIgb2YgZmllbGQgZWxlbWVudHMsIHVzdWFsbHkgQ1VSVkUublxuICogQHJldHVybnMgYnl0ZSBsZW5ndGggb2YgZmllbGRcbiAqL1xuZnVuY3Rpb24gZ2V0RmllbGRCeXRlc0xlbmd0aChmaWVsZE9yZGVyKSB7XG4gICAgaWYgKHR5cGVvZiBmaWVsZE9yZGVyICE9PSAnYmlnaW50JylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaWVsZCBvcmRlciBtdXN0IGJlIGJpZ2ludCcpO1xuICAgIGNvbnN0IGJpdExlbmd0aCA9IGZpZWxkT3JkZXIudG9TdHJpbmcoMikubGVuZ3RoO1xuICAgIHJldHVybiBNYXRoLmNlaWwoYml0TGVuZ3RoIC8gOCk7XG59XG4vKipcbiAqIFJldHVybnMgbWluaW1hbCBhbW91bnQgb2YgYnl0ZXMgdGhhdCBjYW4gYmUgc2FmZWx5IHJlZHVjZWRcbiAqIGJ5IGZpZWxkIG9yZGVyLlxuICogU2hvdWxkIGJlIDJeLTEyOCBmb3IgMTI4LWJpdCBjdXJ2ZSBzdWNoIGFzIFAyNTYuXG4gKiBAcGFyYW0gZmllbGRPcmRlciBudW1iZXIgb2YgZmllbGQgZWxlbWVudHMsIHVzdWFsbHkgQ1VSVkUublxuICogQHJldHVybnMgYnl0ZSBsZW5ndGggb2YgdGFyZ2V0IGhhc2hcbiAqL1xuZnVuY3Rpb24gZ2V0TWluSGFzaExlbmd0aChmaWVsZE9yZGVyKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gZ2V0RmllbGRCeXRlc0xlbmd0aChmaWVsZE9yZGVyKTtcbiAgICByZXR1cm4gbGVuZ3RoICsgTWF0aC5jZWlsKGxlbmd0aCAvIDIpO1xufVxuLyoqXG4gKiBcIkNvbnN0YW50LXRpbWVcIiBwcml2YXRlIGtleSBnZW5lcmF0aW9uIHV0aWxpdHkuXG4gKiBDYW4gdGFrZSAobiArIG4vMikgb3IgbW9yZSBieXRlcyBvZiB1bmlmb3JtIGlucHV0IGUuZy4gZnJvbSBDU1BSTkcgb3IgS0RGXG4gKiBhbmQgY29udmVydCB0aGVtIGludG8gcHJpdmF0ZSBzY2FsYXIsIHdpdGggdGhlIG1vZHVsbyBiaWFzIGJlaW5nIG5lZ2xpZ2libGUuXG4gKiBOZWVkcyBhdCBsZWFzdCA0OCBieXRlcyBvZiBpbnB1dCBmb3IgMzItYnl0ZSBwcml2YXRlIGtleS5cbiAqIGh0dHBzOi8vcmVzZWFyY2gua3VkZWxza2lzZWN1cml0eS5jb20vMjAyMC8wNy8yOC90aGUtZGVmaW5pdGl2ZS1ndWlkZS10by1tb2R1bG8tYmlhcy1hbmQtaG93LXRvLWF2b2lkLWl0L1xuICogRklQUyAxODYtNSwgQS4yIGh0dHBzOi8vY3NyYy5uaXN0Lmdvdi9wdWJsaWNhdGlvbnMvZGV0YWlsL2ZpcHMvMTg2LzUvZmluYWxcbiAqIFJGQyA5MzgwLCBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTVcbiAqIEBwYXJhbSBoYXNoIGhhc2ggb3V0cHV0IGZyb20gU0hBMyBvciBhIHNpbWlsYXIgZnVuY3Rpb25cbiAqIEBwYXJhbSBncm91cE9yZGVyIHNpemUgb2Ygc3ViZ3JvdXAgLSAoZS5nLiBzZWNwMjU2azEuQ1VSVkUubilcbiAqIEBwYXJhbSBpc0xFIGludGVycHJldCBoYXNoIGJ5dGVzIGFzIExFIG51bVxuICogQHJldHVybnMgdmFsaWQgcHJpdmF0ZSBzY2FsYXJcbiAqL1xuZnVuY3Rpb24gbWFwSGFzaFRvRmllbGQoa2V5LCBmaWVsZE9yZGVyLCBpc0xFID0gZmFsc2UpIHtcbiAgICBjb25zdCBsZW4gPSBrZXkubGVuZ3RoO1xuICAgIGNvbnN0IGZpZWxkTGVuID0gZ2V0RmllbGRCeXRlc0xlbmd0aChmaWVsZE9yZGVyKTtcbiAgICBjb25zdCBtaW5MZW4gPSBnZXRNaW5IYXNoTGVuZ3RoKGZpZWxkT3JkZXIpO1xuICAgIC8vIE5vIHNtYWxsIG51bWJlcnM6IG5lZWQgdG8gdW5kZXJzdGFuZCBiaWFzIHN0b3J5LiBObyBodWdlIG51bWJlcnM6IGVhc2llciB0byBkZXRlY3QgSlMgdGltaW5ncy5cbiAgICBpZiAobGVuIDwgMTYgfHwgbGVuIDwgbWluTGVuIHx8IGxlbiA+IDEwMjQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgJyArIG1pbkxlbiArICctMTAyNCBieXRlcyBvZiBpbnB1dCwgZ290ICcgKyBsZW4pO1xuICAgIGNvbnN0IG51bSA9IGlzTEUgPyAoMCwgdXRpbHNfdHNfMS5ieXRlc1RvTnVtYmVyTEUpKGtleSkgOiAoMCwgdXRpbHNfdHNfMS5ieXRlc1RvTnVtYmVyQkUpKGtleSk7XG4gICAgLy8gYG1vZCh4LCAxMSlgIGNhbiBzb21ldGltZXMgcHJvZHVjZSAwLiBgbW9kKHgsIDEwKSArIDFgIGlzIHRoZSBzYW1lLCBidXQgbm8gMFxuICAgIGNvbnN0IHJlZHVjZWQgPSBtb2QobnVtLCBmaWVsZE9yZGVyIC0gXzFuKSArIF8xbjtcbiAgICByZXR1cm4gaXNMRSA/ICgwLCB1dGlsc190c18xLm51bWJlclRvQnl0ZXNMRSkocmVkdWNlZCwgZmllbGRMZW4pIDogKDAsIHV0aWxzX3RzXzEubnVtYmVyVG9CeXRlc0JFKShyZWR1Y2VkLCBmaWVsZExlbik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGFyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImlzTmVnYXRpdmVMRSIsIm1vZCIsInBvdyIsInBvdzIiLCJpbnZlcnQiLCJ0b25lbGxpU2hhbmtzIiwiRnBTcXJ0IiwidmFsaWRhdGVGaWVsZCIsIkZwUG93IiwiRnBJbnZlcnRCYXRjaCIsIkZwRGl2IiwiRnBMZWdlbmRyZSIsIkZwSXNTcXVhcmUiLCJuTGVuZ3RoIiwiRmllbGQiLCJGcFNxcnRPZGQiLCJGcFNxcnRFdmVuIiwiaGFzaFRvUHJpdmF0ZVNjYWxhciIsImdldEZpZWxkQnl0ZXNMZW5ndGgiLCJnZXRNaW5IYXNoTGVuZ3RoIiwibWFwSGFzaFRvRmllbGQiLCJ1dGlsc18xIiwicmVxdWlyZSIsInV0aWxzX3RzXzEiLCJfMG4iLCJCaWdJbnQiLCJfMW4iLCJfMm4iLCJfM24iLCJfNG4iLCJfNW4iLCJfOG4iLCJhIiwiYiIsInJlc3VsdCIsIm51bSIsInBvd2VyIiwibW9kdWxvIiwieCIsInJlcyIsIm51bWJlciIsIkVycm9yIiwieSIsInUiLCJ2IiwicSIsInIiLCJtIiwibiIsImdjZCIsInNxcnQzbW9kNCIsIkZwIiwicDFkaXY0IiwiT1JERVIiLCJyb290IiwiZXFsIiwic3FyIiwic3FydDVtb2Q4IiwicDVkaXY4IiwibjIiLCJtdWwiLCJudiIsImkiLCJzdWIiLCJPTkUiLCJQIiwiUSIsIlMiLCJaIiwiX0ZwIiwiY2MiLCJRMWRpdjIiLCJ0b25lbGxpU2xvdyIsImlzMCIsIk0iLCJjIiwidCIsIlIiLCJaRVJPIiwidF90bXAiLCJleHBvbmVudCIsIkZJRUxEX0ZJRUxEUyIsImZpZWxkIiwiaW5pdGlhbCIsIk1BU0siLCJCWVRFUyIsIkJJVFMiLCJvcHRzIiwicmVkdWNlIiwibWFwIiwidmFsIiwidmFsaWRhdGVPYmplY3QiLCJwIiwiZCIsIm51bXMiLCJwYXNzWmVybyIsImludmVydGVkIiwiQXJyYXkiLCJsZW5ndGgiLCJmaWxsIiwidW5kZWZpbmVkIiwibXVsdGlwbGllZEFjYyIsImFjYyIsImludmVydGVkQWNjIiwiaW52IiwicmVkdWNlUmlnaHQiLCJsaHMiLCJyaHMiLCJwMW1vZDIiLCJwb3dlcmVkIiwieWVzIiwiemVybyIsIm5vIiwibmVnIiwibCIsIm5CaXRMZW5ndGgiLCJhbnVtYmVyIiwiX25CaXRMZW5ndGgiLCJ0b1N0cmluZyIsIm5CeXRlTGVuZ3RoIiwiTWF0aCIsImNlaWwiLCJiaXRMZW4iLCJpc0xFIiwicmVkZWYiLCJzcXJ0UCIsImYiLCJmcmVlemUiLCJiaXRNYXNrIiwiY3JlYXRlIiwiaXNWYWxpZCIsImlzT2RkIiwiYWRkIiwiZGl2Iiwic3FyTiIsImFkZE4iLCJzdWJOIiwibXVsTiIsInNxcnQiLCJ0b0J5dGVzIiwibnVtYmVyVG9CeXRlc0xFIiwibnVtYmVyVG9CeXRlc0JFIiwiZnJvbUJ5dGVzIiwiYnl0ZXMiLCJieXRlc1RvTnVtYmVyTEUiLCJieXRlc1RvTnVtYmVyQkUiLCJpbnZlcnRCYXRjaCIsImxzdCIsImNtb3YiLCJlbG0iLCJoYXNoIiwiZ3JvdXBPcmRlciIsImVuc3VyZUJ5dGVzIiwiaGFzaExlbiIsIm1pbkxlbiIsImZpZWxkT3JkZXIiLCJiaXRMZW5ndGgiLCJrZXkiLCJsZW4iLCJmaWVsZExlbiIsInJlZHVjZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/@noble/curves/abstract/modular.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/@noble/curves/abstract/utils.js":
/*!**********************************************************************!*\
  !*** ./node_modules/ox/node_modules/@noble/curves/abstract/utils.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/**\n * Hex, bytes and number utilities.\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.notImplemented = exports.bitMask = void 0;\nexports.isBytes = isBytes;\nexports.abytes = abytes;\nexports.abool = abool;\nexports.numberToHexUnpadded = numberToHexUnpadded;\nexports.hexToNumber = hexToNumber;\nexports.bytesToHex = bytesToHex;\nexports.hexToBytes = hexToBytes;\nexports.bytesToNumberBE = bytesToNumberBE;\nexports.bytesToNumberLE = bytesToNumberLE;\nexports.numberToBytesBE = numberToBytesBE;\nexports.numberToBytesLE = numberToBytesLE;\nexports.numberToVarBytesBE = numberToVarBytesBE;\nexports.ensureBytes = ensureBytes;\nexports.concatBytes = concatBytes;\nexports.equalBytes = equalBytes;\nexports.utf8ToBytes = utf8ToBytes;\nexports.inRange = inRange;\nexports.aInRange = aInRange;\nexports.bitLen = bitLen;\nexports.bitGet = bitGet;\nexports.bitSet = bitSet;\nexports.createHmacDrbg = createHmacDrbg;\nexports.validateObject = validateObject;\nexports.memoized = memoized;\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nfunction isBytes(a) {\n    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === \"Uint8Array\";\n}\nfunction abytes(item) {\n    if (!isBytes(item)) throw new Error(\"Uint8Array expected\");\n}\nfunction abool(title, value) {\n    if (typeof value !== \"boolean\") throw new Error(title + \" boolean expected, got \" + value);\n}\n// Used in weierstrass, der\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? \"0\" + hex : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    return hex === \"\" ? _0n : BigInt(\"0x\" + hex); // Big Endian\n}\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin = // @ts-ignore\ntypeof Uint8Array.from([]).toHex === \"function\" && typeof Uint8Array.fromHex === \"function\";\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({\n    length: 256\n}, (_, i)=>i.toString(16).padStart(2, \"0\"));\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */ function bytesToHex(bytes) {\n    abytes(bytes);\n    // @ts-ignore\n    if (hasHexBuiltin) return bytes.toHex();\n    // pre-caching improves the speed 6x\n    let hex = \"\";\n    for(let i = 0; i < bytes.length; i++){\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = {\n    _0: 48,\n    _9: 57,\n    A: 65,\n    F: 70,\n    a: 97,\n    f: 102\n};\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */ function hexToBytes(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    // @ts-ignore\n    if (hasHexBuiltin) return Uint8Array.fromHex(hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2) throw new Error(\"hex string expected, got unpadded hex of length \" + hl);\n    const array = new Uint8Array(al);\n    for(let ai = 0, hi = 0; ai < al; ai++, hi += 2){\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction bytesToNumberLE(bytes) {\n    abytes(bytes);\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nfunction numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, \"0\"));\n}\nfunction numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */ function ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === \"string\") {\n        try {\n            res = hexToBytes(hex);\n        } catch (e) {\n            throw new Error(title + \" must be hex string or Uint8Array, cause: \" + e);\n        }\n    } else if (isBytes(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    } else {\n        throw new Error(title + \" must be hex string or Uint8Array\");\n    }\n    const len = res.length;\n    if (typeof expectedLength === \"number\" && len !== expectedLength) throw new Error(title + \" of length \" + expectedLength + \" expected, got \" + len);\n    return res;\n}\n/**\n * Copies several Uint8Arrays into one.\n */ function concatBytes(...arrays) {\n    let sum = 0;\n    for(let i = 0; i < arrays.length; i++){\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for(let i = 0, pad = 0; i < arrays.length; i++){\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// Compares 2 u8a-s in kinda constant time\nfunction equalBytes(a, b) {\n    if (a.length !== b.length) return false;\n    let diff = 0;\n    for(let i = 0; i < a.length; i++)diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */ function utf8ToBytes(str) {\n    if (typeof str !== \"string\") throw new Error(\"string expected\");\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n// Is positive bigint\nconst isPosBig = (n)=>typeof n === \"bigint\" && _0n <= n;\nfunction inRange(n, min, max) {\n    return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n}\n/**\n * Asserts min <= n < max. NOTE: It's < max and not <= max.\n * @example\n * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\n */ function aInRange(title, n, min, max) {\n    // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\n    // consider P=256n, min=0n, max=P\n    // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\n    // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\n    // - our way is the cleanest:               `inRange('x', x, 0n, P)\n    if (!inRange(n, min, max)) throw new Error(\"expected valid \" + title + \": \" + min + \" <= n < \" + max + \", got \" + n);\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n * TODO: merge with nLength in modular\n */ function bitLen(n) {\n    let len;\n    for(len = 0; n > _0n; n >>= _1n, len += 1);\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */ function bitGet(n, pos) {\n    return n >> BigInt(pos) & _1n;\n}\n/**\n * Sets single bit at position.\n */ function bitSet(n, pos, value) {\n    return n | (value ? _1n : _0n) << BigInt(pos);\n}\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */ const bitMask = (n)=>(_1n << BigInt(n)) - _1n;\nexports.bitMask = bitMask;\n// DRBG\nconst u8n = (len)=>new Uint8Array(len); // creates Uint8Array\nconst u8fr = (arr)=>Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */ function createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== \"number\" || hashLen < 2) throw new Error(\"hashLen must be a number\");\n    if (typeof qByteLen !== \"number\" || qByteLen < 2) throw new Error(\"qByteLen must be a number\");\n    if (typeof hmacFn !== \"function\") throw new Error(\"hmacFn must be a function\");\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = ()=>{\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b)=>hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n(0))=>{\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([\n            0x00\n        ]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0) return;\n        k = h(u8fr([\n            0x01\n        ]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = ()=>{\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000) throw new Error(\"drbg: tried 1000 values\");\n        let len = 0;\n        const out = [];\n        while(len < qByteLen){\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred)=>{\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while(!(res = pred(gen())))reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val)=>typeof val === \"bigint\",\n    function: (val)=>typeof val === \"function\",\n    boolean: (val)=>typeof val === \"boolean\",\n    string: (val)=>typeof val === \"string\",\n    stringOrUint8Array: (val)=>typeof val === \"string\" || isBytes(val),\n    isSafeInteger: (val)=>Number.isSafeInteger(val),\n    array: (val)=>Array.isArray(val),\n    field: (val, object)=>object.Fp.isValid(val),\n    hash: (val)=>typeof val === \"function\" && Number.isSafeInteger(val.outputLen)\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional)=>{\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== \"function\") throw new Error(\"invalid validator function\");\n        const val = object[fieldName];\n        if (isOptional && val === undefined) return;\n        if (!checkVal(val, object)) {\n            throw new Error(\"param \" + String(fieldName) + \" is invalid. Expected \" + type + \", got \" + val);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))checkField(fieldName, type, true);\n    return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n/**\n * throws not implemented error\n */ const notImplemented = ()=>{\n    throw new Error(\"not implemented\");\n};\nexports.notImplemented = notImplemented;\n/**\n * Memoizes (caches) computation result.\n * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\n */ function memoized(fn) {\n    const map = new WeakMap();\n    return (arg, ...args)=>{\n        const val = map.get(arg);\n        if (val !== undefined) return val;\n        const computed = fn(arg, ...args);\n        map.set(arg, computed);\n        return computed;\n    };\n} //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvYWJzdHJhY3QvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7O0NBR0MsR0FDRCxvRUFBb0UsR0FDcEVBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxzQkFBc0IsR0FBR0EsZUFBZSxHQUFHLEtBQUs7QUFDaERBLGVBQWUsR0FBR0k7QUFDbEJKLGNBQWMsR0FBR0s7QUFDakJMLGFBQWEsR0FBR007QUFDaEJOLDJCQUEyQixHQUFHTztBQUM5QlAsbUJBQW1CLEdBQUdRO0FBQ3RCUixrQkFBa0IsR0FBR1M7QUFDckJULGtCQUFrQixHQUFHVTtBQUNyQlYsdUJBQXVCLEdBQUdXO0FBQzFCWCx1QkFBdUIsR0FBR1k7QUFDMUJaLHVCQUF1QixHQUFHYTtBQUMxQmIsdUJBQXVCLEdBQUdjO0FBQzFCZCwwQkFBMEIsR0FBR2U7QUFDN0JmLG1CQUFtQixHQUFHZ0I7QUFDdEJoQixtQkFBbUIsR0FBR2lCO0FBQ3RCakIsa0JBQWtCLEdBQUdrQjtBQUNyQmxCLG1CQUFtQixHQUFHbUI7QUFDdEJuQixlQUFlLEdBQUdvQjtBQUNsQnBCLGdCQUFnQixHQUFHcUI7QUFDbkJyQixjQUFjLEdBQUdzQjtBQUNqQnRCLGNBQWMsR0FBR3VCO0FBQ2pCdkIsY0FBYyxHQUFHd0I7QUFDakJ4QixzQkFBc0IsR0FBR3lCO0FBQ3pCekIsc0JBQXNCLEdBQUcwQjtBQUN6QjFCLGdCQUFnQixHQUFHMkI7QUFDbkIsMEVBQTBFO0FBQzFFLDhEQUE4RDtBQUM5RCwrRUFBK0U7QUFDL0UsdUNBQXVDO0FBQ3ZDLE1BQU1DLE1BQU0sYUFBYSxHQUFHQyxPQUFPO0FBQ25DLE1BQU1DLE1BQU0sYUFBYSxHQUFHRCxPQUFPO0FBQ25DLFNBQVN6QixRQUFRMkIsQ0FBQztJQUNkLE9BQU9BLGFBQWFDLGNBQWVDLFlBQVlDLE1BQU0sQ0FBQ0gsTUFBTUEsRUFBRUksV0FBVyxDQUFDQyxJQUFJLEtBQUs7QUFDdkY7QUFDQSxTQUFTL0IsT0FBT2dDLElBQUk7SUFDaEIsSUFBSSxDQUFDakMsUUFBUWlDLE9BQ1QsTUFBTSxJQUFJQyxNQUFNO0FBQ3hCO0FBQ0EsU0FBU2hDLE1BQU1pQyxLQUFLLEVBQUV0QyxLQUFLO0lBQ3ZCLElBQUksT0FBT0EsVUFBVSxXQUNqQixNQUFNLElBQUlxQyxNQUFNQyxRQUFRLDRCQUE0QnRDO0FBQzVEO0FBQ0EsMkJBQTJCO0FBQzNCLFNBQVNNLG9CQUFvQmlDLEdBQUc7SUFDNUIsTUFBTUMsTUFBTUQsSUFBSUUsUUFBUSxDQUFDO0lBQ3pCLE9BQU9ELElBQUlFLE1BQU0sR0FBRyxJQUFJLE1BQU1GLE1BQU1BO0FBQ3hDO0FBQ0EsU0FBU2pDLFlBQVlpQyxHQUFHO0lBQ3BCLElBQUksT0FBT0EsUUFBUSxVQUNmLE1BQU0sSUFBSUgsTUFBTSw4QkFBOEIsT0FBT0c7SUFDekQsT0FBT0EsUUFBUSxLQUFLYixNQUFNQyxPQUFPLE9BQU9ZLE1BQU0sYUFBYTtBQUMvRDtBQUNBLHlGQUF5RjtBQUN6RixNQUFNRyxnQkFDTixhQUFhO0FBQ2IsT0FBT1osV0FBV2EsSUFBSSxDQUFDLEVBQUUsRUFBRUMsS0FBSyxLQUFLLGNBQWMsT0FBT2QsV0FBV2UsT0FBTyxLQUFLO0FBQ2pGLHdEQUF3RDtBQUN4RCxNQUFNQyxRQUFRLGFBQWEsR0FBR0MsTUFBTUosSUFBSSxDQUFDO0lBQUVGLFFBQVE7QUFBSSxHQUFHLENBQUNPLEdBQUdDLElBQU1BLEVBQUVULFFBQVEsQ0FBQyxJQUFJVSxRQUFRLENBQUMsR0FBRztBQUMvRjs7O0NBR0MsR0FDRCxTQUFTM0MsV0FBVzRDLEtBQUs7SUFDckJoRCxPQUFPZ0Q7SUFDUCxhQUFhO0lBQ2IsSUFBSVQsZUFDQSxPQUFPUyxNQUFNUCxLQUFLO0lBQ3RCLG9DQUFvQztJQUNwQyxJQUFJTCxNQUFNO0lBQ1YsSUFBSyxJQUFJVSxJQUFJLEdBQUdBLElBQUlFLE1BQU1WLE1BQU0sRUFBRVEsSUFBSztRQUNuQ1YsT0FBT08sS0FBSyxDQUFDSyxLQUFLLENBQUNGLEVBQUUsQ0FBQztJQUMxQjtJQUNBLE9BQU9WO0FBQ1g7QUFDQSxpRUFBaUU7QUFDakUsTUFBTWEsU0FBUztJQUFFQyxJQUFJO0lBQUlDLElBQUk7SUFBSUMsR0FBRztJQUFJQyxHQUFHO0lBQUkzQixHQUFHO0lBQUk0QixHQUFHO0FBQUk7QUFDN0QsU0FBU0MsY0FBY0MsRUFBRTtJQUNyQixJQUFJQSxNQUFNUCxPQUFPQyxFQUFFLElBQUlNLE1BQU1QLE9BQU9FLEVBQUUsRUFDbEMsT0FBT0ssS0FBS1AsT0FBT0MsRUFBRSxFQUFFLGVBQWU7SUFDMUMsSUFBSU0sTUFBTVAsT0FBT0csQ0FBQyxJQUFJSSxNQUFNUCxPQUFPSSxDQUFDLEVBQ2hDLE9BQU9HLEtBQU1QLENBQUFBLE9BQU9HLENBQUMsR0FBRyxFQUFDLEdBQUksb0JBQW9CO0lBQ3JELElBQUlJLE1BQU1QLE9BQU92QixDQUFDLElBQUk4QixNQUFNUCxPQUFPSyxDQUFDLEVBQ2hDLE9BQU9FLEtBQU1QLENBQUFBLE9BQU92QixDQUFDLEdBQUcsRUFBQyxHQUFJLG9CQUFvQjtJQUNyRDtBQUNKO0FBQ0E7OztDQUdDLEdBQ0QsU0FBU3JCLFdBQVcrQixHQUFHO0lBQ25CLElBQUksT0FBT0EsUUFBUSxVQUNmLE1BQU0sSUFBSUgsTUFBTSw4QkFBOEIsT0FBT0c7SUFDekQsYUFBYTtJQUNiLElBQUlHLGVBQ0EsT0FBT1osV0FBV2UsT0FBTyxDQUFDTjtJQUM5QixNQUFNcUIsS0FBS3JCLElBQUlFLE1BQU07SUFDckIsTUFBTW9CLEtBQUtELEtBQUs7SUFDaEIsSUFBSUEsS0FBSyxHQUNMLE1BQU0sSUFBSXhCLE1BQU0scURBQXFEd0I7SUFDekUsTUFBTUUsUUFBUSxJQUFJaEMsV0FBVytCO0lBQzdCLElBQUssSUFBSUUsS0FBSyxHQUFHQyxLQUFLLEdBQUdELEtBQUtGLElBQUlFLE1BQU1DLE1BQU0sRUFBRztRQUM3QyxNQUFNQyxLQUFLUCxjQUFjbkIsSUFBSTJCLFVBQVUsQ0FBQ0Y7UUFDeEMsTUFBTUcsS0FBS1QsY0FBY25CLElBQUkyQixVQUFVLENBQUNGLEtBQUs7UUFDN0MsSUFBSUMsT0FBT0csYUFBYUQsT0FBT0MsV0FBVztZQUN0QyxNQUFNQyxPQUFPOUIsR0FBRyxDQUFDeUIsR0FBRyxHQUFHekIsR0FBRyxDQUFDeUIsS0FBSyxFQUFFO1lBQ2xDLE1BQU0sSUFBSTVCLE1BQU0saURBQWlEaUMsT0FBTyxnQkFBZ0JMO1FBQzVGO1FBQ0FGLEtBQUssQ0FBQ0MsR0FBRyxHQUFHRSxLQUFLLEtBQUtFLElBQUksK0RBQStEO0lBQzdGO0lBQ0EsT0FBT0w7QUFDWDtBQUNBLG9DQUFvQztBQUNwQyxTQUFTckQsZ0JBQWdCMEMsS0FBSztJQUMxQixPQUFPN0MsWUFBWUMsV0FBVzRDO0FBQ2xDO0FBQ0EsU0FBU3pDLGdCQUFnQnlDLEtBQUs7SUFDMUJoRCxPQUFPZ0Q7SUFDUCxPQUFPN0MsWUFBWUMsV0FBV3VCLFdBQVdhLElBQUksQ0FBQ1EsT0FBT21CLE9BQU87QUFDaEU7QUFDQSxTQUFTM0QsZ0JBQWdCNEQsQ0FBQyxFQUFFQyxHQUFHO0lBQzNCLE9BQU9oRSxXQUFXK0QsRUFBRS9CLFFBQVEsQ0FBQyxJQUFJVSxRQUFRLENBQUNzQixNQUFNLEdBQUc7QUFDdkQ7QUFDQSxTQUFTNUQsZ0JBQWdCMkQsQ0FBQyxFQUFFQyxHQUFHO0lBQzNCLE9BQU83RCxnQkFBZ0I0RCxHQUFHQyxLQUFLRixPQUFPO0FBQzFDO0FBQ0Esd0JBQXdCO0FBQ3hCLFNBQVN6RCxtQkFBbUIwRCxDQUFDO0lBQ3pCLE9BQU8vRCxXQUFXSCxvQkFBb0JrRTtBQUMxQztBQUNBOzs7Ozs7OztDQVFDLEdBQ0QsU0FBU3pELFlBQVl1QixLQUFLLEVBQUVFLEdBQUcsRUFBRWtDLGNBQWM7SUFDM0MsSUFBSUM7SUFDSixJQUFJLE9BQU9uQyxRQUFRLFVBQVU7UUFDekIsSUFBSTtZQUNBbUMsTUFBTWxFLFdBQVcrQjtRQUNyQixFQUNBLE9BQU9vQyxHQUFHO1lBQ04sTUFBTSxJQUFJdkMsTUFBTUMsUUFBUSwrQ0FBK0NzQztRQUMzRTtJQUNKLE9BQ0ssSUFBSXpFLFFBQVFxQyxNQUFNO1FBQ25CLG1FQUFtRTtRQUNuRSxzRUFBc0U7UUFDdEVtQyxNQUFNNUMsV0FBV2EsSUFBSSxDQUFDSjtJQUMxQixPQUNLO1FBQ0QsTUFBTSxJQUFJSCxNQUFNQyxRQUFRO0lBQzVCO0lBQ0EsTUFBTW1DLE1BQU1FLElBQUlqQyxNQUFNO0lBQ3RCLElBQUksT0FBT2dDLG1CQUFtQixZQUFZRCxRQUFRQyxnQkFDOUMsTUFBTSxJQUFJckMsTUFBTUMsUUFBUSxnQkFBZ0JvQyxpQkFBaUIsb0JBQW9CRDtJQUNqRixPQUFPRTtBQUNYO0FBQ0E7O0NBRUMsR0FDRCxTQUFTM0QsWUFBWSxHQUFHNkQsTUFBTTtJQUMxQixJQUFJQyxNQUFNO0lBQ1YsSUFBSyxJQUFJNUIsSUFBSSxHQUFHQSxJQUFJMkIsT0FBT25DLE1BQU0sRUFBRVEsSUFBSztRQUNwQyxNQUFNcEIsSUFBSStDLE1BQU0sQ0FBQzNCLEVBQUU7UUFDbkI5QyxPQUFPMEI7UUFDUGdELE9BQU9oRCxFQUFFWSxNQUFNO0lBQ25CO0lBQ0EsTUFBTWlDLE1BQU0sSUFBSTVDLFdBQVcrQztJQUMzQixJQUFLLElBQUk1QixJQUFJLEdBQUc2QixNQUFNLEdBQUc3QixJQUFJMkIsT0FBT25DLE1BQU0sRUFBRVEsSUFBSztRQUM3QyxNQUFNcEIsSUFBSStDLE1BQU0sQ0FBQzNCLEVBQUU7UUFDbkJ5QixJQUFJSyxHQUFHLENBQUNsRCxHQUFHaUQ7UUFDWEEsT0FBT2pELEVBQUVZLE1BQU07SUFDbkI7SUFDQSxPQUFPaUM7QUFDWDtBQUNBLDBDQUEwQztBQUMxQyxTQUFTMUQsV0FBV2EsQ0FBQyxFQUFFbUQsQ0FBQztJQUNwQixJQUFJbkQsRUFBRVksTUFBTSxLQUFLdUMsRUFBRXZDLE1BQU0sRUFDckIsT0FBTztJQUNYLElBQUl3QyxPQUFPO0lBQ1gsSUFBSyxJQUFJaEMsSUFBSSxHQUFHQSxJQUFJcEIsRUFBRVksTUFBTSxFQUFFUSxJQUMxQmdDLFFBQVFwRCxDQUFDLENBQUNvQixFQUFFLEdBQUcrQixDQUFDLENBQUMvQixFQUFFO0lBQ3ZCLE9BQU9nQyxTQUFTO0FBQ3BCO0FBQ0E7O0NBRUMsR0FDRCxTQUFTaEUsWUFBWWlFLEdBQUc7SUFDcEIsSUFBSSxPQUFPQSxRQUFRLFVBQ2YsTUFBTSxJQUFJOUMsTUFBTTtJQUNwQixPQUFPLElBQUlOLFdBQVcsSUFBSXFELGNBQWNDLE1BQU0sQ0FBQ0YsT0FBTyw0QkFBNEI7QUFDdEY7QUFDQSxxQkFBcUI7QUFDckIsTUFBTUcsV0FBVyxDQUFDZCxJQUFNLE9BQU9BLE1BQU0sWUFBWTdDLE9BQU82QztBQUN4RCxTQUFTckQsUUFBUXFELENBQUMsRUFBRWUsR0FBRyxFQUFFQyxHQUFHO0lBQ3hCLE9BQU9GLFNBQVNkLE1BQU1jLFNBQVNDLFFBQVFELFNBQVNFLFFBQVFELE9BQU9mLEtBQUtBLElBQUlnQjtBQUM1RTtBQUNBOzs7O0NBSUMsR0FDRCxTQUFTcEUsU0FBU2tCLEtBQUssRUFBRWtDLENBQUMsRUFBRWUsR0FBRyxFQUFFQyxHQUFHO0lBQ2hDLHVFQUF1RTtJQUN2RSxpQ0FBaUM7SUFDakMscUVBQXFFO0lBQ3JFLHlFQUF5RTtJQUN6RSxtRUFBbUU7SUFDbkUsSUFBSSxDQUFDckUsUUFBUXFELEdBQUdlLEtBQUtDLE1BQ2pCLE1BQU0sSUFBSW5ELE1BQU0sb0JBQW9CQyxRQUFRLE9BQU9pRCxNQUFNLGFBQWFDLE1BQU0sV0FBV2hCO0FBQy9GO0FBQ0EsaUJBQWlCO0FBQ2pCOzs7O0NBSUMsR0FDRCxTQUFTbkQsT0FBT21ELENBQUM7SUFDYixJQUFJQztJQUNKLElBQUtBLE1BQU0sR0FBR0QsSUFBSTdDLEtBQUs2QyxNQUFNM0MsS0FBSzRDLE9BQU87SUFFekMsT0FBT0E7QUFDWDtBQUNBOzs7O0NBSUMsR0FDRCxTQUFTbkQsT0FBT2tELENBQUMsRUFBRWlCLEdBQUc7SUFDbEIsT0FBTyxLQUFNN0QsT0FBTzZELE9BQVE1RDtBQUNoQztBQUNBOztDQUVDLEdBQ0QsU0FBU04sT0FBT2lELENBQUMsRUFBRWlCLEdBQUcsRUFBRXpGLEtBQUs7SUFDekIsT0FBT3dFLElBQUssQ0FBQ3hFLFFBQVE2QixNQUFNRixHQUFFLEtBQU1DLE9BQU82RDtBQUM5QztBQUNBOzs7Q0FHQyxHQUNELE1BQU12RixVQUFVLENBQUNzRSxJQUFNLENBQUMzQyxPQUFPRCxPQUFPNEMsRUFBQyxJQUFLM0M7QUFDNUM5QixlQUFlLEdBQUdHO0FBQ2xCLE9BQU87QUFDUCxNQUFNd0YsTUFBTSxDQUFDakIsTUFBUSxJQUFJMUMsV0FBVzBDLE1BQU0scUJBQXFCO0FBQy9ELE1BQU1rQixPQUFPLENBQUNDLE1BQVE3RCxXQUFXYSxJQUFJLENBQUNnRCxNQUFNLG1CQUFtQjtBQUMvRDs7Ozs7O0NBTUMsR0FDRCxTQUFTcEUsZUFBZXFFLE9BQU8sRUFBRUMsUUFBUSxFQUFFQyxNQUFNO0lBQzdDLElBQUksT0FBT0YsWUFBWSxZQUFZQSxVQUFVLEdBQ3pDLE1BQU0sSUFBSXhELE1BQU07SUFDcEIsSUFBSSxPQUFPeUQsYUFBYSxZQUFZQSxXQUFXLEdBQzNDLE1BQU0sSUFBSXpELE1BQU07SUFDcEIsSUFBSSxPQUFPMEQsV0FBVyxZQUNsQixNQUFNLElBQUkxRCxNQUFNO0lBQ3BCLGdEQUFnRDtJQUNoRCxJQUFJMkQsSUFBSU4sSUFBSUcsVUFBVSxxRUFBcUU7SUFDM0YsSUFBSUksSUFBSVAsSUFBSUcsVUFBVSxxRUFBcUU7SUFDM0YsSUFBSTNDLElBQUksR0FBRyxnREFBZ0Q7SUFDM0QsTUFBTWdELFFBQVE7UUFDVkYsRUFBRUcsSUFBSSxDQUFDO1FBQ1BGLEVBQUVFLElBQUksQ0FBQztRQUNQakQsSUFBSTtJQUNSO0lBQ0EsTUFBTWtELElBQUksQ0FBQyxHQUFHbkIsSUFBTWMsT0FBT0UsR0FBR0QsTUFBTWYsSUFBSSx3QkFBd0I7SUFDaEUsTUFBTW9CLFNBQVMsQ0FBQ0MsT0FBT1osSUFBSSxFQUFFO1FBQ3pCLHlDQUF5QztRQUN6Q08sSUFBSUcsRUFBRVQsS0FBSztZQUFDO1NBQUssR0FBR1csT0FBTyxtQ0FBbUM7UUFDOUROLElBQUlJLEtBQUssbUJBQW1CO1FBQzVCLElBQUlFLEtBQUs1RCxNQUFNLEtBQUssR0FDaEI7UUFDSnVELElBQUlHLEVBQUVULEtBQUs7WUFBQztTQUFLLEdBQUdXLE9BQU8sbUNBQW1DO1FBQzlETixJQUFJSSxLQUFLLG1CQUFtQjtJQUNoQztJQUNBLE1BQU1HLE1BQU07UUFDUixnQ0FBZ0M7UUFDaEMsSUFBSXJELE9BQU8sTUFDUCxNQUFNLElBQUliLE1BQU07UUFDcEIsSUFBSW9DLE1BQU07UUFDVixNQUFNK0IsTUFBTSxFQUFFO1FBQ2QsTUFBTy9CLE1BQU1xQixTQUFVO1lBQ25CRSxJQUFJSTtZQUNKLE1BQU1LLEtBQUtULEVBQUVVLEtBQUs7WUFDbEJGLElBQUlHLElBQUksQ0FBQ0Y7WUFDVGhDLE9BQU91QixFQUFFdEQsTUFBTTtRQUNuQjtRQUNBLE9BQU8xQixlQUFld0Y7SUFDMUI7SUFDQSxNQUFNSSxXQUFXLENBQUNOLE1BQU1PO1FBQ3BCWDtRQUNBRyxPQUFPQyxPQUFPLFlBQVk7UUFDMUIsSUFBSTNCLE1BQU1OLFdBQVcsdUNBQXVDO1FBQzVELE1BQU8sQ0FBRU0sQ0FBQUEsTUFBTWtDLEtBQUtOLE1BQUssRUFDckJGO1FBQ0pIO1FBQ0EsT0FBT3ZCO0lBQ1g7SUFDQSxPQUFPaUM7QUFDWDtBQUNBLCtCQUErQjtBQUMvQixNQUFNRSxlQUFlO0lBQ2pCQyxRQUFRLENBQUNDLE1BQVEsT0FBT0EsUUFBUTtJQUNoQ0MsVUFBVSxDQUFDRCxNQUFRLE9BQU9BLFFBQVE7SUFDbENFLFNBQVMsQ0FBQ0YsTUFBUSxPQUFPQSxRQUFRO0lBQ2pDRyxRQUFRLENBQUNILE1BQVEsT0FBT0EsUUFBUTtJQUNoQ0ksb0JBQW9CLENBQUNKLE1BQVEsT0FBT0EsUUFBUSxZQUFZN0csUUFBUTZHO0lBQ2hFSyxlQUFlLENBQUNMLE1BQVFNLE9BQU9ELGFBQWEsQ0FBQ0w7SUFDN0NqRCxPQUFPLENBQUNpRCxNQUFRaEUsTUFBTXVFLE9BQU8sQ0FBQ1A7SUFDOUJRLE9BQU8sQ0FBQ1IsS0FBS1MsU0FBV0EsT0FBT0MsRUFBRSxDQUFDQyxPQUFPLENBQUNYO0lBQzFDWSxNQUFNLENBQUNaLE1BQVEsT0FBT0EsUUFBUSxjQUFjTSxPQUFPRCxhQUFhLENBQUNMLElBQUlhLFNBQVM7QUFDbEY7QUFDQSx3RUFBd0U7QUFDeEUsU0FBU3BHLGVBQWVnRyxNQUFNLEVBQUVLLFVBQVUsRUFBRUMsZ0JBQWdCLENBQUMsQ0FBQztJQUMxRCxNQUFNQyxhQUFhLENBQUNDLFdBQVdDLE1BQU1DO1FBQ2pDLE1BQU1DLFdBQVd0QixZQUFZLENBQUNvQixLQUFLO1FBQ25DLElBQUksT0FBT0UsYUFBYSxZQUNwQixNQUFNLElBQUkvRixNQUFNO1FBQ3BCLE1BQU0yRSxNQUFNUyxNQUFNLENBQUNRLFVBQVU7UUFDN0IsSUFBSUUsY0FBY25CLFFBQVEzQyxXQUN0QjtRQUNKLElBQUksQ0FBQytELFNBQVNwQixLQUFLUyxTQUFTO1lBQ3hCLE1BQU0sSUFBSXBGLE1BQU0sV0FBV2dHLE9BQU9KLGFBQWEsMkJBQTJCQyxPQUFPLFdBQVdsQjtRQUNoRztJQUNKO0lBQ0EsS0FBSyxNQUFNLENBQUNpQixXQUFXQyxLQUFLLElBQUlySSxPQUFPeUksT0FBTyxDQUFDUixZQUMzQ0UsV0FBV0MsV0FBV0MsTUFBTTtJQUNoQyxLQUFLLE1BQU0sQ0FBQ0QsV0FBV0MsS0FBSyxJQUFJckksT0FBT3lJLE9BQU8sQ0FBQ1AsZUFDM0NDLFdBQVdDLFdBQVdDLE1BQU07SUFDaEMsT0FBT1Q7QUFDWDtBQUNBLHNCQUFzQjtBQUN0Qix1RUFBdUU7QUFDdkUsZ0ZBQWdGO0FBQ2hGLDRCQUE0QjtBQUM1QiwyREFBMkQ7QUFDM0QscUVBQXFFO0FBQ3JFLCtEQUErRDtBQUMvRCw0REFBNEQ7QUFDNUQ7O0NBRUMsR0FDRCxNQUFNeEgsaUJBQWlCO0lBQ25CLE1BQU0sSUFBSW9DLE1BQU07QUFDcEI7QUFDQXRDLHNCQUFzQixHQUFHRTtBQUN6Qjs7O0NBR0MsR0FDRCxTQUFTeUIsU0FBUzZHLEVBQUU7SUFDaEIsTUFBTUMsTUFBTSxJQUFJQztJQUNoQixPQUFPLENBQUNDLEtBQUssR0FBR0M7UUFDWixNQUFNM0IsTUFBTXdCLElBQUlJLEdBQUcsQ0FBQ0Y7UUFDcEIsSUFBSTFCLFFBQVEzQyxXQUNSLE9BQU8yQztRQUNYLE1BQU02QixXQUFXTixHQUFHRyxRQUFRQztRQUM1QkgsSUFBSXhELEdBQUcsQ0FBQzBELEtBQUtHO1FBQ2IsT0FBT0E7SUFDWDtBQUNKLEVBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xhdy13b3Jrcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC91dGlscy5qcz83NzQ5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBIZXgsIGJ5dGVzIGFuZCBudW1iZXIgdXRpbGl0aWVzLlxuICogQG1vZHVsZVxuICovXG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm5vdEltcGxlbWVudGVkID0gZXhwb3J0cy5iaXRNYXNrID0gdm9pZCAwO1xuZXhwb3J0cy5pc0J5dGVzID0gaXNCeXRlcztcbmV4cG9ydHMuYWJ5dGVzID0gYWJ5dGVzO1xuZXhwb3J0cy5hYm9vbCA9IGFib29sO1xuZXhwb3J0cy5udW1iZXJUb0hleFVucGFkZGVkID0gbnVtYmVyVG9IZXhVbnBhZGRlZDtcbmV4cG9ydHMuaGV4VG9OdW1iZXIgPSBoZXhUb051bWJlcjtcbmV4cG9ydHMuYnl0ZXNUb0hleCA9IGJ5dGVzVG9IZXg7XG5leHBvcnRzLmhleFRvQnl0ZXMgPSBoZXhUb0J5dGVzO1xuZXhwb3J0cy5ieXRlc1RvTnVtYmVyQkUgPSBieXRlc1RvTnVtYmVyQkU7XG5leHBvcnRzLmJ5dGVzVG9OdW1iZXJMRSA9IGJ5dGVzVG9OdW1iZXJMRTtcbmV4cG9ydHMubnVtYmVyVG9CeXRlc0JFID0gbnVtYmVyVG9CeXRlc0JFO1xuZXhwb3J0cy5udW1iZXJUb0J5dGVzTEUgPSBudW1iZXJUb0J5dGVzTEU7XG5leHBvcnRzLm51bWJlclRvVmFyQnl0ZXNCRSA9IG51bWJlclRvVmFyQnl0ZXNCRTtcbmV4cG9ydHMuZW5zdXJlQnl0ZXMgPSBlbnN1cmVCeXRlcztcbmV4cG9ydHMuY29uY2F0Qnl0ZXMgPSBjb25jYXRCeXRlcztcbmV4cG9ydHMuZXF1YWxCeXRlcyA9IGVxdWFsQnl0ZXM7XG5leHBvcnRzLnV0ZjhUb0J5dGVzID0gdXRmOFRvQnl0ZXM7XG5leHBvcnRzLmluUmFuZ2UgPSBpblJhbmdlO1xuZXhwb3J0cy5hSW5SYW5nZSA9IGFJblJhbmdlO1xuZXhwb3J0cy5iaXRMZW4gPSBiaXRMZW47XG5leHBvcnRzLmJpdEdldCA9IGJpdEdldDtcbmV4cG9ydHMuYml0U2V0ID0gYml0U2V0O1xuZXhwb3J0cy5jcmVhdGVIbWFjRHJiZyA9IGNyZWF0ZUhtYWNEcmJnO1xuZXhwb3J0cy52YWxpZGF0ZU9iamVjdCA9IHZhbGlkYXRlT2JqZWN0O1xuZXhwb3J0cy5tZW1vaXplZCA9IG1lbW9pemVkO1xuLy8gMTAwIGxpbmVzIG9mIGNvZGUgaW4gdGhlIGZpbGUgYXJlIGR1cGxpY2F0ZWQgZnJvbSBub2JsZS1oYXNoZXMgKHV0aWxzKS5cbi8vIFRoaXMgaXMgT0s6IGBhYnN0cmFjdGAgZGlyZWN0b3J5IGRvZXMgbm90IHVzZSBub2JsZS1oYXNoZXMuXG4vLyBVc2VyIG1heSBvcHQtaW4gaW50byB1c2luZyBkaWZmZXJlbnQgaGFzaGluZyBsaWJyYXJ5LiBUaGlzIHdheSwgbm9ibGUtaGFzaGVzXG4vLyB3b24ndCBiZSBpbmNsdWRlZCBpbnRvIHRoZWlyIGJ1bmRsZS5cbmNvbnN0IF8wbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDEpO1xuZnVuY3Rpb24gaXNCeXRlcyhhKSB7XG4gICAgcmV0dXJuIGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IChBcnJheUJ1ZmZlci5pc1ZpZXcoYSkgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpO1xufVxuZnVuY3Rpb24gYWJ5dGVzKGl0ZW0pIHtcbiAgICBpZiAoIWlzQnl0ZXMoaXRlbSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xufVxuZnVuY3Rpb24gYWJvb2wodGl0bGUsIHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Jvb2xlYW4nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGl0bGUgKyAnIGJvb2xlYW4gZXhwZWN0ZWQsIGdvdCAnICsgdmFsdWUpO1xufVxuLy8gVXNlZCBpbiB3ZWllcnN0cmFzcywgZGVyXG5mdW5jdGlvbiBudW1iZXJUb0hleFVucGFkZGVkKG51bSkge1xuICAgIGNvbnN0IGhleCA9IG51bS50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIGhleC5sZW5ndGggJiAxID8gJzAnICsgaGV4IDogaGV4O1xufVxuZnVuY3Rpb24gaGV4VG9OdW1iZXIoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgcmV0dXJuIGhleCA9PT0gJycgPyBfMG4gOiBCaWdJbnQoJzB4JyArIGhleCk7IC8vIEJpZyBFbmRpYW5cbn1cbi8vIEJ1aWx0LWluIGhleCBjb252ZXJzaW9uIGh0dHBzOi8vY2FuaXVzZS5jb20vbWRuLWphdmFzY3JpcHRfYnVpbHRpbnNfdWludDhhcnJheV9mcm9taGV4XG5jb25zdCBoYXNIZXhCdWlsdGluID0gXG4vLyBAdHMtaWdub3JlXG50eXBlb2YgVWludDhBcnJheS5mcm9tKFtdKS50b0hleCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgVWludDhBcnJheS5mcm9tSGV4ID09PSAnZnVuY3Rpb24nO1xuLy8gQXJyYXkgd2hlcmUgaW5kZXggMHhmMCAoMjQwKSBpcyBtYXBwZWQgdG8gc3RyaW5nICdmMCdcbmNvbnN0IGhleGVzID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoXywgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4vKipcbiAqIENvbnZlcnQgYnl0ZSBhcnJheSB0byBoZXggc3RyaW5nLiBVc2VzIGJ1aWx0LWluIGZ1bmN0aW9uLCB3aGVuIGF2YWlsYWJsZS5cbiAqIEBleGFtcGxlIGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSkpIC8vICdjYWZlMDEyMydcbiAqL1xuZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgIGFieXRlcyhieXRlcyk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmIChoYXNIZXhCdWlsdGluKVxuICAgICAgICByZXR1cm4gYnl0ZXMudG9IZXgoKTtcbiAgICAvLyBwcmUtY2FjaGluZyBpbXByb3ZlcyB0aGUgc3BlZWQgNnhcbiAgICBsZXQgaGV4ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBoZXggKz0gaGV4ZXNbYnl0ZXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuLy8gV2UgdXNlIG9wdGltaXplZCB0ZWNobmlxdWUgdG8gY29udmVydCBoZXggc3RyaW5nIHRvIGJ5dGUgYXJyYXlcbmNvbnN0IGFzY2lpcyA9IHsgXzA6IDQ4LCBfOTogNTcsIEE6IDY1LCBGOiA3MCwgYTogOTcsIGY6IDEwMiB9O1xuZnVuY3Rpb24gYXNjaWlUb0Jhc2UxNihjaCkge1xuICAgIGlmIChjaCA+PSBhc2NpaXMuXzAgJiYgY2ggPD0gYXNjaWlzLl85KVxuICAgICAgICByZXR1cm4gY2ggLSBhc2NpaXMuXzA7IC8vICcyJyA9PiA1MC00OFxuICAgIGlmIChjaCA+PSBhc2NpaXMuQSAmJiBjaCA8PSBhc2NpaXMuRilcbiAgICAgICAgcmV0dXJuIGNoIC0gKGFzY2lpcy5BIC0gMTApOyAvLyAnQicgPT4gNjYtKDY1LTEwKVxuICAgIGlmIChjaCA+PSBhc2NpaXMuYSAmJiBjaCA8PSBhc2NpaXMuZilcbiAgICAgICAgcmV0dXJuIGNoIC0gKGFzY2lpcy5hIC0gMTApOyAvLyAnYicgPT4gOTgtKDk3LTEwKVxuICAgIHJldHVybjtcbn1cbi8qKlxuICogQ29udmVydCBoZXggc3RyaW5nIHRvIGJ5dGUgYXJyYXkuIFVzZXMgYnVpbHQtaW4gZnVuY3Rpb24sIHdoZW4gYXZhaWxhYmxlLlxuICogQGV4YW1wbGUgaGV4VG9CeXRlcygnY2FmZTAxMjMnKSAvLyBVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKVxuICovXG5mdW5jdGlvbiBoZXhUb0J5dGVzKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAoaGFzSGV4QnVpbHRpbilcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbUhleChoZXgpO1xuICAgIGNvbnN0IGhsID0gaGV4Lmxlbmd0aDtcbiAgICBjb25zdCBhbCA9IGhsIC8gMjtcbiAgICBpZiAoaGwgJSAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCB1bnBhZGRlZCBoZXggb2YgbGVuZ3RoICcgKyBobCk7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShhbCk7XG4gICAgZm9yIChsZXQgYWkgPSAwLCBoaSA9IDA7IGFpIDwgYWw7IGFpKyssIGhpICs9IDIpIHtcbiAgICAgICAgY29uc3QgbjEgPSBhc2NpaVRvQmFzZTE2KGhleC5jaGFyQ29kZUF0KGhpKSk7XG4gICAgICAgIGNvbnN0IG4yID0gYXNjaWlUb0Jhc2UxNihoZXguY2hhckNvZGVBdChoaSArIDEpKTtcbiAgICAgICAgaWYgKG4xID09PSB1bmRlZmluZWQgfHwgbjIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgY2hhciA9IGhleFtoaV0gKyBoZXhbaGkgKyAxXTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IG5vbi1oZXggY2hhcmFjdGVyIFwiJyArIGNoYXIgKyAnXCIgYXQgaW5kZXggJyArIGhpKTtcbiAgICAgICAgfVxuICAgICAgICBhcnJheVthaV0gPSBuMSAqIDE2ICsgbjI7IC8vIG11bHRpcGx5IGZpcnN0IG9jdGV0LCBlLmcuICdhMycgPT4gMTAqMTYrMyA9PiAxNjAgKyAzID0+IDE2M1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG4vLyBCRTogQmlnIEVuZGlhbiwgTEU6IExpdHRsZSBFbmRpYW5cbmZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXJCRShieXRlcykge1xuICAgIHJldHVybiBoZXhUb051bWJlcihieXRlc1RvSGV4KGJ5dGVzKSk7XG59XG5mdW5jdGlvbiBieXRlc1RvTnVtYmVyTEUoYnl0ZXMpIHtcbiAgICBhYnl0ZXMoYnl0ZXMpO1xuICAgIHJldHVybiBoZXhUb051bWJlcihieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShieXRlcykucmV2ZXJzZSgpKSk7XG59XG5mdW5jdGlvbiBudW1iZXJUb0J5dGVzQkUobiwgbGVuKSB7XG4gICAgcmV0dXJuIGhleFRvQnl0ZXMobi50b1N0cmluZygxNikucGFkU3RhcnQobGVuICogMiwgJzAnKSk7XG59XG5mdW5jdGlvbiBudW1iZXJUb0J5dGVzTEUobiwgbGVuKSB7XG4gICAgcmV0dXJuIG51bWJlclRvQnl0ZXNCRShuLCBsZW4pLnJldmVyc2UoKTtcbn1cbi8vIFVucGFkZGVkLCByYXJlbHkgdXNlZFxuZnVuY3Rpb24gbnVtYmVyVG9WYXJCeXRlc0JFKG4pIHtcbiAgICByZXR1cm4gaGV4VG9CeXRlcyhudW1iZXJUb0hleFVucGFkZGVkKG4pKTtcbn1cbi8qKlxuICogVGFrZXMgaGV4IHN0cmluZyBvciBVaW50OEFycmF5LCBjb252ZXJ0cyB0byBVaW50OEFycmF5LlxuICogVmFsaWRhdGVzIG91dHB1dCBsZW5ndGguXG4gKiBXaWxsIHRocm93IGVycm9yIGZvciBvdGhlciB0eXBlcy5cbiAqIEBwYXJhbSB0aXRsZSBkZXNjcmlwdGl2ZSB0aXRsZSBmb3IgYW4gZXJyb3IgZS5nLiAncHJpdmF0ZSBrZXknXG4gKiBAcGFyYW0gaGV4IGhleCBzdHJpbmcgb3IgVWludDhBcnJheVxuICogQHBhcmFtIGV4cGVjdGVkTGVuZ3RoIG9wdGlvbmFsLCB3aWxsIGNvbXBhcmUgdG8gcmVzdWx0IGFycmF5J3MgbGVuZ3RoXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBlbnN1cmVCeXRlcyh0aXRsZSwgaGV4LCBleHBlY3RlZExlbmd0aCkge1xuICAgIGxldCByZXM7XG4gICAgaWYgKHR5cGVvZiBoZXggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXMgPSBoZXhUb0J5dGVzKGhleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0aXRsZSArICcgbXVzdCBiZSBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXksIGNhdXNlOiAnICsgZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNCeXRlcyhoZXgpKSB7XG4gICAgICAgIC8vIFVpbnQ4QXJyYXkuZnJvbSgpIGluc3RlYWQgb2YgaGFzaC5zbGljZSgpIGJlY2F1c2Ugbm9kZS5qcyBCdWZmZXJcbiAgICAgICAgLy8gaXMgaW5zdGFuY2Ugb2YgVWludDhBcnJheSwgYW5kIGl0cyBzbGljZSgpIGNyZWF0ZXMgKiptdXRhYmxlKiogY29weVxuICAgICAgICByZXMgPSBVaW50OEFycmF5LmZyb20oaGV4KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih0aXRsZSArICcgbXVzdCBiZSBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXknKTtcbiAgICB9XG4gICAgY29uc3QgbGVuID0gcmVzLmxlbmd0aDtcbiAgICBpZiAodHlwZW9mIGV4cGVjdGVkTGVuZ3RoID09PSAnbnVtYmVyJyAmJiBsZW4gIT09IGV4cGVjdGVkTGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGl0bGUgKyAnIG9mIGxlbmd0aCAnICsgZXhwZWN0ZWRMZW5ndGggKyAnIGV4cGVjdGVkLCBnb3QgJyArIGxlbik7XG4gICAgcmV0dXJuIHJlcztcbn1cbi8qKlxuICogQ29waWVzIHNldmVyYWwgVWludDhBcnJheXMgaW50byBvbmUuXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGxldCBzdW0gPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBhcnJheXNbaV07XG4gICAgICAgIGFieXRlcyhhKTtcbiAgICAgICAgc3VtICs9IGEubGVuZ3RoO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShzdW0pO1xuICAgIGZvciAobGV0IGkgPSAwLCBwYWQgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBhcnJheXNbaV07XG4gICAgICAgIHJlcy5zZXQoYSwgcGFkKTtcbiAgICAgICAgcGFkICs9IGEubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLy8gQ29tcGFyZXMgMiB1OGEtcyBpbiBraW5kYSBjb25zdGFudCB0aW1lXG5mdW5jdGlvbiBlcXVhbEJ5dGVzKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGRpZmYgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICAgICAgZGlmZiB8PSBhW2ldIF4gYltpXTtcbiAgICByZXR1cm4gZGlmZiA9PT0gMDtcbn1cbi8qKlxuICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIG5ldyBVaW50OEFycmF5KFs5NywgOTgsIDk5XSlcbiAqL1xuZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0cmluZyBleHBlY3RlZCcpO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSk7IC8vIGh0dHBzOi8vYnVnemlsLmxhLzE2ODE4MDlcbn1cbi8vIElzIHBvc2l0aXZlIGJpZ2ludFxuY29uc3QgaXNQb3NCaWcgPSAobikgPT4gdHlwZW9mIG4gPT09ICdiaWdpbnQnICYmIF8wbiA8PSBuO1xuZnVuY3Rpb24gaW5SYW5nZShuLCBtaW4sIG1heCkge1xuICAgIHJldHVybiBpc1Bvc0JpZyhuKSAmJiBpc1Bvc0JpZyhtaW4pICYmIGlzUG9zQmlnKG1heCkgJiYgbWluIDw9IG4gJiYgbiA8IG1heDtcbn1cbi8qKlxuICogQXNzZXJ0cyBtaW4gPD0gbiA8IG1heC4gTk9URTogSXQncyA8IG1heCBhbmQgbm90IDw9IG1heC5cbiAqIEBleGFtcGxlXG4gKiBhSW5SYW5nZSgneCcsIHgsIDFuLCAyNTZuKTsgLy8gd291bGQgYXNzdW1lIHggaXMgaW4gKDFuLi4yNTVuKVxuICovXG5mdW5jdGlvbiBhSW5SYW5nZSh0aXRsZSwgbiwgbWluLCBtYXgpIHtcbiAgICAvLyBXaHkgbWluIDw9IG4gPCBtYXggYW5kIG5vdCBhIChtaW4gPCBuIDwgbWF4KSBPUiBiIChtaW4gPD0gbiA8PSBtYXgpP1xuICAgIC8vIGNvbnNpZGVyIFA9MjU2biwgbWluPTBuLCBtYXg9UFxuICAgIC8vIC0gYSBmb3IgbWluPTAgd291bGQgcmVxdWlyZSAtMTogICAgICAgICAgYGluUmFuZ2UoJ3gnLCB4LCAtMW4sIFApYFxuICAgIC8vIC0gYiB3b3VsZCBjb21tb25seSByZXF1aXJlIHN1YnRyYWN0aW9uOiAgYGluUmFuZ2UoJ3gnLCB4LCAwbiwgUCAtIDFuKWBcbiAgICAvLyAtIG91ciB3YXkgaXMgdGhlIGNsZWFuZXN0OiAgICAgICAgICAgICAgIGBpblJhbmdlKCd4JywgeCwgMG4sIFApXG4gICAgaWYgKCFpblJhbmdlKG4sIG1pbiwgbWF4KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCB2YWxpZCAnICsgdGl0bGUgKyAnOiAnICsgbWluICsgJyA8PSBuIDwgJyArIG1heCArICcsIGdvdCAnICsgbik7XG59XG4vLyBCaXQgb3BlcmF0aW9uc1xuLyoqXG4gKiBDYWxjdWxhdGVzIGFtb3VudCBvZiBiaXRzIGluIGEgYmlnaW50LlxuICogU2FtZSBhcyBgbi50b1N0cmluZygyKS5sZW5ndGhgXG4gKiBUT0RPOiBtZXJnZSB3aXRoIG5MZW5ndGggaW4gbW9kdWxhclxuICovXG5mdW5jdGlvbiBiaXRMZW4obikge1xuICAgIGxldCBsZW47XG4gICAgZm9yIChsZW4gPSAwOyBuID4gXzBuOyBuID4+PSBfMW4sIGxlbiArPSAxKVxuICAgICAgICA7XG4gICAgcmV0dXJuIGxlbjtcbn1cbi8qKlxuICogR2V0cyBzaW5nbGUgYml0IGF0IHBvc2l0aW9uLlxuICogTk9URTogZmlyc3QgYml0IHBvc2l0aW9uIGlzIDAgKHNhbWUgYXMgYXJyYXlzKVxuICogU2FtZSBhcyBgISErQXJyYXkuZnJvbShuLnRvU3RyaW5nKDIpKS5yZXZlcnNlKClbcG9zXWBcbiAqL1xuZnVuY3Rpb24gYml0R2V0KG4sIHBvcykge1xuICAgIHJldHVybiAobiA+PiBCaWdJbnQocG9zKSkgJiBfMW47XG59XG4vKipcbiAqIFNldHMgc2luZ2xlIGJpdCBhdCBwb3NpdGlvbi5cbiAqL1xuZnVuY3Rpb24gYml0U2V0KG4sIHBvcywgdmFsdWUpIHtcbiAgICByZXR1cm4gbiB8ICgodmFsdWUgPyBfMW4gOiBfMG4pIDw8IEJpZ0ludChwb3MpKTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlIG1hc2sgZm9yIE4gYml0cy4gTm90IHVzaW5nICoqIG9wZXJhdG9yIHdpdGggYmlnaW50cyBiZWNhdXNlIG9mIG9sZCBlbmdpbmVzLlxuICogU2FtZSBhcyBCaWdJbnQoYDBiJHtBcnJheShpKS5maWxsKCcxJykuam9pbignJyl9YClcbiAqL1xuY29uc3QgYml0TWFzayA9IChuKSA9PiAoXzFuIDw8IEJpZ0ludChuKSkgLSBfMW47XG5leHBvcnRzLmJpdE1hc2sgPSBiaXRNYXNrO1xuLy8gRFJCR1xuY29uc3QgdThuID0gKGxlbikgPT4gbmV3IFVpbnQ4QXJyYXkobGVuKTsgLy8gY3JlYXRlcyBVaW50OEFycmF5XG5jb25zdCB1OGZyID0gKGFycikgPT4gVWludDhBcnJheS5mcm9tKGFycik7IC8vIGFub3RoZXIgc2hvcnRjdXRcbi8qKlxuICogTWluaW1hbCBITUFDLURSQkcgZnJvbSBOSVNUIDgwMC05MCBmb3IgUkZDNjk3OSBzaWdzLlxuICogQHJldHVybnMgZnVuY3Rpb24gdGhhdCB3aWxsIGNhbGwgRFJCRyB1bnRpbCAybmQgYXJnIHJldHVybnMgc29tZXRoaW5nIG1lYW5pbmdmdWxcbiAqIEBleGFtcGxlXG4gKiAgIGNvbnN0IGRyYmcgPSBjcmVhdGVIbWFjRFJCRzxLZXk+KDMyLCAzMiwgaG1hYyk7XG4gKiAgIGRyYmcoc2VlZCwgYnl0ZXNUb0tleSk7IC8vIGJ5dGVzVG9LZXkgbXVzdCByZXR1cm4gS2V5IG9yIHVuZGVmaW5lZFxuICovXG5mdW5jdGlvbiBjcmVhdGVIbWFjRHJiZyhoYXNoTGVuLCBxQnl0ZUxlbiwgaG1hY0ZuKSB7XG4gICAgaWYgKHR5cGVvZiBoYXNoTGVuICE9PSAnbnVtYmVyJyB8fCBoYXNoTGVuIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoYXNoTGVuIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICBpZiAodHlwZW9mIHFCeXRlTGVuICE9PSAnbnVtYmVyJyB8fCBxQnl0ZUxlbiA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncUJ5dGVMZW4gbXVzdCBiZSBhIG51bWJlcicpO1xuICAgIGlmICh0eXBlb2YgaG1hY0ZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2htYWNGbiBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAvLyBTdGVwIEIsIFN0ZXAgQzogc2V0IGhhc2hMZW4gdG8gOCpjZWlsKGhsZW4vOClcbiAgICBsZXQgdiA9IHU4bihoYXNoTGVuKTsgLy8gTWluaW1hbCBub24tZnVsbC1zcGVjIEhNQUMtRFJCRyBmcm9tIE5JU1QgODAwLTkwIGZvciBSRkM2OTc5IHNpZ3MuXG4gICAgbGV0IGsgPSB1OG4oaGFzaExlbik7IC8vIFN0ZXBzIEIgYW5kIEMgb2YgUkZDNjk3OSAzLjI6IHNldCBoYXNoTGVuLCBpbiBvdXIgY2FzZSBhbHdheXMgc2FtZVxuICAgIGxldCBpID0gMDsgLy8gSXRlcmF0aW9ucyBjb3VudGVyLCB3aWxsIHRocm93IHdoZW4gb3ZlciAxMDAwXG4gICAgY29uc3QgcmVzZXQgPSAoKSA9PiB7XG4gICAgICAgIHYuZmlsbCgxKTtcbiAgICAgICAgay5maWxsKDApO1xuICAgICAgICBpID0gMDtcbiAgICB9O1xuICAgIGNvbnN0IGggPSAoLi4uYikgPT4gaG1hY0ZuKGssIHYsIC4uLmIpOyAvLyBobWFjKGspKHYsIC4uLnZhbHVlcylcbiAgICBjb25zdCByZXNlZWQgPSAoc2VlZCA9IHU4bigwKSkgPT4ge1xuICAgICAgICAvLyBITUFDLURSQkcgcmVzZWVkKCkgZnVuY3Rpb24uIFN0ZXBzIEQtR1xuICAgICAgICBrID0gaCh1OGZyKFsweDAwXSksIHNlZWQpOyAvLyBrID0gaG1hYyhrIHx8IHYgfHwgMHgwMCB8fCBzZWVkKVxuICAgICAgICB2ID0gaCgpOyAvLyB2ID0gaG1hYyhrIHx8IHYpXG4gICAgICAgIGlmIChzZWVkLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgayA9IGgodThmcihbMHgwMV0pLCBzZWVkKTsgLy8gayA9IGhtYWMoayB8fCB2IHx8IDB4MDEgfHwgc2VlZClcbiAgICAgICAgdiA9IGgoKTsgLy8gdiA9IGhtYWMoayB8fCB2KVxuICAgIH07XG4gICAgY29uc3QgZ2VuID0gKCkgPT4ge1xuICAgICAgICAvLyBITUFDLURSQkcgZ2VuZXJhdGUoKSBmdW5jdGlvblxuICAgICAgICBpZiAoaSsrID49IDEwMDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RyYmc6IHRyaWVkIDEwMDAgdmFsdWVzJyk7XG4gICAgICAgIGxldCBsZW4gPSAwO1xuICAgICAgICBjb25zdCBvdXQgPSBbXTtcbiAgICAgICAgd2hpbGUgKGxlbiA8IHFCeXRlTGVuKSB7XG4gICAgICAgICAgICB2ID0gaCgpO1xuICAgICAgICAgICAgY29uc3Qgc2wgPSB2LnNsaWNlKCk7XG4gICAgICAgICAgICBvdXQucHVzaChzbCk7XG4gICAgICAgICAgICBsZW4gKz0gdi5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbmNhdEJ5dGVzKC4uLm91dCk7XG4gICAgfTtcbiAgICBjb25zdCBnZW5VbnRpbCA9IChzZWVkLCBwcmVkKSA9PiB7XG4gICAgICAgIHJlc2V0KCk7XG4gICAgICAgIHJlc2VlZChzZWVkKTsgLy8gU3RlcHMgRC1HXG4gICAgICAgIGxldCByZXMgPSB1bmRlZmluZWQ7IC8vIFN0ZXAgSDogZ3JpbmQgdW50aWwgayBpcyBpbiBbMS4ubi0xXVxuICAgICAgICB3aGlsZSAoIShyZXMgPSBwcmVkKGdlbigpKSkpXG4gICAgICAgICAgICByZXNlZWQoKTtcbiAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIHJldHVybiBnZW5VbnRpbDtcbn1cbi8vIFZhbGlkYXRpbmcgY3VydmVzIGFuZCBmaWVsZHNcbmNvbnN0IHZhbGlkYXRvckZucyA9IHtcbiAgICBiaWdpbnQ6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdiaWdpbnQnLFxuICAgIGZ1bmN0aW9uOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nLFxuICAgIGJvb2xlYW46ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdib29sZWFuJyxcbiAgICBzdHJpbmc6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnLFxuICAgIHN0cmluZ09yVWludDhBcnJheTogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgfHwgaXNCeXRlcyh2YWwpLFxuICAgIGlzU2FmZUludGVnZXI6ICh2YWwpID0+IE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbCksXG4gICAgYXJyYXk6ICh2YWwpID0+IEFycmF5LmlzQXJyYXkodmFsKSxcbiAgICBmaWVsZDogKHZhbCwgb2JqZWN0KSA9PiBvYmplY3QuRnAuaXNWYWxpZCh2YWwpLFxuICAgIGhhc2g6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicgJiYgTnVtYmVyLmlzU2FmZUludGVnZXIodmFsLm91dHB1dExlbiksXG59O1xuLy8gdHlwZSBSZWNvcmQ8SyBleHRlbmRzIHN0cmluZyB8IG51bWJlciB8IHN5bWJvbCwgVD4gPSB7IFtQIGluIEtdOiBUOyB9XG5mdW5jdGlvbiB2YWxpZGF0ZU9iamVjdChvYmplY3QsIHZhbGlkYXRvcnMsIG9wdFZhbGlkYXRvcnMgPSB7fSkge1xuICAgIGNvbnN0IGNoZWNrRmllbGQgPSAoZmllbGROYW1lLCB0eXBlLCBpc09wdGlvbmFsKSA9PiB7XG4gICAgICAgIGNvbnN0IGNoZWNrVmFsID0gdmFsaWRhdG9yRm5zW3R5cGVdO1xuICAgICAgICBpZiAodHlwZW9mIGNoZWNrVmFsICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHZhbGlkYXRvciBmdW5jdGlvbicpO1xuICAgICAgICBjb25zdCB2YWwgPSBvYmplY3RbZmllbGROYW1lXTtcbiAgICAgICAgaWYgKGlzT3B0aW9uYWwgJiYgdmFsID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghY2hlY2tWYWwodmFsLCBvYmplY3QpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhcmFtICcgKyBTdHJpbmcoZmllbGROYW1lKSArICcgaXMgaW52YWxpZC4gRXhwZWN0ZWQgJyArIHR5cGUgKyAnLCBnb3QgJyArIHZhbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgdHlwZV0gb2YgT2JqZWN0LmVudHJpZXModmFsaWRhdG9ycykpXG4gICAgICAgIGNoZWNrRmllbGQoZmllbGROYW1lLCB0eXBlLCBmYWxzZSk7XG4gICAgZm9yIChjb25zdCBbZmllbGROYW1lLCB0eXBlXSBvZiBPYmplY3QuZW50cmllcyhvcHRWYWxpZGF0b3JzKSlcbiAgICAgICAgY2hlY2tGaWVsZChmaWVsZE5hbWUsIHR5cGUsIHRydWUpO1xuICAgIHJldHVybiBvYmplY3Q7XG59XG4vLyB2YWxpZGF0ZSB0eXBlIHRlc3RzXG4vLyBjb25zdCBvOiB7IGE6IG51bWJlcjsgYjogbnVtYmVyOyBjOiBudW1iZXIgfSA9IHsgYTogMSwgYjogNSwgYzogNiB9O1xuLy8gY29uc3QgejAgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdpc1NhZmVJbnRlZ2VyJyB9LCB7IGM6ICdiaWdpbnQnIH0pOyAvLyBPayFcbi8vIC8vIFNob3VsZCBmYWlsIHR5cGUtY2hlY2tcbi8vIGNvbnN0IHoxID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAndG1wJyB9LCB7IGM6ICd6eicgfSk7XG4vLyBjb25zdCB6MiA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2lzU2FmZUludGVnZXInIH0sIHsgYzogJ3p6JyB9KTtcbi8vIGNvbnN0IHozID0gdmFsaWRhdGVPYmplY3QobywgeyB0ZXN0OiAnYm9vbGVhbicsIHo6ICdidWcnIH0pO1xuLy8gY29uc3QgejQgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdib29sZWFuJywgejogJ2J1ZycgfSk7XG4vKipcbiAqIHRocm93cyBub3QgaW1wbGVtZW50ZWQgZXJyb3JcbiAqL1xuY29uc3Qgbm90SW1wbGVtZW50ZWQgPSAoKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbn07XG5leHBvcnRzLm5vdEltcGxlbWVudGVkID0gbm90SW1wbGVtZW50ZWQ7XG4vKipcbiAqIE1lbW9pemVzIChjYWNoZXMpIGNvbXB1dGF0aW9uIHJlc3VsdC5cbiAqIFVzZXMgV2Vha01hcDogdGhlIHZhbHVlIGlzIGdvaW5nIGF1dG8tY2xlYW5lZCBieSBHQyBhZnRlciBsYXN0IHJlZmVyZW5jZSBpcyByZW1vdmVkLlxuICovXG5mdW5jdGlvbiBtZW1vaXplZChmbikge1xuICAgIGNvbnN0IG1hcCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgcmV0dXJuIChhcmcsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgY29uc3QgdmFsID0gbWFwLmdldChhcmcpO1xuICAgICAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICBjb25zdCBjb21wdXRlZCA9IGZuKGFyZywgLi4uYXJncyk7XG4gICAgICAgIG1hcC5zZXQoYXJnLCBjb21wdXRlZCk7XG4gICAgICAgIHJldHVybiBjb21wdXRlZDtcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibm90SW1wbGVtZW50ZWQiLCJiaXRNYXNrIiwiaXNCeXRlcyIsImFieXRlcyIsImFib29sIiwibnVtYmVyVG9IZXhVbnBhZGRlZCIsImhleFRvTnVtYmVyIiwiYnl0ZXNUb0hleCIsImhleFRvQnl0ZXMiLCJieXRlc1RvTnVtYmVyQkUiLCJieXRlc1RvTnVtYmVyTEUiLCJudW1iZXJUb0J5dGVzQkUiLCJudW1iZXJUb0J5dGVzTEUiLCJudW1iZXJUb1ZhckJ5dGVzQkUiLCJlbnN1cmVCeXRlcyIsImNvbmNhdEJ5dGVzIiwiZXF1YWxCeXRlcyIsInV0ZjhUb0J5dGVzIiwiaW5SYW5nZSIsImFJblJhbmdlIiwiYml0TGVuIiwiYml0R2V0IiwiYml0U2V0IiwiY3JlYXRlSG1hY0RyYmciLCJ2YWxpZGF0ZU9iamVjdCIsIm1lbW9pemVkIiwiXzBuIiwiQmlnSW50IiwiXzFuIiwiYSIsIlVpbnQ4QXJyYXkiLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsImNvbnN0cnVjdG9yIiwibmFtZSIsIml0ZW0iLCJFcnJvciIsInRpdGxlIiwibnVtIiwiaGV4IiwidG9TdHJpbmciLCJsZW5ndGgiLCJoYXNIZXhCdWlsdGluIiwiZnJvbSIsInRvSGV4IiwiZnJvbUhleCIsImhleGVzIiwiQXJyYXkiLCJfIiwiaSIsInBhZFN0YXJ0IiwiYnl0ZXMiLCJhc2NpaXMiLCJfMCIsIl85IiwiQSIsIkYiLCJmIiwiYXNjaWlUb0Jhc2UxNiIsImNoIiwiaGwiLCJhbCIsImFycmF5IiwiYWkiLCJoaSIsIm4xIiwiY2hhckNvZGVBdCIsIm4yIiwidW5kZWZpbmVkIiwiY2hhciIsInJldmVyc2UiLCJuIiwibGVuIiwiZXhwZWN0ZWRMZW5ndGgiLCJyZXMiLCJlIiwiYXJyYXlzIiwic3VtIiwicGFkIiwic2V0IiwiYiIsImRpZmYiLCJzdHIiLCJUZXh0RW5jb2RlciIsImVuY29kZSIsImlzUG9zQmlnIiwibWluIiwibWF4IiwicG9zIiwidThuIiwidThmciIsImFyciIsImhhc2hMZW4iLCJxQnl0ZUxlbiIsImhtYWNGbiIsInYiLCJrIiwicmVzZXQiLCJmaWxsIiwiaCIsInJlc2VlZCIsInNlZWQiLCJnZW4iLCJvdXQiLCJzbCIsInNsaWNlIiwicHVzaCIsImdlblVudGlsIiwicHJlZCIsInZhbGlkYXRvckZucyIsImJpZ2ludCIsInZhbCIsImZ1bmN0aW9uIiwiYm9vbGVhbiIsInN0cmluZyIsInN0cmluZ09yVWludDhBcnJheSIsImlzU2FmZUludGVnZXIiLCJOdW1iZXIiLCJpc0FycmF5IiwiZmllbGQiLCJvYmplY3QiLCJGcCIsImlzVmFsaWQiLCJoYXNoIiwib3V0cHV0TGVuIiwidmFsaWRhdG9ycyIsIm9wdFZhbGlkYXRvcnMiLCJjaGVja0ZpZWxkIiwiZmllbGROYW1lIiwidHlwZSIsImlzT3B0aW9uYWwiLCJjaGVja1ZhbCIsIlN0cmluZyIsImVudHJpZXMiLCJmbiIsIm1hcCIsIldlYWtNYXAiLCJhcmciLCJhcmdzIiwiZ2V0IiwiY29tcHV0ZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/@noble/curves/abstract/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/@noble/curves/abstract/weierstrass.js":
/*!****************************************************************************!*\
  !*** ./node_modules/ox/node_modules/@noble/curves/abstract/weierstrass.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.DER = exports.DERErr = void 0;\nexports.weierstrassPoints = weierstrassPoints;\nexports.weierstrass = weierstrass;\nexports.SWUFpSqrtRatio = SWUFpSqrtRatio;\nexports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;\n/**\n * Short Weierstrass curve methods. The formula is: y¬≤ = x¬≥ + ax + b.\n *\n * ### Parameters\n *\n * To initialize a weierstrass curve, one needs to pass following params:\n *\n * * a: formula param\n * * b: formula param\n * * Fp: finite field of prime characteristic P; may be complex (Fp2). Arithmetics is done in field\n * * n: order of prime subgroup a.k.a total amount of valid curve points\n * * Gx: Base point (x, y) aka generator point. Gx = x coordinate\n * * Gy: ...y coordinate\n * * h: cofactor, usually 1. h*n = curve group order (n is only subgroup order)\n * * lowS: whether to enable (default) or disable \"low-s\" non-malleable signatures\n *\n * ### Design rationale for types\n *\n * * Interaction between classes from different curves should fail:\n *   `k256.Point.BASE.add(p256.Point.BASE)`\n * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime\n * * Different calls of `curve()` would return different classes -\n *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,\n *   it won't affect others\n *\n * TypeScript can't infer types for classes created inside a function. Classes is one instance\n * of nominative types in TypeScript and interfaces only check for shape, so it's hard to create\n * unique type for every function call.\n *\n * We can use generic types via some param, like curve opts, but that would:\n *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)\n *     which is hard to debug.\n *     2. Params can be generic and we can't enforce them to be constant value:\n *     if somebody creates curve from non-constant params,\n *     it would be allowed to interact with other curves with non-constant params\n *\n * @todo https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // prettier-ignore\nconst curve_ts_1 = __webpack_require__(/*! ./curve.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/abstract/curve.js\");\n// prettier-ignore\nconst modular_ts_1 = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/abstract/modular.js\");\n// prettier-ignore\nconst utils_ts_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/abstract/utils.js\");\nfunction validateSigVerOpts(opts) {\n    if (opts.lowS !== undefined) (0, utils_ts_1.abool)(\"lowS\", opts.lowS);\n    if (opts.prehash !== undefined) (0, utils_ts_1.abool)(\"prehash\", opts.prehash);\n}\nfunction validatePointOpts(curve) {\n    const opts = (0, curve_ts_1.validateBasic)(curve);\n    (0, utils_ts_1.validateObject)(opts, {\n        a: \"field\",\n        b: \"field\"\n    }, {\n        allowInfinityPoint: \"boolean\",\n        allowedPrivateKeyLengths: \"array\",\n        clearCofactor: \"function\",\n        fromBytes: \"function\",\n        isTorsionFree: \"function\",\n        toBytes: \"function\",\n        wrapPrivateKey: \"boolean\"\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error(\"invalid endo: CURVE.a must be 0\");\n        }\n        if (typeof endo !== \"object\" || typeof endo.beta !== \"bigint\" || typeof endo.splitScalar !== \"function\") {\n            throw new Error('invalid endo: expected \"beta\": bigint and \"splitScalar\": function');\n        }\n    }\n    return Object.freeze({\n        ...opts\n    });\n}\nclass DERErr extends Error {\n    constructor(m = \"\"){\n        super(m);\n    }\n}\nexports.DERErr = DERErr;\n/**\n * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:\n *\n *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]\n *\n * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html\n */ exports.DER = {\n    // asn.1 DER encoding utils\n    Err: DERErr,\n    // Basic building block is TLV (Tag-Length-Value)\n    _tlv: {\n        encode: (tag, data)=>{\n            const { Err: E } = exports.DER;\n            if (tag < 0 || tag > 256) throw new E(\"tlv.encode: wrong tag\");\n            if (data.length & 1) throw new E(\"tlv.encode: unpadded data\");\n            const dataLen = data.length / 2;\n            const len = (0, utils_ts_1.numberToHexUnpadded)(dataLen);\n            if (len.length / 2 & 128) throw new E(\"tlv.encode: long form length too big\");\n            // length of length with long form flag\n            const lenLen = dataLen > 127 ? (0, utils_ts_1.numberToHexUnpadded)(len.length / 2 | 128) : \"\";\n            const t = (0, utils_ts_1.numberToHexUnpadded)(tag);\n            return t + lenLen + len + data;\n        },\n        // v - value, l - left bytes (unparsed)\n        decode (tag, data) {\n            const { Err: E } = exports.DER;\n            let pos = 0;\n            if (tag < 0 || tag > 256) throw new E(\"tlv.encode: wrong tag\");\n            if (data.length < 2 || data[pos++] !== tag) throw new E(\"tlv.decode: wrong tlv\");\n            const first = data[pos++];\n            const isLong = !!(first & 128); // First bit of first length byte is flag for short/long form\n            let length = 0;\n            if (!isLong) length = first;\n            else {\n                // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]\n                const lenLen = first & 127;\n                if (!lenLen) throw new E(\"tlv.decode(long): indefinite length not supported\");\n                if (lenLen > 4) throw new E(\"tlv.decode(long): byte length is too big\"); // this will overflow u32 in js\n                const lengthBytes = data.subarray(pos, pos + lenLen);\n                if (lengthBytes.length !== lenLen) throw new E(\"tlv.decode: length bytes not complete\");\n                if (lengthBytes[0] === 0) throw new E(\"tlv.decode(long): zero leftmost byte\");\n                for (const b of lengthBytes)length = length << 8 | b;\n                pos += lenLen;\n                if (length < 128) throw new E(\"tlv.decode(long): not minimal encoding\");\n            }\n            const v = data.subarray(pos, pos + length);\n            if (v.length !== length) throw new E(\"tlv.decode: wrong value length\");\n            return {\n                v,\n                l: data.subarray(pos + length)\n            };\n        }\n    },\n    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n    // since we always use positive integers here. It must always be empty:\n    // - add zero byte if exists\n    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n    _int: {\n        encode (num) {\n            const { Err: E } = exports.DER;\n            if (num < _0n) throw new E(\"integer: negative integers are not allowed\");\n            let hex = (0, utils_ts_1.numberToHexUnpadded)(num);\n            // Pad with zero byte if negative flag is present\n            if (Number.parseInt(hex[0], 16) & 8) hex = \"00\" + hex;\n            if (hex.length & 1) throw new E(\"unexpected DER parsing assertion: unpadded hex\");\n            return hex;\n        },\n        decode (data) {\n            const { Err: E } = exports.DER;\n            if (data[0] & 128) throw new E(\"invalid signature integer: negative\");\n            if (data[0] === 0x00 && !(data[1] & 128)) throw new E(\"invalid signature integer: unnecessary leading zero\");\n            return (0, utils_ts_1.bytesToNumberBE)(data);\n        }\n    },\n    toSig (hex) {\n        // parse DER signature\n        const { Err: E, _int: int, _tlv: tlv } = exports.DER;\n        const data = (0, utils_ts_1.ensureBytes)(\"signature\", hex);\n        const { v: seqBytes, l: seqLeftBytes } = tlv.decode(0x30, data);\n        if (seqLeftBytes.length) throw new E(\"invalid signature: left bytes after parsing\");\n        const { v: rBytes, l: rLeftBytes } = tlv.decode(0x02, seqBytes);\n        const { v: sBytes, l: sLeftBytes } = tlv.decode(0x02, rLeftBytes);\n        if (sLeftBytes.length) throw new E(\"invalid signature: left bytes after parsing\");\n        return {\n            r: int.decode(rBytes),\n            s: int.decode(sBytes)\n        };\n    },\n    hexFromSig (sig) {\n        const { _tlv: tlv, _int: int } = exports.DER;\n        const rs = tlv.encode(0x02, int.encode(sig.r));\n        const ss = tlv.encode(0x02, int.encode(sig.s));\n        const seq = rs + ss;\n        return tlv.encode(0x30, seq);\n    }\n};\nfunction numToSizedHex(num, size) {\n    return (0, utils_ts_1.bytesToHex)((0, utils_ts_1.numberToBytesBE)(num, size));\n}\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nfunction weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const Fn = (0, modular_ts_1.Field)(CURVE.n, CURVE.nBitLength);\n    const toBytes = CURVE.toBytes || ((_c, point, _isCompressed)=>{\n        const a = point.toAffine();\n        return (0, utils_ts_1.concatBytes)(Uint8Array.from([\n            0x04\n        ]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n    });\n    const fromBytes = CURVE.fromBytes || ((bytes)=>{\n        // const head = bytes[0];\n        const tail = bytes.subarray(1);\n        // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n        return {\n            x,\n            y\n        };\n    });\n    /**\n     * y¬≤ = x¬≥ + ax + b: Short weierstrass curve formula. Takes x, returns y¬≤.\n     * @returns y¬≤\n     */ function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x¬≤ * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x¬≥ + a * x + b\n    }\n    function isValidXY(x, y) {\n        const left = Fp.sqr(y); // y¬≤\n        const right = weierstrassEquation(x); // x¬≥ + ax + b\n        return Fp.eql(left, right);\n    }\n    // Validate whether the passed curve params are valid.\n    // Test 1: equation y¬≤ = x¬≥ + ax + b should work for generator point.\n    if (!isValidXY(CURVE.Gx, CURVE.Gy)) throw new Error(\"bad curve params: generator point\");\n    // Test 2: discriminant Œî part should be non-zero: 4a¬≥ + 27b¬≤ != 0.\n    // Guarantees curve is genus-1, smooth (non-singular).\n    const _4a3 = Fp.mul(Fp.pow(CURVE.a, _3n), _4n);\n    const _27b2 = Fp.mul(Fp.sqr(CURVE.b), BigInt(27));\n    if (Fp.is0(Fp.add(_4a3, _27b2))) throw new Error(\"bad curve params: a or b\");\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return (0, utils_ts_1.inRange)(num, _1n, CURVE.n);\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: N } = CURVE;\n        if (lengths && typeof key !== \"bigint\") {\n            if ((0, utils_ts_1.isBytes)(key)) key = (0, utils_ts_1.bytesToHex)(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== \"string\" || !lengths.includes(key.length)) throw new Error(\"invalid private key\");\n            key = key.padStart(nByteLength * 2, \"0\");\n        }\n        let num;\n        try {\n            num = typeof key === \"bigint\" ? key : (0, utils_ts_1.bytesToNumberBE)((0, utils_ts_1.ensureBytes)(\"private key\", key, nByteLength));\n        } catch (error) {\n            throw new Error(\"invalid private key, expected hex or \" + nByteLength + \" bytes, got \" + typeof key);\n        }\n        if (wrapPrivateKey) num = (0, modular_ts_1.mod)(num, N); // disabled by default, enabled for BLS\n        (0, utils_ts_1.aInRange)(\"private key\", num, _1n, N); // num in range [1..N-1]\n        return num;\n    }\n    function aprjpoint(other) {\n        if (!(other instanceof Point)) throw new Error(\"ProjectivePoint expected\");\n    }\n    // Memoized toAffine / validity check. They are heavy. Points are immutable.\n    // Converts Projective point to affine (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    // (X, Y, Z) ‚àã (x=X/Z, y=Y/Z)\n    const toAffineMemo = (0, utils_ts_1.memoized)((p, iz)=>{\n        const { px: x, py: y, pz: z } = p;\n        // Fast-path for normalized points\n        if (Fp.eql(z, Fp.ONE)) return {\n            x,\n            y\n        };\n        const is0 = p.is0();\n        // If invZ was 0, we return zero point. However we still want to execute\n        // all operations, so we replace invZ with a random number, 1.\n        if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(z);\n        const ax = Fp.mul(x, iz);\n        const ay = Fp.mul(y, iz);\n        const zz = Fp.mul(z, iz);\n        if (is0) return {\n            x: Fp.ZERO,\n            y: Fp.ZERO\n        };\n        if (!Fp.eql(zz, Fp.ONE)) throw new Error(\"invZ was invalid\");\n        return {\n            x: ax,\n            y: ay\n        };\n    });\n    // NOTE: on exception this will crash 'cached' and no value will be set.\n    // Otherwise true will be return\n    const assertValidMemo = (0, utils_ts_1.memoized)((p)=>{\n        if (p.is0()) {\n            // (0, 1, 0) aka ZERO is invalid in most contexts.\n            // In BLS, ZERO can be serialized, so we allow it.\n            // (0, 0, 0) is invalid representation of ZERO.\n            if (CURVE.allowInfinityPoint && !Fp.is0(p.py)) return;\n            throw new Error(\"bad point: ZERO\");\n        }\n        // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n        const { x, y } = p.toAffine();\n        // Check if x, y are valid field elements\n        if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error(\"bad point: x or y not FE\");\n        if (!isValidXY(x, y)) throw new Error(\"bad point: equation left != right\");\n        if (!p.isTorsionFree()) throw new Error(\"bad point: not in prime-order subgroup\");\n        return true;\n    });\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (X, Y, Z) ‚àã (x=X/Z, y=Y/Z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */ class Point {\n        constructor(px, py, pz){\n            if (px == null || !Fp.isValid(px)) throw new Error(\"x required\");\n            if (py == null || !Fp.isValid(py) || Fp.is0(py)) throw new Error(\"y required\");\n            if (pz == null || !Fp.isValid(pz)) throw new Error(\"z required\");\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            Object.freeze(this);\n        }\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error(\"invalid affine point\");\n            if (p instanceof Point) throw new Error(\"projective point not allowed\");\n            const is0 = (i)=>Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y)) return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */ static normalizeZ(points) {\n            const toInv = (0, modular_ts_1.FpInvertBatch)(Fp, points.map((p)=>p.pz));\n            return points.map((p, i)=>p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */ static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes((0, utils_ts_1.ensureBytes)(\"pointHex\", hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // Multiscalar Multiplication\n        static msm(points, scalars) {\n            return (0, curve_ts_1.pippenger)(Point, Fn, points, scalars);\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            wnaf.setWindowSize(this, windowSize);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            assertValidMemo(this);\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd) return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */ equals(other) {\n            aprjpoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */ negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            aprjpoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, n, Point.normalizeZ);\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */ multiplyUnsafe(sc) {\n            const { endo, n: N } = CURVE;\n            (0, utils_ts_1.aInRange)(\"scalar\", sc, _0n, N);\n            const I = Point.ZERO;\n            if (sc === _0n) return I;\n            if (this.is0() || sc === _1n) return this;\n            // Case a: no endomorphism. Case b: has precomputes.\n            if (!endo || wnaf.hasPrecomputes(this)) return wnaf.wNAFCachedUnsafe(this, sc, Point.normalizeZ);\n            // Case c: endomorphism\n            /** See docs for {@link EndomorphismOpts} */ let { k1neg, k1, k2neg, k2 } = endo.splitScalar(sc);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while(k1 > _0n || k2 > _0n){\n                if (k1 & _1n) k1p = k1p.add(d);\n                if (k2 & _1n) k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n;\n                k2 >>= _1n;\n            }\n            if (k1neg) k1p = k1p.negate();\n            if (k2neg) k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */ multiply(scalar) {\n            const { endo, n: N } = CURVE;\n            (0, utils_ts_1.aInRange)(\"scalar\", scalar, _1n, N);\n            let point, fake; // Fake point is used to const-time mult\n            /** See docs for {@link EndomorphismOpts} */ if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(scalar);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            } else {\n                const { p, f } = this.wNAF(scalar);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([\n                point,\n                fake\n            ])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */ multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            )=>a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a);\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z) ‚àã (x=x/z, y=y/z)\n        toAffine(iz) {\n            return toAffineMemo(this, iz);\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n) return true; // No subgroups, always torsion-free\n            if (isTorsionFree) return isTorsionFree(Point, this);\n            throw new Error(\"isTorsionFree() has not been declared for the elliptic curve\");\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n) return this; // Fast-path\n            if (clearCofactor) return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes(isCompressed = true) {\n            (0, utils_ts_1.abool)(\"isCompressed\", isCompressed);\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            (0, utils_ts_1.abool)(\"isCompressed\", isCompressed);\n            return (0, utils_ts_1.bytesToHex)(this.toRawBytes(isCompressed));\n        }\n    }\n    // base / generator point\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    // zero / infinity / identity point\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO); // 0, 1, 0\n    const { endo, nBitLength } = CURVE;\n    const wnaf = (0, curve_ts_1.wNAF)(Point, endo ? Math.ceil(nBitLength / 2) : nBitLength);\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder\n    };\n}\nfunction validateOpts(curve) {\n    const opts = (0, curve_ts_1.validateBasic)(curve);\n    (0, utils_ts_1.validateObject)(opts, {\n        hash: \"hash\",\n        hmac: \"function\",\n        randomBytes: \"function\"\n    }, {\n        bits2int: \"function\",\n        bits2int_modN: \"function\",\n        lowS: \"boolean\"\n    });\n    return Object.freeze({\n        lowS: true,\n        ...opts\n    });\n}\n/**\n * Creates short weierstrass curve and ECDSA signature methods for it.\n * @example\n * import { Field } from '@noble/curves/abstract/modular';\n * // Before that, define BigInt-s: a, b, p, n, Gx, Gy\n * const curve = weierstrass({ a, b, Fp: Field(p), n, Gx, Gy, h: 1n })\n */ function weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER, nByteLength, nBitLength } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function modN(a) {\n        return (0, modular_ts_1.mod)(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return (0, modular_ts_1.invert)(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({\n        ...CURVE,\n        toBytes (_c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = utils_ts_1.concatBytes;\n            (0, utils_ts_1.abool)(\"isCompressed\", isCompressed);\n            if (isCompressed) {\n                return cat(Uint8Array.from([\n                    point.hasEvenY() ? 0x02 : 0x03\n                ]), x);\n            } else {\n                return cat(Uint8Array.from([\n                    0x04\n                ]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes (bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = (0, utils_ts_1.bytesToNumberBE)(tail);\n                if (!(0, utils_ts_1.inRange)(x, _1n, Fp.ORDER)) throw new Error(\"Point is not on curve\");\n                const y2 = weierstrassEquation(x); // y¬≤ = x¬≥ + ax + b\n                let y;\n                try {\n                    y = Fp.sqrt(y2); // y = y¬≤ ^ (p+1)/4\n                } catch (sqrtError) {\n                    const suffix = sqrtError instanceof Error ? \": \" + sqrtError.message : \"\";\n                    throw new Error(\"Point is not on curve\" + suffix);\n                }\n                const isYOdd = (y & _1n) === _1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd) y = Fp.neg(y);\n                return {\n                    x,\n                    y\n                };\n            } else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return {\n                    x,\n                    y\n                };\n            } else {\n                const cl = compressedLen;\n                const ul = uncompressedLen;\n                throw new Error(\"invalid Point, expected length of \" + cl + \", or uncompressed \" + ul + \", got \" + len);\n            }\n        }\n    });\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to)=>(0, utils_ts_1.bytesToNumberBE)(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */ class Signature {\n        constructor(r, s, recovery){\n            (0, utils_ts_1.aInRange)(\"r\", r, _1n, CURVE_ORDER); // r in [1..N]\n            (0, utils_ts_1.aInRange)(\"s\", s, _1n, CURVE_ORDER); // s in [1..N]\n            this.r = r;\n            this.s = s;\n            if (recovery != null) this.recovery = recovery;\n            Object.freeze(this);\n        }\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = nByteLength;\n            hex = (0, utils_ts_1.ensureBytes)(\"compactSignature\", hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = exports.DER.toSig((0, utils_ts_1.ensureBytes)(\"DER\", hex));\n            return new Signature(r, s);\n        }\n        /**\n         * @todo remove\n         * @deprecated\n         */ assertValidity() {}\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN((0, utils_ts_1.ensureBytes)(\"msgHash\", msgHash)); // Truncate hash\n            if (rec == null || ![\n                0,\n                1,\n                2,\n                3\n            ].includes(rec)) throw new Error(\"recovery id invalid\");\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER) throw new Error(\"recovery id 2 or 3 invalid\");\n            const prefix = (rec & 1) === 0 ? \"02\" : \"03\";\n            const R = Point.fromHex(prefix + numToSizedHex(radj, Fp.BYTES));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q) throw new Error(\"point at infinify\"); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return (0, utils_ts_1.hexToBytes)(this.toDERHex());\n        }\n        toDERHex() {\n            return exports.DER.hexFromSig(this);\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return (0, utils_ts_1.hexToBytes)(this.toCompactHex());\n        }\n        toCompactHex() {\n            const l = nByteLength;\n            return numToSizedHex(this.r, l) + numToSizedHex(this.s, l);\n        }\n    }\n    const utils = {\n        isValidPrivateKey (privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            } catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size\n         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n         */ randomPrivateKey: ()=>{\n            const length = (0, modular_ts_1.getMinHashLength)(CURVE.n);\n            return (0, modular_ts_1.mapHashToField)(CURVE.randomBytes(length), CURVE.n);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */ precompute (windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        }\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */ function getPublicKey(privateKey, isCompressed = true) {\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */ function isProbPub(item) {\n        if (typeof item === \"bigint\") return false;\n        if (item instanceof Point) return true;\n        const arr = (0, utils_ts_1.ensureBytes)(\"key\", item);\n        const len = arr.length;\n        const fpl = Fp.BYTES;\n        const compLen = fpl + 1; // e.g. 33 for 32\n        const uncompLen = 2 * fpl + 1; // e.g. 65 for 32\n        if (CURVE.allowedPrivateKeyLengths || nByteLength === compLen) {\n            return undefined;\n        } else {\n            return len === compLen || len === uncompLen;\n        }\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */ function getSharedSecret(privateA, publicB, isCompressed = true) {\n        if (isProbPub(privateA) === true) throw new Error(\"first arg must be private key\");\n        if (isProbPub(publicB) === false) throw new Error(\"second arg must be public key\");\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int || function(bytes) {\n        // Our custom check \"just in case\", for protection against DoS\n        if (bytes.length > 8192) throw new Error(\"input is too large\");\n        // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n        // for some cases, since bytes.length * 8 is not actual bitLength.\n        const num = (0, utils_ts_1.bytesToNumberBE)(bytes); // check for == u8 done here\n        const delta = bytes.length * 8 - nBitLength; // truncate to nBitLength leftmost bits\n        return delta > 0 ? num >> BigInt(delta) : num;\n    };\n    const bits2int_modN = CURVE.bits2int_modN || function(bytes) {\n        return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n    };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = (0, utils_ts_1.bitMask)(nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */ function int2octets(num) {\n        (0, utils_ts_1.aInRange)(\"num < 2^\" + nBitLength, num, _0n, ORDER_MASK);\n        // works with order, can have different size than numToField!\n        return (0, utils_ts_1.numberToBytesBE)(num, nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order,\n    // this will be invalid at least for P521. Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if ([\n            \"recovered\",\n            \"canonical\"\n        ].some((k)=>k in opts)) throw new Error(\"sign() legacy options not supported\");\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null) lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = (0, utils_ts_1.ensureBytes)(\"msgHash\", msgHash);\n        validateSigVerOpts(opts);\n        if (prehash) msgHash = (0, utils_ts_1.ensureBytes)(\"prehashed msgHash\", hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [\n            int2octets(d),\n            int2octets(h1int)\n        ];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null && ent !== false) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push((0, utils_ts_1.ensureBytes)(\"extraEntropy\", e)); // check for being bytes\n        }\n        const seed = (0, utils_ts_1.concatBytes)(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k)) return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === _0n) return;\n            // Can use scalar blinding b^-1(bm + bdr) where b ‚àà [1,q‚àí1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === _0n) return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return {\n            seed,\n            k2sig\n        };\n    }\n    const defaultSigOpts = {\n        lowS: CURVE.lowS,\n        prehash: false\n    };\n    const defaultVerOpts = {\n        lowS: CURVE.lowS,\n        prehash: false\n    };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G √ó k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */ function sign(msgHash, privKey, opts = defaultSigOpts) {\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = (0, utils_ts_1.createHmacDrbg)(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1‚ãÖG - U2‚ãÖP\n     *   mod(R.x, n) == r\n     * ```\n     */ function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = (0, utils_ts_1.ensureBytes)(\"msgHash\", msgHash);\n        publicKey = (0, utils_ts_1.ensureBytes)(\"publicKey\", publicKey);\n        const { lowS, prehash, format } = opts;\n        // Verify opts, deduce signature format\n        validateSigVerOpts(opts);\n        if (\"strict\" in opts) throw new Error(\"options.strict was renamed to lowS\");\n        if (format !== undefined && format !== \"compact\" && format !== \"der\") throw new Error(\"format must be compact or der\");\n        const isHex = typeof sg === \"string\" || (0, utils_ts_1.isBytes)(sg);\n        const isObj = !isHex && !format && typeof sg === \"object\" && sg !== null && typeof sg.r === \"bigint\" && typeof sg.s === \"bigint\";\n        if (!isHex && !isObj) throw new Error(\"invalid signature, expected Uint8Array, hex string or Signature instance\");\n        let _sig = undefined;\n        let P;\n        try {\n            if (isObj) _sig = new Signature(sg.r, sg.s);\n            if (isHex) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    if (format !== \"compact\") _sig = Signature.fromDER(sg);\n                } catch (derError) {\n                    if (!(derError instanceof exports.DER.Err)) throw derError;\n                }\n                if (!_sig && format !== \"der\") _sig = Signature.fromCompact(sg);\n            }\n            P = Point.fromHex(publicKey);\n        } catch (error) {\n            return false;\n        }\n        if (!_sig) return false;\n        if (lowS && _sig.hasHighS()) return false;\n        if (prehash) msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1‚ãÖG + u2‚ãÖP\n        if (!R) return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils\n    };\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */ function SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for(let o = q - _1n; o % _2n === _0n; o /= _2n)l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << c1 - _1n - _1n;\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v)=>{\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for(let i = c1; i > _1n; i--){\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << tv5 - _1n; // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return {\n            isValid: isQR,\n            value: tv3\n        };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v)=>{\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return {\n                isValid: isQR,\n                value: y\n            }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */ function mapToCurveSimpleSWU(Fp, opts) {\n    (0, modular_ts_1.validateField)(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z)) throw new Error(\"mapToCurveSimpleSWU: invalid opts\");\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd) throw new Error(\"Fp.isOdd is not implemented!\");\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u)=>{\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        const tv4_inv = (0, modular_ts_1.FpInvertBatch)(Fp, [\n            tv4\n        ], true)[0];\n        x = Fp.mul(x, tv4_inv); // 25.   x = x / tv4\n        return {\n            x,\n            y\n        };\n    };\n} //# sourceMappingURL=weierstrass.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELFdBQVcsR0FBR0EsY0FBYyxHQUFHLEtBQUs7QUFDcENBLHlCQUF5QixHQUFHSTtBQUM1QkosbUJBQW1CLEdBQUdLO0FBQ3RCTCxzQkFBc0IsR0FBR007QUFDekJOLDJCQUEyQixHQUFHTztBQUM5Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FzQ0MsR0FDRCxvRUFBb0UsR0FDcEUsa0JBQWtCO0FBQ2xCLE1BQU1DLGFBQWFDLG1CQUFPQSxDQUFDLHdGQUFZO0FBQ3ZDLGtCQUFrQjtBQUNsQixNQUFNQyxlQUFlRCxtQkFBT0EsQ0FBQyw0RkFBYztBQUMzQyxrQkFBa0I7QUFDbEIsTUFBTUUsYUFBYUYsbUJBQU9BLENBQUMsd0ZBQVk7QUFDdkMsU0FBU0csbUJBQW1CQyxJQUFJO0lBQzVCLElBQUlBLEtBQUtDLElBQUksS0FBS0MsV0FDZCxDQUFDLEdBQUdKLFdBQVdLLEtBQUssRUFBRSxRQUFRSCxLQUFLQyxJQUFJO0lBQzNDLElBQUlELEtBQUtJLE9BQU8sS0FBS0YsV0FDakIsQ0FBQyxHQUFHSixXQUFXSyxLQUFLLEVBQUUsV0FBV0gsS0FBS0ksT0FBTztBQUNyRDtBQUNBLFNBQVNDLGtCQUFrQkMsS0FBSztJQUM1QixNQUFNTixPQUFPLENBQUMsR0FBR0wsV0FBV1ksYUFBYSxFQUFFRDtJQUMxQyxJQUFHUixXQUFXVSxjQUFjLEVBQUVSLE1BQU07UUFDakNTLEdBQUc7UUFDSEMsR0FBRztJQUNQLEdBQUc7UUFDQ0Msb0JBQW9CO1FBQ3BCQywwQkFBMEI7UUFDMUJDLGVBQWU7UUFDZkMsV0FBVztRQUNYQyxlQUFlO1FBQ2ZDLFNBQVM7UUFDVEMsZ0JBQWdCO0lBQ3BCO0lBQ0EsTUFBTSxF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QUtZLE1BQU0saURBQWlEO1FBQ2pHcFEsSUFBSTNFLEdBQUdtRixHQUFHLENBQUMrTyxLQUFLRCxJQUFJLHFDQUFxQztRQUN6RHRQLElBQUkzRSxHQUFHbUYsR0FBRyxDQUFDUixHQUFHMUcsUUFBUSxtQkFBbUI7UUFDekN5RyxJQUFJMUUsR0FBR3dVLElBQUksQ0FBQzlQLEdBQUcwUCxLQUFLeE0sVUFBVSx3Q0FBd0M7UUFDdEVqRCxJQUFJM0UsR0FBR3dVLElBQUksQ0FBQzdQLEdBQUcxRyxPQUFPMkosVUFBVSx1Q0FBdUM7UUFDdkUsTUFBTThNLEtBQUsxVSxHQUFHbUosS0FBSyxDQUFDOEssT0FBT2pVLEdBQUdtSixLQUFLLENBQUN4RSxJQUFJLCtCQUErQjtRQUN2RUEsSUFBSTNFLEdBQUd3VSxJQUFJLENBQUN4VSxHQUFHOEosR0FBRyxDQUFDbkYsSUFBSUEsR0FBRytQLEtBQUssNEJBQTRCO1FBQzNELE1BQU1NLFVBQVUsQ0FBQyxHQUFHdFcsYUFBYXdKLGFBQWEsRUFBRWxJLElBQUk7WUFBQ3NVO1NBQUksRUFBRSxLQUFLLENBQUMsRUFBRTtRQUNuRTVQLElBQUkxRSxHQUFHbUYsR0FBRyxDQUFDVCxHQUFHc1EsVUFBVSxvQkFBb0I7UUFDNUMsT0FBTztZQUFFdFE7WUFBR0M7UUFBRTtJQUNsQjtBQUNKLEVBQ0EsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xhdy13b3Jrcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC93ZWllcnN0cmFzcy5qcz82YzVjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ERVIgPSBleHBvcnRzLkRFUkVyciA9IHZvaWQgMDtcbmV4cG9ydHMud2VpZXJzdHJhc3NQb2ludHMgPSB3ZWllcnN0cmFzc1BvaW50cztcbmV4cG9ydHMud2VpZXJzdHJhc3MgPSB3ZWllcnN0cmFzcztcbmV4cG9ydHMuU1dVRnBTcXJ0UmF0aW8gPSBTV1VGcFNxcnRSYXRpbztcbmV4cG9ydHMubWFwVG9DdXJ2ZVNpbXBsZVNXVSA9IG1hcFRvQ3VydmVTaW1wbGVTV1U7XG4vKipcbiAqIFNob3J0IFdlaWVyc3RyYXNzIGN1cnZlIG1ldGhvZHMuIFRoZSBmb3JtdWxhIGlzOiB5wrIgPSB4wrMgKyBheCArIGIuXG4gKlxuICogIyMjIFBhcmFtZXRlcnNcbiAqXG4gKiBUbyBpbml0aWFsaXplIGEgd2VpZXJzdHJhc3MgY3VydmUsIG9uZSBuZWVkcyB0byBwYXNzIGZvbGxvd2luZyBwYXJhbXM6XG4gKlxuICogKiBhOiBmb3JtdWxhIHBhcmFtXG4gKiAqIGI6IGZvcm11bGEgcGFyYW1cbiAqICogRnA6IGZpbml0ZSBmaWVsZCBvZiBwcmltZSBjaGFyYWN0ZXJpc3RpYyBQOyBtYXkgYmUgY29tcGxleCAoRnAyKS4gQXJpdGhtZXRpY3MgaXMgZG9uZSBpbiBmaWVsZFxuICogKiBuOiBvcmRlciBvZiBwcmltZSBzdWJncm91cCBhLmsuYSB0b3RhbCBhbW91bnQgb2YgdmFsaWQgY3VydmUgcG9pbnRzXG4gKiAqIEd4OiBCYXNlIHBvaW50ICh4LCB5KSBha2EgZ2VuZXJhdG9yIHBvaW50LiBHeCA9IHggY29vcmRpbmF0ZVxuICogKiBHeTogLi4ueSBjb29yZGluYXRlXG4gKiAqIGg6IGNvZmFjdG9yLCB1c3VhbGx5IDEuIGgqbiA9IGN1cnZlIGdyb3VwIG9yZGVyIChuIGlzIG9ubHkgc3ViZ3JvdXAgb3JkZXIpXG4gKiAqIGxvd1M6IHdoZXRoZXIgdG8gZW5hYmxlIChkZWZhdWx0KSBvciBkaXNhYmxlIFwibG93LXNcIiBub24tbWFsbGVhYmxlIHNpZ25hdHVyZXNcbiAqXG4gKiAjIyMgRGVzaWduIHJhdGlvbmFsZSBmb3IgdHlwZXNcbiAqXG4gKiAqIEludGVyYWN0aW9uIGJldHdlZW4gY2xhc3NlcyBmcm9tIGRpZmZlcmVudCBjdXJ2ZXMgc2hvdWxkIGZhaWw6XG4gKiAgIGBrMjU2LlBvaW50LkJBU0UuYWRkKHAyNTYuUG9pbnQuQkFTRSlgXG4gKiAqIEZvciB0aGlzIHB1cnBvc2Ugd2Ugd2FudCB0byB1c2UgYGluc3RhbmNlb2ZgIG9wZXJhdG9yLCB3aGljaCBpcyBmYXN0IGFuZCB3b3JrcyBkdXJpbmcgcnVudGltZVxuICogKiBEaWZmZXJlbnQgY2FsbHMgb2YgYGN1cnZlKClgIHdvdWxkIHJldHVybiBkaWZmZXJlbnQgY2xhc3NlcyAtXG4gKiAgIGBjdXJ2ZShwYXJhbXMpICE9PSBjdXJ2ZShwYXJhbXMpYDogaWYgc29tZWJvZHkgZGVjaWRlZCB0byBtb25rZXktcGF0Y2ggdGhlaXIgY3VydmUsXG4gKiAgIGl0IHdvbid0IGFmZmVjdCBvdGhlcnNcbiAqXG4gKiBUeXBlU2NyaXB0IGNhbid0IGluZmVyIHR5cGVzIGZvciBjbGFzc2VzIGNyZWF0ZWQgaW5zaWRlIGEgZnVuY3Rpb24uIENsYXNzZXMgaXMgb25lIGluc3RhbmNlXG4gKiBvZiBub21pbmF0aXZlIHR5cGVzIGluIFR5cGVTY3JpcHQgYW5kIGludGVyZmFjZXMgb25seSBjaGVjayBmb3Igc2hhcGUsIHNvIGl0J3MgaGFyZCB0byBjcmVhdGVcbiAqIHVuaXF1ZSB0eXBlIGZvciBldmVyeSBmdW5jdGlvbiBjYWxsLlxuICpcbiAqIFdlIGNhbiB1c2UgZ2VuZXJpYyB0eXBlcyB2aWEgc29tZSBwYXJhbSwgbGlrZSBjdXJ2ZSBvcHRzLCBidXQgdGhhdCB3b3VsZDpcbiAqICAgICAxLiBFbmFibGUgaW50ZXJhY3Rpb24gYmV0d2VlbiBgY3VydmUocGFyYW1zKWAgYW5kIGBjdXJ2ZShwYXJhbXMpYCAoY3VydmVzIG9mIHNhbWUgcGFyYW1zKVxuICogICAgIHdoaWNoIGlzIGhhcmQgdG8gZGVidWcuXG4gKiAgICAgMi4gUGFyYW1zIGNhbiBiZSBnZW5lcmljIGFuZCB3ZSBjYW4ndCBlbmZvcmNlIHRoZW0gdG8gYmUgY29uc3RhbnQgdmFsdWU6XG4gKiAgICAgaWYgc29tZWJvZHkgY3JlYXRlcyBjdXJ2ZSBmcm9tIG5vbi1jb25zdGFudCBwYXJhbXMsXG4gKiAgICAgaXQgd291bGQgYmUgYWxsb3dlZCB0byBpbnRlcmFjdCB3aXRoIG90aGVyIGN1cnZlcyB3aXRoIG5vbi1jb25zdGFudCBwYXJhbXNcbiAqXG4gKiBAdG9kbyBodHRwczovL3d3dy50eXBlc2NyaXB0bGFuZy5vcmcvZG9jcy9oYW5kYm9vay9yZWxlYXNlLW5vdGVzL3R5cGVzY3JpcHQtMi03Lmh0bWwjdW5pcXVlLXN5bWJvbFxuICogQG1vZHVsZVxuICovXG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IGN1cnZlX3RzXzEgPSByZXF1aXJlKFwiLi9jdXJ2ZS5qc1wiKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgbW9kdWxhcl90c18xID0gcmVxdWlyZShcIi4vbW9kdWxhci5qc1wiKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgdXRpbHNfdHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuZnVuY3Rpb24gdmFsaWRhdGVTaWdWZXJPcHRzKG9wdHMpIHtcbiAgICBpZiAob3B0cy5sb3dTICE9PSB1bmRlZmluZWQpXG4gICAgICAgICgwLCB1dGlsc190c18xLmFib29sKSgnbG93UycsIG9wdHMubG93Uyk7XG4gICAgaWYgKG9wdHMucHJlaGFzaCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAoMCwgdXRpbHNfdHNfMS5hYm9vbCkoJ3ByZWhhc2gnLCBvcHRzLnByZWhhc2gpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVQb2ludE9wdHMoY3VydmUpIHtcbiAgICBjb25zdCBvcHRzID0gKDAsIGN1cnZlX3RzXzEudmFsaWRhdGVCYXNpYykoY3VydmUpO1xuICAgICgwLCB1dGlsc190c18xLnZhbGlkYXRlT2JqZWN0KShvcHRzLCB7XG4gICAgICAgIGE6ICdmaWVsZCcsXG4gICAgICAgIGI6ICdmaWVsZCcsXG4gICAgfSwge1xuICAgICAgICBhbGxvd0luZmluaXR5UG9pbnQ6ICdib29sZWFuJyxcbiAgICAgICAgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzOiAnYXJyYXknLFxuICAgICAgICBjbGVhckNvZmFjdG9yOiAnZnVuY3Rpb24nLFxuICAgICAgICBmcm9tQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgICAgIGlzVG9yc2lvbkZyZWU6ICdmdW5jdGlvbicsXG4gICAgICAgIHRvQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgICAgIHdyYXBQcml2YXRlS2V5OiAnYm9vbGVhbicsXG4gICAgfSk7XG4gICAgY29uc3QgeyBlbmRvLCBGcCwgYSB9ID0gb3B0cztcbiAgICBpZiAoZW5kbykge1xuICAgICAgICBpZiAoIUZwLmVxbChhLCBGcC5aRVJPKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGVuZG86IENVUlZFLmEgbXVzdCBiZSAwJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBlbmRvICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICAgdHlwZW9mIGVuZG8uYmV0YSAhPT0gJ2JpZ2ludCcgfHxcbiAgICAgICAgICAgIHR5cGVvZiBlbmRvLnNwbGl0U2NhbGFyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZW5kbzogZXhwZWN0ZWQgXCJiZXRhXCI6IGJpZ2ludCBhbmQgXCJzcGxpdFNjYWxhclwiOiBmdW5jdGlvbicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHsgLi4ub3B0cyB9KTtcbn1cbmNsYXNzIERFUkVyciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtID0gJycpIHtcbiAgICAgICAgc3VwZXIobSk7XG4gICAgfVxufVxuZXhwb3J0cy5ERVJFcnIgPSBERVJFcnI7XG4vKipcbiAqIEFTTi4xIERFUiBlbmNvZGluZyB1dGlsaXRpZXMuIEFTTiBpcyB2ZXJ5IGNvbXBsZXggJiBmcmFnaWxlLiBGb3JtYXQ6XG4gKlxuICogICAgIFsweDMwIChTRVFVRU5DRSksIGJ5dGVsZW5ndGgsIDB4MDIgKElOVEVHRVIpLCBpbnRMZW5ndGgsIFIsIDB4MDIgKElOVEVHRVIpLCBpbnRMZW5ndGgsIFNdXG4gKlxuICogRG9jczogaHR0cHM6Ly9sZXRzZW5jcnlwdC5vcmcvZG9jcy9hLXdhcm0td2VsY29tZS10by1hc24xLWFuZC1kZXIvLCBodHRwczovL2x1Y2EubnRvcC5vcmcvVGVhY2hpbmcvQXBwdW50aS9hc24xLmh0bWxcbiAqL1xuZXhwb3J0cy5ERVIgPSB7XG4gICAgLy8gYXNuLjEgREVSIGVuY29kaW5nIHV0aWxzXG4gICAgRXJyOiBERVJFcnIsXG4gICAgLy8gQmFzaWMgYnVpbGRpbmcgYmxvY2sgaXMgVExWIChUYWctTGVuZ3RoLVZhbHVlKVxuICAgIF90bHY6IHtcbiAgICAgICAgZW5jb2RlOiAodGFnLCBkYXRhKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IEVycjogRSB9ID0gZXhwb3J0cy5ERVI7XG4gICAgICAgICAgICBpZiAodGFnIDwgMCB8fCB0YWcgPiAyNTYpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5lbmNvZGU6IHdyb25nIHRhZycpO1xuICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoICYgMSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmVuY29kZTogdW5wYWRkZWQgZGF0YScpO1xuICAgICAgICAgICAgY29uc3QgZGF0YUxlbiA9IGRhdGEubGVuZ3RoIC8gMjtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9ICgwLCB1dGlsc190c18xLm51bWJlclRvSGV4VW5wYWRkZWQpKGRhdGFMZW4pO1xuICAgICAgICAgICAgaWYgKChsZW4ubGVuZ3RoIC8gMikgJiAxMjgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5lbmNvZGU6IGxvbmcgZm9ybSBsZW5ndGggdG9vIGJpZycpO1xuICAgICAgICAgICAgLy8gbGVuZ3RoIG9mIGxlbmd0aCB3aXRoIGxvbmcgZm9ybSBmbGFnXG4gICAgICAgICAgICBjb25zdCBsZW5MZW4gPSBkYXRhTGVuID4gMTI3ID8gKDAsIHV0aWxzX3RzXzEubnVtYmVyVG9IZXhVbnBhZGRlZCkoKGxlbi5sZW5ndGggLyAyKSB8IDEyOCkgOiAnJztcbiAgICAgICAgICAgIGNvbnN0IHQgPSAoMCwgdXRpbHNfdHNfMS5udW1iZXJUb0hleFVucGFkZGVkKSh0YWcpO1xuICAgICAgICAgICAgcmV0dXJuIHQgKyBsZW5MZW4gKyBsZW4gKyBkYXRhO1xuICAgICAgICB9LFxuICAgICAgICAvLyB2IC0gdmFsdWUsIGwgLSBsZWZ0IGJ5dGVzICh1bnBhcnNlZClcbiAgICAgICAgZGVjb2RlKHRhZywgZGF0YSkge1xuICAgICAgICAgICAgY29uc3QgeyBFcnI6IEUgfSA9IGV4cG9ydHMuREVSO1xuICAgICAgICAgICAgbGV0IHBvcyA9IDA7XG4gICAgICAgICAgICBpZiAodGFnIDwgMCB8fCB0YWcgPiAyNTYpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5lbmNvZGU6IHdyb25nIHRhZycpO1xuICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgMiB8fCBkYXRhW3BvcysrXSAhPT0gdGFnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZGVjb2RlOiB3cm9uZyB0bHYnKTtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0ID0gZGF0YVtwb3MrK107XG4gICAgICAgICAgICBjb25zdCBpc0xvbmcgPSAhIShmaXJzdCAmIDEyOCk7IC8vIEZpcnN0IGJpdCBvZiBmaXJzdCBsZW5ndGggYnl0ZSBpcyBmbGFnIGZvciBzaG9ydC9sb25nIGZvcm1cbiAgICAgICAgICAgIGxldCBsZW5ndGggPSAwO1xuICAgICAgICAgICAgaWYgKCFpc0xvbmcpXG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gZmlyc3Q7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBMb25nIGZvcm06IFtsb25nRmxhZygxYml0KSwgbGVuZ3RoTGVuZ3RoKDdiaXQpLCBsZW5ndGggKEJFKV1cbiAgICAgICAgICAgICAgICBjb25zdCBsZW5MZW4gPSBmaXJzdCAmIDEyNztcbiAgICAgICAgICAgICAgICBpZiAoIWxlbkxlbilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5kZWNvZGUobG9uZyk6IGluZGVmaW5pdGUgbGVuZ3RoIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgICAgICBpZiAobGVuTGVuID4gNClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5kZWNvZGUobG9uZyk6IGJ5dGUgbGVuZ3RoIGlzIHRvbyBiaWcnKTsgLy8gdGhpcyB3aWxsIG92ZXJmbG93IHUzMiBpbiBqc1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aEJ5dGVzID0gZGF0YS5zdWJhcnJheShwb3MsIHBvcyArIGxlbkxlbik7XG4gICAgICAgICAgICAgICAgaWYgKGxlbmd0aEJ5dGVzLmxlbmd0aCAhPT0gbGVuTGVuKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmRlY29kZTogbGVuZ3RoIGJ5dGVzIG5vdCBjb21wbGV0ZScpO1xuICAgICAgICAgICAgICAgIGlmIChsZW5ndGhCeXRlc1swXSA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5kZWNvZGUobG9uZyk6IHplcm8gbGVmdG1vc3QgYnl0ZScpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYiBvZiBsZW5ndGhCeXRlcylcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gKGxlbmd0aCA8PCA4KSB8IGI7XG4gICAgICAgICAgICAgICAgcG9zICs9IGxlbkxlbjtcbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoIDwgMTI4KVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmRlY29kZShsb25nKTogbm90IG1pbmltYWwgZW5jb2RpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHYgPSBkYXRhLnN1YmFycmF5KHBvcywgcG9zICsgbGVuZ3RoKTtcbiAgICAgICAgICAgIGlmICh2Lmxlbmd0aCAhPT0gbGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZGVjb2RlOiB3cm9uZyB2YWx1ZSBsZW5ndGgnKTtcbiAgICAgICAgICAgIHJldHVybiB7IHYsIGw6IGRhdGEuc3ViYXJyYXkocG9zICsgbGVuZ3RoKSB9O1xuICAgICAgICB9LFxuICAgIH0sXG4gICAgLy8gaHR0cHM6Ly9jcnlwdG8uc3RhY2tleGNoYW5nZS5jb20vYS81NzczNCBMZWZ0bW9zdCBiaXQgb2YgZmlyc3QgYnl0ZSBpcyAnbmVnYXRpdmUnIGZsYWcsXG4gICAgLy8gc2luY2Ugd2UgYWx3YXlzIHVzZSBwb3NpdGl2ZSBpbnRlZ2VycyBoZXJlLiBJdCBtdXN0IGFsd2F5cyBiZSBlbXB0eTpcbiAgICAvLyAtIGFkZCB6ZXJvIGJ5dGUgaWYgZXhpc3RzXG4gICAgLy8gLSBpZiBuZXh0IGJ5dGUgZG9lc24ndCBoYXZlIGEgZmxhZywgbGVhZGluZyB6ZXJvIGlzIG5vdCBhbGxvd2VkIChtaW5pbWFsIGVuY29kaW5nKVxuICAgIF9pbnQ6IHtcbiAgICAgICAgZW5jb2RlKG51bSkge1xuICAgICAgICAgICAgY29uc3QgeyBFcnI6IEUgfSA9IGV4cG9ydHMuREVSO1xuICAgICAgICAgICAgaWYgKG51bSA8IF8wbilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgnaW50ZWdlcjogbmVnYXRpdmUgaW50ZWdlcnMgYXJlIG5vdCBhbGxvd2VkJyk7XG4gICAgICAgICAgICBsZXQgaGV4ID0gKDAsIHV0aWxzX3RzXzEubnVtYmVyVG9IZXhVbnBhZGRlZCkobnVtKTtcbiAgICAgICAgICAgIC8vIFBhZCB3aXRoIHplcm8gYnl0ZSBpZiBuZWdhdGl2ZSBmbGFnIGlzIHByZXNlbnRcbiAgICAgICAgICAgIGlmIChOdW1iZXIucGFyc2VJbnQoaGV4WzBdLCAxNikgJiAwYjEwMDApXG4gICAgICAgICAgICAgICAgaGV4ID0gJzAwJyArIGhleDtcbiAgICAgICAgICAgIGlmIChoZXgubGVuZ3RoICYgMSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndW5leHBlY3RlZCBERVIgcGFyc2luZyBhc3NlcnRpb246IHVucGFkZGVkIGhleCcpO1xuICAgICAgICAgICAgcmV0dXJuIGhleDtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlKGRhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgRXJyOiBFIH0gPSBleHBvcnRzLkRFUjtcbiAgICAgICAgICAgIGlmIChkYXRhWzBdICYgMTI4KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCdpbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiBuZWdhdGl2ZScpO1xuICAgICAgICAgICAgaWYgKGRhdGFbMF0gPT09IDB4MDAgJiYgIShkYXRhWzFdICYgMTI4KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgnaW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogdW5uZWNlc3NhcnkgbGVhZGluZyB6ZXJvJyk7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzX3RzXzEuYnl0ZXNUb051bWJlckJFKShkYXRhKTtcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIHRvU2lnKGhleCkge1xuICAgICAgICAvLyBwYXJzZSBERVIgc2lnbmF0dXJlXG4gICAgICAgIGNvbnN0IHsgRXJyOiBFLCBfaW50OiBpbnQsIF90bHY6IHRsdiB9ID0gZXhwb3J0cy5ERVI7XG4gICAgICAgIGNvbnN0IGRhdGEgPSAoMCwgdXRpbHNfdHNfMS5lbnN1cmVCeXRlcykoJ3NpZ25hdHVyZScsIGhleCk7XG4gICAgICAgIGNvbnN0IHsgdjogc2VxQnl0ZXMsIGw6IHNlcUxlZnRCeXRlcyB9ID0gdGx2LmRlY29kZSgweDMwLCBkYXRhKTtcbiAgICAgICAgaWYgKHNlcUxlZnRCeXRlcy5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnaW52YWxpZCBzaWduYXR1cmU6IGxlZnQgYnl0ZXMgYWZ0ZXIgcGFyc2luZycpO1xuICAgICAgICBjb25zdCB7IHY6IHJCeXRlcywgbDogckxlZnRCeXRlcyB9ID0gdGx2LmRlY29kZSgweDAyLCBzZXFCeXRlcyk7XG4gICAgICAgIGNvbnN0IHsgdjogc0J5dGVzLCBsOiBzTGVmdEJ5dGVzIH0gPSB0bHYuZGVjb2RlKDB4MDIsIHJMZWZ0Qnl0ZXMpO1xuICAgICAgICBpZiAoc0xlZnRCeXRlcy5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnaW52YWxpZCBzaWduYXR1cmU6IGxlZnQgYnl0ZXMgYWZ0ZXIgcGFyc2luZycpO1xuICAgICAgICByZXR1cm4geyByOiBpbnQuZGVjb2RlKHJCeXRlcyksIHM6IGludC5kZWNvZGUoc0J5dGVzKSB9O1xuICAgIH0sXG4gICAgaGV4RnJvbVNpZyhzaWcpIHtcbiAgICAgICAgY29uc3QgeyBfdGx2OiB0bHYsIF9pbnQ6IGludCB9ID0gZXhwb3J0cy5ERVI7XG4gICAgICAgIGNvbnN0IHJzID0gdGx2LmVuY29kZSgweDAyLCBpbnQuZW5jb2RlKHNpZy5yKSk7XG4gICAgICAgIGNvbnN0IHNzID0gdGx2LmVuY29kZSgweDAyLCBpbnQuZW5jb2RlKHNpZy5zKSk7XG4gICAgICAgIGNvbnN0IHNlcSA9IHJzICsgc3M7XG4gICAgICAgIHJldHVybiB0bHYuZW5jb2RlKDB4MzAsIHNlcSk7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBudW1Ub1NpemVkSGV4KG51bSwgc2l6ZSkge1xuICAgIHJldHVybiAoMCwgdXRpbHNfdHNfMS5ieXRlc1RvSGV4KSgoMCwgdXRpbHNfdHNfMS5udW1iZXJUb0J5dGVzQkUpKG51bSwgc2l6ZSkpO1xufVxuLy8gQmUgZnJpZW5kbHkgdG8gYmFkIEVDTUFTY3JpcHQgcGFyc2VycyBieSBub3QgdXNpbmcgYmlnaW50IGxpdGVyYWxzXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKSwgXzFuID0gQmlnSW50KDEpLCBfMm4gPSBCaWdJbnQoMiksIF8zbiA9IEJpZ0ludCgzKSwgXzRuID0gQmlnSW50KDQpO1xuZnVuY3Rpb24gd2VpZXJzdHJhc3NQb2ludHMob3B0cykge1xuICAgIGNvbnN0IENVUlZFID0gdmFsaWRhdGVQb2ludE9wdHMob3B0cyk7XG4gICAgY29uc3QgeyBGcCB9ID0gQ1VSVkU7IC8vIEFsbCBjdXJ2ZXMgaGFzIHNhbWUgZmllbGQgLyBncm91cCBsZW5ndGggYXMgZm9yIG5vdywgYnV0IHRoZXkgY2FuIGRpZmZlclxuICAgIGNvbnN0IEZuID0gKDAsIG1vZHVsYXJfdHNfMS5GaWVsZCkoQ1VSVkUubiwgQ1VSVkUubkJpdExlbmd0aCk7XG4gICAgY29uc3QgdG9CeXRlcyA9IENVUlZFLnRvQnl0ZXMgfHxcbiAgICAgICAgKChfYywgcG9pbnQsIF9pc0NvbXByZXNzZWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBwb2ludC50b0FmZmluZSgpO1xuICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsc190c18xLmNvbmNhdEJ5dGVzKShVaW50OEFycmF5LmZyb20oWzB4MDRdKSwgRnAudG9CeXRlcyhhLngpLCBGcC50b0J5dGVzKGEueSkpO1xuICAgICAgICB9KTtcbiAgICBjb25zdCBmcm9tQnl0ZXMgPSBDVVJWRS5mcm9tQnl0ZXMgfHxcbiAgICAgICAgKChieXRlcykgPT4ge1xuICAgICAgICAgICAgLy8gY29uc3QgaGVhZCA9IGJ5dGVzWzBdO1xuICAgICAgICAgICAgY29uc3QgdGFpbCA9IGJ5dGVzLnN1YmFycmF5KDEpO1xuICAgICAgICAgICAgLy8gaWYgKGhlYWQgIT09IDB4MDQpIHRocm93IG5ldyBFcnJvcignT25seSBub24tY29tcHJlc3NlZCBlbmNvZGluZyBpcyBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgIGNvbnN0IHggPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheSgwLCBGcC5CWVRFUykpO1xuICAgICAgICAgICAgY29uc3QgeSA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KEZwLkJZVEVTLCAyICogRnAuQllURVMpKTtcbiAgICAgICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICAgICAgfSk7XG4gICAgLyoqXG4gICAgICogecKyID0geMKzICsgYXggKyBiOiBTaG9ydCB3ZWllcnN0cmFzcyBjdXJ2ZSBmb3JtdWxhLiBUYWtlcyB4LCByZXR1cm5zIHnCsi5cbiAgICAgKiBAcmV0dXJucyB5wrJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpIHtcbiAgICAgICAgY29uc3QgeyBhLCBiIH0gPSBDVVJWRTtcbiAgICAgICAgY29uc3QgeDIgPSBGcC5zcXIoeCk7IC8vIHggKiB4XG4gICAgICAgIGNvbnN0IHgzID0gRnAubXVsKHgyLCB4KTsgLy8geMKyICogeFxuICAgICAgICByZXR1cm4gRnAuYWRkKEZwLmFkZCh4MywgRnAubXVsKHgsIGEpKSwgYik7IC8vIHjCsyArIGEgKiB4ICsgYlxuICAgIH1cbiAgICBmdW5jdGlvbiBpc1ZhbGlkWFkoeCwgeSkge1xuICAgICAgICBjb25zdCBsZWZ0ID0gRnAuc3FyKHkpOyAvLyB5wrJcbiAgICAgICAgY29uc3QgcmlnaHQgPSB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpOyAvLyB4wrMgKyBheCArIGJcbiAgICAgICAgcmV0dXJuIEZwLmVxbChsZWZ0LCByaWdodCk7XG4gICAgfVxuICAgIC8vIFZhbGlkYXRlIHdoZXRoZXIgdGhlIHBhc3NlZCBjdXJ2ZSBwYXJhbXMgYXJlIHZhbGlkLlxuICAgIC8vIFRlc3QgMTogZXF1YXRpb24gecKyID0geMKzICsgYXggKyBiIHNob3VsZCB3b3JrIGZvciBnZW5lcmF0b3IgcG9pbnQuXG4gICAgaWYgKCFpc1ZhbGlkWFkoQ1VSVkUuR3gsIENVUlZFLkd5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgY3VydmUgcGFyYW1zOiBnZW5lcmF0b3IgcG9pbnQnKTtcbiAgICAvLyBUZXN0IDI6IGRpc2NyaW1pbmFudCDOlCBwYXJ0IHNob3VsZCBiZSBub24temVybzogNGHCsyArIDI3YsKyICE9IDAuXG4gICAgLy8gR3VhcmFudGVlcyBjdXJ2ZSBpcyBnZW51cy0xLCBzbW9vdGggKG5vbi1zaW5ndWxhcikuXG4gICAgY29uc3QgXzRhMyA9IEZwLm11bChGcC5wb3coQ1VSVkUuYSwgXzNuKSwgXzRuKTtcbiAgICBjb25zdCBfMjdiMiA9IEZwLm11bChGcC5zcXIoQ1VSVkUuYiksIEJpZ0ludCgyNykpO1xuICAgIGlmIChGcC5pczAoRnAuYWRkKF80YTMsIF8yN2IyKSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIGN1cnZlIHBhcmFtczogYSBvciBiJyk7XG4gICAgLy8gVmFsaWQgZ3JvdXAgZWxlbWVudHMgcmVzaWRlIGluIHJhbmdlIDEuLm4tMVxuICAgIGZ1bmN0aW9uIGlzV2l0aGluQ3VydmVPcmRlcihudW0pIHtcbiAgICAgICAgcmV0dXJuICgwLCB1dGlsc190c18xLmluUmFuZ2UpKG51bSwgXzFuLCBDVVJWRS5uKTtcbiAgICB9XG4gICAgLy8gVmFsaWRhdGVzIGlmIHByaXYga2V5IGlzIHZhbGlkIGFuZCBjb252ZXJ0cyBpdCB0byBiaWdpbnQuXG4gICAgLy8gU3VwcG9ydHMgb3B0aW9ucyBhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHMgYW5kIHdyYXBQcml2YXRlS2V5LlxuICAgIGZ1bmN0aW9uIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIoa2V5KSB7XG4gICAgICAgIGNvbnN0IHsgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzOiBsZW5ndGhzLCBuQnl0ZUxlbmd0aCwgd3JhcFByaXZhdGVLZXksIG46IE4gfSA9IENVUlZFO1xuICAgICAgICBpZiAobGVuZ3RocyAmJiB0eXBlb2Yga2V5ICE9PSAnYmlnaW50Jykge1xuICAgICAgICAgICAgaWYgKCgwLCB1dGlsc190c18xLmlzQnl0ZXMpKGtleSkpXG4gICAgICAgICAgICAgICAga2V5ID0gKDAsIHV0aWxzX3RzXzEuYnl0ZXNUb0hleCkoa2V5KTtcbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSB0byBoZXggc3RyaW5nLCBwYWQuIEUuZy4gUDUyMSB3b3VsZCBub3JtIDEzMC0xMzIgY2hhciBoZXggdG8gMTMyLWNoYXIgYnl0ZXNcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJyB8fCAhbGVuZ3Rocy5pbmNsdWRlcyhrZXkubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcHJpdmF0ZSBrZXknKTtcbiAgICAgICAgICAgIGtleSA9IGtleS5wYWRTdGFydChuQnl0ZUxlbmd0aCAqIDIsICcwJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG51bTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG51bSA9XG4gICAgICAgICAgICAgICAgdHlwZW9mIGtleSA9PT0gJ2JpZ2ludCdcbiAgICAgICAgICAgICAgICAgICAgPyBrZXlcbiAgICAgICAgICAgICAgICAgICAgOiAoMCwgdXRpbHNfdHNfMS5ieXRlc1RvTnVtYmVyQkUpKCgwLCB1dGlsc190c18xLmVuc3VyZUJ5dGVzKSgncHJpdmF0ZSBrZXknLCBrZXksIG5CeXRlTGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcHJpdmF0ZSBrZXksIGV4cGVjdGVkIGhleCBvciAnICsgbkJ5dGVMZW5ndGggKyAnIGJ5dGVzLCBnb3QgJyArIHR5cGVvZiBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3cmFwUHJpdmF0ZUtleSlcbiAgICAgICAgICAgIG51bSA9ICgwLCBtb2R1bGFyX3RzXzEubW9kKShudW0sIE4pOyAvLyBkaXNhYmxlZCBieSBkZWZhdWx0LCBlbmFibGVkIGZvciBCTFNcbiAgICAgICAgKDAsIHV0aWxzX3RzXzEuYUluUmFuZ2UpKCdwcml2YXRlIGtleScsIG51bSwgXzFuLCBOKTsgLy8gbnVtIGluIHJhbmdlIFsxLi5OLTFdXG4gICAgICAgIHJldHVybiBudW07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFwcmpwb2ludChvdGhlcikge1xuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFBvaW50KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvamVjdGl2ZVBvaW50IGV4cGVjdGVkJyk7XG4gICAgfVxuICAgIC8vIE1lbW9pemVkIHRvQWZmaW5lIC8gdmFsaWRpdHkgY2hlY2suIFRoZXkgYXJlIGhlYXZ5LiBQb2ludHMgYXJlIGltbXV0YWJsZS5cbiAgICAvLyBDb252ZXJ0cyBQcm9qZWN0aXZlIHBvaW50IHRvIGFmZmluZSAoeCwgeSkgY29vcmRpbmF0ZXMuXG4gICAgLy8gQ2FuIGFjY2VwdCBwcmVjb21wdXRlZCBaXi0xIC0gZm9yIGV4YW1wbGUsIGZyb20gaW52ZXJ0QmF0Y2guXG4gICAgLy8gKFgsIFksIFopIOKIiyAoeD1YL1osIHk9WS9aKVxuICAgIGNvbnN0IHRvQWZmaW5lTWVtbyA9ICgwLCB1dGlsc190c18xLm1lbW9pemVkKSgocCwgaXopID0+IHtcbiAgICAgICAgY29uc3QgeyBweDogeCwgcHk6IHksIHB6OiB6IH0gPSBwO1xuICAgICAgICAvLyBGYXN0LXBhdGggZm9yIG5vcm1hbGl6ZWQgcG9pbnRzXG4gICAgICAgIGlmIChGcC5lcWwoeiwgRnAuT05FKSlcbiAgICAgICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICAgICAgY29uc3QgaXMwID0gcC5pczAoKTtcbiAgICAgICAgLy8gSWYgaW52WiB3YXMgMCwgd2UgcmV0dXJuIHplcm8gcG9pbnQuIEhvd2V2ZXIgd2Ugc3RpbGwgd2FudCB0byBleGVjdXRlXG4gICAgICAgIC8vIGFsbCBvcGVyYXRpb25zLCBzbyB3ZSByZXBsYWNlIGludlogd2l0aCBhIHJhbmRvbSBudW1iZXIsIDEuXG4gICAgICAgIGlmIChpeiA9PSBudWxsKVxuICAgICAgICAgICAgaXogPSBpczAgPyBGcC5PTkUgOiBGcC5pbnYoeik7XG4gICAgICAgIGNvbnN0IGF4ID0gRnAubXVsKHgsIGl6KTtcbiAgICAgICAgY29uc3QgYXkgPSBGcC5tdWwoeSwgaXopO1xuICAgICAgICBjb25zdCB6eiA9IEZwLm11bCh6LCBpeik7XG4gICAgICAgIGlmIChpczApXG4gICAgICAgICAgICByZXR1cm4geyB4OiBGcC5aRVJPLCB5OiBGcC5aRVJPIH07XG4gICAgICAgIGlmICghRnAuZXFsKHp6LCBGcC5PTkUpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZaIHdhcyBpbnZhbGlkJyk7XG4gICAgICAgIHJldHVybiB7IHg6IGF4LCB5OiBheSB9O1xuICAgIH0pO1xuICAgIC8vIE5PVEU6IG9uIGV4Y2VwdGlvbiB0aGlzIHdpbGwgY3Jhc2ggJ2NhY2hlZCcgYW5kIG5vIHZhbHVlIHdpbGwgYmUgc2V0LlxuICAgIC8vIE90aGVyd2lzZSB0cnVlIHdpbGwgYmUgcmV0dXJuXG4gICAgY29uc3QgYXNzZXJ0VmFsaWRNZW1vID0gKDAsIHV0aWxzX3RzXzEubWVtb2l6ZWQpKChwKSA9PiB7XG4gICAgICAgIGlmIChwLmlzMCgpKSB7XG4gICAgICAgICAgICAvLyAoMCwgMSwgMCkgYWthIFpFUk8gaXMgaW52YWxpZCBpbiBtb3N0IGNvbnRleHRzLlxuICAgICAgICAgICAgLy8gSW4gQkxTLCBaRVJPIGNhbiBiZSBzZXJpYWxpemVkLCBzbyB3ZSBhbGxvdyBpdC5cbiAgICAgICAgICAgIC8vICgwLCAwLCAwKSBpcyBpbnZhbGlkIHJlcHJlc2VudGF0aW9uIG9mIFpFUk8uXG4gICAgICAgICAgICBpZiAoQ1VSVkUuYWxsb3dJbmZpbml0eVBvaW50ICYmICFGcC5pczAocC5weSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IFpFUk8nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTb21lIDNyZC1wYXJ0eSB0ZXN0IHZlY3RvcnMgcmVxdWlyZSBkaWZmZXJlbnQgd29yZGluZyBiZXR3ZWVuIGhlcmUgJiBgZnJvbUNvbXByZXNzZWRIZXhgXG4gICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gcC50b0FmZmluZSgpO1xuICAgICAgICAvLyBDaGVjayBpZiB4LCB5IGFyZSB2YWxpZCBmaWVsZCBlbGVtZW50c1xuICAgICAgICBpZiAoIUZwLmlzVmFsaWQoeCkgfHwgIUZwLmlzVmFsaWQoeSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogeCBvciB5IG5vdCBGRScpO1xuICAgICAgICBpZiAoIWlzVmFsaWRYWSh4LCB5KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBlcXVhdGlvbiBsZWZ0ICE9IHJpZ2h0Jyk7XG4gICAgICAgIGlmICghcC5pc1RvcnNpb25GcmVlKCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogbm90IGluIHByaW1lLW9yZGVyIHN1Ymdyb3VwJyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFByb2plY3RpdmUgUG9pbnQgd29ya3MgaW4gM2QgLyBwcm9qZWN0aXZlIChob21vZ2VuZW91cykgY29vcmRpbmF0ZXM6IChYLCBZLCBaKSDiiIsgKHg9WC9aLCB5PVkvWilcbiAgICAgKiBEZWZhdWx0IFBvaW50IHdvcmtzIGluIDJkIC8gYWZmaW5lIGNvb3JkaW5hdGVzOiAoeCwgeSlcbiAgICAgKiBXZSdyZSBkb2luZyBjYWxjdWxhdGlvbnMgaW4gcHJvamVjdGl2ZSwgYmVjYXVzZSBpdHMgb3BlcmF0aW9ucyBkb24ndCByZXF1aXJlIGNvc3RseSBpbnZlcnNpb24uXG4gICAgICovXG4gICAgY2xhc3MgUG9pbnQge1xuICAgICAgICBjb25zdHJ1Y3RvcihweCwgcHksIHB6KSB7XG4gICAgICAgICAgICBpZiAocHggPT0gbnVsbCB8fCAhRnAuaXNWYWxpZChweCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd4IHJlcXVpcmVkJyk7XG4gICAgICAgICAgICBpZiAocHkgPT0gbnVsbCB8fCAhRnAuaXNWYWxpZChweSkgfHwgRnAuaXMwKHB5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3kgcmVxdWlyZWQnKTtcbiAgICAgICAgICAgIGlmIChweiA9PSBudWxsIHx8ICFGcC5pc1ZhbGlkKHB6KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ogcmVxdWlyZWQnKTtcbiAgICAgICAgICAgIHRoaXMucHggPSBweDtcbiAgICAgICAgICAgIHRoaXMucHkgPSBweTtcbiAgICAgICAgICAgIHRoaXMucHogPSBwejtcbiAgICAgICAgICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG9lcyBub3QgdmFsaWRhdGUgaWYgdGhlIHBvaW50IGlzIG9uLWN1cnZlLlxuICAgICAgICAvLyBVc2UgZnJvbUhleCBpbnN0ZWFkLCBvciBjYWxsIGFzc2VydFZhbGlkaXR5KCkgbGF0ZXIuXG4gICAgICAgIHN0YXRpYyBmcm9tQWZmaW5lKHApIHtcbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gcCB8fCB7fTtcbiAgICAgICAgICAgIGlmICghcCB8fCAhRnAuaXNWYWxpZCh4KSB8fCAhRnAuaXNWYWxpZCh5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYWZmaW5lIHBvaW50Jyk7XG4gICAgICAgICAgICBpZiAocCBpbnN0YW5jZW9mIFBvaW50KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncHJvamVjdGl2ZSBwb2ludCBub3QgYWxsb3dlZCcpO1xuICAgICAgICAgICAgY29uc3QgaXMwID0gKGkpID0+IEZwLmVxbChpLCBGcC5aRVJPKTtcbiAgICAgICAgICAgIC8vIGZyb21BZmZpbmUoeDowLCB5OjApIHdvdWxkIHByb2R1Y2UgKHg6MCwgeTowLCB6OjEpLCBidXQgd2UgbmVlZCAoeDowLCB5OjEsIHo6MClcbiAgICAgICAgICAgIGlmIChpczAoeCkgJiYgaXMwKHkpKVxuICAgICAgICAgICAgICAgIHJldHVybiBQb2ludC5aRVJPO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh4LCB5LCBGcC5PTkUpO1xuICAgICAgICB9XG4gICAgICAgIGdldCB4KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9BZmZpbmUoKS54O1xuICAgICAgICB9XG4gICAgICAgIGdldCB5KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9BZmZpbmUoKS55O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUYWtlcyBhIGJ1bmNoIG9mIFByb2plY3RpdmUgUG9pbnRzIGJ1dCBleGVjdXRlcyBvbmx5IG9uZVxuICAgICAgICAgKiBpbnZlcnNpb24gb24gYWxsIG9mIHRoZW0uIEludmVyc2lvbiBpcyB2ZXJ5IHNsb3cgb3BlcmF0aW9uLFxuICAgICAgICAgKiBzbyB0aGlzIGltcHJvdmVzIHBlcmZvcm1hbmNlIG1hc3NpdmVseS5cbiAgICAgICAgICogT3B0aW1pemF0aW9uOiBjb252ZXJ0cyBhIGxpc3Qgb2YgcHJvamVjdGl2ZSBwb2ludHMgdG8gYSBsaXN0IG9mIGlkZW50aWNhbCBwb2ludHMgd2l0aCBaPTEuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgbm9ybWFsaXplWihwb2ludHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvSW52ID0gKDAsIG1vZHVsYXJfdHNfMS5GcEludmVydEJhdGNoKShGcCwgcG9pbnRzLm1hcCgocCkgPT4gcC5weikpO1xuICAgICAgICAgICAgcmV0dXJuIHBvaW50cy5tYXAoKHAsIGkpID0+IHAudG9BZmZpbmUodG9JbnZbaV0pKS5tYXAoUG9pbnQuZnJvbUFmZmluZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIGhhc2ggc3RyaW5nIG9yIFVpbnQ4QXJyYXkgdG8gUG9pbnQuXG4gICAgICAgICAqIEBwYXJhbSBoZXggc2hvcnQvbG9uZyBFQ0RTQSBoZXhcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBmcm9tSGV4KGhleCkge1xuICAgICAgICAgICAgY29uc3QgUCA9IFBvaW50LmZyb21BZmZpbmUoZnJvbUJ5dGVzKCgwLCB1dGlsc190c18xLmVuc3VyZUJ5dGVzKSgncG9pbnRIZXgnLCBoZXgpKSk7XG4gICAgICAgICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUDtcbiAgICAgICAgfVxuICAgICAgICAvLyBNdWx0aXBsaWVzIGdlbmVyYXRvciBwb2ludCBieSBwcml2YXRlS2V5LlxuICAgICAgICBzdGF0aWMgZnJvbVByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgcmV0dXJuIFBvaW50LkJBU0UubXVsdGlwbHkobm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTXVsdGlzY2FsYXIgTXVsdGlwbGljYXRpb25cbiAgICAgICAgc3RhdGljIG1zbShwb2ludHMsIHNjYWxhcnMpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgY3VydmVfdHNfMS5waXBwZW5nZXIpKFBvaW50LCBGbiwgcG9pbnRzLCBzY2FsYXJzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBcIlByaXZhdGUgbWV0aG9kXCIsIGRvbid0IHVzZSBpdCBkaXJlY3RseVxuICAgICAgICBfc2V0V2luZG93U2l6ZSh3aW5kb3dTaXplKSB7XG4gICAgICAgICAgICB3bmFmLnNldFdpbmRvd1NpemUodGhpcywgd2luZG93U2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQSBwb2ludCBvbiBjdXJ2ZSBpcyB2YWxpZCBpZiBpdCBjb25mb3JtcyB0byBlcXVhdGlvbi5cbiAgICAgICAgYXNzZXJ0VmFsaWRpdHkoKSB7XG4gICAgICAgICAgICBhc3NlcnRWYWxpZE1lbW8odGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaGFzRXZlblkoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHkgfSA9IHRoaXMudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIGlmIChGcC5pc09kZClcbiAgICAgICAgICAgICAgICByZXR1cm4gIUZwLmlzT2RkKHkpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmllbGQgZG9lc24ndCBzdXBwb3J0IGlzT2RkXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21wYXJlIG9uZSBwb2ludCB0byBhbm90aGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgICAgICBhcHJqcG9pbnQob3RoZXIpO1xuICAgICAgICAgICAgY29uc3QgeyBweDogWDEsIHB5OiBZMSwgcHo6IFoxIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgeyBweDogWDIsIHB5OiBZMiwgcHo6IFoyIH0gPSBvdGhlcjtcbiAgICAgICAgICAgIGNvbnN0IFUxID0gRnAuZXFsKEZwLm11bChYMSwgWjIpLCBGcC5tdWwoWDIsIFoxKSk7XG4gICAgICAgICAgICBjb25zdCBVMiA9IEZwLmVxbChGcC5tdWwoWTEsIFoyKSwgRnAubXVsKFkyLCBaMSkpO1xuICAgICAgICAgICAgcmV0dXJuIFUxICYmIFUyO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGbGlwcyBwb2ludCB0byBvbmUgY29ycmVzcG9uZGluZyB0byAoeCwgLXkpIGluIEFmZmluZSBjb29yZGluYXRlcy5cbiAgICAgICAgICovXG4gICAgICAgIG5lZ2F0ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy5weCwgRnAubmVnKHRoaXMucHkpLCB0aGlzLnB6KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW5lcy1Db3N0ZWxsby1CYXRpbmEgZXhjZXB0aW9uLWZyZWUgZG91YmxpbmcgZm9ybXVsYS5cbiAgICAgICAgLy8gVGhlcmUgaXMgMzAlIGZhc3RlciBKYWNvYmlhbiBmb3JtdWxhLCBidXQgaXQgaXMgbm90IGNvbXBsZXRlLlxuICAgICAgICAvLyBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDE1LzEwNjAsIGFsZ29yaXRobSAzXG4gICAgICAgIC8vIENvc3Q6IDhNICsgM1MgKyAzKmEgKyAyKmIzICsgMTVhZGQuXG4gICAgICAgIGRvdWJsZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgYSwgYiB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBjb25zdCBiMyA9IEZwLm11bChiLCBfM24pO1xuICAgICAgICAgICAgY29uc3QgeyBweDogWDEsIHB5OiBZMSwgcHo6IFoxIH0gPSB0aGlzO1xuICAgICAgICAgICAgbGV0IFgzID0gRnAuWkVSTywgWTMgPSBGcC5aRVJPLCBaMyA9IEZwLlpFUk87IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgbGV0IHQwID0gRnAubXVsKFgxLCBYMSk7IC8vIHN0ZXAgMVxuICAgICAgICAgICAgbGV0IHQxID0gRnAubXVsKFkxLCBZMSk7XG4gICAgICAgICAgICBsZXQgdDIgPSBGcC5tdWwoWjEsIFoxKTtcbiAgICAgICAgICAgIGxldCB0MyA9IEZwLm11bChYMSwgWTEpO1xuICAgICAgICAgICAgdDMgPSBGcC5hZGQodDMsIHQzKTsgLy8gc3RlcCA1XG4gICAgICAgICAgICBaMyA9IEZwLm11bChYMSwgWjEpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIFozKTtcbiAgICAgICAgICAgIFgzID0gRnAubXVsKGEsIFozKTtcbiAgICAgICAgICAgIFkzID0gRnAubXVsKGIzLCB0Mik7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZChYMywgWTMpOyAvLyBzdGVwIDEwXG4gICAgICAgICAgICBYMyA9IEZwLnN1Yih0MSwgWTMpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQodDEsIFkzKTtcbiAgICAgICAgICAgIFkzID0gRnAubXVsKFgzLCBZMyk7XG4gICAgICAgICAgICBYMyA9IEZwLm11bCh0MywgWDMpO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwoYjMsIFozKTsgLy8gc3RlcCAxNVxuICAgICAgICAgICAgdDIgPSBGcC5tdWwoYSwgdDIpO1xuICAgICAgICAgICAgdDMgPSBGcC5zdWIodDAsIHQyKTtcbiAgICAgICAgICAgIHQzID0gRnAubXVsKGEsIHQzKTtcbiAgICAgICAgICAgIHQzID0gRnAuYWRkKHQzLCBaMyk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZCh0MCwgdDApOyAvLyBzdGVwIDIwXG4gICAgICAgICAgICB0MCA9IEZwLmFkZChaMywgdDApO1xuICAgICAgICAgICAgdDAgPSBGcC5hZGQodDAsIHQyKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQwLCB0Myk7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZChZMywgdDApO1xuICAgICAgICAgICAgdDIgPSBGcC5tdWwoWTEsIFoxKTsgLy8gc3RlcCAyNVxuICAgICAgICAgICAgdDIgPSBGcC5hZGQodDIsIHQyKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQyLCB0Myk7XG4gICAgICAgICAgICBYMyA9IEZwLnN1YihYMywgdDApO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwodDIsIHQxKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCBaMyk7IC8vIHN0ZXAgMzBcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCBaMyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KFgzLCBZMywgWjMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbmVzLUNvc3RlbGxvLUJhdGluYSBleGNlcHRpb24tZnJlZSBhZGRpdGlvbiBmb3JtdWxhLlxuICAgICAgICAvLyBUaGVyZSBpcyAzMCUgZmFzdGVyIEphY29iaWFuIGZvcm11bGEsIGJ1dCBpdCBpcyBub3QgY29tcGxldGUuXG4gICAgICAgIC8vIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTUvMTA2MCwgYWxnb3JpdGhtIDFcbiAgICAgICAgLy8gQ29zdDogMTJNICsgMFMgKyAzKmEgKyAzKmIzICsgMjNhZGQuXG4gICAgICAgIGFkZChvdGhlcikge1xuICAgICAgICAgICAgYXByanBvaW50KG90aGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgyLCBweTogWTIsIHB6OiBaMiB9ID0gb3RoZXI7XG4gICAgICAgICAgICBsZXQgWDMgPSBGcC5aRVJPLCBZMyA9IEZwLlpFUk8sIFozID0gRnAuWkVSTzsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBjb25zdCBhID0gQ1VSVkUuYTtcbiAgICAgICAgICAgIGNvbnN0IGIzID0gRnAubXVsKENVUlZFLmIsIF8zbik7XG4gICAgICAgICAgICBsZXQgdDAgPSBGcC5tdWwoWDEsIFgyKTsgLy8gc3RlcCAxXG4gICAgICAgICAgICBsZXQgdDEgPSBGcC5tdWwoWTEsIFkyKTtcbiAgICAgICAgICAgIGxldCB0MiA9IEZwLm11bChaMSwgWjIpO1xuICAgICAgICAgICAgbGV0IHQzID0gRnAuYWRkKFgxLCBZMSk7XG4gICAgICAgICAgICBsZXQgdDQgPSBGcC5hZGQoWDIsIFkyKTsgLy8gc3RlcCA1XG4gICAgICAgICAgICB0MyA9IEZwLm11bCh0MywgdDQpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQodDAsIHQxKTtcbiAgICAgICAgICAgIHQzID0gRnAuc3ViKHQzLCB0NCk7XG4gICAgICAgICAgICB0NCA9IEZwLmFkZChYMSwgWjEpO1xuICAgICAgICAgICAgbGV0IHQ1ID0gRnAuYWRkKFgyLCBaMik7IC8vIHN0ZXAgMTBcbiAgICAgICAgICAgIHQ0ID0gRnAubXVsKHQ0LCB0NSk7XG4gICAgICAgICAgICB0NSA9IEZwLmFkZCh0MCwgdDIpO1xuICAgICAgICAgICAgdDQgPSBGcC5zdWIodDQsIHQ1KTtcbiAgICAgICAgICAgIHQ1ID0gRnAuYWRkKFkxLCBaMSk7XG4gICAgICAgICAgICBYMyA9IEZwLmFkZChZMiwgWjIpOyAvLyBzdGVwIDE1XG4gICAgICAgICAgICB0NSA9IEZwLm11bCh0NSwgWDMpO1xuICAgICAgICAgICAgWDMgPSBGcC5hZGQodDEsIHQyKTtcbiAgICAgICAgICAgIHQ1ID0gRnAuc3ViKHQ1LCBYMyk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bChhLCB0NCk7XG4gICAgICAgICAgICBYMyA9IEZwLm11bChiMywgdDIpOyAvLyBzdGVwIDIwXG4gICAgICAgICAgICBaMyA9IEZwLmFkZChYMywgWjMpO1xuICAgICAgICAgICAgWDMgPSBGcC5zdWIodDEsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKHQxLCBaMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChYMywgWjMpO1xuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDAsIHQwKTsgLy8gc3RlcCAyNVxuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDEsIHQwKTtcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAubXVsKGIzLCB0NCk7XG4gICAgICAgICAgICB0MSA9IEZwLmFkZCh0MSwgdDIpO1xuICAgICAgICAgICAgdDIgPSBGcC5zdWIodDAsIHQyKTsgLy8gc3RlcCAzMFxuICAgICAgICAgICAgdDIgPSBGcC5tdWwoYSwgdDIpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQodDQsIHQyKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQxLCB0NCk7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZChZMywgdDApO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDUsIHQ0KTsgLy8gc3RlcCAzNVxuICAgICAgICAgICAgWDMgPSBGcC5tdWwodDMsIFgzKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKFgzLCB0MCk7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MywgdDEpO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwodDUsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCB0MCk7IC8vIHN0ZXAgNDBcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWDMsIFkzLCBaMyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VidHJhY3Qob3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChvdGhlci5uZWdhdGUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaXMwKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXF1YWxzKFBvaW50LlpFUk8pO1xuICAgICAgICB9XG4gICAgICAgIHdOQUYobikge1xuICAgICAgICAgICAgcmV0dXJuIHduYWYud05BRkNhY2hlZCh0aGlzLCBuLCBQb2ludC5ub3JtYWxpemVaKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogTm9uLWNvbnN0YW50LXRpbWUgbXVsdGlwbGljYXRpb24uIFVzZXMgZG91YmxlLWFuZC1hZGQgYWxnb3JpdGhtLlxuICAgICAgICAgKiBJdCdzIGZhc3RlciwgYnV0IHNob3VsZCBvbmx5IGJlIHVzZWQgd2hlbiB5b3UgZG9uJ3QgY2FyZSBhYm91dFxuICAgICAgICAgKiBhbiBleHBvc2VkIHByaXZhdGUga2V5IGUuZy4gc2lnIHZlcmlmaWNhdGlvbiwgd2hpY2ggd29ya3Mgb3ZlciAqcHVibGljKiBrZXlzLlxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHlVbnNhZmUoc2MpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZW5kbywgbjogTiB9ID0gQ1VSVkU7XG4gICAgICAgICAgICAoMCwgdXRpbHNfdHNfMS5hSW5SYW5nZSkoJ3NjYWxhcicsIHNjLCBfMG4sIE4pO1xuICAgICAgICAgICAgY29uc3QgSSA9IFBvaW50LlpFUk87XG4gICAgICAgICAgICBpZiAoc2MgPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm4gSTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzMCgpIHx8IHNjID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAvLyBDYXNlIGE6IG5vIGVuZG9tb3JwaGlzbS4gQ2FzZSBiOiBoYXMgcHJlY29tcHV0ZXMuXG4gICAgICAgICAgICBpZiAoIWVuZG8gfHwgd25hZi5oYXNQcmVjb21wdXRlcyh0aGlzKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gd25hZi53TkFGQ2FjaGVkVW5zYWZlKHRoaXMsIHNjLCBQb2ludC5ub3JtYWxpemVaKTtcbiAgICAgICAgICAgIC8vIENhc2UgYzogZW5kb21vcnBoaXNtXG4gICAgICAgICAgICAvKiogU2VlIGRvY3MgZm9yIHtAbGluayBFbmRvbW9ycGhpc21PcHRzfSAqL1xuICAgICAgICAgICAgbGV0IHsgazFuZWcsIGsxLCBrMm5lZywgazIgfSA9IGVuZG8uc3BsaXRTY2FsYXIoc2MpO1xuICAgICAgICAgICAgbGV0IGsxcCA9IEk7XG4gICAgICAgICAgICBsZXQgazJwID0gSTtcbiAgICAgICAgICAgIGxldCBkID0gdGhpcztcbiAgICAgICAgICAgIHdoaWxlIChrMSA+IF8wbiB8fCBrMiA+IF8wbikge1xuICAgICAgICAgICAgICAgIGlmIChrMSAmIF8xbilcbiAgICAgICAgICAgICAgICAgICAgazFwID0gazFwLmFkZChkKTtcbiAgICAgICAgICAgICAgICBpZiAoazIgJiBfMW4pXG4gICAgICAgICAgICAgICAgICAgIGsycCA9IGsycC5hZGQoZCk7XG4gICAgICAgICAgICAgICAgZCA9IGQuZG91YmxlKCk7XG4gICAgICAgICAgICAgICAgazEgPj49IF8xbjtcbiAgICAgICAgICAgICAgICBrMiA+Pj0gXzFuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGsxbmVnKVxuICAgICAgICAgICAgICAgIGsxcCA9IGsxcC5uZWdhdGUoKTtcbiAgICAgICAgICAgIGlmIChrMm5lZylcbiAgICAgICAgICAgICAgICBrMnAgPSBrMnAubmVnYXRlKCk7XG4gICAgICAgICAgICBrMnAgPSBuZXcgUG9pbnQoRnAubXVsKGsycC5weCwgZW5kby5iZXRhKSwgazJwLnB5LCBrMnAucHopO1xuICAgICAgICAgICAgcmV0dXJuIGsxcC5hZGQoazJwKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RhbnQgdGltZSBtdWx0aXBsaWNhdGlvbi5cbiAgICAgICAgICogVXNlcyB3TkFGIG1ldGhvZC4gV2luZG93ZWQgbWV0aG9kIG1heSBiZSAxMCUgZmFzdGVyLFxuICAgICAgICAgKiBidXQgdGFrZXMgMnggbG9uZ2VyIHRvIGdlbmVyYXRlIGFuZCBjb25zdW1lcyAyeCBtZW1vcnkuXG4gICAgICAgICAqIFVzZXMgcHJlY29tcHV0ZXMgd2hlbiBhdmFpbGFibGUuXG4gICAgICAgICAqIFVzZXMgZW5kb21vcnBoaXNtIGZvciBLb2JsaXR6IGN1cnZlcy5cbiAgICAgICAgICogQHBhcmFtIHNjYWxhciBieSB3aGljaCB0aGUgcG9pbnQgd291bGQgYmUgbXVsdGlwbGllZFxuICAgICAgICAgKiBAcmV0dXJucyBOZXcgcG9pbnRcbiAgICAgICAgICovXG4gICAgICAgIG11bHRpcGx5KHNjYWxhcikge1xuICAgICAgICAgICAgY29uc3QgeyBlbmRvLCBuOiBOIH0gPSBDVVJWRTtcbiAgICAgICAgICAgICgwLCB1dGlsc190c18xLmFJblJhbmdlKSgnc2NhbGFyJywgc2NhbGFyLCBfMW4sIE4pO1xuICAgICAgICAgICAgbGV0IHBvaW50LCBmYWtlOyAvLyBGYWtlIHBvaW50IGlzIHVzZWQgdG8gY29uc3QtdGltZSBtdWx0XG4gICAgICAgICAgICAvKiogU2VlIGRvY3MgZm9yIHtAbGluayBFbmRvbW9ycGhpc21PcHRzfSAqL1xuICAgICAgICAgICAgaWYgKGVuZG8pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGsxbmVnLCBrMSwgazJuZWcsIGsyIH0gPSBlbmRvLnNwbGl0U2NhbGFyKHNjYWxhcik7XG4gICAgICAgICAgICAgICAgbGV0IHsgcDogazFwLCBmOiBmMXAgfSA9IHRoaXMud05BRihrMSk7XG4gICAgICAgICAgICAgICAgbGV0IHsgcDogazJwLCBmOiBmMnAgfSA9IHRoaXMud05BRihrMik7XG4gICAgICAgICAgICAgICAgazFwID0gd25hZi5jb25zdFRpbWVOZWdhdGUoazFuZWcsIGsxcCk7XG4gICAgICAgICAgICAgICAgazJwID0gd25hZi5jb25zdFRpbWVOZWdhdGUoazJuZWcsIGsycCk7XG4gICAgICAgICAgICAgICAgazJwID0gbmV3IFBvaW50KEZwLm11bChrMnAucHgsIGVuZG8uYmV0YSksIGsycC5weSwgazJwLnB6KTtcbiAgICAgICAgICAgICAgICBwb2ludCA9IGsxcC5hZGQoazJwKTtcbiAgICAgICAgICAgICAgICBmYWtlID0gZjFwLmFkZChmMnApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwLCBmIH0gPSB0aGlzLndOQUYoc2NhbGFyKTtcbiAgICAgICAgICAgICAgICBwb2ludCA9IHA7XG4gICAgICAgICAgICAgICAgZmFrZSA9IGY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgYHpgIGZvciBib3RoIHBvaW50cywgYnV0IHJldHVybiBvbmx5IHJlYWwgb25lXG4gICAgICAgICAgICByZXR1cm4gUG9pbnQubm9ybWFsaXplWihbcG9pbnQsIGZha2VdKVswXTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRWZmaWNpZW50bHkgY2FsY3VsYXRlIGBhUCArIGJRYC4gVW5zYWZlLCBjYW4gZXhwb3NlIHByaXZhdGUga2V5LCBpZiB1c2VkIGluY29ycmVjdGx5LlxuICAgICAgICAgKiBOb3QgdXNpbmcgU3RyYXVzcy1TaGFtaXIgdHJpY2s6IHByZWNvbXB1dGF0aW9uIHRhYmxlcyBhcmUgZmFzdGVyLlxuICAgICAgICAgKiBUaGUgdHJpY2sgY291bGQgYmUgdXNlZnVsIGlmIGJvdGggUCBhbmQgUSBhcmUgbm90IEcgKG5vdCBpbiBvdXIgY2FzZSkuXG4gICAgICAgICAqIEByZXR1cm5zIG5vbi16ZXJvIGFmZmluZSBwb2ludFxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHlBbmRBZGRVbnNhZmUoUSwgYSwgYikge1xuICAgICAgICAgICAgY29uc3QgRyA9IFBvaW50LkJBU0U7IC8vIE5vIFN0cmF1c3MtU2hhbWlyIHRyaWNrOiB3ZSBoYXZlIDEwJSBmYXN0ZXIgRyBwcmVjb21wdXRlc1xuICAgICAgICAgICAgY29uc3QgbXVsID0gKFAsIGEgLy8gU2VsZWN0IGZhc3RlciBtdWx0aXBseSgpIG1ldGhvZFxuICAgICAgICAgICAgKSA9PiAoYSA9PT0gXzBuIHx8IGEgPT09IF8xbiB8fCAhUC5lcXVhbHMoRykgPyBQLm11bHRpcGx5VW5zYWZlKGEpIDogUC5tdWx0aXBseShhKSk7XG4gICAgICAgICAgICBjb25zdCBzdW0gPSBtdWwodGhpcywgYSkuYWRkKG11bChRLCBiKSk7XG4gICAgICAgICAgICByZXR1cm4gc3VtLmlzMCgpID8gdW5kZWZpbmVkIDogc3VtO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbnZlcnRzIFByb2plY3RpdmUgcG9pbnQgdG8gYWZmaW5lICh4LCB5KSBjb29yZGluYXRlcy5cbiAgICAgICAgLy8gQ2FuIGFjY2VwdCBwcmVjb21wdXRlZCBaXi0xIC0gZm9yIGV4YW1wbGUsIGZyb20gaW52ZXJ0QmF0Y2guXG4gICAgICAgIC8vICh4LCB5LCB6KSDiiIsgKHg9eC96LCB5PXkveilcbiAgICAgICAgdG9BZmZpbmUoaXopIHtcbiAgICAgICAgICAgIHJldHVybiB0b0FmZmluZU1lbW8odGhpcywgaXopO1xuICAgICAgICB9XG4gICAgICAgIGlzVG9yc2lvbkZyZWUoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGg6IGNvZmFjdG9yLCBpc1RvcnNpb25GcmVlIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGlmIChjb2ZhY3RvciA9PT0gXzFuKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBObyBzdWJncm91cHMsIGFsd2F5cyB0b3JzaW9uLWZyZWVcbiAgICAgICAgICAgIGlmIChpc1RvcnNpb25GcmVlKVxuICAgICAgICAgICAgICAgIHJldHVybiBpc1RvcnNpb25GcmVlKFBvaW50LCB0aGlzKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaXNUb3JzaW9uRnJlZSgpIGhhcyBub3QgYmVlbiBkZWNsYXJlZCBmb3IgdGhlIGVsbGlwdGljIGN1cnZlJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2xlYXJDb2ZhY3RvcigpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaDogY29mYWN0b3IsIGNsZWFyQ29mYWN0b3IgfSA9IENVUlZFO1xuICAgICAgICAgICAgaWYgKGNvZmFjdG9yID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7IC8vIEZhc3QtcGF0aFxuICAgICAgICAgICAgaWYgKGNsZWFyQ29mYWN0b3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsZWFyQ29mYWN0b3IoUG9pbnQsIHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlVbnNhZmUoQ1VSVkUuaCk7XG4gICAgICAgIH1cbiAgICAgICAgdG9SYXdCeXRlcyhpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgICAgICAoMCwgdXRpbHNfdHNfMS5hYm9vbCkoJ2lzQ29tcHJlc3NlZCcsIGlzQ29tcHJlc3NlZCk7XG4gICAgICAgICAgICB0aGlzLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gdG9CeXRlcyhQb2ludCwgdGhpcywgaXNDb21wcmVzc2VkKTtcbiAgICAgICAgfVxuICAgICAgICB0b0hleChpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgICAgICAoMCwgdXRpbHNfdHNfMS5hYm9vbCkoJ2lzQ29tcHJlc3NlZCcsIGlzQ29tcHJlc3NlZCk7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzX3RzXzEuYnl0ZXNUb0hleCkodGhpcy50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGJhc2UgLyBnZW5lcmF0b3IgcG9pbnRcbiAgICBQb2ludC5CQVNFID0gbmV3IFBvaW50KENVUlZFLkd4LCBDVVJWRS5HeSwgRnAuT05FKTtcbiAgICAvLyB6ZXJvIC8gaW5maW5pdHkgLyBpZGVudGl0eSBwb2ludFxuICAgIFBvaW50LlpFUk8gPSBuZXcgUG9pbnQoRnAuWkVSTywgRnAuT05FLCBGcC5aRVJPKTsgLy8gMCwgMSwgMFxuICAgIGNvbnN0IHsgZW5kbywgbkJpdExlbmd0aCB9ID0gQ1VSVkU7XG4gICAgY29uc3Qgd25hZiA9ICgwLCBjdXJ2ZV90c18xLndOQUYpKFBvaW50LCBlbmRvID8gTWF0aC5jZWlsKG5CaXRMZW5ndGggLyAyKSA6IG5CaXRMZW5ndGgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIENVUlZFLFxuICAgICAgICBQcm9qZWN0aXZlUG9pbnQ6IFBvaW50LFxuICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLFxuICAgICAgICB3ZWllcnN0cmFzc0VxdWF0aW9uLFxuICAgICAgICBpc1dpdGhpbkN1cnZlT3JkZXIsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlT3B0cyhjdXJ2ZSkge1xuICAgIGNvbnN0IG9wdHMgPSAoMCwgY3VydmVfdHNfMS52YWxpZGF0ZUJhc2ljKShjdXJ2ZSk7XG4gICAgKDAsIHV0aWxzX3RzXzEudmFsaWRhdGVPYmplY3QpKG9wdHMsIHtcbiAgICAgICAgaGFzaDogJ2hhc2gnLFxuICAgICAgICBobWFjOiAnZnVuY3Rpb24nLFxuICAgICAgICByYW5kb21CeXRlczogJ2Z1bmN0aW9uJyxcbiAgICB9LCB7XG4gICAgICAgIGJpdHMyaW50OiAnZnVuY3Rpb24nLFxuICAgICAgICBiaXRzMmludF9tb2ROOiAnZnVuY3Rpb24nLFxuICAgICAgICBsb3dTOiAnYm9vbGVhbicsXG4gICAgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyBsb3dTOiB0cnVlLCAuLi5vcHRzIH0pO1xufVxuLyoqXG4gKiBDcmVhdGVzIHNob3J0IHdlaWVyc3RyYXNzIGN1cnZlIGFuZCBFQ0RTQSBzaWduYXR1cmUgbWV0aG9kcyBmb3IgaXQuXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgRmllbGQgfSBmcm9tICdAbm9ibGUvY3VydmVzL2Fic3RyYWN0L21vZHVsYXInO1xuICogLy8gQmVmb3JlIHRoYXQsIGRlZmluZSBCaWdJbnQtczogYSwgYiwgcCwgbiwgR3gsIEd5XG4gKiBjb25zdCBjdXJ2ZSA9IHdlaWVyc3RyYXNzKHsgYSwgYiwgRnA6IEZpZWxkKHApLCBuLCBHeCwgR3ksIGg6IDFuIH0pXG4gKi9cbmZ1bmN0aW9uIHdlaWVyc3RyYXNzKGN1cnZlRGVmKSB7XG4gICAgY29uc3QgQ1VSVkUgPSB2YWxpZGF0ZU9wdHMoY3VydmVEZWYpO1xuICAgIGNvbnN0IHsgRnAsIG46IENVUlZFX09SREVSLCBuQnl0ZUxlbmd0aCwgbkJpdExlbmd0aCB9ID0gQ1VSVkU7XG4gICAgY29uc3QgY29tcHJlc3NlZExlbiA9IEZwLkJZVEVTICsgMTsgLy8gZS5nLiAzMyBmb3IgMzJcbiAgICBjb25zdCB1bmNvbXByZXNzZWRMZW4gPSAyICogRnAuQllURVMgKyAxOyAvLyBlLmcuIDY1IGZvciAzMlxuICAgIGZ1bmN0aW9uIG1vZE4oYSkge1xuICAgICAgICByZXR1cm4gKDAsIG1vZHVsYXJfdHNfMS5tb2QpKGEsIENVUlZFX09SREVSKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW52TihhKSB7XG4gICAgICAgIHJldHVybiAoMCwgbW9kdWxhcl90c18xLmludmVydCkoYSwgQ1VSVkVfT1JERVIpO1xuICAgIH1cbiAgICBjb25zdCB7IFByb2plY3RpdmVQb2ludDogUG9pbnQsIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIsIHdlaWVyc3RyYXNzRXF1YXRpb24sIGlzV2l0aGluQ3VydmVPcmRlciwgfSA9IHdlaWVyc3RyYXNzUG9pbnRzKHtcbiAgICAgICAgLi4uQ1VSVkUsXG4gICAgICAgIHRvQnl0ZXMoX2MsIHBvaW50LCBpc0NvbXByZXNzZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBwb2ludC50b0FmZmluZSgpO1xuICAgICAgICAgICAgY29uc3QgeCA9IEZwLnRvQnl0ZXMoYS54KTtcbiAgICAgICAgICAgIGNvbnN0IGNhdCA9IHV0aWxzX3RzXzEuY29uY2F0Qnl0ZXM7XG4gICAgICAgICAgICAoMCwgdXRpbHNfdHNfMS5hYm9vbCkoJ2lzQ29tcHJlc3NlZCcsIGlzQ29tcHJlc3NlZCk7XG4gICAgICAgICAgICBpZiAoaXNDb21wcmVzc2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhdChVaW50OEFycmF5LmZyb20oW3BvaW50Lmhhc0V2ZW5ZKCkgPyAweDAyIDogMHgwM10pLCB4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYXQoVWludDhBcnJheS5mcm9tKFsweDA0XSksIHgsIEZwLnRvQnl0ZXMoYS55KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZyb21CeXRlcyhieXRlcykge1xuICAgICAgICAgICAgY29uc3QgbGVuID0gYnl0ZXMubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgaGVhZCA9IGJ5dGVzWzBdO1xuICAgICAgICAgICAgY29uc3QgdGFpbCA9IGJ5dGVzLnN1YmFycmF5KDEpO1xuICAgICAgICAgICAgLy8gdGhpcy5hc3NlcnRWYWxpZGl0eSgpIGlzIGRvbmUgaW5zaWRlIG9mIGZyb21IZXhcbiAgICAgICAgICAgIGlmIChsZW4gPT09IGNvbXByZXNzZWRMZW4gJiYgKGhlYWQgPT09IDB4MDIgfHwgaGVhZCA9PT0gMHgwMykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gKDAsIHV0aWxzX3RzXzEuYnl0ZXNUb051bWJlckJFKSh0YWlsKTtcbiAgICAgICAgICAgICAgICBpZiAoISgwLCB1dGlsc190c18xLmluUmFuZ2UpKHgsIF8xbiwgRnAuT1JERVIpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvaW50IGlzIG5vdCBvbiBjdXJ2ZScpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkyID0gd2VpZXJzdHJhc3NFcXVhdGlvbih4KTsgLy8gecKyID0geMKzICsgYXggKyBiXG4gICAgICAgICAgICAgICAgbGV0IHk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgeSA9IEZwLnNxcnQoeTIpOyAvLyB5ID0gecKyIF4gKHArMSkvNFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoc3FydEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1ZmZpeCA9IHNxcnRFcnJvciBpbnN0YW5jZW9mIEVycm9yID8gJzogJyArIHNxcnRFcnJvci5tZXNzYWdlIDogJyc7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9pbnQgaXMgbm90IG9uIGN1cnZlJyArIHN1ZmZpeCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGlzWU9kZCA9ICh5ICYgXzFuKSA9PT0gXzFuO1xuICAgICAgICAgICAgICAgIC8vIEVDRFNBXG4gICAgICAgICAgICAgICAgY29uc3QgaXNIZWFkT2RkID0gKGhlYWQgJiAxKSA9PT0gMTtcbiAgICAgICAgICAgICAgICBpZiAoaXNIZWFkT2RkICE9PSBpc1lPZGQpXG4gICAgICAgICAgICAgICAgICAgIHkgPSBGcC5uZWcoeSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobGVuID09PSB1bmNvbXByZXNzZWRMZW4gJiYgaGVhZCA9PT0gMHgwNCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheSgwLCBGcC5CWVRFUykpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheShGcC5CWVRFUywgMiAqIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2wgPSBjb21wcmVzc2VkTGVuO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVsID0gdW5jb21wcmVzc2VkTGVuO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBQb2ludCwgZXhwZWN0ZWQgbGVuZ3RoIG9mICcgKyBjbCArICcsIG9yIHVuY29tcHJlc3NlZCAnICsgdWwgKyAnLCBnb3QgJyArIGxlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgZnVuY3Rpb24gaXNCaWdnZXJUaGFuSGFsZk9yZGVyKG51bWJlcikge1xuICAgICAgICBjb25zdCBIQUxGID0gQ1VSVkVfT1JERVIgPj4gXzFuO1xuICAgICAgICByZXR1cm4gbnVtYmVyID4gSEFMRjtcbiAgICB9XG4gICAgZnVuY3Rpb24gbm9ybWFsaXplUyhzKSB7XG4gICAgICAgIHJldHVybiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIocykgPyBtb2ROKC1zKSA6IHM7XG4gICAgfVxuICAgIC8vIHNsaWNlIGJ5dGVzIG51bVxuICAgIGNvbnN0IHNsY051bSA9IChiLCBmcm9tLCB0bykgPT4gKDAsIHV0aWxzX3RzXzEuYnl0ZXNUb051bWJlckJFKShiLnNsaWNlKGZyb20sIHRvKSk7XG4gICAgLyoqXG4gICAgICogRUNEU0Egc2lnbmF0dXJlIHdpdGggaXRzIChyLCBzKSBwcm9wZXJ0aWVzLiBTdXBwb3J0cyBERVIgJiBjb21wYWN0IHJlcHJlc2VudGF0aW9ucy5cbiAgICAgKi9cbiAgICBjbGFzcyBTaWduYXR1cmUge1xuICAgICAgICBjb25zdHJ1Y3RvcihyLCBzLCByZWNvdmVyeSkge1xuICAgICAgICAgICAgKDAsIHV0aWxzX3RzXzEuYUluUmFuZ2UpKCdyJywgciwgXzFuLCBDVVJWRV9PUkRFUik7IC8vIHIgaW4gWzEuLk5dXG4gICAgICAgICAgICAoMCwgdXRpbHNfdHNfMS5hSW5SYW5nZSkoJ3MnLCBzLCBfMW4sIENVUlZFX09SREVSKTsgLy8gcyBpbiBbMS4uTl1cbiAgICAgICAgICAgIHRoaXMuciA9IHI7XG4gICAgICAgICAgICB0aGlzLnMgPSBzO1xuICAgICAgICAgICAgaWYgKHJlY292ZXJ5ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvdmVyeSA9IHJlY292ZXJ5O1xuICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwYWlyIChieXRlcyBvZiByLCBieXRlcyBvZiBzKVxuICAgICAgICBzdGF0aWMgZnJvbUNvbXBhY3QoaGV4KSB7XG4gICAgICAgICAgICBjb25zdCBsID0gbkJ5dGVMZW5ndGg7XG4gICAgICAgICAgICBoZXggPSAoMCwgdXRpbHNfdHNfMS5lbnN1cmVCeXRlcykoJ2NvbXBhY3RTaWduYXR1cmUnLCBoZXgsIGwgKiAyKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHNsY051bShoZXgsIDAsIGwpLCBzbGNOdW0oaGV4LCBsLCAyICogbCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERFUiBlbmNvZGVkIEVDRFNBIHNpZ25hdHVyZVxuICAgICAgICAvLyBodHRwczovL2JpdGNvaW4uc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzU3NjQ0L3doYXQtYXJlLXRoZS1wYXJ0cy1vZi1hLWJpdGNvaW4tdHJhbnNhY3Rpb24taW5wdXQtc2NyaXB0XG4gICAgICAgIHN0YXRpYyBmcm9tREVSKGhleCkge1xuICAgICAgICAgICAgY29uc3QgeyByLCBzIH0gPSBleHBvcnRzLkRFUi50b1NpZygoMCwgdXRpbHNfdHNfMS5lbnN1cmVCeXRlcykoJ0RFUicsIGhleCkpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUociwgcyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0b2RvIHJlbW92ZVxuICAgICAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAgICAgKi9cbiAgICAgICAgYXNzZXJ0VmFsaWRpdHkoKSB7IH1cbiAgICAgICAgYWRkUmVjb3ZlcnlCaXQocmVjb3ZlcnkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHRoaXMuciwgdGhpcy5zLCByZWNvdmVyeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVjb3ZlclB1YmxpY0tleShtc2dIYXNoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHIsIHMsIHJlY292ZXJ5OiByZWMgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBoID0gYml0czJpbnRfbW9kTigoMCwgdXRpbHNfdHNfMS5lbnN1cmVCeXRlcykoJ21zZ0hhc2gnLCBtc2dIYXNoKSk7IC8vIFRydW5jYXRlIGhhc2hcbiAgICAgICAgICAgIGlmIChyZWMgPT0gbnVsbCB8fCAhWzAsIDEsIDIsIDNdLmluY2x1ZGVzKHJlYykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWNvdmVyeSBpZCBpbnZhbGlkJyk7XG4gICAgICAgICAgICBjb25zdCByYWRqID0gcmVjID09PSAyIHx8IHJlYyA9PT0gMyA/IHIgKyBDVVJWRS5uIDogcjtcbiAgICAgICAgICAgIGlmIChyYWRqID49IEZwLk9SREVSKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVjb3ZlcnkgaWQgMiBvciAzIGludmFsaWQnKTtcbiAgICAgICAgICAgIGNvbnN0IHByZWZpeCA9IChyZWMgJiAxKSA9PT0gMCA/ICcwMicgOiAnMDMnO1xuICAgICAgICAgICAgY29uc3QgUiA9IFBvaW50LmZyb21IZXgocHJlZml4ICsgbnVtVG9TaXplZEhleChyYWRqLCBGcC5CWVRFUykpO1xuICAgICAgICAgICAgY29uc3QgaXIgPSBpbnZOKHJhZGopOyAvLyByXi0xXG4gICAgICAgICAgICBjb25zdCB1MSA9IG1vZE4oLWggKiBpcik7IC8vIC1ocl4tMVxuICAgICAgICAgICAgY29uc3QgdTIgPSBtb2ROKHMgKiBpcik7IC8vIHNyXi0xXG4gICAgICAgICAgICBjb25zdCBRID0gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShSLCB1MSwgdTIpOyAvLyAoc3JeLTEpUi0oaHJeLTEpRyA9IC0oaHJeLTEpRyArIChzcl4tMSlcbiAgICAgICAgICAgIGlmICghUSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvaW50IGF0IGluZmluaWZ5Jyk7IC8vIHVuc2FmZSBpcyBmaW5lOiBubyBwcml2IGRhdGEgbGVha2VkXG4gICAgICAgICAgICBRLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaWduYXR1cmVzIHNob3VsZCBiZSBsb3ctcywgdG8gcHJldmVudCBtYWxsZWFiaWxpdHkuXG4gICAgICAgIGhhc0hpZ2hTKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcih0aGlzLnMpO1xuICAgICAgICB9XG4gICAgICAgIG5vcm1hbGl6ZVMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYXNIaWdoUygpID8gbmV3IFNpZ25hdHVyZSh0aGlzLnIsIG1vZE4oLXRoaXMucyksIHRoaXMucmVjb3ZlcnkpIDogdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBERVItZW5jb2RlZFxuICAgICAgICB0b0RFUlJhd0J5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsc190c18xLmhleFRvQnl0ZXMpKHRoaXMudG9ERVJIZXgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9ERVJIZXgoKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5ERVIuaGV4RnJvbVNpZyh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwYWRkZWQgYnl0ZXMgb2YgciwgdGhlbiBwYWRkZWQgYnl0ZXMgb2Ygc1xuICAgICAgICB0b0NvbXBhY3RSYXdCeXRlcygpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbHNfdHNfMS5oZXhUb0J5dGVzKSh0aGlzLnRvQ29tcGFjdEhleCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0b0NvbXBhY3RIZXgoKSB7XG4gICAgICAgICAgICBjb25zdCBsID0gbkJ5dGVMZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4gbnVtVG9TaXplZEhleCh0aGlzLnIsIGwpICsgbnVtVG9TaXplZEhleCh0aGlzLnMsIGwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHV0aWxzID0ge1xuICAgICAgICBpc1ZhbGlkUHJpdmF0ZUtleShwcml2YXRlS2V5KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUtleSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXI6IG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9kdWNlcyBjcnlwdG9ncmFwaGljYWxseSBzZWN1cmUgcHJpdmF0ZSBrZXkgZnJvbSByYW5kb20gb2Ygc2l6ZVxuICAgICAgICAgKiAoZ3JvdXBMZW4gKyBjZWlsKGdyb3VwTGVuIC8gMikpIHdpdGggbW9kdWxvIGJpYXMgYmVpbmcgbmVnbGlnaWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIHJhbmRvbVByaXZhdGVLZXk6ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9ICgwLCBtb2R1bGFyX3RzXzEuZ2V0TWluSGFzaExlbmd0aCkoQ1VSVkUubik7XG4gICAgICAgICAgICByZXR1cm4gKDAsIG1vZHVsYXJfdHNfMS5tYXBIYXNoVG9GaWVsZCkoQ1VSVkUucmFuZG9tQnl0ZXMobGVuZ3RoKSwgQ1VSVkUubik7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIHByZWNvbXB1dGUgdGFibGUgZm9yIGFuIGFyYml0cmFyeSBFQyBwb2ludC4gTWFrZXMgcG9pbnQgXCJjYWNoZWRcIi5cbiAgICAgICAgICogQWxsb3dzIHRvIG1hc3NpdmVseSBzcGVlZC11cCBgcG9pbnQubXVsdGlwbHkoc2NhbGFyKWAuXG4gICAgICAgICAqIEByZXR1cm5zIGNhY2hlZCBwb2ludFxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBjb25zdCBmYXN0ID0gdXRpbHMucHJlY29tcHV0ZSg4LCBQcm9qZWN0aXZlUG9pbnQuZnJvbUhleChzb21lb25lc1B1YktleSkpO1xuICAgICAgICAgKiBmYXN0Lm11bHRpcGx5KHByaXZLZXkpOyAvLyBtdWNoIGZhc3RlciBFQ0RIIG5vd1xuICAgICAgICAgKi9cbiAgICAgICAgcHJlY29tcHV0ZSh3aW5kb3dTaXplID0gOCwgcG9pbnQgPSBQb2ludC5CQVNFKSB7XG4gICAgICAgICAgICBwb2ludC5fc2V0V2luZG93U2l6ZSh3aW5kb3dTaXplKTtcbiAgICAgICAgICAgIHBvaW50Lm11bHRpcGx5KEJpZ0ludCgzKSk7IC8vIDMgaXMgYXJiaXRyYXJ5LCBqdXN0IG5lZWQgYW55IG51bWJlciBoZXJlXG4gICAgICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBwdWJsaWMga2V5IGZvciBhIHByaXZhdGUga2V5LiBDaGVja3MgZm9yIHZhbGlkaXR5IG9mIHRoZSBwcml2YXRlIGtleS5cbiAgICAgKiBAcGFyYW0gcHJpdmF0ZUtleSBwcml2YXRlIGtleVxuICAgICAqIEBwYXJhbSBpc0NvbXByZXNzZWQgd2hldGhlciB0byByZXR1cm4gY29tcGFjdCAoZGVmYXVsdCksIG9yIGZ1bGwga2V5XG4gICAgICogQHJldHVybnMgUHVibGljIGtleSwgZnVsbCB3aGVuIGlzQ29tcHJlc3NlZD1mYWxzZTsgc2hvcnQgd2hlbiBpc0NvbXByZXNzZWQ9dHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFB1YmxpY0tleShwcml2YXRlS2V5LCBpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBQb2ludC5mcm9tUHJpdmF0ZUtleShwcml2YXRlS2V5KS50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1aWNrIGFuZCBkaXJ0eSBjaGVjayBmb3IgaXRlbSBiZWluZyBwdWJsaWMga2V5LiBEb2VzIG5vdCB2YWxpZGF0ZSBoZXgsIG9yIGJlaW5nIG9uLWN1cnZlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUHJvYlB1YihpdGVtKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgUG9pbnQpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY29uc3QgYXJyID0gKDAsIHV0aWxzX3RzXzEuZW5zdXJlQnl0ZXMpKCdrZXknLCBpdGVtKTtcbiAgICAgICAgY29uc3QgbGVuID0gYXJyLmxlbmd0aDtcbiAgICAgICAgY29uc3QgZnBsID0gRnAuQllURVM7XG4gICAgICAgIGNvbnN0IGNvbXBMZW4gPSBmcGwgKyAxOyAvLyBlLmcuIDMzIGZvciAzMlxuICAgICAgICBjb25zdCB1bmNvbXBMZW4gPSAyICogZnBsICsgMTsgLy8gZS5nLiA2NSBmb3IgMzJcbiAgICAgICAgaWYgKENVUlZFLmFsbG93ZWRQcml2YXRlS2V5TGVuZ3RocyB8fCBuQnl0ZUxlbmd0aCA9PT0gY29tcExlbikge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBsZW4gPT09IGNvbXBMZW4gfHwgbGVuID09PSB1bmNvbXBMZW47XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRUNESCAoRWxsaXB0aWMgQ3VydmUgRGlmZmllIEhlbGxtYW4pLlxuICAgICAqIENvbXB1dGVzIHNoYXJlZCBwdWJsaWMga2V5IGZyb20gcHJpdmF0ZSBrZXkgYW5kIHB1YmxpYyBrZXkuXG4gICAgICogQ2hlY2tzOiAxKSBwcml2YXRlIGtleSB2YWxpZGl0eSAyKSBzaGFyZWQga2V5IGlzIG9uLWN1cnZlLlxuICAgICAqIERvZXMgTk9UIGhhc2ggdGhlIHJlc3VsdC5cbiAgICAgKiBAcGFyYW0gcHJpdmF0ZUEgcHJpdmF0ZSBrZXlcbiAgICAgKiBAcGFyYW0gcHVibGljQiBkaWZmZXJlbnQgcHVibGljIGtleVxuICAgICAqIEBwYXJhbSBpc0NvbXByZXNzZWQgd2hldGhlciB0byByZXR1cm4gY29tcGFjdCAoZGVmYXVsdCksIG9yIGZ1bGwga2V5XG4gICAgICogQHJldHVybnMgc2hhcmVkIHB1YmxpYyBrZXlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRTaGFyZWRTZWNyZXQocHJpdmF0ZUEsIHB1YmxpY0IsIGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgaWYgKGlzUHJvYlB1Yihwcml2YXRlQSkgPT09IHRydWUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpcnN0IGFyZyBtdXN0IGJlIHByaXZhdGUga2V5Jyk7XG4gICAgICAgIGlmIChpc1Byb2JQdWIocHVibGljQikgPT09IGZhbHNlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZWNvbmQgYXJnIG11c3QgYmUgcHVibGljIGtleScpO1xuICAgICAgICBjb25zdCBiID0gUG9pbnQuZnJvbUhleChwdWJsaWNCKTsgLy8gY2hlY2sgZm9yIGJlaW5nIG9uLWN1cnZlXG4gICAgICAgIHJldHVybiBiLm11bHRpcGx5KG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUEpKS50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCk7XG4gICAgfVxuICAgIC8vIFJGQzY5Nzk6IGVuc3VyZSBFQ0RTQSBtc2cgaXMgWCBieXRlcyBhbmQgPCBOLiBSRkMgc3VnZ2VzdHMgb3B0aW9uYWwgdHJ1bmNhdGluZyB2aWEgYml0czJvY3RldHMuXG4gICAgLy8gRklQUyAxODYtNCA0LjYgc3VnZ2VzdHMgdGhlIGxlZnRtb3N0IG1pbihuQml0TGVuLCBvdXRMZW4pIGJpdHMsIHdoaWNoIG1hdGNoZXMgYml0czJpbnQuXG4gICAgLy8gYml0czJpbnQgY2FuIHByb2R1Y2UgcmVzPk4sIHdlIGNhbiBkbyBtb2QocmVzLCBOKSBzaW5jZSB0aGUgYml0TGVuIGlzIHRoZSBzYW1lLlxuICAgIC8vIGludDJvY3RldHMgY2FuJ3QgYmUgdXNlZDsgcGFkcyBzbWFsbCBtc2dzIHdpdGggMDogdW5hY2NlcHRhdGJsZSBmb3IgdHJ1bmMgYXMgcGVyIFJGQyB2ZWN0b3JzXG4gICAgY29uc3QgYml0czJpbnQgPSBDVVJWRS5iaXRzMmludCB8fFxuICAgICAgICBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgICAgICAgICAgIC8vIE91ciBjdXN0b20gY2hlY2sgXCJqdXN0IGluIGNhc2VcIiwgZm9yIHByb3RlY3Rpb24gYWdhaW5zdCBEb1NcbiAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggPiA4MTkyKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW5wdXQgaXMgdG9vIGxhcmdlJyk7XG4gICAgICAgICAgICAvLyBGb3IgY3VydmVzIHdpdGggbkJpdExlbmd0aCAlIDggIT09IDA6IGJpdHMyb2N0ZXRzKGJpdHMyb2N0ZXRzKG0pKSAhPT0gYml0czJvY3RldHMobSlcbiAgICAgICAgICAgIC8vIGZvciBzb21lIGNhc2VzLCBzaW5jZSBieXRlcy5sZW5ndGggKiA4IGlzIG5vdCBhY3R1YWwgYml0TGVuZ3RoLlxuICAgICAgICAgICAgY29uc3QgbnVtID0gKDAsIHV0aWxzX3RzXzEuYnl0ZXNUb051bWJlckJFKShieXRlcyk7IC8vIGNoZWNrIGZvciA9PSB1OCBkb25lIGhlcmVcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gYnl0ZXMubGVuZ3RoICogOCAtIG5CaXRMZW5ndGg7IC8vIHRydW5jYXRlIHRvIG5CaXRMZW5ndGggbGVmdG1vc3QgYml0c1xuICAgICAgICAgICAgcmV0dXJuIGRlbHRhID4gMCA/IG51bSA+PiBCaWdJbnQoZGVsdGEpIDogbnVtO1xuICAgICAgICB9O1xuICAgIGNvbnN0IGJpdHMyaW50X21vZE4gPSBDVVJWRS5iaXRzMmludF9tb2ROIHx8XG4gICAgICAgIGZ1bmN0aW9uIChieXRlcykge1xuICAgICAgICAgICAgcmV0dXJuIG1vZE4oYml0czJpbnQoYnl0ZXMpKTsgLy8gY2FuJ3QgdXNlIGJ5dGVzVG9OdW1iZXJCRSBoZXJlXG4gICAgICAgIH07XG4gICAgLy8gTk9URTogcGFkcyBvdXRwdXQgd2l0aCB6ZXJvIGFzIHBlciBzcGVjXG4gICAgY29uc3QgT1JERVJfTUFTSyA9ICgwLCB1dGlsc190c18xLmJpdE1hc2spKG5CaXRMZW5ndGgpO1xuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRvIGJ5dGVzLiBDaGVja3MgaWYgbnVtIGluIGBbMC4uT1JERVJfTUFTSy0xXWAgZS5nLjogYFswLi4yXjI1Ni0xXWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW50Mm9jdGV0cyhudW0pIHtcbiAgICAgICAgKDAsIHV0aWxzX3RzXzEuYUluUmFuZ2UpKCdudW0gPCAyXicgKyBuQml0TGVuZ3RoLCBudW0sIF8wbiwgT1JERVJfTUFTSyk7XG4gICAgICAgIC8vIHdvcmtzIHdpdGggb3JkZXIsIGNhbiBoYXZlIGRpZmZlcmVudCBzaXplIHRoYW4gbnVtVG9GaWVsZCFcbiAgICAgICAgcmV0dXJuICgwLCB1dGlsc190c18xLm51bWJlclRvQnl0ZXNCRSkobnVtLCBuQnl0ZUxlbmd0aCk7XG4gICAgfVxuICAgIC8vIFN0ZXBzIEEsIEQgb2YgUkZDNjk3OSAzLjJcbiAgICAvLyBDcmVhdGVzIFJGQzY5Nzkgc2VlZDsgY29udmVydHMgbXNnL3ByaXZLZXkgdG8gbnVtYmVycy5cbiAgICAvLyBVc2VkIG9ubHkgaW4gc2lnbiwgbm90IGluIHZlcmlmeS5cbiAgICAvLyBOT1RFOiB3ZSBjYW5ub3QgYXNzdW1lIGhlcmUgdGhhdCBtc2dIYXNoIGhhcyBzYW1lIGFtb3VudCBvZiBieXRlcyBhcyBjdXJ2ZSBvcmRlcixcbiAgICAvLyB0aGlzIHdpbGwgYmUgaW52YWxpZCBhdCBsZWFzdCBmb3IgUDUyMS4gQWxzbyBpdCBjYW4gYmUgYmlnZ2VyIGZvciBQMjI0ICsgU0hBMjU2XG4gICAgZnVuY3Rpb24gcHJlcFNpZyhtc2dIYXNoLCBwcml2YXRlS2V5LCBvcHRzID0gZGVmYXVsdFNpZ09wdHMpIHtcbiAgICAgICAgaWYgKFsncmVjb3ZlcmVkJywgJ2Nhbm9uaWNhbCddLnNvbWUoKGspID0+IGsgaW4gb3B0cykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ24oKSBsZWdhY3kgb3B0aW9ucyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgIGNvbnN0IHsgaGFzaCwgcmFuZG9tQnl0ZXMgfSA9IENVUlZFO1xuICAgICAgICBsZXQgeyBsb3dTLCBwcmVoYXNoLCBleHRyYUVudHJvcHk6IGVudCB9ID0gb3B0czsgLy8gZ2VuZXJhdGVzIGxvdy1zIHNpZ3MgYnkgZGVmYXVsdFxuICAgICAgICBpZiAobG93UyA9PSBudWxsKVxuICAgICAgICAgICAgbG93UyA9IHRydWU7IC8vIFJGQzY5NzkgMy4yOiB3ZSBza2lwIHN0ZXAgQSwgYmVjYXVzZSB3ZSBhbHJlYWR5IHByb3ZpZGUgaGFzaFxuICAgICAgICBtc2dIYXNoID0gKDAsIHV0aWxzX3RzXzEuZW5zdXJlQnl0ZXMpKCdtc2dIYXNoJywgbXNnSGFzaCk7XG4gICAgICAgIHZhbGlkYXRlU2lnVmVyT3B0cyhvcHRzKTtcbiAgICAgICAgaWYgKHByZWhhc2gpXG4gICAgICAgICAgICBtc2dIYXNoID0gKDAsIHV0aWxzX3RzXzEuZW5zdXJlQnl0ZXMpKCdwcmVoYXNoZWQgbXNnSGFzaCcsIGhhc2gobXNnSGFzaCkpO1xuICAgICAgICAvLyBXZSBjYW4ndCBsYXRlciBjYWxsIGJpdHMyb2N0ZXRzLCBzaW5jZSBuZXN0ZWQgYml0czJpbnQgaXMgYnJva2VuIGZvciBjdXJ2ZXNcbiAgICAgICAgLy8gd2l0aCBuQml0TGVuZ3RoICUgOCAhPT0gMC4gQmVjYXVzZSBvZiB0aGF0LCB3ZSB1bndyYXAgaXQgaGVyZSBhcyBpbnQyb2N0ZXRzIGNhbGwuXG4gICAgICAgIC8vIGNvbnN0IGJpdHMyb2N0ZXRzID0gKGJpdHMpID0+IGludDJvY3RldHMoYml0czJpbnRfbW9kTihiaXRzKSlcbiAgICAgICAgY29uc3QgaDFpbnQgPSBiaXRzMmludF9tb2ROKG1zZ0hhc2gpO1xuICAgICAgICBjb25zdCBkID0gbm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KTsgLy8gdmFsaWRhdGUgcHJpdmF0ZSBrZXksIGNvbnZlcnQgdG8gYmlnaW50XG4gICAgICAgIGNvbnN0IHNlZWRBcmdzID0gW2ludDJvY3RldHMoZCksIGludDJvY3RldHMoaDFpbnQpXTtcbiAgICAgICAgLy8gZXh0cmFFbnRyb3B5LiBSRkM2OTc5IDMuNjogYWRkaXRpb25hbCBrJyAob3B0aW9uYWwpLlxuICAgICAgICBpZiAoZW50ICE9IG51bGwgJiYgZW50ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgLy8gSyA9IEhNQUNfSyhWIHx8IDB4MDAgfHwgaW50Mm9jdGV0cyh4KSB8fCBiaXRzMm9jdGV0cyhoMSkgfHwgaycpXG4gICAgICAgICAgICBjb25zdCBlID0gZW50ID09PSB0cnVlID8gcmFuZG9tQnl0ZXMoRnAuQllURVMpIDogZW50OyAvLyBnZW5lcmF0ZSByYW5kb20gYnl0ZXMgT1IgcGFzcyBhcy1pc1xuICAgICAgICAgICAgc2VlZEFyZ3MucHVzaCgoMCwgdXRpbHNfdHNfMS5lbnN1cmVCeXRlcykoJ2V4dHJhRW50cm9weScsIGUpKTsgLy8gY2hlY2sgZm9yIGJlaW5nIGJ5dGVzXG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VlZCA9ICgwLCB1dGlsc190c18xLmNvbmNhdEJ5dGVzKSguLi5zZWVkQXJncyk7IC8vIFN0ZXAgRCBvZiBSRkM2OTc5IDMuMlxuICAgICAgICBjb25zdCBtID0gaDFpbnQ7IC8vIE5PVEU6IG5vIG5lZWQgdG8gY2FsbCBiaXRzMmludCBzZWNvbmQgdGltZSBoZXJlLCBpdCBpcyBpbnNpZGUgdHJ1bmNhdGVIYXNoIVxuICAgICAgICAvLyBDb252ZXJ0cyBzaWduYXR1cmUgcGFyYW1zIGludG8gcG9pbnQgdyByL3MsIGNoZWNrcyByZXN1bHQgZm9yIHZhbGlkaXR5LlxuICAgICAgICBmdW5jdGlvbiBrMnNpZyhrQnl0ZXMpIHtcbiAgICAgICAgICAgIC8vIFJGQyA2OTc5IFNlY3Rpb24gMy4yLCBzdGVwIDM6IGsgPSBiaXRzMmludChUKVxuICAgICAgICAgICAgY29uc3QgayA9IGJpdHMyaW50KGtCeXRlcyk7IC8vIENhbm5vdCB1c2UgZmllbGRzIG1ldGhvZHMsIHNpbmNlIGl0IGlzIGdyb3VwIGVsZW1lbnRcbiAgICAgICAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKGspKVxuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gSW1wb3J0YW50OiBhbGwgbW9kKCkgY2FsbHMgaGVyZSBtdXN0IGJlIGRvbmUgb3ZlciBOXG4gICAgICAgICAgICBjb25zdCBpayA9IGludk4oayk7IC8vIGteLTEgbW9kIG5cbiAgICAgICAgICAgIGNvbnN0IHEgPSBQb2ludC5CQVNFLm11bHRpcGx5KGspLnRvQWZmaW5lKCk7IC8vIHEgPSBHa1xuICAgICAgICAgICAgY29uc3QgciA9IG1vZE4ocS54KTsgLy8gciA9IHEueCBtb2QgblxuICAgICAgICAgICAgaWYgKHIgPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBDYW4gdXNlIHNjYWxhciBibGluZGluZyBiXi0xKGJtICsgYmRyKSB3aGVyZSBiIOKIiCBbMSxx4oiSMV0gYWNjb3JkaW5nIHRvXG4gICAgICAgICAgICAvLyBodHRwczovL3RjaGVzLmlhY3Iub3JnL2luZGV4LnBocC9UQ0hFUy9hcnRpY2xlL3ZpZXcvNzMzNy82NTA5LiBXZSd2ZSBkZWNpZGVkIGFnYWluc3QgaXQ6XG4gICAgICAgICAgICAvLyBhKSBkZXBlbmRlbmN5IG9uIENTUFJORyBiKSAxNSUgc2xvd2Rvd24gYykgZG9lc24ndCByZWFsbHkgaGVscCBzaW5jZSBiaWdpbnRzIGFyZSBub3QgQ1RcbiAgICAgICAgICAgIGNvbnN0IHMgPSBtb2ROKGlrICogbW9kTihtICsgciAqIGQpKTsgLy8gTm90IHVzaW5nIGJsaW5kaW5nIGhlcmVcbiAgICAgICAgICAgIGlmIChzID09PSBfMG4pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHJlY292ZXJ5ID0gKHEueCA9PT0gciA/IDAgOiAyKSB8IE51bWJlcihxLnkgJiBfMW4pOyAvLyByZWNvdmVyeSBiaXQgKDIgb3IgMywgd2hlbiBxLnggPiBuKVxuICAgICAgICAgICAgbGV0IG5vcm1TID0gcztcbiAgICAgICAgICAgIGlmIChsb3dTICYmIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihzKSkge1xuICAgICAgICAgICAgICAgIG5vcm1TID0gbm9ybWFsaXplUyhzKTsgLy8gaWYgbG93UyB3YXMgcGFzc2VkLCBlbnN1cmUgcyBpcyBhbHdheXNcbiAgICAgICAgICAgICAgICByZWNvdmVyeSBePSAxOyAvLyAvLyBpbiB0aGUgYm90dG9tIGhhbGYgb2YgTlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUociwgbm9ybVMsIHJlY292ZXJ5KTsgLy8gdXNlIG5vcm1TLCBub3Qgc1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHNlZWQsIGsyc2lnIH07XG4gICAgfVxuICAgIGNvbnN0IGRlZmF1bHRTaWdPcHRzID0geyBsb3dTOiBDVVJWRS5sb3dTLCBwcmVoYXNoOiBmYWxzZSB9O1xuICAgIGNvbnN0IGRlZmF1bHRWZXJPcHRzID0geyBsb3dTOiBDVVJWRS5sb3dTLCBwcmVoYXNoOiBmYWxzZSB9O1xuICAgIC8qKlxuICAgICAqIFNpZ25zIG1lc3NhZ2UgaGFzaCB3aXRoIGEgcHJpdmF0ZSBrZXkuXG4gICAgICogYGBgXG4gICAgICogc2lnbihtLCBkLCBrKSB3aGVyZVxuICAgICAqICAgKHgsIHkpID0gRyDDlyBrXG4gICAgICogICByID0geCBtb2QgblxuICAgICAqICAgcyA9IChtICsgZHIpL2sgbW9kIG5cbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0gbXNnSGFzaCBOT1QgbWVzc2FnZS4gbXNnIG5lZWRzIHRvIGJlIGhhc2hlZCB0byBgbXNnSGFzaGAsIG9yIHVzZSBgcHJlaGFzaGAuXG4gICAgICogQHBhcmFtIHByaXZLZXkgcHJpdmF0ZSBrZXlcbiAgICAgKiBAcGFyYW0gb3B0cyBsb3dTIGZvciBub24tbWFsbGVhYmxlIHNpZ3MuIGV4dHJhRW50cm9weSBmb3IgbWl4aW5nIHJhbmRvbW5lc3MgaW50byBrLiBwcmVoYXNoIHdpbGwgaGFzaCBmaXJzdCBhcmcuXG4gICAgICogQHJldHVybnMgc2lnbmF0dXJlIHdpdGggcmVjb3ZlcnkgcGFyYW1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaWduKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMgPSBkZWZhdWx0U2lnT3B0cykge1xuICAgICAgICBjb25zdCB7IHNlZWQsIGsyc2lnIH0gPSBwcmVwU2lnKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMpOyAvLyBTdGVwcyBBLCBEIG9mIFJGQzY5NzkgMy4yLlxuICAgICAgICBjb25zdCBDID0gQ1VSVkU7XG4gICAgICAgIGNvbnN0IGRyYmcgPSAoMCwgdXRpbHNfdHNfMS5jcmVhdGVIbWFjRHJiZykoQy5oYXNoLm91dHB1dExlbiwgQy5uQnl0ZUxlbmd0aCwgQy5obWFjKTtcbiAgICAgICAgcmV0dXJuIGRyYmcoc2VlZCwgazJzaWcpOyAvLyBTdGVwcyBCLCBDLCBELCBFLCBGLCBHXG4gICAgfVxuICAgIC8vIEVuYWJsZSBwcmVjb21wdXRlcy4gU2xvd3MgZG93biBmaXJzdCBwdWJsaWNLZXkgY29tcHV0YXRpb24gYnkgMjBtcy5cbiAgICBQb2ludC5CQVNFLl9zZXRXaW5kb3dTaXplKDgpO1xuICAgIC8vIHV0aWxzLnByZWNvbXB1dGUoOCwgUHJvamVjdGl2ZVBvaW50LkJBU0UpXG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgYSBzaWduYXR1cmUgYWdhaW5zdCBtZXNzYWdlIGhhc2ggYW5kIHB1YmxpYyBrZXkuXG4gICAgICogUmVqZWN0cyBsb3dTIHNpZ25hdHVyZXMgYnkgZGVmYXVsdDogdG8gb3ZlcnJpZGUsXG4gICAgICogc3BlY2lmeSBvcHRpb24gYHtsb3dTOiBmYWxzZX1gLiBJbXBsZW1lbnRzIHNlY3Rpb24gNC4xLjQgZnJvbSBodHRwczovL3d3dy5zZWNnLm9yZy9zZWMxLXYyLnBkZjpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIHZlcmlmeShyLCBzLCBoLCBQKSB3aGVyZVxuICAgICAqICAgVTEgPSBoc14tMSBtb2QgblxuICAgICAqICAgVTIgPSByc14tMSBtb2QgblxuICAgICAqICAgUiA9IFUx4ouFRyAtIFUy4ouFUFxuICAgICAqICAgbW9kKFIueCwgbikgPT0gclxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZlcmlmeShzaWduYXR1cmUsIG1zZ0hhc2gsIHB1YmxpY0tleSwgb3B0cyA9IGRlZmF1bHRWZXJPcHRzKSB7XG4gICAgICAgIGNvbnN0IHNnID0gc2lnbmF0dXJlO1xuICAgICAgICBtc2dIYXNoID0gKDAsIHV0aWxzX3RzXzEuZW5zdXJlQnl0ZXMpKCdtc2dIYXNoJywgbXNnSGFzaCk7XG4gICAgICAgIHB1YmxpY0tleSA9ICgwLCB1dGlsc190c18xLmVuc3VyZUJ5dGVzKSgncHVibGljS2V5JywgcHVibGljS2V5KTtcbiAgICAgICAgY29uc3QgeyBsb3dTLCBwcmVoYXNoLCBmb3JtYXQgfSA9IG9wdHM7XG4gICAgICAgIC8vIFZlcmlmeSBvcHRzLCBkZWR1Y2Ugc2lnbmF0dXJlIGZvcm1hdFxuICAgICAgICB2YWxpZGF0ZVNpZ1Zlck9wdHMob3B0cyk7XG4gICAgICAgIGlmICgnc3RyaWN0JyBpbiBvcHRzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcHRpb25zLnN0cmljdCB3YXMgcmVuYW1lZCB0byBsb3dTJyk7XG4gICAgICAgIGlmIChmb3JtYXQgIT09IHVuZGVmaW5lZCAmJiBmb3JtYXQgIT09ICdjb21wYWN0JyAmJiBmb3JtYXQgIT09ICdkZXInKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmb3JtYXQgbXVzdCBiZSBjb21wYWN0IG9yIGRlcicpO1xuICAgICAgICBjb25zdCBpc0hleCA9IHR5cGVvZiBzZyA9PT0gJ3N0cmluZycgfHwgKDAsIHV0aWxzX3RzXzEuaXNCeXRlcykoc2cpO1xuICAgICAgICBjb25zdCBpc09iaiA9ICFpc0hleCAmJlxuICAgICAgICAgICAgIWZvcm1hdCAmJlxuICAgICAgICAgICAgdHlwZW9mIHNnID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgc2cgIT09IG51bGwgJiZcbiAgICAgICAgICAgIHR5cGVvZiBzZy5yID09PSAnYmlnaW50JyAmJlxuICAgICAgICAgICAgdHlwZW9mIHNnLnMgPT09ICdiaWdpbnQnO1xuICAgICAgICBpZiAoIWlzSGV4ICYmICFpc09iailcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzaWduYXR1cmUsIGV4cGVjdGVkIFVpbnQ4QXJyYXksIGhleCBzdHJpbmcgb3IgU2lnbmF0dXJlIGluc3RhbmNlJyk7XG4gICAgICAgIGxldCBfc2lnID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgUDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChpc09iailcbiAgICAgICAgICAgICAgICBfc2lnID0gbmV3IFNpZ25hdHVyZShzZy5yLCBzZy5zKTtcbiAgICAgICAgICAgIGlmIChpc0hleCkge1xuICAgICAgICAgICAgICAgIC8vIFNpZ25hdHVyZSBjYW4gYmUgcmVwcmVzZW50ZWQgaW4gMiB3YXlzOiBjb21wYWN0ICgyKm5CeXRlTGVuZ3RoKSAmIERFUiAodmFyaWFibGUtbGVuZ3RoKS5cbiAgICAgICAgICAgICAgICAvLyBTaW5jZSBERVIgY2FuIGFsc28gYmUgMipuQnl0ZUxlbmd0aCBieXRlcywgd2UgY2hlY2sgZm9yIGl0IGZpcnN0LlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3JtYXQgIT09ICdjb21wYWN0JylcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zaWcgPSBTaWduYXR1cmUuZnJvbURFUihzZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChkZXJFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShkZXJFcnJvciBpbnN0YW5jZW9mIGV4cG9ydHMuREVSLkVycikpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBkZXJFcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFfc2lnICYmIGZvcm1hdCAhPT0gJ2RlcicpXG4gICAgICAgICAgICAgICAgICAgIF9zaWcgPSBTaWduYXR1cmUuZnJvbUNvbXBhY3Qoc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUCA9IFBvaW50LmZyb21IZXgocHVibGljS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIV9zaWcpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChsb3dTICYmIF9zaWcuaGFzSGlnaFMoKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHByZWhhc2gpXG4gICAgICAgICAgICBtc2dIYXNoID0gQ1VSVkUuaGFzaChtc2dIYXNoKTtcbiAgICAgICAgY29uc3QgeyByLCBzIH0gPSBfc2lnO1xuICAgICAgICBjb25zdCBoID0gYml0czJpbnRfbW9kTihtc2dIYXNoKTsgLy8gQ2Fubm90IHVzZSBmaWVsZHMgbWV0aG9kcywgc2luY2UgaXQgaXMgZ3JvdXAgZWxlbWVudFxuICAgICAgICBjb25zdCBpcyA9IGludk4ocyk7IC8vIHNeLTFcbiAgICAgICAgY29uc3QgdTEgPSBtb2ROKGggKiBpcyk7IC8vIHUxID0gaHNeLTEgbW9kIG5cbiAgICAgICAgY29uc3QgdTIgPSBtb2ROKHIgKiBpcyk7IC8vIHUyID0gcnNeLTEgbW9kIG5cbiAgICAgICAgY29uc3QgUiA9IFBvaW50LkJBU0UubXVsdGlwbHlBbmRBZGRVbnNhZmUoUCwgdTEsIHUyKT8udG9BZmZpbmUoKTsgLy8gUiA9IHUx4ouFRyArIHUy4ouFUFxuICAgICAgICBpZiAoIVIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IHYgPSBtb2ROKFIueCk7XG4gICAgICAgIHJldHVybiB2ID09PSByO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBDVVJWRSxcbiAgICAgICAgZ2V0UHVibGljS2V5LFxuICAgICAgICBnZXRTaGFyZWRTZWNyZXQsXG4gICAgICAgIHNpZ24sXG4gICAgICAgIHZlcmlmeSxcbiAgICAgICAgUHJvamVjdGl2ZVBvaW50OiBQb2ludCxcbiAgICAgICAgU2lnbmF0dXJlLFxuICAgICAgICB1dGlscyxcbiAgICB9O1xufVxuLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2hhbGx1ZSBhbmQgdmFuIGRlIFdvZXN0aWpuZSBtZXRob2QgZm9yIGFueSB3ZWllcnN0cmFzcyBjdXJ2ZS5cbiAqIFRPRE86IGNoZWNrIGlmIHRoZXJlIGlzIGEgd2F5IHRvIG1lcmdlIHRoaXMgd2l0aCB1dlJhdGlvIGluIEVkd2FyZHM7IG1vdmUgdG8gbW9kdWxhci5cbiAqIGIgPSBUcnVlIGFuZCB5ID0gc3FydCh1IC8gdikgaWYgKHUgLyB2KSBpcyBzcXVhcmUgaW4gRiwgYW5kXG4gKiBiID0gRmFsc2UgYW5kIHkgPSBzcXJ0KFogKiAodSAvIHYpKSBvdGhlcndpc2UuXG4gKiBAcGFyYW0gRnBcbiAqIEBwYXJhbSBaXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBTV1VGcFNxcnRSYXRpbyhGcCwgWikge1xuICAgIC8vIEdlbmVyaWMgaW1wbGVtZW50YXRpb25cbiAgICBjb25zdCBxID0gRnAuT1JERVI7XG4gICAgbGV0IGwgPSBfMG47XG4gICAgZm9yIChsZXQgbyA9IHEgLSBfMW47IG8gJSBfMm4gPT09IF8wbjsgbyAvPSBfMm4pXG4gICAgICAgIGwgKz0gXzFuO1xuICAgIGNvbnN0IGMxID0gbDsgLy8gMS4gYzEsIHRoZSBsYXJnZXN0IGludGVnZXIgc3VjaCB0aGF0IDJeYzEgZGl2aWRlcyBxIC0gMS5cbiAgICAvLyBXZSBuZWVkIDJuICoqIGMxIGFuZCAybiAqKiAoYzEtMSkuIFdlIGNhbid0IHVzZSAqKjsgYnV0IHdlIGNhbiB1c2UgPDwuXG4gICAgLy8gMm4gKiogYzEgPT0gMm4gPDwgKGMxLTEpXG4gICAgY29uc3QgXzJuX3Bvd19jMV8xID0gXzJuIDw8IChjMSAtIF8xbiAtIF8xbik7XG4gICAgY29uc3QgXzJuX3Bvd19jMSA9IF8ybl9wb3dfYzFfMSAqIF8ybjtcbiAgICBjb25zdCBjMiA9IChxIC0gXzFuKSAvIF8ybl9wb3dfYzE7IC8vIDIuIGMyID0gKHEgLSAxKSAvICgyXmMxKSAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICBjb25zdCBjMyA9IChjMiAtIF8xbikgLyBfMm47IC8vIDMuIGMzID0gKGMyIC0gMSkgLyAyICAgICAgICAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICBjb25zdCBjNCA9IF8ybl9wb3dfYzEgLSBfMW47IC8vIDQuIGM0ID0gMl5jMSAtIDEgICAgICAgICAgICAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICBjb25zdCBjNSA9IF8ybl9wb3dfYzFfMTsgLy8gNS4gYzUgPSAyXihjMSAtIDEpICAgICAgICAgICAgICAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICBjb25zdCBjNiA9IEZwLnBvdyhaLCBjMik7IC8vIDYuIGM2ID0gWl5jMlxuICAgIGNvbnN0IGM3ID0gRnAucG93KFosIChjMiArIF8xbikgLyBfMm4pOyAvLyA3LiBjNyA9IFpeKChjMiArIDEpIC8gMilcbiAgICBsZXQgc3FydFJhdGlvID0gKHUsIHYpID0+IHtcbiAgICAgICAgbGV0IHR2MSA9IGM2OyAvLyAxLiB0djEgPSBjNlxuICAgICAgICBsZXQgdHYyID0gRnAucG93KHYsIGM0KTsgLy8gMi4gdHYyID0gdl5jNFxuICAgICAgICBsZXQgdHYzID0gRnAuc3FyKHR2Mik7IC8vIDMuIHR2MyA9IHR2Ml4yXG4gICAgICAgIHR2MyA9IEZwLm11bCh0djMsIHYpOyAvLyA0LiB0djMgPSB0djMgKiB2XG4gICAgICAgIGxldCB0djUgPSBGcC5tdWwodSwgdHYzKTsgLy8gNS4gdHY1ID0gdSAqIHR2M1xuICAgICAgICB0djUgPSBGcC5wb3codHY1LCBjMyk7IC8vIDYuIHR2NSA9IHR2NV5jM1xuICAgICAgICB0djUgPSBGcC5tdWwodHY1LCB0djIpOyAvLyA3LiB0djUgPSB0djUgKiB0djJcbiAgICAgICAgdHYyID0gRnAubXVsKHR2NSwgdik7IC8vIDguIHR2MiA9IHR2NSAqIHZcbiAgICAgICAgdHYzID0gRnAubXVsKHR2NSwgdSk7IC8vIDkuIHR2MyA9IHR2NSAqIHVcbiAgICAgICAgbGV0IHR2NCA9IEZwLm11bCh0djMsIHR2Mik7IC8vIDEwLiB0djQgPSB0djMgKiB0djJcbiAgICAgICAgdHY1ID0gRnAucG93KHR2NCwgYzUpOyAvLyAxMS4gdHY1ID0gdHY0XmM1XG4gICAgICAgIGxldCBpc1FSID0gRnAuZXFsKHR2NSwgRnAuT05FKTsgLy8gMTIuIGlzUVIgPSB0djUgPT0gMVxuICAgICAgICB0djIgPSBGcC5tdWwodHYzLCBjNyk7IC8vIDEzLiB0djIgPSB0djMgKiBjN1xuICAgICAgICB0djUgPSBGcC5tdWwodHY0LCB0djEpOyAvLyAxNC4gdHY1ID0gdHY0ICogdHYxXG4gICAgICAgIHR2MyA9IEZwLmNtb3YodHYyLCB0djMsIGlzUVIpOyAvLyAxNS4gdHYzID0gQ01PVih0djIsIHR2MywgaXNRUilcbiAgICAgICAgdHY0ID0gRnAuY21vdih0djUsIHR2NCwgaXNRUik7IC8vIDE2LiB0djQgPSBDTU9WKHR2NSwgdHY0LCBpc1FSKVxuICAgICAgICAvLyAxNy4gZm9yIGkgaW4gKGMxLCBjMSAtIDEsIC4uLiwgMik6XG4gICAgICAgIGZvciAobGV0IGkgPSBjMTsgaSA+IF8xbjsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgdHY1ID0gaSAtIF8ybjsgLy8gMTguICAgIHR2NSA9IGkgLSAyXG4gICAgICAgICAgICB0djUgPSBfMm4gPDwgKHR2NSAtIF8xbik7IC8vIDE5LiAgICB0djUgPSAyXnR2NVxuICAgICAgICAgICAgbGV0IHR2djUgPSBGcC5wb3codHY0LCB0djUpOyAvLyAyMC4gICAgdHY1ID0gdHY0XnR2NVxuICAgICAgICAgICAgY29uc3QgZTEgPSBGcC5lcWwodHZ2NSwgRnAuT05FKTsgLy8gMjEuICAgIGUxID0gdHY1ID09IDFcbiAgICAgICAgICAgIHR2MiA9IEZwLm11bCh0djMsIHR2MSk7IC8vIDIyLiAgICB0djIgPSB0djMgKiB0djFcbiAgICAgICAgICAgIHR2MSA9IEZwLm11bCh0djEsIHR2MSk7IC8vIDIzLiAgICB0djEgPSB0djEgKiB0djFcbiAgICAgICAgICAgIHR2djUgPSBGcC5tdWwodHY0LCB0djEpOyAvLyAyNC4gICAgdHY1ID0gdHY0ICogdHYxXG4gICAgICAgICAgICB0djMgPSBGcC5jbW92KHR2MiwgdHYzLCBlMSk7IC8vIDI1LiAgICB0djMgPSBDTU9WKHR2MiwgdHYzLCBlMSlcbiAgICAgICAgICAgIHR2NCA9IEZwLmNtb3YodHZ2NSwgdHY0LCBlMSk7IC8vIDI2LiAgICB0djQgPSBDTU9WKHR2NSwgdHY0LCBlMSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBpc1ZhbGlkOiBpc1FSLCB2YWx1ZTogdHYzIH07XG4gICAgfTtcbiAgICBpZiAoRnAuT1JERVIgJSBfNG4gPT09IF8zbikge1xuICAgICAgICAvLyBzcXJ0X3JhdGlvXzNtb2Q0KHUsIHYpXG4gICAgICAgIGNvbnN0IGMxID0gKEZwLk9SREVSIC0gXzNuKSAvIF80bjsgLy8gMS4gYzEgPSAocSAtIDMpIC8gNCAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICAgICAgY29uc3QgYzIgPSBGcC5zcXJ0KEZwLm5lZyhaKSk7IC8vIDIuIGMyID0gc3FydCgtWilcbiAgICAgICAgc3FydFJhdGlvID0gKHUsIHYpID0+IHtcbiAgICAgICAgICAgIGxldCB0djEgPSBGcC5zcXIodik7IC8vIDEuIHR2MSA9IHZeMlxuICAgICAgICAgICAgY29uc3QgdHYyID0gRnAubXVsKHUsIHYpOyAvLyAyLiB0djIgPSB1ICogdlxuICAgICAgICAgICAgdHYxID0gRnAubXVsKHR2MSwgdHYyKTsgLy8gMy4gdHYxID0gdHYxICogdHYyXG4gICAgICAgICAgICBsZXQgeTEgPSBGcC5wb3codHYxLCBjMSk7IC8vIDQuIHkxID0gdHYxXmMxXG4gICAgICAgICAgICB5MSA9IEZwLm11bCh5MSwgdHYyKTsgLy8gNS4geTEgPSB5MSAqIHR2MlxuICAgICAgICAgICAgY29uc3QgeTIgPSBGcC5tdWwoeTEsIGMyKTsgLy8gNi4geTIgPSB5MSAqIGMyXG4gICAgICAgICAgICBjb25zdCB0djMgPSBGcC5tdWwoRnAuc3FyKHkxKSwgdik7IC8vIDcuIHR2MyA9IHkxXjI7IDguIHR2MyA9IHR2MyAqIHZcbiAgICAgICAgICAgIGNvbnN0IGlzUVIgPSBGcC5lcWwodHYzLCB1KTsgLy8gOS4gaXNRUiA9IHR2MyA9PSB1XG4gICAgICAgICAgICBsZXQgeSA9IEZwLmNtb3YoeTIsIHkxLCBpc1FSKTsgLy8gMTAuIHkgPSBDTU9WKHkyLCB5MSwgaXNRUilcbiAgICAgICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGlzUVIsIHZhbHVlOiB5IH07IC8vIDExLiByZXR1cm4gKGlzUVIsIHkpIGlzUVIgPyB5IDogeSpjMlxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBObyBjdXJ2ZXMgdXNlcyB0aGF0XG4gICAgLy8gaWYgKEZwLk9SREVSICUgXzhuID09PSBfNW4pIC8vIHNxcnRfcmF0aW9fNW1vZDhcbiAgICByZXR1cm4gc3FydFJhdGlvO1xufVxuLyoqXG4gKiBTaW1wbGlmaWVkIFNoYWxsdWUtdmFuIGRlIFdvZXN0aWpuZS1VbGFzIE1ldGhvZFxuICogaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi02LjYuMlxuICovXG5mdW5jdGlvbiBtYXBUb0N1cnZlU2ltcGxlU1dVKEZwLCBvcHRzKSB7XG4gICAgKDAsIG1vZHVsYXJfdHNfMS52YWxpZGF0ZUZpZWxkKShGcCk7XG4gICAgaWYgKCFGcC5pc1ZhbGlkKG9wdHMuQSkgfHwgIUZwLmlzVmFsaWQob3B0cy5CKSB8fCAhRnAuaXNWYWxpZChvcHRzLlopKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcFRvQ3VydmVTaW1wbGVTV1U6IGludmFsaWQgb3B0cycpO1xuICAgIGNvbnN0IHNxcnRSYXRpbyA9IFNXVUZwU3FydFJhdGlvKEZwLCBvcHRzLlopO1xuICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRnAuaXNPZGQgaXMgbm90IGltcGxlbWVudGVkIScpO1xuICAgIC8vIElucHV0OiB1LCBhbiBlbGVtZW50IG9mIEYuXG4gICAgLy8gT3V0cHV0OiAoeCwgeSksIGEgcG9pbnQgb24gRS5cbiAgICByZXR1cm4gKHUpID0+IHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGxldCB0djEsIHR2MiwgdHYzLCB0djQsIHR2NSwgdHY2LCB4LCB5O1xuICAgICAgICB0djEgPSBGcC5zcXIodSk7IC8vIDEuICB0djEgPSB1XjJcbiAgICAgICAgdHYxID0gRnAubXVsKHR2MSwgb3B0cy5aKTsgLy8gMi4gIHR2MSA9IFogKiB0djFcbiAgICAgICAgdHYyID0gRnAuc3FyKHR2MSk7IC8vIDMuICB0djIgPSB0djFeMlxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djEpOyAvLyA0LiAgdHYyID0gdHYyICsgdHYxXG4gICAgICAgIHR2MyA9IEZwLmFkZCh0djIsIEZwLk9ORSk7IC8vIDUuICB0djMgPSB0djIgKyAxXG4gICAgICAgIHR2MyA9IEZwLm11bCh0djMsIG9wdHMuQik7IC8vIDYuICB0djMgPSBCICogdHYzXG4gICAgICAgIHR2NCA9IEZwLmNtb3Yob3B0cy5aLCBGcC5uZWcodHYyKSwgIUZwLmVxbCh0djIsIEZwLlpFUk8pKTsgLy8gNy4gIHR2NCA9IENNT1YoWiwgLXR2MiwgdHYyICE9IDApXG4gICAgICAgIHR2NCA9IEZwLm11bCh0djQsIG9wdHMuQSk7IC8vIDguICB0djQgPSBBICogdHY0XG4gICAgICAgIHR2MiA9IEZwLnNxcih0djMpOyAvLyA5LiAgdHYyID0gdHYzXjJcbiAgICAgICAgdHY2ID0gRnAuc3FyKHR2NCk7IC8vIDEwLiB0djYgPSB0djReMlxuICAgICAgICB0djUgPSBGcC5tdWwodHY2LCBvcHRzLkEpOyAvLyAxMS4gdHY1ID0gQSAqIHR2NlxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djUpOyAvLyAxMi4gdHYyID0gdHYyICsgdHY1XG4gICAgICAgIHR2MiA9IEZwLm11bCh0djIsIHR2Myk7IC8vIDEzLiB0djIgPSB0djIgKiB0djNcbiAgICAgICAgdHY2ID0gRnAubXVsKHR2NiwgdHY0KTsgLy8gMTQuIHR2NiA9IHR2NiAqIHR2NFxuICAgICAgICB0djUgPSBGcC5tdWwodHY2LCBvcHRzLkIpOyAvLyAxNS4gdHY1ID0gQiAqIHR2NlxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djUpOyAvLyAxNi4gdHYyID0gdHYyICsgdHY1XG4gICAgICAgIHggPSBGcC5tdWwodHYxLCB0djMpOyAvLyAxNy4gICB4ID0gdHYxICogdHYzXG4gICAgICAgIGNvbnN0IHsgaXNWYWxpZCwgdmFsdWUgfSA9IHNxcnRSYXRpbyh0djIsIHR2Nik7IC8vIDE4LiAoaXNfZ3gxX3NxdWFyZSwgeTEpID0gc3FydF9yYXRpbyh0djIsIHR2NilcbiAgICAgICAgeSA9IEZwLm11bCh0djEsIHUpOyAvLyAxOS4gICB5ID0gdHYxICogdSAgLT4gWiAqIHVeMyAqIHkxXG4gICAgICAgIHkgPSBGcC5tdWwoeSwgdmFsdWUpOyAvLyAyMC4gICB5ID0geSAqIHkxXG4gICAgICAgIHggPSBGcC5jbW92KHgsIHR2MywgaXNWYWxpZCk7IC8vIDIxLiAgIHggPSBDTU9WKHgsIHR2MywgaXNfZ3gxX3NxdWFyZSlcbiAgICAgICAgeSA9IEZwLmNtb3YoeSwgdmFsdWUsIGlzVmFsaWQpOyAvLyAyMi4gICB5ID0gQ01PVih5LCB5MSwgaXNfZ3gxX3NxdWFyZSlcbiAgICAgICAgY29uc3QgZTEgPSBGcC5pc09kZCh1KSA9PT0gRnAuaXNPZGQoeSk7IC8vIDIzLiAgZTEgPSBzZ24wKHUpID09IHNnbjAoeSlcbiAgICAgICAgeSA9IEZwLmNtb3YoRnAubmVnKHkpLCB5LCBlMSk7IC8vIDI0LiAgIHkgPSBDTU9WKC15LCB5LCBlMSlcbiAgICAgICAgY29uc3QgdHY0X2ludiA9ICgwLCBtb2R1bGFyX3RzXzEuRnBJbnZlcnRCYXRjaCkoRnAsIFt0djRdLCB0cnVlKVswXTtcbiAgICAgICAgeCA9IEZwLm11bCh4LCB0djRfaW52KTsgLy8gMjUuICAgeCA9IHggLyB0djRcbiAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWllcnN0cmFzcy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJERVIiLCJERVJFcnIiLCJ3ZWllcnN0cmFzc1BvaW50cyIsIndlaWVyc3RyYXNzIiwiU1dVRnBTcXJ0UmF0aW8iLCJtYXBUb0N1cnZlU2ltcGxlU1dVIiwiY3VydmVfdHNfMSIsInJlcXVpcmUiLCJtb2R1bGFyX3RzXzEiLCJ1dGlsc190c18xIiwidmFsaWRhdGVTaWdWZXJPcHRzIiwib3B0cyIsImxvd1MiLCJ1bmRlZmluZWQiLCJhYm9vbCIsInByZWhhc2giLCJ2YWxpZGF0ZVBvaW50T3B0cyIsImN1cnZlIiwidmFsaWRhdGVCYXNpYyIsInZhbGlkYXRlT2JqZWN0IiwiYSIsImIiLCJhbGxvd0luZmluaXR5UG9pbnQiLCJhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHMiLCJjbGVhckNvZmFjdG9yIiwiZnJvbUJ5dGVzIiwiaXNUb3JzaW9uRnJlZSIsInRvQnl0ZXMiLCJ3cmFwUHJpdmF0ZUtleSIsImVuZG8iLCJGcCIsImVxbCIsIlpFUk8iLCJFcnJvciIsImJldGEiLCJzcGxpdFNjYWxhciIsImZyZWV6ZSIsImNvbnN0cnVjdG9yIiwibSIsIkVyciIsIl90bHYiLCJlbmNvZGUiLCJ0YWciLCJkYXRhIiwiRSIsImxlbmd0aCIsImRhdGFMZW4iLCJsZW4iLCJudW1iZXJUb0hleFVucGFkZGVkIiwibGVuTGVuIiwidCIsImRlY29kZSIsInBvcyIsImZpcnN0IiwiaXNMb25nIiwibGVuZ3RoQnl0ZXMiLCJzdWJhcnJheSIsInYiLCJsIiwiX2ludCIsIm51bSIsIl8wbiIsImhleCIsIk51bWJlciIsInBhcnNlSW50IiwiYnl0ZXNUb051bWJlckJFIiwidG9TaWciLCJpbnQiLCJ0bHYiLCJlbnN1cmVCeXRlcyIsInNlcUJ5dGVzIiwic2VxTGVmdEJ5dGVzIiwickJ5dGVzIiwickxlZnRCeXRlcyIsInNCeXRlcyIsInNMZWZ0Qnl0ZXMiLCJyIiwicyIsImhleEZyb21TaWciLCJzaWciLCJycyIsInNzIiwic2VxIiwibnVtVG9TaXplZEhleCIsInNpemUiLCJieXRlc1RvSGV4IiwibnVtYmVyVG9CeXRlc0JFIiwiQmlnSW50IiwiXzFuIiwiXzJuIiwiXzNuIiwiXzRuIiwiQ1VSVkUiLCJGbiIsIkZpZWxkIiwibiIsIm5CaXRMZW5ndGgiLCJfYyIsInBvaW50IiwiX2lzQ29tcHJlc3NlZCIsInRvQWZmaW5lIiwiY29uY2F0Qnl0ZXMiLCJVaW50OEFycmF5IiwiZnJvbSIsIngiLCJ5IiwiYnl0ZXMiLCJ0YWlsIiwiQllURVMiLCJ3ZWllcnN0cmFzc0VxdWF0aW9uIiwieDIiLCJzcXIiLCJ4MyIsIm11bCIsImFkZCIsImlzVmFsaWRYWSIsImxlZnQiLCJyaWdodCIsIkd4IiwiR3kiLCJfNGEzIiwicG93IiwiXzI3YjIiLCJpczAiLCJpc1dpdGhpbkN1cnZlT3JkZXIiLCJpblJhbmdlIiwibm9ybVByaXZhdGVLZXlUb1NjYWxhciIsImtleSIsImxlbmd0aHMiLCJuQnl0ZUxlbmd0aCIsIk4iLCJpc0J5dGVzIiwiaW5jbHVkZXMiLCJwYWRTdGFydCIsImVycm9yIiwibW9kIiwiYUluUmFuZ2UiLCJhcHJqcG9pbnQiLCJvdGhlciIsIlBvaW50IiwidG9BZmZpbmVNZW1vIiwibWVtb2l6ZWQiLCJwIiwiaXoiLCJweCIsInB5IiwicHoiLCJ6IiwiT05FIiwiaW52IiwiYXgiLCJheSIsInp6IiwiYXNzZXJ0VmFsaWRNZW1vIiwiaXNWYWxpZCIsImZyb21BZmZpbmUiLCJpIiwibm9ybWFsaXplWiIsInBvaW50cyIsInRvSW52IiwiRnBJbnZlcnRCYXRjaCIsIm1hcCIsImZyb21IZXgiLCJQIiwiYXNzZXJ0VmFsaWRpdHkiLCJmcm9tUHJpdmF0ZUtleSIsInByaXZhdGVLZXkiLCJCQVNFIiwibXVsdGlwbHkiLCJtc20iLCJzY2FsYXJzIiwicGlwcGVuZ2VyIiwiX3NldFdpbmRvd1NpemUiLCJ3aW5kb3dTaXplIiwid25hZiIsInNldFdpbmRvd1NpemUiLCJoYXNFdmVuWSIsImlzT2RkIiwiZXF1YWxzIiwiWDEiLCJZMSIsIloxIiwiWDIiLCJZMiIsIloyIiwiVTEiLCJVMiIsIm5lZ2F0ZSIsIm5lZyIsImRvdWJsZSIsImIzIiwiWDMiLCJZMyIsIlozIiwidDAiLCJ0MSIsInQyIiwidDMiLCJzdWIiLCJ0NCIsInQ1Iiwic3VidHJhY3QiLCJ3TkFGIiwid05BRkNhY2hlZCIsIm11bHRpcGx5VW5zYWZlIiwic2MiLCJJIiwiaGFzUHJlY29tcHV0ZXMiLCJ3TkFGQ2FjaGVkVW5zYWZlIiwiazFuZWciLCJrMSIsImsybmVnIiwiazIiLCJrMXAiLCJrMnAiLCJkIiwic2NhbGFyIiwiZmFrZSIsImYiLCJmMXAiLCJmMnAiLCJjb25zdFRpbWVOZWdhdGUiLCJtdWx0aXBseUFuZEFkZFVuc2FmZSIsIlEiLCJHIiwic3VtIiwiaCIsImNvZmFjdG9yIiwidG9SYXdCeXRlcyIsImlzQ29tcHJlc3NlZCIsInRvSGV4IiwiTWF0aCIsImNlaWwiLCJQcm9qZWN0aXZlUG9pbnQiLCJ2YWxpZGF0ZU9wdHMiLCJoYXNoIiwiaG1hYyIsInJhbmRvbUJ5dGVzIiwiYml0czJpbnQiLCJiaXRzMmludF9tb2ROIiwiY3VydmVEZWYiLCJDVVJWRV9PUkRFUiIsImNvbXByZXNzZWRMZW4iLCJ1bmNvbXByZXNzZWRMZW4iLCJtb2ROIiwiaW52TiIsImludmVydCIsImNhdCIsImhlYWQiLCJPUkRFUiIsInkyIiwic3FydCIsInNxcnRFcnJvciIsInN1ZmZpeCIsIm1lc3NhZ2UiLCJpc1lPZGQiLCJpc0hlYWRPZGQiLCJjbCIsInVsIiwiaXNCaWdnZXJUaGFuSGFsZk9yZGVyIiwibnVtYmVyIiwiSEFMRiIsIm5vcm1hbGl6ZVMiLCJzbGNOdW0iLCJ0byIsInNsaWNlIiwiU2lnbmF0dXJlIiwicmVjb3ZlcnkiLCJmcm9tQ29tcGFjdCIsImZyb21ERVIiLCJhZGRSZWNvdmVyeUJpdCIsInJlY292ZXJQdWJsaWNLZXkiLCJtc2dIYXNoIiwicmVjIiwicmFkaiIsInByZWZpeCIsIlIiLCJpciIsInUxIiwidTIiLCJoYXNIaWdoUyIsInRvREVSUmF3Qnl0ZXMiLCJoZXhUb0J5dGVzIiwidG9ERVJIZXgiLCJ0b0NvbXBhY3RSYXdCeXRlcyIsInRvQ29tcGFjdEhleCIsInV0aWxzIiwiaXNWYWxpZFByaXZhdGVLZXkiLCJyYW5kb21Qcml2YXRlS2V5IiwiZ2V0TWluSGFzaExlbmd0aCIsIm1hcEhhc2hUb0ZpZWxkIiwicHJlY29tcHV0ZSIsImdldFB1YmxpY0tleSIsImlzUHJvYlB1YiIsIml0ZW0iLCJhcnIiLCJmcGwiLCJjb21wTGVuIiwidW5jb21wTGVuIiwiZ2V0U2hhcmVkU2VjcmV0IiwicHJpdmF0ZUEiLCJwdWJsaWNCIiwiZGVsdGEiLCJPUkRFUl9NQVNLIiwiYml0TWFzayIsImludDJvY3RldHMiLCJwcmVwU2lnIiwiZGVmYXVsdFNpZ09wdHMiLCJzb21lIiwiayIsImV4dHJhRW50cm9weSIsImVudCIsImgxaW50Iiwic2VlZEFyZ3MiLCJlIiwicHVzaCIsInNlZWQiLCJrMnNpZyIsImtCeXRlcyIsImlrIiwicSIsIm5vcm1TIiwiZGVmYXVsdFZlck9wdHMiLCJzaWduIiwicHJpdktleSIsIkMiLCJkcmJnIiwiY3JlYXRlSG1hY0RyYmciLCJvdXRwdXRMZW4iLCJ2ZXJpZnkiLCJzaWduYXR1cmUiLCJwdWJsaWNLZXkiLCJzZyIsImZvcm1hdCIsImlzSGV4IiwiaXNPYmoiLCJfc2lnIiwiZGVyRXJyb3IiLCJpcyIsIloiLCJvIiwiYzEiLCJfMm5fcG93X2MxXzEiLCJfMm5fcG93X2MxIiwiYzIiLCJjMyIsImM0IiwiYzUiLCJjNiIsImM3Iiwic3FydFJhdGlvIiwidSIsInR2MSIsInR2MiIsInR2MyIsInR2NSIsInR2NCIsImlzUVIiLCJjbW92IiwidHZ2NSIsImUxIiwieTEiLCJ2YWxpZGF0ZUZpZWxkIiwiQSIsIkIiLCJ0djYiLCJ0djRfaW52Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/@noble/curves/abstract/weierstrass.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/@noble/curves/secp256k1.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ox/node_modules/@noble/curves/secp256k1.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.encodeToCurve = exports.hashToCurve = exports.secp256k1_hasher = exports.schnorr = exports.secp256k1 = void 0;\n/**\n * NIST secp256k1. See [pdf](https://www.secg.org/sec2-v2.pdf).\n *\n * Seems to be rigid (not backdoored)\n * [as per discussion](https://bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975).\n *\n * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n * [See explanation](https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066).\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const sha2_1 = __webpack_require__(/*! @noble/hashes/sha2 */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/sha2.js\");\nconst utils_1 = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/utils.js\");\nconst _shortw_utils_ts_1 = __webpack_require__(/*! ./_shortw_utils.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/_shortw_utils.js\");\nconst hash_to_curve_ts_1 = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/abstract/hash-to-curve.js\");\nconst modular_ts_1 = __webpack_require__(/*! ./abstract/modular.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/abstract/modular.js\");\nconst utils_ts_1 = __webpack_require__(/*! ./abstract/utils.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/abstract/utils.js\");\nconst weierstrass_ts_1 = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/abstract/weierstrass.js\");\nconst secp256k1P = BigInt(\"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f\");\nconst secp256k1N = BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a, b)=>(a + b / _2n) / b;\n/**\n * ‚àön = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */ function sqrtMod(y) {\n    const P = secp256k1P;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = y * y * y % P; // x^3, 11\n    const b3 = b2 * b2 * y % P; // x^7\n    const b6 = (0, modular_ts_1.pow2)(b3, _3n, P) * b3 % P;\n    const b9 = (0, modular_ts_1.pow2)(b6, _3n, P) * b3 % P;\n    const b11 = (0, modular_ts_1.pow2)(b9, _2n, P) * b2 % P;\n    const b22 = (0, modular_ts_1.pow2)(b11, _11n, P) * b11 % P;\n    const b44 = (0, modular_ts_1.pow2)(b22, _22n, P) * b22 % P;\n    const b88 = (0, modular_ts_1.pow2)(b44, _44n, P) * b44 % P;\n    const b176 = (0, modular_ts_1.pow2)(b88, _88n, P) * b88 % P;\n    const b220 = (0, modular_ts_1.pow2)(b176, _44n, P) * b44 % P;\n    const b223 = (0, modular_ts_1.pow2)(b220, _3n, P) * b3 % P;\n    const t1 = (0, modular_ts_1.pow2)(b223, _23n, P) * b22 % P;\n    const t2 = (0, modular_ts_1.pow2)(t1, _6n, P) * b2 % P;\n    const root = (0, modular_ts_1.pow2)(t2, _2n, P);\n    if (!Fpk1.eql(Fpk1.sqr(root), y)) throw new Error(\"Cannot find square root\");\n    return root;\n}\nconst Fpk1 = (0, modular_ts_1.Field)(secp256k1P, undefined, undefined, {\n    sqrt: sqrtMod\n});\n/**\n * secp256k1 curve, ECDSA and ECDH methods.\n *\n * Field: `2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n`\n *\n * @example\n * ```js\n * import { secp256k1 } from '@noble/curves/secp256k1';\n * const priv = secp256k1.utils.randomPrivateKey();\n * const pub = secp256k1.getPublicKey(priv);\n * const msg = new Uint8Array(32).fill(1); // message hash (not message) in ecdsa\n * const sig = secp256k1.sign(msg, priv); // `{prehash: true}` option is available\n * const isValid = secp256k1.verify(sig, msg, pub) === true;\n * ```\n */ exports.secp256k1 = (0, _shortw_utils_ts_1.createCurve)({\n    a: _0n,\n    b: BigInt(7),\n    Fp: Fpk1,\n    n: secp256k1N,\n    Gx: BigInt(\"55066263022277343669578718895168534326250603453777594175500187360389116729240\"),\n    Gy: BigInt(\"32670510020758816978083085130507043184471273380659243275938904335757337482424\"),\n    h: BigInt(1),\n    lowS: true,\n    endo: {\n        // Endomorphism, see above\n        beta: BigInt(\"0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\"),\n        splitScalar: (k)=>{\n            const n = secp256k1N;\n            const a1 = BigInt(\"0x3086d221a7d46bcde86c90e49284eb15\");\n            const b1 = -_1n * BigInt(\"0xe4437ed6010e88286f547fa90abfe4c3\");\n            const a2 = BigInt(\"0x114ca50f7a8e2f3f657c1108d9d44cfd8\");\n            const b2 = a1;\n            const POW_2_128 = BigInt(\"0x100000000000000000000000000000000\"); // (2n**128n).toString(16)\n            const c1 = divNearest(b2 * k, n);\n            const c2 = divNearest(-b1 * k, n);\n            let k1 = (0, modular_ts_1.mod)(k - c1 * a1 - c2 * a2, n);\n            let k2 = (0, modular_ts_1.mod)(-c1 * b1 - c2 * b2, n);\n            const k1neg = k1 > POW_2_128;\n            const k2neg = k2 > POW_2_128;\n            if (k1neg) k1 = n - k1;\n            if (k2neg) k2 = n - k2;\n            if (k1 > POW_2_128 || k2 > POW_2_128) {\n                throw new Error(\"splitScalar: Endomorphism failed, k=\" + k);\n            }\n            return {\n                k1neg,\n                k1,\n                k2neg,\n                k2\n            };\n        }\n    }\n}, sha2_1.sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */ const TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag, ...messages) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = (0, sha2_1.sha256)(Uint8Array.from(tag, (c)=>c.charCodeAt(0)));\n        tagP = (0, utils_ts_1.concatBytes)(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return (0, sha2_1.sha256)((0, utils_ts_1.concatBytes)(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point)=>point.toRawBytes(true).slice(1);\nconst numTo32b = (n)=>(0, utils_ts_1.numberToBytesBE)(n, 32);\nconst modP = (x)=>(0, modular_ts_1.mod)(x, secp256k1P);\nconst modN = (x)=>(0, modular_ts_1.mod)(x, secp256k1N);\nconst Point = /* @__PURE__ */ (()=>exports.secp256k1.ProjectivePoint)();\nconst GmulAdd = (Q, a, b)=>Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    let d_ = exports.secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n    let p = Point.fromPrivateKey(d_); // P = d'‚ãÖG; 0 < d' < n check is done inside\n    const scalar = p.hasEvenY() ? d_ : modN(-d_);\n    return {\n        scalar: scalar,\n        bytes: pointToBytes(p)\n    };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */ function lift_x(x) {\n    (0, utils_ts_1.aInRange)(\"x\", x, _1n, secp256k1P); // Fail if x ‚â• p.\n    const xx = modP(x * x);\n    const c = modP(xx * x + BigInt(7)); // Let c = x¬≥ + 7 mod p.\n    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n    if (y % _2n !== _0n) y = modP(-y); // Return the unique point P such that x(P) = x and\n    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    p.assertValidity();\n    return p;\n}\nconst num = utils_ts_1.bytesToNumberBE;\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */ function challenge(...args) {\n    return modN(num(taggedHash(\"BIP0340/challenge\", ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */ function schnorrGetPublicKey(privateKey) {\n    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'‚â•n. Ret bytes(d'‚ãÖG)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */ function schnorrSign(message, privateKey, auxRand = (0, utils_1.randomBytes)(32)) {\n    const m = (0, utils_ts_1.ensureBytes)(\"message\", message);\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n    const a = (0, utils_ts_1.ensureBytes)(\"auxRand\", auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = numTo32b(d ^ num(taggedHash(\"BIP0340/aux\", a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash(\"BIP0340/nonce\", t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    const k_ = modN(num(rand)); // Let k' = int(rand) mod n\n    if (k_ === _0n) throw new Error(\"sign failed: k is zero\"); // Fail if k' = 0.\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'‚ãÖG.\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(numTo32b(modN(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px)) throw new Error(\"sign: Invalid signature produced\");\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */ function schnorrVerify(signature, message, publicKey) {\n    const sig = (0, utils_ts_1.ensureBytes)(\"signature\", signature, 64);\n    const m = (0, utils_ts_1.ensureBytes)(\"message\", message);\n    const pub = (0, utils_ts_1.ensureBytes)(\"publicKey\", publicKey, 32);\n    try {\n        const P = lift_x(num(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = num(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r ‚â• p.\n        if (!(0, utils_ts_1.inRange)(r, _1n, secp256k1P)) return false;\n        const s = num(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s ‚â• n.\n        if (!(0, utils_ts_1.inRange)(s, _1n, secp256k1N)) return false;\n        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n        const R = GmulAdd(P, s, modN(-e)); // R = s‚ãÖG - e‚ãÖP\n        if (!R || !R.hasEvenY() || R.toAffine().x !== r) return false; // -eP == (n-e)P\n        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R) ‚â† r.\n    } catch (error) {\n        return false;\n    }\n}\n/**\n * Schnorr signatures over secp256k1.\n * https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n * @example\n * ```js\n * import { schnorr } from '@noble/curves/secp256k1';\n * const priv = schnorr.utils.randomPrivateKey();\n * const pub = schnorr.getPublicKey(priv);\n * const msg = new TextEncoder().encode('hello');\n * const sig = schnorr.sign(msg, priv);\n * const isValid = schnorr.verify(sig, msg, pub);\n * ```\n */ exports.schnorr = (()=>({\n        getPublicKey: schnorrGetPublicKey,\n        sign: schnorrSign,\n        verify: schnorrVerify,\n        utils: {\n            randomPrivateKey: exports.secp256k1.utils.randomPrivateKey,\n            lift_x,\n            pointToBytes,\n            numberToBytesBE: utils_ts_1.numberToBytesBE,\n            bytesToNumberBE: utils_ts_1.bytesToNumberBE,\n            taggedHash,\n            mod: modular_ts_1.mod\n        }\n    }))();\nconst isoMap = /* @__PURE__ */ (()=>(0, hash_to_curve_ts_1.isogenyMap)(Fpk1, [\n        // xNum\n        [\n            \"0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7\",\n            \"0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581\",\n            \"0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262\",\n            \"0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c\"\n        ],\n        // xDen\n        [\n            \"0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b\",\n            \"0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14\",\n            \"0x0000000000000000000000000000000000000000000000000000000000000001\"\n        ],\n        // yNum\n        [\n            \"0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c\",\n            \"0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3\",\n            \"0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931\",\n            \"0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84\"\n        ],\n        // yDen\n        [\n            \"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b\",\n            \"0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573\",\n            \"0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f\",\n            \"0x0000000000000000000000000000000000000000000000000000000000000001\"\n        ]\n    ].map((i)=>i.map((j)=>BigInt(j)))))();\nconst mapSWU = /* @__PURE__ */ (()=>(0, weierstrass_ts_1.mapToCurveSimpleSWU)(Fpk1, {\n        A: BigInt(\"0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533\"),\n        B: BigInt(\"1771\"),\n        Z: Fpk1.create(BigInt(\"-11\"))\n    }))();\n/** Hashing / encoding to secp256k1 points / field. RFC 9380 methods. */ exports.secp256k1_hasher = (()=>(0, hash_to_curve_ts_1.createHasher)(exports.secp256k1.ProjectivePoint, (scalars)=>{\n        const { x, y } = mapSWU(Fpk1.create(scalars[0]));\n        return isoMap(x, y);\n    }, {\n        DST: \"secp256k1_XMD:SHA-256_SSWU_RO_\",\n        encodeDST: \"secp256k1_XMD:SHA-256_SSWU_NU_\",\n        p: Fpk1.ORDER,\n        m: 1,\n        k: 128,\n        expand: \"xmd\",\n        hash: sha2_1.sha256\n    }))();\nexports.hashToCurve = (()=>exports.secp256k1_hasher.hashToCurve)();\nexports.encodeToCurve = (()=>exports.secp256k1_hasher.encodeToCurve)(); //# sourceMappingURL=secp256k1.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxxQkFBcUIsR0FBR0EsbUJBQW1CLEdBQUdBLHdCQUF3QixHQUFHQSxlQUFlLEdBQUdBLGlCQUFpQixHQUFHLEtBQUs7QUFDcEg7Ozs7Ozs7Ozs7O0NBV0MsR0FDRCxvRUFBb0UsR0FDcEUsTUFBTU8sU0FBU0MsbUJBQU9BLENBQUMsc0ZBQW9CO0FBQzNDLE1BQU1DLFVBQVVELG1CQUFPQSxDQUFDLHdGQUFxQjtBQUM3QyxNQUFNRSxxQkFBcUJGLG1CQUFPQSxDQUFDLCtGQUFvQjtBQUN2RCxNQUFNRyxxQkFBcUJILG1CQUFPQSxDQUFDLGlIQUE2QjtBQUNoRSxNQUFNSSxlQUFlSixtQkFBT0EsQ0FBQyxxR0FBdUI7QUFDcEQsTUFBTUssYUFBYUwsbUJBQU9BLENBQUMsaUdBQXFCO0FBQ2hELE1BQU1NLG1CQUFtQk4sbUJBQU9BLENBQUMsNkdBQTJCO0FBQzVELE1BQU1PLGFBQWFDLE9BQU87QUFDMUIsTUFBTUMsYUFBYUQsT0FBTztBQUMxQixNQUFNRSxNQUFNRixPQUFPO0FBQ25CLE1BQU1HLE1BQU1ILE9BQU87QUFDbkIsTUFBTUksTUFBTUosT0FBTztBQUNuQixNQUFNSyxhQUFhLENBQUNDLEdBQUdDLElBQU0sQ0FBQ0QsSUFBSUMsSUFBSUgsR0FBRSxJQUFLRztBQUM3Qzs7O0NBR0MsR0FDRCxTQUFTQyxRQUFRQyxDQUFDO0lBQ2QsTUFBTUMsSUFBSVg7SUFDVixrQkFBa0I7SUFDbEIsTUFBTVksTUFBTVgsT0FBTyxJQUFJWSxNQUFNWixPQUFPLElBQUlhLE9BQU9iLE9BQU8sS0FBS2MsT0FBT2QsT0FBTztJQUN6RSxrQkFBa0I7SUFDbEIsTUFBTWUsT0FBT2YsT0FBTyxLQUFLZ0IsT0FBT2hCLE9BQU8sS0FBS2lCLE9BQU9qQixP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QUFDLEVBQUUsR0FBR3VJLE9BQU8vRyxLQUFLb0gsTUFBTSxDQUFDRSxPQUFPLENBQUMsRUFBRTtRQUM5QyxPQUFPWixPQUFPMUQsR0FBR3hFO0lBQ3JCLEdBQUc7UUFDQytJLEtBQUs7UUFDTEMsV0FBVztRQUNYM0QsR0FBRzdELEtBQUt5SCxLQUFLO1FBQ2J6QyxHQUFHO1FBQ0gvRCxHQUFHO1FBQ0h5RyxRQUFRO1FBQ1JDLE1BQU1ySyxPQUFPdUUsTUFBTTtJQUN2QixFQUFDO0FBQ0Q5RSxtQkFBbUIsR0FBRyxDQUFDLElBQU1BLFFBQVFJLGdCQUFnQixDQUFDRCxXQUFXO0FBQ2pFSCxxQkFBcUIsR0FBRyxDQUFDLElBQU1BLFFBQVFJLGdCQUFnQixDQUFDRixhQUFhLEtBQ3JFLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsYXctd29ya3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxLmpzPzk1ZTUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmVuY29kZVRvQ3VydmUgPSBleHBvcnRzLmhhc2hUb0N1cnZlID0gZXhwb3J0cy5zZWNwMjU2azFfaGFzaGVyID0gZXhwb3J0cy5zY2hub3JyID0gZXhwb3J0cy5zZWNwMjU2azEgPSB2b2lkIDA7XG4vKipcbiAqIE5JU1Qgc2VjcDI1NmsxLiBTZWUgW3BkZl0oaHR0cHM6Ly93d3cuc2VjZy5vcmcvc2VjMi12Mi5wZGYpLlxuICpcbiAqIFNlZW1zIHRvIGJlIHJpZ2lkIChub3QgYmFja2Rvb3JlZClcbiAqIFthcyBwZXIgZGlzY3Vzc2lvbl0oaHR0cHM6Ly9iaXRjb2ludGFsay5vcmcvaW5kZXgucGhwP3RvcGljPTI4OTc5NS5tc2czMTgzOTc1I21zZzMxODM5NzUpLlxuICpcbiAqIHNlY3AyNTZrMSBiZWxvbmdzIHRvIEtvYmxpdHogY3VydmVzOiBpdCBoYXMgZWZmaWNpZW50bHkgY29tcHV0YWJsZSBlbmRvbW9ycGhpc20uXG4gKiBFbmRvbW9ycGhpc20gdXNlcyAyeCBsZXNzIFJBTSwgc3BlZWRzIHVwIHByZWNvbXB1dGF0aW9uIGJ5IDJ4IGFuZCBFQ0RIIC8ga2V5IHJlY292ZXJ5IGJ5IDIwJS5cbiAqIEZvciBwcmVjb21wdXRlZCB3TkFGIGl0IHRyYWRlcyBvZmYgMS8yIGluaXQgdGltZSAmIDEvMyByYW0gZm9yIDIwJSBwZXJmIGhpdC5cbiAqIFtTZWUgZXhwbGFuYXRpb25dKGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3BhdWxtaWxsci9lYjY3MDgwNjc5M2U4NGRmNjI4YTdjNDM0YTg3MzA2NikuXG4gKiBAbW9kdWxlXG4gKi9cbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmNvbnN0IHNoYTJfMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL3NoYTJcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvdXRpbHNcIik7XG5jb25zdCBfc2hvcnR3X3V0aWxzX3RzXzEgPSByZXF1aXJlKFwiLi9fc2hvcnR3X3V0aWxzLmpzXCIpO1xuY29uc3QgaGFzaF90b19jdXJ2ZV90c18xID0gcmVxdWlyZShcIi4vYWJzdHJhY3QvaGFzaC10by1jdXJ2ZS5qc1wiKTtcbmNvbnN0IG1vZHVsYXJfdHNfMSA9IHJlcXVpcmUoXCIuL2Fic3RyYWN0L21vZHVsYXIuanNcIik7XG5jb25zdCB1dGlsc190c18xID0gcmVxdWlyZShcIi4vYWJzdHJhY3QvdXRpbHMuanNcIik7XG5jb25zdCB3ZWllcnN0cmFzc190c18xID0gcmVxdWlyZShcIi4vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanNcIik7XG5jb25zdCBzZWNwMjU2azFQID0gQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZmZmZmZjMmYnKTtcbmNvbnN0IHNlY3AyNTZrMU4gPSBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmViYWFlZGNlNmFmNDhhMDNiYmZkMjVlOGNkMDM2NDE0MScpO1xuY29uc3QgXzBuID0gQmlnSW50KDApO1xuY29uc3QgXzFuID0gQmlnSW50KDEpO1xuY29uc3QgXzJuID0gQmlnSW50KDIpO1xuY29uc3QgZGl2TmVhcmVzdCA9IChhLCBiKSA9PiAoYSArIGIgLyBfMm4pIC8gYjtcbi8qKlxuICog4oiabiA9IG5eKChwKzEpLzQpIGZvciBmaWVsZHMgcCA9IDMgbW9kIDQuIFdlIHVud3JhcCB0aGUgbG9vcCBhbmQgbXVsdGlwbHkgYml0LWJ5LWJpdC5cbiAqIChQKzFuLzRuKS50b1N0cmluZygyKSB3b3VsZCBwcm9kdWNlIGJpdHMgWzIyM3ggMSwgMCwgMjJ4IDEsIDR4IDAsIDExLCAwMF1cbiAqL1xuZnVuY3Rpb24gc3FydE1vZCh5KSB7XG4gICAgY29uc3QgUCA9IHNlY3AyNTZrMVA7XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgY29uc3QgXzNuID0gQmlnSW50KDMpLCBfNm4gPSBCaWdJbnQoNiksIF8xMW4gPSBCaWdJbnQoMTEpLCBfMjJuID0gQmlnSW50KDIyKTtcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBjb25zdCBfMjNuID0gQmlnSW50KDIzKSwgXzQ0biA9IEJpZ0ludCg0NCksIF84OG4gPSBCaWdJbnQoODgpO1xuICAgIGNvbnN0IGIyID0gKHkgKiB5ICogeSkgJSBQOyAvLyB4XjMsIDExXG4gICAgY29uc3QgYjMgPSAoYjIgKiBiMiAqIHkpICUgUDsgLy8geF43XG4gICAgY29uc3QgYjYgPSAoKDAsIG1vZHVsYXJfdHNfMS5wb3cyKShiMywgXzNuLCBQKSAqIGIzKSAlIFA7XG4gICAgY29uc3QgYjkgPSAoKDAsIG1vZHVsYXJfdHNfMS5wb3cyKShiNiwgXzNuLCBQKSAqIGIzKSAlIFA7XG4gICAgY29uc3QgYjExID0gKCgwLCBtb2R1bGFyX3RzXzEucG93MikoYjksIF8ybiwgUCkgKiBiMikgJSBQO1xuICAgIGNvbnN0IGIyMiA9ICgoMCwgbW9kdWxhcl90c18xLnBvdzIpKGIxMSwgXzExbiwgUCkgKiBiMTEpICUgUDtcbiAgICBjb25zdCBiNDQgPSAoKDAsIG1vZHVsYXJfdHNfMS5wb3cyKShiMjIsIF8yMm4sIFApICogYjIyKSAlIFA7XG4gICAgY29uc3QgYjg4ID0gKCgwLCBtb2R1bGFyX3RzXzEucG93MikoYjQ0LCBfNDRuLCBQKSAqIGI0NCkgJSBQO1xuICAgIGNvbnN0IGIxNzYgPSAoKDAsIG1vZHVsYXJfdHNfMS5wb3cyKShiODgsIF84OG4sIFApICogYjg4KSAlIFA7XG4gICAgY29uc3QgYjIyMCA9ICgoMCwgbW9kdWxhcl90c18xLnBvdzIpKGIxNzYsIF80NG4sIFApICogYjQ0KSAlIFA7XG4gICAgY29uc3QgYjIyMyA9ICgoMCwgbW9kdWxhcl90c18xLnBvdzIpKGIyMjAsIF8zbiwgUCkgKiBiMykgJSBQO1xuICAgIGNvbnN0IHQxID0gKCgwLCBtb2R1bGFyX3RzXzEucG93MikoYjIyMywgXzIzbiwgUCkgKiBiMjIpICUgUDtcbiAgICBjb25zdCB0MiA9ICgoMCwgbW9kdWxhcl90c18xLnBvdzIpKHQxLCBfNm4sIFApICogYjIpICUgUDtcbiAgICBjb25zdCByb290ID0gKDAsIG1vZHVsYXJfdHNfMS5wb3cyKSh0MiwgXzJuLCBQKTtcbiAgICBpZiAoIUZwazEuZXFsKEZwazEuc3FyKHJvb3QpLCB5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgIHJldHVybiByb290O1xufVxuY29uc3QgRnBrMSA9ICgwLCBtb2R1bGFyX3RzXzEuRmllbGQpKHNlY3AyNTZrMVAsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB7IHNxcnQ6IHNxcnRNb2QgfSk7XG4vKipcbiAqIHNlY3AyNTZrMSBjdXJ2ZSwgRUNEU0EgYW5kIEVDREggbWV0aG9kcy5cbiAqXG4gKiBGaWVsZDogYDJuKioyNTZuIC0gMm4qKjMybiAtIDJuKio5biAtIDJuKio4biAtIDJuKio3biAtIDJuKio2biAtIDJuKio0biAtIDFuYFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogaW1wb3J0IHsgc2VjcDI1NmsxIH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9zZWNwMjU2azEnO1xuICogY29uc3QgcHJpdiA9IHNlY3AyNTZrMS51dGlscy5yYW5kb21Qcml2YXRlS2V5KCk7XG4gKiBjb25zdCBwdWIgPSBzZWNwMjU2azEuZ2V0UHVibGljS2V5KHByaXYpO1xuICogY29uc3QgbXNnID0gbmV3IFVpbnQ4QXJyYXkoMzIpLmZpbGwoMSk7IC8vIG1lc3NhZ2UgaGFzaCAobm90IG1lc3NhZ2UpIGluIGVjZHNhXG4gKiBjb25zdCBzaWcgPSBzZWNwMjU2azEuc2lnbihtc2csIHByaXYpOyAvLyBge3ByZWhhc2g6IHRydWV9YCBvcHRpb24gaXMgYXZhaWxhYmxlXG4gKiBjb25zdCBpc1ZhbGlkID0gc2VjcDI1NmsxLnZlcmlmeShzaWcsIG1zZywgcHViKSA9PT0gdHJ1ZTtcbiAqIGBgYFxuICovXG5leHBvcnRzLnNlY3AyNTZrMSA9ICgwLCBfc2hvcnR3X3V0aWxzX3RzXzEuY3JlYXRlQ3VydmUpKHtcbiAgICBhOiBfMG4sXG4gICAgYjogQmlnSW50KDcpLFxuICAgIEZwOiBGcGsxLFxuICAgIG46IHNlY3AyNTZrMU4sXG4gICAgR3g6IEJpZ0ludCgnNTUwNjYyNjMwMjIyNzczNDM2Njk1Nzg3MTg4OTUxNjg1MzQzMjYyNTA2MDM0NTM3Nzc1OTQxNzU1MDAxODczNjAzODkxMTY3MjkyNDAnKSxcbiAgICBHeTogQmlnSW50KCczMjY3MDUxMDAyMDc1ODgxNjk3ODA4MzA4NTEzMDUwNzA0MzE4NDQ3MTI3MzM4MDY1OTI0MzI3NTkzODkwNDMzNTc1NzMzNzQ4MjQyNCcpLFxuICAgIGg6IEJpZ0ludCgxKSxcbiAgICBsb3dTOiB0cnVlLCAvLyBBbGxvdyBvbmx5IGxvdy1TIHNpZ25hdHVyZXMgYnkgZGVmYXVsdCBpbiBzaWduKCkgYW5kIHZlcmlmeSgpXG4gICAgZW5kbzoge1xuICAgICAgICAvLyBFbmRvbW9ycGhpc20sIHNlZSBhYm92ZVxuICAgICAgICBiZXRhOiBCaWdJbnQoJzB4N2FlOTZhMmI2NTdjMDcxMDZlNjQ0NzllYWMzNDM0ZTk5Y2YwNDk3NTEyZjU4OTk1YzEzOTZjMjg3MTk1MDFlZScpLFxuICAgICAgICBzcGxpdFNjYWxhcjogKGspID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBzZWNwMjU2azFOO1xuICAgICAgICAgICAgY29uc3QgYTEgPSBCaWdJbnQoJzB4MzA4NmQyMjFhN2Q0NmJjZGU4NmM5MGU0OTI4NGViMTUnKTtcbiAgICAgICAgICAgIGNvbnN0IGIxID0gLV8xbiAqIEJpZ0ludCgnMHhlNDQzN2VkNjAxMGU4ODI4NmY1NDdmYTkwYWJmZTRjMycpO1xuICAgICAgICAgICAgY29uc3QgYTIgPSBCaWdJbnQoJzB4MTE0Y2E1MGY3YThlMmYzZjY1N2MxMTA4ZDlkNDRjZmQ4Jyk7XG4gICAgICAgICAgICBjb25zdCBiMiA9IGExO1xuICAgICAgICAgICAgY29uc3QgUE9XXzJfMTI4ID0gQmlnSW50KCcweDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcpOyAvLyAoMm4qKjEyOG4pLnRvU3RyaW5nKDE2KVxuICAgICAgICAgICAgY29uc3QgYzEgPSBkaXZOZWFyZXN0KGIyICogaywgbik7XG4gICAgICAgICAgICBjb25zdCBjMiA9IGRpdk5lYXJlc3QoLWIxICogaywgbik7XG4gICAgICAgICAgICBsZXQgazEgPSAoMCwgbW9kdWxhcl90c18xLm1vZCkoayAtIGMxICogYTEgLSBjMiAqIGEyLCBuKTtcbiAgICAgICAgICAgIGxldCBrMiA9ICgwLCBtb2R1bGFyX3RzXzEubW9kKSgtYzEgKiBiMSAtIGMyICogYjIsIG4pO1xuICAgICAgICAgICAgY29uc3QgazFuZWcgPSBrMSA+IFBPV18yXzEyODtcbiAgICAgICAgICAgIGNvbnN0IGsybmVnID0gazIgPiBQT1dfMl8xMjg7XG4gICAgICAgICAgICBpZiAoazFuZWcpXG4gICAgICAgICAgICAgICAgazEgPSBuIC0gazE7XG4gICAgICAgICAgICBpZiAoazJuZWcpXG4gICAgICAgICAgICAgICAgazIgPSBuIC0gazI7XG4gICAgICAgICAgICBpZiAoazEgPiBQT1dfMl8xMjggfHwgazIgPiBQT1dfMl8xMjgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NwbGl0U2NhbGFyOiBFbmRvbW9ycGhpc20gZmFpbGVkLCBrPScgKyBrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGsxbmVnLCBrMSwgazJuZWcsIGsyIH07XG4gICAgICAgIH0sXG4gICAgfSxcbn0sIHNoYTJfMS5zaGEyNTYpO1xuLy8gU2Nobm9yciBzaWduYXR1cmVzIGFyZSBzdXBlcmlvciB0byBFQ0RTQSBmcm9tIGFib3ZlLiBCZWxvdyBpcyBTY2hub3JyLXNwZWNpZmljIEJJUDAzNDAgY29kZS5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpcHMvYmxvYi9tYXN0ZXIvYmlwLTAzNDAubWVkaWF3aWtpXG4vKiogQW4gb2JqZWN0IG1hcHBpbmcgdGFncyB0byB0aGVpciB0YWdnZWQgaGFzaCBwcmVmaXggb2YgW1NIQTI1Nih0YWcpIHwgU0hBMjU2KHRhZyldICovXG5jb25zdCBUQUdHRURfSEFTSF9QUkVGSVhFUyA9IHt9O1xuZnVuY3Rpb24gdGFnZ2VkSGFzaCh0YWcsIC4uLm1lc3NhZ2VzKSB7XG4gICAgbGV0IHRhZ1AgPSBUQUdHRURfSEFTSF9QUkVGSVhFU1t0YWddO1xuICAgIGlmICh0YWdQID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgdGFnSCA9ICgwLCBzaGEyXzEuc2hhMjU2KShVaW50OEFycmF5LmZyb20odGFnLCAoYykgPT4gYy5jaGFyQ29kZUF0KDApKSk7XG4gICAgICAgIHRhZ1AgPSAoMCwgdXRpbHNfdHNfMS5jb25jYXRCeXRlcykodGFnSCwgdGFnSCk7XG4gICAgICAgIFRBR0dFRF9IQVNIX1BSRUZJWEVTW3RhZ10gPSB0YWdQO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIHNoYTJfMS5zaGEyNTYpKCgwLCB1dGlsc190c18xLmNvbmNhdEJ5dGVzKSh0YWdQLCAuLi5tZXNzYWdlcykpO1xufVxuLy8gRUNEU0EgY29tcGFjdCBwb2ludHMgYXJlIDMzLWJ5dGUuIFNjaG5vcnIgaXMgMzI6IHdlIHN0cmlwIGZpcnN0IGJ5dGUgMHgwMiBvciAweDAzXG5jb25zdCBwb2ludFRvQnl0ZXMgPSAocG9pbnQpID0+IHBvaW50LnRvUmF3Qnl0ZXModHJ1ZSkuc2xpY2UoMSk7XG5jb25zdCBudW1UbzMyYiA9IChuKSA9PiAoMCwgdXRpbHNfdHNfMS5udW1iZXJUb0J5dGVzQkUpKG4sIDMyKTtcbmNvbnN0IG1vZFAgPSAoeCkgPT4gKDAsIG1vZHVsYXJfdHNfMS5tb2QpKHgsIHNlY3AyNTZrMVApO1xuY29uc3QgbW9kTiA9ICh4KSA9PiAoMCwgbW9kdWxhcl90c18xLm1vZCkoeCwgc2VjcDI1NmsxTik7XG5jb25zdCBQb2ludCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gZXhwb3J0cy5zZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50KSgpO1xuY29uc3QgR211bEFkZCA9IChRLCBhLCBiKSA9PiBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFEsIGEsIGIpO1xuLy8gQ2FsY3VsYXRlIHBvaW50LCBzY2FsYXIgYW5kIGJ5dGVzXG5mdW5jdGlvbiBzY2hub3JyR2V0RXh0UHViS2V5KHByaXYpIHtcbiAgICBsZXQgZF8gPSBleHBvcnRzLnNlY3AyNTZrMS51dGlscy5ub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXYpOyAvLyBzYW1lIG1ldGhvZCBleGVjdXRlZCBpbiBmcm9tUHJpdmF0ZUtleVxuICAgIGxldCBwID0gUG9pbnQuZnJvbVByaXZhdGVLZXkoZF8pOyAvLyBQID0gZCfii4VHOyAwIDwgZCcgPCBuIGNoZWNrIGlzIGRvbmUgaW5zaWRlXG4gICAgY29uc3Qgc2NhbGFyID0gcC5oYXNFdmVuWSgpID8gZF8gOiBtb2ROKC1kXyk7XG4gICAgcmV0dXJuIHsgc2NhbGFyOiBzY2FsYXIsIGJ5dGVzOiBwb2ludFRvQnl0ZXMocCkgfTtcbn1cbi8qKlxuICogbGlmdF94IGZyb20gQklQMzQwLiBDb252ZXJ0IDMyLWJ5dGUgeCBjb29yZGluYXRlIHRvIGVsbGlwdGljIGN1cnZlIHBvaW50LlxuICogQHJldHVybnMgdmFsaWQgcG9pbnQgY2hlY2tlZCBmb3IgYmVpbmcgb24tY3VydmVcbiAqL1xuZnVuY3Rpb24gbGlmdF94KHgpIHtcbiAgICAoMCwgdXRpbHNfdHNfMS5hSW5SYW5nZSkoJ3gnLCB4LCBfMW4sIHNlY3AyNTZrMVApOyAvLyBGYWlsIGlmIHgg4omlIHAuXG4gICAgY29uc3QgeHggPSBtb2RQKHggKiB4KTtcbiAgICBjb25zdCBjID0gbW9kUCh4eCAqIHggKyBCaWdJbnQoNykpOyAvLyBMZXQgYyA9IHjCsyArIDcgbW9kIHAuXG4gICAgbGV0IHkgPSBzcXJ0TW9kKGMpOyAvLyBMZXQgeSA9IGNeKHArMSkvNCBtb2QgcC5cbiAgICBpZiAoeSAlIF8ybiAhPT0gXzBuKVxuICAgICAgICB5ID0gbW9kUCgteSk7IC8vIFJldHVybiB0aGUgdW5pcXVlIHBvaW50IFAgc3VjaCB0aGF0IHgoUCkgPSB4IGFuZFxuICAgIGNvbnN0IHAgPSBuZXcgUG9pbnQoeCwgeSwgXzFuKTsgLy8geShQKSA9IHkgaWYgeSBtb2QgMiA9IDAgb3IgeShQKSA9IHAteSBvdGhlcndpc2UuXG4gICAgcC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgIHJldHVybiBwO1xufVxuY29uc3QgbnVtID0gdXRpbHNfdHNfMS5ieXRlc1RvTnVtYmVyQkU7XG4vKipcbiAqIENyZWF0ZSB0YWdnZWQgaGFzaCwgY29udmVydCBpdCB0byBiaWdpbnQsIHJlZHVjZSBtb2R1bG8tbi5cbiAqL1xuZnVuY3Rpb24gY2hhbGxlbmdlKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gbW9kTihudW0odGFnZ2VkSGFzaCgnQklQMDM0MC9jaGFsbGVuZ2UnLCAuLi5hcmdzKSkpO1xufVxuLyoqXG4gKiBTY2hub3JyIHB1YmxpYyBrZXkgaXMganVzdCBgeGAgY29vcmRpbmF0ZSBvZiBQb2ludCBhcyBwZXIgQklQMzQwLlxuICovXG5mdW5jdGlvbiBzY2hub3JyR2V0UHVibGljS2V5KHByaXZhdGVLZXkpIHtcbiAgICByZXR1cm4gc2Nobm9yckdldEV4dFB1YktleShwcml2YXRlS2V5KS5ieXRlczsgLy8gZCc9aW50KHNrKS4gRmFpbCBpZiBkJz0wIG9yIGQn4omlbi4gUmV0IGJ5dGVzKGQn4ouFRylcbn1cbi8qKlxuICogQ3JlYXRlcyBTY2hub3JyIHNpZ25hdHVyZSBhcyBwZXIgQklQMzQwLiBWZXJpZmllcyBpdHNlbGYgYmVmb3JlIHJldHVybmluZyBhbnl0aGluZy5cbiAqIGF1eFJhbmQgaXMgb3B0aW9uYWwgYW5kIGlzIG5vdCB0aGUgc29sZSBzb3VyY2Ugb2YgayBnZW5lcmF0aW9uOiBiYWQgQ1NQUk5HIHdvbid0IGJlIGRhbmdlcm91cy5cbiAqL1xuZnVuY3Rpb24gc2Nobm9yclNpZ24obWVzc2FnZSwgcHJpdmF0ZUtleSwgYXV4UmFuZCA9ICgwLCB1dGlsc18xLnJhbmRvbUJ5dGVzKSgzMikpIHtcbiAgICBjb25zdCBtID0gKDAsIHV0aWxzX3RzXzEuZW5zdXJlQnl0ZXMpKCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgY29uc3QgeyBieXRlczogcHgsIHNjYWxhcjogZCB9ID0gc2Nobm9yckdldEV4dFB1YktleShwcml2YXRlS2V5KTsgLy8gY2hlY2tzIGZvciBpc1dpdGhpbkN1cnZlT3JkZXJcbiAgICBjb25zdCBhID0gKDAsIHV0aWxzX3RzXzEuZW5zdXJlQnl0ZXMpKCdhdXhSYW5kJywgYXV4UmFuZCwgMzIpOyAvLyBBdXhpbGlhcnkgcmFuZG9tIGRhdGEgYTogYSAzMi1ieXRlIGFycmF5XG4gICAgY29uc3QgdCA9IG51bVRvMzJiKGQgXiBudW0odGFnZ2VkSGFzaCgnQklQMDM0MC9hdXgnLCBhKSkpOyAvLyBMZXQgdCBiZSB0aGUgYnl0ZS13aXNlIHhvciBvZiBieXRlcyhkKSBhbmQgaGFzaC9hdXgoYSlcbiAgICBjb25zdCByYW5kID0gdGFnZ2VkSGFzaCgnQklQMDM0MC9ub25jZScsIHQsIHB4LCBtKTsgLy8gTGV0IHJhbmQgPSBoYXNoL25vbmNlKHQgfHwgYnl0ZXMoUCkgfHwgbSlcbiAgICBjb25zdCBrXyA9IG1vZE4obnVtKHJhbmQpKTsgLy8gTGV0IGsnID0gaW50KHJhbmQpIG1vZCBuXG4gICAgaWYgKGtfID09PSBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbiBmYWlsZWQ6IGsgaXMgemVybycpOyAvLyBGYWlsIGlmIGsnID0gMC5cbiAgICBjb25zdCB7IGJ5dGVzOiByeCwgc2NhbGFyOiBrIH0gPSBzY2hub3JyR2V0RXh0UHViS2V5KGtfKTsgLy8gTGV0IFIgPSBrJ+KLhUcuXG4gICAgY29uc3QgZSA9IGNoYWxsZW5nZShyeCwgcHgsIG0pOyAvLyBMZXQgZSA9IGludChoYXNoL2NoYWxsZW5nZShieXRlcyhSKSB8fCBieXRlcyhQKSB8fCBtKSkgbW9kIG4uXG4gICAgY29uc3Qgc2lnID0gbmV3IFVpbnQ4QXJyYXkoNjQpOyAvLyBMZXQgc2lnID0gYnl0ZXMoUikgfHwgYnl0ZXMoKGsgKyBlZCkgbW9kIG4pLlxuICAgIHNpZy5zZXQocngsIDApO1xuICAgIHNpZy5zZXQobnVtVG8zMmIobW9kTihrICsgZSAqIGQpKSwgMzIpO1xuICAgIC8vIElmIFZlcmlmeShieXRlcyhQKSwgbSwgc2lnKSAoc2VlIGJlbG93KSByZXR1cm5zIGZhaWx1cmUsIGFib3J0XG4gICAgaWYgKCFzY2hub3JyVmVyaWZ5KHNpZywgbSwgcHgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ246IEludmFsaWQgc2lnbmF0dXJlIHByb2R1Y2VkJyk7XG4gICAgcmV0dXJuIHNpZztcbn1cbi8qKlxuICogVmVyaWZpZXMgU2Nobm9yciBzaWduYXR1cmUuXG4gKiBXaWxsIHN3YWxsb3cgZXJyb3JzICYgcmV0dXJuIGZhbHNlIGV4Y2VwdCBmb3IgaW5pdGlhbCB0eXBlIHZhbGlkYXRpb24gb2YgYXJndW1lbnRzLlxuICovXG5mdW5jdGlvbiBzY2hub3JyVmVyaWZ5KHNpZ25hdHVyZSwgbWVzc2FnZSwgcHVibGljS2V5KSB7XG4gICAgY29uc3Qgc2lnID0gKDAsIHV0aWxzX3RzXzEuZW5zdXJlQnl0ZXMpKCdzaWduYXR1cmUnLCBzaWduYXR1cmUsIDY0KTtcbiAgICBjb25zdCBtID0gKDAsIHV0aWxzX3RzXzEuZW5zdXJlQnl0ZXMpKCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgY29uc3QgcHViID0gKDAsIHV0aWxzX3RzXzEuZW5zdXJlQnl0ZXMpKCdwdWJsaWNLZXknLCBwdWJsaWNLZXksIDMyKTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBQID0gbGlmdF94KG51bShwdWIpKTsgLy8gUCA9IGxpZnRfeChpbnQocGspKTsgZmFpbCBpZiB0aGF0IGZhaWxzXG4gICAgICAgIGNvbnN0IHIgPSBudW0oc2lnLnN1YmFycmF5KDAsIDMyKSk7IC8vIExldCByID0gaW50KHNpZ1swOjMyXSk7IGZhaWwgaWYgciDiiaUgcC5cbiAgICAgICAgaWYgKCEoMCwgdXRpbHNfdHNfMS5pblJhbmdlKShyLCBfMW4sIHNlY3AyNTZrMVApKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBzID0gbnVtKHNpZy5zdWJhcnJheSgzMiwgNjQpKTsgLy8gTGV0IHMgPSBpbnQoc2lnWzMyOjY0XSk7IGZhaWwgaWYgcyDiiaUgbi5cbiAgICAgICAgaWYgKCEoMCwgdXRpbHNfdHNfMS5pblJhbmdlKShzLCBfMW4sIHNlY3AyNTZrMU4pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBlID0gY2hhbGxlbmdlKG51bVRvMzJiKHIpLCBwb2ludFRvQnl0ZXMoUCksIG0pOyAvLyBpbnQoY2hhbGxlbmdlKGJ5dGVzKHIpfHxieXRlcyhQKXx8bSkpJW5cbiAgICAgICAgY29uc3QgUiA9IEdtdWxBZGQoUCwgcywgbW9kTigtZSkpOyAvLyBSID0gc+KLhUcgLSBl4ouFUFxuICAgICAgICBpZiAoIVIgfHwgIVIuaGFzRXZlblkoKSB8fCBSLnRvQWZmaW5lKCkueCAhPT0gcilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gLWVQID09IChuLWUpUFxuICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gRmFpbCBpZiBpc19pbmZpbml0ZShSKSAvIG5vdCBoYXNfZXZlbl95KFIpIC8geChSKSDiiaAgci5cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vKipcbiAqIFNjaG5vcnIgc2lnbmF0dXJlcyBvdmVyIHNlY3AyNTZrMS5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpcHMvYmxvYi9tYXN0ZXIvYmlwLTAzNDAubWVkaWF3aWtpXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGltcG9ydCB7IHNjaG5vcnIgfSBmcm9tICdAbm9ibGUvY3VydmVzL3NlY3AyNTZrMSc7XG4gKiBjb25zdCBwcml2ID0gc2Nobm9yci51dGlscy5yYW5kb21Qcml2YXRlS2V5KCk7XG4gKiBjb25zdCBwdWIgPSBzY2hub3JyLmdldFB1YmxpY0tleShwcml2KTtcbiAqIGNvbnN0IG1zZyA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSgnaGVsbG8nKTtcbiAqIGNvbnN0IHNpZyA9IHNjaG5vcnIuc2lnbihtc2csIHByaXYpO1xuICogY29uc3QgaXNWYWxpZCA9IHNjaG5vcnIudmVyaWZ5KHNpZywgbXNnLCBwdWIpO1xuICogYGBgXG4gKi9cbmV4cG9ydHMuc2Nobm9yciA9ICgoKSA9PiAoe1xuICAgIGdldFB1YmxpY0tleTogc2Nobm9yckdldFB1YmxpY0tleSxcbiAgICBzaWduOiBzY2hub3JyU2lnbixcbiAgICB2ZXJpZnk6IHNjaG5vcnJWZXJpZnksXG4gICAgdXRpbHM6IHtcbiAgICAgICAgcmFuZG9tUHJpdmF0ZUtleTogZXhwb3J0cy5zZWNwMjU2azEudXRpbHMucmFuZG9tUHJpdmF0ZUtleSxcbiAgICAgICAgbGlmdF94LFxuICAgICAgICBwb2ludFRvQnl0ZXMsXG4gICAgICAgIG51bWJlclRvQnl0ZXNCRTogdXRpbHNfdHNfMS5udW1iZXJUb0J5dGVzQkUsXG4gICAgICAgIGJ5dGVzVG9OdW1iZXJCRTogdXRpbHNfdHNfMS5ieXRlc1RvTnVtYmVyQkUsXG4gICAgICAgIHRhZ2dlZEhhc2gsXG4gICAgICAgIG1vZDogbW9kdWxhcl90c18xLm1vZCxcbiAgICB9LFxufSkpKCk7XG5jb25zdCBpc29NYXAgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+ICgwLCBoYXNoX3RvX2N1cnZlX3RzXzEuaXNvZ2VueU1hcCkoRnBrMSwgW1xuICAgIC8vIHhOdW1cbiAgICBbXG4gICAgICAgICcweDhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhkYWFhYWE4YzcnLFxuICAgICAgICAnMHg3ZDNkNGM4MGJjMzIxZDViOWYzMTVjZWE3ZmQ0NGM1ZDU5NWQyZmMwYmY2M2I5MmRmZmYxMDQ0ZjE3YzY1ODEnLFxuICAgICAgICAnMHg1MzRjMzI4ZDIzZjIzNGU2ZTJhNDEzZGVjYTI1Y2FlY2U0NTA2MTQ0MDM3YzQwMzE0ZWNiZDBiNTNkOWRkMjYyJyxcbiAgICAgICAgJzB4OGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGRhYWFhYTg4YycsXG4gICAgXSxcbiAgICAvLyB4RGVuXG4gICAgW1xuICAgICAgICAnMHhkMzU3NzExOTNkOTQ5MThhOWNhMzRjY2JiN2I2NDBkZDg2Y2Q0MDk1NDJmODQ4N2Q5ZmU2Yjc0NTc4MWViNDliJyxcbiAgICAgICAgJzB4ZWRhZGM2ZjY0MzgzZGMxZGY3YzRiMmQ1MWI1NDIyNTQwNmQzNmI2NDFmNWU0MWJiYzUyYTU2NjEyYThjNmQxNCcsXG4gICAgICAgICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnLCAvLyBMQVNUIDFcbiAgICBdLFxuICAgIC8vIHlOdW1cbiAgICBbXG4gICAgICAgICcweDRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiOGUzOGUyM2MnLFxuICAgICAgICAnMHhjNzVlMGMzMmQ1Y2I3YzBmYTlkMGE1NGIxMmEwYTZkNTY0N2FiMDQ2ZDY4NmRhNmZkZmZjOTBmYzIwMWQ3MWEzJyxcbiAgICAgICAgJzB4MjlhNjE5NDY5MWY5MWE3MzcxNTIwOWVmNjUxMmU1NzY3MjI4MzBhMjAxYmUyMDE4YTc2NWU4NWE5ZWNlZTkzMScsXG4gICAgICAgICcweDJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmMzhlMzhkODQnLFxuICAgIF0sXG4gICAgLy8geURlblxuICAgIFtcbiAgICAgICAgJzB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmVmZmZmZjkzYicsXG4gICAgICAgICcweDdhMDY1MzRiYjhiZGI0OWZkNWU5ZTY2MzI3MjJjMjk4OTQ2N2MxYmZjOGU4ZDk3OGRmYjQyNWQyNjg1YzI1NzMnLFxuICAgICAgICAnMHg2NDg0YWE3MTY1NDVjYTJjZjNhNzBjM2ZhOGZlMzM3ZTBhM2QyMTE2MmYwZDYyOTlhN2JmODE5MmJmZDJhNzZmJyxcbiAgICAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsIC8vIExBU1QgMVxuICAgIF0sXG5dLm1hcCgoaSkgPT4gaS5tYXAoKGopID0+IEJpZ0ludChqKSkpKSkoKTtcbmNvbnN0IG1hcFNXVSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gKDAsIHdlaWVyc3RyYXNzX3RzXzEubWFwVG9DdXJ2ZVNpbXBsZVNXVSkoRnBrMSwge1xuICAgIEE6IEJpZ0ludCgnMHgzZjg3MzFhYmRkNjYxYWRjYTA4YTU1NThmMGY1ZDI3MmU5NTNkMzYzY2I2ZjBlNWQ0MDU0NDdjMDFhNDQ0NTMzJyksXG4gICAgQjogQmlnSW50KCcxNzcxJyksXG4gICAgWjogRnBrMS5jcmVhdGUoQmlnSW50KCctMTEnKSksXG59KSkoKTtcbi8qKiBIYXNoaW5nIC8gZW5jb2RpbmcgdG8gc2VjcDI1NmsxIHBvaW50cyAvIGZpZWxkLiBSRkMgOTM4MCBtZXRob2RzLiAqL1xuZXhwb3J0cy5zZWNwMjU2azFfaGFzaGVyID0gKCgpID0+ICgwLCBoYXNoX3RvX2N1cnZlX3RzXzEuY3JlYXRlSGFzaGVyKShleHBvcnRzLnNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQsIChzY2FsYXJzKSA9PiB7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBtYXBTV1UoRnBrMS5jcmVhdGUoc2NhbGFyc1swXSkpO1xuICAgIHJldHVybiBpc29NYXAoeCwgeSk7XG59LCB7XG4gICAgRFNUOiAnc2VjcDI1NmsxX1hNRDpTSEEtMjU2X1NTV1VfUk9fJyxcbiAgICBlbmNvZGVEU1Q6ICdzZWNwMjU2azFfWE1EOlNIQS0yNTZfU1NXVV9OVV8nLFxuICAgIHA6IEZwazEuT1JERVIsXG4gICAgbTogMSxcbiAgICBrOiAxMjgsXG4gICAgZXhwYW5kOiAneG1kJyxcbiAgICBoYXNoOiBzaGEyXzEuc2hhMjU2LFxufSkpKCk7XG5leHBvcnRzLmhhc2hUb0N1cnZlID0gKCgpID0+IGV4cG9ydHMuc2VjcDI1NmsxX2hhc2hlci5oYXNoVG9DdXJ2ZSkoKTtcbmV4cG9ydHMuZW5jb2RlVG9DdXJ2ZSA9ICgoKSA9PiBleHBvcnRzLnNlY3AyNTZrMV9oYXNoZXIuZW5jb2RlVG9DdXJ2ZSkoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlY3AyNTZrMS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbmNvZGVUb0N1cnZlIiwiaGFzaFRvQ3VydmUiLCJzZWNwMjU2azFfaGFzaGVyIiwic2Nobm9yciIsInNlY3AyNTZrMSIsInNoYTJfMSIsInJlcXVpcmUiLCJ1dGlsc18xIiwiX3Nob3J0d191dGlsc190c18xIiwiaGFzaF90b19jdXJ2ZV90c18xIiwibW9kdWxhcl90c18xIiwidXRpbHNfdHNfMSIsIndlaWVyc3RyYXNzX3RzXzEiLCJzZWNwMjU2azFQIiwiQmlnSW50Iiwic2VjcDI1NmsxTiIsIl8wbiIsIl8xbiIsIl8ybiIsImRpdk5lYXJlc3QiLCJhIiwiYiIsInNxcnRNb2QiLCJ5IiwiUCIsIl8zbiIsIl82biIsIl8xMW4iLCJfMjJuIiwiXzIzbiIsIl80NG4iLCJfODhuIiwiYjIiLCJiMyIsImI2IiwicG93MiIsImI5IiwiYjExIiwiYjIyIiwiYjQ0IiwiYjg4IiwiYjE3NiIsImIyMjAiLCJiMjIzIiwidDEiLCJ0MiIsInJvb3QiLCJGcGsxIiwiZXFsIiwic3FyIiwiRXJyb3IiLCJGaWVsZCIsInVuZGVmaW5lZCIsInNxcnQiLCJjcmVhdGVDdXJ2ZSIsIkZwIiwibiIsIkd4IiwiR3kiLCJoIiwibG93UyIsImVuZG8iLCJiZXRhIiwic3BsaXRTY2FsYXIiLCJrIiwiYTEiLCJiMSIsImEyIiwiUE9XXzJfMTI4IiwiYzEiLCJjMiIsImsxIiwibW9kIiwiazIiLCJrMW5lZyIsImsybmVnIiwic2hhMjU2IiwiVEFHR0VEX0hBU0hfUFJFRklYRVMiLCJ0YWdnZWRIYXNoIiwidGFnIiwibWVzc2FnZXMiLCJ0YWdQIiwidGFnSCIsIlVpbnQ4QXJyYXkiLCJmcm9tIiwiYyIsImNoYXJDb2RlQXQiLCJjb25jYXRCeXRlcyIsInBvaW50VG9CeXRlcyIsInBvaW50IiwidG9SYXdCeXRlcyIsInNsaWNlIiwibnVtVG8zMmIiLCJudW1iZXJUb0J5dGVzQkUiLCJtb2RQIiwieCIsIm1vZE4iLCJQb2ludCIsIlByb2plY3RpdmVQb2ludCIsIkdtdWxBZGQiLCJRIiwiQkFTRSIsIm11bHRpcGx5QW5kQWRkVW5zYWZlIiwic2Nobm9yckdldEV4dFB1YktleSIsInByaXYiLCJkXyIsInV0aWxzIiwibm9ybVByaXZhdGVLZXlUb1NjYWxhciIsInAiLCJmcm9tUHJpdmF0ZUtleSIsInNjYWxhciIsImhhc0V2ZW5ZIiwiYnl0ZXMiLCJsaWZ0X3giLCJhSW5SYW5nZSIsInh4IiwiYXNzZXJ0VmFsaWRpdHkiLCJudW0iLCJieXRlc1RvTnVtYmVyQkUiLCJjaGFsbGVuZ2UiLCJhcmdzIiwic2Nobm9yckdldFB1YmxpY0tleSIsInByaXZhdGVLZXkiLCJzY2hub3JyU2lnbiIsIm1lc3NhZ2UiLCJhdXhSYW5kIiwicmFuZG9tQnl0ZXMiLCJtIiwiZW5zdXJlQnl0ZXMiLCJweCIsImQiLCJ0IiwicmFuZCIsImtfIiwicngiLCJlIiwic2lnIiwic2V0Iiwic2Nobm9yclZlcmlmeSIsInNpZ25hdHVyZSIsInB1YmxpY0tleSIsInB1YiIsInIiLCJzdWJhcnJheSIsImluUmFuZ2UiLCJzIiwiUiIsInRvQWZmaW5lIiwiZXJyb3IiLCJnZXRQdWJsaWNLZXkiLCJzaWduIiwidmVyaWZ5IiwicmFuZG9tUHJpdmF0ZUtleSIsImlzb01hcCIsImlzb2dlbnlNYXAiLCJtYXAiLCJpIiwiaiIsIm1hcFNXVSIsIm1hcFRvQ3VydmVTaW1wbGVTV1UiLCJBIiwiQiIsIloiLCJjcmVhdGUiLCJjcmVhdGVIYXNoZXIiLCJzY2FsYXJzIiwiRFNUIiwiZW5jb2RlRFNUIiwiT1JERVIiLCJleHBhbmQiLCJoYXNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/@noble/curves/secp256k1.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/@noble/hashes/_md.js":
/*!***********************************************************!*\
  !*** ./node_modules/ox/node_modules/@noble/hashes/_md.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.SHA512_IV = exports.SHA384_IV = exports.SHA224_IV = exports.SHA256_IV = exports.HashMD = void 0;\nexports.setBigUint64 = setBigUint64;\nexports.Chi = Chi;\nexports.Maj = Maj;\n/**\n * Internal Merkle-Damgard hash utils.\n * @module\n */ const utils_ts_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/utils.js\");\n/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */ function setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === \"function\") return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number(value >> _32n & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n/** Choice: a ? b : c */ function Chi(a, b, c) {\n    return a & b ^ ~a & c;\n}\n/** Majority function, true if any two inputs is true. */ function Maj(a, b, c) {\n    return a & b ^ a & c ^ b & c;\n}\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */ class HashMD extends utils_ts_1.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE){\n        super();\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0, utils_ts_1.createView)(this.buffer);\n    }\n    update(data) {\n        (0, utils_ts_1.aexists)(this);\n        data = (0, utils_ts_1.toBytes)(data);\n        (0, utils_ts_1.abytes)(data);\n        const { view, buffer, blockLen } = this;\n        const len = data.length;\n        for(let pos = 0; pos < len;){\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0, utils_ts_1.createView)(data);\n                for(; blockLen <= len - pos; pos += blockLen)this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0, utils_ts_1.aexists)(this);\n        (0, utils_ts_1.aoutput)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 128;\n        (0, utils_ts_1.clean)(this.buffer.subarray(pos));\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for(let i = pos; i < blockLen; i++)buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0, utils_ts_1.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4) throw new Error(\"_sha2: outputLen should be aligned to 32bit\");\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length) throw new Error(\"_sha2: outputLen bigger than state\");\n        for(let i = 0; i < outLen; i++)oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.destroyed = destroyed;\n        to.finished = finished;\n        to.length = length;\n        to.pos = pos;\n        if (length % blockLen) to.buffer.set(buffer);\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n}\nexports.HashMD = HashMD;\n/**\n * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.\n * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.\n */ /** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */ exports.SHA256_IV = Uint32Array.from([\n    0x6a09e667,\n    0xbb67ae85,\n    0x3c6ef372,\n    0xa54ff53a,\n    0x510e527f,\n    0x9b05688c,\n    0x1f83d9ab,\n    0x5be0cd19\n]);\n/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */ exports.SHA224_IV = Uint32Array.from([\n    0xc1059ed8,\n    0x367cd507,\n    0x3070dd17,\n    0xf70e5939,\n    0xffc00b31,\n    0x68581511,\n    0x64f98fa7,\n    0xbefa4fa4\n]);\n/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */ exports.SHA384_IV = Uint32Array.from([\n    0xcbbb9d5d,\n    0xc1059ed8,\n    0x629a292a,\n    0x367cd507,\n    0x9159015a,\n    0x3070dd17,\n    0x152fecd8,\n    0xf70e5939,\n    0x67332667,\n    0xffc00b31,\n    0x8eb44a87,\n    0x68581511,\n    0xdb0c2e0d,\n    0x64f98fa7,\n    0x47b5481d,\n    0xbefa4fa4\n]);\n/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */ exports.SHA512_IV = Uint32Array.from([\n    0x6a09e667,\n    0xf3bcc908,\n    0xbb67ae85,\n    0x84caa73b,\n    0x3c6ef372,\n    0xfe94f82b,\n    0xa54ff53a,\n    0x5f1d36f1,\n    0x510e527f,\n    0xade682d1,\n    0x9b05688c,\n    0x2b3e6c1f,\n    0x1f83d9ab,\n    0xfb41bd6b,\n    0x5be0cd19,\n    0x137e2179\n]); //# sourceMappingURL=_md.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvX21kLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxpQkFBaUIsR0FBR0EsaUJBQWlCLEdBQUdBLGlCQUFpQixHQUFHQSxpQkFBaUIsR0FBR0EsY0FBYyxHQUFHLEtBQUs7QUFDdEdBLG9CQUFvQixHQUFHTztBQUN2QlAsV0FBVyxHQUFHUTtBQUNkUixXQUFXLEdBQUdTO0FBQ2Q7OztDQUdDLEdBQ0QsTUFBTUMsYUFBYUMsbUJBQU9BLENBQUMsK0VBQVk7QUFDdkMsOEZBQThGLEdBQzlGLFNBQVNKLGFBQWFLLElBQUksRUFBRUMsVUFBVSxFQUFFWixLQUFLLEVBQUVhLElBQUk7SUFDL0MsSUFBSSxPQUFPRixLQUFLTCxZQUFZLEtBQUssWUFDN0IsT0FBT0ssS0FBS0wsWUFBWSxDQUFDTSxZQUFZWixPQUFPYTtJQUNoRCxNQUFNQyxPQUFPQyxPQUFPO0lBQ3BCLE1BQU1DLFdBQVdELE9BQU87SUFDeEIsTUFBTUUsS0FBS0MsT0FBTyxTQUFVSixPQUFRRTtJQUNwQyxNQUFNRyxLQUFLRCxPQUFPbEIsUUFBUWdCO0lBQzFCLE1BQU1JLElBQUlQLE9BQU8sSUFBSTtJQUNyQixNQUFNUSxJQUFJUixPQUFPLElBQUk7SUFDckJGLEtBQUtXLFNBQVMsQ0FBQ1YsYUFBYVEsR0FBR0gsSUFBSUo7SUFDbkNGLEtBQUtXLFNBQVMsQ0FBQ1YsYUFBYVMsR0FBR0YsSUFBSU47QUFDdkM7QUFDQSxzQkFBc0IsR0FDdEIsU0FBU04sSUFBSWdCLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDO0lBQ2hCLE9BQU8sSUFBS0QsSUFBTSxDQUFDRCxJQUFJRTtBQUMzQjtBQUNBLHVEQUF1RCxHQUN2RCxTQUFTakIsSUFBSWUsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUM7SUFDaEIsT0FBTyxJQUFLRCxJQUFNRCxJQUFJRSxJ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RCxHQUFHLEVBQUUsR0FBRyxJQUFJO1FBQ25Fa0MsR0FBR2pDLFNBQVMsR0FBR0E7UUFDZmlDLEdBQUdwQyxRQUFRLEdBQUdBO1FBQ2RvQyxHQUFHbkMsTUFBTSxHQUFHQTtRQUNabUMsR0FBR2xDLEdBQUcsR0FBR0E7UUFDVCxJQUFJRCxTQUFTSixVQUNUdUMsR0FBR2hDLE1BQU0sQ0FBQ2MsR0FBRyxDQUFDZDtRQUNsQixPQUFPZ0M7SUFDWDtJQUNBQyxRQUFRO1FBQ0osT0FBTyxJQUFJLENBQUNGLFVBQVU7SUFDMUI7QUFDSjtBQUNBbkUsY0FBYyxHQUFHTTtBQUNqQjs7O0NBR0MsR0FDRCwwRUFBMEUsR0FDMUVOLGlCQUFpQixHQUFHc0UsWUFBWUMsSUFBSSxDQUFDO0lBQ2pDO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7Q0FDdkY7QUFDRCw0RUFBNEUsR0FDNUV2RSxpQkFBaUIsR0FBR3NFLFlBQVlDLElBQUksQ0FBQztJQUNqQztJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0NBQ3ZGO0FBQ0QsMkVBQTJFLEdBQzNFdkUsaUJBQWlCLEdBQUdzRSxZQUFZQyxJQUFJLENBQUM7SUFDakM7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUNwRjtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0NBQ3ZGO0FBQ0QsMEVBQTBFLEdBQzFFdkUsaUJBQWlCLEdBQUdzRSxZQUFZQyxJQUFJLENBQUM7SUFDakM7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUNwRjtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0NBQ3ZGLEdBQ0QsK0JBQStCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xhdy13b3Jrcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9fbWQuanM/NmQ3NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU0hBNTEyX0lWID0gZXhwb3J0cy5TSEEzODRfSVYgPSBleHBvcnRzLlNIQTIyNF9JViA9IGV4cG9ydHMuU0hBMjU2X0lWID0gZXhwb3J0cy5IYXNoTUQgPSB2b2lkIDA7XG5leHBvcnRzLnNldEJpZ1VpbnQ2NCA9IHNldEJpZ1VpbnQ2NDtcbmV4cG9ydHMuQ2hpID0gQ2hpO1xuZXhwb3J0cy5NYWogPSBNYWo7XG4vKipcbiAqIEludGVybmFsIE1lcmtsZS1EYW1nYXJkIGhhc2ggdXRpbHMuXG4gKiBAbW9kdWxlXG4gKi9cbmNvbnN0IHV0aWxzX3RzXzEgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbi8qKiBQb2x5ZmlsbCBmb3IgU2FmYXJpIDE0LiBodHRwczovL2Nhbml1c2UuY29tL21kbi1qYXZhc2NyaXB0X2J1aWx0aW5zX2RhdGF2aWV3X3NldGJpZ3VpbnQ2NCAqL1xuZnVuY3Rpb24gc2V0QmlnVWludDY0KHZpZXcsIGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKSB7XG4gICAgaWYgKHR5cGVvZiB2aWV3LnNldEJpZ1VpbnQ2NCA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuIHZpZXcuc2V0QmlnVWludDY0KGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKTtcbiAgICBjb25zdCBfMzJuID0gQmlnSW50KDMyKTtcbiAgICBjb25zdCBfdTMyX21heCA9IEJpZ0ludCgweGZmZmZmZmZmKTtcbiAgICBjb25zdCB3aCA9IE51bWJlcigodmFsdWUgPj4gXzMybikgJiBfdTMyX21heCk7XG4gICAgY29uc3Qgd2wgPSBOdW1iZXIodmFsdWUgJiBfdTMyX21heCk7XG4gICAgY29uc3QgaCA9IGlzTEUgPyA0IDogMDtcbiAgICBjb25zdCBsID0gaXNMRSA/IDAgOiA0O1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBoLCB3aCwgaXNMRSk7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGwsIHdsLCBpc0xFKTtcbn1cbi8qKiBDaG9pY2U6IGEgPyBiIDogYyAqL1xuZnVuY3Rpb24gQ2hpKGEsIGIsIGMpIHtcbiAgICByZXR1cm4gKGEgJiBiKSBeICh+YSAmIGMpO1xufVxuLyoqIE1ham9yaXR5IGZ1bmN0aW9uLCB0cnVlIGlmIGFueSB0d28gaW5wdXRzIGlzIHRydWUuICovXG5mdW5jdGlvbiBNYWooYSwgYiwgYykge1xuICAgIHJldHVybiAoYSAmIGIpIF4gKGEgJiBjKSBeIChiICYgYyk7XG59XG4vKipcbiAqIE1lcmtsZS1EYW1nYXJkIGhhc2ggY29uc3RydWN0aW9uIGJhc2UgY2xhc3MuXG4gKiBDb3VsZCBiZSB1c2VkIHRvIGNyZWF0ZSBNRDUsIFJJUEVNRCwgU0hBMSwgU0hBMi5cbiAqL1xuY2xhc3MgSGFzaE1EIGV4dGVuZHMgdXRpbHNfdHNfMS5IYXNoIHtcbiAgICBjb25zdHJ1Y3RvcihibG9ja0xlbiwgb3V0cHV0TGVuLCBwYWRPZmZzZXQsIGlzTEUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdGhpcy5wYWRPZmZzZXQgPSBwYWRPZmZzZXQ7XG4gICAgICAgIHRoaXMuaXNMRSA9IGlzTEU7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xuICAgICAgICB0aGlzLnZpZXcgPSAoMCwgdXRpbHNfdHNfMS5jcmVhdGVWaWV3KSh0aGlzLmJ1ZmZlcik7XG4gICAgfVxuICAgIHVwZGF0ZShkYXRhKSB7XG4gICAgICAgICgwLCB1dGlsc190c18xLmFleGlzdHMpKHRoaXMpO1xuICAgICAgICBkYXRhID0gKDAsIHV0aWxzX3RzXzEudG9CeXRlcykoZGF0YSk7XG4gICAgICAgICgwLCB1dGlsc190c18xLmFieXRlcykoZGF0YSk7XG4gICAgICAgIGNvbnN0IHsgdmlldywgYnVmZmVyLCBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IGxlbjspIHtcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zLCBsZW4gLSBwb3MpO1xuICAgICAgICAgICAgLy8gRmFzdCBwYXRoOiB3ZSBoYXZlIGF0IGxlYXN0IG9uZSBibG9jayBpbiBpbnB1dCwgY2FzdCBpdCB0byB2aWV3IGFuZCBwcm9jZXNzXG4gICAgICAgICAgICBpZiAodGFrZSA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhVmlldyA9ICgwLCB1dGlsc190c18xLmNyZWF0ZVZpZXcpKGRhdGEpO1xuICAgICAgICAgICAgICAgIGZvciAoOyBibG9ja0xlbiA8PSBsZW4gLSBwb3M7IHBvcyArPSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKGRhdGFWaWV3LCBwb3MpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyLnNldChkYXRhLnN1YmFycmF5KHBvcywgcG9zICsgdGFrZSksIHRoaXMucG9zKTtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IHRha2U7XG4gICAgICAgICAgICBwb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGVuZ3RoICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICB0aGlzLnJvdW5kQ2xlYW4oKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgICgwLCB1dGlsc190c18xLmFleGlzdHMpKHRoaXMpO1xuICAgICAgICAoMCwgdXRpbHNfdHNfMS5hb3V0cHV0KShvdXQsIHRoaXMpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gUGFkZGluZ1xuICAgICAgICAvLyBXZSBjYW4gYXZvaWQgYWxsb2NhdGlvbiBvZiBidWZmZXIgZm9yIHBhZGRpbmcgY29tcGxldGVseSBpZiBpdFxuICAgICAgICAvLyB3YXMgcHJldmlvdXNseSBub3QgYWxsb2NhdGVkIGhlcmUuIEJ1dCBpdCB3b24ndCBjaGFuZ2UgcGVyZm9ybWFuY2UuXG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCB2aWV3LCBibG9ja0xlbiwgaXNMRSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgcG9zIH0gPSB0aGlzO1xuICAgICAgICAvLyBhcHBlbmQgdGhlIGJpdCAnMScgdG8gdGhlIG1lc3NhZ2VcbiAgICAgICAgYnVmZmVyW3BvcysrXSA9IDBiMTAwMDAwMDA7XG4gICAgICAgICgwLCB1dGlsc190c18xLmNsZWFuKSh0aGlzLmJ1ZmZlci5zdWJhcnJheShwb3MpKTtcbiAgICAgICAgLy8gd2UgaGF2ZSBsZXNzIHRoYW4gcGFkT2Zmc2V0IGxlZnQgaW4gYnVmZmVyLCBzbyB3ZSBjYW5ub3QgcHV0IGxlbmd0aCBpblxuICAgICAgICAvLyBjdXJyZW50IGJsb2NrLCBuZWVkIHByb2Nlc3MgaXQgYW5kIHBhZCBhZ2FpblxuICAgICAgICBpZiAodGhpcy5wYWRPZmZzZXQgPiBibG9ja0xlbiAtIHBvcykge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgcG9zID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYWQgdW50aWwgZnVsbCBibG9jayBieXRlIHdpdGggemVyb3NcbiAgICAgICAgZm9yIChsZXQgaSA9IHBvczsgaSA8IGJsb2NrTGVuOyBpKyspXG4gICAgICAgICAgICBidWZmZXJbaV0gPSAwO1xuICAgICAgICAvLyBOb3RlOiBzaGE1MTIgcmVxdWlyZXMgbGVuZ3RoIHRvIGJlIDEyOGJpdCBpbnRlZ2VyLCBidXQgbGVuZ3RoIGluIEpTIHdpbGwgb3ZlcmZsb3cgYmVmb3JlIHRoYXRcbiAgICAgICAgLy8gWW91IG5lZWQgdG8gd3JpdGUgYXJvdW5kIDIgZXhhYnl0ZXMgKHU2NF9tYXggLyA4IC8gKDEwMjQqKjYpKSBmb3IgdGhpcyB0byBoYXBwZW4uXG4gICAgICAgIC8vIFNvIHdlIGp1c3Qgd3JpdGUgbG93ZXN0IDY0IGJpdHMgb2YgdGhhdCB2YWx1ZS5cbiAgICAgICAgc2V0QmlnVWludDY0KHZpZXcsIGJsb2NrTGVuIC0gOCwgQmlnSW50KHRoaXMubGVuZ3RoICogOCksIGlzTEUpO1xuICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgIGNvbnN0IG92aWV3ID0gKDAsIHV0aWxzX3RzXzEuY3JlYXRlVmlldykob3V0KTtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5vdXRwdXRMZW47XG4gICAgICAgIC8vIE5PVEU6IHdlIGRvIGRpdmlzaW9uIGJ5IDQgbGF0ZXIsIHdoaWNoIHNob3VsZCBiZSBmdXNlZCBpbiBzaW5nbGUgb3Agd2l0aCBtb2R1bG8gYnkgSklUXG4gICAgICAgIGlmIChsZW4gJSA0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIHNob3VsZCBiZSBhbGlnbmVkIHRvIDMyYml0Jyk7XG4gICAgICAgIGNvbnN0IG91dExlbiA9IGxlbiAvIDQ7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXQoKTtcbiAgICAgICAgaWYgKG91dExlbiA+IHN0YXRlLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBiaWdnZXIgdGhhbiBzdGF0ZScpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dExlbjsgaSsrKVxuICAgICAgICAgICAgb3ZpZXcuc2V0VWludDMyKDQgKiBpLCBzdGF0ZVtpXSwgaXNMRSk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3QgeyBidWZmZXIsIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKGJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IHJlcyA9IGJ1ZmZlci5zbGljZSgwLCBvdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICB0byB8fCAodG8gPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpKTtcbiAgICAgICAgdG8uc2V0KC4uLnRoaXMuZ2V0KCkpO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBidWZmZXIsIGxlbmd0aCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgcG9zIH0gPSB0aGlzO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSBkZXN0cm95ZWQ7XG4gICAgICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgICAgIHRvLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdG8ucG9zID0gcG9zO1xuICAgICAgICBpZiAobGVuZ3RoICUgYmxvY2tMZW4pXG4gICAgICAgICAgICB0by5idWZmZXIuc2V0KGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9uZUludG8oKTtcbiAgICB9XG59XG5leHBvcnRzLkhhc2hNRCA9IEhhc2hNRDtcbi8qKlxuICogSW5pdGlhbCBTSEEtMiBzdGF0ZTogZnJhY3Rpb25hbCBwYXJ0cyBvZiBzcXVhcmUgcm9vdHMgb2YgZmlyc3QgMTYgcHJpbWVzIDIuLjUzLlxuICogQ2hlY2sgb3V0IGB0ZXN0L21pc2Mvc2hhMi1nZW4taXYuanNgIGZvciByZWNvbXB1dGF0aW9uIGd1aWRlLlxuICovXG4vKiogSW5pdGlhbCBTSEEyNTYgc3RhdGUuIEJpdHMgMC4uMzIgb2YgZnJhYyBwYXJ0IG9mIHNxcnQgb2YgcHJpbWVzIDIuLjE5ICovXG5leHBvcnRzLlNIQTI1Nl9JViA9IFVpbnQzMkFycmF5LmZyb20oW1xuICAgIDB4NmEwOWU2NjcsIDB4YmI2N2FlODUsIDB4M2M2ZWYzNzIsIDB4YTU0ZmY1M2EsIDB4NTEwZTUyN2YsIDB4OWIwNTY4OGMsIDB4MWY4M2Q5YWIsIDB4NWJlMGNkMTksXG5dKTtcbi8qKiBJbml0aWFsIFNIQTIyNCBzdGF0ZS4gQml0cyAzMi4uNjQgb2YgZnJhYyBwYXJ0IG9mIHNxcnQgb2YgcHJpbWVzIDIzLi41MyAqL1xuZXhwb3J0cy5TSEEyMjRfSVYgPSBVaW50MzJBcnJheS5mcm9tKFtcbiAgICAweGMxMDU5ZWQ4LCAweDM2N2NkNTA3LCAweDMwNzBkZDE3LCAweGY3MGU1OTM5LCAweGZmYzAwYjMxLCAweDY4NTgxNTExLCAweDY0Zjk4ZmE3LCAweGJlZmE0ZmE0LFxuXSk7XG4vKiogSW5pdGlhbCBTSEEzODQgc3RhdGUuIEJpdHMgMC4uNjQgb2YgZnJhYyBwYXJ0IG9mIHNxcnQgb2YgcHJpbWVzIDIzLi41MyAqL1xuZXhwb3J0cy5TSEEzODRfSVYgPSBVaW50MzJBcnJheS5mcm9tKFtcbiAgICAweGNiYmI5ZDVkLCAweGMxMDU5ZWQ4LCAweDYyOWEyOTJhLCAweDM2N2NkNTA3LCAweDkxNTkwMTVhLCAweDMwNzBkZDE3LCAweDE1MmZlY2Q4LCAweGY3MGU1OTM5LFxuICAgIDB4NjczMzI2NjcsIDB4ZmZjMDBiMzEsIDB4OGViNDRhODcsIDB4Njg1ODE1MTEsIDB4ZGIwYzJlMGQsIDB4NjRmOThmYTcsIDB4NDdiNTQ4MWQsIDB4YmVmYTRmYTQsXG5dKTtcbi8qKiBJbml0aWFsIFNIQTUxMiBzdGF0ZS4gQml0cyAwLi42NCBvZiBmcmFjIHBhcnQgb2Ygc3FydCBvZiBwcmltZXMgMi4uMTkgKi9cbmV4cG9ydHMuU0hBNTEyX0lWID0gVWludDMyQXJyYXkuZnJvbShbXG4gICAgMHg2YTA5ZTY2NywgMHhmM2JjYzkwOCwgMHhiYjY3YWU4NSwgMHg4NGNhYTczYiwgMHgzYzZlZjM3MiwgMHhmZTk0ZjgyYiwgMHhhNTRmZjUzYSwgMHg1ZjFkMzZmMSxcbiAgICAweDUxMGU1MjdmLCAweGFkZTY4MmQxLCAweDliMDU2ODhjLCAweDJiM2U2YzFmLCAweDFmODNkOWFiLCAweGZiNDFiZDZiLCAweDViZTBjZDE5LCAweDEzN2UyMTc5LFxuXSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fbWQuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiU0hBNTEyX0lWIiwiU0hBMzg0X0lWIiwiU0hBMjI0X0lWIiwiU0hBMjU2X0lWIiwiSGFzaE1EIiwic2V0QmlnVWludDY0IiwiQ2hpIiwiTWFqIiwidXRpbHNfdHNfMSIsInJlcXVpcmUiLCJ2aWV3IiwiYnl0ZU9mZnNldCIsImlzTEUiLCJfMzJuIiwiQmlnSW50IiwiX3UzMl9tYXgiLCJ3aCIsIk51bWJlciIsIndsIiwiaCIsImwiLCJzZXRVaW50MzIiLCJhIiwiYiIsImMiLCJIYXNoIiwiY29uc3RydWN0b3IiLCJibG9ja0xlbiIsIm91dHB1dExlbiIsInBhZE9mZnNldCIsImZpbmlzaGVkIiwibGVuZ3RoIiwicG9zIiwiZGVzdHJveWVkIiwiYnVmZmVyIiwiVWludDhBcnJheSIsImNyZWF0ZVZpZXciLCJ1cGRhdGUiLCJkYXRhIiwiYWV4aXN0cyIsInRvQnl0ZXMiLCJhYnl0ZXMiLCJsZW4iLCJ0YWtlIiwiTWF0aCIsIm1pbiIsImRhdGFWaWV3IiwicHJvY2VzcyIsInNldCIsInN1YmFycmF5Iiwicm91bmRDbGVhbiIsImRpZ2VzdEludG8iLCJvdXQiLCJhb3V0cHV0IiwiY2xlYW4iLCJpIiwib3ZpZXciLCJFcnJvciIsIm91dExlbiIsInN0YXRlIiwiZ2V0IiwiZGlnZXN0IiwicmVzIiwic2xpY2UiLCJkZXN0cm95IiwiX2Nsb25lSW50byIsInRvIiwiY2xvbmUiLCJVaW50MzJBcnJheSIsImZyb20iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/@noble/hashes/_md.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/@noble/hashes/_u64.js":
/*!************************************************************!*\
  !*** ./node_modules/ox/node_modules/@noble/hashes/_u64.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.toBig = exports.shrSL = exports.shrSH = exports.rotrSL = exports.rotrSH = exports.rotrBL = exports.rotrBH = exports.rotr32L = exports.rotr32H = exports.rotlSL = exports.rotlSH = exports.rotlBL = exports.rotlBH = exports.add5L = exports.add5H = exports.add4L = exports.add4H = exports.add3L = exports.add3H = void 0;\nexports.add = add;\nexports.fromBig = fromBig;\nexports.split = split;\n/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */ const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\nfunction fromBig(n, le = false) {\n    if (le) return {\n        h: Number(n & U32_MASK64),\n        l: Number(n >> _32n & U32_MASK64)\n    };\n    return {\n        h: Number(n >> _32n & U32_MASK64) | 0,\n        l: Number(n & U32_MASK64) | 0\n    };\n}\nfunction split(lst, le = false) {\n    const len = lst.length;\n    let Ah = new Uint32Array(len);\n    let Al = new Uint32Array(len);\n    for(let i = 0; i < len; i++){\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [\n            h,\n            l\n        ];\n    }\n    return [\n        Ah,\n        Al\n    ];\n}\nconst toBig = (h, l)=>BigInt(h >>> 0) << _32n | BigInt(l >>> 0);\nexports.toBig = toBig;\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s)=>h >>> s;\nexports.shrSH = shrSH;\nconst shrSL = (h, l, s)=>h << 32 - s | l >>> s;\nexports.shrSL = shrSL;\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s)=>h >>> s | l << 32 - s;\nexports.rotrSH = rotrSH;\nconst rotrSL = (h, l, s)=>h << 32 - s | l >>> s;\nexports.rotrSL = rotrSL;\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s)=>h << 64 - s | l >>> s - 32;\nexports.rotrBH = rotrBH;\nconst rotrBL = (h, l, s)=>h >>> s - 32 | l << 64 - s;\nexports.rotrBL = rotrBL;\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l)=>l;\nexports.rotr32H = rotr32H;\nconst rotr32L = (h, _l)=>h;\nexports.rotr32L = rotr32L;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s)=>h << s | l >>> 32 - s;\nexports.rotlSH = rotlSH;\nconst rotlSL = (h, l, s)=>l << s | h >>> 32 - s;\nexports.rotlSL = rotlSL;\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s)=>l << s - 32 | h >>> 64 - s;\nexports.rotlBH = rotlBH;\nconst rotlBL = (h, l, s)=>h << s - 32 | l >>> 64 - s;\nexports.rotlBL = rotlBL;\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return {\n        h: Ah + Bh + (l / 2 ** 32 | 0) | 0,\n        l: l | 0\n    };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nexports.add3L = add3L;\nconst add3H = (low, Ah, Bh, Ch)=>Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;\nexports.add3H = add3H;\nconst add4L = (Al, Bl, Cl, Dl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nexports.add4L = add4L;\nconst add4H = (low, Ah, Bh, Ch, Dh)=>Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;\nexports.add4H = add4H;\nconst add5L = (Al, Bl, Cl, Dl, El)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nexports.add5L = add5L;\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh)=>Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;\nexports.add5H = add5H;\n// prettier-ignore\nconst u64 = {\n    fromBig,\n    split,\n    toBig,\n    shrSH,\n    shrSL,\n    rotrSH,\n    rotrSL,\n    rotrBH,\n    rotrBL,\n    rotr32H,\n    rotr32L,\n    rotlSH,\n    rotlSL,\n    rotlBH,\n    rotlBL,\n    add,\n    add3L,\n    add3H,\n    add4L,\n    add4H,\n    add5H,\n    add5L\n};\nexports[\"default\"] = u64; //# sourceMappingURL=_u64.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvX3U2NC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsYUFBYSxHQUFHQSxhQUFhLEdBQUdBLGFBQWEsR0FBR0EsY0FBYyxHQUFHQSxjQUFjLEdBQUdBLGNBQWMsR0FBR0EsY0FBYyxHQUFHQSxlQUFlLEdBQUdBLGVBQWUsR0FBR0EsY0FBYyxHQUFHQSxjQUFjLEdBQUdBLGNBQWMsR0FBR0EsY0FBYyxHQUFHQSxhQUFhLEdBQUdBLGFBQWEsR0FBR0EsYUFBYSxHQUFHQSxhQUFhLEdBQUdBLGFBQWEsR0FBR0EsYUFBYSxHQUFHLEtBQUs7QUFDalVBLFdBQVcsR0FBR3FCO0FBQ2RyQixlQUFlLEdBQUdzQjtBQUNsQnRCLGFBQWEsR0FBR3VCO0FBQ2hCOzs7O0NBSUMsR0FDRCxNQUFNQyxhQUFhLGFBQWEsR0FBR0MsT0FBTyxLQUFLLEtBQUs7QUFDcEQsTUFBTUMsT0FBTyxhQUFhLEdBQUdELE9BQU87QUFDcEMsU0FBU0gsUUFBUUssQ0FBQyxFQUFFQyxLQUFLLEtBQUs7SUFDMUIsSUFBSUEsSUFDQSxPQUFPO1FBQUVDLEdBQUdDLE9BQU9ILElBQUlIO1FBQWFPLEdBQUdELE9BQU8sS0FBTUosT0FBUUY7SUFBWTtJQUM1RSxPQUFPO1FBQUVLLEdBQUdDLE9BQU8sS0FBTUosT0FBUUYsY0FBYztRQUFHTyxHQUFHRCxPQUFPSCxJQUFJSCxjQUFjO0lBQUU7QUFDcEY7QUFDQSxTQUFTRCxNQUFNUyxHQUFHLEVBQUVKLEtBQUssS0FBSztJQUMxQixNQUFNSyxNQUFNRCxJQUFJRSxNQUFNO0lBQ3RCLElBQUlDLEtBQUssSUFBSUMsWUFBWUg7SUFDekIsSUFBSUksS0FBSyxJQUFJRCxZQUFZSDtJQUN6QixJQUFLLElBQUlLLElBQUksR0FBR0EsSUFBSUwsS0FBS0ssSUFBSztRQUMxQixNQUFNLEVBQUVULENBQUMs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TUcsQ0FBQUEsT0FBTztBQUNqRi9DLGFBQWEsR0FBR2lCO0FBQ2hCLE1BQU1DLFFBQVEsQ0FBQzJCLEtBQUtWLElBQUlPLElBQUlJLElBQUlFLEtBQU8sS0FBTU4sS0FBS0ksS0FBS0UsS0FBTSxPQUFPLEtBQUssS0FBTSxLQUFNO0FBQ3JGaEQsYUFBYSxHQUFHa0I7QUFDaEIsTUFBTUgsUUFBUSxDQUFDc0IsSUFBSU0sSUFBSUMsSUFBSUcsSUFBSUUsS0FBTyxDQUFDWixPQUFPLEtBQU1NLENBQUFBLE9BQU8sS0FBTUMsQ0FBQUEsT0FBTyxLQUFNRyxDQUFBQSxPQUFPLEtBQU1FLENBQUFBLE9BQU87QUFDbEdqRCxhQUFhLEdBQUdlO0FBQ2hCLE1BQU1DLFFBQVEsQ0FBQzZCLEtBQUtWLElBQUlPLElBQUlJLElBQUlFLElBQUlFLEtBQU8sS0FBTVIsS0FBS0ksS0FBS0UsS0FBS0UsS0FBTSxPQUFPLEtBQUssS0FBTSxLQUFNO0FBQzlGbEQsYUFBYSxHQUFHZ0I7QUFDaEIsa0JBQWtCO0FBQ2xCLE1BQU1tQyxNQUFNO0lBQ1I3QjtJQUFTQztJQUFPckI7SUFDaEJFO0lBQU9EO0lBQ1BHO0lBQVFEO0lBQVFHO0lBQVFEO0lBQ3hCRztJQUFTRDtJQUNURztJQUFRRDtJQUFRRztJQUFRRDtJQUN4QlE7SUFBS0Y7SUFBT0M7SUFBT0g7SUFBT0M7SUFBT0Y7SUFBT0Q7QUFDNUM7QUFDQWYsa0JBQWUsR0FBR21ELEtBQ2xCLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsYXctd29ya3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvX3U2NC5qcz82NGY5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy50b0JpZyA9IGV4cG9ydHMuc2hyU0wgPSBleHBvcnRzLnNoclNIID0gZXhwb3J0cy5yb3RyU0wgPSBleHBvcnRzLnJvdHJTSCA9IGV4cG9ydHMucm90ckJMID0gZXhwb3J0cy5yb3RyQkggPSBleHBvcnRzLnJvdHIzMkwgPSBleHBvcnRzLnJvdHIzMkggPSBleHBvcnRzLnJvdGxTTCA9IGV4cG9ydHMucm90bFNIID0gZXhwb3J0cy5yb3RsQkwgPSBleHBvcnRzLnJvdGxCSCA9IGV4cG9ydHMuYWRkNUwgPSBleHBvcnRzLmFkZDVIID0gZXhwb3J0cy5hZGQ0TCA9IGV4cG9ydHMuYWRkNEggPSBleHBvcnRzLmFkZDNMID0gZXhwb3J0cy5hZGQzSCA9IHZvaWQgMDtcbmV4cG9ydHMuYWRkID0gYWRkO1xuZXhwb3J0cy5mcm9tQmlnID0gZnJvbUJpZztcbmV4cG9ydHMuc3BsaXQgPSBzcGxpdDtcbi8qKlxuICogSW50ZXJuYWwgaGVscGVycyBmb3IgdTY0LiBCaWdVaW50NjRBcnJheSBpcyB0b28gc2xvdyBhcyBwZXIgMjAyNSwgc28gd2UgaW1wbGVtZW50IGl0IHVzaW5nIFVpbnQzMkFycmF5LlxuICogQHRvZG8gcmUtY2hlY2sgaHR0cHM6Ly9pc3N1ZXMuY2hyb21pdW0ub3JnL2lzc3Vlcy80MjIxMjU4OFxuICogQG1vZHVsZVxuICovXG5jb25zdCBVMzJfTUFTSzY0ID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgyICoqIDMyIC0gMSk7XG5jb25zdCBfMzJuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgzMik7XG5mdW5jdGlvbiBmcm9tQmlnKG4sIGxlID0gZmFsc2UpIHtcbiAgICBpZiAobGUpXG4gICAgICAgIHJldHVybiB7IGg6IE51bWJlcihuICYgVTMyX01BU0s2NCksIGw6IE51bWJlcigobiA+PiBfMzJuKSAmIFUzMl9NQVNLNjQpIH07XG4gICAgcmV0dXJuIHsgaDogTnVtYmVyKChuID4+IF8zMm4pICYgVTMyX01BU0s2NCkgfCAwLCBsOiBOdW1iZXIobiAmIFUzMl9NQVNLNjQpIHwgMCB9O1xufVxuZnVuY3Rpb24gc3BsaXQobHN0LCBsZSA9IGZhbHNlKSB7XG4gICAgY29uc3QgbGVuID0gbHN0Lmxlbmd0aDtcbiAgICBsZXQgQWggPSBuZXcgVWludDMyQXJyYXkobGVuKTtcbiAgICBsZXQgQWwgPSBuZXcgVWludDMyQXJyYXkobGVuKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHsgaCwgbCB9ID0gZnJvbUJpZyhsc3RbaV0sIGxlKTtcbiAgICAgICAgW0FoW2ldLCBBbFtpXV0gPSBbaCwgbF07XG4gICAgfVxuICAgIHJldHVybiBbQWgsIEFsXTtcbn1cbmNvbnN0IHRvQmlnID0gKGgsIGwpID0+IChCaWdJbnQoaCA+Pj4gMCkgPDwgXzMybikgfCBCaWdJbnQobCA+Pj4gMCk7XG5leHBvcnRzLnRvQmlnID0gdG9CaWc7XG4vLyBmb3IgU2hpZnQgaW4gWzAsIDMyKVxuY29uc3Qgc2hyU0ggPSAoaCwgX2wsIHMpID0+IGggPj4+IHM7XG5leHBvcnRzLnNoclNIID0gc2hyU0g7XG5jb25zdCBzaHJTTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoMzIgLSBzKSkgfCAobCA+Pj4gcyk7XG5leHBvcnRzLnNoclNMID0gc2hyU0w7XG4vLyBSaWdodCByb3RhdGUgZm9yIFNoaWZ0IGluIFsxLCAzMilcbmNvbnN0IHJvdHJTSCA9IChoLCBsLCBzKSA9PiAoaCA+Pj4gcykgfCAobCA8PCAoMzIgLSBzKSk7XG5leHBvcnRzLnJvdHJTSCA9IHJvdHJTSDtcbmNvbnN0IHJvdHJTTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoMzIgLSBzKSkgfCAobCA+Pj4gcyk7XG5leHBvcnRzLnJvdHJTTCA9IHJvdHJTTDtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gKDMyLCA2NCksIE5PVEU6IDMyIGlzIHNwZWNpYWwgY2FzZS5cbmNvbnN0IHJvdHJCSCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoNjQgLSBzKSkgfCAobCA+Pj4gKHMgLSAzMikpO1xuZXhwb3J0cy5yb3RyQkggPSByb3RyQkg7XG5jb25zdCByb3RyQkwgPSAoaCwgbCwgcykgPT4gKGggPj4+IChzIC0gMzIpKSB8IChsIDw8ICg2NCAtIHMpKTtcbmV4cG9ydHMucm90ckJMID0gcm90ckJMO1xuLy8gUmlnaHQgcm90YXRlIGZvciBzaGlmdD09PTMyIChqdXN0IHN3YXBzIGwmaClcbmNvbnN0IHJvdHIzMkggPSAoX2gsIGwpID0+IGw7XG5leHBvcnRzLnJvdHIzMkggPSByb3RyMzJIO1xuY29uc3Qgcm90cjMyTCA9IChoLCBfbCkgPT4gaDtcbmV4cG9ydHMucm90cjMyTCA9IHJvdHIzMkw7XG4vLyBMZWZ0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gWzEsIDMyKVxuY29uc3Qgcm90bFNIID0gKGgsIGwsIHMpID0+IChoIDw8IHMpIHwgKGwgPj4+ICgzMiAtIHMpKTtcbmV4cG9ydHMucm90bFNIID0gcm90bFNIO1xuY29uc3Qgcm90bFNMID0gKGgsIGwsIHMpID0+IChsIDw8IHMpIHwgKGggPj4+ICgzMiAtIHMpKTtcbmV4cG9ydHMucm90bFNMID0gcm90bFNMO1xuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluICgzMiwgNjQpLCBOT1RFOiAzMiBpcyBzcGVjaWFsIGNhc2UuXG5jb25zdCByb3RsQkggPSAoaCwgbCwgcykgPT4gKGwgPDwgKHMgLSAzMikpIHwgKGggPj4+ICg2NCAtIHMpKTtcbmV4cG9ydHMucm90bEJIID0gcm90bEJIO1xuY29uc3Qgcm90bEJMID0gKGgsIGwsIHMpID0+IChoIDw8IChzIC0gMzIpKSB8IChsID4+PiAoNjQgLSBzKSk7XG5leHBvcnRzLnJvdGxCTCA9IHJvdGxCTDtcbi8vIEpTIHVzZXMgMzItYml0IHNpZ25lZCBpbnRlZ2VycyBmb3IgYml0d2lzZSBvcGVyYXRpb25zIHdoaWNoIG1lYW5zIHdlIGNhbm5vdFxuLy8gc2ltcGxlIHRha2UgY2Fycnkgb3V0IG9mIGxvdyBiaXQgc3VtIGJ5IHNoaWZ0LCB3ZSBuZWVkIHRvIHVzZSBkaXZpc2lvbi5cbmZ1bmN0aW9uIGFkZChBaCwgQWwsIEJoLCBCbCkge1xuICAgIGNvbnN0IGwgPSAoQWwgPj4+IDApICsgKEJsID4+PiAwKTtcbiAgICByZXR1cm4geyBoOiAoQWggKyBCaCArICgobCAvIDIgKiogMzIpIHwgMCkpIHwgMCwgbDogbCB8IDAgfTtcbn1cbi8vIEFkZGl0aW9uIHdpdGggbW9yZSB0aGFuIDIgZWxlbWVudHNcbmNvbnN0IGFkZDNMID0gKEFsLCBCbCwgQ2wpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKTtcbmV4cG9ydHMuYWRkM0wgPSBhZGQzTDtcbmNvbnN0IGFkZDNIID0gKGxvdywgQWgsIEJoLCBDaCkgPT4gKEFoICsgQmggKyBDaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuZXhwb3J0cy5hZGQzSCA9IGFkZDNIO1xuY29uc3QgYWRkNEwgPSAoQWwsIEJsLCBDbCwgRGwpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKSArIChEbCA+Pj4gMCk7XG5leHBvcnRzLmFkZDRMID0gYWRkNEw7XG5jb25zdCBhZGQ0SCA9IChsb3csIEFoLCBCaCwgQ2gsIERoKSA9PiAoQWggKyBCaCArIENoICsgRGggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbmV4cG9ydHMuYWRkNEggPSBhZGQ0SDtcbmNvbnN0IGFkZDVMID0gKEFsLCBCbCwgQ2wsIERsLCBFbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApICsgKERsID4+PiAwKSArIChFbCA+Pj4gMCk7XG5leHBvcnRzLmFkZDVMID0gYWRkNUw7XG5jb25zdCBhZGQ1SCA9IChsb3csIEFoLCBCaCwgQ2gsIERoLCBFaCkgPT4gKEFoICsgQmggKyBDaCArIERoICsgRWggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbmV4cG9ydHMuYWRkNUggPSBhZGQ1SDtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgdTY0ID0ge1xuICAgIGZyb21CaWcsIHNwbGl0LCB0b0JpZyxcbiAgICBzaHJTSCwgc2hyU0wsXG4gICAgcm90clNILCByb3RyU0wsIHJvdHJCSCwgcm90ckJMLFxuICAgIHJvdHIzMkgsIHJvdHIzMkwsXG4gICAgcm90bFNILCByb3RsU0wsIHJvdGxCSCwgcm90bEJMLFxuICAgIGFkZCwgYWRkM0wsIGFkZDNILCBhZGQ0TCwgYWRkNEgsIGFkZDVILCBhZGQ1TCxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSB1NjQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdTY0LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInRvQmlnIiwic2hyU0wiLCJzaHJTSCIsInJvdHJTTCIsInJvdHJTSCIsInJvdHJCTCIsInJvdHJCSCIsInJvdHIzMkwiLCJyb3RyMzJIIiwicm90bFNMIiwicm90bFNIIiwicm90bEJMIiwicm90bEJIIiwiYWRkNUwiLCJhZGQ1SCIsImFkZDRMIiwiYWRkNEgiLCJhZGQzTCIsImFkZDNIIiwiYWRkIiwiZnJvbUJpZyIsInNwbGl0IiwiVTMyX01BU0s2NCIsIkJpZ0ludCIsIl8zMm4iLCJuIiwibGUiLCJoIiwiTnVtYmVyIiwibCIsImxzdCIsImxlbiIsImxlbmd0aCIsIkFoIiwiVWludDMyQXJyYXkiLCJBbCIsImkiLCJfbCIsInMiLCJfaCIsIkJoIiwiQmwiLCJDbCIsImxvdyIsIkNoIiwiRGwiLCJEaCIsIkVsIiwiRWgiLCJ1NjQiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/@noble/hashes/_u64.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/@noble/hashes/cryptoNode.js":
/*!******************************************************************!*\
  !*** ./node_modules/ox/node_modules/@noble/hashes/cryptoNode.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.crypto = void 0;\n/**\n * Internal webcrypto alias.\n * We prefer WebCrypto aka globalThis.crypto, which exists in node.js 16+.\n * Falls back to Node.js built-in crypto for Node.js <=v14.\n * See utils.ts for details.\n * @module\n */ // @ts-ignore\nconst nc = __webpack_require__(/*! node:crypto */ \"node:crypto\");\nexports.crypto = nc && typeof nc === \"object\" && \"webcrypto\" in nc ? nc.webcrypto : nc && typeof nc === \"object\" && \"randomBytes\" in nc ? nc : undefined; //# sourceMappingURL=cryptoNode.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvY3J5cHRvTm9kZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsY0FBYyxHQUFHLEtBQUs7QUFDdEI7Ozs7OztDQU1DLEdBQ0QsYUFBYTtBQUNiLE1BQU1HLEtBQUtDLG1CQUFPQSxDQUFDLGdDQUFhO0FBQ2hDSixjQUFjLEdBQUdHLE1BQU0sT0FBT0EsT0FBTyxZQUFZLGVBQWVBLEtBQzFEQSxHQUFHRSxTQUFTLEdBQ1pGLE1BQU0sT0FBT0EsT0FBTyxZQUFZLGlCQUFpQkEsS0FDN0NBLEtBQ0FHLFdBQ1Ysc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xhdy13b3Jrcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9jcnlwdG9Ob2RlLmpzP2JlNTYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyeXB0byA9IHZvaWQgMDtcbi8qKlxuICogSW50ZXJuYWwgd2ViY3J5cHRvIGFsaWFzLlxuICogV2UgcHJlZmVyIFdlYkNyeXB0byBha2EgZ2xvYmFsVGhpcy5jcnlwdG8sIHdoaWNoIGV4aXN0cyBpbiBub2RlLmpzIDE2Ky5cbiAqIEZhbGxzIGJhY2sgdG8gTm9kZS5qcyBidWlsdC1pbiBjcnlwdG8gZm9yIE5vZGUuanMgPD12MTQuXG4gKiBTZWUgdXRpbHMudHMgZm9yIGRldGFpbHMuXG4gKiBAbW9kdWxlXG4gKi9cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IG5jID0gcmVxdWlyZShcIm5vZGU6Y3J5cHRvXCIpO1xuZXhwb3J0cy5jcnlwdG8gPSBuYyAmJiB0eXBlb2YgbmMgPT09ICdvYmplY3QnICYmICd3ZWJjcnlwdG8nIGluIG5jXG4gICAgPyBuYy53ZWJjcnlwdG9cbiAgICA6IG5jICYmIHR5cGVvZiBuYyA9PT0gJ29iamVjdCcgJiYgJ3JhbmRvbUJ5dGVzJyBpbiBuY1xuICAgICAgICA/IG5jXG4gICAgICAgIDogdW5kZWZpbmVkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3J5cHRvTm9kZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJjcnlwdG8iLCJuYyIsInJlcXVpcmUiLCJ3ZWJjcnlwdG8iLCJ1bmRlZmluZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/@noble/hashes/cryptoNode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/@noble/hashes/hmac.js":
/*!************************************************************!*\
  !*** ./node_modules/ox/node_modules/@noble/hashes/hmac.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.hmac = exports.HMAC = void 0;\n/**\n * HMAC: RFC2104 message authentication code.\n * @module\n */ const utils_ts_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/utils.js\");\nclass HMAC extends utils_ts_1.Hash {\n    constructor(hash, _key){\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        (0, utils_ts_1.ahash)(hash);\n        const key = (0, utils_ts_1.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== \"function\") throw new Error(\"Expected instance of class which extends utils.Hash\");\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for(let i = 0; i < pad.length; i++)pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for(let i = 0; i < pad.length; i++)pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        (0, utils_ts_1.clean)(pad);\n    }\n    update(buf) {\n        (0, utils_ts_1.aexists)(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        (0, utils_ts_1.aexists)(this);\n        (0, utils_ts_1.abytes)(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\nexports.HMAC = HMAC;\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n * @example\n * import { hmac } from '@noble/hashes/hmac';\n * import { sha256 } from '@noble/hashes/sha2';\n * const mac1 = hmac(sha256, 'key', 'message');\n */ const hmac = (hash, key, message)=>new HMAC(hash, key).update(message).digest();\nexports.hmac = hmac;\nexports.hmac.create = (hash, key)=>new HMAC(hash, key); //# sourceMappingURL=hmac.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvaG1hYy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsWUFBWSxHQUFHQSxZQUFZLEdBQUcsS0FBSztBQUNuQzs7O0NBR0MsR0FDRCxNQUFNSSxhQUFhQyxtQkFBT0EsQ0FBQywrRUFBWTtBQUN2QyxNQUFNRixhQUFhQyxXQUFXRSxJQUFJO0lBQzlCQyxZQUFZQyxJQUFJLEVBQUVDLElBQUksQ0FBRTtRQUNwQixLQUFLO1FBQ0wsSUFBSSxDQUFDQyxRQUFRLEdBQUc7UUFDaEIsSUFBSSxDQUFDQyxTQUFTLEdBQUc7UUFDaEIsSUFBR1AsV0FBV1EsS0FBSyxFQUFFSjtRQUN0QixNQUFNSyxNQUFNLENBQUMsR0FBR1QsV0FBV1UsT0FBTyxFQUFFTDtRQUNwQyxJQUFJLENBQUNNLEtBQUssR0FBR1AsS0FBS1EsTUFBTTtRQUN4QixJQUFJLE9BQU8sSUFBSSxDQUFDRCxLQUFLLENBQUNFLE1BQU0sS0FBSyxZQUM3QixNQUFNLElBQUlDLE1BQU07UUFDcEIsSUFBSSxDQUFDQyxRQUFRLEdBQUcsSUFBSSxDQUFDSixLQUFLLENBQUNJLFFBQVE7UUFDbkMsSUFBSSxDQUFDQyxTQUFTLEdBQUcsSUFBSSxDQUFDTCxLQUFLLENBQUNLLFNBQVM7UUFDckMsTUFBTUQsV0FBVyxJQUFJLENBQUNBLFFBQVE7UUFDOUIsTUFBTUUsTUFBTSxJQUFJQyxXQUFXSDtRQUMzQix3Q0FBd0M7UUFDeENFLElBQUlFLEdBQUcsQ0FBQ1YsSUFBSVcsTUFBTSxHQUFHTCxXQUFXWCxLQUFLUSxNQUFNLEdBQUdDLE1BQU0sQ0FBQ0osS0FBS1ksTUFBTSxLQUFLWjtRQUNyRSxJQUFLLElBQUlhLElBQUksR0FBR0EsSUFBSUwsSUFBSUcsTUFBTSxFQUFFRSxJQUM1QkwsR0FBRyxDQUFDSyxFQUFFLElBQUk7UUFDZCxJQUFJLENBQUNYLEtBQUssQ0FBQ0UsTUFBTSxDQUFDSTtRQUNsQixtSEFBbUg7UUFDbkgsSUFBSSxDQUFDTSxLQUFLLEdBQUduQixLQUFLUSxNQUFNO1FBQ3hCLHVDQUF1QztRQUN2QyxJQUFLLElBQUlVLElBQUksR0FBR0EsSUFBSUwsSUFBSUcsTUFBTSxFQUFFRSxJQUM1QkwsR0FBRyxDQUFDSyxFQUFFLElBQUksT0FBTztRQUNyQixJQUFJLENBQUNDLEtBQUssQ0FBQ1YsTUFBTSxDQUFDSTtRQUNqQixJQUFHakIsV0FBV3dCLEtBQUssRUFBRVA7SUFDMUI7SUFDQUosT0FBT1ksR0FBRyxFQUFFO1FBQ1AsSUFBR3pCLFdBQVcwQixPQUFPLEVBQUUsSUFBSTtRQUM1QixJQUFJLENBQUNmLEtBQUssQ0FBQ0UsTUFBTSxDQUFDWTtRQUNsQixPQUFPLElBQUk7SUFDZjtJQUNBRSxXQUFXQyxHQUFHLEVBQUU7UUFDWCxJQUFHNUIsV0FBVzBCLE9BQU8sRUFBRSxJQUFJO1FBQzNCLElBQUcxQixXQUFXNkIsTUFBTSxFQUFFRCxLQUFLLElBQUksQ0FBQ1osU0FBUztRQUMxQyxJQUFJLENBQUNWLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNLLEtBQUssQ0FBQ2dCLFVBQVUsQ0FBQ0M7UUFDdEIsSUFBSSxDQUFDTCxLQUFLLENBQUNWLE1BQU0sQ0FBQ2U7UUFDbEIsSUFBSSxDQUFDTCxLQUFLLENBQUNJLFVBQVUsQ0FBQ0M7UUFDdEIsSUFBSSxDQUFDRSxPQUFPO0lBQ2hCO0lBQ0FULFNBQVM7UUFDTCxNQUFNTyxNQUFNLElBQUlWLFdBQVcsSUFBSSxDQUFDSyxLQUFLLENBQUNQLFNBQVM7UUFDL0MsSUFBSSxDQUFDVyxVQUFVLENBQUNDO1FBQ2hCLE9BQU9BO0lBQ1g7SUFDQUcsV0FBV0MsRUFBRSxFQUFFO1FBQ1gsbUdBQW1HO1FBQ25HQSxNQUFPQSxDQUFBQSxLQUFLdEMsT0FBT2tCLE1BQU0sQ0FBQ2xCLE9BQU91QyxjQUFjLENBQUMsSUFBSSxHQUFHLENBQUMsRUFBQztRQUN6RCxNQUFNLEVBQUVWLEtBQUssRUFBRVosS0FBSyxFQUFFTCxRQUFRLEVBQUVDLFNBQVMsRUFBRVEsUUFBUSxFQUFFQyxTQUFTLEVBQUUsR0FBRyxJQUFJO1FBQ3ZFZ0IsS0FBS0E7UUFDTEEsR0FBRzFCLFFBQVEsR0FBR0E7UUFDZDBCLEdBQUd6QixTQUFTLEdBQUdBO1FBQ2Z5QixHQUFHakIsUUFBUSxHQUFHQTtRQUNkaUIsR0FBR2hCLFNBQVMsR0FBR0E7UUFDZmdCLEdBQUdULEtBQUssR0FBR0EsTUFBTVEsVUFBVSxDQUFDQyxHQUFHVCxLQUFLO1FBQ3BDUyxHQUFHckIsS0FBSyxHQUFHQSxNQUFNb0IsVUFBVSxDQUFDQyxHQUFHckIsS0FBSztRQUNwQyxPQUFPcUI7SUFDWDtJQUNBRSxRQUFRO1FBQ0osT0FBTyxJQUFJLENBQUNILFVBQVU7SUFDMUI7SUFDQUQsVUFBVTtRQUNOLElBQUksQ0FBQ3ZCLFNBQVMsR0FBRztRQUNqQixJQUFJLENBQUNnQixLQUFLLENBQUNPLE9BQU87UUFDbEIsSUFBSSxDQUFDbkIsS0FBSyxDQUFDbUIsT0FBTztJQUN0QjtBQUNKO0FBQ0FsQyxZQUFZLEdBQUdHO0FBQ2Y7Ozs7Ozs7OztDQVNDLEdBQ0QsTUFBTUQsT0FBTyxDQUFDTSxNQUFNSyxLQUFLMEIsVUFBWSxJQUFJcEMsS0FBS0ssTUFBTUssS0FBS0ksTUFBTSxDQUFDc0IsU0FBU2QsTUFBTTtBQUMvRXpCLFlBQVksR0FBR0U7QUFDZkYsbUJBQW1CLEdBQUcsQ0FBQ1EsTUFBTUssTUFBUSxJQUFJVixLQUFLSyxNQUFNSyxNQUNwRCxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGF3LXdvcmtzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2htYWMuanM/MmQ5ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaG1hYyA9IGV4cG9ydHMuSE1BQyA9IHZvaWQgMDtcbi8qKlxuICogSE1BQzogUkZDMjEwNCBtZXNzYWdlIGF1dGhlbnRpY2F0aW9uIGNvZGUuXG4gKiBAbW9kdWxlXG4gKi9cbmNvbnN0IHV0aWxzX3RzXzEgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbmNsYXNzIEhNQUMgZXh0ZW5kcyB1dGlsc190c18xLkhhc2gge1xuICAgIGNvbnN0cnVjdG9yKGhhc2gsIF9rZXkpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICAoMCwgdXRpbHNfdHNfMS5haGFzaCkoaGFzaCk7XG4gICAgICAgIGNvbnN0IGtleSA9ICgwLCB1dGlsc190c18xLnRvQnl0ZXMpKF9rZXkpO1xuICAgICAgICB0aGlzLmlIYXNoID0gaGFzaC5jcmVhdGUoKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmlIYXNoLnVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgaW5zdGFuY2Ugb2YgY2xhc3Mgd2hpY2ggZXh0ZW5kcyB1dGlscy5IYXNoJyk7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSB0aGlzLmlIYXNoLmJsb2NrTGVuO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IHRoaXMuaUhhc2gub3V0cHV0TGVuO1xuICAgICAgICBjb25zdCBibG9ja0xlbiA9IHRoaXMuYmxvY2tMZW47XG4gICAgICAgIGNvbnN0IHBhZCA9IG5ldyBVaW50OEFycmF5KGJsb2NrTGVuKTtcbiAgICAgICAgLy8gYmxvY2tMZW4gY2FuIGJlIGJpZ2dlciB0aGFuIG91dHB1dExlblxuICAgICAgICBwYWQuc2V0KGtleS5sZW5ndGggPiBibG9ja0xlbiA/IGhhc2guY3JlYXRlKCkudXBkYXRlKGtleSkuZGlnZXN0KCkgOiBrZXkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHBhZFtpXSBePSAweDM2O1xuICAgICAgICB0aGlzLmlIYXNoLnVwZGF0ZShwYWQpO1xuICAgICAgICAvLyBCeSBkb2luZyB1cGRhdGUgKHByb2Nlc3Npbmcgb2YgZmlyc3QgYmxvY2spIG9mIG91dGVyIGhhc2ggaGVyZSB3ZSBjYW4gcmUtdXNlIGl0IGJldHdlZW4gbXVsdGlwbGUgY2FsbHMgdmlhIGNsb25lXG4gICAgICAgIHRoaXMub0hhc2ggPSBoYXNoLmNyZWF0ZSgpO1xuICAgICAgICAvLyBVbmRvIGludGVybmFsIFhPUiAmJiBhcHBseSBvdXRlciBYT1JcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBwYWRbaV0gXj0gMHgzNiBeIDB4NWM7XG4gICAgICAgIHRoaXMub0hhc2gudXBkYXRlKHBhZCk7XG4gICAgICAgICgwLCB1dGlsc190c18xLmNsZWFuKShwYWQpO1xuICAgIH1cbiAgICB1cGRhdGUoYnVmKSB7XG4gICAgICAgICgwLCB1dGlsc190c18xLmFleGlzdHMpKHRoaXMpO1xuICAgICAgICB0aGlzLmlIYXNoLnVwZGF0ZShidWYpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgKDAsIHV0aWxzX3RzXzEuYWV4aXN0cykodGhpcyk7XG4gICAgICAgICgwLCB1dGlsc190c18xLmFieXRlcykob3V0LCB0aGlzLm91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmlIYXNoLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgdGhpcy5vSGFzaC51cGRhdGUob3V0KTtcbiAgICAgICAgdGhpcy5vSGFzaC5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIGNvbnN0IG91dCA9IG5ldyBVaW50OEFycmF5KHRoaXMub0hhc2gub3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIF9jbG9uZUludG8odG8pIHtcbiAgICAgICAgLy8gQ3JlYXRlIG5ldyBpbnN0YW5jZSB3aXRob3V0IGNhbGxpbmcgY29uc3RydWN0b3Igc2luY2Uga2V5IGFscmVhZHkgaW4gc3RhdGUgYW5kIHdlIGRvbid0IGtub3cgaXQuXG4gICAgICAgIHRvIHx8ICh0byA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLCB7fSkpO1xuICAgICAgICBjb25zdCB7IG9IYXNoLCBpSGFzaCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgYmxvY2tMZW4sIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdG8gPSB0bztcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gZGVzdHJveWVkO1xuICAgICAgICB0by5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0by5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRvLm9IYXNoID0gb0hhc2guX2Nsb25lSW50byh0by5vSGFzaCk7XG4gICAgICAgIHRvLmlIYXNoID0gaUhhc2guX2Nsb25lSW50byh0by5pSGFzaCk7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9uZUludG8oKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm9IYXNoLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5pSGFzaC5kZXN0cm95KCk7XG4gICAgfVxufVxuZXhwb3J0cy5ITUFDID0gSE1BQztcbi8qKlxuICogSE1BQzogUkZDMjEwNCBtZXNzYWdlIGF1dGhlbnRpY2F0aW9uIGNvZGUuXG4gKiBAcGFyYW0gaGFzaCAtIGZ1bmN0aW9uIHRoYXQgd291bGQgYmUgdXNlZCBlLmcuIHNoYTI1NlxuICogQHBhcmFtIGtleSAtIG1lc3NhZ2Uga2V5XG4gKiBAcGFyYW0gbWVzc2FnZSAtIG1lc3NhZ2UgZGF0YVxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IGhtYWMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL2htYWMnO1xuICogaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGEyJztcbiAqIGNvbnN0IG1hYzEgPSBobWFjKHNoYTI1NiwgJ2tleScsICdtZXNzYWdlJyk7XG4gKi9cbmNvbnN0IGhtYWMgPSAoaGFzaCwga2V5LCBtZXNzYWdlKSA9PiBuZXcgSE1BQyhoYXNoLCBrZXkpLnVwZGF0ZShtZXNzYWdlKS5kaWdlc3QoKTtcbmV4cG9ydHMuaG1hYyA9IGhtYWM7XG5leHBvcnRzLmhtYWMuY3JlYXRlID0gKGhhc2gsIGtleSkgPT4gbmV3IEhNQUMoaGFzaCwga2V5KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhtYWMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiaG1hYyIsIkhNQUMiLCJ1dGlsc190c18xIiwicmVxdWlyZSIsIkhhc2giLCJjb25zdHJ1Y3RvciIsImhhc2giLCJfa2V5IiwiZmluaXNoZWQiLCJkZXN0cm95ZWQiLCJhaGFzaCIsImtleSIsInRvQnl0ZXMiLCJpSGFzaCIsImNyZWF0ZSIsInVwZGF0ZSIsIkVycm9yIiwiYmxvY2tMZW4iLCJvdXRwdXRMZW4iLCJwYWQiLCJVaW50OEFycmF5Iiwic2V0IiwibGVuZ3RoIiwiZGlnZXN0IiwiaSIsIm9IYXNoIiwiY2xlYW4iLCJidWYiLCJhZXhpc3RzIiwiZGlnZXN0SW50byIsIm91dCIsImFieXRlcyIsImRlc3Ryb3kiLCJfY2xvbmVJbnRvIiwidG8iLCJnZXRQcm90b3R5cGVPZiIsImNsb25lIiwibWVzc2FnZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/@noble/hashes/hmac.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/@noble/hashes/legacy.js":
/*!**************************************************************!*\
  !*** ./node_modules/ox/node_modules/@noble/hashes/legacy.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ripemd160 = exports.RIPEMD160 = exports.md5 = exports.MD5 = exports.sha1 = exports.SHA1 = void 0;\n/**\n\nSHA1 (RFC 3174), MD5 (RFC 1321) and RIPEMD160 (RFC 2286) legacy, weak hash functions.\nDon't use them in a new protocol. What \"weak\" means:\n\n- Collisions can be made with 2^18 effort in MD5, 2^60 in SHA1, 2^80 in RIPEMD160.\n- No practical pre-image attacks (only theoretical, 2^123.4)\n- HMAC seems kinda ok: https://datatracker.ietf.org/doc/html/rfc6151\n * @module\n */ const _md_ts_1 = __webpack_require__(/*! ./_md.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/_md.js\");\nconst utils_ts_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/utils.js\");\n/** Initial SHA1 state */ const SHA1_IV = /* @__PURE__ */ Uint32Array.from([\n    0x67452301,\n    0xefcdab89,\n    0x98badcfe,\n    0x10325476,\n    0xc3d2e1f0\n]);\n// Reusable temporary buffer\nconst SHA1_W = /* @__PURE__ */ new Uint32Array(80);\n/** SHA1 legacy hash class. */ class SHA1 extends _md_ts_1.HashMD {\n    constructor(){\n        super(64, 20, 8, false);\n        this.A = SHA1_IV[0] | 0;\n        this.B = SHA1_IV[1] | 0;\n        this.C = SHA1_IV[2] | 0;\n        this.D = SHA1_IV[3] | 0;\n        this.E = SHA1_IV[4] | 0;\n    }\n    get() {\n        const { A, B, C, D, E } = this;\n        return [\n            A,\n            B,\n            C,\n            D,\n            E\n        ];\n    }\n    set(A, B, C, D, E) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n    }\n    process(view, offset) {\n        for(let i = 0; i < 16; i++, offset += 4)SHA1_W[i] = view.getUint32(offset, false);\n        for(let i = 16; i < 80; i++)SHA1_W[i] = (0, utils_ts_1.rotl)(SHA1_W[i - 3] ^ SHA1_W[i - 8] ^ SHA1_W[i - 14] ^ SHA1_W[i - 16], 1);\n        // Compression function main loop, 80 rounds\n        let { A, B, C, D, E } = this;\n        for(let i = 0; i < 80; i++){\n            let F, K;\n            if (i < 20) {\n                F = (0, _md_ts_1.Chi)(B, C, D);\n                K = 0x5a827999;\n            } else if (i < 40) {\n                F = B ^ C ^ D;\n                K = 0x6ed9eba1;\n            } else if (i < 60) {\n                F = (0, _md_ts_1.Maj)(B, C, D);\n                K = 0x8f1bbcdc;\n            } else {\n                F = B ^ C ^ D;\n                K = 0xca62c1d6;\n            }\n            const T = (0, utils_ts_1.rotl)(A, 5) + F + E + K + SHA1_W[i] | 0;\n            E = D;\n            D = C;\n            C = (0, utils_ts_1.rotl)(B, 30);\n            B = A;\n            A = T;\n        }\n        // Add the compressed chunk to the current hash value\n        A = A + this.A | 0;\n        B = B + this.B | 0;\n        C = C + this.C | 0;\n        D = D + this.D | 0;\n        E = E + this.E | 0;\n        this.set(A, B, C, D, E);\n    }\n    roundClean() {\n        (0, utils_ts_1.clean)(SHA1_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0);\n        (0, utils_ts_1.clean)(this.buffer);\n    }\n}\nexports.SHA1 = SHA1;\n/** SHA1 (RFC 3174) legacy hash function. It was cryptographically broken. */ exports.sha1 = (0, utils_ts_1.createHasher)(()=>new SHA1());\n/** Per-round constants */ const p32 = /* @__PURE__ */ Math.pow(2, 32);\nconst K = /* @__PURE__ */ Array.from({\n    length: 64\n}, (_, i)=>Math.floor(p32 * Math.abs(Math.sin(i + 1))));\n/** md5 initial state: same as sha1, but 4 u32 instead of 5. */ const MD5_IV = /* @__PURE__ */ SHA1_IV.slice(0, 4);\n// Reusable temporary buffer\nconst MD5_W = /* @__PURE__ */ new Uint32Array(16);\n/** MD5 legacy hash class. */ class MD5 extends _md_ts_1.HashMD {\n    constructor(){\n        super(64, 16, 8, true);\n        this.A = MD5_IV[0] | 0;\n        this.B = MD5_IV[1] | 0;\n        this.C = MD5_IV[2] | 0;\n        this.D = MD5_IV[3] | 0;\n    }\n    get() {\n        const { A, B, C, D } = this;\n        return [\n            A,\n            B,\n            C,\n            D\n        ];\n    }\n    set(A, B, C, D) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n    }\n    process(view, offset) {\n        for(let i = 0; i < 16; i++, offset += 4)MD5_W[i] = view.getUint32(offset, true);\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D } = this;\n        for(let i = 0; i < 64; i++){\n            let F, g, s;\n            if (i < 16) {\n                F = (0, _md_ts_1.Chi)(B, C, D);\n                g = i;\n                s = [\n                    7,\n                    12,\n                    17,\n                    22\n                ];\n            } else if (i < 32) {\n                F = (0, _md_ts_1.Chi)(D, B, C);\n                g = (5 * i + 1) % 16;\n                s = [\n                    5,\n                    9,\n                    14,\n                    20\n                ];\n            } else if (i < 48) {\n                F = B ^ C ^ D;\n                g = (3 * i + 5) % 16;\n                s = [\n                    4,\n                    11,\n                    16,\n                    23\n                ];\n            } else {\n                F = C ^ (B | ~D);\n                g = 7 * i % 16;\n                s = [\n                    6,\n                    10,\n                    15,\n                    21\n                ];\n            }\n            F = F + A + K[i] + MD5_W[g];\n            A = D;\n            D = C;\n            C = B;\n            B = B + (0, utils_ts_1.rotl)(F, s[i % 4]);\n        }\n        // Add the compressed chunk to the current hash value\n        A = A + this.A | 0;\n        B = B + this.B | 0;\n        C = C + this.C | 0;\n        D = D + this.D | 0;\n        this.set(A, B, C, D);\n    }\n    roundClean() {\n        (0, utils_ts_1.clean)(MD5_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0);\n        (0, utils_ts_1.clean)(this.buffer);\n    }\n}\nexports.MD5 = MD5;\n/**\n * MD5 (RFC 1321) legacy hash function. It was cryptographically broken.\n * MD5 architecture is similar to SHA1, with some differences:\n * - Reduced output length: 16 bytes (128 bit) instead of 20\n * - 64 rounds, instead of 80\n * - Little-endian: could be faster, but will require more code\n * - Non-linear index selection: huge speed-up for unroll\n * - Per round constants: more memory accesses, additional speed-up for unroll\n */ exports.md5 = (0, utils_ts_1.createHasher)(()=>new MD5());\n// RIPEMD-160\nconst Rho160 = /* @__PURE__ */ Uint8Array.from([\n    7,\n    4,\n    13,\n    1,\n    10,\n    6,\n    15,\n    3,\n    12,\n    0,\n    9,\n    5,\n    2,\n    14,\n    11,\n    8\n]);\nconst Id160 = /* @__PURE__ */ (()=>Uint8Array.from(new Array(16).fill(0).map((_, i)=>i)))();\nconst Pi160 = /* @__PURE__ */ (()=>Id160.map((i)=>(9 * i + 5) % 16))();\nconst idxLR = /* @__PURE__ */ (()=>{\n    const L = [\n        Id160\n    ];\n    const R = [\n        Pi160\n    ];\n    const res = [\n        L,\n        R\n    ];\n    for(let i = 0; i < 4; i++)for (let j of res)j.push(j[i].map((k)=>Rho160[k]));\n    return res;\n})();\nconst idxL = /* @__PURE__ */ (()=>idxLR[0])();\nconst idxR = /* @__PURE__ */ (()=>idxLR[1])();\n// const [idxL, idxR] = idxLR;\nconst shifts160 = /* @__PURE__ */ [\n    [\n        11,\n        14,\n        15,\n        12,\n        5,\n        8,\n        7,\n        9,\n        11,\n        13,\n        14,\n        15,\n        6,\n        7,\n        9,\n        8\n    ],\n    [\n        12,\n        13,\n        11,\n        15,\n        6,\n        9,\n        9,\n        7,\n        12,\n        15,\n        11,\n        13,\n        7,\n        8,\n        7,\n        7\n    ],\n    [\n        13,\n        15,\n        14,\n        11,\n        7,\n        7,\n        6,\n        8,\n        13,\n        14,\n        13,\n        12,\n        5,\n        5,\n        6,\n        9\n    ],\n    [\n        14,\n        11,\n        12,\n        14,\n        8,\n        6,\n        5,\n        5,\n        15,\n        12,\n        15,\n        14,\n        9,\n        9,\n        8,\n        6\n    ],\n    [\n        15,\n        12,\n        13,\n        13,\n        9,\n        5,\n        8,\n        6,\n        14,\n        11,\n        12,\n        11,\n        8,\n        6,\n        5,\n        5\n    ]\n].map((i)=>Uint8Array.from(i));\nconst shiftsL160 = /* @__PURE__ */ idxL.map((idx, i)=>idx.map((j)=>shifts160[i][j]));\nconst shiftsR160 = /* @__PURE__ */ idxR.map((idx, i)=>idx.map((j)=>shifts160[i][j]));\nconst Kl160 = /* @__PURE__ */ Uint32Array.from([\n    0x00000000,\n    0x5a827999,\n    0x6ed9eba1,\n    0x8f1bbcdc,\n    0xa953fd4e\n]);\nconst Kr160 = /* @__PURE__ */ Uint32Array.from([\n    0x50a28be6,\n    0x5c4dd124,\n    0x6d703ef3,\n    0x7a6d76e9,\n    0x00000000\n]);\n// It's called f() in spec.\nfunction ripemd_f(group, x, y, z) {\n    if (group === 0) return x ^ y ^ z;\n    if (group === 1) return x & y | ~x & z;\n    if (group === 2) return (x | ~y) ^ z;\n    if (group === 3) return x & z | y & ~z;\n    return x ^ (y | ~z);\n}\n// Reusable temporary buffer\nconst BUF_160 = /* @__PURE__ */ new Uint32Array(16);\nclass RIPEMD160 extends _md_ts_1.HashMD {\n    constructor(){\n        super(64, 20, 8, true);\n        this.h0 = 0x67452301 | 0;\n        this.h1 = 0xefcdab89 | 0;\n        this.h2 = 0x98badcfe | 0;\n        this.h3 = 0x10325476 | 0;\n        this.h4 = 0xc3d2e1f0 | 0;\n    }\n    get() {\n        const { h0, h1, h2, h3, h4 } = this;\n        return [\n            h0,\n            h1,\n            h2,\n            h3,\n            h4\n        ];\n    }\n    set(h0, h1, h2, h3, h4) {\n        this.h0 = h0 | 0;\n        this.h1 = h1 | 0;\n        this.h2 = h2 | 0;\n        this.h3 = h3 | 0;\n        this.h4 = h4 | 0;\n    }\n    process(view, offset) {\n        for(let i = 0; i < 16; i++, offset += 4)BUF_160[i] = view.getUint32(offset, true);\n        // prettier-ignore\n        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;\n        // Instead of iterating 0 to 80, we split it into 5 groups\n        // And use the groups in constants, functions, etc. Much simpler\n        for(let group = 0; group < 5; group++){\n            const rGroup = 4 - group;\n            const hbl = Kl160[group], hbr = Kr160[group]; // prettier-ignore\n            const rl = idxL[group], rr = idxR[group]; // prettier-ignore\n            const sl = shiftsL160[group], sr = shiftsR160[group]; // prettier-ignore\n            for(let i = 0; i < 16; i++){\n                const tl = (0, utils_ts_1.rotl)(al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i]] + hbl, sl[i]) + el | 0;\n                al = el, el = dl, dl = (0, utils_ts_1.rotl)(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore\n            }\n            // 2 loops are 10% faster\n            for(let i = 0; i < 16; i++){\n                const tr = (0, utils_ts_1.rotl)(ar + ripemd_f(rGroup, br, cr, dr) + BUF_160[rr[i]] + hbr, sr[i]) + er | 0;\n                ar = er, er = dr, dr = (0, utils_ts_1.rotl)(cr, 10) | 0, cr = br, br = tr; // prettier-ignore\n            }\n        }\n        // Add the compressed chunk to the current hash value\n        this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);\n    }\n    roundClean() {\n        (0, utils_ts_1.clean)(BUF_160);\n    }\n    destroy() {\n        this.destroyed = true;\n        (0, utils_ts_1.clean)(this.buffer);\n        this.set(0, 0, 0, 0, 0);\n    }\n}\nexports.RIPEMD160 = RIPEMD160;\n/**\n * RIPEMD-160 - a legacy hash function from 1990s.\n * * https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n * * https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\n */ exports.ripemd160 = (0, utils_ts_1.createHasher)(()=>new RIPEMD160()); //# sourceMappingURL=legacy.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvbGVnYWN5LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxpQkFBaUIsR0FBR0EsaUJBQWlCLEdBQUdBLFdBQVcsR0FBR0EsV0FBVyxHQUFHQSxZQUFZLEdBQUdBLFlBQVksR0FBRyxLQUFLO0FBQ3ZHOzs7Ozs7Ozs7Q0FTQyxHQUNELE1BQU1RLFdBQVdDLG1CQUFPQSxDQUFDLDJFQUFVO0FBQ25DLE1BQU1DLGFBQWFELG1CQUFPQSxDQUFDLCtFQUFZO0FBQ3ZDLHVCQUF1QixHQUN2QixNQUFNRSxVQUFVLGFBQWEsR0FBR0MsWUFBWUMsSUFBSSxDQUFDO0lBQzdDO0lBQVk7SUFBWTtJQUFZO0lBQVk7Q0FDbkQ7QUFDRCw0QkFBNEI7QUFDNUIsTUFBTUMsU0FBUyxhQUFhLEdBQUcsSUFBSUYsWUFBWTtBQUMvQyw0QkFBNEIsR0FDNUIsTUFBTUwsYUFBYUMsU0FBU08sTUFBTTtJQUM5QkMsYUFBYztRQUNWLEtBQUssQ0FBQyxJQUFJLElBQUksR0FBRztRQUNqQixJQUFJLENBQUNDLENBQUMsR0FBR04sT0FBTyxDQUFDLEVBQUUsR0FBRztRQUN0QixJQUFJLENBQUNPLENBQUMsR0FBR1AsT0FBTyxDQUFDLEVBQUUsR0FBRztRQUN0QixJQUFJLENBQUNRLENBQUMsR0FBR1IsT0FBTyxDQUFDLEVBQUUsR0FBRztRQUN0QixJQUFJLENBQUNTLENBQUMsR0FBR1QsT0FBTyxDQUFDLEVBQUUsR0FBRztRQUN0QixJQUFJLENBQUNVLENBQUMsR0FBR1YsT0FBTyxDQUFDLEVBQUUsR0FBRztJQUMxQjtJQUNBVyxNQUFNO1FBQ0YsTUFBTSxFQUFFTCxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRSxHQUFHLElBQUk7UUFDOUIsT0FBTztZQUFDSjtZQUFHQztZQUFHQztZQUFHQztZQUFHQztTQUFFO0lBQzFCO0lBQ0FFLElBQUlOLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFO1FBQ2YsSUFBSSxDQUFDSixDQUFDLEdBQUdBLElBQUk7UUFDYixJQUFJLENBQUNDLENBQUMsR0FBR0EsSUFBSTtRQUNiLElBQUksQ0FBQ0MsQ0FBQyxHQUFHQSxJQUFJO1FBQ2IsSUFBSSxDQUFDQyxDQUFDLEdBQUdBLElBQUk7UUFDYixJQUFJLENBQUNDLENBQUMsR0FBR0EsSUFBSTtJQUNqQjtJQUNBRyxRQUFRQyxJQUFJLEVBQUVDLE1BQU0sRUFBRTtRQUNsQixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSSxJQUFJQSxLQUFLRCxVQUFVLEVBQ25DWixNQUFNLENBQUNhLEVBQUUsR0FBR0YsS0FBS0csU0FBUyxDQUFDRixRQUFRO1FBQ3ZDLElBQUssSUFBSUMsSUFBSSxJQUFJQSxJQUFJLElBQUlBLElBQ3JCYixNQUFNLENBQUNhLEVBQUUsR0FBRyxDQUFDLEdBQUdqQixXQUFXbUIsSUFBSSxFQUFFZixNQUFNLENBQUNhLElBQUksRUFBRSxHQUFHYixNQUFNLENBQUNhLElBQUksRUFBRSxHQUFHYixNQUFNLENBQUNhLElBQUksR0FBRyxHQUFHYixNQUFNLENBQUNhLElBQUksR0FBRyxFQUFFO1FBQ3RHLDRDQUE0QztRQUM1QyxJQUFJLEVBQUVWLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFLEdBQUcsSUFBSTtRQUM1QixJQUFLLElBQUlNLElBQUksR0FBR0EsSUFBSSxJQUFJQSxJQUFLO1lBQ3pCLElBQUlHLEdBQUdDO1lBQ1AsSUFBSUosSUFBSSxJQUFJO2dCQUNSRyxJQUFJLENBQUMsR0FBR3RCLFNBQVN3QixHQUFHLEVBQUVkLEdBQUdDLEdBQUdDO2dCQUM1QlcsSUFBSTtZQUNSLE9BQ0ssSUFBSUosSUFBSSxJQUFJO2dCQUNiRyxJQUFJWixJQUFJQyxJQUFJQztnQkFDWlcsSUFBSTtZQUNSLE9BQ0ssSUFBSUosSUFBSSxJQUFJO2dCQUNiRyxJQUFJLENBQUMsR0FBR3RCLFNBQVN5QixHQUFHLEVBQUVmLEdBQUdDLEdBQUdDO2dCQUM1QlcsSUFBSTtZQUNSLE9BQ0s7Z0JBQ0RELElBQUlaLElBQUlDLElBQUlDO2dCQUNaVyxJQUFJO1lBQ1I7WUFDQSxNQUFNRyxJQUFJLENBQUUsR0FBR3hCLFdBQVdtQixJQUFJLEVBQUVaLEdBQUcsS0FBS2EsSUFBSVQsSUFBSVUsSUFBSWpCLE1BQU0sQ0FBQ2EsRUFBRSxHQUFJO1lBQ2pFTixJQUFJRDtZQUNKQSxJQUFJRDtZQUNKQSxJQUFJLENBQUMsR0FBR1QsV0FBV21CLElBQUksRUFBRVgsR0FBRztZQUM1QkEsSUFBSUQ7WUFDSkEsSUFBSWlCO1FBQ1I7UUFDQSxxREFBcUQ7UUFDckRqQixJQUFJLElBQUssSUFBSSxDQUFDQSxDQUFDLEdBQUk7UUFDbkJDLElBQUksSUFBSyxJQUFJLENBQUNBLENBQUMsR0FBSTtRQUNuQkMsSUFBSSxJQUFLLElBQUksQ0FBQ0EsQ0FBQyxHQUFJO1FBQ25CQyxJQUFJLElBQUssSUFBSSxDQUFDQSxDQUFDLEdBQUk7UUFDbkJDLElBQUksSUFBSyxJQUFJLENBQUNBLENBQUMsR0FBSTtRQUNuQixJQUFJLENBQUNFLEdBQUcsQ0FBQ04sR0FBR0MsR0FBR0MsR0FBR0MsR0FBR0M7SUFDekI7SUFDQWMsYUFBYTtRQUNSLElBQUd6QixXQUFXMEIsS0FBSyxFQUFFdEI7SUFDMUI7SUFDQXVCLFVBQVU7UUFDTixJQUFJLENBQUNkLEdBQUcsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHO1FBQ3BCLElBQUdiLFdBQVcwQixLQUFLLEVBQUUsSUFBSSxDQUFDRSxNQUFNO0lBQ3JDO0FBQ0o7QUFDQXRDLFlBQVksR0FBR087QUFDZiwyRUFBMkUsR0FDM0VQLFlBQVksR0FBRyxDQUFDLEdBQUdVLFdBQVc2QixZQUFZLEVBQUUsSUFBTSxJQUFJaEM7QUFDdEQsd0JBQXdCLEdBQ3hCLE1BQU1pQyxNQUFNLGFBQWEsR0FBR0MsS0FBS0MsR0FBRyxDQUFDLEdBQUc7QUFDeEMsTUFBTVgsSUFBSSxhQUFhLEdBQUdZLE1BQU05QixJQUFJLENBQUM7SUFBRStCLFFBQVE7QUFBRyxHQUFHLENBQUNDLEdBQUdsQixJQUFNYyxLQUFLSyxLQUFLLENBQUNOLE1BQU1DLEtBQUtNLEdBQUcsQ0FBQ04sS0FBS08sR0FBRyxDQUFDckIsSUFBSTtBQUN0Ryw2REFBNkQsR0FDN0QsTUFBTXNCLFNBQVMsYUFBYSxHQUFHdEMsUUFBUXVDLEtBQUssQ0FBQyxHQUFHO0FBQ2hELDRCQUE0QjtBQUM1QixNQUFNQyxRQUFRLGFBQWEsR0FBRyxJQUFJdkMsWUFBWTtBQUM5QywyQkFBMkIsR0FDM0IsTUFBTVAsWUFBWUcsU0FBU08sTUFBTTtJQUM3QkMsYUFBYztRQUNWLEtBQUssQ0FBQyxJQUFJLElBQUksR0FBRztRQUNqQixJQUFJLENBQUNDLENBQUMsR0FBR2dDLE1BQU0sQ0FBQyxFQUFFLEdBQUc7UUFDckIsSUFBSSxDQUFDL0IsQ0FBQyxHQUFHK0IsTUFBTSxDQUFDLEVBQUUsR0FBRztRQUNyQixJQUFJLENBQUM5QixDQUFDLEdBQUc4QixNQUFNLENBQUMsRUFBRSxHQUFHO1FBQ3JCLElBQUksQ0FBQzdCLENBQUMsR0FBRzZCLE1BQU0sQ0FBQyxFQUFFLEdBQUc7SUFDekI7SUFDQTNCLE1BQU07UUFDRixNQUFNLEVBQUVMLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRSxHQUFHLElBQUk7UUFDM0IsT0FBTztZQUFDSDtZQUFHQztZQUFHQztZQUFHQztTQUFFO0lBQ3ZCO0lBQ0FHLElBQUlOLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRTtRQUNaLElBQUksQ0FBQ0gsQ0FBQyxHQUFHQSxJQUFJO1FBQ2IsSUFBSSxDQUFDQyxDQUFDLEdBQUdBLElBQUk7UUFDYixJQUFJLENBQUNDLENBQUMsR0FBR0EsSUFBSTtRQUNiLElBQUksQ0FBQ0MsQ0FBQyxHQUFHQSxJQUFJO0lBQ2pCO0lBQ0FJLFFBQVFDLElBQUksRUFBRUMsTUFBTSxFQUFFO1FBQ2xCLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJLElBQUlBLEtBQUtELFVBQVUsRUFDbkN5QixLQUFLLENBQUN4QixFQUFFLEdBQUdGLEtBQUtHLFNBQVMsQ0FBQ0YsUUFBUTtRQUN0Qyw0Q0FBNEM7UUFDNUMsSUFBSSxFQUFFVCxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUUsR0FBRyxJQUFJO1FBQ3pCLElBQUssSUFBSU8sSUFBSSxHQUFHQSxJQUFJLElBQUlBLElBQUs7WUFDekIsSUFBSUcsR0FBR3NCLEdBQUdDO1lBQ1YsSUFBSTFCLElBQUksSUFBSTtnQkFDUkcsSUFBSSxDQUFDLEdBQUd0QixTQUFTd0IsR0FBRyxFQUFFZCxHQUFHQyxHQUFHQztnQkFDNUJnQyxJQUFJekI7Z0JBQ0owQixJQUFJO29CQUFDO29CQUFHO29CQUFJO29CQUFJO2lCQUFHO1lBQ3ZCLE9BQ0ssSUFBSTFCLElBQUksSUFBSTtnQkFDYkcsSUFBSSxDQUFDLEdBQUd0QixTQUFTd0IsR0FBRyxFQUFFWixHQUFHRixHQUFHQztnQkFDNUJpQyxJQUFJLENBQUMsSUFBSXpCLElBQUksS0FBSztnQkFDbEIwQixJQUFJO29CQUFDO29CQUFHO29CQUFHO29CQUFJO2lCQUFHO1lBQ3RCLE9BQ0ssSUFBSTFCLElBQUksSUFBSTtnQkFDYkcsSUFBSVosSUFBSUMsSUFBSUM7Z0JBQ1pnQyxJQUFJLENBQUMsSUFBSXpCLElBQUksS0FBSztnQkFDbEIwQixJQUFJO29CQUFDO29CQUFHO29CQUFJO29CQUFJO2lCQUFHO1lBQ3ZCLE9BQ0s7Z0JBQ0R2QixJQUFJWCxJQUFLRCxDQUFBQSxJQUFJLENBQUNFLENBQUFBO2dCQUNkZ0MsSUFBSSxJQUFLekIsSUFBSztnQkFDZDBCLElBQUk7b0JBQUM7b0JBQUc7b0JBQUk7b0JBQUk7aUJBQUc7WUFDdkI7WUFDQXZCLElBQUlBLElBQUliLElBQUljLENBQUMsQ0FBQ0osRUFBRSxHQUFHd0IsS0FBSyxDQUFDQyxFQUFFO1lBQzNCbkMsSUFBSUc7WUFDSkEsSUFBSUQ7WUFDSkEsSUFBSUQ7WUFDSkEsSUFBSUEsSUFBSSxDQUFDLEdBQUdSLFdBQVdtQixJQUFJLEVBQUVDLEdBQUd1QixDQUFDLENBQUMxQixJQUFJLEVBQUU7UUFDNUM7UUFDQSxxREFBcUQ7UUFDckRWLElBQUksSUFBSyxJQUFJLENBQUNBLENBQUMsR0FBSTtRQUNuQkMsSUFBSSxJQUFLLElBQUksQ0FBQ0EsQ0FBQyxHQUFJO1FBQ25CQyxJQUFJLElBQUssSUFBSSxDQUFDQSxDQUFDLEdBQUk7UUFDbkJDLElBQUksSUFBSyxJQUFJLENBQUNBLENBQUMsR0FBSTtRQUNuQixJQUFJLENBQUNHLEdBQUcsQ0FBQ04sR0FBR0MsR0FBR0MsR0FBR0M7SUFDdEI7SUFDQWUsYUFBYTtRQUNSLElBQUd6QixXQUFXMEIsS0FBSyxFQUFFZTtJQUMxQjtJQUNBZCxVQUFVO1FBQ04sSUFBSSxDQUFDZCxHQUFHLENBQUMsR0FBRyxHQUFHLEdBQUc7UUFDakIsSUFBR2IsV0FBVzBCLEtBQUssRUFBRSxJQUFJLENBQUNFLE1BQU07SUFDckM7QUFDSjtBQUNBdEMsV0FBVyxHQUFHSztBQUNkOzs7Ozs7OztDQVFDLEdBQ0RMLFdBQVcsR0FBRyxDQUFDLEdBQUdVLFdBQVc2QixZQUFZLEVBQUUsSUFBTSxJQUFJbEM7QUFDckQsYUFBYTtBQUNiLE1BQU1pRCxTQUFTLGFBQWEsR0FBR0MsV0FBVzFDLElBQUksQ0FBQztJQUMzQztJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUk7SUFBRztJQUFJO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBSTtDQUN0RDtBQUNELE1BQU0yQyxRQUF3QixhQUFILEdBQUksS0FBTUQsV0FBVzFDLElBQUksQ0FBQyxJQUFJOEIsTUFBTSxJQUFJYyxJQUFJLENBQUMsR0FBR0MsR0FBRyxDQUFDLENBQUNiLEdBQUdsQixJQUFNQSxHQUFFO0FBQzNGLE1BQU1nQyxRQUF3QixhQUFILEdBQUksS0FBTUgsTUFBTUUsR0FBRyxDQUFDLENBQUMvQixJQUFNLENBQUMsSUFBSUEsSUFBSSxLQUFLLEdBQUU7QUFDdEUsTUFBTWlDLFFBQXdCLGFBQUgsR0FBSTtJQUMzQixNQUFNQyxJQUFJO1FBQUNMO0tBQU07SUFDakIsTUFBTU0sSUFBSTtRQUFDSDtLQUFNO0lBQ2pCLE1BQU1JLE1BQU07UUFBQ0Y7UUFBR0M7S0FBRTtJQUNsQixJQUFLLElBQUluQyxJQUFJLEdBQUdBLElBQUksR0FBR0EsSUFDbkIsS0FBSyxJQUFJcUMsS0FBS0QsSUFDVkMsRUFBRUMsSUFBSSxDQUFDRCxDQUFDLENBQUNyQyxFQUFFLENBQUMrQixHQUFHLENBQUMsQ0FBQ1EsSUFBTVosTUFBTSxDQUFDWSxFQUFFO0lBQ3hDLE9BQU9IO0FBQ1g7QUFDQSxNQUFNSSxPQUF1QixhQUFILEdBQUksS0FBTVAsS0FBSyxDQUFDLEVBQUU7QUFDNUMsTUFBTVEsT0FBdUIsYUFBSCxHQUFJLEtBQU1SLEtBQUssQ0FBQyxFQUFFO0FBQzVDLDhCQUE4QjtBQUM5QixNQUFNUyxZQUFZLGFBQWEsR0FBRztJQUM5QjtRQUFDO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUc7UUFBRztRQUFHO0tBQUU7SUFDeEQ7UUFBQztRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFHO1FBQUc7UUFBRztLQUFFO0lBQ3hEO1FBQUM7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBRztRQUFHO1FBQUc7S0FBRTtJQUN4RDtRQUFDO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUc7UUFBRztRQUFHO0tBQUU7SUFDeEQ7UUFBQztRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFHO1FBQUc7UUFBRztLQUFFO0NBQzNELENBQUNYLEdBQUcsQ0FBQyxDQUFDL0IsSUFBTTRCLFdBQVcxQyxJQUFJLENBQUNjO0FBQzdCLE1BQU0yQyxhQUFhLGFBQWEsR0FBR0gsS0FBS1QsR0FBRyxDQUFDLENBQUNhLEtBQUs1QyxJQUFNNEMsSUFBSWIsR0FBRyxDQUFDLENBQUNNLElBQU1LLFNBQVMsQ0FBQzFDLEVBQUUsQ0FBQ3FDLEVBQUU7QUFDdEYsTUFBTVEsYUFBYSxhQUFhLEdBQUdKLEtBQUtWLEdBQUcsQ0FBQyxDQUFDYSxLQUFLNUMsSUFBTTRDLElBQUliLEdBQUcsQ0FBQyxDQUFDTSxJQUFNSyxTQUFTLENBQUMxQyxFQUFFLENBQUNxQyxFQUFFO0FBQ3RGLE1BQU1TLFFBQVEsYUFBYSxHQUFHN0QsWUFBWUMsSUFBSSxDQUFDO0lBQzNDO0lBQVk7SUFBWTtJQUFZO0lBQVk7Q0FDbkQ7QUFDRCxNQUFNNkQsUUFBUSxhQUFhLEdBQUc5RCxZQUFZQyxJQUFJLENBQUM7SUFDM0M7SUFBWTtJQUFZO0lBQVk7SUFBWTtDQUNuRDtBQUNELDJCQUEyQjtBQUMzQixTQUFTOEQsU0FBU0MsS0FBSyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQztJQUM1QixJQUFJSCxVQUFVLEdBQ1YsT0FBT0MsSUFBSUMsSUFBSUM7SUFDbkIsSUFBSUgsVUFBVSxHQUNWLE9BQU8sSUFBS0UsSUFBTSxDQUFDRCxJQUFJRTtJQUMzQixJQUFJSCxVQUFVLEdBQ1YsT0FBTyxDQUFDQyxJQUFJLENBQUNDLENBQUFBLElBQUtDO0lBQ3RCLElBQUlILFVBQVUsR0FDVixPQUFPLElBQUtHLElBQU1ELElBQUksQ0FBQ0M7SUFDM0IsT0FBT0YsSUFBS0MsQ0FBQUEsSUFBSSxDQUFDQyxDQUFBQTtBQUNyQjtBQUNBLDRCQUE0QjtBQUM1QixNQUFNQyxVQUFVLGFBQWEsR0FBRyxJQUFJcEUsWUFBWTtBQUNoRCxNQUFNVCxrQkFBa0JLLFNBQVNPLE1BQU07SUFDbkNDLGFBQWM7UUFDVixLQUFLLENBQUMsSUFBSSxJQUFJLEdBQUc7UUFDakIsSUFBSSxDQUFDaUUsRUFBRSxHQUFHLGFBQWE7UUFDdkIsSUFBSSxDQUFDQyxFQUFFLEdBQUcsYUFBYTtRQUN2QixJQUFJLENBQUNDLEVBQUUsR0FBRyxhQUFhO1FBQ3ZCLElBQUksQ0FBQ0MsRUFBRSxHQUFHLGFBQWE7UUFDdkIsSUFBSSxDQUFDQyxFQUFFLEdBQUcsYUFBYTtJQUMzQjtJQUNBL0QsTUFBTTtRQUNGLE1BQU0sRUFBRTJELEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFLEdBQUcsSUFBSTtRQUNuQyxPQUFPO1lBQUNKO1lBQUlDO1lBQUlDO1lBQUlDO1lBQUlDO1NBQUc7SUFDL0I7SUFDQTlELElBQUkwRCxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRTtRQUNwQixJQUFJLENBQUNKLEVBQUUsR0FBR0EsS0FBSztRQUNmLElBQUksQ0FBQ0MsRUFBRSxHQUFHQSxLQUFLO1FBQ2YsSUFBSSxDQUFDQyxFQUFFLEdBQUdBLEtBQUs7UUFDZixJQUFJLENBQUNDLEVBQUUsR0FBR0EsS0FBSztRQUNmLElBQUksQ0FBQ0MsRUFBRSxHQUFHQSxLQUFLO0lBQ25CO0lBQ0E3RCxRQUFRQyxJQUFJLEVBQUVDLE1BQU0sRUFBRTtRQUNsQixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSSxJQUFJQSxLQUFLRCxVQUFVLEVBQ25Dc0QsT0FBTyxDQUFDckQsRUFBRSxHQUFHRixLQUFLRyxTQUFTLENBQUNGLFFBQVE7UUFDeEMsa0JBQWtCO1FBQ2xCLElBQUk0RCxLQUFLLElBQUksQ0FBQ0wsRUFBRSxHQUFHLEdBQUdNLEtBQUtELElBQUlFLEtBQUssSUFBSSxDQUFDTixFQUFFLEdBQUcsR0FBR08sS0FBS0QsSUFBSUUsS0FBSyxJQUFJLENBQUNQLEVBQUUsR0FBRyxHQUFHUSxLQUFLRCxJQUFJRSxLQUFLLElBQUksQ0FBQ1IsRUFBRSxHQUFHLEdBQUdTLEtBQUtELElBQUlFLEtBQUssSUFBSSxDQUFDVCxFQUFFLEdBQUcsR0FBR1UsS0FBS0Q7UUFDdkksMERBQTBEO1FBQzFELGdFQUFnRTtRQUNoRSxJQUFLLElBQUlsQixRQUFRLEdBQUdBLFFBQVEsR0FBR0EsUUFBUztZQUNwQyxNQUFNb0IsU0FBUyxJQUFJcEI7WUFDbkIsTUFBTXFCLE1BQU14QixLQUFLLENBQUNHLE1BQU0sRUFBRXNCLE1BQU14QixLQUFLLENBQUNFLE1BQU0sRUFBRSxrQkFBa0I7WUFDaEUsTUFBTXVCLEtBQUtoQyxJQUFJLENBQUNTLE1BQU0sRUFBRXdCLEtBQUtoQyxJQUFJLENBQUNRLE1BQU0sRUFBRSxrQkFBa0I7WUFDNUQsTUFBTXlCLEtBQUsvQixVQUFVLENBQUNNLE1BQU0sRUFBRTBCLEtBQUs5QixVQUFVLENBQUNJLE1BQU0sRUFBRSxrQkFBa0I7WUFDeEUsSUFBSyxJQUFJakQsSUFBSSxHQUFHQSxJQUFJLElBQUlBLElBQUs7Z0JBQ3pCLE1BQU00RSxLQUFLLENBQUUsR0FBRzdGLFdBQVdtQixJQUFJLEVBQUV5RCxLQUFLWCxTQUFTQyxPQUFPWSxJQUFJRSxJQUFJRSxNQUFNWixPQUFPLENBQUNtQixFQUFFLENBQUN4RSxFQUFFLENBQUMsR0FBR3NFLEtBQUtJLEVBQUUsQ0FBQzFFLEVBQUUsSUFBSW1FLEtBQU07Z0JBQ3pHUixLQUFLUSxJQUFJQSxLQUFLRixJQUFJQSxLQUFLLENBQUMsR0FBR2xGLFdBQVdtQixJQUFJLEVBQUU2RCxJQUFJLE1BQU0sR0FBR0EsS0FBS0YsSUFBSUEsS0FBS2UsSUFBSSxrQkFBa0I7WUFDakc7WUFDQSx5QkFBeUI7WUFDekIsSUFBSyxJQUFJNUUsSUFBSSxHQUFHQSxJQUFJLElBQUlBLElBQUs7Z0JBQ3pCLE1BQU02RSxLQUFLLENBQUUsR0FBRzlGLFdBQVdtQixJQUFJLEVBQUUwRCxLQUFLWixTQUFTcUIsUUFBUVAsSUFBSUUsSUFBSUUsTUFBTWIsT0FBTyxDQUFDb0IsRUFBRSxDQUFDekUsRUFBRSxDQUFDLEdBQUd1RSxLQUFLSSxFQUFFLENBQUMzRSxFQUFFLElBQUlvRSxLQUFNO2dCQUMxR1IsS0FBS1EsSUFBSUEsS0FBS0YsSUFBSUEsS0FBSyxDQUFDLEdBQUduRixXQUFXbUIsSUFBSSxFQUFFOEQsSUFBSSxNQUFNLEdBQUdBLEtBQUtGLElBQUlBLEtBQUtlLElBQUksa0JBQWtCO1lBQ2pHO1FBQ0o7UUFDQSxxREFBcUQ7UUFDckQsSUFBSSxDQUFDakYsR0FBRyxDQUFDLElBQUssQ0FBQzJELEVBQUUsR0FBR1EsS0FBS0csS0FBTSxHQUFHLElBQUssQ0FBQ1YsRUFBRSxHQUFHUyxLQUFLRyxLQUFNLEdBQUcsSUFBSyxDQUFDWCxFQUFFLEdBQUdVLEtBQUtQLEtBQU0sR0FBRyxJQUFLLENBQUNGLEVBQUUsR0FBR0MsS0FBS0csS0FBTSxHQUFHLElBQUssQ0FBQ1IsRUFBRSxHQUFHTyxLQUFLRyxLQUFNO0lBQ3ZJO0lBQ0F4RCxhQUFhO1FBQ1IsSUFBR3pCLFdBQVcwQixLQUFLLEVBQUU0QztJQUMxQjtJQUNBM0MsVUFBVTtRQUNOLElBQUksQ0FBQ29FLFNBQVMsR0FBRztRQUNoQixJQUFHL0YsV0FBVzBCLEtBQUssRUFBRSxJQUFJLENBQUNFLE1BQU07UUFDakMsSUFBSSxDQUFDZixHQUFHLENBQUMsR0FBRyxHQUFHLEdBQUcsR0FBRztJQUN6QjtBQUNKO0FBQ0F2QixpQkFBaUIsR0FBR0c7QUFDcEI7Ozs7Q0FJQyxHQUNESCxpQkFBaUIsR0FBRyxDQUFDLEdBQUdVLFdBQVc2QixZQUFZLEVBQUUsSUFBTSxJQUFJcEMsY0FDM0Qsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xhdy13b3Jrcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9sZWdhY3kuanM/YWRhZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmlwZW1kMTYwID0gZXhwb3J0cy5SSVBFTUQxNjAgPSBleHBvcnRzLm1kNSA9IGV4cG9ydHMuTUQ1ID0gZXhwb3J0cy5zaGExID0gZXhwb3J0cy5TSEExID0gdm9pZCAwO1xuLyoqXG5cblNIQTEgKFJGQyAzMTc0KSwgTUQ1IChSRkMgMTMyMSkgYW5kIFJJUEVNRDE2MCAoUkZDIDIyODYpIGxlZ2FjeSwgd2VhayBoYXNoIGZ1bmN0aW9ucy5cbkRvbid0IHVzZSB0aGVtIGluIGEgbmV3IHByb3RvY29sLiBXaGF0IFwid2Vha1wiIG1lYW5zOlxuXG4tIENvbGxpc2lvbnMgY2FuIGJlIG1hZGUgd2l0aCAyXjE4IGVmZm9ydCBpbiBNRDUsIDJeNjAgaW4gU0hBMSwgMl44MCBpbiBSSVBFTUQxNjAuXG4tIE5vIHByYWN0aWNhbCBwcmUtaW1hZ2UgYXR0YWNrcyAob25seSB0aGVvcmV0aWNhbCwgMl4xMjMuNClcbi0gSE1BQyBzZWVtcyBraW5kYSBvazogaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM2MTUxXG4gKiBAbW9kdWxlXG4gKi9cbmNvbnN0IF9tZF90c18xID0gcmVxdWlyZShcIi4vX21kLmpzXCIpO1xuY29uc3QgdXRpbHNfdHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuLyoqIEluaXRpYWwgU0hBMSBzdGF0ZSAqL1xuY29uc3QgU0hBMV9JViA9IC8qIEBfX1BVUkVfXyAqLyBVaW50MzJBcnJheS5mcm9tKFtcbiAgICAweDY3NDUyMzAxLCAweGVmY2RhYjg5LCAweDk4YmFkY2ZlLCAweDEwMzI1NDc2LCAweGMzZDJlMWYwLFxuXSk7XG4vLyBSZXVzYWJsZSB0ZW1wb3JhcnkgYnVmZmVyXG5jb25zdCBTSEExX1cgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDgwKTtcbi8qKiBTSEExIGxlZ2FjeSBoYXNoIGNsYXNzLiAqL1xuY2xhc3MgU0hBMSBleHRlbmRzIF9tZF90c18xLkhhc2hNRCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDY0LCAyMCwgOCwgZmFsc2UpO1xuICAgICAgICB0aGlzLkEgPSBTSEExX0lWWzBdIHwgMDtcbiAgICAgICAgdGhpcy5CID0gU0hBMV9JVlsxXSB8IDA7XG4gICAgICAgIHRoaXMuQyA9IFNIQTFfSVZbMl0gfCAwO1xuICAgICAgICB0aGlzLkQgPSBTSEExX0lWWzNdIHwgMDtcbiAgICAgICAgdGhpcy5FID0gU0hBMV9JVls0XSB8IDA7XG4gICAgfVxuICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgeyBBLCBCLCBDLCBELCBFIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW0EsIEIsIEMsIEQsIEVdO1xuICAgIH1cbiAgICBzZXQoQSwgQiwgQywgRCwgRSkge1xuICAgICAgICB0aGlzLkEgPSBBIHwgMDtcbiAgICAgICAgdGhpcy5CID0gQiB8IDA7XG4gICAgICAgIHRoaXMuQyA9IEMgfCAwO1xuICAgICAgICB0aGlzLkQgPSBEIHwgMDtcbiAgICAgICAgdGhpcy5FID0gRSB8IDA7XG4gICAgfVxuICAgIHByb2Nlc3Modmlldywgb2Zmc2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpXG4gICAgICAgICAgICBTSEExX1dbaV0gPSB2aWV3LmdldFVpbnQzMihvZmZzZXQsIGZhbHNlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE2OyBpIDwgODA7IGkrKylcbiAgICAgICAgICAgIFNIQTFfV1tpXSA9ICgwLCB1dGlsc190c18xLnJvdGwpKFNIQTFfV1tpIC0gM10gXiBTSEExX1dbaSAtIDhdIF4gU0hBMV9XW2kgLSAxNF0gXiBTSEExX1dbaSAtIDE2XSwgMSk7XG4gICAgICAgIC8vIENvbXByZXNzaW9uIGZ1bmN0aW9uIG1haW4gbG9vcCwgODAgcm91bmRzXG4gICAgICAgIGxldCB7IEEsIEIsIEMsIEQsIEUgfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODA7IGkrKykge1xuICAgICAgICAgICAgbGV0IEYsIEs7XG4gICAgICAgICAgICBpZiAoaSA8IDIwKSB7XG4gICAgICAgICAgICAgICAgRiA9ICgwLCBfbWRfdHNfMS5DaGkpKEIsIEMsIEQpO1xuICAgICAgICAgICAgICAgIEsgPSAweDVhODI3OTk5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaSA8IDQwKSB7XG4gICAgICAgICAgICAgICAgRiA9IEIgXiBDIF4gRDtcbiAgICAgICAgICAgICAgICBLID0gMHg2ZWQ5ZWJhMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGkgPCA2MCkge1xuICAgICAgICAgICAgICAgIEYgPSAoMCwgX21kX3RzXzEuTWFqKShCLCBDLCBEKTtcbiAgICAgICAgICAgICAgICBLID0gMHg4ZjFiYmNkYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIEYgPSBCIF4gQyBeIEQ7XG4gICAgICAgICAgICAgICAgSyA9IDB4Y2E2MmMxZDY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBUID0gKCgwLCB1dGlsc190c18xLnJvdGwpKEEsIDUpICsgRiArIEUgKyBLICsgU0hBMV9XW2ldKSB8IDA7XG4gICAgICAgICAgICBFID0gRDtcbiAgICAgICAgICAgIEQgPSBDO1xuICAgICAgICAgICAgQyA9ICgwLCB1dGlsc190c18xLnJvdGwpKEIsIDMwKTtcbiAgICAgICAgICAgIEIgPSBBO1xuICAgICAgICAgICAgQSA9IFQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBjb21wcmVzc2VkIGNodW5rIHRvIHRoZSBjdXJyZW50IGhhc2ggdmFsdWVcbiAgICAgICAgQSA9IChBICsgdGhpcy5BKSB8IDA7XG4gICAgICAgIEIgPSAoQiArIHRoaXMuQikgfCAwO1xuICAgICAgICBDID0gKEMgKyB0aGlzLkMpIHwgMDtcbiAgICAgICAgRCA9IChEICsgdGhpcy5EKSB8IDA7XG4gICAgICAgIEUgPSAoRSArIHRoaXMuRSkgfCAwO1xuICAgICAgICB0aGlzLnNldChBLCBCLCBDLCBELCBFKTtcbiAgICB9XG4gICAgcm91bmRDbGVhbigpIHtcbiAgICAgICAgKDAsIHV0aWxzX3RzXzEuY2xlYW4pKFNIQTFfVyk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDApO1xuICAgICAgICAoMCwgdXRpbHNfdHNfMS5jbGVhbikodGhpcy5idWZmZXIpO1xuICAgIH1cbn1cbmV4cG9ydHMuU0hBMSA9IFNIQTE7XG4vKiogU0hBMSAoUkZDIDMxNzQpIGxlZ2FjeSBoYXNoIGZ1bmN0aW9uLiBJdCB3YXMgY3J5cHRvZ3JhcGhpY2FsbHkgYnJva2VuLiAqL1xuZXhwb3J0cy5zaGExID0gKDAsIHV0aWxzX3RzXzEuY3JlYXRlSGFzaGVyKSgoKSA9PiBuZXcgU0hBMSgpKTtcbi8qKiBQZXItcm91bmQgY29uc3RhbnRzICovXG5jb25zdCBwMzIgPSAvKiBAX19QVVJFX18gKi8gTWF0aC5wb3coMiwgMzIpO1xuY29uc3QgSyA9IC8qIEBfX1BVUkVfXyAqLyBBcnJheS5mcm9tKHsgbGVuZ3RoOiA2NCB9LCAoXywgaSkgPT4gTWF0aC5mbG9vcihwMzIgKiBNYXRoLmFicyhNYXRoLnNpbihpICsgMSkpKSk7XG4vKiogbWQ1IGluaXRpYWwgc3RhdGU6IHNhbWUgYXMgc2hhMSwgYnV0IDQgdTMyIGluc3RlYWQgb2YgNS4gKi9cbmNvbnN0IE1ENV9JViA9IC8qIEBfX1BVUkVfXyAqLyBTSEExX0lWLnNsaWNlKDAsIDQpO1xuLy8gUmV1c2FibGUgdGVtcG9yYXJ5IGJ1ZmZlclxuY29uc3QgTUQ1X1cgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDE2KTtcbi8qKiBNRDUgbGVnYWN5IGhhc2ggY2xhc3MuICovXG5jbGFzcyBNRDUgZXh0ZW5kcyBfbWRfdHNfMS5IYXNoTUQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcig2NCwgMTYsIDgsIHRydWUpO1xuICAgICAgICB0aGlzLkEgPSBNRDVfSVZbMF0gfCAwO1xuICAgICAgICB0aGlzLkIgPSBNRDVfSVZbMV0gfCAwO1xuICAgICAgICB0aGlzLkMgPSBNRDVfSVZbMl0gfCAwO1xuICAgICAgICB0aGlzLkQgPSBNRDVfSVZbM10gfCAwO1xuICAgIH1cbiAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IHsgQSwgQiwgQywgRCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFtBLCBCLCBDLCBEXTtcbiAgICB9XG4gICAgc2V0KEEsIEIsIEMsIEQpIHtcbiAgICAgICAgdGhpcy5BID0gQSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IEIgfCAwO1xuICAgICAgICB0aGlzLkMgPSBDIHwgMDtcbiAgICAgICAgdGhpcy5EID0gRCB8IDA7XG4gICAgfVxuICAgIHByb2Nlc3Modmlldywgb2Zmc2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpXG4gICAgICAgICAgICBNRDVfV1tpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCwgdHJ1ZSk7XG4gICAgICAgIC8vIENvbXByZXNzaW9uIGZ1bmN0aW9uIG1haW4gbG9vcCwgNjQgcm91bmRzXG4gICAgICAgIGxldCB7IEEsIEIsIEMsIEQgfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgbGV0IEYsIGcsIHM7XG4gICAgICAgICAgICBpZiAoaSA8IDE2KSB7XG4gICAgICAgICAgICAgICAgRiA9ICgwLCBfbWRfdHNfMS5DaGkpKEIsIEMsIEQpO1xuICAgICAgICAgICAgICAgIGcgPSBpO1xuICAgICAgICAgICAgICAgIHMgPSBbNywgMTIsIDE3LCAyMl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpIDwgMzIpIHtcbiAgICAgICAgICAgICAgICBGID0gKDAsIF9tZF90c18xLkNoaSkoRCwgQiwgQyk7XG4gICAgICAgICAgICAgICAgZyA9ICg1ICogaSArIDEpICUgMTY7XG4gICAgICAgICAgICAgICAgcyA9IFs1LCA5LCAxNCwgMjBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaSA8IDQ4KSB7XG4gICAgICAgICAgICAgICAgRiA9IEIgXiBDIF4gRDtcbiAgICAgICAgICAgICAgICBnID0gKDMgKiBpICsgNSkgJSAxNjtcbiAgICAgICAgICAgICAgICBzID0gWzQsIDExLCAxNiwgMjNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgRiA9IEMgXiAoQiB8IH5EKTtcbiAgICAgICAgICAgICAgICBnID0gKDcgKiBpKSAlIDE2O1xuICAgICAgICAgICAgICAgIHMgPSBbNiwgMTAsIDE1LCAyMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBGID0gRiArIEEgKyBLW2ldICsgTUQ1X1dbZ107XG4gICAgICAgICAgICBBID0gRDtcbiAgICAgICAgICAgIEQgPSBDO1xuICAgICAgICAgICAgQyA9IEI7XG4gICAgICAgICAgICBCID0gQiArICgwLCB1dGlsc190c18xLnJvdGwpKEYsIHNbaSAlIDRdKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICBBID0gKEEgKyB0aGlzLkEpIHwgMDtcbiAgICAgICAgQiA9IChCICsgdGhpcy5CKSB8IDA7XG4gICAgICAgIEMgPSAoQyArIHRoaXMuQykgfCAwO1xuICAgICAgICBEID0gKEQgKyB0aGlzLkQpIHwgMDtcbiAgICAgICAgdGhpcy5zZXQoQSwgQiwgQywgRCk7XG4gICAgfVxuICAgIHJvdW5kQ2xlYW4oKSB7XG4gICAgICAgICgwLCB1dGlsc190c18xLmNsZWFuKShNRDVfVyk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDApO1xuICAgICAgICAoMCwgdXRpbHNfdHNfMS5jbGVhbikodGhpcy5idWZmZXIpO1xuICAgIH1cbn1cbmV4cG9ydHMuTUQ1ID0gTUQ1O1xuLyoqXG4gKiBNRDUgKFJGQyAxMzIxKSBsZWdhY3kgaGFzaCBmdW5jdGlvbi4gSXQgd2FzIGNyeXB0b2dyYXBoaWNhbGx5IGJyb2tlbi5cbiAqIE1ENSBhcmNoaXRlY3R1cmUgaXMgc2ltaWxhciB0byBTSEExLCB3aXRoIHNvbWUgZGlmZmVyZW5jZXM6XG4gKiAtIFJlZHVjZWQgb3V0cHV0IGxlbmd0aDogMTYgYnl0ZXMgKDEyOCBiaXQpIGluc3RlYWQgb2YgMjBcbiAqIC0gNjQgcm91bmRzLCBpbnN0ZWFkIG9mIDgwXG4gKiAtIExpdHRsZS1lbmRpYW46IGNvdWxkIGJlIGZhc3RlciwgYnV0IHdpbGwgcmVxdWlyZSBtb3JlIGNvZGVcbiAqIC0gTm9uLWxpbmVhciBpbmRleCBzZWxlY3Rpb246IGh1Z2Ugc3BlZWQtdXAgZm9yIHVucm9sbFxuICogLSBQZXIgcm91bmQgY29uc3RhbnRzOiBtb3JlIG1lbW9yeSBhY2Nlc3NlcywgYWRkaXRpb25hbCBzcGVlZC11cCBmb3IgdW5yb2xsXG4gKi9cbmV4cG9ydHMubWQ1ID0gKDAsIHV0aWxzX3RzXzEuY3JlYXRlSGFzaGVyKSgoKSA9PiBuZXcgTUQ1KCkpO1xuLy8gUklQRU1ELTE2MFxuY29uc3QgUmhvMTYwID0gLyogQF9fUFVSRV9fICovIFVpbnQ4QXJyYXkuZnJvbShbXG4gICAgNywgNCwgMTMsIDEsIDEwLCA2LCAxNSwgMywgMTIsIDAsIDksIDUsIDIsIDE0LCAxMSwgOCxcbl0pO1xuY29uc3QgSWQxNjAgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IFVpbnQ4QXJyYXkuZnJvbShuZXcgQXJyYXkoMTYpLmZpbGwoMCkubWFwKChfLCBpKSA9PiBpKSkpKCk7XG5jb25zdCBQaTE2MCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gSWQxNjAubWFwKChpKSA9PiAoOSAqIGkgKyA1KSAlIDE2KSkoKTtcbmNvbnN0IGlkeExSID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB7XG4gICAgY29uc3QgTCA9IFtJZDE2MF07XG4gICAgY29uc3QgUiA9IFtQaTE2MF07XG4gICAgY29uc3QgcmVzID0gW0wsIFJdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKVxuICAgICAgICBmb3IgKGxldCBqIG9mIHJlcylcbiAgICAgICAgICAgIGoucHVzaChqW2ldLm1hcCgoaykgPT4gUmhvMTYwW2tdKSk7XG4gICAgcmV0dXJuIHJlcztcbn0pKCk7XG5jb25zdCBpZHhMID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBpZHhMUlswXSkoKTtcbmNvbnN0IGlkeFIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGlkeExSWzFdKSgpO1xuLy8gY29uc3QgW2lkeEwsIGlkeFJdID0gaWR4TFI7XG5jb25zdCBzaGlmdHMxNjAgPSAvKiBAX19QVVJFX18gKi8gW1xuICAgIFsxMSwgMTQsIDE1LCAxMiwgNSwgOCwgNywgOSwgMTEsIDEzLCAxNCwgMTUsIDYsIDcsIDksIDhdLFxuICAgIFsxMiwgMTMsIDExLCAxNSwgNiwgOSwgOSwgNywgMTIsIDE1LCAxMSwgMTMsIDcsIDgsIDcsIDddLFxuICAgIFsxMywgMTUsIDE0LCAxMSwgNywgNywgNiwgOCwgMTMsIDE0LCAxMywgMTIsIDUsIDUsIDYsIDldLFxuICAgIFsxNCwgMTEsIDEyLCAxNCwgOCwgNiwgNSwgNSwgMTUsIDEyLCAxNSwgMTQsIDksIDksIDgsIDZdLFxuICAgIFsxNSwgMTIsIDEzLCAxMywgOSwgNSwgOCwgNiwgMTQsIDExLCAxMiwgMTEsIDgsIDYsIDUsIDVdLFxuXS5tYXAoKGkpID0+IFVpbnQ4QXJyYXkuZnJvbShpKSk7XG5jb25zdCBzaGlmdHNMMTYwID0gLyogQF9fUFVSRV9fICovIGlkeEwubWFwKChpZHgsIGkpID0+IGlkeC5tYXAoKGopID0+IHNoaWZ0czE2MFtpXVtqXSkpO1xuY29uc3Qgc2hpZnRzUjE2MCA9IC8qIEBfX1BVUkVfXyAqLyBpZHhSLm1hcCgoaWR4LCBpKSA9PiBpZHgubWFwKChqKSA9PiBzaGlmdHMxNjBbaV1bal0pKTtcbmNvbnN0IEtsMTYwID0gLyogQF9fUFVSRV9fICovIFVpbnQzMkFycmF5LmZyb20oW1xuICAgIDB4MDAwMDAwMDAsIDB4NWE4Mjc5OTksIDB4NmVkOWViYTEsIDB4OGYxYmJjZGMsIDB4YTk1M2ZkNGUsXG5dKTtcbmNvbnN0IEtyMTYwID0gLyogQF9fUFVSRV9fICovIFVpbnQzMkFycmF5LmZyb20oW1xuICAgIDB4NTBhMjhiZTYsIDB4NWM0ZGQxMjQsIDB4NmQ3MDNlZjMsIDB4N2E2ZDc2ZTksIDB4MDAwMDAwMDAsXG5dKTtcbi8vIEl0J3MgY2FsbGVkIGYoKSBpbiBzcGVjLlxuZnVuY3Rpb24gcmlwZW1kX2YoZ3JvdXAsIHgsIHksIHopIHtcbiAgICBpZiAoZ3JvdXAgPT09IDApXG4gICAgICAgIHJldHVybiB4IF4geSBeIHo7XG4gICAgaWYgKGdyb3VwID09PSAxKVxuICAgICAgICByZXR1cm4gKHggJiB5KSB8ICh+eCAmIHopO1xuICAgIGlmIChncm91cCA9PT0gMilcbiAgICAgICAgcmV0dXJuICh4IHwgfnkpIF4gejtcbiAgICBpZiAoZ3JvdXAgPT09IDMpXG4gICAgICAgIHJldHVybiAoeCAmIHopIHwgKHkgJiB+eik7XG4gICAgcmV0dXJuIHggXiAoeSB8IH56KTtcbn1cbi8vIFJldXNhYmxlIHRlbXBvcmFyeSBidWZmZXJcbmNvbnN0IEJVRl8xNjAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDE2KTtcbmNsYXNzIFJJUEVNRDE2MCBleHRlbmRzIF9tZF90c18xLkhhc2hNRCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDY0LCAyMCwgOCwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuaDAgPSAweDY3NDUyMzAxIHwgMDtcbiAgICAgICAgdGhpcy5oMSA9IDB4ZWZjZGFiODkgfCAwO1xuICAgICAgICB0aGlzLmgyID0gMHg5OGJhZGNmZSB8IDA7XG4gICAgICAgIHRoaXMuaDMgPSAweDEwMzI1NDc2IHwgMDtcbiAgICAgICAgdGhpcy5oNCA9IDB4YzNkMmUxZjAgfCAwO1xuICAgIH1cbiAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IHsgaDAsIGgxLCBoMiwgaDMsIGg0IH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW2gwLCBoMSwgaDIsIGgzLCBoNF07XG4gICAgfVxuICAgIHNldChoMCwgaDEsIGgyLCBoMywgaDQpIHtcbiAgICAgICAgdGhpcy5oMCA9IGgwIHwgMDtcbiAgICAgICAgdGhpcy5oMSA9IGgxIHwgMDtcbiAgICAgICAgdGhpcy5oMiA9IGgyIHwgMDtcbiAgICAgICAgdGhpcy5oMyA9IGgzIHwgMDtcbiAgICAgICAgdGhpcy5oNCA9IGg0IHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNClcbiAgICAgICAgICAgIEJVRl8xNjBbaV0gPSB2aWV3LmdldFVpbnQzMihvZmZzZXQsIHRydWUpO1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgbGV0IGFsID0gdGhpcy5oMCB8IDAsIGFyID0gYWwsIGJsID0gdGhpcy5oMSB8IDAsIGJyID0gYmwsIGNsID0gdGhpcy5oMiB8IDAsIGNyID0gY2wsIGRsID0gdGhpcy5oMyB8IDAsIGRyID0gZGwsIGVsID0gdGhpcy5oNCB8IDAsIGVyID0gZWw7XG4gICAgICAgIC8vIEluc3RlYWQgb2YgaXRlcmF0aW5nIDAgdG8gODAsIHdlIHNwbGl0IGl0IGludG8gNSBncm91cHNcbiAgICAgICAgLy8gQW5kIHVzZSB0aGUgZ3JvdXBzIGluIGNvbnN0YW50cywgZnVuY3Rpb25zLCBldGMuIE11Y2ggc2ltcGxlclxuICAgICAgICBmb3IgKGxldCBncm91cCA9IDA7IGdyb3VwIDwgNTsgZ3JvdXArKykge1xuICAgICAgICAgICAgY29uc3Qgckdyb3VwID0gNCAtIGdyb3VwO1xuICAgICAgICAgICAgY29uc3QgaGJsID0gS2wxNjBbZ3JvdXBdLCBoYnIgPSBLcjE2MFtncm91cF07IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgcmwgPSBpZHhMW2dyb3VwXSwgcnIgPSBpZHhSW2dyb3VwXTsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBjb25zdCBzbCA9IHNoaWZ0c0wxNjBbZ3JvdXBdLCBzciA9IHNoaWZ0c1IxNjBbZ3JvdXBdOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRsID0gKCgwLCB1dGlsc190c18xLnJvdGwpKGFsICsgcmlwZW1kX2YoZ3JvdXAsIGJsLCBjbCwgZGwpICsgQlVGXzE2MFtybFtpXV0gKyBoYmwsIHNsW2ldKSArIGVsKSB8IDA7XG4gICAgICAgICAgICAgICAgYWwgPSBlbCwgZWwgPSBkbCwgZGwgPSAoMCwgdXRpbHNfdHNfMS5yb3RsKShjbCwgMTApIHwgMCwgY2wgPSBibCwgYmwgPSB0bDsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyAyIGxvb3BzIGFyZSAxMCUgZmFzdGVyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ciA9ICgoMCwgdXRpbHNfdHNfMS5yb3RsKShhciArIHJpcGVtZF9mKHJHcm91cCwgYnIsIGNyLCBkcikgKyBCVUZfMTYwW3JyW2ldXSArIGhiciwgc3JbaV0pICsgZXIpIHwgMDtcbiAgICAgICAgICAgICAgICBhciA9IGVyLCBlciA9IGRyLCBkciA9ICgwLCB1dGlsc190c18xLnJvdGwpKGNyLCAxMCkgfCAwLCBjciA9IGJyLCBiciA9IHRyOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICB0aGlzLnNldCgodGhpcy5oMSArIGNsICsgZHIpIHwgMCwgKHRoaXMuaDIgKyBkbCArIGVyKSB8IDAsICh0aGlzLmgzICsgZWwgKyBhcikgfCAwLCAodGhpcy5oNCArIGFsICsgYnIpIHwgMCwgKHRoaXMuaDAgKyBibCArIGNyKSB8IDApO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICAoMCwgdXRpbHNfdHNfMS5jbGVhbikoQlVGXzE2MCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgKDAsIHV0aWxzX3RzXzEuY2xlYW4pKHRoaXMuYnVmZmVyKTtcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCk7XG4gICAgfVxufVxuZXhwb3J0cy5SSVBFTUQxNjAgPSBSSVBFTUQxNjA7XG4vKipcbiAqIFJJUEVNRC0xNjAgLSBhIGxlZ2FjeSBoYXNoIGZ1bmN0aW9uIGZyb20gMTk5MHMuXG4gKiAqIGh0dHBzOi8vaG9tZXMuZXNhdC5rdWxldXZlbi5iZS9+Ym9zc2VsYWUvcmlwZW1kMTYwLmh0bWxcbiAqICogaHR0cHM6Ly9ob21lcy5lc2F0Lmt1bGV1dmVuLmJlL35ib3NzZWxhZS9yaXBlbWQxNjAvcGRmL0FCLTk2MDEvQUItOTYwMS5wZGZcbiAqL1xuZXhwb3J0cy5yaXBlbWQxNjAgPSAoMCwgdXRpbHNfdHNfMS5jcmVhdGVIYXNoZXIpKCgpID0+IG5ldyBSSVBFTUQxNjAoKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sZWdhY3kuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwicmlwZW1kMTYwIiwiUklQRU1EMTYwIiwibWQ1IiwiTUQ1Iiwic2hhMSIsIlNIQTEiLCJfbWRfdHNfMSIsInJlcXVpcmUiLCJ1dGlsc190c18xIiwiU0hBMV9JViIsIlVpbnQzMkFycmF5IiwiZnJvbSIsIlNIQTFfVyIsIkhhc2hNRCIsImNvbnN0cnVjdG9yIiwiQSIsIkIiLCJDIiwiRCIsIkUiLCJnZXQiLCJzZXQiLCJwcm9jZXNzIiwidmlldyIsIm9mZnNldCIsImkiLCJnZXRVaW50MzIiLCJyb3RsIiwiRiIsIksiLCJDaGkiLCJNYWoiLCJUIiwicm91bmRDbGVhbiIsImNsZWFuIiwiZGVzdHJveSIsImJ1ZmZlciIsImNyZWF0ZUhhc2hlciIsInAzMiIsIk1hdGgiLCJwb3ciLCJBcnJheSIsImxlbmd0aCIsIl8iLCJmbG9vciIsImFicyIsInNpbiIsIk1ENV9JViIsInNsaWNlIiwiTUQ1X1ciLCJnIiwicyIsIlJobzE2MCIsIlVpbnQ4QXJyYXkiLCJJZDE2MCIsImZpbGwiLCJtYXAiLCJQaTE2MCIsImlkeExSIiwiTCIsIlIiLCJyZXMiLCJqIiwicHVzaCIsImsiLCJpZHhMIiwiaWR4UiIsInNoaWZ0czE2MCIsInNoaWZ0c0wxNjAiLCJpZHgiLCJzaGlmdHNSMTYwIiwiS2wxNjAiLCJLcjE2MCIsInJpcGVtZF9mIiwiZ3JvdXAiLCJ4IiwieSIsInoiLCJCVUZfMTYwIiwiaDAiLCJoMSIsImgyIiwiaDMiLCJoNCIsImFsIiwiYXIiLCJibCIsImJyIiwiY2wiLCJjciIsImRsIiwiZHIiLCJlbCIsImVyIiwickdyb3VwIiwiaGJsIiwiaGJyIiwicmwiLCJyciIsInNsIiwic3IiLCJ0bCIsInRyIiwiZGVzdHJveWVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/@noble/hashes/legacy.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/@noble/hashes/ripemd160.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ox/node_modules/@noble/hashes/ripemd160.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ripemd160 = exports.RIPEMD160 = void 0;\n/**\n * RIPEMD-160 legacy hash function.\n * https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n * https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\n * @module\n * @deprecated\n */ const legacy_ts_1 = __webpack_require__(/*! ./legacy.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/legacy.js\");\n/** @deprecated Use import from `noble/hashes/legacy` module */ exports.RIPEMD160 = legacy_ts_1.RIPEMD160;\n/** @deprecated Use import from `noble/hashes/legacy` module */ exports.ripemd160 = legacy_ts_1.ripemd160; //# sourceMappingURL=ripemd160.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvcmlwZW1kMTYwLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxpQkFBaUIsR0FBR0EsaUJBQWlCLEdBQUcsS0FBSztBQUM3Qzs7Ozs7O0NBTUMsR0FDRCxNQUFNSSxjQUFjQyxtQkFBT0EsQ0FBQyxpRkFBYTtBQUN6Qyw2REFBNkQsR0FDN0RMLGlCQUFpQixHQUFHSSxZQUFZRCxTQUFTO0FBQ3pDLDZEQUE2RCxHQUM3REgsaUJBQWlCLEdBQUdJLFlBQVlGLFNBQVMsRUFDekMscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xhdy13b3Jrcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9yaXBlbWQxNjAuanM/NTM1MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmlwZW1kMTYwID0gZXhwb3J0cy5SSVBFTUQxNjAgPSB2b2lkIDA7XG4vKipcbiAqIFJJUEVNRC0xNjAgbGVnYWN5IGhhc2ggZnVuY3Rpb24uXG4gKiBodHRwczovL2hvbWVzLmVzYXQua3VsZXV2ZW4uYmUvfmJvc3NlbGFlL3JpcGVtZDE2MC5odG1sXG4gKiBodHRwczovL2hvbWVzLmVzYXQua3VsZXV2ZW4uYmUvfmJvc3NlbGFlL3JpcGVtZDE2MC9wZGYvQUItOTYwMS9BQi05NjAxLnBkZlxuICogQG1vZHVsZVxuICogQGRlcHJlY2F0ZWRcbiAqL1xuY29uc3QgbGVnYWN5X3RzXzEgPSByZXF1aXJlKFwiLi9sZWdhY3kuanNcIik7XG4vKiogQGRlcHJlY2F0ZWQgVXNlIGltcG9ydCBmcm9tIGBub2JsZS9oYXNoZXMvbGVnYWN5YCBtb2R1bGUgKi9cbmV4cG9ydHMuUklQRU1EMTYwID0gbGVnYWN5X3RzXzEuUklQRU1EMTYwO1xuLyoqIEBkZXByZWNhdGVkIFVzZSBpbXBvcnQgZnJvbSBgbm9ibGUvaGFzaGVzL2xlZ2FjeWAgbW9kdWxlICovXG5leHBvcnRzLnJpcGVtZDE2MCA9IGxlZ2FjeV90c18xLnJpcGVtZDE2MDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJpcGVtZDE2MC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJyaXBlbWQxNjAiLCJSSVBFTUQxNjAiLCJsZWdhY3lfdHNfMSIsInJlcXVpcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/@noble/hashes/ripemd160.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/@noble/hashes/sha2.js":
/*!************************************************************!*\
  !*** ./node_modules/ox/node_modules/@noble/hashes/sha2.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.sha512_224 = exports.sha512_256 = exports.sha384 = exports.sha512 = exports.sha224 = exports.sha256 = exports.SHA512_256 = exports.SHA512_224 = exports.SHA384 = exports.SHA512 = exports.SHA224 = exports.SHA256 = void 0;\n/**\n * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.\n * SHA256 is the fastest hash implementable in JS, even faster than Blake3.\n * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and\n * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n */ const _md_ts_1 = __webpack_require__(/*! ./_md.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/_md.js\");\nconst u64 = __webpack_require__(/*! ./_u64.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/_u64.js\");\nconst utils_ts_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/utils.js\");\n/**\n * Round constants:\n * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)\n */ // prettier-ignore\nconst SHA256_K = /* @__PURE__ */ Uint32Array.from([\n    0x428a2f98,\n    0x71374491,\n    0xb5c0fbcf,\n    0xe9b5dba5,\n    0x3956c25b,\n    0x59f111f1,\n    0x923f82a4,\n    0xab1c5ed5,\n    0xd807aa98,\n    0x12835b01,\n    0x243185be,\n    0x550c7dc3,\n    0x72be5d74,\n    0x80deb1fe,\n    0x9bdc06a7,\n    0xc19bf174,\n    0xe49b69c1,\n    0xefbe4786,\n    0x0fc19dc6,\n    0x240ca1cc,\n    0x2de92c6f,\n    0x4a7484aa,\n    0x5cb0a9dc,\n    0x76f988da,\n    0x983e5152,\n    0xa831c66d,\n    0xb00327c8,\n    0xbf597fc7,\n    0xc6e00bf3,\n    0xd5a79147,\n    0x06ca6351,\n    0x14292967,\n    0x27b70a85,\n    0x2e1b2138,\n    0x4d2c6dfc,\n    0x53380d13,\n    0x650a7354,\n    0x766a0abb,\n    0x81c2c92e,\n    0x92722c85,\n    0xa2bfe8a1,\n    0xa81a664b,\n    0xc24b8b70,\n    0xc76c51a3,\n    0xd192e819,\n    0xd6990624,\n    0xf40e3585,\n    0x106aa070,\n    0x19a4c116,\n    0x1e376c08,\n    0x2748774c,\n    0x34b0bcb5,\n    0x391c0cb3,\n    0x4ed8aa4a,\n    0x5b9cca4f,\n    0x682e6ff3,\n    0x748f82ee,\n    0x78a5636f,\n    0x84c87814,\n    0x8cc70208,\n    0x90befffa,\n    0xa4506ceb,\n    0xbef9a3f7,\n    0xc67178f2\n]);\n/** Reusable temporary buffer. \"W\" comes straight from spec. */ const SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _md_ts_1.HashMD {\n    constructor(outputLen = 32){\n        super(64, outputLen, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = _md_ts_1.SHA256_IV[0] | 0;\n        this.B = _md_ts_1.SHA256_IV[1] | 0;\n        this.C = _md_ts_1.SHA256_IV[2] | 0;\n        this.D = _md_ts_1.SHA256_IV[3] | 0;\n        this.E = _md_ts_1.SHA256_IV[4] | 0;\n        this.F = _md_ts_1.SHA256_IV[5] | 0;\n        this.G = _md_ts_1.SHA256_IV[6] | 0;\n        this.H = _md_ts_1.SHA256_IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [\n            A,\n            B,\n            C,\n            D,\n            E,\n            F,\n            G,\n            H\n        ];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for(let i = 0; i < 16; i++, offset += 4)SHA256_W[i] = view.getUint32(offset, false);\n        for(let i = 16; i < 64; i++){\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0, utils_ts_1.rotr)(W15, 7) ^ (0, utils_ts_1.rotr)(W15, 18) ^ W15 >>> 3;\n            const s1 = (0, utils_ts_1.rotr)(W2, 17) ^ (0, utils_ts_1.rotr)(W2, 19) ^ W2 >>> 10;\n            SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for(let i = 0; i < 64; i++){\n            const sigma1 = (0, utils_ts_1.rotr)(E, 6) ^ (0, utils_ts_1.rotr)(E, 11) ^ (0, utils_ts_1.rotr)(E, 25);\n            const T1 = H + sigma1 + (0, _md_ts_1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;\n            const sigma0 = (0, utils_ts_1.rotr)(A, 2) ^ (0, utils_ts_1.rotr)(A, 13) ^ (0, utils_ts_1.rotr)(A, 22);\n            const T2 = sigma0 + (0, _md_ts_1.Maj)(A, B, C) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = D + T1 | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = T1 + T2 | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = A + this.A | 0;\n        B = B + this.B | 0;\n        C = C + this.C | 0;\n        D = D + this.D | 0;\n        E = E + this.E | 0;\n        F = F + this.F | 0;\n        G = G + this.G | 0;\n        H = H + this.H | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        (0, utils_ts_1.clean)(SHA256_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        (0, utils_ts_1.clean)(this.buffer);\n    }\n}\nexports.SHA256 = SHA256;\nclass SHA224 extends SHA256 {\n    constructor(){\n        super(28);\n        this.A = _md_ts_1.SHA224_IV[0] | 0;\n        this.B = _md_ts_1.SHA224_IV[1] | 0;\n        this.C = _md_ts_1.SHA224_IV[2] | 0;\n        this.D = _md_ts_1.SHA224_IV[3] | 0;\n        this.E = _md_ts_1.SHA224_IV[4] | 0;\n        this.F = _md_ts_1.SHA224_IV[5] | 0;\n        this.G = _md_ts_1.SHA224_IV[6] | 0;\n        this.H = _md_ts_1.SHA224_IV[7] | 0;\n    }\n}\nexports.SHA224 = SHA224;\n// SHA2-512 is slower than sha256 in js because u64 operations are slow.\n// Round contants\n// First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409\n// prettier-ignore\nconst K512 = /* @__PURE__ */ (()=>u64.split([\n        \"0x428a2f98d728ae22\",\n        \"0x7137449123ef65cd\",\n        \"0xb5c0fbcfec4d3b2f\",\n        \"0xe9b5dba58189dbbc\",\n        \"0x3956c25bf348b538\",\n        \"0x59f111f1b605d019\",\n        \"0x923f82a4af194f9b\",\n        \"0xab1c5ed5da6d8118\",\n        \"0xd807aa98a3030242\",\n        \"0x12835b0145706fbe\",\n        \"0x243185be4ee4b28c\",\n        \"0x550c7dc3d5ffb4e2\",\n        \"0x72be5d74f27b896f\",\n        \"0x80deb1fe3b1696b1\",\n        \"0x9bdc06a725c71235\",\n        \"0xc19bf174cf692694\",\n        \"0xe49b69c19ef14ad2\",\n        \"0xefbe4786384f25e3\",\n        \"0x0fc19dc68b8cd5b5\",\n        \"0x240ca1cc77ac9c65\",\n        \"0x2de92c6f592b0275\",\n        \"0x4a7484aa6ea6e483\",\n        \"0x5cb0a9dcbd41fbd4\",\n        \"0x76f988da831153b5\",\n        \"0x983e5152ee66dfab\",\n        \"0xa831c66d2db43210\",\n        \"0xb00327c898fb213f\",\n        \"0xbf597fc7beef0ee4\",\n        \"0xc6e00bf33da88fc2\",\n        \"0xd5a79147930aa725\",\n        \"0x06ca6351e003826f\",\n        \"0x142929670a0e6e70\",\n        \"0x27b70a8546d22ffc\",\n        \"0x2e1b21385c26c926\",\n        \"0x4d2c6dfc5ac42aed\",\n        \"0x53380d139d95b3df\",\n        \"0x650a73548baf63de\",\n        \"0x766a0abb3c77b2a8\",\n        \"0x81c2c92e47edaee6\",\n        \"0x92722c851482353b\",\n        \"0xa2bfe8a14cf10364\",\n        \"0xa81a664bbc423001\",\n        \"0xc24b8b70d0f89791\",\n        \"0xc76c51a30654be30\",\n        \"0xd192e819d6ef5218\",\n        \"0xd69906245565a910\",\n        \"0xf40e35855771202a\",\n        \"0x106aa07032bbd1b8\",\n        \"0x19a4c116b8d2d0c8\",\n        \"0x1e376c085141ab53\",\n        \"0x2748774cdf8eeb99\",\n        \"0x34b0bcb5e19b48a8\",\n        \"0x391c0cb3c5c95a63\",\n        \"0x4ed8aa4ae3418acb\",\n        \"0x5b9cca4f7763e373\",\n        \"0x682e6ff3d6b2b8a3\",\n        \"0x748f82ee5defb2fc\",\n        \"0x78a5636f43172f60\",\n        \"0x84c87814a1f0ab72\",\n        \"0x8cc702081a6439ec\",\n        \"0x90befffa23631e28\",\n        \"0xa4506cebde82bde9\",\n        \"0xbef9a3f7b2c67915\",\n        \"0xc67178f2e372532b\",\n        \"0xca273eceea26619c\",\n        \"0xd186b8c721c0c207\",\n        \"0xeada7dd6cde0eb1e\",\n        \"0xf57d4f7fee6ed178\",\n        \"0x06f067aa72176fba\",\n        \"0x0a637dc5a2c898a6\",\n        \"0x113f9804bef90dae\",\n        \"0x1b710b35131c471b\",\n        \"0x28db77f523047d84\",\n        \"0x32caab7b40c72493\",\n        \"0x3c9ebe0a15c9bebc\",\n        \"0x431d67c49c100d4c\",\n        \"0x4cc5d4becb3e42b6\",\n        \"0x597f299cfc657e2a\",\n        \"0x5fcb6fab3ad6faec\",\n        \"0x6c44198c4a475817\"\n    ].map((n)=>BigInt(n))))();\nconst SHA512_Kh = /* @__PURE__ */ (()=>K512[0])();\nconst SHA512_Kl = /* @__PURE__ */ (()=>K512[1])();\n// Reusable temporary buffers\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nclass SHA512 extends _md_ts_1.HashMD {\n    constructor(outputLen = 64){\n        super(128, outputLen, 16, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = _md_ts_1.SHA512_IV[0] | 0;\n        this.Al = _md_ts_1.SHA512_IV[1] | 0;\n        this.Bh = _md_ts_1.SHA512_IV[2] | 0;\n        this.Bl = _md_ts_1.SHA512_IV[3] | 0;\n        this.Ch = _md_ts_1.SHA512_IV[4] | 0;\n        this.Cl = _md_ts_1.SHA512_IV[5] | 0;\n        this.Dh = _md_ts_1.SHA512_IV[6] | 0;\n        this.Dl = _md_ts_1.SHA512_IV[7] | 0;\n        this.Eh = _md_ts_1.SHA512_IV[8] | 0;\n        this.El = _md_ts_1.SHA512_IV[9] | 0;\n        this.Fh = _md_ts_1.SHA512_IV[10] | 0;\n        this.Fl = _md_ts_1.SHA512_IV[11] | 0;\n        this.Gh = _md_ts_1.SHA512_IV[12] | 0;\n        this.Gl = _md_ts_1.SHA512_IV[13] | 0;\n        this.Hh = _md_ts_1.SHA512_IV[14] | 0;\n        this.Hl = _md_ts_1.SHA512_IV[15] | 0;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [\n            Ah,\n            Al,\n            Bh,\n            Bl,\n            Ch,\n            Cl,\n            Dh,\n            Dl,\n            Eh,\n            El,\n            Fh,\n            Fl,\n            Gh,\n            Gl,\n            Hh,\n            Hl\n        ];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for(let i = 0; i < 16; i++, offset += 4){\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32(offset += 4);\n        }\n        for(let i = 16; i < 80; i++){\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n            const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n            const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for(let i = 0; i < 80; i++){\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n            const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = Eh & Fh ^ ~Eh & Gh;\n            const CHIl = El & Fl ^ ~El & Gl;\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n            const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n            const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;\n            const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = u64.add3L(T1l, sigma0l, MAJl);\n            Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        (0, utils_ts_1.clean)(SHA512_W_H, SHA512_W_L);\n    }\n    destroy() {\n        (0, utils_ts_1.clean)(this.buffer);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nexports.SHA512 = SHA512;\nclass SHA384 extends SHA512 {\n    constructor(){\n        super(48);\n        this.Ah = _md_ts_1.SHA384_IV[0] | 0;\n        this.Al = _md_ts_1.SHA384_IV[1] | 0;\n        this.Bh = _md_ts_1.SHA384_IV[2] | 0;\n        this.Bl = _md_ts_1.SHA384_IV[3] | 0;\n        this.Ch = _md_ts_1.SHA384_IV[4] | 0;\n        this.Cl = _md_ts_1.SHA384_IV[5] | 0;\n        this.Dh = _md_ts_1.SHA384_IV[6] | 0;\n        this.Dl = _md_ts_1.SHA384_IV[7] | 0;\n        this.Eh = _md_ts_1.SHA384_IV[8] | 0;\n        this.El = _md_ts_1.SHA384_IV[9] | 0;\n        this.Fh = _md_ts_1.SHA384_IV[10] | 0;\n        this.Fl = _md_ts_1.SHA384_IV[11] | 0;\n        this.Gh = _md_ts_1.SHA384_IV[12] | 0;\n        this.Gl = _md_ts_1.SHA384_IV[13] | 0;\n        this.Hh = _md_ts_1.SHA384_IV[14] | 0;\n        this.Hl = _md_ts_1.SHA384_IV[15] | 0;\n    }\n}\nexports.SHA384 = SHA384;\n/**\n * Truncated SHA512/256 and SHA512/224.\n * SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as \"intermediary\" IV of SHA512/t.\n * Then t hashes string to produce result IV.\n * See `test/misc/sha2-gen-iv.js`.\n */ /** SHA512/224 IV */ const T224_IV = /* @__PURE__ */ Uint32Array.from([\n    0x8c3d37c8,\n    0x19544da2,\n    0x73e19966,\n    0x89dcd4d6,\n    0x1dfab7ae,\n    0x32ff9c82,\n    0x679dd514,\n    0x582f9fcf,\n    0x0f6d2b69,\n    0x7bd44da8,\n    0x77e36f73,\n    0x04c48942,\n    0x3f9d85a8,\n    0x6a1d36c8,\n    0x1112e6ad,\n    0x91d692a1\n]);\n/** SHA512/256 IV */ const T256_IV = /* @__PURE__ */ Uint32Array.from([\n    0x22312194,\n    0xfc2bf72c,\n    0x9f555fa3,\n    0xc84c64c2,\n    0x2393b86b,\n    0x6f53b151,\n    0x96387719,\n    0x5940eabd,\n    0x96283ee2,\n    0xa88effe3,\n    0xbe5e1e25,\n    0x53863992,\n    0x2b0199fc,\n    0x2c85b8aa,\n    0x0eb72ddc,\n    0x81c52ca2\n]);\nclass SHA512_224 extends SHA512 {\n    constructor(){\n        super(28);\n        this.Ah = T224_IV[0] | 0;\n        this.Al = T224_IV[1] | 0;\n        this.Bh = T224_IV[2] | 0;\n        this.Bl = T224_IV[3] | 0;\n        this.Ch = T224_IV[4] | 0;\n        this.Cl = T224_IV[5] | 0;\n        this.Dh = T224_IV[6] | 0;\n        this.Dl = T224_IV[7] | 0;\n        this.Eh = T224_IV[8] | 0;\n        this.El = T224_IV[9] | 0;\n        this.Fh = T224_IV[10] | 0;\n        this.Fl = T224_IV[11] | 0;\n        this.Gh = T224_IV[12] | 0;\n        this.Gl = T224_IV[13] | 0;\n        this.Hh = T224_IV[14] | 0;\n        this.Hl = T224_IV[15] | 0;\n    }\n}\nexports.SHA512_224 = SHA512_224;\nclass SHA512_256 extends SHA512 {\n    constructor(){\n        super(32);\n        this.Ah = T256_IV[0] | 0;\n        this.Al = T256_IV[1] | 0;\n        this.Bh = T256_IV[2] | 0;\n        this.Bl = T256_IV[3] | 0;\n        this.Ch = T256_IV[4] | 0;\n        this.Cl = T256_IV[5] | 0;\n        this.Dh = T256_IV[6] | 0;\n        this.Dl = T256_IV[7] | 0;\n        this.Eh = T256_IV[8] | 0;\n        this.El = T256_IV[9] | 0;\n        this.Fh = T256_IV[10] | 0;\n        this.Fl = T256_IV[11] | 0;\n        this.Gh = T256_IV[12] | 0;\n        this.Gl = T256_IV[13] | 0;\n        this.Hh = T256_IV[14] | 0;\n        this.Hl = T256_IV[15] | 0;\n    }\n}\nexports.SHA512_256 = SHA512_256;\n/**\n * SHA2-256 hash function from RFC 4634.\n *\n * It is the fastest JS hash, even faster than Blake3.\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n */ exports.sha256 = (0, utils_ts_1.createHasher)(()=>new SHA256());\n/** SHA2-224 hash function from RFC 4634 */ exports.sha224 = (0, utils_ts_1.createHasher)(()=>new SHA224());\n/** SHA2-512 hash function from RFC 4634. */ exports.sha512 = (0, utils_ts_1.createHasher)(()=>new SHA512());\n/** SHA2-384 hash function from RFC 4634. */ exports.sha384 = (0, utils_ts_1.createHasher)(()=>new SHA384());\n/**\n * SHA2-512/256 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */ exports.sha512_256 = (0, utils_ts_1.createHasher)(()=>new SHA512_256());\n/**\n * SHA2-512/224 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */ exports.sha512_224 = (0, utils_ts_1.createHasher)(()=>new SHA512_224()); //# sourceMappingURL=sha2.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvc2hhMi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsa0JBQWtCLEdBQUdBLGtCQUFrQixHQUFHQSxjQUFjLEdBQUdBLGNBQWMsR0FBR0EsY0FBYyxHQUFHQSxjQUFjLEdBQUdBLGtCQUFrQixHQUFHQSxrQkFBa0IsR0FBR0EsY0FBYyxHQUFHQSxjQUFjLEdBQUdBLGNBQWMsR0FBR0EsY0FBYyxHQUFHLEtBQUs7QUFDak87Ozs7OztDQU1DLEdBQ0QsTUFBTWMsV0FBV0MsbUJBQU9BLENBQUMsMkVBQVU7QUFDbkMsTUFBTUMsTUFBTUQsbUJBQU9BLENBQUMsNkVBQVc7QUFDL0IsTUFBTUUsYUFBYUYsbUJBQU9BLENBQUMsK0VBQVk7QUFDdkM7OztDQUdDLEdBQ0Qsa0JBQWtCO0FBQ2xCLE1BQU1HLFdBQVcsYUFBYSxHQUFHQyxZQUFZQyxJQUFJLENBQUM7SUFDOUM7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUNwRjtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQ3BGO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFDcEY7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUNwRjtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQ3BGO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFDcEY7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUNwRjtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0NBQ3ZGO0FBQ0QsNkRBQTZELEdBQzdELE1BQU1DLFdBQVcsYUFBYSxHQUFHLElBQUlGLFlBQVk7QUFDakQsTUFBTU4sZUFBZUMsU0FBU1EsTUFBTTtJQUNoQ0Ms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LFdBQVcwRyxZQUFZLEVBQUUsSUFBTSxJQUFJbEgsZUFDNUQsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xhdy13b3Jrcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9zaGEyLmpzPzRlYTkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNoYTUxMl8yMjQgPSBleHBvcnRzLnNoYTUxMl8yNTYgPSBleHBvcnRzLnNoYTM4NCA9IGV4cG9ydHMuc2hhNTEyID0gZXhwb3J0cy5zaGEyMjQgPSBleHBvcnRzLnNoYTI1NiA9IGV4cG9ydHMuU0hBNTEyXzI1NiA9IGV4cG9ydHMuU0hBNTEyXzIyNCA9IGV4cG9ydHMuU0hBMzg0ID0gZXhwb3J0cy5TSEE1MTIgPSBleHBvcnRzLlNIQTIyNCA9IGV4cG9ydHMuU0hBMjU2ID0gdm9pZCAwO1xuLyoqXG4gKiBTSEEyIGhhc2ggZnVuY3Rpb24uIEEuay5hLiBzaGEyNTYsIHNoYTM4NCwgc2hhNTEyLCBzaGE1MTJfMjI0LCBzaGE1MTJfMjU2LlxuICogU0hBMjU2IGlzIHRoZSBmYXN0ZXN0IGhhc2ggaW1wbGVtZW50YWJsZSBpbiBKUywgZXZlbiBmYXN0ZXIgdGhhbiBCbGFrZTMuXG4gKiBDaGVjayBvdXQgW1JGQyA0NjM0XShodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzQ2MzQpIGFuZFxuICogW0ZJUFMgMTgwLTRdKGh0dHBzOi8vbnZscHVicy5uaXN0Lmdvdi9uaXN0cHVicy9GSVBTL05JU1QuRklQUy4xODAtNC5wZGYpLlxuICogQG1vZHVsZVxuICovXG5jb25zdCBfbWRfdHNfMSA9IHJlcXVpcmUoXCIuL19tZC5qc1wiKTtcbmNvbnN0IHU2NCA9IHJlcXVpcmUoXCIuL191NjQuanNcIik7XG5jb25zdCB1dGlsc190c18xID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG4vKipcbiAqIFJvdW5kIGNvbnN0YW50czpcbiAqIEZpcnN0IDMyIGJpdHMgb2YgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgY3ViZSByb290cyBvZiB0aGUgZmlyc3QgNjQgcHJpbWVzIDIuLjMxMSlcbiAqL1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBTSEEyNTZfSyA9IC8qIEBfX1BVUkVfXyAqLyBVaW50MzJBcnJheS5mcm9tKFtcbiAgICAweDQyOGEyZjk4LCAweDcxMzc0NDkxLCAweGI1YzBmYmNmLCAweGU5YjVkYmE1LCAweDM5NTZjMjViLCAweDU5ZjExMWYxLCAweDkyM2Y4MmE0LCAweGFiMWM1ZWQ1LFxuICAgIDB4ZDgwN2FhOTgsIDB4MTI4MzViMDEsIDB4MjQzMTg1YmUsIDB4NTUwYzdkYzMsIDB4NzJiZTVkNzQsIDB4ODBkZWIxZmUsIDB4OWJkYzA2YTcsIDB4YzE5YmYxNzQsXG4gICAgMHhlNDliNjljMSwgMHhlZmJlNDc4NiwgMHgwZmMxOWRjNiwgMHgyNDBjYTFjYywgMHgyZGU5MmM2ZiwgMHg0YTc0ODRhYSwgMHg1Y2IwYTlkYywgMHg3NmY5ODhkYSxcbiAgICAweDk4M2U1MTUyLCAweGE4MzFjNjZkLCAweGIwMDMyN2M4LCAweGJmNTk3ZmM3LCAweGM2ZTAwYmYzLCAweGQ1YTc5MTQ3LCAweDA2Y2E2MzUxLCAweDE0MjkyOTY3LFxuICAgIDB4MjdiNzBhODUsIDB4MmUxYjIxMzgsIDB4NGQyYzZkZmMsIDB4NTMzODBkMTMsIDB4NjUwYTczNTQsIDB4NzY2YTBhYmIsIDB4ODFjMmM5MmUsIDB4OTI3MjJjODUsXG4gICAgMHhhMmJmZThhMSwgMHhhODFhNjY0YiwgMHhjMjRiOGI3MCwgMHhjNzZjNTFhMywgMHhkMTkyZTgxOSwgMHhkNjk5MDYyNCwgMHhmNDBlMzU4NSwgMHgxMDZhYTA3MCxcbiAgICAweDE5YTRjMTE2LCAweDFlMzc2YzA4LCAweDI3NDg3NzRjLCAweDM0YjBiY2I1LCAweDM5MWMwY2IzLCAweDRlZDhhYTRhLCAweDViOWNjYTRmLCAweDY4MmU2ZmYzLFxuICAgIDB4NzQ4ZjgyZWUsIDB4NzhhNTYzNmYsIDB4ODRjODc4MTQsIDB4OGNjNzAyMDgsIDB4OTBiZWZmZmEsIDB4YTQ1MDZjZWIsIDB4YmVmOWEzZjcsIDB4YzY3MTc4ZjJcbl0pO1xuLyoqIFJldXNhYmxlIHRlbXBvcmFyeSBidWZmZXIuIFwiV1wiIGNvbWVzIHN0cmFpZ2h0IGZyb20gc3BlYy4gKi9cbmNvbnN0IFNIQTI1Nl9XID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheSg2NCk7XG5jbGFzcyBTSEEyNTYgZXh0ZW5kcyBfbWRfdHNfMS5IYXNoTUQge1xuICAgIGNvbnN0cnVjdG9yKG91dHB1dExlbiA9IDMyKSB7XG4gICAgICAgIHN1cGVyKDY0LCBvdXRwdXRMZW4sIDgsIGZhbHNlKTtcbiAgICAgICAgLy8gV2UgY2Fubm90IHVzZSBhcnJheSBoZXJlIHNpbmNlIGFycmF5IGFsbG93cyBpbmRleGluZyBieSB2YXJpYWJsZVxuICAgICAgICAvLyB3aGljaCBtZWFucyBvcHRpbWl6ZXIvY29tcGlsZXIgY2Fubm90IHVzZSByZWdpc3RlcnMuXG4gICAgICAgIHRoaXMuQSA9IF9tZF90c18xLlNIQTI1Nl9JVlswXSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IF9tZF90c18xLlNIQTI1Nl9JVlsxXSB8IDA7XG4gICAgICAgIHRoaXMuQyA9IF9tZF90c18xLlNIQTI1Nl9JVlsyXSB8IDA7XG4gICAgICAgIHRoaXMuRCA9IF9tZF90c18xLlNIQTI1Nl9JVlszXSB8IDA7XG4gICAgICAgIHRoaXMuRSA9IF9tZF90c18xLlNIQTI1Nl9JVls0XSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IF9tZF90c18xLlNIQTI1Nl9JVls1XSB8IDA7XG4gICAgICAgIHRoaXMuRyA9IF9tZF90c18xLlNIQTI1Nl9JVls2XSB8IDA7XG4gICAgICAgIHRoaXMuSCA9IF9tZF90c18xLlNIQTI1Nl9JVls3XSB8IDA7XG4gICAgfVxuICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW0EsIEIsIEMsIEQsIEUsIEYsIEcsIEhdO1xuICAgIH1cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBzZXQoQSwgQiwgQywgRCwgRSwgRiwgRywgSCkge1xuICAgICAgICB0aGlzLkEgPSBBIHwgMDtcbiAgICAgICAgdGhpcy5CID0gQiB8IDA7XG4gICAgICAgIHRoaXMuQyA9IEMgfCAwO1xuICAgICAgICB0aGlzLkQgPSBEIHwgMDtcbiAgICAgICAgdGhpcy5FID0gRSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IEYgfCAwO1xuICAgICAgICB0aGlzLkcgPSBHIHwgMDtcbiAgICAgICAgdGhpcy5IID0gSCB8IDA7XG4gICAgfVxuICAgIHByb2Nlc3Modmlldywgb2Zmc2V0KSB7XG4gICAgICAgIC8vIEV4dGVuZCB0aGUgZmlyc3QgMTYgd29yZHMgaW50byB0aGUgcmVtYWluaW5nIDQ4IHdvcmRzIHdbMTYuLjYzXSBvZiB0aGUgbWVzc2FnZSBzY2hlZHVsZSBhcnJheVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyssIG9mZnNldCArPSA0KVxuICAgICAgICAgICAgU0hBMjU2X1dbaV0gPSB2aWV3LmdldFVpbnQzMihvZmZzZXQsIGZhbHNlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE2OyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgVzE1ID0gU0hBMjU2X1dbaSAtIDE1XTtcbiAgICAgICAgICAgIGNvbnN0IFcyID0gU0hBMjU2X1dbaSAtIDJdO1xuICAgICAgICAgICAgY29uc3QgczAgPSAoMCwgdXRpbHNfdHNfMS5yb3RyKShXMTUsIDcpIF4gKDAsIHV0aWxzX3RzXzEucm90cikoVzE1LCAxOCkgXiAoVzE1ID4+PiAzKTtcbiAgICAgICAgICAgIGNvbnN0IHMxID0gKDAsIHV0aWxzX3RzXzEucm90cikoVzIsIDE3KSBeICgwLCB1dGlsc190c18xLnJvdHIpKFcyLCAxOSkgXiAoVzIgPj4+IDEwKTtcbiAgICAgICAgICAgIFNIQTI1Nl9XW2ldID0gKHMxICsgU0hBMjU2X1dbaSAtIDddICsgczAgKyBTSEEyNTZfV1tpIC0gMTZdKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcHJlc3Npb24gZnVuY3Rpb24gbWFpbiBsb29wLCA2NCByb3VuZHNcbiAgICAgICAgbGV0IHsgQSwgQiwgQywgRCwgRSwgRiwgRywgSCB9ID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTEgPSAoMCwgdXRpbHNfdHNfMS5yb3RyKShFLCA2KSBeICgwLCB1dGlsc190c18xLnJvdHIpKEUsIDExKSBeICgwLCB1dGlsc190c18xLnJvdHIpKEUsIDI1KTtcbiAgICAgICAgICAgIGNvbnN0IFQxID0gKEggKyBzaWdtYTEgKyAoMCwgX21kX3RzXzEuQ2hpKShFLCBGLCBHKSArIFNIQTI1Nl9LW2ldICsgU0hBMjU2X1dbaV0pIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMCA9ICgwLCB1dGlsc190c18xLnJvdHIpKEEsIDIpIF4gKDAsIHV0aWxzX3RzXzEucm90cikoQSwgMTMpIF4gKDAsIHV0aWxzX3RzXzEucm90cikoQSwgMjIpO1xuICAgICAgICAgICAgY29uc3QgVDIgPSAoc2lnbWEwICsgKDAsIF9tZF90c18xLk1haikoQSwgQiwgQykpIHwgMDtcbiAgICAgICAgICAgIEggPSBHO1xuICAgICAgICAgICAgRyA9IEY7XG4gICAgICAgICAgICBGID0gRTtcbiAgICAgICAgICAgIEUgPSAoRCArIFQxKSB8IDA7XG4gICAgICAgICAgICBEID0gQztcbiAgICAgICAgICAgIEMgPSBCO1xuICAgICAgICAgICAgQiA9IEE7XG4gICAgICAgICAgICBBID0gKFQxICsgVDIpIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICBBID0gKEEgKyB0aGlzLkEpIHwgMDtcbiAgICAgICAgQiA9IChCICsgdGhpcy5CKSB8IDA7XG4gICAgICAgIEMgPSAoQyArIHRoaXMuQykgfCAwO1xuICAgICAgICBEID0gKEQgKyB0aGlzLkQpIHwgMDtcbiAgICAgICAgRSA9IChFICsgdGhpcy5FKSB8IDA7XG4gICAgICAgIEYgPSAoRiArIHRoaXMuRikgfCAwO1xuICAgICAgICBHID0gKEcgKyB0aGlzLkcpIHwgMDtcbiAgICAgICAgSCA9IChIICsgdGhpcy5IKSB8IDA7XG4gICAgICAgIHRoaXMuc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICAoMCwgdXRpbHNfdHNfMS5jbGVhbikoU0hBMjU2X1cpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICAgICAgKDAsIHV0aWxzX3RzXzEuY2xlYW4pKHRoaXMuYnVmZmVyKTtcbiAgICB9XG59XG5leHBvcnRzLlNIQTI1NiA9IFNIQTI1NjtcbmNsYXNzIFNIQTIyNCBleHRlbmRzIFNIQTI1NiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDI4KTtcbiAgICAgICAgdGhpcy5BID0gX21kX3RzXzEuU0hBMjI0X0lWWzBdIHwgMDtcbiAgICAgICAgdGhpcy5CID0gX21kX3RzXzEuU0hBMjI0X0lWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5DID0gX21kX3RzXzEuU0hBMjI0X0lWWzJdIHwgMDtcbiAgICAgICAgdGhpcy5EID0gX21kX3RzXzEuU0hBMjI0X0lWWzNdIHwgMDtcbiAgICAgICAgdGhpcy5FID0gX21kX3RzXzEuU0hBMjI0X0lWWzRdIHwgMDtcbiAgICAgICAgdGhpcy5GID0gX21kX3RzXzEuU0hBMjI0X0lWWzVdIHwgMDtcbiAgICAgICAgdGhpcy5HID0gX21kX3RzXzEuU0hBMjI0X0lWWzZdIHwgMDtcbiAgICAgICAgdGhpcy5IID0gX21kX3RzXzEuU0hBMjI0X0lWWzddIHwgMDtcbiAgICB9XG59XG5leHBvcnRzLlNIQTIyNCA9IFNIQTIyNDtcbi8vIFNIQTItNTEyIGlzIHNsb3dlciB0aGFuIHNoYTI1NiBpbiBqcyBiZWNhdXNlIHU2NCBvcGVyYXRpb25zIGFyZSBzbG93LlxuLy8gUm91bmQgY29udGFudHNcbi8vIEZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIGN1YmUgcm9vdHMgb2YgdGhlIGZpcnN0IDgwIHByaW1lcyAyLi40MDlcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgSzUxMiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gdTY0LnNwbGl0KFtcbiAgICAnMHg0MjhhMmY5OGQ3MjhhZTIyJywgJzB4NzEzNzQ0OTEyM2VmNjVjZCcsICcweGI1YzBmYmNmZWM0ZDNiMmYnLCAnMHhlOWI1ZGJhNTgxODlkYmJjJyxcbiAgICAnMHgzOTU2YzI1YmYzNDhiNTM4JywgJzB4NTlmMTExZjFiNjA1ZDAxOScsICcweDkyM2Y4MmE0YWYxOTRmOWInLCAnMHhhYjFjNWVkNWRhNmQ4MTE4JyxcbiAgICAnMHhkODA3YWE5OGEzMDMwMjQyJywgJzB4MTI4MzViMDE0NTcwNmZiZScsICcweDI0MzE4NWJlNGVlNGIyOGMnLCAnMHg1NTBjN2RjM2Q1ZmZiNGUyJyxcbiAgICAnMHg3MmJlNWQ3NGYyN2I4OTZmJywgJzB4ODBkZWIxZmUzYjE2OTZiMScsICcweDliZGMwNmE3MjVjNzEyMzUnLCAnMHhjMTliZjE3NGNmNjkyNjk0JyxcbiAgICAnMHhlNDliNjljMTllZjE0YWQyJywgJzB4ZWZiZTQ3ODYzODRmMjVlMycsICcweDBmYzE5ZGM2OGI4Y2Q1YjUnLCAnMHgyNDBjYTFjYzc3YWM5YzY1JyxcbiAgICAnMHgyZGU5MmM2ZjU5MmIwMjc1JywgJzB4NGE3NDg0YWE2ZWE2ZTQ4MycsICcweDVjYjBhOWRjYmQ0MWZiZDQnLCAnMHg3NmY5ODhkYTgzMTE1M2I1JyxcbiAgICAnMHg5ODNlNTE1MmVlNjZkZmFiJywgJzB4YTgzMWM2NmQyZGI0MzIxMCcsICcweGIwMDMyN2M4OThmYjIxM2YnLCAnMHhiZjU5N2ZjN2JlZWYwZWU0JyxcbiAgICAnMHhjNmUwMGJmMzNkYTg4ZmMyJywgJzB4ZDVhNzkxNDc5MzBhYTcyNScsICcweDA2Y2E2MzUxZTAwMzgyNmYnLCAnMHgxNDI5Mjk2NzBhMGU2ZTcwJyxcbiAgICAnMHgyN2I3MGE4NTQ2ZDIyZmZjJywgJzB4MmUxYjIxMzg1YzI2YzkyNicsICcweDRkMmM2ZGZjNWFjNDJhZWQnLCAnMHg1MzM4MGQxMzlkOTViM2RmJyxcbiAgICAnMHg2NTBhNzM1NDhiYWY2M2RlJywgJzB4NzY2YTBhYmIzYzc3YjJhOCcsICcweDgxYzJjOTJlNDdlZGFlZTYnLCAnMHg5MjcyMmM4NTE0ODIzNTNiJyxcbiAgICAnMHhhMmJmZThhMTRjZjEwMzY0JywgJzB4YTgxYTY2NGJiYzQyMzAwMScsICcweGMyNGI4YjcwZDBmODk3OTEnLCAnMHhjNzZjNTFhMzA2NTRiZTMwJyxcbiAgICAnMHhkMTkyZTgxOWQ2ZWY1MjE4JywgJzB4ZDY5OTA2MjQ1NTY1YTkxMCcsICcweGY0MGUzNTg1NTc3MTIwMmEnLCAnMHgxMDZhYTA3MDMyYmJkMWI4JyxcbiAgICAnMHgxOWE0YzExNmI4ZDJkMGM4JywgJzB4MWUzNzZjMDg1MTQxYWI1MycsICcweDI3NDg3NzRjZGY4ZWViOTknLCAnMHgzNGIwYmNiNWUxOWI0OGE4JyxcbiAgICAnMHgzOTFjMGNiM2M1Yzk1YTYzJywgJzB4NGVkOGFhNGFlMzQxOGFjYicsICcweDViOWNjYTRmNzc2M2UzNzMnLCAnMHg2ODJlNmZmM2Q2YjJiOGEzJyxcbiAgICAnMHg3NDhmODJlZTVkZWZiMmZjJywgJzB4NzhhNTYzNmY0MzE3MmY2MCcsICcweDg0Yzg3ODE0YTFmMGFiNzInLCAnMHg4Y2M3MDIwODFhNjQzOWVjJyxcbiAgICAnMHg5MGJlZmZmYTIzNjMxZTI4JywgJzB4YTQ1MDZjZWJkZTgyYmRlOScsICcweGJlZjlhM2Y3YjJjNjc5MTUnLCAnMHhjNjcxNzhmMmUzNzI1MzJiJyxcbiAgICAnMHhjYTI3M2VjZWVhMjY2MTljJywgJzB4ZDE4NmI4YzcyMWMwYzIwNycsICcweGVhZGE3ZGQ2Y2RlMGViMWUnLCAnMHhmNTdkNGY3ZmVlNmVkMTc4JyxcbiAgICAnMHgwNmYwNjdhYTcyMTc2ZmJhJywgJzB4MGE2MzdkYzVhMmM4OThhNicsICcweDExM2Y5ODA0YmVmOTBkYWUnLCAnMHgxYjcxMGIzNTEzMWM0NzFiJyxcbiAgICAnMHgyOGRiNzdmNTIzMDQ3ZDg0JywgJzB4MzJjYWFiN2I0MGM3MjQ5MycsICcweDNjOWViZTBhMTVjOWJlYmMnLCAnMHg0MzFkNjdjNDljMTAwZDRjJyxcbiAgICAnMHg0Y2M1ZDRiZWNiM2U0MmI2JywgJzB4NTk3ZjI5OWNmYzY1N2UyYScsICcweDVmY2I2ZmFiM2FkNmZhZWMnLCAnMHg2YzQ0MTk4YzRhNDc1ODE3J1xuXS5tYXAobiA9PiBCaWdJbnQobikpKSkoKTtcbmNvbnN0IFNIQTUxMl9LaCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gSzUxMlswXSkoKTtcbmNvbnN0IFNIQTUxMl9LbCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gSzUxMlsxXSkoKTtcbi8vIFJldXNhYmxlIHRlbXBvcmFyeSBidWZmZXJzXG5jb25zdCBTSEE1MTJfV19IID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheSg4MCk7XG5jb25zdCBTSEE1MTJfV19MID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheSg4MCk7XG5jbGFzcyBTSEE1MTIgZXh0ZW5kcyBfbWRfdHNfMS5IYXNoTUQge1xuICAgIGNvbnN0cnVjdG9yKG91dHB1dExlbiA9IDY0KSB7XG4gICAgICAgIHN1cGVyKDEyOCwgb3V0cHV0TGVuLCAxNiwgZmFsc2UpO1xuICAgICAgICAvLyBXZSBjYW5ub3QgdXNlIGFycmF5IGhlcmUgc2luY2UgYXJyYXkgYWxsb3dzIGluZGV4aW5nIGJ5IHZhcmlhYmxlXG4gICAgICAgIC8vIHdoaWNoIG1lYW5zIG9wdGltaXplci9jb21waWxlciBjYW5ub3QgdXNlIHJlZ2lzdGVycy5cbiAgICAgICAgLy8gaCAtLSBoaWdoIDMyIGJpdHMsIGwgLS0gbG93IDMyIGJpdHNcbiAgICAgICAgdGhpcy5BaCA9IF9tZF90c18xLlNIQTUxMl9JVlswXSB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSBfbWRfdHNfMS5TSEE1MTJfSVZbMV0gfCAwO1xuICAgICAgICB0aGlzLkJoID0gX21kX3RzXzEuU0hBNTEyX0lWWzJdIHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IF9tZF90c18xLlNIQTUxMl9JVlszXSB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSBfbWRfdHNfMS5TSEE1MTJfSVZbNF0gfCAwO1xuICAgICAgICB0aGlzLkNsID0gX21kX3RzXzEuU0hBNTEyX0lWWzVdIHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IF9tZF90c18xLlNIQTUxMl9JVls2XSB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSBfbWRfdHNfMS5TSEE1MTJfSVZbN10gfCAwO1xuICAgICAgICB0aGlzLkVoID0gX21kX3RzXzEuU0hBNTEyX0lWWzhdIHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IF9tZF90c18xLlNIQTUxMl9JVls5XSB8IDA7XG4gICAgICAgIHRoaXMuRmggPSBfbWRfdHNfMS5TSEE1MTJfSVZbMTBdIHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IF9tZF90c18xLlNIQTUxMl9JVlsxMV0gfCAwO1xuICAgICAgICB0aGlzLkdoID0gX21kX3RzXzEuU0hBNTEyX0lWWzEyXSB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSBfbWRfdHNfMS5TSEE1MTJfSVZbMTNdIHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IF9tZF90c18xLlNIQTUxMl9JVlsxNF0gfCAwO1xuICAgICAgICB0aGlzLkhsID0gX21kX3RzXzEuU0hBNTEyX0lWWzE1XSB8IDA7XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgeyBBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFtBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbF07XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHNldChBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCkge1xuICAgICAgICB0aGlzLkFoID0gQWggfCAwO1xuICAgICAgICB0aGlzLkFsID0gQWwgfCAwO1xuICAgICAgICB0aGlzLkJoID0gQmggfCAwO1xuICAgICAgICB0aGlzLkJsID0gQmwgfCAwO1xuICAgICAgICB0aGlzLkNoID0gQ2ggfCAwO1xuICAgICAgICB0aGlzLkNsID0gQ2wgfCAwO1xuICAgICAgICB0aGlzLkRoID0gRGggfCAwO1xuICAgICAgICB0aGlzLkRsID0gRGwgfCAwO1xuICAgICAgICB0aGlzLkVoID0gRWggfCAwO1xuICAgICAgICB0aGlzLkVsID0gRWwgfCAwO1xuICAgICAgICB0aGlzLkZoID0gRmggfCAwO1xuICAgICAgICB0aGlzLkZsID0gRmwgfCAwO1xuICAgICAgICB0aGlzLkdoID0gR2ggfCAwO1xuICAgICAgICB0aGlzLkdsID0gR2wgfCAwO1xuICAgICAgICB0aGlzLkhoID0gSGggfCAwO1xuICAgICAgICB0aGlzLkhsID0gSGwgfCAwO1xuICAgIH1cbiAgICBwcm9jZXNzKHZpZXcsIG9mZnNldCkge1xuICAgICAgICAvLyBFeHRlbmQgdGhlIGZpcnN0IDE2IHdvcmRzIGludG8gdGhlIHJlbWFpbmluZyA2NCB3b3JkcyB3WzE2Li43OV0gb2YgdGhlIG1lc3NhZ2Ugc2NoZWR1bGUgYXJyYXlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNCkge1xuICAgICAgICAgICAgU0hBNTEyX1dfSFtpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCk7XG4gICAgICAgICAgICBTSEE1MTJfV19MW2ldID0gdmlldy5nZXRVaW50MzIoKG9mZnNldCArPSA0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDE2OyBpIDwgODA7IGkrKykge1xuICAgICAgICAgICAgLy8gczAgOj0gKHdbaS0xNV0gcmlnaHRyb3RhdGUgMSkgeG9yICh3W2ktMTVdIHJpZ2h0cm90YXRlIDgpIHhvciAod1tpLTE1XSByaWdodHNoaWZ0IDcpXG4gICAgICAgICAgICBjb25zdCBXMTVoID0gU0hBNTEyX1dfSFtpIC0gMTVdIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IFcxNWwgPSBTSEE1MTJfV19MW2kgLSAxNV0gfCAwO1xuICAgICAgICAgICAgY29uc3QgczBoID0gdTY0LnJvdHJTSChXMTVoLCBXMTVsLCAxKSBeIHU2NC5yb3RyU0goVzE1aCwgVzE1bCwgOCkgXiB1NjQuc2hyU0goVzE1aCwgVzE1bCwgNyk7XG4gICAgICAgICAgICBjb25zdCBzMGwgPSB1NjQucm90clNMKFcxNWgsIFcxNWwsIDEpIF4gdTY0LnJvdHJTTChXMTVoLCBXMTVsLCA4KSBeIHU2NC5zaHJTTChXMTVoLCBXMTVsLCA3KTtcbiAgICAgICAgICAgIC8vIHMxIDo9ICh3W2ktMl0gcmlnaHRyb3RhdGUgMTkpIHhvciAod1tpLTJdIHJpZ2h0cm90YXRlIDYxKSB4b3IgKHdbaS0yXSByaWdodHNoaWZ0IDYpXG4gICAgICAgICAgICBjb25zdCBXMmggPSBTSEE1MTJfV19IW2kgLSAyXSB8IDA7XG4gICAgICAgICAgICBjb25zdCBXMmwgPSBTSEE1MTJfV19MW2kgLSAyXSB8IDA7XG4gICAgICAgICAgICBjb25zdCBzMWggPSB1NjQucm90clNIKFcyaCwgVzJsLCAxOSkgXiB1NjQucm90ckJIKFcyaCwgVzJsLCA2MSkgXiB1NjQuc2hyU0goVzJoLCBXMmwsIDYpO1xuICAgICAgICAgICAgY29uc3QgczFsID0gdTY0LnJvdHJTTChXMmgsIFcybCwgMTkpIF4gdTY0LnJvdHJCTChXMmgsIFcybCwgNjEpIF4gdTY0LnNoclNMKFcyaCwgVzJsLCA2KTtcbiAgICAgICAgICAgIC8vIFNIQTI1Nl9XW2ldID0gczAgKyBzMSArIFNIQTI1Nl9XW2kgLSA3XSArIFNIQTI1Nl9XW2kgLSAxNl07XG4gICAgICAgICAgICBjb25zdCBTVU1sID0gdTY0LmFkZDRMKHMwbCwgczFsLCBTSEE1MTJfV19MW2kgLSA3XSwgU0hBNTEyX1dfTFtpIC0gMTZdKTtcbiAgICAgICAgICAgIGNvbnN0IFNVTWggPSB1NjQuYWRkNEgoU1VNbCwgczBoLCBzMWgsIFNIQTUxMl9XX0hbaSAtIDddLCBTSEE1MTJfV19IW2kgLSAxNl0pO1xuICAgICAgICAgICAgU0hBNTEyX1dfSFtpXSA9IFNVTWggfCAwO1xuICAgICAgICAgICAgU0hBNTEyX1dfTFtpXSA9IFNVTWwgfCAwO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IEFoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsIH0gPSB0aGlzO1xuICAgICAgICAvLyBDb21wcmVzc2lvbiBmdW5jdGlvbiBtYWluIGxvb3AsIDgwIHJvdW5kc1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDgwOyBpKyspIHtcbiAgICAgICAgICAgIC8vIFMxIDo9IChlIHJpZ2h0cm90YXRlIDE0KSB4b3IgKGUgcmlnaHRyb3RhdGUgMTgpIHhvciAoZSByaWdodHJvdGF0ZSA0MSlcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMWggPSB1NjQucm90clNIKEVoLCBFbCwgMTQpIF4gdTY0LnJvdHJTSChFaCwgRWwsIDE4KSBeIHU2NC5yb3RyQkgoRWgsIEVsLCA0MSk7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTFsID0gdTY0LnJvdHJTTChFaCwgRWwsIDE0KSBeIHU2NC5yb3RyU0woRWgsIEVsLCAxOCkgXiB1NjQucm90ckJMKEVoLCBFbCwgNDEpO1xuICAgICAgICAgICAgLy9jb25zdCBUMSA9IChIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBMjU2X0tbaV0gKyBTSEEyNTZfV1tpXSkgfCAwO1xuICAgICAgICAgICAgY29uc3QgQ0hJaCA9IChFaCAmIEZoKSBeICh+RWggJiBHaCk7XG4gICAgICAgICAgICBjb25zdCBDSElsID0gKEVsICYgRmwpIF4gKH5FbCAmIEdsKTtcbiAgICAgICAgICAgIC8vIFQxID0gSCArIHNpZ21hMSArIENoaShFLCBGLCBHKSArIFNIQTUxMl9LW2ldICsgU0hBNTEyX1dbaV1cbiAgICAgICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgVDFsbCA9IHU2NC5hZGQ1TChIbCwgc2lnbWExbCwgQ0hJbCwgU0hBNTEyX0tsW2ldLCBTSEE1MTJfV19MW2ldKTtcbiAgICAgICAgICAgIGNvbnN0IFQxaCA9IHU2NC5hZGQ1SChUMWxsLCBIaCwgc2lnbWExaCwgQ0hJaCwgU0hBNTEyX0toW2ldLCBTSEE1MTJfV19IW2ldKTtcbiAgICAgICAgICAgIGNvbnN0IFQxbCA9IFQxbGwgfCAwO1xuICAgICAgICAgICAgLy8gUzAgOj0gKGEgcmlnaHRyb3RhdGUgMjgpIHhvciAoYSByaWdodHJvdGF0ZSAzNCkgeG9yIChhIHJpZ2h0cm90YXRlIDM5KVxuICAgICAgICAgICAgY29uc3Qgc2lnbWEwaCA9IHU2NC5yb3RyU0goQWgsIEFsLCAyOCkgXiB1NjQucm90ckJIKEFoLCBBbCwgMzQpIF4gdTY0LnJvdHJCSChBaCwgQWwsIDM5KTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMGwgPSB1NjQucm90clNMKEFoLCBBbCwgMjgpIF4gdTY0LnJvdHJCTChBaCwgQWwsIDM0KSBeIHU2NC5yb3RyQkwoQWgsIEFsLCAzOSk7XG4gICAgICAgICAgICBjb25zdCBNQUpoID0gKEFoICYgQmgpIF4gKEFoICYgQ2gpIF4gKEJoICYgQ2gpO1xuICAgICAgICAgICAgY29uc3QgTUFKbCA9IChBbCAmIEJsKSBeIChBbCAmIENsKSBeIChCbCAmIENsKTtcbiAgICAgICAgICAgIEhoID0gR2ggfCAwO1xuICAgICAgICAgICAgSGwgPSBHbCB8IDA7XG4gICAgICAgICAgICBHaCA9IEZoIHwgMDtcbiAgICAgICAgICAgIEdsID0gRmwgfCAwO1xuICAgICAgICAgICAgRmggPSBFaCB8IDA7XG4gICAgICAgICAgICBGbCA9IEVsIHwgMDtcbiAgICAgICAgICAgICh7IGg6IEVoLCBsOiBFbCB9ID0gdTY0LmFkZChEaCB8IDAsIERsIHwgMCwgVDFoIHwgMCwgVDFsIHwgMCkpO1xuICAgICAgICAgICAgRGggPSBDaCB8IDA7XG4gICAgICAgICAgICBEbCA9IENsIHwgMDtcbiAgICAgICAgICAgIENoID0gQmggfCAwO1xuICAgICAgICAgICAgQ2wgPSBCbCB8IDA7XG4gICAgICAgICAgICBCaCA9IEFoIHwgMDtcbiAgICAgICAgICAgIEJsID0gQWwgfCAwO1xuICAgICAgICAgICAgY29uc3QgQWxsID0gdTY0LmFkZDNMKFQxbCwgc2lnbWEwbCwgTUFKbCk7XG4gICAgICAgICAgICBBaCA9IHU2NC5hZGQzSChBbGwsIFQxaCwgc2lnbWEwaCwgTUFKaCk7XG4gICAgICAgICAgICBBbCA9IEFsbCB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBjb21wcmVzc2VkIGNodW5rIHRvIHRoZSBjdXJyZW50IGhhc2ggdmFsdWVcbiAgICAgICAgKHsgaDogQWgsIGw6IEFsIH0gPSB1NjQuYWRkKHRoaXMuQWggfCAwLCB0aGlzLkFsIHwgMCwgQWggfCAwLCBBbCB8IDApKTtcbiAgICAgICAgKHsgaDogQmgsIGw6IEJsIH0gPSB1NjQuYWRkKHRoaXMuQmggfCAwLCB0aGlzLkJsIHwgMCwgQmggfCAwLCBCbCB8IDApKTtcbiAgICAgICAgKHsgaDogQ2gsIGw6IENsIH0gPSB1NjQuYWRkKHRoaXMuQ2ggfCAwLCB0aGlzLkNsIHwgMCwgQ2ggfCAwLCBDbCB8IDApKTtcbiAgICAgICAgKHsgaDogRGgsIGw6IERsIH0gPSB1NjQuYWRkKHRoaXMuRGggfCAwLCB0aGlzLkRsIHwgMCwgRGggfCAwLCBEbCB8IDApKTtcbiAgICAgICAgKHsgaDogRWgsIGw6IEVsIH0gPSB1NjQuYWRkKHRoaXMuRWggfCAwLCB0aGlzLkVsIHwgMCwgRWggfCAwLCBFbCB8IDApKTtcbiAgICAgICAgKHsgaDogRmgsIGw6IEZsIH0gPSB1NjQuYWRkKHRoaXMuRmggfCAwLCB0aGlzLkZsIHwgMCwgRmggfCAwLCBGbCB8IDApKTtcbiAgICAgICAgKHsgaDogR2gsIGw6IEdsIH0gPSB1NjQuYWRkKHRoaXMuR2ggfCAwLCB0aGlzLkdsIHwgMCwgR2ggfCAwLCBHbCB8IDApKTtcbiAgICAgICAgKHsgaDogSGgsIGw6IEhsIH0gPSB1NjQuYWRkKHRoaXMuSGggfCAwLCB0aGlzLkhsIHwgMCwgSGggfCAwLCBIbCB8IDApKTtcbiAgICAgICAgdGhpcy5zZXQoQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwpO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICAoMCwgdXRpbHNfdHNfMS5jbGVhbikoU0hBNTEyX1dfSCwgU0hBNTEyX1dfTCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgICgwLCB1dGlsc190c18xLmNsZWFuKSh0aGlzLmJ1ZmZlcik7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgIH1cbn1cbmV4cG9ydHMuU0hBNTEyID0gU0hBNTEyO1xuY2xhc3MgU0hBMzg0IGV4dGVuZHMgU0hBNTEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoNDgpO1xuICAgICAgICB0aGlzLkFoID0gX21kX3RzXzEuU0hBMzg0X0lWWzBdIHwgMDtcbiAgICAgICAgdGhpcy5BbCA9IF9tZF90c18xLlNIQTM4NF9JVlsxXSB8IDA7XG4gICAgICAgIHRoaXMuQmggPSBfbWRfdHNfMS5TSEEzODRfSVZbMl0gfCAwO1xuICAgICAgICB0aGlzLkJsID0gX21kX3RzXzEuU0hBMzg0X0lWWzNdIHwgMDtcbiAgICAgICAgdGhpcy5DaCA9IF9tZF90c18xLlNIQTM4NF9JVls0XSB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSBfbWRfdHNfMS5TSEEzODRfSVZbNV0gfCAwO1xuICAgICAgICB0aGlzLkRoID0gX21kX3RzXzEuU0hBMzg0X0lWWzZdIHwgMDtcbiAgICAgICAgdGhpcy5EbCA9IF9tZF90c18xLlNIQTM4NF9JVls3XSB8IDA7XG4gICAgICAgIHRoaXMuRWggPSBfbWRfdHNfMS5TSEEzODRfSVZbOF0gfCAwO1xuICAgICAgICB0aGlzLkVsID0gX21kX3RzXzEuU0hBMzg0X0lWWzldIHwgMDtcbiAgICAgICAgdGhpcy5GaCA9IF9tZF90c18xLlNIQTM4NF9JVlsxMF0gfCAwO1xuICAgICAgICB0aGlzLkZsID0gX21kX3RzXzEuU0hBMzg0X0lWWzExXSB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSBfbWRfdHNfMS5TSEEzODRfSVZbMTJdIHwgMDtcbiAgICAgICAgdGhpcy5HbCA9IF9tZF90c18xLlNIQTM4NF9JVlsxM10gfCAwO1xuICAgICAgICB0aGlzLkhoID0gX21kX3RzXzEuU0hBMzg0X0lWWzE0XSB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSBfbWRfdHNfMS5TSEEzODRfSVZbMTVdIHwgMDtcbiAgICB9XG59XG5leHBvcnRzLlNIQTM4NCA9IFNIQTM4NDtcbi8qKlxuICogVHJ1bmNhdGVkIFNIQTUxMi8yNTYgYW5kIFNIQTUxMi8yMjQuXG4gKiBTSEE1MTJfSVYgaXMgWE9SZWQgd2l0aCAweGE1YTVhNWE1YTVhNWE1YTUsIHRoZW4gdXNlZCBhcyBcImludGVybWVkaWFyeVwiIElWIG9mIFNIQTUxMi90LlxuICogVGhlbiB0IGhhc2hlcyBzdHJpbmcgdG8gcHJvZHVjZSByZXN1bHQgSVYuXG4gKiBTZWUgYHRlc3QvbWlzYy9zaGEyLWdlbi1pdi5qc2AuXG4gKi9cbi8qKiBTSEE1MTIvMjI0IElWICovXG5jb25zdCBUMjI0X0lWID0gLyogQF9fUFVSRV9fICovIFVpbnQzMkFycmF5LmZyb20oW1xuICAgIDB4OGMzZDM3YzgsIDB4MTk1NDRkYTIsIDB4NzNlMTk5NjYsIDB4ODlkY2Q0ZDYsIDB4MWRmYWI3YWUsIDB4MzJmZjljODIsIDB4Njc5ZGQ1MTQsIDB4NTgyZjlmY2YsXG4gICAgMHgwZjZkMmI2OSwgMHg3YmQ0NGRhOCwgMHg3N2UzNmY3MywgMHgwNGM0ODk0MiwgMHgzZjlkODVhOCwgMHg2YTFkMzZjOCwgMHgxMTEyZTZhZCwgMHg5MWQ2OTJhMSxcbl0pO1xuLyoqIFNIQTUxMi8yNTYgSVYgKi9cbmNvbnN0IFQyNTZfSVYgPSAvKiBAX19QVVJFX18gKi8gVWludDMyQXJyYXkuZnJvbShbXG4gICAgMHgyMjMxMjE5NCwgMHhmYzJiZjcyYywgMHg5ZjU1NWZhMywgMHhjODRjNjRjMiwgMHgyMzkzYjg2YiwgMHg2ZjUzYjE1MSwgMHg5NjM4NzcxOSwgMHg1OTQwZWFiZCxcbiAgICAweDk2MjgzZWUyLCAweGE4OGVmZmUzLCAweGJlNWUxZTI1LCAweDUzODYzOTkyLCAweDJiMDE5OWZjLCAweDJjODViOGFhLCAweDBlYjcyZGRjLCAweDgxYzUyY2EyLFxuXSk7XG5jbGFzcyBTSEE1MTJfMjI0IGV4dGVuZHMgU0hBNTEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoMjgpO1xuICAgICAgICB0aGlzLkFoID0gVDIyNF9JVlswXSB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSBUMjI0X0lWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IFQyMjRfSVZbMl0gfCAwO1xuICAgICAgICB0aGlzLkJsID0gVDIyNF9JVlszXSB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSBUMjI0X0lWWzRdIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IFQyMjRfSVZbNV0gfCAwO1xuICAgICAgICB0aGlzLkRoID0gVDIyNF9JVls2XSB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSBUMjI0X0lWWzddIHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IFQyMjRfSVZbOF0gfCAwO1xuICAgICAgICB0aGlzLkVsID0gVDIyNF9JVls5XSB8IDA7XG4gICAgICAgIHRoaXMuRmggPSBUMjI0X0lWWzEwXSB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSBUMjI0X0lWWzExXSB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSBUMjI0X0lWWzEyXSB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSBUMjI0X0lWWzEzXSB8IDA7XG4gICAgICAgIHRoaXMuSGggPSBUMjI0X0lWWzE0XSB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSBUMjI0X0lWWzE1XSB8IDA7XG4gICAgfVxufVxuZXhwb3J0cy5TSEE1MTJfMjI0ID0gU0hBNTEyXzIyNDtcbmNsYXNzIFNIQTUxMl8yNTYgZXh0ZW5kcyBTSEE1MTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigzMik7XG4gICAgICAgIHRoaXMuQWggPSBUMjU2X0lWWzBdIHwgMDtcbiAgICAgICAgdGhpcy5BbCA9IFQyNTZfSVZbMV0gfCAwO1xuICAgICAgICB0aGlzLkJoID0gVDI1Nl9JVlsyXSB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSBUMjU2X0lWWzNdIHwgMDtcbiAgICAgICAgdGhpcy5DaCA9IFQyNTZfSVZbNF0gfCAwO1xuICAgICAgICB0aGlzLkNsID0gVDI1Nl9JVls1XSB8IDA7XG4gICAgICAgIHRoaXMuRGggPSBUMjU2X0lWWzZdIHwgMDtcbiAgICAgICAgdGhpcy5EbCA9IFQyNTZfSVZbN10gfCAwO1xuICAgICAgICB0aGlzLkVoID0gVDI1Nl9JVls4XSB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSBUMjU2X0lWWzldIHwgMDtcbiAgICAgICAgdGhpcy5GaCA9IFQyNTZfSVZbMTBdIHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IFQyNTZfSVZbMTFdIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IFQyNTZfSVZbMTJdIHwgMDtcbiAgICAgICAgdGhpcy5HbCA9IFQyNTZfSVZbMTNdIHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IFQyNTZfSVZbMTRdIHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IFQyNTZfSVZbMTVdIHwgMDtcbiAgICB9XG59XG5leHBvcnRzLlNIQTUxMl8yNTYgPSBTSEE1MTJfMjU2O1xuLyoqXG4gKiBTSEEyLTI1NiBoYXNoIGZ1bmN0aW9uIGZyb20gUkZDIDQ2MzQuXG4gKlxuICogSXQgaXMgdGhlIGZhc3Rlc3QgSlMgaGFzaCwgZXZlbiBmYXN0ZXIgdGhhbiBCbGFrZTMuXG4gKiBUbyBicmVhayBzaGEyNTYgdXNpbmcgYmlydGhkYXkgYXR0YWNrLCBhdHRhY2tlcnMgbmVlZCB0byB0cnkgMl4xMjggaGFzaGVzLlxuICogQlRDIG5ldHdvcmsgaXMgZG9pbmcgMl43MCBoYXNoZXMvc2VjICgyXjk1IGhhc2hlcy95ZWFyKSBhcyBwZXIgMjAyNS5cbiAqL1xuZXhwb3J0cy5zaGEyNTYgPSAoMCwgdXRpbHNfdHNfMS5jcmVhdGVIYXNoZXIpKCgpID0+IG5ldyBTSEEyNTYoKSk7XG4vKiogU0hBMi0yMjQgaGFzaCBmdW5jdGlvbiBmcm9tIFJGQyA0NjM0ICovXG5leHBvcnRzLnNoYTIyNCA9ICgwLCB1dGlsc190c18xLmNyZWF0ZUhhc2hlcikoKCkgPT4gbmV3IFNIQTIyNCgpKTtcbi8qKiBTSEEyLTUxMiBoYXNoIGZ1bmN0aW9uIGZyb20gUkZDIDQ2MzQuICovXG5leHBvcnRzLnNoYTUxMiA9ICgwLCB1dGlsc190c18xLmNyZWF0ZUhhc2hlcikoKCkgPT4gbmV3IFNIQTUxMigpKTtcbi8qKiBTSEEyLTM4NCBoYXNoIGZ1bmN0aW9uIGZyb20gUkZDIDQ2MzQuICovXG5leHBvcnRzLnNoYTM4NCA9ICgwLCB1dGlsc190c18xLmNyZWF0ZUhhc2hlcikoKCkgPT4gbmV3IFNIQTM4NCgpKTtcbi8qKlxuICogU0hBMi01MTIvMjU2IFwidHJ1bmNhdGVkXCIgaGFzaCBmdW5jdGlvbiwgd2l0aCBpbXByb3ZlZCByZXNpc3RhbmNlIHRvIGxlbmd0aCBleHRlbnNpb24gYXR0YWNrcy5cbiAqIFNlZSB0aGUgcGFwZXIgb24gW3RydW5jYXRlZCBTSEE1MTJdKGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTAvNTQ4LnBkZikuXG4gKi9cbmV4cG9ydHMuc2hhNTEyXzI1NiA9ICgwLCB1dGlsc190c18xLmNyZWF0ZUhhc2hlcikoKCkgPT4gbmV3IFNIQTUxMl8yNTYoKSk7XG4vKipcbiAqIFNIQTItNTEyLzIyNCBcInRydW5jYXRlZFwiIGhhc2ggZnVuY3Rpb24sIHdpdGggaW1wcm92ZWQgcmVzaXN0YW5jZSB0byBsZW5ndGggZXh0ZW5zaW9uIGF0dGFja3MuXG4gKiBTZWUgdGhlIHBhcGVyIG9uIFt0cnVuY2F0ZWQgU0hBNTEyXShodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDEwLzU0OC5wZGYpLlxuICovXG5leHBvcnRzLnNoYTUxMl8yMjQgPSAoMCwgdXRpbHNfdHNfMS5jcmVhdGVIYXNoZXIpKCgpID0+IG5ldyBTSEE1MTJfMjI0KCkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhMi5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJzaGE1MTJfMjI0Iiwic2hhNTEyXzI1NiIsInNoYTM4NCIsInNoYTUxMiIsInNoYTIyNCIsInNoYTI1NiIsIlNIQTUxMl8yNTYiLCJTSEE1MTJfMjI0IiwiU0hBMzg0IiwiU0hBNTEyIiwiU0hBMjI0IiwiU0hBMjU2IiwiX21kX3RzXzEiLCJyZXF1aXJlIiwidTY0IiwidXRpbHNfdHNfMSIsIlNIQTI1Nl9LIiwiVWludDMyQXJyYXkiLCJmcm9tIiwiU0hBMjU2X1ciLCJIYXNoTUQiLCJjb25zdHJ1Y3RvciIsIm91dHB1dExlbiIsIkEiLCJTSEEyNTZfSVYiLCJCIiwiQyIsIkQiLCJFIiwiRiIsIkciLCJIIiwiZ2V0Iiwic2V0IiwicHJvY2VzcyIsInZpZXciLCJvZmZzZXQiLCJpIiwiZ2V0VWludDMyIiwiVzE1IiwiVzIiLCJzMCIsInJvdHIiLCJzMSIsInNpZ21hMSIsIlQxIiwiQ2hpIiwic2lnbWEwIiwiVDIiLCJNYWoiLCJyb3VuZENsZWFuIiwiY2xlYW4iLCJkZXN0cm95IiwiYnVmZmVyIiwiU0hBMjI0X0lWIiwiSzUxMiIsInNwbGl0IiwibWFwIiwibiIsIkJpZ0ludCIsIlNIQTUxMl9LaCIsIlNIQTUxMl9LbCIsIlNIQTUxMl9XX0giLCJTSEE1MTJfV19MIiwiQWgiLCJTSEE1MTJfSVYiLCJBbCIsIkJoIiwiQmwiLCJDaCIsIkNsIiwiRGgiLCJEbCIsIkVoIiwiRWwiLCJGaCIsIkZsIiwiR2giLCJHbCIsIkhoIiwiSGwiLCJXMTVoIiwiVzE1bCIsInMwaCIsInJvdHJTSCIsInNoclNIIiwiczBsIiwicm90clNMIiwic2hyU0wiLCJXMmgiLCJXMmwiLCJzMWgiLCJyb3RyQkgiLCJzMWwiLCJyb3RyQkwiLCJTVU1sIiwiYWRkNEwiLCJTVU1oIiwiYWRkNEgiLCJzaWdtYTFoIiwic2lnbWExbCIsIkNISWgiLCJDSElsIiwiVDFsbCIsImFkZDVMIiwiVDFoIiwiYWRkNUgiLCJUMWwiLCJzaWdtYTBoIiwic2lnbWEwbCIsIk1BSmgiLCJNQUpsIiwiaCIsImwiLCJhZGQiLCJBbGwiLCJhZGQzTCIsImFkZDNIIiwiU0hBMzg0X0lWIiwiVDIyNF9JViIsIlQyNTZfSVYiLCJjcmVhdGVIYXNoZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/@noble/hashes/sha2.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/@noble/hashes/sha256.js":
/*!**************************************************************!*\
  !*** ./node_modules/ox/node_modules/@noble/hashes/sha256.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.sha224 = exports.SHA224 = exports.sha256 = exports.SHA256 = void 0;\n/**\n * SHA2-256 a.k.a. sha256. In JS, it is the fastest hash, even faster than Blake3.\n *\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n *\n * Check out [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n * @deprecated\n */ const sha2_ts_1 = __webpack_require__(/*! ./sha2.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/sha2.js\");\n/** @deprecated Use import from `noble/hashes/sha2` module */ exports.SHA256 = sha2_ts_1.SHA256;\n/** @deprecated Use import from `noble/hashes/sha2` module */ exports.sha256 = sha2_ts_1.sha256;\n/** @deprecated Use import from `noble/hashes/sha2` module */ exports.SHA224 = sha2_ts_1.SHA224;\n/** @deprecated Use import from `noble/hashes/sha2` module */ exports.sha224 = sha2_ts_1.sha224; //# sourceMappingURL=sha256.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvc2hhMjU2LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxjQUFjLEdBQUdBLGNBQWMsR0FBR0EsY0FBYyxHQUFHQSxjQUFjLEdBQUcsS0FBSztBQUN6RTs7Ozs7Ozs7O0NBU0MsR0FDRCxNQUFNTSxZQUFZQyxtQkFBT0EsQ0FBQyw2RUFBVztBQUNyQywyREFBMkQsR0FDM0RQLGNBQWMsR0FBR00sVUFBVUQsTUFBTTtBQUNqQywyREFBMkQsR0FDM0RMLGNBQWMsR0FBR00sVUFBVUYsTUFBTTtBQUNqQywyREFBMkQsR0FDM0RKLGNBQWMsR0FBR00sVUFBVUgsTUFBTTtBQUNqQywyREFBMkQsR0FDM0RILGNBQWMsR0FBR00sVUFBVUosTUFBTSxFQUNqQyxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGF3LXdvcmtzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL3NoYTI1Ni5qcz80M2Y4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zaGEyMjQgPSBleHBvcnRzLlNIQTIyNCA9IGV4cG9ydHMuc2hhMjU2ID0gZXhwb3J0cy5TSEEyNTYgPSB2b2lkIDA7XG4vKipcbiAqIFNIQTItMjU2IGEuay5hLiBzaGEyNTYuIEluIEpTLCBpdCBpcyB0aGUgZmFzdGVzdCBoYXNoLCBldmVuIGZhc3RlciB0aGFuIEJsYWtlMy5cbiAqXG4gKiBUbyBicmVhayBzaGEyNTYgdXNpbmcgYmlydGhkYXkgYXR0YWNrLCBhdHRhY2tlcnMgbmVlZCB0byB0cnkgMl4xMjggaGFzaGVzLlxuICogQlRDIG5ldHdvcmsgaXMgZG9pbmcgMl43MCBoYXNoZXMvc2VjICgyXjk1IGhhc2hlcy95ZWFyKSBhcyBwZXIgMjAyNS5cbiAqXG4gKiBDaGVjayBvdXQgW0ZJUFMgMTgwLTRdKGh0dHBzOi8vbnZscHVicy5uaXN0Lmdvdi9uaXN0cHVicy9GSVBTL05JU1QuRklQUy4xODAtNC5wZGYpLlxuICogQG1vZHVsZVxuICogQGRlcHJlY2F0ZWRcbiAqL1xuY29uc3Qgc2hhMl90c18xID0gcmVxdWlyZShcIi4vc2hhMi5qc1wiKTtcbi8qKiBAZGVwcmVjYXRlZCBVc2UgaW1wb3J0IGZyb20gYG5vYmxlL2hhc2hlcy9zaGEyYCBtb2R1bGUgKi9cbmV4cG9ydHMuU0hBMjU2ID0gc2hhMl90c18xLlNIQTI1Njtcbi8qKiBAZGVwcmVjYXRlZCBVc2UgaW1wb3J0IGZyb20gYG5vYmxlL2hhc2hlcy9zaGEyYCBtb2R1bGUgKi9cbmV4cG9ydHMuc2hhMjU2ID0gc2hhMl90c18xLnNoYTI1Njtcbi8qKiBAZGVwcmVjYXRlZCBVc2UgaW1wb3J0IGZyb20gYG5vYmxlL2hhc2hlcy9zaGEyYCBtb2R1bGUgKi9cbmV4cG9ydHMuU0hBMjI0ID0gc2hhMl90c18xLlNIQTIyNDtcbi8qKiBAZGVwcmVjYXRlZCBVc2UgaW1wb3J0IGZyb20gYG5vYmxlL2hhc2hlcy9zaGEyYCBtb2R1bGUgKi9cbmV4cG9ydHMuc2hhMjI0ID0gc2hhMl90c18xLnNoYTIyNDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYTI1Ni5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJzaGEyMjQiLCJTSEEyMjQiLCJzaGEyNTYiLCJTSEEyNTYiLCJzaGEyX3RzXzEiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/@noble/hashes/sha256.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/@noble/hashes/sha3.js":
/*!************************************************************!*\
  !*** ./node_modules/ox/node_modules/@noble/hashes/sha3.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = void 0;\nexports.keccakP = keccakP;\n/**\n * SHA3 (keccak) hash function, based on a new \"Sponge function\" design.\n * Different from older hashes, the internal state is bigger than output size.\n *\n * Check out [FIPS-202](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf),\n * [Website](https://keccak.team/keccak.html),\n * [the differences between SHA-3 and Keccak](https://crypto.stackexchange.com/questions/15727/what-are-the-key-differences-between-the-draft-sha-3-standard-and-the-keccak-sub).\n *\n * Check out `sha3-addons` module for cSHAKE, k12, and others.\n * @module\n */ const _u64_ts_1 = __webpack_require__(/*! ./_u64.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/_u64.js\");\n// prettier-ignore\nconst utils_ts_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/utils.js\");\n// No __PURE__ annotations in sha3 header:\n// EVERYTHING is in fact used on every export.\n// Various per round constants calculations\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _7n = BigInt(7);\nconst _256n = BigInt(256);\nconst _0x71n = BigInt(0x71);\nconst SHA3_PI = [];\nconst SHA3_ROTL = [];\nconst _SHA3_IOTA = [];\nfor(let round = 0, R = _1n, x = 1, y = 0; round < 24; round++){\n    // Pi\n    [x, y] = [\n        y,\n        (2 * x + 3 * y) % 5\n    ];\n    SHA3_PI.push(2 * (5 * y + x));\n    // Rotational\n    SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);\n    // Iota\n    let t = _0n;\n    for(let j = 0; j < 7; j++){\n        R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;\n        if (R & _2n) t ^= _1n << (_1n << /* @__PURE__ */ BigInt(j)) - _1n;\n    }\n    _SHA3_IOTA.push(t);\n}\nconst IOTAS = (0, _u64_ts_1.split)(_SHA3_IOTA, true);\nconst SHA3_IOTA_H = IOTAS[0];\nconst SHA3_IOTA_L = IOTAS[1];\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h, l, s)=>s > 32 ? (0, _u64_ts_1.rotlBH)(h, l, s) : (0, _u64_ts_1.rotlSH)(h, l, s);\nconst rotlL = (h, l, s)=>s > 32 ? (0, _u64_ts_1.rotlBL)(h, l, s) : (0, _u64_ts_1.rotlSL)(h, l, s);\n/** `keccakf1600` internal function, additionally allows to adjust round count. */ function keccakP(s, rounds = 24) {\n    const B = new Uint32Array(5 * 2);\n    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n    for(let round = 24 - rounds; round < 24; round++){\n        // Theta Œ∏\n        for(let x = 0; x < 10; x++)B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n        for(let x = 0; x < 10; x += 2){\n            const idx1 = (x + 8) % 10;\n            const idx0 = (x + 2) % 10;\n            const B0 = B[idx0];\n            const B1 = B[idx0 + 1];\n            const Th = rotlH(B0, B1, 1) ^ B[idx1];\n            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n            for(let y = 0; y < 50; y += 10){\n                s[x + y] ^= Th;\n                s[x + y + 1] ^= Tl;\n            }\n        }\n        // Rho (œÅ) and Pi (œÄ)\n        let curH = s[2];\n        let curL = s[3];\n        for(let t = 0; t < 24; t++){\n            const shift = SHA3_ROTL[t];\n            const Th = rotlH(curH, curL, shift);\n            const Tl = rotlL(curH, curL, shift);\n            const PI = SHA3_PI[t];\n            curH = s[PI];\n            curL = s[PI + 1];\n            s[PI] = Th;\n            s[PI + 1] = Tl;\n        }\n        // Chi (œá)\n        for(let y = 0; y < 50; y += 10){\n            for(let x = 0; x < 10; x++)B[x] = s[y + x];\n            for(let x = 0; x < 10; x++)s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n        }\n        // Iota (Œπ)\n        s[0] ^= SHA3_IOTA_H[round];\n        s[1] ^= SHA3_IOTA_L[round];\n    }\n    (0, utils_ts_1.clean)(B);\n}\n/** Keccak sponge function. */ class Keccak extends utils_ts_1.Hash {\n    // NOTE: we accept arguments in bytes instead of bits here.\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24){\n        super();\n        this.pos = 0;\n        this.posOut = 0;\n        this.finished = false;\n        this.destroyed = false;\n        this.enableXOF = false;\n        this.blockLen = blockLen;\n        this.suffix = suffix;\n        this.outputLen = outputLen;\n        this.enableXOF = enableXOF;\n        this.rounds = rounds;\n        // Can be passed from user as dkLen\n        (0, utils_ts_1.anumber)(outputLen);\n        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n        // 0 < blockLen < 200\n        if (!(0 < blockLen && blockLen < 200)) throw new Error(\"only keccak-f1600 function is supported\");\n        this.state = new Uint8Array(200);\n        this.state32 = (0, utils_ts_1.u32)(this.state);\n    }\n    clone() {\n        return this._cloneInto();\n    }\n    keccak() {\n        (0, utils_ts_1.swap32IfBE)(this.state32);\n        keccakP(this.state32, this.rounds);\n        (0, utils_ts_1.swap32IfBE)(this.state32);\n        this.posOut = 0;\n        this.pos = 0;\n    }\n    update(data) {\n        (0, utils_ts_1.aexists)(this);\n        data = (0, utils_ts_1.toBytes)(data);\n        (0, utils_ts_1.abytes)(data);\n        const { blockLen, state } = this;\n        const len = data.length;\n        for(let pos = 0; pos < len;){\n            const take = Math.min(blockLen - this.pos, len - pos);\n            for(let i = 0; i < take; i++)state[this.pos++] ^= data[pos++];\n            if (this.pos === blockLen) this.keccak();\n        }\n        return this;\n    }\n    finish() {\n        if (this.finished) return;\n        this.finished = true;\n        const { state, suffix, pos, blockLen } = this;\n        // Do the padding\n        state[pos] ^= suffix;\n        if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();\n        state[blockLen - 1] ^= 0x80;\n        this.keccak();\n    }\n    writeInto(out) {\n        (0, utils_ts_1.aexists)(this, false);\n        (0, utils_ts_1.abytes)(out);\n        this.finish();\n        const bufferOut = this.state;\n        const { blockLen } = this;\n        for(let pos = 0, len = out.length; pos < len;){\n            if (this.posOut >= blockLen) this.keccak();\n            const take = Math.min(blockLen - this.posOut, len - pos);\n            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n            this.posOut += take;\n            pos += take;\n        }\n        return out;\n    }\n    xofInto(out) {\n        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n        if (!this.enableXOF) throw new Error(\"XOF is not possible for this instance\");\n        return this.writeInto(out);\n    }\n    xof(bytes) {\n        (0, utils_ts_1.anumber)(bytes);\n        return this.xofInto(new Uint8Array(bytes));\n    }\n    digestInto(out) {\n        (0, utils_ts_1.aoutput)(out, this);\n        if (this.finished) throw new Error(\"digest() was already called\");\n        this.writeInto(out);\n        this.destroy();\n        return out;\n    }\n    digest() {\n        return this.digestInto(new Uint8Array(this.outputLen));\n    }\n    destroy() {\n        this.destroyed = true;\n        (0, utils_ts_1.clean)(this.state);\n    }\n    _cloneInto(to) {\n        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n        to.state32.set(this.state32);\n        to.pos = this.pos;\n        to.posOut = this.posOut;\n        to.finished = this.finished;\n        to.rounds = rounds;\n        // Suffix can change in cSHAKE\n        to.suffix = suffix;\n        to.outputLen = outputLen;\n        to.enableXOF = enableXOF;\n        to.destroyed = this.destroyed;\n        return to;\n    }\n}\nexports.Keccak = Keccak;\nconst gen = (suffix, blockLen, outputLen)=>(0, utils_ts_1.createHasher)(()=>new Keccak(blockLen, suffix, outputLen));\n/** SHA3-224 hash function. */ exports.sha3_224 = (()=>gen(0x06, 144, 224 / 8))();\n/** SHA3-256 hash function. Different from keccak-256. */ exports.sha3_256 = (()=>gen(0x06, 136, 256 / 8))();\n/** SHA3-384 hash function. */ exports.sha3_384 = (()=>gen(0x06, 104, 384 / 8))();\n/** SHA3-512 hash function. */ exports.sha3_512 = (()=>gen(0x06, 72, 512 / 8))();\n/** keccak-224 hash function. */ exports.keccak_224 = (()=>gen(0x01, 144, 224 / 8))();\n/** keccak-256 hash function. Different from SHA3-256. */ exports.keccak_256 = (()=>gen(0x01, 136, 256 / 8))();\n/** keccak-384 hash function. */ exports.keccak_384 = (()=>gen(0x01, 104, 384 / 8))();\n/** keccak-512 hash function. */ exports.keccak_512 = (()=>gen(0x01, 72, 512 / 8))();\nconst genShake = (suffix, blockLen, outputLen)=>(0, utils_ts_1.createXOFer)((opts = {})=>new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));\n/** SHAKE128 XOF with 128-bit security. */ exports.shake128 = (()=>genShake(0x1f, 168, 128 / 8))();\n/** SHAKE256 XOF with 256-bit security. */ exports.shake256 = (()=>genShake(0x1f, 136, 256 / 8))(); //# sourceMappingURL=sha3.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvc2hhMy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsZ0JBQWdCLEdBQUdBLGdCQUFnQixHQUFHQSxrQkFBa0IsR0FBR0Esa0JBQWtCLEdBQUdBLGtCQUFrQixHQUFHQSxrQkFBa0IsR0FBR0EsZ0JBQWdCLEdBQUdBLGdCQUFnQixHQUFHQSxnQkFBZ0IsR0FBR0EsZ0JBQWdCLEdBQUdBLGNBQWMsR0FBRyxLQUFLO0FBQzVOQSxlQUFlLEdBQUdhO0FBQ2xCOzs7Ozs7Ozs7O0NBVUMsR0FDRCxNQUFNQyxZQUFZQyxtQkFBT0EsQ0FBQyw2RUFBVztBQUNyQyxrQkFBa0I7QUFDbEIsTUFBTUMsYUFBYUQsbUJBQU9BLENBQUMsK0VBQVk7QUFDdkMsMENBQTBDO0FBQzFDLDhDQUE4QztBQUM5QywyQ0FBMkM7QUFDM0MsTUFBTUUsTUFBTUMsT0FBTztBQUNuQixNQUFNQyxNQUFNRCxPQUFPO0FBQ25CLE1BQU1FLE1BQU1GLE9BQU87QUFDbkIsTUFBTUcsTUFBTUgsT0FBTztBQUNuQixNQUFNSSxRQUFRSixPQUFPO0FBQ3JCLE1BQU1LLFNBQVNMLE9BQU87QUFDdEIsTUFBTU0sVUFBVSxFQUFFO0FBQ2xCLE1BQU1DLFlBQVksRUFBRTtBQUNwQixNQUFNQyxhQUFhLEVBQUU7QUFDckIsSUFBSyxJQUFJQyxRQUFRLEdBQUdDLElBQUlULEtBQUtVLElBQUksR0FBR0MsSUFBSSxHQUFHSCxRQUFRLElBQUlBLFFBQVM7SUFDNUQsS0FBSztJQUNMLENBQUNFLEdBQUdDLEVBQUUsR0FBRztRQUFDQTtRQUFJLEtBQUlELElBQUksSUFBSUMsQ0FBQUEsSUFBSztLQUFFO0lBQ2pDTixRQUFRTyxJQUFJLENBQUMsSUFBSyxLQUFJRCxJQUFJRCxDQUFBQTtJQUMxQixhQUFhO0lBQ2JKLFVBQVVNLElBQUksQ0FBQyxDQUFHSixR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QUFJLE1BQU0sS0FBSyxNQUFNLEVBQUM7QUFDbEQsOEJBQThCLEdBQzlCMUcsa0JBQWtCLEdBQUcsQ0FBQyxJQUFNMEcsSUFBSSxNQUFNLElBQUksTUFBTSxFQUFDO0FBQ2pELE1BQU1FLFdBQVcsQ0FBQzVDLFFBQVFELFVBQVVFLFlBQWMsQ0FBQyxHQUFHakQsV0FBVzZGLFdBQVcsRUFBRSxDQUFDQyxPQUFPLENBQUMsQ0FBQyxHQUFLLElBQUlsRyxPQUFPbUQsVUFBVUMsUUFBUThDLEtBQUtDLEtBQUssS0FBS0MsWUFBWS9DLFlBQVk2QyxLQUFLQyxLQUFLLEVBQUU7QUFDN0ssd0NBQXdDLEdBQ3hDL0csZ0JBQWdCLEdBQUcsQ0FBQyxJQUFNNEcsU0FBUyxNQUFNLEtBQUssTUFBTSxFQUFDO0FBQ3JELHdDQUF3QyxHQUN4QzVHLGdCQUFnQixHQUFHLENBQUMsSUFBTTRHLFNBQVMsTUFBTSxLQUFLLE1BQU0sRUFBQyxLQUNyRCxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGF3LXdvcmtzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL3NoYTMuanM/MzdhZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2hha2UyNTYgPSBleHBvcnRzLnNoYWtlMTI4ID0gZXhwb3J0cy5rZWNjYWtfNTEyID0gZXhwb3J0cy5rZWNjYWtfMzg0ID0gZXhwb3J0cy5rZWNjYWtfMjU2ID0gZXhwb3J0cy5rZWNjYWtfMjI0ID0gZXhwb3J0cy5zaGEzXzUxMiA9IGV4cG9ydHMuc2hhM18zODQgPSBleHBvcnRzLnNoYTNfMjU2ID0gZXhwb3J0cy5zaGEzXzIyNCA9IGV4cG9ydHMuS2VjY2FrID0gdm9pZCAwO1xuZXhwb3J0cy5rZWNjYWtQID0ga2VjY2FrUDtcbi8qKlxuICogU0hBMyAoa2VjY2FrKSBoYXNoIGZ1bmN0aW9uLCBiYXNlZCBvbiBhIG5ldyBcIlNwb25nZSBmdW5jdGlvblwiIGRlc2lnbi5cbiAqIERpZmZlcmVudCBmcm9tIG9sZGVyIGhhc2hlcywgdGhlIGludGVybmFsIHN0YXRlIGlzIGJpZ2dlciB0aGFuIG91dHB1dCBzaXplLlxuICpcbiAqIENoZWNrIG91dCBbRklQUy0yMDJdKGh0dHBzOi8vbnZscHVicy5uaXN0Lmdvdi9uaXN0cHVicy9GSVBTL05JU1QuRklQUy4yMDIucGRmKSxcbiAqIFtXZWJzaXRlXShodHRwczovL2tlY2Nhay50ZWFtL2tlY2Nhay5odG1sKSxcbiAqIFt0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBTSEEtMyBhbmQgS2VjY2FrXShodHRwczovL2NyeXB0by5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvMTU3Mjcvd2hhdC1hcmUtdGhlLWtleS1kaWZmZXJlbmNlcy1iZXR3ZWVuLXRoZS1kcmFmdC1zaGEtMy1zdGFuZGFyZC1hbmQtdGhlLWtlY2Nhay1zdWIpLlxuICpcbiAqIENoZWNrIG91dCBgc2hhMy1hZGRvbnNgIG1vZHVsZSBmb3IgY1NIQUtFLCBrMTIsIGFuZCBvdGhlcnMuXG4gKiBAbW9kdWxlXG4gKi9cbmNvbnN0IF91NjRfdHNfMSA9IHJlcXVpcmUoXCIuL191NjQuanNcIik7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IHV0aWxzX3RzXzEgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbi8vIE5vIF9fUFVSRV9fIGFubm90YXRpb25zIGluIHNoYTMgaGVhZGVyOlxuLy8gRVZFUllUSElORyBpcyBpbiBmYWN0IHVzZWQgb24gZXZlcnkgZXhwb3J0LlxuLy8gVmFyaW91cyBwZXIgcm91bmQgY29uc3RhbnRzIGNhbGN1bGF0aW9uc1xuY29uc3QgXzBuID0gQmlnSW50KDApO1xuY29uc3QgXzFuID0gQmlnSW50KDEpO1xuY29uc3QgXzJuID0gQmlnSW50KDIpO1xuY29uc3QgXzduID0gQmlnSW50KDcpO1xuY29uc3QgXzI1Nm4gPSBCaWdJbnQoMjU2KTtcbmNvbnN0IF8weDcxbiA9IEJpZ0ludCgweDcxKTtcbmNvbnN0IFNIQTNfUEkgPSBbXTtcbmNvbnN0IFNIQTNfUk9UTCA9IFtdO1xuY29uc3QgX1NIQTNfSU9UQSA9IFtdO1xuZm9yIChsZXQgcm91bmQgPSAwLCBSID0gXzFuLCB4ID0gMSwgeSA9IDA7IHJvdW5kIDwgMjQ7IHJvdW5kKyspIHtcbiAgICAvLyBQaVxuICAgIFt4LCB5XSA9IFt5LCAoMiAqIHggKyAzICogeSkgJSA1XTtcbiAgICBTSEEzX1BJLnB1c2goMiAqICg1ICogeSArIHgpKTtcbiAgICAvLyBSb3RhdGlvbmFsXG4gICAgU0hBM19ST1RMLnB1c2goKCgocm91bmQgKyAxKSAqIChyb3VuZCArIDIpKSAvIDIpICUgNjQpO1xuICAgIC8vIElvdGFcbiAgICBsZXQgdCA9IF8wbjtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IDc7IGorKykge1xuICAgICAgICBSID0gKChSIDw8IF8xbikgXiAoKFIgPj4gXzduKSAqIF8weDcxbikpICUgXzI1Nm47XG4gICAgICAgIGlmIChSICYgXzJuKVxuICAgICAgICAgICAgdCBePSBfMW4gPDwgKChfMW4gPDwgLyogQF9fUFVSRV9fICovIEJpZ0ludChqKSkgLSBfMW4pO1xuICAgIH1cbiAgICBfU0hBM19JT1RBLnB1c2godCk7XG59XG5jb25zdCBJT1RBUyA9ICgwLCBfdTY0X3RzXzEuc3BsaXQpKF9TSEEzX0lPVEEsIHRydWUpO1xuY29uc3QgU0hBM19JT1RBX0ggPSBJT1RBU1swXTtcbmNvbnN0IFNIQTNfSU9UQV9MID0gSU9UQVNbMV07XG4vLyBMZWZ0IHJvdGF0aW9uICh3aXRob3V0IDAsIDMyLCA2NClcbmNvbnN0IHJvdGxIID0gKGgsIGwsIHMpID0+IChzID4gMzIgPyAoMCwgX3U2NF90c18xLnJvdGxCSCkoaCwgbCwgcykgOiAoMCwgX3U2NF90c18xLnJvdGxTSCkoaCwgbCwgcykpO1xuY29uc3Qgcm90bEwgPSAoaCwgbCwgcykgPT4gKHMgPiAzMiA/ICgwLCBfdTY0X3RzXzEucm90bEJMKShoLCBsLCBzKSA6ICgwLCBfdTY0X3RzXzEucm90bFNMKShoLCBsLCBzKSk7XG4vKiogYGtlY2Nha2YxNjAwYCBpbnRlcm5hbCBmdW5jdGlvbiwgYWRkaXRpb25hbGx5IGFsbG93cyB0byBhZGp1c3Qgcm91bmQgY291bnQuICovXG5mdW5jdGlvbiBrZWNjYWtQKHMsIHJvdW5kcyA9IDI0KSB7XG4gICAgY29uc3QgQiA9IG5ldyBVaW50MzJBcnJheSg1ICogMik7XG4gICAgLy8gTk9URTogYWxsIGluZGljZXMgYXJlIHgyIHNpbmNlIHdlIHN0b3JlIHN0YXRlIGFzIHUzMiBpbnN0ZWFkIG9mIHU2NCAoYmlnaW50cyB0byBzbG93IGluIGpzKVxuICAgIGZvciAobGV0IHJvdW5kID0gMjQgLSByb3VuZHM7IHJvdW5kIDwgMjQ7IHJvdW5kKyspIHtcbiAgICAgICAgLy8gVGhldGEgzrhcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCsrKVxuICAgICAgICAgICAgQlt4XSA9IHNbeF0gXiBzW3ggKyAxMF0gXiBzW3ggKyAyMF0gXiBzW3ggKyAzMF0gXiBzW3ggKyA0MF07XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHggKz0gMikge1xuICAgICAgICAgICAgY29uc3QgaWR4MSA9ICh4ICsgOCkgJSAxMDtcbiAgICAgICAgICAgIGNvbnN0IGlkeDAgPSAoeCArIDIpICUgMTA7XG4gICAgICAgICAgICBjb25zdCBCMCA9IEJbaWR4MF07XG4gICAgICAgICAgICBjb25zdCBCMSA9IEJbaWR4MCArIDFdO1xuICAgICAgICAgICAgY29uc3QgVGggPSByb3RsSChCMCwgQjEsIDEpIF4gQltpZHgxXTtcbiAgICAgICAgICAgIGNvbnN0IFRsID0gcm90bEwoQjAsIEIxLCAxKSBeIEJbaWR4MSArIDFdO1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCA1MDsgeSArPSAxMCkge1xuICAgICAgICAgICAgICAgIHNbeCArIHldIF49IFRoO1xuICAgICAgICAgICAgICAgIHNbeCArIHkgKyAxXSBePSBUbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSaG8gKM+BKSBhbmQgUGkgKM+AKVxuICAgICAgICBsZXQgY3VySCA9IHNbMl07XG4gICAgICAgIGxldCBjdXJMID0gc1szXTtcbiAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCAyNDsgdCsrKSB7XG4gICAgICAgICAgICBjb25zdCBzaGlmdCA9IFNIQTNfUk9UTFt0XTtcbiAgICAgICAgICAgIGNvbnN0IFRoID0gcm90bEgoY3VySCwgY3VyTCwgc2hpZnQpO1xuICAgICAgICAgICAgY29uc3QgVGwgPSByb3RsTChjdXJILCBjdXJMLCBzaGlmdCk7XG4gICAgICAgICAgICBjb25zdCBQSSA9IFNIQTNfUElbdF07XG4gICAgICAgICAgICBjdXJIID0gc1tQSV07XG4gICAgICAgICAgICBjdXJMID0gc1tQSSArIDFdO1xuICAgICAgICAgICAgc1tQSV0gPSBUaDtcbiAgICAgICAgICAgIHNbUEkgKyAxXSA9IFRsO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoaSAoz4cpXG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgNTA7IHkgKz0gMTApIHtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHgrKylcbiAgICAgICAgICAgICAgICBCW3hdID0gc1t5ICsgeF07XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4KyspXG4gICAgICAgICAgICAgICAgc1t5ICsgeF0gXj0gfkJbKHggKyAyKSAlIDEwXSAmIEJbKHggKyA0KSAlIDEwXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJb3RhICjOuSlcbiAgICAgICAgc1swXSBePSBTSEEzX0lPVEFfSFtyb3VuZF07XG4gICAgICAgIHNbMV0gXj0gU0hBM19JT1RBX0xbcm91bmRdO1xuICAgIH1cbiAgICAoMCwgdXRpbHNfdHNfMS5jbGVhbikoQik7XG59XG4vKiogS2VjY2FrIHNwb25nZSBmdW5jdGlvbi4gKi9cbmNsYXNzIEtlY2NhayBleHRlbmRzIHV0aWxzX3RzXzEuSGFzaCB7XG4gICAgLy8gTk9URTogd2UgYWNjZXB0IGFyZ3VtZW50cyBpbiBieXRlcyBpbnN0ZWFkIG9mIGJpdHMgaGVyZS5cbiAgICBjb25zdHJ1Y3RvcihibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4sIGVuYWJsZVhPRiA9IGZhbHNlLCByb3VuZHMgPSAyNCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMucG9zT3V0ID0gMDtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVuYWJsZVhPRiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRoaXMuc3VmZml4ID0gc3VmZml4O1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdGhpcy5lbmFibGVYT0YgPSBlbmFibGVYT0Y7XG4gICAgICAgIHRoaXMucm91bmRzID0gcm91bmRzO1xuICAgICAgICAvLyBDYW4gYmUgcGFzc2VkIGZyb20gdXNlciBhcyBka0xlblxuICAgICAgICAoMCwgdXRpbHNfdHNfMS5hbnVtYmVyKShvdXRwdXRMZW4pO1xuICAgICAgICAvLyAxNjAwID0gNXg1IG1hdHJpeCBvZiA2NGJpdC4gIDE2MDAgYml0cyA9PT0gMjAwIGJ5dGVzXG4gICAgICAgIC8vIDAgPCBibG9ja0xlbiA8IDIwMFxuICAgICAgICBpZiAoISgwIDwgYmxvY2tMZW4gJiYgYmxvY2tMZW4gPCAyMDApKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvbmx5IGtlY2Nhay1mMTYwMCBmdW5jdGlvbiBpcyBzdXBwb3J0ZWQnKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IG5ldyBVaW50OEFycmF5KDIwMCk7XG4gICAgICAgIHRoaXMuc3RhdGUzMiA9ICgwLCB1dGlsc190c18xLnUzMikodGhpcy5zdGF0ZSk7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvbmVJbnRvKCk7XG4gICAgfVxuICAgIGtlY2NhaygpIHtcbiAgICAgICAgKDAsIHV0aWxzX3RzXzEuc3dhcDMySWZCRSkodGhpcy5zdGF0ZTMyKTtcbiAgICAgICAga2VjY2FrUCh0aGlzLnN0YXRlMzIsIHRoaXMucm91bmRzKTtcbiAgICAgICAgKDAsIHV0aWxzX3RzXzEuc3dhcDMySWZCRSkodGhpcy5zdGF0ZTMyKTtcbiAgICAgICAgdGhpcy5wb3NPdXQgPSAwO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgfVxuICAgIHVwZGF0ZShkYXRhKSB7XG4gICAgICAgICgwLCB1dGlsc190c18xLmFleGlzdHMpKHRoaXMpO1xuICAgICAgICBkYXRhID0gKDAsIHV0aWxzX3RzXzEudG9CeXRlcykoZGF0YSk7XG4gICAgICAgICgwLCB1dGlsc190c18xLmFieXRlcykoZGF0YSk7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIHN0YXRlIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3MsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRha2U7IGkrKylcbiAgICAgICAgICAgICAgICBzdGF0ZVt0aGlzLnBvcysrXSBePSBkYXRhW3BvcysrXTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA9PT0gYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgdGhpcy5rZWNjYWsoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZmluaXNoKCkge1xuICAgICAgICBpZiAodGhpcy5maW5pc2hlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIGNvbnN0IHsgc3RhdGUsIHN1ZmZpeCwgcG9zLCBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgLy8gRG8gdGhlIHBhZGRpbmdcbiAgICAgICAgc3RhdGVbcG9zXSBePSBzdWZmaXg7XG4gICAgICAgIGlmICgoc3VmZml4ICYgMHg4MCkgIT09IDAgJiYgcG9zID09PSBibG9ja0xlbiAtIDEpXG4gICAgICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgICAgICBzdGF0ZVtibG9ja0xlbiAtIDFdIF49IDB4ODA7XG4gICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgfVxuICAgIHdyaXRlSW50byhvdXQpIHtcbiAgICAgICAgKDAsIHV0aWxzX3RzXzEuYWV4aXN0cykodGhpcywgZmFsc2UpO1xuICAgICAgICAoMCwgdXRpbHNfdHNfMS5hYnl0ZXMpKG91dCk7XG4gICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlck91dCA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4gfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDAsIGxlbiA9IG91dC5sZW5ndGg7IHBvcyA8IGxlbjspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvc091dCA+PSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3NPdXQsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICBvdXQuc2V0KGJ1ZmZlck91dC5zdWJhcnJheSh0aGlzLnBvc091dCwgdGhpcy5wb3NPdXQgKyB0YWtlKSwgcG9zKTtcbiAgICAgICAgICAgIHRoaXMucG9zT3V0ICs9IHRha2U7XG4gICAgICAgICAgICBwb3MgKz0gdGFrZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICB4b2ZJbnRvKG91dCkge1xuICAgICAgICAvLyBTaGEzL0tlY2NhayB1c2FnZSB3aXRoIFhPRiBpcyBwcm9iYWJseSBtaXN0YWtlLCBvbmx5IFNIQUtFIGluc3RhbmNlcyBjYW4gZG8gWE9GXG4gICAgICAgIGlmICghdGhpcy5lbmFibGVYT0YpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1hPRiBpcyBub3QgcG9zc2libGUgZm9yIHRoaXMgaW5zdGFuY2UnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVJbnRvKG91dCk7XG4gICAgfVxuICAgIHhvZihieXRlcykge1xuICAgICAgICAoMCwgdXRpbHNfdHNfMS5hbnVtYmVyKShieXRlcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnhvZkludG8obmV3IFVpbnQ4QXJyYXkoYnl0ZXMpKTtcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgKDAsIHV0aWxzX3RzXzEuYW91dHB1dCkob3V0LCB0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuZmluaXNoZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpZ2VzdCgpIHdhcyBhbHJlYWR5IGNhbGxlZCcpO1xuICAgICAgICB0aGlzLndyaXRlSW50byhvdXQpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaWdlc3RJbnRvKG5ldyBVaW50OEFycmF5KHRoaXMub3V0cHV0TGVuKSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgKDAsIHV0aWxzX3RzXzEuY2xlYW4pKHRoaXMuc3RhdGUpO1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuLCByb3VuZHMsIGVuYWJsZVhPRiB9ID0gdGhpcztcbiAgICAgICAgdG8gfHwgKHRvID0gbmV3IEtlY2NhayhibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4sIGVuYWJsZVhPRiwgcm91bmRzKSk7XG4gICAgICAgIHRvLnN0YXRlMzIuc2V0KHRoaXMuc3RhdGUzMik7XG4gICAgICAgIHRvLnBvcyA9IHRoaXMucG9zO1xuICAgICAgICB0by5wb3NPdXQgPSB0aGlzLnBvc091dDtcbiAgICAgICAgdG8uZmluaXNoZWQgPSB0aGlzLmZpbmlzaGVkO1xuICAgICAgICB0by5yb3VuZHMgPSByb3VuZHM7XG4gICAgICAgIC8vIFN1ZmZpeCBjYW4gY2hhbmdlIGluIGNTSEFLRVxuICAgICAgICB0by5zdWZmaXggPSBzdWZmaXg7XG4gICAgICAgIHRvLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdG8uZW5hYmxlWE9GID0gZW5hYmxlWE9GO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSB0aGlzLmRlc3Ryb3llZDtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbn1cbmV4cG9ydHMuS2VjY2FrID0gS2VjY2FrO1xuY29uc3QgZ2VuID0gKHN1ZmZpeCwgYmxvY2tMZW4sIG91dHB1dExlbikgPT4gKDAsIHV0aWxzX3RzXzEuY3JlYXRlSGFzaGVyKSgoKSA9PiBuZXcgS2VjY2FrKGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbikpO1xuLyoqIFNIQTMtMjI0IGhhc2ggZnVuY3Rpb24uICovXG5leHBvcnRzLnNoYTNfMjI0ID0gKCgpID0+IGdlbigweDA2LCAxNDQsIDIyNCAvIDgpKSgpO1xuLyoqIFNIQTMtMjU2IGhhc2ggZnVuY3Rpb24uIERpZmZlcmVudCBmcm9tIGtlY2Nhay0yNTYuICovXG5leHBvcnRzLnNoYTNfMjU2ID0gKCgpID0+IGdlbigweDA2LCAxMzYsIDI1NiAvIDgpKSgpO1xuLyoqIFNIQTMtMzg0IGhhc2ggZnVuY3Rpb24uICovXG5leHBvcnRzLnNoYTNfMzg0ID0gKCgpID0+IGdlbigweDA2LCAxMDQsIDM4NCAvIDgpKSgpO1xuLyoqIFNIQTMtNTEyIGhhc2ggZnVuY3Rpb24uICovXG5leHBvcnRzLnNoYTNfNTEyID0gKCgpID0+IGdlbigweDA2LCA3MiwgNTEyIC8gOCkpKCk7XG4vKioga2VjY2FrLTIyNCBoYXNoIGZ1bmN0aW9uLiAqL1xuZXhwb3J0cy5rZWNjYWtfMjI0ID0gKCgpID0+IGdlbigweDAxLCAxNDQsIDIyNCAvIDgpKSgpO1xuLyoqIGtlY2Nhay0yNTYgaGFzaCBmdW5jdGlvbi4gRGlmZmVyZW50IGZyb20gU0hBMy0yNTYuICovXG5leHBvcnRzLmtlY2Nha18yNTYgPSAoKCkgPT4gZ2VuKDB4MDEsIDEzNiwgMjU2IC8gOCkpKCk7XG4vKioga2VjY2FrLTM4NCBoYXNoIGZ1bmN0aW9uLiAqL1xuZXhwb3J0cy5rZWNjYWtfMzg0ID0gKCgpID0+IGdlbigweDAxLCAxMDQsIDM4NCAvIDgpKSgpO1xuLyoqIGtlY2Nhay01MTIgaGFzaCBmdW5jdGlvbi4gKi9cbmV4cG9ydHMua2VjY2FrXzUxMiA9ICgoKSA9PiBnZW4oMHgwMSwgNzIsIDUxMiAvIDgpKSgpO1xuY29uc3QgZ2VuU2hha2UgPSAoc3VmZml4LCBibG9ja0xlbiwgb3V0cHV0TGVuKSA9PiAoMCwgdXRpbHNfdHNfMS5jcmVhdGVYT0ZlcikoKG9wdHMgPSB7fSkgPT4gbmV3IEtlY2NhayhibG9ja0xlbiwgc3VmZml4LCBvcHRzLmRrTGVuID09PSB1bmRlZmluZWQgPyBvdXRwdXRMZW4gOiBvcHRzLmRrTGVuLCB0cnVlKSk7XG4vKiogU0hBS0UxMjggWE9GIHdpdGggMTI4LWJpdCBzZWN1cml0eS4gKi9cbmV4cG9ydHMuc2hha2UxMjggPSAoKCkgPT4gZ2VuU2hha2UoMHgxZiwgMTY4LCAxMjggLyA4KSkoKTtcbi8qKiBTSEFLRTI1NiBYT0Ygd2l0aCAyNTYtYml0IHNlY3VyaXR5LiAqL1xuZXhwb3J0cy5zaGFrZTI1NiA9ICgoKSA9PiBnZW5TaGFrZSgweDFmLCAxMzYsIDI1NiAvIDgpKSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhMy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJzaGFrZTI1NiIsInNoYWtlMTI4Iiwia2VjY2FrXzUxMiIsImtlY2Nha18zODQiLCJrZWNjYWtfMjU2Iiwia2VjY2FrXzIyNCIsInNoYTNfNTEyIiwic2hhM18zODQiLCJzaGEzXzI1NiIsInNoYTNfMjI0IiwiS2VjY2FrIiwia2VjY2FrUCIsIl91NjRfdHNfMSIsInJlcXVpcmUiLCJ1dGlsc190c18xIiwiXzBuIiwiQmlnSW50IiwiXzFuIiwiXzJuIiwiXzduIiwiXzI1Nm4iLCJfMHg3MW4iLCJTSEEzX1BJIiwiU0hBM19ST1RMIiwiX1NIQTNfSU9UQSIsInJvdW5kIiwiUiIsIngiLCJ5IiwicHVzaCIsInQiLCJqIiwiSU9UQVMiLCJzcGxpdCIsIlNIQTNfSU9UQV9IIiwiU0hBM19JT1RBX0wiLCJyb3RsSCIsImgiLCJsIiwicyIsInJvdGxCSCIsInJvdGxTSCIsInJvdGxMIiwicm90bEJMIiwicm90bFNMIiwicm91bmRzIiwiQiIsIlVpbnQzMkFycmF5IiwiaWR4MSIsImlkeDAiLCJCMCIsIkIxIiwiVGgiLCJUbCIsImN1ckgiLCJjdXJMIiwic2hpZnQiLCJQSSIsImNsZWFuIiwiSGFzaCIsImNvbnN0cnVjdG9yIiwiYmxvY2tMZW4iLCJzdWZmaXgiLCJvdXRwdXRMZW4iLCJlbmFibGVYT0YiLCJwb3MiLCJwb3NPdXQiLCJmaW5pc2hlZCIsImRlc3Ryb3llZCIsImFudW1iZXIiLCJFcnJvciIsInN0YXRlIiwiVWludDhBcnJheSIsInN0YXRlMzIiLCJ1MzIiLCJjbG9uZSIsIl9jbG9uZUludG8iLCJrZWNjYWsiLCJzd2FwMzJJZkJFIiwidXBkYXRlIiwiZGF0YSIsImFleGlzdHMiLCJ0b0J5dGVzIiwiYWJ5dGVzIiwibGVuIiwibGVuZ3RoIiwidGFrZSIsIk1hdGgiLCJtaW4iLCJpIiwiZmluaXNoIiwid3JpdGVJbnRvIiwib3V0IiwiYnVmZmVyT3V0Iiwic2V0Iiwic3ViYXJyYXkiLCJ4b2ZJbnRvIiwieG9mIiwiYnl0ZXMiLCJkaWdlc3RJbnRvIiwiYW91dHB1dCIsImRlc3Ryb3kiLCJkaWdlc3QiLCJ0byIsImdlbiIsImNyZWF0ZUhhc2hlciIsImdlblNoYWtlIiwiY3JlYXRlWE9GZXIiLCJvcHRzIiwiZGtMZW4iLCJ1bmRlZmluZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/@noble/hashes/sha3.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/@noble/hashes/utils.js":
/*!*************************************************************!*\
  !*** ./node_modules/ox/node_modules/@noble/hashes/utils.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */ /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.Hash = exports.nextTick = exports.swap32IfBE = exports.byteSwapIfBE = exports.swap8IfBE = exports.isLE = void 0;\nexports.isBytes = isBytes;\nexports.anumber = anumber;\nexports.abytes = abytes;\nexports.ahash = ahash;\nexports.aexists = aexists;\nexports.aoutput = aoutput;\nexports.u8 = u8;\nexports.u32 = u32;\nexports.clean = clean;\nexports.createView = createView;\nexports.rotr = rotr;\nexports.rotl = rotl;\nexports.byteSwap = byteSwap;\nexports.byteSwap32 = byteSwap32;\nexports.bytesToHex = bytesToHex;\nexports.hexToBytes = hexToBytes;\nexports.asyncLoop = asyncLoop;\nexports.utf8ToBytes = utf8ToBytes;\nexports.bytesToUtf8 = bytesToUtf8;\nexports.toBytes = toBytes;\nexports.kdfInputToBytes = kdfInputToBytes;\nexports.concatBytes = concatBytes;\nexports.checkOpts = checkOpts;\nexports.createHasher = createHasher;\nexports.createOptHasher = createOptHasher;\nexports.createXOFer = createXOFer;\nexports.randomBytes = randomBytes;\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nconst crypto_1 = __webpack_require__(/*! @noble/hashes/crypto */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/cryptoNode.js\");\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */ function isBytes(a) {\n    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === \"Uint8Array\";\n}\n/** Asserts something is positive integer. */ function anumber(n) {\n    if (!Number.isSafeInteger(n) || n < 0) throw new Error(\"positive integer expected, got \" + n);\n}\n/** Asserts something is Uint8Array. */ function abytes(b, ...lengths) {\n    if (!isBytes(b)) throw new Error(\"Uint8Array expected\");\n    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error(\"Uint8Array expected of length \" + lengths + \", got length=\" + b.length);\n}\n/** Asserts something is hash */ function ahash(h) {\n    if (typeof h !== \"function\" || typeof h.create !== \"function\") throw new Error(\"Hash should be wrapped by utils.createHasher\");\n    anumber(h.outputLen);\n    anumber(h.blockLen);\n}\n/** Asserts a hash instance has not been destroyed / finished */ function aexists(instance, checkFinished = true) {\n    if (instance.destroyed) throw new Error(\"Hash instance has been destroyed\");\n    if (checkFinished && instance.finished) throw new Error(\"Hash#digest() has already been called\");\n}\n/** Asserts output is properly-sized byte array */ function aoutput(out, instance) {\n    abytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(\"digestInto() expects output buffer of length at least \" + min);\n    }\n}\n/** Cast u8 / u16 / u32 to u8. */ function u8(arr) {\n    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** Cast u8 / u16 / u32 to u32. */ function u32(arr) {\n    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n/** Zeroize a byte array. Warning: JS provides no guarantees. */ function clean(...arrays) {\n    for(let i = 0; i < arrays.length; i++){\n        arrays[i].fill(0);\n    }\n}\n/** Create DataView of an array for easy byte-level manipulation. */ function createView(arr) {\n    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** The rotate right (circular right shift) operation for uint32 */ function rotr(word, shift) {\n    return word << 32 - shift | word >>> shift;\n}\n/** The rotate left (circular left shift) operation for uint32 */ function rotl(word, shift) {\n    return word << shift | word >>> 32 - shift >>> 0;\n}\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */ exports.isLE = (()=>new Uint8Array(new Uint32Array([\n        0x11223344\n    ]).buffer)[0] === 0x44)();\n/** The byte swap operation for uint32 */ function byteSwap(word) {\n    return word << 24 & 0xff000000 | word << 8 & 0xff0000 | word >>> 8 & 0xff00 | word >>> 24 & 0xff;\n}\n/** Conditionally byte swap if on a big-endian platform */ exports.swap8IfBE = exports.isLE ? (n)=>n : (n)=>byteSwap(n);\n/** @deprecated */ exports.byteSwapIfBE = exports.swap8IfBE;\n/** In place byte swap for Uint32Array */ function byteSwap32(arr) {\n    for(let i = 0; i < arr.length; i++){\n        arr[i] = byteSwap(arr[i]);\n    }\n    return arr;\n}\nexports.swap32IfBE = exports.isLE ? (u)=>u : byteSwap32;\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin = /* @__PURE__ */ (()=>// @ts-ignore\n    typeof Uint8Array.from([]).toHex === \"function\" && typeof Uint8Array.fromHex === \"function\")();\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({\n    length: 256\n}, (_, i)=>i.toString(16).padStart(2, \"0\"));\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */ function bytesToHex(bytes) {\n    abytes(bytes);\n    // @ts-ignore\n    if (hasHexBuiltin) return bytes.toHex();\n    // pre-caching improves the speed 6x\n    let hex = \"\";\n    for(let i = 0; i < bytes.length; i++){\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = {\n    _0: 48,\n    _9: 57,\n    A: 65,\n    F: 70,\n    a: 97,\n    f: 102\n};\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */ function hexToBytes(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    // @ts-ignore\n    if (hasHexBuiltin) return Uint8Array.fromHex(hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2) throw new Error(\"hex string expected, got unpadded hex of length \" + hl);\n    const array = new Uint8Array(al);\n    for(let ai = 0, hi = 0; ai < al; ai++, hi += 2){\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */ const nextTick = async ()=>{};\nexports.nextTick = nextTick;\n/** Returns control to thread each 'tick' ms to avoid blocking. */ async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for(let i = 0; i < iters; i++){\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick) continue;\n        await (0, exports.nextTick)();\n        ts += diff;\n    }\n}\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */ function utf8ToBytes(str) {\n    if (typeof str !== \"string\") throw new Error(\"string expected\");\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */ function bytesToUtf8(bytes) {\n    return new TextDecoder().decode(bytes);\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */ function toBytes(data) {\n    if (typeof data === \"string\") data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */ function kdfInputToBytes(data) {\n    if (typeof data === \"string\") data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/** Copies several Uint8Arrays into one. */ function concatBytes(...arrays) {\n    let sum = 0;\n    for(let i = 0; i < arrays.length; i++){\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for(let i = 0, pad = 0; i < arrays.length; i++){\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && ({}).toString.call(opts) !== \"[object Object]\") throw new Error(\"options should be object or undefined\");\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\n/** For runtime check if class implements interface */ class Hash {\n}\nexports.Hash = Hash;\n/** Wraps hash function, creating an interface on top of it */ function createHasher(hashCons) {\n    const hashC = (msg)=>hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = ()=>hashCons();\n    return hashC;\n}\nfunction createOptHasher(hashCons) {\n    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts)=>hashCons(opts);\n    return hashC;\n}\nfunction createXOFer(hashCons) {\n    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts)=>hashCons(opts);\n    return hashC;\n}\nexports.wrapConstructor = createHasher;\nexports.wrapConstructorWithOpts = createOptHasher;\nexports.wrapXOFConstructorWithOpts = createXOFer;\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */ function randomBytes(bytesLength = 32) {\n    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === \"function\") {\n        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    // Legacy Node.js compatibility\n    if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === \"function\") {\n        return Uint8Array.from(crypto_1.crypto.randomBytes(bytesLength));\n    }\n    throw new Error(\"crypto.getRandomValues must be defined\");\n} //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7O0NBR0MsR0FDRCxvRUFBb0UsR0FDcEVBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxrQ0FBa0MsR0FBR0EsK0JBQStCLEdBQUdBLHVCQUF1QixHQUFHQSxZQUFZLEdBQUdBLGdCQUFnQixHQUFHQSxrQkFBa0IsR0FBR0Esb0JBQW9CLEdBQUdBLGlCQUFpQixHQUFHQSxZQUFZLEdBQUcsS0FBSztBQUN2TkEsZUFBZSxHQUFHVztBQUNsQlgsZUFBZSxHQUFHWTtBQUNsQlosY0FBYyxHQUFHYTtBQUNqQmIsYUFBYSxHQUFHYztBQUNoQmQsZUFBZSxHQUFHZTtBQUNsQmYsZUFBZSxHQUFHZ0I7QUFDbEJoQixVQUFVLEdBQUdpQjtBQUNiakIsV0FBVyxHQUFHa0I7QUFDZGxCLGFBQWEsR0FBR21CO0FBQ2hCbkIsa0JBQWtCLEdBQUdvQjtBQUNyQnBCLFlBQVksR0FBR3FCO0FBQ2ZyQixZQUFZLEdBQUdzQjtBQUNmdEIsZ0JBQWdCLEdBQUd1QjtBQUNuQnZCLGtCQUFrQixHQUFHd0I7QUFDckJ4QixrQkFBa0IsR0FBR3lCO0FBQ3JCekIsa0JBQWtCLEdBQUcwQjtBQUNyQjFCLGlCQUFpQixHQUFHMkI7QUFDcEIzQixtQkFBbUIsR0FBRzRCO0FBQ3RCNUIsbUJBQW1CLEdBQUc2QjtBQUN0QjdCLGVBQWUsR0FBRzhCO0FBQ2xCOUIsdUJBQXVCLEdBQUcrQjtBQUMxQi9CLG1CQUFtQixHQUFHZ0M7QUFDdEJoQyxpQkFBaUIsR0FBR2lDO0FBQ3BCakMsb0JBQW9CLEdBQUdrQztBQUN2QmxDLHVCQUF1QixHQUFHbUM7QUFDMUJuQyxtQkFBbUIsR0FBR29DO0FBQ3RCcEMsbUJBQW1CLEdBQUdxQztBQUN0QixvRkFBb0Y7QUFDcEYsc0VBQXNFO0FBQ3RFLGtFQUFrRTtBQUNsRSw4REFBOEQ7QUFDOUQs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MUUsT0FBT25HLFNBQVNrRyxNQUFNLENBQUNDLGVBQWUsQ0FBQyxJQUFJaEcsV0FBVzhGO0lBQzFEO0lBQ0EsK0JBQStCO0lBQy9CLElBQUlqRyxTQUFTa0csTUFBTSxJQUFJLE9BQU9sRyxTQUFTa0csTUFBTSxDQUFDbkcsV0FBVyxLQUFLLFlBQVk7UUFDdEUsT0FBT0ksV0FBV3NDLElBQUksQ0FBQ3pDLFNBQVNrRyxNQUFNLENBQUNuRyxXQUFXLENBQUNrRztJQUN2RDtJQUNBLE1BQU0sSUFBSXRGLE1BQU07QUFDcEIsRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGF3LXdvcmtzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL3V0aWxzLmpzP2M2ZjEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIFV0aWxpdGllcyBmb3IgaGV4LCBieXRlcywgQ1NQUk5HLlxuICogQG1vZHVsZVxuICovXG4vKiEgbm9ibGUtaGFzaGVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLndyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzID0gZXhwb3J0cy53cmFwQ29uc3RydWN0b3JXaXRoT3B0cyA9IGV4cG9ydHMud3JhcENvbnN0cnVjdG9yID0gZXhwb3J0cy5IYXNoID0gZXhwb3J0cy5uZXh0VGljayA9IGV4cG9ydHMuc3dhcDMySWZCRSA9IGV4cG9ydHMuYnl0ZVN3YXBJZkJFID0gZXhwb3J0cy5zd2FwOElmQkUgPSBleHBvcnRzLmlzTEUgPSB2b2lkIDA7XG5leHBvcnRzLmlzQnl0ZXMgPSBpc0J5dGVzO1xuZXhwb3J0cy5hbnVtYmVyID0gYW51bWJlcjtcbmV4cG9ydHMuYWJ5dGVzID0gYWJ5dGVzO1xuZXhwb3J0cy5haGFzaCA9IGFoYXNoO1xuZXhwb3J0cy5hZXhpc3RzID0gYWV4aXN0cztcbmV4cG9ydHMuYW91dHB1dCA9IGFvdXRwdXQ7XG5leHBvcnRzLnU4ID0gdTg7XG5leHBvcnRzLnUzMiA9IHUzMjtcbmV4cG9ydHMuY2xlYW4gPSBjbGVhbjtcbmV4cG9ydHMuY3JlYXRlVmlldyA9IGNyZWF0ZVZpZXc7XG5leHBvcnRzLnJvdHIgPSByb3RyO1xuZXhwb3J0cy5yb3RsID0gcm90bDtcbmV4cG9ydHMuYnl0ZVN3YXAgPSBieXRlU3dhcDtcbmV4cG9ydHMuYnl0ZVN3YXAzMiA9IGJ5dGVTd2FwMzI7XG5leHBvcnRzLmJ5dGVzVG9IZXggPSBieXRlc1RvSGV4O1xuZXhwb3J0cy5oZXhUb0J5dGVzID0gaGV4VG9CeXRlcztcbmV4cG9ydHMuYXN5bmNMb29wID0gYXN5bmNMb29wO1xuZXhwb3J0cy51dGY4VG9CeXRlcyA9IHV0ZjhUb0J5dGVzO1xuZXhwb3J0cy5ieXRlc1RvVXRmOCA9IGJ5dGVzVG9VdGY4O1xuZXhwb3J0cy50b0J5dGVzID0gdG9CeXRlcztcbmV4cG9ydHMua2RmSW5wdXRUb0J5dGVzID0ga2RmSW5wdXRUb0J5dGVzO1xuZXhwb3J0cy5jb25jYXRCeXRlcyA9IGNvbmNhdEJ5dGVzO1xuZXhwb3J0cy5jaGVja09wdHMgPSBjaGVja09wdHM7XG5leHBvcnRzLmNyZWF0ZUhhc2hlciA9IGNyZWF0ZUhhc2hlcjtcbmV4cG9ydHMuY3JlYXRlT3B0SGFzaGVyID0gY3JlYXRlT3B0SGFzaGVyO1xuZXhwb3J0cy5jcmVhdGVYT0ZlciA9IGNyZWF0ZVhPRmVyO1xuZXhwb3J0cy5yYW5kb21CeXRlcyA9IHJhbmRvbUJ5dGVzO1xuLy8gV2UgdXNlIFdlYkNyeXB0byBha2EgZ2xvYmFsVGhpcy5jcnlwdG8sIHdoaWNoIGV4aXN0cyBpbiBicm93c2VycyBhbmQgbm9kZS5qcyAxNisuXG4vLyBub2RlLmpzIHZlcnNpb25zIGVhcmxpZXIgdGhhbiB2MTkgZG9uJ3QgZGVjbGFyZSBpdCBpbiBnbG9iYWwgc2NvcGUuXG4vLyBGb3Igbm9kZS5qcywgcGFja2FnZS5qc29uI2V4cG9ydHMgZmllbGQgbWFwcGluZyByZXdyaXRlcyBpbXBvcnRcbi8vIGZyb20gYGNyeXB0b2AgdG8gYGNyeXB0b05vZGVgLCB3aGljaCBpbXBvcnRzIG5hdGl2ZSBtb2R1bGUuXG4vLyBNYWtlcyB0aGUgdXRpbHMgdW4taW1wb3J0YWJsZSBpbiBicm93c2VycyB3aXRob3V0IGEgYnVuZGxlci5cbi8vIE9uY2Ugbm9kZS5qcyAxOCBpcyBkZXByZWNhdGVkICgyMDI1LTA0LTMwKSwgd2UgY2FuIGp1c3QgZHJvcCB0aGUgaW1wb3J0LlxuY29uc3QgY3J5cHRvXzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy9jcnlwdG9cIik7XG4vKiogQ2hlY2tzIGlmIHNvbWV0aGluZyBpcyBVaW50OEFycmF5LiBCZSBjYXJlZnVsOiBub2RlanMgQnVmZmVyIHdpbGwgcmV0dXJuIHRydWUuICovXG5mdW5jdGlvbiBpc0J5dGVzKGEpIHtcbiAgICByZXR1cm4gYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgKEFycmF5QnVmZmVyLmlzVmlldyhhKSAmJiBhLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdVaW50OEFycmF5Jyk7XG59XG4vKiogQXNzZXJ0cyBzb21ldGhpbmcgaXMgcG9zaXRpdmUgaW50ZWdlci4gKi9cbmZ1bmN0aW9uIGFudW1iZXIobikge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobikgfHwgbiA8IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncG9zaXRpdmUgaW50ZWdlciBleHBlY3RlZCwgZ290ICcgKyBuKTtcbn1cbi8qKiBBc3NlcnRzIHNvbWV0aGluZyBpcyBVaW50OEFycmF5LiAqL1xuZnVuY3Rpb24gYWJ5dGVzKGIsIC4uLmxlbmd0aHMpIHtcbiAgICBpZiAoIWlzQnl0ZXMoYikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgIGlmIChsZW5ndGhzLmxlbmd0aCA+IDAgJiYgIWxlbmd0aHMuaW5jbHVkZXMoYi5sZW5ndGgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQgb2YgbGVuZ3RoICcgKyBsZW5ndGhzICsgJywgZ290IGxlbmd0aD0nICsgYi5sZW5ndGgpO1xufVxuLyoqIEFzc2VydHMgc29tZXRoaW5nIGlzIGhhc2ggKi9cbmZ1bmN0aW9uIGFoYXNoKGgpIHtcbiAgICBpZiAodHlwZW9mIGggIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGguY3JlYXRlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggc2hvdWxkIGJlIHdyYXBwZWQgYnkgdXRpbHMuY3JlYXRlSGFzaGVyJyk7XG4gICAgYW51bWJlcihoLm91dHB1dExlbik7XG4gICAgYW51bWJlcihoLmJsb2NrTGVuKTtcbn1cbi8qKiBBc3NlcnRzIGEgaGFzaCBpbnN0YW5jZSBoYXMgbm90IGJlZW4gZGVzdHJveWVkIC8gZmluaXNoZWQgKi9cbmZ1bmN0aW9uIGFleGlzdHMoaW5zdGFuY2UsIGNoZWNrRmluaXNoZWQgPSB0cnVlKSB7XG4gICAgaWYgKGluc3RhbmNlLmRlc3Ryb3llZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIGluc3RhbmNlIGhhcyBiZWVuIGRlc3Ryb3llZCcpO1xuICAgIGlmIChjaGVja0ZpbmlzaGVkICYmIGluc3RhbmNlLmZpbmlzaGVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2gjZGlnZXN0KCkgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQnKTtcbn1cbi8qKiBBc3NlcnRzIG91dHB1dCBpcyBwcm9wZXJseS1zaXplZCBieXRlIGFycmF5ICovXG5mdW5jdGlvbiBhb3V0cHV0KG91dCwgaW5zdGFuY2UpIHtcbiAgICBhYnl0ZXMob3V0KTtcbiAgICBjb25zdCBtaW4gPSBpbnN0YW5jZS5vdXRwdXRMZW47XG4gICAgaWYgKG91dC5sZW5ndGggPCBtaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaWdlc3RJbnRvKCkgZXhwZWN0cyBvdXRwdXQgYnVmZmVyIG9mIGxlbmd0aCBhdCBsZWFzdCAnICsgbWluKTtcbiAgICB9XG59XG4vKiogQ2FzdCB1OCAvIHUxNiAvIHUzMiB0byB1OC4gKi9cbmZ1bmN0aW9uIHU4KGFycikge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xufVxuLyoqIENhc3QgdTggLyB1MTYgLyB1MzIgdG8gdTMyLiAqL1xuZnVuY3Rpb24gdTMyKGFycikge1xuICAgIHJldHVybiBuZXcgVWludDMyQXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIE1hdGguZmxvb3IoYXJyLmJ5dGVMZW5ndGggLyA0KSk7XG59XG4vKiogWmVyb2l6ZSBhIGJ5dGUgYXJyYXkuIFdhcm5pbmc6IEpTIHByb3ZpZGVzIG5vIGd1YXJhbnRlZXMuICovXG5mdW5jdGlvbiBjbGVhbiguLi5hcnJheXMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJheXNbaV0uZmlsbCgwKTtcbiAgICB9XG59XG4vKiogQ3JlYXRlIERhdGFWaWV3IG9mIGFuIGFycmF5IGZvciBlYXN5IGJ5dGUtbGV2ZWwgbWFuaXB1bGF0aW9uLiAqL1xuZnVuY3Rpb24gY3JlYXRlVmlldyhhcnIpIHtcbiAgICByZXR1cm4gbmV3IERhdGFWaWV3KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG59XG4vKiogVGhlIHJvdGF0ZSByaWdodCAoY2lyY3VsYXIgcmlnaHQgc2hpZnQpIG9wZXJhdGlvbiBmb3IgdWludDMyICovXG5mdW5jdGlvbiByb3RyKHdvcmQsIHNoaWZ0KSB7XG4gICAgcmV0dXJuICh3b3JkIDw8ICgzMiAtIHNoaWZ0KSkgfCAod29yZCA+Pj4gc2hpZnQpO1xufVxuLyoqIFRoZSByb3RhdGUgbGVmdCAoY2lyY3VsYXIgbGVmdCBzaGlmdCkgb3BlcmF0aW9uIGZvciB1aW50MzIgKi9cbmZ1bmN0aW9uIHJvdGwod29yZCwgc2hpZnQpIHtcbiAgICByZXR1cm4gKHdvcmQgPDwgc2hpZnQpIHwgKCh3b3JkID4+PiAoMzIgLSBzaGlmdCkpID4+PiAwKTtcbn1cbi8qKiBJcyBjdXJyZW50IHBsYXRmb3JtIGxpdHRsZS1lbmRpYW4/IE1vc3QgYXJlLiBCaWctRW5kaWFuIHBsYXRmb3JtOiBJQk0gKi9cbmV4cG9ydHMuaXNMRSA9ICgoKSA9PiBuZXcgVWludDhBcnJheShuZXcgVWludDMyQXJyYXkoWzB4MTEyMjMzNDRdKS5idWZmZXIpWzBdID09PSAweDQ0KSgpO1xuLyoqIFRoZSBieXRlIHN3YXAgb3BlcmF0aW9uIGZvciB1aW50MzIgKi9cbmZ1bmN0aW9uIGJ5dGVTd2FwKHdvcmQpIHtcbiAgICByZXR1cm4gKCgod29yZCA8PCAyNCkgJiAweGZmMDAwMDAwKSB8XG4gICAgICAgICgod29yZCA8PCA4KSAmIDB4ZmYwMDAwKSB8XG4gICAgICAgICgod29yZCA+Pj4gOCkgJiAweGZmMDApIHxcbiAgICAgICAgKCh3b3JkID4+PiAyNCkgJiAweGZmKSk7XG59XG4vKiogQ29uZGl0aW9uYWxseSBieXRlIHN3YXAgaWYgb24gYSBiaWctZW5kaWFuIHBsYXRmb3JtICovXG5leHBvcnRzLnN3YXA4SWZCRSA9IGV4cG9ydHMuaXNMRVxuICAgID8gKG4pID0+IG5cbiAgICA6IChuKSA9PiBieXRlU3dhcChuKTtcbi8qKiBAZGVwcmVjYXRlZCAqL1xuZXhwb3J0cy5ieXRlU3dhcElmQkUgPSBleHBvcnRzLnN3YXA4SWZCRTtcbi8qKiBJbiBwbGFjZSBieXRlIHN3YXAgZm9yIFVpbnQzMkFycmF5ICovXG5mdW5jdGlvbiBieXRlU3dhcDMyKGFycikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycltpXSA9IGJ5dGVTd2FwKGFycltpXSk7XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG59XG5leHBvcnRzLnN3YXAzMklmQkUgPSBleHBvcnRzLmlzTEVcbiAgICA/ICh1KSA9PiB1XG4gICAgOiBieXRlU3dhcDMyO1xuLy8gQnVpbHQtaW4gaGV4IGNvbnZlcnNpb24gaHR0cHM6Ly9jYW5pdXNlLmNvbS9tZG4tamF2YXNjcmlwdF9idWlsdGluc191aW50OGFycmF5X2Zyb21oZXhcbmNvbnN0IGhhc0hleEJ1aWx0aW4gPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IFxuLy8gQHRzLWlnbm9yZVxudHlwZW9mIFVpbnQ4QXJyYXkuZnJvbShbXSkudG9IZXggPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFVpbnQ4QXJyYXkuZnJvbUhleCA9PT0gJ2Z1bmN0aW9uJykoKTtcbi8vIEFycmF5IHdoZXJlIGluZGV4IDB4ZjAgKDI0MCkgaXMgbWFwcGVkIHRvIHN0cmluZyAnZjAnXG5jb25zdCBoZXhlcyA9IC8qIEBfX1BVUkVfXyAqLyBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyNTYgfSwgKF8sIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuLyoqXG4gKiBDb252ZXJ0IGJ5dGUgYXJyYXkgdG8gaGV4IHN0cmluZy4gVXNlcyBidWlsdC1pbiBmdW5jdGlvbiwgd2hlbiBhdmFpbGFibGUuXG4gKiBAZXhhbXBsZSBieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pKSAvLyAnY2FmZTAxMjMnXG4gKi9cbmZ1bmN0aW9uIGJ5dGVzVG9IZXgoYnl0ZXMpIHtcbiAgICBhYnl0ZXMoYnl0ZXMpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAoaGFzSGV4QnVpbHRpbilcbiAgICAgICAgcmV0dXJuIGJ5dGVzLnRvSGV4KCk7XG4gICAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGhleGVzW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbi8vIFdlIHVzZSBvcHRpbWl6ZWQgdGVjaG5pcXVlIHRvIGNvbnZlcnQgaGV4IHN0cmluZyB0byBieXRlIGFycmF5XG5jb25zdCBhc2NpaXMgPSB7IF8wOiA0OCwgXzk6IDU3LCBBOiA2NSwgRjogNzAsIGE6IDk3LCBmOiAxMDIgfTtcbmZ1bmN0aW9uIGFzY2lpVG9CYXNlMTYoY2gpIHtcbiAgICBpZiAoY2ggPj0gYXNjaWlzLl8wICYmIGNoIDw9IGFzY2lpcy5fOSlcbiAgICAgICAgcmV0dXJuIGNoIC0gYXNjaWlzLl8wOyAvLyAnMicgPT4gNTAtNDhcbiAgICBpZiAoY2ggPj0gYXNjaWlzLkEgJiYgY2ggPD0gYXNjaWlzLkYpXG4gICAgICAgIHJldHVybiBjaCAtIChhc2NpaXMuQSAtIDEwKTsgLy8gJ0InID0+IDY2LSg2NS0xMClcbiAgICBpZiAoY2ggPj0gYXNjaWlzLmEgJiYgY2ggPD0gYXNjaWlzLmYpXG4gICAgICAgIHJldHVybiBjaCAtIChhc2NpaXMuYSAtIDEwKTsgLy8gJ2InID0+IDk4LSg5Ny0xMClcbiAgICByZXR1cm47XG59XG4vKipcbiAqIENvbnZlcnQgaGV4IHN0cmluZyB0byBieXRlIGFycmF5LiBVc2VzIGJ1aWx0LWluIGZ1bmN0aW9uLCB3aGVuIGF2YWlsYWJsZS5cbiAqIEBleGFtcGxlIGhleFRvQnl0ZXMoJ2NhZmUwMTIzJykgLy8gVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSlcbiAqL1xuZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKGhhc0hleEJ1aWx0aW4pXG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb21IZXgoaGV4KTtcbiAgICBjb25zdCBobCA9IGhleC5sZW5ndGg7XG4gICAgY29uc3QgYWwgPSBobCAvIDI7XG4gICAgaWYgKGhsICUgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgdW5wYWRkZWQgaGV4IG9mIGxlbmd0aCAnICsgaGwpO1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYWwpO1xuICAgIGZvciAobGV0IGFpID0gMCwgaGkgPSAwOyBhaSA8IGFsOyBhaSsrLCBoaSArPSAyKSB7XG4gICAgICAgIGNvbnN0IG4xID0gYXNjaWlUb0Jhc2UxNihoZXguY2hhckNvZGVBdChoaSkpO1xuICAgICAgICBjb25zdCBuMiA9IGFzY2lpVG9CYXNlMTYoaGV4LmNoYXJDb2RlQXQoaGkgKyAxKSk7XG4gICAgICAgIGlmIChuMSA9PT0gdW5kZWZpbmVkIHx8IG4yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXIgPSBoZXhbaGldICsgaGV4W2hpICsgMV07XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCBub24taGV4IGNoYXJhY3RlciBcIicgKyBjaGFyICsgJ1wiIGF0IGluZGV4ICcgKyBoaSk7XG4gICAgICAgIH1cbiAgICAgICAgYXJyYXlbYWldID0gbjEgKiAxNiArIG4yOyAvLyBtdWx0aXBseSBmaXJzdCBvY3RldCwgZS5nLiAnYTMnID0+IDEwKjE2KzMgPT4gMTYwICsgMyA9PiAxNjNcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuLyoqXG4gKiBUaGVyZSBpcyBubyBzZXRJbW1lZGlhdGUgaW4gYnJvd3NlciBhbmQgc2V0VGltZW91dCBpcyBzbG93LlxuICogQ2FsbCBvZiBhc3luYyBmbiB3aWxsIHJldHVybiBQcm9taXNlLCB3aGljaCB3aWxsIGJlIGZ1bGxmaWxlZCBvbmx5IG9uXG4gKiBuZXh0IHNjaGVkdWxlciBxdWV1ZSBwcm9jZXNzaW5nIHN0ZXAgYW5kIHRoaXMgaXMgZXhhY3RseSB3aGF0IHdlIG5lZWQuXG4gKi9cbmNvbnN0IG5leHRUaWNrID0gYXN5bmMgKCkgPT4geyB9O1xuZXhwb3J0cy5uZXh0VGljayA9IG5leHRUaWNrO1xuLyoqIFJldHVybnMgY29udHJvbCB0byB0aHJlYWQgZWFjaCAndGljaycgbXMgdG8gYXZvaWQgYmxvY2tpbmcuICovXG5hc3luYyBmdW5jdGlvbiBhc3luY0xvb3AoaXRlcnMsIHRpY2ssIGNiKSB7XG4gICAgbGV0IHRzID0gRGF0ZS5ub3coKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJzOyBpKyspIHtcbiAgICAgICAgY2IoaSk7XG4gICAgICAgIC8vIERhdGUubm93KCkgaXMgbm90IG1vbm90b25pYywgc28gaW4gY2FzZSBpZiBjbG9jayBnb2VzIGJhY2t3YXJkcyB3ZSByZXR1cm4gcmV0dXJuIGNvbnRyb2wgdG9vXG4gICAgICAgIGNvbnN0IGRpZmYgPSBEYXRlLm5vdygpIC0gdHM7XG4gICAgICAgIGlmIChkaWZmID49IDAgJiYgZGlmZiA8IHRpY2spXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgYXdhaXQgKDAsIGV4cG9ydHMubmV4dFRpY2spKCk7XG4gICAgICAgIHRzICs9IGRpZmY7XG4gICAgfVxufVxuLyoqXG4gKiBDb252ZXJ0cyBzdHJpbmcgdG8gYnl0ZXMgdXNpbmcgVVRGOCBlbmNvZGluZy5cbiAqIEBleGFtcGxlIHV0ZjhUb0J5dGVzKCdhYmMnKSAvLyBVaW50OEFycmF5LmZyb20oWzk3LCA5OCwgOTldKVxuICovXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc3RyaW5nIGV4cGVjdGVkJyk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpKTsgLy8gaHR0cHM6Ly9idWd6aWwubGEvMTY4MTgwOVxufVxuLyoqXG4gKiBDb252ZXJ0cyBieXRlcyB0byBzdHJpbmcgdXNpbmcgVVRGOCBlbmNvZGluZy5cbiAqIEBleGFtcGxlIGJ5dGVzVG9VdGY4KFVpbnQ4QXJyYXkuZnJvbShbOTcsIDk4LCA5OV0pKSAvLyAnYWJjJ1xuICovXG5mdW5jdGlvbiBieXRlc1RvVXRmOChieXRlcykge1xuICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoYnl0ZXMpO1xufVxuLyoqXG4gKiBOb3JtYWxpemVzIChub24taGV4KSBzdHJpbmcgb3IgVWludDhBcnJheSB0byBVaW50OEFycmF5LlxuICogV2FybmluZzogd2hlbiBVaW50OEFycmF5IGlzIHBhc3NlZCwgaXQgd291bGQgTk9UIGdldCBjb3BpZWQuXG4gKiBLZWVwIGluIG1pbmQgZm9yIGZ1dHVyZSBtdXRhYmxlIG9wZXJhdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIHRvQnl0ZXMoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpXG4gICAgICAgIGRhdGEgPSB1dGY4VG9CeXRlcyhkYXRhKTtcbiAgICBhYnl0ZXMoZGF0YSk7XG4gICAgcmV0dXJuIGRhdGE7XG59XG4vKipcbiAqIEhlbHBlciBmb3IgS0RGczogY29uc3VtZXMgdWludDhhcnJheSBvciBzdHJpbmcuXG4gKiBXaGVuIHN0cmluZyBpcyBwYXNzZWQsIGRvZXMgdXRmOCBkZWNvZGluZywgdXNpbmcgVGV4dERlY29kZXIuXG4gKi9cbmZ1bmN0aW9uIGtkZklucHV0VG9CeXRlcyhkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJylcbiAgICAgICAgZGF0YSA9IHV0ZjhUb0J5dGVzKGRhdGEpO1xuICAgIGFieXRlcyhkYXRhKTtcbiAgICByZXR1cm4gZGF0YTtcbn1cbi8qKiBDb3BpZXMgc2V2ZXJhbCBVaW50OEFycmF5cyBpbnRvIG9uZS4gKi9cbmZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGxldCBzdW0gPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBhcnJheXNbaV07XG4gICAgICAgIGFieXRlcyhhKTtcbiAgICAgICAgc3VtICs9IGEubGVuZ3RoO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShzdW0pO1xuICAgIGZvciAobGV0IGkgPSAwLCBwYWQgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBhcnJheXNbaV07XG4gICAgICAgIHJlcy5zZXQoYSwgcGFkKTtcbiAgICAgICAgcGFkICs9IGEubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gY2hlY2tPcHRzKGRlZmF1bHRzLCBvcHRzKSB7XG4gICAgaWYgKG9wdHMgIT09IHVuZGVmaW5lZCAmJiB7fS50b1N0cmluZy5jYWxsKG9wdHMpICE9PSAnW29iamVjdCBPYmplY3RdJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcHRpb25zIHNob3VsZCBiZSBvYmplY3Qgb3IgdW5kZWZpbmVkJyk7XG4gICAgY29uc3QgbWVyZ2VkID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0cywgb3B0cyk7XG4gICAgcmV0dXJuIG1lcmdlZDtcbn1cbi8qKiBGb3IgcnVudGltZSBjaGVjayBpZiBjbGFzcyBpbXBsZW1lbnRzIGludGVyZmFjZSAqL1xuY2xhc3MgSGFzaCB7XG59XG5leHBvcnRzLkhhc2ggPSBIYXNoO1xuLyoqIFdyYXBzIGhhc2ggZnVuY3Rpb24sIGNyZWF0aW5nIGFuIGludGVyZmFjZSBvbiB0b3Agb2YgaXQgKi9cbmZ1bmN0aW9uIGNyZWF0ZUhhc2hlcihoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZykgPT4gaGFzaENvbnMoKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucygpO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKCkgPT4gaGFzaENvbnMoKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5mdW5jdGlvbiBjcmVhdGVPcHRIYXNoZXIoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5mdW5jdGlvbiBjcmVhdGVYT0ZlcihoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZywgb3B0cykgPT4gaGFzaENvbnMob3B0cykudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoe30pO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKG9wdHMpID0+IGhhc2hDb25zKG9wdHMpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbmV4cG9ydHMud3JhcENvbnN0cnVjdG9yID0gY3JlYXRlSGFzaGVyO1xuZXhwb3J0cy53cmFwQ29uc3RydWN0b3JXaXRoT3B0cyA9IGNyZWF0ZU9wdEhhc2hlcjtcbmV4cG9ydHMud3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMgPSBjcmVhdGVYT0Zlcjtcbi8qKiBDcnlwdG9ncmFwaGljYWxseSBzZWN1cmUgUFJORy4gVXNlcyBpbnRlcm5hbCBPUy1sZXZlbCBgY3J5cHRvLmdldFJhbmRvbVZhbHVlc2AuICovXG5mdW5jdGlvbiByYW5kb21CeXRlcyhieXRlc0xlbmd0aCA9IDMyKSB7XG4gICAgaWYgKGNyeXB0b18xLmNyeXB0byAmJiB0eXBlb2YgY3J5cHRvXzEuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gY3J5cHRvXzEuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShieXRlc0xlbmd0aCkpO1xuICAgIH1cbiAgICAvLyBMZWdhY3kgTm9kZS5qcyBjb21wYXRpYmlsaXR5XG4gICAgaWYgKGNyeXB0b18xLmNyeXB0byAmJiB0eXBlb2YgY3J5cHRvXzEuY3J5cHRvLnJhbmRvbUJ5dGVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oY3J5cHRvXzEuY3J5cHRvLnJhbmRvbUJ5dGVzKGJ5dGVzTGVuZ3RoKSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignY3J5cHRvLmdldFJhbmRvbVZhbHVlcyBtdXN0IGJlIGRlZmluZWQnKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIndyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzIiwid3JhcENvbnN0cnVjdG9yV2l0aE9wdHMiLCJ3cmFwQ29uc3RydWN0b3IiLCJIYXNoIiwibmV4dFRpY2siLCJzd2FwMzJJZkJFIiwiYnl0ZVN3YXBJZkJFIiwic3dhcDhJZkJFIiwiaXNMRSIsImlzQnl0ZXMiLCJhbnVtYmVyIiwiYWJ5dGVzIiwiYWhhc2giLCJhZXhpc3RzIiwiYW91dHB1dCIsInU4IiwidTMyIiwiY2xlYW4iLCJjcmVhdGVWaWV3Iiwicm90ciIsInJvdGwiLCJieXRlU3dhcCIsImJ5dGVTd2FwMzIiLCJieXRlc1RvSGV4IiwiaGV4VG9CeXRlcyIsImFzeW5jTG9vcCIsInV0ZjhUb0J5dGVzIiwiYnl0ZXNUb1V0ZjgiLCJ0b0J5dGVzIiwia2RmSW5wdXRUb0J5dGVzIiwiY29uY2F0Qnl0ZXMiLCJjaGVja09wdHMiLCJjcmVhdGVIYXNoZXIiLCJjcmVhdGVPcHRIYXNoZXIiLCJjcmVhdGVYT0ZlciIsInJhbmRvbUJ5dGVzIiwiY3J5cHRvXzEiLCJyZXF1aXJlIiwiYSIsIlVpbnQ4QXJyYXkiLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsImNvbnN0cnVjdG9yIiwibmFtZSIsIm4iLCJOdW1iZXIiLCJpc1NhZmVJbnRlZ2VyIiwiRXJyb3IiLCJiIiwibGVuZ3RocyIsImxlbmd0aCIsImluY2x1ZGVzIiwiaCIsImNyZWF0ZSIsIm91dHB1dExlbiIsImJsb2NrTGVuIiwiaW5zdGFuY2UiLCJjaGVja0ZpbmlzaGVkIiwiZGVzdHJveWVkIiwiZmluaXNoZWQiLCJvdXQiLCJtaW4iLCJhcnIiLCJidWZmZXIiLCJieXRlT2Zmc2V0IiwiYnl0ZUxlbmd0aCIsIlVpbnQzMkFycmF5IiwiTWF0aCIsImZsb29yIiwiYXJyYXlzIiwiaSIsImZpbGwiLCJEYXRhVmlldyIsIndvcmQiLCJzaGlmdCIsInUiLCJoYXNIZXhCdWlsdGluIiwiZnJvbSIsInRvSGV4IiwiZnJvbUhleCIsImhleGVzIiwiQXJyYXkiLCJfIiwidG9TdHJpbmciLCJwYWRTdGFydCIsImJ5dGVzIiwiaGV4IiwiYXNjaWlzIiwiXzAiLCJfOSIsIkEiLCJGIiwiZiIsImFzY2lpVG9CYXNlMTYiLCJjaCIsImhsIiwiYWwiLCJhcnJheSIsImFpIiwiaGkiLCJuMSIsImNoYXJDb2RlQXQiLCJuMiIsInVuZGVmaW5lZCIsImNoYXIiLCJpdGVycyIsInRpY2siLCJjYiIsInRzIiwiRGF0ZSIsIm5vdyIsImRpZmYiLCJzdHIiLCJUZXh0RW5jb2RlciIsImVuY29kZSIsIlRleHREZWNvZGVyIiwiZGVjb2RlIiwiZGF0YSIsInN1bSIsInJlcyIsInBhZCIsInNldCIsImRlZmF1bHRzIiwib3B0cyIsImNhbGwiLCJtZXJnZWQiLCJhc3NpZ24iLCJoYXNoQ29ucyIsImhhc2hDIiwibXNnIiwidXBkYXRlIiwiZGlnZXN0IiwidG1wIiwiYnl0ZXNMZW5ndGgiLCJjcnlwdG8iLCJnZXRSYW5kb21WYWx1ZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/@noble/hashes/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_cjs/core/AbiConstructor.js":
/*!*****************************************************!*\
  !*** ./node_modules/ox/_cjs/core/AbiConstructor.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.decode = decode;\nexports.encode = encode;\nexports.format = format;\nexports.from = from;\nexports.fromAbi = fromAbi;\nconst abitype = __webpack_require__(/*! abitype */ \"(ssr)/./node_modules/abitype/dist/cjs/exports/index.js\");\nconst AbiItem = __webpack_require__(/*! ./AbiItem.js */ \"(ssr)/./node_modules/ox/_cjs/core/AbiItem.js\");\nconst AbiParameters = __webpack_require__(/*! ./AbiParameters.js */ \"(ssr)/./node_modules/ox/_cjs/core/AbiParameters.js\");\nconst Hex = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_cjs/core/Hex.js\");\nfunction decode(...parameters) {\n    const [abiConstructor, options] = (()=>{\n        if (Array.isArray(parameters[0])) {\n            const [abi, options] = parameters;\n            return [\n                fromAbi(abi),\n                options\n            ];\n        }\n        return parameters;\n    })();\n    const { bytecode } = options;\n    if (abiConstructor.inputs?.length === 0) return undefined;\n    const data = options.data.replace(bytecode, \"0x\");\n    return AbiParameters.decode(abiConstructor.inputs, data);\n}\nfunction encode(...parameters) {\n    const [abiConstructor, options] = (()=>{\n        if (Array.isArray(parameters[0])) {\n            const [abi, options] = parameters;\n            return [\n                fromAbi(abi),\n                options\n            ];\n        }\n        return parameters;\n    })();\n    const { bytecode, args } = options;\n    return Hex.concat(bytecode, abiConstructor.inputs?.length && args?.length ? AbiParameters.encode(abiConstructor.inputs, args) : \"0x\");\n}\nfunction format(abiConstructor) {\n    return abitype.formatAbiItem(abiConstructor);\n}\nfunction from(abiConstructor) {\n    return AbiItem.from(abiConstructor);\n}\nfunction fromAbi(abi) {\n    const item = abi.find((item)=>item.type === \"constructor\");\n    if (!item) throw new AbiItem.NotFoundError({\n        name: \"constructor\"\n    });\n    return item;\n} //# sourceMappingURL=AbiConstructor.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2Nqcy9jb3JlL0FiaUNvbnN0cnVjdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxjQUFjLEdBQUdFO0FBQ2pCRixjQUFjLEdBQUdHO0FBQ2pCSCxjQUFjLEdBQUdJO0FBQ2pCSixZQUFZLEdBQUdLO0FBQ2ZMLGVBQWUsR0FBR007QUFDbEIsTUFBTUMsVUFBVUMsbUJBQU9BLENBQUMsdUVBQVM7QUFDakMsTUFBTUMsVUFBVUQsbUJBQU9BLENBQUMsa0VBQWM7QUFDdEMsTUFBTUUsZ0JBQWdCRixtQkFBT0EsQ0FBQyw4RUFBb0I7QUFDbEQsTUFBTUcsTUFBTUgsbUJBQU9BLENBQUMsMERBQVU7QUFDOUIsU0FBU04sT0FBTyxHQUFHVSxVQUFVO0lBQ3pCLE1BQU0sQ0FBQ0MsZ0JBQWdCQyxRQUFRLEdBQUcsQ0FBQztRQUMvQixJQUFJQyxNQUFNQyxPQUFPLENBQUNKLFVBQVUsQ0FBQyxFQUFFLEdBQUc7WUFDOUIsTUFBTSxDQUFDSyxLQUFLSCxRQUFRLEdBQUdGO1lBQ3ZCLE9BQU87Z0JBQUNOLFFBQVFXO2dCQUFNSDthQUFRO1FBQ2xDO1FBQ0EsT0FBT0Y7SUFDWDtJQUNBLE1BQU0sRUFBRU0sUUFBUSxFQUFFLEdBQUdKO0lBQ3JCLElBQUlELGVBQWVNLE1BQU0sRUFBRUMsV0FBVyxHQUNsQyxPQUFPQztJQUNYLE1BQU1DLE9BQU9SLFFBQVFRLElBQUksQ0FBQ0MsT0FBTyxDQUFDTCxVQUFVO0lBQzVDLE9BQU9SLGNBQWNSLE1BQU0sQ0FBQ1csZUFBZU0sTUFBTSxFQUFFRztBQUN2RDtBQUNBLFNBQVNuQixPQUFPLEdBQUdTLFVBQVU7SUFDekIsTUFBTSxDQUFDQyxnQkFBZ0JDLFFBQVEsR0FBRyxDQUFDO1FBQy9CLElBQUlDLE1BQU1DLE9BQU8sQ0FBQ0osVUFBVSxDQUFDLEVBQUUsR0FBRztZQUM5QixNQUFNLENBQUNLLEtBQUtILFFBQVEsR0FBR0Y7WUFDdkIsT0FBTztnQkFBQ04sUUFBUVc7Z0JBQU1IO2FBQVE7UUFDbEM7UUFDQSxPQUFPRjtJQUNYO0lBQ0EsTUFBTSxFQUFFTSxRQUFRLEVBQUVNLElBQUksRUFBRSxHQUFHVjtJQUMzQixPQUFPSCxJQUFJYyxNQUFNLENBQUNQLFVBQVVMLGVBQWVNLE1BQU0sRUFBRUMsVUFBVUksTUFBTUosU0FDN0RWLGNBQWNQLE1BQU0sQ0FBQ1UsZUFBZU0sTUFBTSxFQUFFSyxRQUM1QztBQUNWO0FBQ0EsU0FBU3BCLE9BQU9TLGNBQWM7SUFDMUIsT0FBT04sUUFBUW1CLGFBQWEsQ0FBQ2I7QUFDakM7QUFDQSxTQUFTUixLQUFLUSxjQUFjO0lBQ3hCLE9BQU9KLFFBQVFKLElBQUksQ0FBQ1E7QUFDeEI7QUFDQSxTQUFTUCxRQUFRVyxHQUFHO0lBQ2hCLE1BQU1VLE9BQU9WLElBQUlXLElBQUksQ0FBQyxDQUFDRCxPQUFTQSxLQUFLRSxJQUFJLEtBQUs7SUFDOUMsSUFBSSxDQUFDRixNQUNELE1BQU0sSUFBSWxCLFFBQVFxQixhQUFhLENBQUM7UUFBRUMsTUFBTTtJQUFjO0lBQzFELE9BQU9KO0FBQ1gsRUFDQSwwQ0FBMEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGF3LXdvcmtzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L19janMvY29yZS9BYmlDb25zdHJ1Y3Rvci5qcz8xMzg3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG5leHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbmV4cG9ydHMuZm9ybWF0ID0gZm9ybWF0O1xuZXhwb3J0cy5mcm9tID0gZnJvbTtcbmV4cG9ydHMuZnJvbUFiaSA9IGZyb21BYmk7XG5jb25zdCBhYml0eXBlID0gcmVxdWlyZShcImFiaXR5cGVcIik7XG5jb25zdCBBYmlJdGVtID0gcmVxdWlyZShcIi4vQWJpSXRlbS5qc1wiKTtcbmNvbnN0IEFiaVBhcmFtZXRlcnMgPSByZXF1aXJlKFwiLi9BYmlQYXJhbWV0ZXJzLmpzXCIpO1xuY29uc3QgSGV4ID0gcmVxdWlyZShcIi4vSGV4LmpzXCIpO1xuZnVuY3Rpb24gZGVjb2RlKC4uLnBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBbYWJpQ29uc3RydWN0b3IsIG9wdGlvbnNdID0gKCgpID0+IHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW1ldGVyc1swXSkpIHtcbiAgICAgICAgICAgIGNvbnN0IFthYmksIG9wdGlvbnNdID0gcGFyYW1ldGVycztcbiAgICAgICAgICAgIHJldHVybiBbZnJvbUFiaShhYmkpLCBvcHRpb25zXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyYW1ldGVycztcbiAgICB9KSgpO1xuICAgIGNvbnN0IHsgYnl0ZWNvZGUgfSA9IG9wdGlvbnM7XG4gICAgaWYgKGFiaUNvbnN0cnVjdG9yLmlucHV0cz8ubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGRhdGEgPSBvcHRpb25zLmRhdGEucmVwbGFjZShieXRlY29kZSwgJzB4Jyk7XG4gICAgcmV0dXJuIEFiaVBhcmFtZXRlcnMuZGVjb2RlKGFiaUNvbnN0cnVjdG9yLmlucHV0cywgZGF0YSk7XG59XG5mdW5jdGlvbiBlbmNvZGUoLi4ucGFyYW1ldGVycykge1xuICAgIGNvbnN0IFthYmlDb25zdHJ1Y3Rvciwgb3B0aW9uc10gPSAoKCkgPT4ge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbWV0ZXJzWzBdKSkge1xuICAgICAgICAgICAgY29uc3QgW2FiaSwgb3B0aW9uc10gPSBwYXJhbWV0ZXJzO1xuICAgICAgICAgICAgcmV0dXJuIFtmcm9tQWJpKGFiaSksIG9wdGlvbnNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJhbWV0ZXJzO1xuICAgIH0pKCk7XG4gICAgY29uc3QgeyBieXRlY29kZSwgYXJncyB9ID0gb3B0aW9ucztcbiAgICByZXR1cm4gSGV4LmNvbmNhdChieXRlY29kZSwgYWJpQ29uc3RydWN0b3IuaW5wdXRzPy5sZW5ndGggJiYgYXJncz8ubGVuZ3RoXG4gICAgICAgID8gQWJpUGFyYW1ldGVycy5lbmNvZGUoYWJpQ29uc3RydWN0b3IuaW5wdXRzLCBhcmdzKVxuICAgICAgICA6ICcweCcpO1xufVxuZnVuY3Rpb24gZm9ybWF0KGFiaUNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIGFiaXR5cGUuZm9ybWF0QWJpSXRlbShhYmlDb25zdHJ1Y3Rvcik7XG59XG5mdW5jdGlvbiBmcm9tKGFiaUNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIEFiaUl0ZW0uZnJvbShhYmlDb25zdHJ1Y3Rvcik7XG59XG5mdW5jdGlvbiBmcm9tQWJpKGFiaSkge1xuICAgIGNvbnN0IGl0ZW0gPSBhYmkuZmluZCgoaXRlbSkgPT4gaXRlbS50eXBlID09PSAnY29uc3RydWN0b3InKTtcbiAgICBpZiAoIWl0ZW0pXG4gICAgICAgIHRocm93IG5ldyBBYmlJdGVtLk5vdEZvdW5kRXJyb3IoeyBuYW1lOiAnY29uc3RydWN0b3InIH0pO1xuICAgIHJldHVybiBpdGVtO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWJpQ29uc3RydWN0b3IuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZGVjb2RlIiwiZW5jb2RlIiwiZm9ybWF0IiwiZnJvbSIsImZyb21BYmkiLCJhYml0eXBlIiwicmVxdWlyZSIsIkFiaUl0ZW0iLCJBYmlQYXJhbWV0ZXJzIiwiSGV4IiwicGFyYW1ldGVycyIsImFiaUNvbnN0cnVjdG9yIiwib3B0aW9ucyIsIkFycmF5IiwiaXNBcnJheSIsImFiaSIsImJ5dGVjb2RlIiwiaW5wdXRzIiwibGVuZ3RoIiwidW5kZWZpbmVkIiwiZGF0YSIsInJlcGxhY2UiLCJhcmdzIiwiY29uY2F0IiwiZm9ybWF0QWJpSXRlbSIsIml0ZW0iLCJmaW5kIiwidHlwZSIsIk5vdEZvdW5kRXJyb3IiLCJuYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_cjs/core/AbiConstructor.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_cjs/core/AbiFunction.js":
/*!**************************************************!*\
  !*** ./node_modules/ox/_cjs/core/AbiFunction.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.decodeData = decodeData;\nexports.decodeResult = decodeResult;\nexports.encodeData = encodeData;\nexports.encodeResult = encodeResult;\nexports.format = format;\nexports.from = from;\nexports.fromAbi = fromAbi;\nexports.getSelector = getSelector;\nconst abitype = __webpack_require__(/*! abitype */ \"(ssr)/./node_modules/abitype/dist/cjs/exports/index.js\");\nconst AbiItem = __webpack_require__(/*! ./AbiItem.js */ \"(ssr)/./node_modules/ox/_cjs/core/AbiItem.js\");\nconst AbiParameters = __webpack_require__(/*! ./AbiParameters.js */ \"(ssr)/./node_modules/ox/_cjs/core/AbiParameters.js\");\nconst Hex = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_cjs/core/Hex.js\");\nfunction decodeData(...parameters) {\n    const [abiFunction, data] = (()=>{\n        if (Array.isArray(parameters[0])) {\n            const [abi, name, data] = parameters;\n            return [\n                fromAbi(abi, name),\n                data\n            ];\n        }\n        return parameters;\n    })();\n    const { overloads } = abiFunction;\n    if (Hex.size(data) < 4) throw new AbiItem.InvalidSelectorSizeError({\n        data\n    });\n    if (abiFunction.inputs?.length === 0) return undefined;\n    const item = overloads ? fromAbi([\n        abiFunction,\n        ...overloads\n    ], data) : abiFunction;\n    if (Hex.size(data) <= 4) return undefined;\n    return AbiParameters.decode(item.inputs, Hex.slice(data, 4));\n}\nfunction decodeResult(...parameters) {\n    const [abiFunction, data, options = {}] = (()=>{\n        if (Array.isArray(parameters[0])) {\n            const [abi, name, data, options] = parameters;\n            return [\n                fromAbi(abi, name),\n                data,\n                options\n            ];\n        }\n        return parameters;\n    })();\n    const values = AbiParameters.decode(abiFunction.outputs, data, options);\n    if (values && Object.keys(values).length === 0) return undefined;\n    if (values && Object.keys(values).length === 1) {\n        if (Array.isArray(values)) return values[0];\n        return Object.values(values)[0];\n    }\n    return values;\n}\nfunction encodeData(...parameters) {\n    const [abiFunction, args = []] = (()=>{\n        if (Array.isArray(parameters[0])) {\n            const [abi, name, args] = parameters;\n            return [\n                fromAbi(abi, name, {\n                    args\n                }),\n                args\n            ];\n        }\n        const [abiFunction, args] = parameters;\n        return [\n            abiFunction,\n            args\n        ];\n    })();\n    const { overloads } = abiFunction;\n    const item = overloads ? fromAbi([\n        abiFunction,\n        ...overloads\n    ], abiFunction.name, {\n        args\n    }) : abiFunction;\n    const selector = getSelector(item);\n    const data = args.length > 0 ? AbiParameters.encode(item.inputs, args) : undefined;\n    return data ? Hex.concat(selector, data) : selector;\n}\nfunction encodeResult(...parameters) {\n    const [abiFunction, output, options = {}] = (()=>{\n        if (Array.isArray(parameters[0])) {\n            const [abi, name, output, options] = parameters;\n            return [\n                fromAbi(abi, name),\n                output,\n                options\n            ];\n        }\n        return parameters;\n    })();\n    const { as = \"Array\" } = options;\n    const values = (()=>{\n        if (abiFunction.outputs.length === 1) return [\n            output\n        ];\n        if (Array.isArray(output)) return output;\n        if (as === \"Object\") return Object.values(output);\n        return [\n            output\n        ];\n    })();\n    return AbiParameters.encode(abiFunction.outputs, values);\n}\nfunction format(abiFunction) {\n    return abitype.formatAbiItem(abiFunction);\n}\nfunction from(abiFunction, options = {}) {\n    return AbiItem.from(abiFunction, options);\n}\nfunction fromAbi(abi, name, options) {\n    const item = AbiItem.fromAbi(abi, name, options);\n    if (item.type !== \"function\") throw new AbiItem.NotFoundError({\n        name,\n        type: \"function\"\n    });\n    return item;\n}\nfunction getSelector(abiItem) {\n    return AbiItem.getSelector(abiItem);\n} //# sourceMappingURL=AbiFunction.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2Nqcy9jb3JlL0FiaUZ1bmN0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxrQkFBa0IsR0FBR0U7QUFDckJGLG9CQUFvQixHQUFHRztBQUN2Qkgsa0JBQWtCLEdBQUdJO0FBQ3JCSixvQkFBb0IsR0FBR0s7QUFDdkJMLGNBQWMsR0FBR007QUFDakJOLFlBQVksR0FBR087QUFDZlAsZUFBZSxHQUFHUTtBQUNsQlIsbUJBQW1CLEdBQUdTO0FBQ3RCLE1BQU1DLFVBQVVDLG1CQUFPQSxDQUFDLHVFQUFTO0FBQ2pDLE1BQU1DLFVBQVVELG1CQUFPQSxDQUFDLGtFQUFjO0FBQ3RDLE1BQU1FLGdCQUFnQkYsbUJBQU9BLENBQUMsOEVBQW9CO0FBQ2xELE1BQU1HLE1BQU1ILG1CQUFPQSxDQUFDLDBEQUFVO0FBQzlCLFNBQVNULFdBQVcsR0FBR2EsVUFBVTtJQUM3QixNQUFNLENBQUNDLGFBQWFDLEtBQUssR0FBRyxDQUFDO1FBQ3pCLElBQUlDLE1BQU1DLE9BQU8sQ0FBQ0osVUFBVSxDQUFDLEVBQUUsR0FBRztZQUM5QixNQUFNLENBQUNLLEtBQUtDLE1BQU1KLEtBQUssR0FBR0Y7WUFDMUIsT0FBTztnQkFBQ1AsUUFBUVksS0FBS0M7Z0JBQU9KO2FBQUs7UUFDckM7UUFDQSxPQUFPRjtJQUNYO0lBQ0EsTUFBTSxFQUFFTyxTQUFTLEVBQUUsR0FBR047SUFDdEIsSUFBSUYsSUFBSVMsSUFBSSxDQUFDTixRQUFRLEdBQ2pCLE1BQU0sSUFBSUwsUUFBUVksd0JBQXdCLENBQUM7UUFBRVA7SUFBSztJQUN0RCxJQUFJRCxZQUFZUyxNQUFNLEVBQUVDLFdBQVcsR0FDL0IsT0FBT0M7SUFDWCxNQUFNQyxPQUFPTixZQUNQZCxRQUFRO1FBQUNRO1dBQWdCTTtLQUFVLEVBQUVMLFFBQ3JDRDtJQUNOLElBQUlGLElBQUlTLElBQUksQ0FBQ04sU0FBUyxHQUNs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VSxXQUFXO0lBQ3ZCLE9BQU9OLFFBQVErQixhQUFhLENBQUN6QjtBQUNqQztBQUNBLFNBQVNULEtBQUtTLFdBQVcsRUFBRWUsVUFBVSxDQUFDLENBQUM7SUFDbkMsT0FBT25CLFFBQVFMLElBQUksQ0FBQ1MsYUFBYWU7QUFDckM7QUFDQSxTQUFTdkIsUUFBUVksR0FBRyxFQUFFQyxJQUFJLEVBQUVVLE9BQU87SUFDL0IsTUFBTUgsT0FBT2hCLFFBQVFKLE9BQU8sQ0FBQ1ksS0FBS0MsTUFBTVU7SUFDeEMsSUFBSUgsS0FBS2MsSUFBSSxLQUFLLFlBQ2QsTUFBTSxJQUFJOUIsUUFBUStCLGFBQWEsQ0FBQztRQUFFdEI7UUFBTXFCLE1BQU07SUFBVztJQUM3RCxPQUFPZDtBQUNYO0FBQ0EsU0FBU25CLFlBQVltQyxPQUFPO0lBQ3hCLE9BQU9oQyxRQUFRSCxXQUFXLENBQUNtQztBQUMvQixFQUNBLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsYXctd29ya3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3gvX2Nqcy9jb3JlL0FiaUZ1bmN0aW9uLmpzP2I4YWMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlY29kZURhdGEgPSBkZWNvZGVEYXRhO1xuZXhwb3J0cy5kZWNvZGVSZXN1bHQgPSBkZWNvZGVSZXN1bHQ7XG5leHBvcnRzLmVuY29kZURhdGEgPSBlbmNvZGVEYXRhO1xuZXhwb3J0cy5lbmNvZGVSZXN1bHQgPSBlbmNvZGVSZXN1bHQ7XG5leHBvcnRzLmZvcm1hdCA9IGZvcm1hdDtcbmV4cG9ydHMuZnJvbSA9IGZyb207XG5leHBvcnRzLmZyb21BYmkgPSBmcm9tQWJpO1xuZXhwb3J0cy5nZXRTZWxlY3RvciA9IGdldFNlbGVjdG9yO1xuY29uc3QgYWJpdHlwZSA9IHJlcXVpcmUoXCJhYml0eXBlXCIpO1xuY29uc3QgQWJpSXRlbSA9IHJlcXVpcmUoXCIuL0FiaUl0ZW0uanNcIik7XG5jb25zdCBBYmlQYXJhbWV0ZXJzID0gcmVxdWlyZShcIi4vQWJpUGFyYW1ldGVycy5qc1wiKTtcbmNvbnN0IEhleCA9IHJlcXVpcmUoXCIuL0hleC5qc1wiKTtcbmZ1bmN0aW9uIGRlY29kZURhdGEoLi4ucGFyYW1ldGVycykge1xuICAgIGNvbnN0IFthYmlGdW5jdGlvbiwgZGF0YV0gPSAoKCkgPT4ge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbWV0ZXJzWzBdKSkge1xuICAgICAgICAgICAgY29uc3QgW2FiaSwgbmFtZSwgZGF0YV0gPSBwYXJhbWV0ZXJzO1xuICAgICAgICAgICAgcmV0dXJuIFtmcm9tQWJpKGFiaSwgbmFtZSksIGRhdGFdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJhbWV0ZXJzO1xuICAgIH0pKCk7XG4gICAgY29uc3QgeyBvdmVybG9hZHMgfSA9IGFiaUZ1bmN0aW9uO1xuICAgIGlmIChIZXguc2l6ZShkYXRhKSA8IDQpXG4gICAgICAgIHRocm93IG5ldyBBYmlJdGVtLkludmFsaWRTZWxlY3RvclNpemVFcnJvcih7IGRhdGEgfSk7XG4gICAgaWYgKGFiaUZ1bmN0aW9uLmlucHV0cz8ubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGl0ZW0gPSBvdmVybG9hZHNcbiAgICAgICAgPyBmcm9tQWJpKFthYmlGdW5jdGlvbiwgLi4ub3ZlcmxvYWRzXSwgZGF0YSlcbiAgICAgICAgOiBhYmlGdW5jdGlvbjtcbiAgICBpZiAoSGV4LnNpemUoZGF0YSkgPD0gNClcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICByZXR1cm4gQWJpUGFyYW1ldGVycy5kZWNvZGUoaXRlbS5pbnB1dHMsIEhleC5zbGljZShkYXRhLCA0KSk7XG59XG5mdW5jdGlvbiBkZWNvZGVSZXN1bHQoLi4ucGFyYW1ldGVycykge1xuICAgIGNvbnN0IFthYmlGdW5jdGlvbiwgZGF0YSwgb3B0aW9ucyA9IHt9XSA9ICgoKSA9PiB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtZXRlcnNbMF0pKSB7XG4gICAgICAgICAgICBjb25zdCBbYWJpLCBuYW1lLCBkYXRhLCBvcHRpb25zXSA9IHBhcmFtZXRlcnM7XG4gICAgICAgICAgICByZXR1cm4gW2Zyb21BYmkoYWJpLCBuYW1lKSwgZGF0YSwgb3B0aW9uc107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmFtZXRlcnM7XG4gICAgfSkoKTtcbiAgICBjb25zdCB2YWx1ZXMgPSBBYmlQYXJhbWV0ZXJzLmRlY29kZShhYmlGdW5jdGlvbi5vdXRwdXRzLCBkYXRhLCBvcHRpb25zKTtcbiAgICBpZiAodmFsdWVzICYmIE9iamVjdC5rZXlzKHZhbHVlcykubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGlmICh2YWx1ZXMgJiYgT2JqZWN0LmtleXModmFsdWVzKS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSlcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXNbMF07XG4gICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKHZhbHVlcylbMF07XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG59XG5mdW5jdGlvbiBlbmNvZGVEYXRhKC4uLnBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBbYWJpRnVuY3Rpb24sIGFyZ3MgPSBbXV0gPSAoKCkgPT4ge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbWV0ZXJzWzBdKSkge1xuICAgICAgICAgICAgY29uc3QgW2FiaSwgbmFtZSwgYXJnc10gPSBwYXJhbWV0ZXJzO1xuICAgICAgICAgICAgcmV0dXJuIFtmcm9tQWJpKGFiaSwgbmFtZSwgeyBhcmdzIH0pLCBhcmdzXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbYWJpRnVuY3Rpb24sIGFyZ3NdID0gcGFyYW1ldGVycztcbiAgICAgICAgcmV0dXJuIFthYmlGdW5jdGlvbiwgYXJnc107XG4gICAgfSkoKTtcbiAgICBjb25zdCB7IG92ZXJsb2FkcyB9ID0gYWJpRnVuY3Rpb247XG4gICAgY29uc3QgaXRlbSA9IG92ZXJsb2Fkc1xuICAgICAgICA/IGZyb21BYmkoW2FiaUZ1bmN0aW9uLCAuLi5vdmVybG9hZHNdLCBhYmlGdW5jdGlvbi5uYW1lLCB7XG4gICAgICAgICAgICBhcmdzLFxuICAgICAgICB9KVxuICAgICAgICA6IGFiaUZ1bmN0aW9uO1xuICAgIGNvbnN0IHNlbGVjdG9yID0gZ2V0U2VsZWN0b3IoaXRlbSk7XG4gICAgY29uc3QgZGF0YSA9IGFyZ3MubGVuZ3RoID4gMCA/IEFiaVBhcmFtZXRlcnMuZW5jb2RlKGl0ZW0uaW5wdXRzLCBhcmdzKSA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gZGF0YSA/IEhleC5jb25jYXQoc2VsZWN0b3IsIGRhdGEpIDogc2VsZWN0b3I7XG59XG5mdW5jdGlvbiBlbmNvZGVSZXN1bHQoLi4ucGFyYW1ldGVycykge1xuICAgIGNvbnN0IFthYmlGdW5jdGlvbiwgb3V0cHV0LCBvcHRpb25zID0ge31dID0gKCgpID0+IHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW1ldGVyc1swXSkpIHtcbiAgICAgICAgICAgIGNvbnN0IFthYmksIG5hbWUsIG91dHB1dCwgb3B0aW9uc10gPSBwYXJhbWV0ZXJzO1xuICAgICAgICAgICAgcmV0dXJuIFtmcm9tQWJpKGFiaSwgbmFtZSksIG91dHB1dCwgb3B0aW9uc107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmFtZXRlcnM7XG4gICAgfSkoKTtcbiAgICBjb25zdCB7IGFzID0gJ0FycmF5JyB9ID0gb3B0aW9ucztcbiAgICBjb25zdCB2YWx1ZXMgPSAoKCkgPT4ge1xuICAgICAgICBpZiAoYWJpRnVuY3Rpb24ub3V0cHV0cy5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICByZXR1cm4gW291dHB1dF07XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG91dHB1dCkpXG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICBpZiAoYXMgPT09ICdPYmplY3QnKVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXMob3V0cHV0KTtcbiAgICAgICAgcmV0dXJuIFtvdXRwdXRdO1xuICAgIH0pKCk7XG4gICAgcmV0dXJuIEFiaVBhcmFtZXRlcnMuZW5jb2RlKGFiaUZ1bmN0aW9uLm91dHB1dHMsIHZhbHVlcyk7XG59XG5mdW5jdGlvbiBmb3JtYXQoYWJpRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gYWJpdHlwZS5mb3JtYXRBYmlJdGVtKGFiaUZ1bmN0aW9uKTtcbn1cbmZ1bmN0aW9uIGZyb20oYWJpRnVuY3Rpb24sIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBBYmlJdGVtLmZyb20oYWJpRnVuY3Rpb24sIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gZnJvbUFiaShhYmksIG5hbWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBpdGVtID0gQWJpSXRlbS5mcm9tQWJpKGFiaSwgbmFtZSwgb3B0aW9ucyk7XG4gICAgaWYgKGl0ZW0udHlwZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEFiaUl0ZW0uTm90Rm91bmRFcnJvcih7IG5hbWUsIHR5cGU6ICdmdW5jdGlvbicgfSk7XG4gICAgcmV0dXJuIGl0ZW07XG59XG5mdW5jdGlvbiBnZXRTZWxlY3RvcihhYmlJdGVtKSB7XG4gICAgcmV0dXJuIEFiaUl0ZW0uZ2V0U2VsZWN0b3IoYWJpSXRlbSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BYmlGdW5jdGlvbi5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkZWNvZGVEYXRhIiwiZGVjb2RlUmVzdWx0IiwiZW5jb2RlRGF0YSIsImVuY29kZVJlc3VsdCIsImZvcm1hdCIsImZyb20iLCJmcm9tQWJpIiwiZ2V0U2VsZWN0b3IiLCJhYml0eXBlIiwicmVxdWlyZSIsIkFiaUl0ZW0iLCJBYmlQYXJhbWV0ZXJzIiwiSGV4IiwicGFyYW1ldGVycyIsImFiaUZ1bmN0aW9uIiwiZGF0YSIsIkFycmF5IiwiaXNBcnJheSIsImFiaSIsIm5hbWUiLCJvdmVybG9hZHMiLCJzaXplIiwiSW52YWxpZFNlbGVjdG9yU2l6ZUVycm9yIiwiaW5wdXRzIiwibGVuZ3RoIiwidW5kZWZpbmVkIiwiaXRlbSIsImRlY29kZSIsInNsaWNlIiwib3B0aW9ucyIsInZhbHVlcyIsIm91dHB1dHMiLCJrZXlzIiwiYXJncyIsInNlbGVjdG9yIiwiZW5jb2RlIiwiY29uY2F0Iiwib3V0cHV0IiwiYXMiLCJmb3JtYXRBYmlJdGVtIiwidHlwZSIsIk5vdEZvdW5kRXJyb3IiLCJhYmlJdGVtIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_cjs/core/AbiFunction.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_cjs/core/AbiItem.js":
/*!**********************************************!*\
  !*** ./node_modules/ox/_cjs/core/AbiItem.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.InvalidSelectorSizeError = exports.NotFoundError = exports.AmbiguityError = void 0;\nexports.format = format;\nexports.from = from;\nexports.fromAbi = fromAbi;\nexports.getSelector = getSelector;\nexports.getSignature = getSignature;\nexports.getSignatureHash = getSignatureHash;\nconst abitype = __webpack_require__(/*! abitype */ \"(ssr)/./node_modules/abitype/dist/cjs/exports/index.js\");\nconst Errors = __webpack_require__(/*! ./Errors.js */ \"(ssr)/./node_modules/ox/_cjs/core/Errors.js\");\nconst Hash = __webpack_require__(/*! ./Hash.js */ \"(ssr)/./node_modules/ox/_cjs/core/Hash.js\");\nconst Hex = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_cjs/core/Hex.js\");\nconst internal = __webpack_require__(/*! ./internal/abiItem.js */ \"(ssr)/./node_modules/ox/_cjs/core/internal/abiItem.js\");\nfunction format(abiItem) {\n    return abitype.formatAbiItem(abiItem);\n}\nfunction from(abiItem, options = {}) {\n    const { prepare = true } = options;\n    const item = (()=>{\n        if (Array.isArray(abiItem)) return abitype.parseAbiItem(abiItem);\n        if (typeof abiItem === \"string\") return abitype.parseAbiItem(abiItem);\n        return abiItem;\n    })();\n    return {\n        ...item,\n        ...prepare ? {\n            hash: getSignatureHash(item)\n        } : {}\n    };\n}\nfunction fromAbi(abi, name, options) {\n    const { args = [], prepare = true } = options ?? {};\n    const isSelector = Hex.validate(name, {\n        strict: false\n    });\n    const abiItems = abi.filter((abiItem)=>{\n        if (isSelector) {\n            if (abiItem.type === \"function\" || abiItem.type === \"error\") return getSelector(abiItem) === Hex.slice(name, 0, 4);\n            if (abiItem.type === \"event\") return getSignatureHash(abiItem) === name;\n            return false;\n        }\n        return \"name\" in abiItem && abiItem.name === name;\n    });\n    if (abiItems.length === 0) throw new NotFoundError({\n        name: name\n    });\n    if (abiItems.length === 1) return {\n        ...abiItems[0],\n        ...prepare ? {\n            hash: getSignatureHash(abiItems[0])\n        } : {}\n    };\n    let matchedAbiItem;\n    for (const abiItem of abiItems){\n        if (!(\"inputs\" in abiItem)) continue;\n        if (!args || args.length === 0) {\n            if (!abiItem.inputs || abiItem.inputs.length === 0) return {\n                ...abiItem,\n                ...prepare ? {\n                    hash: getSignatureHash(abiItem)\n                } : {}\n            };\n            continue;\n        }\n        if (!abiItem.inputs) continue;\n        if (abiItem.inputs.length === 0) continue;\n        if (abiItem.inputs.length !== args.length) continue;\n        const matched = args.every((arg, index)=>{\n            const abiParameter = \"inputs\" in abiItem && abiItem.inputs[index];\n            if (!abiParameter) return false;\n            return internal.isArgOfType(arg, abiParameter);\n        });\n        if (matched) {\n            if (matchedAbiItem && \"inputs\" in matchedAbiItem && matchedAbiItem.inputs) {\n                const ambiguousTypes = internal.getAmbiguousTypes(abiItem.inputs, matchedAbiItem.inputs, args);\n                if (ambiguousTypes) throw new AmbiguityError({\n                    abiItem,\n                    type: ambiguousTypes[0]\n                }, {\n                    abiItem: matchedAbiItem,\n                    type: ambiguousTypes[1]\n                });\n            }\n            matchedAbiItem = abiItem;\n        }\n    }\n    const abiItem = (()=>{\n        if (matchedAbiItem) return matchedAbiItem;\n        const [abiItem, ...overloads] = abiItems;\n        return {\n            ...abiItem,\n            overloads\n        };\n    })();\n    if (!abiItem) throw new NotFoundError({\n        name: name\n    });\n    return {\n        ...abiItem,\n        ...prepare ? {\n            hash: getSignatureHash(abiItem)\n        } : {}\n    };\n}\nfunction getSelector(...parameters) {\n    const abiItem = (()=>{\n        if (Array.isArray(parameters[0])) {\n            const [abi, name] = parameters;\n            return fromAbi(abi, name);\n        }\n        return parameters[0];\n    })();\n    return Hex.slice(getSignatureHash(abiItem), 0, 4);\n}\nfunction getSignature(...parameters) {\n    const abiItem = (()=>{\n        if (Array.isArray(parameters[0])) {\n            const [abi, name] = parameters;\n            return fromAbi(abi, name);\n        }\n        return parameters[0];\n    })();\n    const signature = (()=>{\n        if (typeof abiItem === \"string\") return abiItem;\n        return abitype.formatAbiItem(abiItem);\n    })();\n    return internal.normalizeSignature(signature);\n}\nfunction getSignatureHash(...parameters) {\n    const abiItem = (()=>{\n        if (Array.isArray(parameters[0])) {\n            const [abi, name] = parameters;\n            return fromAbi(abi, name);\n        }\n        return parameters[0];\n    })();\n    if (typeof abiItem !== \"string\" && \"hash\" in abiItem && abiItem.hash) return abiItem.hash;\n    return Hash.keccak256(Hex.fromString(getSignature(abiItem)));\n}\nclass AmbiguityError extends Errors.BaseError {\n    constructor(x, y){\n        super(\"Found ambiguous types in overloaded ABI Items.\", {\n            metaMessages: [\n                `\\`${x.type}\\` in \\`${internal.normalizeSignature(abitype.formatAbiItem(x.abiItem))}\\`, and`,\n                `\\`${y.type}\\` in \\`${internal.normalizeSignature(abitype.formatAbiItem(y.abiItem))}\\``,\n                \"\",\n                \"These types encode differently and cannot be distinguished at runtime.\",\n                \"Remove one of the ambiguous items in the ABI.\"\n            ]\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"AbiItem.AmbiguityError\"\n        });\n    }\n}\nexports.AmbiguityError = AmbiguityError;\nclass NotFoundError extends Errors.BaseError {\n    constructor({ name, data, type = \"item\" }){\n        const selector = (()=>{\n            if (name) return ` with name \"${name}\"`;\n            if (data) return ` with data \"${data}\"`;\n            return \"\";\n        })();\n        super(`ABI ${type}${selector} not found.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"AbiItem.NotFoundError\"\n        });\n    }\n}\nexports.NotFoundError = NotFoundError;\nclass InvalidSelectorSizeError extends Errors.BaseError {\n    constructor({ data }){\n        super(`Selector size is invalid. Expected 4 bytes. Received ${Hex.size(data)} bytes (\"${data}\").`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"AbiItem.InvalidSelectorSizeError\"\n        });\n    }\n}\nexports.InvalidSelectorSizeError = InvalidSelectorSizeError; //# sourceMappingURL=AbiItem.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2Nqcy9jb3JlL0FiaUl0ZW0uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGdDQUFnQyxHQUFHQSxxQkFBcUIsR0FBR0Esc0JBQXNCLEdBQUcsS0FBSztBQUN6RkEsY0FBYyxHQUFHSztBQUNqQkwsWUFBWSxHQUFHTTtBQUNmTixlQUFlLEdBQUdPO0FBQ2xCUCxtQkFBbUIsR0FBR1E7QUFDdEJSLG9CQUFvQixHQUFHUztBQUN2QlQsd0JBQXdCLEdBQUdVO0FBQzNCLE1BQU1DLFVBQVVDLG1CQUFPQSxDQUFDLHVFQUFTO0FBQ2pDLE1BQU1DLFNBQVNELG1CQUFPQSxDQUFDLGdFQUFhO0FBQ3BDLE1BQU1FLE9BQU9GLG1CQUFPQSxDQUFDLDREQUFXO0FBQ2hDLE1BQU1HLE1BQU1ILG1CQUFPQSxDQUFDLDBEQUFVO0FBQzlCLE1BQU1JLFdBQVdKLG1CQUFPQSxDQUFDLG9GQUF1QjtBQUNoRCxTQUFTUCxPQUFPWSxPQUFPO0lBQ25CLE9BQU9OLFFBQVFPLGFBQWEsQ0FBQ0Q7QUFDakM7QUFDQSxTQUFTWCxLQUFLVyxPQUFPLEVBQUVFLFVBQVUsQ0FBQyxDQUFDO0lBQy9CLE1BQU0sRUFBRUMsVUFBVSxJQUFJLEVBQUUsR0FBR0Q7SUFDM0IsTUFBTUUsT0FBTyxDQUFDO1FBQ1YsSUFBSUMsTUFBTUMsT0FBTyxDQUFDTixVQUNkLE9BQU9OLFFBQVFhLFlBQVksQ0FBQ1A7UUFDaEMsSUFBSSxPQUFPQSxZQUFZLFVBQ25CLE9BQU9OLFFBQVFhLFlBQVksQ0FBQ1A7UUFDaEMsT0FBT0E7SUFDWDtJQUNBLE9BQU87UUFDSCxHQUFHSSxJQUFJO1FBQ1AsR0FBSUQsVUFBVTtZQUFFSyxNQUFNZixpQkFBaUJXO1FBQU0sSUFBSSxDQUFDLENBQUM7SUFDdkQ7QUFDSjtBQUNBLFNBQVNkLFFBQVFtQixHQUFHLEVBQUVDLElBQUksRUFBRVIsT0FBTztJQUMvQixNQUFN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O0FBQ3hCLE1BQU1ELGlDQUFpQ1csT0FBT3dDLFNBQVM7SUFDbkRDLFlBQVksRUFBRU8sSUFBSSxFQUFFLENBQUU7UUFDbEIsS0FBSyxDQUFDLENBQUMscURBQXFELEVBQUU5QyxJQUFJZ0QsSUFBSSxDQUFDRixNQUFNLFNBQVMsRUFBRUEsS0FBSyxHQUFHLENBQUM7UUFDakcvRCxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLFFBQVE7WUFDaEMyRCxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWM0QsT0FBTztRQUNYO0lBQ0o7QUFDSjtBQUNBRCxnQ0FBZ0MsR0FBR0UsMEJBQ25DLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsYXctd29ya3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3gvX2Nqcy9jb3JlL0FiaUl0ZW0uanM/OGFlOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSW52YWxpZFNlbGVjdG9yU2l6ZUVycm9yID0gZXhwb3J0cy5Ob3RGb3VuZEVycm9yID0gZXhwb3J0cy5BbWJpZ3VpdHlFcnJvciA9IHZvaWQgMDtcbmV4cG9ydHMuZm9ybWF0ID0gZm9ybWF0O1xuZXhwb3J0cy5mcm9tID0gZnJvbTtcbmV4cG9ydHMuZnJvbUFiaSA9IGZyb21BYmk7XG5leHBvcnRzLmdldFNlbGVjdG9yID0gZ2V0U2VsZWN0b3I7XG5leHBvcnRzLmdldFNpZ25hdHVyZSA9IGdldFNpZ25hdHVyZTtcbmV4cG9ydHMuZ2V0U2lnbmF0dXJlSGFzaCA9IGdldFNpZ25hdHVyZUhhc2g7XG5jb25zdCBhYml0eXBlID0gcmVxdWlyZShcImFiaXR5cGVcIik7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKFwiLi9FcnJvcnMuanNcIik7XG5jb25zdCBIYXNoID0gcmVxdWlyZShcIi4vSGFzaC5qc1wiKTtcbmNvbnN0IEhleCA9IHJlcXVpcmUoXCIuL0hleC5qc1wiKTtcbmNvbnN0IGludGVybmFsID0gcmVxdWlyZShcIi4vaW50ZXJuYWwvYWJpSXRlbS5qc1wiKTtcbmZ1bmN0aW9uIGZvcm1hdChhYmlJdGVtKSB7XG4gICAgcmV0dXJuIGFiaXR5cGUuZm9ybWF0QWJpSXRlbShhYmlJdGVtKTtcbn1cbmZ1bmN0aW9uIGZyb20oYWJpSXRlbSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBwcmVwYXJlID0gdHJ1ZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBpdGVtID0gKCgpID0+IHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYWJpSXRlbSkpXG4gICAgICAgICAgICByZXR1cm4gYWJpdHlwZS5wYXJzZUFiaUl0ZW0oYWJpSXRlbSk7XG4gICAgICAgIGlmICh0eXBlb2YgYWJpSXRlbSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICByZXR1cm4gYWJpdHlwZS5wYXJzZUFiaUl0ZW0oYWJpSXRlbSk7XG4gICAgICAgIHJldHVybiBhYmlJdGVtO1xuICAgIH0pKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uaXRlbSxcbiAgICAgICAgLi4uKHByZXBhcmUgPyB7IGhhc2g6IGdldFNpZ25hdHVyZUhhc2goaXRlbSkgfSA6IHt9KSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZnJvbUFiaShhYmksIG5hbWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGFyZ3MgPSBbXSwgcHJlcGFyZSA9IHRydWUgfSA9IChvcHRpb25zID8/XG4gICAgICAgIHt9KTtcbiAgICBjb25zdCBpc1NlbGVjdG9yID0gSGV4LnZhbGlkYXRlKG5hbWUsIHsgc3RyaWN0OiBmYWxzZSB9KTtcbiAgICBjb25zdCBhYmlJdGVtcyA9IGFiaS5maWx0ZXIoKGFiaUl0ZW0pID0+IHtcbiAgICAgICAgaWYgKGlzU2VsZWN0b3IpIHtcbiAgICAgICAgICAgIGlmIChhYmlJdGVtLnR5cGUgPT09ICdmdW5jdGlvbicgfHwgYWJpSXRlbS50eXBlID09PSAnZXJyb3InKVxuICAgICAgICAgICAgICAgIHJldHVybiBnZXRTZWxlY3RvcihhYmlJdGVtKSA9PT0gSGV4LnNsaWNlKG5hbWUsIDAsIDQpO1xuICAgICAgICAgICAgaWYgKGFiaUl0ZW0udHlwZSA9PT0gJ2V2ZW50JylcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0U2lnbmF0dXJlSGFzaChhYmlJdGVtKSA9PT0gbmFtZTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ25hbWUnIGluIGFiaUl0ZW0gJiYgYWJpSXRlbS5uYW1lID09PSBuYW1lO1xuICAgIH0pO1xuICAgIGlmIChhYmlJdGVtcy5sZW5ndGggPT09IDApXG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEVycm9yKHsgbmFtZTogbmFtZSB9KTtcbiAgICBpZiAoYWJpSXRlbXMubGVuZ3RoID09PSAxKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uYWJpSXRlbXNbMF0sXG4gICAgICAgICAgICAuLi4ocHJlcGFyZSA/IHsgaGFzaDogZ2V0U2lnbmF0dXJlSGFzaChhYmlJdGVtc1swXSkgfSA6IHt9KSxcbiAgICAgICAgfTtcbiAgICBsZXQgbWF0Y2hlZEFiaUl0ZW07XG4gICAgZm9yIChjb25zdCBhYmlJdGVtIG9mIGFiaUl0ZW1zKSB7XG4gICAgICAgIGlmICghKCdpbnB1dHMnIGluIGFiaUl0ZW0pKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmICghYXJncyB8fCBhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKCFhYmlJdGVtLmlucHV0cyB8fCBhYmlJdGVtLmlucHV0cy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgLi4uYWJpSXRlbSxcbiAgICAgICAgICAgICAgICAgICAgLi4uKHByZXBhcmUgPyB7IGhhc2g6IGdldFNpZ25hdHVyZUhhc2goYWJpSXRlbSkgfSA6IHt9KSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhYmlJdGVtLmlucHV0cylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoYWJpSXRlbS5pbnB1dHMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChhYmlJdGVtLmlucHV0cy5sZW5ndGggIT09IGFyZ3MubGVuZ3RoKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IG1hdGNoZWQgPSBhcmdzLmV2ZXJ5KChhcmcsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhYmlQYXJhbWV0ZXIgPSAnaW5wdXRzJyBpbiBhYmlJdGVtICYmIGFiaUl0ZW0uaW5wdXRzW2luZGV4XTtcbiAgICAgICAgICAgIGlmICghYWJpUGFyYW1ldGVyKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbC5pc0FyZ09mVHlwZShhcmcsIGFiaVBhcmFtZXRlcik7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgICAgICAgaWYgKG1hdGNoZWRBYmlJdGVtICYmXG4gICAgICAgICAgICAgICAgJ2lucHV0cycgaW4gbWF0Y2hlZEFiaUl0ZW0gJiZcbiAgICAgICAgICAgICAgICBtYXRjaGVkQWJpSXRlbS5pbnB1dHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhbWJpZ3VvdXNUeXBlcyA9IGludGVybmFsLmdldEFtYmlndW91c1R5cGVzKGFiaUl0ZW0uaW5wdXRzLCBtYXRjaGVkQWJpSXRlbS5pbnB1dHMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIGlmIChhbWJpZ3VvdXNUeXBlcylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFtYmlndWl0eUVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFiaUl0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBhbWJpZ3VvdXNUeXBlc1swXSxcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWJpSXRlbTogbWF0Y2hlZEFiaUl0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBhbWJpZ3VvdXNUeXBlc1sxXSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXRjaGVkQWJpSXRlbSA9IGFiaUl0ZW07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgYWJpSXRlbSA9ICgoKSA9PiB7XG4gICAgICAgIGlmIChtYXRjaGVkQWJpSXRlbSlcbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVkQWJpSXRlbTtcbiAgICAgICAgY29uc3QgW2FiaUl0ZW0sIC4uLm92ZXJsb2Fkc10gPSBhYmlJdGVtcztcbiAgICAgICAgcmV0dXJuIHsgLi4uYWJpSXRlbSwgb3ZlcmxvYWRzIH07XG4gICAgfSkoKTtcbiAgICBpZiAoIWFiaUl0ZW0pXG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEVycm9yKHsgbmFtZTogbmFtZSB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5hYmlJdGVtLFxuICAgICAgICAuLi4ocHJlcGFyZSA/IHsgaGFzaDogZ2V0U2lnbmF0dXJlSGFzaChhYmlJdGVtKSB9IDoge30pLFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRTZWxlY3RvciguLi5wYXJhbWV0ZXJzKSB7XG4gICAgY29uc3QgYWJpSXRlbSA9ICgoKSA9PiB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtZXRlcnNbMF0pKSB7XG4gICAgICAgICAgICBjb25zdCBbYWJpLCBuYW1lXSA9IHBhcmFtZXRlcnM7XG4gICAgICAgICAgICByZXR1cm4gZnJvbUFiaShhYmksIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJhbWV0ZXJzWzBdO1xuICAgIH0pKCk7XG4gICAgcmV0dXJuIEhleC5zbGljZShnZXRTaWduYXR1cmVIYXNoKGFiaUl0ZW0pLCAwLCA0KTtcbn1cbmZ1bmN0aW9uIGdldFNpZ25hdHVyZSguLi5wYXJhbWV0ZXJzKSB7XG4gICAgY29uc3QgYWJpSXRlbSA9ICgoKSA9PiB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtZXRlcnNbMF0pKSB7XG4gICAgICAgICAgICBjb25zdCBbYWJpLCBuYW1lXSA9IHBhcmFtZXRlcnM7XG4gICAgICAgICAgICByZXR1cm4gZnJvbUFiaShhYmksIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJhbWV0ZXJzWzBdO1xuICAgIH0pKCk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gKCgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBhYmlJdGVtID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiBhYmlJdGVtO1xuICAgICAgICByZXR1cm4gYWJpdHlwZS5mb3JtYXRBYmlJdGVtKGFiaUl0ZW0pO1xuICAgIH0pKCk7XG4gICAgcmV0dXJuIGludGVybmFsLm5vcm1hbGl6ZVNpZ25hdHVyZShzaWduYXR1cmUpO1xufVxuZnVuY3Rpb24gZ2V0U2lnbmF0dXJlSGFzaCguLi5wYXJhbWV0ZXJzKSB7XG4gICAgY29uc3QgYWJpSXRlbSA9ICgoKSA9PiB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtZXRlcnNbMF0pKSB7XG4gICAgICAgICAgICBjb25zdCBbYWJpLCBuYW1lXSA9IHBhcmFtZXRlcnM7XG4gICAgICAgICAgICByZXR1cm4gZnJvbUFiaShhYmksIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJhbWV0ZXJzWzBdO1xuICAgIH0pKCk7XG4gICAgaWYgKHR5cGVvZiBhYmlJdGVtICE9PSAnc3RyaW5nJyAmJiAnaGFzaCcgaW4gYWJpSXRlbSAmJiBhYmlJdGVtLmhhc2gpXG4gICAgICAgIHJldHVybiBhYmlJdGVtLmhhc2g7XG4gICAgcmV0dXJuIEhhc2gua2VjY2FrMjU2KEhleC5mcm9tU3RyaW5nKGdldFNpZ25hdHVyZShhYmlJdGVtKSkpO1xufVxuY2xhc3MgQW1iaWd1aXR5RXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih4LCB5KSB7XG4gICAgICAgIHN1cGVyKCdGb3VuZCBhbWJpZ3VvdXMgdHlwZXMgaW4gb3ZlcmxvYWRlZCBBQkkgSXRlbXMuJywge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXG4gICAgICAgICAgICAgICAgYFxcYCR7eC50eXBlfVxcYCBpbiBcXGAke2ludGVybmFsLm5vcm1hbGl6ZVNpZ25hdHVyZShhYml0eXBlLmZvcm1hdEFiaUl0ZW0oeC5hYmlJdGVtKSl9XFxgLCBhbmRgLFxuICAgICAgICAgICAgICAgIGBcXGAke3kudHlwZX1cXGAgaW4gXFxgJHtpbnRlcm5hbC5ub3JtYWxpemVTaWduYXR1cmUoYWJpdHlwZS5mb3JtYXRBYmlJdGVtKHkuYWJpSXRlbSkpfVxcYGAsXG4gICAgICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAgICAgJ1RoZXNlIHR5cGVzIGVuY29kZSBkaWZmZXJlbnRseSBhbmQgY2Fubm90IGJlIGRpc3Rpbmd1aXNoZWQgYXQgcnVudGltZS4nLFxuICAgICAgICAgICAgICAgICdSZW1vdmUgb25lIG9mIHRoZSBhbWJpZ3VvdXMgaXRlbXMgaW4gdGhlIEFCSS4nLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdBYmlJdGVtLkFtYmlndWl0eUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkFtYmlndWl0eUVycm9yID0gQW1iaWd1aXR5RXJyb3I7XG5jbGFzcyBOb3RGb3VuZEVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBuYW1lLCBkYXRhLCB0eXBlID0gJ2l0ZW0nLCB9KSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdG9yID0gKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChuYW1lKVxuICAgICAgICAgICAgICAgIHJldHVybiBgIHdpdGggbmFtZSBcIiR7bmFtZX1cImA7XG4gICAgICAgICAgICBpZiAoZGF0YSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYCB3aXRoIGRhdGEgXCIke2RhdGF9XCJgO1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9KSgpO1xuICAgICAgICBzdXBlcihgQUJJICR7dHlwZX0ke3NlbGVjdG9yfSBub3QgZm91bmQuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdBYmlJdGVtLk5vdEZvdW5kRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuTm90Rm91bmRFcnJvciA9IE5vdEZvdW5kRXJyb3I7XG5jbGFzcyBJbnZhbGlkU2VsZWN0b3JTaXplRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGRhdGEgfSkge1xuICAgICAgICBzdXBlcihgU2VsZWN0b3Igc2l6ZSBpcyBpbnZhbGlkLiBFeHBlY3RlZCA0IGJ5dGVzLiBSZWNlaXZlZCAke0hleC5zaXplKGRhdGEpfSBieXRlcyAoXCIke2RhdGF9XCIpLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQWJpSXRlbS5JbnZhbGlkU2VsZWN0b3JTaXplRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuSW52YWxpZFNlbGVjdG9yU2l6ZUVycm9yID0gSW52YWxpZFNlbGVjdG9yU2l6ZUVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWJpSXRlbS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJJbnZhbGlkU2VsZWN0b3JTaXplRXJyb3IiLCJOb3RGb3VuZEVycm9yIiwiQW1iaWd1aXR5RXJyb3IiLCJmb3JtYXQiLCJmcm9tIiwiZnJvbUFiaSIsImdldFNlbGVjdG9yIiwiZ2V0U2lnbmF0dXJlIiwiZ2V0U2lnbmF0dXJlSGFzaCIsImFiaXR5cGUiLCJyZXF1aXJlIiwiRXJyb3JzIiwiSGFzaCIsIkhleCIsImludGVybmFsIiwiYWJpSXRlbSIsImZvcm1hdEFiaUl0ZW0iLCJvcHRpb25zIiwicHJlcGFyZSIsIml0ZW0iLCJBcnJheSIsImlzQXJyYXkiLCJwYXJzZUFiaUl0ZW0iLCJoYXNoIiwiYWJpIiwibmFtZSIsImFyZ3MiLCJpc1NlbGVjdG9yIiwidmFsaWRhdGUiLCJzdHJpY3QiLCJhYmlJdGVtcyIsImZpbHRlciIsInR5cGUiLCJzbGljZSIsImxlbmd0aCIsIm1hdGNoZWRBYmlJdGVtIiwiaW5wdXRzIiwibWF0Y2hlZCIsImV2ZXJ5IiwiYXJnIiwiaW5kZXgiLCJhYmlQYXJhbWV0ZXIiLCJpc0FyZ09mVHlwZSIsImFtYmlndW91c1R5cGVzIiwiZ2V0QW1iaWd1b3VzVHlwZXMiLCJvdmVybG9hZHMiLCJwYXJhbWV0ZXJzIiwic2lnbmF0dXJlIiwibm9ybWFsaXplU2lnbmF0dXJlIiwia2VjY2FrMjU2IiwiZnJvbVN0cmluZyIsIkJhc2VFcnJvciIsImNvbnN0cnVjdG9yIiwieCIsInkiLCJtZXRhTWVzc2FnZXMiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJkYXRhIiwic2VsZWN0b3IiLCJzaXplIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_cjs/core/AbiItem.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_cjs/core/AbiParameters.js":
/*!****************************************************!*\
  !*** ./node_modules/ox/_cjs/core/AbiParameters.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.InvalidTypeError = exports.InvalidArrayError = exports.LengthMismatchError = exports.BytesSizeMismatchError = exports.ArrayLengthMismatchError = exports.ZeroDataError = exports.DataSizeTooSmallError = void 0;\nexports.decode = decode;\nexports.encode = encode;\nexports.encodePacked = encodePacked;\nexports.format = format;\nexports.from = from;\nconst abitype = __webpack_require__(/*! abitype */ \"(ssr)/./node_modules/abitype/dist/cjs/exports/index.js\");\nconst Address = __webpack_require__(/*! ./Address.js */ \"(ssr)/./node_modules/ox/_cjs/core/Address.js\");\nconst Bytes = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/./node_modules/ox/_cjs/core/Bytes.js\");\nconst Errors = __webpack_require__(/*! ./Errors.js */ \"(ssr)/./node_modules/ox/_cjs/core/Errors.js\");\nconst Hex = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_cjs/core/Hex.js\");\nconst internal = __webpack_require__(/*! ./internal/abiParameters.js */ \"(ssr)/./node_modules/ox/_cjs/core/internal/abiParameters.js\");\nconst Cursor = __webpack_require__(/*! ./internal/cursor.js */ \"(ssr)/./node_modules/ox/_cjs/core/internal/cursor.js\");\nconst Solidity = __webpack_require__(/*! ./Solidity.js */ \"(ssr)/./node_modules/ox/_cjs/core/Solidity.js\");\nfunction decode(parameters, data, options = {}) {\n    const { as = \"Array\", checksumAddress = false } = options;\n    const bytes = typeof data === \"string\" ? Bytes.fromHex(data) : data;\n    const cursor = Cursor.create(bytes);\n    if (Bytes.size(bytes) === 0 && parameters.length > 0) throw new ZeroDataError();\n    if (Bytes.size(bytes) && Bytes.size(bytes) < 32) throw new DataSizeTooSmallError({\n        data: typeof data === \"string\" ? data : Hex.fromBytes(data),\n        parameters: parameters,\n        size: Bytes.size(bytes)\n    });\n    let consumed = 0;\n    const values = as === \"Array\" ? [] : {};\n    for(let i = 0; i < parameters.length; ++i){\n        const param = parameters[i];\n        cursor.setPosition(consumed);\n        const [data, consumed_] = internal.decodeParameter(cursor, param, {\n            checksumAddress,\n            staticPosition: 0\n        });\n        consumed += consumed_;\n        if (as === \"Array\") values.push(data);\n        else values[param.name ?? i] = data;\n    }\n    return values;\n}\nfunction encode(parameters, values, options) {\n    const { checksumAddress = false } = options ?? {};\n    if (parameters.length !== values.length) throw new LengthMismatchError({\n        expectedLength: parameters.length,\n        givenLength: values.length\n    });\n    const preparedParameters = internal.prepareParameters({\n        checksumAddress,\n        parameters: parameters,\n        values: values\n    });\n    const data = internal.encode(preparedParameters);\n    if (data.length === 0) return \"0x\";\n    return data;\n}\nfunction encodePacked(types, values) {\n    if (types.length !== values.length) throw new LengthMismatchError({\n        expectedLength: types.length,\n        givenLength: values.length\n    });\n    const data = [];\n    for(let i = 0; i < types.length; i++){\n        const type = types[i];\n        const value = values[i];\n        data.push(encodePacked.encode(type, value));\n    }\n    return Hex.concat(...data);\n}\n(function(encodePacked) {\n    function encode(type, value, isArray = false) {\n        if (type === \"address\") {\n            const address = value;\n            Address.assert(address);\n            return Hex.padLeft(address.toLowerCase(), isArray ? 32 : 0);\n        }\n        if (type === \"string\") return Hex.fromString(value);\n        if (type === \"bytes\") return value;\n        if (type === \"bool\") return Hex.padLeft(Hex.fromBoolean(value), isArray ? 32 : 1);\n        const intMatch = type.match(Solidity.integerRegex);\n        if (intMatch) {\n            const [_type, baseType, bits = \"256\"] = intMatch;\n            const size = Number.parseInt(bits, 10) / 8;\n            return Hex.fromNumber(value, {\n                size: isArray ? 32 : size,\n                signed: baseType === \"int\"\n            });\n        }\n        const bytesMatch = type.match(Solidity.bytesRegex);\n        if (bytesMatch) {\n            const [_type, size] = bytesMatch;\n            if (Number.parseInt(size, 10) !== (value.length - 2) / 2) throw new BytesSizeMismatchError({\n                expectedSize: Number.parseInt(size, 10),\n                value: value\n            });\n            return Hex.padRight(value, isArray ? 32 : 0);\n        }\n        const arrayMatch = type.match(Solidity.arrayRegex);\n        if (arrayMatch && Array.isArray(value)) {\n            const [_type, childType] = arrayMatch;\n            const data = [];\n            for(let i = 0; i < value.length; i++){\n                data.push(encode(childType, value[i], true));\n            }\n            if (data.length === 0) return \"0x\";\n            return Hex.concat(...data);\n        }\n        throw new InvalidTypeError(type);\n    }\n    encodePacked.encode = encode;\n})(encodePacked || (exports.encodePacked = encodePacked = {}));\nfunction format(parameters) {\n    return abitype.formatAbiParameters(parameters);\n}\nfunction from(parameters) {\n    if (Array.isArray(parameters) && typeof parameters[0] === \"string\") return abitype.parseAbiParameters(parameters);\n    if (typeof parameters === \"string\") return abitype.parseAbiParameters(parameters);\n    return parameters;\n}\nclass DataSizeTooSmallError extends Errors.BaseError {\n    constructor({ data, parameters, size }){\n        super(`Data size of ${size} bytes is too small for given parameters.`, {\n            metaMessages: [\n                `Params: (${abitype.formatAbiParameters(parameters)})`,\n                `Data:   ${data} (${size} bytes)`\n            ]\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"AbiParameters.DataSizeTooSmallError\"\n        });\n    }\n}\nexports.DataSizeTooSmallError = DataSizeTooSmallError;\nclass ZeroDataError extends Errors.BaseError {\n    constructor(){\n        super('Cannot decode zero data (\"0x\") with ABI parameters.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"AbiParameters.ZeroDataError\"\n        });\n    }\n}\nexports.ZeroDataError = ZeroDataError;\nclass ArrayLengthMismatchError extends Errors.BaseError {\n    constructor({ expectedLength, givenLength, type }){\n        super(`Array length mismatch for type \\`${type}\\`. Expected: \\`${expectedLength}\\`. Given: \\`${givenLength}\\`.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"AbiParameters.ArrayLengthMismatchError\"\n        });\n    }\n}\nexports.ArrayLengthMismatchError = ArrayLengthMismatchError;\nclass BytesSizeMismatchError extends Errors.BaseError {\n    constructor({ expectedSize, value }){\n        super(`Size of bytes \"${value}\" (bytes${Hex.size(value)}) does not match expected size (bytes${expectedSize}).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"AbiParameters.BytesSizeMismatchError\"\n        });\n    }\n}\nexports.BytesSizeMismatchError = BytesSizeMismatchError;\nclass LengthMismatchError extends Errors.BaseError {\n    constructor({ expectedLength, givenLength }){\n        super([\n            \"ABI encoding parameters/values length mismatch.\",\n            `Expected length (parameters): ${expectedLength}`,\n            `Given length (values): ${givenLength}`\n        ].join(\"\\n\"));\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"AbiParameters.LengthMismatchError\"\n        });\n    }\n}\nexports.LengthMismatchError = LengthMismatchError;\nclass InvalidArrayError extends Errors.BaseError {\n    constructor(value){\n        super(`Value \\`${value}\\` is not a valid array.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"AbiParameters.InvalidArrayError\"\n        });\n    }\n}\nexports.InvalidArrayError = InvalidArrayError;\nclass InvalidTypeError extends Errors.BaseError {\n    constructor(type){\n        super(`Type \\`${type}\\` is not a valid ABI Type.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"AbiParameters.InvalidTypeError\"\n        });\n    }\n}\nexports.InvalidTypeError = InvalidTypeError; //# sourceMappingURL=AbiParameters.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2Nqcy9jb3JlL0FiaVBhcmFtZXRlcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHdCQUF3QixHQUFHQSx5QkFBeUIsR0FBR0EsMkJBQTJCLEdBQUdBLDhCQUE4QixHQUFHQSxnQ0FBZ0MsR0FBR0EscUJBQXFCLEdBQUdBLDZCQUE2QixHQUFHLEtBQUs7QUFDdE5BLGNBQWMsR0FBR1M7QUFDakJULGNBQWMsR0FBR1U7QUFDakJWLG9CQUFvQixHQUFHVztBQUN2QlgsY0FBYyxHQUFHWTtBQUNqQlosWUFBWSxHQUFHYTtBQUNmLE1BQU1DLFVBQVVDLG1CQUFPQSxDQUFDLHVFQUFTO0FBQ2pDLE1BQU1DLFVBQVVELG1CQUFPQSxDQUFDLGtFQUFjO0FBQ3RDLE1BQU1FLFFBQVFGLG1CQUFPQSxDQUFDLDhEQUFZO0FBQ2xDLE1BQU1HLFNBQVNILG1CQUFPQSxDQUFDLGdFQUFhO0FBQ3BDLE1BQU1JLE1BQU1KLG1CQUFPQSxDQUFDLDBEQUFVO0FBQzlCLE1BQU1LLFdBQVdMLG1CQUFPQSxDQUFDLGdHQUE2QjtBQUN0RCxNQUFNTSxTQUFTTixtQkFBT0EsQ0FBQyxrRkFBc0I7QUFDN0MsTUFBTU8sV0FBV1AsbUJBQU9BLENBQUMsb0VBQWU7QUFDeEMsU0FBU04sT0FBT2MsVUFBVSxFQUFFQyxJQUFJLEVBQUVDLFVBQVUsQ0FBQyxDQUFDO0lBQzFDLE1BQU0sRUFBRUMsS0FBSyxPQUFPLEVBQUVDLGtCQUFrQixLQUFLLEVBQUUsR0FBR0Y7SUFDbEQsTUFBTUcsUUFBUSxPQUFPSixTQUFTLFdBQVdQLE1BQU1ZLE9BQU8sQ0FBQ0wsUUFBUUE7SUFDL0QsTUFBTU0sU0FBU1QsT0FBT1UsTUFBTSxDQUFDSDtJQUM3QixJQUFJWCxNQUFNZSxJQUFJLENBQUNKLFdBQVcsS0FBS0wsV0FBV1UsTUFBTSxHQUFHLEdBQy9DLE1BQU0sSUFBSTFCO0lBQ2QsSUFBSVUs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ZixLQUFLLENBQUMsQ0FBQyxRQUFRLEVBQUVBLE1BQU0sd0JBQXdCLENBQUM7UUFDaERILE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsUUFBUTtZQUNoQ21GLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZuRixPQUFPO1FBQ1g7SUFDSjtBQUNKO0FBQ0FELHlCQUF5QixHQUFHRztBQUM1QixNQUFNRCx5QkFBeUJnQixPQUFPNkQsU0FBUztJQUMzQ0MsWUFBWTlCLElBQUksQ0FBRTtRQUNkLEtBQUssQ0FBQyxDQUFDLE9BQU8sRUFBRUEsS0FBSywyQkFBMkIsQ0FBQztRQUNqRHBELE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsUUFBUTtZQUNoQ21GLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZuRixPQUFPO1FBQ1g7SUFDSjtBQUNKO0FBQ0FELHdCQUF3QixHQUFHRSxrQkFDM0IseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xhdy13b3Jrcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9fY2pzL2NvcmUvQWJpUGFyYW1ldGVycy5qcz9iNTRmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JbnZhbGlkVHlwZUVycm9yID0gZXhwb3J0cy5JbnZhbGlkQXJyYXlFcnJvciA9IGV4cG9ydHMuTGVuZ3RoTWlzbWF0Y2hFcnJvciA9IGV4cG9ydHMuQnl0ZXNTaXplTWlzbWF0Y2hFcnJvciA9IGV4cG9ydHMuQXJyYXlMZW5ndGhNaXNtYXRjaEVycm9yID0gZXhwb3J0cy5aZXJvRGF0YUVycm9yID0gZXhwb3J0cy5EYXRhU2l6ZVRvb1NtYWxsRXJyb3IgPSB2b2lkIDA7XG5leHBvcnRzLmRlY29kZSA9IGRlY29kZTtcbmV4cG9ydHMuZW5jb2RlID0gZW5jb2RlO1xuZXhwb3J0cy5lbmNvZGVQYWNrZWQgPSBlbmNvZGVQYWNrZWQ7XG5leHBvcnRzLmZvcm1hdCA9IGZvcm1hdDtcbmV4cG9ydHMuZnJvbSA9IGZyb207XG5jb25zdCBhYml0eXBlID0gcmVxdWlyZShcImFiaXR5cGVcIik7XG5jb25zdCBBZGRyZXNzID0gcmVxdWlyZShcIi4vQWRkcmVzcy5qc1wiKTtcbmNvbnN0IEJ5dGVzID0gcmVxdWlyZShcIi4vQnl0ZXMuanNcIik7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKFwiLi9FcnJvcnMuanNcIik7XG5jb25zdCBIZXggPSByZXF1aXJlKFwiLi9IZXguanNcIik7XG5jb25zdCBpbnRlcm5hbCA9IHJlcXVpcmUoXCIuL2ludGVybmFsL2FiaVBhcmFtZXRlcnMuanNcIik7XG5jb25zdCBDdXJzb3IgPSByZXF1aXJlKFwiLi9pbnRlcm5hbC9jdXJzb3IuanNcIik7XG5jb25zdCBTb2xpZGl0eSA9IHJlcXVpcmUoXCIuL1NvbGlkaXR5LmpzXCIpO1xuZnVuY3Rpb24gZGVjb2RlKHBhcmFtZXRlcnMsIGRhdGEsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgYXMgPSAnQXJyYXknLCBjaGVja3N1bUFkZHJlc3MgPSBmYWxzZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBieXRlcyA9IHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyA/IEJ5dGVzLmZyb21IZXgoZGF0YSkgOiBkYXRhO1xuICAgIGNvbnN0IGN1cnNvciA9IEN1cnNvci5jcmVhdGUoYnl0ZXMpO1xuICAgIGlmIChCeXRlcy5zaXplKGJ5dGVzKSA9PT0gMCAmJiBwYXJhbWV0ZXJzLmxlbmd0aCA+IDApXG4gICAgICAgIHRocm93IG5ldyBaZXJvRGF0YUVycm9yKCk7XG4gICAgaWYgKEJ5dGVzLnNpemUoYnl0ZXMpICYmIEJ5dGVzLnNpemUoYnl0ZXMpIDwgMzIpXG4gICAgICAgIHRocm93IG5ldyBEYXRhU2l6ZVRvb1NtYWxsRXJyb3Ioe1xuICAgICAgICAgICAgZGF0YTogdHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnID8gZGF0YSA6IEhleC5mcm9tQnl0ZXMoZGF0YSksXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBwYXJhbWV0ZXJzLFxuICAgICAgICAgICAgc2l6ZTogQnl0ZXMuc2l6ZShieXRlcyksXG4gICAgICAgIH0pO1xuICAgIGxldCBjb25zdW1lZCA9IDA7XG4gICAgY29uc3QgdmFsdWVzID0gYXMgPT09ICdBcnJheScgPyBbXSA6IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyYW1ldGVycy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBwYXJhbSA9IHBhcmFtZXRlcnNbaV07XG4gICAgICAgIGN1cnNvci5zZXRQb3NpdGlvbihjb25zdW1lZCk7XG4gICAgICAgIGNvbnN0IFtkYXRhLCBjb25zdW1lZF9dID0gaW50ZXJuYWwuZGVjb2RlUGFyYW1ldGVyKGN1cnNvciwgcGFyYW0sIHtcbiAgICAgICAgICAgIGNoZWNrc3VtQWRkcmVzcyxcbiAgICAgICAgICAgIHN0YXRpY1Bvc2l0aW9uOiAwLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3VtZWQgKz0gY29uc3VtZWRfO1xuICAgICAgICBpZiAoYXMgPT09ICdBcnJheScpXG4gICAgICAgICAgICB2YWx1ZXMucHVzaChkYXRhKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdmFsdWVzW3BhcmFtLm5hbWUgPz8gaV0gPSBkYXRhO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xufVxuZnVuY3Rpb24gZW5jb2RlKHBhcmFtZXRlcnMsIHZhbHVlcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgY2hlY2tzdW1BZGRyZXNzID0gZmFsc2UgfSA9IG9wdGlvbnMgPz8ge307XG4gICAgaWYgKHBhcmFtZXRlcnMubGVuZ3RoICE9PSB2YWx1ZXMubGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgTGVuZ3RoTWlzbWF0Y2hFcnJvcih7XG4gICAgICAgICAgICBleHBlY3RlZExlbmd0aDogcGFyYW1ldGVycy5sZW5ndGgsXG4gICAgICAgICAgICBnaXZlbkxlbmd0aDogdmFsdWVzLmxlbmd0aCxcbiAgICAgICAgfSk7XG4gICAgY29uc3QgcHJlcGFyZWRQYXJhbWV0ZXJzID0gaW50ZXJuYWwucHJlcGFyZVBhcmFtZXRlcnMoe1xuICAgICAgICBjaGVja3N1bUFkZHJlc3MsXG4gICAgICAgIHBhcmFtZXRlcnM6IHBhcmFtZXRlcnMsXG4gICAgICAgIHZhbHVlczogdmFsdWVzLFxuICAgIH0pO1xuICAgIGNvbnN0IGRhdGEgPSBpbnRlcm5hbC5lbmNvZGUocHJlcGFyZWRQYXJhbWV0ZXJzKTtcbiAgICBpZiAoZGF0YS5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiAnMHgnO1xuICAgIHJldHVybiBkYXRhO1xufVxuZnVuY3Rpb24gZW5jb2RlUGFja2VkKHR5cGVzLCB2YWx1ZXMpIHtcbiAgICBpZiAodHlwZXMubGVuZ3RoICE9PSB2YWx1ZXMubGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgTGVuZ3RoTWlzbWF0Y2hFcnJvcih7XG4gICAgICAgICAgICBleHBlY3RlZExlbmd0aDogdHlwZXMubGVuZ3RoLFxuICAgICAgICAgICAgZ2l2ZW5MZW5ndGg6IHZhbHVlcy5sZW5ndGgsXG4gICAgICAgIH0pO1xuICAgIGNvbnN0IGRhdGEgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0eXBlc1tpXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICAgIGRhdGEucHVzaChlbmNvZGVQYWNrZWQuZW5jb2RlKHR5cGUsIHZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiBIZXguY29uY2F0KC4uLmRhdGEpO1xufVxuKGZ1bmN0aW9uIChlbmNvZGVQYWNrZWQpIHtcbiAgICBmdW5jdGlvbiBlbmNvZGUodHlwZSwgdmFsdWUsIGlzQXJyYXkgPSBmYWxzZSkge1xuICAgICAgICBpZiAodHlwZSA9PT0gJ2FkZHJlc3MnKSB7XG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzID0gdmFsdWU7XG4gICAgICAgICAgICBBZGRyZXNzLmFzc2VydChhZGRyZXNzKTtcbiAgICAgICAgICAgIHJldHVybiBIZXgucGFkTGVmdChhZGRyZXNzLnRvTG93ZXJDYXNlKCksIGlzQXJyYXkgPyAzMiA6IDApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiBIZXguZnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgICAgIGlmICh0eXBlID09PSAnYnl0ZXMnKVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ2Jvb2wnKVxuICAgICAgICAgICAgcmV0dXJuIEhleC5wYWRMZWZ0KEhleC5mcm9tQm9vbGVhbih2YWx1ZSksIGlzQXJyYXkgPyAzMiA6IDEpO1xuICAgICAgICBjb25zdCBpbnRNYXRjaCA9IHR5cGUubWF0Y2goU29saWRpdHkuaW50ZWdlclJlZ2V4KTtcbiAgICAgICAgaWYgKGludE1hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCBbX3R5cGUsIGJhc2VUeXBlLCBiaXRzID0gJzI1NiddID0gaW50TWF0Y2g7XG4gICAgICAgICAgICBjb25zdCBzaXplID0gTnVtYmVyLnBhcnNlSW50KGJpdHMsIDEwKSAvIDg7XG4gICAgICAgICAgICByZXR1cm4gSGV4LmZyb21OdW1iZXIodmFsdWUsIHtcbiAgICAgICAgICAgICAgICBzaXplOiBpc0FycmF5ID8gMzIgOiBzaXplLFxuICAgICAgICAgICAgICAgIHNpZ25lZDogYmFzZVR5cGUgPT09ICdpbnQnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnl0ZXNNYXRjaCA9IHR5cGUubWF0Y2goU29saWRpdHkuYnl0ZXNSZWdleCk7XG4gICAgICAgIGlmIChieXRlc01hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCBbX3R5cGUsIHNpemVdID0gYnl0ZXNNYXRjaDtcbiAgICAgICAgICAgIGlmIChOdW1iZXIucGFyc2VJbnQoc2l6ZSwgMTApICE9PSAodmFsdWUubGVuZ3RoIC0gMikgLyAyKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCeXRlc1NpemVNaXNtYXRjaEVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWRTaXplOiBOdW1iZXIucGFyc2VJbnQoc2l6ZSwgMTApLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSGV4LnBhZFJpZ2h0KHZhbHVlLCBpc0FycmF5ID8gMzIgOiAwKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcnJheU1hdGNoID0gdHlwZS5tYXRjaChTb2xpZGl0eS5hcnJheVJlZ2V4KTtcbiAgICAgICAgaWYgKGFycmF5TWF0Y2ggJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IFtfdHlwZSwgY2hpbGRUeXBlXSA9IGFycmF5TWF0Y2g7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5wdXNoKGVuY29kZShjaGlsZFR5cGUsIHZhbHVlW2ldLCB0cnVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuICcweCc7XG4gICAgICAgICAgICByZXR1cm4gSGV4LmNvbmNhdCguLi5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFR5cGVFcnJvcih0eXBlKTtcbiAgICB9XG4gICAgZW5jb2RlUGFja2VkLmVuY29kZSA9IGVuY29kZTtcbn0pKGVuY29kZVBhY2tlZCB8fCAoZXhwb3J0cy5lbmNvZGVQYWNrZWQgPSBlbmNvZGVQYWNrZWQgPSB7fSkpO1xuZnVuY3Rpb24gZm9ybWF0KHBhcmFtZXRlcnMpIHtcbiAgICByZXR1cm4gYWJpdHlwZS5mb3JtYXRBYmlQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpO1xufVxuZnVuY3Rpb24gZnJvbShwYXJhbWV0ZXJzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW1ldGVycykgJiYgdHlwZW9mIHBhcmFtZXRlcnNbMF0gPT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gYWJpdHlwZS5wYXJzZUFiaVBhcmFtZXRlcnMocGFyYW1ldGVycyk7XG4gICAgaWYgKHR5cGVvZiBwYXJhbWV0ZXJzID09PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIGFiaXR5cGUucGFyc2VBYmlQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpO1xuICAgIHJldHVybiBwYXJhbWV0ZXJzO1xufVxuY2xhc3MgRGF0YVNpemVUb29TbWFsbEVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBkYXRhLCBwYXJhbWV0ZXJzLCBzaXplLCB9KSB7XG4gICAgICAgIHN1cGVyKGBEYXRhIHNpemUgb2YgJHtzaXplfSBieXRlcyBpcyB0b28gc21hbGwgZm9yIGdpdmVuIHBhcmFtZXRlcnMuYCwge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXG4gICAgICAgICAgICAgICAgYFBhcmFtczogKCR7YWJpdHlwZS5mb3JtYXRBYmlQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpfSlgLFxuICAgICAgICAgICAgICAgIGBEYXRhOiAgICR7ZGF0YX0gKCR7c2l6ZX0gYnl0ZXMpYCxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQWJpUGFyYW1ldGVycy5EYXRhU2l6ZVRvb1NtYWxsRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuRGF0YVNpemVUb29TbWFsbEVycm9yID0gRGF0YVNpemVUb29TbWFsbEVycm9yO1xuY2xhc3MgWmVyb0RhdGFFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignQ2Fubm90IGRlY29kZSB6ZXJvIGRhdGEgKFwiMHhcIikgd2l0aCBBQkkgcGFyYW1ldGVycy4nKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0FiaVBhcmFtZXRlcnMuWmVyb0RhdGFFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5aZXJvRGF0YUVycm9yID0gWmVyb0RhdGFFcnJvcjtcbmNsYXNzIEFycmF5TGVuZ3RoTWlzbWF0Y2hFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgZXhwZWN0ZWRMZW5ndGgsIGdpdmVuTGVuZ3RoLCB0eXBlLCB9KSB7XG4gICAgICAgIHN1cGVyKGBBcnJheSBsZW5ndGggbWlzbWF0Y2ggZm9yIHR5cGUgXFxgJHt0eXBlfVxcYC4gRXhwZWN0ZWQ6IFxcYCR7ZXhwZWN0ZWRMZW5ndGh9XFxgLiBHaXZlbjogXFxgJHtnaXZlbkxlbmd0aH1cXGAuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdBYmlQYXJhbWV0ZXJzLkFycmF5TGVuZ3RoTWlzbWF0Y2hFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5BcnJheUxlbmd0aE1pc21hdGNoRXJyb3IgPSBBcnJheUxlbmd0aE1pc21hdGNoRXJyb3I7XG5jbGFzcyBCeXRlc1NpemVNaXNtYXRjaEVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBleHBlY3RlZFNpemUsIHZhbHVlLCB9KSB7XG4gICAgICAgIHN1cGVyKGBTaXplIG9mIGJ5dGVzIFwiJHt2YWx1ZX1cIiAoYnl0ZXMke0hleC5zaXplKHZhbHVlKX0pIGRvZXMgbm90IG1hdGNoIGV4cGVjdGVkIHNpemUgKGJ5dGVzJHtleHBlY3RlZFNpemV9KS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0FiaVBhcmFtZXRlcnMuQnl0ZXNTaXplTWlzbWF0Y2hFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5CeXRlc1NpemVNaXNtYXRjaEVycm9yID0gQnl0ZXNTaXplTWlzbWF0Y2hFcnJvcjtcbmNsYXNzIExlbmd0aE1pc21hdGNoRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGV4cGVjdGVkTGVuZ3RoLCBnaXZlbkxlbmd0aCwgfSkge1xuICAgICAgICBzdXBlcihbXG4gICAgICAgICAgICAnQUJJIGVuY29kaW5nIHBhcmFtZXRlcnMvdmFsdWVzIGxlbmd0aCBtaXNtYXRjaC4nLFxuICAgICAgICAgICAgYEV4cGVjdGVkIGxlbmd0aCAocGFyYW1ldGVycyk6ICR7ZXhwZWN0ZWRMZW5ndGh9YCxcbiAgICAgICAgICAgIGBHaXZlbiBsZW5ndGggKHZhbHVlcyk6ICR7Z2l2ZW5MZW5ndGh9YCxcbiAgICAgICAgXS5qb2luKCdcXG4nKSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdBYmlQYXJhbWV0ZXJzLkxlbmd0aE1pc21hdGNoRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuTGVuZ3RoTWlzbWF0Y2hFcnJvciA9IExlbmd0aE1pc21hdGNoRXJyb3I7XG5jbGFzcyBJbnZhbGlkQXJyYXlFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIHN1cGVyKGBWYWx1ZSBcXGAke3ZhbHVlfVxcYCBpcyBub3QgYSB2YWxpZCBhcnJheS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0FiaVBhcmFtZXRlcnMuSW52YWxpZEFycmF5RXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuSW52YWxpZEFycmF5RXJyb3IgPSBJbnZhbGlkQXJyYXlFcnJvcjtcbmNsYXNzIEludmFsaWRUeXBlRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlKSB7XG4gICAgICAgIHN1cGVyKGBUeXBlIFxcYCR7dHlwZX1cXGAgaXMgbm90IGEgdmFsaWQgQUJJIFR5cGUuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdBYmlQYXJhbWV0ZXJzLkludmFsaWRUeXBlRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuSW52YWxpZFR5cGVFcnJvciA9IEludmFsaWRUeXBlRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BYmlQYXJhbWV0ZXJzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkludmFsaWRUeXBlRXJyb3IiLCJJbnZhbGlkQXJyYXlFcnJvciIsIkxlbmd0aE1pc21hdGNoRXJyb3IiLCJCeXRlc1NpemVNaXNtYXRjaEVycm9yIiwiQXJyYXlMZW5ndGhNaXNtYXRjaEVycm9yIiwiWmVyb0RhdGFFcnJvciIsIkRhdGFTaXplVG9vU21hbGxFcnJvciIsImRlY29kZSIsImVuY29kZSIsImVuY29kZVBhY2tlZCIsImZvcm1hdCIsImZyb20iLCJhYml0eXBlIiwicmVxdWlyZSIsIkFkZHJlc3MiLCJCeXRlcyIsIkVycm9ycyIsIkhleCIsImludGVybmFsIiwiQ3Vyc29yIiwiU29saWRpdHkiLCJwYXJhbWV0ZXJzIiwiZGF0YSIsIm9wdGlvbnMiLCJhcyIsImNoZWNrc3VtQWRkcmVzcyIsImJ5dGVzIiwiZnJvbUhleCIsImN1cnNvciIsImNyZWF0ZSIsInNpemUiLCJsZW5ndGgiLCJmcm9tQnl0ZXMiLCJjb25zdW1lZCIsInZhbHVlcyIsImkiLCJwYXJhbSIsInNldFBvc2l0aW9uIiwiY29uc3VtZWRfIiwiZGVjb2RlUGFyYW1ldGVyIiwic3RhdGljUG9zaXRpb24iLCJwdXNoIiwibmFtZSIsImV4cGVjdGVkTGVuZ3RoIiwiZ2l2ZW5MZW5ndGgiLCJwcmVwYXJlZFBhcmFtZXRlcnMiLCJwcmVwYXJlUGFyYW1ldGVycyIsInR5cGVzIiwidHlwZSIsImNvbmNhdCIsImlzQXJyYXkiLCJhZGRyZXNzIiwiYXNzZXJ0IiwicGFkTGVmdCIsInRvTG93ZXJDYXNlIiwiZnJvbVN0cmluZyIsImZyb21Cb29sZWFuIiwiaW50TWF0Y2giLCJtYXRjaCIsImludGVnZXJSZWdleCIsIl90eXBlIiwiYmFzZVR5cGUiLCJiaXRzIiwiTnVtYmVyIiwicGFyc2VJbnQiLCJmcm9tTnVtYmVyIiwic2lnbmVkIiwiYnl0ZXNNYXRjaCIsImJ5dGVzUmVnZXgiLCJleHBlY3RlZFNpemUiLCJwYWRSaWdodCIsImFycmF5TWF0Y2giLCJhcnJheVJlZ2V4IiwiQXJyYXkiLCJjaGlsZFR5cGUiLCJmb3JtYXRBYmlQYXJhbWV0ZXJzIiwicGFyc2VBYmlQYXJhbWV0ZXJzIiwiQmFzZUVycm9yIiwiY29uc3RydWN0b3IiLCJtZXRhTWVzc2FnZXMiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJqb2luIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_cjs/core/AbiParameters.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_cjs/core/Address.js":
/*!**********************************************!*\
  !*** ./node_modules/ox/_cjs/core/Address.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.InvalidChecksumError = exports.InvalidInputError = exports.InvalidAddressError = void 0;\nexports.assert = assert;\nexports.checksum = checksum;\nexports.from = from;\nexports.fromPublicKey = fromPublicKey;\nexports.isEqual = isEqual;\nexports.validate = validate;\nconst Bytes = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/./node_modules/ox/_cjs/core/Bytes.js\");\nconst Caches = __webpack_require__(/*! ./Caches.js */ \"(ssr)/./node_modules/ox/_cjs/core/Caches.js\");\nconst Errors = __webpack_require__(/*! ./Errors.js */ \"(ssr)/./node_modules/ox/_cjs/core/Errors.js\");\nconst Hash = __webpack_require__(/*! ./Hash.js */ \"(ssr)/./node_modules/ox/_cjs/core/Hash.js\");\nconst PublicKey = __webpack_require__(/*! ./PublicKey.js */ \"(ssr)/./node_modules/ox/_cjs/core/PublicKey.js\");\nconst addressRegex = /^0x[a-fA-F0-9]{40}$/;\nfunction assert(value, options = {}) {\n    const { strict = true } = options;\n    if (!addressRegex.test(value)) throw new InvalidAddressError({\n        address: value,\n        cause: new InvalidInputError()\n    });\n    if (strict) {\n        if (value.toLowerCase() === value) return;\n        if (checksum(value) !== value) throw new InvalidAddressError({\n            address: value,\n            cause: new InvalidChecksumError()\n        });\n    }\n}\nfunction checksum(address) {\n    if (Caches.checksum.has(address)) return Caches.checksum.get(address);\n    assert(address, {\n        strict: false\n    });\n    const hexAddress = address.substring(2).toLowerCase();\n    const hash = Hash.keccak256(Bytes.fromString(hexAddress), {\n        as: \"Bytes\"\n    });\n    const characters = hexAddress.split(\"\");\n    for(let i = 0; i < 40; i += 2){\n        if (hash[i >> 1] >> 4 >= 8 && characters[i]) {\n            characters[i] = characters[i].toUpperCase();\n        }\n        if ((hash[i >> 1] & 0x0f) >= 8 && characters[i + 1]) {\n            characters[i + 1] = characters[i + 1].toUpperCase();\n        }\n    }\n    const result = `0x${characters.join(\"\")}`;\n    Caches.checksum.set(address, result);\n    return result;\n}\nfunction from(address, options = {}) {\n    const { checksum: checksumVal = false } = options;\n    assert(address);\n    if (checksumVal) return checksum(address);\n    return address;\n}\nfunction fromPublicKey(publicKey, options = {}) {\n    const address = Hash.keccak256(`0x${PublicKey.toHex(publicKey).slice(4)}`).substring(26);\n    return from(`0x${address}`, options);\n}\nfunction isEqual(addressA, addressB) {\n    assert(addressA, {\n        strict: false\n    });\n    assert(addressB, {\n        strict: false\n    });\n    return addressA.toLowerCase() === addressB.toLowerCase();\n}\nfunction validate(address, options = {}) {\n    const { strict = true } = options ?? {};\n    try {\n        assert(address, {\n            strict\n        });\n        return true;\n    } catch  {\n        return false;\n    }\n}\nclass InvalidAddressError extends Errors.BaseError {\n    constructor({ address, cause }){\n        super(`Address \"${address}\" is invalid.`, {\n            cause\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Address.InvalidAddressError\"\n        });\n    }\n}\nexports.InvalidAddressError = InvalidAddressError;\nclass InvalidInputError extends Errors.BaseError {\n    constructor(){\n        super(\"Address is not a 20 byte (40 hexadecimal character) value.\");\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Address.InvalidInputError\"\n        });\n    }\n}\nexports.InvalidInputError = InvalidInputError;\nclass InvalidChecksumError extends Errors.BaseError {\n    constructor(){\n        super(\"Address does not match its checksum counterpart.\");\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Address.InvalidChecksumError\"\n        });\n    }\n}\nexports.InvalidChecksumError = InvalidChecksumError; //# sourceMappingURL=Address.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2Nqcy9jb3JlL0FkZHJlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDRCQUE0QixHQUFHQSx5QkFBeUIsR0FBR0EsMkJBQTJCLEdBQUcsS0FBSztBQUM5RkEsY0FBYyxHQUFHSztBQUNqQkwsZ0JBQWdCLEdBQUdNO0FBQ25CTixZQUFZLEdBQUdPO0FBQ2ZQLHFCQUFxQixHQUFHUTtBQUN4QlIsZUFBZSxHQUFHUztBQUNsQlQsZ0JBQWdCLEdBQUdVO0FBQ25CLE1BQU1DLFFBQVFDLG1CQUFPQSxDQUFDLDhEQUFZO0FBQ2xDLE1BQU1DLFNBQVNELG1CQUFPQSxDQUFDLGdFQUFhO0FBQ3BDLE1BQU1FLFNBQVNGLG1CQUFPQSxDQUFDLGdFQUFhO0FBQ3BDLE1BQU1HLE9BQU9ILG1CQUFPQSxDQUFDLDREQUFXO0FBQ2hDLE1BQU1JLFlBQVlKLG1CQUFPQSxDQUFDLHNFQUFnQjtBQUMxQyxNQUFNSyxlQUFlO0FBQ3JCLFNBQVNaLE9BQU9KLEtBQUssRUFBRWlCLFVBQVUsQ0FBQyxDQUFDO0lBQy9CLE1BQU0sRUFBRUMsU0FBUyxJQUFJLEVBQUUsR0FBR0Q7SUFDMUIsSUFBSSxDQUFDRCxhQUFhRyxJQUFJLENBQUNuQixRQUNuQixNQUFNLElBQUlHLG9CQUFvQjtRQUMxQmlCLFNBQVNwQjtRQUNUcUIsT0FBTyxJQUFJbkI7SUFDZjtJQUNKLElBQUlnQixRQUFRO1FBQ1IsSUFBSWxCLE1BQU1zQixXQUFXLE9BQU90QixPQUN4QjtRQUNKLElBQUlLLFNBQVNMLFdBQVdBLE9BQ3BCLE1BQU0sSUFBSUcsb0JBQW9CO1lBQzFCaUIsU0FBU3BCO1lBQ1RxQixPQUFPLElBQUlwQjtRQUNmO0lBQ1I7QUFDSjtBQUNBLFNBQVNJLFNBQVNlLE9BQU87SUFDckIsSUFBSVIsT0FBT1AsUUFBUSxDQUFDa0IsR0FBRyxDQUFDSCxVQUNwQixPQUFPUixPQUFPUCxRQUFR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R0c7QUFDNUIsTUFBTUQsNkJBQTZCWSxPQUFPK0IsU0FBUztJQUMvQ0MsYUFBYztRQUNWLEtBQUssQ0FBQztRQUNOaEQsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxRQUFRO1lBQ2hDZ0QsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVmhELE9BQU87UUFDWDtJQUNKO0FBQ0o7QUFDQUQsNEJBQTRCLEdBQUdFLHNCQUMvQixtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGF3LXdvcmtzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L19janMvY29yZS9BZGRyZXNzLmpzPzQ2MTAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkludmFsaWRDaGVja3N1bUVycm9yID0gZXhwb3J0cy5JbnZhbGlkSW5wdXRFcnJvciA9IGV4cG9ydHMuSW52YWxpZEFkZHJlc3NFcnJvciA9IHZvaWQgMDtcbmV4cG9ydHMuYXNzZXJ0ID0gYXNzZXJ0O1xuZXhwb3J0cy5jaGVja3N1bSA9IGNoZWNrc3VtO1xuZXhwb3J0cy5mcm9tID0gZnJvbTtcbmV4cG9ydHMuZnJvbVB1YmxpY0tleSA9IGZyb21QdWJsaWNLZXk7XG5leHBvcnRzLmlzRXF1YWwgPSBpc0VxdWFsO1xuZXhwb3J0cy52YWxpZGF0ZSA9IHZhbGlkYXRlO1xuY29uc3QgQnl0ZXMgPSByZXF1aXJlKFwiLi9CeXRlcy5qc1wiKTtcbmNvbnN0IENhY2hlcyA9IHJlcXVpcmUoXCIuL0NhY2hlcy5qc1wiKTtcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoXCIuL0Vycm9ycy5qc1wiKTtcbmNvbnN0IEhhc2ggPSByZXF1aXJlKFwiLi9IYXNoLmpzXCIpO1xuY29uc3QgUHVibGljS2V5ID0gcmVxdWlyZShcIi4vUHVibGljS2V5LmpzXCIpO1xuY29uc3QgYWRkcmVzc1JlZ2V4ID0gL14weFthLWZBLUYwLTldezQwfSQvO1xuZnVuY3Rpb24gYXNzZXJ0KHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHN0cmljdCA9IHRydWUgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCFhZGRyZXNzUmVnZXgudGVzdCh2YWx1ZSkpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKHtcbiAgICAgICAgICAgIGFkZHJlc3M6IHZhbHVlLFxuICAgICAgICAgICAgY2F1c2U6IG5ldyBJbnZhbGlkSW5wdXRFcnJvcigpLFxuICAgICAgICB9KTtcbiAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgIGlmICh2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSB2YWx1ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGNoZWNrc3VtKHZhbHVlKSAhPT0gdmFsdWUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcih7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogdmFsdWUsXG4gICAgICAgICAgICAgICAgY2F1c2U6IG5ldyBJbnZhbGlkQ2hlY2tzdW1FcnJvcigpLFxuICAgICAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tzdW0oYWRkcmVzcykge1xuICAgIGlmIChDYWNoZXMuY2hlY2tzdW0uaGFzKGFkZHJlc3MpKVxuICAgICAgICByZXR1cm4gQ2FjaGVzLmNoZWNrc3VtLmdldChhZGRyZXNzKTtcbiAgICBhc3NlcnQoYWRkcmVzcywgeyBzdHJpY3Q6IGZhbHNlIH0pO1xuICAgIGNvbnN0IGhleEFkZHJlc3MgPSBhZGRyZXNzLnN1YnN0cmluZygyKS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IGhhc2ggPSBIYXNoLmtlY2NhazI1NihCeXRlcy5mcm9tU3RyaW5nKGhleEFkZHJlc3MpLCB7IGFzOiAnQnl0ZXMnIH0pO1xuICAgIGNvbnN0IGNoYXJhY3RlcnMgPSBoZXhBZGRyZXNzLnNwbGl0KCcnKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQwOyBpICs9IDIpIHtcbiAgICAgICAgaWYgKGhhc2hbaSA+PiAxXSA+PiA0ID49IDggJiYgY2hhcmFjdGVyc1tpXSkge1xuICAgICAgICAgICAgY2hhcmFjdGVyc1tpXSA9IGNoYXJhY3RlcnNbaV0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGhhc2hbaSA+PiAxXSAmIDB4MGYpID49IDggJiYgY2hhcmFjdGVyc1tpICsgMV0pIHtcbiAgICAgICAgICAgIGNoYXJhY3RlcnNbaSArIDFdID0gY2hhcmFjdGVyc1tpICsgMV0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBgMHgke2NoYXJhY3RlcnMuam9pbignJyl9YDtcbiAgICBDYWNoZXMuY2hlY2tzdW0uc2V0KGFkZHJlc3MsIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGZyb20oYWRkcmVzcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBjaGVja3N1bTogY2hlY2tzdW1WYWwgPSBmYWxzZSB9ID0gb3B0aW9ucztcbiAgICBhc3NlcnQoYWRkcmVzcyk7XG4gICAgaWYgKGNoZWNrc3VtVmFsKVxuICAgICAgICByZXR1cm4gY2hlY2tzdW0oYWRkcmVzcyk7XG4gICAgcmV0dXJuIGFkZHJlc3M7XG59XG5mdW5jdGlvbiBmcm9tUHVibGljS2V5KHB1YmxpY0tleSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgYWRkcmVzcyA9IEhhc2gua2VjY2FrMjU2KGAweCR7UHVibGljS2V5LnRvSGV4KHB1YmxpY0tleSkuc2xpY2UoNCl9YCkuc3Vic3RyaW5nKDI2KTtcbiAgICByZXR1cm4gZnJvbShgMHgke2FkZHJlc3N9YCwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBpc0VxdWFsKGFkZHJlc3NBLCBhZGRyZXNzQikge1xuICAgIGFzc2VydChhZGRyZXNzQSwgeyBzdHJpY3Q6IGZhbHNlIH0pO1xuICAgIGFzc2VydChhZGRyZXNzQiwgeyBzdHJpY3Q6IGZhbHNlIH0pO1xuICAgIHJldHVybiBhZGRyZXNzQS50b0xvd2VyQ2FzZSgpID09PSBhZGRyZXNzQi50b0xvd2VyQ2FzZSgpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGUoYWRkcmVzcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzdHJpY3QgPSB0cnVlIH0gPSBvcHRpb25zID8/IHt9O1xuICAgIHRyeSB7XG4gICAgICAgIGFzc2VydChhZGRyZXNzLCB7IHN0cmljdCB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmNsYXNzIEludmFsaWRBZGRyZXNzRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGFkZHJlc3MsIGNhdXNlIH0pIHtcbiAgICAgICAgc3VwZXIoYEFkZHJlc3MgXCIke2FkZHJlc3N9XCIgaXMgaW52YWxpZC5gLCB7XG4gICAgICAgICAgICBjYXVzZSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdBZGRyZXNzLkludmFsaWRBZGRyZXNzRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuSW52YWxpZEFkZHJlc3NFcnJvciA9IEludmFsaWRBZGRyZXNzRXJyb3I7XG5jbGFzcyBJbnZhbGlkSW5wdXRFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignQWRkcmVzcyBpcyBub3QgYSAyMCBieXRlICg0MCBoZXhhZGVjaW1hbCBjaGFyYWN0ZXIpIHZhbHVlLicpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQWRkcmVzcy5JbnZhbGlkSW5wdXRFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5JbnZhbGlkSW5wdXRFcnJvciA9IEludmFsaWRJbnB1dEVycm9yO1xuY2xhc3MgSW52YWxpZENoZWNrc3VtRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ0FkZHJlc3MgZG9lcyBub3QgbWF0Y2ggaXRzIGNoZWNrc3VtIGNvdW50ZXJwYXJ0LicpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQWRkcmVzcy5JbnZhbGlkQ2hlY2tzdW1FcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5JbnZhbGlkQ2hlY2tzdW1FcnJvciA9IEludmFsaWRDaGVja3N1bUVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWRkcmVzcy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJJbnZhbGlkQ2hlY2tzdW1FcnJvciIsIkludmFsaWRJbnB1dEVycm9yIiwiSW52YWxpZEFkZHJlc3NFcnJvciIsImFzc2VydCIsImNoZWNrc3VtIiwiZnJvbSIsImZyb21QdWJsaWNLZXkiLCJpc0VxdWFsIiwidmFsaWRhdGUiLCJCeXRlcyIsInJlcXVpcmUiLCJDYWNoZXMiLCJFcnJvcnMiLCJIYXNoIiwiUHVibGljS2V5IiwiYWRkcmVzc1JlZ2V4Iiwib3B0aW9ucyIsInN0cmljdCIsInRlc3QiLCJhZGRyZXNzIiwiY2F1c2UiLCJ0b0xvd2VyQ2FzZSIsImhhcyIsImdldCIsImhleEFkZHJlc3MiLCJzdWJzdHJpbmciLCJoYXNoIiwia2VjY2FrMjU2IiwiZnJvbVN0cmluZyIsImFzIiwiY2hhcmFjdGVycyIsInNwbGl0IiwiaSIsInRvVXBwZXJDYXNlIiwicmVzdWx0Iiwiam9pbiIsInNldCIsImNoZWNrc3VtVmFsIiwicHVibGljS2V5IiwidG9IZXgiLCJzbGljZSIsImFkZHJlc3NBIiwiYWRkcmVzc0IiLCJCYXNlRXJyb3IiLCJjb25zdHJ1Y3RvciIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_cjs/core/Address.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_cjs/core/Authorization.js":
/*!****************************************************!*\
  !*** ./node_modules/ox/_cjs/core/Authorization.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.from = from;\nexports.fromRpc = fromRpc;\nexports.fromRpcList = fromRpcList;\nexports.fromTuple = fromTuple;\nexports.fromTupleList = fromTupleList;\nexports.getSignPayload = getSignPayload;\nexports.hash = hash;\nexports.toRpc = toRpc;\nexports.toRpcList = toRpcList;\nexports.toTuple = toTuple;\nexports.toTupleList = toTupleList;\nconst Hash = __webpack_require__(/*! ./Hash.js */ \"(ssr)/./node_modules/ox/_cjs/core/Hash.js\");\nconst Hex = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_cjs/core/Hex.js\");\nconst Rlp = __webpack_require__(/*! ./Rlp.js */ \"(ssr)/./node_modules/ox/_cjs/core/Rlp.js\");\nconst Signature = __webpack_require__(/*! ./Signature.js */ \"(ssr)/./node_modules/ox/_cjs/core/Signature.js\");\nfunction from(authorization, options = {}) {\n    if (typeof authorization.chainId === \"string\") return fromRpc(authorization);\n    return {\n        ...authorization,\n        ...options.signature\n    };\n}\nfunction fromRpc(authorization) {\n    const { address, chainId, nonce } = authorization;\n    const signature = Signature.extract(authorization);\n    return {\n        address,\n        chainId: Number(chainId),\n        nonce: BigInt(nonce),\n        ...signature\n    };\n}\nfunction fromRpcList(authorizationList) {\n    return authorizationList.map(fromRpc);\n}\nfunction fromTuple(tuple) {\n    const [chainId, address, nonce, yParity, r, s] = tuple;\n    let args = {\n        address,\n        chainId: chainId === \"0x\" ? 0 : Number(chainId),\n        nonce: nonce === \"0x\" ? 0n : BigInt(nonce)\n    };\n    if (yParity && r && s) args = {\n        ...args,\n        ...Signature.fromTuple([\n            yParity,\n            r,\n            s\n        ])\n    };\n    return from(args);\n}\nfunction fromTupleList(tupleList) {\n    const list = [];\n    for (const tuple of tupleList)list.push(fromTuple(tuple));\n    return list;\n}\nfunction getSignPayload(authorization) {\n    return hash(authorization, {\n        presign: true\n    });\n}\nfunction hash(authorization, options = {}) {\n    const { presign } = options;\n    return Hash.keccak256(Hex.concat(\"0x05\", Rlp.fromHex(toTuple(presign ? {\n        address: authorization.address,\n        chainId: authorization.chainId,\n        nonce: authorization.nonce\n    } : authorization))));\n}\nfunction toRpc(authorization) {\n    const { address, chainId, nonce, ...signature } = authorization;\n    return {\n        address,\n        chainId: Hex.fromNumber(chainId),\n        nonce: Hex.fromNumber(nonce),\n        ...Signature.toRpc(signature)\n    };\n}\nfunction toRpcList(authorizationList) {\n    return authorizationList.map(toRpc);\n}\nfunction toTuple(authorization) {\n    const { address, chainId, nonce } = authorization;\n    const signature = Signature.extract(authorization);\n    return [\n        chainId ? Hex.fromNumber(chainId) : \"0x\",\n        address,\n        nonce ? Hex.fromNumber(nonce) : \"0x\",\n        ...signature ? Signature.toTuple(signature) : []\n    ];\n}\nfunction toTupleList(list) {\n    if (!list || list.length === 0) return [];\n    const tupleList = [];\n    for (const authorization of list)tupleList.push(toTuple(authorization));\n    return tupleList;\n} //# sourceMappingURL=Authorization.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2Nqcy9jb3JlL0F1dGhvcml6YXRpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELFlBQVksR0FBR0U7QUFDZkYsZUFBZSxHQUFHRztBQUNsQkgsbUJBQW1CLEdBQUdJO0FBQ3RCSixpQkFBaUIsR0FBR0s7QUFDcEJMLHFCQUFxQixHQUFHTTtBQUN4Qk4sc0JBQXNCLEdBQUdPO0FBQ3pCUCxZQUFZLEdBQUdRO0FBQ2ZSLGFBQWEsR0FBR1M7QUFDaEJULGlCQUFpQixHQUFHVTtBQUNwQlYsZUFBZSxHQUFHVztBQUNsQlgsbUJBQW1CLEdBQUdZO0FBQ3RCLE1BQU1DLE9BQU9DLG1CQUFPQSxDQUFDLDREQUFXO0FBQ2hDLE1BQU1DLE1BQU1ELG1CQUFPQSxDQUFDLDBEQUFVO0FBQzlCLE1BQU1FLE1BQU1GLG1CQUFPQSxDQUFDLDBEQUFVO0FBQzlCLE1BQU1HLFlBQVlILG1CQUFPQSxDQUFDLHNFQUFnQjtBQUMxQyxTQUFTWixLQUFLZ0IsYUFBYSxFQUFFQyxVQUFVLENBQUMsQ0FBQztJQUNyQyxJQUFJLE9BQU9ELGNBQWNFLE9BQU8sS0FBSyxVQUNqQyxPQUFPakIsUUFBUWU7SUFDbkIsT0FBTztRQUFFLEdBQUdBLGFBQWE7UUFBRSxHQUFHQyxRQUFRRSxTQUFTO0lBQUM7QUFDcEQ7QUFDQSxTQUFTbEIsUUFBUWUsYUFBYTtJQUMxQixNQUFNLEVBQUVJLE9BQU8sRUFBRUYsT0FBTyxFQUFFRyxLQUFLLEVBQUUsR0FBR0w7SUFDcEMsTUFBTUcsWUFBWUosVUFBVU8sT0FBTyxDQUFDTjtJQUNwQyxPQUFPO1FBQ0hJO1FBQ0FGLFNBQVNLLE9BQU9MO1FBQ2hCRyxPQUFPRyxPQUFPSDtRQUNkLEdBQUdGLFNBQVM7SUFDaEI7QUFDSjtBQUNBLFNBQVNqQixZQUFZdUIsaUJBQWlCO0lBQ2xDLE9BQU9BLGtCQUFrQkMsR0FBRyxDQUFDekI7QUFDakM7QUFDQSxTQUFTRSxVQUFVd0IsS0FBSztJQUNwQixNQUFNLENBQUNULFNBQVNFLFNBQVNDLE9BQU9PLFNBQVNDLEdBQUdDLEVBQUUsR0FBR0g7SUFDakQsSUFBSUksT0FBTztRQUNQWDtRQUNBRixTQUFTQSxZQUFZLE9BQU8sSUFBSUssT0FBT0w7UUFDdkNHLE9BQU9BLFVBQVUsT0FBTyxFQUFFLEdBQUdHLE9BQU9IO0lBQ3hDO0lBQ0EsSUFBSU8sV0FBV0MsS0FBS0MsR0FDaEJDLE9BQU87UUFBRSxHQUFHQSxJQUFJO1FBQUUsR0FBR2hCLFVBQVVaLFNBQVMsQ0FBQztZQUFDeUI7WUFBU0M7WUFBR0M7U0FBRSxDQUFDO0lBQUM7SUFDOUQsT0FBTzlCLEtBQUsrQjtBQUNoQjtBQUNBLFNBQVMzQixjQUFjNEIsU0FBUztJQUM1QixNQUFNQyxPQUFPLEVBQUU7SUFDZixLQUFLLE1BQU1OLFNBQVNLLFVBQ2hCQyxLQUFLQyxJQUFJLENBQUMvQixVQUFVd0I7SUFDeEIsT0FBT007QUFDWDtBQUNBLFNBQVM1QixlQUFlVyxhQUFhO0lBQ2pDLE9BQU9WLEtBQUtVLGVBQWU7UUFBRW1CLFNBQVM7SUFBSztBQUMvQztBQUNBLFNBQVM3QixLQUFLVSxhQUFhLEVBQUVDLFVBQVUsQ0FBQyxDQUFDO0lBQ3JDLE1BQU0sRUFBRWtCLE9BQU8sRUFBRSxHQUFHbEI7SUFDcEIsT0FBT04sS0FBS3lCLFNBQVMsQ0FBQ3ZCLElBQUl3QixNQUFNLENBQUMsUUFBUXZCLElBQUl3QixPQUFPLENBQUM3QixRQUFRMEIsVUFDdkQ7UUFDRWYsU0FBU0osY0FBY0ksT0FBTztRQUM5QkYsU0FBU0YsY0FBY0UsT0FBTztRQUM5QkcsT0FBT0wsY0FBY0ssS0FBSztJQUM5QixJQUNFTDtBQUNWO0FBQ0EsU0FBU1QsTUFBTVMsYUFBYTtJQUN4QixNQUFNLEVBQUVJLE9BQU8sRUFBRUYsT0FBTyxFQUFFRyxLQUFLLEVBQUUsR0FBR0YsV0FBVyxHQUFHSDtJQUNsRCxPQUFPO1FBQ0hJO1FBQ0FGLFNBQVNMLElBQUkwQixVQUFVLENBQUNyQjtRQUN4QkcsT0FBT1IsSUFBSTBCLFVBQVUsQ0FBQ2xCO1FBQ3RCLEdBQUdOLFVBQVVSLEtBQUssQ0FBQ1ksVUFBVTtJQUNqQztBQUNKO0FBQ0EsU0FBU1gsVUFBVWlCLGlCQUFpQjtJQUNoQyxPQUFPQSxrQkFBa0JDLEdBQUcsQ0FBQ25CO0FBQ2pDO0FBQ0EsU0FBU0UsUUFBUU8sYUFBYTtJQUMxQixNQUFNLEVBQUVJLE9BQU8sRUFBRUYsT0FBTyxFQUFFRyxLQUFLLEVBQUUsR0FBR0w7SUFDcEMsTUFBTUcsWUFBWUosVUFBVU8sT0FBTyxDQUFDTjtJQUNwQyxPQUFPO1FBQ0hFLFVBQVVMLElBQUkwQixVQUFVLENBQUNyQixXQUFXO1FBQ3BDRTtRQUNBQyxRQUFRUixJQUFJMEIsVUFBVSxDQUFDbEIsU0FBUztXQUM1QkYsWUFBWUosVUFBVU4sT0FBTyxDQUFDVSxhQUFhLEVBQUU7S0FDcEQ7QUFDTDtBQUNBLFNBQVNULFlBQVl1QixJQUFJO0lBQ3JCLElBQUksQ0FBQ0EsUUFBUUEsS0FBS08sTUFBTSxLQUFLLEdBQ3pCLE9BQU8sRUFBRTtJQUNiLE1BQU1SLFlBQVksRUFBRTtJQUNwQixLQUFLLE1BQU1oQixpQkFBaUJpQixLQUN4QkQsVUFBVUUsSUFBSSxDQUFDekIsUUFBUU87SUFDM0IsT0FBT2dCO0FBQ1gsRUFDQSx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGF3LXdvcmtzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L19janMvY29yZS9BdXRob3JpemF0aW9uLmpzPzE4NDYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZyb20gPSBmcm9tO1xuZXhwb3J0cy5mcm9tUnBjID0gZnJvbVJwYztcbmV4cG9ydHMuZnJvbVJwY0xpc3QgPSBmcm9tUnBjTGlzdDtcbmV4cG9ydHMuZnJvbVR1cGxlID0gZnJvbVR1cGxlO1xuZXhwb3J0cy5mcm9tVHVwbGVMaXN0ID0gZnJvbVR1cGxlTGlzdDtcbmV4cG9ydHMuZ2V0U2lnblBheWxvYWQgPSBnZXRTaWduUGF5bG9hZDtcbmV4cG9ydHMuaGFzaCA9IGhhc2g7XG5leHBvcnRzLnRvUnBjID0gdG9ScGM7XG5leHBvcnRzLnRvUnBjTGlzdCA9IHRvUnBjTGlzdDtcbmV4cG9ydHMudG9UdXBsZSA9IHRvVHVwbGU7XG5leHBvcnRzLnRvVHVwbGVMaXN0ID0gdG9UdXBsZUxpc3Q7XG5jb25zdCBIYXNoID0gcmVxdWlyZShcIi4vSGFzaC5qc1wiKTtcbmNvbnN0IEhleCA9IHJlcXVpcmUoXCIuL0hleC5qc1wiKTtcbmNvbnN0IFJscCA9IHJlcXVpcmUoXCIuL1JscC5qc1wiKTtcbmNvbnN0IFNpZ25hdHVyZSA9IHJlcXVpcmUoXCIuL1NpZ25hdHVyZS5qc1wiKTtcbmZ1bmN0aW9uIGZyb20oYXV0aG9yaXphdGlvbiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKHR5cGVvZiBhdXRob3JpemF0aW9uLmNoYWluSWQgPT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gZnJvbVJwYyhhdXRob3JpemF0aW9uKTtcbiAgICByZXR1cm4geyAuLi5hdXRob3JpemF0aW9uLCAuLi5vcHRpb25zLnNpZ25hdHVyZSB9O1xufVxuZnVuY3Rpb24gZnJvbVJwYyhhdXRob3JpemF0aW9uKSB7XG4gICAgY29uc3QgeyBhZGRyZXNzLCBjaGFpbklkLCBub25jZSB9ID0gYXV0aG9yaXphdGlvbjtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBTaWduYXR1cmUuZXh0cmFjdChhdXRob3JpemF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhZGRyZXNzLFxuICAgICAgICBjaGFpbklkOiBOdW1iZXIoY2hhaW5JZCksXG4gICAgICAgIG5vbmNlOiBCaWdJbnQobm9uY2UpLFxuICAgICAgICAuLi5zaWduYXR1cmUsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZyb21ScGNMaXN0KGF1dGhvcml6YXRpb25MaXN0KSB7XG4gICAgcmV0dXJuIGF1dGhvcml6YXRpb25MaXN0Lm1hcChmcm9tUnBjKTtcbn1cbmZ1bmN0aW9uIGZyb21UdXBsZSh0dXBsZSkge1xuICAgIGNvbnN0IFtjaGFpbklkLCBhZGRyZXNzLCBub25jZSwgeVBhcml0eSwgciwgc10gPSB0dXBsZTtcbiAgICBsZXQgYXJncyA9IHtcbiAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgY2hhaW5JZDogY2hhaW5JZCA9PT0gJzB4JyA/IDAgOiBOdW1iZXIoY2hhaW5JZCksXG4gICAgICAgIG5vbmNlOiBub25jZSA9PT0gJzB4JyA/IDBuIDogQmlnSW50KG5vbmNlKSxcbiAgICB9O1xuICAgIGlmICh5UGFyaXR5ICYmIHIgJiYgcylcbiAgICAgICAgYXJncyA9IHsgLi4uYXJncywgLi4uU2lnbmF0dXJlLmZyb21UdXBsZShbeVBhcml0eSwgciwgc10pIH07XG4gICAgcmV0dXJuIGZyb20oYXJncyk7XG59XG5mdW5jdGlvbiBmcm9tVHVwbGVMaXN0KHR1cGxlTGlzdCkge1xuICAgIGNvbnN0IGxpc3QgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHR1cGxlIG9mIHR1cGxlTGlzdClcbiAgICAgICAgbGlzdC5wdXNoKGZyb21UdXBsZSh0dXBsZSkpO1xuICAgIHJldHVybiBsaXN0O1xufVxuZnVuY3Rpb24gZ2V0U2lnblBheWxvYWQoYXV0aG9yaXphdGlvbikge1xuICAgIHJldHVybiBoYXNoKGF1dGhvcml6YXRpb24sIHsgcHJlc2lnbjogdHJ1ZSB9KTtcbn1cbmZ1bmN0aW9uIGhhc2goYXV0aG9yaXphdGlvbiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBwcmVzaWduIH0gPSBvcHRpb25zO1xuICAgIHJldHVybiBIYXNoLmtlY2NhazI1NihIZXguY29uY2F0KCcweDA1JywgUmxwLmZyb21IZXgodG9UdXBsZShwcmVzaWduXG4gICAgICAgID8ge1xuICAgICAgICAgICAgYWRkcmVzczogYXV0aG9yaXphdGlvbi5hZGRyZXNzLFxuICAgICAgICAgICAgY2hhaW5JZDogYXV0aG9yaXphdGlvbi5jaGFpbklkLFxuICAgICAgICAgICAgbm9uY2U6IGF1dGhvcml6YXRpb24ubm9uY2UsXG4gICAgICAgIH1cbiAgICAgICAgOiBhdXRob3JpemF0aW9uKSkpKTtcbn1cbmZ1bmN0aW9uIHRvUnBjKGF1dGhvcml6YXRpb24pIHtcbiAgICBjb25zdCB7IGFkZHJlc3MsIGNoYWluSWQsIG5vbmNlLCAuLi5zaWduYXR1cmUgfSA9IGF1dGhvcml6YXRpb247XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgY2hhaW5JZDogSGV4LmZyb21OdW1iZXIoY2hhaW5JZCksXG4gICAgICAgIG5vbmNlOiBIZXguZnJvbU51bWJlcihub25jZSksXG4gICAgICAgIC4uLlNpZ25hdHVyZS50b1JwYyhzaWduYXR1cmUpLFxuICAgIH07XG59XG5mdW5jdGlvbiB0b1JwY0xpc3QoYXV0aG9yaXphdGlvbkxpc3QpIHtcbiAgICByZXR1cm4gYXV0aG9yaXphdGlvbkxpc3QubWFwKHRvUnBjKTtcbn1cbmZ1bmN0aW9uIHRvVHVwbGUoYXV0aG9yaXphdGlvbikge1xuICAgIGNvbnN0IHsgYWRkcmVzcywgY2hhaW5JZCwgbm9uY2UgfSA9IGF1dGhvcml6YXRpb247XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gU2lnbmF0dXJlLmV4dHJhY3QoYXV0aG9yaXphdGlvbik7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgY2hhaW5JZCA/IEhleC5mcm9tTnVtYmVyKGNoYWluSWQpIDogJzB4JyxcbiAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgbm9uY2UgPyBIZXguZnJvbU51bWJlcihub25jZSkgOiAnMHgnLFxuICAgICAgICAuLi4oc2lnbmF0dXJlID8gU2lnbmF0dXJlLnRvVHVwbGUoc2lnbmF0dXJlKSA6IFtdKSxcbiAgICBdO1xufVxuZnVuY3Rpb24gdG9UdXBsZUxpc3QobGlzdCkge1xuICAgIGlmICghbGlzdCB8fCBsaXN0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIGNvbnN0IHR1cGxlTGlzdCA9IFtdO1xuICAgIGZvciAoY29uc3QgYXV0aG9yaXphdGlvbiBvZiBsaXN0KVxuICAgICAgICB0dXBsZUxpc3QucHVzaCh0b1R1cGxlKGF1dGhvcml6YXRpb24pKTtcbiAgICByZXR1cm4gdHVwbGVMaXN0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXV0aG9yaXphdGlvbi5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJmcm9tIiwiZnJvbVJwYyIsImZyb21ScGNMaXN0IiwiZnJvbVR1cGxlIiwiZnJvbVR1cGxlTGlzdCIsImdldFNpZ25QYXlsb2FkIiwiaGFzaCIsInRvUnBjIiwidG9ScGNMaXN0IiwidG9UdXBsZSIsInRvVHVwbGVMaXN0IiwiSGFzaCIsInJlcXVpcmUiLCJIZXgiLCJSbHAiLCJTaWduYXR1cmUiLCJhdXRob3JpemF0aW9uIiwib3B0aW9ucyIsImNoYWluSWQiLCJzaWduYXR1cmUiLCJhZGRyZXNzIiwibm9uY2UiLCJleHRyYWN0IiwiTnVtYmVyIiwiQmlnSW50IiwiYXV0aG9yaXphdGlvbkxpc3QiLCJtYXAiLCJ0dXBsZSIsInlQYXJpdHkiLCJyIiwicyIsImFyZ3MiLCJ0dXBsZUxpc3QiLCJsaXN0IiwicHVzaCIsInByZXNpZ24iLCJrZWNjYWsyNTYiLCJjb25jYXQiLCJmcm9tSGV4IiwiZnJvbU51bWJlciIsImxlbmd0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_cjs/core/Authorization.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_cjs/core/BlockOverrides.js":
/*!*****************************************************!*\
  !*** ./node_modules/ox/_cjs/core/BlockOverrides.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.fromRpc = fromRpc;\nexports.toRpc = toRpc;\nconst Hex = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_cjs/core/Hex.js\");\nconst Withdrawal = __webpack_require__(/*! ./Withdrawal.js */ \"(ssr)/./node_modules/ox/_cjs/core/Withdrawal.js\");\nfunction fromRpc(rpcBlockOverrides) {\n    return {\n        ...rpcBlockOverrides.baseFeePerGas && {\n            baseFeePerGas: BigInt(rpcBlockOverrides.baseFeePerGas)\n        },\n        ...rpcBlockOverrides.blobBaseFee && {\n            blobBaseFee: BigInt(rpcBlockOverrides.blobBaseFee)\n        },\n        ...rpcBlockOverrides.feeRecipient && {\n            feeRecipient: rpcBlockOverrides.feeRecipient\n        },\n        ...rpcBlockOverrides.gasLimit && {\n            gasLimit: BigInt(rpcBlockOverrides.gasLimit)\n        },\n        ...rpcBlockOverrides.number && {\n            number: BigInt(rpcBlockOverrides.number)\n        },\n        ...rpcBlockOverrides.prevRandao && {\n            prevRandao: BigInt(rpcBlockOverrides.prevRandao)\n        },\n        ...rpcBlockOverrides.time && {\n            time: BigInt(rpcBlockOverrides.time)\n        },\n        ...rpcBlockOverrides.withdrawals && {\n            withdrawals: rpcBlockOverrides.withdrawals.map(Withdrawal.fromRpc)\n        }\n    };\n}\nfunction toRpc(blockOverrides) {\n    return {\n        ...typeof blockOverrides.baseFeePerGas === \"bigint\" && {\n            baseFeePerGas: Hex.fromNumber(blockOverrides.baseFeePerGas)\n        },\n        ...typeof blockOverrides.blobBaseFee === \"bigint\" && {\n            blobBaseFee: Hex.fromNumber(blockOverrides.blobBaseFee)\n        },\n        ...typeof blockOverrides.feeRecipient === \"string\" && {\n            feeRecipient: blockOverrides.feeRecipient\n        },\n        ...typeof blockOverrides.gasLimit === \"bigint\" && {\n            gasLimit: Hex.fromNumber(blockOverrides.gasLimit)\n        },\n        ...typeof blockOverrides.number === \"bigint\" && {\n            number: Hex.fromNumber(blockOverrides.number)\n        },\n        ...typeof blockOverrides.prevRandao === \"bigint\" && {\n            prevRandao: Hex.fromNumber(blockOverrides.prevRandao)\n        },\n        ...typeof blockOverrides.time === \"bigint\" && {\n            time: Hex.fromNumber(blockOverrides.time)\n        },\n        ...blockOverrides.withdrawals && {\n            withdrawals: blockOverrides.withdrawals.map(Withdrawal.toRpc)\n        }\n    };\n} //# sourceMappingURL=BlockOverrides.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2Nqcy9jb3JlL0Jsb2NrT3ZlcnJpZGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxlQUFlLEdBQUdFO0FBQ2xCRixhQUFhLEdBQUdHO0FBQ2hCLE1BQU1DLE1BQU1DLG1CQUFPQSxDQUFDLDBEQUFVO0FBQzlCLE1BQU1DLGFBQWFELG1CQUFPQSxDQUFDLHdFQUFpQjtBQUM1QyxTQUFTSCxRQUFRSyxpQkFBaUI7SUFDOUIsT0FBTztRQUNILEdBQUlBLGtCQUFrQkMsYUFBYSxJQUFJO1lBQ25DQSxlQUFlQyxPQUFPRixrQkFBa0JDLGFBQWE7UUFDekQsQ0FBQztRQUNELEdBQUlELGtCQUFrQkcsV0FBVyxJQUFJO1lBQ2pDQSxhQUFhRCxPQUFPRixrQkFBa0JHLFdBQVc7UUFDckQsQ0FBQztRQUNELEdBQUlILGtCQUFrQkksWUFBWSxJQUFJO1lBQ2xDQSxjQUFjSixrQkFBa0JJLFlBQVk7UUFDaEQsQ0FBQztRQUNELEdBQUlKLGtCQUFrQkssUUFBUSxJQUFJO1lBQzlCQSxVQUFVSCxPQUFPRixrQkFBa0JLLFFBQVE7UUFDL0MsQ0FBQztRQUNELEdBQUlMLGtCQUFrQk0sTUFBTSxJQUFJO1lBQzVCQSxRQUFRSixPQUFPRixrQkFBa0JNLE1BQU07UUFDM0MsQ0FBQztRQUNELEdBQUlOLGtCQUFrQk8sVUFBVSxJQUFJO1lBQ2hDQSxZQUFZTCxPQUFPRixrQkFBa0JPLFVBQVU7UUFDbkQsQ0FBQztRQUNELEdBQUlQLGtCQUFrQlEsSUFBSSxJQUFJO1lBQzFCQSxNQUFNTixPQUFPRixrQkFBa0JRLElBQUk7UUFDdkMsQ0FBQztRQUNELEdBQUlSLGtCQUFrQlMsV0FBVyxJQUFJO1lBQ2pDQSxhQUFhVCxrQkFBa0JTLFdBQVcsQ0FBQ0MsR0FBRyxDQUFDWCxXQUFXSixPQUFPO1FBQ3JFLENBQUM7SUFDTDtBQUNKO0FBQ0EsU0FBU0MsTUFBTWUsY0FBYztJQUN6QixPQUFPO1FBQ0gsR0FBSSxPQUFPQSxlQUFlVixhQUFhLEtBQUssWUFBWTtZQUNwREEsZUFBZUosSUFBSWUsVUFBVSxDQUFDRCxlQUFlVixhQUFhO1FBQzlELENBQUM7UUFDRCxHQUFJLE9BQU9VLGVBQWVSLFdBQVcsS0FBSyxZQUFZO1lBQ2xEQSxhQUFhTixJQUFJZSxVQUFVLENBQUNELGVBQWVSLFdBQVc7UUFDMUQsQ0FBQztRQUNELEdBQUksT0FBT1EsZUFBZVAsWUFBWSxLQUFLLFlBQVk7WUFDbkRBLGNBQWNPLGVBQWVQLFlBQVk7UUFDN0MsQ0FBQztRQUNELEdBQUksT0FBT08sZUFBZU4sUUFBUSxLQUFLLFlBQVk7WUFDL0NBLFVBQVVSLElBQUllLFVBQVUsQ0FBQ0QsZUFBZU4sUUFBUTtRQUNwRCxDQUFDO1FBQ0QsR0FBSSxPQUFPTSxlQUFlTCxNQUFNLEtBQUssWUFBWTtZQUM3Q0EsUUFBUVQsSUFBSWUsVUFBVSxDQUFDRCxlQUFlTCxNQUFNO1FBQ2hELENBQUM7UUFDRCxHQUFJLE9BQU9LLGVBQWVKLFVBQVUsS0FBSyxZQUFZO1lBQ2pEQSxZQUFZVixJQUFJZSxVQUFVLENBQUNELGVBQWVKLFVBQVU7UUFDeEQsQ0FBQztRQUNELEdBQUksT0FBT0ksZUFBZUgsSUFBSSxLQUFLLFlBQVk7WUFDM0NBLE1BQU1YLElBQUllLFVBQVUsQ0FBQ0QsZUFBZUgsSUFBSTtRQUM1QyxDQUFDO1FBQ0QsR0FBSUcsZUFBZUYsV0FBVyxJQUFJO1lBQzlCQSxhQUFhRSxlQUFlRixXQUFXLENBQUNDLEdBQUcsQ0FBQ1gsV0FBV0gsS0FBSztRQUNoRSxDQUFDO0lBQ0w7QUFDSixFQUNBLDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsYXctd29ya3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3gvX2Nqcy9jb3JlL0Jsb2NrT3ZlcnJpZGVzLmpzPzI0MGQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZyb21ScGMgPSBmcm9tUnBjO1xuZXhwb3J0cy50b1JwYyA9IHRvUnBjO1xuY29uc3QgSGV4ID0gcmVxdWlyZShcIi4vSGV4LmpzXCIpO1xuY29uc3QgV2l0aGRyYXdhbCA9IHJlcXVpcmUoXCIuL1dpdGhkcmF3YWwuanNcIik7XG5mdW5jdGlvbiBmcm9tUnBjKHJwY0Jsb2NrT3ZlcnJpZGVzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uKHJwY0Jsb2NrT3ZlcnJpZGVzLmJhc2VGZWVQZXJHYXMgJiYge1xuICAgICAgICAgICAgYmFzZUZlZVBlckdhczogQmlnSW50KHJwY0Jsb2NrT3ZlcnJpZGVzLmJhc2VGZWVQZXJHYXMpLFxuICAgICAgICB9KSxcbiAgICAgICAgLi4uKHJwY0Jsb2NrT3ZlcnJpZGVzLmJsb2JCYXNlRmVlICYmIHtcbiAgICAgICAgICAgIGJsb2JCYXNlRmVlOiBCaWdJbnQocnBjQmxvY2tPdmVycmlkZXMuYmxvYkJhc2VGZWUpLFxuICAgICAgICB9KSxcbiAgICAgICAgLi4uKHJwY0Jsb2NrT3ZlcnJpZGVzLmZlZVJlY2lwaWVudCAmJiB7XG4gICAgICAgICAgICBmZWVSZWNpcGllbnQ6IHJwY0Jsb2NrT3ZlcnJpZGVzLmZlZVJlY2lwaWVudCxcbiAgICAgICAgfSksXG4gICAgICAgIC4uLihycGNCbG9ja092ZXJyaWRlcy5nYXNMaW1pdCAmJiB7XG4gICAgICAgICAgICBnYXNMaW1pdDogQmlnSW50KHJwY0Jsb2NrT3ZlcnJpZGVzLmdhc0xpbWl0KSxcbiAgICAgICAgfSksXG4gICAgICAgIC4uLihycGNCbG9ja092ZXJyaWRlcy5udW1iZXIgJiYge1xuICAgICAgICAgICAgbnVtYmVyOiBCaWdJbnQocnBjQmxvY2tPdmVycmlkZXMubnVtYmVyKSxcbiAgICAgICAgfSksXG4gICAgICAgIC4uLihycGNCbG9ja092ZXJyaWRlcy5wcmV2UmFuZGFvICYmIHtcbiAgICAgICAgICAgIHByZXZSYW5kYW86IEJpZ0ludChycGNCbG9ja092ZXJyaWRlcy5wcmV2UmFuZGFvKSxcbiAgICAgICAgfSksXG4gICAgICAgIC4uLihycGNCbG9ja092ZXJyaWRlcy50aW1lICYmIHtcbiAgICAgICAgICAgIHRpbWU6IEJpZ0ludChycGNCbG9ja092ZXJyaWRlcy50aW1lKSxcbiAgICAgICAgfSksXG4gICAgICAgIC4uLihycGNCbG9ja092ZXJyaWRlcy53aXRoZHJhd2FscyAmJiB7XG4gICAgICAgICAgICB3aXRoZHJhd2FsczogcnBjQmxvY2tPdmVycmlkZXMud2l0aGRyYXdhbHMubWFwKFdpdGhkcmF3YWwuZnJvbVJwYyksXG4gICAgICAgIH0pLFxuICAgIH07XG59XG5mdW5jdGlvbiB0b1JwYyhibG9ja092ZXJyaWRlcykge1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLih0eXBlb2YgYmxvY2tPdmVycmlkZXMuYmFzZUZlZVBlckdhcyA9PT0gJ2JpZ2ludCcgJiYge1xuICAgICAgICAgICAgYmFzZUZlZVBlckdhczogSGV4LmZyb21OdW1iZXIoYmxvY2tPdmVycmlkZXMuYmFzZUZlZVBlckdhcyksXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4odHlwZW9mIGJsb2NrT3ZlcnJpZGVzLmJsb2JCYXNlRmVlID09PSAnYmlnaW50JyAmJiB7XG4gICAgICAgICAgICBibG9iQmFzZUZlZTogSGV4LmZyb21OdW1iZXIoYmxvY2tPdmVycmlkZXMuYmxvYkJhc2VGZWUpLFxuICAgICAgICB9KSxcbiAgICAgICAgLi4uKHR5cGVvZiBibG9ja092ZXJyaWRlcy5mZWVSZWNpcGllbnQgPT09ICdzdHJpbmcnICYmIHtcbiAgICAgICAgICAgIGZlZVJlY2lwaWVudDogYmxvY2tPdmVycmlkZXMuZmVlUmVjaXBpZW50LFxuICAgICAgICB9KSxcbiAgICAgICAgLi4uKHR5cGVvZiBibG9ja092ZXJyaWRlcy5nYXNMaW1pdCA9PT0gJ2JpZ2ludCcgJiYge1xuICAgICAgICAgICAgZ2FzTGltaXQ6IEhleC5mcm9tTnVtYmVyKGJsb2NrT3ZlcnJpZGVzLmdhc0xpbWl0KSxcbiAgICAgICAgfSksXG4gICAgICAgIC4uLih0eXBlb2YgYmxvY2tPdmVycmlkZXMubnVtYmVyID09PSAnYmlnaW50JyAmJiB7XG4gICAgICAgICAgICBudW1iZXI6IEhleC5mcm9tTnVtYmVyKGJsb2NrT3ZlcnJpZGVzLm51bWJlciksXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4odHlwZW9mIGJsb2NrT3ZlcnJpZGVzLnByZXZSYW5kYW8gPT09ICdiaWdpbnQnICYmIHtcbiAgICAgICAgICAgIHByZXZSYW5kYW86IEhleC5mcm9tTnVtYmVyKGJsb2NrT3ZlcnJpZGVzLnByZXZSYW5kYW8pLFxuICAgICAgICB9KSxcbiAgICAgICAgLi4uKHR5cGVvZiBibG9ja092ZXJyaWRlcy50aW1lID09PSAnYmlnaW50JyAmJiB7XG4gICAgICAgICAgICB0aW1lOiBIZXguZnJvbU51bWJlcihibG9ja092ZXJyaWRlcy50aW1lKSxcbiAgICAgICAgfSksXG4gICAgICAgIC4uLihibG9ja092ZXJyaWRlcy53aXRoZHJhd2FscyAmJiB7XG4gICAgICAgICAgICB3aXRoZHJhd2FsczogYmxvY2tPdmVycmlkZXMud2l0aGRyYXdhbHMubWFwKFdpdGhkcmF3YWwudG9ScGMpLFxuICAgICAgICB9KSxcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmxvY2tPdmVycmlkZXMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZnJvbVJwYyIsInRvUnBjIiwiSGV4IiwicmVxdWlyZSIsIldpdGhkcmF3YWwiLCJycGNCbG9ja092ZXJyaWRlcyIsImJhc2VGZWVQZXJHYXMiLCJCaWdJbnQiLCJibG9iQmFzZUZlZSIsImZlZVJlY2lwaWVudCIsImdhc0xpbWl0IiwibnVtYmVyIiwicHJldlJhbmRhbyIsInRpbWUiLCJ3aXRoZHJhd2FscyIsIm1hcCIsImJsb2NrT3ZlcnJpZGVzIiwiZnJvbU51bWJlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_cjs/core/BlockOverrides.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_cjs/core/Bytes.js":
/*!********************************************!*\
  !*** ./node_modules/ox/_cjs/core/Bytes.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.SizeExceedsPaddingSizeError = exports.SliceOffsetOutOfBoundsError = exports.SizeOverflowError = exports.InvalidBytesTypeError = exports.InvalidBytesBooleanError = void 0;\nexports.assert = assert;\nexports.concat = concat;\nexports.from = from;\nexports.fromArray = fromArray;\nexports.fromBoolean = fromBoolean;\nexports.fromHex = fromHex;\nexports.fromNumber = fromNumber;\nexports.fromString = fromString;\nexports.isEqual = isEqual;\nexports.padLeft = padLeft;\nexports.padRight = padRight;\nexports.random = random;\nexports.size = size;\nexports.slice = slice;\nexports.toBigInt = toBigInt;\nexports.toBoolean = toBoolean;\nexports.toHex = toHex;\nexports.toNumber = toNumber;\nexports.toString = toString;\nexports.trimLeft = trimLeft;\nexports.trimRight = trimRight;\nexports.validate = validate;\nconst utils_1 = __webpack_require__(/*! @noble/curves/abstract/utils */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/abstract/utils.js\");\nconst Errors = __webpack_require__(/*! ./Errors.js */ \"(ssr)/./node_modules/ox/_cjs/core/Errors.js\");\nconst Hex = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_cjs/core/Hex.js\");\nconst internal = __webpack_require__(/*! ./internal/bytes.js */ \"(ssr)/./node_modules/ox/_cjs/core/internal/bytes.js\");\nconst internal_hex = __webpack_require__(/*! ./internal/hex.js */ \"(ssr)/./node_modules/ox/_cjs/core/internal/hex.js\");\nconst Json = __webpack_require__(/*! ./Json.js */ \"(ssr)/./node_modules/ox/_cjs/core/Json.js\");\nconst decoder = new TextDecoder();\nconst encoder = new TextEncoder();\nfunction assert(value) {\n    if (value instanceof Uint8Array) return;\n    if (!value) throw new InvalidBytesTypeError(value);\n    if (typeof value !== \"object\") throw new InvalidBytesTypeError(value);\n    if (!(\"BYTES_PER_ELEMENT\" in value)) throw new InvalidBytesTypeError(value);\n    if (value.BYTES_PER_ELEMENT !== 1 || value.constructor.name !== \"Uint8Array\") throw new InvalidBytesTypeError(value);\n}\nfunction concat(...values) {\n    let length = 0;\n    for (const arr of values){\n        length += arr.length;\n    }\n    const result = new Uint8Array(length);\n    for(let i = 0, index = 0; i < values.length; i++){\n        const arr = values[i];\n        result.set(arr, index);\n        index += arr.length;\n    }\n    return result;\n}\nfunction from(value) {\n    if (value instanceof Uint8Array) return value;\n    if (typeof value === \"string\") return fromHex(value);\n    return fromArray(value);\n}\nfunction fromArray(value) {\n    return value instanceof Uint8Array ? value : new Uint8Array(value);\n}\nfunction fromBoolean(value, options = {}) {\n    const { size } = options;\n    const bytes = new Uint8Array(1);\n    bytes[0] = Number(value);\n    if (typeof size === \"number\") {\n        internal.assertSize(bytes, size);\n        return padLeft(bytes, size);\n    }\n    return bytes;\n}\nfunction fromHex(value, options = {}) {\n    const { size } = options;\n    let hex = value;\n    if (size) {\n        internal_hex.assertSize(value, size);\n        hex = Hex.padRight(value, size);\n    }\n    let hexString = hex.slice(2);\n    if (hexString.length % 2) hexString = `0${hexString}`;\n    const length = hexString.length / 2;\n    const bytes = new Uint8Array(length);\n    for(let index = 0, j = 0; index < length; index++){\n        const nibbleLeft = internal.charCodeToBase16(hexString.charCodeAt(j++));\n        const nibbleRight = internal.charCodeToBase16(hexString.charCodeAt(j++));\n        if (nibbleLeft === undefined || nibbleRight === undefined) {\n            throw new Errors.BaseError(`Invalid byte sequence (\"${hexString[j - 2]}${hexString[j - 1]}\" in \"${hexString}\").`);\n        }\n        bytes[index] = nibbleLeft << 4 | nibbleRight;\n    }\n    return bytes;\n}\nfunction fromNumber(value, options) {\n    const hex = Hex.fromNumber(value, options);\n    return fromHex(hex);\n}\nfunction fromString(value, options = {}) {\n    const { size } = options;\n    const bytes = encoder.encode(value);\n    if (typeof size === \"number\") {\n        internal.assertSize(bytes, size);\n        return padRight(bytes, size);\n    }\n    return bytes;\n}\nfunction isEqual(bytesA, bytesB) {\n    return (0, utils_1.equalBytes)(bytesA, bytesB);\n}\nfunction padLeft(value, size) {\n    return internal.pad(value, {\n        dir: \"left\",\n        size\n    });\n}\nfunction padRight(value, size) {\n    return internal.pad(value, {\n        dir: \"right\",\n        size\n    });\n}\nfunction random(length) {\n    return crypto.getRandomValues(new Uint8Array(length));\n}\nfunction size(value) {\n    return value.length;\n}\nfunction slice(value, start, end, options = {}) {\n    const { strict } = options;\n    internal.assertStartOffset(value, start);\n    const value_ = value.slice(start, end);\n    if (strict) internal.assertEndOffset(value_, start, end);\n    return value_;\n}\nfunction toBigInt(bytes, options = {}) {\n    const { size } = options;\n    if (typeof size !== \"undefined\") internal.assertSize(bytes, size);\n    const hex = Hex.fromBytes(bytes, options);\n    return Hex.toBigInt(hex, options);\n}\nfunction toBoolean(bytes, options = {}) {\n    const { size } = options;\n    let bytes_ = bytes;\n    if (typeof size !== \"undefined\") {\n        internal.assertSize(bytes_, size);\n        bytes_ = trimLeft(bytes_);\n    }\n    if (bytes_.length > 1 || bytes_[0] > 1) throw new InvalidBytesBooleanError(bytes_);\n    return Boolean(bytes_[0]);\n}\nfunction toHex(value, options = {}) {\n    return Hex.fromBytes(value, options);\n}\nfunction toNumber(bytes, options = {}) {\n    const { size } = options;\n    if (typeof size !== \"undefined\") internal.assertSize(bytes, size);\n    const hex = Hex.fromBytes(bytes, options);\n    return Hex.toNumber(hex, options);\n}\nfunction toString(bytes, options = {}) {\n    const { size } = options;\n    let bytes_ = bytes;\n    if (typeof size !== \"undefined\") {\n        internal.assertSize(bytes_, size);\n        bytes_ = trimRight(bytes_);\n    }\n    return decoder.decode(bytes_);\n}\nfunction trimLeft(value) {\n    return internal.trim(value, {\n        dir: \"left\"\n    });\n}\nfunction trimRight(value) {\n    return internal.trim(value, {\n        dir: \"right\"\n    });\n}\nfunction validate(value) {\n    try {\n        assert(value);\n        return true;\n    } catch  {\n        return false;\n    }\n}\nclass InvalidBytesBooleanError extends Errors.BaseError {\n    constructor(bytes){\n        super(`Bytes value \\`${bytes}\\` is not a valid boolean.`, {\n            metaMessages: [\n                \"The bytes array must contain a single byte of either a `0` or `1` value.\"\n            ]\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Bytes.InvalidBytesBooleanError\"\n        });\n    }\n}\nexports.InvalidBytesBooleanError = InvalidBytesBooleanError;\nclass InvalidBytesTypeError extends Errors.BaseError {\n    constructor(value){\n        super(`Value \\`${typeof value === \"object\" ? Json.stringify(value) : value}\\` of type \\`${typeof value}\\` is an invalid Bytes value.`, {\n            metaMessages: [\n                \"Bytes values must be of type `Bytes`.\"\n            ]\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Bytes.InvalidBytesTypeError\"\n        });\n    }\n}\nexports.InvalidBytesTypeError = InvalidBytesTypeError;\nclass SizeOverflowError extends Errors.BaseError {\n    constructor({ givenSize, maxSize }){\n        super(`Size cannot exceed \\`${maxSize}\\` bytes. Given size: \\`${givenSize}\\` bytes.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Bytes.SizeOverflowError\"\n        });\n    }\n}\nexports.SizeOverflowError = SizeOverflowError;\nclass SliceOffsetOutOfBoundsError extends Errors.BaseError {\n    constructor({ offset, position, size }){\n        super(`Slice ${position === \"start\" ? \"starting\" : \"ending\"} at offset \\`${offset}\\` is out-of-bounds (size: \\`${size}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Bytes.SliceOffsetOutOfBoundsError\"\n        });\n    }\n}\nexports.SliceOffsetOutOfBoundsError = SliceOffsetOutOfBoundsError;\nclass SizeExceedsPaddingSizeError extends Errors.BaseError {\n    constructor({ size, targetSize, type }){\n        super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (\\`${size}\\`) exceeds padding size (\\`${targetSize}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Bytes.SizeExceedsPaddingSizeError\"\n        });\n    }\n}\nexports.SizeExceedsPaddingSizeError = SizeExceedsPaddingSizeError; //# sourceMappingURL=Bytes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2Nqcy9jb3JlL0J5dGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxtQ0FBbUMsR0FBR0EsbUNBQW1DLEdBQUdBLHlCQUF5QixHQUFHQSw2QkFBNkIsR0FBR0EsZ0NBQWdDLEdBQUcsS0FBSztBQUNoTEEsY0FBYyxHQUFHTztBQUNqQlAsY0FBYyxHQUFHUTtBQUNqQlIsWUFBWSxHQUFHUztBQUNmVCxpQkFBaUIsR0FBR1U7QUFDcEJWLG1CQUFtQixHQUFHVztBQUN0QlgsZUFBZSxHQUFHWTtBQUNsQlosa0JBQWtCLEdBQUdhO0FBQ3JCYixrQkFBa0IsR0FBR2M7QUFDckJkLGVBQWUsR0FBR2U7QUFDbEJmLGVBQWUsR0FBR2dCO0FBQ2xCaEIsZ0JBQWdCLEdBQUdpQjtBQUNuQmpCLGNBQWMsR0FBR2tCO0FBQ2pCbEIsWUFBWSxHQUFHbUI7QUFDZm5CLGFBQWEsR0FBR29CO0FBQ2hCcEIsZ0JBQWdCLEdBQUdxQjtBQUNuQnJCLGlCQUFpQixHQUFHc0I7QUFDcEJ0QixhQUFhLEdBQUd1QjtBQUNoQnZCLGdCQUFnQixHQUFHd0I7QUFDbkJ4QixnQkFBZ0IsR0FBR3lCO0FBQ25CekIsZ0JBQWdCLEdBQUcwQjtBQUNuQjFCLGlCQUFpQixHQUFHMkI7QUFDcEIzQixnQkFBZ0IsR0FBRzRCO0FBQ25CLE1BQU1DLFVBQVVDLG1CQUFPQSxDQUFDLDBHQUE4QjtBQUN0RCxNQUFNQyxTQUFTRCxtQkFBT0EsQ0FBQyxnRUFBYTtBQUNwQyxNQUFNRSxNQUFNRixtQkFBT0EsQ0FBQywwREFBVTtBQUM5QixNQUFNRyxXQUFXSCxtQkFBT0EsQ0FBQyxnRkFBcUI7QUFDOUMsTUFBTUksZUFBZUosbUJBQU9BLENBQUMsNEVBQW1CO0FBQ2hELE1BQU1LLE9BQU9MLG1CQUFPQSxDQUFDLDREQUFXO0FBQ2hDLE1BQU1NLFVBQVUsSUFBSUM7QUFDcEIsTUFBTUMsVUFBVSxJQUFJQztBQUNwQixTQUFTaEMsT0FBT04sS0FBSztJQUNqQixJQUFJQSxpQkFBaUJ1QyxZQUNqQjtJQUNKLElBQUksQ0FBQ3ZDLE9BQ0QsTUFBTSxJQUFJSSxzQkFBc0JKO0lBQ3BDLElBQUksT0FBT0EsVUFBVSxVQUNqQixNQUFNLElBQUlJLHNCQUFzQko7SUFDcEMsSUFBSSxDQUFFLHdCQUF1QkEsS0FBSSxHQUM3QixNQUFNLElBQUlJLHNCQUFzQko7SUFDcEMsSUFBSUEsTUFBTXdDLGlCQUFpQixLQUFLLEtBQUt4QyxNQUFNeUMsV0FBVyxDQUFDQyxJQUFJLEtBQUssY0FDNUQsTUFBTSxJQUFJdEMsc0JBQXNCSjtBQUN4QztBQUNBLFNBQVNPLE9BQU8sR0FBR29DLE1BQU07SUFDckIsSUFBSUMsU0FBUztJQUNiLEtBQUssTUFBTUMsT0FBT0YsT0FBUTtRQUN0QkMsVUFBVUMsSUFBSUQsTUFBTTtJQUN4QjtJQUNBLE1BQU1FLFNBQVMsSUFBSVAsV0FBV0s7SUFDOUIsSUFBSyxJQUFJRyxJQUFJLEdBQUdDLFFBQVEsR0FBR0QsSUFBSUosT0FBT0MsTUFBTSxFQUFFRyxJQUFLO1FBQy9DLE1BQU1GLE1BQU1GLE1BQU0sQ0FBQ0ksRUFBRTtRQUNyQkQsT0FBT0csR0FBRyxDQUFDSixLQUFLRztRQUNoQkEsU0FBU0gsSUFBSUQsTUFBTTtJQUN2QjtJQUNBLE9BQU9FO0FBQ1g7QUFDQSxTQUFTdEMsS0FBS1IsS0FBSztJQUNmLElBQUlBLGlCQUFpQnVDLFlBQ2pCLE9BQU92QztJQUNYLElBQUksT0FBT0EsVUFBVSxVQUNqQixPQUFPVyxRQUFRWDtJQUNuQixPQUFPUyxVQUFVVDtBQUNyQjtBQUNBLFNBQVNTLFVBQVVULEtBQUs7SUFDcEIsT0FBT0EsaUJBQWlCdUMsYUFBYXZDLFFBQVEsSUFBSXVDLFdBQVd2QztBQUNoRTtBQUNBLFNBQVNVLFlBQVlWLEtBQUssRUFBRWtELFVBQVUsQ0FBQyxDQUFDO0lBQ3BDLE1BQU0sRUFBRWhDLElBQUksRUFBRSxHQUFHZ0M7SUFDakIsTUFBTUMsUUFBUSxJQUFJWixXQUFXO0lBQzdCWSxLQUFLLENBQUMsRUFBRSxHQUFHQyxPQUFPcEQ7SUFDbEIsSUFBSSxPQUFPa0IsU0FBUyxVQUFVO1FBQzFCYyxTQUFTcUIsVUFBVSxDQUFDRixPQUFPakM7UUFDM0IsT0FBT0gsUUFBUW9DLE9BQU9qQztJQUMxQjtJQUNBLE9BQU9pQztBQUNYO0FBQ0EsU0FBU3hDLFFBQVFYLEtBQUssRUFBRWtELFVBQVUsQ0FBQyxDQUFDO0lBQ2hDLE1BQU0sRUFBRWhDLElBQUksRUFBRSxHQUFHZ0M7SUFDakIsSUFBSUksTUFBTXREO0lBQ1YsSUFBSWtCLE1BQU07UUFDTmUsYUFBYW9CLFVBQVUsQ0FBQ3JELE9BQU9rQjtRQUMvQm9DLE1BQU12QixJQUFJZixRQUFRLENBQUNoQixPQUFPa0I7SUFDOUI7SUFDQSxJQUFJcUMsWUFBWUQsSUFBSW5DLEtBQUssQ0FBQztJQUMxQixJQUFJb0MsVUFBVVgsTUFBTSxHQUFHLEdBQ25CVyxZQUFZLENBQUMsQ0FBQyxFQUFFQSxVQUFVLENBQUM7SUFDL0IsTUFBTVgsU0FBU1csVUFBVVgsTUFBTSxHQUFHO0lBQ2xDLE1BQU1PLFFBQVEsSUFBSVosV0FBV0s7SUFDN0IsSUFBSyxJQUFJSSxRQUFRLEdBQUdRLElBQUksR0FBR1IsUUFBUUosUUFBUUksUUFBUztRQUNoRCxNQUFNUyxhQUFhekIsU0FBUzBCLGdCQUFnQixDQUFDSCxVQUFVSSxVQUFVLENBQUNIO1FBQ2xFLE1BQU1JLGNBQWM1QixTQUFTMEIsZ0JBQWdCLENBQUNILFVBQVVJLFVBQVUsQ0FBQ0g7UUFDbkUsSUFBSUMsZUFBZUksYUFBYUQsZ0JBQWdCQyxXQUFXO1lBQ3ZELE1BQU0sSUFBSS9CLE9BQU9nQyxTQUFTLENBQUMsQ0FBQyx3QkFBd0IsRUFBRVAsU0FBUyxDQUFDQyxJQUFJLEVBQUUsQ0FBQyxFQUFFRCxTQUFTLENBQUNDLElBQUksRUFBRSxDQUFDLE1BQU0sRUFBRUQsVUFBVSxHQUFHLENBQUM7UUFDcEg7UUFDQUosS0FBSyxDQUFDSCxNQUFNLEdBQUcsY0FBZSxJQUFLWTtJQUN2QztJQUNBLE9BQU9UO0FBQ1g7QUFDQSxTQUFTdkMsV0FBV1osS0FBSyxFQUFFa0QsT0FBTztJQUM5QixNQUFNSSxNQUFNdkIsSUFBSW5CLFVBQVUsQ0FBQ1osT0FBT2tEO0lBQ2xDLE9BQU92QyxRQUFRMkM7QUFDbkI7QUFDQSxTQUFTekMsV0FBV2IsS0FBSyxFQUFFa0QsVUFBVSxDQUFDLENBQUM7SUFDbkMsTUFBTSxFQUFFaEMsSUFBSSxFQUFFLEdBQUdnQztJQUNqQixNQUFNQyxRQUFRZCxRQUFRMEIsTUFBTSxDQUFDL0Q7SUFDN0IsSUFBSSxPQUFPa0IsU0FBUyxVQUFVO1FBQzFCYyxTQUFTcUIsVUFBVSxDQUFDRixPQUFPakM7UUFDM0IsT0FBT0YsU0FBU21DLE9BQU9qQztJQUMzQjtJQUNBLE9BQU9pQztBQUNYO0FBQ0EsU0FBU3JDLFFBQVFrRCxNQUFNLEVBQUVDLE1BQU07SUFDM0IsT0FBTyxDQUFDLEdBQUdyQyxRQUFRc0MsVUFBVSxFQUFFRixRQUFRQztBQUMzQztBQUNBLFNBQVNsRCxRQUFRZixLQUFLLEVBQUVrQixJQUFJO0lBQ3hCLE9BQU9jLFNBQVNtQyxHQUFHLENBQUNuRSxPQUFPO1FBQUVvRSxLQUFLO1FBQVFsRDtJQUFLO0FBQ25EO0FBQ0EsU0FBU0YsU0FBU2hCLEtBQUssRUFBRWtCLElBQUk7SUFDekIsT0FBT2MsU0FBU21DLEdBQUcsQ0FBQ25FLE9BQU87UUFBRW9FLEtBQUs7UUFBU2xEO0lBQUs7QUFDcEQ7QUFDQSxTQUFTRCxPQUFPMkIsTUFBTTtJQUNsQixPQUFPeUIsT0FBT0MsZUFBZSxDQUFDLElBQUkvQixXQUFXSztBQUNqRDtBQUNBLFNBQVMxQixLQUFLbEIsS0FBSztJQUNmLE9BQU9BLE1BQU00QyxNQUFNO0FBQ3ZCO0FBQ0EsU0FBU3pCLE1BQU1uQixLQUFLLEVBQUV1RSxLQUFLLEVBQUVDLEdBQUcsRUFBRXRCLFVBQVUsQ0FBQyxDQUFDO0lBQzFDLE1BQU0sRUFBRXVCLE1BQU0sRUFBRSxHQUFHdkI7SUFDbkJsQixTQUFTMEMsaUJBQWlCLENBQUMxRSxPQUFPdUU7SUFDbEMsTUFBTUksU0FBUzNFLE1BQU1tQixLQUFLLENBQUNvRCxPQUFPQztJQUNsQyxJQUFJQyxRQUNBekMsU0FBUzRDLGVBQWUsQ0FBQ0QsUUFBUUosT0FBT0M7SUFDNUMsT0FBT0c7QUFDWDtBQUNBLFNBQVN2RCxTQUFTK0IsS0FBSyxFQUFFRCxVQUFVLENBQUMsQ0FBQztJQUNqQyxNQUFNLEVBQUVoQyxJQUFJLEVBQUUsR0FBR2dDO0lBQ2pCLElBQUksT0FBT2hDLFNBQVMsYUFDaEJjLFNBQVNxQixVQUFVLENBQUNGLE9BQU9qQztJQUMvQixNQUFNb0MsTUFBTXZCLElBQUk4QyxTQUFTLENBQUMxQixPQUFPRDtJQUNqQyxPQUFPbkIsSUFBSVgsUUFBUSxDQUFDa0MsS0FBS0o7QUFDN0I7QUFDQSxTQUFTN0IsVUFBVThCLEtBQUssRUFBRUQsVUFBVSxDQUFDLENBQUM7SUFDbEMsTUFBTSxFQUFFaEMsSUFBSSxFQUFFLEdBQUdnQztJQUNqQixJQUFJNEIsU0FBUzNCO0lBQ2IsSUFBSSxPQUFPakMsU0FBUyxhQUFhO1FBQzdCYyxTQUFTcUIsVUFBVSxDQUFDeUIsUUFBUTVEO1FBQzVCNEQsU0FBU3JELFNBQVNxRDtJQUN0QjtJQUNBLElBQUlBLE9BQU9sQyxNQUFNLEdBQUcsS0FBS2tDLE1BQU0sQ0FBQyxFQUFFLEdBQUcsR0FDakMsTUFBTSxJQUFJekUseUJBQXlCeUU7SUFDdkMsT0FBT0MsUUFBUUQsTUFBTSxDQUFDLEVBQUU7QUFDNUI7QUFDQSxTQUFTeEQsTUFBTXRCLEtBQUssRUFBRWtELFVBQVUsQ0FBQyxDQUFDO0lBQzlCLE9BQU9uQixJQUFJOEMsU0FBUyxDQUFDN0UsT0FBT2tEO0FBQ2hDO0FBQ0EsU0FBUzNCLFNBQVM0QixLQUFLLEVBQUVELFVBQVUsQ0FBQyxDQUFDO0lBQ2pDLE1BQU0sRUFBRWhDLElBQUksRUFBRSxHQUFHZ0M7SUFDakIsSUFBSSxPQUFPaEMsU0FBUyxhQUNoQmMsU0FBU3FCLFVBQVUsQ0FBQ0YsT0FBT2pDO0lBQy9CLE1BQU1vQyxNQUFNdkIsSUFBSThDLFNBQVMsQ0FBQzFCLE9BQU9EO0lBQ2pDLE9BQU9uQixJQUFJUixRQUFRLENBQUMrQixLQUFLSjtBQUM3QjtBQUNBLFNBQVMxQixTQUFTMkIsS0FBSyxFQUFFRCxVQUFVLENBQUMsQ0FBQztJQUNqQyxNQUFNLEVBQUVoQyxJQUFJLEVBQUUsR0FBR2dDO0lBQ2pCLElBQUk0QixTQUFTM0I7SUFDYixJQUFJLE9BQU9qQyxTQUFTLGFBQWE7UUFDN0JjLFNBQVNxQixVQUFVLENBQUN5QixRQUFRNUQ7UUFDNUI0RCxTQUFTcEQsVUFBVW9EO0lBQ3ZCO0lBQ0EsT0FBTzNDLFFBQVE2QyxNQUFNLENBQUNGO0FBQzFCO0FBQ0EsU0FBU3JELFNBQVN6QixLQUFLO0lBQ25CLE9BQU9nQyxTQUFTaUQsSUFBSSxDQUFDakYsT0FBTztRQUFFb0UsS0FBSztJQUFPO0FBQzlDO0FBQ0EsU0FBUzFDLFVBQVUxQixLQUFLO0lBQ3BCLE9BQU9nQyxTQUFTaUQsSUFBSSxDQUFDakYsT0FBTztRQUFFb0UsS0FBSztJQUFRO0FBQy9DO0FBQ0EsU0FBU3pDLFNBQVMzQixLQUFLO0lBQ25CLElBQUk7UUFDQU0sT0FBT047UUFDUCxPQUFPO0lBQ1gsRUFDQSxPQUFNO1FBQ0YsT0FBTztJQUNYO0FBQ0o7QUFDQSxNQUFNSyxpQ0FBaUN5QixPQUFPZ0MsU0FBUztJQUNuRHJCLFlBQVlVLEtBQUssQ0FBRTtRQUNmLEtBQUssQ0FBQyxDQUFDLGNBQWMsRUFBRUEsTUFBTSwwQkFBMEIsQ0FBQyxFQUFFO1lBQ3REK0IsY0FBYztnQkFDVjthQUNIO1FBQ0w7UUFDQXJGLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsUUFBUTtZQUNoQ3FGLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZyRixPQUFPO1FBQ1g7SUFDSjtBQUNKO0FBQ0FELGdDQUFnQyxHQUFHTTtBQUNuQyxNQUFNRCw4QkFBOEIwQixPQUFPZ0MsU0FBUztJQUNoRHJCLFlBQVl6QyxLQUFLLENBQUU7UUFDZixLQUFLLENBQUMsQ0FBQyxRQUFRLEVBQUUsT0FBT0EsVUFBVSxXQUFXa0MsS0FBS29ELFNBQVMsQ0FBQ3RGLFNBQVNBLE1BQU0sYUFBYSxFQUFFLE9BQU9BLE1BQU0sNkJBQTZCLENBQUMsRUFBRTtZQUNuSWtGLGNBQWM7Z0JBQUM7YUFBd0M7UUFDM0Q7UUFDQXJGLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsUUFBUTtZQUNoQ3FGLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZyRixPQUFPO1FBQ1g7SUFDSjtBQUNKO0FBQ0FELDZCQUE2QixHQUFHSztBQUNoQyxNQUFNRCwwQkFBMEIyQixPQUFPZ0MsU0FBUztJQUM1Q3JCLFlBQVksRUFBRThDLFNBQVMsRUFBRUMsT0FBTyxFQUFFLENBQUU7UUFDaEMsS0FBSyxDQUFDLENBQUMscUJBQXFCLEVBQUVBLFFBQVEsd0JBQXdCLEVBQUVELFVBQVUsU0FBUyxDQUFDO1FBQ3BGMUYsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxRQUFRO1lBQ2hDcUYsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVnJGLE9BQU87UUFDWDtJQUNKO0FBQ0o7QUFDQUQseUJBQXlCLEdBQUdJO0FBQzVCLE1BQU1ELG9DQUFvQzRCLE9BQU9nQyxTQUFTO0lBQ3REckIsWUFBWSxFQUFFZ0QsTUFBTSxFQUFFQyxRQUFRLEVBQUV4RSxJQUFJLEVBQUcsQ0FBRTtRQUNyQyxLQUFLLENBQUMsQ0FBQyxNQUFNLEVBQUV3RSxhQUFhLFVBQVUsYUFBYSxTQUFTLGFBQWEsRUFBRUQsT0FBTyw2QkFBNkIsRUFBRXZFLEtBQUssSUFBSSxDQUFDO1FBQzNIckIsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxRQUFRO1lBQ2hDcUYsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVnJGLE9BQU87UUFDWDtJQUNKO0FBQ0o7QUFDQUQsbUNBQW1DLEdBQUdHO0FBQ3RDLE1BQU1ELG9DQUFvQzZCLE9BQU9nQyxTQUFTO0lBQ3REckIsWUFBWSxFQUFFdkIsSUFBSSxFQUFFeUUsVUFBVSxFQUFFQyxJQUFJLEVBQUcsQ0FBRTtRQUNyQyxLQUFLLENBQUMsQ0FBQyxFQUFFQSxLQUFLQyxNQUFNLENBQUMsR0FBR0MsV0FBVyxHQUFHLEVBQUVGLEtBQ25DekUsS0FBSyxDQUFDLEdBQ040RSxXQUFXLEdBQUcsU0FBUyxFQUFFN0UsS0FBSyw0QkFBNEIsRUFBRXlFLFdBQVcsSUFBSSxDQUFDO1FBQ2pGOUYsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxRQUFRO1lBQ2hDcUYsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVnJGLE9BQU87UUFDWDtJQUNKO0FBQ0o7QUFDQUQsbUNBQW1DLEdBQUdFLDZCQUN0QyxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGF3LXdvcmtzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L19janMvY29yZS9CeXRlcy5qcz9hMTdhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TaXplRXhjZWVkc1BhZGRpbmdTaXplRXJyb3IgPSBleHBvcnRzLlNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvciA9IGV4cG9ydHMuU2l6ZU92ZXJmbG93RXJyb3IgPSBleHBvcnRzLkludmFsaWRCeXRlc1R5cGVFcnJvciA9IGV4cG9ydHMuSW52YWxpZEJ5dGVzQm9vbGVhbkVycm9yID0gdm9pZCAwO1xuZXhwb3J0cy5hc3NlcnQgPSBhc3NlcnQ7XG5leHBvcnRzLmNvbmNhdCA9IGNvbmNhdDtcbmV4cG9ydHMuZnJvbSA9IGZyb207XG5leHBvcnRzLmZyb21BcnJheSA9IGZyb21BcnJheTtcbmV4cG9ydHMuZnJvbUJvb2xlYW4gPSBmcm9tQm9vbGVhbjtcbmV4cG9ydHMuZnJvbUhleCA9IGZyb21IZXg7XG5leHBvcnRzLmZyb21OdW1iZXIgPSBmcm9tTnVtYmVyO1xuZXhwb3J0cy5mcm9tU3RyaW5nID0gZnJvbVN0cmluZztcbmV4cG9ydHMuaXNFcXVhbCA9IGlzRXF1YWw7XG5leHBvcnRzLnBhZExlZnQgPSBwYWRMZWZ0O1xuZXhwb3J0cy5wYWRSaWdodCA9IHBhZFJpZ2h0O1xuZXhwb3J0cy5yYW5kb20gPSByYW5kb207XG5leHBvcnRzLnNpemUgPSBzaXplO1xuZXhwb3J0cy5zbGljZSA9IHNsaWNlO1xuZXhwb3J0cy50b0JpZ0ludCA9IHRvQmlnSW50O1xuZXhwb3J0cy50b0Jvb2xlYW4gPSB0b0Jvb2xlYW47XG5leHBvcnRzLnRvSGV4ID0gdG9IZXg7XG5leHBvcnRzLnRvTnVtYmVyID0gdG9OdW1iZXI7XG5leHBvcnRzLnRvU3RyaW5nID0gdG9TdHJpbmc7XG5leHBvcnRzLnRyaW1MZWZ0ID0gdHJpbUxlZnQ7XG5leHBvcnRzLnRyaW1SaWdodCA9IHRyaW1SaWdodDtcbmV4cG9ydHMudmFsaWRhdGUgPSB2YWxpZGF0ZTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC91dGlsc1wiKTtcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoXCIuL0Vycm9ycy5qc1wiKTtcbmNvbnN0IEhleCA9IHJlcXVpcmUoXCIuL0hleC5qc1wiKTtcbmNvbnN0IGludGVybmFsID0gcmVxdWlyZShcIi4vaW50ZXJuYWwvYnl0ZXMuanNcIik7XG5jb25zdCBpbnRlcm5hbF9oZXggPSByZXF1aXJlKFwiLi9pbnRlcm5hbC9oZXguanNcIik7XG5jb25zdCBKc29uID0gcmVxdWlyZShcIi4vSnNvbi5qc1wiKTtcbmNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbmNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbmZ1bmN0aW9uIGFzc2VydCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoIXZhbHVlKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEJ5dGVzVHlwZUVycm9yKHZhbHVlKTtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JylcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRCeXRlc1R5cGVFcnJvcih2YWx1ZSk7XG4gICAgaWYgKCEoJ0JZVEVTX1BFUl9FTEVNRU5UJyBpbiB2YWx1ZSkpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQnl0ZXNUeXBlRXJyb3IodmFsdWUpO1xuICAgIGlmICh2YWx1ZS5CWVRFU19QRVJfRUxFTUVOVCAhPT0gMSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lICE9PSAnVWludDhBcnJheScpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQnl0ZXNUeXBlRXJyb3IodmFsdWUpO1xufVxuZnVuY3Rpb24gY29uY2F0KC4uLnZhbHVlcykge1xuICAgIGxldCBsZW5ndGggPSAwO1xuICAgIGZvciAoY29uc3QgYXJyIG9mIHZhbHVlcykge1xuICAgICAgICBsZW5ndGggKz0gYXJyLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaW5kZXggPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IHZhbHVlc1tpXTtcbiAgICAgICAgcmVzdWx0LnNldChhcnIsIGluZGV4KTtcbiAgICAgICAgaW5kZXggKz0gYXJyLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGZyb20odmFsdWUpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiBmcm9tSGV4KHZhbHVlKTtcbiAgICByZXR1cm4gZnJvbUFycmF5KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGZyb21BcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyB2YWx1ZSA6IG5ldyBVaW50OEFycmF5KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGZyb21Cb29sZWFuKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpemUgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheSgxKTtcbiAgICBieXRlc1swXSA9IE51bWJlcih2YWx1ZSk7XG4gICAgaWYgKHR5cGVvZiBzaXplID09PSAnbnVtYmVyJykge1xuICAgICAgICBpbnRlcm5hbC5hc3NlcnRTaXplKGJ5dGVzLCBzaXplKTtcbiAgICAgICAgcmV0dXJuIHBhZExlZnQoYnl0ZXMsIHNpemUpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59XG5mdW5jdGlvbiBmcm9tSGV4KHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpemUgfSA9IG9wdGlvbnM7XG4gICAgbGV0IGhleCA9IHZhbHVlO1xuICAgIGlmIChzaXplKSB7XG4gICAgICAgIGludGVybmFsX2hleC5hc3NlcnRTaXplKHZhbHVlLCBzaXplKTtcbiAgICAgICAgaGV4ID0gSGV4LnBhZFJpZ2h0KHZhbHVlLCBzaXplKTtcbiAgICB9XG4gICAgbGV0IGhleFN0cmluZyA9IGhleC5zbGljZSgyKTtcbiAgICBpZiAoaGV4U3RyaW5nLmxlbmd0aCAlIDIpXG4gICAgICAgIGhleFN0cmluZyA9IGAwJHtoZXhTdHJpbmd9YDtcbiAgICBjb25zdCBsZW5ndGggPSBoZXhTdHJpbmcubGVuZ3RoIC8gMjtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgZm9yIChsZXQgaW5kZXggPSAwLCBqID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgY29uc3QgbmliYmxlTGVmdCA9IGludGVybmFsLmNoYXJDb2RlVG9CYXNlMTYoaGV4U3RyaW5nLmNoYXJDb2RlQXQoaisrKSk7XG4gICAgICAgIGNvbnN0IG5pYmJsZVJpZ2h0ID0gaW50ZXJuYWwuY2hhckNvZGVUb0Jhc2UxNihoZXhTdHJpbmcuY2hhckNvZGVBdChqKyspKTtcbiAgICAgICAgaWYgKG5pYmJsZUxlZnQgPT09IHVuZGVmaW5lZCB8fCBuaWJibGVSaWdodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3JzLkJhc2VFcnJvcihgSW52YWxpZCBieXRlIHNlcXVlbmNlIChcIiR7aGV4U3RyaW5nW2ogLSAyXX0ke2hleFN0cmluZ1tqIC0gMV19XCIgaW4gXCIke2hleFN0cmluZ31cIikuYCk7XG4gICAgICAgIH1cbiAgICAgICAgYnl0ZXNbaW5kZXhdID0gKG5pYmJsZUxlZnQgPDwgNCkgfCBuaWJibGVSaWdodDtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuZnVuY3Rpb24gZnJvbU51bWJlcih2YWx1ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGhleCA9IEhleC5mcm9tTnVtYmVyKHZhbHVlLCBvcHRpb25zKTtcbiAgICByZXR1cm4gZnJvbUhleChoZXgpO1xufVxuZnVuY3Rpb24gZnJvbVN0cmluZyh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzaXplIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJ5dGVzID0gZW5jb2Rlci5lbmNvZGUodmFsdWUpO1xuICAgIGlmICh0eXBlb2Ygc2l6ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaW50ZXJuYWwuYXNzZXJ0U2l6ZShieXRlcywgc2l6ZSk7XG4gICAgICAgIHJldHVybiBwYWRSaWdodChieXRlcywgc2l6ZSk7XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbn1cbmZ1bmN0aW9uIGlzRXF1YWwoYnl0ZXNBLCBieXRlc0IpIHtcbiAgICByZXR1cm4gKDAsIHV0aWxzXzEuZXF1YWxCeXRlcykoYnl0ZXNBLCBieXRlc0IpO1xufVxuZnVuY3Rpb24gcGFkTGVmdCh2YWx1ZSwgc2l6ZSkge1xuICAgIHJldHVybiBpbnRlcm5hbC5wYWQodmFsdWUsIHsgZGlyOiAnbGVmdCcsIHNpemUgfSk7XG59XG5mdW5jdGlvbiBwYWRSaWdodCh2YWx1ZSwgc2l6ZSkge1xuICAgIHJldHVybiBpbnRlcm5hbC5wYWQodmFsdWUsIHsgZGlyOiAncmlnaHQnLCBzaXplIH0pO1xufVxuZnVuY3Rpb24gcmFuZG9tKGxlbmd0aCkge1xuICAgIHJldHVybiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KGxlbmd0aCkpO1xufVxuZnVuY3Rpb24gc2l6ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5sZW5ndGg7XG59XG5mdW5jdGlvbiBzbGljZSh2YWx1ZSwgc3RhcnQsIGVuZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzdHJpY3QgfSA9IG9wdGlvbnM7XG4gICAgaW50ZXJuYWwuYXNzZXJ0U3RhcnRPZmZzZXQodmFsdWUsIHN0YXJ0KTtcbiAgICBjb25zdCB2YWx1ZV8gPSB2YWx1ZS5zbGljZShzdGFydCwgZW5kKTtcbiAgICBpZiAoc3RyaWN0KVxuICAgICAgICBpbnRlcm5hbC5hc3NlcnRFbmRPZmZzZXQodmFsdWVfLCBzdGFydCwgZW5kKTtcbiAgICByZXR1cm4gdmFsdWVfO1xufVxuZnVuY3Rpb24gdG9CaWdJbnQoYnl0ZXMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2l6ZSB9ID0gb3B0aW9ucztcbiAgICBpZiAodHlwZW9mIHNpemUgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICBpbnRlcm5hbC5hc3NlcnRTaXplKGJ5dGVzLCBzaXplKTtcbiAgICBjb25zdCBoZXggPSBIZXguZnJvbUJ5dGVzKGJ5dGVzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gSGV4LnRvQmlnSW50KGhleCwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiB0b0Jvb2xlYW4oYnl0ZXMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2l6ZSB9ID0gb3B0aW9ucztcbiAgICBsZXQgYnl0ZXNfID0gYnl0ZXM7XG4gICAgaWYgKHR5cGVvZiBzaXplICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpbnRlcm5hbC5hc3NlcnRTaXplKGJ5dGVzXywgc2l6ZSk7XG4gICAgICAgIGJ5dGVzXyA9IHRyaW1MZWZ0KGJ5dGVzXyk7XG4gICAgfVxuICAgIGlmIChieXRlc18ubGVuZ3RoID4gMSB8fCBieXRlc19bMF0gPiAxKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEJ5dGVzQm9vbGVhbkVycm9yKGJ5dGVzXyk7XG4gICAgcmV0dXJuIEJvb2xlYW4oYnl0ZXNfWzBdKTtcbn1cbmZ1bmN0aW9uIHRvSGV4KHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gSGV4LmZyb21CeXRlcyh2YWx1ZSwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiB0b051bWJlcihieXRlcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzaXplIH0gPSBvcHRpb25zO1xuICAgIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIGludGVybmFsLmFzc2VydFNpemUoYnl0ZXMsIHNpemUpO1xuICAgIGNvbnN0IGhleCA9IEhleC5mcm9tQnl0ZXMoYnl0ZXMsIG9wdGlvbnMpO1xuICAgIHJldHVybiBIZXgudG9OdW1iZXIoaGV4LCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHRvU3RyaW5nKGJ5dGVzLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpemUgfSA9IG9wdGlvbnM7XG4gICAgbGV0IGJ5dGVzXyA9IGJ5dGVzO1xuICAgIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaW50ZXJuYWwuYXNzZXJ0U2l6ZShieXRlc18sIHNpemUpO1xuICAgICAgICBieXRlc18gPSB0cmltUmlnaHQoYnl0ZXNfKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlY29kZXIuZGVjb2RlKGJ5dGVzXyk7XG59XG5mdW5jdGlvbiB0cmltTGVmdCh2YWx1ZSkge1xuICAgIHJldHVybiBpbnRlcm5hbC50cmltKHZhbHVlLCB7IGRpcjogJ2xlZnQnIH0pO1xufVxuZnVuY3Rpb24gdHJpbVJpZ2h0KHZhbHVlKSB7XG4gICAgcmV0dXJuIGludGVybmFsLnRyaW0odmFsdWUsIHsgZGlyOiAncmlnaHQnIH0pO1xufVxuZnVuY3Rpb24gdmFsaWRhdGUodmFsdWUpIHtcbiAgICB0cnkge1xuICAgICAgICBhc3NlcnQodmFsdWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuY2xhc3MgSW52YWxpZEJ5dGVzQm9vbGVhbkVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoYnl0ZXMpIHtcbiAgICAgICAgc3VwZXIoYEJ5dGVzIHZhbHVlIFxcYCR7Ynl0ZXN9XFxgIGlzIG5vdCBhIHZhbGlkIGJvb2xlYW4uYCwge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXG4gICAgICAgICAgICAgICAgJ1RoZSBieXRlcyBhcnJheSBtdXN0IGNvbnRhaW4gYSBzaW5nbGUgYnl0ZSBvZiBlaXRoZXIgYSBgMGAgb3IgYDFgIHZhbHVlLicsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0J5dGVzLkludmFsaWRCeXRlc0Jvb2xlYW5FcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5JbnZhbGlkQnl0ZXNCb29sZWFuRXJyb3IgPSBJbnZhbGlkQnl0ZXNCb29sZWFuRXJyb3I7XG5jbGFzcyBJbnZhbGlkQnl0ZXNUeXBlRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICBzdXBlcihgVmFsdWUgXFxgJHt0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnID8gSnNvbi5zdHJpbmdpZnkodmFsdWUpIDogdmFsdWV9XFxgIG9mIHR5cGUgXFxgJHt0eXBlb2YgdmFsdWV9XFxgIGlzIGFuIGludmFsaWQgQnl0ZXMgdmFsdWUuYCwge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbJ0J5dGVzIHZhbHVlcyBtdXN0IGJlIG9mIHR5cGUgYEJ5dGVzYC4nXSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdCeXRlcy5JbnZhbGlkQnl0ZXNUeXBlRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuSW52YWxpZEJ5dGVzVHlwZUVycm9yID0gSW52YWxpZEJ5dGVzVHlwZUVycm9yO1xuY2xhc3MgU2l6ZU92ZXJmbG93RXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGdpdmVuU2l6ZSwgbWF4U2l6ZSB9KSB7XG4gICAgICAgIHN1cGVyKGBTaXplIGNhbm5vdCBleGNlZWQgXFxgJHttYXhTaXplfVxcYCBieXRlcy4gR2l2ZW4gc2l6ZTogXFxgJHtnaXZlblNpemV9XFxgIGJ5dGVzLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQnl0ZXMuU2l6ZU92ZXJmbG93RXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuU2l6ZU92ZXJmbG93RXJyb3IgPSBTaXplT3ZlcmZsb3dFcnJvcjtcbmNsYXNzIFNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgb2Zmc2V0LCBwb3NpdGlvbiwgc2l6ZSwgfSkge1xuICAgICAgICBzdXBlcihgU2xpY2UgJHtwb3NpdGlvbiA9PT0gJ3N0YXJ0JyA/ICdzdGFydGluZycgOiAnZW5kaW5nJ30gYXQgb2Zmc2V0IFxcYCR7b2Zmc2V0fVxcYCBpcyBvdXQtb2YtYm91bmRzIChzaXplOiBcXGAke3NpemV9XFxgKS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0J5dGVzLlNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5TbGljZU9mZnNldE91dE9mQm91bmRzRXJyb3IgPSBTbGljZU9mZnNldE91dE9mQm91bmRzRXJyb3I7XG5jbGFzcyBTaXplRXhjZWVkc1BhZGRpbmdTaXplRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHNpemUsIHRhcmdldFNpemUsIHR5cGUsIH0pIHtcbiAgICAgICAgc3VwZXIoYCR7dHlwZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKX0ke3R5cGVcbiAgICAgICAgICAgIC5zbGljZSgxKVxuICAgICAgICAgICAgLnRvTG93ZXJDYXNlKCl9IHNpemUgKFxcYCR7c2l6ZX1cXGApIGV4Y2VlZHMgcGFkZGluZyBzaXplIChcXGAke3RhcmdldFNpemV9XFxgKS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0J5dGVzLlNpemVFeGNlZWRzUGFkZGluZ1NpemVFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5TaXplRXhjZWVkc1BhZGRpbmdTaXplRXJyb3IgPSBTaXplRXhjZWVkc1BhZGRpbmdTaXplRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CeXRlcy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJTaXplRXhjZWVkc1BhZGRpbmdTaXplRXJyb3IiLCJTbGljZU9mZnNldE91dE9mQm91bmRzRXJyb3IiLCJTaXplT3ZlcmZsb3dFcnJvciIsIkludmFsaWRCeXRlc1R5cGVFcnJvciIsIkludmFsaWRCeXRlc0Jvb2xlYW5FcnJvciIsImFzc2VydCIsImNvbmNhdCIsImZyb20iLCJmcm9tQXJyYXkiLCJmcm9tQm9vbGVhbiIsImZyb21IZXgiLCJmcm9tTnVtYmVyIiwiZnJvbVN0cmluZyIsImlzRXF1YWwiLCJwYWRMZWZ0IiwicGFkUmlnaHQiLCJyYW5kb20iLCJzaXplIiwic2xpY2UiLCJ0b0JpZ0ludCIsInRvQm9vbGVhbiIsInRvSGV4IiwidG9OdW1iZXIiLCJ0b1N0cmluZyIsInRyaW1MZWZ0IiwidHJpbVJpZ2h0IiwidmFsaWRhdGUiLCJ1dGlsc18xIiwicmVxdWlyZSIsIkVycm9ycyIsIkhleCIsImludGVybmFsIiwiaW50ZXJuYWxfaGV4IiwiSnNvbiIsImRlY29kZXIiLCJUZXh0RGVjb2RlciIsImVuY29kZXIiLCJUZXh0RW5jb2RlciIsIlVpbnQ4QXJyYXkiLCJCWVRFU19QRVJfRUxFTUVOVCIsImNvbnN0cnVjdG9yIiwibmFtZSIsInZhbHVlcyIsImxlbmd0aCIsImFyciIsInJlc3VsdCIsImkiLCJpbmRleCIsInNldCIsIm9wdGlvbnMiLCJieXRlcyIsIk51bWJlciIsImFzc2VydFNpemUiLCJoZXgiLCJoZXhTdHJpbmciLCJqIiwibmliYmxlTGVmdCIsImNoYXJDb2RlVG9CYXNlMTYiLCJjaGFyQ29kZUF0IiwibmliYmxlUmlnaHQiLCJ1bmRlZmluZWQiLCJCYXNlRXJyb3IiLCJlbmNvZGUiLCJieXRlc0EiLCJieXRlc0IiLCJlcXVhbEJ5dGVzIiwicGFkIiwiZGlyIiwiY3J5cHRvIiwiZ2V0UmFuZG9tVmFsdWVzIiwic3RhcnQiLCJlbmQiLCJzdHJpY3QiLCJhc3NlcnRTdGFydE9mZnNldCIsInZhbHVlXyIsImFzc2VydEVuZE9mZnNldCIsImZyb21CeXRlcyIsImJ5dGVzXyIsIkJvb2xlYW4iLCJkZWNvZGUiLCJ0cmltIiwibWV0YU1lc3NhZ2VzIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwic3RyaW5naWZ5IiwiZ2l2ZW5TaXplIiwibWF4U2l6ZSIsIm9mZnNldCIsInBvc2l0aW9uIiwidGFyZ2V0U2l6ZSIsInR5cGUiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsInRvTG93ZXJDYXNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_cjs/core/Bytes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_cjs/core/Caches.js":
/*!*********************************************!*\
  !*** ./node_modules/ox/_cjs/core/Caches.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.checksum = void 0;\nexports.clear = clear;\nconst lru_js_1 = __webpack_require__(/*! ./internal/lru.js */ \"(ssr)/./node_modules/ox/_cjs/core/internal/lru.js\");\nconst caches = {\n    checksum: new lru_js_1.LruMap(8192)\n};\nexports.checksum = caches.checksum;\nfunction clear() {\n    for (const cache of Object.values(caches))cache.clear();\n} //# sourceMappingURL=Caches.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2Nqcy9jb3JlL0NhY2hlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsZ0JBQWdCLEdBQUcsS0FBSztBQUN4QkEsYUFBYSxHQUFHRztBQUNoQixNQUFNQyxXQUFXQyxtQkFBT0EsQ0FBQyw0RUFBbUI7QUFDNUMsTUFBTUMsU0FBUztJQUNYSixVQUFVLElBQUlFLFNBQVNHLE1BQU0sQ0FBQztBQUNsQztBQUNBUCxnQkFBZ0IsR0FBR00sT0FBT0osUUFBUTtBQUNsQyxTQUFTQztJQUNMLEtBQUssTUFBTUssU0FBU1YsT0FBT1csTUFBTSxDQUFDSCxRQUM5QkUsTUFBTUwsS0FBSztBQUNuQixFQUNBLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsYXctd29ya3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3gvX2Nqcy9jb3JlL0NhY2hlcy5qcz8xYTM0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jaGVja3N1bSA9IHZvaWQgMDtcbmV4cG9ydHMuY2xlYXIgPSBjbGVhcjtcbmNvbnN0IGxydV9qc18xID0gcmVxdWlyZShcIi4vaW50ZXJuYWwvbHJ1LmpzXCIpO1xuY29uc3QgY2FjaGVzID0ge1xuICAgIGNoZWNrc3VtOiBuZXcgbHJ1X2pzXzEuTHJ1TWFwKDgxOTIpLFxufTtcbmV4cG9ydHMuY2hlY2tzdW0gPSBjYWNoZXMuY2hlY2tzdW07XG5mdW5jdGlvbiBjbGVhcigpIHtcbiAgICBmb3IgKGNvbnN0IGNhY2hlIG9mIE9iamVjdC52YWx1ZXMoY2FjaGVzKSlcbiAgICAgICAgY2FjaGUuY2xlYXIoKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNhY2hlcy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJjaGVja3N1bSIsImNsZWFyIiwibHJ1X2pzXzEiLCJyZXF1aXJlIiwiY2FjaGVzIiwiTHJ1TWFwIiwiY2FjaGUiLCJ2YWx1ZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_cjs/core/Caches.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_cjs/core/Errors.js":
/*!*********************************************!*\
  !*** ./node_modules/ox/_cjs/core/Errors.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.BaseError = void 0;\nconst errors_js_1 = __webpack_require__(/*! ./internal/errors.js */ \"(ssr)/./node_modules/ox/_cjs/core/internal/errors.js\");\nclass BaseError extends Error {\n    static setStaticOptions(options) {\n        BaseError.prototype.docsOrigin = options.docsOrigin;\n        BaseError.prototype.showVersion = options.showVersion;\n        BaseError.prototype.version = options.version;\n    }\n    constructor(shortMessage, options = {}){\n        const details = (()=>{\n            if (options.cause instanceof BaseError) {\n                if (options.cause.details) return options.cause.details;\n                if (options.cause.shortMessage) return options.cause.shortMessage;\n            }\n            if (options.cause && \"details\" in options.cause && typeof options.cause.details === \"string\") return options.cause.details;\n            if (options.cause?.message) return options.cause.message;\n            return options.details;\n        })();\n        const docsPath = (()=>{\n            if (options.cause instanceof BaseError) return options.cause.docsPath || options.docsPath;\n            return options.docsPath;\n        })();\n        const docsBaseUrl = options.docsOrigin ?? BaseError.prototype.docsOrigin;\n        const docs = `${docsBaseUrl}${docsPath ?? \"\"}`;\n        const showVersion = Boolean(options.version ?? BaseError.prototype.showVersion);\n        const version = options.version ?? BaseError.prototype.version;\n        const message = [\n            shortMessage || \"An error occurred.\",\n            ...options.metaMessages ? [\n                \"\",\n                ...options.metaMessages\n            ] : [],\n            ...details || docsPath || showVersion ? [\n                \"\",\n                details ? `Details: ${details}` : undefined,\n                docsPath ? `See: ${docs}` : undefined,\n                showVersion ? `Version: ${version}` : undefined\n            ] : []\n        ].filter((x)=>typeof x === \"string\").join(\"\\n\");\n        super(message, options.cause ? {\n            cause: options.cause\n        } : undefined);\n        Object.defineProperty(this, \"details\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"docs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"docsOrigin\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"docsPath\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"shortMessage\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"showVersion\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"cause\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"BaseError\"\n        });\n        this.cause = options.cause;\n        this.details = details;\n        this.docs = docs;\n        this.docsOrigin = docsBaseUrl;\n        this.docsPath = docsPath;\n        this.shortMessage = shortMessage;\n        this.showVersion = showVersion;\n        this.version = version;\n    }\n    walk(fn) {\n        return walk(this, fn);\n    }\n}\nexports.BaseError = BaseError;\nObject.defineProperty(BaseError, \"defaultStaticOptions\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: {\n        docsOrigin: \"https://oxlib.sh\",\n        showVersion: false,\n        version: `ox@${(0, errors_js_1.getVersion)()}`\n    }\n});\n(()=>{\n    BaseError.setStaticOptions(BaseError.defaultStaticOptions);\n})();\nfunction walk(err, fn) {\n    if (fn?.(err)) return err;\n    if (err && typeof err === \"object\" && \"cause\" in err && err.cause) return walk(err.cause, fn);\n    return fn ? null : err;\n} //# sourceMappingURL=Errors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2Nqcy9jb3JlL0Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsaUJBQWlCLEdBQUcsS0FBSztBQUN6QixNQUFNRyxjQUFjQyxtQkFBT0EsQ0FBQyxrRkFBc0I7QUFDbEQsTUFBTUYsa0JBQWtCRztJQUNwQixPQUFPQyxpQkFBaUJDLE9BQU8sRUFBRTtRQUM3QkwsVUFBVU0sU0FBUyxDQUFDQyxVQUFVLEdBQUdGLFFBQVFFLFVBQVU7UUFDbkRQLFVBQVVNLFNBQVMsQ0FBQ0UsV0FBVyxHQUFHSCxRQUFRRyxXQUFXO1FBQ3JEUixVQUFVTSxTQUFTLENBQUNHLE9BQU8sR0FBR0osUUFBUUksT0FBTztJQUNqRDtJQUNBQyxZQUFZQyxZQUFZLEVBQUVOLFVBQVUsQ0FBQyxDQUFDLENBQUU7UUFDcEMsTUFBTU8sVUFBVSxDQUFDO1lBQ2IsSUFBSVAsUUFBUVEsS0FBSyxZQUFZYixXQUFXO2dCQUNwQyxJQUFJSyxRQUFRUSxLQUFLLENBQUNELE9BQU8sRUFDckIsT0FBT1AsUUFBUVEsS0FBSyxDQUFDRCxPQUFPO2dCQUNoQyxJQUFJUCxRQUFRUSxLQUFLLENBQUNGLFlBQVksRUFDMUIsT0FBT04sUUFBUVEsS0FBSyxDQUFDRixZQUFZO1lBQ3pDO1lBQ0EsSUFBSU4sUUFBUVEsS0FBSyxJQUNiLGFBQWFSLFFBQVFRLEtBQUssSUFDMUIsT0FBT1IsUUFBUVEsS0FBSyxDQUFDRCxPQUFPLEtBQUssVUFDakMsT0FBT1AsUUFBUVEsS0FBSyxDQUFDRCxPQUFPO1lBQ2hDLElBQUlQLFFBQVFRLEtBQUssRUFBRUMsU0FDZixPQUFPVCxRQUFRUSxLQUFLLENBQUNDLE9BQU87WUFDaEMsT0FBT1QsUUFBUU8sT0FBTztRQUMxQjtRQUNBLE1BQU1HLFdBQVcsQ0FBQztZQUNkLElBQUlWLFFBQVFRLEtBQUssWUFBWWIsV0FDekIsT0FBT0ssUUFBUVEsS0FBSyxD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QUFFO1FBQ0wsT0FBT0QsS0FBSyxJQUFJLEVBQUVDO0lBQ3RCO0FBQ0o7QUFDQTlCLGlCQUFpQixHQUFHRTtBQUNwQkosT0FBT0MsY0FBYyxDQUFDRyxXQUFXLHdCQUF3QjtJQUNyRHdCLFlBQVk7SUFDWkMsY0FBYztJQUNkQyxVQUFVO0lBQ1YzQixPQUFPO1FBQ0hRLFlBQVk7UUFDWkMsYUFBYTtRQUNiQyxTQUFTLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBR1IsWUFBWTRCLFVBQVUsSUFBSSxDQUFDO0lBQ2xEO0FBQ0o7QUFDQztJQUNHN0IsVUFBVUksZ0JBQWdCLENBQUNKLFVBQVU4QixvQkFBb0I7QUFDN0Q7QUFDQSxTQUFTSCxLQUFLSSxHQUFHLEVBQUVILEVBQUU7SUFDakIsSUFBSUEsS0FBS0csTUFDTCxPQUFPQTtJQUNYLElBQUlBLE9BQU8sT0FBT0EsUUFBUSxZQUFZLFdBQVdBLE9BQU9BLElBQUlsQixLQUFLLEVBQzdELE9BQU9jLEtBQUtJLElBQUlsQixLQUFLLEVBQUVlO0lBQzNCLE9BQU9BLEtBQUssT0FBT0c7QUFDdkIsRUFDQSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGF3LXdvcmtzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L19janMvY29yZS9FcnJvcnMuanM/NGI3MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmFzZUVycm9yID0gdm9pZCAwO1xuY29uc3QgZXJyb3JzX2pzXzEgPSByZXF1aXJlKFwiLi9pbnRlcm5hbC9lcnJvcnMuanNcIik7XG5jbGFzcyBCYXNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgc3RhdGljIHNldFN0YXRpY09wdGlvbnMob3B0aW9ucykge1xuICAgICAgICBCYXNlRXJyb3IucHJvdG90eXBlLmRvY3NPcmlnaW4gPSBvcHRpb25zLmRvY3NPcmlnaW47XG4gICAgICAgIEJhc2VFcnJvci5wcm90b3R5cGUuc2hvd1ZlcnNpb24gPSBvcHRpb25zLnNob3dWZXJzaW9uO1xuICAgICAgICBCYXNlRXJyb3IucHJvdG90eXBlLnZlcnNpb24gPSBvcHRpb25zLnZlcnNpb247XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHNob3J0TWVzc2FnZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGRldGFpbHMgPSAoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2F1c2UgaW5zdGFuY2VvZiBCYXNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5jYXVzZS5kZXRhaWxzKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5jYXVzZS5kZXRhaWxzO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmNhdXNlLnNob3J0TWVzc2FnZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuY2F1c2Uuc2hvcnRNZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2F1c2UgJiZcbiAgICAgICAgICAgICAgICAnZGV0YWlscycgaW4gb3B0aW9ucy5jYXVzZSAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBvcHRpb25zLmNhdXNlLmRldGFpbHMgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmNhdXNlLmRldGFpbHM7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jYXVzZT8ubWVzc2FnZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5jYXVzZS5tZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuZGV0YWlscztcbiAgICAgICAgfSkoKTtcbiAgICAgICAgY29uc3QgZG9jc1BhdGggPSAoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2F1c2UgaW5zdGFuY2VvZiBCYXNlRXJyb3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuY2F1c2UuZG9jc1BhdGggfHwgb3B0aW9ucy5kb2NzUGF0aDtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmRvY3NQYXRoO1xuICAgICAgICB9KSgpO1xuICAgICAgICBjb25zdCBkb2NzQmFzZVVybCA9IG9wdGlvbnMuZG9jc09yaWdpbiA/PyBCYXNlRXJyb3IucHJvdG90eXBlLmRvY3NPcmlnaW47XG4gICAgICAgIGNvbnN0IGRvY3MgPSBgJHtkb2NzQmFzZVVybH0ke2RvY3NQYXRoID8/ICcnfWA7XG4gICAgICAgIGNvbnN0IHNob3dWZXJzaW9uID0gQm9vbGVhbihvcHRpb25zLnZlcnNpb24gPz8gQmFzZUVycm9yLnByb3RvdHlwZS5zaG93VmVyc2lvbik7XG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSBvcHRpb25zLnZlcnNpb24gPz8gQmFzZUVycm9yLnByb3RvdHlwZS52ZXJzaW9uO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gW1xuICAgICAgICAgICAgc2hvcnRNZXNzYWdlIHx8ICdBbiBlcnJvciBvY2N1cnJlZC4nLFxuICAgICAgICAgICAgLi4uKG9wdGlvbnMubWV0YU1lc3NhZ2VzID8gWycnLCAuLi5vcHRpb25zLm1ldGFNZXNzYWdlc10gOiBbXSksXG4gICAgICAgICAgICAuLi4oZGV0YWlscyB8fCBkb2NzUGF0aCB8fCBzaG93VmVyc2lvblxuICAgICAgICAgICAgICAgID8gW1xuICAgICAgICAgICAgICAgICAgICAnJyxcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlscyA/IGBEZXRhaWxzOiAke2RldGFpbHN9YCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgZG9jc1BhdGggPyBgU2VlOiAke2RvY3N9YCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgc2hvd1ZlcnNpb24gPyBgVmVyc2lvbjogJHt2ZXJzaW9ufWAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIDogW10pLFxuICAgICAgICBdXG4gICAgICAgICAgICAuZmlsdGVyKCh4KSA9PiB0eXBlb2YgeCA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAuam9pbignXFxuJyk7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsIG9wdGlvbnMuY2F1c2UgPyB7IGNhdXNlOiBvcHRpb25zLmNhdXNlIH0gOiB1bmRlZmluZWQpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkZXRhaWxzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRvY3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZG9jc09yaWdpblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkb2NzUGF0aFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzaG9ydE1lc3NhZ2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic2hvd1ZlcnNpb25cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidmVyc2lvblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjYXVzZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQmFzZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYXVzZSA9IG9wdGlvbnMuY2F1c2U7XG4gICAgICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XG4gICAgICAgIHRoaXMuZG9jcyA9IGRvY3M7XG4gICAgICAgIHRoaXMuZG9jc09yaWdpbiA9IGRvY3NCYXNlVXJsO1xuICAgICAgICB0aGlzLmRvY3NQYXRoID0gZG9jc1BhdGg7XG4gICAgICAgIHRoaXMuc2hvcnRNZXNzYWdlID0gc2hvcnRNZXNzYWdlO1xuICAgICAgICB0aGlzLnNob3dWZXJzaW9uID0gc2hvd1ZlcnNpb247XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb247XG4gICAgfVxuICAgIHdhbGsoZm4pIHtcbiAgICAgICAgcmV0dXJuIHdhbGsodGhpcywgZm4pO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFzZUVycm9yID0gQmFzZUVycm9yO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VFcnJvciwgXCJkZWZhdWx0U3RhdGljT3B0aW9uc1wiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IHtcbiAgICAgICAgZG9jc09yaWdpbjogJ2h0dHBzOi8vb3hsaWIuc2gnLFxuICAgICAgICBzaG93VmVyc2lvbjogZmFsc2UsXG4gICAgICAgIHZlcnNpb246IGBveEAkeygwLCBlcnJvcnNfanNfMS5nZXRWZXJzaW9uKSgpfWAsXG4gICAgfVxufSk7XG4oKCkgPT4ge1xuICAgIEJhc2VFcnJvci5zZXRTdGF0aWNPcHRpb25zKEJhc2VFcnJvci5kZWZhdWx0U3RhdGljT3B0aW9ucyk7XG59KSgpO1xuZnVuY3Rpb24gd2FsayhlcnIsIGZuKSB7XG4gICAgaWYgKGZuPy4oZXJyKSlcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICBpZiAoZXJyICYmIHR5cGVvZiBlcnIgPT09ICdvYmplY3QnICYmICdjYXVzZScgaW4gZXJyICYmIGVyci5jYXVzZSlcbiAgICAgICAgcmV0dXJuIHdhbGsoZXJyLmNhdXNlLCBmbik7XG4gICAgcmV0dXJuIGZuID8gbnVsbCA6IGVycjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVycm9ycy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJCYXNlRXJyb3IiLCJlcnJvcnNfanNfMSIsInJlcXVpcmUiLCJFcnJvciIsInNldFN0YXRpY09wdGlvbnMiLCJvcHRpb25zIiwicHJvdG90eXBlIiwiZG9jc09yaWdpbiIsInNob3dWZXJzaW9uIiwidmVyc2lvbiIsImNvbnN0cnVjdG9yIiwic2hvcnRNZXNzYWdlIiwiZGV0YWlscyIsImNhdXNlIiwibWVzc2FnZSIsImRvY3NQYXRoIiwiZG9jc0Jhc2VVcmwiLCJkb2NzIiwiQm9vbGVhbiIsIm1ldGFNZXNzYWdlcyIsInVuZGVmaW5lZCIsImZpbHRlciIsIngiLCJqb2luIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwid2FsayIsImZuIiwiZ2V0VmVyc2lvbiIsImRlZmF1bHRTdGF0aWNPcHRpb25zIiwiZXJyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_cjs/core/Errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_cjs/core/Hash.js":
/*!*******************************************!*\
  !*** ./node_modules/ox/_cjs/core/Hash.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.keccak256 = keccak256;\nexports.ripemd160 = ripemd160;\nexports.sha256 = sha256;\nexports.validate = validate;\nconst ripemd160_1 = __webpack_require__(/*! @noble/hashes/ripemd160 */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/ripemd160.js\");\nconst sha3_1 = __webpack_require__(/*! @noble/hashes/sha3 */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/sha3.js\");\nconst sha256_1 = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/sha256.js\");\nconst Bytes = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/./node_modules/ox/_cjs/core/Bytes.js\");\nconst Hex = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_cjs/core/Hex.js\");\nfunction keccak256(value, options = {}) {\n    const { as = typeof value === \"string\" ? \"Hex\" : \"Bytes\" } = options;\n    const bytes = (0, sha3_1.keccak_256)(Bytes.from(value));\n    if (as === \"Bytes\") return bytes;\n    return Hex.fromBytes(bytes);\n}\nfunction ripemd160(value, options = {}) {\n    const { as = typeof value === \"string\" ? \"Hex\" : \"Bytes\" } = options;\n    const bytes = (0, ripemd160_1.ripemd160)(Bytes.from(value));\n    if (as === \"Bytes\") return bytes;\n    return Hex.fromBytes(bytes);\n}\nfunction sha256(value, options = {}) {\n    const { as = typeof value === \"string\" ? \"Hex\" : \"Bytes\" } = options;\n    const bytes = (0, sha256_1.sha256)(Bytes.from(value));\n    if (as === \"Bytes\") return bytes;\n    return Hex.fromBytes(bytes);\n}\nfunction validate(value) {\n    return Hex.validate(value) && Hex.size(value) === 32;\n} //# sourceMappingURL=Hash.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2Nqcy9jb3JlL0hhc2guanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGlCQUFpQixHQUFHRTtBQUNwQkYsaUJBQWlCLEdBQUdHO0FBQ3BCSCxjQUFjLEdBQUdJO0FBQ2pCSixnQkFBZ0IsR0FBR0s7QUFDbkIsTUFBTUMsY0FBY0MsbUJBQU9BLENBQUMsZ0dBQXlCO0FBQ3JELE1BQU1DLFNBQVNELG1CQUFPQSxDQUFDLHNGQUFvQjtBQUMzQyxNQUFNRSxXQUFXRixtQkFBT0EsQ0FBQywwRkFBc0I7QUFDL0MsTUFBTUcsUUFBUUgsbUJBQU9BLENBQUMsOERBQVk7QUFDbEMsTUFBTUksTUFBTUosbUJBQU9BLENBQUMsMERBQVU7QUFDOUIsU0FBU0wsVUFBVUQsS0FBSyxFQUFFVyxVQUFVLENBQUMsQ0FBQztJQUNsQyxNQUFNLEVBQUVDLEtBQUssT0FBT1osVUFBVSxXQUFXLFFBQVEsT0FBTyxFQUFFLEdBQUdXO0lBQzdELE1BQU1FLFFBQVEsQ0FBQyxHQUFHTixPQUFPTyxVQUFVLEVBQUVMLE1BQU1NLElBQUksQ0FBQ2Y7SUFDaEQsSUFBSVksT0FBTyxTQUNQLE9BQU9DO0lBQ1gsT0FBT0gsSUFBSU0sU0FBUyxDQUFDSDtBQUN6QjtBQUNBLFNBQVNYLFVBQVVGLEtBQUssRUFBRVcsVUFBVSxDQUFDLENBQUM7SUFDbEMsTUFBTSxFQUFFQyxLQUFLLE9BQU9aLFVBQVUsV0FBVyxRQUFRLE9BQU8sRUFBRSxHQUFHVztJQUM3RCxNQUFNRSxRQUFRLENBQUMsR0FBR1IsWUFBWUgsU0FBUyxFQUFFTyxNQUFNTSxJQUFJLENBQUNmO0lBQ3BELElBQUlZLE9BQU8sU0FDUCxPQUFPQztJQUNYLE9BQU9ILElBQUlNLFNBQVMsQ0FBQ0g7QUFDekI7QUFDQSxTQUFTVixPQUFPSCxLQUFLLEVBQUVXLFVBQVUsQ0FBQyxDQUFDO0lBQy9CLE1BQU0sRUFBRUMsS0FBSyxPQUFPWixVQUFVLFdBQVcsUUFBUSxPQUFPLEVBQUUsR0FBR1c7SUFDN0QsTUFBTUUsUUFBUSxDQUFDLEdBQUdMLFNBQVNMLE1BQU0sRUFBRU0sTUFBTU0sSUFBSSxDQUFDZjtJQUM5QyxJQUFJWSxPQUFPLFNBQ1AsT0FBT0M7SUFDWCxPQUFPSCxJQUFJTSxTQUFTLENBQUNIO0FBQ3pCO0FBQ0EsU0FBU1QsU0FBU0osS0FBSztJQUNuQixPQUFPVSxJQUFJTixRQUFRLENBQUNKLFVBQVVVLElBQUlPLElBQUksQ0FBQ2pCLFdBQVc7QUFDdEQsRUFDQSxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGF3LXdvcmtzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L19janMvY29yZS9IYXNoLmpzPzZjNTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmtlY2NhazI1NiA9IGtlY2NhazI1NjtcbmV4cG9ydHMucmlwZW1kMTYwID0gcmlwZW1kMTYwO1xuZXhwb3J0cy5zaGEyNTYgPSBzaGEyNTY7XG5leHBvcnRzLnZhbGlkYXRlID0gdmFsaWRhdGU7XG5jb25zdCByaXBlbWQxNjBfMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL3JpcGVtZDE2MFwiKTtcbmNvbnN0IHNoYTNfMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL3NoYTNcIik7XG5jb25zdCBzaGEyNTZfMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL3NoYTI1NlwiKTtcbmNvbnN0IEJ5dGVzID0gcmVxdWlyZShcIi4vQnl0ZXMuanNcIik7XG5jb25zdCBIZXggPSByZXF1aXJlKFwiLi9IZXguanNcIik7XG5mdW5jdGlvbiBrZWNjYWsyNTYodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgYXMgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gJ0hleCcgOiAnQnl0ZXMnIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJ5dGVzID0gKDAsIHNoYTNfMS5rZWNjYWtfMjU2KShCeXRlcy5mcm9tKHZhbHVlKSk7XG4gICAgaWYgKGFzID09PSAnQnl0ZXMnKVxuICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgcmV0dXJuIEhleC5mcm9tQnl0ZXMoYnl0ZXMpO1xufVxuZnVuY3Rpb24gcmlwZW1kMTYwKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGFzID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/ICdIZXgnIDogJ0J5dGVzJyB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBieXRlcyA9ICgwLCByaXBlbWQxNjBfMS5yaXBlbWQxNjApKEJ5dGVzLmZyb20odmFsdWUpKTtcbiAgICBpZiAoYXMgPT09ICdCeXRlcycpXG4gICAgICAgIHJldHVybiBieXRlcztcbiAgICByZXR1cm4gSGV4LmZyb21CeXRlcyhieXRlcyk7XG59XG5mdW5jdGlvbiBzaGEyNTYodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgYXMgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gJ0hleCcgOiAnQnl0ZXMnIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJ5dGVzID0gKDAsIHNoYTI1Nl8xLnNoYTI1NikoQnl0ZXMuZnJvbSh2YWx1ZSkpO1xuICAgIGlmIChhcyA9PT0gJ0J5dGVzJylcbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIHJldHVybiBIZXguZnJvbUJ5dGVzKGJ5dGVzKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgcmV0dXJuIEhleC52YWxpZGF0ZSh2YWx1ZSkgJiYgSGV4LnNpemUodmFsdWUpID09PSAzMjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUhhc2guanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwia2VjY2FrMjU2IiwicmlwZW1kMTYwIiwic2hhMjU2IiwidmFsaWRhdGUiLCJyaXBlbWQxNjBfMSIsInJlcXVpcmUiLCJzaGEzXzEiLCJzaGEyNTZfMSIsIkJ5dGVzIiwiSGV4Iiwib3B0aW9ucyIsImFzIiwiYnl0ZXMiLCJrZWNjYWtfMjU2IiwiZnJvbSIsImZyb21CeXRlcyIsInNpemUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_cjs/core/Hash.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_cjs/core/Hex.js":
/*!******************************************!*\
  !*** ./node_modules/ox/_cjs/core/Hex.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.SizeExceedsPaddingSizeError = exports.SliceOffsetOutOfBoundsError = exports.SizeOverflowError = exports.InvalidLengthError = exports.InvalidHexValueError = exports.InvalidHexTypeError = exports.InvalidHexBooleanError = exports.IntegerOutOfRangeError = void 0;\nexports.assert = assert;\nexports.concat = concat;\nexports.from = from;\nexports.fromBoolean = fromBoolean;\nexports.fromBytes = fromBytes;\nexports.fromNumber = fromNumber;\nexports.fromString = fromString;\nexports.isEqual = isEqual;\nexports.padLeft = padLeft;\nexports.padRight = padRight;\nexports.random = random;\nexports.slice = slice;\nexports.size = size;\nexports.trimLeft = trimLeft;\nexports.trimRight = trimRight;\nexports.toBigInt = toBigInt;\nexports.toBoolean = toBoolean;\nexports.toBytes = toBytes;\nexports.toNumber = toNumber;\nexports.toString = toString;\nexports.validate = validate;\nconst utils_1 = __webpack_require__(/*! @noble/curves/abstract/utils */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/abstract/utils.js\");\nconst Bytes = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/./node_modules/ox/_cjs/core/Bytes.js\");\nconst Errors = __webpack_require__(/*! ./Errors.js */ \"(ssr)/./node_modules/ox/_cjs/core/Errors.js\");\nconst internal_bytes = __webpack_require__(/*! ./internal/bytes.js */ \"(ssr)/./node_modules/ox/_cjs/core/internal/bytes.js\");\nconst internal = __webpack_require__(/*! ./internal/hex.js */ \"(ssr)/./node_modules/ox/_cjs/core/internal/hex.js\");\nconst Json = __webpack_require__(/*! ./Json.js */ \"(ssr)/./node_modules/ox/_cjs/core/Json.js\");\nconst encoder = new TextEncoder();\nconst hexes = Array.from({\n    length: 256\n}, (_v, i)=>i.toString(16).padStart(2, \"0\"));\nfunction assert(value, options = {}) {\n    const { strict = false } = options;\n    if (!value) throw new InvalidHexTypeError(value);\n    if (typeof value !== \"string\") throw new InvalidHexTypeError(value);\n    if (strict) {\n        if (!/^0x[0-9a-fA-F]*$/.test(value)) throw new InvalidHexValueError(value);\n    }\n    if (!value.startsWith(\"0x\")) throw new InvalidHexValueError(value);\n}\nfunction concat(...values) {\n    return `0x${values.reduce((acc, x)=>acc + x.replace(\"0x\", \"\"), \"\")}`;\n}\nfunction from(value) {\n    if (value instanceof Uint8Array) return fromBytes(value);\n    if (Array.isArray(value)) return fromBytes(new Uint8Array(value));\n    return value;\n}\nfunction fromBoolean(value, options = {}) {\n    const hex = `0x${Number(value)}`;\n    if (typeof options.size === \"number\") {\n        internal.assertSize(hex, options.size);\n        return padLeft(hex, options.size);\n    }\n    return hex;\n}\nfunction fromBytes(value, options = {}) {\n    let string = \"\";\n    for(let i = 0; i < value.length; i++)string += hexes[value[i]];\n    const hex = `0x${string}`;\n    if (typeof options.size === \"number\") {\n        internal.assertSize(hex, options.size);\n        return padRight(hex, options.size);\n    }\n    return hex;\n}\nfunction fromNumber(value, options = {}) {\n    const { signed, size } = options;\n    const value_ = BigInt(value);\n    let maxValue;\n    if (size) {\n        if (signed) maxValue = (1n << BigInt(size) * 8n - 1n) - 1n;\n        else maxValue = 2n ** (BigInt(size) * 8n) - 1n;\n    } else if (typeof value === \"number\") {\n        maxValue = BigInt(Number.MAX_SAFE_INTEGER);\n    }\n    const minValue = typeof maxValue === \"bigint\" && signed ? -maxValue - 1n : 0;\n    if (maxValue && value_ > maxValue || value_ < minValue) {\n        const suffix = typeof value === \"bigint\" ? \"n\" : \"\";\n        throw new IntegerOutOfRangeError({\n            max: maxValue ? `${maxValue}${suffix}` : undefined,\n            min: `${minValue}${suffix}`,\n            signed,\n            size,\n            value: `${value}${suffix}`\n        });\n    }\n    const stringValue = (signed && value_ < 0 ? BigInt.asUintN(size * 8, BigInt(value_)) : value_).toString(16);\n    const hex = `0x${stringValue}`;\n    if (size) return padLeft(hex, size);\n    return hex;\n}\nfunction fromString(value, options = {}) {\n    return fromBytes(encoder.encode(value), options);\n}\nfunction isEqual(hexA, hexB) {\n    return (0, utils_1.equalBytes)(Bytes.fromHex(hexA), Bytes.fromHex(hexB));\n}\nfunction padLeft(value, size) {\n    return internal.pad(value, {\n        dir: \"left\",\n        size\n    });\n}\nfunction padRight(value, size) {\n    return internal.pad(value, {\n        dir: \"right\",\n        size\n    });\n}\nfunction random(length) {\n    return fromBytes(Bytes.random(length));\n}\nfunction slice(value, start, end, options = {}) {\n    const { strict } = options;\n    internal.assertStartOffset(value, start);\n    const value_ = `0x${value.replace(\"0x\", \"\").slice((start ?? 0) * 2, (end ?? value.length) * 2)}`;\n    if (strict) internal.assertEndOffset(value_, start, end);\n    return value_;\n}\nfunction size(value) {\n    return Math.ceil((value.length - 2) / 2);\n}\nfunction trimLeft(value) {\n    return internal.trim(value, {\n        dir: \"left\"\n    });\n}\nfunction trimRight(value) {\n    return internal.trim(value, {\n        dir: \"right\"\n    });\n}\nfunction toBigInt(hex, options = {}) {\n    const { signed } = options;\n    if (options.size) internal.assertSize(hex, options.size);\n    const value = BigInt(hex);\n    if (!signed) return value;\n    const size = (hex.length - 2) / 2;\n    const max_unsigned = (1n << BigInt(size) * 8n) - 1n;\n    const max_signed = max_unsigned >> 1n;\n    if (value <= max_signed) return value;\n    return value - max_unsigned - 1n;\n}\nfunction toBoolean(hex, options = {}) {\n    if (options.size) internal.assertSize(hex, options.size);\n    const hex_ = trimLeft(hex);\n    if (hex_ === \"0x\") return false;\n    if (hex_ === \"0x1\") return true;\n    throw new InvalidHexBooleanError(hex);\n}\nfunction toBytes(hex, options = {}) {\n    return Bytes.fromHex(hex, options);\n}\nfunction toNumber(hex, options = {}) {\n    const { signed, size } = options;\n    if (!signed && !size) return Number(hex);\n    return Number(toBigInt(hex, options));\n}\nfunction toString(hex, options = {}) {\n    const { size } = options;\n    let bytes = Bytes.fromHex(hex);\n    if (size) {\n        internal_bytes.assertSize(bytes, size);\n        bytes = Bytes.trimRight(bytes);\n    }\n    return new TextDecoder().decode(bytes);\n}\nfunction validate(value, options = {}) {\n    const { strict = false } = options;\n    try {\n        assert(value, {\n            strict\n        });\n        return true;\n    } catch  {\n        return false;\n    }\n}\nclass IntegerOutOfRangeError extends Errors.BaseError {\n    constructor({ max, min, signed, size, value }){\n        super(`Number \\`${value}\\` is not in safe${size ? ` ${size * 8}-bit` : \"\"}${signed ? \" signed\" : \" unsigned\"} integer range ${max ? `(\\`${min}\\` to \\`${max}\\`)` : `(above \\`${min}\\`)`}`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Hex.IntegerOutOfRangeError\"\n        });\n    }\n}\nexports.IntegerOutOfRangeError = IntegerOutOfRangeError;\nclass InvalidHexBooleanError extends Errors.BaseError {\n    constructor(hex){\n        super(`Hex value \\`\"${hex}\"\\` is not a valid boolean.`, {\n            metaMessages: [\n                'The hex value must be `\"0x0\"` (false) or `\"0x1\"` (true).'\n            ]\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Hex.InvalidHexBooleanError\"\n        });\n    }\n}\nexports.InvalidHexBooleanError = InvalidHexBooleanError;\nclass InvalidHexTypeError extends Errors.BaseError {\n    constructor(value){\n        super(`Value \\`${typeof value === \"object\" ? Json.stringify(value) : value}\\` of type \\`${typeof value}\\` is an invalid hex type.`, {\n            metaMessages: [\n                'Hex types must be represented as `\"0x${string}\"`.'\n            ]\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Hex.InvalidHexTypeError\"\n        });\n    }\n}\nexports.InvalidHexTypeError = InvalidHexTypeError;\nclass InvalidHexValueError extends Errors.BaseError {\n    constructor(value){\n        super(`Value \\`${value}\\` is an invalid hex value.`, {\n            metaMessages: [\n                'Hex values must start with `\"0x\"` and contain only hexadecimal characters (0-9, a-f, A-F).'\n            ]\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Hex.InvalidHexValueError\"\n        });\n    }\n}\nexports.InvalidHexValueError = InvalidHexValueError;\nclass InvalidLengthError extends Errors.BaseError {\n    constructor(value){\n        super(`Hex value \\`\"${value}\"\\` is an odd length (${value.length - 2} nibbles).`, {\n            metaMessages: [\n                \"It must be an even length.\"\n            ]\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Hex.InvalidLengthError\"\n        });\n    }\n}\nexports.InvalidLengthError = InvalidLengthError;\nclass SizeOverflowError extends Errors.BaseError {\n    constructor({ givenSize, maxSize }){\n        super(`Size cannot exceed \\`${maxSize}\\` bytes. Given size: \\`${givenSize}\\` bytes.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Hex.SizeOverflowError\"\n        });\n    }\n}\nexports.SizeOverflowError = SizeOverflowError;\nclass SliceOffsetOutOfBoundsError extends Errors.BaseError {\n    constructor({ offset, position, size }){\n        super(`Slice ${position === \"start\" ? \"starting\" : \"ending\"} at offset \\`${offset}\\` is out-of-bounds (size: \\`${size}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Hex.SliceOffsetOutOfBoundsError\"\n        });\n    }\n}\nexports.SliceOffsetOutOfBoundsError = SliceOffsetOutOfBoundsError;\nclass SizeExceedsPaddingSizeError extends Errors.BaseError {\n    constructor({ size, targetSize, type }){\n        super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (\\`${size}\\`) exceeds padding size (\\`${targetSize}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Hex.SizeExceedsPaddingSizeError\"\n        });\n    }\n}\nexports.SizeExceedsPaddingSizeError = SizeExceedsPaddingSizeError; //# sourceMappingURL=Hex.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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UUFBUSx3QkFBd0IsRUFBRUQsVUFBVSxTQUFTLENBQUM7UUFDcEZ0RyxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLFFBQVE7WUFDaENnRyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWaEcsT0FBTztRQUNYO0lBQ0o7QUFDSjtBQUNBRCx5QkFBeUIsR0FBR0k7QUFDNUIsTUFBTUQsb0NBQW9DK0IsT0FBTzJELFNBQVM7SUFDdERDLFlBQVksRUFBRVEsTUFBTSxFQUFFQyxRQUFRLEVBQUVqRixJQUFJLEVBQUcsQ0FBRTtRQUNyQyxLQUFLLENBQUMsQ0FBQyxNQUFNLEVBQUVpRixhQUFhLFVBQVUsYUFBYSxTQUFTLGFBQWEsRUFBRUQsT0FBTyw2QkFBNkIsRUFBRWhGLEtBQUssSUFBSSxDQUFDO1FBQzNIeEIsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxRQUFRO1lBQ2hDZ0csWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVmhHLE9BQU87UUFDWDtJQUNKO0FBQ0o7QUFDQUQsbUNBQW1DLEdBQUdHO0FBQ3RDLE1BQU1ELG9DQUFvQ2dDLE9BQU8yRCxTQUFTO0lBQ3REQyxZQUFZLEVBQUV4RSxJQUFJLEVBQUVrRixVQUFVLEVBQUVDLElBQUksRUFBRyxDQUFFO1FBQ3JDLEtBQUssQ0FBQyxDQUFDLEVBQUVBLEtBQUtDLE1BQU0sQ0FBQyxHQUFHQyxXQUFXLEdBQUcsRUFBRUYsS0FDbkNwRixLQUFLLENBQUMsR0FDTnVGLFdBQVcsR0FBRyxTQUFTLEVBQUV0RixLQUFLLDRCQUE0QixFQUFFa0YsV0FBVyxJQUFJLENBQUM7UUFDakYxRyxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLFFBQVE7WUFDaENnRyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWaEcsT0FBTztRQUNYO0lBQ0o7QUFDSjtBQUNBRCxtQ0FBbUMsR0FBR0UsNkJBQ3RDLCtCQUErQiIsInNvdXJjZXMiOlsid2VicGFjazovL2NsYXctd29ya3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3gvX2Nqcy9jb3JlL0hleC5qcz9iZjg0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TaXplRXhjZWVkc1BhZGRpbmdTaXplRXJyb3IgPSBleHBvcnRzLlNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvciA9IGV4cG9ydHMuU2l6ZU92ZXJmbG93RXJyb3IgPSBleHBvcnRzLkludmFsaWRMZW5ndGhFcnJvciA9IGV4cG9ydHMuSW52YWxpZEhleFZhbHVlRXJyb3IgPSBleHBvcnRzLkludmFsaWRIZXhUeXBlRXJyb3IgPSBleHBvcnRzLkludmFsaWRIZXhCb29sZWFuRXJyb3IgPSBleHBvcnRzLkludGVnZXJPdXRPZlJhbmdlRXJyb3IgPSB2b2lkIDA7XG5leHBvcnRzLmFzc2VydCA9IGFzc2VydDtcbmV4cG9ydHMuY29uY2F0ID0gY29uY2F0O1xuZXhwb3J0cy5mcm9tID0gZnJvbTtcbmV4cG9ydHMuZnJvbUJvb2xlYW4gPSBmcm9tQm9vbGVhbjtcbmV4cG9ydHMuZnJvbUJ5dGVzID0gZnJvbUJ5dGVzO1xuZXhwb3J0cy5mcm9tTnVtYmVyID0gZnJvbU51bWJlcjtcbmV4cG9ydHMuZnJvbVN0cmluZyA9IGZyb21TdHJpbmc7XG5leHBvcnRzLmlzRXF1YWwgPSBpc0VxdWFsO1xuZXhwb3J0cy5wYWRMZWZ0ID0gcGFkTGVmdDtcbmV4cG9ydHMucGFkUmlnaHQgPSBwYWRSaWdodDtcbmV4cG9ydHMucmFuZG9tID0gcmFuZG9tO1xuZXhwb3J0cy5zbGljZSA9IHNsaWNlO1xuZXhwb3J0cy5zaXplID0gc2l6ZTtcbmV4cG9ydHMudHJpbUxlZnQgPSB0cmltTGVmdDtcbmV4cG9ydHMudHJpbVJpZ2h0ID0gdHJpbVJpZ2h0O1xuZXhwb3J0cy50b0JpZ0ludCA9IHRvQmlnSW50O1xuZXhwb3J0cy50b0Jvb2xlYW4gPSB0b0Jvb2xlYW47XG5leHBvcnRzLnRvQnl0ZXMgPSB0b0J5dGVzO1xuZXhwb3J0cy50b051bWJlciA9IHRvTnVtYmVyO1xuZXhwb3J0cy50b1N0cmluZyA9IHRvU3RyaW5nO1xuZXhwb3J0cy52YWxpZGF0ZSA9IHZhbGlkYXRlO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJAbm9ibGUvY3VydmVzL2Fic3RyYWN0L3V0aWxzXCIpO1xuY29uc3QgQnl0ZXMgPSByZXF1aXJlKFwiLi9CeXRlcy5qc1wiKTtcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoXCIuL0Vycm9ycy5qc1wiKTtcbmNvbnN0IGludGVybmFsX2J5dGVzID0gcmVxdWlyZShcIi4vaW50ZXJuYWwvYnl0ZXMuanNcIik7XG5jb25zdCBpbnRlcm5hbCA9IHJlcXVpcmUoXCIuL2ludGVybmFsL2hleC5qc1wiKTtcbmNvbnN0IEpzb24gPSByZXF1aXJlKFwiLi9Kc29uLmpzXCIpO1xuY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuY29uc3QgaGV4ZXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyNTYgfSwgKF92LCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbmZ1bmN0aW9uIGFzc2VydCh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzdHJpY3QgPSBmYWxzZSB9ID0gb3B0aW9ucztcbiAgICBpZiAoIXZhbHVlKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEhleFR5cGVFcnJvcih2YWx1ZSk7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkSGV4VHlwZUVycm9yKHZhbHVlKTtcbiAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgIGlmICghL14weFswLTlhLWZBLUZdKiQvLnRlc3QodmFsdWUpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRIZXhWYWx1ZUVycm9yKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKCF2YWx1ZS5zdGFydHNXaXRoKCcweCcpKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEhleFZhbHVlRXJyb3IodmFsdWUpO1xufVxuZnVuY3Rpb24gY29uY2F0KC4uLnZhbHVlcykge1xuICAgIHJldHVybiBgMHgke3ZhbHVlcy5yZWR1Y2UoKGFjYywgeCkgPT4gYWNjICsgeC5yZXBsYWNlKCcweCcsICcnKSwgJycpfWA7XG59XG5mdW5jdGlvbiBmcm9tKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSlcbiAgICAgICAgcmV0dXJuIGZyb21CeXRlcyh2YWx1ZSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKVxuICAgICAgICByZXR1cm4gZnJvbUJ5dGVzKG5ldyBVaW50OEFycmF5KHZhbHVlKSk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gZnJvbUJvb2xlYW4odmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGhleCA9IGAweCR7TnVtYmVyKHZhbHVlKX1gO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5zaXplID09PSAnbnVtYmVyJykge1xuICAgICAgICBpbnRlcm5hbC5hc3NlcnRTaXplKGhleCwgb3B0aW9ucy5zaXplKTtcbiAgICAgICAgcmV0dXJuIHBhZExlZnQoaGV4LCBvcHRpb25zLnNpemUpO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuZnVuY3Rpb24gZnJvbUJ5dGVzKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBsZXQgc3RyaW5nID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKylcbiAgICAgICAgc3RyaW5nICs9IGhleGVzW3ZhbHVlW2ldXTtcbiAgICBjb25zdCBoZXggPSBgMHgke3N0cmluZ31gO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5zaXplID09PSAnbnVtYmVyJykge1xuICAgICAgICBpbnRlcm5hbC5hc3NlcnRTaXplKGhleCwgb3B0aW9ucy5zaXplKTtcbiAgICAgICAgcmV0dXJuIHBhZFJpZ2h0KGhleCwgb3B0aW9ucy5zaXplKTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbmZ1bmN0aW9uIGZyb21OdW1iZXIodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2lnbmVkLCBzaXplIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHZhbHVlXyA9IEJpZ0ludCh2YWx1ZSk7XG4gICAgbGV0IG1heFZhbHVlO1xuICAgIGlmIChzaXplKSB7XG4gICAgICAgIGlmIChzaWduZWQpXG4gICAgICAgICAgICBtYXhWYWx1ZSA9ICgxbiA8PCAoQmlnSW50KHNpemUpICogOG4gLSAxbikpIC0gMW47XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG1heFZhbHVlID0gMm4gKiogKEJpZ0ludChzaXplKSAqIDhuKSAtIDFuO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIG1heFZhbHVlID0gQmlnSW50KE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKTtcbiAgICB9XG4gICAgY29uc3QgbWluVmFsdWUgPSB0eXBlb2YgbWF4VmFsdWUgPT09ICdiaWdpbnQnICYmIHNpZ25lZCA/IC1tYXhWYWx1ZSAtIDFuIDogMDtcbiAgICBpZiAoKG1heFZhbHVlICYmIHZhbHVlXyA+IG1heFZhbHVlKSB8fCB2YWx1ZV8gPCBtaW5WYWx1ZSkge1xuICAgICAgICBjb25zdCBzdWZmaXggPSB0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnID8gJ24nIDogJyc7XG4gICAgICAgIHRocm93IG5ldyBJbnRlZ2VyT3V0T2ZSYW5nZUVycm9yKHtcbiAgICAgICAgICAgIG1heDogbWF4VmFsdWUgPyBgJHttYXhWYWx1ZX0ke3N1ZmZpeH1gIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbWluOiBgJHttaW5WYWx1ZX0ke3N1ZmZpeH1gLFxuICAgICAgICAgICAgc2lnbmVkLFxuICAgICAgICAgICAgc2l6ZSxcbiAgICAgICAgICAgIHZhbHVlOiBgJHt2YWx1ZX0ke3N1ZmZpeH1gLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3Qgc3RyaW5nVmFsdWUgPSAoc2lnbmVkICYmIHZhbHVlXyA8IDAgPyBCaWdJbnQuYXNVaW50TihzaXplICogOCwgQmlnSW50KHZhbHVlXykpIDogdmFsdWVfKS50b1N0cmluZygxNik7XG4gICAgY29uc3QgaGV4ID0gYDB4JHtzdHJpbmdWYWx1ZX1gO1xuICAgIGlmIChzaXplKVxuICAgICAgICByZXR1cm4gcGFkTGVmdChoZXgsIHNpemUpO1xuICAgIHJldHVybiBoZXg7XG59XG5mdW5jdGlvbiBmcm9tU3RyaW5nKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gZnJvbUJ5dGVzKGVuY29kZXIuZW5jb2RlKHZhbHVlKSwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBpc0VxdWFsKGhleEEsIGhleEIpIHtcbiAgICByZXR1cm4gKDAsIHV0aWxzXzEuZXF1YWxCeXRlcykoQnl0ZXMuZnJvbUhleChoZXhBKSwgQnl0ZXMuZnJvbUhleChoZXhCKSk7XG59XG5mdW5jdGlvbiBwYWRMZWZ0KHZhbHVlLCBzaXplKSB7XG4gICAgcmV0dXJuIGludGVybmFsLnBhZCh2YWx1ZSwgeyBkaXI6ICdsZWZ0Jywgc2l6ZSB9KTtcbn1cbmZ1bmN0aW9uIHBhZFJpZ2h0KHZhbHVlLCBzaXplKSB7XG4gICAgcmV0dXJuIGludGVybmFsLnBhZCh2YWx1ZSwgeyBkaXI6ICdyaWdodCcsIHNpemUgfSk7XG59XG5mdW5jdGlvbiByYW5kb20obGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZyb21CeXRlcyhCeXRlcy5yYW5kb20obGVuZ3RoKSk7XG59XG5mdW5jdGlvbiBzbGljZSh2YWx1ZSwgc3RhcnQsIGVuZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzdHJpY3QgfSA9IG9wdGlvbnM7XG4gICAgaW50ZXJuYWwuYXNzZXJ0U3RhcnRPZmZzZXQodmFsdWUsIHN0YXJ0KTtcbiAgICBjb25zdCB2YWx1ZV8gPSBgMHgke3ZhbHVlXG4gICAgICAgIC5yZXBsYWNlKCcweCcsICcnKVxuICAgICAgICAuc2xpY2UoKHN0YXJ0ID8/IDApICogMiwgKGVuZCA/PyB2YWx1ZS5sZW5ndGgpICogMil9YDtcbiAgICBpZiAoc3RyaWN0KVxuICAgICAgICBpbnRlcm5hbC5hc3NlcnRFbmRPZmZzZXQodmFsdWVfLCBzdGFydCwgZW5kKTtcbiAgICByZXR1cm4gdmFsdWVfO1xufVxuZnVuY3Rpb24gc2l6ZSh2YWx1ZSkge1xuICAgIHJldHVybiBNYXRoLmNlaWwoKHZhbHVlLmxlbmd0aCAtIDIpIC8gMik7XG59XG5mdW5jdGlvbiB0cmltTGVmdCh2YWx1ZSkge1xuICAgIHJldHVybiBpbnRlcm5hbC50cmltKHZhbHVlLCB7IGRpcjogJ2xlZnQnIH0pO1xufVxuZnVuY3Rpb24gdHJpbVJpZ2h0KHZhbHVlKSB7XG4gICAgcmV0dXJuIGludGVybmFsLnRyaW0odmFsdWUsIHsgZGlyOiAncmlnaHQnIH0pO1xufVxuZnVuY3Rpb24gdG9CaWdJbnQoaGV4LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpZ25lZCB9ID0gb3B0aW9ucztcbiAgICBpZiAob3B0aW9ucy5zaXplKVxuICAgICAgICBpbnRlcm5hbC5hc3NlcnRTaXplKGhleCwgb3B0aW9ucy5zaXplKTtcbiAgICBjb25zdCB2YWx1ZSA9IEJpZ0ludChoZXgpO1xuICAgIGlmICghc2lnbmVkKVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgY29uc3Qgc2l6ZSA9IChoZXgubGVuZ3RoIC0gMikgLyAyO1xuICAgIGNvbnN0IG1heF91bnNpZ25lZCA9ICgxbiA8PCAoQmlnSW50KHNpemUpICogOG4pKSAtIDFuO1xuICAgIGNvbnN0IG1heF9zaWduZWQgPSBtYXhfdW5zaWduZWQgPj4gMW47XG4gICAgaWYgKHZhbHVlIDw9IG1heF9zaWduZWQpXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICByZXR1cm4gdmFsdWUgLSBtYXhfdW5zaWduZWQgLSAxbjtcbn1cbmZ1bmN0aW9uIHRvQm9vbGVhbihoZXgsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmIChvcHRpb25zLnNpemUpXG4gICAgICAgIGludGVybmFsLmFzc2VydFNpemUoaGV4LCBvcHRpb25zLnNpemUpO1xuICAgIGNvbnN0IGhleF8gPSB0cmltTGVmdChoZXgpO1xuICAgIGlmIChoZXhfID09PSAnMHgnKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGhleF8gPT09ICcweDEnKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEhleEJvb2xlYW5FcnJvcihoZXgpO1xufVxuZnVuY3Rpb24gdG9CeXRlcyhoZXgsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBCeXRlcy5mcm9tSGV4KGhleCwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiB0b051bWJlcihoZXgsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2lnbmVkLCBzaXplIH0gPSBvcHRpb25zO1xuICAgIGlmICghc2lnbmVkICYmICFzaXplKVxuICAgICAgICByZXR1cm4gTnVtYmVyKGhleCk7XG4gICAgcmV0dXJuIE51bWJlcih0b0JpZ0ludChoZXgsIG9wdGlvbnMpKTtcbn1cbmZ1bmN0aW9uIHRvU3RyaW5nKGhleCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzaXplIH0gPSBvcHRpb25zO1xuICAgIGxldCBieXRlcyA9IEJ5dGVzLmZyb21IZXgoaGV4KTtcbiAgICBpZiAoc2l6ZSkge1xuICAgICAgICBpbnRlcm5hbF9ieXRlcy5hc3NlcnRTaXplKGJ5dGVzLCBzaXplKTtcbiAgICAgICAgYnl0ZXMgPSBCeXRlcy50cmltUmlnaHQoYnl0ZXMpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGJ5dGVzKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHN0cmljdCA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICAgIHRyeSB7XG4gICAgICAgIGFzc2VydCh2YWx1ZSwgeyBzdHJpY3QgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5jbGFzcyBJbnRlZ2VyT3V0T2ZSYW5nZUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBtYXgsIG1pbiwgc2lnbmVkLCBzaXplLCB2YWx1ZSwgfSkge1xuICAgICAgICBzdXBlcihgTnVtYmVyIFxcYCR7dmFsdWV9XFxgIGlzIG5vdCBpbiBzYWZlJHtzaXplID8gYCAke3NpemUgKiA4fS1iaXRgIDogJyd9JHtzaWduZWQgPyAnIHNpZ25lZCcgOiAnIHVuc2lnbmVkJ30gaW50ZWdlciByYW5nZSAke21heCA/IGAoXFxgJHttaW59XFxgIHRvIFxcYCR7bWF4fVxcYClgIDogYChhYm92ZSBcXGAke21pbn1cXGApYH1gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0hleC5JbnRlZ2VyT3V0T2ZSYW5nZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkludGVnZXJPdXRPZlJhbmdlRXJyb3IgPSBJbnRlZ2VyT3V0T2ZSYW5nZUVycm9yO1xuY2xhc3MgSW52YWxpZEhleEJvb2xlYW5FcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGhleCkge1xuICAgICAgICBzdXBlcihgSGV4IHZhbHVlIFxcYFwiJHtoZXh9XCJcXGAgaXMgbm90IGEgdmFsaWQgYm9vbGVhbi5gLCB7XG4gICAgICAgICAgICBtZXRhTWVzc2FnZXM6IFtcbiAgICAgICAgICAgICAgICAnVGhlIGhleCB2YWx1ZSBtdXN0IGJlIGBcIjB4MFwiYCAoZmFsc2UpIG9yIGBcIjB4MVwiYCAodHJ1ZSkuJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnSGV4LkludmFsaWRIZXhCb29sZWFuRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuSW52YWxpZEhleEJvb2xlYW5FcnJvciA9IEludmFsaWRIZXhCb29sZWFuRXJyb3I7XG5jbGFzcyBJbnZhbGlkSGV4VHlwZUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgc3VwZXIoYFZhbHVlIFxcYCR7dHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyA/IEpzb24uc3RyaW5naWZ5KHZhbHVlKSA6IHZhbHVlfVxcYCBvZiB0eXBlIFxcYCR7dHlwZW9mIHZhbHVlfVxcYCBpcyBhbiBpbnZhbGlkIGhleCB0eXBlLmAsIHtcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogWydIZXggdHlwZXMgbXVzdCBiZSByZXByZXNlbnRlZCBhcyBgXCIweCR7c3RyaW5nfVwiYC4nXSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdIZXguSW52YWxpZEhleFR5cGVFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5JbnZhbGlkSGV4VHlwZUVycm9yID0gSW52YWxpZEhleFR5cGVFcnJvcjtcbmNsYXNzIEludmFsaWRIZXhWYWx1ZUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgc3VwZXIoYFZhbHVlIFxcYCR7dmFsdWV9XFxgIGlzIGFuIGludmFsaWQgaGV4IHZhbHVlLmAsIHtcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogW1xuICAgICAgICAgICAgICAgICdIZXggdmFsdWVzIG11c3Qgc3RhcnQgd2l0aCBgXCIweFwiYCBhbmQgY29udGFpbiBvbmx5IGhleGFkZWNpbWFsIGNoYXJhY3RlcnMgKDAtOSwgYS1mLCBBLUYpLicsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0hleC5JbnZhbGlkSGV4VmFsdWVFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5JbnZhbGlkSGV4VmFsdWVFcnJvciA9IEludmFsaWRIZXhWYWx1ZUVycm9yO1xuY2xhc3MgSW52YWxpZExlbmd0aEVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgc3VwZXIoYEhleCB2YWx1ZSBcXGBcIiR7dmFsdWV9XCJcXGAgaXMgYW4gb2RkIGxlbmd0aCAoJHt2YWx1ZS5sZW5ndGggLSAyfSBuaWJibGVzKS5gLCB7XG4gICAgICAgICAgICBtZXRhTWVzc2FnZXM6IFsnSXQgbXVzdCBiZSBhbiBldmVuIGxlbmd0aC4nXSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdIZXguSW52YWxpZExlbmd0aEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkludmFsaWRMZW5ndGhFcnJvciA9IEludmFsaWRMZW5ndGhFcnJvcjtcbmNsYXNzIFNpemVPdmVyZmxvd0Vycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBnaXZlblNpemUsIG1heFNpemUgfSkge1xuICAgICAgICBzdXBlcihgU2l6ZSBjYW5ub3QgZXhjZWVkIFxcYCR7bWF4U2l6ZX1cXGAgYnl0ZXMuIEdpdmVuIHNpemU6IFxcYCR7Z2l2ZW5TaXplfVxcYCBieXRlcy5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0hleC5TaXplT3ZlcmZsb3dFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5TaXplT3ZlcmZsb3dFcnJvciA9IFNpemVPdmVyZmxvd0Vycm9yO1xuY2xhc3MgU2xpY2VPZmZzZXRPdXRPZkJvdW5kc0Vycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBvZmZzZXQsIHBvc2l0aW9uLCBzaXplLCB9KSB7XG4gICAgICAgIHN1cGVyKGBTbGljZSAke3Bvc2l0aW9uID09PSAnc3RhcnQnID8gJ3N0YXJ0aW5nJyA6ICdlbmRpbmcnfSBhdCBvZmZzZXQgXFxgJHtvZmZzZXR9XFxgIGlzIG91dC1vZi1ib3VuZHMgKHNpemU6IFxcYCR7c2l6ZX1cXGApLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnSGV4LlNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5TbGljZU9mZnNldE91dE9mQm91bmRzRXJyb3IgPSBTbGljZU9mZnNldE91dE9mQm91bmRzRXJyb3I7XG5jbGFzcyBTaXplRXhjZWVkc1BhZGRpbmdTaXplRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHNpemUsIHRhcmdldFNpemUsIHR5cGUsIH0pIHtcbiAgICAgICAgc3VwZXIoYCR7dHlwZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKX0ke3R5cGVcbiAgICAgICAgICAgIC5zbGljZSgxKVxuICAgICAgICAgICAgLnRvTG93ZXJDYXNlKCl9IHNpemUgKFxcYCR7c2l6ZX1cXGApIGV4Y2VlZHMgcGFkZGluZyBzaXplIChcXGAke3RhcmdldFNpemV9XFxgKS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0hleC5TaXplRXhjZWVkc1BhZGRpbmdTaXplRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuU2l6ZUV4Y2VlZHNQYWRkaW5nU2l6ZUVycm9yID0gU2l6ZUV4Y2VlZHNQYWRkaW5nU2l6ZUVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlNpemVFeGNlZWRzUGFkZGluZ1NpemVFcnJvciIsIlNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvciIsIlNpemVPdmVyZmxvd0Vycm9yIiwiSW52YWxpZExlbmd0aEVycm9yIiwiSW52YWxpZEhleFZhbHVlRXJyb3IiLCJJbnZhbGlkSGV4VHlwZUVycm9yIiwiSW52YWxpZEhleEJvb2xlYW5FcnJvciIsIkludGVnZXJPdXRPZlJhbmdlRXJyb3IiLCJhc3NlcnQiLCJjb25jYXQiLCJmcm9tIiwiZnJvbUJvb2xlYW4iLCJmcm9tQnl0ZXMiLCJmcm9tTnVtYmVyIiwiZnJvbVN0cmluZyIsImlzRXF1YWwiLCJwYWRMZWZ0IiwicGFkUmlnaHQiLCJyYW5kb20iLCJzbGljZSIsInNpemUiLCJ0cmltTGVmdCIsInRyaW1SaWdodCIsInRvQmlnSW50IiwidG9Cb29sZWFuIiwidG9CeXRlcyIsInRvTnVtYmVyIiwidG9TdHJpbmciLCJ2YWxpZGF0ZSIsInV0aWxzXzEiLCJyZXF1aXJlIiwiQnl0ZXMiLCJFcnJvcnMiLCJpbnRlcm5hbF9ieXRlcyIsImludGVybmFsIiwiSnNvbiIsImVuY29kZXIiLCJUZXh0RW5jb2RlciIsImhleGVzIiwiQXJyYXkiLCJsZW5ndGgiLCJfdiIsImkiLCJwYWRTdGFydCIsIm9wdGlvbnMiLCJzdHJpY3QiLCJ0ZXN0Iiwic3RhcnRzV2l0aCIsInZhbHVlcyIsInJlZHVjZSIsImFjYyIsIngiLCJyZXBsYWNlIiwiVWludDhBcnJheSIsImlzQXJyYXkiLCJoZXgiLCJOdW1iZXIiLCJhc3NlcnRTaXplIiwic3RyaW5nIiwic2lnbmVkIiwidmFsdWVfIiwiQmlnSW50IiwibWF4VmFsdWUiLCJNQVhfU0FGRV9JTlRFR0VSIiwibWluVmFsdWUiLCJzdWZmaXgiLCJtYXgiLCJ1bmRlZmluZWQiLCJtaW4iLCJzdHJpbmdWYWx1ZSIsImFzVWludE4iLCJlbmNvZGUiLCJoZXhBIiwiaGV4QiIsImVxdWFsQnl0ZXMiLCJmcm9tSGV4IiwicGFkIiwiZGlyIiwic3RhcnQiLCJlbmQiLCJhc3NlcnRTdGFydE9mZnNldCIsImFzc2VydEVuZE9mZnNldCIsIk1hdGgiLCJjZWlsIiwidHJpbSIsIm1heF91bnNpZ25lZCIsIm1heF9zaWduZWQiLCJoZXhfIiwiYnl0ZXMiLCJUZXh0RGVjb2RlciIsImRlY29kZSIsIkJhc2VFcnJvciIsImNvbnN0cnVjdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwibWV0YU1lc3NhZ2VzIiwic3RyaW5naWZ5IiwiZ2l2ZW5TaXplIiwibWF4U2l6ZSIsIm9mZnNldCIsInBvc2l0aW9uIiwidGFyZ2V0U2l6ZSIsInR5cGUiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsInRvTG93ZXJDYXNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_cjs/core/Hex.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_cjs/core/Json.js":
/*!*******************************************!*\
  !*** ./node_modules/ox/_cjs/core/Json.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.parse = parse;\nexports.stringify = stringify;\nconst bigIntSuffix = \"#__bigint\";\nfunction parse(string, reviver) {\n    return JSON.parse(string, (key, value_)=>{\n        const value = value_;\n        if (typeof value === \"string\" && value.endsWith(bigIntSuffix)) return BigInt(value.slice(0, -bigIntSuffix.length));\n        return typeof reviver === \"function\" ? reviver(key, value) : value;\n    });\n}\nfunction stringify(value, replacer, space) {\n    return JSON.stringify(value, (key, value)=>{\n        if (typeof replacer === \"function\") return replacer(key, value);\n        if (typeof value === \"bigint\") return value.toString() + bigIntSuffix;\n        return value;\n    }, space);\n} //# sourceMappingURL=Json.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2Nqcy9jb3JlL0pzb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGFBQWEsR0FBR0U7QUFDaEJGLGlCQUFpQixHQUFHRztBQUNwQixNQUFNQyxlQUFlO0FBQ3JCLFNBQVNGLE1BQU1HLE1BQU0sRUFBRUMsT0FBTztJQUMxQixPQUFPQyxLQUFLTCxLQUFLLENBQUNHLFFBQVEsQ0FBQ0csS0FBS0M7UUFDNUIsTUFBTVIsUUFBUVE7UUFDZCxJQUFJLE9BQU9SLFVBQVUsWUFBWUEsTUFBTVMsUUFBUSxDQUFDTixlQUM1QyxPQUFPTyxPQUFPVixNQUFNVyxLQUFLLENBQUMsR0FBRyxDQUFDUixhQUFhUyxNQUFNO1FBQ3JELE9BQU8sT0FBT1AsWUFBWSxhQUFhQSxRQUFRRSxLQUFLUCxTQUFTQTtJQUNqRTtBQUNKO0FBQ0EsU0FBU0UsVUFBVUYsS0FBSyxFQUFFYSxRQUFRLEVBQUVDLEtBQUs7SUFDckMsT0FBT1IsS0FBS0osU0FBUyxDQUFDRixPQUFPLENBQUNPLEtBQUtQO1FBQy9CLElBQUksT0FBT2EsYUFBYSxZQUNwQixPQUFPQSxTQUFTTixLQUFLUDtRQUN6QixJQUFJLE9BQU9BLFVBQVUsVUFDakIsT0FBT0EsTUFBTWUsUUFBUSxLQUFLWjtRQUM5QixPQUFPSDtJQUNYLEdBQUdjO0FBQ1AsRUFDQSxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGF3LXdvcmtzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L19janMvY29yZS9Kc29uLmpzP2E3NmUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG5leHBvcnRzLnN0cmluZ2lmeSA9IHN0cmluZ2lmeTtcbmNvbnN0IGJpZ0ludFN1ZmZpeCA9ICcjX19iaWdpbnQnO1xuZnVuY3Rpb24gcGFyc2Uoc3RyaW5nLCByZXZpdmVyKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2Uoc3RyaW5nLCAoa2V5LCB2YWx1ZV8pID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZV87XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLmVuZHNXaXRoKGJpZ0ludFN1ZmZpeCkpXG4gICAgICAgICAgICByZXR1cm4gQmlnSW50KHZhbHVlLnNsaWNlKDAsIC1iaWdJbnRTdWZmaXgubGVuZ3RoKSk7XG4gICAgICAgIHJldHVybiB0eXBlb2YgcmV2aXZlciA9PT0gJ2Z1bmN0aW9uJyA/IHJldml2ZXIoa2V5LCB2YWx1ZSkgOiB2YWx1ZTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeSh2YWx1ZSwgcmVwbGFjZXIsIHNwYWNlKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlLCAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHJlcGxhY2VyID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VyKGtleSwgdmFsdWUpO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYmlnaW50JylcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpICsgYmlnSW50U3VmZml4O1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSwgc3BhY2UpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SnNvbi5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJwYXJzZSIsInN0cmluZ2lmeSIsImJpZ0ludFN1ZmZpeCIsInN0cmluZyIsInJldml2ZXIiLCJKU09OIiwia2V5IiwidmFsdWVfIiwiZW5kc1dpdGgiLCJCaWdJbnQiLCJzbGljZSIsImxlbmd0aCIsInJlcGxhY2VyIiwic3BhY2UiLCJ0b1N0cmluZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_cjs/core/Json.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_cjs/core/PublicKey.js":
/*!************************************************!*\
  !*** ./node_modules/ox/_cjs/core/PublicKey.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.InvalidSerializedSizeError = exports.InvalidUncompressedPrefixError = exports.InvalidCompressedPrefixError = exports.InvalidPrefixError = exports.InvalidError = void 0;\nexports.assert = assert;\nexports.compress = compress;\nexports.from = from;\nexports.fromBytes = fromBytes;\nexports.fromHex = fromHex;\nexports.toBytes = toBytes;\nexports.toHex = toHex;\nexports.validate = validate;\nconst Bytes = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/./node_modules/ox/_cjs/core/Bytes.js\");\nconst Errors = __webpack_require__(/*! ./Errors.js */ \"(ssr)/./node_modules/ox/_cjs/core/Errors.js\");\nconst Hex = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_cjs/core/Hex.js\");\nconst Json = __webpack_require__(/*! ./Json.js */ \"(ssr)/./node_modules/ox/_cjs/core/Json.js\");\nfunction assert(publicKey, options = {}) {\n    const { compressed } = options;\n    const { prefix, x, y } = publicKey;\n    if (compressed === false || typeof x === \"bigint\" && typeof y === \"bigint\") {\n        if (prefix !== 4) throw new InvalidPrefixError({\n            prefix,\n            cause: new InvalidUncompressedPrefixError()\n        });\n        return;\n    }\n    if (compressed === true || typeof x === \"bigint\" && typeof y === \"undefined\") {\n        if (prefix !== 3 && prefix !== 2) throw new InvalidPrefixError({\n            prefix,\n            cause: new InvalidCompressedPrefixError()\n        });\n        return;\n    }\n    throw new InvalidError({\n        publicKey\n    });\n}\nfunction compress(publicKey) {\n    const { x, y } = publicKey;\n    return {\n        prefix: y % 2n === 0n ? 2 : 3,\n        x\n    };\n}\nfunction from(value) {\n    const publicKey = (()=>{\n        if (Hex.validate(value)) return fromHex(value);\n        if (Bytes.validate(value)) return fromBytes(value);\n        const { prefix, x, y } = value;\n        if (typeof x === \"bigint\" && typeof y === \"bigint\") return {\n            prefix: prefix ?? 0x04,\n            x,\n            y\n        };\n        return {\n            prefix,\n            x\n        };\n    })();\n    assert(publicKey);\n    return publicKey;\n}\nfunction fromBytes(publicKey) {\n    return fromHex(Hex.fromBytes(publicKey));\n}\nfunction fromHex(publicKey) {\n    if (publicKey.length !== 132 && publicKey.length !== 130 && publicKey.length !== 68) throw new InvalidSerializedSizeError({\n        publicKey\n    });\n    if (publicKey.length === 130) {\n        const x = BigInt(Hex.slice(publicKey, 0, 32));\n        const y = BigInt(Hex.slice(publicKey, 32, 64));\n        return {\n            prefix: 4,\n            x,\n            y\n        };\n    }\n    if (publicKey.length === 132) {\n        const prefix = Number(Hex.slice(publicKey, 0, 1));\n        const x = BigInt(Hex.slice(publicKey, 1, 33));\n        const y = BigInt(Hex.slice(publicKey, 33, 65));\n        return {\n            prefix,\n            x,\n            y\n        };\n    }\n    const prefix = Number(Hex.slice(publicKey, 0, 1));\n    const x = BigInt(Hex.slice(publicKey, 1, 33));\n    return {\n        prefix,\n        x\n    };\n}\nfunction toBytes(publicKey, options = {}) {\n    return Bytes.fromHex(toHex(publicKey, options));\n}\nfunction toHex(publicKey, options = {}) {\n    assert(publicKey);\n    const { prefix, x, y } = publicKey;\n    const { includePrefix = true } = options;\n    const publicKey_ = Hex.concat(includePrefix ? Hex.fromNumber(prefix, {\n        size: 1\n    }) : \"0x\", Hex.fromNumber(x, {\n        size: 32\n    }), typeof y === \"bigint\" ? Hex.fromNumber(y, {\n        size: 32\n    }) : \"0x\");\n    return publicKey_;\n}\nfunction validate(publicKey, options = {}) {\n    try {\n        assert(publicKey, options);\n        return true;\n    } catch (_error) {\n        return false;\n    }\n}\nclass InvalidError extends Errors.BaseError {\n    constructor({ publicKey }){\n        super(`Value \\`${Json.stringify(publicKey)}\\` is not a valid public key.`, {\n            metaMessages: [\n                \"Public key must contain:\",\n                \"- an `x` and `prefix` value (compressed)\",\n                \"- an `x`, `y`, and `prefix` value (uncompressed)\"\n            ]\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"PublicKey.InvalidError\"\n        });\n    }\n}\nexports.InvalidError = InvalidError;\nclass InvalidPrefixError extends Errors.BaseError {\n    constructor({ prefix, cause }){\n        super(`Prefix \"${prefix}\" is invalid.`, {\n            cause\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"PublicKey.InvalidPrefixError\"\n        });\n    }\n}\nexports.InvalidPrefixError = InvalidPrefixError;\nclass InvalidCompressedPrefixError extends Errors.BaseError {\n    constructor(){\n        super(\"Prefix must be 2 or 3 for compressed public keys.\");\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"PublicKey.InvalidCompressedPrefixError\"\n        });\n    }\n}\nexports.InvalidCompressedPrefixError = InvalidCompressedPrefixError;\nclass InvalidUncompressedPrefixError extends Errors.BaseError {\n    constructor(){\n        super(\"Prefix must be 4 for uncompressed public keys.\");\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"PublicKey.InvalidUncompressedPrefixError\"\n        });\n    }\n}\nexports.InvalidUncompressedPrefixError = InvalidUncompressedPrefixError;\nclass InvalidSerializedSizeError extends Errors.BaseError {\n    constructor({ publicKey }){\n        super(`Value \\`${publicKey}\\` is an invalid public key size.`, {\n            metaMessages: [\n                \"Expected: 33 bytes (compressed + prefix), 64 bytes (uncompressed) or 65 bytes (uncompressed + prefix).\",\n                `Received ${Hex.size(Hex.from(publicKey))} bytes.`\n            ]\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"PublicKey.InvalidSerializedSizeError\"\n        });\n    }\n}\nexports.InvalidSerializedSizeError = InvalidSerializedSizeError; //# sourceMappingURL=PublicKey.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2Nqcy9jb3JlL1B1YmxpY0tleS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsa0NBQWtDLEdBQUdBLHNDQUFzQyxHQUFHQSxvQ0FBb0MsR0FBR0EsMEJBQTBCLEdBQUdBLG9CQUFvQixHQUFHLEtBQUs7QUFDOUtBLGNBQWMsR0FBR087QUFDakJQLGdCQUFnQixHQUFHUTtBQUNuQlIsWUFBWSxHQUFHUztBQUNmVCxpQkFBaUIsR0FBR1U7QUFDcEJWLGVBQWUsR0FBR1c7QUFDbEJYLGVBQWUsR0FBR1k7QUFDbEJaLGFBQWEsR0FBR2E7QUFDaEJiLGdCQUFnQixHQUFHYztBQUNuQixNQUFNQyxRQUFRQyxtQkFBT0EsQ0FBQyw4REFBWTtBQUNsQyxNQUFNQyxTQUFTRCxtQkFBT0EsQ0FBQyxnRUFBYTtBQUNwQyxNQUFNRSxNQUFNRixtQkFBT0EsQ0FBQywwREFBVTtBQUM5QixNQUFNRyxPQUFPSCxtQkFBT0EsQ0FBQyw0REFBVztBQUNoQyxTQUFTVCxPQUFPYSxTQUFTLEVBQUVDLFVBQVUsQ0FBQyxDQUFDO0lBQ25DLE1BQU0sRUFBRUMsVUFBVSxFQUFFLEdBQUdEO0lBQ3ZCLE1BQU0sRUFBRUUsTUFBTSxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRSxHQUFHTDtJQUN6QixJQUFJRSxlQUFlLFNBQ2QsT0FBT0UsTUFBTSxZQUFZLE9BQU9DLE1BQU0sVUFBVztRQUNsRCxJQUFJRixXQUFXLEdBQ1gsTUFBTSxJQUFJbEIsbUJBQW1CO1lBQ3pCa0I7WUFDQUcsT0FBTyxJQUFJdkI7UUFDZjtRQUNKO0lBQ0o7SUFDQSxJQUFJbUIsZUFBZSxRQUNkLE9BQU9FLE1BQU0sWUFBWSxPQUFPQyxNQUFNLGFBQWM7UUFDckQsSUFBSUYsV0FBVyxLQUFLQSxXQUFXLEdBQzNCLE1BQU0sSUFBSWxCLG1CQUFtQjtZQUN6QmtCO1lBQ0FHLE9BQU8sSUFBSXRCO1FBQ2Y7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VUFBVTtZQUNWMUMsT0FBTztRQUNYO0lBQ0o7QUFDSjtBQUNBRCxzQ0FBc0MsR0FBR0c7QUFDekMsTUFBTUQsbUNBQW1DZSxPQUFPb0IsU0FBUztJQUNyREMsWUFBWSxFQUFFbEIsU0FBUyxFQUFFLENBQUU7UUFDdkIsS0FBSyxDQUFDLENBQUMsUUFBUSxFQUFFQSxVQUFVLGlDQUFpQyxDQUFDLEVBQUU7WUFDM0RvQixjQUFjO2dCQUNWO2dCQUNBLENBQUMsU0FBUyxFQUFFdEIsSUFBSWlCLElBQUksQ0FBQ2pCLElBQUlULElBQUksQ0FBQ1csWUFBWSxPQUFPLENBQUM7YUFDckQ7UUFDTDtRQUNBdEIsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxRQUFRO1lBQ2hDMEMsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVjFDLE9BQU87UUFDWDtJQUNKO0FBQ0o7QUFDQUQsa0NBQWtDLEdBQUdFLDRCQUNyQyxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGF3LXdvcmtzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L19janMvY29yZS9QdWJsaWNLZXkuanM/ZmUwNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSW52YWxpZFNlcmlhbGl6ZWRTaXplRXJyb3IgPSBleHBvcnRzLkludmFsaWRVbmNvbXByZXNzZWRQcmVmaXhFcnJvciA9IGV4cG9ydHMuSW52YWxpZENvbXByZXNzZWRQcmVmaXhFcnJvciA9IGV4cG9ydHMuSW52YWxpZFByZWZpeEVycm9yID0gZXhwb3J0cy5JbnZhbGlkRXJyb3IgPSB2b2lkIDA7XG5leHBvcnRzLmFzc2VydCA9IGFzc2VydDtcbmV4cG9ydHMuY29tcHJlc3MgPSBjb21wcmVzcztcbmV4cG9ydHMuZnJvbSA9IGZyb207XG5leHBvcnRzLmZyb21CeXRlcyA9IGZyb21CeXRlcztcbmV4cG9ydHMuZnJvbUhleCA9IGZyb21IZXg7XG5leHBvcnRzLnRvQnl0ZXMgPSB0b0J5dGVzO1xuZXhwb3J0cy50b0hleCA9IHRvSGV4O1xuZXhwb3J0cy52YWxpZGF0ZSA9IHZhbGlkYXRlO1xuY29uc3QgQnl0ZXMgPSByZXF1aXJlKFwiLi9CeXRlcy5qc1wiKTtcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoXCIuL0Vycm9ycy5qc1wiKTtcbmNvbnN0IEhleCA9IHJlcXVpcmUoXCIuL0hleC5qc1wiKTtcbmNvbnN0IEpzb24gPSByZXF1aXJlKFwiLi9Kc29uLmpzXCIpO1xuZnVuY3Rpb24gYXNzZXJ0KHB1YmxpY0tleSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBjb21wcmVzc2VkIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHsgcHJlZml4LCB4LCB5IH0gPSBwdWJsaWNLZXk7XG4gICAgaWYgKGNvbXByZXNzZWQgPT09IGZhbHNlIHx8XG4gICAgICAgICh0eXBlb2YgeCA9PT0gJ2JpZ2ludCcgJiYgdHlwZW9mIHkgPT09ICdiaWdpbnQnKSkge1xuICAgICAgICBpZiAocHJlZml4ICE9PSA0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRQcmVmaXhFcnJvcih7XG4gICAgICAgICAgICAgICAgcHJlZml4LFxuICAgICAgICAgICAgICAgIGNhdXNlOiBuZXcgSW52YWxpZFVuY29tcHJlc3NlZFByZWZpeEVycm9yKCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY29tcHJlc3NlZCA9PT0gdHJ1ZSB8fFxuICAgICAgICAodHlwZW9mIHggPT09ICdiaWdpbnQnICYmIHR5cGVvZiB5ID09PSAndW5kZWZpbmVkJykpIHtcbiAgICAgICAgaWYgKHByZWZpeCAhPT0gMyAmJiBwcmVmaXggIT09IDIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFByZWZpeEVycm9yKHtcbiAgICAgICAgICAgICAgICBwcmVmaXgsXG4gICAgICAgICAgICAgICAgY2F1c2U6IG5ldyBJbnZhbGlkQ29tcHJlc3NlZFByZWZpeEVycm9yKCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgSW52YWxpZEVycm9yKHsgcHVibGljS2V5IH0pO1xufVxuZnVuY3Rpb24gY29tcHJlc3MocHVibGljS2V5KSB7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBwdWJsaWNLZXk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJlZml4OiB5ICUgMm4gPT09IDBuID8gMiA6IDMsXG4gICAgICAgIHgsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZyb20odmFsdWUpIHtcbiAgICBjb25zdCBwdWJsaWNLZXkgPSAoKCkgPT4ge1xuICAgICAgICBpZiAoSGV4LnZhbGlkYXRlKHZhbHVlKSlcbiAgICAgICAgICAgIHJldHVybiBmcm9tSGV4KHZhbHVlKTtcbiAgICAgICAgaWYgKEJ5dGVzLnZhbGlkYXRlKHZhbHVlKSlcbiAgICAgICAgICAgIHJldHVybiBmcm9tQnl0ZXModmFsdWUpO1xuICAgICAgICBjb25zdCB7IHByZWZpeCwgeCwgeSB9ID0gdmFsdWU7XG4gICAgICAgIGlmICh0eXBlb2YgeCA9PT0gJ2JpZ2ludCcgJiYgdHlwZW9mIHkgPT09ICdiaWdpbnQnKVxuICAgICAgICAgICAgcmV0dXJuIHsgcHJlZml4OiBwcmVmaXggPz8gMHgwNCwgeCwgeSB9O1xuICAgICAgICByZXR1cm4geyBwcmVmaXgsIHggfTtcbiAgICB9KSgpO1xuICAgIGFzc2VydChwdWJsaWNLZXkpO1xuICAgIHJldHVybiBwdWJsaWNLZXk7XG59XG5mdW5jdGlvbiBmcm9tQnl0ZXMocHVibGljS2V5KSB7XG4gICAgcmV0dXJuIGZyb21IZXgoSGV4LmZyb21CeXRlcyhwdWJsaWNLZXkpKTtcbn1cbmZ1bmN0aW9uIGZyb21IZXgocHVibGljS2V5KSB7XG4gICAgaWYgKHB1YmxpY0tleS5sZW5ndGggIT09IDEzMiAmJlxuICAgICAgICBwdWJsaWNLZXkubGVuZ3RoICE9PSAxMzAgJiZcbiAgICAgICAgcHVibGljS2V5Lmxlbmd0aCAhPT0gNjgpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkU2VyaWFsaXplZFNpemVFcnJvcih7IHB1YmxpY0tleSB9KTtcbiAgICBpZiAocHVibGljS2V5Lmxlbmd0aCA9PT0gMTMwKSB7XG4gICAgICAgIGNvbnN0IHggPSBCaWdJbnQoSGV4LnNsaWNlKHB1YmxpY0tleSwgMCwgMzIpKTtcbiAgICAgICAgY29uc3QgeSA9IEJpZ0ludChIZXguc2xpY2UocHVibGljS2V5LCAzMiwgNjQpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHByZWZpeDogNCxcbiAgICAgICAgICAgIHgsXG4gICAgICAgICAgICB5LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAocHVibGljS2V5Lmxlbmd0aCA9PT0gMTMyKSB7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IE51bWJlcihIZXguc2xpY2UocHVibGljS2V5LCAwLCAxKSk7XG4gICAgICAgIGNvbnN0IHggPSBCaWdJbnQoSGV4LnNsaWNlKHB1YmxpY0tleSwgMSwgMzMpKTtcbiAgICAgICAgY29uc3QgeSA9IEJpZ0ludChIZXguc2xpY2UocHVibGljS2V5LCAzMywgNjUpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHByZWZpeCxcbiAgICAgICAgICAgIHgsXG4gICAgICAgICAgICB5LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBwcmVmaXggPSBOdW1iZXIoSGV4LnNsaWNlKHB1YmxpY0tleSwgMCwgMSkpO1xuICAgIGNvbnN0IHggPSBCaWdJbnQoSGV4LnNsaWNlKHB1YmxpY0tleSwgMSwgMzMpKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwcmVmaXgsXG4gICAgICAgIHgsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRvQnl0ZXMocHVibGljS2V5LCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gQnl0ZXMuZnJvbUhleCh0b0hleChwdWJsaWNLZXksIG9wdGlvbnMpKTtcbn1cbmZ1bmN0aW9uIHRvSGV4KHB1YmxpY0tleSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgYXNzZXJ0KHB1YmxpY0tleSk7XG4gICAgY29uc3QgeyBwcmVmaXgsIHgsIHkgfSA9IHB1YmxpY0tleTtcbiAgICBjb25zdCB7IGluY2x1ZGVQcmVmaXggPSB0cnVlIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHB1YmxpY0tleV8gPSBIZXguY29uY2F0KGluY2x1ZGVQcmVmaXggPyBIZXguZnJvbU51bWJlcihwcmVmaXgsIHsgc2l6ZTogMSB9KSA6ICcweCcsIEhleC5mcm9tTnVtYmVyKHgsIHsgc2l6ZTogMzIgfSksIHR5cGVvZiB5ID09PSAnYmlnaW50JyA/IEhleC5mcm9tTnVtYmVyKHksIHsgc2l6ZTogMzIgfSkgOiAnMHgnKTtcbiAgICByZXR1cm4gcHVibGljS2V5Xztcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlKHB1YmxpY0tleSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgYXNzZXJ0KHB1YmxpY0tleSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5jbGFzcyBJbnZhbGlkRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHB1YmxpY0tleSB9KSB7XG4gICAgICAgIHN1cGVyKGBWYWx1ZSBcXGAke0pzb24uc3RyaW5naWZ5KHB1YmxpY0tleSl9XFxgIGlzIG5vdCBhIHZhbGlkIHB1YmxpYyBrZXkuYCwge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXG4gICAgICAgICAgICAgICAgJ1B1YmxpYyBrZXkgbXVzdCBjb250YWluOicsXG4gICAgICAgICAgICAgICAgJy0gYW4gYHhgIGFuZCBgcHJlZml4YCB2YWx1ZSAoY29tcHJlc3NlZCknLFxuICAgICAgICAgICAgICAgICctIGFuIGB4YCwgYHlgLCBhbmQgYHByZWZpeGAgdmFsdWUgKHVuY29tcHJlc3NlZCknLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdQdWJsaWNLZXkuSW52YWxpZEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkludmFsaWRFcnJvciA9IEludmFsaWRFcnJvcjtcbmNsYXNzIEludmFsaWRQcmVmaXhFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgcHJlZml4LCBjYXVzZSB9KSB7XG4gICAgICAgIHN1cGVyKGBQcmVmaXggXCIke3ByZWZpeH1cIiBpcyBpbnZhbGlkLmAsIHtcbiAgICAgICAgICAgIGNhdXNlLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1B1YmxpY0tleS5JbnZhbGlkUHJlZml4RXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuSW52YWxpZFByZWZpeEVycm9yID0gSW52YWxpZFByZWZpeEVycm9yO1xuY2xhc3MgSW52YWxpZENvbXByZXNzZWRQcmVmaXhFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignUHJlZml4IG11c3QgYmUgMiBvciAzIGZvciBjb21wcmVzc2VkIHB1YmxpYyBrZXlzLicpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnUHVibGljS2V5LkludmFsaWRDb21wcmVzc2VkUHJlZml4RXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuSW52YWxpZENvbXByZXNzZWRQcmVmaXhFcnJvciA9IEludmFsaWRDb21wcmVzc2VkUHJlZml4RXJyb3I7XG5jbGFzcyBJbnZhbGlkVW5jb21wcmVzc2VkUHJlZml4RXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ1ByZWZpeCBtdXN0IGJlIDQgZm9yIHVuY29tcHJlc3NlZCBwdWJsaWMga2V5cy4nKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1B1YmxpY0tleS5JbnZhbGlkVW5jb21wcmVzc2VkUHJlZml4RXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuSW52YWxpZFVuY29tcHJlc3NlZFByZWZpeEVycm9yID0gSW52YWxpZFVuY29tcHJlc3NlZFByZWZpeEVycm9yO1xuY2xhc3MgSW52YWxpZFNlcmlhbGl6ZWRTaXplRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHB1YmxpY0tleSB9KSB7XG4gICAgICAgIHN1cGVyKGBWYWx1ZSBcXGAke3B1YmxpY0tleX1cXGAgaXMgYW4gaW52YWxpZCBwdWJsaWMga2V5IHNpemUuYCwge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXG4gICAgICAgICAgICAgICAgJ0V4cGVjdGVkOiAzMyBieXRlcyAoY29tcHJlc3NlZCArIHByZWZpeCksIDY0IGJ5dGVzICh1bmNvbXByZXNzZWQpIG9yIDY1IGJ5dGVzICh1bmNvbXByZXNzZWQgKyBwcmVmaXgpLicsXG4gICAgICAgICAgICAgICAgYFJlY2VpdmVkICR7SGV4LnNpemUoSGV4LmZyb20ocHVibGljS2V5KSl9IGJ5dGVzLmAsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1B1YmxpY0tleS5JbnZhbGlkU2VyaWFsaXplZFNpemVFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5JbnZhbGlkU2VyaWFsaXplZFNpemVFcnJvciA9IEludmFsaWRTZXJpYWxpemVkU2l6ZUVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UHVibGljS2V5LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkludmFsaWRTZXJpYWxpemVkU2l6ZUVycm9yIiwiSW52YWxpZFVuY29tcHJlc3NlZFByZWZpeEVycm9yIiwiSW52YWxpZENvbXByZXNzZWRQcmVmaXhFcnJvciIsIkludmFsaWRQcmVmaXhFcnJvciIsIkludmFsaWRFcnJvciIsImFzc2VydCIsImNvbXByZXNzIiwiZnJvbSIsImZyb21CeXRlcyIsImZyb21IZXgiLCJ0b0J5dGVzIiwidG9IZXgiLCJ2YWxpZGF0ZSIsIkJ5dGVzIiwicmVxdWlyZSIsIkVycm9ycyIsIkhleCIsIkpzb24iLCJwdWJsaWNLZXkiLCJvcHRpb25zIiwiY29tcHJlc3NlZCIsInByZWZpeCIsIngiLCJ5IiwiY2F1c2UiLCJsZW5ndGgiLCJCaWdJbnQiLCJzbGljZSIsIk51bWJlciIsImluY2x1ZGVQcmVmaXgiLCJwdWJsaWNLZXlfIiwiY29uY2F0IiwiZnJvbU51bWJlciIsInNpemUiLCJfZXJyb3IiLCJCYXNlRXJyb3IiLCJjb25zdHJ1Y3RvciIsInN0cmluZ2lmeSIsIm1ldGFNZXNzYWdlcyIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_cjs/core/PublicKey.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_cjs/core/Rlp.js":
/*!******************************************!*\
  !*** ./node_modules/ox/_cjs/core/Rlp.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.toBytes = toBytes;\nexports.toHex = toHex;\nexports.to = to;\nexports.decodeRlpCursor = decodeRlpCursor;\nexports.readLength = readLength;\nexports.readList = readList;\nexports.from = from;\nexports.fromBytes = fromBytes;\nexports.fromHex = fromHex;\nconst Bytes = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/./node_modules/ox/_cjs/core/Bytes.js\");\nconst Errors = __webpack_require__(/*! ./Errors.js */ \"(ssr)/./node_modules/ox/_cjs/core/Errors.js\");\nconst Hex = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_cjs/core/Hex.js\");\nconst Cursor = __webpack_require__(/*! ./internal/cursor.js */ \"(ssr)/./node_modules/ox/_cjs/core/internal/cursor.js\");\nfunction toBytes(value) {\n    return to(value, \"Bytes\");\n}\nfunction toHex(value) {\n    return to(value, \"Hex\");\n}\nfunction to(value, to) {\n    const to_ = to ?? (typeof value === \"string\" ? \"Hex\" : \"Bytes\");\n    const bytes = (()=>{\n        if (typeof value === \"string\") {\n            if (value.length > 3 && value.length % 2 !== 0) throw new Hex.InvalidLengthError(value);\n            return Bytes.fromHex(value);\n        }\n        return value;\n    })();\n    const cursor = Cursor.create(bytes, {\n        recursiveReadLimit: Number.POSITIVE_INFINITY\n    });\n    const result = decodeRlpCursor(cursor, to_);\n    return result;\n}\nfunction decodeRlpCursor(cursor, to = \"Hex\") {\n    if (cursor.bytes.length === 0) return to === \"Hex\" ? Hex.fromBytes(cursor.bytes) : cursor.bytes;\n    const prefix = cursor.readByte();\n    if (prefix < 0x80) cursor.decrementPosition(1);\n    if (prefix < 0xc0) {\n        const length = readLength(cursor, prefix, 0x80);\n        const bytes = cursor.readBytes(length);\n        return to === \"Hex\" ? Hex.fromBytes(bytes) : bytes;\n    }\n    const length = readLength(cursor, prefix, 0xc0);\n    return readList(cursor, length, to);\n}\nfunction readLength(cursor, prefix, offset) {\n    if (offset === 0x80 && prefix < 0x80) return 1;\n    if (prefix <= offset + 55) return prefix - offset;\n    if (prefix === offset + 55 + 1) return cursor.readUint8();\n    if (prefix === offset + 55 + 2) return cursor.readUint16();\n    if (prefix === offset + 55 + 3) return cursor.readUint24();\n    if (prefix === offset + 55 + 4) return cursor.readUint32();\n    throw new Errors.BaseError(\"Invalid RLP prefix\");\n}\nfunction readList(cursor, length, to) {\n    const position = cursor.position;\n    const value = [];\n    while(cursor.position - position < length)value.push(decodeRlpCursor(cursor, to));\n    return value;\n}\nfunction from(value, options) {\n    const { as } = options;\n    const encodable = getEncodable(value);\n    const cursor = Cursor.create(new Uint8Array(encodable.length));\n    encodable.encode(cursor);\n    if (as === \"Hex\") return Hex.fromBytes(cursor.bytes);\n    return cursor.bytes;\n}\nfunction fromBytes(bytes, options = {}) {\n    const { as = \"Bytes\" } = options;\n    return from(bytes, {\n        as\n    });\n}\nfunction fromHex(hex, options = {}) {\n    const { as = \"Hex\" } = options;\n    return from(hex, {\n        as\n    });\n}\nfunction getEncodable(bytes) {\n    if (Array.isArray(bytes)) return getEncodableList(bytes.map((x)=>getEncodable(x)));\n    return getEncodableBytes(bytes);\n}\nfunction getEncodableList(list) {\n    const bodyLength = list.reduce((acc, x)=>acc + x.length, 0);\n    const sizeOfBodyLength = getSizeOfLength(bodyLength);\n    const length = (()=>{\n        if (bodyLength <= 55) return 1 + bodyLength;\n        return 1 + sizeOfBodyLength + bodyLength;\n    })();\n    return {\n        length,\n        encode (cursor) {\n            if (bodyLength <= 55) {\n                cursor.pushByte(0xc0 + bodyLength);\n            } else {\n                cursor.pushByte(0xc0 + 55 + sizeOfBodyLength);\n                if (sizeOfBodyLength === 1) cursor.pushUint8(bodyLength);\n                else if (sizeOfBodyLength === 2) cursor.pushUint16(bodyLength);\n                else if (sizeOfBodyLength === 3) cursor.pushUint24(bodyLength);\n                else cursor.pushUint32(bodyLength);\n            }\n            for (const { encode } of list){\n                encode(cursor);\n            }\n        }\n    };\n}\nfunction getEncodableBytes(bytesOrHex) {\n    const bytes = typeof bytesOrHex === \"string\" ? Bytes.fromHex(bytesOrHex) : bytesOrHex;\n    const sizeOfBytesLength = getSizeOfLength(bytes.length);\n    const length = (()=>{\n        if (bytes.length === 1 && bytes[0] < 0x80) return 1;\n        if (bytes.length <= 55) return 1 + bytes.length;\n        return 1 + sizeOfBytesLength + bytes.length;\n    })();\n    return {\n        length,\n        encode (cursor) {\n            if (bytes.length === 1 && bytes[0] < 0x80) {\n                cursor.pushBytes(bytes);\n            } else if (bytes.length <= 55) {\n                cursor.pushByte(0x80 + bytes.length);\n                cursor.pushBytes(bytes);\n            } else {\n                cursor.pushByte(0x80 + 55 + sizeOfBytesLength);\n                if (sizeOfBytesLength === 1) cursor.pushUint8(bytes.length);\n                else if (sizeOfBytesLength === 2) cursor.pushUint16(bytes.length);\n                else if (sizeOfBytesLength === 3) cursor.pushUint24(bytes.length);\n                else cursor.pushUint32(bytes.length);\n                cursor.pushBytes(bytes);\n            }\n        }\n    };\n}\nfunction getSizeOfLength(length) {\n    if (length <= 0xff) return 1;\n    if (length <= 0xffff) return 2;\n    if (length <= 0xffffff) return 3;\n    if (length <= 0xffffffff) return 4;\n    throw new Errors.BaseError(\"Length is too large.\");\n} //# sourceMappingURL=Rlp.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2Nqcy9jb3JlL1JscC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsZUFBZSxHQUFHRTtBQUNsQkYsYUFBYSxHQUFHRztBQUNoQkgsVUFBVSxHQUFHSTtBQUNiSix1QkFBdUIsR0FBR0s7QUFDMUJMLGtCQUFrQixHQUFHTTtBQUNyQk4sZ0JBQWdCLEdBQUdPO0FBQ25CUCxZQUFZLEdBQUdRO0FBQ2ZSLGlCQUFpQixHQUFHUztBQUNwQlQsZUFBZSxHQUFHVTtBQUNsQixNQUFNQyxRQUFRQyxtQkFBT0EsQ0FBQyw4REFBWTtBQUNsQyxNQUFNQyxTQUFTRCxtQkFBT0EsQ0FBQyxnRUFBYTtBQUNwQyxNQUFNRSxNQUFNRixtQkFBT0EsQ0FBQywwREFBVTtBQUM5QixNQUFNRyxTQUFTSCxtQkFBT0EsQ0FBQyxrRkFBc0I7QUFDN0MsU0FBU1YsUUFBUUQsS0FBSztJQUNsQixPQUFPRyxHQUFHSCxPQUFPO0FBQ3JCO0FBQ0EsU0FBU0UsTUFBTUYsS0FBSztJQUNoQixPQUFPRyxHQUFHSCxPQUFPO0FBQ3JCO0FBQ0EsU0FBU0csR0FBR0gsS0FBSyxFQUFFRyxFQUFFO0lBQ2pCLE1BQU1ZLE1BQU1aLE1BQU8sUUFBT0gsVUFBVSxXQUFXLFFBQVEsT0FBTTtJQUM3RCxNQUFNZ0IsUUFBUSxDQUFDO1FBQ1gsSUFBSSxPQUFPaEIsVUFBVSxVQUFVO1lBQzNCLElBQUlBLE1BQU1pQixNQUFNLEdBQUcsS0FBS2pCLE1BQU1pQixNQUFNLEdBQUcsTUFBTSxHQUN6QyxNQUFNLElBQUlKLElBQUlLLGtCQUFrQixDQUFDbEI7WUFDckMsT0FBT1UsTUFBTUQsT0FBTyxDQUFDVDtRQUN6QjtRQUNBLE9BQU9BO0lBQ1g7SUFDQSxNQUFNbUIsU0FBU0wsT0FBT00sTUFBTSxDQUFDSixPQUFPO1FBQ2hDSyxvQkFBb0JDLE9BQU9DLGlCQUFpQjtJQUNoRDtJQUNBLE1BQU1DLFNB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TzRDLFNBQVMsQ0FBQy9DO1lBQ3JCLE9BQ0ssSUFBSUEsTUFBTUMsTUFBTSxJQUFJLElBQUk7Z0JBQ3pCRSxPQUFPcUMsUUFBUSxDQUFDLE9BQU94QyxNQUFNQyxNQUFNO2dCQUNuQ0UsT0FBTzRDLFNBQVMsQ0FBQy9DO1lBQ3JCLE9BQ0s7Z0JBQ0RHLE9BQU9xQyxRQUFRLENBQUMsT0FBTyxLQUFLTTtnQkFDNUIsSUFBSUEsc0JBQXNCLEdBQ3RCM0MsT0FBT3NDLFNBQVMsQ0FBQ3pDLE1BQU1DLE1BQU07cUJBQzVCLElBQUk2QyxzQkFBc0IsR0FDM0IzQyxPQUFPdUMsVUFBVSxDQUFDMUMsTUFBTUMsTUFBTTtxQkFDN0IsSUFBSTZDLHNCQUFzQixHQUMzQjNDLE9BQU93QyxVQUFVLENBQUMzQyxNQUFNQyxNQUFNO3FCQUU5QkUsT0FBT3lDLFVBQVUsQ0FBQzVDLE1BQU1DLE1BQU07Z0JBQ2xDRSxPQUFPNEMsU0FBUyxDQUFDL0M7WUFDckI7UUFDSjtJQUNKO0FBQ0o7QUFDQSxTQUFTdUMsZ0JBQWdCdEMsTUFBTTtJQUMzQixJQUFJQSxVQUFVLE1BQ1YsT0FBTztJQUNYLElBQUlBLFVBQVUsUUFDVixPQUFPO0lBQ1gsSUFBSUEsVUFBVSxVQUNWLE9BQU87SUFDWCxJQUFJQSxVQUFVLFlBQ1YsT0FBTztJQUNYLE1BQU0sSUFBSUwsT0FBT3NCLFNBQVMsQ0FBQztBQUMvQixFQUNBLCtCQUErQiIsInNvdXJjZXMiOlsid2VicGFjazovL2NsYXctd29ya3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3gvX2Nqcy9jb3JlL1JscC5qcz9mYzYyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy50b0J5dGVzID0gdG9CeXRlcztcbmV4cG9ydHMudG9IZXggPSB0b0hleDtcbmV4cG9ydHMudG8gPSB0bztcbmV4cG9ydHMuZGVjb2RlUmxwQ3Vyc29yID0gZGVjb2RlUmxwQ3Vyc29yO1xuZXhwb3J0cy5yZWFkTGVuZ3RoID0gcmVhZExlbmd0aDtcbmV4cG9ydHMucmVhZExpc3QgPSByZWFkTGlzdDtcbmV4cG9ydHMuZnJvbSA9IGZyb207XG5leHBvcnRzLmZyb21CeXRlcyA9IGZyb21CeXRlcztcbmV4cG9ydHMuZnJvbUhleCA9IGZyb21IZXg7XG5jb25zdCBCeXRlcyA9IHJlcXVpcmUoXCIuL0J5dGVzLmpzXCIpO1xuY29uc3QgRXJyb3JzID0gcmVxdWlyZShcIi4vRXJyb3JzLmpzXCIpO1xuY29uc3QgSGV4ID0gcmVxdWlyZShcIi4vSGV4LmpzXCIpO1xuY29uc3QgQ3Vyc29yID0gcmVxdWlyZShcIi4vaW50ZXJuYWwvY3Vyc29yLmpzXCIpO1xuZnVuY3Rpb24gdG9CeXRlcyh2YWx1ZSkge1xuICAgIHJldHVybiB0byh2YWx1ZSwgJ0J5dGVzJyk7XG59XG5mdW5jdGlvbiB0b0hleCh2YWx1ZSkge1xuICAgIHJldHVybiB0byh2YWx1ZSwgJ0hleCcpO1xufVxuZnVuY3Rpb24gdG8odmFsdWUsIHRvKSB7XG4gICAgY29uc3QgdG9fID0gdG8gPz8gKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyAnSGV4JyA6ICdCeXRlcycpO1xuICAgIGNvbnN0IGJ5dGVzID0gKCgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAzICYmIHZhbHVlLmxlbmd0aCAlIDIgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEhleC5JbnZhbGlkTGVuZ3RoRXJyb3IodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIEJ5dGVzLmZyb21IZXgodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9KSgpO1xuICAgIGNvbnN0IGN1cnNvciA9IEN1cnNvci5jcmVhdGUoYnl0ZXMsIHtcbiAgICAgICAgcmVjdXJzaXZlUmVhZExpbWl0OiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gICAgfSk7XG4gICAgY29uc3QgcmVzdWx0ID0gZGVjb2RlUmxwQ3Vyc29yKGN1cnNvciwgdG9fKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZGVjb2RlUmxwQ3Vyc29yKGN1cnNvciwgdG8gPSAnSGV4Jykge1xuICAgIGlmIChjdXJzb3IuYnl0ZXMubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gKHRvID09PSAnSGV4JyA/IEhleC5mcm9tQnl0ZXMoY3Vyc29yLmJ5dGVzKSA6IGN1cnNvci5ieXRlcyk7XG4gICAgY29uc3QgcHJlZml4ID0gY3Vyc29yLnJlYWRCeXRlKCk7XG4gICAgaWYgKHByZWZpeCA8IDB4ODApXG4gICAgICAgIGN1cnNvci5kZWNyZW1lbnRQb3NpdGlvbigxKTtcbiAgICBpZiAocHJlZml4IDwgMHhjMCkge1xuICAgICAgICBjb25zdCBsZW5ndGggPSByZWFkTGVuZ3RoKGN1cnNvciwgcHJlZml4LCAweDgwKTtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBjdXJzb3IucmVhZEJ5dGVzKGxlbmd0aCk7XG4gICAgICAgIHJldHVybiAodG8gPT09ICdIZXgnID8gSGV4LmZyb21CeXRlcyhieXRlcykgOiBieXRlcyk7XG4gICAgfVxuICAgIGNvbnN0IGxlbmd0aCA9IHJlYWRMZW5ndGgoY3Vyc29yLCBwcmVmaXgsIDB4YzApO1xuICAgIHJldHVybiByZWFkTGlzdChjdXJzb3IsIGxlbmd0aCwgdG8pO1xufVxuZnVuY3Rpb24gcmVhZExlbmd0aChjdXJzb3IsIHByZWZpeCwgb2Zmc2V0KSB7XG4gICAgaWYgKG9mZnNldCA9PT0gMHg4MCAmJiBwcmVmaXggPCAweDgwKVxuICAgICAgICByZXR1cm4gMTtcbiAgICBpZiAocHJlZml4IDw9IG9mZnNldCArIDU1KVxuICAgICAgICByZXR1cm4gcHJlZml4IC0gb2Zmc2V0O1xuICAgIGlmIChwcmVmaXggPT09IG9mZnNldCArIDU1ICsgMSlcbiAgICAgICAgcmV0dXJuIGN1cnNvci5yZWFkVWludDgoKTtcbiAgICBpZiAocHJlZml4ID09PSBvZmZzZXQgKyA1NSArIDIpXG4gICAgICAgIHJldHVybiBjdXJzb3IucmVhZFVpbnQxNigpO1xuICAgIGlmIChwcmVmaXggPT09IG9mZnNldCArIDU1ICsgMylcbiAgICAgICAgcmV0dXJuIGN1cnNvci5yZWFkVWludDI0KCk7XG4gICAgaWYgKHByZWZpeCA9PT0gb2Zmc2V0ICsgNTUgKyA0KVxuICAgICAgICByZXR1cm4gY3Vyc29yLnJlYWRVaW50MzIoKTtcbiAgICB0aHJvdyBuZXcgRXJyb3JzLkJhc2VFcnJvcignSW52YWxpZCBSTFAgcHJlZml4Jyk7XG59XG5mdW5jdGlvbiByZWFkTGlzdChjdXJzb3IsIGxlbmd0aCwgdG8pIHtcbiAgICBjb25zdCBwb3NpdGlvbiA9IGN1cnNvci5wb3NpdGlvbjtcbiAgICBjb25zdCB2YWx1ZSA9IFtdO1xuICAgIHdoaWxlIChjdXJzb3IucG9zaXRpb24gLSBwb3NpdGlvbiA8IGxlbmd0aClcbiAgICAgICAgdmFsdWUucHVzaChkZWNvZGVSbHBDdXJzb3IoY3Vyc29yLCB0bykpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGZyb20odmFsdWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGFzIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGVuY29kYWJsZSA9IGdldEVuY29kYWJsZSh2YWx1ZSk7XG4gICAgY29uc3QgY3Vyc29yID0gQ3Vyc29yLmNyZWF0ZShuZXcgVWludDhBcnJheShlbmNvZGFibGUubGVuZ3RoKSk7XG4gICAgZW5jb2RhYmxlLmVuY29kZShjdXJzb3IpO1xuICAgIGlmIChhcyA9PT0gJ0hleCcpXG4gICAgICAgIHJldHVybiBIZXguZnJvbUJ5dGVzKGN1cnNvci5ieXRlcyk7XG4gICAgcmV0dXJuIGN1cnNvci5ieXRlcztcbn1cbmZ1bmN0aW9uIGZyb21CeXRlcyhieXRlcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBhcyA9ICdCeXRlcycgfSA9IG9wdGlvbnM7XG4gICAgcmV0dXJuIGZyb20oYnl0ZXMsIHsgYXMgfSk7XG59XG5mdW5jdGlvbiBmcm9tSGV4KGhleCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBhcyA9ICdIZXgnIH0gPSBvcHRpb25zO1xuICAgIHJldHVybiBmcm9tKGhleCwgeyBhcyB9KTtcbn1cbmZ1bmN0aW9uIGdldEVuY29kYWJsZShieXRlcykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGJ5dGVzKSlcbiAgICAgICAgcmV0dXJuIGdldEVuY29kYWJsZUxpc3QoYnl0ZXMubWFwKCh4KSA9PiBnZXRFbmNvZGFibGUoeCkpKTtcbiAgICByZXR1cm4gZ2V0RW5jb2RhYmxlQnl0ZXMoYnl0ZXMpO1xufVxuZnVuY3Rpb24gZ2V0RW5jb2RhYmxlTGlzdChsaXN0KSB7XG4gICAgY29uc3QgYm9keUxlbmd0aCA9IGxpc3QucmVkdWNlKChhY2MsIHgpID0+IGFjYyArIHgubGVuZ3RoLCAwKTtcbiAgICBjb25zdCBzaXplT2ZCb2R5TGVuZ3RoID0gZ2V0U2l6ZU9mTGVuZ3RoKGJvZHlMZW5ndGgpO1xuICAgIGNvbnN0IGxlbmd0aCA9ICgoKSA9PiB7XG4gICAgICAgIGlmIChib2R5TGVuZ3RoIDw9IDU1KVxuICAgICAgICAgICAgcmV0dXJuIDEgKyBib2R5TGVuZ3RoO1xuICAgICAgICByZXR1cm4gMSArIHNpemVPZkJvZHlMZW5ndGggKyBib2R5TGVuZ3RoO1xuICAgIH0pKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGVuZ3RoLFxuICAgICAgICBlbmNvZGUoY3Vyc29yKSB7XG4gICAgICAgICAgICBpZiAoYm9keUxlbmd0aCA8PSA1NSkge1xuICAgICAgICAgICAgICAgIGN1cnNvci5wdXNoQnl0ZSgweGMwICsgYm9keUxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJzb3IucHVzaEJ5dGUoMHhjMCArIDU1ICsgc2l6ZU9mQm9keUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgaWYgKHNpemVPZkJvZHlMZW5ndGggPT09IDEpXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvci5wdXNoVWludDgoYm9keUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2l6ZU9mQm9keUxlbmd0aCA9PT0gMilcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hVaW50MTYoYm9keUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2l6ZU9mQm9keUxlbmd0aCA9PT0gMylcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hVaW50MjQoYm9keUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IucHVzaFVpbnQzMihib2R5TGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgeyBlbmNvZGUgfSBvZiBsaXN0KSB7XG4gICAgICAgICAgICAgICAgZW5jb2RlKGN1cnNvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldEVuY29kYWJsZUJ5dGVzKGJ5dGVzT3JIZXgpIHtcbiAgICBjb25zdCBieXRlcyA9IHR5cGVvZiBieXRlc09ySGV4ID09PSAnc3RyaW5nJyA/IEJ5dGVzLmZyb21IZXgoYnl0ZXNPckhleCkgOiBieXRlc09ySGV4O1xuICAgIGNvbnN0IHNpemVPZkJ5dGVzTGVuZ3RoID0gZ2V0U2l6ZU9mTGVuZ3RoKGJ5dGVzLmxlbmd0aCk7XG4gICAgY29uc3QgbGVuZ3RoID0gKCgpID0+IHtcbiAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gMSAmJiBieXRlc1swXSA8IDB4ODApXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA8PSA1NSlcbiAgICAgICAgICAgIHJldHVybiAxICsgYnl0ZXMubGVuZ3RoO1xuICAgICAgICByZXR1cm4gMSArIHNpemVPZkJ5dGVzTGVuZ3RoICsgYnl0ZXMubGVuZ3RoO1xuICAgIH0pKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGVuZ3RoLFxuICAgICAgICBlbmNvZGUoY3Vyc29yKSB7XG4gICAgICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSAxICYmIGJ5dGVzWzBdIDwgMHg4MCkge1xuICAgICAgICAgICAgICAgIGN1cnNvci5wdXNoQnl0ZXMoYnl0ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYnl0ZXMubGVuZ3RoIDw9IDU1KSB7XG4gICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hCeXRlKDB4ODAgKyBieXRlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGN1cnNvci5wdXNoQnl0ZXMoYnl0ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hCeXRlKDB4ODAgKyA1NSArIHNpemVPZkJ5dGVzTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAoc2l6ZU9mQnl0ZXNMZW5ndGggPT09IDEpXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvci5wdXNoVWludDgoYnl0ZXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaXplT2ZCeXRlc0xlbmd0aCA9PT0gMilcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hVaW50MTYoYnl0ZXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaXplT2ZCeXRlc0xlbmd0aCA9PT0gMylcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hVaW50MjQoYnl0ZXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvci5wdXNoVWludDMyKGJ5dGVzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hCeXRlcyhieXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldFNpemVPZkxlbmd0aChsZW5ndGgpIHtcbiAgICBpZiAobGVuZ3RoIDw9IDB4ZmYpXG4gICAgICAgIHJldHVybiAxO1xuICAgIGlmIChsZW5ndGggPD0gMHhmZl9mZilcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgaWYgKGxlbmd0aCA8PSAweGZmX2ZmX2ZmKVxuICAgICAgICByZXR1cm4gMztcbiAgICBpZiAobGVuZ3RoIDw9IDB4ZmZfZmZfZmZfZmYpXG4gICAgICAgIHJldHVybiA0O1xuICAgIHRocm93IG5ldyBFcnJvcnMuQmFzZUVycm9yKCdMZW5ndGggaXMgdG9vIGxhcmdlLicpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmxwLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInRvQnl0ZXMiLCJ0b0hleCIsInRvIiwiZGVjb2RlUmxwQ3Vyc29yIiwicmVhZExlbmd0aCIsInJlYWRMaXN0IiwiZnJvbSIsImZyb21CeXRlcyIsImZyb21IZXgiLCJCeXRlcyIsInJlcXVpcmUiLCJFcnJvcnMiLCJIZXgiLCJDdXJzb3IiLCJ0b18iLCJieXRlcyIsImxlbmd0aCIsIkludmFsaWRMZW5ndGhFcnJvciIsImN1cnNvciIsImNyZWF0ZSIsInJlY3Vyc2l2ZVJlYWRMaW1pdCIsIk51bWJlciIsIlBPU0lUSVZFX0lORklOSVRZIiwicmVzdWx0IiwicHJlZml4IiwicmVhZEJ5dGUiLCJkZWNyZW1lbnRQb3NpdGlvbiIsInJlYWRCeXRlcyIsIm9mZnNldCIsInJlYWRVaW50OCIsInJlYWRVaW50MTYiLCJyZWFkVWludDI0IiwicmVhZFVpbnQzMiIsIkJhc2VFcnJvciIsInBvc2l0aW9uIiwicHVzaCIsIm9wdGlvbnMiLCJhcyIsImVuY29kYWJsZSIsImdldEVuY29kYWJsZSIsIlVpbnQ4QXJyYXkiLCJlbmNvZGUiLCJoZXgiLCJBcnJheSIsImlzQXJyYXkiLCJnZXRFbmNvZGFibGVMaXN0IiwibWFwIiwieCIsImdldEVuY29kYWJsZUJ5dGVzIiwibGlzdCIsImJvZHlMZW5ndGgiLCJyZWR1Y2UiLCJhY2MiLCJzaXplT2ZCb2R5TGVuZ3RoIiwiZ2V0U2l6ZU9mTGVuZ3RoIiwicHVzaEJ5dGUiLCJwdXNoVWludDgiLCJwdXNoVWludDE2IiwicHVzaFVpbnQyNCIsInB1c2hVaW50MzIiLCJieXRlc09ySGV4Iiwic2l6ZU9mQnl0ZXNMZW5ndGgiLCJwdXNoQnl0ZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_cjs/core/Rlp.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_cjs/core/Secp256k1.js":
/*!************************************************!*\
  !*** ./node_modules/ox/_cjs/core/Secp256k1.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.noble = void 0;\nexports.createKeyPair = createKeyPair;\nexports.getPublicKey = getPublicKey;\nexports.getSharedSecret = getSharedSecret;\nexports.randomPrivateKey = randomPrivateKey;\nexports.recoverAddress = recoverAddress;\nexports.recoverPublicKey = recoverPublicKey;\nexports.sign = sign;\nexports.verify = verify;\nconst secp256k1_1 = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/secp256k1.js\");\nconst Address = __webpack_require__(/*! ./Address.js */ \"(ssr)/./node_modules/ox/_cjs/core/Address.js\");\nconst Bytes = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/./node_modules/ox/_cjs/core/Bytes.js\");\nconst Hex = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_cjs/core/Hex.js\");\nconst Entropy = __webpack_require__(/*! ./internal/entropy.js */ \"(ssr)/./node_modules/ox/_cjs/core/internal/entropy.js\");\nconst PublicKey = __webpack_require__(/*! ./PublicKey.js */ \"(ssr)/./node_modules/ox/_cjs/core/PublicKey.js\");\nexports.noble = secp256k1_1.secp256k1;\nfunction createKeyPair(options = {}) {\n    const { as = \"Hex\" } = options;\n    const privateKey = randomPrivateKey({\n        as\n    });\n    const publicKey = getPublicKey({\n        privateKey\n    });\n    return {\n        privateKey: privateKey,\n        publicKey\n    };\n}\nfunction getPublicKey(options) {\n    const { privateKey } = options;\n    const point = secp256k1_1.secp256k1.ProjectivePoint.fromPrivateKey(Hex.from(privateKey).slice(2));\n    return PublicKey.from(point);\n}\nfunction getSharedSecret(options) {\n    const { as = \"Hex\", privateKey, publicKey } = options;\n    const point = secp256k1_1.secp256k1.ProjectivePoint.fromHex(PublicKey.toHex(publicKey).slice(2));\n    const sharedPoint = point.multiply(secp256k1_1.secp256k1.utils.normPrivateKeyToScalar(Hex.from(privateKey).slice(2)));\n    const sharedSecret = sharedPoint.toRawBytes(true);\n    if (as === \"Hex\") return Hex.fromBytes(sharedSecret);\n    return sharedSecret;\n}\nfunction randomPrivateKey(options = {}) {\n    const { as = \"Hex\" } = options;\n    const bytes = secp256k1_1.secp256k1.utils.randomPrivateKey();\n    if (as === \"Hex\") return Hex.fromBytes(bytes);\n    return bytes;\n}\nfunction recoverAddress(options) {\n    return Address.fromPublicKey(recoverPublicKey(options));\n}\nfunction recoverPublicKey(options) {\n    const { payload, signature } = options;\n    const { r, s, yParity } = signature;\n    const signature_ = new secp256k1_1.secp256k1.Signature(BigInt(r), BigInt(s)).addRecoveryBit(yParity);\n    const point = signature_.recoverPublicKey(Hex.from(payload).substring(2));\n    return PublicKey.from(point);\n}\nfunction sign(options) {\n    const { extraEntropy = Entropy.extraEntropy, hash, payload, privateKey } = options;\n    const { r, s, recovery } = secp256k1_1.secp256k1.sign(Bytes.from(payload), Bytes.from(privateKey), {\n        extraEntropy: typeof extraEntropy === \"boolean\" ? extraEntropy : Hex.from(extraEntropy).slice(2),\n        lowS: true,\n        ...hash ? {\n            prehash: true\n        } : {}\n    });\n    return {\n        r,\n        s,\n        yParity: recovery\n    };\n}\nfunction verify(options) {\n    const { address, hash, payload, publicKey, signature } = options;\n    if (address) return Address.isEqual(address, recoverAddress({\n        payload,\n        signature\n    }));\n    return secp256k1_1.secp256k1.verify(signature, Bytes.from(payload), PublicKey.toBytes(publicKey), ...hash ? [\n        {\n            prehash: true,\n            lowS: true\n        }\n    ] : []);\n} //# sourceMappingURL=Secp256k1.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2Nqcy9jb3JlL1NlY3AyNTZrMS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsYUFBYSxHQUFHLEtBQUs7QUFDckJBLHFCQUFxQixHQUFHRztBQUN4Qkgsb0JBQW9CLEdBQUdJO0FBQ3ZCSix1QkFBdUIsR0FBR0s7QUFDMUJMLHdCQUF3QixHQUFHTTtBQUMzQk4sc0JBQXNCLEdBQUdPO0FBQ3pCUCx3QkFBd0IsR0FBR1E7QUFDM0JSLFlBQVksR0FBR1M7QUFDZlQsY0FBYyxHQUFHVTtBQUNqQixNQUFNQyxjQUFjQyxtQkFBT0EsQ0FBQyxnR0FBeUI7QUFDckQsTUFBTUMsVUFBVUQsbUJBQU9BLENBQUMsa0VBQWM7QUFDdEMsTUFBTUUsUUFBUUYsbUJBQU9BLENBQUMsOERBQVk7QUFDbEMsTUFBTUcsTUFBTUgsbUJBQU9BLENBQUMsMERBQVU7QUFDOUIsTUFBTUksVUFBVUosbUJBQU9BLENBQUMsb0ZBQXVCO0FBQy9DLE1BQU1LLFlBQVlMLG1CQUFPQSxDQUFDLHNFQUFnQjtBQUMxQ1osYUFBYSxHQUFHVyxZQUFZTyxTQUFTO0FBQ3JDLFNBQVNmLGNBQWNnQixVQUFVLENBQUMsQ0FBQztJQUMvQixNQUFNLEVBQUVDLEtBQUssS0FBSyxFQUFFLEdBQUdEO0lBQ3ZCLE1BQU1FLGFBQWFmLGlCQUFpQjtRQUFFYztJQUFHO0lBQ3pDLE1BQU1FLFlBQVlsQixhQUFhO1FBQUVpQjtJQUFXO0lBQzVDLE9BQU87UUFDSEEsWUFBWUE7UUFDWkM7SUFDSjtBQUNKO0FBQ0EsU0FBU2xCLGFBQWFlLE9BQU87SUFDekIsTUFBTSxFQUFFRSxVQUFVLEVBQUUsR0FBR0Y7SUFDdkIsTUFBTUksUUFBUVosWUFBWU8sU0FBUyxDQUFDTSxlQUFlLENBQUNDLGNBQWMsQ0FBQ1YsSUFBSVcsSUFBSSxDQUFDTCxZQUFZTSxLQUFLLENBQUM7SUFDOUYsT0FBT1YsVUFBVVMsSUFB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dWxlcy9veC9fY2pzL2NvcmUvU2VjcDI1NmsxLmpzP2UyYjgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm5vYmxlID0gdm9pZCAwO1xuZXhwb3J0cy5jcmVhdGVLZXlQYWlyID0gY3JlYXRlS2V5UGFpcjtcbmV4cG9ydHMuZ2V0UHVibGljS2V5ID0gZ2V0UHVibGljS2V5O1xuZXhwb3J0cy5nZXRTaGFyZWRTZWNyZXQgPSBnZXRTaGFyZWRTZWNyZXQ7XG5leHBvcnRzLnJhbmRvbVByaXZhdGVLZXkgPSByYW5kb21Qcml2YXRlS2V5O1xuZXhwb3J0cy5yZWNvdmVyQWRkcmVzcyA9IHJlY292ZXJBZGRyZXNzO1xuZXhwb3J0cy5yZWNvdmVyUHVibGljS2V5ID0gcmVjb3ZlclB1YmxpY0tleTtcbmV4cG9ydHMuc2lnbiA9IHNpZ247XG5leHBvcnRzLnZlcmlmeSA9IHZlcmlmeTtcbmNvbnN0IHNlY3AyNTZrMV8xID0gcmVxdWlyZShcIkBub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxXCIpO1xuY29uc3QgQWRkcmVzcyA9IHJlcXVpcmUoXCIuL0FkZHJlc3MuanNcIik7XG5jb25zdCBCeXRlcyA9IHJlcXVpcmUoXCIuL0J5dGVzLmpzXCIpO1xuY29uc3QgSGV4ID0gcmVxdWlyZShcIi4vSGV4LmpzXCIpO1xuY29uc3QgRW50cm9weSA9IHJlcXVpcmUoXCIuL2ludGVybmFsL2VudHJvcHkuanNcIik7XG5jb25zdCBQdWJsaWNLZXkgPSByZXF1aXJlKFwiLi9QdWJsaWNLZXkuanNcIik7XG5leHBvcnRzLm5vYmxlID0gc2VjcDI1NmsxXzEuc2VjcDI1NmsxO1xuZnVuY3Rpb24gY3JlYXRlS2V5UGFpcihvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGFzID0gJ0hleCcgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgcHJpdmF0ZUtleSA9IHJhbmRvbVByaXZhdGVLZXkoeyBhcyB9KTtcbiAgICBjb25zdCBwdWJsaWNLZXkgPSBnZXRQdWJsaWNLZXkoeyBwcml2YXRlS2V5IH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHByaXZhdGVLZXk6IHByaXZhdGVLZXksXG4gICAgICAgIHB1YmxpY0tleSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0UHVibGljS2V5KG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHByaXZhdGVLZXkgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgcG9pbnQgPSBzZWNwMjU2azFfMS5zZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50LmZyb21Qcml2YXRlS2V5KEhleC5mcm9tKHByaXZhdGVLZXkpLnNsaWNlKDIpKTtcbiAgICByZXR1cm4gUHVibGljS2V5LmZyb20ocG9pbnQpO1xufVxuZnVuY3Rpb24gZ2V0U2hhcmVkU2VjcmV0KG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGFzID0gJ0hleCcsIHByaXZhdGVLZXksIHB1YmxpY0tleSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBwb2ludCA9IHNlY3AyNTZrMV8xLnNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQuZnJvbUhleChQdWJsaWNLZXkudG9IZXgocHVibGljS2V5KS5zbGljZSgyKSk7XG4gICAgY29uc3Qgc2hhcmVkUG9pbnQgPSBwb2ludC5tdWx0aXBseShzZWNwMjU2azFfMS5zZWNwMjU2azEudXRpbHMubm9ybVByaXZhdGVLZXlUb1NjYWxhcihIZXguZnJvbShwcml2YXRlS2V5KS5zbGljZSgyKSkpO1xuICAgIGNvbnN0IHNoYXJlZFNlY3JldCA9IHNoYXJlZFBvaW50LnRvUmF3Qnl0ZXModHJ1ZSk7XG4gICAgaWYgKGFzID09PSAnSGV4JylcbiAgICAgICAgcmV0dXJuIEhleC5mcm9tQnl0ZXMoc2hhcmVkU2VjcmV0KTtcbiAgICByZXR1cm4gc2hhcmVkU2VjcmV0O1xufVxuZnVuY3Rpb24gcmFuZG9tUHJpdmF0ZUtleShvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGFzID0gJ0hleCcgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYnl0ZXMgPSBzZWNwMjU2azFfMS5zZWNwMjU2azEudXRpbHMucmFuZG9tUHJpdmF0ZUtleSgpO1xuICAgIGlmIChhcyA9PT0gJ0hleCcpXG4gICAgICAgIHJldHVybiBIZXguZnJvbUJ5dGVzKGJ5dGVzKTtcbiAgICByZXR1cm4gYnl0ZXM7XG59XG5mdW5jdGlvbiByZWNvdmVyQWRkcmVzcyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIEFkZHJlc3MuZnJvbVB1YmxpY0tleShyZWNvdmVyUHVibGljS2V5KG9wdGlvbnMpKTtcbn1cbmZ1bmN0aW9uIHJlY292ZXJQdWJsaWNLZXkob3B0aW9ucykge1xuICAgIGNvbnN0IHsgcGF5bG9hZCwgc2lnbmF0dXJlIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHsgciwgcywgeVBhcml0eSB9ID0gc2lnbmF0dXJlO1xuICAgIGNvbnN0IHNpZ25hdHVyZV8gPSBuZXcgc2VjcDI1NmsxXzEuc2VjcDI1NmsxLlNpZ25hdHVyZShCaWdJbnQociksIEJpZ0ludChzKSkuYWRkUmVjb3ZlcnlCaXQoeVBhcml0eSk7XG4gICAgY29uc3QgcG9pbnQgPSBzaWduYXR1cmVfLnJlY292ZXJQdWJsaWNLZXkoSGV4LmZyb20ocGF5bG9hZCkuc3Vic3RyaW5nKDIpKTtcbiAgICByZXR1cm4gUHVibGljS2V5LmZyb20ocG9pbnQpO1xufVxuZnVuY3Rpb24gc2lnbihvcHRpb25zKSB7XG4gICAgY29uc3QgeyBleHRyYUVudHJvcHkgPSBFbnRyb3B5LmV4dHJhRW50cm9weSwgaGFzaCwgcGF5bG9hZCwgcHJpdmF0ZUtleSwgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgeyByLCBzLCByZWNvdmVyeSB9ID0gc2VjcDI1NmsxXzEuc2VjcDI1NmsxLnNpZ24oQnl0ZXMuZnJvbShwYXlsb2FkKSwgQnl0ZXMuZnJvbShwcml2YXRlS2V5KSwge1xuICAgICAgICBleHRyYUVudHJvcHk6IHR5cGVvZiBleHRyYUVudHJvcHkgPT09ICdib29sZWFuJ1xuICAgICAgICAgICAgPyBleHRyYUVudHJvcHlcbiAgICAgICAgICAgIDogSGV4LmZyb20oZXh0cmFFbnRyb3B5KS5zbGljZSgyKSxcbiAgICAgICAgbG93UzogdHJ1ZSxcbiAgICAgICAgLi4uKGhhc2ggPyB7IHByZWhhc2g6IHRydWUgfSA6IHt9KSxcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICByLFxuICAgICAgICBzLFxuICAgICAgICB5UGFyaXR5OiByZWNvdmVyeSxcbiAgICB9O1xufVxuZnVuY3Rpb24gdmVyaWZ5KG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGFkZHJlc3MsIGhhc2gsIHBheWxvYWQsIHB1YmxpY0tleSwgc2lnbmF0dXJlIH0gPSBvcHRpb25zO1xuICAgIGlmIChhZGRyZXNzKVxuICAgICAgICByZXR1cm4gQWRkcmVzcy5pc0VxdWFsKGFkZHJlc3MsIHJlY292ZXJBZGRyZXNzKHsgcGF5bG9hZCwgc2lnbmF0dXJlIH0pKTtcbiAgICByZXR1cm4gc2VjcDI1NmsxXzEuc2VjcDI1NmsxLnZlcmlmeShzaWduYXR1cmUsIEJ5dGVzLmZyb20ocGF5bG9hZCksIFB1YmxpY0tleS50b0J5dGVzKHB1YmxpY0tleSksIC4uLihoYXNoID8gW3sgcHJlaGFzaDogdHJ1ZSwgbG93UzogdHJ1ZSB9XSA6IFtdKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TZWNwMjU2azEuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibm9ibGUiLCJjcmVhdGVLZXlQYWlyIiwiZ2V0UHVibGljS2V5IiwiZ2V0U2hhcmVkU2VjcmV0IiwicmFuZG9tUHJpdmF0ZUtleSIsInJlY292ZXJBZGRyZXNzIiwicmVjb3ZlclB1YmxpY0tleSIsInNpZ24iLCJ2ZXJpZnkiLCJzZWNwMjU2azFfMSIsInJlcXVpcmUiLCJBZGRyZXNzIiwiQnl0ZXMiLCJIZXgiLCJFbnRyb3B5IiwiUHVibGljS2V5Iiwic2VjcDI1NmsxIiwib3B0aW9ucyIsImFzIiwicHJpdmF0ZUtleSIsInB1YmxpY0tleSIsInBvaW50IiwiUHJvamVjdGl2ZVBvaW50IiwiZnJvbVByaXZhdGVLZXkiLCJmcm9tIiwic2xpY2UiLCJmcm9tSGV4IiwidG9IZXgiLCJzaGFyZWRQb2ludCIsIm11bHRpcGx5IiwidXRpbHMiLCJub3JtUHJpdmF0ZUtleVRvU2NhbGFyIiwic2hhcmVkU2VjcmV0IiwidG9SYXdCeXRlcyIsImZyb21CeXRlcyIsImJ5dGVzIiwiZnJvbVB1YmxpY0tleSIsInBheWxvYWQiLCJzaWduYXR1cmUiLCJyIiwicyIsInlQYXJpdHkiLCJzaWduYXR1cmVfIiwiU2lnbmF0dXJlIiwiQmlnSW50IiwiYWRkUmVjb3ZlcnlCaXQiLCJzdWJzdHJpbmciLCJleHRyYUVudHJvcHkiLCJoYXNoIiwicmVjb3ZlcnkiLCJsb3dTIiwicHJlaGFzaCIsImFkZHJlc3MiLCJpc0VxdWFsIiwidG9CeXRlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_cjs/core/Secp256k1.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_cjs/core/Signature.js":
/*!************************************************!*\
  !*** ./node_modules/ox/_cjs/core/Signature.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.InvalidVError = exports.InvalidYParityError = exports.InvalidSError = exports.InvalidRError = exports.MissingPropertiesError = exports.InvalidSerializedSizeError = void 0;\nexports.assert = assert;\nexports.fromBytes = fromBytes;\nexports.fromHex = fromHex;\nexports.extract = extract;\nexports.from = from;\nexports.fromDerBytes = fromDerBytes;\nexports.fromDerHex = fromDerHex;\nexports.fromLegacy = fromLegacy;\nexports.fromRpc = fromRpc;\nexports.fromTuple = fromTuple;\nexports.toBytes = toBytes;\nexports.toHex = toHex;\nexports.toDerBytes = toDerBytes;\nexports.toDerHex = toDerHex;\nexports.toLegacy = toLegacy;\nexports.toRpc = toRpc;\nexports.toTuple = toTuple;\nexports.validate = validate;\nexports.vToYParity = vToYParity;\nexports.yParityToV = yParityToV;\nconst secp256k1_1 = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/secp256k1.js\");\nconst Bytes = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/./node_modules/ox/_cjs/core/Bytes.js\");\nconst Errors = __webpack_require__(/*! ./Errors.js */ \"(ssr)/./node_modules/ox/_cjs/core/Errors.js\");\nconst Hex = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_cjs/core/Hex.js\");\nconst Json = __webpack_require__(/*! ./Json.js */ \"(ssr)/./node_modules/ox/_cjs/core/Json.js\");\nconst Solidity = __webpack_require__(/*! ./Solidity.js */ \"(ssr)/./node_modules/ox/_cjs/core/Solidity.js\");\nfunction assert(signature, options = {}) {\n    const { recovered } = options;\n    if (typeof signature.r === \"undefined\") throw new MissingPropertiesError({\n        signature\n    });\n    if (typeof signature.s === \"undefined\") throw new MissingPropertiesError({\n        signature\n    });\n    if (recovered && typeof signature.yParity === \"undefined\") throw new MissingPropertiesError({\n        signature\n    });\n    if (signature.r < 0n || signature.r > Solidity.maxUint256) throw new InvalidRError({\n        value: signature.r\n    });\n    if (signature.s < 0n || signature.s > Solidity.maxUint256) throw new InvalidSError({\n        value: signature.s\n    });\n    if (typeof signature.yParity === \"number\" && signature.yParity !== 0 && signature.yParity !== 1) throw new InvalidYParityError({\n        value: signature.yParity\n    });\n}\nfunction fromBytes(signature) {\n    return fromHex(Hex.fromBytes(signature));\n}\nfunction fromHex(signature) {\n    if (signature.length !== 130 && signature.length !== 132) throw new InvalidSerializedSizeError({\n        signature\n    });\n    const r = BigInt(Hex.slice(signature, 0, 32));\n    const s = BigInt(Hex.slice(signature, 32, 64));\n    const yParity = (()=>{\n        const yParity = Number(`0x${signature.slice(130)}`);\n        if (Number.isNaN(yParity)) return undefined;\n        try {\n            return vToYParity(yParity);\n        } catch  {\n            throw new InvalidYParityError({\n                value: yParity\n            });\n        }\n    })();\n    if (typeof yParity === \"undefined\") return {\n        r,\n        s\n    };\n    return {\n        r,\n        s,\n        yParity\n    };\n}\nfunction extract(value) {\n    if (typeof value.r === \"undefined\") return undefined;\n    if (typeof value.s === \"undefined\") return undefined;\n    return from(value);\n}\nfunction from(signature) {\n    const signature_ = (()=>{\n        if (typeof signature === \"string\") return fromHex(signature);\n        if (signature instanceof Uint8Array) return fromBytes(signature);\n        if (typeof signature.r === \"string\") return fromRpc(signature);\n        if (signature.v) return fromLegacy(signature);\n        return {\n            r: signature.r,\n            s: signature.s,\n            ...typeof signature.yParity !== \"undefined\" ? {\n                yParity: signature.yParity\n            } : {}\n        };\n    })();\n    assert(signature_);\n    return signature_;\n}\nfunction fromDerBytes(signature) {\n    return fromDerHex(Hex.fromBytes(signature));\n}\nfunction fromDerHex(signature) {\n    const { r, s } = secp256k1_1.secp256k1.Signature.fromDER(Hex.from(signature).slice(2));\n    return {\n        r,\n        s\n    };\n}\nfunction fromLegacy(signature) {\n    return {\n        r: signature.r,\n        s: signature.s,\n        yParity: vToYParity(signature.v)\n    };\n}\nfunction fromRpc(signature) {\n    const yParity = (()=>{\n        const v = signature.v ? Number(signature.v) : undefined;\n        let yParity = signature.yParity ? Number(signature.yParity) : undefined;\n        if (typeof v === \"number\" && typeof yParity !== \"number\") yParity = vToYParity(v);\n        if (typeof yParity !== \"number\") throw new InvalidYParityError({\n            value: signature.yParity\n        });\n        return yParity;\n    })();\n    return {\n        r: BigInt(signature.r),\n        s: BigInt(signature.s),\n        yParity\n    };\n}\nfunction fromTuple(tuple) {\n    const [yParity, r, s] = tuple;\n    return from({\n        r: r === \"0x\" ? 0n : BigInt(r),\n        s: s === \"0x\" ? 0n : BigInt(s),\n        yParity: yParity === \"0x\" ? 0 : Number(yParity)\n    });\n}\nfunction toBytes(signature) {\n    return Bytes.fromHex(toHex(signature));\n}\nfunction toHex(signature) {\n    assert(signature);\n    const r = signature.r;\n    const s = signature.s;\n    const signature_ = Hex.concat(Hex.fromNumber(r, {\n        size: 32\n    }), Hex.fromNumber(s, {\n        size: 32\n    }), typeof signature.yParity === \"number\" ? Hex.fromNumber(yParityToV(signature.yParity), {\n        size: 1\n    }) : \"0x\");\n    return signature_;\n}\nfunction toDerBytes(signature) {\n    const sig = new secp256k1_1.secp256k1.Signature(signature.r, signature.s);\n    return sig.toDERRawBytes();\n}\nfunction toDerHex(signature) {\n    const sig = new secp256k1_1.secp256k1.Signature(signature.r, signature.s);\n    return `0x${sig.toDERHex()}`;\n}\nfunction toLegacy(signature) {\n    return {\n        r: signature.r,\n        s: signature.s,\n        v: yParityToV(signature.yParity)\n    };\n}\nfunction toRpc(signature) {\n    const { r, s, yParity } = signature;\n    return {\n        r: Hex.fromNumber(r, {\n            size: 32\n        }),\n        s: Hex.fromNumber(s, {\n            size: 32\n        }),\n        yParity: yParity === 0 ? \"0x0\" : \"0x1\"\n    };\n}\nfunction toTuple(signature) {\n    const { r, s, yParity } = signature;\n    return [\n        yParity ? \"0x01\" : \"0x\",\n        r === 0n ? \"0x\" : Hex.trimLeft(Hex.fromNumber(r)),\n        s === 0n ? \"0x\" : Hex.trimLeft(Hex.fromNumber(s))\n    ];\n}\nfunction validate(signature, options = {}) {\n    try {\n        assert(signature, options);\n        return true;\n    } catch  {\n        return false;\n    }\n}\nfunction vToYParity(v) {\n    if (v === 0 || v === 27) return 0;\n    if (v === 1 || v === 28) return 1;\n    if (v >= 35) return v % 2 === 0 ? 1 : 0;\n    throw new InvalidVError({\n        value: v\n    });\n}\nfunction yParityToV(yParity) {\n    if (yParity === 0) return 27;\n    if (yParity === 1) return 28;\n    throw new InvalidYParityError({\n        value: yParity\n    });\n}\nclass InvalidSerializedSizeError extends Errors.BaseError {\n    constructor({ signature }){\n        super(`Value \\`${signature}\\` is an invalid signature size.`, {\n            metaMessages: [\n                \"Expected: 64 bytes or 65 bytes.\",\n                `Received ${Hex.size(Hex.from(signature))} bytes.`\n            ]\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Signature.InvalidSerializedSizeError\"\n        });\n    }\n}\nexports.InvalidSerializedSizeError = InvalidSerializedSizeError;\nclass MissingPropertiesError extends Errors.BaseError {\n    constructor({ signature }){\n        super(`Signature \\`${Json.stringify(signature)}\\` is missing either an \\`r\\`, \\`s\\`, or \\`yParity\\` property.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Signature.MissingPropertiesError\"\n        });\n    }\n}\nexports.MissingPropertiesError = MissingPropertiesError;\nclass InvalidRError extends Errors.BaseError {\n    constructor({ value }){\n        super(`Value \\`${value}\\` is an invalid r value. r must be a positive integer less than 2^256.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Signature.InvalidRError\"\n        });\n    }\n}\nexports.InvalidRError = InvalidRError;\nclass InvalidSError extends Errors.BaseError {\n    constructor({ value }){\n        super(`Value \\`${value}\\` is an invalid s value. s must be a positive integer less than 2^256.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Signature.InvalidSError\"\n        });\n    }\n}\nexports.InvalidSError = InvalidSError;\nclass InvalidYParityError extends Errors.BaseError {\n    constructor({ value }){\n        super(`Value \\`${value}\\` is an invalid y-parity value. Y-parity must be 0 or 1.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Signature.InvalidYParityError\"\n        });\n    }\n}\nexports.InvalidYParityError = InvalidYParityError;\nclass InvalidVError extends Errors.BaseError {\n    constructor({ value }){\n        super(`Value \\`${value}\\` is an invalid v value. v must be 27, 28 or >=35.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Signature.InvalidVError\"\n        });\n    }\n}\nexports.InvalidVError = InvalidVError; //# sourceMappingURL=Signature.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2Nqcy9jb3JlL1NpZ25hdHVyZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQscUJBQXFCLEdBQUdBLDJCQUEyQixHQUFHQSxxQkFBcUIsR0FBR0EscUJBQXFCLEdBQUdBLDhCQUE4QixHQUFHQSxrQ0FBa0MsR0FBRyxLQUFLO0FBQ2pMQSxjQUFjLEdBQUdRO0FBQ2pCUixpQkFBaUIsR0FBR1M7QUFDcEJULGVBQWUsR0FBR1U7QUFDbEJWLGVBQWUsR0FBR1c7QUFDbEJYLFlBQVksR0FBR1k7QUFDZlosb0JBQW9CLEdBQUdhO0FBQ3ZCYixrQkFBa0IsR0FBR2M7QUFDckJkLGtCQUFrQixHQUFHZTtBQUNyQmYsZUFBZSxHQUFHZ0I7QUFDbEJoQixpQkFBaUIsR0FBR2lCO0FBQ3BCakIsZUFBZSxHQUFHa0I7QUFDbEJsQixhQUFhLEdBQUdtQjtBQUNoQm5CLGtCQUFrQixHQUFHb0I7QUFDckJwQixnQkFBZ0IsR0FBR3FCO0FBQ25CckIsZ0JBQWdCLEdBQUdzQjtBQUNuQnRCLGFBQWEsR0FBR3VCO0FBQ2hCdkIsZUFBZSxHQUFHd0I7QUFDbEJ4QixnQkFBZ0IsR0FBR3lCO0FBQ25CekIsa0JBQWtCLEdBQUcwQjtBQUNyQjFCLGtCQUFrQixHQUFHMkI7QUFDckIsTUFBTUMsY0FBY0MsbUJBQU9BLENBQUMsZ0dBQXlCO0FBQ3JELE1BQU1DLFFBQVFELG1CQUFPQSxDQUFDLDhEQUFZO0FBQ2xDLE1BQU1FLFNBQVNGLG1CQUFPQSxDQUFDLGdFQUFhO0FBQ3BDLE1BQU1HLE1BQU1ILG1CQUFPQSxDQUFDLDBEQUFVO0FBQzlCLE1BQU1JLE9BQU9KLG1CQUFPQSxDQUFDLDREQUFXO0FBQ2hDLE1BQU1LLFdBQVdMLG1CQUFPQSxDQUFDLG9FQUFlO0FBQ3hDLFNBQVNyQixPQUFPMkIsU0FBUyxFQUFFQyxVQUFVLENBQUMsQ0FBQztJQUNuQyxNQUFNLEVBQUVDLFNB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LHVFQUF1RSxDQUFDO1FBQy9GSCxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLFFBQVE7WUFDaENrRSxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWbEUsT0FBTztRQUNYO0lBQ0o7QUFDSjtBQUNBRCxxQkFBcUIsR0FBR0k7QUFDeEIsTUFBTUQsNEJBQTRCNEIsT0FBTytCLFNBQVM7SUFDOUNDLFlBQVksRUFBRTlELEtBQUssRUFBRSxDQUFFO1FBQ25CLEtBQUssQ0FBQyxDQUFDLFFBQVEsRUFBRUEsTUFBTSx5REFBeUQsQ0FBQztRQUNqRkgsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxRQUFRO1lBQ2hDa0UsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVmxFLE9BQU87UUFDWDtJQUNKO0FBQ0o7QUFDQUQsMkJBQTJCLEdBQUdHO0FBQzlCLE1BQU1ELHNCQUFzQjZCLE9BQU8rQixTQUFTO0lBQ3hDQyxZQUFZLEVBQUU5RCxLQUFLLEVBQUUsQ0FBRTtRQUNuQixLQUFLLENBQUMsQ0FBQyxRQUFRLEVBQUVBLE1BQU0sbURBQW1ELENBQUM7UUFDM0VILE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsUUFBUTtZQUNoQ2tFLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZsRSxPQUFPO1FBQ1g7SUFDSjtBQUNKO0FBQ0FELHFCQUFxQixHQUFHRSxlQUN4QixxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGF3LXdvcmtzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L19janMvY29yZS9TaWduYXR1cmUuanM/OTEzNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSW52YWxpZFZFcnJvciA9IGV4cG9ydHMuSW52YWxpZFlQYXJpdHlFcnJvciA9IGV4cG9ydHMuSW52YWxpZFNFcnJvciA9IGV4cG9ydHMuSW52YWxpZFJFcnJvciA9IGV4cG9ydHMuTWlzc2luZ1Byb3BlcnRpZXNFcnJvciA9IGV4cG9ydHMuSW52YWxpZFNlcmlhbGl6ZWRTaXplRXJyb3IgPSB2b2lkIDA7XG5leHBvcnRzLmFzc2VydCA9IGFzc2VydDtcbmV4cG9ydHMuZnJvbUJ5dGVzID0gZnJvbUJ5dGVzO1xuZXhwb3J0cy5mcm9tSGV4ID0gZnJvbUhleDtcbmV4cG9ydHMuZXh0cmFjdCA9IGV4dHJhY3Q7XG5leHBvcnRzLmZyb20gPSBmcm9tO1xuZXhwb3J0cy5mcm9tRGVyQnl0ZXMgPSBmcm9tRGVyQnl0ZXM7XG5leHBvcnRzLmZyb21EZXJIZXggPSBmcm9tRGVySGV4O1xuZXhwb3J0cy5mcm9tTGVnYWN5ID0gZnJvbUxlZ2FjeTtcbmV4cG9ydHMuZnJvbVJwYyA9IGZyb21ScGM7XG5leHBvcnRzLmZyb21UdXBsZSA9IGZyb21UdXBsZTtcbmV4cG9ydHMudG9CeXRlcyA9IHRvQnl0ZXM7XG5leHBvcnRzLnRvSGV4ID0gdG9IZXg7XG5leHBvcnRzLnRvRGVyQnl0ZXMgPSB0b0RlckJ5dGVzO1xuZXhwb3J0cy50b0RlckhleCA9IHRvRGVySGV4O1xuZXhwb3J0cy50b0xlZ2FjeSA9IHRvTGVnYWN5O1xuZXhwb3J0cy50b1JwYyA9IHRvUnBjO1xuZXhwb3J0cy50b1R1cGxlID0gdG9UdXBsZTtcbmV4cG9ydHMudmFsaWRhdGUgPSB2YWxpZGF0ZTtcbmV4cG9ydHMudlRvWVBhcml0eSA9IHZUb1lQYXJpdHk7XG5leHBvcnRzLnlQYXJpdHlUb1YgPSB5UGFyaXR5VG9WO1xuY29uc3Qgc2VjcDI1NmsxXzEgPSByZXF1aXJlKFwiQG5vYmxlL2N1cnZlcy9zZWNwMjU2azFcIik7XG5jb25zdCBCeXRlcyA9IHJlcXVpcmUoXCIuL0J5dGVzLmpzXCIpO1xuY29uc3QgRXJyb3JzID0gcmVxdWlyZShcIi4vRXJyb3JzLmpzXCIpO1xuY29uc3QgSGV4ID0gcmVxdWlyZShcIi4vSGV4LmpzXCIpO1xuY29uc3QgSnNvbiA9IHJlcXVpcmUoXCIuL0pzb24uanNcIik7XG5jb25zdCBTb2xpZGl0eSA9IHJlcXVpcmUoXCIuL1NvbGlkaXR5LmpzXCIpO1xuZnVuY3Rpb24gYXNzZXJ0KHNpZ25hdHVyZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyByZWNvdmVyZWQgfSA9IG9wdGlvbnM7XG4gICAgaWYgKHR5cGVvZiBzaWduYXR1cmUuciA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHRocm93IG5ldyBNaXNzaW5nUHJvcGVydGllc0Vycm9yKHsgc2lnbmF0dXJlIH0pO1xuICAgIGlmICh0eXBlb2Ygc2lnbmF0dXJlLnMgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICB0aHJvdyBuZXcgTWlzc2luZ1Byb3BlcnRpZXNFcnJvcih7IHNpZ25hdHVyZSB9KTtcbiAgICBpZiAocmVjb3ZlcmVkICYmIHR5cGVvZiBzaWduYXR1cmUueVBhcml0eSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHRocm93IG5ldyBNaXNzaW5nUHJvcGVydGllc0Vycm9yKHsgc2lnbmF0dXJlIH0pO1xuICAgIGlmIChzaWduYXR1cmUuciA8IDBuIHx8IHNpZ25hdHVyZS5yID4gU29saWRpdHkubWF4VWludDI1NilcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRSRXJyb3IoeyB2YWx1ZTogc2lnbmF0dXJlLnIgfSk7XG4gICAgaWYgKHNpZ25hdHVyZS5zIDwgMG4gfHwgc2lnbmF0dXJlLnMgPiBTb2xpZGl0eS5tYXhVaW50MjU2KVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFNFcnJvcih7IHZhbHVlOiBzaWduYXR1cmUucyB9KTtcbiAgICBpZiAodHlwZW9mIHNpZ25hdHVyZS55UGFyaXR5ID09PSAnbnVtYmVyJyAmJlxuICAgICAgICBzaWduYXR1cmUueVBhcml0eSAhPT0gMCAmJlxuICAgICAgICBzaWduYXR1cmUueVBhcml0eSAhPT0gMSlcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRZUGFyaXR5RXJyb3IoeyB2YWx1ZTogc2lnbmF0dXJlLnlQYXJpdHkgfSk7XG59XG5mdW5jdGlvbiBmcm9tQnl0ZXMoc2lnbmF0dXJlKSB7XG4gICAgcmV0dXJuIGZyb21IZXgoSGV4LmZyb21CeXRlcyhzaWduYXR1cmUpKTtcbn1cbmZ1bmN0aW9uIGZyb21IZXgoc2lnbmF0dXJlKSB7XG4gICAgaWYgKHNpZ25hdHVyZS5sZW5ndGggIT09IDEzMCAmJiBzaWduYXR1cmUubGVuZ3RoICE9PSAxMzIpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkU2VyaWFsaXplZFNpemVFcnJvcih7IHNpZ25hdHVyZSB9KTtcbiAgICBjb25zdCByID0gQmlnSW50KEhleC5zbGljZShzaWduYXR1cmUsIDAsIDMyKSk7XG4gICAgY29uc3QgcyA9IEJpZ0ludChIZXguc2xpY2Uoc2lnbmF0dXJlLCAzMiwgNjQpKTtcbiAgICBjb25zdCB5UGFyaXR5ID0gKCgpID0+IHtcbiAgICAgICAgY29uc3QgeVBhcml0eSA9IE51bWJlcihgMHgke3NpZ25hdHVyZS5zbGljZSgxMzApfWApO1xuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKHlQYXJpdHkpKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB2VG9ZUGFyaXR5KHlQYXJpdHkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkWVBhcml0eUVycm9yKHsgdmFsdWU6IHlQYXJpdHkgfSk7XG4gICAgICAgIH1cbiAgICB9KSgpO1xuICAgIGlmICh0eXBlb2YgeVBhcml0eSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByLFxuICAgICAgICAgICAgcyxcbiAgICAgICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICByLFxuICAgICAgICBzLFxuICAgICAgICB5UGFyaXR5LFxuICAgIH07XG59XG5mdW5jdGlvbiBleHRyYWN0KHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZS5yID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBpZiAodHlwZW9mIHZhbHVlLnMgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHJldHVybiBmcm9tKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGZyb20oc2lnbmF0dXJlKSB7XG4gICAgY29uc3Qgc2lnbmF0dXJlXyA9ICgoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2lnbmF0dXJlID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiBmcm9tSGV4KHNpZ25hdHVyZSk7XG4gICAgICAgIGlmIChzaWduYXR1cmUgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuICAgICAgICAgICAgcmV0dXJuIGZyb21CeXRlcyhzaWduYXR1cmUpO1xuICAgICAgICBpZiAodHlwZW9mIHNpZ25hdHVyZS5yID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiBmcm9tUnBjKHNpZ25hdHVyZSk7XG4gICAgICAgIGlmIChzaWduYXR1cmUudilcbiAgICAgICAgICAgIHJldHVybiBmcm9tTGVnYWN5KHNpZ25hdHVyZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByOiBzaWduYXR1cmUucixcbiAgICAgICAgICAgIHM6IHNpZ25hdHVyZS5zLFxuICAgICAgICAgICAgLi4uKHR5cGVvZiBzaWduYXR1cmUueVBhcml0eSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgICA/IHsgeVBhcml0eTogc2lnbmF0dXJlLnlQYXJpdHkgfVxuICAgICAgICAgICAgICAgIDoge30pLFxuICAgICAgICB9O1xuICAgIH0pKCk7XG4gICAgYXNzZXJ0KHNpZ25hdHVyZV8pO1xuICAgIHJldHVybiBzaWduYXR1cmVfO1xufVxuZnVuY3Rpb24gZnJvbURlckJ5dGVzKHNpZ25hdHVyZSkge1xuICAgIHJldHVybiBmcm9tRGVySGV4KEhleC5mcm9tQnl0ZXMoc2lnbmF0dXJlKSk7XG59XG5mdW5jdGlvbiBmcm9tRGVySGV4KHNpZ25hdHVyZSkge1xuICAgIGNvbnN0IHsgciwgcyB9ID0gc2VjcDI1NmsxXzEuc2VjcDI1NmsxLlNpZ25hdHVyZS5mcm9tREVSKEhleC5mcm9tKHNpZ25hdHVyZSkuc2xpY2UoMikpO1xuICAgIHJldHVybiB7IHIsIHMgfTtcbn1cbmZ1bmN0aW9uIGZyb21MZWdhY3koc2lnbmF0dXJlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcjogc2lnbmF0dXJlLnIsXG4gICAgICAgIHM6IHNpZ25hdHVyZS5zLFxuICAgICAgICB5UGFyaXR5OiB2VG9ZUGFyaXR5KHNpZ25hdHVyZS52KSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZnJvbVJwYyhzaWduYXR1cmUpIHtcbiAgICBjb25zdCB5UGFyaXR5ID0gKCgpID0+IHtcbiAgICAgICAgY29uc3QgdiA9IHNpZ25hdHVyZS52ID8gTnVtYmVyKHNpZ25hdHVyZS52KSA6IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IHlQYXJpdHkgPSBzaWduYXR1cmUueVBhcml0eSA/IE51bWJlcihzaWduYXR1cmUueVBhcml0eSkgOiB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0eXBlb2YgdiA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHlQYXJpdHkgIT09ICdudW1iZXInKVxuICAgICAgICAgICAgeVBhcml0eSA9IHZUb1lQYXJpdHkodik7XG4gICAgICAgIGlmICh0eXBlb2YgeVBhcml0eSAhPT0gJ251bWJlcicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFlQYXJpdHlFcnJvcih7IHZhbHVlOiBzaWduYXR1cmUueVBhcml0eSB9KTtcbiAgICAgICAgcmV0dXJuIHlQYXJpdHk7XG4gICAgfSkoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICByOiBCaWdJbnQoc2lnbmF0dXJlLnIpLFxuICAgICAgICBzOiBCaWdJbnQoc2lnbmF0dXJlLnMpLFxuICAgICAgICB5UGFyaXR5LFxuICAgIH07XG59XG5mdW5jdGlvbiBmcm9tVHVwbGUodHVwbGUpIHtcbiAgICBjb25zdCBbeVBhcml0eSwgciwgc10gPSB0dXBsZTtcbiAgICByZXR1cm4gZnJvbSh7XG4gICAgICAgIHI6IHIgPT09ICcweCcgPyAwbiA6IEJpZ0ludChyKSxcbiAgICAgICAgczogcyA9PT0gJzB4JyA/IDBuIDogQmlnSW50KHMpLFxuICAgICAgICB5UGFyaXR5OiB5UGFyaXR5ID09PSAnMHgnID8gMCA6IE51bWJlcih5UGFyaXR5KSxcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHRvQnl0ZXMoc2lnbmF0dXJlKSB7XG4gICAgcmV0dXJuIEJ5dGVzLmZyb21IZXgodG9IZXgoc2lnbmF0dXJlKSk7XG59XG5mdW5jdGlvbiB0b0hleChzaWduYXR1cmUpIHtcbiAgICBhc3NlcnQoc2lnbmF0dXJlKTtcbiAgICBjb25zdCByID0gc2lnbmF0dXJlLnI7XG4gICAgY29uc3QgcyA9IHNpZ25hdHVyZS5zO1xuICAgIGNvbnN0IHNpZ25hdHVyZV8gPSBIZXguY29uY2F0KEhleC5mcm9tTnVtYmVyKHIsIHsgc2l6ZTogMzIgfSksIEhleC5mcm9tTnVtYmVyKHMsIHsgc2l6ZTogMzIgfSksIHR5cGVvZiBzaWduYXR1cmUueVBhcml0eSA9PT0gJ251bWJlcidcbiAgICAgICAgPyBIZXguZnJvbU51bWJlcih5UGFyaXR5VG9WKHNpZ25hdHVyZS55UGFyaXR5KSwgeyBzaXplOiAxIH0pXG4gICAgICAgIDogJzB4Jyk7XG4gICAgcmV0dXJuIHNpZ25hdHVyZV87XG59XG5mdW5jdGlvbiB0b0RlckJ5dGVzKHNpZ25hdHVyZSkge1xuICAgIGNvbnN0IHNpZyA9IG5ldyBzZWNwMjU2azFfMS5zZWNwMjU2azEuU2lnbmF0dXJlKHNpZ25hdHVyZS5yLCBzaWduYXR1cmUucyk7XG4gICAgcmV0dXJuIHNpZy50b0RFUlJhd0J5dGVzKCk7XG59XG5mdW5jdGlvbiB0b0RlckhleChzaWduYXR1cmUpIHtcbiAgICBjb25zdCBzaWcgPSBuZXcgc2VjcDI1NmsxXzEuc2VjcDI1NmsxLlNpZ25hdHVyZShzaWduYXR1cmUuciwgc2lnbmF0dXJlLnMpO1xuICAgIHJldHVybiBgMHgke3NpZy50b0RFUkhleCgpfWA7XG59XG5mdW5jdGlvbiB0b0xlZ2FjeShzaWduYXR1cmUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICByOiBzaWduYXR1cmUucixcbiAgICAgICAgczogc2lnbmF0dXJlLnMsXG4gICAgICAgIHY6IHlQYXJpdHlUb1Yoc2lnbmF0dXJlLnlQYXJpdHkpLFxuICAgIH07XG59XG5mdW5jdGlvbiB0b1JwYyhzaWduYXR1cmUpIHtcbiAgICBjb25zdCB7IHIsIHMsIHlQYXJpdHkgfSA9IHNpZ25hdHVyZTtcbiAgICByZXR1cm4ge1xuICAgICAgICByOiBIZXguZnJvbU51bWJlcihyLCB7IHNpemU6IDMyIH0pLFxuICAgICAgICBzOiBIZXguZnJvbU51bWJlcihzLCB7IHNpemU6IDMyIH0pLFxuICAgICAgICB5UGFyaXR5OiB5UGFyaXR5ID09PSAwID8gJzB4MCcgOiAnMHgxJyxcbiAgICB9O1xufVxuZnVuY3Rpb24gdG9UdXBsZShzaWduYXR1cmUpIHtcbiAgICBjb25zdCB7IHIsIHMsIHlQYXJpdHkgfSA9IHNpZ25hdHVyZTtcbiAgICByZXR1cm4gW1xuICAgICAgICB5UGFyaXR5ID8gJzB4MDEnIDogJzB4JyxcbiAgICAgICAgciA9PT0gMG4gPyAnMHgnIDogSGV4LnRyaW1MZWZ0KEhleC5mcm9tTnVtYmVyKHIpKSxcbiAgICAgICAgcyA9PT0gMG4gPyAnMHgnIDogSGV4LnRyaW1MZWZ0KEhleC5mcm9tTnVtYmVyKHMpKSxcbiAgICBdO1xufVxuZnVuY3Rpb24gdmFsaWRhdGUoc2lnbmF0dXJlLCBvcHRpb25zID0ge30pIHtcbiAgICB0cnkge1xuICAgICAgICBhc3NlcnQoc2lnbmF0dXJlLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZUb1lQYXJpdHkodikge1xuICAgIGlmICh2ID09PSAwIHx8IHYgPT09IDI3KVxuICAgICAgICByZXR1cm4gMDtcbiAgICBpZiAodiA9PT0gMSB8fCB2ID09PSAyOClcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgaWYgKHYgPj0gMzUpXG4gICAgICAgIHJldHVybiB2ICUgMiA9PT0gMCA/IDEgOiAwO1xuICAgIHRocm93IG5ldyBJbnZhbGlkVkVycm9yKHsgdmFsdWU6IHYgfSk7XG59XG5mdW5jdGlvbiB5UGFyaXR5VG9WKHlQYXJpdHkpIHtcbiAgICBpZiAoeVBhcml0eSA9PT0gMClcbiAgICAgICAgcmV0dXJuIDI3O1xuICAgIGlmICh5UGFyaXR5ID09PSAxKVxuICAgICAgICByZXR1cm4gMjg7XG4gICAgdGhyb3cgbmV3IEludmFsaWRZUGFyaXR5RXJyb3IoeyB2YWx1ZTogeVBhcml0eSB9KTtcbn1cbmNsYXNzIEludmFsaWRTZXJpYWxpemVkU2l6ZUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBzaWduYXR1cmUgfSkge1xuICAgICAgICBzdXBlcihgVmFsdWUgXFxgJHtzaWduYXR1cmV9XFxgIGlzIGFuIGludmFsaWQgc2lnbmF0dXJlIHNpemUuYCwge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXG4gICAgICAgICAgICAgICAgJ0V4cGVjdGVkOiA2NCBieXRlcyBvciA2NSBieXRlcy4nLFxuICAgICAgICAgICAgICAgIGBSZWNlaXZlZCAke0hleC5zaXplKEhleC5mcm9tKHNpZ25hdHVyZSkpfSBieXRlcy5gLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdTaWduYXR1cmUuSW52YWxpZFNlcmlhbGl6ZWRTaXplRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuSW52YWxpZFNlcmlhbGl6ZWRTaXplRXJyb3IgPSBJbnZhbGlkU2VyaWFsaXplZFNpemVFcnJvcjtcbmNsYXNzIE1pc3NpbmdQcm9wZXJ0aWVzRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHNpZ25hdHVyZSB9KSB7XG4gICAgICAgIHN1cGVyKGBTaWduYXR1cmUgXFxgJHtKc29uLnN0cmluZ2lmeShzaWduYXR1cmUpfVxcYCBpcyBtaXNzaW5nIGVpdGhlciBhbiBcXGByXFxgLCBcXGBzXFxgLCBvciBcXGB5UGFyaXR5XFxgIHByb3BlcnR5LmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnU2lnbmF0dXJlLk1pc3NpbmdQcm9wZXJ0aWVzRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuTWlzc2luZ1Byb3BlcnRpZXNFcnJvciA9IE1pc3NpbmdQcm9wZXJ0aWVzRXJyb3I7XG5jbGFzcyBJbnZhbGlkUkVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyB2YWx1ZSB9KSB7XG4gICAgICAgIHN1cGVyKGBWYWx1ZSBcXGAke3ZhbHVlfVxcYCBpcyBhbiBpbnZhbGlkIHIgdmFsdWUuIHIgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgbGVzcyB0aGFuIDJeMjU2LmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnU2lnbmF0dXJlLkludmFsaWRSRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuSW52YWxpZFJFcnJvciA9IEludmFsaWRSRXJyb3I7XG5jbGFzcyBJbnZhbGlkU0Vycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyB2YWx1ZSB9KSB7XG4gICAgICAgIHN1cGVyKGBWYWx1ZSBcXGAke3ZhbHVlfVxcYCBpcyBhbiBpbnZhbGlkIHMgdmFsdWUuIHMgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgbGVzcyB0aGFuIDJeMjU2LmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnU2lnbmF0dXJlLkludmFsaWRTRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuSW52YWxpZFNFcnJvciA9IEludmFsaWRTRXJyb3I7XG5jbGFzcyBJbnZhbGlkWVBhcml0eUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyB2YWx1ZSB9KSB7XG4gICAgICAgIHN1cGVyKGBWYWx1ZSBcXGAke3ZhbHVlfVxcYCBpcyBhbiBpbnZhbGlkIHktcGFyaXR5IHZhbHVlLiBZLXBhcml0eSBtdXN0IGJlIDAgb3IgMS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1NpZ25hdHVyZS5JbnZhbGlkWVBhcml0eUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkludmFsaWRZUGFyaXR5RXJyb3IgPSBJbnZhbGlkWVBhcml0eUVycm9yO1xuY2xhc3MgSW52YWxpZFZFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgdmFsdWUgfSkge1xuICAgICAgICBzdXBlcihgVmFsdWUgXFxgJHt2YWx1ZX1cXGAgaXMgYW4gaW52YWxpZCB2IHZhbHVlLiB2IG11c3QgYmUgMjcsIDI4IG9yID49MzUuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdTaWduYXR1cmUuSW52YWxpZFZFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5JbnZhbGlkVkVycm9yID0gSW52YWxpZFZFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNpZ25hdHVyZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJJbnZhbGlkVkVycm9yIiwiSW52YWxpZFlQYXJpdHlFcnJvciIsIkludmFsaWRTRXJyb3IiLCJJbnZhbGlkUkVycm9yIiwiTWlzc2luZ1Byb3BlcnRpZXNFcnJvciIsIkludmFsaWRTZXJpYWxpemVkU2l6ZUVycm9yIiwiYXNzZXJ0IiwiZnJvbUJ5dGVzIiwiZnJvbUhleCIsImV4dHJhY3QiLCJmcm9tIiwiZnJvbURlckJ5dGVzIiwiZnJvbURlckhleCIsImZyb21MZWdhY3kiLCJmcm9tUnBjIiwiZnJvbVR1cGxlIiwidG9CeXRlcyIsInRvSGV4IiwidG9EZXJCeXRlcyIsInRvRGVySGV4IiwidG9MZWdhY3kiLCJ0b1JwYyIsInRvVHVwbGUiLCJ2YWxpZGF0ZSIsInZUb1lQYXJpdHkiLCJ5UGFyaXR5VG9WIiwic2VjcDI1NmsxXzEiLCJyZXF1aXJlIiwiQnl0ZXMiLCJFcnJvcnMiLCJIZXgiLCJKc29uIiwiU29saWRpdHkiLCJzaWduYXR1cmUiLCJvcHRpb25zIiwicmVjb3ZlcmVkIiwiciIsInMiLCJ5UGFyaXR5IiwibWF4VWludDI1NiIsImxlbmd0aCIsIkJpZ0ludCIsInNsaWNlIiwiTnVtYmVyIiwiaXNOYU4iLCJ1bmRlZmluZWQiLCJzaWduYXR1cmVfIiwiVWludDhBcnJheSIsInYiLCJzZWNwMjU2azEiLCJTaWduYXR1cmUiLCJmcm9tREVSIiwidHVwbGUiLCJjb25jYXQiLCJmcm9tTnVtYmVyIiwic2l6ZSIsInNpZyIsInRvREVSUmF3Qnl0ZXMiLCJ0b0RFUkhleCIsInRyaW1MZWZ0IiwiQmFzZUVycm9yIiwiY29uc3RydWN0b3IiLCJtZXRhTWVzc2FnZXMiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJzdHJpbmdpZnkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_cjs/core/Signature.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_cjs/core/Solidity.js":
/*!***********************************************!*\
  !*** ./node_modules/ox/_cjs/core/Solidity.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.minInt120 = exports.minInt112 = exports.minInt104 = exports.minInt96 = exports.minInt88 = exports.minInt80 = exports.minInt72 = exports.minInt64 = exports.minInt56 = exports.minInt48 = exports.minInt40 = exports.minInt32 = exports.minInt24 = exports.minInt16 = exports.minInt8 = exports.maxInt256 = exports.maxInt248 = exports.maxInt240 = exports.maxInt232 = exports.maxInt224 = exports.maxInt216 = exports.maxInt208 = exports.maxInt200 = exports.maxInt192 = exports.maxInt184 = exports.maxInt176 = exports.maxInt168 = exports.maxInt160 = exports.maxInt152 = exports.maxInt144 = exports.maxInt136 = exports.maxInt128 = exports.maxInt120 = exports.maxInt112 = exports.maxInt104 = exports.maxInt96 = exports.maxInt88 = exports.maxInt80 = exports.maxInt72 = exports.maxInt64 = exports.maxInt56 = exports.maxInt48 = exports.maxInt40 = exports.maxInt32 = exports.maxInt24 = exports.maxInt16 = exports.maxInt8 = exports.integerRegex = exports.bytesRegex = exports.arrayRegex = void 0;\nexports.maxUint256 = exports.maxUint248 = exports.maxUint240 = exports.maxUint232 = exports.maxUint224 = exports.maxUint216 = exports.maxUint208 = exports.maxUint200 = exports.maxUint192 = exports.maxUint184 = exports.maxUint176 = exports.maxUint168 = exports.maxUint160 = exports.maxUint152 = exports.maxUint144 = exports.maxUint136 = exports.maxUint128 = exports.maxUint120 = exports.maxUint112 = exports.maxUint104 = exports.maxUint96 = exports.maxUint88 = exports.maxUint80 = exports.maxUint72 = exports.maxUint64 = exports.maxUint56 = exports.maxUint48 = exports.maxUint40 = exports.maxUint32 = exports.maxUint24 = exports.maxUint16 = exports.maxUint8 = exports.minInt256 = exports.minInt248 = exports.minInt240 = exports.minInt232 = exports.minInt224 = exports.minInt216 = exports.minInt208 = exports.minInt200 = exports.minInt192 = exports.minInt184 = exports.minInt176 = exports.minInt168 = exports.minInt160 = exports.minInt152 = exports.minInt144 = exports.minInt136 = exports.minInt128 = void 0;\nexports.arrayRegex = /^(.*)\\[([0-9]*)\\]$/;\nexports.bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;\nexports.integerRegex = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;\nexports.maxInt8 = 2n ** (8n - 1n) - 1n;\nexports.maxInt16 = 2n ** (16n - 1n) - 1n;\nexports.maxInt24 = 2n ** (24n - 1n) - 1n;\nexports.maxInt32 = 2n ** (32n - 1n) - 1n;\nexports.maxInt40 = 2n ** (40n - 1n) - 1n;\nexports.maxInt48 = 2n ** (48n - 1n) - 1n;\nexports.maxInt56 = 2n ** (56n - 1n) - 1n;\nexports.maxInt64 = 2n ** (64n - 1n) - 1n;\nexports.maxInt72 = 2n ** (72n - 1n) - 1n;\nexports.maxInt80 = 2n ** (80n - 1n) - 1n;\nexports.maxInt88 = 2n ** (88n - 1n) - 1n;\nexports.maxInt96 = 2n ** (96n - 1n) - 1n;\nexports.maxInt104 = 2n ** (104n - 1n) - 1n;\nexports.maxInt112 = 2n ** (112n - 1n) - 1n;\nexports.maxInt120 = 2n ** (120n - 1n) - 1n;\nexports.maxInt128 = 2n ** (128n - 1n) - 1n;\nexports.maxInt136 = 2n ** (136n - 1n) - 1n;\nexports.maxInt144 = 2n ** (144n - 1n) - 1n;\nexports.maxInt152 = 2n ** (152n - 1n) - 1n;\nexports.maxInt160 = 2n ** (160n - 1n) - 1n;\nexports.maxInt168 = 2n ** (168n - 1n) - 1n;\nexports.maxInt176 = 2n ** (176n - 1n) - 1n;\nexports.maxInt184 = 2n ** (184n - 1n) - 1n;\nexports.maxInt192 = 2n ** (192n - 1n) - 1n;\nexports.maxInt200 = 2n ** (200n - 1n) - 1n;\nexports.maxInt208 = 2n ** (208n - 1n) - 1n;\nexports.maxInt216 = 2n ** (216n - 1n) - 1n;\nexports.maxInt224 = 2n ** (224n - 1n) - 1n;\nexports.maxInt232 = 2n ** (232n - 1n) - 1n;\nexports.maxInt240 = 2n ** (240n - 1n) - 1n;\nexports.maxInt248 = 2n ** (248n - 1n) - 1n;\nexports.maxInt256 = 2n ** (256n - 1n) - 1n;\nexports.minInt8 = -(2n ** (8n - 1n));\nexports.minInt16 = -(2n ** (16n - 1n));\nexports.minInt24 = -(2n ** (24n - 1n));\nexports.minInt32 = -(2n ** (32n - 1n));\nexports.minInt40 = -(2n ** (40n - 1n));\nexports.minInt48 = -(2n ** (48n - 1n));\nexports.minInt56 = -(2n ** (56n - 1n));\nexports.minInt64 = -(2n ** (64n - 1n));\nexports.minInt72 = -(2n ** (72n - 1n));\nexports.minInt80 = -(2n ** (80n - 1n));\nexports.minInt88 = -(2n ** (88n - 1n));\nexports.minInt96 = -(2n ** (96n - 1n));\nexports.minInt104 = -(2n ** (104n - 1n));\nexports.minInt112 = -(2n ** (112n - 1n));\nexports.minInt120 = -(2n ** (120n - 1n));\nexports.minInt128 = -(2n ** (128n - 1n));\nexports.minInt136 = -(2n ** (136n - 1n));\nexports.minInt144 = -(2n ** (144n - 1n));\nexports.minInt152 = -(2n ** (152n - 1n));\nexports.minInt160 = -(2n ** (160n - 1n));\nexports.minInt168 = -(2n ** (168n - 1n));\nexports.minInt176 = -(2n ** (176n - 1n));\nexports.minInt184 = -(2n ** (184n - 1n));\nexports.minInt192 = -(2n ** (192n - 1n));\nexports.minInt200 = -(2n ** (200n - 1n));\nexports.minInt208 = -(2n ** (208n - 1n));\nexports.minInt216 = -(2n ** (216n - 1n));\nexports.minInt224 = -(2n ** (224n - 1n));\nexports.minInt232 = -(2n ** (232n - 1n));\nexports.minInt240 = -(2n ** (240n - 1n));\nexports.minInt248 = -(2n ** (248n - 1n));\nexports.minInt256 = -(2n ** (256n - 1n));\nexports.maxUint8 = 2n ** 8n - 1n;\nexports.maxUint16 = 2n ** 16n - 1n;\nexports.maxUint24 = 2n ** 24n - 1n;\nexports.maxUint32 = 2n ** 32n - 1n;\nexports.maxUint40 = 2n ** 40n - 1n;\nexports.maxUint48 = 2n ** 48n - 1n;\nexports.maxUint56 = 2n ** 56n - 1n;\nexports.maxUint64 = 2n ** 64n - 1n;\nexports.maxUint72 = 2n ** 72n - 1n;\nexports.maxUint80 = 2n ** 80n - 1n;\nexports.maxUint88 = 2n ** 88n - 1n;\nexports.maxUint96 = 2n ** 96n - 1n;\nexports.maxUint104 = 2n ** 104n - 1n;\nexports.maxUint112 = 2n ** 112n - 1n;\nexports.maxUint120 = 2n ** 120n - 1n;\nexports.maxUint128 = 2n ** 128n - 1n;\nexports.maxUint136 = 2n ** 136n - 1n;\nexports.maxUint144 = 2n ** 144n - 1n;\nexports.maxUint152 = 2n ** 152n - 1n;\nexports.maxUint160 = 2n ** 160n - 1n;\nexports.maxUint168 = 2n ** 168n - 1n;\nexports.maxUint176 = 2n ** 176n - 1n;\nexports.maxUint184 = 2n ** 184n - 1n;\nexports.maxUint192 = 2n ** 192n - 1n;\nexports.maxUint200 = 2n ** 200n - 1n;\nexports.maxUint208 = 2n ** 208n - 1n;\nexports.maxUint216 = 2n ** 216n - 1n;\nexports.maxUint224 = 2n ** 224n - 1n;\nexports.maxUint232 = 2n ** 232n - 1n;\nexports.maxUint240 = 2n ** 240n - 1n;\nexports.maxUint248 = 2n ** 248n - 1n;\nexports.maxUint256 = 2n ** 256n - 1n; //# sourceMappingURL=Solidity.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2Nqcy9jb3JlL1NvbGlkaXR5LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxpQkFBaUIsR0FBR0EsaUJBQWlCLEdBQUdBLGlCQUFpQixHQUFHQSxnQkFBZ0IsR0FBR0EsZ0JBQWdCLEdBQUdBLGdCQUFnQixHQUFHQSxnQkFBZ0IsR0FBR0EsZ0JBQWdCLEdBQUdBLGdCQUFnQixHQUFHQSxnQkFBZ0IsR0FBR0EsZ0JBQWdCLEdBQUdBLGdCQUFnQixHQUFHQSxnQkFBZ0IsR0FBR0EsZ0JBQWdCLEdBQUdBLGVBQWUsR0FBR0EsaUJBQWlCLEdBQUdBLGlCQUFpQixHQUFHQSxpQkFBaUIsR0FBR0EsaUJBQWlCLEdBQUdBLGlCQUFpQixHQUFHQSxpQkFBaUIsR0FBR0EsaUJBQWlCLEdBQUdBLGlCQUFpQixHQUFHQSxpQkFBaUIsR0FBR0EsaUJBQWlCLEdBQUdBLGlCQUFpQixHQUFHQSxpQkFBaUIsR0FBR0EsaUJBQWlCLEdBQUdBLGlCQUFpQixHQUFHQSxpQkFBaUIsR0FBR0EsaUJBQWlCLEdBQUdBLGlCQUFpQixHQUFHQSxpQkFBaUIsR0FBR0EsaUJBQWlCLEdBQUdBLGlCQUFpQixHQUFHQSxnQkFBZ0IsR0FBR0EsZ0JBQWdCLEdBQUdBLGdCQUFnQixHQUFHQSxnQkFBZ0IsR0FBR0EsZ0JBQWdCLEdBQUdBLGdCQUFnQixHQUFHQSxnQkFBZ0IsR0FBR0EsZ0JBQWdCLEdBQUdBLGdCQUFnQixHQUFHQSxnQkFBZ0IsR0FBR0EsZ0JBQWdCLEdBQUdBLGVBQWUsR0FBR0Esb0JBQW9CLEdBQUdBLGtCQUFrQixHQUFHQSxrQkFBa0IsR0FBRyxLQUFLO0FBQ3g5QkEsa0JBQWtCLEdBQUdBLGtCQUFrQixHQUFHQSxrQkFBa0IsR0FBR0Esa0JBQWtCLEdBQUdBLGtCQUFrQixHQUFHQSxrQkFBa0IsR0FBR0Esa0JBQWtCLEdBQUdBLGtCQUFrQixHQUFHQSxrQkFBa0IsR0FBR0Esa0JBQWtCLEdBQUdBLGtCQUFrQixHQUFHQSxrQkFBa0IsR0FBR0Esa0JBQWtCLEdBQUdBLGtCQUFrQixHQUFHQSxrQkFBa0IsR0FBR0Esa0JBQWtCLEdBQUdBLGtCQUFrQixHQUFHQSxrQkFBa0IsR0FBR0Esa0JBQWtCLEdBQUdBLGtCQUFrQixHQUFHQSxpQkFBaUIsR0FBR0EsaUJBQWlCLEdBQUdBLGlCQUFpQixHQUFHQSxpQkFBaUIsR0FBR0EsaUJBQWlCLEdBQUdBLGlCQUFpQixHQUFHQSxpQkFBaUIsR0FBR0EsaUJBQWlCLEdBQUdBLGlCQUFpQixHQUFHQSxpQkFBaUIsR0FBR0EsaUJBQWlCLEdBQUdBLGdCQUFnQixHQUFHQSxpQkFBaUIsR0FBR0EsaUJBQWlCLEdBQUdBLGlCQUFpQixHQUFHQSxpQkFBaUIsR0FBR0EsaUJBQWlCLEdBQUdBLGlCQUFpQixHQUFHQSxpQkFBaUIsR0FBR0EsaUJBQWlCLEdBQUdBLGlCQUFpQixHQUFHQSxpQkFBaUIsR0FBR0EsaUJBQWlCLEdBQUdBLGlCQUFpQixHQUFHQSxpQkFBaUIsR0FBR0EsaUJBQWlCLEdBQUdBLGlCQUFpQixHQUFHQSxpQkFBaUIsR0FBR0EsaUJBQWlCLEdBQUcsS0FBSztBQUM1K0JBLGtCQUFrQixHQUFHO0FBQ3JCQSxrQkFBa0IsR0FBRztBQUNyQkEsb0JBQW9CLEdBQUc7QUFDdkJBLGVBQWUsR0FBRyxFQUFFLElBQUssR0FBRSxHQUFHLEVBQUUsSUFBSSxFQUFFO0FBQ3RDQSxnQkFBZ0IsR0FBRyxFQUFFLElBQUssSUFBRyxHQUFHLEVBQUUsSUFBSSxFQUFFO0FBQ3hDQSxnQkFBZ0IsR0FBRyxFQUFFLElBQUssSUFBRyxHQUFHLEVBQUUsSUFBSSxFQUFFO0FBQ3hDQSxnQkFBZ0IsR0FBRyxFQUFFLElBQUssSUFBRyxHQUFHLEVBQUUsSUFBSSxFQUFFO0FBQ3hDQSxnQkFBZ0IsR0FBRyxFQUFFLElBQUssSUFBRyxHQUFHLEVBQUUsSUFBSSxFQUFFO0FBQ3hDQSxnQkFBZ0IsR0FBRyxFQUFFLElBQUssSUFBRyxHQUFHLEVBQUUsSUFBSSxFQUFFO0FBQ3hDQSxnQkFBZ0IsR0FBRyxFQUFFLElBQUssSUFBRyxHQUFHLEVBQUUsSUFBSSxFQUFFO0FBQ3hDQSxnQkFBZ0IsR0FBRyxFQUFFLElBQUssSUFBRyxHQUFHLEVBQUUsSUFBSSxFQUFFO0FBQ3hDQSxnQkFBZ0IsR0FBRyxFQUFFLElBQUssSUFBRyxHQUFHLEVBQUUsSUFBSSxFQUFFO0FBQ3hDQSxnQkFBZ0IsR0FBRyxFQUFFLElBQUssSUFBRyxHQUFHLEVBQUUsSUFBSSxFQUFFO0FBQ3hDQSxnQkFBZ0IsR0FBRyxFQUFFLElBQUssSUFBRyxHQUFHLEVBQUUsSUFBSSxFQUFFO0FBQ3hDQSxnQkFBZ0IsR0FBRyxFQUFFLElBQUssSUFBRyxHQUFHLEVBQUUsSUFBSSxFQUFFO0FBQ3hDQSxpQkFBaUIsR0FBRyxFQUFFLElBQUssS0FBSSxHQUFHLEVBQUUsSUFBSSxFQUFFO0FBQzFDQSxpQkFBaUIsR0FBRyxFQUFFLElBQUssS0FBSSxHQUFHLEVBQUUsSUFBSSxFQUFFO0FBQzFDQSxpQkFBaUIsR0FBRyxFQUFFLElBQUssS0FBSSxHQUFHLEVBQUUsSUFBSSxFQUFFO0FBQzFDQSxpQkFBaUIsR0FBRyxFQUFFLElBQUssS0FBSSxHQUFHLEVBQUUsSUFBSSxFQUFFO0FBQzFDQSxpQkFBaUIsR0FBRyxFQUFFLElBQUssS0FBSSxHQUFHLEVBQUUsSUFBSSxFQUFFO0FBQzFDQSxpQkFBaUIsR0FBRyxFQUFFLElBQUssS0FBSSxHQUFHLEVBQUUsSUFBSSxFQUFFO0FBQzFDQSxpQkFBaUIsR0FBRyxFQUFFLElBQUssS0FBSSxHQUFHLEVBQUUsSUFBSSxFQUFFO0FBQzFDQSxpQkFBaUIsR0FBRyxFQUFFLElBQUssS0FBSSxHQUFHLEVBQUUsSUFBSSxFQUFFO0FBQzFDQSxpQkFBaUIsR0FBRyxFQUFFLElBQUssS0FBSSxHQUFHLEVBQUUsSUFBSSxFQUFFO0FBQzFDQSxpQkFBaUIsR0FBRyxFQUFFLElBQUssS0FBSSxHQUFHLEVBQUUsSUFBSSxFQUFFO0FBQzFDQSxpQkFBaUIsR0FBRyxFQUFFLElBQUssS0FBSSxHQUFHLEVBQUUsSUFBSSxFQUFFO0FBQzFDQSxpQkFBaUIsR0FBRyxFQUFFLElBQUssS0FBSSxHQUFHLEVBQUUsSUFBSSxFQUFFO0FBQzFDQSxpQkFBaUIsR0FBRyxFQUFFLElBQUssS0FBSSxHQUFHLEVBQUUsSUFBSSxFQUFFO0FBQzFDQSxpQkFBaUIsR0FBRyxFQUFFLElBQUssS0FBSSxHQUFHLEVBQUUsSUFBSSxFQUFFO0FBQzFDQSxpQkFBaUIsR0FBRyxFQUFFLElBQUssS0FBSSxHQUFHLEVBQUUsSUFBSSxFQUFFO0FBQzFDQSxpQkFBaUIsR0FBRyxFQUFFLElBQUssS0FBSSxHQUFHLEVBQUUsSUFBSSxFQUFFO0FBQzFDQSxpQkFBaUIsR0FBRyxFQUFFLElBQUssS0FBSSxHQUFHLEVBQUUsSUFBSSxFQUFFO0FBQzFDQSxpQkFBaUIsR0FBRyxFQUFFLElBQUssS0FBSSxHQUFHLEVBQUUsSUFBSSxFQUFFO0FBQzFDQSxpQkFBaUIsR0FBRyxFQUFFLElBQUssS0FBSSxHQUFHLEVBQUUsSUFBSSxFQUFFO0FBQzFDQSxpQkFBaUIsR0FBRyxFQUFFLElBQUssS0FBSSxHQUFHLEVBQUUsSUFBSSxFQUFFO0FBQzFDQSxlQUFlLEdBQUcsQ0FBRSxHQUFFLElBQUssR0FBRSxHQUFHLEVBQUU7QUFDbENBLGdCQUFnQixHQUFHLENBQUUsR0FBRSxJQUFLLElBQUcsR0FBRyxFQUFFO0FBQ3BDQSxnQkFBZ0IsR0FBRyxDQUFFLEdBQUUsSUFBSyxJQUFHLEdBQUcsRUFBRTtBQUNwQ0EsZ0JBQWdCLEdBQUcsQ0FBRSxHQUFFLElBQUssSUFBRyxHQUFHLEVBQUU7QUFDcENBLGdCQUFnQixHQUFHLENBQUUsR0FBRSxJQUFLLElBQUcsR0FBRyxFQUFFO0FBQ3BDQSxnQkFBZ0IsR0FBRyxDQUFFLEdBQUUsSUFBSyxJQUFHLEdBQUcsRUFBRTtBQUNwQ0EsZ0JBQWdCLEdBQUcsQ0FBRSxHQUFFLElBQUssSUFBRyxHQUFHLEVBQUU7QUFDcENBLGdCQUFnQixHQUFHLENBQUUsR0FBRSxJQUFLLElBQUcsR0FBRyxFQUFFO0FBQ3BDQSxnQkFBZ0IsR0FBRyxDQUFFLEdBQUUsSUFBSyxJQUFHLEdBQUcsRUFBRTtBQUNwQ0EsZ0JBQWdCLEdBQUcsQ0FBRSxHQUFFLElBQUssSUFBRyxHQUFHLEVBQUU7QUFDcENBLGdCQUFnQixHQUFHLENBQUUsR0FBRSxJQUFLLElBQUcsR0FBRyxFQUFFO0FBQ3BDQSxnQkFBZ0IsR0FBRyxDQUFFLEdBQUUsSUFBSyxJQUFHLEdBQUcsRUFBRTtBQUNwQ0EsaUJBQWlCLEdBQUcsQ0FBRSxHQUFFLElBQUssS0FBSSxHQUFHLEVBQUU7QUFDdENBLGlCQUFpQixHQUFHLENBQUUsR0FBRSxJQUFLLEtBQUksR0FBRyxFQUFFO0FBQ3RDQSxpQkFBaUIsR0FBRyxDQUFFLEdBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRTtBQUN0Q0EsaUJBQWlCLEdBQUcsQ0FBRSxHQUFFLElBQUssS0FBSSxHQUFHLEVBQUU7QUFDdENBLGlCQUFpQixHQUFHLENBQUUsR0FBRSxJQUFLLEtBQUksR0FBRyxFQUFFO0FBQ3RDQSxpQkFBaUIsR0FBRyxDQUFFLEdBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRTtBQUN0Q0EsaUJBQWlCLEdBQUcsQ0FBRSxHQUFFLElBQUssS0FBSSxHQUFHLEVBQUU7QUFDdENBLGlCQUFpQixHQUFHLENBQUUsR0FBRSxJQUFLLEtBQUksR0FBRyxFQUFFO0FBQ3RDQSxpQkFBaUIsR0FBRyxDQUFFLEdBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRTtBQUN0Q0EsaUJBQWlCLEdBQUcsQ0FBRSxHQUFFLElBQUssS0FBSSxHQUFHLEVBQUU7QUFDdENBLGlCQUFpQixHQUFHLENBQUUsR0FBRSxJQUFLLEtBQUksR0FBRyxFQUFFO0FBQ3RDQSxpQkFBaUIsR0FBRyxDQUFFLEdBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRTtBQUN0Q0EsaUJBQWlCLEdBQUcsQ0FBRSxHQUFFLElBQUssS0FBSSxHQUFHLEVBQUU7QUFDdENBLGlCQUFpQixHQUFHLENBQUUsR0FBRSxJQUFLLEtBQUksR0FBRyxFQUFFO0FBQ3RDQSxpQkFBaUIsR0FBRyxDQUFFLEdBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRTtBQUN0Q0EsaUJBQWlCLEdBQUcsQ0FBRSxHQUFFLElBQUssS0FBSSxHQUFHLEVBQUU7QUFDdENBLGlCQUFpQixHQUFHLENBQUUsR0FBRSxJQUFLLEtBQUksR0FBRyxFQUFFO0FBQ3RDQSxpQkFBaUIsR0FBRyxDQUFFLEdBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRTtBQUN0Q0EsaUJBQWlCLEdBQUcsQ0FBRSxHQUFFLElBQUssS0FBSSxHQUFHLEVBQUU7QUFDdENBLGlCQUFpQixHQUFHLENBQUUsR0FBRSxJQUFLLEtBQUksR0FBRyxFQUFFO0FBQ3RDQSxnQkFBZ0IsR0FBRyxFQUFFLElBQUksRUFBRSxHQUFHLEVBQUU7QUFDaENBLGlCQUFpQixHQUFHLEVBQUUsSUFBSSxHQUFHLEdBQUcsRUFBRTtBQUNsQ0EsaUJBQWlCLEdBQUcsRUFBRSxJQUFJLEdBQUcsR0FBRyxFQUFFO0FBQ2xDQSxpQkFBaUIsR0FBRyxFQUFFLElBQUksR0FBRyxHQUFHLEVBQUU7QUFDbENBLGlCQUFpQixHQUFHLEVBQUUsSUFBSSxHQUFHLEdBQUcsRUFBRTtBQUNsQ0EsaUJBQWlCLEdBQUcsRUFBRSxJQUFJLEdBQUcsR0FBRyxFQUFFO0FBQ2xDQSxpQkFBaUIsR0FBRyxFQUFFLElBQUksR0FBRyxHQUFHLEVBQUU7QUFDbENBLGlCQUFpQixHQUFHLEVBQUUsSUFBSSxHQUFHLEdBQUcsRUFBRTtBQUNsQ0EsaUJBQWlCLEdBQUcsRUFBRSxJQUFJLEdBQUcsR0FBRyxFQUFFO0FBQ2xDQSxpQkFBaUIsR0FBRyxFQUFFLElBQUksR0FBRyxHQUFHLEVBQUU7QUFDbENBLGlCQUFpQixHQUFHLEVBQUUsSUFBSSxHQUFHLEdBQUcsRUFBRTtBQUNsQ0EsaUJBQWlCLEdBQUcsRUFBRSxJQUFJLEdBQUcsR0FBRyxFQUFFO0FBQ2xDQSxrQkFBa0IsR0FBRyxFQUFFLElBQUksSUFBSSxHQUFHLEVBQUU7QUFDcENBLGtCQUFrQixHQUFHLEVBQUUsSUFBSSxJQUFJLEdBQUcsRUFBRTtBQUNwQ0Esa0JBQWtCLEdBQUcsRUFBRSxJQUFJLElBQUksR0FBRyxFQUFFO0FBQ3BDQSxrQkFBa0IsR0FBRyxFQUFFLElBQUksSUFBSSxHQUFHLEVBQUU7QUFDcENBLGtCQUFrQixHQUFHLEVBQUUsSUFBSSxJQUFJLEdBQUcsRUFBRTtBQUNwQ0Esa0JBQWtCLEdBQUcsRUFBRSxJQUFJLElBQUksR0FBRyxFQUFFO0FBQ3BDQSxrQkFBa0IsR0FBRyxFQUFFLElBQUksSUFBSSxHQUFHLEVBQUU7QUFDcENBLGtCQUFrQixHQUFHLEVBQUUsSUFBSSxJQUFJLEdBQUcsRUFBRTtBQUNwQ0Esa0JBQWtCLEdBQUcsRUFBRSxJQUFJLElBQUksR0FBRyxFQUFFO0FBQ3BDQSxrQkFBa0IsR0FBRyxFQUFFLElBQUksSUFBSSxHQUFHLEVBQUU7QUFDcENBLGtCQUFrQixHQUFHLEVBQUUsSUFBSSxJQUFJLEdBQUcsRUFBRTtBQUNwQ0Esa0JBQWtCLEdBQUcsRUFBRSxJQUFJLElBQUksR0FBRyxFQUFFO0FBQ3BDQSxrQkFBa0IsR0FBRyxFQUFFLElBQUksSUFBSSxHQUFHLEVBQUU7QUFDcENBLGtCQUFrQixHQUFHLEVBQUUsSUFBSSxJQUFJLEdBQUcsRUFBRTtBQUNwQ0Esa0JBQWtCLEdBQUcsRUFBRSxJQUFJLElBQUksR0FBRyxFQUFFO0FBQ3BDQSxrQkFBa0IsR0FBRyxFQUFFLElBQUksSUFBSSxHQUFHLEVBQUU7QUFDcENBLGtCQUFrQixHQUFHLEVBQUUsSUFBSSxJQUFJLEdBQUcsRUFBRTtBQUNwQ0Esa0JBQWtCLEdBQUcsRUFBRSxJQUFJLElBQUksR0FBRyxFQUFFO0FBQ3BDQSxrQkFBa0IsR0FBRyxFQUFFLElBQUksSUFBSSxHQUFHLEVBQUU7QUFDcENBLGtCQUFrQixHQUFHLEVBQUUsSUFBSSxJQUFJLEdBQUcsRUFBRSxFQUNwQyxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGF3LXdvcmtzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L19janMvY29yZS9Tb2xpZGl0eS5qcz9kYmMzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5taW5JbnQxMjAgPSBleHBvcnRzLm1pbkludDExMiA9IGV4cG9ydHMubWluSW50MTA0ID0gZXhwb3J0cy5taW5JbnQ5NiA9IGV4cG9ydHMubWluSW50ODggPSBleHBvcnRzLm1pbkludDgwID0gZXhwb3J0cy5taW5JbnQ3MiA9IGV4cG9ydHMubWluSW50NjQgPSBleHBvcnRzLm1pbkludDU2ID0gZXhwb3J0cy5taW5JbnQ0OCA9IGV4cG9ydHMubWluSW50NDAgPSBleHBvcnRzLm1pbkludDMyID0gZXhwb3J0cy5taW5JbnQyNCA9IGV4cG9ydHMubWluSW50MTYgPSBleHBvcnRzLm1pbkludDggPSBleHBvcnRzLm1heEludDI1NiA9IGV4cG9ydHMubWF4SW50MjQ4ID0gZXhwb3J0cy5tYXhJbnQyNDAgPSBleHBvcnRzLm1heEludDIzMiA9IGV4cG9ydHMubWF4SW50MjI0ID0gZXhwb3J0cy5tYXhJbnQyMTYgPSBleHBvcnRzLm1heEludDIwOCA9IGV4cG9ydHMubWF4SW50MjAwID0gZXhwb3J0cy5tYXhJbnQxOTIgPSBleHBvcnRzLm1heEludDE4NCA9IGV4cG9ydHMubWF4SW50MTc2ID0gZXhwb3J0cy5tYXhJbnQxNjggPSBleHBvcnRzLm1heEludDE2MCA9IGV4cG9ydHMubWF4SW50MTUyID0gZXhwb3J0cy5tYXhJbnQxNDQgPSBleHBvcnRzLm1heEludDEzNiA9IGV4cG9ydHMubWF4SW50MTI4ID0gZXhwb3J0cy5tYXhJbnQxMjAgPSBleHBvcnRzLm1heEludDExMiA9IGV4cG9ydHMubWF4SW50MTA0ID0gZXhwb3J0cy5tYXhJbnQ5NiA9IGV4cG9ydHMubWF4SW50ODggPSBleHBvcnRzLm1heEludDgwID0gZXhwb3J0cy5tYXhJbnQ3MiA9IGV4cG9ydHMubWF4SW50NjQgPSBleHBvcnRzLm1heEludDU2ID0gZXhwb3J0cy5tYXhJbnQ0OCA9IGV4cG9ydHMubWF4SW50NDAgPSBleHBvcnRzLm1heEludDMyID0gZXhwb3J0cy5tYXhJbnQyNCA9IGV4cG9ydHMubWF4SW50MTYgPSBleHBvcnRzLm1heEludDggPSBleHBvcnRzLmludGVnZXJSZWdleCA9IGV4cG9ydHMuYnl0ZXNSZWdleCA9IGV4cG9ydHMuYXJyYXlSZWdleCA9IHZvaWQgMDtcbmV4cG9ydHMubWF4VWludDI1NiA9IGV4cG9ydHMubWF4VWludDI0OCA9IGV4cG9ydHMubWF4VWludDI0MCA9IGV4cG9ydHMubWF4VWludDIzMiA9IGV4cG9ydHMubWF4VWludDIyNCA9IGV4cG9ydHMubWF4VWludDIxNiA9IGV4cG9ydHMubWF4VWludDIwOCA9IGV4cG9ydHMubWF4VWludDIwMCA9IGV4cG9ydHMubWF4VWludDE5MiA9IGV4cG9ydHMubWF4VWludDE4NCA9IGV4cG9ydHMubWF4VWludDE3NiA9IGV4cG9ydHMubWF4VWludDE2OCA9IGV4cG9ydHMubWF4VWludDE2MCA9IGV4cG9ydHMubWF4VWludDE1MiA9IGV4cG9ydHMubWF4VWludDE0NCA9IGV4cG9ydHMubWF4VWludDEzNiA9IGV4cG9ydHMubWF4VWludDEyOCA9IGV4cG9ydHMubWF4VWludDEyMCA9IGV4cG9ydHMubWF4VWludDExMiA9IGV4cG9ydHMubWF4VWludDEwNCA9IGV4cG9ydHMubWF4VWludDk2ID0gZXhwb3J0cy5tYXhVaW50ODggPSBleHBvcnRzLm1heFVpbnQ4MCA9IGV4cG9ydHMubWF4VWludDcyID0gZXhwb3J0cy5tYXhVaW50NjQgPSBleHBvcnRzLm1heFVpbnQ1NiA9IGV4cG9ydHMubWF4VWludDQ4ID0gZXhwb3J0cy5tYXhVaW50NDAgPSBleHBvcnRzLm1heFVpbnQzMiA9IGV4cG9ydHMubWF4VWludDI0ID0gZXhwb3J0cy5tYXhVaW50MTYgPSBleHBvcnRzLm1heFVpbnQ4ID0gZXhwb3J0cy5taW5JbnQyNTYgPSBleHBvcnRzLm1pbkludDI0OCA9IGV4cG9ydHMubWluSW50MjQwID0gZXhwb3J0cy5taW5JbnQyMzIgPSBleHBvcnRzLm1pbkludDIyNCA9IGV4cG9ydHMubWluSW50MjE2ID0gZXhwb3J0cy5taW5JbnQyMDggPSBleHBvcnRzLm1pbkludDIwMCA9IGV4cG9ydHMubWluSW50MTkyID0gZXhwb3J0cy5taW5JbnQxODQgPSBleHBvcnRzLm1pbkludDE3NiA9IGV4cG9ydHMubWluSW50MTY4ID0gZXhwb3J0cy5taW5JbnQxNjAgPSBleHBvcnRzLm1pbkludDE1MiA9IGV4cG9ydHMubWluSW50MTQ0ID0gZXhwb3J0cy5taW5JbnQxMzYgPSBleHBvcnRzLm1pbkludDEyOCA9IHZvaWQgMDtcbmV4cG9ydHMuYXJyYXlSZWdleCA9IC9eKC4qKVxcWyhbMC05XSopXFxdJC87XG5leHBvcnRzLmJ5dGVzUmVnZXggPSAvXmJ5dGVzKFsxLTldfDFbMC05XXwyWzAtOV18M1swLTJdKT8kLztcbmV4cG9ydHMuaW50ZWdlclJlZ2V4ID0gL14odT9pbnQpKDh8MTZ8MjR8MzJ8NDB8NDh8NTZ8NjR8NzJ8ODB8ODh8OTZ8MTA0fDExMnwxMjB8MTI4fDEzNnwxNDR8MTUyfDE2MHwxNjh8MTc2fDE4NHwxOTJ8MjAwfDIwOHwyMTZ8MjI0fDIzMnwyNDB8MjQ4fDI1Nik/JC87XG5leHBvcnRzLm1heEludDggPSAybiAqKiAoOG4gLSAxbikgLSAxbjtcbmV4cG9ydHMubWF4SW50MTYgPSAybiAqKiAoMTZuIC0gMW4pIC0gMW47XG5leHBvcnRzLm1heEludDI0ID0gMm4gKiogKDI0biAtIDFuKSAtIDFuO1xuZXhwb3J0cy5tYXhJbnQzMiA9IDJuICoqICgzMm4gLSAxbikgLSAxbjtcbmV4cG9ydHMubWF4SW50NDAgPSAybiAqKiAoNDBuIC0gMW4pIC0gMW47XG5leHBvcnRzLm1heEludDQ4ID0gMm4gKiogKDQ4biAtIDFuKSAtIDFuO1xuZXhwb3J0cy5tYXhJbnQ1NiA9IDJuICoqICg1Nm4gLSAxbikgLSAxbjtcbmV4cG9ydHMubWF4SW50NjQgPSAybiAqKiAoNjRuIC0gMW4pIC0gMW47XG5leHBvcnRzLm1heEludDcyID0gMm4gKiogKDcybiAtIDFuKSAtIDFuO1xuZXhwb3J0cy5tYXhJbnQ4MCA9IDJuICoqICg4MG4gLSAxbikgLSAxbjtcbmV4cG9ydHMubWF4SW50ODggPSAybiAqKiAoODhuIC0gMW4pIC0gMW47XG5leHBvcnRzLm1heEludDk2ID0gMm4gKiogKDk2biAtIDFuKSAtIDFuO1xuZXhwb3J0cy5tYXhJbnQxMDQgPSAybiAqKiAoMTA0biAtIDFuKSAtIDFuO1xuZXhwb3J0cy5tYXhJbnQxMTIgPSAybiAqKiAoMTEybiAtIDFuKSAtIDFuO1xuZXhwb3J0cy5tYXhJbnQxMjAgPSAybiAqKiAoMTIwbiAtIDFuKSAtIDFuO1xuZXhwb3J0cy5tYXhJbnQxMjggPSAybiAqKiAoMTI4biAtIDFuKSAtIDFuO1xuZXhwb3J0cy5tYXhJbnQxMzYgPSAybiAqKiAoMTM2biAtIDFuKSAtIDFuO1xuZXhwb3J0cy5tYXhJbnQxNDQgPSAybiAqKiAoMTQ0biAtIDFuKSAtIDFuO1xuZXhwb3J0cy5tYXhJbnQxNTIgPSAybiAqKiAoMTUybiAtIDFuKSAtIDFuO1xuZXhwb3J0cy5tYXhJbnQxNjAgPSAybiAqKiAoMTYwbiAtIDFuKSAtIDFuO1xuZXhwb3J0cy5tYXhJbnQxNjggPSAybiAqKiAoMTY4biAtIDFuKSAtIDFuO1xuZXhwb3J0cy5tYXhJbnQxNzYgPSAybiAqKiAoMTc2biAtIDFuKSAtIDFuO1xuZXhwb3J0cy5tYXhJbnQxODQgPSAybiAqKiAoMTg0biAtIDFuKSAtIDFuO1xuZXhwb3J0cy5tYXhJbnQxOTIgPSAybiAqKiAoMTkybiAtIDFuKSAtIDFuO1xuZXhwb3J0cy5tYXhJbnQyMDAgPSAybiAqKiAoMjAwbiAtIDFuKSAtIDFuO1xuZXhwb3J0cy5tYXhJbnQyMDggPSAybiAqKiAoMjA4biAtIDFuKSAtIDFuO1xuZXhwb3J0cy5tYXhJbnQyMTYgPSAybiAqKiAoMjE2biAtIDFuKSAtIDFuO1xuZXhwb3J0cy5tYXhJbnQyMjQgPSAybiAqKiAoMjI0biAtIDFuKSAtIDFuO1xuZXhwb3J0cy5tYXhJbnQyMzIgPSAybiAqKiAoMjMybiAtIDFuKSAtIDFuO1xuZXhwb3J0cy5tYXhJbnQyNDAgPSAybiAqKiAoMjQwbiAtIDFuKSAtIDFuO1xuZXhwb3J0cy5tYXhJbnQyNDggPSAybiAqKiAoMjQ4biAtIDFuKSAtIDFuO1xuZXhwb3J0cy5tYXhJbnQyNTYgPSAybiAqKiAoMjU2biAtIDFuKSAtIDFuO1xuZXhwb3J0cy5taW5JbnQ4ID0gLSgybiAqKiAoOG4gLSAxbikpO1xuZXhwb3J0cy5taW5JbnQxNiA9IC0oMm4gKiogKDE2biAtIDFuKSk7XG5leHBvcnRzLm1pbkludDI0ID0gLSgybiAqKiAoMjRuIC0gMW4pKTtcbmV4cG9ydHMubWluSW50MzIgPSAtKDJuICoqICgzMm4gLSAxbikpO1xuZXhwb3J0cy5taW5JbnQ0MCA9IC0oMm4gKiogKDQwbiAtIDFuKSk7XG5leHBvcnRzLm1pbkludDQ4ID0gLSgybiAqKiAoNDhuIC0gMW4pKTtcbmV4cG9ydHMubWluSW50NTYgPSAtKDJuICoqICg1Nm4gLSAxbikpO1xuZXhwb3J0cy5taW5JbnQ2NCA9IC0oMm4gKiogKDY0biAtIDFuKSk7XG5leHBvcnRzLm1pbkludDcyID0gLSgybiAqKiAoNzJuIC0gMW4pKTtcbmV4cG9ydHMubWluSW50ODAgPSAtKDJuICoqICg4MG4gLSAxbikpO1xuZXhwb3J0cy5taW5JbnQ4OCA9IC0oMm4gKiogKDg4biAtIDFuKSk7XG5leHBvcnRzLm1pbkludDk2ID0gLSgybiAqKiAoOTZuIC0gMW4pKTtcbmV4cG9ydHMubWluSW50MTA0ID0gLSgybiAqKiAoMTA0biAtIDFuKSk7XG5leHBvcnRzLm1pbkludDExMiA9IC0oMm4gKiogKDExMm4gLSAxbikpO1xuZXhwb3J0cy5taW5JbnQxMjAgPSAtKDJuICoqICgxMjBuIC0gMW4pKTtcbmV4cG9ydHMubWluSW50MTI4ID0gLSgybiAqKiAoMTI4biAtIDFuKSk7XG5leHBvcnRzLm1pbkludDEzNiA9IC0oMm4gKiogKDEzNm4gLSAxbikpO1xuZXhwb3J0cy5taW5JbnQxNDQgPSAtKDJuICoqICgxNDRuIC0gMW4pKTtcbmV4cG9ydHMubWluSW50MTUyID0gLSgybiAqKiAoMTUybiAtIDFuKSk7XG5leHBvcnRzLm1pbkludDE2MCA9IC0oMm4gKiogKDE2MG4gLSAxbikpO1xuZXhwb3J0cy5taW5JbnQxNjggPSAtKDJuICoqICgxNjhuIC0gMW4pKTtcbmV4cG9ydHMubWluSW50MTc2ID0gLSgybiAqKiAoMTc2biAtIDFuKSk7XG5leHBvcnRzLm1pbkludDE4NCA9IC0oMm4gKiogKDE4NG4gLSAxbikpO1xuZXhwb3J0cy5taW5JbnQxOTIgPSAtKDJuICoqICgxOTJuIC0gMW4pKTtcbmV4cG9ydHMubWluSW50MjAwID0gLSgybiAqKiAoMjAwbiAtIDFuKSk7XG5leHBvcnRzLm1pbkludDIwOCA9IC0oMm4gKiogKDIwOG4gLSAxbikpO1xuZXhwb3J0cy5taW5JbnQyMTYgPSAtKDJuICoqICgyMTZuIC0gMW4pKTtcbmV4cG9ydHMubWluSW50MjI0ID0gLSgybiAqKiAoMjI0biAtIDFuKSk7XG5leHBvcnRzLm1pbkludDIzMiA9IC0oMm4gKiogKDIzMm4gLSAxbikpO1xuZXhwb3J0cy5taW5JbnQyNDAgPSAtKDJuICoqICgyNDBuIC0gMW4pKTtcbmV4cG9ydHMubWluSW50MjQ4ID0gLSgybiAqKiAoMjQ4biAtIDFuKSk7XG5leHBvcnRzLm1pbkludDI1NiA9IC0oMm4gKiogKDI1Nm4gLSAxbikpO1xuZXhwb3J0cy5tYXhVaW50OCA9IDJuICoqIDhuIC0gMW47XG5leHBvcnRzLm1heFVpbnQxNiA9IDJuICoqIDE2biAtIDFuO1xuZXhwb3J0cy5tYXhVaW50MjQgPSAybiAqKiAyNG4gLSAxbjtcbmV4cG9ydHMubWF4VWludDMyID0gMm4gKiogMzJuIC0gMW47XG5leHBvcnRzLm1heFVpbnQ0MCA9IDJuICoqIDQwbiAtIDFuO1xuZXhwb3J0cy5tYXhVaW50NDggPSAybiAqKiA0OG4gLSAxbjtcbmV4cG9ydHMubWF4VWludDU2ID0gMm4gKiogNTZuIC0gMW47XG5leHBvcnRzLm1heFVpbnQ2NCA9IDJuICoqIDY0biAtIDFuO1xuZXhwb3J0cy5tYXhVaW50NzIgPSAybiAqKiA3Mm4gLSAxbjtcbmV4cG9ydHMubWF4VWludDgwID0gMm4gKiogODBuIC0gMW47XG5leHBvcnRzLm1heFVpbnQ4OCA9IDJuICoqIDg4biAtIDFuO1xuZXhwb3J0cy5tYXhVaW50OTYgPSAybiAqKiA5Nm4gLSAxbjtcbmV4cG9ydHMubWF4VWludDEwNCA9IDJuICoqIDEwNG4gLSAxbjtcbmV4cG9ydHMubWF4VWludDExMiA9IDJuICoqIDExMm4gLSAxbjtcbmV4cG9ydHMubWF4VWludDEyMCA9IDJuICoqIDEyMG4gLSAxbjtcbmV4cG9ydHMubWF4VWludDEyOCA9IDJuICoqIDEyOG4gLSAxbjtcbmV4cG9ydHMubWF4VWludDEzNiA9IDJuICoqIDEzNm4gLSAxbjtcbmV4cG9ydHMubWF4VWludDE0NCA9IDJuICoqIDE0NG4gLSAxbjtcbmV4cG9ydHMubWF4VWludDE1MiA9IDJuICoqIDE1Mm4gLSAxbjtcbmV4cG9ydHMubWF4VWludDE2MCA9IDJuICoqIDE2MG4gLSAxbjtcbmV4cG9ydHMubWF4VWludDE2OCA9IDJuICoqIDE2OG4gLSAxbjtcbmV4cG9ydHMubWF4VWludDE3NiA9IDJuICoqIDE3Nm4gLSAxbjtcbmV4cG9ydHMubWF4VWludDE4NCA9IDJuICoqIDE4NG4gLSAxbjtcbmV4cG9ydHMubWF4VWludDE5MiA9IDJuICoqIDE5Mm4gLSAxbjtcbmV4cG9ydHMubWF4VWludDIwMCA9IDJuICoqIDIwMG4gLSAxbjtcbmV4cG9ydHMubWF4VWludDIwOCA9IDJuICoqIDIwOG4gLSAxbjtcbmV4cG9ydHMubWF4VWludDIxNiA9IDJuICoqIDIxNm4gLSAxbjtcbmV4cG9ydHMubWF4VWludDIyNCA9IDJuICoqIDIyNG4gLSAxbjtcbmV4cG9ydHMubWF4VWludDIzMiA9IDJuICoqIDIzMm4gLSAxbjtcbmV4cG9ydHMubWF4VWludDI0MCA9IDJuICoqIDI0MG4gLSAxbjtcbmV4cG9ydHMubWF4VWludDI0OCA9IDJuICoqIDI0OG4gLSAxbjtcbmV4cG9ydHMubWF4VWludDI1NiA9IDJuICoqIDI1Nm4gLSAxbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNvbGlkaXR5LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1pbkludDEyMCIsIm1pbkludDExMiIsIm1pbkludDEwNCIsIm1pbkludDk2IiwibWluSW50ODgiLCJtaW5JbnQ4MCIsIm1pbkludDcyIiwibWluSW50NjQiLCJtaW5JbnQ1NiIsIm1pbkludDQ4IiwibWluSW50NDAiLCJtaW5JbnQzMiIsIm1pbkludDI0IiwibWluSW50MTYiLCJtaW5JbnQ4IiwibWF4SW50MjU2IiwibWF4SW50MjQ4IiwibWF4SW50MjQwIiwibWF4SW50MjMyIiwibWF4SW50MjI0IiwibWF4SW50MjE2IiwibWF4SW50MjA4IiwibWF4SW50MjAwIiwibWF4SW50MTkyIiwibWF4SW50MTg0IiwibWF4SW50MTc2IiwibWF4SW50MTY4IiwibWF4SW50MTYwIiwibWF4SW50MTUyIiwibWF4SW50MTQ0IiwibWF4SW50MTM2IiwibWF4SW50MTI4IiwibWF4SW50MTIwIiwibWF4SW50MTEyIiwibWF4SW50MTA0IiwibWF4SW50OTYiLCJtYXhJbnQ4OCIsIm1heEludDgwIiwibWF4SW50NzIiLCJtYXhJbnQ2NCIsIm1heEludDU2IiwibWF4SW50NDgiLCJtYXhJbnQ0MCIsIm1heEludDMyIiwibWF4SW50MjQiLCJtYXhJbnQxNiIsIm1heEludDgiLCJpbnRlZ2VyUmVnZXgiLCJieXRlc1JlZ2V4IiwiYXJyYXlSZWdleCIsIm1heFVpbnQyNTYiLCJtYXhVaW50MjQ4IiwibWF4VWludDI0MCIsIm1heFVpbnQyMzIiLCJtYXhVaW50MjI0IiwibWF4VWludDIxNiIsIm1heFVpbnQyMDgiLCJtYXhVaW50MjAwIiwibWF4VWludDE5MiIsIm1heFVpbnQxODQiLCJtYXhVaW50MTc2IiwibWF4VWludDE2OCIsIm1heFVpbnQxNjAiLCJtYXhVaW50MTUyIiwibWF4VWludDE0NCIsIm1heFVpbnQxMzYiLCJtYXhVaW50MTI4IiwibWF4VWludDEyMCIsIm1heFVpbnQxMTIiLCJtYXhVaW50MTA0IiwibWF4VWludDk2IiwibWF4VWludDg4IiwibWF4VWludDgwIiwibWF4VWludDcyIiwibWF4VWludDY0IiwibWF4VWludDU2IiwibWF4VWludDQ4IiwibWF4VWludDQwIiwibWF4VWludDMyIiwibWF4VWludDI0IiwibWF4VWludDE2IiwibWF4VWludDgiLCJtaW5JbnQyNTYiLCJtaW5JbnQyNDgiLCJtaW5JbnQyNDAiLCJtaW5JbnQyMzIiLCJtaW5JbnQyMjQiLCJtaW5JbnQyMTYiLCJtaW5JbnQyMDgiLCJtaW5JbnQyMDAiLCJtaW5JbnQxOTIiLCJtaW5JbnQxODQiLCJtaW5JbnQxNzYiLCJtaW5JbnQxNjgiLCJtaW5JbnQxNjAiLCJtaW5JbnQxNTIiLCJtaW5JbnQxNDQiLCJtaW5JbnQxMzYiLCJtaW5JbnQxMjgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_cjs/core/Solidity.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_cjs/core/Withdrawal.js":
/*!*************************************************!*\
  !*** ./node_modules/ox/_cjs/core/Withdrawal.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.fromRpc = fromRpc;\nexports.toRpc = toRpc;\nconst Hex = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_cjs/core/Hex.js\");\nfunction fromRpc(withdrawal) {\n    return {\n        ...withdrawal,\n        amount: BigInt(withdrawal.amount),\n        index: Number(withdrawal.index),\n        validatorIndex: Number(withdrawal.validatorIndex)\n    };\n}\nfunction toRpc(withdrawal) {\n    return {\n        address: withdrawal.address,\n        amount: Hex.fromNumber(withdrawal.amount),\n        index: Hex.fromNumber(withdrawal.index),\n        validatorIndex: Hex.fromNumber(withdrawal.validatorIndex)\n    };\n} //# sourceMappingURL=Withdrawal.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2Nqcy9jb3JlL1dpdGhkcmF3YWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGVBQWUsR0FBR0U7QUFDbEJGLGFBQWEsR0FBR0c7QUFDaEIsTUFBTUMsTUFBTUMsbUJBQU9BLENBQUMsMERBQVU7QUFDOUIsU0FBU0gsUUFBUUksVUFBVTtJQUN2QixPQUFPO1FBQ0gsR0FBR0EsVUFBVTtRQUNiQyxRQUFRQyxPQUFPRixXQUFXQyxNQUFNO1FBQ2hDRSxPQUFPQyxPQUFPSixXQUFXRyxLQUFLO1FBQzlCRSxnQkFBZ0JELE9BQU9KLFdBQVdLLGNBQWM7SUFDcEQ7QUFDSjtBQUNBLFNBQVNSLE1BQU1HLFVBQVU7SUFDckIsT0FBTztRQUNITSxTQUFTTixXQUFXTSxPQUFPO1FBQzNCTCxRQUFRSCxJQUFJUyxVQUFVLENBQUNQLFdBQVdDLE1BQU07UUFDeENFLE9BQU9MLElBQUlTLFVBQVUsQ0FBQ1AsV0FBV0csS0FBSztRQUN0Q0UsZ0JBQWdCUCxJQUFJUyxVQUFVLENBQUNQLFdBQVdLLGNBQWM7SUFDNUQ7QUFDSixFQUNBLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsYXctd29ya3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3gvX2Nqcy9jb3JlL1dpdGhkcmF3YWwuanM/MmI5NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZnJvbVJwYyA9IGZyb21ScGM7XG5leHBvcnRzLnRvUnBjID0gdG9ScGM7XG5jb25zdCBIZXggPSByZXF1aXJlKFwiLi9IZXguanNcIik7XG5mdW5jdGlvbiBmcm9tUnBjKHdpdGhkcmF3YWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi53aXRoZHJhd2FsLFxuICAgICAgICBhbW91bnQ6IEJpZ0ludCh3aXRoZHJhd2FsLmFtb3VudCksXG4gICAgICAgIGluZGV4OiBOdW1iZXIod2l0aGRyYXdhbC5pbmRleCksXG4gICAgICAgIHZhbGlkYXRvckluZGV4OiBOdW1iZXIod2l0aGRyYXdhbC52YWxpZGF0b3JJbmRleCksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRvUnBjKHdpdGhkcmF3YWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBhZGRyZXNzOiB3aXRoZHJhd2FsLmFkZHJlc3MsXG4gICAgICAgIGFtb3VudDogSGV4LmZyb21OdW1iZXIod2l0aGRyYXdhbC5hbW91bnQpLFxuICAgICAgICBpbmRleDogSGV4LmZyb21OdW1iZXIod2l0aGRyYXdhbC5pbmRleCksXG4gICAgICAgIHZhbGlkYXRvckluZGV4OiBIZXguZnJvbU51bWJlcih3aXRoZHJhd2FsLnZhbGlkYXRvckluZGV4KSxcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9V2l0aGRyYXdhbC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJmcm9tUnBjIiwidG9ScGMiLCJIZXgiLCJyZXF1aXJlIiwid2l0aGRyYXdhbCIsImFtb3VudCIsIkJpZ0ludCIsImluZGV4IiwiTnVtYmVyIiwidmFsaWRhdG9ySW5kZXgiLCJhZGRyZXNzIiwiZnJvbU51bWJlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_cjs/core/Withdrawal.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_cjs/core/internal/abiItem.js":
/*!*******************************************************!*\
  !*** ./node_modules/ox/_cjs/core/internal/abiItem.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.normalizeSignature = normalizeSignature;\nexports.isArgOfType = isArgOfType;\nexports.getAmbiguousTypes = getAmbiguousTypes;\nconst Address = __webpack_require__(/*! ../Address.js */ \"(ssr)/./node_modules/ox/_cjs/core/Address.js\");\nconst Errors = __webpack_require__(/*! ../Errors.js */ \"(ssr)/./node_modules/ox/_cjs/core/Errors.js\");\nfunction normalizeSignature(signature) {\n    let active = true;\n    let current = \"\";\n    let level = 0;\n    let result = \"\";\n    let valid = false;\n    for(let i = 0; i < signature.length; i++){\n        const char = signature[i];\n        if ([\n            \"(\",\n            \")\",\n            \",\"\n        ].includes(char)) active = true;\n        if (char === \"(\") level++;\n        if (char === \")\") level--;\n        if (!active) continue;\n        if (level === 0) {\n            if (char === \" \" && [\n                \"event\",\n                \"function\",\n                \"error\",\n                \"\"\n            ].includes(result)) result = \"\";\n            else {\n                result += char;\n                if (char === \")\") {\n                    valid = true;\n                    break;\n                }\n            }\n            continue;\n        }\n        if (char === \" \") {\n            if (signature[i - 1] !== \",\" && current !== \",\" && current !== \",(\") {\n                current = \"\";\n                active = false;\n            }\n            continue;\n        }\n        result += char;\n        current += char;\n    }\n    if (!valid) throw new Errors.BaseError(\"Unable to normalize signature.\");\n    return result;\n}\nfunction isArgOfType(arg, abiParameter) {\n    const argType = typeof arg;\n    const abiParameterType = abiParameter.type;\n    switch(abiParameterType){\n        case \"address\":\n            return Address.validate(arg, {\n                strict: false\n            });\n        case \"bool\":\n            return argType === \"boolean\";\n        case \"function\":\n            return argType === \"string\";\n        case \"string\":\n            return argType === \"string\";\n        default:\n            {\n                if (abiParameterType === \"tuple\" && \"components\" in abiParameter) return Object.values(abiParameter.components).every((component, index)=>{\n                    return isArgOfType(Object.values(arg)[index], component);\n                });\n                if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType)) return argType === \"number\" || argType === \"bigint\";\n                if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType)) return argType === \"string\" || arg instanceof Uint8Array;\n                if (/[a-z]+[1-9]{0,3}(\\[[0-9]{0,}\\])+$/.test(abiParameterType)) {\n                    return Array.isArray(arg) && arg.every((x)=>isArgOfType(x, {\n                            ...abiParameter,\n                            type: abiParameterType.replace(/(\\[[0-9]{0,}\\])$/, \"\")\n                        }));\n                }\n                return false;\n            }\n    }\n}\nfunction getAmbiguousTypes(sourceParameters, targetParameters, args) {\n    for(const parameterIndex in sourceParameters){\n        const sourceParameter = sourceParameters[parameterIndex];\n        const targetParameter = targetParameters[parameterIndex];\n        if (sourceParameter.type === \"tuple\" && targetParameter.type === \"tuple\" && \"components\" in sourceParameter && \"components\" in targetParameter) return getAmbiguousTypes(sourceParameter.components, targetParameter.components, args[parameterIndex]);\n        const types = [\n            sourceParameter.type,\n            targetParameter.type\n        ];\n        const ambiguous = (()=>{\n            if (types.includes(\"address\") && types.includes(\"bytes20\")) return true;\n            if (types.includes(\"address\") && types.includes(\"string\")) return Address.validate(args[parameterIndex], {\n                strict: false\n            });\n            if (types.includes(\"address\") && types.includes(\"bytes\")) return Address.validate(args[parameterIndex], {\n                strict: false\n            });\n            return false;\n        })();\n        if (ambiguous) return types;\n    }\n    return;\n} //# sourceMappingURL=abiItem.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2Nqcy9jb3JlL2ludGVybmFsL2FiaUl0ZW0uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDBCQUEwQixHQUFHRTtBQUM3QkYsbUJBQW1CLEdBQUdHO0FBQ3RCSCx5QkFBeUIsR0FBR0k7QUFDNUIsTUFBTUMsVUFBVUMsbUJBQU9BLENBQUMsbUVBQWU7QUFDdkMsTUFBTUMsU0FBU0QsbUJBQU9BLENBQUMsaUVBQWM7QUFDckMsU0FBU0osbUJBQW1CTSxTQUFTO0lBQ2pDLElBQUlDLFNBQVM7SUFDYixJQUFJQyxVQUFVO0lBQ2QsSUFBSUMsUUFBUTtJQUNaLElBQUlDLFNBQVM7SUFDYixJQUFJQyxRQUFRO0lBQ1osSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlOLFVBQVVPLE1BQU0sRUFBRUQsSUFBSztRQUN2QyxNQUFNRSxPQUFPUixTQUFTLENBQUNNLEVBQUU7UUFDekIsSUFBSTtZQUFDO1lBQUs7WUFBSztTQUFJLENBQUNHLFFBQVEsQ0FBQ0QsT0FDekJQLFNBQVM7UUFDYixJQUFJTyxTQUFTLEtBQ1RMO1FBQ0osSUFBSUssU0FBUyxLQUNUTDtRQUNKLElBQUksQ0FBQ0YsUUFDRDtRQUNKLElBQUlFLFVBQVUsR0FBRztZQUNiLElBQUlLLFNBQVMsT0FBTztnQkFBQztnQkFBUztnQkFBWTtnQkFBUzthQUFHLENBQUNDLFFBQVEsQ0FBQ0wsU0FDNURBLFNBQVM7aUJBQ1I7Z0JBQ0RBLFVBQVVJO2dCQUNWLElBQUlBLFNBQVMsS0FBSztvQkFDZEgsUUFBUTtvQkFDUjtnQkFDSjtZQUNKO1lBQ0E7UUFDSjtRQUNBLElBQUlHLFNBQVMsS0FBSztZQUNkLElBQUlSLFNBQVMsQ0FBQ00sSUFBSSxFQUFFLEtBQUssT0FBT0osWUFBWSxPQUFPQSxZQUFZLE1BQU07Z0JBQ2pFQSxVQUFVO2dCQUNWRCxTQUFTO1lBQ2I7WUFDQTtRQUNKO1FBQ0FHLFVBQVVJO1FBQ1ZOLFdBQVdNO0lBQ2Y7SUFDQSxJQUFJLENBQUNILE9BQ0QsTUFBTSxJQUFJTixPQUFPVyxTQUFTLENBQUM7SUFDL0IsT0FBT047QUFDWDtBQUNBLFNBQVNULFlBQVlnQixHQUFHLEVBQUVDLFlBQVk7SUFDbEMsTUFBTUMsVUFBVSxPQUFPRjtJQUN2QixNQUFNRyxtQkFBbUJGLGFBQWFHLElBQUk7SUFDMUMsT0FBUUQ7UUFDSixLQUFLO1lBQ0QsT0FBT2pCLFFBQVFtQixRQUFRLENBQUNMLEtBQUs7Z0JBQUVNLFFBQVE7WUFBTTtRQUNqRCxLQUFLO1lBQ0QsT0FBT0osWUFBWTtRQUN2QixLQUFLO1lBQ0QsT0FBT0EsWUFBWTtRQUN2QixLQUFLO1lBQ0QsT0FBT0EsWUFBWTtRQUN2QjtZQUFTO2dCQUNMLElBQUlDLHFCQUFxQixXQUFXLGdCQUFnQkYsY0FDaEQsT0FBT3RCLE9BQU80QixNQUFNLENBQUNOLGFBQWFPLFVBQVUsRUFBRUMsS0FBSyxDQUFDLENBQUNDLFdBQVdDO29CQUM1RCxPQUFPM0IsWUFBWUwsT0FBTzRCLE1BQU0sQ0FBQ1AsSUFBSSxDQUFDVyxNQUFNLEVBQUVEO2dCQUNsRDtnQkFDSixJQUFJLCtIQUErSEUsSUFBSSxDQUFDVCxtQkFDcEksT0FBT0QsWUFBWSxZQUFZQSxZQUFZO2dCQUMvQyxJQUFJLHVDQUF1Q1UsSUFBSSxDQUFDVCxtQkFDNUMsT0FBT0QsWUFBWSxZQUFZRixlQUFlYTtnQkFDbEQsSUFBSSxvQ0FBb0NELElBQUksQ0FBQ1QsbUJBQW1CO29CQUM1RCxPQUFRVyxNQUFNQyxPQUFPLENBQUNmLFFBQ2xCQSxJQUFJUyxLQUFLLENBQUMsQ0FBQ08sSUFBTWhDLFlBQVlnQyxHQUFHOzRCQUM1QixHQUFHZixZQUFZOzRCQUNmRyxNQUFNRCxpQkFBaUJjLE9BQU8sQ0FBQyxvQkFBb0I7d0JBQ3ZEO2dCQUNSO2dCQUNBLE9BQU87WUFDWDtJQUNKO0FBQ0o7QUFDQSxTQUFTaEMsa0JBQWtCaUMsZ0JBQWdCLEVBQUVDLGdCQUFnQixFQUFFQyxJQUFJO0lBQy9ELElBQUssTUFBTUMsa0JBQWtCSCxpQkFBa0I7UUFDM0MsTUFBTUksa0JBQWtCSixnQkFBZ0IsQ0FBQ0csZUFBZTtRQUN4RCxNQUFNRSxrQkFBa0JKLGdCQUFnQixDQUFDRSxlQUFlO1FBQ3hELElBQUlDLGdCQUFnQmxCLElBQUksS0FBSyxXQUN6Qm1CLGdCQUFnQm5CLElBQUksS0FBSyxXQUN6QixnQkFBZ0JrQixtQkFDaEIsZ0JBQWdCQyxpQkFDaEIsT0FBT3RDLGtCQUFrQnFDLGdCQUFnQmQsVUFBVSxFQUFFZSxnQkFBZ0JmLFVBQVUsRUFBRVksSUFBSSxDQUFDQyxlQUFlO1FBQ3pHLE1BQU1HLFFBQVE7WUFBQ0YsZ0JBQWdCbEIsSUFBSTtZQUFFbUIsZ0JBQWdCbkIsSUFBSTtTQUFDO1FBQzFELE1BQU1xQixZQUFZLENBQUM7WUFDZixJQUFJRCxNQUFNMUIsUUFBUSxDQUFDLGNBQWMwQixNQUFNMUIsUUFBUSxDQUFDLFlBQzVDLE9BQU87WUFDWCxJQUFJMEIsTUFBTTFCLFFBQVEsQ0FBQyxjQUFjMEIsTUFBTTFCLFFBQVEsQ0FBQyxXQUM1QyxPQUFPWixRQUFRbUIsUUFBUSxDQUFDZSxJQUFJLENBQUNDLGVBQWUsRUFBRTtnQkFDMUNmLFFBQVE7WUFDWjtZQUNKLElBQUlrQixNQUFNMUIsUUFBUSxDQUFDLGNBQWMwQixNQUFNMUIsUUFBUSxDQUFDLFVBQzVDLE9BQU9aLFFBQVFtQixRQUFRLENBQUNlLElBQUksQ0FBQ0MsZUFBZSxFQUFFO2dCQUMxQ2YsUUFBUTtZQUNaO1lBQ0osT0FBTztRQUNYO1FBQ0EsSUFBSW1CLFdBQ0EsT0FBT0Q7SUFDZjtJQUNBO0FBQ0osRUFDQSxtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGF3LXdvcmtzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L19janMvY29yZS9pbnRlcm5hbC9hYmlJdGVtLmpzPzdkOTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm5vcm1hbGl6ZVNpZ25hdHVyZSA9IG5vcm1hbGl6ZVNpZ25hdHVyZTtcbmV4cG9ydHMuaXNBcmdPZlR5cGUgPSBpc0FyZ09mVHlwZTtcbmV4cG9ydHMuZ2V0QW1iaWd1b3VzVHlwZXMgPSBnZXRBbWJpZ3VvdXNUeXBlcztcbmNvbnN0IEFkZHJlc3MgPSByZXF1aXJlKFwiLi4vQWRkcmVzcy5qc1wiKTtcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoXCIuLi9FcnJvcnMuanNcIik7XG5mdW5jdGlvbiBub3JtYWxpemVTaWduYXR1cmUoc2lnbmF0dXJlKSB7XG4gICAgbGV0IGFjdGl2ZSA9IHRydWU7XG4gICAgbGV0IGN1cnJlbnQgPSAnJztcbiAgICBsZXQgbGV2ZWwgPSAwO1xuICAgIGxldCByZXN1bHQgPSAnJztcbiAgICBsZXQgdmFsaWQgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpZ25hdHVyZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjaGFyID0gc2lnbmF0dXJlW2ldO1xuICAgICAgICBpZiAoWycoJywgJyknLCAnLCddLmluY2x1ZGVzKGNoYXIpKVxuICAgICAgICAgICAgYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgaWYgKGNoYXIgPT09ICcoJylcbiAgICAgICAgICAgIGxldmVsKys7XG4gICAgICAgIGlmIChjaGFyID09PSAnKScpXG4gICAgICAgICAgICBsZXZlbC0tO1xuICAgICAgICBpZiAoIWFjdGl2ZSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAobGV2ZWwgPT09IDApIHtcbiAgICAgICAgICAgIGlmIChjaGFyID09PSAnICcgJiYgWydldmVudCcsICdmdW5jdGlvbicsICdlcnJvcicsICcnXS5pbmNsdWRlcyhyZXN1bHQpKVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9ICcnO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGNoYXI7XG4gICAgICAgICAgICAgICAgaWYgKGNoYXIgPT09ICcpJykge1xuICAgICAgICAgICAgICAgICAgICB2YWxpZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFyID09PSAnICcpIHtcbiAgICAgICAgICAgIGlmIChzaWduYXR1cmVbaSAtIDFdICE9PSAnLCcgJiYgY3VycmVudCAhPT0gJywnICYmIGN1cnJlbnQgIT09ICcsKCcpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gJyc7XG4gICAgICAgICAgICAgICAgYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gY2hhcjtcbiAgICAgICAgY3VycmVudCArPSBjaGFyO1xuICAgIH1cbiAgICBpZiAoIXZhbGlkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3JzLkJhc2VFcnJvcignVW5hYmxlIHRvIG5vcm1hbGl6ZSBzaWduYXR1cmUuJyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGlzQXJnT2ZUeXBlKGFyZywgYWJpUGFyYW1ldGVyKSB7XG4gICAgY29uc3QgYXJnVHlwZSA9IHR5cGVvZiBhcmc7XG4gICAgY29uc3QgYWJpUGFyYW1ldGVyVHlwZSA9IGFiaVBhcmFtZXRlci50eXBlO1xuICAgIHN3aXRjaCAoYWJpUGFyYW1ldGVyVHlwZSkge1xuICAgICAgICBjYXNlICdhZGRyZXNzJzpcbiAgICAgICAgICAgIHJldHVybiBBZGRyZXNzLnZhbGlkYXRlKGFyZywgeyBzdHJpY3Q6IGZhbHNlIH0pO1xuICAgICAgICBjYXNlICdib29sJzpcbiAgICAgICAgICAgIHJldHVybiBhcmdUeXBlID09PSAnYm9vbGVhbic7XG4gICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICAgIHJldHVybiBhcmdUeXBlID09PSAnc3RyaW5nJztcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIHJldHVybiBhcmdUeXBlID09PSAnc3RyaW5nJztcbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgaWYgKGFiaVBhcmFtZXRlclR5cGUgPT09ICd0dXBsZScgJiYgJ2NvbXBvbmVudHMnIGluIGFiaVBhcmFtZXRlcilcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhhYmlQYXJhbWV0ZXIuY29tcG9uZW50cykuZXZlcnkoKGNvbXBvbmVudCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzQXJnT2ZUeXBlKE9iamVjdC52YWx1ZXMoYXJnKVtpbmRleF0sIGNvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoL151P2ludCg4fDE2fDI0fDMyfDQwfDQ4fDU2fDY0fDcyfDgwfDg4fDk2fDEwNHwxMTJ8MTIwfDEyOHwxMzZ8MTQ0fDE1MnwxNjB8MTY4fDE3NnwxODR8MTkyfDIwMHwyMDh8MjE2fDIyNHwyMzJ8MjQwfDI0OHwyNTYpPyQvLnRlc3QoYWJpUGFyYW1ldGVyVHlwZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZ1R5cGUgPT09ICdudW1iZXInIHx8IGFyZ1R5cGUgPT09ICdiaWdpbnQnO1xuICAgICAgICAgICAgaWYgKC9eYnl0ZXMoWzEtOV18MVswLTldfDJbMC05XXwzWzAtMl0pPyQvLnRlc3QoYWJpUGFyYW1ldGVyVHlwZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZ1R5cGUgPT09ICdzdHJpbmcnIHx8IGFyZyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG4gICAgICAgICAgICBpZiAoL1thLXpdK1sxLTldezAsM30oXFxbWzAtOV17MCx9XFxdKSskLy50ZXN0KGFiaVBhcmFtZXRlclR5cGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChBcnJheS5pc0FycmF5KGFyZykgJiZcbiAgICAgICAgICAgICAgICAgICAgYXJnLmV2ZXJ5KCh4KSA9PiBpc0FyZ09mVHlwZSh4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5hYmlQYXJhbWV0ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBhYmlQYXJhbWV0ZXJUeXBlLnJlcGxhY2UoLyhcXFtbMC05XXswLH1cXF0pJC8sICcnKSxcbiAgICAgICAgICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEFtYmlndW91c1R5cGVzKHNvdXJjZVBhcmFtZXRlcnMsIHRhcmdldFBhcmFtZXRlcnMsIGFyZ3MpIHtcbiAgICBmb3IgKGNvbnN0IHBhcmFtZXRlckluZGV4IGluIHNvdXJjZVBhcmFtZXRlcnMpIHtcbiAgICAgICAgY29uc3Qgc291cmNlUGFyYW1ldGVyID0gc291cmNlUGFyYW1ldGVyc1twYXJhbWV0ZXJJbmRleF07XG4gICAgICAgIGNvbnN0IHRhcmdldFBhcmFtZXRlciA9IHRhcmdldFBhcmFtZXRlcnNbcGFyYW1ldGVySW5kZXhdO1xuICAgICAgICBpZiAoc291cmNlUGFyYW1ldGVyLnR5cGUgPT09ICd0dXBsZScgJiZcbiAgICAgICAgICAgIHRhcmdldFBhcmFtZXRlci50eXBlID09PSAndHVwbGUnICYmXG4gICAgICAgICAgICAnY29tcG9uZW50cycgaW4gc291cmNlUGFyYW1ldGVyICYmXG4gICAgICAgICAgICAnY29tcG9uZW50cycgaW4gdGFyZ2V0UGFyYW1ldGVyKVxuICAgICAgICAgICAgcmV0dXJuIGdldEFtYmlndW91c1R5cGVzKHNvdXJjZVBhcmFtZXRlci5jb21wb25lbnRzLCB0YXJnZXRQYXJhbWV0ZXIuY29tcG9uZW50cywgYXJnc1twYXJhbWV0ZXJJbmRleF0pO1xuICAgICAgICBjb25zdCB0eXBlcyA9IFtzb3VyY2VQYXJhbWV0ZXIudHlwZSwgdGFyZ2V0UGFyYW1ldGVyLnR5cGVdO1xuICAgICAgICBjb25zdCBhbWJpZ3VvdXMgPSAoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVzLmluY2x1ZGVzKCdhZGRyZXNzJykgJiYgdHlwZXMuaW5jbHVkZXMoJ2J5dGVzMjAnKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0eXBlcy5pbmNsdWRlcygnYWRkcmVzcycpICYmIHR5cGVzLmluY2x1ZGVzKCdzdHJpbmcnKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gQWRkcmVzcy52YWxpZGF0ZShhcmdzW3BhcmFtZXRlckluZGV4XSwge1xuICAgICAgICAgICAgICAgICAgICBzdHJpY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHR5cGVzLmluY2x1ZGVzKCdhZGRyZXNzJykgJiYgdHlwZXMuaW5jbHVkZXMoJ2J5dGVzJykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEFkZHJlc3MudmFsaWRhdGUoYXJnc1twYXJhbWV0ZXJJbmRleF0sIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgaWYgKGFtYmlndW91cylcbiAgICAgICAgICAgIHJldHVybiB0eXBlcztcbiAgICB9XG4gICAgcmV0dXJuO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWJpSXRlbS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJub3JtYWxpemVTaWduYXR1cmUiLCJpc0FyZ09mVHlwZSIsImdldEFtYmlndW91c1R5cGVzIiwiQWRkcmVzcyIsInJlcXVpcmUiLCJFcnJvcnMiLCJzaWduYXR1cmUiLCJhY3RpdmUiLCJjdXJyZW50IiwibGV2ZWwiLCJyZXN1bHQiLCJ2YWxpZCIsImkiLCJsZW5ndGgiLCJjaGFyIiwiaW5jbHVkZXMiLCJCYXNlRXJyb3IiLCJhcmciLCJhYmlQYXJhbWV0ZXIiLCJhcmdUeXBlIiwiYWJpUGFyYW1ldGVyVHlwZSIsInR5cGUiLCJ2YWxpZGF0ZSIsInN0cmljdCIsInZhbHVlcyIsImNvbXBvbmVudHMiLCJldmVyeSIsImNvbXBvbmVudCIsImluZGV4IiwidGVzdCIsIlVpbnQ4QXJyYXkiLCJBcnJheSIsImlzQXJyYXkiLCJ4IiwicmVwbGFjZSIsInNvdXJjZVBhcmFtZXRlcnMiLCJ0YXJnZXRQYXJhbWV0ZXJzIiwiYXJncyIsInBhcmFtZXRlckluZGV4Iiwic291cmNlUGFyYW1ldGVyIiwidGFyZ2V0UGFyYW1ldGVyIiwidHlwZXMiLCJhbWJpZ3VvdXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_cjs/core/internal/abiItem.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_cjs/core/internal/abiParameters.js":
/*!*************************************************************!*\
  !*** ./node_modules/ox/_cjs/core/internal/abiParameters.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.decodeParameter = decodeParameter;\nexports.decodeAddress = decodeAddress;\nexports.decodeArray = decodeArray;\nexports.decodeBool = decodeBool;\nexports.decodeBytes = decodeBytes;\nexports.decodeNumber = decodeNumber;\nexports.decodeTuple = decodeTuple;\nexports.decodeString = decodeString;\nexports.prepareParameters = prepareParameters;\nexports.prepareParameter = prepareParameter;\nexports.encode = encode;\nexports.encodeAddress = encodeAddress;\nexports.encodeArray = encodeArray;\nexports.encodeBytes = encodeBytes;\nexports.encodeBoolean = encodeBoolean;\nexports.encodeNumber = encodeNumber;\nexports.encodeString = encodeString;\nexports.encodeTuple = encodeTuple;\nexports.getArrayComponents = getArrayComponents;\nexports.hasDynamicChild = hasDynamicChild;\nconst AbiParameters = __webpack_require__(/*! ../AbiParameters.js */ \"(ssr)/./node_modules/ox/_cjs/core/AbiParameters.js\");\nconst Address = __webpack_require__(/*! ../Address.js */ \"(ssr)/./node_modules/ox/_cjs/core/Address.js\");\nconst Bytes = __webpack_require__(/*! ../Bytes.js */ \"(ssr)/./node_modules/ox/_cjs/core/Bytes.js\");\nconst Errors = __webpack_require__(/*! ../Errors.js */ \"(ssr)/./node_modules/ox/_cjs/core/Errors.js\");\nconst Hex = __webpack_require__(/*! ../Hex.js */ \"(ssr)/./node_modules/ox/_cjs/core/Hex.js\");\nconst Solidity_js_1 = __webpack_require__(/*! ../Solidity.js */ \"(ssr)/./node_modules/ox/_cjs/core/Solidity.js\");\nfunction decodeParameter(cursor, param, options) {\n    const { checksumAddress, staticPosition } = options;\n    const arrayComponents = getArrayComponents(param.type);\n    if (arrayComponents) {\n        const [length, type] = arrayComponents;\n        return decodeArray(cursor, {\n            ...param,\n            type\n        }, {\n            checksumAddress,\n            length,\n            staticPosition\n        });\n    }\n    if (param.type === \"tuple\") return decodeTuple(cursor, param, {\n        checksumAddress,\n        staticPosition\n    });\n    if (param.type === \"address\") return decodeAddress(cursor, {\n        checksum: checksumAddress\n    });\n    if (param.type === \"bool\") return decodeBool(cursor);\n    if (param.type.startsWith(\"bytes\")) return decodeBytes(cursor, param, {\n        staticPosition\n    });\n    if (param.type.startsWith(\"uint\") || param.type.startsWith(\"int\")) return decodeNumber(cursor, param);\n    if (param.type === \"string\") return decodeString(cursor, {\n        staticPosition\n    });\n    throw new AbiParameters.InvalidTypeError(param.type);\n}\nconst sizeOfLength = 32;\nconst sizeOfOffset = 32;\nfunction decodeAddress(cursor, options = {}) {\n    const { checksum = false } = options;\n    const value = cursor.readBytes(32);\n    const wrap = (address)=>checksum ? Address.checksum(address) : address;\n    return [\n        wrap(Hex.fromBytes(Bytes.slice(value, -20))),\n        32\n    ];\n}\nfunction decodeArray(cursor, param, options) {\n    const { checksumAddress, length, staticPosition } = options;\n    if (!length) {\n        const offset = Bytes.toNumber(cursor.readBytes(sizeOfOffset));\n        const start = staticPosition + offset;\n        const startOfData = start + sizeOfLength;\n        cursor.setPosition(start);\n        const length = Bytes.toNumber(cursor.readBytes(sizeOfLength));\n        const dynamicChild = hasDynamicChild(param);\n        let consumed = 0;\n        const value = [];\n        for(let i = 0; i < length; ++i){\n            cursor.setPosition(startOfData + (dynamicChild ? i * 32 : consumed));\n            const [data, consumed_] = decodeParameter(cursor, param, {\n                checksumAddress,\n                staticPosition: startOfData\n            });\n            consumed += consumed_;\n            value.push(data);\n        }\n        cursor.setPosition(staticPosition + 32);\n        return [\n            value,\n            32\n        ];\n    }\n    if (hasDynamicChild(param)) {\n        const offset = Bytes.toNumber(cursor.readBytes(sizeOfOffset));\n        const start = staticPosition + offset;\n        const value = [];\n        for(let i = 0; i < length; ++i){\n            cursor.setPosition(start + i * 32);\n            const [data] = decodeParameter(cursor, param, {\n                checksumAddress,\n                staticPosition: start\n            });\n            value.push(data);\n        }\n        cursor.setPosition(staticPosition + 32);\n        return [\n            value,\n            32\n        ];\n    }\n    let consumed = 0;\n    const value = [];\n    for(let i = 0; i < length; ++i){\n        const [data, consumed_] = decodeParameter(cursor, param, {\n            checksumAddress,\n            staticPosition: staticPosition + consumed\n        });\n        consumed += consumed_;\n        value.push(data);\n    }\n    return [\n        value,\n        consumed\n    ];\n}\nfunction decodeBool(cursor) {\n    return [\n        Bytes.toBoolean(cursor.readBytes(32), {\n            size: 32\n        }),\n        32\n    ];\n}\nfunction decodeBytes(cursor, param, { staticPosition }) {\n    const [_, size] = param.type.split(\"bytes\");\n    if (!size) {\n        const offset = Bytes.toNumber(cursor.readBytes(32));\n        cursor.setPosition(staticPosition + offset);\n        const length = Bytes.toNumber(cursor.readBytes(32));\n        if (length === 0) {\n            cursor.setPosition(staticPosition + 32);\n            return [\n                \"0x\",\n                32\n            ];\n        }\n        const data = cursor.readBytes(length);\n        cursor.setPosition(staticPosition + 32);\n        return [\n            Hex.fromBytes(data),\n            32\n        ];\n    }\n    const value = Hex.fromBytes(cursor.readBytes(Number.parseInt(size, 10), 32));\n    return [\n        value,\n        32\n    ];\n}\nfunction decodeNumber(cursor, param) {\n    const signed = param.type.startsWith(\"int\");\n    const size = Number.parseInt(param.type.split(\"int\")[1] || \"256\", 10);\n    const value = cursor.readBytes(32);\n    return [\n        size > 48 ? Bytes.toBigInt(value, {\n            signed\n        }) : Bytes.toNumber(value, {\n            signed\n        }),\n        32\n    ];\n}\nfunction decodeTuple(cursor, param, options) {\n    const { checksumAddress, staticPosition } = options;\n    const hasUnnamedChild = param.components.length === 0 || param.components.some(({ name })=>!name);\n    const value = hasUnnamedChild ? [] : {};\n    let consumed = 0;\n    if (hasDynamicChild(param)) {\n        const offset = Bytes.toNumber(cursor.readBytes(sizeOfOffset));\n        const start = staticPosition + offset;\n        for(let i = 0; i < param.components.length; ++i){\n            const component = param.components[i];\n            cursor.setPosition(start + consumed);\n            const [data, consumed_] = decodeParameter(cursor, component, {\n                checksumAddress,\n                staticPosition: start\n            });\n            consumed += consumed_;\n            value[hasUnnamedChild ? i : component?.name] = data;\n        }\n        cursor.setPosition(staticPosition + 32);\n        return [\n            value,\n            32\n        ];\n    }\n    for(let i = 0; i < param.components.length; ++i){\n        const component = param.components[i];\n        const [data, consumed_] = decodeParameter(cursor, component, {\n            checksumAddress,\n            staticPosition\n        });\n        value[hasUnnamedChild ? i : component?.name] = data;\n        consumed += consumed_;\n    }\n    return [\n        value,\n        consumed\n    ];\n}\nfunction decodeString(cursor, { staticPosition }) {\n    const offset = Bytes.toNumber(cursor.readBytes(32));\n    const start = staticPosition + offset;\n    cursor.setPosition(start);\n    const length = Bytes.toNumber(cursor.readBytes(32));\n    if (length === 0) {\n        cursor.setPosition(staticPosition + 32);\n        return [\n            \"\",\n            32\n        ];\n    }\n    const data = cursor.readBytes(length, 32);\n    const value = Bytes.toString(Bytes.trimLeft(data));\n    cursor.setPosition(staticPosition + 32);\n    return [\n        value,\n        32\n    ];\n}\nfunction prepareParameters({ checksumAddress, parameters, values }) {\n    const preparedParameters = [];\n    for(let i = 0; i < parameters.length; i++){\n        preparedParameters.push(prepareParameter({\n            checksumAddress,\n            parameter: parameters[i],\n            value: values[i]\n        }));\n    }\n    return preparedParameters;\n}\nfunction prepareParameter({ checksumAddress = false, parameter: parameter_, value }) {\n    const parameter = parameter_;\n    const arrayComponents = getArrayComponents(parameter.type);\n    if (arrayComponents) {\n        const [length, type] = arrayComponents;\n        return encodeArray(value, {\n            checksumAddress,\n            length,\n            parameter: {\n                ...parameter,\n                type\n            }\n        });\n    }\n    if (parameter.type === \"tuple\") {\n        return encodeTuple(value, {\n            checksumAddress,\n            parameter: parameter\n        });\n    }\n    if (parameter.type === \"address\") {\n        return encodeAddress(value, {\n            checksum: checksumAddress\n        });\n    }\n    if (parameter.type === \"bool\") {\n        return encodeBoolean(value);\n    }\n    if (parameter.type.startsWith(\"uint\") || parameter.type.startsWith(\"int\")) {\n        const signed = parameter.type.startsWith(\"int\");\n        const [, , size = \"256\"] = Solidity_js_1.integerRegex.exec(parameter.type) ?? [];\n        return encodeNumber(value, {\n            signed,\n            size: Number(size)\n        });\n    }\n    if (parameter.type.startsWith(\"bytes\")) {\n        return encodeBytes(value, {\n            type: parameter.type\n        });\n    }\n    if (parameter.type === \"string\") {\n        return encodeString(value);\n    }\n    throw new AbiParameters.InvalidTypeError(parameter.type);\n}\nfunction encode(preparedParameters) {\n    let staticSize = 0;\n    for(let i = 0; i < preparedParameters.length; i++){\n        const { dynamic, encoded } = preparedParameters[i];\n        if (dynamic) staticSize += 32;\n        else staticSize += Hex.size(encoded);\n    }\n    const staticParameters = [];\n    const dynamicParameters = [];\n    let dynamicSize = 0;\n    for(let i = 0; i < preparedParameters.length; i++){\n        const { dynamic, encoded } = preparedParameters[i];\n        if (dynamic) {\n            staticParameters.push(Hex.fromNumber(staticSize + dynamicSize, {\n                size: 32\n            }));\n            dynamicParameters.push(encoded);\n            dynamicSize += Hex.size(encoded);\n        } else {\n            staticParameters.push(encoded);\n        }\n    }\n    return Hex.concat(...staticParameters, ...dynamicParameters);\n}\nfunction encodeAddress(value, options) {\n    const { checksum = false } = options;\n    Address.assert(value, {\n        strict: checksum\n    });\n    return {\n        dynamic: false,\n        encoded: Hex.padLeft(value.toLowerCase())\n    };\n}\nfunction encodeArray(value, options) {\n    const { checksumAddress, length, parameter } = options;\n    const dynamic = length === null;\n    if (!Array.isArray(value)) throw new AbiParameters.InvalidArrayError(value);\n    if (!dynamic && value.length !== length) throw new AbiParameters.ArrayLengthMismatchError({\n        expectedLength: length,\n        givenLength: value.length,\n        type: `${parameter.type}[${length}]`\n    });\n    let dynamicChild = false;\n    const preparedParameters = [];\n    for(let i = 0; i < value.length; i++){\n        const preparedParam = prepareParameter({\n            checksumAddress,\n            parameter,\n            value: value[i]\n        });\n        if (preparedParam.dynamic) dynamicChild = true;\n        preparedParameters.push(preparedParam);\n    }\n    if (dynamic || dynamicChild) {\n        const data = encode(preparedParameters);\n        if (dynamic) {\n            const length = Hex.fromNumber(preparedParameters.length, {\n                size: 32\n            });\n            return {\n                dynamic: true,\n                encoded: preparedParameters.length > 0 ? Hex.concat(length, data) : length\n            };\n        }\n        if (dynamicChild) return {\n            dynamic: true,\n            encoded: data\n        };\n    }\n    return {\n        dynamic: false,\n        encoded: Hex.concat(...preparedParameters.map(({ encoded })=>encoded))\n    };\n}\nfunction encodeBytes(value, { type }) {\n    const [, parametersize] = type.split(\"bytes\");\n    const bytesSize = Hex.size(value);\n    if (!parametersize) {\n        let value_ = value;\n        if (bytesSize % 32 !== 0) value_ = Hex.padRight(value_, Math.ceil((value.length - 2) / 2 / 32) * 32);\n        return {\n            dynamic: true,\n            encoded: Hex.concat(Hex.padLeft(Hex.fromNumber(bytesSize, {\n                size: 32\n            })), value_)\n        };\n    }\n    if (bytesSize !== Number.parseInt(parametersize, 10)) throw new AbiParameters.BytesSizeMismatchError({\n        expectedSize: Number.parseInt(parametersize, 10),\n        value\n    });\n    return {\n        dynamic: false,\n        encoded: Hex.padRight(value)\n    };\n}\nfunction encodeBoolean(value) {\n    if (typeof value !== \"boolean\") throw new Errors.BaseError(`Invalid boolean value: \"${value}\" (type: ${typeof value}). Expected: \\`true\\` or \\`false\\`.`);\n    return {\n        dynamic: false,\n        encoded: Hex.padLeft(Hex.fromBoolean(value))\n    };\n}\nfunction encodeNumber(value, { signed, size }) {\n    if (typeof size === \"number\") {\n        const max = 2n ** (BigInt(size) - (signed ? 1n : 0n)) - 1n;\n        const min = signed ? -max - 1n : 0n;\n        if (value > max || value < min) throw new Hex.IntegerOutOfRangeError({\n            max: max.toString(),\n            min: min.toString(),\n            signed,\n            size: size / 8,\n            value: value.toString()\n        });\n    }\n    return {\n        dynamic: false,\n        encoded: Hex.fromNumber(value, {\n            size: 32,\n            signed\n        })\n    };\n}\nfunction encodeString(value) {\n    const hexValue = Hex.fromString(value);\n    const partsLength = Math.ceil(Hex.size(hexValue) / 32);\n    const parts = [];\n    for(let i = 0; i < partsLength; i++){\n        parts.push(Hex.padRight(Hex.slice(hexValue, i * 32, (i + 1) * 32)));\n    }\n    return {\n        dynamic: true,\n        encoded: Hex.concat(Hex.padRight(Hex.fromNumber(Hex.size(hexValue), {\n            size: 32\n        })), ...parts)\n    };\n}\nfunction encodeTuple(value, options) {\n    const { checksumAddress, parameter } = options;\n    let dynamic = false;\n    const preparedParameters = [];\n    for(let i = 0; i < parameter.components.length; i++){\n        const param_ = parameter.components[i];\n        const index = Array.isArray(value) ? i : param_.name;\n        const preparedParam = prepareParameter({\n            checksumAddress,\n            parameter: param_,\n            value: value[index]\n        });\n        preparedParameters.push(preparedParam);\n        if (preparedParam.dynamic) dynamic = true;\n    }\n    return {\n        dynamic,\n        encoded: dynamic ? encode(preparedParameters) : Hex.concat(...preparedParameters.map(({ encoded })=>encoded))\n    };\n}\nfunction getArrayComponents(type) {\n    const matches = type.match(/^(.*)\\[(\\d+)?\\]$/);\n    return matches ? [\n        matches[2] ? Number(matches[2]) : null,\n        matches[1]\n    ] : undefined;\n}\nfunction hasDynamicChild(param) {\n    const { type } = param;\n    if (type === \"string\") return true;\n    if (type === \"bytes\") return true;\n    if (type.endsWith(\"[]\")) return true;\n    if (type === \"tuple\") return param.components?.some(hasDynamicChild);\n    const arrayComponents = getArrayComponents(param.type);\n    if (arrayComponents && hasDynamicChild({\n        ...param,\n        type: arrayComponents[1]\n    })) return true;\n    return false;\n} //# sourceMappingURL=abiParameters.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2Nqcy9jb3JlL2ludGVybmFsL2FiaVBhcmFtZXRlcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHVCQUF1QixHQUFHRTtBQUMxQkYscUJBQXFCLEdBQUdHO0FBQ3hCSCxtQkFBbUIsR0FBR0k7QUFDdEJKLGtCQUFrQixHQUFHSztBQUNyQkwsbUJBQW1CLEdBQUdNO0FBQ3RCTixvQkFBb0IsR0FBR087QUFDdkJQLG1CQUFtQixHQUFHUTtBQUN0QlIsb0JBQW9CLEdBQUdTO0FBQ3ZCVCx5QkFBeUIsR0FBR1U7QUFDNUJWLHdCQUF3QixHQUFHVztBQUMzQlgsY0FBYyxHQUFHWTtBQUNqQloscUJBQXFCLEdBQUdhO0FBQ3hCYixtQkFBbUIsR0FBR2M7QUFDdEJkLG1CQUFtQixHQUFHZTtBQUN0QmYscUJBQXFCLEdBQUdnQjtBQUN4QmhCLG9CQUFvQixHQUFHaUI7QUFDdkJqQixvQkFBb0IsR0FBR2tCO0FBQ3ZCbEIsbUJBQW1CLEdBQUdtQjtBQUN0Qm5CLDBCQUEwQixHQUFHb0I7QUFDN0JwQix1QkFBdUIsR0FBR3FCO0FBQzFCLE1BQU1DLGdCQUFnQkMsbUJBQU9BLENBQUMsK0VBQXFCO0FBQ25ELE1BQU1DLFVBQVVELG1CQUFPQSxDQUFDLG1FQUFlO0FBQ3ZDLE1BQU1FLFFBQVFGLG1CQUFPQSxDQUFDLCtEQUFhO0FBQ25DLE1BQU1HLFNBQVNILG1CQUFPQSxDQUFDLGlFQUFjO0FBQ3JDLE1BQU1JLE1BQU1KLG1CQUFPQSxDQUFDLDJEQUFXO0FBQy9CLE1BQU1LLGdCQUFnQkwsbUJBQU9BLENBQUMscUVBQWdCO0FBQzlDLFNBQVNyQixnQkFBZ0IyQixNQUFNLEVBQUVDLEtBQUssRUFBRUMsT0FBTztJQUMzQyxNQUFNLEVBQUVDLGVBQWUsRUFBRUMsY0FBYyxFQUFFLEdBQUdGO0lBQzVDLE1BQU1HLGtCQUFrQmQsbUJBQW1CVSxNQUFNSyxJQUFJ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LElBQUk7SUFDckQsSUFBSUQsbUJBQ0FiLGdCQUFnQjtRQUNaLEdBQUdTLEtBQUs7UUFDUkssTUFBTUQsZUFBZSxDQUFDLEVBQUU7SUFDNUIsSUFDQSxPQUFPO0lBQ1gsT0FBTztBQUNYLEVBQ0EseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xhdy13b3Jrcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9fY2pzL2NvcmUvaW50ZXJuYWwvYWJpUGFyYW1ldGVycy5qcz83NjA0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWNvZGVQYXJhbWV0ZXIgPSBkZWNvZGVQYXJhbWV0ZXI7XG5leHBvcnRzLmRlY29kZUFkZHJlc3MgPSBkZWNvZGVBZGRyZXNzO1xuZXhwb3J0cy5kZWNvZGVBcnJheSA9IGRlY29kZUFycmF5O1xuZXhwb3J0cy5kZWNvZGVCb29sID0gZGVjb2RlQm9vbDtcbmV4cG9ydHMuZGVjb2RlQnl0ZXMgPSBkZWNvZGVCeXRlcztcbmV4cG9ydHMuZGVjb2RlTnVtYmVyID0gZGVjb2RlTnVtYmVyO1xuZXhwb3J0cy5kZWNvZGVUdXBsZSA9IGRlY29kZVR1cGxlO1xuZXhwb3J0cy5kZWNvZGVTdHJpbmcgPSBkZWNvZGVTdHJpbmc7XG5leHBvcnRzLnByZXBhcmVQYXJhbWV0ZXJzID0gcHJlcGFyZVBhcmFtZXRlcnM7XG5leHBvcnRzLnByZXBhcmVQYXJhbWV0ZXIgPSBwcmVwYXJlUGFyYW1ldGVyO1xuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG5leHBvcnRzLmVuY29kZUFkZHJlc3MgPSBlbmNvZGVBZGRyZXNzO1xuZXhwb3J0cy5lbmNvZGVBcnJheSA9IGVuY29kZUFycmF5O1xuZXhwb3J0cy5lbmNvZGVCeXRlcyA9IGVuY29kZUJ5dGVzO1xuZXhwb3J0cy5lbmNvZGVCb29sZWFuID0gZW5jb2RlQm9vbGVhbjtcbmV4cG9ydHMuZW5jb2RlTnVtYmVyID0gZW5jb2RlTnVtYmVyO1xuZXhwb3J0cy5lbmNvZGVTdHJpbmcgPSBlbmNvZGVTdHJpbmc7XG5leHBvcnRzLmVuY29kZVR1cGxlID0gZW5jb2RlVHVwbGU7XG5leHBvcnRzLmdldEFycmF5Q29tcG9uZW50cyA9IGdldEFycmF5Q29tcG9uZW50cztcbmV4cG9ydHMuaGFzRHluYW1pY0NoaWxkID0gaGFzRHluYW1pY0NoaWxkO1xuY29uc3QgQWJpUGFyYW1ldGVycyA9IHJlcXVpcmUoXCIuLi9BYmlQYXJhbWV0ZXJzLmpzXCIpO1xuY29uc3QgQWRkcmVzcyA9IHJlcXVpcmUoXCIuLi9BZGRyZXNzLmpzXCIpO1xuY29uc3QgQnl0ZXMgPSByZXF1aXJlKFwiLi4vQnl0ZXMuanNcIik7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKFwiLi4vRXJyb3JzLmpzXCIpO1xuY29uc3QgSGV4ID0gcmVxdWlyZShcIi4uL0hleC5qc1wiKTtcbmNvbnN0IFNvbGlkaXR5X2pzXzEgPSByZXF1aXJlKFwiLi4vU29saWRpdHkuanNcIik7XG5mdW5jdGlvbiBkZWNvZGVQYXJhbWV0ZXIoY3Vyc29yLCBwYXJhbSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgY2hlY2tzdW1BZGRyZXNzLCBzdGF0aWNQb3NpdGlvbiB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBhcnJheUNvbXBvbmVudHMgPSBnZXRBcnJheUNvbXBvbmVudHMocGFyYW0udHlwZSk7XG4gICAgaWYgKGFycmF5Q29tcG9uZW50cykge1xuICAgICAgICBjb25zdCBbbGVuZ3RoLCB0eXBlXSA9IGFycmF5Q29tcG9uZW50cztcbiAgICAgICAgcmV0dXJuIGRlY29kZUFycmF5KGN1cnNvciwgeyAuLi5wYXJhbSwgdHlwZSB9LCB7IGNoZWNrc3VtQWRkcmVzcywgbGVuZ3RoLCBzdGF0aWNQb3NpdGlvbiB9KTtcbiAgICB9XG4gICAgaWYgKHBhcmFtLnR5cGUgPT09ICd0dXBsZScpXG4gICAgICAgIHJldHVybiBkZWNvZGVUdXBsZShjdXJzb3IsIHBhcmFtLCB7XG4gICAgICAgICAgICBjaGVja3N1bUFkZHJlc3MsXG4gICAgICAgICAgICBzdGF0aWNQb3NpdGlvbixcbiAgICAgICAgfSk7XG4gICAgaWYgKHBhcmFtLnR5cGUgPT09ICdhZGRyZXNzJylcbiAgICAgICAgcmV0dXJuIGRlY29kZUFkZHJlc3MoY3Vyc29yLCB7IGNoZWNrc3VtOiBjaGVja3N1bUFkZHJlc3MgfSk7XG4gICAgaWYgKHBhcmFtLnR5cGUgPT09ICdib29sJylcbiAgICAgICAgcmV0dXJuIGRlY29kZUJvb2woY3Vyc29yKTtcbiAgICBpZiAocGFyYW0udHlwZS5zdGFydHNXaXRoKCdieXRlcycpKVxuICAgICAgICByZXR1cm4gZGVjb2RlQnl0ZXMoY3Vyc29yLCBwYXJhbSwgeyBzdGF0aWNQb3NpdGlvbiB9KTtcbiAgICBpZiAocGFyYW0udHlwZS5zdGFydHNXaXRoKCd1aW50JykgfHwgcGFyYW0udHlwZS5zdGFydHNXaXRoKCdpbnQnKSlcbiAgICAgICAgcmV0dXJuIGRlY29kZU51bWJlcihjdXJzb3IsIHBhcmFtKTtcbiAgICBpZiAocGFyYW0udHlwZSA9PT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiBkZWNvZGVTdHJpbmcoY3Vyc29yLCB7IHN0YXRpY1Bvc2l0aW9uIH0pO1xuICAgIHRocm93IG5ldyBBYmlQYXJhbWV0ZXJzLkludmFsaWRUeXBlRXJyb3IocGFyYW0udHlwZSk7XG59XG5jb25zdCBzaXplT2ZMZW5ndGggPSAzMjtcbmNvbnN0IHNpemVPZk9mZnNldCA9IDMyO1xuZnVuY3Rpb24gZGVjb2RlQWRkcmVzcyhjdXJzb3IsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgY2hlY2tzdW0gPSBmYWxzZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCB2YWx1ZSA9IGN1cnNvci5yZWFkQnl0ZXMoMzIpO1xuICAgIGNvbnN0IHdyYXAgPSAoYWRkcmVzcykgPT4gY2hlY2tzdW0gPyBBZGRyZXNzLmNoZWNrc3VtKGFkZHJlc3MpIDogYWRkcmVzcztcbiAgICByZXR1cm4gW3dyYXAoSGV4LmZyb21CeXRlcyhCeXRlcy5zbGljZSh2YWx1ZSwgLTIwKSkpLCAzMl07XG59XG5mdW5jdGlvbiBkZWNvZGVBcnJheShjdXJzb3IsIHBhcmFtLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBjaGVja3N1bUFkZHJlc3MsIGxlbmd0aCwgc3RhdGljUG9zaXRpb24gfSA9IG9wdGlvbnM7XG4gICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gQnl0ZXMudG9OdW1iZXIoY3Vyc29yLnJlYWRCeXRlcyhzaXplT2ZPZmZzZXQpKTtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBzdGF0aWNQb3NpdGlvbiArIG9mZnNldDtcbiAgICAgICAgY29uc3Qgc3RhcnRPZkRhdGEgPSBzdGFydCArIHNpemVPZkxlbmd0aDtcbiAgICAgICAgY3Vyc29yLnNldFBvc2l0aW9uKHN0YXJ0KTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gQnl0ZXMudG9OdW1iZXIoY3Vyc29yLnJlYWRCeXRlcyhzaXplT2ZMZW5ndGgpKTtcbiAgICAgICAgY29uc3QgZHluYW1pY0NoaWxkID0gaGFzRHluYW1pY0NoaWxkKHBhcmFtKTtcbiAgICAgICAgbGV0IGNvbnN1bWVkID0gMDtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY3Vyc29yLnNldFBvc2l0aW9uKHN0YXJ0T2ZEYXRhICsgKGR5bmFtaWNDaGlsZCA/IGkgKiAzMiA6IGNvbnN1bWVkKSk7XG4gICAgICAgICAgICBjb25zdCBbZGF0YSwgY29uc3VtZWRfXSA9IGRlY29kZVBhcmFtZXRlcihjdXJzb3IsIHBhcmFtLCB7XG4gICAgICAgICAgICAgICAgY2hlY2tzdW1BZGRyZXNzLFxuICAgICAgICAgICAgICAgIHN0YXRpY1Bvc2l0aW9uOiBzdGFydE9mRGF0YSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3VtZWQgKz0gY29uc3VtZWRfO1xuICAgICAgICAgICAgdmFsdWUucHVzaChkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJzb3Iuc2V0UG9zaXRpb24oc3RhdGljUG9zaXRpb24gKyAzMik7XG4gICAgICAgIHJldHVybiBbdmFsdWUsIDMyXTtcbiAgICB9XG4gICAgaWYgKGhhc0R5bmFtaWNDaGlsZChwYXJhbSkpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gQnl0ZXMudG9OdW1iZXIoY3Vyc29yLnJlYWRCeXRlcyhzaXplT2ZPZmZzZXQpKTtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBzdGF0aWNQb3NpdGlvbiArIG9mZnNldDtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY3Vyc29yLnNldFBvc2l0aW9uKHN0YXJ0ICsgaSAqIDMyKTtcbiAgICAgICAgICAgIGNvbnN0IFtkYXRhXSA9IGRlY29kZVBhcmFtZXRlcihjdXJzb3IsIHBhcmFtLCB7XG4gICAgICAgICAgICAgICAgY2hlY2tzdW1BZGRyZXNzLFxuICAgICAgICAgICAgICAgIHN0YXRpY1Bvc2l0aW9uOiBzdGFydCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFsdWUucHVzaChkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJzb3Iuc2V0UG9zaXRpb24oc3RhdGljUG9zaXRpb24gKyAzMik7XG4gICAgICAgIHJldHVybiBbdmFsdWUsIDMyXTtcbiAgICB9XG4gICAgbGV0IGNvbnN1bWVkID0gMDtcbiAgICBjb25zdCB2YWx1ZSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgW2RhdGEsIGNvbnN1bWVkX10gPSBkZWNvZGVQYXJhbWV0ZXIoY3Vyc29yLCBwYXJhbSwge1xuICAgICAgICAgICAgY2hlY2tzdW1BZGRyZXNzLFxuICAgICAgICAgICAgc3RhdGljUG9zaXRpb246IHN0YXRpY1Bvc2l0aW9uICsgY29uc3VtZWQsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdW1lZCArPSBjb25zdW1lZF87XG4gICAgICAgIHZhbHVlLnB1c2goZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBbdmFsdWUsIGNvbnN1bWVkXTtcbn1cbmZ1bmN0aW9uIGRlY29kZUJvb2woY3Vyc29yKSB7XG4gICAgcmV0dXJuIFtCeXRlcy50b0Jvb2xlYW4oY3Vyc29yLnJlYWRCeXRlcygzMiksIHsgc2l6ZTogMzIgfSksIDMyXTtcbn1cbmZ1bmN0aW9uIGRlY29kZUJ5dGVzKGN1cnNvciwgcGFyYW0sIHsgc3RhdGljUG9zaXRpb24gfSkge1xuICAgIGNvbnN0IFtfLCBzaXplXSA9IHBhcmFtLnR5cGUuc3BsaXQoJ2J5dGVzJyk7XG4gICAgaWYgKCFzaXplKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IEJ5dGVzLnRvTnVtYmVyKGN1cnNvci5yZWFkQnl0ZXMoMzIpKTtcbiAgICAgICAgY3Vyc29yLnNldFBvc2l0aW9uKHN0YXRpY1Bvc2l0aW9uICsgb2Zmc2V0KTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gQnl0ZXMudG9OdW1iZXIoY3Vyc29yLnJlYWRCeXRlcygzMikpO1xuICAgICAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjdXJzb3Iuc2V0UG9zaXRpb24oc3RhdGljUG9zaXRpb24gKyAzMik7XG4gICAgICAgICAgICByZXR1cm4gWycweCcsIDMyXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhID0gY3Vyc29yLnJlYWRCeXRlcyhsZW5ndGgpO1xuICAgICAgICBjdXJzb3Iuc2V0UG9zaXRpb24oc3RhdGljUG9zaXRpb24gKyAzMik7XG4gICAgICAgIHJldHVybiBbSGV4LmZyb21CeXRlcyhkYXRhKSwgMzJdO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IEhleC5mcm9tQnl0ZXMoY3Vyc29yLnJlYWRCeXRlcyhOdW1iZXIucGFyc2VJbnQoc2l6ZSwgMTApLCAzMikpO1xuICAgIHJldHVybiBbdmFsdWUsIDMyXTtcbn1cbmZ1bmN0aW9uIGRlY29kZU51bWJlcihjdXJzb3IsIHBhcmFtKSB7XG4gICAgY29uc3Qgc2lnbmVkID0gcGFyYW0udHlwZS5zdGFydHNXaXRoKCdpbnQnKTtcbiAgICBjb25zdCBzaXplID0gTnVtYmVyLnBhcnNlSW50KHBhcmFtLnR5cGUuc3BsaXQoJ2ludCcpWzFdIHx8ICcyNTYnLCAxMCk7XG4gICAgY29uc3QgdmFsdWUgPSBjdXJzb3IucmVhZEJ5dGVzKDMyKTtcbiAgICByZXR1cm4gW1xuICAgICAgICBzaXplID4gNDhcbiAgICAgICAgICAgID8gQnl0ZXMudG9CaWdJbnQodmFsdWUsIHsgc2lnbmVkIH0pXG4gICAgICAgICAgICA6IEJ5dGVzLnRvTnVtYmVyKHZhbHVlLCB7IHNpZ25lZCB9KSxcbiAgICAgICAgMzIsXG4gICAgXTtcbn1cbmZ1bmN0aW9uIGRlY29kZVR1cGxlKGN1cnNvciwgcGFyYW0sIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGNoZWNrc3VtQWRkcmVzcywgc3RhdGljUG9zaXRpb24gfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgaGFzVW5uYW1lZENoaWxkID0gcGFyYW0uY29tcG9uZW50cy5sZW5ndGggPT09IDAgfHwgcGFyYW0uY29tcG9uZW50cy5zb21lKCh7IG5hbWUgfSkgPT4gIW5hbWUpO1xuICAgIGNvbnN0IHZhbHVlID0gaGFzVW5uYW1lZENoaWxkID8gW10gOiB7fTtcbiAgICBsZXQgY29uc3VtZWQgPSAwO1xuICAgIGlmIChoYXNEeW5hbWljQ2hpbGQocGFyYW0pKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IEJ5dGVzLnRvTnVtYmVyKGN1cnNvci5yZWFkQnl0ZXMoc2l6ZU9mT2Zmc2V0KSk7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gc3RhdGljUG9zaXRpb24gKyBvZmZzZXQ7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyYW0uY29tcG9uZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50ID0gcGFyYW0uY29tcG9uZW50c1tpXTtcbiAgICAgICAgICAgIGN1cnNvci5zZXRQb3NpdGlvbihzdGFydCArIGNvbnN1bWVkKTtcbiAgICAgICAgICAgIGNvbnN0IFtkYXRhLCBjb25zdW1lZF9dID0gZGVjb2RlUGFyYW1ldGVyKGN1cnNvciwgY29tcG9uZW50LCB7XG4gICAgICAgICAgICAgICAgY2hlY2tzdW1BZGRyZXNzLFxuICAgICAgICAgICAgICAgIHN0YXRpY1Bvc2l0aW9uOiBzdGFydCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3VtZWQgKz0gY29uc3VtZWRfO1xuICAgICAgICAgICAgdmFsdWVbaGFzVW5uYW1lZENoaWxkID8gaSA6IGNvbXBvbmVudD8ubmFtZV0gPSBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGN1cnNvci5zZXRQb3NpdGlvbihzdGF0aWNQb3NpdGlvbiArIDMyKTtcbiAgICAgICAgcmV0dXJuIFt2YWx1ZSwgMzJdO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmFtLmNvbXBvbmVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgY29tcG9uZW50ID0gcGFyYW0uY29tcG9uZW50c1tpXTtcbiAgICAgICAgY29uc3QgW2RhdGEsIGNvbnN1bWVkX10gPSBkZWNvZGVQYXJhbWV0ZXIoY3Vyc29yLCBjb21wb25lbnQsIHtcbiAgICAgICAgICAgIGNoZWNrc3VtQWRkcmVzcyxcbiAgICAgICAgICAgIHN0YXRpY1Bvc2l0aW9uLFxuICAgICAgICB9KTtcbiAgICAgICAgdmFsdWVbaGFzVW5uYW1lZENoaWxkID8gaSA6IGNvbXBvbmVudD8ubmFtZV0gPSBkYXRhO1xuICAgICAgICBjb25zdW1lZCArPSBjb25zdW1lZF87XG4gICAgfVxuICAgIHJldHVybiBbdmFsdWUsIGNvbnN1bWVkXTtcbn1cbmZ1bmN0aW9uIGRlY29kZVN0cmluZyhjdXJzb3IsIHsgc3RhdGljUG9zaXRpb24gfSkge1xuICAgIGNvbnN0IG9mZnNldCA9IEJ5dGVzLnRvTnVtYmVyKGN1cnNvci5yZWFkQnl0ZXMoMzIpKTtcbiAgICBjb25zdCBzdGFydCA9IHN0YXRpY1Bvc2l0aW9uICsgb2Zmc2V0O1xuICAgIGN1cnNvci5zZXRQb3NpdGlvbihzdGFydCk7XG4gICAgY29uc3QgbGVuZ3RoID0gQnl0ZXMudG9OdW1iZXIoY3Vyc29yLnJlYWRCeXRlcygzMikpO1xuICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgICAgY3Vyc29yLnNldFBvc2l0aW9uKHN0YXRpY1Bvc2l0aW9uICsgMzIpO1xuICAgICAgICByZXR1cm4gWycnLCAzMl07XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBjdXJzb3IucmVhZEJ5dGVzKGxlbmd0aCwgMzIpO1xuICAgIGNvbnN0IHZhbHVlID0gQnl0ZXMudG9TdHJpbmcoQnl0ZXMudHJpbUxlZnQoZGF0YSkpO1xuICAgIGN1cnNvci5zZXRQb3NpdGlvbihzdGF0aWNQb3NpdGlvbiArIDMyKTtcbiAgICByZXR1cm4gW3ZhbHVlLCAzMl07XG59XG5mdW5jdGlvbiBwcmVwYXJlUGFyYW1ldGVycyh7IGNoZWNrc3VtQWRkcmVzcywgcGFyYW1ldGVycywgdmFsdWVzLCB9KSB7XG4gICAgY29uc3QgcHJlcGFyZWRQYXJhbWV0ZXJzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJhbWV0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHByZXBhcmVkUGFyYW1ldGVycy5wdXNoKHByZXBhcmVQYXJhbWV0ZXIoe1xuICAgICAgICAgICAgY2hlY2tzdW1BZGRyZXNzLFxuICAgICAgICAgICAgcGFyYW1ldGVyOiBwYXJhbWV0ZXJzW2ldLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlc1tpXSxcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gcHJlcGFyZWRQYXJhbWV0ZXJzO1xufVxuZnVuY3Rpb24gcHJlcGFyZVBhcmFtZXRlcih7IGNoZWNrc3VtQWRkcmVzcyA9IGZhbHNlLCBwYXJhbWV0ZXI6IHBhcmFtZXRlcl8sIHZhbHVlLCB9KSB7XG4gICAgY29uc3QgcGFyYW1ldGVyID0gcGFyYW1ldGVyXztcbiAgICBjb25zdCBhcnJheUNvbXBvbmVudHMgPSBnZXRBcnJheUNvbXBvbmVudHMocGFyYW1ldGVyLnR5cGUpO1xuICAgIGlmIChhcnJheUNvbXBvbmVudHMpIHtcbiAgICAgICAgY29uc3QgW2xlbmd0aCwgdHlwZV0gPSBhcnJheUNvbXBvbmVudHM7XG4gICAgICAgIHJldHVybiBlbmNvZGVBcnJheSh2YWx1ZSwge1xuICAgICAgICAgICAgY2hlY2tzdW1BZGRyZXNzLFxuICAgICAgICAgICAgbGVuZ3RoLFxuICAgICAgICAgICAgcGFyYW1ldGVyOiB7XG4gICAgICAgICAgICAgICAgLi4ucGFyYW1ldGVyLFxuICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHBhcmFtZXRlci50eXBlID09PSAndHVwbGUnKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVUdXBsZSh2YWx1ZSwge1xuICAgICAgICAgICAgY2hlY2tzdW1BZGRyZXNzLFxuICAgICAgICAgICAgcGFyYW1ldGVyOiBwYXJhbWV0ZXIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAocGFyYW1ldGVyLnR5cGUgPT09ICdhZGRyZXNzJykge1xuICAgICAgICByZXR1cm4gZW5jb2RlQWRkcmVzcyh2YWx1ZSwge1xuICAgICAgICAgICAgY2hlY2tzdW06IGNoZWNrc3VtQWRkcmVzcyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChwYXJhbWV0ZXIudHlwZSA9PT0gJ2Jvb2wnKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVCb29sZWFuKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHBhcmFtZXRlci50eXBlLnN0YXJ0c1dpdGgoJ3VpbnQnKSB8fCBwYXJhbWV0ZXIudHlwZS5zdGFydHNXaXRoKCdpbnQnKSkge1xuICAgICAgICBjb25zdCBzaWduZWQgPSBwYXJhbWV0ZXIudHlwZS5zdGFydHNXaXRoKCdpbnQnKTtcbiAgICAgICAgY29uc3QgWywgLCBzaXplID0gJzI1NiddID0gU29saWRpdHlfanNfMS5pbnRlZ2VyUmVnZXguZXhlYyhwYXJhbWV0ZXIudHlwZSkgPz8gW107XG4gICAgICAgIHJldHVybiBlbmNvZGVOdW1iZXIodmFsdWUsIHtcbiAgICAgICAgICAgIHNpZ25lZCxcbiAgICAgICAgICAgIHNpemU6IE51bWJlcihzaXplKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChwYXJhbWV0ZXIudHlwZS5zdGFydHNXaXRoKCdieXRlcycpKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVCeXRlcyh2YWx1ZSwgeyB0eXBlOiBwYXJhbWV0ZXIudHlwZSB9KTtcbiAgICB9XG4gICAgaWYgKHBhcmFtZXRlci50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZW5jb2RlU3RyaW5nKHZhbHVlKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEFiaVBhcmFtZXRlcnMuSW52YWxpZFR5cGVFcnJvcihwYXJhbWV0ZXIudHlwZSk7XG59XG5mdW5jdGlvbiBlbmNvZGUocHJlcGFyZWRQYXJhbWV0ZXJzKSB7XG4gICAgbGV0IHN0YXRpY1NpemUgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlcGFyZWRQYXJhbWV0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHsgZHluYW1pYywgZW5jb2RlZCB9ID0gcHJlcGFyZWRQYXJhbWV0ZXJzW2ldO1xuICAgICAgICBpZiAoZHluYW1pYylcbiAgICAgICAgICAgIHN0YXRpY1NpemUgKz0gMzI7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHN0YXRpY1NpemUgKz0gSGV4LnNpemUoZW5jb2RlZCk7XG4gICAgfVxuICAgIGNvbnN0IHN0YXRpY1BhcmFtZXRlcnMgPSBbXTtcbiAgICBjb25zdCBkeW5hbWljUGFyYW1ldGVycyA9IFtdO1xuICAgIGxldCBkeW5hbWljU2l6ZSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVwYXJlZFBhcmFtZXRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgeyBkeW5hbWljLCBlbmNvZGVkIH0gPSBwcmVwYXJlZFBhcmFtZXRlcnNbaV07XG4gICAgICAgIGlmIChkeW5hbWljKSB7XG4gICAgICAgICAgICBzdGF0aWNQYXJhbWV0ZXJzLnB1c2goSGV4LmZyb21OdW1iZXIoc3RhdGljU2l6ZSArIGR5bmFtaWNTaXplLCB7IHNpemU6IDMyIH0pKTtcbiAgICAgICAgICAgIGR5bmFtaWNQYXJhbWV0ZXJzLnB1c2goZW5jb2RlZCk7XG4gICAgICAgICAgICBkeW5hbWljU2l6ZSArPSBIZXguc2l6ZShlbmNvZGVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRpY1BhcmFtZXRlcnMucHVzaChlbmNvZGVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gSGV4LmNvbmNhdCguLi5zdGF0aWNQYXJhbWV0ZXJzLCAuLi5keW5hbWljUGFyYW1ldGVycyk7XG59XG5mdW5jdGlvbiBlbmNvZGVBZGRyZXNzKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBjaGVja3N1bSA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICAgIEFkZHJlc3MuYXNzZXJ0KHZhbHVlLCB7IHN0cmljdDogY2hlY2tzdW0gfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZHluYW1pYzogZmFsc2UsXG4gICAgICAgIGVuY29kZWQ6IEhleC5wYWRMZWZ0KHZhbHVlLnRvTG93ZXJDYXNlKCkpLFxuICAgIH07XG59XG5mdW5jdGlvbiBlbmNvZGVBcnJheSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgY2hlY2tzdW1BZGRyZXNzLCBsZW5ndGgsIHBhcmFtZXRlciB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBkeW5hbWljID0gbGVuZ3RoID09PSBudWxsO1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpXG4gICAgICAgIHRocm93IG5ldyBBYmlQYXJhbWV0ZXJzLkludmFsaWRBcnJheUVycm9yKHZhbHVlKTtcbiAgICBpZiAoIWR5bmFtaWMgJiYgdmFsdWUubGVuZ3RoICE9PSBsZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBBYmlQYXJhbWV0ZXJzLkFycmF5TGVuZ3RoTWlzbWF0Y2hFcnJvcih7XG4gICAgICAgICAgICBleHBlY3RlZExlbmd0aDogbGVuZ3RoLFxuICAgICAgICAgICAgZ2l2ZW5MZW5ndGg6IHZhbHVlLmxlbmd0aCxcbiAgICAgICAgICAgIHR5cGU6IGAke3BhcmFtZXRlci50eXBlfVske2xlbmd0aH1dYCxcbiAgICAgICAgfSk7XG4gICAgbGV0IGR5bmFtaWNDaGlsZCA9IGZhbHNlO1xuICAgIGNvbnN0IHByZXBhcmVkUGFyYW1ldGVycyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcHJlcGFyZWRQYXJhbSA9IHByZXBhcmVQYXJhbWV0ZXIoe1xuICAgICAgICAgICAgY2hlY2tzdW1BZGRyZXNzLFxuICAgICAgICAgICAgcGFyYW1ldGVyLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlW2ldLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHByZXBhcmVkUGFyYW0uZHluYW1pYylcbiAgICAgICAgICAgIGR5bmFtaWNDaGlsZCA9IHRydWU7XG4gICAgICAgIHByZXBhcmVkUGFyYW1ldGVycy5wdXNoKHByZXBhcmVkUGFyYW0pO1xuICAgIH1cbiAgICBpZiAoZHluYW1pYyB8fCBkeW5hbWljQ2hpbGQpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGVuY29kZShwcmVwYXJlZFBhcmFtZXRlcnMpO1xuICAgICAgICBpZiAoZHluYW1pYykge1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gSGV4LmZyb21OdW1iZXIocHJlcGFyZWRQYXJhbWV0ZXJzLmxlbmd0aCwgeyBzaXplOiAzMiB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZHluYW1pYzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbmNvZGVkOiBwcmVwYXJlZFBhcmFtZXRlcnMubGVuZ3RoID4gMCA/IEhleC5jb25jYXQobGVuZ3RoLCBkYXRhKSA6IGxlbmd0aCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGR5bmFtaWNDaGlsZClcbiAgICAgICAgICAgIHJldHVybiB7IGR5bmFtaWM6IHRydWUsIGVuY29kZWQ6IGRhdGEgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZHluYW1pYzogZmFsc2UsXG4gICAgICAgIGVuY29kZWQ6IEhleC5jb25jYXQoLi4ucHJlcGFyZWRQYXJhbWV0ZXJzLm1hcCgoeyBlbmNvZGVkIH0pID0+IGVuY29kZWQpKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZW5jb2RlQnl0ZXModmFsdWUsIHsgdHlwZSB9KSB7XG4gICAgY29uc3QgWywgcGFyYW1ldGVyc2l6ZV0gPSB0eXBlLnNwbGl0KCdieXRlcycpO1xuICAgIGNvbnN0IGJ5dGVzU2l6ZSA9IEhleC5zaXplKHZhbHVlKTtcbiAgICBpZiAoIXBhcmFtZXRlcnNpemUpIHtcbiAgICAgICAgbGV0IHZhbHVlXyA9IHZhbHVlO1xuICAgICAgICBpZiAoYnl0ZXNTaXplICUgMzIgIT09IDApXG4gICAgICAgICAgICB2YWx1ZV8gPSBIZXgucGFkUmlnaHQodmFsdWVfLCBNYXRoLmNlaWwoKHZhbHVlLmxlbmd0aCAtIDIpIC8gMiAvIDMyKSAqIDMyKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGR5bmFtaWM6IHRydWUsXG4gICAgICAgICAgICBlbmNvZGVkOiBIZXguY29uY2F0KEhleC5wYWRMZWZ0KEhleC5mcm9tTnVtYmVyKGJ5dGVzU2l6ZSwgeyBzaXplOiAzMiB9KSksIHZhbHVlXyksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChieXRlc1NpemUgIT09IE51bWJlci5wYXJzZUludChwYXJhbWV0ZXJzaXplLCAxMCkpXG4gICAgICAgIHRocm93IG5ldyBBYmlQYXJhbWV0ZXJzLkJ5dGVzU2l6ZU1pc21hdGNoRXJyb3Ioe1xuICAgICAgICAgICAgZXhwZWN0ZWRTaXplOiBOdW1iZXIucGFyc2VJbnQocGFyYW1ldGVyc2l6ZSwgMTApLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgIH0pO1xuICAgIHJldHVybiB7IGR5bmFtaWM6IGZhbHNlLCBlbmNvZGVkOiBIZXgucGFkUmlnaHQodmFsdWUpIH07XG59XG5mdW5jdGlvbiBlbmNvZGVCb29sZWFuKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Jvb2xlYW4nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3JzLkJhc2VFcnJvcihgSW52YWxpZCBib29sZWFuIHZhbHVlOiBcIiR7dmFsdWV9XCIgKHR5cGU6ICR7dHlwZW9mIHZhbHVlfSkuIEV4cGVjdGVkOiBcXGB0cnVlXFxgIG9yIFxcYGZhbHNlXFxgLmApO1xuICAgIHJldHVybiB7IGR5bmFtaWM6IGZhbHNlLCBlbmNvZGVkOiBIZXgucGFkTGVmdChIZXguZnJvbUJvb2xlYW4odmFsdWUpKSB9O1xufVxuZnVuY3Rpb24gZW5jb2RlTnVtYmVyKHZhbHVlLCB7IHNpZ25lZCwgc2l6ZSB9KSB7XG4gICAgaWYgKHR5cGVvZiBzaXplID09PSAnbnVtYmVyJykge1xuICAgICAgICBjb25zdCBtYXggPSAybiAqKiAoQmlnSW50KHNpemUpIC0gKHNpZ25lZCA/IDFuIDogMG4pKSAtIDFuO1xuICAgICAgICBjb25zdCBtaW4gPSBzaWduZWQgPyAtbWF4IC0gMW4gOiAwbjtcbiAgICAgICAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEhleC5JbnRlZ2VyT3V0T2ZSYW5nZUVycm9yKHtcbiAgICAgICAgICAgICAgICBtYXg6IG1heC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIG1pbjogbWluLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgc2lnbmVkLFxuICAgICAgICAgICAgICAgIHNpemU6IHNpemUgLyA4LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZS50b1N0cmluZygpLFxuICAgICAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGR5bmFtaWM6IGZhbHNlLFxuICAgICAgICBlbmNvZGVkOiBIZXguZnJvbU51bWJlcih2YWx1ZSwge1xuICAgICAgICAgICAgc2l6ZTogMzIsXG4gICAgICAgICAgICBzaWduZWQsXG4gICAgICAgIH0pLFxuICAgIH07XG59XG5mdW5jdGlvbiBlbmNvZGVTdHJpbmcodmFsdWUpIHtcbiAgICBjb25zdCBoZXhWYWx1ZSA9IEhleC5mcm9tU3RyaW5nKHZhbHVlKTtcbiAgICBjb25zdCBwYXJ0c0xlbmd0aCA9IE1hdGguY2VpbChIZXguc2l6ZShoZXhWYWx1ZSkgLyAzMik7XG4gICAgY29uc3QgcGFydHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcGFydHMucHVzaChIZXgucGFkUmlnaHQoSGV4LnNsaWNlKGhleFZhbHVlLCBpICogMzIsIChpICsgMSkgKiAzMikpKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZHluYW1pYzogdHJ1ZSxcbiAgICAgICAgZW5jb2RlZDogSGV4LmNvbmNhdChIZXgucGFkUmlnaHQoSGV4LmZyb21OdW1iZXIoSGV4LnNpemUoaGV4VmFsdWUpLCB7IHNpemU6IDMyIH0pKSwgLi4ucGFydHMpLFxuICAgIH07XG59XG5mdW5jdGlvbiBlbmNvZGVUdXBsZSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgY2hlY2tzdW1BZGRyZXNzLCBwYXJhbWV0ZXIgfSA9IG9wdGlvbnM7XG4gICAgbGV0IGR5bmFtaWMgPSBmYWxzZTtcbiAgICBjb25zdCBwcmVwYXJlZFBhcmFtZXRlcnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmFtZXRlci5jb21wb25lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtXyA9IHBhcmFtZXRlci5jb21wb25lbnRzW2ldO1xuICAgICAgICBjb25zdCBpbmRleCA9IEFycmF5LmlzQXJyYXkodmFsdWUpID8gaSA6IHBhcmFtXy5uYW1lO1xuICAgICAgICBjb25zdCBwcmVwYXJlZFBhcmFtID0gcHJlcGFyZVBhcmFtZXRlcih7XG4gICAgICAgICAgICBjaGVja3N1bUFkZHJlc3MsXG4gICAgICAgICAgICBwYXJhbWV0ZXI6IHBhcmFtXyxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVtpbmRleF0sXG4gICAgICAgIH0pO1xuICAgICAgICBwcmVwYXJlZFBhcmFtZXRlcnMucHVzaChwcmVwYXJlZFBhcmFtKTtcbiAgICAgICAgaWYgKHByZXBhcmVkUGFyYW0uZHluYW1pYylcbiAgICAgICAgICAgIGR5bmFtaWMgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBkeW5hbWljLFxuICAgICAgICBlbmNvZGVkOiBkeW5hbWljXG4gICAgICAgICAgICA/IGVuY29kZShwcmVwYXJlZFBhcmFtZXRlcnMpXG4gICAgICAgICAgICA6IEhleC5jb25jYXQoLi4ucHJlcGFyZWRQYXJhbWV0ZXJzLm1hcCgoeyBlbmNvZGVkIH0pID0+IGVuY29kZWQpKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0QXJyYXlDb21wb25lbnRzKHR5cGUpIHtcbiAgICBjb25zdCBtYXRjaGVzID0gdHlwZS5tYXRjaCgvXiguKilcXFsoXFxkKyk/XFxdJC8pO1xuICAgIHJldHVybiBtYXRjaGVzXG4gICAgICAgID9cbiAgICAgICAgICAgIFttYXRjaGVzWzJdID8gTnVtYmVyKG1hdGNoZXNbMl0pIDogbnVsbCwgbWF0Y2hlc1sxXV1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBoYXNEeW5hbWljQ2hpbGQocGFyYW0pIHtcbiAgICBjb25zdCB7IHR5cGUgfSA9IHBhcmFtO1xuICAgIGlmICh0eXBlID09PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKHR5cGUgPT09ICdieXRlcycpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmICh0eXBlLmVuZHNXaXRoKCdbXScpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAodHlwZSA9PT0gJ3R1cGxlJylcbiAgICAgICAgcmV0dXJuIHBhcmFtLmNvbXBvbmVudHM/LnNvbWUoaGFzRHluYW1pY0NoaWxkKTtcbiAgICBjb25zdCBhcnJheUNvbXBvbmVudHMgPSBnZXRBcnJheUNvbXBvbmVudHMocGFyYW0udHlwZSk7XG4gICAgaWYgKGFycmF5Q29tcG9uZW50cyAmJlxuICAgICAgICBoYXNEeW5hbWljQ2hpbGQoe1xuICAgICAgICAgICAgLi4ucGFyYW0sXG4gICAgICAgICAgICB0eXBlOiBhcnJheUNvbXBvbmVudHNbMV0sXG4gICAgICAgIH0pKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYmlQYXJhbWV0ZXJzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImRlY29kZVBhcmFtZXRlciIsImRlY29kZUFkZHJlc3MiLCJkZWNvZGVBcnJheSIsImRlY29kZUJvb2wiLCJkZWNvZGVCeXRlcyIsImRlY29kZU51bWJlciIsImRlY29kZVR1cGxlIiwiZGVjb2RlU3RyaW5nIiwicHJlcGFyZVBhcmFtZXRlcnMiLCJwcmVwYXJlUGFyYW1ldGVyIiwiZW5jb2RlIiwiZW5jb2RlQWRkcmVzcyIsImVuY29kZUFycmF5IiwiZW5jb2RlQnl0ZXMiLCJlbmNvZGVCb29sZWFuIiwiZW5jb2RlTnVtYmVyIiwiZW5jb2RlU3RyaW5nIiwiZW5jb2RlVHVwbGUiLCJnZXRBcnJheUNvbXBvbmVudHMiLCJoYXNEeW5hbWljQ2hpbGQiLCJBYmlQYXJhbWV0ZXJzIiwicmVxdWlyZSIsIkFkZHJlc3MiLCJCeXRlcyIsIkVycm9ycyIsIkhleCIsIlNvbGlkaXR5X2pzXzEiLCJjdXJzb3IiLCJwYXJhbSIsIm9wdGlvbnMiLCJjaGVja3N1bUFkZHJlc3MiLCJzdGF0aWNQb3NpdGlvbiIsImFycmF5Q29tcG9uZW50cyIsInR5cGUiLCJsZW5ndGgiLCJjaGVja3N1bSIsInN0YXJ0c1dpdGgiLCJJbnZhbGlkVHlwZUVycm9yIiwic2l6ZU9mTGVuZ3RoIiwic2l6ZU9mT2Zmc2V0IiwicmVhZEJ5dGVzIiwid3JhcCIsImFkZHJlc3MiLCJmcm9tQnl0ZXMiLCJzbGljZSIsIm9mZnNldCIsInRvTnVtYmVyIiwic3RhcnQiLCJzdGFydE9mRGF0YSIsInNldFBvc2l0aW9uIiwiZHluYW1pY0NoaWxkIiwiY29uc3VtZWQiLCJpIiwiZGF0YSIsImNvbnN1bWVkXyIsInB1c2giLCJ0b0Jvb2xlYW4iLCJzaXplIiwiXyIsInNwbGl0IiwiTnVtYmVyIiwicGFyc2VJbnQiLCJzaWduZWQiLCJ0b0JpZ0ludCIsImhhc1VubmFtZWRDaGlsZCIsImNvbXBvbmVudHMiLCJzb21lIiwibmFtZSIsImNvbXBvbmVudCIsInRvU3RyaW5nIiwidHJpbUxlZnQiLCJwYXJhbWV0ZXJzIiwidmFsdWVzIiwicHJlcGFyZWRQYXJhbWV0ZXJzIiwicGFyYW1ldGVyIiwicGFyYW1ldGVyXyIsImludGVnZXJSZWdleCIsImV4ZWMiLCJzdGF0aWNTaXplIiwiZHluYW1pYyIsImVuY29kZWQiLCJzdGF0aWNQYXJhbWV0ZXJzIiwiZHluYW1pY1BhcmFtZXRlcnMiLCJkeW5hbWljU2l6ZSIsImZyb21OdW1iZXIiLCJjb25jYXQiLCJhc3NlcnQiLCJzdHJpY3QiLCJwYWRMZWZ0IiwidG9Mb3dlckNhc2UiLCJBcnJheSIsImlzQXJyYXkiLCJJbnZhbGlkQXJyYXlFcnJvciIsIkFycmF5TGVuZ3RoTWlzbWF0Y2hFcnJvciIsImV4cGVjdGVkTGVuZ3RoIiwiZ2l2ZW5MZW5ndGgiLCJwcmVwYXJlZFBhcmFtIiwibWFwIiwicGFyYW1ldGVyc2l6ZSIsImJ5dGVzU2l6ZSIsInZhbHVlXyIsInBhZFJpZ2h0IiwiTWF0aCIsImNlaWwiLCJCeXRlc1NpemVNaXNtYXRjaEVycm9yIiwiZXhwZWN0ZWRTaXplIiwiQmFzZUVycm9yIiwiZnJvbUJvb2xlYW4iLCJtYXgiLCJCaWdJbnQiLCJtaW4iLCJJbnRlZ2VyT3V0T2ZSYW5nZUVycm9yIiwiaGV4VmFsdWUiLCJmcm9tU3RyaW5nIiwicGFydHNMZW5ndGgiLCJwYXJ0cyIsInBhcmFtXyIsImluZGV4IiwibWF0Y2hlcyIsIm1hdGNoIiwidW5kZWZpbmVkIiwiZW5kc1dpdGgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_cjs/core/internal/abiParameters.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_cjs/core/internal/bytes.js":
/*!*****************************************************!*\
  !*** ./node_modules/ox/_cjs/core/internal/bytes.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.charCodeMap = void 0;\nexports.assertSize = assertSize;\nexports.assertStartOffset = assertStartOffset;\nexports.assertEndOffset = assertEndOffset;\nexports.charCodeToBase16 = charCodeToBase16;\nexports.pad = pad;\nexports.trim = trim;\nconst Bytes = __webpack_require__(/*! ../Bytes.js */ \"(ssr)/./node_modules/ox/_cjs/core/Bytes.js\");\nfunction assertSize(bytes, size_) {\n    if (Bytes.size(bytes) > size_) throw new Bytes.SizeOverflowError({\n        givenSize: Bytes.size(bytes),\n        maxSize: size_\n    });\n}\nfunction assertStartOffset(value, start) {\n    if (typeof start === \"number\" && start > 0 && start > Bytes.size(value) - 1) throw new Bytes.SliceOffsetOutOfBoundsError({\n        offset: start,\n        position: \"start\",\n        size: Bytes.size(value)\n    });\n}\nfunction assertEndOffset(value, start, end) {\n    if (typeof start === \"number\" && typeof end === \"number\" && Bytes.size(value) !== end - start) {\n        throw new Bytes.SliceOffsetOutOfBoundsError({\n            offset: end,\n            position: \"end\",\n            size: Bytes.size(value)\n        });\n    }\n}\nexports.charCodeMap = {\n    zero: 48,\n    nine: 57,\n    A: 65,\n    F: 70,\n    a: 97,\n    f: 102\n};\nfunction charCodeToBase16(char) {\n    if (char >= exports.charCodeMap.zero && char <= exports.charCodeMap.nine) return char - exports.charCodeMap.zero;\n    if (char >= exports.charCodeMap.A && char <= exports.charCodeMap.F) return char - (exports.charCodeMap.A - 10);\n    if (char >= exports.charCodeMap.a && char <= exports.charCodeMap.f) return char - (exports.charCodeMap.a - 10);\n    return undefined;\n}\nfunction pad(bytes, options = {}) {\n    const { dir, size = 32 } = options;\n    if (size === 0) return bytes;\n    if (bytes.length > size) throw new Bytes.SizeExceedsPaddingSizeError({\n        size: bytes.length,\n        targetSize: size,\n        type: \"Bytes\"\n    });\n    const paddedBytes = new Uint8Array(size);\n    for(let i = 0; i < size; i++){\n        const padEnd = dir === \"right\";\n        paddedBytes[padEnd ? i : size - i - 1] = bytes[padEnd ? i : bytes.length - i - 1];\n    }\n    return paddedBytes;\n}\nfunction trim(value, options = {}) {\n    const { dir = \"left\" } = options;\n    let data = value;\n    let sliceLength = 0;\n    for(let i = 0; i < data.length - 1; i++){\n        if (data[dir === \"left\" ? i : data.length - i - 1].toString() === \"0\") sliceLength++;\n        else break;\n    }\n    data = dir === \"left\" ? data.slice(sliceLength) : data.slice(0, data.length - sliceLength);\n    return data;\n} //# sourceMappingURL=bytes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2Nqcy9jb3JlL2ludGVybmFsL2J5dGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxtQkFBbUIsR0FBRyxLQUFLO0FBQzNCQSxrQkFBa0IsR0FBR0c7QUFDckJILHlCQUF5QixHQUFHSTtBQUM1QkosdUJBQXVCLEdBQUdLO0FBQzFCTCx3QkFBd0IsR0FBR007QUFDM0JOLFdBQVcsR0FBR087QUFDZFAsWUFBWSxHQUFHUTtBQUNmLE1BQU1DLFFBQVFDLG1CQUFPQSxDQUFDLCtEQUFhO0FBQ25DLFNBQVNQLFdBQVdRLEtBQUssRUFBRUMsS0FBSztJQUM1QixJQUFJSCxNQUFNSSxJQUFJLENBQUNGLFNBQVNDLE9BQ3BCLE1BQU0sSUFBSUgsTUFBTUssaUJBQWlCLENBQUM7UUFDOUJDLFdBQVdOLE1BQU1JLElBQUksQ0FBQ0Y7UUFDdEJLLFNBQVNKO0lBQ2I7QUFDUjtBQUNBLFNBQVNSLGtCQUFrQkgsS0FBSyxFQUFFZ0IsS0FBSztJQUNuQyxJQUFJLE9BQU9BLFVBQVUsWUFBWUEsUUFBUSxLQUFLQSxRQUFRUixNQUFNSSxJQUFJLENBQUNaLFNBQVMsR0FDdEUsTUFBTSxJQUFJUSxNQUFNUywyQkFBMkIsQ0FBQztRQUN4Q0MsUUFBUUY7UUFDUkcsVUFBVTtRQUNWUCxNQUFNSixNQUFNSSxJQUFJLENBQUNaO0lBQ3JCO0FBQ1I7QUFDQSxTQUFTSSxnQkFBZ0JKLEtBQUssRUFBRWdCLEtBQUssRUFBRUksR0FBRztJQUN0QyxJQUFJLE9BQU9KLFVBQVUsWUFDakIsT0FBT0ksUUFBUSxZQUNmWixNQUFNSSxJQUFJLENBQUNaLFdBQVdvQixNQUFNSixPQUFPO1FBQ25DLE1BQU0sSUFBSVIsTUFBTVMsMkJBQTJCLENBQUM7WUFDeENDLFFBQVFFO1lBQ1JELFVBQVU7WUFDVlAsTUFBTUosTUFBTUksSUFBSSxDQUFDWjtRQUNyQjtJQUNKO0FBQ0o7QUFDQUQsbUJBQW1CLEdBQUc7SUFDbEJzQixNQUFNO0lBQ05DLE1BQU07SUFDTkMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztBQUNQO0FBQ0EsU0FBU3JCLGlCQUFpQnNCLElBQUk7SUFDMUIsSUFBSUEsUUFBUTVCLFFBQVFFLFdBQVcsQ0FBQ29CLElBQUksSUFBSU0sUUFBUTVCLFFBQVFFLFdBQVcsQ0FBQ3FCLElBQUksRUFDcEUsT0FBT0ssT0FBTzVCLFFBQVFFLFdBQVcsQ0FBQ29CLElBQUk7SUFDMUMsSUFBSU0sUUFBUTVCLFFBQVFFLFdBQVcsQ0FBQ3NCLENBQUMsSUFBSUksUUFBUTVCLFFBQVFFLFdBQVcsQ0FBQ3VCLENBQUMsRUFDOUQsT0FBT0csT0FBUTVCLENBQUFBLFFBQVFFLFdBQVcsQ0FBQ3NCLENBQUMsR0FBRyxFQUFDO0lBQzVDLElBQUlJLFFBQVE1QixRQUFRRSxXQUFXLENBQUN3QixDQUFDLElBQUlFLFFBQVE1QixRQUFRRSxXQUFXLENBQUN5QixDQUFDLEVBQzlELE9BQU9DLE9BQVE1QixDQUFBQSxRQUFRRSxXQUFXLENBQUN3QixDQUFDLEdBQUcsRUFBQztJQUM1QyxPQUFPRztBQUNYO0FBQ0EsU0FBU3RCLElBQUlJLEtBQUssRUFBRW1CLFVBQVUsQ0FBQyxDQUFDO0lBQzVCLE1BQU0sRUFBRUMsR0FBRyxFQUFFbEIsT0FBTyxFQUFFLEVBQUUsR0FBR2lCO0lBQzNCLElBQUlqQixTQUFTLEdBQ1QsT0FBT0Y7SUFDWCxJQUFJQSxNQUFNcUIsTUFBTSxHQUFHbkIsTUFDZixNQUFNLElBQUlKLE1BQU13QiwyQkFBMkIsQ0FBQztRQUN4Q3BCLE1BQU1GLE1BQU1xQixNQUFNO1FBQ2xCRSxZQUFZckI7UUFDWnNCLE1BQU07SUFDVjtJQUNKLE1BQU1DLGNBQWMsSUFBSUMsV0FBV3hCO0lBQ25DLElBQUssSUFBSXlCLElBQUksR0FBR0EsSUFBSXpCLE1BQU15QixJQUFLO1FBQzNCLE1BQU1DLFNBQVNSLFFBQVE7UUFDdkJLLFdBQVcsQ0FBQ0csU0FBU0QsSUFBSXpCLE9BQU95QixJQUFJLEVBQUUsR0FDbEMzQixLQUFLLENBQUM0QixTQUFTRCxJQUFJM0IsTUFBTXFCLE1BQU0sR0FBR00sSUFBSSxFQUFFO0lBQ2hEO0lBQ0EsT0FBT0Y7QUFDWDtBQUNBLFNBQVM1QixLQUFLUCxLQUFLLEVBQUU2QixVQUFVLENBQUMsQ0FBQztJQUM3QixNQUFNLEVBQUVDLE1BQU0sTUFBTSxFQUFFLEdBQUdEO0lBQ3pCLElBQUlVLE9BQU92QztJQUNYLElBQUl3QyxjQUFjO0lBQ2xCLElBQUssSUFBSUgsSUFBSSxHQUFHQSxJQUFJRSxLQUFLUixNQUFNLEdBQUcsR0FBR00sSUFBSztRQUN0QyxJQUFJRSxJQUFJLENBQUNULFFBQVEsU0FBU08sSUFBSUUsS0FBS1IsTUFBTSxHQUFHTSxJQUFJLEVBQUUsQ0FBQ0ksUUFBUSxPQUFPLEtBQzlERDthQUVBO0lBQ1I7SUFDQUQsT0FDSVQsUUFBUSxTQUNGUyxLQUFLRyxLQUFLLENBQUNGLGVBQ1hELEtBQUtHLEtBQUssQ0FBQyxHQUFHSCxLQUFLUixNQUFNLEdBQUdTO0lBQ3RDLE9BQU9EO0FBQ1gsRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGF3LXdvcmtzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L19janMvY29yZS9pbnRlcm5hbC9ieXRlcy5qcz80NjY2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jaGFyQ29kZU1hcCA9IHZvaWQgMDtcbmV4cG9ydHMuYXNzZXJ0U2l6ZSA9IGFzc2VydFNpemU7XG5leHBvcnRzLmFzc2VydFN0YXJ0T2Zmc2V0ID0gYXNzZXJ0U3RhcnRPZmZzZXQ7XG5leHBvcnRzLmFzc2VydEVuZE9mZnNldCA9IGFzc2VydEVuZE9mZnNldDtcbmV4cG9ydHMuY2hhckNvZGVUb0Jhc2UxNiA9IGNoYXJDb2RlVG9CYXNlMTY7XG5leHBvcnRzLnBhZCA9IHBhZDtcbmV4cG9ydHMudHJpbSA9IHRyaW07XG5jb25zdCBCeXRlcyA9IHJlcXVpcmUoXCIuLi9CeXRlcy5qc1wiKTtcbmZ1bmN0aW9uIGFzc2VydFNpemUoYnl0ZXMsIHNpemVfKSB7XG4gICAgaWYgKEJ5dGVzLnNpemUoYnl0ZXMpID4gc2l6ZV8pXG4gICAgICAgIHRocm93IG5ldyBCeXRlcy5TaXplT3ZlcmZsb3dFcnJvcih7XG4gICAgICAgICAgICBnaXZlblNpemU6IEJ5dGVzLnNpemUoYnl0ZXMpLFxuICAgICAgICAgICAgbWF4U2l6ZTogc2l6ZV8sXG4gICAgICAgIH0pO1xufVxuZnVuY3Rpb24gYXNzZXJ0U3RhcnRPZmZzZXQodmFsdWUsIHN0YXJ0KSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ251bWJlcicgJiYgc3RhcnQgPiAwICYmIHN0YXJ0ID4gQnl0ZXMuc2l6ZSh2YWx1ZSkgLSAxKVxuICAgICAgICB0aHJvdyBuZXcgQnl0ZXMuU2xpY2VPZmZzZXRPdXRPZkJvdW5kc0Vycm9yKHtcbiAgICAgICAgICAgIG9mZnNldDogc3RhcnQsXG4gICAgICAgICAgICBwb3NpdGlvbjogJ3N0YXJ0JyxcbiAgICAgICAgICAgIHNpemU6IEJ5dGVzLnNpemUodmFsdWUpLFxuICAgICAgICB9KTtcbn1cbmZ1bmN0aW9uIGFzc2VydEVuZE9mZnNldCh2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdudW1iZXInICYmXG4gICAgICAgIHR5cGVvZiBlbmQgPT09ICdudW1iZXInICYmXG4gICAgICAgIEJ5dGVzLnNpemUodmFsdWUpICE9PSBlbmQgLSBzdGFydCkge1xuICAgICAgICB0aHJvdyBuZXcgQnl0ZXMuU2xpY2VPZmZzZXRPdXRPZkJvdW5kc0Vycm9yKHtcbiAgICAgICAgICAgIG9mZnNldDogZW5kLFxuICAgICAgICAgICAgcG9zaXRpb246ICdlbmQnLFxuICAgICAgICAgICAgc2l6ZTogQnl0ZXMuc2l6ZSh2YWx1ZSksXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuY2hhckNvZGVNYXAgPSB7XG4gICAgemVybzogNDgsXG4gICAgbmluZTogNTcsXG4gICAgQTogNjUsXG4gICAgRjogNzAsXG4gICAgYTogOTcsXG4gICAgZjogMTAyLFxufTtcbmZ1bmN0aW9uIGNoYXJDb2RlVG9CYXNlMTYoY2hhcikge1xuICAgIGlmIChjaGFyID49IGV4cG9ydHMuY2hhckNvZGVNYXAuemVybyAmJiBjaGFyIDw9IGV4cG9ydHMuY2hhckNvZGVNYXAubmluZSlcbiAgICAgICAgcmV0dXJuIGNoYXIgLSBleHBvcnRzLmNoYXJDb2RlTWFwLnplcm87XG4gICAgaWYgKGNoYXIgPj0gZXhwb3J0cy5jaGFyQ29kZU1hcC5BICYmIGNoYXIgPD0gZXhwb3J0cy5jaGFyQ29kZU1hcC5GKVxuICAgICAgICByZXR1cm4gY2hhciAtIChleHBvcnRzLmNoYXJDb2RlTWFwLkEgLSAxMCk7XG4gICAgaWYgKGNoYXIgPj0gZXhwb3J0cy5jaGFyQ29kZU1hcC5hICYmIGNoYXIgPD0gZXhwb3J0cy5jaGFyQ29kZU1hcC5mKVxuICAgICAgICByZXR1cm4gY2hhciAtIChleHBvcnRzLmNoYXJDb2RlTWFwLmEgLSAxMCk7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIHBhZChieXRlcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBkaXIsIHNpemUgPSAzMiB9ID0gb3B0aW9ucztcbiAgICBpZiAoc2l6ZSA9PT0gMClcbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIGlmIChieXRlcy5sZW5ndGggPiBzaXplKVxuICAgICAgICB0aHJvdyBuZXcgQnl0ZXMuU2l6ZUV4Y2VlZHNQYWRkaW5nU2l6ZUVycm9yKHtcbiAgICAgICAgICAgIHNpemU6IGJ5dGVzLmxlbmd0aCxcbiAgICAgICAgICAgIHRhcmdldFNpemU6IHNpemUsXG4gICAgICAgICAgICB0eXBlOiAnQnl0ZXMnLFxuICAgICAgICB9KTtcbiAgICBjb25zdCBwYWRkZWRCeXRlcyA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHBhZEVuZCA9IGRpciA9PT0gJ3JpZ2h0JztcbiAgICAgICAgcGFkZGVkQnl0ZXNbcGFkRW5kID8gaSA6IHNpemUgLSBpIC0gMV0gPVxuICAgICAgICAgICAgYnl0ZXNbcGFkRW5kID8gaSA6IGJ5dGVzLmxlbmd0aCAtIGkgLSAxXTtcbiAgICB9XG4gICAgcmV0dXJuIHBhZGRlZEJ5dGVzO1xufVxuZnVuY3Rpb24gdHJpbSh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBkaXIgPSAnbGVmdCcgfSA9IG9wdGlvbnM7XG4gICAgbGV0IGRhdGEgPSB2YWx1ZTtcbiAgICBsZXQgc2xpY2VMZW5ndGggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgaWYgKGRhdGFbZGlyID09PSAnbGVmdCcgPyBpIDogZGF0YS5sZW5ndGggLSBpIC0gMV0udG9TdHJpbmcoKSA9PT0gJzAnKVxuICAgICAgICAgICAgc2xpY2VMZW5ndGgrKztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGRhdGEgPVxuICAgICAgICBkaXIgPT09ICdsZWZ0J1xuICAgICAgICAgICAgPyBkYXRhLnNsaWNlKHNsaWNlTGVuZ3RoKVxuICAgICAgICAgICAgOiBkYXRhLnNsaWNlKDAsIGRhdGEubGVuZ3RoIC0gc2xpY2VMZW5ndGgpO1xuICAgIHJldHVybiBkYXRhO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ynl0ZXMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiY2hhckNvZGVNYXAiLCJhc3NlcnRTaXplIiwiYXNzZXJ0U3RhcnRPZmZzZXQiLCJhc3NlcnRFbmRPZmZzZXQiLCJjaGFyQ29kZVRvQmFzZTE2IiwicGFkIiwidHJpbSIsIkJ5dGVzIiwicmVxdWlyZSIsImJ5dGVzIiwic2l6ZV8iLCJzaXplIiwiU2l6ZU92ZXJmbG93RXJyb3IiLCJnaXZlblNpemUiLCJtYXhTaXplIiwic3RhcnQiLCJTbGljZU9mZnNldE91dE9mQm91bmRzRXJyb3IiLCJvZmZzZXQiLCJwb3NpdGlvbiIsImVuZCIsInplcm8iLCJuaW5lIiwiQSIsIkYiLCJhIiwiZiIsImNoYXIiLCJ1bmRlZmluZWQiLCJvcHRpb25zIiwiZGlyIiwibGVuZ3RoIiwiU2l6ZUV4Y2VlZHNQYWRkaW5nU2l6ZUVycm9yIiwidGFyZ2V0U2l6ZSIsInR5cGUiLCJwYWRkZWRCeXRlcyIsIlVpbnQ4QXJyYXkiLCJpIiwicGFkRW5kIiwiZGF0YSIsInNsaWNlTGVuZ3RoIiwidG9TdHJpbmciLCJzbGljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_cjs/core/internal/bytes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_cjs/core/internal/cursor.js":
/*!******************************************************!*\
  !*** ./node_modules/ox/_cjs/core/internal/cursor.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.RecursiveReadLimitExceededError = exports.PositionOutOfBoundsError = exports.NegativeOffsetError = void 0;\nexports.create = create;\nconst Errors = __webpack_require__(/*! ../Errors.js */ \"(ssr)/./node_modules/ox/_cjs/core/Errors.js\");\nconst staticCursor = {\n    bytes: new Uint8Array(),\n    dataView: new DataView(new ArrayBuffer(0)),\n    position: 0,\n    positionReadCount: new Map(),\n    recursiveReadCount: 0,\n    recursiveReadLimit: Number.POSITIVE_INFINITY,\n    assertReadLimit () {\n        if (this.recursiveReadCount >= this.recursiveReadLimit) throw new RecursiveReadLimitExceededError({\n            count: this.recursiveReadCount + 1,\n            limit: this.recursiveReadLimit\n        });\n    },\n    assertPosition (position) {\n        if (position < 0 || position > this.bytes.length - 1) throw new PositionOutOfBoundsError({\n            length: this.bytes.length,\n            position\n        });\n    },\n    decrementPosition (offset) {\n        if (offset < 0) throw new NegativeOffsetError({\n            offset\n        });\n        const position = this.position - offset;\n        this.assertPosition(position);\n        this.position = position;\n    },\n    getReadCount (position) {\n        return this.positionReadCount.get(position || this.position) || 0;\n    },\n    incrementPosition (offset) {\n        if (offset < 0) throw new NegativeOffsetError({\n            offset\n        });\n        const position = this.position + offset;\n        this.assertPosition(position);\n        this.position = position;\n    },\n    inspectByte (position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position);\n        return this.bytes[position];\n    },\n    inspectBytes (length, position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position + length - 1);\n        return this.bytes.subarray(position, position + length);\n    },\n    inspectUint8 (position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position);\n        return this.bytes[position];\n    },\n    inspectUint16 (position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position + 1);\n        return this.dataView.getUint16(position);\n    },\n    inspectUint24 (position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position + 2);\n        return (this.dataView.getUint16(position) << 8) + this.dataView.getUint8(position + 2);\n    },\n    inspectUint32 (position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position + 3);\n        return this.dataView.getUint32(position);\n    },\n    pushByte (byte) {\n        this.assertPosition(this.position);\n        this.bytes[this.position] = byte;\n        this.position++;\n    },\n    pushBytes (bytes) {\n        this.assertPosition(this.position + bytes.length - 1);\n        this.bytes.set(bytes, this.position);\n        this.position += bytes.length;\n    },\n    pushUint8 (value) {\n        this.assertPosition(this.position);\n        this.bytes[this.position] = value;\n        this.position++;\n    },\n    pushUint16 (value) {\n        this.assertPosition(this.position + 1);\n        this.dataView.setUint16(this.position, value);\n        this.position += 2;\n    },\n    pushUint24 (value) {\n        this.assertPosition(this.position + 2);\n        this.dataView.setUint16(this.position, value >> 8);\n        this.dataView.setUint8(this.position + 2, value & ~4294967040);\n        this.position += 3;\n    },\n    pushUint32 (value) {\n        this.assertPosition(this.position + 3);\n        this.dataView.setUint32(this.position, value);\n        this.position += 4;\n    },\n    readByte () {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectByte();\n        this.position++;\n        return value;\n    },\n    readBytes (length, size) {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectBytes(length);\n        this.position += size ?? length;\n        return value;\n    },\n    readUint8 () {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectUint8();\n        this.position += 1;\n        return value;\n    },\n    readUint16 () {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectUint16();\n        this.position += 2;\n        return value;\n    },\n    readUint24 () {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectUint24();\n        this.position += 3;\n        return value;\n    },\n    readUint32 () {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectUint32();\n        this.position += 4;\n        return value;\n    },\n    get remaining () {\n        return this.bytes.length - this.position;\n    },\n    setPosition (position) {\n        const oldPosition = this.position;\n        this.assertPosition(position);\n        this.position = position;\n        return ()=>this.position = oldPosition;\n    },\n    _touch () {\n        if (this.recursiveReadLimit === Number.POSITIVE_INFINITY) return;\n        const count = this.getReadCount();\n        this.positionReadCount.set(this.position, count + 1);\n        if (count > 0) this.recursiveReadCount++;\n    }\n};\nfunction create(bytes, { recursiveReadLimit = 8192 } = {}) {\n    const cursor = Object.create(staticCursor);\n    cursor.bytes = bytes;\n    cursor.dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n    cursor.positionReadCount = new Map();\n    cursor.recursiveReadLimit = recursiveReadLimit;\n    return cursor;\n}\nclass NegativeOffsetError extends Errors.BaseError {\n    constructor({ offset }){\n        super(`Offset \\`${offset}\\` cannot be negative.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Cursor.NegativeOffsetError\"\n        });\n    }\n}\nexports.NegativeOffsetError = NegativeOffsetError;\nclass PositionOutOfBoundsError extends Errors.BaseError {\n    constructor({ length, position }){\n        super(`Position \\`${position}\\` is out of bounds (\\`0 < position < ${length}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Cursor.PositionOutOfBoundsError\"\n        });\n    }\n}\nexports.PositionOutOfBoundsError = PositionOutOfBoundsError;\nclass RecursiveReadLimitExceededError extends Errors.BaseError {\n    constructor({ count, limit }){\n        super(`Recursive read limit of \\`${limit}\\` exceeded (recursive read count: \\`${count}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Cursor.RecursiveReadLimitExceededError\"\n        });\n    }\n}\nexports.RecursiveReadLimitExceededError = RecursiveReadLimitExceededError; //# sourceMappingURL=cursor.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2Nqcy9jb3JlL2ludGVybmFsL2N1cnNvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsdUNBQXVDLEdBQUdBLGdDQUFnQyxHQUFHQSwyQkFBMkIsR0FBRyxLQUFLO0FBQ2hIQSxjQUFjLEdBQUdLO0FBQ2pCLE1BQU1DLFNBQVNDLG1CQUFPQSxDQUFDLGlFQUFjO0FBQ3JDLE1BQU1DLGVBQWU7SUFDakJDLE9BQU8sSUFBSUM7SUFDWEMsVUFBVSxJQUFJQyxTQUFTLElBQUlDLFlBQVk7SUFDdkNDLFVBQVU7SUFDVkMsbUJBQW1CLElBQUlDO0lBQ3ZCQyxvQkFBb0I7SUFDcEJDLG9CQUFvQkMsT0FBT0MsaUJBQWlCO0lBQzVDQztRQUNJLElBQUksSUFBSSxDQUFDSixrQkFBa0IsSUFBSSxJQUFJLENBQUNDLGtCQUFrQixFQUNsRCxNQUFNLElBQUloQixnQ0FBZ0M7WUFDdENvQixPQUFPLElBQUksQ0FBQ0wsa0JBQWtCLEdBQUc7WUFDakNNLE9BQU8sSUFBSSxDQUFDTCxrQkFBa0I7UUFDbEM7SUFDUjtJQUNBTSxnQkFBZVYsUUFBUTtRQUNuQixJQUFJQSxXQUFXLEtBQUtBLFdBQVcsSUFBSSxDQUFDTCxLQUFLLENBQUNnQixNQUFNLEdBQUcsR0FDL0MsTUFBTSxJQUFJdEIseUJBQXlCO1lBQy9Cc0IsUUFBUSxJQUFJLENBQUNoQixLQUFLLENBQUNnQixNQUFNO1lBQ3pCWDtRQUNKO0lBQ1I7SUFDQVksbUJBQWtCQyxNQUFNO1FBQ3BCLElBQUlBLFNBQVMsR0FDVCxNQUFNLElBQUl2QixvQkFBb0I7WUFBRXVCO1FBQU87UUFDM0MsTUFBTWIsV0FBVyxJQUFJLENBQUNBLFFBQVEsR0FBR2E7UUFDakMsSUFBSSxDQUFDSCxjQUFjLENBQUNWO1FBQ3BCLElBQUksQ0FBQ0EsUUFBUSxHQUFHQTtJQUNwQjtJQUNBYyxjQUFhZCxRQUFRO1FBQ2pCLE9BQU8sSUFBSSxDQUFDQyxpQkFBaUIsQ0FBQ2MsR0FBRyxDQUFDZixZQUFZLElBQUksQ0FBQ0EsUUFBUSxLQUFLO0lBQ3BFO0lBQ0FnQixtQkFBa0JILE1BQU07UUFDcEIsSUFBSUEsU0FBUyxHQUNULE1BQU0sSUFBSXZCLG9CQUFvQjtZQUFFdUI7UUFBTztRQUMzQyxNQUFNYixXQUFXLElBQUksQ0FBQ0EsUUFBUSxHQUFHYTtRQUNqQyxJQUFJLENBQUNILGNBQWMsQ0FBQ1Y7UUFDcEIsSUFBSSxDQUFDQSxRQUFRLEdBQUdBO0lBQ3BCO0lBQ0FpQixhQUFZQyxTQUFTO1FBQ2pCLE1BQU1sQixXQUFXa0IsYUFBYSxJQUFJLENBQUNsQixRQUFRO1FBQzNDLElBQUksQ0FBQ1UsY0FBYyxDQUFDVjtRQUNwQixPQUFPLElBQUksQ0FBQ0wsS0FBSyxDQUFDSyxTQUFTO0lBQy9CO0lBQ0FtQixjQUFhUixNQUFNLEVBQUVPLFNBQVM7UUFDMUIsTUFBTWxCLFdBQVdrQixhQUFhLElBQUksQ0FBQ2xCLFFBQVE7UUFDM0MsSUFBSSxDQUFDVSxjQUFjLENBQUNWLFdBQVdXLFNBQVM7UUFDeEMsT0FBTyxJQUFJLENBQUNoQixLQUFLLENBQUN5QixRQUFRLENBQUNwQixVQUFVQSxXQUFXVztJQUNwRDtJQUNBVSxjQUFhSCxTQUFTO1FBQ2xCLE1BQU1sQixXQUFXa0IsYUFBYSxJQUFJLENBQUNsQixRQUFRO1FBQzNDLElBQUksQ0FBQ1UsY0FBYyxDQUFDVjtRQUNwQixPQUFPLElBQUksQ0FBQ0wsS0FBSyxDQUFDSyxTQUFTO0lBQy9CO0lBQ0FzQixlQUFjSixTQUFTO1FBQ25CLE1BQU1sQixXQUFXa0IsYUFBYSxJQUFJLENBQUNsQixRQUFRO1FBQzNDLElBQUksQ0FBQ1UsY0FBYyxDQUFDVixXQUFXO1FBQy9CLE9BQU8sSUFBSSxDQUFDSCxRQUFRLENBQUMwQixTQUFTLENBQUN2QjtJQUNuQztJQUNBd0IsZUFBY04sU0FBUztRQUNuQixNQUFNbEIsV0FBV2tCLGFBQWEsSUFBSSxDQUFDbEIsUUFBUTtRQUMzQyxJQUFJLENBQUNVLGNBQWMsQ0FBQ1YsV0FBVztRQUMvQixPQUFRLENBQUMsSUFBSSxDQUFDSCxRQUFRLENBQUMwQixTQUFTLENBQUN2QixhQUFhLEtBQzFDLElBQUksQ0FBQ0gsUUFBUSxDQUFDNEIsUUFBUSxDQUFDekIsV0FBVztJQUMxQztJQUNBMEIsZUFBY1IsU0FBUztRQUNuQixNQUFNbEIsV0FBV2tCLGFBQWEsSUFBSSxDQUFDbEIsUUFBUTtRQUMzQyxJQUFJLENBQUNVLGNBQWMsQ0FBQ1YsV0FBVztRQUMvQixPQUFPLElBQUksQ0FBQ0gsUUFBUSxDQUFDOEIsU0FBUyxDQUFDM0I7SUFDbkM7SUFDQTRCLFVBQVNDLElBQUk7UUFDVCxJQUFJLENBQUNuQixjQUFjLENBQUMsSUFBSSxDQUFDVixRQUFRO1FBQ2pDLElBQUksQ0FBQ0wsS0FBSyxDQUFDLElBQUksQ0FBQ0ssUUFBUSxDQUFDLEdBQUc2QjtRQUM1QixJQUFJLENBQUM3QixRQUFRO0lBQ2pCO0lBQ0E4QixXQUFVbkMsS0FBSztRQUNYLElBQUksQ0FBQ2UsY0FBYyxDQUFDLElBQUksQ0FBQ1YsUUFBUSxHQUFHTCxNQUFNZ0IsTUFBTSxHQUFHO1FBQ25ELElBQUksQ0FBQ2hCLEtBQUssQ0FBQ29DLEdBQUcsQ0FBQ3BDLE9BQU8sSUFBSSxDQUFDSyxRQUFRO1FBQ25DLElBQUksQ0FBQ0EsUUFBUSxJQUFJTCxNQUFNZ0IsTUFBTTtJQUNqQztJQUNBcUIsV0FBVTdDLEtBQUs7UUFDWCxJQUFJLENBQUN1QixjQUFjLENBQUMsSUFBSSxDQUFDVixRQUFRO1FBQ2pDLElBQUksQ0FBQ0wsS0FBSyxDQUFDLElBQUksQ0FBQ0ssUUFBUSxDQUFDLEdBQUdiO1FBQzVCLElBQUksQ0FBQ2EsUUFBUTtJQUNqQjtJQUNBaUMsWUFBVzlDLEtBQUs7UUFDWixJQUFJLENBQUN1QixjQUFjLENBQUMsSUFBSSxDQUFDVixRQUFRLEdBQUc7UUFDcEMsSUFBSSxDQUFDSCxRQUFRLENBQUNxQyxTQUFTLENBQUMsSUFBSSxDQUFDbEMsUUFBUSxFQUFFYjtRQUN2QyxJQUFJLENBQUNhLFFBQVEsSUFBSTtJQUNyQjtJQUNBbUMsWUFBV2hELEtBQUs7UUFDWixJQUFJLENBQUN1QixjQUFjLENBQUMsSUFBSSxDQUFDVixRQUFRLEdBQUc7UUFDcEMsSUFBSSxDQUFDSCxRQUFRLENBQUNxQyxTQUFTLENBQUMsSUFBSSxDQUFDbEMsUUFBUSxFQUFFYixTQUFTO1FBQ2hELElBQUksQ0FBQ1UsUUFBUSxDQUFDdUMsUUFBUSxDQUFDLElBQUksQ0FBQ3BDLFFBQVEsR0FBRyxHQUFHYixRQUFRLENBQUM7UUFDbkQsSUFBSSxDQUFDYSxRQUFRLElBQUk7SUFDckI7SUFDQXFDLFlBQVdsRCxLQUFLO1FBQ1osSUFBSSxDQUFDdUIsY0FBYyxDQUFDLElBQUksQ0FBQ1YsUUFBUSxHQUFHO1FBQ3BDLElBQUksQ0FBQ0gsUUFBUSxDQUFDeUMsU0FBUyxDQUFDLElBQUksQ0FBQ3RDLFFBQVEsRUFBRWI7UUFDdkMsSUFBSSxDQUFDYSxRQUFRLElBQUk7SUFDckI7SUFDQXVDO1FBQ0ksSUFBSSxDQUFDaEMsZUFBZTtRQUNwQixJQUFJLENBQUNpQyxNQUFNO1FBQ1gsTUFBTXJELFFBQVEsSUFBSSxDQUFDOEIsV0FBVztRQUM5QixJQUFJLENBQUNqQixRQUFRO1FBQ2IsT0FBT2I7SUFDWDtJQUNBc0QsV0FBVTlCLE1BQU0sRUFBRStCLElBQUk7UUFDbEIsSUFBSSxDQUFDbkMsZUFBZTtRQUNwQixJQUFJLENBQUNpQyxNQUFNO1FBQ1gsTUFBTXJELFFBQVEsSUFBSSxDQUFDZ0MsWUFBWSxDQUFDUjtRQUNoQyxJQUFJLENBQUNYLFFBQVEsSUFBSTBDLFFBQVEvQjtRQUN6QixPQUFPeEI7SUFDWDtJQUNBd0Q7UUFDSSxJQUFJLENBQUNwQyxlQUFlO1FBQ3BCLElBQUksQ0FBQ2lDLE1BQU07UUFDWCxNQUFNckQsUUFBUSxJQUFJLENBQUNrQyxZQUFZO1FBQy9CLElBQUksQ0FBQ3JCLFFBQVEsSUFBSTtRQUNqQixPQUFPYjtJQUNYO0lBQ0F5RDtRQUNJLElBQUksQ0FBQ3JDLGVBQWU7UUFDcEIsSUFBSSxDQUFDaUMsTUFBTTtRQUNYLE1BQU1yRCxRQUFRLElBQUksQ0FBQ21DLGFBQWE7UUFDaEMsSUFBSSxDQUFDdEIsUUFBUSxJQUFJO1FBQ2pCLE9BQU9iO0lBQ1g7SUFDQTBEO1FBQ0ksSUFBSSxDQUFDdEMsZUFBZTtRQUNwQixJQUFJLENBQUNpQyxNQUFNO1FBQ1gsTUFBTXJELFFBQVEsSUFBSSxDQUFDcUMsYUFBYTtRQUNoQyxJQUFJLENBQUN4QixRQUFRLElBQUk7UUFDakIsT0FBT2I7SUFDWDtJQUNBMkQ7UUFDSSxJQUFJLENBQUN2QyxlQUFlO1FBQ3BCLElBQUksQ0FBQ2lDLE1BQU07UUFDWCxNQUFNckQsUUFBUSxJQUFJLENBQUN1QyxhQUFhO1FBQ2hDLElBQUksQ0FBQzFCLFFBQVEsSUFBSTtRQUNqQixPQUFPYjtJQUNYO0lBQ0EsSUFBSTRELGFBQVk7UUFDWixPQUFPLElBQUksQ0FBQ3BELEtBQUssQ0FBQ2dCLE1BQU0sR0FBRyxJQUFJLENBQUNYLFFBQVE7SUFDNUM7SUFDQWdELGFBQVloRCxRQUFRO1FBQ2hCLE1BQU1pRCxjQUFjLElBQUksQ0FBQ2pELFFBQVE7UUFDakMsSUFBSSxDQUFDVSxjQUFjLENBQUNWO1FBQ3BCLElBQUksQ0FBQ0EsUUFBUSxHQUFHQTtRQUNoQixPQUFPLElBQU8sSUFBSSxDQUFDQSxRQUFRLEdBQUdpRDtJQUNsQztJQUNBVDtRQUNJLElBQUksSUFBSSxDQUFDcEMsa0JBQWtCLEtBQUtDLE9BQU9DLGlCQUFpQixFQUNwRDtRQUNKLE1BQU1FLFFBQVEsSUFBSSxDQUFDTSxZQUFZO1FBQy9CLElBQUksQ0FBQ2IsaUJBQWlCLENBQUM4QixHQUFHLENBQUMsSUFBSSxDQUFDL0IsUUFBUSxFQUFFUSxRQUFRO1FBQ2xELElBQUlBLFFBQVEsR0FDUixJQUFJLENBQUNMLGtCQUFrQjtJQUMvQjtBQUNKO0FBQ0EsU0FBU1osT0FBT0ksS0FBSyxFQUFFLEVBQUVTLHFCQUFxQixJQUFLLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFDdEQsTUFBTThDLFNBQVNsRSxPQUFPTyxNQUFNLENBQUNHO0lBQzdCd0QsT0FBT3ZELEtBQUssR0FBR0E7SUFDZnVELE9BQU9yRCxRQUFRLEdBQUcsSUFBSUMsU0FBU0gsTUFBTXdELE1BQU0sRUFBRXhELE1BQU15RCxVQUFVLEVBQUV6RCxNQUFNMEQsVUFBVTtJQUMvRUgsT0FBT2pELGlCQUFpQixHQUFHLElBQUlDO0lBQy9CZ0QsT0FBTzlDLGtCQUFrQixHQUFHQTtJQUM1QixPQUFPOEM7QUFDWDtBQUNBLE1BQU01RCw0QkFBNEJFLE9BQU84RCxTQUFTO0lBQzlDQyxZQUFZLEVBQUUxQyxNQUFNLEVBQUUsQ0FBRTtRQUNwQixLQUFLLENBQUMsQ0FBQyxTQUFTLEVBQUVBLE9BQU8sc0JBQXNCLENBQUM7UUFDaEQ3QixPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLFFBQVE7WUFDaEN1RSxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWdkUsT0FBTztRQUNYO0lBQ0o7QUFDSjtBQUNBRCwyQkFBMkIsR0FBR0k7QUFDOUIsTUFBTUQsaUNBQWlDRyxPQUFPOEQsU0FBUztJQUNuREMsWUFBWSxFQUFFNUMsTUFBTSxFQUFFWCxRQUFRLEVBQUUsQ0FBRTtRQUM5QixLQUFLLENBQUMsQ0FBQyxXQUFXLEVBQUVBLFNBQVMsc0NBQXNDLEVBQUVXLE9BQU8sSUFBSSxDQUFDO1FBQ2pGM0IsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxRQUFRO1lBQ2hDdUUsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVnZFLE9BQU87UUFDWDtJQUNKO0FBQ0o7QUFDQUQsZ0NBQWdDLEdBQUdHO0FBQ25DLE1BQU1ELHdDQUF3Q0ksT0FBTzhELFNBQVM7SUFDMURDLFlBQVksRUFBRS9DLEtBQUssRUFBRUMsS0FBSyxFQUFFLENBQUU7UUFDMUIsS0FBSyxDQUFDLENBQUMsMEJBQTBCLEVBQUVBLE1BQU0scUNBQXFDLEVBQUVELE1BQU0sSUFBSSxDQUFDO1FBQzNGeEIsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxRQUFRO1lBQ2hDdUUsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVnZFLE9BQU87UUFDWDtJQUNKO0FBQ0o7QUFDQUQsdUNBQXVDLEdBQUdFLGlDQUMxQyxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGF3LXdvcmtzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L19janMvY29yZS9pbnRlcm5hbC9jdXJzb3IuanM/YWQ5MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmVjdXJzaXZlUmVhZExpbWl0RXhjZWVkZWRFcnJvciA9IGV4cG9ydHMuUG9zaXRpb25PdXRPZkJvdW5kc0Vycm9yID0gZXhwb3J0cy5OZWdhdGl2ZU9mZnNldEVycm9yID0gdm9pZCAwO1xuZXhwb3J0cy5jcmVhdGUgPSBjcmVhdGU7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKFwiLi4vRXJyb3JzLmpzXCIpO1xuY29uc3Qgc3RhdGljQ3Vyc29yID0ge1xuICAgIGJ5dGVzOiBuZXcgVWludDhBcnJheSgpLFxuICAgIGRhdGFWaWV3OiBuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDApKSxcbiAgICBwb3NpdGlvbjogMCxcbiAgICBwb3NpdGlvblJlYWRDb3VudDogbmV3IE1hcCgpLFxuICAgIHJlY3Vyc2l2ZVJlYWRDb3VudDogMCxcbiAgICByZWN1cnNpdmVSZWFkTGltaXQ6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICBhc3NlcnRSZWFkTGltaXQoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlY3Vyc2l2ZVJlYWRDb3VudCA+PSB0aGlzLnJlY3Vyc2l2ZVJlYWRMaW1pdClcbiAgICAgICAgICAgIHRocm93IG5ldyBSZWN1cnNpdmVSZWFkTGltaXRFeGNlZWRlZEVycm9yKHtcbiAgICAgICAgICAgICAgICBjb3VudDogdGhpcy5yZWN1cnNpdmVSZWFkQ291bnQgKyAxLFxuICAgICAgICAgICAgICAgIGxpbWl0OiB0aGlzLnJlY3Vyc2l2ZVJlYWRMaW1pdCxcbiAgICAgICAgICAgIH0pO1xuICAgIH0sXG4gICAgYXNzZXJ0UG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMCB8fCBwb3NpdGlvbiA+IHRoaXMuYnl0ZXMubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgIHRocm93IG5ldyBQb3NpdGlvbk91dE9mQm91bmRzRXJyb3Ioe1xuICAgICAgICAgICAgICAgIGxlbmd0aDogdGhpcy5ieXRlcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICB9KTtcbiAgICB9LFxuICAgIGRlY3JlbWVudFBvc2l0aW9uKG9mZnNldCkge1xuICAgICAgICBpZiAob2Zmc2V0IDwgMClcbiAgICAgICAgICAgIHRocm93IG5ldyBOZWdhdGl2ZU9mZnNldEVycm9yKHsgb2Zmc2V0IH0pO1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMucG9zaXRpb24gLSBvZmZzZXQ7XG4gICAgICAgIHRoaXMuYXNzZXJ0UG9zaXRpb24ocG9zaXRpb24pO1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgfSxcbiAgICBnZXRSZWFkQ291bnQocG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb25SZWFkQ291bnQuZ2V0KHBvc2l0aW9uIHx8IHRoaXMucG9zaXRpb24pIHx8IDA7XG4gICAgfSxcbiAgICBpbmNyZW1lbnRQb3NpdGlvbihvZmZzZXQpIHtcbiAgICAgICAgaWYgKG9mZnNldCA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgTmVnYXRpdmVPZmZzZXRFcnJvcih7IG9mZnNldCB9KTtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uICsgb2Zmc2V0O1xuICAgICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgIH0sXG4gICAgaW5zcGVjdEJ5dGUocG9zaXRpb25fKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gcG9zaXRpb25fID8/IHRoaXMucG9zaXRpb247XG4gICAgICAgIHRoaXMuYXNzZXJ0UG9zaXRpb24ocG9zaXRpb24pO1xuICAgICAgICByZXR1cm4gdGhpcy5ieXRlc1twb3NpdGlvbl07XG4gICAgfSxcbiAgICBpbnNwZWN0Qnl0ZXMobGVuZ3RoLCBwb3NpdGlvbl8pIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbl8gPz8gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgdGhpcy5hc3NlcnRQb3NpdGlvbihwb3NpdGlvbiArIGxlbmd0aCAtIDEpO1xuICAgICAgICByZXR1cm4gdGhpcy5ieXRlcy5zdWJhcnJheShwb3NpdGlvbiwgcG9zaXRpb24gKyBsZW5ndGgpO1xuICAgIH0sXG4gICAgaW5zcGVjdFVpbnQ4KHBvc2l0aW9uXykge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHBvc2l0aW9uXyA/PyB0aGlzLnBvc2l0aW9uO1xuICAgICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZXNbcG9zaXRpb25dO1xuICAgIH0sXG4gICAgaW5zcGVjdFVpbnQxNihwb3NpdGlvbl8pIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbl8gPz8gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgdGhpcy5hc3NlcnRQb3NpdGlvbihwb3NpdGlvbiArIDEpO1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhVmlldy5nZXRVaW50MTYocG9zaXRpb24pO1xuICAgIH0sXG4gICAgaW5zcGVjdFVpbnQyNChwb3NpdGlvbl8pIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbl8gPz8gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgdGhpcy5hc3NlcnRQb3NpdGlvbihwb3NpdGlvbiArIDIpO1xuICAgICAgICByZXR1cm4gKCh0aGlzLmRhdGFWaWV3LmdldFVpbnQxNihwb3NpdGlvbikgPDwgOCkgK1xuICAgICAgICAgICAgdGhpcy5kYXRhVmlldy5nZXRVaW50OChwb3NpdGlvbiArIDIpKTtcbiAgICB9LFxuICAgIGluc3BlY3RVaW50MzIocG9zaXRpb25fKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gcG9zaXRpb25fID8/IHRoaXMucG9zaXRpb247XG4gICAgICAgIHRoaXMuYXNzZXJ0UG9zaXRpb24ocG9zaXRpb24gKyAzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVZpZXcuZ2V0VWludDMyKHBvc2l0aW9uKTtcbiAgICB9LFxuICAgIHB1c2hCeXRlKGJ5dGUpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRQb3NpdGlvbih0aGlzLnBvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5ieXRlc1t0aGlzLnBvc2l0aW9uXSA9IGJ5dGU7XG4gICAgICAgIHRoaXMucG9zaXRpb24rKztcbiAgICB9LFxuICAgIHB1c2hCeXRlcyhieXRlcykge1xuICAgICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHRoaXMucG9zaXRpb24gKyBieXRlcy5sZW5ndGggLSAxKTtcbiAgICAgICAgdGhpcy5ieXRlcy5zZXQoYnl0ZXMsIHRoaXMucG9zaXRpb24pO1xuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IGJ5dGVzLmxlbmd0aDtcbiAgICB9LFxuICAgIHB1c2hVaW50OCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHRoaXMucG9zaXRpb24pO1xuICAgICAgICB0aGlzLmJ5dGVzW3RoaXMucG9zaXRpb25dID0gdmFsdWU7XG4gICAgICAgIHRoaXMucG9zaXRpb24rKztcbiAgICB9LFxuICAgIHB1c2hVaW50MTYodmFsdWUpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRQb3NpdGlvbih0aGlzLnBvc2l0aW9uICsgMSk7XG4gICAgICAgIHRoaXMuZGF0YVZpZXcuc2V0VWludDE2KHRoaXMucG9zaXRpb24sIHZhbHVlKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSAyO1xuICAgIH0sXG4gICAgcHVzaFVpbnQyNCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHRoaXMucG9zaXRpb24gKyAyKTtcbiAgICAgICAgdGhpcy5kYXRhVmlldy5zZXRVaW50MTYodGhpcy5wb3NpdGlvbiwgdmFsdWUgPj4gOCk7XG4gICAgICAgIHRoaXMuZGF0YVZpZXcuc2V0VWludDgodGhpcy5wb3NpdGlvbiArIDIsIHZhbHVlICYgfjQyOTQ5NjcwNDApO1xuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IDM7XG4gICAgfSxcbiAgICBwdXNoVWludDMyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0UG9zaXRpb24odGhpcy5wb3NpdGlvbiArIDMpO1xuICAgICAgICB0aGlzLmRhdGFWaWV3LnNldFVpbnQzMih0aGlzLnBvc2l0aW9uLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gNDtcbiAgICB9LFxuICAgIHJlYWRCeXRlKCkge1xuICAgICAgICB0aGlzLmFzc2VydFJlYWRMaW1pdCgpO1xuICAgICAgICB0aGlzLl90b3VjaCgpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuaW5zcGVjdEJ5dGUoKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbisrO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICByZWFkQnl0ZXMobGVuZ3RoLCBzaXplKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0UmVhZExpbWl0KCk7XG4gICAgICAgIHRoaXMuX3RvdWNoKCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5pbnNwZWN0Qnl0ZXMobGVuZ3RoKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSBzaXplID8/IGxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgcmVhZFVpbnQ4KCkge1xuICAgICAgICB0aGlzLmFzc2VydFJlYWRMaW1pdCgpO1xuICAgICAgICB0aGlzLl90b3VjaCgpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuaW5zcGVjdFVpbnQ4KCk7XG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gMTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgcmVhZFVpbnQxNigpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRSZWFkTGltaXQoKTtcbiAgICAgICAgdGhpcy5fdG91Y2goKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmluc3BlY3RVaW50MTYoKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSAyO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICByZWFkVWludDI0KCkge1xuICAgICAgICB0aGlzLmFzc2VydFJlYWRMaW1pdCgpO1xuICAgICAgICB0aGlzLl90b3VjaCgpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuaW5zcGVjdFVpbnQyNCgpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IDM7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHJlYWRVaW50MzIoKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0UmVhZExpbWl0KCk7XG4gICAgICAgIHRoaXMuX3RvdWNoKCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5pbnNwZWN0VWludDMyKCk7XG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gNDtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgZ2V0IHJlbWFpbmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZXMubGVuZ3RoIC0gdGhpcy5wb3NpdGlvbjtcbiAgICB9LFxuICAgIHNldFBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgIGNvbnN0IG9sZFBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgdGhpcy5hc3NlcnRQb3NpdGlvbihwb3NpdGlvbik7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICAgICAgcmV0dXJuICgpID0+ICh0aGlzLnBvc2l0aW9uID0gb2xkUG9zaXRpb24pO1xuICAgIH0sXG4gICAgX3RvdWNoKCkge1xuICAgICAgICBpZiAodGhpcy5yZWN1cnNpdmVSZWFkTGltaXQgPT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgY291bnQgPSB0aGlzLmdldFJlYWRDb3VudCgpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uUmVhZENvdW50LnNldCh0aGlzLnBvc2l0aW9uLCBjb3VudCArIDEpO1xuICAgICAgICBpZiAoY291bnQgPiAwKVxuICAgICAgICAgICAgdGhpcy5yZWN1cnNpdmVSZWFkQ291bnQrKztcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZShieXRlcywgeyByZWN1cnNpdmVSZWFkTGltaXQgPSA4XzE5MiB9ID0ge30pIHtcbiAgICBjb25zdCBjdXJzb3IgPSBPYmplY3QuY3JlYXRlKHN0YXRpY0N1cnNvcik7XG4gICAgY3Vyc29yLmJ5dGVzID0gYnl0ZXM7XG4gICAgY3Vyc29yLmRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGJ5dGVzLmJ1ZmZlciwgYnl0ZXMuYnl0ZU9mZnNldCwgYnl0ZXMuYnl0ZUxlbmd0aCk7XG4gICAgY3Vyc29yLnBvc2l0aW9uUmVhZENvdW50ID0gbmV3IE1hcCgpO1xuICAgIGN1cnNvci5yZWN1cnNpdmVSZWFkTGltaXQgPSByZWN1cnNpdmVSZWFkTGltaXQ7XG4gICAgcmV0dXJuIGN1cnNvcjtcbn1cbmNsYXNzIE5lZ2F0aXZlT2Zmc2V0RXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IG9mZnNldCB9KSB7XG4gICAgICAgIHN1cGVyKGBPZmZzZXQgXFxgJHtvZmZzZXR9XFxgIGNhbm5vdCBiZSBuZWdhdGl2ZS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0N1cnNvci5OZWdhdGl2ZU9mZnNldEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLk5lZ2F0aXZlT2Zmc2V0RXJyb3IgPSBOZWdhdGl2ZU9mZnNldEVycm9yO1xuY2xhc3MgUG9zaXRpb25PdXRPZkJvdW5kc0Vycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBsZW5ndGgsIHBvc2l0aW9uIH0pIHtcbiAgICAgICAgc3VwZXIoYFBvc2l0aW9uIFxcYCR7cG9zaXRpb259XFxgIGlzIG91dCBvZiBib3VuZHMgKFxcYDAgPCBwb3NpdGlvbiA8ICR7bGVuZ3RofVxcYCkuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdDdXJzb3IuUG9zaXRpb25PdXRPZkJvdW5kc0Vycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLlBvc2l0aW9uT3V0T2ZCb3VuZHNFcnJvciA9IFBvc2l0aW9uT3V0T2ZCb3VuZHNFcnJvcjtcbmNsYXNzIFJlY3Vyc2l2ZVJlYWRMaW1pdEV4Y2VlZGVkRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGNvdW50LCBsaW1pdCB9KSB7XG4gICAgICAgIHN1cGVyKGBSZWN1cnNpdmUgcmVhZCBsaW1pdCBvZiBcXGAke2xpbWl0fVxcYCBleGNlZWRlZCAocmVjdXJzaXZlIHJlYWQgY291bnQ6IFxcYCR7Y291bnR9XFxgKS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0N1cnNvci5SZWN1cnNpdmVSZWFkTGltaXRFeGNlZWRlZEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLlJlY3Vyc2l2ZVJlYWRMaW1pdEV4Y2VlZGVkRXJyb3IgPSBSZWN1cnNpdmVSZWFkTGltaXRFeGNlZWRlZEVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3Vyc29yLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlJlY3Vyc2l2ZVJlYWRMaW1pdEV4Y2VlZGVkRXJyb3IiLCJQb3NpdGlvbk91dE9mQm91bmRzRXJyb3IiLCJOZWdhdGl2ZU9mZnNldEVycm9yIiwiY3JlYXRlIiwiRXJyb3JzIiwicmVxdWlyZSIsInN0YXRpY0N1cnNvciIsImJ5dGVzIiwiVWludDhBcnJheSIsImRhdGFWaWV3IiwiRGF0YVZpZXciLCJBcnJheUJ1ZmZlciIsInBvc2l0aW9uIiwicG9zaXRpb25SZWFkQ291bnQiLCJNYXAiLCJyZWN1cnNpdmVSZWFkQ291bnQiLCJyZWN1cnNpdmVSZWFkTGltaXQiLCJOdW1iZXIiLCJQT1NJVElWRV9JTkZJTklUWSIsImFzc2VydFJlYWRMaW1pdCIsImNvdW50IiwibGltaXQiLCJhc3NlcnRQb3NpdGlvbiIsImxlbmd0aCIsImRlY3JlbWVudFBvc2l0aW9uIiwib2Zmc2V0IiwiZ2V0UmVhZENvdW50IiwiZ2V0IiwiaW5jcmVtZW50UG9zaXRpb24iLCJpbnNwZWN0Qnl0ZSIsInBvc2l0aW9uXyIsImluc3BlY3RCeXRlcyIsInN1YmFycmF5IiwiaW5zcGVjdFVpbnQ4IiwiaW5zcGVjdFVpbnQxNiIsImdldFVpbnQxNiIsImluc3BlY3RVaW50MjQiLCJnZXRVaW50OCIsImluc3BlY3RVaW50MzIiLCJnZXRVaW50MzIiLCJwdXNoQnl0ZSIsImJ5dGUiLCJwdXNoQnl0ZXMiLCJzZXQiLCJwdXNoVWludDgiLCJwdXNoVWludDE2Iiwic2V0VWludDE2IiwicHVzaFVpbnQyNCIsInNldFVpbnQ4IiwicHVzaFVpbnQzMiIsInNldFVpbnQzMiIsInJlYWRCeXRlIiwiX3RvdWNoIiwicmVhZEJ5dGVzIiwic2l6ZSIsInJlYWRVaW50OCIsInJlYWRVaW50MTYiLCJyZWFkVWludDI0IiwicmVhZFVpbnQzMiIsInJlbWFpbmluZyIsInNldFBvc2l0aW9uIiwib2xkUG9zaXRpb24iLCJjdXJzb3IiLCJidWZmZXIiLCJieXRlT2Zmc2V0IiwiYnl0ZUxlbmd0aCIsIkJhc2VFcnJvciIsImNvbnN0cnVjdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_cjs/core/internal/cursor.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_cjs/core/internal/entropy.js":
/*!*******************************************************!*\
  !*** ./node_modules/ox/_cjs/core/internal/entropy.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.extraEntropy = void 0;\nexports.setExtraEntropy = setExtraEntropy;\nexports.extraEntropy = false;\nfunction setExtraEntropy(entropy) {\n    exports.extraEntropy = entropy;\n} //# sourceMappingURL=entropy.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2Nqcy9jb3JlL2ludGVybmFsL2VudHJvcHkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELG9CQUFvQixHQUFHLEtBQUs7QUFDNUJBLHVCQUF1QixHQUFHRztBQUMxQkgsb0JBQW9CLEdBQUc7QUFDdkIsU0FBU0csZ0JBQWdCQyxPQUFPO0lBQzVCSixvQkFBb0IsR0FBR0k7QUFDM0IsRUFDQSxtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGF3LXdvcmtzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L19janMvY29yZS9pbnRlcm5hbC9lbnRyb3B5LmpzPzI2YTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmV4dHJhRW50cm9weSA9IHZvaWQgMDtcbmV4cG9ydHMuc2V0RXh0cmFFbnRyb3B5ID0gc2V0RXh0cmFFbnRyb3B5O1xuZXhwb3J0cy5leHRyYUVudHJvcHkgPSBmYWxzZTtcbmZ1bmN0aW9uIHNldEV4dHJhRW50cm9weShlbnRyb3B5KSB7XG4gICAgZXhwb3J0cy5leHRyYUVudHJvcHkgPSBlbnRyb3B5O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW50cm9weS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJleHRyYUVudHJvcHkiLCJzZXRFeHRyYUVudHJvcHkiLCJlbnRyb3B5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_cjs/core/internal/entropy.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_cjs/core/internal/errors.js":
/*!******************************************************!*\
  !*** ./node_modules/ox/_cjs/core/internal/errors.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getUrl = getUrl;\nexports.getVersion = getVersion;\nexports.prettyPrint = prettyPrint;\nconst version_js_1 = __webpack_require__(/*! ../version.js */ \"(ssr)/./node_modules/ox/_cjs/core/version.js\");\nfunction getUrl(url) {\n    return url;\n}\nfunction getVersion() {\n    return version_js_1.version;\n}\nfunction prettyPrint(args) {\n    if (!args) return \"\";\n    const entries = Object.entries(args).map(([key, value])=>{\n        if (value === undefined || value === false) return null;\n        return [\n            key,\n            value\n        ];\n    }).filter(Boolean);\n    const maxLength = entries.reduce((acc, [key])=>Math.max(acc, key.length), 0);\n    return entries.map(([key, value])=>`  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`).join(\"\\n\");\n} //# sourceMappingURL=errors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2Nqcy9jb3JlL2ludGVybmFsL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsY0FBYyxHQUFHRTtBQUNqQkYsa0JBQWtCLEdBQUdHO0FBQ3JCSCxtQkFBbUIsR0FBR0k7QUFDdEIsTUFBTUMsZUFBZUMsbUJBQU9BLENBQUMsbUVBQWU7QUFDNUMsU0FBU0osT0FBT0ssR0FBRztJQUNmLE9BQU9BO0FBQ1g7QUFDQSxTQUFTSjtJQUNMLE9BQU9FLGFBQWFHLE9BQU87QUFDL0I7QUFDQSxTQUFTSixZQUFZSyxJQUFJO0lBQ3JCLElBQUksQ0FBQ0EsTUFDRCxPQUFPO0lBQ1gsTUFBTUMsVUFBVVosT0FBT1ksT0FBTyxDQUFDRCxNQUMxQkUsR0FBRyxDQUFDLENBQUMsQ0FBQ0MsS0FBS1gsTUFBTTtRQUNsQixJQUFJQSxVQUFVWSxhQUFhWixVQUFVLE9BQ2pDLE9BQU87UUFDWCxPQUFPO1lBQUNXO1lBQUtYO1NBQU07SUFDdkIsR0FDS2EsTUFBTSxDQUFDQztJQUNaLE1BQU1DLFlBQVlOLFFBQVFPLE1BQU0sQ0FBQyxDQUFDQyxLQUFLLENBQUNOLElBQUksR0FBS08sS0FBS0MsR0FBRyxDQUFDRixLQUFLTixJQUFJUyxNQUFNLEdBQUc7SUFDNUUsT0FBT1gsUUFDRkMsR0FBRyxDQUFDLENBQUMsQ0FBQ0MsS0FBS1gsTUFBTSxHQUFLLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRVcsSUFBSSxDQUFDLENBQUMsQ0FBQ1UsTUFBTSxDQUFDTixZQUFZLEdBQUcsRUFBRSxFQUFFZixNQUFNLENBQUMsRUFDdEVzQixJQUFJLENBQUM7QUFDZCxFQUNBLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsYXctd29ya3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3gvX2Nqcy9jb3JlL2ludGVybmFsL2Vycm9ycy5qcz82YmI3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRVcmwgPSBnZXRVcmw7XG5leHBvcnRzLmdldFZlcnNpb24gPSBnZXRWZXJzaW9uO1xuZXhwb3J0cy5wcmV0dHlQcmludCA9IHByZXR0eVByaW50O1xuY29uc3QgdmVyc2lvbl9qc18xID0gcmVxdWlyZShcIi4uL3ZlcnNpb24uanNcIik7XG5mdW5jdGlvbiBnZXRVcmwodXJsKSB7XG4gICAgcmV0dXJuIHVybDtcbn1cbmZ1bmN0aW9uIGdldFZlcnNpb24oKSB7XG4gICAgcmV0dXJuIHZlcnNpb25fanNfMS52ZXJzaW9uO1xufVxuZnVuY3Rpb24gcHJldHR5UHJpbnQoYXJncykge1xuICAgIGlmICghYXJncylcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIGNvbnN0IGVudHJpZXMgPSBPYmplY3QuZW50cmllcyhhcmdzKVxuICAgICAgICAubWFwKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IGZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBba2V5LCB2YWx1ZV07XG4gICAgfSlcbiAgICAgICAgLmZpbHRlcihCb29sZWFuKTtcbiAgICBjb25zdCBtYXhMZW5ndGggPSBlbnRyaWVzLnJlZHVjZSgoYWNjLCBba2V5XSkgPT4gTWF0aC5tYXgoYWNjLCBrZXkubGVuZ3RoKSwgMCk7XG4gICAgcmV0dXJuIGVudHJpZXNcbiAgICAgICAgLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBgICAke2Ake2tleX06YC5wYWRFbmQobWF4TGVuZ3RoICsgMSl9ICAke3ZhbHVlfWApXG4gICAgICAgIC5qb2luKCdcXG4nKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9ycy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJnZXRVcmwiLCJnZXRWZXJzaW9uIiwicHJldHR5UHJpbnQiLCJ2ZXJzaW9uX2pzXzEiLCJyZXF1aXJlIiwidXJsIiwidmVyc2lvbiIsImFyZ3MiLCJlbnRyaWVzIiwibWFwIiwia2V5IiwidW5kZWZpbmVkIiwiZmlsdGVyIiwiQm9vbGVhbiIsIm1heExlbmd0aCIsInJlZHVjZSIsImFjYyIsIk1hdGgiLCJtYXgiLCJsZW5ndGgiLCJwYWRFbmQiLCJqb2luIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_cjs/core/internal/errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_cjs/core/internal/hex.js":
/*!***************************************************!*\
  !*** ./node_modules/ox/_cjs/core/internal/hex.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.assertSize = assertSize;\nexports.assertStartOffset = assertStartOffset;\nexports.assertEndOffset = assertEndOffset;\nexports.pad = pad;\nexports.trim = trim;\nconst Hex = __webpack_require__(/*! ../Hex.js */ \"(ssr)/./node_modules/ox/_cjs/core/Hex.js\");\nfunction assertSize(hex, size_) {\n    if (Hex.size(hex) > size_) throw new Hex.SizeOverflowError({\n        givenSize: Hex.size(hex),\n        maxSize: size_\n    });\n}\nfunction assertStartOffset(value, start) {\n    if (typeof start === \"number\" && start > 0 && start > Hex.size(value) - 1) throw new Hex.SliceOffsetOutOfBoundsError({\n        offset: start,\n        position: \"start\",\n        size: Hex.size(value)\n    });\n}\nfunction assertEndOffset(value, start, end) {\n    if (typeof start === \"number\" && typeof end === \"number\" && Hex.size(value) !== end - start) {\n        throw new Hex.SliceOffsetOutOfBoundsError({\n            offset: end,\n            position: \"end\",\n            size: Hex.size(value)\n        });\n    }\n}\nfunction pad(hex_, options = {}) {\n    const { dir, size = 32 } = options;\n    if (size === 0) return hex_;\n    const hex = hex_.replace(\"0x\", \"\");\n    if (hex.length > size * 2) throw new Hex.SizeExceedsPaddingSizeError({\n        size: Math.ceil(hex.length / 2),\n        targetSize: size,\n        type: \"Hex\"\n    });\n    return `0x${hex[dir === \"right\" ? \"padEnd\" : \"padStart\"](size * 2, \"0\")}`;\n}\nfunction trim(value, options = {}) {\n    const { dir = \"left\" } = options;\n    let data = value.replace(\"0x\", \"\");\n    let sliceLength = 0;\n    for(let i = 0; i < data.length - 1; i++){\n        if (data[dir === \"left\" ? i : data.length - i - 1].toString() === \"0\") sliceLength++;\n        else break;\n    }\n    data = dir === \"left\" ? data.slice(sliceLength) : data.slice(0, data.length - sliceLength);\n    if (data === \"0\") return \"0x\";\n    if (dir === \"right\" && data.length % 2 === 1) return `0x${data}0`;\n    return `0x${data}`;\n} //# sourceMappingURL=hex.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2Nqcy9jb3JlL2ludGVybmFsL2hleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsa0JBQWtCLEdBQUdFO0FBQ3JCRix5QkFBeUIsR0FBR0c7QUFDNUJILHVCQUF1QixHQUFHSTtBQUMxQkosV0FBVyxHQUFHSztBQUNkTCxZQUFZLEdBQUdNO0FBQ2YsTUFBTUMsTUFBTUMsbUJBQU9BLENBQUMsMkRBQVc7QUFDL0IsU0FBU04sV0FBV08sR0FBRyxFQUFFQyxLQUFLO0lBQzFCLElBQUlILElBQUlJLElBQUksQ0FBQ0YsT0FBT0MsT0FDaEIsTUFBTSxJQUFJSCxJQUFJSyxpQkFBaUIsQ0FBQztRQUM1QkMsV0FBV04sSUFBSUksSUFBSSxDQUFDRjtRQUNwQkssU0FBU0o7SUFDYjtBQUNSO0FBQ0EsU0FBU1Asa0JBQWtCRixLQUFLLEVBQUVjLEtBQUs7SUFDbkMsSUFBSSxPQUFPQSxVQUFVLFlBQVlBLFFBQVEsS0FBS0EsUUFBUVIsSUFBSUksSUFBSSxDQUFDVixTQUFTLEdBQ3BFLE1BQU0sSUFBSU0sSUFBSVMsMkJBQTJCLENBQUM7UUFDdENDLFFBQVFGO1FBQ1JHLFVBQVU7UUFDVlAsTUFBTUosSUFBSUksSUFBSSxDQUFDVjtJQUNuQjtBQUNSO0FBQ0EsU0FBU0csZ0JBQWdCSCxLQUFLLEVBQUVjLEtBQUssRUFBRUksR0FBRztJQUN0QyxJQUFJLE9BQU9KLFVBQVUsWUFDakIsT0FBT0ksUUFBUSxZQUNmWixJQUFJSSxJQUFJLENBQUNWLFdBQVdrQixNQUFNSixPQUFPO1FBQ2pDLE1BQU0sSUFBSVIsSUFBSVMsMkJBQTJCLENBQUM7WUFDdENDLFFBQVFFO1lBQ1JELFVBQVU7WUFDVlAsTUFBTUosSUFBSUksSUFBSSxDQUFDVjtRQUNuQjtJQUNKO0FBQ0o7QUFDQSxTQUFTSSxJQUFJZSxJQUFJLEVBQUVDLFVBQVUsQ0FBQyxDQUFDO0lBQzNCLE1BQU0sRUFBRUMsR0FBRyxFQUFFWCxPQUFPLEVBQUUsRUFBRSxHQUFHVTtJQUMzQixJQUFJVixTQUFTLEdBQ1QsT0FBT1M7SUFDWCxNQUFNWCxNQUFNVyxLQUFLRyxPQUFPLENBQUMsTUFBTTtJQUMvQixJQUFJZCxJQUFJZSxNQUFNLEdBQUdiLE9BQU8sR0FDcEIsTUFBTSxJQUFJSixJQUFJa0IsMkJBQTJCLENBQUM7UUFDdENkLE1BQU1lLEtBQUtDLElBQUksQ0FBQ2xCLElBQUllLE1BQU0sR0FBRztRQUM3QkksWUFBWWpCO1FBQ1prQixNQUFNO0lBQ1Y7SUFDSixPQUFPLENBQUMsRUFBRSxFQUFFcEIsR0FBRyxDQUFDYSxRQUFRLFVBQVUsV0FBVyxXQUFXLENBQUNYLE9BQU8sR0FBRyxLQUFLLENBQUM7QUFDN0U7QUFDQSxTQUFTTCxLQUFLTCxLQUFLLEVBQUVvQixVQUFVLENBQUMsQ0FBQztJQUM3QixNQUFNLEVBQUVDLE1BQU0sTUFBTSxFQUFFLEdBQUdEO0lBQ3pCLElBQUlTLE9BQU83QixNQUFNc0IsT0FBTyxDQUFDLE1BQU07SUFDL0IsSUFBSVEsY0FBYztJQUNsQixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUYsS0FBS04sTUFBTSxHQUFHLEdBQUdRLElBQUs7UUFDdEMsSUFBSUYsSUFBSSxDQUFDUixRQUFRLFNBQVNVLElBQUlGLEtBQUtOLE1BQU0sR0FBR1EsSUFBSSxFQUFFLENBQUNDLFFBQVEsT0FBTyxLQUM5REY7YUFFQTtJQUNSO0lBQ0FELE9BQ0lSLFFBQVEsU0FDRlEsS0FBS0ksS0FBSyxDQUFDSCxlQUNYRCxLQUFLSSxLQUFLLENBQUMsR0FBR0osS0FBS04sTUFBTSxHQUFHTztJQUN0QyxJQUFJRCxTQUFTLEtBQ1QsT0FBTztJQUNYLElBQUlSLFFBQVEsV0FBV1EsS0FBS04sTUFBTSxHQUFHLE1BQU0sR0FDdkMsT0FBTyxDQUFDLEVBQUUsRUFBRU0sS0FBSyxDQUFDLENBQUM7SUFDdkIsT0FBTyxDQUFDLEVBQUUsRUFBRUEsS0FBSyxDQUFDO0FBQ3RCLEVBQ0EsK0JBQStCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xhdy13b3Jrcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9fY2pzL2NvcmUvaW50ZXJuYWwvaGV4LmpzPzQ0ODEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFzc2VydFNpemUgPSBhc3NlcnRTaXplO1xuZXhwb3J0cy5hc3NlcnRTdGFydE9mZnNldCA9IGFzc2VydFN0YXJ0T2Zmc2V0O1xuZXhwb3J0cy5hc3NlcnRFbmRPZmZzZXQgPSBhc3NlcnRFbmRPZmZzZXQ7XG5leHBvcnRzLnBhZCA9IHBhZDtcbmV4cG9ydHMudHJpbSA9IHRyaW07XG5jb25zdCBIZXggPSByZXF1aXJlKFwiLi4vSGV4LmpzXCIpO1xuZnVuY3Rpb24gYXNzZXJ0U2l6ZShoZXgsIHNpemVfKSB7XG4gICAgaWYgKEhleC5zaXplKGhleCkgPiBzaXplXylcbiAgICAgICAgdGhyb3cgbmV3IEhleC5TaXplT3ZlcmZsb3dFcnJvcih7XG4gICAgICAgICAgICBnaXZlblNpemU6IEhleC5zaXplKGhleCksXG4gICAgICAgICAgICBtYXhTaXplOiBzaXplXyxcbiAgICAgICAgfSk7XG59XG5mdW5jdGlvbiBhc3NlcnRTdGFydE9mZnNldCh2YWx1ZSwgc3RhcnQpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnbnVtYmVyJyAmJiBzdGFydCA+IDAgJiYgc3RhcnQgPiBIZXguc2l6ZSh2YWx1ZSkgLSAxKVxuICAgICAgICB0aHJvdyBuZXcgSGV4LlNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvcih7XG4gICAgICAgICAgICBvZmZzZXQ6IHN0YXJ0LFxuICAgICAgICAgICAgcG9zaXRpb246ICdzdGFydCcsXG4gICAgICAgICAgICBzaXplOiBIZXguc2l6ZSh2YWx1ZSksXG4gICAgICAgIH0pO1xufVxuZnVuY3Rpb24gYXNzZXJ0RW5kT2Zmc2V0KHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgdHlwZW9mIGVuZCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgSGV4LnNpemUodmFsdWUpICE9PSBlbmQgLSBzdGFydCkge1xuICAgICAgICB0aHJvdyBuZXcgSGV4LlNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvcih7XG4gICAgICAgICAgICBvZmZzZXQ6IGVuZCxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnZW5kJyxcbiAgICAgICAgICAgIHNpemU6IEhleC5zaXplKHZhbHVlKSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFkKGhleF8sIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgZGlyLCBzaXplID0gMzIgfSA9IG9wdGlvbnM7XG4gICAgaWYgKHNpemUgPT09IDApXG4gICAgICAgIHJldHVybiBoZXhfO1xuICAgIGNvbnN0IGhleCA9IGhleF8ucmVwbGFjZSgnMHgnLCAnJyk7XG4gICAgaWYgKGhleC5sZW5ndGggPiBzaXplICogMilcbiAgICAgICAgdGhyb3cgbmV3IEhleC5TaXplRXhjZWVkc1BhZGRpbmdTaXplRXJyb3Ioe1xuICAgICAgICAgICAgc2l6ZTogTWF0aC5jZWlsKGhleC5sZW5ndGggLyAyKSxcbiAgICAgICAgICAgIHRhcmdldFNpemU6IHNpemUsXG4gICAgICAgICAgICB0eXBlOiAnSGV4JyxcbiAgICAgICAgfSk7XG4gICAgcmV0dXJuIGAweCR7aGV4W2RpciA9PT0gJ3JpZ2h0JyA/ICdwYWRFbmQnIDogJ3BhZFN0YXJ0J10oc2l6ZSAqIDIsICcwJyl9YDtcbn1cbmZ1bmN0aW9uIHRyaW0odmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgZGlyID0gJ2xlZnQnIH0gPSBvcHRpb25zO1xuICAgIGxldCBkYXRhID0gdmFsdWUucmVwbGFjZSgnMHgnLCAnJyk7XG4gICAgbGV0IHNsaWNlTGVuZ3RoID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGlmIChkYXRhW2RpciA9PT0gJ2xlZnQnID8gaSA6IGRhdGEubGVuZ3RoIC0gaSAtIDFdLnRvU3RyaW5nKCkgPT09ICcwJylcbiAgICAgICAgICAgIHNsaWNlTGVuZ3RoKys7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkYXRhID1cbiAgICAgICAgZGlyID09PSAnbGVmdCdcbiAgICAgICAgICAgID8gZGF0YS5zbGljZShzbGljZUxlbmd0aClcbiAgICAgICAgICAgIDogZGF0YS5zbGljZSgwLCBkYXRhLmxlbmd0aCAtIHNsaWNlTGVuZ3RoKTtcbiAgICBpZiAoZGF0YSA9PT0gJzAnKVxuICAgICAgICByZXR1cm4gJzB4JztcbiAgICBpZiAoZGlyID09PSAncmlnaHQnICYmIGRhdGEubGVuZ3RoICUgMiA9PT0gMSlcbiAgICAgICAgcmV0dXJuIGAweCR7ZGF0YX0wYDtcbiAgICByZXR1cm4gYDB4JHtkYXRhfWA7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZXguanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiYXNzZXJ0U2l6ZSIsImFzc2VydFN0YXJ0T2Zmc2V0IiwiYXNzZXJ0RW5kT2Zmc2V0IiwicGFkIiwidHJpbSIsIkhleCIsInJlcXVpcmUiLCJoZXgiLCJzaXplXyIsInNpemUiLCJTaXplT3ZlcmZsb3dFcnJvciIsImdpdmVuU2l6ZSIsIm1heFNpemUiLCJzdGFydCIsIlNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvciIsIm9mZnNldCIsInBvc2l0aW9uIiwiZW5kIiwiaGV4XyIsIm9wdGlvbnMiLCJkaXIiLCJyZXBsYWNlIiwibGVuZ3RoIiwiU2l6ZUV4Y2VlZHNQYWRkaW5nU2l6ZUVycm9yIiwiTWF0aCIsImNlaWwiLCJ0YXJnZXRTaXplIiwidHlwZSIsImRhdGEiLCJzbGljZUxlbmd0aCIsImkiLCJ0b1N0cmluZyIsInNsaWNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_cjs/core/internal/hex.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_cjs/core/internal/lru.js":
/*!***************************************************!*\
  !*** ./node_modules/ox/_cjs/core/internal/lru.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.LruMap = void 0;\nclass LruMap extends Map {\n    constructor(size){\n        super();\n        Object.defineProperty(this, \"maxSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.maxSize = size;\n    }\n    get(key) {\n        const value = super.get(key);\n        if (super.has(key) && value !== undefined) {\n            this.delete(key);\n            super.set(key, value);\n        }\n        return value;\n    }\n    set(key, value) {\n        super.set(key, value);\n        if (this.maxSize && this.size > this.maxSize) {\n            const firstKey = this.keys().next().value;\n            if (firstKey) this.delete(firstKey);\n        }\n        return this;\n    }\n}\nexports.LruMap = LruMap; //# sourceMappingURL=lru.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2Nqcy9jb3JlL2ludGVybmFsL2xydS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsY0FBYyxHQUFHLEtBQUs7QUFDdEIsTUFBTUUsZUFBZUM7SUFDakJDLFlBQVlDLElBQUksQ0FBRTtRQUNkLEtBQUs7UUFDTFAsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxXQUFXO1lBQ25DTyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWUCxPQUFPLEtBQUs7UUFDaEI7UUFDQSxJQUFJLENBQUNRLE9BQU8sR0FBR0o7SUFDbkI7SUFDQUssSUFBSUMsR0FBRyxFQUFFO1FBQ0wsTUFBTVYsUUFBUSxLQUFLLENBQUNTLElBQUlDO1FBQ3hCLElBQUksS0FBSyxDQUFDQyxJQUFJRCxRQUFRVixVQUFVWSxXQUFXO1lBQ3ZDLElBQUksQ0FBQ0MsTUFBTSxDQUFDSDtZQUNaLEtBQUssQ0FBQ0ksSUFBSUosS0FBS1Y7UUFDbkI7UUFDQSxPQUFPQTtJQUNYO0lBQ0FjLElBQUlKLEdBQUcsRUFBRVYsS0FBSyxFQUFFO1FBQ1osS0FBSyxDQUFDYyxJQUFJSixLQUFLVjtRQUNmLElBQUksSUFBSSxDQUFDUSxPQUFPLElBQUksSUFBSSxDQUFDSixJQUFJLEdBQUcsSUFBSSxDQUFDSSxPQUFPLEVBQUU7WUFDMUMsTUFBTU8sV0FBVyxJQUFJLENBQUNDLElBQUksR0FBR0MsSUFBSSxHQUFHakIsS0FBSztZQUN6QyxJQUFJZSxVQUNBLElBQUksQ0FBQ0YsTUFBTSxDQUFDRTtRQUNwQjtRQUNBLE9BQU8sSUFBSTtJQUNmO0FBQ0o7QUFDQWhCLGNBQWMsR0FBR0UsUUFDakIsK0JBQStCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xhdy13b3Jrcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9fY2pzL2NvcmUvaW50ZXJuYWwvbHJ1LmpzP2IyNzQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxydU1hcCA9IHZvaWQgMDtcbmNsYXNzIExydU1hcCBleHRlbmRzIE1hcCB7XG4gICAgY29uc3RydWN0b3Ioc2l6ZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXhTaXplXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWF4U2l6ZSA9IHNpemU7XG4gICAgfVxuICAgIGdldChrZXkpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBzdXBlci5nZXQoa2V5KTtcbiAgICAgICAgaWYgKHN1cGVyLmhhcyhrZXkpICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICBzdXBlci5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBzdXBlci5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIGlmICh0aGlzLm1heFNpemUgJiYgdGhpcy5zaXplID4gdGhpcy5tYXhTaXplKSB7XG4gICAgICAgICAgICBjb25zdCBmaXJzdEtleSA9IHRoaXMua2V5cygpLm5leHQoKS52YWx1ZTtcbiAgICAgICAgICAgIGlmIChmaXJzdEtleSlcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGV0ZShmaXJzdEtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuZXhwb3J0cy5McnVNYXAgPSBMcnVNYXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1scnUuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiTHJ1TWFwIiwiTWFwIiwiY29uc3RydWN0b3IiLCJzaXplIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwibWF4U2l6ZSIsImdldCIsImtleSIsImhhcyIsInVuZGVmaW5lZCIsImRlbGV0ZSIsInNldCIsImZpcnN0S2V5Iiwia2V5cyIsIm5leHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_cjs/core/internal/lru.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_cjs/core/version.js":
/*!**********************************************!*\
  !*** ./node_modules/ox/_cjs/core/version.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.version = void 0;\nexports.version = \"0.1.1\"; //# sourceMappingURL=version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2Nqcy9jb3JlL3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGVBQWUsR0FBRyxLQUFLO0FBQ3ZCQSxlQUFlLEdBQUcsU0FDbEIsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xhdy13b3Jrcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9fY2pzL2NvcmUvdmVyc2lvbi5qcz81ZTk5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52ZXJzaW9uID0gdm9pZCAwO1xuZXhwb3J0cy52ZXJzaW9uID0gJzAuMS4xJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlcnNpb24uanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwidmVyc2lvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_cjs/core/version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_cjs/erc6492/SignatureErc6492.js":
/*!**********************************************************!*\
  !*** ./node_modules/ox/_cjs/erc6492/SignatureErc6492.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.InvalidWrappedSignatureError = exports.universalSignatureValidatorAbi = exports.universalSignatureValidatorBytecode = exports.magicBytes = void 0;\nexports.assert = assert;\nexports.from = from;\nexports.unwrap = unwrap;\nexports.wrap = wrap;\nexports.validate = validate;\nconst AbiParameters = __webpack_require__(/*! ../core/AbiParameters.js */ \"(ssr)/./node_modules/ox/_cjs/core/AbiParameters.js\");\nconst Errors = __webpack_require__(/*! ../core/Errors.js */ \"(ssr)/./node_modules/ox/_cjs/core/Errors.js\");\nconst Hex = __webpack_require__(/*! ../core/Hex.js */ \"(ssr)/./node_modules/ox/_cjs/core/Hex.js\");\nexports.magicBytes = \"0x6492649264926492649264926492649264926492649264926492649264926492\";\nexports.universalSignatureValidatorBytecode = \"0x608060405234801561001057600080fd5b5060405161069438038061069483398101604081905261002f9161051e565b600061003c848484610048565b9050806000526001601ff35b60007f64926492649264926492649264926492649264926492649264926492649264926100748361040c565b036101e7576000606080848060200190518101906100929190610577565b60405192955090935091506000906001600160a01b038516906100b69085906105dd565b6000604051808303816000865af19150503d80600081146100f3576040519150601f19603f3d011682016040523d82523d6000602084013e6100f8565b606091505b50509050876001600160a01b03163b60000361016057806101605760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90610190908b9087906004016105f9565b602060405180830381865afa1580156101ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101d19190610633565b6001600160e01b03191614945050505050610405565b6001600160a01b0384163b1561027a57604051630b135d3f60e11b808252906001600160a01b03861690631626ba7e9061022790879087906004016105f9565b602060405180830381865afa158015610244573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102689190610633565b6001600160e01b031916149050610405565b81516041146102df5760405162461bcd60e51b815260206004820152603a602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e6774680000000000006064820152608401610157565b6102e7610425565b5060208201516040808401518451859392600091859190811061030c5761030c61065d565b016020015160f81c9050601b811480159061032b57508060ff16601c14155b1561038c5760405162461bcd60e51b815260206004820152603b602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c756500000000006064820152608401610157565b60408051600081526020810180835289905260ff83169181019190915260608101849052608081018390526001600160a01b0389169060019060a0016020604051602081039080840390855afa1580156103ea573d6000803e3d6000fd5b505050602060405103516001600160a01b0316149450505050505b9392505050565b600060208251101561041d57600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b038116811461045857600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561048c578181015183820152602001610474565b50506000910152565b600082601f8301126104a657600080fd5b81516001600160401b038111156104bf576104bf61045b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156104ed576104ed61045b565b60405281815283820160200185101561050557600080fd5b610516826020830160208701610471565b949350505050565b60008060006060848603121561053357600080fd5b835161053e81610443565b6020850151604086015191945092506001600160401b0381111561056157600080fd5b61056d86828701610495565b9150509250925092565b60008060006060848603121561058c57600080fd5b835161059781610443565b60208501519093506001600160401b038111156105b357600080fd5b6105bf86828701610495565b604086015190935090506001600160401b0381111561056157600080fd5b600082516105ef818460208701610471565b9190910192915050565b828152604060208201526000825180604084015261061e816060850160208701610471565b601f01601f1916919091016060019392505050565b60006020828403121561064557600080fd5b81516001600160e01b03198116811461040557600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572\";\nexports.universalSignatureValidatorAbi = [\n    {\n        inputs: [\n            {\n                name: \"_signer\",\n                type: \"address\"\n            },\n            {\n                name: \"_hash\",\n                type: \"bytes32\"\n            },\n            {\n                name: \"_signature\",\n                type: \"bytes\"\n            }\n        ],\n        stateMutability: \"nonpayable\",\n        type: \"constructor\"\n    },\n    {\n        inputs: [\n            {\n                name: \"_signer\",\n                type: \"address\"\n            },\n            {\n                name: \"_hash\",\n                type: \"bytes32\"\n            },\n            {\n                name: \"_signature\",\n                type: \"bytes\"\n            }\n        ],\n        outputs: [\n            {\n                type: \"bool\"\n            }\n        ],\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n        name: \"isValidSig\"\n    }\n];\nfunction assert(wrapped) {\n    if (Hex.slice(wrapped, -32) !== exports.magicBytes) throw new InvalidWrappedSignatureError(wrapped);\n}\nfunction from(wrapped) {\n    if (typeof wrapped === \"string\") return unwrap(wrapped);\n    return wrapped;\n}\nfunction unwrap(wrapped) {\n    assert(wrapped);\n    const [to, data, signature] = AbiParameters.decode(AbiParameters.from(\"address, bytes, bytes\"), wrapped);\n    return {\n        data,\n        signature,\n        to\n    };\n}\nfunction wrap(value) {\n    const { data, signature, to } = value;\n    return Hex.concat(AbiParameters.encode(AbiParameters.from(\"address, bytes, bytes\"), [\n        to,\n        data,\n        signature\n    ]), exports.magicBytes);\n}\nfunction validate(wrapped) {\n    try {\n        assert(wrapped);\n        return true;\n    } catch  {\n        return false;\n    }\n}\nclass InvalidWrappedSignatureError extends Errors.BaseError {\n    constructor(wrapped){\n        super(`Value \\`${wrapped}\\` is an invalid ERC-6492 wrapped signature.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"SignatureErc6492.InvalidWrappedSignatureError\"\n        });\n    }\n}\nexports.InvalidWrappedSignatureError = InvalidWrappedSignatureError; //# sourceMappingURL=SignatureErc6492.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2Nqcy9lcmM2NDkyL1NpZ25hdHVyZUVyYzY0OTIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELG9DQUFvQyxHQUFHQSxzQ0FBc0MsR0FBR0EsMkNBQTJDLEdBQUdBLGtCQUFrQixHQUFHLEtBQUs7QUFDeEpBLGNBQWMsR0FBR007QUFDakJOLFlBQVksR0FBR087QUFDZlAsY0FBYyxHQUFHUTtBQUNqQlIsWUFBWSxHQUFHUztBQUNmVCxnQkFBZ0IsR0FBR1U7QUFDbkIsTUFBTUMsZ0JBQWdCQyxtQkFBT0EsQ0FBQyxvRkFBMEI7QUFDeEQsTUFBTUMsU0FBU0QsbUJBQU9BLENBQUMsc0VBQW1CO0FBQzFDLE1BQU1FLE1BQU1GLG1CQUFPQSxDQUFDLGdFQUFnQjtBQUNwQ1osa0JBQWtCLEdBQUc7QUFDckJBLDJDQUEyQyxHQUFHO0FBQzlDQSxzQ0FBc0MsR0FBRztJQUNyQztRQUNJZSxRQUFRO1lBQ0o7Z0JBQ0lDLE1BQU07Z0JBQ05DLE1BQU07WUFDVjtZQUNBO2dCQUNJRCxNQUFNO2dCQUNOQyxNQUFNO1lBQ1Y7WUFDQTtnQkFDSUQsTUFBTTtnQkFDTkMsTUFBTTtZQUNWO1NBQ0g7UUFDREMsaUJBQWlCO1FBQ2pCRCxNQUFNO0lBQ1Y7SUFDQTtRQUNJRixRQUFRO1lBQ0o7Z0JBQ0lDLE1BQU07Z0JBQ05DLE1BQU07WUFDVjtZQUNBO2dCQUNJRCxNQUFNO2dCQUNOQyxNQUFNO1lBQ1Y7WUFDQTtnQkFDSUQsTUFBTTtnQkFDTkMsTUFBTTtZQUNWO1NBQ0g7UUFDREUsU0FBUztZQUNMO2dCQUNJRixNQUFNO1lBQ1Y7U0FDSDtRQUNEQyxpQkFBaUI7UUFDakJELE1BQU07UUFDTkQsTUFBTTtJQUNWO0NBQ0g7QUFDRCxTQUFTVixPQUFPYyxPQUFPO0lBQ25CLElBQUlOLElBQUlPLEtBQUssQ0FBQ0QsU0FBUyxDQUFDLFFBQVFwQixRQUFRSyxVQUFVLEVBQzlDLE1BQU0sSUFBSUgsNkJBQTZCa0I7QUFDL0M7QUFDQSxTQUFTYixLQUFLYSxPQUFPO0lBQ2pCLElBQUksT0FBT0EsWUFBWSxVQUNuQixPQUFPWixPQUFPWTtJQUNsQixPQUFPQTtBQUNYO0FBQ0EsU0FBU1osT0FBT1ksT0FBTztJQUNuQmQsT0FBT2M7SUFDUCxNQUFNLENBQUNFLElBQUlDLE1BQU1DLFVBQVUsR0FBR2IsY0FBY2MsTUFBTSxDQUFDZCxjQUFjSixJQUFJLENBQUMsMEJBQTBCYTtJQUNoRyxPQUFPO1FBQUVHO1FBQU1DO1FBQVdGO0lBQUc7QUFDakM7QUFDQSxTQUFTYixLQUFLUixLQUFLO0lBQ2YsTUFBTSxFQUFFc0IsSUFBSSxFQUFFQyxTQUFTLEVBQUVGLEVBQUUsRUFBRSxHQUFHckI7SUFDaEMsT0FBT2EsSUFBSVksTUFBTSxDQUFDZixjQUFjZ0IsTUFBTSxDQUFDaEIsY0FBY0osSUFBSSxDQUFDLDBCQUEwQjtRQUNoRmU7UUFDQUM7UUFDQUM7S0FDSCxHQUFHeEIsUUFBUUssVUFBVTtBQUMxQjtBQUNBLFNBQVNLLFNBQVNVLE9BQU87SUFDckIsSUFBSTtRQUNBZCxPQUFPYztRQUNQLE9BQU87SUFDWCxFQUNBLE9BQU07UUFDRixPQUFPO0lBQ1g7QUFDSjtBQUNBLE1BQU1sQixxQ0FBcUNXLE9BQU9lLFNBQVM7SUFDdkRDLFlBQVlULE9BQU8sQ0FBRTtRQUNqQixLQUFLLENBQUMsQ0FBQyxRQUFRLEVBQUVBLFFBQVEsNENBQTRDLENBQUM7UUFDdEV0QixPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLFFBQVE7WUFDaEMrQixZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWL0IsT0FBTztRQUNYO0lBQ0o7QUFDSjtBQUNBRCxvQ0FBb0MsR0FBR0UsOEJBQ3ZDLDRDQUE0QyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsYXctd29ya3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3gvX2Nqcy9lcmM2NDkyL1NpZ25hdHVyZUVyYzY0OTIuanM/MTU0MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSW52YWxpZFdyYXBwZWRTaWduYXR1cmVFcnJvciA9IGV4cG9ydHMudW5pdmVyc2FsU2lnbmF0dXJlVmFsaWRhdG9yQWJpID0gZXhwb3J0cy51bml2ZXJzYWxTaWduYXR1cmVWYWxpZGF0b3JCeXRlY29kZSA9IGV4cG9ydHMubWFnaWNCeXRlcyA9IHZvaWQgMDtcbmV4cG9ydHMuYXNzZXJ0ID0gYXNzZXJ0O1xuZXhwb3J0cy5mcm9tID0gZnJvbTtcbmV4cG9ydHMudW53cmFwID0gdW53cmFwO1xuZXhwb3J0cy53cmFwID0gd3JhcDtcbmV4cG9ydHMudmFsaWRhdGUgPSB2YWxpZGF0ZTtcbmNvbnN0IEFiaVBhcmFtZXRlcnMgPSByZXF1aXJlKFwiLi4vY29yZS9BYmlQYXJhbWV0ZXJzLmpzXCIpO1xuY29uc3QgRXJyb3JzID0gcmVxdWlyZShcIi4uL2NvcmUvRXJyb3JzLmpzXCIpO1xuY29uc3QgSGV4ID0gcmVxdWlyZShcIi4uL2NvcmUvSGV4LmpzXCIpO1xuZXhwb3J0cy5tYWdpY0J5dGVzID0gJzB4NjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5Mic7XG5leHBvcnRzLnVuaXZlcnNhbFNpZ25hdHVyZVZhbGlkYXRvckJ5dGVjb2RlID0gJzB4NjA4MDYwNDA1MjM0ODAxNTYxMDAxMDU3NjAwMDgwZmQ1YjUwNjA0MDUxNjEwNjk0MzgwMzgwNjEwNjk0ODMzOTgxMDE2MDQwODE5MDUyNjEwMDJmOTE2MTA1MWU1NjViNjAwMDYxMDAzYzg0ODQ4NDYxMDA0ODU2NWI5MDUwODA2MDAwNTI2MDAxNjAxZmYzNWI2MDAwN2Y2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjEwMDc0ODM2MTA0MGM1NjViMDM2MTAxZTc1NzYwMDA2MDYwODA4NDgwNjAyMDAxOTA1MTgxMDE5MDYxMDA5MjkxOTA2MTA1Nzc1NjViNjA0MDUxOTI5NTUwOTA5MzUwOTE1MDYwMDA5MDYwMDE2MDAxNjBhMDFiMDM4NTE2OTA2MTAwYjY5MDg1OTA2MTA1ZGQ1NjViNjAwMDYwNDA1MTgwODMwMzgxNjAwMDg2NWFmMTkxNTA1MDNkODA2MDAwODExNDYxMDBmMzU3NjA0MDUxOTE1MDYwMWYxOTYwM2YzZDAxMTY4MjAxNjA0MDUyM2Q4MjUyM2Q2MDAwNjAyMDg0MDEzZTYxMDBmODU2NWI2MDYwOTE1MDViNTA1MDkwNTA4NzYwMDE2MDAxNjBhMDFiMDMxNjNiNjAwMDAzNjEwMTYwNTc4MDYxMDE2MDU3NjA0MDUxNjI0NjFiY2Q2MGU1MWI4MTUyNjAyMDYwMDQ4MjAxNTI2MDFlNjAyNDgyMDE1MjdmNTM2OTY3NmU2MTc0NzU3MjY1NTY2MTZjNjk2NDYxNzQ2ZjcyM2EyMDY0NjU3MDZjNmY3OTZkNjU2ZTc0MDAwMDYwNDQ4MjAxNTI2MDY0MDE1YjYwNDA1MTgwOTEwMzkwZmQ1YjYwNDA1MTYzMGIxMzVkM2Y2MGUxMWI4MDgyNTI5MDYwMDE2MDAxNjBhMDFiMDM4YTE2OTA2MzE2MjZiYTdlOTA2MTAxOTA5MDhiOTA4NzkwNjAwNDAxNjEwNWY5NTY1YjYwMjA2MDQwNTE4MDgzMDM4MTg2NWFmYTE1ODAxNTYxMDFhZDU3M2Q2MDAwODAzZTNkNjAwMGZkNWI1MDUwNTA1MDYwNDA1MTNkNjAxZjE5NjAxZjgyMDExNjgyMDE4MDYwNDA1MjUwODEwMTkwNjEwMWQxOTE5MDYxMDYzMzU2NWI2MDAxNjAwMTYwZTAxYjAzMTkxNjE0OTQ1MDUwNTA1MDUwNjEwNDA1NTY1YjYwMDE2MDAxNjBhMDFiMDM4NDE2M2IxNTYxMDI3YTU3NjA0MDUxNjMwYjEzNWQzZjYwZTExYjgwODI1MjkwNjAwMTYwMDE2MGEwMWIwMzg2MTY5MDYzMTYyNmJhN2U5MDYxMDIyNzkwODc5MDg3OTA2MDA0MDE2MTA1Zjk1NjViNjAyMDYwNDA1MTgwODMwMzgxODY1YWZhMTU4MDE1NjEwMjQ0NTczZDYwMDA4MDNlM2Q2MDAwZmQ1YjUwNTA1MDUwNjA0MDUxM2Q2MDFmMTk2MDFmODIwMTE2ODIwMTgwNjA0MDUyNTA4MTAxOTA2MTAyNjg5MTkwNjEwNjMzNTY1YjYwMDE2MDAxNjBlMDFiMDMxOTE2MTQ5MDUwNjEwNDA1NTY1YjgxNTE2MDQxMTQ2MTAyZGY1NzYwNDA1MTYyNDYxYmNkNjBlNTFiODE1MjYwMjA2MDA0ODIwMTUyNjAzYTYwMjQ4MjAxNTI2MDAwODA1MTYwMjA2MTA2NzQ4MzM5ODE1MTkxNTI2MDQ0ODIwMTUyN2YzYTIwNjk2ZTc2NjE2YzY5NjQyMDczNjk2NzZlNjE3NDc1NzI2NTIwNmM2NTZlNjc3NDY4MDAwMDAwMDAwMDAwNjA2NDgyMDE1MjYwODQwMTYxMDE1NzU2NWI2MTAyZTc2MTA0MjU1NjViNTA2MDIwODIwMTUxNjA0MDgwODQwMTUxODQ1MTg1OTM5MjYwMDA5MTg1OTE5MDgxMTA2MTAzMGM1NzYxMDMwYzYxMDY1ZDU2NWIwMTYwMjAwMTUxNjBmODFjOTA1MDYwMWI4MTE0ODAxNTkwNjEwMzJiNTc1MDgwNjBmZjE2NjAxYzE0MTU1YjE1NjEwMzhjNTc2MDQwNTE2MjQ2MWJjZDYwZTUxYjgxNTI2MDIwNjAwNDgyMDE1MjYwM2I2MDI0ODIwMTUyNjAwMDgwNTE2MDIwNjEwNjc0ODMzOTgxNTE5MTUyNjA0NDgyMDE1MjdmM2EyMDY5NmU3NjYxNmM2OTY0MjA3MzY5Njc2ZTYxNzQ3NTcyNjUyMDc2MjA3NjYxNmM3NTY1MDAwMDAwMDAwMDYwNjQ4MjAxNTI2MDg0MDE2MTAxNTc1NjViNjA0MDgwNTE2MDAwODE1MjYwMjA4MTAxODA4MzUyODk5MDUyNjBmZjgzMTY5MTgxMDE5MTkwOTE1MjYwNjA4MTAxODQ5MDUyNjA4MDgxMDE4MzkwNTI2MDAxNjAwMTYwYTAxYjAzODkxNjkwNjAwMTkwNjBhMDAxNjAyMDYwNDA1MTYwMjA4MTAzOTA4MDg0MDM5MDg1NWFmYTE1ODAxNTYxMDNlYTU3M2Q2MDAwODAzZTNkNjAwMGZkNWI1MDUwNTA2MDIwNjA0MDUxMDM1MTYwMDE2MDAxNjBhMDFiMDMxNjE0OTQ1MDUwNTA1MDUwNWI5MzkyNTA1MDUwNTY1YjYwMDA2MDIwODI1MTEwMTU2MTA0MWQ1NzYwMDA4MGZkNWI1MDgwNTEwMTUxOTA1NjViNjA0MDUxODA2MDYwMDE2MDQwNTI4MDYwMDM5MDYwMjA4MjAyODAzNjgzMzc1MDkxOTI5MTUwNTA1NjViNjAwMTYwMDE2MGEwMWIwMzgxMTY4MTE0NjEwNDU4NTc2MDAwODBmZDViNTA1NjViNjM0ZTQ4N2I3MTYwZTAxYjYwMDA1MjYwNDE2MDA0NTI2MDI0NjAwMGZkNWI2MDAwNWI4MzgxMTAxNTYxMDQ4YzU3ODE4MTAxNTE4MzgyMDE1MjYwMjAwMTYxMDQ3NDU2NWI1MDUwNjAwMDkxMDE1MjU2NWI2MDAwODI2MDFmODMwMTEyNjEwNGE2NTc2MDAwODBmZDViODE1MTYwMDE2MDAxNjA0MDFiMDM4MTExMTU2MTA0YmY1NzYxMDRiZjYxMDQ1YjU2NWI2MDQwNTE2MDFmODIwMTYwMWYxOTkwODExNjYwM2YwMTE2ODEwMTYwMDE2MDAxNjA0MDFiMDM4MTExODI4MjEwMTcxNTYxMDRlZDU3NjEwNGVkNjEwNDViNTY1YjYwNDA1MjgxODE1MjgzODIwMTYwMjAwMTg1MTAxNTYxMDUwNTU3NjAwMDgwZmQ1YjYxMDUxNjgyNjAyMDgzMDE2MDIwODcwMTYxMDQ3MTU2NWI5NDkzNTA1MDUwNTA1NjViNjAwMDgwNjAwMDYwNjA4NDg2MDMxMjE1NjEwNTMzNTc2MDAwODBmZDViODM1MTYxMDUzZTgxNjEwNDQzNTY1YjYwMjA4NTAxNTE2MDQwODYwMTUxOTE5NDUwOTI1MDYwMDE2MDAxNjA0MDFiMDM4MTExMTU2MTA1NjE1NzYwMDA4MGZkNWI2MTA1NmQ4NjgyODcwMTYxMDQ5NTU2NWI5MTUwNTA5MjUwOTI1MDkyNTY1YjYwMDA4MDYwMDA2MDYwODQ4NjAzMTIxNTYxMDU4YzU3NjAwMDgwZmQ1YjgzNTE2MTA1OTc4MTYxMDQ0MzU2NWI2MDIwODUwMTUxOTA5MzUwNjAwMTYwMDE2MDQwMWIwMzgxMTExNTYxMDViMzU3NjAwMDgwZmQ1YjYxMDViZjg2ODI4NzAxNjEwNDk1NTY1YjYwNDA4NjAxNTE5MDkzNTA5MDUwNjAwMTYwMDE2MDQwMWIwMzgxMTExNTYxMDU2MTU3NjAwMDgwZmQ1YjYwMDA4MjUxNjEwNWVmODE4NDYwMjA4NzAxNjEwNDcxNTY1YjkxOTA5MTAxOTI5MTUwNTA1NjViODI4MTUyNjA0MDYwMjA4MjAxNTI2MDAwODI1MTgwNjA0MDg0MDE1MjYxMDYxZTgxNjA2MDg1MDE2MDIwODcwMTYxMDQ3MTU2NWI2MDFmMDE2MDFmMTkxNjkxOTA5MTAxNjA2MDAxOTM5MjUwNTA1MDU2NWI2MDAwNjAyMDgyODQwMzEyMTU2MTA2NDU1NzYwMDA4MGZkNWI4MTUxNjAwMTYwMDE2MGUwMWIwMzE5ODExNjgxMTQ2MTA0MDU1NzYwMDA4MGZkNWI2MzRlNDg3YjcxNjBlMDFiNjAwMDUyNjAzMjYwMDQ1MjYwMjQ2MDAwZmRmZTUzNjk2NzZlNjE3NDc1NzI2NTU2NjE2YzY5NjQ2MTc0NmY3MjIzNzI2NTYzNmY3NjY1NzI1MzY5Njc2ZTY1NzInO1xuZXhwb3J0cy51bml2ZXJzYWxTaWduYXR1cmVWYWxpZGF0b3JBYmkgPSBbXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnX3NpZ25lcicsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnX2hhc2gnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdieXRlczMyJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ19zaWduYXR1cmUnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdieXRlcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6ICdub25wYXlhYmxlJyxcbiAgICAgICAgdHlwZTogJ2NvbnN0cnVjdG9yJyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ19zaWduZXInLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ19oYXNoJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYnl0ZXMzMicsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdfc2lnbmF0dXJlJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYnl0ZXMnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgb3V0cHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdib29sJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogJ25vbnBheWFibGUnLFxuICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgICAgICBuYW1lOiAnaXNWYWxpZFNpZycsXG4gICAgfSxcbl07XG5mdW5jdGlvbiBhc3NlcnQod3JhcHBlZCkge1xuICAgIGlmIChIZXguc2xpY2Uod3JhcHBlZCwgLTMyKSAhPT0gZXhwb3J0cy5tYWdpY0J5dGVzKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFdyYXBwZWRTaWduYXR1cmVFcnJvcih3cmFwcGVkKTtcbn1cbmZ1bmN0aW9uIGZyb20od3JhcHBlZCkge1xuICAgIGlmICh0eXBlb2Ygd3JhcHBlZCA9PT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiB1bndyYXAod3JhcHBlZCk7XG4gICAgcmV0dXJuIHdyYXBwZWQ7XG59XG5mdW5jdGlvbiB1bndyYXAod3JhcHBlZCkge1xuICAgIGFzc2VydCh3cmFwcGVkKTtcbiAgICBjb25zdCBbdG8sIGRhdGEsIHNpZ25hdHVyZV0gPSBBYmlQYXJhbWV0ZXJzLmRlY29kZShBYmlQYXJhbWV0ZXJzLmZyb20oJ2FkZHJlc3MsIGJ5dGVzLCBieXRlcycpLCB3cmFwcGVkKTtcbiAgICByZXR1cm4geyBkYXRhLCBzaWduYXR1cmUsIHRvIH07XG59XG5mdW5jdGlvbiB3cmFwKHZhbHVlKSB7XG4gICAgY29uc3QgeyBkYXRhLCBzaWduYXR1cmUsIHRvIH0gPSB2YWx1ZTtcbiAgICByZXR1cm4gSGV4LmNvbmNhdChBYmlQYXJhbWV0ZXJzLmVuY29kZShBYmlQYXJhbWV0ZXJzLmZyb20oJ2FkZHJlc3MsIGJ5dGVzLCBieXRlcycpLCBbXG4gICAgICAgIHRvLFxuICAgICAgICBkYXRhLFxuICAgICAgICBzaWduYXR1cmUsXG4gICAgXSksIGV4cG9ydHMubWFnaWNCeXRlcyk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZSh3cmFwcGVkKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgYXNzZXJ0KHdyYXBwZWQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuY2xhc3MgSW52YWxpZFdyYXBwZWRTaWduYXR1cmVFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHdyYXBwZWQpIHtcbiAgICAgICAgc3VwZXIoYFZhbHVlIFxcYCR7d3JhcHBlZH1cXGAgaXMgYW4gaW52YWxpZCBFUkMtNjQ5MiB3cmFwcGVkIHNpZ25hdHVyZS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1NpZ25hdHVyZUVyYzY0OTIuSW52YWxpZFdyYXBwZWRTaWduYXR1cmVFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5JbnZhbGlkV3JhcHBlZFNpZ25hdHVyZUVycm9yID0gSW52YWxpZFdyYXBwZWRTaWduYXR1cmVFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNpZ25hdHVyZUVyYzY0OTIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiSW52YWxpZFdyYXBwZWRTaWduYXR1cmVFcnJvciIsInVuaXZlcnNhbFNpZ25hdHVyZVZhbGlkYXRvckFiaSIsInVuaXZlcnNhbFNpZ25hdHVyZVZhbGlkYXRvckJ5dGVjb2RlIiwibWFnaWNCeXRlcyIsImFzc2VydCIsImZyb20iLCJ1bndyYXAiLCJ3cmFwIiwidmFsaWRhdGUiLCJBYmlQYXJhbWV0ZXJzIiwicmVxdWlyZSIsIkVycm9ycyIsIkhleCIsImlucHV0cyIsIm5hbWUiLCJ0eXBlIiwic3RhdGVNdXRhYmlsaXR5Iiwib3V0cHV0cyIsIndyYXBwZWQiLCJzbGljZSIsInRvIiwiZGF0YSIsInNpZ25hdHVyZSIsImRlY29kZSIsImNvbmNhdCIsImVuY29kZSIsIkJhc2VFcnJvciIsImNvbnN0cnVjdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_cjs/erc6492/SignatureErc6492.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_cjs/erc6492/index.js":
/*!***********************************************!*\
  !*** ./node_modules/ox/_cjs/erc6492/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.SignatureErc6492 = void 0;\nexports.SignatureErc6492 = __webpack_require__(/*! ./SignatureErc6492.js */ \"(ssr)/./node_modules/ox/_cjs/erc6492/SignatureErc6492.js\"); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2Nqcy9lcmM2NDkyL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCx3QkFBd0IsR0FBRyxLQUFLO0FBQ2hDQSx1SUFBMkQsRUFDM0QsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xhdy13b3Jrcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9fY2pzL2VyYzY0OTIvaW5kZXguanM/MWUxOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2lnbmF0dXJlRXJjNjQ5MiA9IHZvaWQgMDtcbmV4cG9ydHMuU2lnbmF0dXJlRXJjNjQ5MiA9IHJlcXVpcmUoXCIuL1NpZ25hdHVyZUVyYzY0OTIuanNcIik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJTaWduYXR1cmVFcmM2NDkyIiwicmVxdWlyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_cjs/erc6492/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_cjs/erc8010/SignatureErc8010.js":
/*!**********************************************************!*\
  !*** ./node_modules/ox/_cjs/erc8010/SignatureErc8010.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.InvalidWrappedSignatureError = exports.suffixParameters = exports.magicBytes = void 0;\nexports.assert = assert;\nexports.from = from;\nexports.unwrap = unwrap;\nexports.wrap = wrap;\nexports.validate = validate;\nconst AbiParameters = __webpack_require__(/*! ../core/AbiParameters.js */ \"(ssr)/./node_modules/ox/_cjs/core/AbiParameters.js\");\nconst Authorization = __webpack_require__(/*! ../core/Authorization.js */ \"(ssr)/./node_modules/ox/_cjs/core/Authorization.js\");\nconst Errors = __webpack_require__(/*! ../core/Errors.js */ \"(ssr)/./node_modules/ox/_cjs/core/Errors.js\");\nconst Hex = __webpack_require__(/*! ../core/Hex.js */ \"(ssr)/./node_modules/ox/_cjs/core/Hex.js\");\nconst Secp256k1 = __webpack_require__(/*! ../core/Secp256k1.js */ \"(ssr)/./node_modules/ox/_cjs/core/Secp256k1.js\");\nconst Signature = __webpack_require__(/*! ../core/Signature.js */ \"(ssr)/./node_modules/ox/_cjs/core/Signature.js\");\nexports.magicBytes = \"0x8010801080108010801080108010801080108010801080108010801080108010\";\nexports.suffixParameters = AbiParameters.from(\"(uint256 chainId, address delegation, uint256 nonce, uint8 yParity, uint256 r, uint256 s), address to, bytes data\");\nfunction assert(value) {\n    if (typeof value === \"string\") {\n        if (Hex.slice(value, -32) !== exports.magicBytes) throw new InvalidWrappedSignatureError(value);\n    } else Signature.assert(value.authorization);\n}\nfunction from(value) {\n    if (typeof value === \"string\") return unwrap(value);\n    return value;\n}\nfunction unwrap(wrapped) {\n    assert(wrapped);\n    const suffixLength = Hex.toNumber(Hex.slice(wrapped, -64, -32));\n    const suffix = Hex.slice(wrapped, -suffixLength - 64, -64);\n    const signature = Hex.slice(wrapped, 0, -suffixLength - 64);\n    const [auth, to, data] = AbiParameters.decode(exports.suffixParameters, suffix);\n    const authorization = Authorization.from({\n        address: auth.delegation,\n        chainId: Number(auth.chainId),\n        nonce: auth.nonce,\n        yParity: auth.yParity,\n        r: auth.r,\n        s: auth.s\n    });\n    return {\n        authorization,\n        signature,\n        ...data && data !== \"0x\" ? {\n            data,\n            to\n        } : {}\n    };\n}\nfunction wrap(value) {\n    const { data, signature } = value;\n    assert(value);\n    const self = Secp256k1.recoverAddress({\n        payload: Authorization.getSignPayload(value.authorization),\n        signature: Signature.from(value.authorization)\n    });\n    const suffix = AbiParameters.encode(exports.suffixParameters, [\n        {\n            ...value.authorization,\n            delegation: value.authorization.address,\n            chainId: BigInt(value.authorization.chainId)\n        },\n        value.to ?? self,\n        data ?? \"0x\"\n    ]);\n    const suffixLength = Hex.fromNumber(Hex.size(suffix), {\n        size: 32\n    });\n    return Hex.concat(signature, suffix, suffixLength, exports.magicBytes);\n}\nfunction validate(value) {\n    try {\n        assert(value);\n        return true;\n    } catch  {\n        return false;\n    }\n}\nclass InvalidWrappedSignatureError extends Errors.BaseError {\n    constructor(wrapped){\n        super(`Value \\`${wrapped}\\` is an invalid ERC-8010 wrapped signature.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"SignatureErc8010.InvalidWrappedSignatureError\"\n        });\n    }\n}\nexports.InvalidWrappedSignatureError = InvalidWrappedSignatureError; //# sourceMappingURL=SignatureErc8010.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2Nqcy9lcmM4MDEwL1NpZ25hdHVyZUVyYzgwMTAuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELG9DQUFvQyxHQUFHQSx3QkFBd0IsR0FBR0Esa0JBQWtCLEdBQUcsS0FBSztBQUM1RkEsY0FBYyxHQUFHSztBQUNqQkwsWUFBWSxHQUFHTTtBQUNmTixjQUFjLEdBQUdPO0FBQ2pCUCxZQUFZLEdBQUdRO0FBQ2ZSLGdCQUFnQixHQUFHUztBQUNuQixNQUFNQyxnQkFBZ0JDLG1CQUFPQSxDQUFDLG9GQUEwQjtBQUN4RCxNQUFNQyxnQkFBZ0JELG1CQUFPQSxDQUFDLG9GQUEwQjtBQUN4RCxNQUFNRSxTQUFTRixtQkFBT0EsQ0FBQyxzRUFBbUI7QUFDMUMsTUFBTUcsTUFBTUgsbUJBQU9BLENBQUMsZ0VBQWdCO0FBQ3BDLE1BQU1JLFlBQVlKLG1CQUFPQSxDQUFDLDRFQUFzQjtBQUNoRCxNQUFNSyxZQUFZTCxtQkFBT0EsQ0FBQyw0RUFBc0I7QUFDaERYLGtCQUFrQixHQUFHO0FBQ3JCQSx3QkFBd0IsR0FBR1UsY0FBY0osSUFBSSxDQUFDO0FBQzlDLFNBQVNELE9BQU9KLEtBQUs7SUFDakIsSUFBSSxPQUFPQSxVQUFVLFVBQVU7UUFDM0IsSUFBSWEsSUFBSUcsS0FBSyxDQUFDaEIsT0FBTyxDQUFDLFFBQVFELFFBQVFJLFVBQVUsRUFDNUMsTUFBTSxJQUFJRiw2QkFBNkJEO0lBQy9DLE9BRUllLFVBQVVYLE1BQU0sQ0FBQ0osTUFBTWlCLGFBQWE7QUFDNUM7QUFDQSxTQUFTWixLQUFLTCxLQUFLO0lBQ2YsSUFBSSxPQUFPQSxVQUFVLFVBQ2pCLE9BQU9NLE9BQU9OO0lBQ2xCLE9BQU9BO0FBQ1g7QUFDQSxTQUFTTSxPQUFPWSxPQUFPO0lBQ25CZCxPQUFPYztJQUNQLE1BQU1DLGVBQWVOLElBQUlPLFFBQVEsQ0FBQ1AsSUFBSUcsS0FBSyxDQUFDRSxTQUFTLENBQUMsSUFBSSxDQUFDO0lBQzNELE1BQU1HLFNBQVNSLElBQUlHLEtBQUssQ0FBQ0UsU0FBUyxDQUFDQyxlQUFlLElBQUksQ0FBQztJQUN2RCxNQUFNRyxZQUFZVCxJQUFJRyxLQUFLLENBQUNFLFNBQVMsR0FBRyxDQUFDQyxlQUFlO0lBQ3hELE1BQU0sQ0FBQ0ksTUFBTUMsSUFBSUMsS0FBSyxHQUFHaEIsY0FBY2lCLE1BQU0sQ0FBQzNCLFFBQVFHLGdCQUFnQixFQUFFbUI7SUFDeEUsTUFBTUosZ0JBQWdCTixjQUFjTixJQUFJLENBQUM7UUFDckNzQixTQUFTSixLQUFLSyxVQUFVO1FBQ3hCQyxTQUFTQyxPQUFPUCxLQUFLTSxPQUFPO1FBQzVCRSxPQUFPUixLQUFLUSxLQUFLO1FBQ2pCQyxTQUFTVCxLQUFLUyxPQUFPO1FBQ3JCQyxHQUFHVixLQUFLVSxDQUFDO1FBQ1RDLEdBQUdYLEtBQUtXLENBQUM7SUFDYjtJQUNBLE9BQU87UUFDSGpCO1FBQ0FLO1FBQ0EsR0FBSUcsUUFBUUEsU0FBUyxPQUFPO1lBQUVBO1lBQU1EO1FBQUcsSUFBSSxDQUFDLENBQUM7SUFDakQ7QUFDSjtBQUNBLFNBQVNqQixLQUFLUCxLQUFLO0lBQ2YsTUFBTSxFQUFFeUIsSUFBSSxFQUFFSCxTQUFTLEVBQUUsR0FBR3RCO0lBQzVCSSxPQUFPSjtJQUNQLE1BQU1tQyxPQUFPckIsVUFBVXNCLGNBQWMsQ0FBQztRQUNsQ0MsU0FBUzFCLGNBQWMyQixjQUFjLENBQUN0QyxNQUFNaUIsYUFBYTtRQUN6REssV0FBV1AsVUFBVVYsSUFBSSxDQUFDTCxNQUFNaUIsYUFBYTtJQUNqRDtJQUNBLE1BQU1JLFNBQVNaLGNBQWM4QixNQUFNLENBQUN4QyxRQUFRRyxnQkFBZ0IsRUFBRTtRQUMxRDtZQUNJLEdBQUdGLE1BQU1pQixhQUFhO1lBQ3RCVyxZQUFZNUIsTUFBTWlCLGFBQWEsQ0FBQ1UsT0FBTztZQUN2Q0UsU0FBU1csT0FBT3hDLE1BQU1pQixhQUFhLENBQUNZLE9BQU87UUFDL0M7UUFDQTdCLE1BQU13QixFQUFFLElBQUlXO1FBQ1pWLFFBQVE7S0FDWDtJQUNELE1BQU1OLGVBQWVOLElBQUk0QixVQUFVLENBQUM1QixJQUFJNkIsSUFBSSxDQUFDckIsU0FBUztRQUFFcUIsTUFBTTtJQUFHO0lBQ2pFLE9BQU83QixJQUFJOEIsTUFBTSxDQUFDckIsV0FBV0QsUUFBUUYsY0FBY3BCLFFBQVFJLFVBQVU7QUFDekU7QUFDQSxTQUFTSyxTQUFTUixLQUFLO0lBQ25CLElBQUk7UUFDQUksT0FBT0o7UUFDUCxPQUFPO0lBQ1gsRUFDQSxPQUFNO1FBQ0YsT0FBTztJQUNYO0FBQ0o7QUFDQSxNQUFNQyxxQ0FBcUNXLE9BQU9nQyxTQUFTO0lBQ3ZEQyxZQUFZM0IsT0FBTyxDQUFFO1FBQ2pCLEtBQUssQ0FBQyxDQUFDLFFBQVEsRUFBRUEsUUFBUSw0Q0FBNEMsQ0FBQztRQUN0RXJCLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsUUFBUTtZQUNoQ2dELFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZoRCxPQUFPO1FBQ1g7SUFDSjtBQUNKO0FBQ0FELG9DQUFvQyxHQUFHRSw4QkFDdkMsNENBQTRDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xhdy13b3Jrcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9fY2pzL2VyYzgwMTAvU2lnbmF0dXJlRXJjODAxMC5qcz81MDk0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JbnZhbGlkV3JhcHBlZFNpZ25hdHVyZUVycm9yID0gZXhwb3J0cy5zdWZmaXhQYXJhbWV0ZXJzID0gZXhwb3J0cy5tYWdpY0J5dGVzID0gdm9pZCAwO1xuZXhwb3J0cy5hc3NlcnQgPSBhc3NlcnQ7XG5leHBvcnRzLmZyb20gPSBmcm9tO1xuZXhwb3J0cy51bndyYXAgPSB1bndyYXA7XG5leHBvcnRzLndyYXAgPSB3cmFwO1xuZXhwb3J0cy52YWxpZGF0ZSA9IHZhbGlkYXRlO1xuY29uc3QgQWJpUGFyYW1ldGVycyA9IHJlcXVpcmUoXCIuLi9jb3JlL0FiaVBhcmFtZXRlcnMuanNcIik7XG5jb25zdCBBdXRob3JpemF0aW9uID0gcmVxdWlyZShcIi4uL2NvcmUvQXV0aG9yaXphdGlvbi5qc1wiKTtcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoXCIuLi9jb3JlL0Vycm9ycy5qc1wiKTtcbmNvbnN0IEhleCA9IHJlcXVpcmUoXCIuLi9jb3JlL0hleC5qc1wiKTtcbmNvbnN0IFNlY3AyNTZrMSA9IHJlcXVpcmUoXCIuLi9jb3JlL1NlY3AyNTZrMS5qc1wiKTtcbmNvbnN0IFNpZ25hdHVyZSA9IHJlcXVpcmUoXCIuLi9jb3JlL1NpZ25hdHVyZS5qc1wiKTtcbmV4cG9ydHMubWFnaWNCeXRlcyA9ICcweDgwMTA4MDEwODAxMDgwMTA4MDEwODAxMDgwMTA4MDEwODAxMDgwMTA4MDEwODAxMDgwMTA4MDEwODAxMDgwMTAnO1xuZXhwb3J0cy5zdWZmaXhQYXJhbWV0ZXJzID0gQWJpUGFyYW1ldGVycy5mcm9tKCcodWludDI1NiBjaGFpbklkLCBhZGRyZXNzIGRlbGVnYXRpb24sIHVpbnQyNTYgbm9uY2UsIHVpbnQ4IHlQYXJpdHksIHVpbnQyNTYgciwgdWludDI1NiBzKSwgYWRkcmVzcyB0bywgYnl0ZXMgZGF0YScpO1xuZnVuY3Rpb24gYXNzZXJ0KHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKEhleC5zbGljZSh2YWx1ZSwgLTMyKSAhPT0gZXhwb3J0cy5tYWdpY0J5dGVzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRXcmFwcGVkU2lnbmF0dXJlRXJyb3IodmFsdWUpO1xuICAgIH1cbiAgICBlbHNlXG4gICAgICAgIFNpZ25hdHVyZS5hc3NlcnQodmFsdWUuYXV0aG9yaXphdGlvbik7XG59XG5mdW5jdGlvbiBmcm9tKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiB1bndyYXAodmFsdWUpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHVud3JhcCh3cmFwcGVkKSB7XG4gICAgYXNzZXJ0KHdyYXBwZWQpO1xuICAgIGNvbnN0IHN1ZmZpeExlbmd0aCA9IEhleC50b051bWJlcihIZXguc2xpY2Uod3JhcHBlZCwgLTY0LCAtMzIpKTtcbiAgICBjb25zdCBzdWZmaXggPSBIZXguc2xpY2Uod3JhcHBlZCwgLXN1ZmZpeExlbmd0aCAtIDY0LCAtNjQpO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IEhleC5zbGljZSh3cmFwcGVkLCAwLCAtc3VmZml4TGVuZ3RoIC0gNjQpO1xuICAgIGNvbnN0IFthdXRoLCB0bywgZGF0YV0gPSBBYmlQYXJhbWV0ZXJzLmRlY29kZShleHBvcnRzLnN1ZmZpeFBhcmFtZXRlcnMsIHN1ZmZpeCk7XG4gICAgY29uc3QgYXV0aG9yaXphdGlvbiA9IEF1dGhvcml6YXRpb24uZnJvbSh7XG4gICAgICAgIGFkZHJlc3M6IGF1dGguZGVsZWdhdGlvbixcbiAgICAgICAgY2hhaW5JZDogTnVtYmVyKGF1dGguY2hhaW5JZCksXG4gICAgICAgIG5vbmNlOiBhdXRoLm5vbmNlLFxuICAgICAgICB5UGFyaXR5OiBhdXRoLnlQYXJpdHksXG4gICAgICAgIHI6IGF1dGgucixcbiAgICAgICAgczogYXV0aC5zLFxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGF1dGhvcml6YXRpb24sXG4gICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgLi4uKGRhdGEgJiYgZGF0YSAhPT0gJzB4JyA/IHsgZGF0YSwgdG8gfSA6IHt9KSxcbiAgICB9O1xufVxuZnVuY3Rpb24gd3JhcCh2YWx1ZSkge1xuICAgIGNvbnN0IHsgZGF0YSwgc2lnbmF0dXJlIH0gPSB2YWx1ZTtcbiAgICBhc3NlcnQodmFsdWUpO1xuICAgIGNvbnN0IHNlbGYgPSBTZWNwMjU2azEucmVjb3ZlckFkZHJlc3Moe1xuICAgICAgICBwYXlsb2FkOiBBdXRob3JpemF0aW9uLmdldFNpZ25QYXlsb2FkKHZhbHVlLmF1dGhvcml6YXRpb24pLFxuICAgICAgICBzaWduYXR1cmU6IFNpZ25hdHVyZS5mcm9tKHZhbHVlLmF1dGhvcml6YXRpb24pLFxuICAgIH0pO1xuICAgIGNvbnN0IHN1ZmZpeCA9IEFiaVBhcmFtZXRlcnMuZW5jb2RlKGV4cG9ydHMuc3VmZml4UGFyYW1ldGVycywgW1xuICAgICAgICB7XG4gICAgICAgICAgICAuLi52YWx1ZS5hdXRob3JpemF0aW9uLFxuICAgICAgICAgICAgZGVsZWdhdGlvbjogdmFsdWUuYXV0aG9yaXphdGlvbi5hZGRyZXNzLFxuICAgICAgICAgICAgY2hhaW5JZDogQmlnSW50KHZhbHVlLmF1dGhvcml6YXRpb24uY2hhaW5JZCksXG4gICAgICAgIH0sXG4gICAgICAgIHZhbHVlLnRvID8/IHNlbGYsXG4gICAgICAgIGRhdGEgPz8gJzB4JyxcbiAgICBdKTtcbiAgICBjb25zdCBzdWZmaXhMZW5ndGggPSBIZXguZnJvbU51bWJlcihIZXguc2l6ZShzdWZmaXgpLCB7IHNpemU6IDMyIH0pO1xuICAgIHJldHVybiBIZXguY29uY2F0KHNpZ25hdHVyZSwgc3VmZml4LCBzdWZmaXhMZW5ndGgsIGV4cG9ydHMubWFnaWNCeXRlcyk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGFzc2VydCh2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5jbGFzcyBJbnZhbGlkV3JhcHBlZFNpZ25hdHVyZUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3Iod3JhcHBlZCkge1xuICAgICAgICBzdXBlcihgVmFsdWUgXFxgJHt3cmFwcGVkfVxcYCBpcyBhbiBpbnZhbGlkIEVSQy04MDEwIHdyYXBwZWQgc2lnbmF0dXJlLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnU2lnbmF0dXJlRXJjODAxMC5JbnZhbGlkV3JhcHBlZFNpZ25hdHVyZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkludmFsaWRXcmFwcGVkU2lnbmF0dXJlRXJyb3IgPSBJbnZhbGlkV3JhcHBlZFNpZ25hdHVyZUVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2lnbmF0dXJlRXJjODAxMC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJJbnZhbGlkV3JhcHBlZFNpZ25hdHVyZUVycm9yIiwic3VmZml4UGFyYW1ldGVycyIsIm1hZ2ljQnl0ZXMiLCJhc3NlcnQiLCJmcm9tIiwidW53cmFwIiwid3JhcCIsInZhbGlkYXRlIiwiQWJpUGFyYW1ldGVycyIsInJlcXVpcmUiLCJBdXRob3JpemF0aW9uIiwiRXJyb3JzIiwiSGV4IiwiU2VjcDI1NmsxIiwiU2lnbmF0dXJlIiwic2xpY2UiLCJhdXRob3JpemF0aW9uIiwid3JhcHBlZCIsInN1ZmZpeExlbmd0aCIsInRvTnVtYmVyIiwic3VmZml4Iiwic2lnbmF0dXJlIiwiYXV0aCIsInRvIiwiZGF0YSIsImRlY29kZSIsImFkZHJlc3MiLCJkZWxlZ2F0aW9uIiwiY2hhaW5JZCIsIk51bWJlciIsIm5vbmNlIiwieVBhcml0eSIsInIiLCJzIiwic2VsZiIsInJlY292ZXJBZGRyZXNzIiwicGF5bG9hZCIsImdldFNpZ25QYXlsb2FkIiwiZW5jb2RlIiwiQmlnSW50IiwiZnJvbU51bWJlciIsInNpemUiLCJjb25jYXQiLCJCYXNlRXJyb3IiLCJjb25zdHJ1Y3RvciIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_cjs/erc8010/SignatureErc8010.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_cjs/erc8010/index.js":
/*!***********************************************!*\
  !*** ./node_modules/ox/_cjs/erc8010/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.SignatureErc8010 = void 0;\nexports.SignatureErc8010 = __webpack_require__(/*! ./SignatureErc8010.js */ \"(ssr)/./node_modules/ox/_cjs/erc8010/SignatureErc8010.js\"); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2Nqcy9lcmM4MDEwL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCx3QkFBd0IsR0FBRyxLQUFLO0FBQ2hDQSx1SUFBMkQsRUFDM0QsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xhdy13b3Jrcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9fY2pzL2VyYzgwMTAvaW5kZXguanM/NzE3NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2lnbmF0dXJlRXJjODAxMCA9IHZvaWQgMDtcbmV4cG9ydHMuU2lnbmF0dXJlRXJjODAxMCA9IHJlcXVpcmUoXCIuL1NpZ25hdHVyZUVyYzgwMTAuanNcIik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJTaWduYXR1cmVFcmM4MDEwIiwicmVxdWlyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_cjs/erc8010/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/AbiConstructor.js":
/*!*****************************************************!*\
  !*** ./node_modules/ox/_esm/core/AbiConstructor.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encode: () => (/* binding */ encode),\n/* harmony export */   format: () => (/* binding */ format),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromAbi: () => (/* binding */ fromAbi)\n/* harmony export */ });\n/* harmony import */ var abitype__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! abitype */ \"(ssr)/./node_modules/abitype/dist/esm/human-readable/formatAbiItem.js\");\n/* harmony import */ var _AbiItem_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AbiItem.js */ \"(ssr)/./node_modules/ox/_esm/core/AbiItem.js\");\n/* harmony import */ var _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AbiParameters.js */ \"(ssr)/./node_modules/ox/_esm/core/AbiParameters.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n\n\n\n\n// eslint-disable-next-line jsdoc/require-jsdoc\nfunction decode(...parameters) {\n    const [abiConstructor, options] = (()=>{\n        if (Array.isArray(parameters[0])) {\n            const [abi, options] = parameters;\n            return [\n                fromAbi(abi),\n                options\n            ];\n        }\n        return parameters;\n    })();\n    const { bytecode } = options;\n    if (abiConstructor.inputs?.length === 0) return undefined;\n    const data = options.data.replace(bytecode, \"0x\");\n    return _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.decode(abiConstructor.inputs, data);\n}\n// eslint-disable-next-line jsdoc/require-jsdoc\nfunction encode(...parameters) {\n    const [abiConstructor, options] = (()=>{\n        if (Array.isArray(parameters[0])) {\n            const [abi, options] = parameters;\n            return [\n                fromAbi(abi),\n                options\n            ];\n        }\n        return parameters;\n    })();\n    const { bytecode, args } = options;\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_1__.concat(bytecode, abiConstructor.inputs?.length && args?.length ? _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.encode(abiConstructor.inputs, args) : \"0x\");\n}\n/** @internal */ function format(abiConstructor) {\n    return abitype__WEBPACK_IMPORTED_MODULE_2__.formatAbiItem(abiConstructor);\n}\n/** @internal */ function from(abiConstructor) {\n    return _AbiItem_js__WEBPACK_IMPORTED_MODULE_3__.from(abiConstructor);\n}\n/** @internal */ function fromAbi(abi) {\n    const item = abi.find((item)=>item.type === \"constructor\");\n    if (!item) throw new _AbiItem_js__WEBPACK_IMPORTED_MODULE_3__.NotFoundError({\n        name: \"constructor\"\n    });\n    return item;\n} //# sourceMappingURL=AbiConstructor.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0FiaUNvbnN0cnVjdG9yLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFtQztBQUNLO0FBQ1k7QUFDcEI7QUFDaEMsK0NBQStDO0FBQ3hDLFNBQVNJLE9BQU8sR0FBR0MsVUFBVTtJQUNoQyxNQUFNLENBQUNDLGdCQUFnQkMsUUFBUSxHQUFHLENBQUM7UUFDL0IsSUFBSUMsTUFBTUMsT0FBTyxDQUFDSixVQUFVLENBQUMsRUFBRSxHQUFHO1lBQzlCLE1BQU0sQ0FBQ0ssS0FBS0gsUUFBUSxHQUFHRjtZQUN2QixPQUFPO2dCQUFDTSxRQUFRRDtnQkFBTUg7YUFBUTtRQUNsQztRQUNBLE9BQU9GO0lBQ1g7SUFDQSxNQUFNLEVBQUVPLFFBQVEsRUFBRSxHQUFHTDtJQUNyQixJQUFJRCxlQUFlTyxNQUFNLEVBQUVDLFdBQVcsR0FDbEMsT0FBT0M7SUFDWCxNQUFNQyxPQUFPVCxRQUFRUyxJQUFJLENBQUNDLE9BQU8sQ0FBQ0wsVUFBVTtJQUM1QyxPQUFPVixxREFBb0IsQ0FBQ0ksZUFBZU8sTUFBTSxFQUFFRztBQUN2RDtBQUNBLCtDQUErQztBQUN4QyxTQUFTRSxPQUFPLEdBQUdiLFVBQVU7SUFDaEMsTUFBTSxDQUFDQyxnQkFBZ0JDLFFBQVEsR0FBRyxDQUFDO1FBQy9CLElBQUlDLE1BQU1DLE9BQU8sQ0FBQ0osVUFBVSxDQUFDLEVBQUUsR0FBRztZQUM5QixNQUFNLENBQUNLLEtBQUtILFFBQVEsR0FBR0Y7WUFDdkIsT0FBTztnQkFBQ00sUUFBUUQ7Z0JBQU1IO2FBQVE7UUFDbEM7UUFDQSxPQUFPRjtJQUNYO0lBQ0EsTUFBTSxFQUFFTyxRQUFRLEVBQUVPLElBQUksRUFBRSxHQUFHWjtJQUMzQixPQUFPSiwyQ0FBVSxDQUFDUyxVQUFVTixlQUFlTyxNQUFNLEVBQUVDLFVBQVVLLE1BQU1MLFNBQzdEWixxREFBb0IsQ0FBQ0ksZUFBZU8sTUFBTSxFQUFFTSxRQUM1QztBQUNWO0FBQ0EsY0FBYyxHQUNQLFNBQVNFLE9BQU9mLGNBQWM7SUFDakMsT0FBT04sa0RBQXFCLENBQUNNO0FBQ2pDO0FBQ0EsY0FBYyxHQUNQLFNBQVNpQixLQUFLakIsY0FBYztJQUMvQixPQUFPTCw2Q0FBWSxDQUFDSztBQUN4QjtBQUNBLGNBQWMsR0FDUCxTQUFTSyxRQUFRRCxHQUFHO0lBQ3ZCLE1BQU1jLE9BQU9kLElBQUllLElBQUksQ0FBQyxDQUFDRCxPQUFTQSxLQUFLRSxJQUFJLEtBQUs7SUFDOUMsSUFBSSxDQUFDRixNQUNELE1BQU0sSUFBSXZCLHNEQUFxQixDQUFDO1FBQUUyQixNQUFNO0lBQWM7SUFDMUQsT0FBT0o7QUFDWCxFQUNBLDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsYXctd29ya3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0FiaUNvbnN0cnVjdG9yLmpzPzZjZTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgYWJpdHlwZSBmcm9tICdhYml0eXBlJztcbmltcG9ydCAqIGFzIEFiaUl0ZW0gZnJvbSAnLi9BYmlJdGVtLmpzJztcbmltcG9ydCAqIGFzIEFiaVBhcmFtZXRlcnMgZnJvbSAnLi9BYmlQYXJhbWV0ZXJzLmpzJztcbmltcG9ydCAqIGFzIEhleCBmcm9tICcuL0hleC5qcyc7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvY1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZSguLi5wYXJhbWV0ZXJzKSB7XG4gICAgY29uc3QgW2FiaUNvbnN0cnVjdG9yLCBvcHRpb25zXSA9ICgoKSA9PiB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtZXRlcnNbMF0pKSB7XG4gICAgICAgICAgICBjb25zdCBbYWJpLCBvcHRpb25zXSA9IHBhcmFtZXRlcnM7XG4gICAgICAgICAgICByZXR1cm4gW2Zyb21BYmkoYWJpKSwgb3B0aW9uc107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmFtZXRlcnM7XG4gICAgfSkoKTtcbiAgICBjb25zdCB7IGJ5dGVjb2RlIH0gPSBvcHRpb25zO1xuICAgIGlmIChhYmlDb25zdHJ1Y3Rvci5pbnB1dHM/Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBjb25zdCBkYXRhID0gb3B0aW9ucy5kYXRhLnJlcGxhY2UoYnl0ZWNvZGUsICcweCcpO1xuICAgIHJldHVybiBBYmlQYXJhbWV0ZXJzLmRlY29kZShhYmlDb25zdHJ1Y3Rvci5pbnB1dHMsIGRhdGEpO1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzZG9jL3JlcXVpcmUtanNkb2NcbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGUoLi4ucGFyYW1ldGVycykge1xuICAgIGNvbnN0IFthYmlDb25zdHJ1Y3Rvciwgb3B0aW9uc10gPSAoKCkgPT4ge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbWV0ZXJzWzBdKSkge1xuICAgICAgICAgICAgY29uc3QgW2FiaSwgb3B0aW9uc10gPSBwYXJhbWV0ZXJzO1xuICAgICAgICAgICAgcmV0dXJuIFtmcm9tQWJpKGFiaSksIG9wdGlvbnNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJhbWV0ZXJzO1xuICAgIH0pKCk7XG4gICAgY29uc3QgeyBieXRlY29kZSwgYXJncyB9ID0gb3B0aW9ucztcbiAgICByZXR1cm4gSGV4LmNvbmNhdChieXRlY29kZSwgYWJpQ29uc3RydWN0b3IuaW5wdXRzPy5sZW5ndGggJiYgYXJncz8ubGVuZ3RoXG4gICAgICAgID8gQWJpUGFyYW1ldGVycy5lbmNvZGUoYWJpQ29uc3RydWN0b3IuaW5wdXRzLCBhcmdzKVxuICAgICAgICA6ICcweCcpO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdChhYmlDb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBhYml0eXBlLmZvcm1hdEFiaUl0ZW0oYWJpQ29uc3RydWN0b3IpO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb20oYWJpQ29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gQWJpSXRlbS5mcm9tKGFiaUNvbnN0cnVjdG9yKTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tQWJpKGFiaSkge1xuICAgIGNvbnN0IGl0ZW0gPSBhYmkuZmluZCgoaXRlbSkgPT4gaXRlbS50eXBlID09PSAnY29uc3RydWN0b3InKTtcbiAgICBpZiAoIWl0ZW0pXG4gICAgICAgIHRocm93IG5ldyBBYmlJdGVtLk5vdEZvdW5kRXJyb3IoeyBuYW1lOiAnY29uc3RydWN0b3InIH0pO1xuICAgIHJldHVybiBpdGVtO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWJpQ29uc3RydWN0b3IuanMubWFwIl0sIm5hbWVzIjpbImFiaXR5cGUiLCJBYmlJdGVtIiwiQWJpUGFyYW1ldGVycyIsIkhleCIsImRlY29kZSIsInBhcmFtZXRlcnMiLCJhYmlDb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJBcnJheSIsImlzQXJyYXkiLCJhYmkiLCJmcm9tQWJpIiwiYnl0ZWNvZGUiLCJpbnB1dHMiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJkYXRhIiwicmVwbGFjZSIsImVuY29kZSIsImFyZ3MiLCJjb25jYXQiLCJmb3JtYXQiLCJmb3JtYXRBYmlJdGVtIiwiZnJvbSIsIml0ZW0iLCJmaW5kIiwidHlwZSIsIk5vdEZvdW5kRXJyb3IiLCJuYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/AbiConstructor.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/AbiFunction.js":
/*!**************************************************!*\
  !*** ./node_modules/ox/_esm/core/AbiFunction.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeData: () => (/* binding */ decodeData),\n/* harmony export */   decodeResult: () => (/* binding */ decodeResult),\n/* harmony export */   encodeData: () => (/* binding */ encodeData),\n/* harmony export */   encodeResult: () => (/* binding */ encodeResult),\n/* harmony export */   format: () => (/* binding */ format),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromAbi: () => (/* binding */ fromAbi),\n/* harmony export */   getSelector: () => (/* binding */ getSelector)\n/* harmony export */ });\n/* harmony import */ var abitype__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! abitype */ \"(ssr)/./node_modules/abitype/dist/esm/human-readable/formatAbiItem.js\");\n/* harmony import */ var _AbiItem_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AbiItem.js */ \"(ssr)/./node_modules/ox/_esm/core/AbiItem.js\");\n/* harmony import */ var _AbiParameters_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AbiParameters.js */ \"(ssr)/./node_modules/ox/_esm/core/AbiParameters.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n\n\n\n\n// eslint-disable-next-line jsdoc/require-jsdoc\nfunction decodeData(...parameters) {\n    const [abiFunction, data] = (()=>{\n        if (Array.isArray(parameters[0])) {\n            const [abi, name, data] = parameters;\n            return [\n                fromAbi(abi, name),\n                data\n            ];\n        }\n        return parameters;\n    })();\n    const { overloads } = abiFunction;\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(data) < 4) throw new _AbiItem_js__WEBPACK_IMPORTED_MODULE_1__.InvalidSelectorSizeError({\n        data\n    });\n    if (abiFunction.inputs?.length === 0) return undefined;\n    const item = overloads ? fromAbi([\n        abiFunction,\n        ...overloads\n    ], data) : abiFunction;\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(data) <= 4) return undefined;\n    return _AbiParameters_js__WEBPACK_IMPORTED_MODULE_2__.decode(item.inputs, _Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(data, 4));\n}\n// eslint-disable-next-line jsdoc/require-jsdoc\nfunction decodeResult(...parameters) {\n    const [abiFunction, data, options = {}] = (()=>{\n        if (Array.isArray(parameters[0])) {\n            const [abi, name, data, options] = parameters;\n            return [\n                fromAbi(abi, name),\n                data,\n                options\n            ];\n        }\n        return parameters;\n    })();\n    const values = _AbiParameters_js__WEBPACK_IMPORTED_MODULE_2__.decode(abiFunction.outputs, data, options);\n    if (values && Object.keys(values).length === 0) return undefined;\n    if (values && Object.keys(values).length === 1) {\n        if (Array.isArray(values)) return values[0];\n        return Object.values(values)[0];\n    }\n    return values;\n}\n// eslint-disable-next-line jsdoc/require-jsdoc\nfunction encodeData(...parameters) {\n    const [abiFunction, args = []] = (()=>{\n        if (Array.isArray(parameters[0])) {\n            const [abi, name, args] = parameters;\n            return [\n                fromAbi(abi, name, {\n                    args\n                }),\n                args\n            ];\n        }\n        const [abiFunction, args] = parameters;\n        return [\n            abiFunction,\n            args\n        ];\n    })();\n    const { overloads } = abiFunction;\n    const item = overloads ? fromAbi([\n        abiFunction,\n        ...overloads\n    ], abiFunction.name, {\n        args\n    }) : abiFunction;\n    const selector = getSelector(item);\n    const data = args.length > 0 ? _AbiParameters_js__WEBPACK_IMPORTED_MODULE_2__.encode(item.inputs, args) : undefined;\n    return data ? _Hex_js__WEBPACK_IMPORTED_MODULE_0__.concat(selector, data) : selector;\n}\n// eslint-disable-next-line jsdoc/require-jsdoc\nfunction encodeResult(...parameters) {\n    const [abiFunction, output, options = {}] = (()=>{\n        if (Array.isArray(parameters[0])) {\n            const [abi, name, output, options] = parameters;\n            return [\n                fromAbi(abi, name),\n                output,\n                options\n            ];\n        }\n        return parameters;\n    })();\n    const { as = \"Array\" } = options;\n    const values = (()=>{\n        if (abiFunction.outputs.length === 1) return [\n            output\n        ];\n        if (Array.isArray(output)) return output;\n        if (as === \"Object\") return Object.values(output);\n        return [\n            output\n        ];\n    })();\n    return _AbiParameters_js__WEBPACK_IMPORTED_MODULE_2__.encode(abiFunction.outputs, values);\n}\n/**\n * Formats an {@link ox#AbiFunction.AbiFunction} into a **Human Readable ABI Function**.\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const formatted = AbiFunction.format({\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * })\n *\n * formatted\n * //    ^?\n *\n *\n * ```\n *\n * @param abiFunction - The ABI Function to format.\n * @returns The formatted ABI Function.\n */ function format(abiFunction) {\n    return abitype__WEBPACK_IMPORTED_MODULE_3__.formatAbiItem(abiFunction);\n}\n/**\n * Parses an arbitrary **JSON ABI Function** or **Human Readable ABI Function** into a typed {@link ox#AbiFunction.AbiFunction}.\n *\n * @example\n * ### JSON ABIs\n *\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const approve = AbiFunction.from({\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * })\n *\n * approve\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable ABIs\n *\n * A Human Readable ABI can be parsed into a typed ABI object:\n *\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const approve = AbiFunction.from(\n *   'function approve(address spender, uint256 amount) returns (bool)' // [!code hl]\n * )\n *\n * approve\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * It is possible to specify `struct`s along with your definitions:\n *\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const approve = AbiFunction.from([\n *   'struct Foo { address spender; uint256 amount; }', // [!code hl]\n *   'function approve(Foo foo) returns (bool)',\n * ])\n *\n * approve\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n *\n *\n * @param abiFunction - The ABI Function to parse.\n * @returns Typed ABI Function.\n */ function from(abiFunction, options = {}) {\n    return _AbiItem_js__WEBPACK_IMPORTED_MODULE_1__.from(abiFunction, options);\n}\n/**\n * Extracts an {@link ox#AbiFunction.AbiFunction} from an {@link ox#Abi.Abi} given a name and optional arguments.\n *\n * @example\n * ### Extracting by Name\n *\n * ABI Functions can be extracted by their name using the `name` option:\n *\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n *\n * const item = AbiFunction.fromAbi(abi, 'foo') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Extracting by Selector\n *\n * ABI Functions can be extract by their selector when {@link ox#Hex.Hex} is provided to `name`.\n *\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n * const item = AbiFunction.fromAbi(abi, '0x095ea7b3') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * :::note\n *\n * Extracting via a hex selector is useful when extracting an ABI Function from an `eth_call` RPC response or\n * from a Transaction `input`.\n *\n * :::\n *\n * @param abi - The ABI to extract from.\n * @param name - The name (or selector) of the ABI item to extract.\n * @param options - Extraction options.\n * @returns The ABI item.\n */ function fromAbi(abi, name, options) {\n    const item = _AbiItem_js__WEBPACK_IMPORTED_MODULE_1__.fromAbi(abi, name, options);\n    if (item.type !== \"function\") throw new _AbiItem_js__WEBPACK_IMPORTED_MODULE_1__.NotFoundError({\n        name,\n        type: \"function\"\n    });\n    return item;\n}\n/**\n * Computes the [4-byte selector](https://solidity-by-example.org/function-selector/) for an {@link ox#AbiFunction.AbiFunction}.\n *\n * Useful for computing function selectors for calldata.\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const selector = AbiFunction.getSelector('function ownerOf(uint256 tokenId)')\n * // @log: '0x6352211e'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const selector = AbiFunction.getSelector({\n *   inputs: [{ type: 'uint256' }],\n *   name: 'ownerOf',\n *   outputs: [],\n *   stateMutability: 'view',\n *   type: 'function'\n * })\n * // @log: '0x6352211e'\n * ```\n *\n * @param abiItem - The ABI item to compute the selector for.\n * @returns The first 4 bytes of the {@link ox#Hash.(keccak256:function)} hash of the function signature.\n */ function getSelector(abiItem) {\n    return _AbiItem_js__WEBPACK_IMPORTED_MODULE_1__.getSelector(abiItem);\n} //# sourceMappingURL=AbiFunction.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0FiaUZ1bmN0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFtQztBQUNLO0FBQ1k7QUFDcEI7QUFDaEMsK0NBQStDO0FBQ3hDLFNBQVNJLFdBQVcsR0FBR0MsVUFBVTtJQUNwQyxNQUFNLENBQUNDLGFBQWFDLEtBQUssR0FBRyxDQUFDO1FBQ3pCLElBQUlDLE1BQU1DLE9BQU8sQ0FBQ0osVUFBVSxDQUFDLEVBQUUsR0FBRztZQUM5QixNQUFNLENBQUNLLEtBQUtDLE1BQU1KLEtBQUssR0FBR0Y7WUFDMUIsT0FBTztnQkFBQ08sUUFBUUYsS0FBS0M7Z0JBQU9KO2FBQUs7UUFDckM7UUFDQSxPQUFPRjtJQUNYO0lBQ0EsTUFBTSxFQUFFUSxTQUFTLEVBQUUsR0FBR1A7SUFDdEIsSUFBSUgseUNBQVEsQ0FBQ0ksUUFBUSxHQUNqQixNQUFNLElBQUlOLGlFQUFnQyxDQUFDO1FBQUVNO0lBQUs7SUFDdEQsSUFBSUQsWUFBWVUsTUFBTSxFQUFFQyxXQUFXLEdBQy9CLE9BQU9DO0lBQ1gsTUFBTUMsT0FBT04sWUFDUEQsUUFBUTtRQUFDTjtXQUFnQk87S0FBVSxFQUFFTixRQUNyQ0Q7SUFDTixJQUFJSCx5Q0FBUSxDQUFDSSxTQUFTLEdBQ2xCLE9BQU9XO0lBQ1gsT0FBT2hCLHFEQUFvQixDQUFDaUIsS0FBS0gsTUFBTSxFQUFFYiwwQ0FBUyxDQUFDSSxNQUFNO0FBQzdEO0FBQ0EsK0NBQStDO0FBQ3hDLFNBQVNlLGFBQWEsR0FBR2pCLFVBQVU7SUFDdEMsTUFBTSxDQUFDQyxhQUFhQyxNQUFNZ0IsVUFBVSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUM7UUFDdkMsSUFBSWYsTUFBTUMsT0FBTyxDQUFDSixVQUFVLENBQUMsRUFBRSxHQUFHO1lBQzlCLE1BQU0sQ0FBQ0ssS0FBS0MsTUFBTUosTUFBTWdCLFFBQVEsR0FBR2xCO1lBQ25DLE9BQU87Z0JBQUNPLFFBQVFGLEtBQUtDO2dCQUFPSjtn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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWdFQyxHQUNNLFNBQVNYLFFBQVFGLEdBQUcsRUFBRUMsSUFBSSxFQUFFWSxPQUFPO0lBQ3RDLE1BQU1KLE9BQU9sQixnREFBZSxDQUFDUyxLQUFLQyxNQUFNWTtJQUN4QyxJQUFJSixLQUFLcUIsSUFBSSxLQUFLLFlBQ2QsTUFBTSxJQUFJdkMsc0RBQXFCLENBQUM7UUFBRVU7UUFBTTZCLE1BQU07SUFBVztJQUM3RCxPQUFPckI7QUFDWDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQTZCQyxHQUNNLFNBQVNZLFlBQVlXLE9BQU87SUFDL0IsT0FBT3pDLG9EQUFtQixDQUFDeUM7QUFDL0IsRUFDQSx1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGF3LXdvcmtzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9BYmlGdW5jdGlvbi5qcz8yMjg3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGFiaXR5cGUgZnJvbSAnYWJpdHlwZSc7XG5pbXBvcnQgKiBhcyBBYmlJdGVtIGZyb20gJy4vQWJpSXRlbS5qcyc7XG5pbXBvcnQgKiBhcyBBYmlQYXJhbWV0ZXJzIGZyb20gJy4vQWJpUGFyYW1ldGVycy5qcyc7XG5pbXBvcnQgKiBhcyBIZXggZnJvbSAnLi9IZXguanMnO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzZG9jL3JlcXVpcmUtanNkb2NcbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVEYXRhKC4uLnBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBbYWJpRnVuY3Rpb24sIGRhdGFdID0gKCgpID0+IHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW1ldGVyc1swXSkpIHtcbiAgICAgICAgICAgIGNvbnN0IFthYmksIG5hbWUsIGRhdGFdID0gcGFyYW1ldGVycztcbiAgICAgICAgICAgIHJldHVybiBbZnJvbUFiaShhYmksIG5hbWUpLCBkYXRhXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyYW1ldGVycztcbiAgICB9KSgpO1xuICAgIGNvbnN0IHsgb3ZlcmxvYWRzIH0gPSBhYmlGdW5jdGlvbjtcbiAgICBpZiAoSGV4LnNpemUoZGF0YSkgPCA0KVxuICAgICAgICB0aHJvdyBuZXcgQWJpSXRlbS5JbnZhbGlkU2VsZWN0b3JTaXplRXJyb3IoeyBkYXRhIH0pO1xuICAgIGlmIChhYmlGdW5jdGlvbi5pbnB1dHM/Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBjb25zdCBpdGVtID0gb3ZlcmxvYWRzXG4gICAgICAgID8gZnJvbUFiaShbYWJpRnVuY3Rpb24sIC4uLm92ZXJsb2Fkc10sIGRhdGEpXG4gICAgICAgIDogYWJpRnVuY3Rpb247XG4gICAgaWYgKEhleC5zaXplKGRhdGEpIDw9IDQpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIEFiaVBhcmFtZXRlcnMuZGVjb2RlKGl0ZW0uaW5wdXRzLCBIZXguc2xpY2UoZGF0YSwgNCkpO1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzZG9jL3JlcXVpcmUtanNkb2NcbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVSZXN1bHQoLi4ucGFyYW1ldGVycykge1xuICAgIGNvbnN0IFthYmlGdW5jdGlvbiwgZGF0YSwgb3B0aW9ucyA9IHt9XSA9ICgoKSA9PiB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtZXRlcnNbMF0pKSB7XG4gICAgICAgICAgICBjb25zdCBbYWJpLCBuYW1lLCBkYXRhLCBvcHRpb25zXSA9IHBhcmFtZXRlcnM7XG4gICAgICAgICAgICByZXR1cm4gW2Zyb21BYmkoYWJpLCBuYW1lKSwgZGF0YSwgb3B0aW9uc107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmFtZXRlcnM7XG4gICAgfSkoKTtcbiAgICBjb25zdCB2YWx1ZXMgPSBBYmlQYXJhbWV0ZXJzLmRlY29kZShhYmlGdW5jdGlvbi5vdXRwdXRzLCBkYXRhLCBvcHRpb25zKTtcbiAgICBpZiAodmFsdWVzICYmIE9iamVjdC5rZXlzKHZhbHVlcykubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGlmICh2YWx1ZXMgJiYgT2JqZWN0LmtleXModmFsdWVzKS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSlcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXNbMF07XG4gICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKHZhbHVlcylbMF07XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvY1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZURhdGEoLi4ucGFyYW1ldGVycykge1xuICAgIGNvbnN0IFthYmlGdW5jdGlvbiwgYXJncyA9IFtdXSA9ICgoKSA9PiB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtZXRlcnNbMF0pKSB7XG4gICAgICAgICAgICBjb25zdCBbYWJpLCBuYW1lLCBhcmdzXSA9IHBhcmFtZXRlcnM7XG4gICAgICAgICAgICByZXR1cm4gW2Zyb21BYmkoYWJpLCBuYW1lLCB7IGFyZ3MgfSksIGFyZ3NdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFthYmlGdW5jdGlvbiwgYXJnc10gPSBwYXJhbWV0ZXJzO1xuICAgICAgICByZXR1cm4gW2FiaUZ1bmN0aW9uLCBhcmdzXTtcbiAgICB9KSgpO1xuICAgIGNvbnN0IHsgb3ZlcmxvYWRzIH0gPSBhYmlGdW5jdGlvbjtcbiAgICBjb25zdCBpdGVtID0gb3ZlcmxvYWRzXG4gICAgICAgID8gZnJvbUFiaShbYWJpRnVuY3Rpb24sIC4uLm92ZXJsb2Fkc10sIGFiaUZ1bmN0aW9uLm5hbWUsIHtcbiAgICAgICAgICAgIGFyZ3MsXG4gICAgICAgIH0pXG4gICAgICAgIDogYWJpRnVuY3Rpb247XG4gICAgY29uc3Qgc2VsZWN0b3IgPSBnZXRTZWxlY3RvcihpdGVtKTtcbiAgICBjb25zdCBkYXRhID0gYXJncy5sZW5ndGggPiAwID8gQWJpUGFyYW1ldGVycy5lbmNvZGUoaXRlbS5pbnB1dHMsIGFyZ3MpIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiBkYXRhID8gSGV4LmNvbmNhdChzZWxlY3RvciwgZGF0YSkgOiBzZWxlY3Rvcjtcbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc2RvYy9yZXF1aXJlLWpzZG9jXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlUmVzdWx0KC4uLnBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBbYWJpRnVuY3Rpb24sIG91dHB1dCwgb3B0aW9ucyA9IHt9XSA9ICgoKSA9PiB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtZXRlcnNbMF0pKSB7XG4gICAgICAgICAgICBjb25zdCBbYWJpLCBuYW1lLCBvdXRwdXQsIG9wdGlvbnNdID0gcGFyYW1ldGVycztcbiAgICAgICAgICAgIHJldHVybiBbZnJvbUFiaShhYmksIG5hbWUpLCBvdXRwdXQsIG9wdGlvbnNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJhbWV0ZXJzO1xuICAgIH0pKCk7XG4gICAgY29uc3QgeyBhcyA9ICdBcnJheScgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgdmFsdWVzID0gKCgpID0+IHtcbiAgICAgICAgaWYgKGFiaUZ1bmN0aW9uLm91dHB1dHMubGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgcmV0dXJuIFtvdXRwdXRdO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvdXRwdXQpKVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgaWYgKGFzID09PSAnT2JqZWN0JylcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKG91dHB1dCk7XG4gICAgICAgIHJldHVybiBbb3V0cHV0XTtcbiAgICB9KSgpO1xuICAgIHJldHVybiBBYmlQYXJhbWV0ZXJzLmVuY29kZShhYmlGdW5jdGlvbi5vdXRwdXRzLCB2YWx1ZXMpO1xufVxuLyoqXG4gKiBGb3JtYXRzIGFuIHtAbGluayBveCNBYmlGdW5jdGlvbi5BYmlGdW5jdGlvbn0gaW50byBhICoqSHVtYW4gUmVhZGFibGUgQUJJIEZ1bmN0aW9uKiouXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlGdW5jdGlvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGZvcm1hdHRlZCA9IEFiaUZ1bmN0aW9uLmZvcm1hdCh7XG4gKiAgIHR5cGU6ICdmdW5jdGlvbicsXG4gKiAgIG5hbWU6ICdhcHByb3ZlJyxcbiAqICAgc3RhdGVNdXRhYmlsaXR5OiAnbm9ucGF5YWJsZScsXG4gKiAgIGlucHV0czogW1xuICogICAgIHtcbiAqICAgICAgIG5hbWU6ICdzcGVuZGVyJyxcbiAqICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAqICAgICB9LFxuICogICAgIHtcbiAqICAgICAgIG5hbWU6ICdhbW91bnQnLFxuICogICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICogICAgIH0sXG4gKiAgIF0sXG4gKiAgIG91dHB1dHM6IFt7IHR5cGU6ICdib29sJyB9XSxcbiAqIH0pXG4gKlxuICogZm9ybWF0dGVkXG4gKiAvLyAgICBeP1xuICpcbiAqXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYWJpRnVuY3Rpb24gLSBUaGUgQUJJIEZ1bmN0aW9uIHRvIGZvcm1hdC5cbiAqIEByZXR1cm5zIFRoZSBmb3JtYXR0ZWQgQUJJIEZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0KGFiaUZ1bmN0aW9uKSB7XG4gICAgcmV0dXJuIGFiaXR5cGUuZm9ybWF0QWJpSXRlbShhYmlGdW5jdGlvbik7XG59XG4vKipcbiAqIFBhcnNlcyBhbiBhcmJpdHJhcnkgKipKU09OIEFCSSBGdW5jdGlvbioqIG9yICoqSHVtYW4gUmVhZGFibGUgQUJJIEZ1bmN0aW9uKiogaW50byBhIHR5cGVkIHtAbGluayBveCNBYmlGdW5jdGlvbi5BYmlGdW5jdGlvbn0uXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBKU09OIEFCSXNcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpRnVuY3Rpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhcHByb3ZlID0gQWJpRnVuY3Rpb24uZnJvbSh7XG4gKiAgIHR5cGU6ICdmdW5jdGlvbicsXG4gKiAgIG5hbWU6ICdhcHByb3ZlJyxcbiAqICAgc3RhdGVNdXRhYmlsaXR5OiAnbm9ucGF5YWJsZScsXG4gKiAgIGlucHV0czogW1xuICogICAgIHtcbiAqICAgICAgIG5hbWU6ICdzcGVuZGVyJyxcbiAqICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAqICAgICB9LFxuICogICAgIHtcbiAqICAgICAgIG5hbWU6ICdhbW91bnQnLFxuICogICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICogICAgIH0sXG4gKiAgIF0sXG4gKiAgIG91dHB1dHM6IFt7IHR5cGU6ICdib29sJyB9XSxcbiAqIH0pXG4gKlxuICogYXBwcm92ZVxuICogLy9eP1xuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBIdW1hbiBSZWFkYWJsZSBBQklzXG4gKlxuICogQSBIdW1hbiBSZWFkYWJsZSBBQkkgY2FuIGJlIHBhcnNlZCBpbnRvIGEgdHlwZWQgQUJJIG9iamVjdDpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpRnVuY3Rpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhcHByb3ZlID0gQWJpRnVuY3Rpb24uZnJvbShcbiAqICAgJ2Z1bmN0aW9uIGFwcHJvdmUoYWRkcmVzcyBzcGVuZGVyLCB1aW50MjU2IGFtb3VudCkgcmV0dXJucyAoYm9vbCknIC8vIFshY29kZSBobF1cbiAqIClcbiAqXG4gKiBhcHByb3ZlXG4gKiAvL14/XG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIEl0IGlzIHBvc3NpYmxlIHRvIHNwZWNpZnkgYHN0cnVjdGBzIGFsb25nIHdpdGggeW91ciBkZWZpbml0aW9uczpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpRnVuY3Rpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhcHByb3ZlID0gQWJpRnVuY3Rpb24uZnJvbShbXG4gKiAgICdzdHJ1Y3QgRm9vIHsgYWRkcmVzcyBzcGVuZGVyOyB1aW50MjU2IGFtb3VudDsgfScsIC8vIFshY29kZSBobF1cbiAqICAgJ2Z1bmN0aW9uIGFwcHJvdmUoRm9vIGZvbykgcmV0dXJucyAoYm9vbCknLFxuICogXSlcbiAqXG4gKiBhcHByb3ZlXG4gKiAvL14/XG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKiBgYGBcbiAqXG4gKlxuICpcbiAqIEBwYXJhbSBhYmlGdW5jdGlvbiAtIFRoZSBBQkkgRnVuY3Rpb24gdG8gcGFyc2UuXG4gKiBAcmV0dXJucyBUeXBlZCBBQkkgRnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tKGFiaUZ1bmN0aW9uLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gQWJpSXRlbS5mcm9tKGFiaUZ1bmN0aW9uLCBvcHRpb25zKTtcbn1cbi8qKlxuICogRXh0cmFjdHMgYW4ge0BsaW5rIG94I0FiaUZ1bmN0aW9uLkFiaUZ1bmN0aW9ufSBmcm9tIGFuIHtAbGluayBveCNBYmkuQWJpfSBnaXZlbiBhIG5hbWUgYW5kIG9wdGlvbmFsIGFyZ3VtZW50cy5cbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEV4dHJhY3RpbmcgYnkgTmFtZVxuICpcbiAqIEFCSSBGdW5jdGlvbnMgY2FuIGJlIGV4dHJhY3RlZCBieSB0aGVpciBuYW1lIHVzaW5nIHRoZSBgbmFtZWAgb3B0aW9uOlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmksIEFiaUZ1bmN0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYWJpID0gQWJpLmZyb20oW1xuICogICAnZnVuY3Rpb24gZm9vKCknLFxuICogICAnZXZlbnQgVHJhbnNmZXIoYWRkcmVzcyBvd25lciwgYWRkcmVzcyB0bywgdWludDI1NiB0b2tlbklkKScsXG4gKiAgICdmdW5jdGlvbiBiYXIoc3RyaW5nIGEpIHJldHVybnMgKHVpbnQyNTYgeCknLFxuICogXSlcbiAqXG4gKiBjb25zdCBpdGVtID0gQWJpRnVuY3Rpb24uZnJvbUFiaShhYmksICdmb28nKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyAgICBeP1xuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBFeHRyYWN0aW5nIGJ5IFNlbGVjdG9yXG4gKlxuICogQUJJIEZ1bmN0aW9ucyBjYW4gYmUgZXh0cmFjdCBieSB0aGVpciBzZWxlY3RvciB3aGVuIHtAbGluayBveCNIZXguSGV4fSBpcyBwcm92aWRlZCB0byBgbmFtZWAuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaSwgQWJpRnVuY3Rpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhYmkgPSBBYmkuZnJvbShbXG4gKiAgICdmdW5jdGlvbiBmb28oKScsXG4gKiAgICdldmVudCBUcmFuc2ZlcihhZGRyZXNzIG93bmVyLCBhZGRyZXNzIHRvLCB1aW50MjU2IHRva2VuSWQpJyxcbiAqICAgJ2Z1bmN0aW9uIGJhcihzdHJpbmcgYSkgcmV0dXJucyAodWludDI1NiB4KScsXG4gKiBdKVxuICogY29uc3QgaXRlbSA9IEFiaUZ1bmN0aW9uLmZyb21BYmkoYWJpLCAnMHgwOTVlYTdiMycpIC8vIFshY29kZSBmb2N1c11cbiAqIC8vICAgIF4/XG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKiBgYGBcbiAqXG4gKiA6Ojpub3RlXG4gKlxuICogRXh0cmFjdGluZyB2aWEgYSBoZXggc2VsZWN0b3IgaXMgdXNlZnVsIHdoZW4gZXh0cmFjdGluZyBhbiBBQkkgRnVuY3Rpb24gZnJvbSBhbiBgZXRoX2NhbGxgIFJQQyByZXNwb25zZSBvclxuICogZnJvbSBhIFRyYW5zYWN0aW9uIGBpbnB1dGAuXG4gKlxuICogOjo6XG4gKlxuICogQHBhcmFtIGFiaSAtIFRoZSBBQkkgdG8gZXh0cmFjdCBmcm9tLlxuICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSAob3Igc2VsZWN0b3IpIG9mIHRoZSBBQkkgaXRlbSB0byBleHRyYWN0LlxuICogQHBhcmFtIG9wdGlvbnMgLSBFeHRyYWN0aW9uIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgQUJJIGl0ZW0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tQWJpKGFiaSwgbmFtZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGl0ZW0gPSBBYmlJdGVtLmZyb21BYmkoYWJpLCBuYW1lLCBvcHRpb25zKTtcbiAgICBpZiAoaXRlbS50eXBlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgQWJpSXRlbS5Ob3RGb3VuZEVycm9yKHsgbmFtZSwgdHlwZTogJ2Z1bmN0aW9uJyB9KTtcbiAgICByZXR1cm4gaXRlbTtcbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIFs0LWJ5dGUgc2VsZWN0b3JdKGh0dHBzOi8vc29saWRpdHktYnktZXhhbXBsZS5vcmcvZnVuY3Rpb24tc2VsZWN0b3IvKSBmb3IgYW4ge0BsaW5rIG94I0FiaUZ1bmN0aW9uLkFiaUZ1bmN0aW9ufS5cbiAqXG4gKiBVc2VmdWwgZm9yIGNvbXB1dGluZyBmdW5jdGlvbiBzZWxlY3RvcnMgZm9yIGNhbGxkYXRhLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpRnVuY3Rpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBzZWxlY3RvciA9IEFiaUZ1bmN0aW9uLmdldFNlbGVjdG9yKCdmdW5jdGlvbiBvd25lck9mKHVpbnQyNTYgdG9rZW5JZCknKVxuICogLy8gQGxvZzogJzB4NjM1MjIxMWUnXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaUZ1bmN0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2VsZWN0b3IgPSBBYmlGdW5jdGlvbi5nZXRTZWxlY3Rvcih7XG4gKiAgIGlucHV0czogW3sgdHlwZTogJ3VpbnQyNTYnIH1dLFxuICogICBuYW1lOiAnb3duZXJPZicsXG4gKiAgIG91dHB1dHM6IFtdLFxuICogICBzdGF0ZU11dGFiaWxpdHk6ICd2aWV3JyxcbiAqICAgdHlwZTogJ2Z1bmN0aW9uJ1xuICogfSlcbiAqIC8vIEBsb2c6ICcweDYzNTIyMTFlJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIGFiaUl0ZW0gLSBUaGUgQUJJIGl0ZW0gdG8gY29tcHV0ZSB0aGUgc2VsZWN0b3IgZm9yLlxuICogQHJldHVybnMgVGhlIGZpcnN0IDQgYnl0ZXMgb2YgdGhlIHtAbGluayBveCNIYXNoLihrZWNjYWsyNTY6ZnVuY3Rpb24pfSBoYXNoIG9mIHRoZSBmdW5jdGlvbiBzaWduYXR1cmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTZWxlY3RvcihhYmlJdGVtKSB7XG4gICAgcmV0dXJuIEFiaUl0ZW0uZ2V0U2VsZWN0b3IoYWJpSXRlbSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BYmlGdW5jdGlvbi5qcy5tYXAiXSwibmFtZXMiOlsiYWJpdHlwZSIsIkFiaUl0ZW0iLCJBYmlQYXJhbWV0ZXJzIiwiSGV4IiwiZGVjb2RlRGF0YSIsInBhcmFtZXRlcnMiLCJhYmlGdW5jdGlvbiIsImRhdGEiLCJBcnJheSIsImlzQXJyYXkiLCJhYmkiLCJuYW1lIiwiZnJvbUFiaSIsIm92ZXJsb2FkcyIsInNpemUiLCJJbnZhbGlkU2VsZWN0b3JTaXplRXJyb3IiLCJpbnB1dHMiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJpdGVtIiwiZGVjb2RlIiwic2xpY2UiLCJkZWNvZGVSZXN1bHQiLCJvcHRpb25zIiwidmFsdWVzIiwib3V0cHV0cyIsIk9iamVjdCIsImtleXMiLCJlbmNvZGVEYXRhIiwiYXJncyIsInNlbGVjdG9yIiwiZ2V0U2VsZWN0b3IiLCJlbmNvZGUiLCJjb25jYXQiLCJlbmNvZGVSZXN1bHQiLCJvdXRwdXQiLCJhcyIsImZvcm1hdCIsImZvcm1hdEFiaUl0ZW0iLCJmcm9tIiwidHlwZSIsIk5vdEZvdW5kRXJyb3IiLCJhYmlJdGVtIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/AbiFunction.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/AbiItem.js":
/*!**********************************************!*\
  !*** ./node_modules/ox/_esm/core/AbiItem.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AmbiguityError: () => (/* binding */ AmbiguityError),\n/* harmony export */   InvalidSelectorSizeError: () => (/* binding */ InvalidSelectorSizeError),\n/* harmony export */   NotFoundError: () => (/* binding */ NotFoundError),\n/* harmony export */   format: () => (/* binding */ format),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromAbi: () => (/* binding */ fromAbi),\n/* harmony export */   getSelector: () => (/* binding */ getSelector),\n/* harmony export */   getSignature: () => (/* binding */ getSignature),\n/* harmony export */   getSignatureHash: () => (/* binding */ getSignatureHash)\n/* harmony export */ });\n/* harmony import */ var abitype__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! abitype */ \"(ssr)/./node_modules/abitype/dist/esm/human-readable/formatAbiItem.js\");\n/* harmony import */ var abitype__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! abitype */ \"(ssr)/./node_modules/abitype/dist/esm/human-readable/parseAbiItem.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Hash.js */ \"(ssr)/./node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _internal_abiItem_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/abiItem.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/abiItem.js\");\n\n\n\n\n\n/**\n * Formats an {@link ox#AbiItem.AbiItem} into a **Human Readable ABI Item**.\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const formatted = AbiItem.format({\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * })\n *\n * formatted\n * //    ^?\n *\n *\n * ```\n *\n * @param abiItem - The ABI Item to format.\n * @returns The formatted ABI Item  .\n */ function format(abiItem) {\n    return abitype__WEBPACK_IMPORTED_MODULE_0__.formatAbiItem(abiItem);\n}\n/**\n * Parses an arbitrary **JSON ABI Item** or **Human Readable ABI Item** into a typed {@link ox#AbiItem.AbiItem}.\n *\n * @example\n * ### JSON ABIs\n *\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const abiItem = AbiItem.from({\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * })\n *\n * abiItem\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable ABIs\n *\n * A Human Readable ABI can be parsed into a typed ABI object:\n *\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const abiItem = AbiItem.from(\n *   'function approve(address spender, uint256 amount) returns (bool)' // [!code hl]\n * )\n *\n * abiItem\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * It is possible to specify `struct`s along with your definitions:\n *\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const abiItem = AbiItem.from([\n *   'struct Foo { address spender; uint256 amount; }', // [!code hl]\n *   'function approve(Foo foo) returns (bool)',\n * ])\n *\n * abiItem\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n *\n *\n * @param abiItem - The ABI Item to parse.\n * @returns The typed ABI Item.\n */ function from(abiItem, options = {}) {\n    const { prepare = true } = options;\n    const item = (()=>{\n        if (Array.isArray(abiItem)) return abitype__WEBPACK_IMPORTED_MODULE_1__.parseAbiItem(abiItem);\n        if (typeof abiItem === \"string\") return abitype__WEBPACK_IMPORTED_MODULE_1__.parseAbiItem(abiItem);\n        return abiItem;\n    })();\n    return {\n        ...item,\n        ...prepare ? {\n            hash: getSignatureHash(item)\n        } : {}\n    };\n}\n/**\n * Extracts an {@link ox#AbiItem.AbiItem} from an {@link ox#Abi.Abi} given a name and optional arguments.\n *\n * @example\n * ABI Items can be extracted by their name using the `name` option:\n *\n * ```ts twoslash\n * import { Abi, AbiItem } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n *\n * const item = AbiItem.fromAbi(abi, 'Transfer') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Extracting by Selector\n *\n * ABI Items can be extract by their selector when {@link ox#Hex.Hex} is provided to `name`.\n *\n * ```ts twoslash\n * import { Abi, AbiItem } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n * const item = AbiItem.fromAbi(abi, '0x095ea7b3') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * :::note\n *\n * Extracting via a hex selector is useful when extracting an ABI Item from an `eth_call` RPC response,\n * a Transaction `input`, or from Event Log `topics`.\n *\n * :::\n *\n * @param abi - The ABI to extract from.\n * @param name - The name (or selector) of the ABI item to extract.\n * @param options - Extraction options.\n * @returns The ABI item.\n */ function fromAbi(abi, name, options) {\n    const { args = [], prepare = true } = options ?? {};\n    const isSelector = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.validate(name, {\n        strict: false\n    });\n    const abiItems = abi.filter((abiItem)=>{\n        if (isSelector) {\n            if (abiItem.type === \"function\" || abiItem.type === \"error\") return getSelector(abiItem) === _Hex_js__WEBPACK_IMPORTED_MODULE_2__.slice(name, 0, 4);\n            if (abiItem.type === \"event\") return getSignatureHash(abiItem) === name;\n            return false;\n        }\n        return \"name\" in abiItem && abiItem.name === name;\n    });\n    if (abiItems.length === 0) throw new NotFoundError({\n        name: name\n    });\n    if (abiItems.length === 1) return {\n        ...abiItems[0],\n        ...prepare ? {\n            hash: getSignatureHash(abiItems[0])\n        } : {}\n    };\n    let matchedAbiItem;\n    for (const abiItem of abiItems){\n        if (!(\"inputs\" in abiItem)) continue;\n        if (!args || args.length === 0) {\n            if (!abiItem.inputs || abiItem.inputs.length === 0) return {\n                ...abiItem,\n                ...prepare ? {\n                    hash: getSignatureHash(abiItem)\n                } : {}\n            };\n            continue;\n        }\n        if (!abiItem.inputs) continue;\n        if (abiItem.inputs.length === 0) continue;\n        if (abiItem.inputs.length !== args.length) continue;\n        const matched = args.every((arg, index)=>{\n            const abiParameter = \"inputs\" in abiItem && abiItem.inputs[index];\n            if (!abiParameter) return false;\n            return _internal_abiItem_js__WEBPACK_IMPORTED_MODULE_3__.isArgOfType(arg, abiParameter);\n        });\n        if (matched) {\n            // Check for ambiguity against already matched parameters (e.g. `address` vs `bytes20`).\n            if (matchedAbiItem && \"inputs\" in matchedAbiItem && matchedAbiItem.inputs) {\n                const ambiguousTypes = _internal_abiItem_js__WEBPACK_IMPORTED_MODULE_3__.getAmbiguousTypes(abiItem.inputs, matchedAbiItem.inputs, args);\n                if (ambiguousTypes) throw new AmbiguityError({\n                    abiItem,\n                    type: ambiguousTypes[0]\n                }, {\n                    abiItem: matchedAbiItem,\n                    type: ambiguousTypes[1]\n                });\n            }\n            matchedAbiItem = abiItem;\n        }\n    }\n    const abiItem = (()=>{\n        if (matchedAbiItem) return matchedAbiItem;\n        const [abiItem, ...overloads] = abiItems;\n        return {\n            ...abiItem,\n            overloads\n        };\n    })();\n    if (!abiItem) throw new NotFoundError({\n        name: name\n    });\n    return {\n        ...abiItem,\n        ...prepare ? {\n            hash: getSignatureHash(abiItem)\n        } : {}\n    };\n}\n// eslint-disable-next-line jsdoc/require-jsdoc\nfunction getSelector(...parameters) {\n    const abiItem = (()=>{\n        if (Array.isArray(parameters[0])) {\n            const [abi, name] = parameters;\n            return fromAbi(abi, name);\n        }\n        return parameters[0];\n    })();\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.slice(getSignatureHash(abiItem), 0, 4);\n}\n// eslint-disable-next-line jsdoc/require-jsdoc\nfunction getSignature(...parameters) {\n    const abiItem = (()=>{\n        if (Array.isArray(parameters[0])) {\n            const [abi, name] = parameters;\n            return fromAbi(abi, name);\n        }\n        return parameters[0];\n    })();\n    const signature = (()=>{\n        if (typeof abiItem === \"string\") return abiItem;\n        return abitype__WEBPACK_IMPORTED_MODULE_0__.formatAbiItem(abiItem);\n    })();\n    return _internal_abiItem_js__WEBPACK_IMPORTED_MODULE_3__.normalizeSignature(signature);\n}\n// eslint-disable-next-line jsdoc/require-jsdoc\nfunction getSignatureHash(...parameters) {\n    const abiItem = (()=>{\n        if (Array.isArray(parameters[0])) {\n            const [abi, name] = parameters;\n            return fromAbi(abi, name);\n        }\n        return parameters[0];\n    })();\n    if (typeof abiItem !== \"string\" && \"hash\" in abiItem && abiItem.hash) return abiItem.hash;\n    return _Hash_js__WEBPACK_IMPORTED_MODULE_4__.keccak256(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromString(getSignature(abiItem)));\n}\n/**\n * Throws when ambiguous types are found on overloaded ABI items.\n *\n * @example\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from(['function foo(address)', 'function foo(bytes20)'])\n * AbiFunction.fromAbi(foo, 'foo', {\n *   args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],\n * })\n * // @error: AbiItem.AmbiguityError: Found ambiguous types in overloaded ABI Items.\n * // @error: `bytes20` in `foo(bytes20)`, and\n * // @error: `address` in `foo(address)`\n * // @error: These types encode differently and cannot be distinguished at runtime.\n * // @error: Remove one of the ambiguous items in the ABI.\n * ```\n *\n * ### Solution\n *\n * Remove one of the ambiguous types from the ABI.\n *\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function foo(bytes20)' // [!code --]\n * ])\n * AbiFunction.fromAbi(foo, 'foo', {\n *   args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],\n * })\n * // @error: AbiItem.AmbiguityError: Found ambiguous types in overloaded ABI Items.\n * // @error: `bytes20` in `foo(bytes20)`, and\n * // @error: `address` in `foo(address)`\n * // @error: These types encode differently and cannot be distinguished at runtime.\n * // @error: Remove one of the ambiguous items in the ABI.\n * ```\n */ class AmbiguityError extends _Errors_js__WEBPACK_IMPORTED_MODULE_5__.BaseError {\n    constructor(x, y){\n        super(\"Found ambiguous types in overloaded ABI Items.\", {\n            metaMessages: [\n                // TODO: abitype to add support for signature-formatted ABI items.\n                `\\`${x.type}\\` in \\`${_internal_abiItem_js__WEBPACK_IMPORTED_MODULE_3__.normalizeSignature(abitype__WEBPACK_IMPORTED_MODULE_0__.formatAbiItem(x.abiItem))}\\`, and`,\n                `\\`${y.type}\\` in \\`${_internal_abiItem_js__WEBPACK_IMPORTED_MODULE_3__.normalizeSignature(abitype__WEBPACK_IMPORTED_MODULE_0__.formatAbiItem(y.abiItem))}\\``,\n                \"\",\n                \"These types encode differently and cannot be distinguished at runtime.\",\n                \"Remove one of the ambiguous items in the ABI.\"\n            ]\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"AbiItem.AmbiguityError\"\n        });\n    }\n}\n/**\n * Throws when an ABI item is not found in the ABI.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)'\n * ])\n * AbiFunction.fromAbi(foo, 'baz')\n * // @error: AbiItem.NotFoundError: ABI function with name \"baz\" not found.\n * ```\n *\n * ### Solution\n *\n * Ensure the ABI item exists on the ABI.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)',\n *   'function baz(bool)' // [!code ++]\n * ])\n * AbiFunction.fromAbi(foo, 'baz')\n * ```\n */ class NotFoundError extends _Errors_js__WEBPACK_IMPORTED_MODULE_5__.BaseError {\n    constructor({ name, data, type = \"item\" }){\n        const selector = (()=>{\n            if (name) return ` with name \"${name}\"`;\n            if (data) return ` with data \"${data}\"`;\n            return \"\";\n        })();\n        super(`ABI ${type}${selector} not found.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"AbiItem.NotFoundError\"\n        });\n    }\n}\n/**\n * Throws when the selector size is invalid.\n *\n * @example\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)'\n * ])\n * AbiFunction.fromAbi(foo, '0xaaa')\n * // @error: AbiItem.InvalidSelectorSizeError: Selector size is invalid. Expected 4 bytes. Received 2 bytes (\"0xaaa\").\n * ```\n *\n * ### Solution\n *\n * Ensure the selector size is 4 bytes.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)'\n * ])\n * AbiFunction.fromAbi(foo, '0x7af82b1a')\n * ```\n */ class InvalidSelectorSizeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_5__.BaseError {\n    constructor({ data }){\n        super(`Selector size is invalid. Expected 4 bytes. Received ${_Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(data)} bytes (\"${data}\").`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"AbiItem.InvalidSelectorSizeError\"\n        });\n    }\n} //# sourceMappingURL=AbiItem.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0FiaUl0ZW0uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW1DO0FBQ0c7QUFDSjtBQUNGO0FBQ2tCO0FBQ2xEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWdDQyxHQUNNLFNBQVNLLE9BQU9DLE9BQU87SUFDMUIsT0FBT04sa0RBQXFCLENBQUNNO0FBQ2pDO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXNHQyxHQUNNLFNBQVNFLEtBQUtGLE9BQU8sRUFBRUcsVUFBVSxDQUFDLENBQUM7SUFDdEMsTUFBTSxFQUFFQyxVQUFVLElBQUksRUFBRSxHQUFHRDtJQUMzQixNQUFNRSxPQUFPLENBQUM7UUFDVixJQUFJQyxNQUFNQyxPQUFPLENBQUNQLFVBQ2QsT0FBT04saURBQW9CLENBQUNNO1FBQ2hDLElBQUksT0FBT0EsWUFBWSxVQUNuQixPQUFPTixpREFBb0IsQ0FBQ007UUFDaEMsT0FBT0E7SUFDWDtJQUNBLE9BQU87UUFDSCxHQUFHSyxJQUFJO1FBQ1AsR0FBSUQsVUFBVTtZQUFFSyxNQUFNQyxpQkFBaUJMO1FBQU0sSUFBSSxDQUFDLENBQUM7SUFDdkQ7QUFDSjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FrRUMsR0FDTSxTQUFTTSxRQUFRQyxHQUFHLEVBQUVDLElBQUksRUFBRVYsT0FBTztJQUN0QyxNQUFNLEVBQUVXLE9BQU8sRUFBRSxFQUFFVixVQUFVLElBQUksRUFBRSxHQUFJRCxXQUNuQyxDQUFDO0lBQ0wsTUFBTVksYUFBYWxCLDZDQUFZLENBQUNnQixNQUFNO1FBQUVJLFFBQVE7SUFBTTtJQUN0RCxNQUFNQyxXQUFXTixJ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RSxDQUFFO1FBQ2xCLEtBQUssQ0FBQyxDQUFDLHFEQUFxRCxFQUFFekQseUNBQVEsQ0FBQ3lELE1BQU0sU0FBUyxFQUFFQSxLQUFLLEdBQUcsQ0FBQztRQUNqR04sT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxRQUFRO1lBQ2hDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxPQUFPO1FBQ1g7SUFDSjtBQUNKLEVBQ0EsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xhdy13b3Jrcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvQWJpSXRlbS5qcz9lZTUwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGFiaXR5cGUgZnJvbSAnYWJpdHlwZSc7XG5pbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSAnLi9FcnJvcnMuanMnO1xuaW1wb3J0ICogYXMgSGFzaCBmcm9tICcuL0hhc2guanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbmltcG9ydCAqIGFzIGludGVybmFsIGZyb20gJy4vaW50ZXJuYWwvYWJpSXRlbS5qcyc7XG4vKipcbiAqIEZvcm1hdHMgYW4ge0BsaW5rIG94I0FiaUl0ZW0uQWJpSXRlbX0gaW50byBhICoqSHVtYW4gUmVhZGFibGUgQUJJIEl0ZW0qKi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaUl0ZW0gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBmb3JtYXR0ZWQgPSBBYmlJdGVtLmZvcm1hdCh7XG4gKiAgIHR5cGU6ICdmdW5jdGlvbicsXG4gKiAgIG5hbWU6ICdhcHByb3ZlJyxcbiAqICAgc3RhdGVNdXRhYmlsaXR5OiAnbm9ucGF5YWJsZScsXG4gKiAgIGlucHV0czogW1xuICogICAgIHtcbiAqICAgICAgIG5hbWU6ICdzcGVuZGVyJyxcbiAqICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAqICAgICB9LFxuICogICAgIHtcbiAqICAgICAgIG5hbWU6ICdhbW91bnQnLFxuICogICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICogICAgIH0sXG4gKiAgIF0sXG4gKiAgIG91dHB1dHM6IFt7IHR5cGU6ICdib29sJyB9XSxcbiAqIH0pXG4gKlxuICogZm9ybWF0dGVkXG4gKiAvLyAgICBeP1xuICpcbiAqXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYWJpSXRlbSAtIFRoZSBBQkkgSXRlbSB0byBmb3JtYXQuXG4gKiBAcmV0dXJucyBUaGUgZm9ybWF0dGVkIEFCSSBJdGVtICAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXQoYWJpSXRlbSkge1xuICAgIHJldHVybiBhYml0eXBlLmZvcm1hdEFiaUl0ZW0oYWJpSXRlbSk7XG59XG4vKipcbiAqIFBhcnNlcyBhbiBhcmJpdHJhcnkgKipKU09OIEFCSSBJdGVtKiogb3IgKipIdW1hbiBSZWFkYWJsZSBBQkkgSXRlbSoqIGludG8gYSB0eXBlZCB7QGxpbmsgb3gjQWJpSXRlbS5BYmlJdGVtfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEpTT04gQUJJc1xuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlJdGVtIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYWJpSXRlbSA9IEFiaUl0ZW0uZnJvbSh7XG4gKiAgIHR5cGU6ICdmdW5jdGlvbicsXG4gKiAgIG5hbWU6ICdhcHByb3ZlJyxcbiAqICAgc3RhdGVNdXRhYmlsaXR5OiAnbm9ucGF5YWJsZScsXG4gKiAgIGlucHV0czogW1xuICogICAgIHtcbiAqICAgICAgIG5hbWU6ICdzcGVuZGVyJyxcbiAqICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAqICAgICB9LFxuICogICAgIHtcbiAqICAgICAgIG5hbWU6ICdhbW91bnQnLFxuICogICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICogICAgIH0sXG4gKiAgIF0sXG4gKiAgIG91dHB1dHM6IFt7IHR5cGU6ICdib29sJyB9XSxcbiAqIH0pXG4gKlxuICogYWJpSXRlbVxuICogLy9eP1xuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBIdW1hbiBSZWFkYWJsZSBBQklzXG4gKlxuICogQSBIdW1hbiBSZWFkYWJsZSBBQkkgY2FuIGJlIHBhcnNlZCBpbnRvIGEgdHlwZWQgQUJJIG9iamVjdDpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpSXRlbSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGFiaUl0ZW0gPSBBYmlJdGVtLmZyb20oXG4gKiAgICdmdW5jdGlvbiBhcHByb3ZlKGFkZHJlc3Mgc3BlbmRlciwgdWludDI1NiBhbW91bnQpIHJldHVybnMgKGJvb2wpJyAvLyBbIWNvZGUgaGxdXG4gKiApXG4gKlxuICogYWJpSXRlbVxuICogLy9eP1xuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBJdCBpcyBwb3NzaWJsZSB0byBzcGVjaWZ5IGBzdHJ1Y3RgcyBhbG9uZyB3aXRoIHlvdXIgZGVmaW5pdGlvbnM6XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaUl0ZW0gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhYmlJdGVtID0gQWJpSXRlbS5mcm9tKFtcbiAqICAgJ3N0cnVjdCBGb28geyBhZGRyZXNzIHNwZW5kZXI7IHVpbnQyNTYgYW1vdW50OyB9JywgLy8gWyFjb2RlIGhsXVxuICogICAnZnVuY3Rpb24gYXBwcm92ZShGb28gZm9vKSByZXR1cm5zIChib29sKScsXG4gKiBdKVxuICpcbiAqIGFiaUl0ZW1cbiAqIC8vXj9cbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqIGBgYFxuICpcbiAqXG4gKlxuICogQHBhcmFtIGFiaUl0ZW0gLSBUaGUgQUJJIEl0ZW0gdG8gcGFyc2UuXG4gKiBAcmV0dXJucyBUaGUgdHlwZWQgQUJJIEl0ZW0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tKGFiaUl0ZW0sIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgcHJlcGFyZSA9IHRydWUgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgaXRlbSA9ICgoKSA9PiB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFiaUl0ZW0pKVxuICAgICAgICAgICAgcmV0dXJuIGFiaXR5cGUucGFyc2VBYmlJdGVtKGFiaUl0ZW0pO1xuICAgICAgICBpZiAodHlwZW9mIGFiaUl0ZW0gPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIGFiaXR5cGUucGFyc2VBYmlJdGVtKGFiaUl0ZW0pO1xuICAgICAgICByZXR1cm4gYWJpSXRlbTtcbiAgICB9KSgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLml0ZW0sXG4gICAgICAgIC4uLihwcmVwYXJlID8geyBoYXNoOiBnZXRTaWduYXR1cmVIYXNoKGl0ZW0pIH0gOiB7fSksXG4gICAgfTtcbn1cbi8qKlxuICogRXh0cmFjdHMgYW4ge0BsaW5rIG94I0FiaUl0ZW0uQWJpSXRlbX0gZnJvbSBhbiB7QGxpbmsgb3gjQWJpLkFiaX0gZ2l2ZW4gYSBuYW1lIGFuZCBvcHRpb25hbCBhcmd1bWVudHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIEFCSSBJdGVtcyBjYW4gYmUgZXh0cmFjdGVkIGJ5IHRoZWlyIG5hbWUgdXNpbmcgdGhlIGBuYW1lYCBvcHRpb246XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaSwgQWJpSXRlbSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGFiaSA9IEFiaS5mcm9tKFtcbiAqICAgJ2Z1bmN0aW9uIGZvbygpJyxcbiAqICAgJ2V2ZW50IFRyYW5zZmVyKGFkZHJlc3Mgb3duZXIsIGFkZHJlc3MgdG8sIHVpbnQyNTYgdG9rZW5JZCknLFxuICogICAnZnVuY3Rpb24gYmFyKHN0cmluZyBhKSByZXR1cm5zICh1aW50MjU2IHgpJyxcbiAqIF0pXG4gKlxuICogY29uc3QgaXRlbSA9IEFiaUl0ZW0uZnJvbUFiaShhYmksICdUcmFuc2ZlcicpIC8vIFshY29kZSBmb2N1c11cbiAqIC8vICAgIF4/XG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEV4dHJhY3RpbmcgYnkgU2VsZWN0b3JcbiAqXG4gKiBBQkkgSXRlbXMgY2FuIGJlIGV4dHJhY3QgYnkgdGhlaXIgc2VsZWN0b3Igd2hlbiB7QGxpbmsgb3gjSGV4LkhleH0gaXMgcHJvdmlkZWQgdG8gYG5hbWVgLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmksIEFiaUl0ZW0gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhYmkgPSBBYmkuZnJvbShbXG4gKiAgICdmdW5jdGlvbiBmb28oKScsXG4gKiAgICdldmVudCBUcmFuc2ZlcihhZGRyZXNzIG93bmVyLCBhZGRyZXNzIHRvLCB1aW50MjU2IHRva2VuSWQpJyxcbiAqICAgJ2Z1bmN0aW9uIGJhcihzdHJpbmcgYSkgcmV0dXJucyAodWludDI1NiB4KScsXG4gKiBdKVxuICogY29uc3QgaXRlbSA9IEFiaUl0ZW0uZnJvbUFiaShhYmksICcweDA5NWVhN2IzJykgLy8gWyFjb2RlIGZvY3VzXVxuICogLy8gICAgXj9cbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKiBgYGBcbiAqXG4gKiA6Ojpub3RlXG4gKlxuICogRXh0cmFjdGluZyB2aWEgYSBoZXggc2VsZWN0b3IgaXMgdXNlZnVsIHdoZW4gZXh0cmFjdGluZyBhbiBBQkkgSXRlbSBmcm9tIGFuIGBldGhfY2FsbGAgUlBDIHJlc3BvbnNlLFxuICogYSBUcmFuc2FjdGlvbiBgaW5wdXRgLCBvciBmcm9tIEV2ZW50IExvZyBgdG9waWNzYC5cbiAqXG4gKiA6OjpcbiAqXG4gKiBAcGFyYW0gYWJpIC0gVGhlIEFCSSB0byBleHRyYWN0IGZyb20uXG4gKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIChvciBzZWxlY3Rvcikgb2YgdGhlIEFCSSBpdGVtIHRvIGV4dHJhY3QuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEV4dHJhY3Rpb24gb3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBBQkkgaXRlbS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21BYmkoYWJpLCBuYW1lLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBhcmdzID0gW10sIHByZXBhcmUgPSB0cnVlIH0gPSAob3B0aW9ucyA/P1xuICAgICAgICB7fSk7XG4gICAgY29uc3QgaXNTZWxlY3RvciA9IEhleC52YWxpZGF0ZShuYW1lLCB7IHN0cmljdDogZmFsc2UgfSk7XG4gICAgY29uc3QgYWJpSXRlbXMgPSBhYmkuZmlsdGVyKChhYmlJdGVtKSA9PiB7XG4gICAgICAgIGlmIChpc1NlbGVjdG9yKSB7XG4gICAgICAgICAgICBpZiAoYWJpSXRlbS50eXBlID09PSAnZnVuY3Rpb24nIHx8IGFiaUl0ZW0udHlwZSA9PT0gJ2Vycm9yJylcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0U2VsZWN0b3IoYWJpSXRlbSkgPT09IEhleC5zbGljZShuYW1lLCAwLCA0KTtcbiAgICAgICAgICAgIGlmIChhYmlJdGVtLnR5cGUgPT09ICdldmVudCcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFNpZ25hdHVyZUhhc2goYWJpSXRlbSkgPT09IG5hbWU7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICduYW1lJyBpbiBhYmlJdGVtICYmIGFiaUl0ZW0ubmFtZSA9PT0gbmFtZTtcbiAgICB9KTtcbiAgICBpZiAoYWJpSXRlbXMubGVuZ3RoID09PSAwKVxuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFcnJvcih7IG5hbWU6IG5hbWUgfSk7XG4gICAgaWYgKGFiaUl0ZW1zLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmFiaUl0ZW1zWzBdLFxuICAgICAgICAgICAgLi4uKHByZXBhcmUgPyB7IGhhc2g6IGdldFNpZ25hdHVyZUhhc2goYWJpSXRlbXNbMF0pIH0gOiB7fSksXG4gICAgICAgIH07XG4gICAgbGV0IG1hdGNoZWRBYmlJdGVtO1xuICAgIGZvciAoY29uc3QgYWJpSXRlbSBvZiBhYmlJdGVtcykge1xuICAgICAgICBpZiAoISgnaW5wdXRzJyBpbiBhYmlJdGVtKSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIWFyZ3MgfHwgYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGlmICghYWJpSXRlbS5pbnB1dHMgfHwgYWJpSXRlbS5pbnB1dHMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmFiaUl0ZW0sXG4gICAgICAgICAgICAgICAgICAgIC4uLihwcmVwYXJlID8geyBoYXNoOiBnZXRTaWduYXR1cmVIYXNoKGFiaUl0ZW0pIH0gOiB7fSksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYWJpSXRlbS5pbnB1dHMpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKGFiaUl0ZW0uaW5wdXRzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoYWJpSXRlbS5pbnB1dHMubGVuZ3RoICE9PSBhcmdzLmxlbmd0aClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBtYXRjaGVkID0gYXJncy5ldmVyeSgoYXJnLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYWJpUGFyYW1ldGVyID0gJ2lucHV0cycgaW4gYWJpSXRlbSAmJiBhYmlJdGVtLmlucHV0c1tpbmRleF07XG4gICAgICAgICAgICBpZiAoIWFiaVBhcmFtZXRlcilcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWwuaXNBcmdPZlR5cGUoYXJnLCBhYmlQYXJhbWV0ZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBhbWJpZ3VpdHkgYWdhaW5zdCBhbHJlYWR5IG1hdGNoZWQgcGFyYW1ldGVycyAoZS5nLiBgYWRkcmVzc2AgdnMgYGJ5dGVzMjBgKS5cbiAgICAgICAgICAgIGlmIChtYXRjaGVkQWJpSXRlbSAmJlxuICAgICAgICAgICAgICAgICdpbnB1dHMnIGluIG1hdGNoZWRBYmlJdGVtICYmXG4gICAgICAgICAgICAgICAgbWF0Y2hlZEFiaUl0ZW0uaW5wdXRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYW1iaWd1b3VzVHlwZXMgPSBpbnRlcm5hbC5nZXRBbWJpZ3VvdXNUeXBlcyhhYmlJdGVtLmlucHV0cywgbWF0Y2hlZEFiaUl0ZW0uaW5wdXRzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICBpZiAoYW1iaWd1b3VzVHlwZXMpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBBbWJpZ3VpdHlFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBhYmlJdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogYW1iaWd1b3VzVHlwZXNbMF0sXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFiaUl0ZW06IG1hdGNoZWRBYmlJdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogYW1iaWd1b3VzVHlwZXNbMV0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWF0Y2hlZEFiaUl0ZW0gPSBhYmlJdGVtO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGFiaUl0ZW0gPSAoKCkgPT4ge1xuICAgICAgICBpZiAobWF0Y2hlZEFiaUl0ZW0pXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlZEFiaUl0ZW07XG4gICAgICAgIGNvbnN0IFthYmlJdGVtLCAuLi5vdmVybG9hZHNdID0gYWJpSXRlbXM7XG4gICAgICAgIHJldHVybiB7IC4uLmFiaUl0ZW0sIG92ZXJsb2FkcyB9O1xuICAgIH0pKCk7XG4gICAgaWYgKCFhYmlJdGVtKVxuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFcnJvcih7IG5hbWU6IG5hbWUgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uYWJpSXRlbSxcbiAgICAgICAgLi4uKHByZXBhcmUgPyB7IGhhc2g6IGdldFNpZ25hdHVyZUhhc2goYWJpSXRlbSkgfSA6IHt9KSxcbiAgICB9O1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzZG9jL3JlcXVpcmUtanNkb2NcbmV4cG9ydCBmdW5jdGlvbiBnZXRTZWxlY3RvciguLi5wYXJhbWV0ZXJzKSB7XG4gICAgY29uc3QgYWJpSXRlbSA9ICgoKSA9PiB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtZXRlcnNbMF0pKSB7XG4gICAgICAgICAgICBjb25zdCBbYWJpLCBuYW1lXSA9IHBhcmFtZXRlcnM7XG4gICAgICAgICAgICByZXR1cm4gZnJvbUFiaShhYmksIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJhbWV0ZXJzWzBdO1xuICAgIH0pKCk7XG4gICAgcmV0dXJuIEhleC5zbGljZShnZXRTaWduYXR1cmVIYXNoKGFiaUl0ZW0pLCAwLCA0KTtcbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc2RvYy9yZXF1aXJlLWpzZG9jXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2lnbmF0dXJlKC4uLnBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBhYmlJdGVtID0gKCgpID0+IHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW1ldGVyc1swXSkpIHtcbiAgICAgICAgICAgIGNvbnN0IFthYmksIG5hbWVdID0gcGFyYW1ldGVycztcbiAgICAgICAgICAgIHJldHVybiBmcm9tQWJpKGFiaSwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmFtZXRlcnNbMF07XG4gICAgfSkoKTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSAoKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGFiaUl0ZW0gPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIGFiaUl0ZW07XG4gICAgICAgIHJldHVybiBhYml0eXBlLmZvcm1hdEFiaUl0ZW0oYWJpSXRlbSk7XG4gICAgfSkoKTtcbiAgICByZXR1cm4gaW50ZXJuYWwubm9ybWFsaXplU2lnbmF0dXJlKHNpZ25hdHVyZSk7XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvY1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNpZ25hdHVyZUhhc2goLi4ucGFyYW1ldGVycykge1xuICAgIGNvbnN0IGFiaUl0ZW0gPSAoKCkgPT4ge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbWV0ZXJzWzBdKSkge1xuICAgICAgICAgICAgY29uc3QgW2FiaSwgbmFtZV0gPSBwYXJhbWV0ZXJzO1xuICAgICAgICAgICAgcmV0dXJuIGZyb21BYmkoYWJpLCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyYW1ldGVyc1swXTtcbiAgICB9KSgpO1xuICAgIGlmICh0eXBlb2YgYWJpSXRlbSAhPT0gJ3N0cmluZycgJiYgJ2hhc2gnIGluIGFiaUl0ZW0gJiYgYWJpSXRlbS5oYXNoKVxuICAgICAgICByZXR1cm4gYWJpSXRlbS5oYXNoO1xuICAgIHJldHVybiBIYXNoLmtlY2NhazI1NihIZXguZnJvbVN0cmluZyhnZXRTaWduYXR1cmUoYWJpSXRlbSkpKTtcbn1cbi8qKlxuICogVGhyb3dzIHdoZW4gYW1iaWd1b3VzIHR5cGVzIGFyZSBmb3VuZCBvbiBvdmVybG9hZGVkIEFCSSBpdGVtcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaSwgQWJpRnVuY3Rpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBmb28gPSBBYmkuZnJvbShbJ2Z1bmN0aW9uIGZvbyhhZGRyZXNzKScsICdmdW5jdGlvbiBmb28oYnl0ZXMyMCknXSlcbiAqIEFiaUZ1bmN0aW9uLmZyb21BYmkoZm9vLCAnZm9vJywge1xuICogICBhcmdzOiBbJzB4QTBDZjc5ODgxNkQ0YjliOTg2NmI1MzMwRUVhNDZhMTgzODJmMjUxZSddLFxuICogfSlcbiAqIC8vIEBlcnJvcjogQWJpSXRlbS5BbWJpZ3VpdHlFcnJvcjogRm91bmQgYW1iaWd1b3VzIHR5cGVzIGluIG92ZXJsb2FkZWQgQUJJIEl0ZW1zLlxuICogLy8gQGVycm9yOiBgYnl0ZXMyMGAgaW4gYGZvbyhieXRlczIwKWAsIGFuZFxuICogLy8gQGVycm9yOiBgYWRkcmVzc2AgaW4gYGZvbyhhZGRyZXNzKWBcbiAqIC8vIEBlcnJvcjogVGhlc2UgdHlwZXMgZW5jb2RlIGRpZmZlcmVudGx5IGFuZCBjYW5ub3QgYmUgZGlzdGluZ3Vpc2hlZCBhdCBydW50aW1lLlxuICogLy8gQGVycm9yOiBSZW1vdmUgb25lIG9mIHRoZSBhbWJpZ3VvdXMgaXRlbXMgaW4gdGhlIEFCSS5cbiAqIGBgYFxuICpcbiAqICMjIyBTb2x1dGlvblxuICpcbiAqIFJlbW92ZSBvbmUgb2YgdGhlIGFtYmlndW91cyB0eXBlcyBmcm9tIHRoZSBBQkkuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaSwgQWJpRnVuY3Rpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBmb28gPSBBYmkuZnJvbShbXG4gKiAgICdmdW5jdGlvbiBmb28oYWRkcmVzcyknLFxuICogICAnZnVuY3Rpb24gZm9vKGJ5dGVzMjApJyAvLyBbIWNvZGUgLS1dXG4gKiBdKVxuICogQWJpRnVuY3Rpb24uZnJvbUFiaShmb28sICdmb28nLCB7XG4gKiAgIGFyZ3M6IFsnMHhBMENmNzk4ODE2RDRiOWI5ODY2YjUzMzBFRWE0NmExODM4MmYyNTFlJ10sXG4gKiB9KVxuICogLy8gQGVycm9yOiBBYmlJdGVtLkFtYmlndWl0eUVycm9yOiBGb3VuZCBhbWJpZ3VvdXMgdHlwZXMgaW4gb3ZlcmxvYWRlZCBBQkkgSXRlbXMuXG4gKiAvLyBAZXJyb3I6IGBieXRlczIwYCBpbiBgZm9vKGJ5dGVzMjApYCwgYW5kXG4gKiAvLyBAZXJyb3I6IGBhZGRyZXNzYCBpbiBgZm9vKGFkZHJlc3MpYFxuICogLy8gQGVycm9yOiBUaGVzZSB0eXBlcyBlbmNvZGUgZGlmZmVyZW50bHkgYW5kIGNhbm5vdCBiZSBkaXN0aW5ndWlzaGVkIGF0IHJ1bnRpbWUuXG4gKiAvLyBAZXJyb3I6IFJlbW92ZSBvbmUgb2YgdGhlIGFtYmlndW91cyBpdGVtcyBpbiB0aGUgQUJJLlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBBbWJpZ3VpdHlFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHgsIHkpIHtcbiAgICAgICAgc3VwZXIoJ0ZvdW5kIGFtYmlndW91cyB0eXBlcyBpbiBvdmVybG9hZGVkIEFCSSBJdGVtcy4nLCB7XG4gICAgICAgICAgICBtZXRhTWVzc2FnZXM6IFtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBhYml0eXBlIHRvIGFkZCBzdXBwb3J0IGZvciBzaWduYXR1cmUtZm9ybWF0dGVkIEFCSSBpdGVtcy5cbiAgICAgICAgICAgICAgICBgXFxgJHt4LnR5cGV9XFxgIGluIFxcYCR7aW50ZXJuYWwubm9ybWFsaXplU2lnbmF0dXJlKGFiaXR5cGUuZm9ybWF0QWJpSXRlbSh4LmFiaUl0ZW0pKX1cXGAsIGFuZGAsXG4gICAgICAgICAgICAgICAgYFxcYCR7eS50eXBlfVxcYCBpbiBcXGAke2ludGVybmFsLm5vcm1hbGl6ZVNpZ25hdHVyZShhYml0eXBlLmZvcm1hdEFiaUl0ZW0oeS5hYmlJdGVtKSl9XFxgYCxcbiAgICAgICAgICAgICAgICAnJyxcbiAgICAgICAgICAgICAgICAnVGhlc2UgdHlwZXMgZW5jb2RlIGRpZmZlcmVudGx5IGFuZCBjYW5ub3QgYmUgZGlzdGluZ3Vpc2hlZCBhdCBydW50aW1lLicsXG4gICAgICAgICAgICAgICAgJ1JlbW92ZSBvbmUgb2YgdGhlIGFtYmlndW91cyBpdGVtcyBpbiB0aGUgQUJJLicsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0FiaUl0ZW0uQW1iaWd1aXR5RXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3dzIHdoZW4gYW4gQUJJIGl0ZW0gaXMgbm90IGZvdW5kIGluIHRoZSBBQkkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IEFiaSwgQWJpRnVuY3Rpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBmb28gPSBBYmkuZnJvbShbXG4gKiAgICdmdW5jdGlvbiBmb28oYWRkcmVzcyknLFxuICogICAnZnVuY3Rpb24gYmFyKHVpbnQpJ1xuICogXSlcbiAqIEFiaUZ1bmN0aW9uLmZyb21BYmkoZm9vLCAnYmF6JylcbiAqIC8vIEBlcnJvcjogQWJpSXRlbS5Ob3RGb3VuZEVycm9yOiBBQkkgZnVuY3Rpb24gd2l0aCBuYW1lIFwiYmF6XCIgbm90IGZvdW5kLlxuICogYGBgXG4gKlxuICogIyMjIFNvbHV0aW9uXG4gKlxuICogRW5zdXJlIHRoZSBBQkkgaXRlbSBleGlzdHMgb24gdGhlIEFCSS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBBYmksIEFiaUZ1bmN0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZm9vID0gQWJpLmZyb20oW1xuICogICAnZnVuY3Rpb24gZm9vKGFkZHJlc3MpJyxcbiAqICAgJ2Z1bmN0aW9uIGJhcih1aW50KScsXG4gKiAgICdmdW5jdGlvbiBiYXooYm9vbCknIC8vIFshY29kZSArK11cbiAqIF0pXG4gKiBBYmlGdW5jdGlvbi5mcm9tQWJpKGZvbywgJ2JheicpXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIE5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IG5hbWUsIGRhdGEsIHR5cGUgPSAnaXRlbScsIH0pIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSAoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKG5hbWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGAgd2l0aCBuYW1lIFwiJHtuYW1lfVwiYDtcbiAgICAgICAgICAgIGlmIChkYXRhKVxuICAgICAgICAgICAgICAgIHJldHVybiBgIHdpdGggZGF0YSBcIiR7ZGF0YX1cImA7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIHN1cGVyKGBBQkkgJHt0eXBlfSR7c2VsZWN0b3J9IG5vdCBmb3VuZC5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0FiaUl0ZW0uTm90Rm91bmRFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd3Mgd2hlbiB0aGUgc2VsZWN0b3Igc2l6ZSBpcyBpbnZhbGlkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpLCBBYmlGdW5jdGlvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGZvbyA9IEFiaS5mcm9tKFtcbiAqICAgJ2Z1bmN0aW9uIGZvbyhhZGRyZXNzKScsXG4gKiAgICdmdW5jdGlvbiBiYXIodWludCknXG4gKiBdKVxuICogQWJpRnVuY3Rpb24uZnJvbUFiaShmb28sICcweGFhYScpXG4gKiAvLyBAZXJyb3I6IEFiaUl0ZW0uSW52YWxpZFNlbGVjdG9yU2l6ZUVycm9yOiBTZWxlY3RvciBzaXplIGlzIGludmFsaWQuIEV4cGVjdGVkIDQgYnl0ZXMuIFJlY2VpdmVkIDIgYnl0ZXMgKFwiMHhhYWFcIikuXG4gKiBgYGBcbiAqXG4gKiAjIyMgU29sdXRpb25cbiAqXG4gKiBFbnN1cmUgdGhlIHNlbGVjdG9yIHNpemUgaXMgNCBieXRlcy5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBBYmksIEFiaUZ1bmN0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZm9vID0gQWJpLmZyb20oW1xuICogICAnZnVuY3Rpb24gZm9vKGFkZHJlc3MpJyxcbiAqICAgJ2Z1bmN0aW9uIGJhcih1aW50KSdcbiAqIF0pXG4gKiBBYmlGdW5jdGlvbi5mcm9tQWJpKGZvbywgJzB4N2FmODJiMWEnKVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkU2VsZWN0b3JTaXplRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGRhdGEgfSkge1xuICAgICAgICBzdXBlcihgU2VsZWN0b3Igc2l6ZSBpcyBpbnZhbGlkLiBFeHBlY3RlZCA0IGJ5dGVzLiBSZWNlaXZlZCAke0hleC5zaXplKGRhdGEpfSBieXRlcyAoXCIke2RhdGF9XCIpLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQWJpSXRlbS5JbnZhbGlkU2VsZWN0b3JTaXplRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFiaUl0ZW0uanMubWFwIl0sIm5hbWVzIjpbImFiaXR5cGUiLCJFcnJvcnMiLCJIYXNoIiwiSGV4IiwiaW50ZXJuYWwiLCJmb3JtYXQiLCJhYmlJdGVtIiwiZm9ybWF0QWJpSXRlbSIsImZyb20iLCJvcHRpb25zIiwicHJlcGFyZSIsIml0ZW0iLCJBcnJheSIsImlzQXJyYXkiLCJwYXJzZUFiaUl0ZW0iLCJoYXNoIiwiZ2V0U2lnbmF0dXJlSGFzaCIsImZyb21BYmkiLCJhYmkiLCJuYW1lIiwiYXJncyIsImlzU2VsZWN0b3IiLCJ2YWxpZGF0ZSIsInN0cmljdCIsImFiaUl0ZW1zIiwiZmlsdGVyIiwidHlwZSIsImdldFNlbGVjdG9yIiwic2xpY2UiLCJsZW5ndGgiLCJOb3RGb3VuZEVycm9yIiwibWF0Y2hlZEFiaUl0ZW0iLCJpbnB1dHMiLCJtYXRjaGVkIiwiZXZlcnkiLCJhcmciLCJpbmRleCIsImFiaVBhcmFtZXRlciIsImlzQXJnT2ZUeXBlIiwiYW1iaWd1b3VzVHlwZXMiLCJnZXRBbWJpZ3VvdXNUeXBlcyIsIkFtYmlndWl0eUVycm9yIiwib3ZlcmxvYWRzIiwicGFyYW1ldGVycyIsImdldFNpZ25hdHVyZSIsInNpZ25hdHVyZSIsIm5vcm1hbGl6ZVNpZ25hdHVyZSIsImtlY2NhazI1NiIsImZyb21TdHJpbmciLCJCYXNlRXJyb3IiLCJjb25zdHJ1Y3RvciIsIngiLCJ5IiwibWV0YU1lc3NhZ2VzIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJ2YWx1ZSIsImRhdGEiLCJzZWxlY3RvciIsIkludmFsaWRTZWxlY3RvclNpemVFcnJvciIsInNpemUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/AbiItem.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/AbiParameters.js":
/*!****************************************************!*\
  !*** ./node_modules/ox/_esm/core/AbiParameters.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ArrayLengthMismatchError: () => (/* binding */ ArrayLengthMismatchError),\n/* harmony export */   BytesSizeMismatchError: () => (/* binding */ BytesSizeMismatchError),\n/* harmony export */   DataSizeTooSmallError: () => (/* binding */ DataSizeTooSmallError),\n/* harmony export */   InvalidArrayError: () => (/* binding */ InvalidArrayError),\n/* harmony export */   InvalidTypeError: () => (/* binding */ InvalidTypeError),\n/* harmony export */   LengthMismatchError: () => (/* binding */ LengthMismatchError),\n/* harmony export */   ZeroDataError: () => (/* binding */ ZeroDataError),\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encode: () => (/* binding */ encode),\n/* harmony export */   encodePacked: () => (/* binding */ encodePacked),\n/* harmony export */   format: () => (/* binding */ format),\n/* harmony export */   from: () => (/* binding */ from)\n/* harmony export */ });\n/* harmony import */ var abitype__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! abitype */ \"(ssr)/./node_modules/abitype/dist/esm/human-readable/formatAbiParameters.js\");\n/* harmony import */ var abitype__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! abitype */ \"(ssr)/./node_modules/abitype/dist/esm/human-readable/parseAbiParameters.js\");\n/* harmony import */ var _Address_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Address.js */ \"(ssr)/./node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _internal_abiParameters_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/abiParameters.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/abiParameters.js\");\n/* harmony import */ var _internal_cursor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/cursor.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/cursor.js\");\n/* harmony import */ var _Solidity_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Solidity.js */ \"(ssr)/./node_modules/ox/_esm/core/Solidity.js\");\n\n\n\n\n\n\n\n\n// eslint-disable-next-line jsdoc/require-jsdoc\nfunction decode(parameters, data, options = {}) {\n    const { as = \"Array\", checksumAddress = false } = options;\n    const bytes = typeof data === \"string\" ? _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.fromHex(data) : data;\n    const cursor = _internal_cursor_js__WEBPACK_IMPORTED_MODULE_1__.create(bytes);\n    if (_Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(bytes) === 0 && parameters.length > 0) throw new ZeroDataError();\n    if (_Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(bytes) && _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(bytes) < 32) throw new DataSizeTooSmallError({\n        data: typeof data === \"string\" ? data : _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(data),\n        parameters: parameters,\n        size: _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(bytes)\n    });\n    let consumed = 0;\n    const values = as === \"Array\" ? [] : {};\n    for(let i = 0; i < parameters.length; ++i){\n        const param = parameters[i];\n        cursor.setPosition(consumed);\n        const [data, consumed_] = _internal_abiParameters_js__WEBPACK_IMPORTED_MODULE_3__.decodeParameter(cursor, param, {\n            checksumAddress,\n            staticPosition: 0\n        });\n        consumed += consumed_;\n        if (as === \"Array\") values.push(data);\n        else values[param.name ?? i] = data;\n    }\n    return values;\n}\n/**\n * Encodes primitive values into ABI encoded data as per the [Application Binary Interface (ABI) Specification](https://docs.soliditylang.org/en/latest/abi-spec).\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const data = AbiParameters.encode(\n *   AbiParameters.from(['string', 'uint', 'bool']),\n *   ['wagmi', 420n, true],\n * )\n * ```\n *\n * @example\n * ### JSON Parameters\n *\n * Specify **JSON ABI** Parameters as schema:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const data = AbiParameters.encode(\n *   [\n *     { type: 'string', name: 'name' },\n *     { type: 'uint', name: 'age' },\n *     { type: 'bool', name: 'isOwner' },\n *   ],\n *   ['wagmi', 420n, true],\n * )\n * ```\n *\n * @param parameters - The set of ABI parameters to encode, in the shape of the `inputs` or `outputs` attribute of an ABI Item. These parameters must include valid [ABI types](https://docs.soliditylang.org/en/latest/types.html).\n * @param values - The set of primitive values that correspond to the ABI types defined in `parameters`.\n * @returns ABI encoded data.\n */ function encode(parameters, values, options) {\n    const { checksumAddress = false } = options ?? {};\n    if (parameters.length !== values.length) throw new LengthMismatchError({\n        expectedLength: parameters.length,\n        givenLength: values.length\n    });\n    // Prepare the parameters to determine dynamic types to encode.\n    const preparedParameters = _internal_abiParameters_js__WEBPACK_IMPORTED_MODULE_3__.prepareParameters({\n        checksumAddress,\n        parameters: parameters,\n        values: values\n    });\n    const data = _internal_abiParameters_js__WEBPACK_IMPORTED_MODULE_3__.encode(preparedParameters);\n    if (data.length === 0) return \"0x\";\n    return data;\n}\n/**\n * Encodes an array of primitive values to a [packed ABI encoding](https://docs.soliditylang.org/en/latest/abi-spec.html#non-standard-packed-mode).\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const encoded = AbiParameters.encodePacked(\n *   ['address', 'string'],\n *   ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 'hello world'],\n * )\n * // @log: '0xd8da6bf26964af9d7eed9e03e53415d37aa9604568656c6c6f20776f726c64'\n * ```\n *\n * @param types - Set of ABI types to pack encode.\n * @param values - The set of primitive values that correspond to the ABI types defined in `types`.\n * @returns The encoded packed data.\n */ function encodePacked(types, values) {\n    if (types.length !== values.length) throw new LengthMismatchError({\n        expectedLength: types.length,\n        givenLength: values.length\n    });\n    const data = [];\n    for(let i = 0; i < types.length; i++){\n        const type = types[i];\n        const value = values[i];\n        data.push(encodePacked.encode(type, value));\n    }\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(...data);\n}\n(function(encodePacked) {\n    // eslint-disable-next-line jsdoc/require-jsdoc\n    function encode(type, value, isArray = false) {\n        if (type === \"address\") {\n            const address = value;\n            _Address_js__WEBPACK_IMPORTED_MODULE_4__.assert(address);\n            return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.padLeft(address.toLowerCase(), isArray ? 32 : 0);\n        }\n        if (type === \"string\") return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromString(value);\n        if (type === \"bytes\") return value;\n        if (type === \"bool\") return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.padLeft(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBoolean(value), isArray ? 32 : 1);\n        const intMatch = type.match(_Solidity_js__WEBPACK_IMPORTED_MODULE_5__.integerRegex);\n        if (intMatch) {\n            const [_type, baseType, bits = \"256\"] = intMatch;\n            const size = Number.parseInt(bits, 10) / 8;\n            return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(value, {\n                size: isArray ? 32 : size,\n                signed: baseType === \"int\"\n            });\n        }\n        const bytesMatch = type.match(_Solidity_js__WEBPACK_IMPORTED_MODULE_5__.bytesRegex);\n        if (bytesMatch) {\n            const [_type, size] = bytesMatch;\n            if (Number.parseInt(size, 10) !== (value.length - 2) / 2) throw new BytesSizeMismatchError({\n                expectedSize: Number.parseInt(size, 10),\n                value: value\n            });\n            return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.padRight(value, isArray ? 32 : 0);\n        }\n        const arrayMatch = type.match(_Solidity_js__WEBPACK_IMPORTED_MODULE_5__.arrayRegex);\n        if (arrayMatch && Array.isArray(value)) {\n            const [_type, childType] = arrayMatch;\n            const data = [];\n            for(let i = 0; i < value.length; i++){\n                data.push(encode(childType, value[i], true));\n            }\n            if (data.length === 0) return \"0x\";\n            return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(...data);\n        }\n        throw new InvalidTypeError(type);\n    }\n    encodePacked.encode = encode;\n})(encodePacked || (encodePacked = {}));\n/**\n * Formats {@link ox#AbiParameters.AbiParameters} into **Human Readable ABI Parameters**.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const formatted = AbiParameters.format([\n *   {\n *     name: 'spender',\n *     type: 'address',\n *   },\n *   {\n *     name: 'amount',\n *     type: 'uint256',\n *   },\n * ])\n *\n * formatted\n * //    ^?\n *\n *\n * ```\n *\n * @param parameters - The ABI Parameters to format.\n * @returns The formatted ABI Parameters  .\n */ function format(parameters) {\n    return abitype__WEBPACK_IMPORTED_MODULE_6__.formatAbiParameters(parameters);\n}\n/**\n * Parses arbitrary **JSON ABI Parameters** or **Human Readable ABI Parameters** into typed {@link ox#AbiParameters.AbiParameters}.\n *\n * @example\n * ### JSON Parameters\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const parameters = AbiParameters.from([\n *   {\n *     name: 'spender',\n *     type: 'address',\n *   },\n *   {\n *     name: 'amount',\n *     type: 'uint256',\n *   },\n * ])\n *\n * parameters\n * //^?\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable Parameters\n *\n * Human Readable ABI Parameters can be parsed into a typed {@link ox#AbiParameters.AbiParameters}:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const parameters = AbiParameters.from('address spender, uint256 amount')\n *\n * parameters\n * //^?\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * It is possible to specify `struct`s along with your definitions:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const parameters = AbiParameters.from([\n *   'struct Foo { address spender; uint256 amount; }', // [!code hl]\n *   'Foo foo, address bar',\n * ])\n *\n * parameters\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n *\n *\n * @param parameters - The ABI Parameters to parse.\n * @returns The typed ABI Parameters.\n */ function from(parameters) {\n    if (Array.isArray(parameters) && typeof parameters[0] === \"string\") return abitype__WEBPACK_IMPORTED_MODULE_7__.parseAbiParameters(parameters);\n    if (typeof parameters === \"string\") return abitype__WEBPACK_IMPORTED_MODULE_7__.parseAbiParameters(parameters);\n    return parameters;\n}\n/**\n * Throws when the data size is too small for the given parameters.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x010f')\n * //                                             ‚Üë ‚ùå 2 bytes\n * // @error: AbiParameters.DataSizeTooSmallError: Data size of 2 bytes is too small for given parameters.\n * // @error: Params: (uint256)\n * // @error: Data:   0x010f (2 bytes)\n * ```\n *\n * ### Solution\n *\n * Pass a valid data size.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x00000000000000000000000000000000000000000000000000000000000010f')\n * //                                             ‚Üë ‚úÖ 32 bytes\n * ```\n */ class DataSizeTooSmallError extends _Errors_js__WEBPACK_IMPORTED_MODULE_8__.BaseError {\n    constructor({ data, parameters, size }){\n        super(`Data size of ${size} bytes is too small for given parameters.`, {\n            metaMessages: [\n                `Params: (${abitype__WEBPACK_IMPORTED_MODULE_6__.formatAbiParameters(parameters)})`,\n                `Data:   ${data} (${size} bytes)`\n            ]\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"AbiParameters.DataSizeTooSmallError\"\n        });\n    }\n}\n/**\n * Throws when zero data is provided, but data is expected.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x')\n * //                                           ‚Üë ‚ùå zero data\n * // @error: AbiParameters.DataSizeTooSmallError: Data size of 2 bytes is too small for given parameters.\n * // @error: Params: (uint256)\n * // @error: Data:   0x010f (2 bytes)\n * ```\n *\n * ### Solution\n *\n * Pass valid data.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x00000000000000000000000000000000000000000000000000000000000010f')\n * //                                             ‚Üë ‚úÖ 32 bytes\n * ```\n */ class ZeroDataError extends _Errors_js__WEBPACK_IMPORTED_MODULE_8__.BaseError {\n    constructor(){\n        super('Cannot decode zero data (\"0x\") with ABI parameters.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"AbiParameters.ZeroDataError\"\n        });\n    }\n}\n/**\n * The length of the array value does not match the length specified in the corresponding ABI parameter.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from('uint256[3]'), [[69n, 420n]])\n * //                                               ‚Üë expected: 3  ‚Üë ‚ùå length: 2\n * // @error: AbiParameters.ArrayLengthMismatchError: ABI encoding array length mismatch\n * // @error: for type `uint256[3]`. Expected: `3`. Given: `2`.\n * ```\n *\n * ### Solution\n *\n * Pass an array of the correct length.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['uint256[3]']), [[69n, 420n, 69n]])\n * //                                                         ‚Üë ‚úÖ length: 3\n * ```\n */ class ArrayLengthMismatchError extends _Errors_js__WEBPACK_IMPORTED_MODULE_8__.BaseError {\n    constructor({ expectedLength, givenLength, type }){\n        super(`Array length mismatch for type \\`${type}\\`. Expected: \\`${expectedLength}\\`. Given: \\`${givenLength}\\`.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"AbiParameters.ArrayLengthMismatchError\"\n        });\n    }\n}\n/**\n * The size of the bytes value does not match the size specified in the corresponding ABI parameter.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from('bytes8'), [['0xdeadbeefdeadbeefdeadbeef']])\n * //                                            ‚Üë expected: 8 bytes  ‚Üë ‚ùå size: 12 bytes\n * // @error: BytesSizeMismatchError: Size of bytes \"0xdeadbeefdeadbeefdeadbeef\"\n * // @error: (bytes12) does not match expected size (bytes8).\n * ```\n *\n * ### Solution\n *\n * Pass a bytes value of the correct size.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['bytes8']), ['0xdeadbeefdeadbeef'])\n * //                                                       ‚Üë ‚úÖ size: 8 bytes\n * ```\n */ class BytesSizeMismatchError extends _Errors_js__WEBPACK_IMPORTED_MODULE_8__.BaseError {\n    constructor({ expectedSize, value }){\n        super(`Size of bytes \"${value}\" (bytes${_Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(value)}) does not match expected size (bytes${expectedSize}).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"AbiParameters.BytesSizeMismatchError\"\n        });\n    }\n}\n/**\n * The length of the values to encode does not match the length of the ABI parameters.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['string', 'uint256']), ['hello'])\n * // @error: LengthMismatchError: ABI encoding params/values length mismatch.\n * // @error: Expected length (params): 2\n * // @error: Given length (values): 1\n * ```\n *\n * ### Solution\n *\n * Pass the correct number of values to encode.\n *\n * ### Solution\n *\n * Pass a [valid ABI type](https://docs.soliditylang.org/en/develop/abi-spec.html#types).\n */ class LengthMismatchError extends _Errors_js__WEBPACK_IMPORTED_MODULE_8__.BaseError {\n    constructor({ expectedLength, givenLength }){\n        super([\n            \"ABI encoding parameters/values length mismatch.\",\n            `Expected length (parameters): ${expectedLength}`,\n            `Given length (values): ${givenLength}`\n        ].join(\"\\n\"));\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"AbiParameters.LengthMismatchError\"\n        });\n    }\n}\n/**\n * The value provided is not a valid array as specified in the corresponding ABI parameter.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['uint256[3]']), [69])\n * ```\n *\n * ### Solution\n *\n * Pass an array value.\n */ class InvalidArrayError extends _Errors_js__WEBPACK_IMPORTED_MODULE_8__.BaseError {\n    constructor(value){\n        super(`Value \\`${value}\\` is not a valid array.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"AbiParameters.InvalidArrayError\"\n        });\n    }\n}\n/**\n * Throws when the ABI parameter type is invalid.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'lol' }], '0x00000000000000000000000000000000000000000000000000000000000010f')\n * //                             ‚Üë ‚ùå invalid type\n * // @error: AbiParameters.InvalidTypeError: Type `lol` is not a valid ABI Type.\n * ```\n */ class InvalidTypeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_8__.BaseError {\n    constructor(type){\n        super(`Type \\`${type}\\` is not a valid ABI Type.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"AbiParameters.InvalidTypeError\"\n        });\n    }\n} //# sourceMappingURL=AbiParameters.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0FiaVBhcmFtZXRlcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW1DO0FBQ0s7QUFDSjtBQUNFO0FBQ047QUFDd0I7QUFDVDtBQUNMO0FBQzFDLCtDQUErQztBQUN4QyxTQUFTUSxPQUFPQyxVQUFVLEVBQUVDLElBQUksRUFBRUMsVUFBVSxDQUFDLENBQUM7SUFDakQsTUFBTSxFQUFFQyxLQUFLLE9BQU8sRUFBRUMsa0JBQWtCLEtBQUssRUFBRSxHQUFHRjtJQUNsRCxNQUFNRyxRQUFRLE9BQU9KLFNBQVMsV0FBV1IsOENBQWEsQ0FBQ1EsUUFBUUE7SUFDL0QsTUFBTU0sU0FBU1YsdURBQWEsQ0FBQ1E7SUFDN0IsSUFBSVosMkNBQVUsQ0FBQ1ksV0FBVyxLQUFLTCxXQUFXVSxNQUFNLEdBQUcsR0FDL0MsTUFBTSxJQUFJQztJQUNkLElBQUlsQiwyQ0FBVSxDQUFDWSxVQUFVWiwyQ0FBVSxDQUFDWSxTQUFTLElBQ3pDLE1BQU0sSUFBSU8sc0JBQXNCO1FBQzVCWCxNQUFNLE9BQU9BLFNBQVMsV0FBV0EsT0FBT04sOENBQWEsQ0FBQ007UUFDdERELFlBQVlBO1FBQ1pTLE1BQU1oQiwyQ0FBVSxDQUFDWTtJQUNyQjtJQUNKLElBQUlTLFdBQVc7SUFDZixNQUFNQyxTQUFTWixPQUFPLFVBQVUsRUFBRSxHQUFHLENBQUM7SUFDdEMsSUFBSyxJQUFJYSxJQUFJLEdBQUdBLElBQUloQixXQUFXVSxNQUFNLEVBQUUsRUFBRU0sRUFBRztRQUN4QyxNQUFNQyxRQUFRakIsVUFBVSxDQUFDZ0IsRUFBRTtRQUMzQlQsT0FBT1csV0FBVyxDQUFDSjtRQUNuQixNQUFNLENBQUNiLE1BQU1rQixVQUFVLEdBQUd2Qix1RUFBd0IsQ0FBQ1csUUFBUVUsT0FBTztZQUM5RGI7WUFDQWlCLGdCQUFnQjtRQUNwQjtRQUNBUCxZQUFZSztRQUNaLElBQUloQixPQUFPLFNBQ1BZLE9BQU9PLElBQUks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QWM7WUFDZEMsVUFBVTtZQUNWeEMsT0FBTztRQUNYO0lBQ0o7QUFDSixFQUNBLHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsYXctd29ya3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0FiaVBhcmFtZXRlcnMuanM/ZjU1NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBhYml0eXBlIGZyb20gJ2FiaXR5cGUnO1xuaW1wb3J0ICogYXMgQWRkcmVzcyBmcm9tICcuL0FkZHJlc3MuanMnO1xuaW1wb3J0ICogYXMgQnl0ZXMgZnJvbSAnLi9CeXRlcy5qcyc7XG5pbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSAnLi9FcnJvcnMuanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbmltcG9ydCAqIGFzIGludGVybmFsIGZyb20gJy4vaW50ZXJuYWwvYWJpUGFyYW1ldGVycy5qcyc7XG5pbXBvcnQgKiBhcyBDdXJzb3IgZnJvbSAnLi9pbnRlcm5hbC9jdXJzb3IuanMnO1xuaW1wb3J0ICogYXMgU29saWRpdHkgZnJvbSAnLi9Tb2xpZGl0eS5qcyc7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvY1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZShwYXJhbWV0ZXJzLCBkYXRhLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGFzID0gJ0FycmF5JywgY2hlY2tzdW1BZGRyZXNzID0gZmFsc2UgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYnl0ZXMgPSB0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgPyBCeXRlcy5mcm9tSGV4KGRhdGEpIDogZGF0YTtcbiAgICBjb25zdCBjdXJzb3IgPSBDdXJzb3IuY3JlYXRlKGJ5dGVzKTtcbiAgICBpZiAoQnl0ZXMuc2l6ZShieXRlcykgPT09IDAgJiYgcGFyYW1ldGVycy5sZW5ndGggPiAwKVxuICAgICAgICB0aHJvdyBuZXcgWmVyb0RhdGFFcnJvcigpO1xuICAgIGlmIChCeXRlcy5zaXplKGJ5dGVzKSAmJiBCeXRlcy5zaXplKGJ5dGVzKSA8IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRGF0YVNpemVUb29TbWFsbEVycm9yKHtcbiAgICAgICAgICAgIGRhdGE6IHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyA/IGRhdGEgOiBIZXguZnJvbUJ5dGVzKGRhdGEpLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogcGFyYW1ldGVycyxcbiAgICAgICAgICAgIHNpemU6IEJ5dGVzLnNpemUoYnl0ZXMpLFxuICAgICAgICB9KTtcbiAgICBsZXQgY29uc3VtZWQgPSAwO1xuICAgIGNvbnN0IHZhbHVlcyA9IGFzID09PSAnQXJyYXknID8gW10gOiB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmFtZXRlcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgcGFyYW0gPSBwYXJhbWV0ZXJzW2ldO1xuICAgICAgICBjdXJzb3Iuc2V0UG9zaXRpb24oY29uc3VtZWQpO1xuICAgICAgICBjb25zdCBbZGF0YSwgY29uc3VtZWRfXSA9IGludGVybmFsLmRlY29kZVBhcmFtZXRlcihjdXJzb3IsIHBhcmFtLCB7XG4gICAgICAgICAgICBjaGVja3N1bUFkZHJlc3MsXG4gICAgICAgICAgICBzdGF0aWNQb3NpdGlvbjogMCxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN1bWVkICs9IGNvbnN1bWVkXztcbiAgICAgICAgaWYgKGFzID09PSAnQXJyYXknKVxuICAgICAgICAgICAgdmFsdWVzLnB1c2goZGF0YSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHZhbHVlc1twYXJhbS5uYW1lID8/IGldID0gZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbn1cbi8qKlxuICogRW5jb2RlcyBwcmltaXRpdmUgdmFsdWVzIGludG8gQUJJIGVuY29kZWQgZGF0YSBhcyBwZXIgdGhlIFtBcHBsaWNhdGlvbiBCaW5hcnkgSW50ZXJmYWNlIChBQkkpIFNwZWNpZmljYXRpb25dKGh0dHBzOi8vZG9jcy5zb2xpZGl0eWxhbmcub3JnL2VuL2xhdGVzdC9hYmktc3BlYykuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlQYXJhbWV0ZXJzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZGF0YSA9IEFiaVBhcmFtZXRlcnMuZW5jb2RlKFxuICogICBBYmlQYXJhbWV0ZXJzLmZyb20oWydzdHJpbmcnLCAndWludCcsICdib29sJ10pLFxuICogICBbJ3dhZ21pJywgNDIwbiwgdHJ1ZV0sXG4gKiApXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEpTT04gUGFyYW1ldGVyc1xuICpcbiAqIFNwZWNpZnkgKipKU09OIEFCSSoqIFBhcmFtZXRlcnMgYXMgc2NoZW1hOlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlQYXJhbWV0ZXJzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZGF0YSA9IEFiaVBhcmFtZXRlcnMuZW5jb2RlKFxuICogICBbXG4gKiAgICAgeyB0eXBlOiAnc3RyaW5nJywgbmFtZTogJ25hbWUnIH0sXG4gKiAgICAgeyB0eXBlOiAndWludCcsIG5hbWU6ICdhZ2UnIH0sXG4gKiAgICAgeyB0eXBlOiAnYm9vbCcsIG5hbWU6ICdpc093bmVyJyB9LFxuICogICBdLFxuICogICBbJ3dhZ21pJywgNDIwbiwgdHJ1ZV0sXG4gKiApXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gcGFyYW1ldGVycyAtIFRoZSBzZXQgb2YgQUJJIHBhcmFtZXRlcnMgdG8gZW5jb2RlLCBpbiB0aGUgc2hhcGUgb2YgdGhlIGBpbnB1dHNgIG9yIGBvdXRwdXRzYCBhdHRyaWJ1dGUgb2YgYW4gQUJJIEl0ZW0uIFRoZXNlIHBhcmFtZXRlcnMgbXVzdCBpbmNsdWRlIHZhbGlkIFtBQkkgdHlwZXNdKGh0dHBzOi8vZG9jcy5zb2xpZGl0eWxhbmcub3JnL2VuL2xhdGVzdC90eXBlcy5odG1sKS5cbiAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgc2V0IG9mIHByaW1pdGl2ZSB2YWx1ZXMgdGhhdCBjb3JyZXNwb25kIHRvIHRoZSBBQkkgdHlwZXMgZGVmaW5lZCBpbiBgcGFyYW1ldGVyc2AuXG4gKiBAcmV0dXJucyBBQkkgZW5jb2RlZCBkYXRhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlKHBhcmFtZXRlcnMsIHZhbHVlcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgY2hlY2tzdW1BZGRyZXNzID0gZmFsc2UgfSA9IG9wdGlvbnMgPz8ge307XG4gICAgaWYgKHBhcmFtZXRlcnMubGVuZ3RoICE9PSB2YWx1ZXMubGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgTGVuZ3RoTWlzbWF0Y2hFcnJvcih7XG4gICAgICAgICAgICBleHBlY3RlZExlbmd0aDogcGFyYW1ldGVycy5sZW5ndGgsXG4gICAgICAgICAgICBnaXZlbkxlbmd0aDogdmFsdWVzLmxlbmd0aCxcbiAgICAgICAgfSk7XG4gICAgLy8gUHJlcGFyZSB0aGUgcGFyYW1ldGVycyB0byBkZXRlcm1pbmUgZHluYW1pYyB0eXBlcyB0byBlbmNvZGUuXG4gICAgY29uc3QgcHJlcGFyZWRQYXJhbWV0ZXJzID0gaW50ZXJuYWwucHJlcGFyZVBhcmFtZXRlcnMoe1xuICAgICAgICBjaGVja3N1bUFkZHJlc3MsXG4gICAgICAgIHBhcmFtZXRlcnM6IHBhcmFtZXRlcnMsXG4gICAgICAgIHZhbHVlczogdmFsdWVzLFxuICAgIH0pO1xuICAgIGNvbnN0IGRhdGEgPSBpbnRlcm5hbC5lbmNvZGUocHJlcGFyZWRQYXJhbWV0ZXJzKTtcbiAgICBpZiAoZGF0YS5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiAnMHgnO1xuICAgIHJldHVybiBkYXRhO1xufVxuLyoqXG4gKiBFbmNvZGVzIGFuIGFycmF5IG9mIHByaW1pdGl2ZSB2YWx1ZXMgdG8gYSBbcGFja2VkIEFCSSBlbmNvZGluZ10oaHR0cHM6Ly9kb2NzLnNvbGlkaXR5bGFuZy5vcmcvZW4vbGF0ZXN0L2FiaS1zcGVjLmh0bWwjbm9uLXN0YW5kYXJkLXBhY2tlZC1tb2RlKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaVBhcmFtZXRlcnMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBlbmNvZGVkID0gQWJpUGFyYW1ldGVycy5lbmNvZGVQYWNrZWQoXG4gKiAgIFsnYWRkcmVzcycsICdzdHJpbmcnXSxcbiAqICAgWycweGQ4ZGE2YmYyNjk2NGFmOWQ3ZWVkOWUwM2U1MzQxNWQzN2FhOTYwNDUnLCAnaGVsbG8gd29ybGQnXSxcbiAqIClcbiAqIC8vIEBsb2c6ICcweGQ4ZGE2YmYyNjk2NGFmOWQ3ZWVkOWUwM2U1MzQxNWQzN2FhOTYwNDU2ODY1NmM2YzZmMjA3NzZmNzI2YzY0J1xuICogYGBgXG4gKlxuICogQHBhcmFtIHR5cGVzIC0gU2V0IG9mIEFCSSB0eXBlcyB0byBwYWNrIGVuY29kZS5cbiAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgc2V0IG9mIHByaW1pdGl2ZSB2YWx1ZXMgdGhhdCBjb3JyZXNwb25kIHRvIHRoZSBBQkkgdHlwZXMgZGVmaW5lZCBpbiBgdHlwZXNgLlxuICogQHJldHVybnMgVGhlIGVuY29kZWQgcGFja2VkIGRhdGEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVQYWNrZWQodHlwZXMsIHZhbHVlcykge1xuICAgIGlmICh0eXBlcy5sZW5ndGggIT09IHZhbHVlcy5sZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBMZW5ndGhNaXNtYXRjaEVycm9yKHtcbiAgICAgICAgICAgIGV4cGVjdGVkTGVuZ3RoOiB0eXBlcy5sZW5ndGgsXG4gICAgICAgICAgICBnaXZlbkxlbmd0aDogdmFsdWVzLmxlbmd0aCxcbiAgICAgICAgfSk7XG4gICAgY29uc3QgZGF0YSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IHR5cGVzW2ldO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgICAgZGF0YS5wdXNoKGVuY29kZVBhY2tlZC5lbmNvZGUodHlwZSwgdmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIEhleC5jb25jYXQoLi4uZGF0YSk7XG59XG4oZnVuY3Rpb24gKGVuY29kZVBhY2tlZCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc2RvYy9yZXF1aXJlLWpzZG9jXG4gICAgZnVuY3Rpb24gZW5jb2RlKHR5cGUsIHZhbHVlLCBpc0FycmF5ID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdhZGRyZXNzJykge1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IHZhbHVlO1xuICAgICAgICAgICAgQWRkcmVzcy5hc3NlcnQoYWRkcmVzcyk7XG4gICAgICAgICAgICByZXR1cm4gSGV4LnBhZExlZnQoYWRkcmVzcy50b0xvd2VyQ2FzZSgpLCBpc0FycmF5ID8gMzIgOiAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICByZXR1cm4gSGV4LmZyb21TdHJpbmcodmFsdWUpO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ2J5dGVzJylcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdib29sJylcbiAgICAgICAgICAgIHJldHVybiBIZXgucGFkTGVmdChIZXguZnJvbUJvb2xlYW4odmFsdWUpLCBpc0FycmF5ID8gMzIgOiAxKTtcbiAgICAgICAgY29uc3QgaW50TWF0Y2ggPSB0eXBlLm1hdGNoKFNvbGlkaXR5LmludGVnZXJSZWdleCk7XG4gICAgICAgIGlmIChpbnRNYXRjaCkge1xuICAgICAgICAgICAgY29uc3QgW190eXBlLCBiYXNlVHlwZSwgYml0cyA9ICcyNTYnXSA9IGludE1hdGNoO1xuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IE51bWJlci5wYXJzZUludChiaXRzLCAxMCkgLyA4O1xuICAgICAgICAgICAgcmV0dXJuIEhleC5mcm9tTnVtYmVyKHZhbHVlLCB7XG4gICAgICAgICAgICAgICAgc2l6ZTogaXNBcnJheSA/IDMyIDogc2l6ZSxcbiAgICAgICAgICAgICAgICBzaWduZWQ6IGJhc2VUeXBlID09PSAnaW50JyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ5dGVzTWF0Y2ggPSB0eXBlLm1hdGNoKFNvbGlkaXR5LmJ5dGVzUmVnZXgpO1xuICAgICAgICBpZiAoYnl0ZXNNYXRjaCkge1xuICAgICAgICAgICAgY29uc3QgW190eXBlLCBzaXplXSA9IGJ5dGVzTWF0Y2g7XG4gICAgICAgICAgICBpZiAoTnVtYmVyLnBhcnNlSW50KHNpemUsIDEwKSAhPT0gKHZhbHVlLmxlbmd0aCAtIDIpIC8gMilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQnl0ZXNTaXplTWlzbWF0Y2hFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkU2l6ZTogTnVtYmVyLnBhcnNlSW50KHNpemUsIDEwKSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIEhleC5wYWRSaWdodCh2YWx1ZSwgaXNBcnJheSA/IDMyIDogMCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXJyYXlNYXRjaCA9IHR5cGUubWF0Y2goU29saWRpdHkuYXJyYXlSZWdleCk7XG4gICAgICAgIGlmIChhcnJheU1hdGNoICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBjb25zdCBbX3R5cGUsIGNoaWxkVHlwZV0gPSBhcnJheU1hdGNoO1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGRhdGEucHVzaChlbmNvZGUoY2hpbGRUeXBlLCB2YWx1ZVtpXSwgdHJ1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiAnMHgnO1xuICAgICAgICAgICAgcmV0dXJuIEhleC5jb25jYXQoLi4uZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRUeXBlRXJyb3IodHlwZSk7XG4gICAgfVxuICAgIGVuY29kZVBhY2tlZC5lbmNvZGUgPSBlbmNvZGU7XG59KShlbmNvZGVQYWNrZWQgfHwgKGVuY29kZVBhY2tlZCA9IHt9KSk7XG4vKipcbiAqIEZvcm1hdHMge0BsaW5rIG94I0FiaVBhcmFtZXRlcnMuQWJpUGFyYW1ldGVyc30gaW50byAqKkh1bWFuIFJlYWRhYmxlIEFCSSBQYXJhbWV0ZXJzKiouXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlQYXJhbWV0ZXJzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZm9ybWF0dGVkID0gQWJpUGFyYW1ldGVycy5mb3JtYXQoW1xuICogICB7XG4gKiAgICAgbmFtZTogJ3NwZW5kZXInLFxuICogICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAqICAgfSxcbiAqICAge1xuICogICAgIG5hbWU6ICdhbW91bnQnLFxuICogICAgIHR5cGU6ICd1aW50MjU2JyxcbiAqICAgfSxcbiAqIF0pXG4gKlxuICogZm9ybWF0dGVkXG4gKiAvLyAgICBeP1xuICpcbiAqXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gcGFyYW1ldGVycyAtIFRoZSBBQkkgUGFyYW1ldGVycyB0byBmb3JtYXQuXG4gKiBAcmV0dXJucyBUaGUgZm9ybWF0dGVkIEFCSSBQYXJhbWV0ZXJzICAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXQocGFyYW1ldGVycykge1xuICAgIHJldHVybiBhYml0eXBlLmZvcm1hdEFiaVBhcmFtZXRlcnMocGFyYW1ldGVycyk7XG59XG4vKipcbiAqIFBhcnNlcyBhcmJpdHJhcnkgKipKU09OIEFCSSBQYXJhbWV0ZXJzKiogb3IgKipIdW1hbiBSZWFkYWJsZSBBQkkgUGFyYW1ldGVycyoqIGludG8gdHlwZWQge0BsaW5rIG94I0FiaVBhcmFtZXRlcnMuQWJpUGFyYW1ldGVyc30uXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBKU09OIFBhcmFtZXRlcnNcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpUGFyYW1ldGVycyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHBhcmFtZXRlcnMgPSBBYmlQYXJhbWV0ZXJzLmZyb20oW1xuICogICB7XG4gKiAgICAgbmFtZTogJ3NwZW5kZXInLFxuICogICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAqICAgfSxcbiAqICAge1xuICogICAgIG5hbWU6ICdhbW91bnQnLFxuICogICAgIHR5cGU6ICd1aW50MjU2JyxcbiAqICAgfSxcbiAqIF0pXG4gKlxuICogcGFyYW1ldGVyc1xuICogLy9eP1xuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgSHVtYW4gUmVhZGFibGUgUGFyYW1ldGVyc1xuICpcbiAqIEh1bWFuIFJlYWRhYmxlIEFCSSBQYXJhbWV0ZXJzIGNhbiBiZSBwYXJzZWQgaW50byBhIHR5cGVkIHtAbGluayBveCNBYmlQYXJhbWV0ZXJzLkFiaVBhcmFtZXRlcnN9OlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlQYXJhbWV0ZXJzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgcGFyYW1ldGVycyA9IEFiaVBhcmFtZXRlcnMuZnJvbSgnYWRkcmVzcyBzcGVuZGVyLCB1aW50MjU2IGFtb3VudCcpXG4gKlxuICogcGFyYW1ldGVyc1xuICogLy9eP1xuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBJdCBpcyBwb3NzaWJsZSB0byBzcGVjaWZ5IGBzdHJ1Y3RgcyBhbG9uZyB3aXRoIHlvdXIgZGVmaW5pdGlvbnM6XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaVBhcmFtZXRlcnMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwYXJhbWV0ZXJzID0gQWJpUGFyYW1ldGVycy5mcm9tKFtcbiAqICAgJ3N0cnVjdCBGb28geyBhZGRyZXNzIHNwZW5kZXI7IHVpbnQyNTYgYW1vdW50OyB9JywgLy8gWyFjb2RlIGhsXVxuICogICAnRm9vIGZvbywgYWRkcmVzcyBiYXInLFxuICogXSlcbiAqXG4gKiBwYXJhbWV0ZXJzXG4gKiAvL14/XG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKiBgYGBcbiAqXG4gKlxuICpcbiAqIEBwYXJhbSBwYXJhbWV0ZXJzIC0gVGhlIEFCSSBQYXJhbWV0ZXJzIHRvIHBhcnNlLlxuICogQHJldHVybnMgVGhlIHR5cGVkIEFCSSBQYXJhbWV0ZXJzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbShwYXJhbWV0ZXJzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW1ldGVycykgJiYgdHlwZW9mIHBhcmFtZXRlcnNbMF0gPT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gYWJpdHlwZS5wYXJzZUFiaVBhcmFtZXRlcnMocGFyYW1ldGVycyk7XG4gICAgaWYgKHR5cGVvZiBwYXJhbWV0ZXJzID09PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIGFiaXR5cGUucGFyc2VBYmlQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpO1xuICAgIHJldHVybiBwYXJhbWV0ZXJzO1xufVxuLyoqXG4gKiBUaHJvd3Mgd2hlbiB0aGUgZGF0YSBzaXplIGlzIHRvbyBzbWFsbCBmb3IgdGhlIGdpdmVuIHBhcmFtZXRlcnMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlQYXJhbWV0ZXJzIH0gZnJvbSAnb3gnXG4gKlxuICogQWJpUGFyYW1ldGVycy5kZWNvZGUoW3sgdHlwZTogJ3VpbnQyNTYnIH1dLCAnMHgwMTBmJylcbiAqIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4oaRIOKdjCAyIGJ5dGVzXG4gKiAvLyBAZXJyb3I6IEFiaVBhcmFtZXRlcnMuRGF0YVNpemVUb29TbWFsbEVycm9yOiBEYXRhIHNpemUgb2YgMiBieXRlcyBpcyB0b28gc21hbGwgZm9yIGdpdmVuIHBhcmFtZXRlcnMuXG4gKiAvLyBAZXJyb3I6IFBhcmFtczogKHVpbnQyNTYpXG4gKiAvLyBAZXJyb3I6IERhdGE6ICAgMHgwMTBmICgyIGJ5dGVzKVxuICogYGBgXG4gKlxuICogIyMjIFNvbHV0aW9uXG4gKlxuICogUGFzcyBhIHZhbGlkIGRhdGEgc2l6ZS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpUGFyYW1ldGVycyB9IGZyb20gJ294J1xuICpcbiAqIEFiaVBhcmFtZXRlcnMuZGVjb2RlKFt7IHR5cGU6ICd1aW50MjU2JyB9XSwgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTBmJylcbiAqIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4oaRIOKchSAzMiBieXRlc1xuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBEYXRhU2l6ZVRvb1NtYWxsRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGRhdGEsIHBhcmFtZXRlcnMsIHNpemUsIH0pIHtcbiAgICAgICAgc3VwZXIoYERhdGEgc2l6ZSBvZiAke3NpemV9IGJ5dGVzIGlzIHRvbyBzbWFsbCBmb3IgZ2l2ZW4gcGFyYW1ldGVycy5gLCB7XG4gICAgICAgICAgICBtZXRhTWVzc2FnZXM6IFtcbiAgICAgICAgICAgICAgICBgUGFyYW1zOiAoJHthYml0eXBlLmZvcm1hdEFiaVBhcmFtZXRlcnMocGFyYW1ldGVycyl9KWAsXG4gICAgICAgICAgICAgICAgYERhdGE6ICAgJHtkYXRhfSAoJHtzaXplfSBieXRlcylgLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdBYmlQYXJhbWV0ZXJzLkRhdGFTaXplVG9vU21hbGxFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd3Mgd2hlbiB6ZXJvIGRhdGEgaXMgcHJvdmlkZWQsIGJ1dCBkYXRhIGlzIGV4cGVjdGVkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpUGFyYW1ldGVycyB9IGZyb20gJ294J1xuICpcbiAqIEFiaVBhcmFtZXRlcnMuZGVjb2RlKFt7IHR5cGU6ICd1aW50MjU2JyB9XSwgJzB4JylcbiAqIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKGkSDinYwgemVybyBkYXRhXG4gKiAvLyBAZXJyb3I6IEFiaVBhcmFtZXRlcnMuRGF0YVNpemVUb29TbWFsbEVycm9yOiBEYXRhIHNpemUgb2YgMiBieXRlcyBpcyB0b28gc21hbGwgZm9yIGdpdmVuIHBhcmFtZXRlcnMuXG4gKiAvLyBAZXJyb3I6IFBhcmFtczogKHVpbnQyNTYpXG4gKiAvLyBAZXJyb3I6IERhdGE6ICAgMHgwMTBmICgyIGJ5dGVzKVxuICogYGBgXG4gKlxuICogIyMjIFNvbHV0aW9uXG4gKlxuICogUGFzcyB2YWxpZCBkYXRhLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlQYXJhbWV0ZXJzIH0gZnJvbSAnb3gnXG4gKlxuICogQWJpUGFyYW1ldGVycy5kZWNvZGUoW3sgdHlwZTogJ3VpbnQyNTYnIH1dLCAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMGYnKVxuICogLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDihpEg4pyFIDMyIGJ5dGVzXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIFplcm9EYXRhRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ0Nhbm5vdCBkZWNvZGUgemVybyBkYXRhIChcIjB4XCIpIHdpdGggQUJJIHBhcmFtZXRlcnMuJyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdBYmlQYXJhbWV0ZXJzLlplcm9EYXRhRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkgdmFsdWUgZG9lcyBub3QgbWF0Y2ggdGhlIGxlbmd0aCBzcGVjaWZpZWQgaW4gdGhlIGNvcnJlc3BvbmRpbmcgQUJJIHBhcmFtZXRlci5cbiAqXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IEFiaVBhcmFtZXRlcnMgfSBmcm9tICdveCdcbiAqIC8vIC0tLWN1dC0tLVxuICogQWJpUGFyYW1ldGVycy5lbmNvZGUoQWJpUGFyYW1ldGVycy5mcm9tKCd1aW50MjU2WzNdJyksIFtbNjluLCA0MjBuXV0pXG4gKiAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4oaRIGV4cGVjdGVkOiAzICDihpEg4p2MIGxlbmd0aDogMlxuICogLy8gQGVycm9yOiBBYmlQYXJhbWV0ZXJzLkFycmF5TGVuZ3RoTWlzbWF0Y2hFcnJvcjogQUJJIGVuY29kaW5nIGFycmF5IGxlbmd0aCBtaXNtYXRjaFxuICogLy8gQGVycm9yOiBmb3IgdHlwZSBgdWludDI1NlszXWAuIEV4cGVjdGVkOiBgM2AuIEdpdmVuOiBgMmAuXG4gKiBgYGBcbiAqXG4gKiAjIyMgU29sdXRpb25cbiAqXG4gKiBQYXNzIGFuIGFycmF5IG9mIHRoZSBjb3JyZWN0IGxlbmd0aC5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpUGFyYW1ldGVycyB9IGZyb20gJ294J1xuICogLy8gLS0tY3V0LS0tXG4gKiBBYmlQYXJhbWV0ZXJzLmVuY29kZShBYmlQYXJhbWV0ZXJzLmZyb20oWyd1aW50MjU2WzNdJ10pLCBbWzY5biwgNDIwbiwgNjluXV0pXG4gKiAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKGkSDinIUgbGVuZ3RoOiAzXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEFycmF5TGVuZ3RoTWlzbWF0Y2hFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgZXhwZWN0ZWRMZW5ndGgsIGdpdmVuTGVuZ3RoLCB0eXBlLCB9KSB7XG4gICAgICAgIHN1cGVyKGBBcnJheSBsZW5ndGggbWlzbWF0Y2ggZm9yIHR5cGUgXFxgJHt0eXBlfVxcYC4gRXhwZWN0ZWQ6IFxcYCR7ZXhwZWN0ZWRMZW5ndGh9XFxgLiBHaXZlbjogXFxgJHtnaXZlbkxlbmd0aH1cXGAuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdBYmlQYXJhbWV0ZXJzLkFycmF5TGVuZ3RoTWlzbWF0Y2hFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaGUgc2l6ZSBvZiB0aGUgYnl0ZXMgdmFsdWUgZG9lcyBub3QgbWF0Y2ggdGhlIHNpemUgc3BlY2lmaWVkIGluIHRoZSBjb3JyZXNwb25kaW5nIEFCSSBwYXJhbWV0ZXIuXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBBYmlQYXJhbWV0ZXJzIH0gZnJvbSAnb3gnXG4gKiAvLyAtLS1jdXQtLS1cbiAqIEFiaVBhcmFtZXRlcnMuZW5jb2RlKEFiaVBhcmFtZXRlcnMuZnJvbSgnYnl0ZXM4JyksIFtbJzB4ZGVhZGJlZWZkZWFkYmVlZmRlYWRiZWVmJ11dKVxuICogLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKGkSBleHBlY3RlZDogOCBieXRlcyAg4oaRIOKdjCBzaXplOiAxMiBieXRlc1xuICogLy8gQGVycm9yOiBCeXRlc1NpemVNaXNtYXRjaEVycm9yOiBTaXplIG9mIGJ5dGVzIFwiMHhkZWFkYmVlZmRlYWRiZWVmZGVhZGJlZWZcIlxuICogLy8gQGVycm9yOiAoYnl0ZXMxMikgZG9lcyBub3QgbWF0Y2ggZXhwZWN0ZWQgc2l6ZSAoYnl0ZXM4KS5cbiAqIGBgYFxuICpcbiAqICMjIyBTb2x1dGlvblxuICpcbiAqIFBhc3MgYSBieXRlcyB2YWx1ZSBvZiB0aGUgY29ycmVjdCBzaXplLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlQYXJhbWV0ZXJzIH0gZnJvbSAnb3gnXG4gKiAvLyAtLS1jdXQtLS1cbiAqIEFiaVBhcmFtZXRlcnMuZW5jb2RlKEFiaVBhcmFtZXRlcnMuZnJvbShbJ2J5dGVzOCddKSwgWycweGRlYWRiZWVmZGVhZGJlZWYnXSlcbiAqIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKGkSDinIUgc2l6ZTogOCBieXRlc1xuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBCeXRlc1NpemVNaXNtYXRjaEVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBleHBlY3RlZFNpemUsIHZhbHVlLCB9KSB7XG4gICAgICAgIHN1cGVyKGBTaXplIG9mIGJ5dGVzIFwiJHt2YWx1ZX1cIiAoYnl0ZXMke0hleC5zaXplKHZhbHVlKX0pIGRvZXMgbm90IG1hdGNoIGV4cGVjdGVkIHNpemUgKGJ5dGVzJHtleHBlY3RlZFNpemV9KS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0FiaVBhcmFtZXRlcnMuQnl0ZXNTaXplTWlzbWF0Y2hFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaGUgbGVuZ3RoIG9mIHRoZSB2YWx1ZXMgdG8gZW5jb2RlIGRvZXMgbm90IG1hdGNoIHRoZSBsZW5ndGggb2YgdGhlIEFCSSBwYXJhbWV0ZXJzLlxuICpcbiAqICMjIyBFeGFtcGxlXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgQWJpUGFyYW1ldGVycyB9IGZyb20gJ294J1xuICogLy8gLS0tY3V0LS0tXG4gKiBBYmlQYXJhbWV0ZXJzLmVuY29kZShBYmlQYXJhbWV0ZXJzLmZyb20oWydzdHJpbmcnLCAndWludDI1NiddKSwgWydoZWxsbyddKVxuICogLy8gQGVycm9yOiBMZW5ndGhNaXNtYXRjaEVycm9yOiBBQkkgZW5jb2RpbmcgcGFyYW1zL3ZhbHVlcyBsZW5ndGggbWlzbWF0Y2guXG4gKiAvLyBAZXJyb3I6IEV4cGVjdGVkIGxlbmd0aCAocGFyYW1zKTogMlxuICogLy8gQGVycm9yOiBHaXZlbiBsZW5ndGggKHZhbHVlcyk6IDFcbiAqIGBgYFxuICpcbiAqICMjIyBTb2x1dGlvblxuICpcbiAqIFBhc3MgdGhlIGNvcnJlY3QgbnVtYmVyIG9mIHZhbHVlcyB0byBlbmNvZGUuXG4gKlxuICogIyMjIFNvbHV0aW9uXG4gKlxuICogUGFzcyBhIFt2YWxpZCBBQkkgdHlwZV0oaHR0cHM6Ly9kb2NzLnNvbGlkaXR5bGFuZy5vcmcvZW4vZGV2ZWxvcC9hYmktc3BlYy5odG1sI3R5cGVzKS5cbiAqL1xuZXhwb3J0IGNsYXNzIExlbmd0aE1pc21hdGNoRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGV4cGVjdGVkTGVuZ3RoLCBnaXZlbkxlbmd0aCwgfSkge1xuICAgICAgICBzdXBlcihbXG4gICAgICAgICAgICAnQUJJIGVuY29kaW5nIHBhcmFtZXRlcnMvdmFsdWVzIGxlbmd0aCBtaXNtYXRjaC4nLFxuICAgICAgICAgICAgYEV4cGVjdGVkIGxlbmd0aCAocGFyYW1ldGVycyk6ICR7ZXhwZWN0ZWRMZW5ndGh9YCxcbiAgICAgICAgICAgIGBHaXZlbiBsZW5ndGggKHZhbHVlcyk6ICR7Z2l2ZW5MZW5ndGh9YCxcbiAgICAgICAgXS5qb2luKCdcXG4nKSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdBYmlQYXJhbWV0ZXJzLkxlbmd0aE1pc21hdGNoRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhlIHZhbHVlIHByb3ZpZGVkIGlzIG5vdCBhIHZhbGlkIGFycmF5IGFzIHNwZWNpZmllZCBpbiB0aGUgY29ycmVzcG9uZGluZyBBQkkgcGFyYW1ldGVyLlxuICpcbiAqICMjIyBFeGFtcGxlXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgQWJpUGFyYW1ldGVycyB9IGZyb20gJ294J1xuICogLy8gLS0tY3V0LS0tXG4gKiBBYmlQYXJhbWV0ZXJzLmVuY29kZShBYmlQYXJhbWV0ZXJzLmZyb20oWyd1aW50MjU2WzNdJ10pLCBbNjldKVxuICogYGBgXG4gKlxuICogIyMjIFNvbHV0aW9uXG4gKlxuICogUGFzcyBhbiBhcnJheSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRBcnJheUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgc3VwZXIoYFZhbHVlIFxcYCR7dmFsdWV9XFxgIGlzIG5vdCBhIHZhbGlkIGFycmF5LmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQWJpUGFyYW1ldGVycy5JbnZhbGlkQXJyYXlFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd3Mgd2hlbiB0aGUgQUJJIHBhcmFtZXRlciB0eXBlIGlzIGludmFsaWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlQYXJhbWV0ZXJzIH0gZnJvbSAnb3gnXG4gKlxuICogQWJpUGFyYW1ldGVycy5kZWNvZGUoW3sgdHlwZTogJ2xvbCcgfV0sICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwZicpXG4gKiAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4oaRIOKdjCBpbnZhbGlkIHR5cGVcbiAqIC8vIEBlcnJvcjogQWJpUGFyYW1ldGVycy5JbnZhbGlkVHlwZUVycm9yOiBUeXBlIGBsb2xgIGlzIG5vdCBhIHZhbGlkIEFCSSBUeXBlLlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkVHlwZUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IodHlwZSkge1xuICAgICAgICBzdXBlcihgVHlwZSBcXGAke3R5cGV9XFxgIGlzIG5vdCBhIHZhbGlkIEFCSSBUeXBlLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQWJpUGFyYW1ldGVycy5JbnZhbGlkVHlwZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BYmlQYXJhbWV0ZXJzLmpzLm1hcCJdLCJuYW1lcyI6WyJhYml0eXBlIiwiQWRkcmVzcyIsIkJ5dGVzIiwiRXJyb3JzIiwiSGV4IiwiaW50ZXJuYWwiLCJDdXJzb3IiLCJTb2xpZGl0eSIsImRlY29kZSIsInBhcmFtZXRlcnMiLCJkYXRhIiwib3B0aW9ucyIsImFzIiwiY2hlY2tzdW1BZGRyZXNzIiwiYnl0ZXMiLCJmcm9tSGV4IiwiY3Vyc29yIiwiY3JlYXRlIiwic2l6ZSIsImxlbmd0aCIsIlplcm9EYXRhRXJyb3IiLCJEYXRhU2l6ZVRvb1NtYWxsRXJyb3IiLCJmcm9tQnl0ZXMiLCJjb25zdW1lZCIsInZhbHVlcyIsImkiLCJwYXJhbSIsInNldFBvc2l0aW9uIiwiY29uc3VtZWRfIiwiZGVjb2RlUGFyYW1ldGVyIiwic3RhdGljUG9zaXRpb24iLCJwdXNoIiwibmFtZSIsImVuY29kZSIsIkxlbmd0aE1pc21hdGNoRXJyb3IiLCJleHBlY3RlZExlbmd0aCIsImdpdmVuTGVuZ3RoIiwicHJlcGFyZWRQYXJhbWV0ZXJzIiwicHJlcGFyZVBhcmFtZXRlcnMiLCJlbmNvZGVQYWNrZWQiLCJ0eXBlcyIsInR5cGUiLCJ2YWx1ZSIsImNvbmNhdCIsImlzQXJyYXkiLCJhZGRyZXNzIiwiYXNzZXJ0IiwicGFkTGVmdCIsInRvTG93ZXJDYXNlIiwiZnJvbVN0cmluZyIsImZyb21Cb29sZWFuIiwiaW50TWF0Y2giLCJtYXRjaCIsImludGVnZXJSZWdleCIsIl90eXBlIiwiYmFzZVR5cGUiLCJiaXRzIiwiTnVtYmVyIiwicGFyc2VJbnQiLCJmcm9tTnVtYmVyIiwic2lnbmVkIiwiYnl0ZXNNYXRjaCIsImJ5dGVzUmVnZXgiLCJCeXRlc1NpemVNaXNtYXRjaEVycm9yIiwiZXhwZWN0ZWRTaXplIiwicGFkUmlnaHQiLCJhcnJheU1hdGNoIiwiYXJyYXlSZWdleCIsIkFycmF5IiwiY2hpbGRUeXBlIiwiSW52YWxpZFR5cGVFcnJvciIsImZvcm1hdCIsImZvcm1hdEFiaVBhcmFtZXRlcnMiLCJmcm9tIiwicGFyc2VBYmlQYXJhbWV0ZXJzIiwiQmFzZUVycm9yIiwiY29uc3RydWN0b3IiLCJtZXRhTWVzc2FnZXMiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIkFycmF5TGVuZ3RoTWlzbWF0Y2hFcnJvciIsImpvaW4iLCJJbnZhbGlkQXJyYXlFcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/AbiParameters.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/AccessList.js":
/*!*************************************************!*\
  !*** ./node_modules/ox/_esm/core/AccessList.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidStorageKeySizeError: () => (/* binding */ InvalidStorageKeySizeError),\n/* harmony export */   fromTupleList: () => (/* binding */ fromTupleList),\n/* harmony export */   toTupleList: () => (/* binding */ toTupleList)\n/* harmony export */ });\n/* harmony import */ var _Address_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Address.js */ \"(ssr)/./node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hash.js */ \"(ssr)/./node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n\n\n\n\n/**\n * Converts a list of Access List tuples into a object-formatted list.\n *\n * @example\n * ```ts twoslash\n * import { AccessList } from 'ox'\n *\n * const accessList = AccessList.fromTupleList([\n *   [\n *     '0x0000000000000000000000000000000000000000',\n *     [\n *       '0x0000000000000000000000000000000000000000000000000000000000000001',\n *       '0x60fdd29ff912ce880cd3edaf9f932dc61d3dae823ea77e0323f94adb9f6a72fe',\n *     ],\n *   ],\n * ])\n * // @log: [\n * // @log:   {\n * // @log:     address: '0x0000000000000000000000000000000000000000',\n * // @log:     storageKeys: [\n * // @log:       '0x0000000000000000000000000000000000000000000000000000000000000001',\n * // @log:       '0x60fdd29ff912ce880cd3edaf9f932dc61d3dae823ea77e0323f94adb9f6a72fe',\n * // @log:     ],\n * // @log:   },\n * // @log: ]\n * ```\n *\n * @param accessList - List of tuples.\n * @returns Access list.\n */ function fromTupleList(accessList) {\n    const list = [];\n    for(let i = 0; i < accessList.length; i++){\n        const [address, storageKeys] = accessList[i];\n        if (address) _Address_js__WEBPACK_IMPORTED_MODULE_0__.assert(address, {\n            strict: false\n        });\n        list.push({\n            address: address,\n            storageKeys: storageKeys.map((key)=>_Hash_js__WEBPACK_IMPORTED_MODULE_1__.validate(key) ? key : _Hex_js__WEBPACK_IMPORTED_MODULE_2__.trimLeft(key))\n        });\n    }\n    return list;\n}\n/**\n * Converts a structured Access List into a list of tuples.\n *\n * @example\n * ```ts twoslash\n * import { AccessList } from 'ox'\n *\n * const accessList = AccessList.toTupleList([\n *   {\n *     address: '0x0000000000000000000000000000000000000000',\n *     storageKeys: [\n *       '0x0000000000000000000000000000000000000000000000000000000000000001',\n *       '0x60fdd29ff912ce880cd3edaf9f932dc61d3dae823ea77e0323f94adb9f6a72fe'],\n *   },\n * ])\n * // @log: [\n * // @log:   [\n * // @log:     '0x0000000000000000000000000000000000000000',\n * // @log:     [\n * // @log:       '0x0000000000000000000000000000000000000000000000000000000000000001',\n * // @log:       '0x60fdd29ff912ce880cd3edaf9f932dc61d3dae823ea77e0323f94adb9f6a72fe',\n * // @log:     ],\n * // @log:   ],\n * // @log: ]\n * ```\n *\n * @param accessList - Access list.\n * @returns List of tuples.\n */ function toTupleList(accessList) {\n    if (!accessList || accessList.length === 0) return [];\n    const tuple = [];\n    for (const { address, storageKeys } of accessList){\n        for(let j = 0; j < storageKeys.length; j++)if (_Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(storageKeys[j]) !== 32) throw new InvalidStorageKeySizeError({\n            storageKey: storageKeys[j]\n        });\n        if (address) _Address_js__WEBPACK_IMPORTED_MODULE_0__.assert(address, {\n            strict: false\n        });\n        tuple.push([\n            address,\n            storageKeys\n        ]);\n    }\n    return tuple;\n}\n/** Thrown when the size of a storage key is invalid. */ class InvalidStorageKeySizeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError {\n    constructor({ storageKey }){\n        super(`Size for storage key \"${storageKey}\" is invalid. Expected 32 bytes. Got ${_Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(storageKey)} bytes.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"AccessList.InvalidStorageKeySizeError\"\n        });\n    }\n} //# sourceMappingURL=AccessList.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0FjY2Vzc0xpc3QuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUF3QztBQUNGO0FBQ0o7QUFDRjtBQUNoQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0E2QkMsR0FDTSxTQUFTSSxjQUFjQyxVQUFVO0lBQ3BDLE1BQU1DLE9BQU8sRUFBRTtJQUNmLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJRixXQUFXRyxNQUFNLEVBQUVELElBQUs7UUFDeEMsTUFBTSxDQUFDRSxTQUFTQyxZQUFZLEdBQUdMLFVBQVUsQ0FBQ0UsRUFBRTtRQUM1QyxJQUFJRSxTQUNBVCwrQ0FBYyxDQUFDUyxTQUFTO1lBQUVHLFFBQVE7UUFBTTtRQUM1Q04sS0FBS08sSUFBSSxDQUFDO1lBQ05KLFNBQVNBO1lBQ1RDLGFBQWFBLFlBQVlJLEdBQUcsQ0FBQyxDQUFDQyxNQUFRYiw4Q0FBYSxDQUFDYSxPQUFPQSxNQUFNWiw2Q0FBWSxDQUFDWTtRQUNsRjtJQUNKO0lBQ0EsT0FBT1Q7QUFDWDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBNEJDLEdBQ00sU0FBU1ksWUFBWWIsVUFBVTtJQUNsQyxJQUFJLENBQUNBLGNBQWNBLFdBQVdHLE1BQU0sS0FBSyxHQUNyQyxPQUFPLEVBQUU7SUFDYixNQUFNVyxRQUFRLEVBQUU7SUFDaEIsS0FBSyxNQUFNLEVBQUVWLE9BQU8sRUFBRUMsV0FBVyxFQUFFLElBQUlMLFdBQVk7UUFDL0MsSUFBSyxJQUFJZSxJQUFJLEdBQUdBLElBQUlWLFlBQVlGLE1BQU0sRUFBRVksSUFDcEMsSUFBSWpCLHlDQUFRLENBQUNPLFdBQVcsQ0FBQ1UsRUFBRSxNQUFNLElBQzdCLE1BQU0sSUFBSUUsMkJBQTJCO1lBQ2pDQyxZQUFZYixXQUFXLENBQUNVLEVBQUU7UUFDOUI7UUFDUixJQUFJWCxTQUNBVCwrQ0FBYyxDQUFDUyxTQUFTO1lBQUVHLFFBQVE7UUFBTTtRQUM1Q08sTUFBTU4sSUFBSSxDQUFDO1lBQUNKO1lBQVNDO1NBQVk7SUFDckM7SUFDQSxPQUFPUztBQUNYO0FBQ0Esc0RBQXNELEdBQy9DLE1BQU1HLG1DQUFtQ3JCLGlEQUFnQjtJQUM1RHdCLFlBQVksRUFBRUYsVUFBVSxFQUFFLENBQUU7UUFDeEIsS0FBSyxDQUFDLENBQUMsc0JBQXNCLEVBQUVBLFdBQVcscUNBQXFDLEVBQUVwQix5Q0FBUSxDQUFDb0IsWUFBWSxPQUFPLENBQUM7UUFDOUdHLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsUUFBUTtZQUNoQ0MsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVkMsT0FBTztRQUNYO0lBQ0o7QUFDSixFQUNBLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsYXctd29ya3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0FjY2Vzc0xpc3QuanM/MmRhZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBBZGRyZXNzIGZyb20gJy4vQWRkcmVzcy5qcyc7XG5pbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSAnLi9FcnJvcnMuanMnO1xuaW1wb3J0ICogYXMgSGFzaCBmcm9tICcuL0hhc2guanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbi8qKlxuICogQ29udmVydHMgYSBsaXN0IG9mIEFjY2VzcyBMaXN0IHR1cGxlcyBpbnRvIGEgb2JqZWN0LWZvcm1hdHRlZCBsaXN0LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWNjZXNzTGlzdCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGFjY2Vzc0xpc3QgPSBBY2Nlc3NMaXN0LmZyb21UdXBsZUxpc3QoW1xuICogICBbXG4gKiAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgICAgW1xuICogICAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsXG4gKiAgICAgICAnMHg2MGZkZDI5ZmY5MTJjZTg4MGNkM2VkYWY5ZjkzMmRjNjFkM2RhZTgyM2VhNzdlMDMyM2Y5NGFkYjlmNmE3MmZlJyxcbiAqICAgICBdLFxuICogICBdLFxuICogXSlcbiAqIC8vIEBsb2c6IFtcbiAqIC8vIEBsb2c6ICAge1xuICogLy8gQGxvZzogICAgIGFkZHJlc3M6ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogLy8gQGxvZzogICAgIHN0b3JhZ2VLZXlzOiBbXG4gKiAvLyBAbG9nOiAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJyxcbiAqIC8vIEBsb2c6ICAgICAgICcweDYwZmRkMjlmZjkxMmNlODgwY2QzZWRhZjlmOTMyZGM2MWQzZGFlODIzZWE3N2UwMzIzZjk0YWRiOWY2YTcyZmUnLFxuICogLy8gQGxvZzogICAgIF0sXG4gKiAvLyBAbG9nOiAgIH0sXG4gKiAvLyBAbG9nOiBdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYWNjZXNzTGlzdCAtIExpc3Qgb2YgdHVwbGVzLlxuICogQHJldHVybnMgQWNjZXNzIGxpc3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVHVwbGVMaXN0KGFjY2Vzc0xpc3QpIHtcbiAgICBjb25zdCBsaXN0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhY2Nlc3NMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IFthZGRyZXNzLCBzdG9yYWdlS2V5c10gPSBhY2Nlc3NMaXN0W2ldO1xuICAgICAgICBpZiAoYWRkcmVzcylcbiAgICAgICAgICAgIEFkZHJlc3MuYXNzZXJ0KGFkZHJlc3MsIHsgc3RyaWN0OiBmYWxzZSB9KTtcbiAgICAgICAgbGlzdC5wdXNoKHtcbiAgICAgICAgICAgIGFkZHJlc3M6IGFkZHJlc3MsXG4gICAgICAgICAgICBzdG9yYWdlS2V5czogc3RvcmFnZUtleXMubWFwKChrZXkpID0+IEhhc2gudmFsaWRhdGUoa2V5KSA/IGtleSA6IEhleC50cmltTGVmdChrZXkpKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBsaXN0O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIHN0cnVjdHVyZWQgQWNjZXNzIExpc3QgaW50byBhIGxpc3Qgb2YgdHVwbGVzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWNjZXNzTGlzdCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGFjY2Vzc0xpc3QgPSBBY2Nlc3NMaXN0LnRvVHVwbGVMaXN0KFtcbiAqICAge1xuICogICAgIGFkZHJlc3M6ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICAgIHN0b3JhZ2VLZXlzOiBbXG4gKiAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJyxcbiAqICAgICAgICcweDYwZmRkMjlmZjkxMmNlODgwY2QzZWRhZjlmOTMyZGM2MWQzZGFlODIzZWE3N2UwMzIzZjk0YWRiOWY2YTcyZmUnXSxcbiAqICAgfSxcbiAqIF0pXG4gKiAvLyBAbG9nOiBbXG4gKiAvLyBAbG9nOiAgIFtcbiAqIC8vIEBsb2c6ICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqIC8vIEBsb2c6ICAgICBbXG4gKiAvLyBAbG9nOiAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJyxcbiAqIC8vIEBsb2c6ICAgICAgICcweDYwZmRkMjlmZjkxMmNlODgwY2QzZWRhZjlmOTMyZGM2MWQzZGFlODIzZWE3N2UwMzIzZjk0YWRiOWY2YTcyZmUnLFxuICogLy8gQGxvZzogICAgIF0sXG4gKiAvLyBAbG9nOiAgIF0sXG4gKiAvLyBAbG9nOiBdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYWNjZXNzTGlzdCAtIEFjY2VzcyBsaXN0LlxuICogQHJldHVybnMgTGlzdCBvZiB0dXBsZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1R1cGxlTGlzdChhY2Nlc3NMaXN0KSB7XG4gICAgaWYgKCFhY2Nlc3NMaXN0IHx8IGFjY2Vzc0xpc3QubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gW107XG4gICAgY29uc3QgdHVwbGUgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHsgYWRkcmVzcywgc3RvcmFnZUtleXMgfSBvZiBhY2Nlc3NMaXN0KSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc3RvcmFnZUtleXMubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICBpZiAoSGV4LnNpemUoc3RvcmFnZUtleXNbal0pICE9PSAzMilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFN0b3JhZ2VLZXlTaXplRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICBzdG9yYWdlS2V5OiBzdG9yYWdlS2V5c1tqXSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKGFkZHJlc3MpXG4gICAgICAgICAgICBBZGRyZXNzLmFzc2VydChhZGRyZXNzLCB7IHN0cmljdDogZmFsc2UgfSk7XG4gICAgICAgIHR1cGxlLnB1c2goW2FkZHJlc3MsIHN0b3JhZ2VLZXlzXSk7XG4gICAgfVxuICAgIHJldHVybiB0dXBsZTtcbn1cbi8qKiBUaHJvd24gd2hlbiB0aGUgc2l6ZSBvZiBhIHN0b3JhZ2Uga2V5IGlzIGludmFsaWQuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZFN0b3JhZ2VLZXlTaXplRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHN0b3JhZ2VLZXkgfSkge1xuICAgICAgICBzdXBlcihgU2l6ZSBmb3Igc3RvcmFnZSBrZXkgXCIke3N0b3JhZ2VLZXl9XCIgaXMgaW52YWxpZC4gRXhwZWN0ZWQgMzIgYnl0ZXMuIEdvdCAke0hleC5zaXplKHN0b3JhZ2VLZXkpfSBieXRlcy5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0FjY2Vzc0xpc3QuSW52YWxpZFN0b3JhZ2VLZXlTaXplRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFjY2Vzc0xpc3QuanMubWFwIl0sIm5hbWVzIjpbIkFkZHJlc3MiLCJFcnJvcnMiLCJIYXNoIiwiSGV4IiwiZnJvbVR1cGxlTGlzdCIsImFjY2Vzc0xpc3QiLCJsaXN0IiwiaSIsImxlbmd0aCIsImFkZHJlc3MiLCJzdG9yYWdlS2V5cyIsImFzc2VydCIsInN0cmljdCIsInB1c2giLCJtYXAiLCJrZXkiLCJ2YWxpZGF0ZSIsInRyaW1MZWZ0IiwidG9UdXBsZUxpc3QiLCJ0dXBsZSIsImoiLCJzaXplIiwiSW52YWxpZFN0b3JhZ2VLZXlTaXplRXJyb3IiLCJzdG9yYWdlS2V5IiwiQmFzZUVycm9yIiwiY29uc3RydWN0b3IiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsInZhbHVlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/AccessList.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Address.js":
/*!**********************************************!*\
  !*** ./node_modules/ox/_esm/core/Address.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidAddressError: () => (/* binding */ InvalidAddressError),\n/* harmony export */   InvalidChecksumError: () => (/* binding */ InvalidChecksumError),\n/* harmony export */   InvalidInputError: () => (/* binding */ InvalidInputError),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   checksum: () => (/* binding */ checksum),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromPublicKey: () => (/* binding */ fromPublicKey),\n/* harmony export */   isEqual: () => (/* binding */ isEqual),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Caches_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Caches.js */ \"(ssr)/./node_modules/ox/_esm/core/Caches.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hash.js */ \"(ssr)/./node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _PublicKey_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PublicKey.js */ \"(ssr)/./node_modules/ox/_esm/core/PublicKey.js\");\n\n\n\n\n\nconst addressRegex = /^0x[a-fA-F0-9]{40}$/;\n/**\n * Asserts that the given value is a valid {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.assert('0xA0Cf798816D4b9b9866b5330EEa46a18382f251e')\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.assert('0xdeadbeef')\n * // @error: InvalidAddressError: Address \"0xdeadbeef\" is invalid.\n * ```\n *\n * @param value - Value to assert if it is a valid address.\n * @param options - Assertion options.\n */ function assert(value, options = {}) {\n    const { strict = true } = options;\n    if (!addressRegex.test(value)) throw new InvalidAddressError({\n        address: value,\n        cause: new InvalidInputError()\n    });\n    if (strict) {\n        if (value.toLowerCase() === value) return;\n        if (checksum(value) !== value) throw new InvalidAddressError({\n            address: value,\n            cause: new InvalidChecksumError()\n        });\n    }\n}\n/**\n * Computes the checksum address for the given {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.checksum('0xa0cf798816d4b9b9866b5330eea46a18382f251e')\n * // @log: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'\n * ```\n *\n * @param address - The address to compute the checksum for.\n * @returns The checksummed address.\n */ function checksum(address) {\n    if (_Caches_js__WEBPACK_IMPORTED_MODULE_0__.checksum.has(address)) return _Caches_js__WEBPACK_IMPORTED_MODULE_0__.checksum.get(address);\n    assert(address, {\n        strict: false\n    });\n    const hexAddress = address.substring(2).toLowerCase();\n    const hash = _Hash_js__WEBPACK_IMPORTED_MODULE_1__.keccak256(_Bytes_js__WEBPACK_IMPORTED_MODULE_2__.fromString(hexAddress), {\n        as: \"Bytes\"\n    });\n    const characters = hexAddress.split(\"\");\n    for(let i = 0; i < 40; i += 2){\n        if (hash[i >> 1] >> 4 >= 8 && characters[i]) {\n            characters[i] = characters[i].toUpperCase();\n        }\n        if ((hash[i >> 1] & 0x0f) >= 8 && characters[i + 1]) {\n            characters[i + 1] = characters[i + 1].toUpperCase();\n        }\n    }\n    const result = `0x${characters.join(\"\")}`;\n    _Caches_js__WEBPACK_IMPORTED_MODULE_0__.checksum.set(address, result);\n    return result;\n}\n/**\n * Converts a stringified address to a typed (optionally checksummed) {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('0xa0cf798816d4b9b9866b5330eea46a18382f251e')\n * // @log: '0xa0cf798816d4b9b9866b5330eea46a18382f251e'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('0xa0cf798816d4b9b9866b5330eea46a18382f251e', {\n *   checksum: true\n * })\n * // @log: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('hello')\n * // @error: InvalidAddressError: Address \"0xa\" is invalid.\n * ```\n *\n * @param address - An address string to convert to a typed Address.\n * @param options - Conversion options.\n * @returns The typed Address.\n */ function from(address, options = {}) {\n    const { checksum: checksumVal = false } = options;\n    assert(address);\n    if (checksumVal) return checksum(address);\n    return address;\n}\n/**\n * Converts an ECDSA public key to an {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address, PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from(\n *   '0x048318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5',\n * )\n * const address = Address.fromPublicKey(publicKey)\n * // @log: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266'\n * ```\n *\n * @param publicKey - The ECDSA public key to convert to an {@link ox#Address.Address}.\n * @param options - Conversion options.\n * @returns The {@link ox#Address.Address} corresponding to the public key.\n */ function fromPublicKey(publicKey, options = {}) {\n    const address = _Hash_js__WEBPACK_IMPORTED_MODULE_1__.keccak256(`0x${_PublicKey_js__WEBPACK_IMPORTED_MODULE_3__.toHex(publicKey).slice(4)}`).substring(26);\n    return from(`0x${address}`, options);\n}\n/**\n * Checks if two {@link ox#Address.Address} are equal.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.isEqual(\n *   '0xa0cf798816d4b9b9866b5330eea46a18382f251e',\n *   '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'\n * )\n * // @log: true\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.isEqual(\n *   '0xa0cf798816d4b9b9866b5330eea46a18382f251e',\n *   '0xA0Cf798816D4b9b9866b5330EEa46a18382f251f'\n * )\n * // @log: false\n * ```\n *\n * @param addressA - The first address to compare.\n * @param addressB - The second address to compare.\n * @returns Whether the addresses are equal.\n */ function isEqual(addressA, addressB) {\n    assert(addressA, {\n        strict: false\n    });\n    assert(addressB, {\n        strict: false\n    });\n    return addressA.toLowerCase() === addressB.toLowerCase();\n}\n/**\n * Checks if the given address is a valid {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.validate('0xA0Cf798816D4b9b9866b5330EEa46a18382f251e')\n * // @log: true\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.validate('0xdeadbeef')\n * // @log: false\n * ```\n *\n * @param address - Value to check if it is a valid address.\n * @param options - Check options.\n * @returns Whether the address is a valid address.\n */ function validate(address, options = {}) {\n    const { strict = true } = options ?? {};\n    try {\n        assert(address, {\n            strict\n        });\n        return true;\n    } catch  {\n        return false;\n    }\n}\n/**\n * Thrown when an address is invalid.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('0x123')\n * // @error: Address.InvalidAddressError: Address `0x123` is invalid.\n * ```\n */ class InvalidAddressError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ address, cause }){\n        super(`Address \"${address}\" is invalid.`, {\n            cause\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Address.InvalidAddressError\"\n        });\n    }\n}\n/** Thrown when an address is not a 20 byte (40 hexadecimal character) value. */ class InvalidInputError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor(){\n        super(\"Address is not a 20 byte (40 hexadecimal character) value.\");\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Address.InvalidInputError\"\n        });\n    }\n}\n/** Thrown when an address does not match its checksum counterpart. */ class InvalidChecksumError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor(){\n        super(\"Address does not match its checksum counterpart.\");\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Address.InvalidChecksumError\"\n        });\n    }\n} //# sourceMappingURL=Address.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0FkZHJlc3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb0M7QUFDRTtBQUNBO0FBQ0o7QUFDVTtBQUM1QyxNQUFNSyxlQUFlO0FBQ3JCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW9CQyxHQUNNLFNBQVNDLE9BQU9DLEtBQUssRUFBRUMsVUFBVSxDQUFDLENBQUM7SUFDdEMsTUFBTSxFQUFFQyxTQUFTLElBQUksRUFBRSxHQUFHRDtJQUMxQixJQUFJLENBQUNILGFBQWFLLElBQUksQ0FBQ0gsUUFDbkIsTUFBTSxJQUFJSSxvQkFBb0I7UUFDMUJDLFNBQVNMO1FBQ1RNLE9BQU8sSUFBSUM7SUFDZjtJQUNKLElBQUlMLFFBQVE7UUFDUixJQUFJRixNQUFNUSxXQUFXLE9BQU9SLE9BQ3hCO1FBQ0osSUFBSVMsU0FBU1QsV0FBV0EsT0FDcEIsTUFBTSxJQUFJSSxvQkFBb0I7WUFDMUJDLFNBQVNMO1lBQ1RNLE9BQU8sSUFBSUk7UUFDZjtJQUNSO0FBQ0o7QUFDQTs7Ozs7Ozs7Ozs7OztDQWFDLEdBQ00sU0FBU0QsU0FBU0osT0FBTztJQUM1QixJQUFJWCxnREFBZSxDQUFDaUIsR0FBRyxDQUFDTixVQUNwQixPQUFPWCxnREFBZSxDQUFDa0IsR0FBRyxDQUFDUDtJQUMvQk4sT0FBT00sU0FBUztRQUFFSCxRQUFRO0lBQU07SUFDaEMsTUFBTVcsYUFBYVIsUUFBUVMsU0FBUyxDQUFDLEdBQUdOLFdBQVc7SUFDbkQsTUFBTU8sT0FBT25CLCtDQUFjLENBQUNILGlEQUFnQixDQUFDb0IsYUFBYTtRQUFFSyxJQUFJO0lBQVE7SUFDeEUsTUFBTUMsYUFBYU4sV0FBV08sS0FBSyxDQUFDO0lBQ3BDLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJLElBQUlBLEtBQUssRUFBRztRQUM1QixJQUFJTixJQUFJLENBQUNNLEtBQUssRUFBRSxJQUFJLEtBQUssS0FBS0YsVUFBVSxDQUFDRSxFQUFFLEVBQUU7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bmQvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0FkZHJlc3MuanM/NDQ2OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBCeXRlcyBmcm9tICcuL0J5dGVzLmpzJztcbmltcG9ydCAqIGFzIENhY2hlcyBmcm9tICcuL0NhY2hlcy5qcyc7XG5pbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSAnLi9FcnJvcnMuanMnO1xuaW1wb3J0ICogYXMgSGFzaCBmcm9tICcuL0hhc2guanMnO1xuaW1wb3J0ICogYXMgUHVibGljS2V5IGZyb20gJy4vUHVibGljS2V5LmpzJztcbmNvbnN0IGFkZHJlc3NSZWdleCA9IC9eMHhbYS1mQS1GMC05XXs0MH0kLztcbi8qKlxuICogQXNzZXJ0cyB0aGF0IHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBveCNBZGRyZXNzLkFkZHJlc3N9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWRkcmVzcyB9IGZyb20gJ294J1xuICpcbiAqIEFkZHJlc3MuYXNzZXJ0KCcweEEwQ2Y3OTg4MTZENGI5Yjk4NjZiNTMzMEVFYTQ2YTE4MzgyZjI1MWUnKVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBZGRyZXNzIH0gZnJvbSAnb3gnXG4gKlxuICogQWRkcmVzcy5hc3NlcnQoJzB4ZGVhZGJlZWYnKVxuICogLy8gQGVycm9yOiBJbnZhbGlkQWRkcmVzc0Vycm9yOiBBZGRyZXNzIFwiMHhkZWFkYmVlZlwiIGlzIGludmFsaWQuXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZSB0byBhc3NlcnQgaWYgaXQgaXMgYSB2YWxpZCBhZGRyZXNzLlxuICogQHBhcmFtIG9wdGlvbnMgLSBBc3NlcnRpb24gb3B0aW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydCh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzdHJpY3QgPSB0cnVlIH0gPSBvcHRpb25zO1xuICAgIGlmICghYWRkcmVzc1JlZ2V4LnRlc3QodmFsdWUpKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcih7XG4gICAgICAgICAgICBhZGRyZXNzOiB2YWx1ZSxcbiAgICAgICAgICAgIGNhdXNlOiBuZXcgSW52YWxpZElucHV0RXJyb3IoKSxcbiAgICAgICAgfSk7XG4gICAgaWYgKHN0cmljdCkge1xuICAgICAgICBpZiAodmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gdmFsdWUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChjaGVja3N1bSh2YWx1ZSkgIT09IHZhbHVlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3Ioe1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IHZhbHVlLFxuICAgICAgICAgICAgICAgIGNhdXNlOiBuZXcgSW52YWxpZENoZWNrc3VtRXJyb3IoKSxcbiAgICAgICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGNoZWNrc3VtIGFkZHJlc3MgZm9yIHRoZSBnaXZlbiB7QGxpbmsgb3gjQWRkcmVzcy5BZGRyZXNzfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFkZHJlc3MgfSBmcm9tICdveCdcbiAqXG4gKiBBZGRyZXNzLmNoZWNrc3VtKCcweGEwY2Y3OTg4MTZkNGI5Yjk4NjZiNTMzMGVlYTQ2YTE4MzgyZjI1MWUnKVxuICogLy8gQGxvZzogJzB4QTBDZjc5ODgxNkQ0YjliOTg2NmI1MzMwRUVhNDZhMTgzODJmMjUxZSdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhZGRyZXNzIC0gVGhlIGFkZHJlc3MgdG8gY29tcHV0ZSB0aGUgY2hlY2tzdW0gZm9yLlxuICogQHJldHVybnMgVGhlIGNoZWNrc3VtbWVkIGFkZHJlc3MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaGVja3N1bShhZGRyZXNzKSB7XG4gICAgaWYgKENhY2hlcy5jaGVja3N1bS5oYXMoYWRkcmVzcykpXG4gICAgICAgIHJldHVybiBDYWNoZXMuY2hlY2tzdW0uZ2V0KGFkZHJlc3MpO1xuICAgIGFzc2VydChhZGRyZXNzLCB7IHN0cmljdDogZmFsc2UgfSk7XG4gICAgY29uc3QgaGV4QWRkcmVzcyA9IGFkZHJlc3Muc3Vic3RyaW5nKDIpLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgaGFzaCA9IEhhc2gua2VjY2FrMjU2KEJ5dGVzLmZyb21TdHJpbmcoaGV4QWRkcmVzcyksIHsgYXM6ICdCeXRlcycgfSk7XG4gICAgY29uc3QgY2hhcmFjdGVycyA9IGhleEFkZHJlc3Muc3BsaXQoJycpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDA7IGkgKz0gMikge1xuICAgICAgICBpZiAoaGFzaFtpID4+IDFdID4+IDQgPj0gOCAmJiBjaGFyYWN0ZXJzW2ldKSB7XG4gICAgICAgICAgICBjaGFyYWN0ZXJzW2ldID0gY2hhcmFjdGVyc1tpXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoaGFzaFtpID4+IDFdICYgMHgwZikgPj0gOCAmJiBjaGFyYWN0ZXJzW2kgKyAxXSkge1xuICAgICAgICAgICAgY2hhcmFjdGVyc1tpICsgMV0gPSBjaGFyYWN0ZXJzW2kgKyAxXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGAweCR7Y2hhcmFjdGVycy5qb2luKCcnKX1gO1xuICAgIENhY2hlcy5jaGVja3N1bS5zZXQoYWRkcmVzcywgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIHN0cmluZ2lmaWVkIGFkZHJlc3MgdG8gYSB0eXBlZCAob3B0aW9uYWxseSBjaGVja3N1bW1lZCkge0BsaW5rIG94I0FkZHJlc3MuQWRkcmVzc30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBZGRyZXNzIH0gZnJvbSAnb3gnXG4gKlxuICogQWRkcmVzcy5mcm9tKCcweGEwY2Y3OTg4MTZkNGI5Yjk4NjZiNTMzMGVlYTQ2YTE4MzgyZjI1MWUnKVxuICogLy8gQGxvZzogJzB4YTBjZjc5ODgxNmQ0YjliOTg2NmI1MzMwZWVhNDZhMTgzODJmMjUxZSdcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWRkcmVzcyB9IGZyb20gJ294J1xuICpcbiAqIEFkZHJlc3MuZnJvbSgnMHhhMGNmNzk4ODE2ZDRiOWI5ODY2YjUzMzBlZWE0NmExODM4MmYyNTFlJywge1xuICogICBjaGVja3N1bTogdHJ1ZVxuICogfSlcbiAqIC8vIEBsb2c6ICcweEEwQ2Y3OTg4MTZENGI5Yjk4NjZiNTMzMEVFYTQ2YTE4MzgyZjI1MWUnXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFkZHJlc3MgfSBmcm9tICdveCdcbiAqXG4gKiBBZGRyZXNzLmZyb20oJ2hlbGxvJylcbiAqIC8vIEBlcnJvcjogSW52YWxpZEFkZHJlc3NFcnJvcjogQWRkcmVzcyBcIjB4YVwiIGlzIGludmFsaWQuXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYWRkcmVzcyAtIEFuIGFkZHJlc3Mgc3RyaW5nIHRvIGNvbnZlcnQgdG8gYSB0eXBlZCBBZGRyZXNzLlxuICogQHBhcmFtIG9wdGlvbnMgLSBDb252ZXJzaW9uIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgdHlwZWQgQWRkcmVzcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb20oYWRkcmVzcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBjaGVja3N1bTogY2hlY2tzdW1WYWwgPSBmYWxzZSB9ID0gb3B0aW9ucztcbiAgICBhc3NlcnQoYWRkcmVzcyk7XG4gICAgaWYgKGNoZWNrc3VtVmFsKVxuICAgICAgICByZXR1cm4gY2hlY2tzdW0oYWRkcmVzcyk7XG4gICAgcmV0dXJuIGFkZHJlc3M7XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIEVDRFNBIHB1YmxpYyBrZXkgdG8gYW4ge0BsaW5rIG94I0FkZHJlc3MuQWRkcmVzc30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBZGRyZXNzLCBQdWJsaWNLZXkgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwdWJsaWNLZXkgPSBQdWJsaWNLZXkuZnJvbShcbiAqICAgJzB4MDQ4MzE4NTM1YjU0MTA1ZDRhN2FhZTYwYzA4ZmM0NWY5Njg3MTgxYjRmZGZjNjI1YmQxYTc1M2ZhNzM5N2ZlZDc1MzU0N2YxMWNhODY5NjY0NmYyZjNhY2IwOGUzMTAxNmFmYWMyM2U2MzBjNWQxMWY1OWY2MWZlZjU3YjBkMmFhNScsXG4gKiApXG4gKiBjb25zdCBhZGRyZXNzID0gQWRkcmVzcy5mcm9tUHVibGljS2V5KHB1YmxpY0tleSlcbiAqIC8vIEBsb2c6ICcweGYzOWZkNmU1MWFhZDg4ZjZmNGNlNmFiODgyNzI3OWNmZmZiOTIyNjYnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gcHVibGljS2V5IC0gVGhlIEVDRFNBIHB1YmxpYyBrZXkgdG8gY29udmVydCB0byBhbiB7QGxpbmsgb3gjQWRkcmVzcy5BZGRyZXNzfS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gQ29udmVyc2lvbiBvcHRpb25zLlxuICogQHJldHVybnMgVGhlIHtAbGluayBveCNBZGRyZXNzLkFkZHJlc3N9IGNvcnJlc3BvbmRpbmcgdG8gdGhlIHB1YmxpYyBrZXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUHVibGljS2V5KHB1YmxpY0tleSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgYWRkcmVzcyA9IEhhc2gua2VjY2FrMjU2KGAweCR7UHVibGljS2V5LnRvSGV4KHB1YmxpY0tleSkuc2xpY2UoNCl9YCkuc3Vic3RyaW5nKDI2KTtcbiAgICByZXR1cm4gZnJvbShgMHgke2FkZHJlc3N9YCwgb3B0aW9ucyk7XG59XG4vKipcbiAqIENoZWNrcyBpZiB0d28ge0BsaW5rIG94I0FkZHJlc3MuQWRkcmVzc30gYXJlIGVxdWFsLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWRkcmVzcyB9IGZyb20gJ294J1xuICpcbiAqIEFkZHJlc3MuaXNFcXVhbChcbiAqICAgJzB4YTBjZjc5ODgxNmQ0YjliOTg2NmI1MzMwZWVhNDZhMTgzODJmMjUxZScsXG4gKiAgICcweEEwQ2Y3OTg4MTZENGI5Yjk4NjZiNTMzMEVFYTQ2YTE4MzgyZjI1MWUnXG4gKiApXG4gKiAvLyBAbG9nOiB0cnVlXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFkZHJlc3MgfSBmcm9tICdveCdcbiAqXG4gKiBBZGRyZXNzLmlzRXF1YWwoXG4gKiAgICcweGEwY2Y3OTg4MTZkNGI5Yjk4NjZiNTMzMGVlYTQ2YTE4MzgyZjI1MWUnLFxuICogICAnMHhBMENmNzk4ODE2RDRiOWI5ODY2YjUzMzBFRWE0NmExODM4MmYyNTFmJ1xuICogKVxuICogLy8gQGxvZzogZmFsc2VcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhZGRyZXNzQSAtIFRoZSBmaXJzdCBhZGRyZXNzIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0gYWRkcmVzc0IgLSBUaGUgc2Vjb25kIGFkZHJlc3MgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGFkZHJlc3NlcyBhcmUgZXF1YWwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0VxdWFsKGFkZHJlc3NBLCBhZGRyZXNzQikge1xuICAgIGFzc2VydChhZGRyZXNzQSwgeyBzdHJpY3Q6IGZhbHNlIH0pO1xuICAgIGFzc2VydChhZGRyZXNzQiwgeyBzdHJpY3Q6IGZhbHNlIH0pO1xuICAgIHJldHVybiBhZGRyZXNzQS50b0xvd2VyQ2FzZSgpID09PSBhZGRyZXNzQi50b0xvd2VyQ2FzZSgpO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIGFkZHJlc3MgaXMgYSB2YWxpZCB7QGxpbmsgb3gjQWRkcmVzcy5BZGRyZXNzfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFkZHJlc3MgfSBmcm9tICdveCdcbiAqXG4gKiBBZGRyZXNzLnZhbGlkYXRlKCcweEEwQ2Y3OTg4MTZENGI5Yjk4NjZiNTMzMEVFYTQ2YTE4MzgyZjI1MWUnKVxuICogLy8gQGxvZzogdHJ1ZVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBZGRyZXNzIH0gZnJvbSAnb3gnXG4gKlxuICogQWRkcmVzcy52YWxpZGF0ZSgnMHhkZWFkYmVlZicpXG4gKiAvLyBAbG9nOiBmYWxzZVxuICogYGBgXG4gKlxuICogQHBhcmFtIGFkZHJlc3MgLSBWYWx1ZSB0byBjaGVjayBpZiBpdCBpcyBhIHZhbGlkIGFkZHJlc3MuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIENoZWNrIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBhZGRyZXNzIGlzIGEgdmFsaWQgYWRkcmVzcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlKGFkZHJlc3MsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc3RyaWN0ID0gdHJ1ZSB9ID0gb3B0aW9ucyA/PyB7fTtcbiAgICB0cnkge1xuICAgICAgICBhc3NlcnQoYWRkcmVzcywgeyBzdHJpY3QgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIGFuIGFkZHJlc3MgaXMgaW52YWxpZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFkZHJlc3MgfSBmcm9tICdveCdcbiAqXG4gKiBBZGRyZXNzLmZyb20oJzB4MTIzJylcbiAqIC8vIEBlcnJvcjogQWRkcmVzcy5JbnZhbGlkQWRkcmVzc0Vycm9yOiBBZGRyZXNzIGAweDEyM2AgaXMgaW52YWxpZC5cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZEFkZHJlc3NFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgYWRkcmVzcywgY2F1c2UgfSkge1xuICAgICAgICBzdXBlcihgQWRkcmVzcyBcIiR7YWRkcmVzc31cIiBpcyBpbnZhbGlkLmAsIHtcbiAgICAgICAgICAgIGNhdXNlLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0FkZHJlc3MuSW52YWxpZEFkZHJlc3NFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqIFRocm93biB3aGVuIGFuIGFkZHJlc3MgaXMgbm90IGEgMjAgYnl0ZSAoNDAgaGV4YWRlY2ltYWwgY2hhcmFjdGVyKSB2YWx1ZS4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkSW5wdXRFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignQWRkcmVzcyBpcyBub3QgYSAyMCBieXRlICg0MCBoZXhhZGVjaW1hbCBjaGFyYWN0ZXIpIHZhbHVlLicpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQWRkcmVzcy5JbnZhbGlkSW5wdXRFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqIFRocm93biB3aGVuIGFuIGFkZHJlc3MgZG9lcyBub3QgbWF0Y2ggaXRzIGNoZWNrc3VtIGNvdW50ZXJwYXJ0LiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRDaGVja3N1bUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdBZGRyZXNzIGRvZXMgbm90IG1hdGNoIGl0cyBjaGVja3N1bSBjb3VudGVycGFydC4nKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0FkZHJlc3MuSW52YWxpZENoZWNrc3VtRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFkZHJlc3MuanMubWFwIl0sIm5hbWVzIjpbIkJ5dGVzIiwiQ2FjaGVzIiwiRXJyb3JzIiwiSGFzaCIsIlB1YmxpY0tleSIsImFkZHJlc3NSZWdleCIsImFzc2VydCIsInZhbHVlIiwib3B0aW9ucyIsInN0cmljdCIsInRlc3QiLCJJbnZhbGlkQWRkcmVzc0Vycm9yIiwiYWRkcmVzcyIsImNhdXNlIiwiSW52YWxpZElucHV0RXJyb3IiLCJ0b0xvd2VyQ2FzZSIsImNoZWNrc3VtIiwiSW52YWxpZENoZWNrc3VtRXJyb3IiLCJoYXMiLCJnZXQiLCJoZXhBZGRyZXNzIiwic3Vic3RyaW5nIiwiaGFzaCIsImtlY2NhazI1NiIsImZyb21TdHJpbmciLCJhcyIsImNoYXJhY3RlcnMiLCJzcGxpdCIsImkiLCJ0b1VwcGVyQ2FzZSIsInJlc3VsdCIsImpvaW4iLCJzZXQiLCJmcm9tIiwiY2hlY2tzdW1WYWwiLCJmcm9tUHVibGljS2V5IiwicHVibGljS2V5IiwidG9IZXgiLCJzbGljZSIsImlzRXF1YWwiLCJhZGRyZXNzQSIsImFkZHJlc3NCIiwidmFsaWRhdGUiLCJCYXNlRXJyb3IiLCJjb25zdHJ1Y3RvciIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Address.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Authorization.js":
/*!****************************************************!*\
  !*** ./node_modules/ox/_esm/core/Authorization.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromRpc: () => (/* binding */ fromRpc),\n/* harmony export */   fromRpcList: () => (/* binding */ fromRpcList),\n/* harmony export */   fromTuple: () => (/* binding */ fromTuple),\n/* harmony export */   fromTupleList: () => (/* binding */ fromTupleList),\n/* harmony export */   getSignPayload: () => (/* binding */ getSignPayload),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   toRpc: () => (/* binding */ toRpc),\n/* harmony export */   toRpcList: () => (/* binding */ toRpcList),\n/* harmony export */   toTuple: () => (/* binding */ toTuple),\n/* harmony export */   toTupleList: () => (/* binding */ toTupleList)\n/* harmony export */ });\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hash.js */ \"(ssr)/./node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Rlp_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Rlp.js */ \"(ssr)/./node_modules/ox/_esm/core/Rlp.js\");\n/* harmony import */ var _Signature_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Signature.js */ \"(ssr)/./node_modules/ox/_esm/core/Signature.js\");\n\n\n\n\n/**\n * Converts an [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization object into a typed {@link ox#Authorization.Authorization}.\n *\n * @example\n * An Authorization can be instantiated from an [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple in object format.\n *\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * A {@link ox#Signature.Signature} can be attached with the `signature` option. The example below demonstrates signing\n * an Authorization with {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * import { Authorization, Secp256k1 } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   chainId: 1,\n *   nonce: 40n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: Authorization.getSignPayload(authorization),\n *   privateKey: '0x...',\n * })\n *\n * const authorization_signed = Authorization.from(authorization, { signature }) // [!code focus]\n * ```\n *\n * @param authorization - An [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple in object format.\n * @param options - Authorization options.\n * @returns The {@link ox#Authorization.Authorization}.\n */ function from(authorization, options = {}) {\n    if (typeof authorization.chainId === \"string\") return fromRpc(authorization);\n    return {\n        ...authorization,\n        ...options.signature\n    };\n}\n/**\n * Converts an {@link ox#Authorization.Rpc} to an {@link ox#Authorization.Authorization}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.fromRpc({\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: '0x1',\n *   nonce: '0x1',\n *   r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *   s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *   yParity: '0x0',\n * })\n * ```\n *\n * @param authorization - The RPC-formatted Authorization.\n * @returns A signed {@link ox#Authorization.Authorization}.\n */ function fromRpc(authorization) {\n    const { address, chainId, nonce } = authorization;\n    const signature = _Signature_js__WEBPACK_IMPORTED_MODULE_0__.extract(authorization);\n    return {\n        address,\n        chainId: Number(chainId),\n        nonce: BigInt(nonce),\n        ...signature\n    };\n}\n/**\n * Converts an {@link ox#Authorization.ListRpc} to an {@link ox#Authorization.List}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorizationList = Authorization.fromRpcList([{\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: '0x1',\n *   nonce: '0x1',\n *   r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *   s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *   yParity: '0x0',\n * }])\n * ```\n *\n * @param authorizationList - The RPC-formatted Authorization list.\n * @returns A signed {@link ox#Authorization.List}.\n */ function fromRpcList(authorizationList) {\n    return authorizationList.map(fromRpc);\n}\n/**\n * Converts an {@link ox#Authorization.Tuple} to an {@link ox#Authorization.Authorization}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.fromTuple([\n *   '0x1',\n *   '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   '0x3'\n * ])\n * // @log: {\n * // @log:   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:   chainId: 1,\n * // @log:   nonce: 3n\n * // @log: }\n * ```\n *\n * @example\n * It is also possible to append a Signature tuple to the end of an Authorization tuple.\n *\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.fromTuple([\n *   '0x1',\n *   '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   '0x3',\n *   '0x1',\n *   '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90',\n *   '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064',\n * ])\n * // @log: {\n * // @log:   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:   chainId: 1,\n * // @log:   nonce: 3n\n * // @log:   r: BigInt('0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90'),\n * // @log:   s: BigInt('0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'),\n * // @log:   yParity: 0,\n * // @log: }\n * ```\n *\n * @param tuple - The [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple.\n * @returns The {@link ox#Authorization.Authorization}.\n */ function fromTuple(tuple) {\n    const [chainId, address, nonce, yParity, r, s] = tuple;\n    let args = {\n        address,\n        chainId: chainId === \"0x\" ? 0 : Number(chainId),\n        nonce: nonce === \"0x\" ? 0n : BigInt(nonce)\n    };\n    if (yParity && r && s) args = {\n        ...args,\n        ..._Signature_js__WEBPACK_IMPORTED_MODULE_0__.fromTuple([\n            yParity,\n            r,\n            s\n        ])\n    };\n    return from(args);\n}\n/**\n * Converts an {@link ox#Authorization.TupleList} to an {@link ox#Authorization.List}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorizationList = Authorization.fromTupleList([\n *   ['0x1', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x3'],\n *   ['0x3', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x14'],\n * ])\n * // @log: [\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 1,\n * // @log:     nonce: 3n,\n * // @log:   },\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 3,\n * // @log:     nonce: 20n,\n * // @log:   },\n * // @log: ]\n * ```\n *\n * @example\n * It is also possible to append a Signature tuple to the end of an Authorization tuple.\n *\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorizationList = Authorization.fromTupleList([\n *   ['0x1', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x3', '0x1', '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90', '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'],\n *   ['0x3', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x14', '0x1', '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90', '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'],\n * ])\n * // @log: [\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 1,\n * // @log:     nonce: 3n,\n * // @log:     r: BigInt('0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90'),\n * // @log:     s: BigInt('0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'),\n * // @log:     yParity: 0,\n * // @log:   },\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 3,\n * // @log:     nonce: 20n,\n * // @log:     r: BigInt('0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90'),\n * // @log:     s: BigInt('0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'),\n * // @log:     yParity: 0,\n * // @log:   },\n * // @log: ]\n * ```\n *\n * @param tupleList - The [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple list.\n * @returns An {@link ox#Authorization.List}.\n */ function fromTupleList(tupleList) {\n    const list = [];\n    for (const tuple of tupleList)list.push(fromTuple(tuple));\n    return list;\n}\n/**\n * Computes the sign payload for an {@link ox#Authorization.Authorization} in [EIP-7702 format](https://eips.ethereum.org/EIPS/eip-7702): `keccak256('0x05' || rlp([chain_id, address, nonce]))`.\n *\n * @example\n * The example below demonstrates computing the sign payload for an {@link ox#Authorization.Authorization}. This payload\n * can then be passed to signing functions like {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * import { Authorization, Secp256k1 } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const payload = Authorization.getSignPayload(authorization) // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload,\n *   privateKey: '0x...',\n * })\n * ```\n *\n * @param authorization - The {@link ox#Authorization.Authorization}.\n * @returns The sign payload.\n */ function getSignPayload(authorization) {\n    return hash(authorization, {\n        presign: true\n    });\n}\n/**\n * Computes the hash for an {@link ox#Authorization.Authorization} in [EIP-7702 format](https://eips.ethereum.org/EIPS/eip-7702): `keccak256('0x05' || rlp([chain_id, address, nonce]))`.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const hash = Authorization.hash(authorization) // [!code focus]\n * ```\n *\n * @param authorization - The {@link ox#Authorization.Authorization}.\n * @returns The hash.\n */ function hash(authorization, options = {}) {\n    const { presign } = options;\n    return _Hash_js__WEBPACK_IMPORTED_MODULE_1__.keccak256(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(\"0x05\", _Rlp_js__WEBPACK_IMPORTED_MODULE_3__.fromHex(toTuple(presign ? {\n        address: authorization.address,\n        chainId: authorization.chainId,\n        nonce: authorization.nonce\n    } : authorization))));\n}\n/**\n * Converts an {@link ox#Authorization.Authorization} to an {@link ox#Authorization.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.toRpc({\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: 1,\n *   nonce: 1n,\n *   r: 44944627813007772897391531230081695102703289123332187696115181104739239197517n,\n *   s: 36528503505192438307355164441104001310566505351980369085208178712678799181120n,\n *   yParity: 0,\n * })\n * ```\n *\n * @param authorization - An Authorization.\n * @returns An RPC-formatted Authorization.\n */ function toRpc(authorization) {\n    const { address, chainId, nonce, ...signature } = authorization;\n    return {\n        address,\n        chainId: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(chainId),\n        nonce: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(nonce),\n        ..._Signature_js__WEBPACK_IMPORTED_MODULE_0__.toRpc(signature)\n    };\n}\n/**\n * Converts an {@link ox#Authorization.List} to an {@link ox#Authorization.ListRpc}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.toRpcList([{\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: 1,\n *   nonce: 1n,\n *   r: 44944627813007772897391531230081695102703289123332187696115181104739239197517n,\n *   s: 36528503505192438307355164441104001310566505351980369085208178712678799181120n,\n *   yParity: 0,\n * }])\n * ```\n *\n * @param authorizationList - An Authorization List.\n * @returns An RPC-formatted Authorization List.\n */ function toRpcList(authorizationList) {\n    return authorizationList.map(toRpc);\n}\n/**\n * Converts an {@link ox#Authorization.Authorization} to an {@link ox#Authorization.Tuple}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const tuple = Authorization.toTuple(authorization) // [!code focus]\n * // @log: [\n * // @log:   address: '0x1234567890abcdef1234567890abcdef12345678',\n * // @log:   chainId: 1,\n * // @log:   nonce: 69n,\n * // @log: ]\n * ```\n *\n * @param authorization - The {@link ox#Authorization.Authorization}.\n * @returns An [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple.\n */ function toTuple(authorization) {\n    const { address, chainId, nonce } = authorization;\n    const signature = _Signature_js__WEBPACK_IMPORTED_MODULE_0__.extract(authorization);\n    return [\n        chainId ? _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(chainId) : \"0x\",\n        address,\n        nonce ? _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(nonce) : \"0x\",\n        ...signature ? _Signature_js__WEBPACK_IMPORTED_MODULE_0__.toTuple(signature) : []\n    ];\n}\n/**\n * Converts an {@link ox#Authorization.List} to an {@link ox#Authorization.TupleList}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization_1 = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n * const authorization_2 = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 3,\n *   nonce: 20n,\n * })\n *\n * const tuple = Authorization.toTupleList([authorization_1, authorization_2]) // [!code focus]\n * // @log: [\n * // @log:   [\n * // @log:     address: '0x1234567890abcdef1234567890abcdef12345678',\n * // @log:     chainId: 1,\n * // @log:     nonce: 69n,\n * // @log:   ],\n * // @log:   [\n * // @log:     address: '0x1234567890abcdef1234567890abcdef12345678',\n * // @log:     chainId: 3,\n * // @log:     nonce: 20n,\n * // @log:   ],\n * // @log: ]\n * ```\n *\n * @param list - An {@link ox#Authorization.List}.\n * @returns An [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple list.\n */ function toTupleList(list) {\n    if (!list || list.length === 0) return [];\n    const tupleList = [];\n    for (const authorization of list)tupleList.push(toTuple(authorization));\n    return tupleList;\n} //# sourceMappingURL=Authorization.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0F1dGhvcml6YXRpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWtDO0FBQ0Y7QUFDQTtBQUNZO0FBQzVDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0EwQ0MsR0FDTSxTQUFTSSxLQUFLQyxhQUFhLEVBQUVDLFVBQVUsQ0FBQyxDQUFDO0lBQzVDLElBQUksT0FBT0QsY0FBY0UsT0FBTyxLQUFLLFVBQ2pDLE9BQU9DLFFBQVFIO0lBQ25CLE9BQU87UUFBRSxHQUFHQSxhQUFhO1FBQUUsR0FBR0MsUUFBUUcsU0FBUztJQUFDO0FBQ3BEO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FtQkMsR0FDTSxTQUFTRCxRQUFRSCxhQUFhO0lBQ2pDLE1BQU0sRUFBRUssT0FBTyxFQUFFSCxPQUFPLEVBQUVJLEtBQUssRUFBRSxHQUFHTjtJQUNwQyxNQUFNSSxZQUFZTixrREFBaUIsQ0FBQ0U7SUFDcEMsT0FBTztRQUNISztRQUNBSCxTQUFTTSxPQUFPTjtRQUNoQkksT0FBT0csT0FBT0g7UUFDZCxHQUFHRixTQUFTO0lBQ2hCO0FBQ0o7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW1CQyxHQUNNLFNBQVNNLFlBQVlDLGlCQUFpQjtJQUN6QyxPQUFPQSxrQkFBa0JDLEdBQUcsQ0FBQ1Q7QUFDakM7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBNkNDLEdBQ00sU0FBU1UsVUFBVUMsS0FBSztJQUMzQixNQUFNLENBQUNaLFNBQVNHLFNBQVNDLE9BQU9TLFNBQVNDLEdBQUdDLEVBQUUsR0FBR0g7SUFDakQsSUFBSUksT0FBTztRQUNQYjtRQUNBSCxTQUFTQSxZQUFZLE9BQU8sSUFBSU0sT0FBT047UUFDdkNJLE9BQU9BLFVBQVUsT0FBTyxFQUFFLEdBQUdHLE9BQU9IO0lBQ3hDO0lBQ0EsSUFBSVMsV0FBV0MsS0FBS0MsR0FDaEJDLE9BQU87UUFBRSxHQUFHQSxJQUFJO1FBQUUsR0FBR3BCLG9EQUFtQixDQUFDO1lBQUNpQjtZQUFTQztZQUFHQztTQUFFLENBQUM7SUFBQztJQUM5RCxPQUFPbEIsS0FBS21CO0FBQ2hCO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXlEQyxHQUNNLFNBQVNDLGNBQWNDLFNBQVM7SUFDbkMsTUFBTUMsT0FBTyxFQUFFO0lBQ2YsS0FBSyxNQUFNUCxTQUFTTSxVQUNoQkMsS0FBS0MsSUFBSSxDQUFDVCxVQUFVQztJQUN4QixPQUFPTztBQUNYO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBMEJDLEdBQ00sU0FBU0UsZUFBZXZCLGFBQWE7SUFDeEMsT0FBT3dCLEtBQUt4QixlQUFlO1FBQUV5QixTQUFTO0lBQUs7QUFDL0M7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBa0JDLEdBQ00sU0FBU0QsS0FBS3hCLGFBQWEsRUFBRUMsVUFBVSxDQUFDLENBQUM7SUFDNUMsTUFBTSxFQUFFd0IsT0FBTyxFQUFFLEdBQUd4QjtJQUNwQixPQUFPTiwrQ0FBYyxDQUFDQywyQ0FBVSxDQUFDLFFBQVFDLDRDQUFXLENBQUNnQyxRQUFRSixVQUN2RDtRQUNFcEIsU0FBU0wsY0FBY0ssT0FBTztRQUM5QkgsU0FBU0YsY0FBY0UsT0FBTztRQUM5QkksT0FBT04sY0FBY00sS0FBSztJQUM5QixJQUNFTjtBQUNWO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FtQkMsR0FDTSxTQUFTOEIsTUFBTTlCLGFBQWE7SUFDL0IsTUFBTSxFQUFFSyxPQUFPLEVBQUVILE9BQU8sRUFBRUksS0FBSyxFQUFFLEdBQUdGLFdBQVcsR0FBR0o7SUFDbEQsT0FBTztRQUNISztRQUNBSCxTQUFTTiwrQ0FBYyxDQUFDTTtRQUN4QkksT0FBT1YsK0NBQWMsQ0FBQ1U7UUFDdEIsR0FBR1IsZ0RBQWUsQ0FBQ00sVUFBVTtJQUNqQztBQUNKO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FtQkMsR0FDTSxTQUFTNEIsVUFBVXJCLGlCQUFpQjtJQUN2QyxPQUFPQSxrQkFBa0JDLEdBQUcsQ0FBQ2tCO0FBQ2pDO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBdUJDLEdBQ00sU0FBU0QsUUFBUTdCLGFBQWE7SUFDakMsTUFBTSxFQUFFSyxPQUFPLEVBQUVILE9BQU8sRUFBRUksS0FBSyxFQUFFLEdBQUdOO0lBQ3BDLE1BQU1JLFlBQVlOLGtEQUFpQixDQUFDRTtJQUNwQyxPQUFPO1FBQ0hFLFVBQVVOLCtDQUFjLENBQUNNLFdBQVc7UUFDcENHO1FBQ0FDLFFBQVFWLCtDQUFjLENBQUNVLFNBQVM7V0FDNUJGLFlBQVlOLGtEQUFpQixDQUFDTSxhQUFhLEVBQUU7S0FDcEQ7QUFDTDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW1DQyxHQUNNLFNBQVM2QixZQUFZWixJQUFJO0lBQzVCLElBQUksQ0FBQ0EsUUFBUUEsS0FBS2EsTUFBTSxLQUFLLEdBQ3pCLE9BQU8sRUFBRTtJQUNiLE1BQU1kLFlBQVksRUFBRTtJQUNwQixLQUFLLE1BQU1wQixpQkFBaUJxQixLQUN4QkQsVUFBVUUsSUFBSSxDQUFDTyxRQUFRN0I7SUFDM0IsT0FBT29CO0FBQ1gsRUFDQSx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGF3LXdvcmtzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9BdXRob3JpemF0aW9uLmpzPzJmYjEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgSGFzaCBmcm9tICcuL0hhc2guanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbmltcG9ydCAqIGFzIFJscCBmcm9tICcuL1JscC5qcyc7XG5pbXBvcnQgKiBhcyBTaWduYXR1cmUgZnJvbSAnLi9TaWduYXR1cmUuanMnO1xuLyoqXG4gKiBDb252ZXJ0cyBhbiBbRUlQLTc3MDJdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNzcwMikgQXV0aG9yaXphdGlvbiBvYmplY3QgaW50byBhIHR5cGVkIHtAbGluayBveCNBdXRob3JpemF0aW9uLkF1dGhvcml6YXRpb259LlxuICpcbiAqIEBleGFtcGxlXG4gKiBBbiBBdXRob3JpemF0aW9uIGNhbiBiZSBpbnN0YW50aWF0ZWQgZnJvbSBhbiBbRUlQLTc3MDJdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNzcwMikgQXV0aG9yaXphdGlvbiB0dXBsZSBpbiBvYmplY3QgZm9ybWF0LlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEF1dGhvcml6YXRpb24uZnJvbSh7XG4gKiAgIGFkZHJlc3M6ICcweDEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3ODkwYWJjZGVmMTIzNDU2NzgnLFxuICogICBjaGFpbklkOiAxLFxuICogICBub25jZTogNjluLFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgQXR0YWNoaW5nIFNpZ25hdHVyZXNcbiAqXG4gKiBBIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfSBjYW4gYmUgYXR0YWNoZWQgd2l0aCB0aGUgYHNpZ25hdHVyZWAgb3B0aW9uLiBUaGUgZXhhbXBsZSBiZWxvdyBkZW1vbnN0cmF0ZXMgc2lnbmluZ1xuICogYW4gQXV0aG9yaXphdGlvbiB3aXRoIHtAbGluayBveCNTZWNwMjU2azEuKHNpZ246ZnVuY3Rpb24pfS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQXV0aG9yaXphdGlvbiwgU2VjcDI1NmsxIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEF1dGhvcml6YXRpb24uZnJvbSh7XG4gKiAgIGFkZHJlc3M6ICcweGJlOTVjM2Y1NTRlOWZjODVlYzUxYmU2OWEzZDgwN2EwZDU1YmNmMmMnLFxuICogICBjaGFpbklkOiAxLFxuICogICBub25jZTogNDBuLFxuICogfSlcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7XG4gKiAgIHBheWxvYWQ6IEF1dGhvcml6YXRpb24uZ2V0U2lnblBheWxvYWQoYXV0aG9yaXphdGlvbiksXG4gKiAgIHByaXZhdGVLZXk6ICcweC4uLicsXG4gKiB9KVxuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb25fc2lnbmVkID0gQXV0aG9yaXphdGlvbi5mcm9tKGF1dGhvcml6YXRpb24sIHsgc2lnbmF0dXJlIH0pIC8vIFshY29kZSBmb2N1c11cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRob3JpemF0aW9uIC0gQW4gW0VJUC03NzAyXShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTc3MDIpIEF1dGhvcml6YXRpb24gdHVwbGUgaW4gb2JqZWN0IGZvcm1hdC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gQXV0aG9yaXphdGlvbiBvcHRpb25zLlxuICogQHJldHVybnMgVGhlIHtAbGluayBveCNBdXRob3JpemF0aW9uLkF1dGhvcml6YXRpb259LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbShhdXRob3JpemF0aW9uLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAodHlwZW9mIGF1dGhvcml6YXRpb24uY2hhaW5JZCA9PT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiBmcm9tUnBjKGF1dGhvcml6YXRpb24pO1xuICAgIHJldHVybiB7IC4uLmF1dGhvcml6YXRpb24sIC4uLm9wdGlvbnMuc2lnbmF0dXJlIH07XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLlJwY30gdG8gYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb24uQXV0aG9yaXphdGlvbn0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEF1dGhvcml6YXRpb24uZnJvbVJwYyh7XG4gKiAgIGFkZHJlc3M6ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICBjaGFpbklkOiAnMHgxJyxcbiAqICAgbm9uY2U6ICcweDEnLFxuICogICByOiAnMHg2MzVkYzIwMzNlNjAxODViYjM2NzA5YzI5Yzc1ZDY0ZWE1MWRmYmQ5MWMzMmVmNGJlMTk4ZTRjZWIxNjlmYjRkJyxcbiAqICAgczogJzB4NTBjMjY2N2FjNGM3NzEwNzI3NDZhY2ZkY2YxZjE0ODMzMzZkY2NhOGJkMmRmNDdjZDgzMTc1ZGJlNjBmMDU0MCcsXG4gKiAgIHlQYXJpdHk6ICcweDAnLFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRob3JpemF0aW9uIC0gVGhlIFJQQy1mb3JtYXR0ZWQgQXV0aG9yaXphdGlvbi5cbiAqIEByZXR1cm5zIEEgc2lnbmVkIHtAbGluayBveCNBdXRob3JpemF0aW9uLkF1dGhvcml6YXRpb259LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJwYyhhdXRob3JpemF0aW9uKSB7XG4gICAgY29uc3QgeyBhZGRyZXNzLCBjaGFpbklkLCBub25jZSB9ID0gYXV0aG9yaXphdGlvbjtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBTaWduYXR1cmUuZXh0cmFjdChhdXRob3JpemF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhZGRyZXNzLFxuICAgICAgICBjaGFpbklkOiBOdW1iZXIoY2hhaW5JZCksXG4gICAgICAgIG5vbmNlOiBCaWdJbnQobm9uY2UpLFxuICAgICAgICAuLi5zaWduYXR1cmUsXG4gICAgfTtcbn1cbi8qKlxuICogQ29udmVydHMgYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb24uTGlzdFJwY30gdG8gYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb24uTGlzdH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbkxpc3QgPSBBdXRob3JpemF0aW9uLmZyb21ScGNMaXN0KFt7XG4gKiAgIGFkZHJlc3M6ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICBjaGFpbklkOiAnMHgxJyxcbiAqICAgbm9uY2U6ICcweDEnLFxuICogICByOiAnMHg2MzVkYzIwMzNlNjAxODViYjM2NzA5YzI5Yzc1ZDY0ZWE1MWRmYmQ5MWMzMmVmNGJlMTk4ZTRjZWIxNjlmYjRkJyxcbiAqICAgczogJzB4NTBjMjY2N2FjNGM3NzEwNzI3NDZhY2ZkY2YxZjE0ODMzMzZkY2NhOGJkMmRmNDdjZDgzMTc1ZGJlNjBmMDU0MCcsXG4gKiAgIHlQYXJpdHk6ICcweDAnLFxuICogfV0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYXV0aG9yaXphdGlvbkxpc3QgLSBUaGUgUlBDLWZvcm1hdHRlZCBBdXRob3JpemF0aW9uIGxpc3QuXG4gKiBAcmV0dXJucyBBIHNpZ25lZCB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5MaXN0fS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21ScGNMaXN0KGF1dGhvcml6YXRpb25MaXN0KSB7XG4gICAgcmV0dXJuIGF1dGhvcml6YXRpb25MaXN0Lm1hcChmcm9tUnBjKTtcbn1cbi8qKlxuICogQ29udmVydHMgYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb24uVHVwbGV9IHRvIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLkF1dGhvcml6YXRpb259LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQXV0aG9yaXphdGlvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb24gPSBBdXRob3JpemF0aW9uLmZyb21UdXBsZShbXG4gKiAgICcweDEnLFxuICogICAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJyxcbiAqICAgJzB4MydcbiAqIF0pXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIGFkZHJlc3M6ICcweGJlOTVjM2Y1NTRlOWZjODVlYzUxYmU2OWEzZDgwN2EwZDU1YmNmMmMnLFxuICogLy8gQGxvZzogICBjaGFpbklkOiAxLFxuICogLy8gQGxvZzogICBub25jZTogM25cbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBJdCBpcyBhbHNvIHBvc3NpYmxlIHRvIGFwcGVuZCBhIFNpZ25hdHVyZSB0dXBsZSB0byB0aGUgZW5kIG9mIGFuIEF1dGhvcml6YXRpb24gdHVwbGUuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uID0gQXV0aG9yaXphdGlvbi5mcm9tVHVwbGUoW1xuICogICAnMHgxJyxcbiAqICAgJzB4YmU5NWMzZjU1NGU5ZmM4NWVjNTFiZTY5YTNkODA3YTBkNTViY2YyYycsXG4gKiAgICcweDMnLFxuICogICAnMHgxJyxcbiAqICAgJzB4NjhhMDIwYTIwOWQzZDU2YzQ2ZjM4Y2M1MGEzM2Y3MDRmNGE5YTEwYTU5Mzc3ZjhkZDc2MmFjNjY5MTBlOWI5MCcsXG4gKiAgICcweDdlODY1YWQwNWM0MDM1YWI1NzkyNzg3ZDRhMDI5N2E0MzYxN2FlODk3OTMwYTZmZTRkODIyYjhmYWVhNTIwNjQnLFxuICogXSlcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgYWRkcmVzczogJzB4YmU5NWMzZjU1NGU5ZmM4NWVjNTFiZTY5YTNkODA3YTBkNTViY2YyYycsXG4gKiAvLyBAbG9nOiAgIGNoYWluSWQ6IDEsXG4gKiAvLyBAbG9nOiAgIG5vbmNlOiAzblxuICogLy8gQGxvZzogICByOiBCaWdJbnQoJzB4NjhhMDIwYTIwOWQzZDU2YzQ2ZjM4Y2M1MGEzM2Y3MDRmNGE5YTEwYTU5Mzc3ZjhkZDc2MmFjNjY5MTBlOWI5MCcpLFxuICogLy8gQGxvZzogICBzOiBCaWdJbnQoJzB4N2U4NjVhZDA1YzQwMzVhYjU3OTI3ODdkNGEwMjk3YTQzNjE3YWU4OTc5MzBhNmZlNGQ4MjJiOGZhZWE1MjA2NCcpLFxuICogLy8gQGxvZzogICB5UGFyaXR5OiAwLFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHR1cGxlIC0gVGhlIFtFSVAtNzcwMl0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC03NzAyKSBBdXRob3JpemF0aW9uIHR1cGxlLlxuICogQHJldHVybnMgVGhlIHtAbGluayBveCNBdXRob3JpemF0aW9uLkF1dGhvcml6YXRpb259LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVR1cGxlKHR1cGxlKSB7XG4gICAgY29uc3QgW2NoYWluSWQsIGFkZHJlc3MsIG5vbmNlLCB5UGFyaXR5LCByLCBzXSA9IHR1cGxlO1xuICAgIGxldCBhcmdzID0ge1xuICAgICAgICBhZGRyZXNzLFxuICAgICAgICBjaGFpbklkOiBjaGFpbklkID09PSAnMHgnID8gMCA6IE51bWJlcihjaGFpbklkKSxcbiAgICAgICAgbm9uY2U6IG5vbmNlID09PSAnMHgnID8gMG4gOiBCaWdJbnQobm9uY2UpLFxuICAgIH07XG4gICAgaWYgKHlQYXJpdHkgJiYgciAmJiBzKVxuICAgICAgICBhcmdzID0geyAuLi5hcmdzLCAuLi5TaWduYXR1cmUuZnJvbVR1cGxlKFt5UGFyaXR5LCByLCBzXSkgfTtcbiAgICByZXR1cm4gZnJvbShhcmdzKTtcbn1cbi8qKlxuICogQ29udmVydHMgYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb24uVHVwbGVMaXN0fSB0byBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5MaXN0fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uTGlzdCA9IEF1dGhvcml6YXRpb24uZnJvbVR1cGxlTGlzdChbXG4gKiAgIFsnMHgxJywgJzB4YmU5NWMzZjU1NGU5ZmM4NWVjNTFiZTY5YTNkODA3YTBkNTViY2YyYycsICcweDMnXSxcbiAqICAgWycweDMnLCAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJywgJzB4MTQnXSxcbiAqIF0pXG4gKiAvLyBAbG9nOiBbXG4gKiAvLyBAbG9nOiAgIHtcbiAqIC8vIEBsb2c6ICAgICBhZGRyZXNzOiAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJyxcbiAqIC8vIEBsb2c6ICAgICBjaGFpbklkOiAxLFxuICogLy8gQGxvZzogICAgIG5vbmNlOiAzbixcbiAqIC8vIEBsb2c6ICAgfSxcbiAqIC8vIEBsb2c6ICAge1xuICogLy8gQGxvZzogICAgIGFkZHJlc3M6ICcweGJlOTVjM2Y1NTRlOWZjODVlYzUxYmU2OWEzZDgwN2EwZDU1YmNmMmMnLFxuICogLy8gQGxvZzogICAgIGNoYWluSWQ6IDMsXG4gKiAvLyBAbG9nOiAgICAgbm9uY2U6IDIwbixcbiAqIC8vIEBsb2c6ICAgfSxcbiAqIC8vIEBsb2c6IF1cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBJdCBpcyBhbHNvIHBvc3NpYmxlIHRvIGFwcGVuZCBhIFNpZ25hdHVyZSB0dXBsZSB0byB0aGUgZW5kIG9mIGFuIEF1dGhvcml6YXRpb24gdHVwbGUuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uTGlzdCA9IEF1dGhvcml6YXRpb24uZnJvbVR1cGxlTGlzdChbXG4gKiAgIFsnMHgxJywgJzB4YmU5NWMzZjU1NGU5ZmM4NWVjNTFiZTY5YTNkODA3YTBkNTViY2YyYycsICcweDMnLCAnMHgxJywgJzB4NjhhMDIwYTIwOWQzZDU2YzQ2ZjM4Y2M1MGEzM2Y3MDRmNGE5YTEwYTU5Mzc3ZjhkZDc2MmFjNjY5MTBlOWI5MCcsICcweDdlODY1YWQwNWM0MDM1YWI1NzkyNzg3ZDRhMDI5N2E0MzYxN2FlODk3OTMwYTZmZTRkODIyYjhmYWVhNTIwNjQnXSxcbiAqICAgWycweDMnLCAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJywgJzB4MTQnLCAnMHgxJywgJzB4NjhhMDIwYTIwOWQzZDU2YzQ2ZjM4Y2M1MGEzM2Y3MDRmNGE5YTEwYTU5Mzc3ZjhkZDc2MmFjNjY5MTBlOWI5MCcsICcweDdlODY1YWQwNWM0MDM1YWI1NzkyNzg3ZDRhMDI5N2E0MzYxN2FlODk3OTMwYTZmZTRkODIyYjhmYWVhNTIwNjQnXSxcbiAqIF0pXG4gKiAvLyBAbG9nOiBbXG4gKiAvLyBAbG9nOiAgIHtcbiAqIC8vIEBsb2c6ICAgICBhZGRyZXNzOiAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJyxcbiAqIC8vIEBsb2c6ICAgICBjaGFpbklkOiAxLFxuICogLy8gQGxvZzogICAgIG5vbmNlOiAzbixcbiAqIC8vIEBsb2c6ICAgICByOiBCaWdJbnQoJzB4NjhhMDIwYTIwOWQzZDU2YzQ2ZjM4Y2M1MGEzM2Y3MDRmNGE5YTEwYTU5Mzc3ZjhkZDc2MmFjNjY5MTBlOWI5MCcpLFxuICogLy8gQGxvZzogICAgIHM6IEJpZ0ludCgnMHg3ZTg2NWFkMDVjNDAzNWFiNTc5Mjc4N2Q0YTAyOTdhNDM2MTdhZTg5NzkzMGE2ZmU0ZDgyMmI4ZmFlYTUyMDY0JyksXG4gKiAvLyBAbG9nOiAgICAgeVBhcml0eTogMCxcbiAqIC8vIEBsb2c6ICAgfSxcbiAqIC8vIEBsb2c6ICAge1xuICogLy8gQGxvZzogICAgIGFkZHJlc3M6ICcweGJlOTVjM2Y1NTRlOWZjODVlYzUxYmU2OWEzZDgwN2EwZDU1YmNmMmMnLFxuICogLy8gQGxvZzogICAgIGNoYWluSWQ6IDMsXG4gKiAvLyBAbG9nOiAgICAgbm9uY2U6IDIwbixcbiAqIC8vIEBsb2c6ICAgICByOiBCaWdJbnQoJzB4NjhhMDIwYTIwOWQzZDU2YzQ2ZjM4Y2M1MGEzM2Y3MDRmNGE5YTEwYTU5Mzc3ZjhkZDc2MmFjNjY5MTBlOWI5MCcpLFxuICogLy8gQGxvZzogICAgIHM6IEJpZ0ludCgnMHg3ZTg2NWFkMDVjNDAzNWFiNTc5Mjc4N2Q0YTAyOTdhNDM2MTdhZTg5NzkzMGE2ZmU0ZDgyMmI4ZmFlYTUyMDY0JyksXG4gKiAvLyBAbG9nOiAgICAgeVBhcml0eTogMCxcbiAqIC8vIEBsb2c6ICAgfSxcbiAqIC8vIEBsb2c6IF1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB0dXBsZUxpc3QgLSBUaGUgW0VJUC03NzAyXShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTc3MDIpIEF1dGhvcml6YXRpb24gdHVwbGUgbGlzdC5cbiAqIEByZXR1cm5zIEFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLkxpc3R9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVR1cGxlTGlzdCh0dXBsZUxpc3QpIHtcbiAgICBjb25zdCBsaXN0ID0gW107XG4gICAgZm9yIChjb25zdCB0dXBsZSBvZiB0dXBsZUxpc3QpXG4gICAgICAgIGxpc3QucHVzaChmcm9tVHVwbGUodHVwbGUpKTtcbiAgICByZXR1cm4gbGlzdDtcbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIHNpZ24gcGF5bG9hZCBmb3IgYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb24uQXV0aG9yaXphdGlvbn0gaW4gW0VJUC03NzAyIGZvcm1hdF0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC03NzAyKTogYGtlY2NhazI1NignMHgwNScgfHwgcmxwKFtjaGFpbl9pZCwgYWRkcmVzcywgbm9uY2VdKSlgLlxuICpcbiAqIEBleGFtcGxlXG4gKiBUaGUgZXhhbXBsZSBiZWxvdyBkZW1vbnN0cmF0ZXMgY29tcHV0aW5nIHRoZSBzaWduIHBheWxvYWQgZm9yIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLkF1dGhvcml6YXRpb259LiBUaGlzIHBheWxvYWRcbiAqIGNhbiB0aGVuIGJlIHBhc3NlZCB0byBzaWduaW5nIGZ1bmN0aW9ucyBsaWtlIHtAbGluayBveCNTZWNwMjU2azEuKHNpZ246ZnVuY3Rpb24pfS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQXV0aG9yaXphdGlvbiwgU2VjcDI1NmsxIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEF1dGhvcml6YXRpb24uZnJvbSh7XG4gKiAgIGFkZHJlc3M6ICcweDEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3ODkwYWJjZGVmMTIzNDU2NzgnLFxuICogICBjaGFpbklkOiAxLFxuICogICBub25jZTogNjluLFxuICogfSlcbiAqXG4gKiBjb25zdCBwYXlsb2FkID0gQXV0aG9yaXphdGlvbi5nZXRTaWduUGF5bG9hZChhdXRob3JpemF0aW9uKSAvLyBbIWNvZGUgZm9jdXNdXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oe1xuICogICBwYXlsb2FkLFxuICogICBwcml2YXRlS2V5OiAnMHguLi4nLFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRob3JpemF0aW9uIC0gVGhlIHtAbGluayBveCNBdXRob3JpemF0aW9uLkF1dGhvcml6YXRpb259LlxuICogQHJldHVybnMgVGhlIHNpZ24gcGF5bG9hZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNpZ25QYXlsb2FkKGF1dGhvcml6YXRpb24pIHtcbiAgICByZXR1cm4gaGFzaChhdXRob3JpemF0aW9uLCB7IHByZXNpZ246IHRydWUgfSk7XG59XG4vKipcbiAqIENvbXB1dGVzIHRoZSBoYXNoIGZvciBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5BdXRob3JpemF0aW9ufSBpbiBbRUlQLTc3MDIgZm9ybWF0XShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTc3MDIpOiBga2VjY2FrMjU2KCcweDA1JyB8fCBybHAoW2NoYWluX2lkLCBhZGRyZXNzLCBub25jZV0pKWAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEF1dGhvcml6YXRpb24uZnJvbSh7XG4gKiAgIGFkZHJlc3M6ICcweDEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3ODkwYWJjZGVmMTIzNDU2NzgnLFxuICogICBjaGFpbklkOiAxLFxuICogICBub25jZTogNjluLFxuICogfSlcbiAqXG4gKiBjb25zdCBoYXNoID0gQXV0aG9yaXphdGlvbi5oYXNoKGF1dGhvcml6YXRpb24pIC8vIFshY29kZSBmb2N1c11cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRob3JpemF0aW9uIC0gVGhlIHtAbGluayBveCNBdXRob3JpemF0aW9uLkF1dGhvcml6YXRpb259LlxuICogQHJldHVybnMgVGhlIGhhc2guXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNoKGF1dGhvcml6YXRpb24sIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgcHJlc2lnbiB9ID0gb3B0aW9ucztcbiAgICByZXR1cm4gSGFzaC5rZWNjYWsyNTYoSGV4LmNvbmNhdCgnMHgwNScsIFJscC5mcm9tSGV4KHRvVHVwbGUocHJlc2lnblxuICAgICAgICA/IHtcbiAgICAgICAgICAgIGFkZHJlc3M6IGF1dGhvcml6YXRpb24uYWRkcmVzcyxcbiAgICAgICAgICAgIGNoYWluSWQ6IGF1dGhvcml6YXRpb24uY2hhaW5JZCxcbiAgICAgICAgICAgIG5vbmNlOiBhdXRob3JpemF0aW9uLm5vbmNlLFxuICAgICAgICB9XG4gICAgICAgIDogYXV0aG9yaXphdGlvbikpKSk7XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLkF1dGhvcml6YXRpb259IHRvIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLlJwY30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEF1dGhvcml6YXRpb24udG9ScGMoe1xuICogICBhZGRyZXNzOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbm9uY2U6IDFuLFxuICogICByOiA0NDk0NDYyNzgxMzAwNzc3Mjg5NzM5MTUzMTIzMDA4MTY5NTEwMjcwMzI4OTEyMzMzMjE4NzY5NjExNTE4MTEwNDczOTIzOTE5NzUxN24sXG4gKiAgIHM6IDM2NTI4NTAzNTA1MTkyNDM4MzA3MzU1MTY0NDQxMTA0MDAxMzEwNTY2NTA1MzUxOTgwMzY5MDg1MjA4MTc4NzEyNjc4Nzk5MTgxMTIwbixcbiAqICAgeVBhcml0eTogMCxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYXV0aG9yaXphdGlvbiAtIEFuIEF1dGhvcml6YXRpb24uXG4gKiBAcmV0dXJucyBBbiBSUEMtZm9ybWF0dGVkIEF1dGhvcml6YXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1JwYyhhdXRob3JpemF0aW9uKSB7XG4gICAgY29uc3QgeyBhZGRyZXNzLCBjaGFpbklkLCBub25jZSwgLi4uc2lnbmF0dXJlIH0gPSBhdXRob3JpemF0aW9uO1xuICAgIHJldHVybiB7XG4gICAgICAgIGFkZHJlc3MsXG4gICAgICAgIGNoYWluSWQ6IEhleC5mcm9tTnVtYmVyKGNoYWluSWQpLFxuICAgICAgICBub25jZTogSGV4LmZyb21OdW1iZXIobm9uY2UpLFxuICAgICAgICAuLi5TaWduYXR1cmUudG9ScGMoc2lnbmF0dXJlKSxcbiAgICB9O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5MaXN0fSB0byBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5MaXN0UnBjfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uID0gQXV0aG9yaXphdGlvbi50b1JwY0xpc3QoW3tcbiAqICAgYWRkcmVzczogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG5vbmNlOiAxbixcbiAqICAgcjogNDQ5NDQ2Mjc4MTMwMDc3NzI4OTczOTE1MzEyMzAwODE2OTUxMDI3MDMyODkxMjMzMzIxODc2OTYxMTUxODExMDQ3MzkyMzkxOTc1MTduLFxuICogICBzOiAzNjUyODUwMzUwNTE5MjQzODMwNzM1NTE2NDQ0MTEwNDAwMTMxMDU2NjUwNTM1MTk4MDM2OTA4NTIwODE3ODcxMjY3ODc5OTE4MTEyMG4sXG4gKiAgIHlQYXJpdHk6IDAsXG4gKiB9XSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRob3JpemF0aW9uTGlzdCAtIEFuIEF1dGhvcml6YXRpb24gTGlzdC5cbiAqIEByZXR1cm5zIEFuIFJQQy1mb3JtYXR0ZWQgQXV0aG9yaXphdGlvbiBMaXN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9ScGNMaXN0KGF1dGhvcml6YXRpb25MaXN0KSB7XG4gICAgcmV0dXJuIGF1dGhvcml6YXRpb25MaXN0Lm1hcCh0b1JwYyk7XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLkF1dGhvcml6YXRpb259IHRvIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLlR1cGxlfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uID0gQXV0aG9yaXphdGlvbi5mcm9tKHtcbiAqICAgYWRkcmVzczogJzB4MTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3OCcsXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG5vbmNlOiA2OW4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IHR1cGxlID0gQXV0aG9yaXphdGlvbi50b1R1cGxlKGF1dGhvcml6YXRpb24pIC8vIFshY29kZSBmb2N1c11cbiAqIC8vIEBsb2c6IFtcbiAqIC8vIEBsb2c6ICAgYWRkcmVzczogJzB4MTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3OCcsXG4gKiAvLyBAbG9nOiAgIGNoYWluSWQ6IDEsXG4gKiAvLyBAbG9nOiAgIG5vbmNlOiA2OW4sXG4gKiAvLyBAbG9nOiBdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYXV0aG9yaXphdGlvbiAtIFRoZSB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5BdXRob3JpemF0aW9ufS5cbiAqIEByZXR1cm5zIEFuIFtFSVAtNzcwMl0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC03NzAyKSBBdXRob3JpemF0aW9uIHR1cGxlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9UdXBsZShhdXRob3JpemF0aW9uKSB7XG4gICAgY29uc3QgeyBhZGRyZXNzLCBjaGFpbklkLCBub25jZSB9ID0gYXV0aG9yaXphdGlvbjtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBTaWduYXR1cmUuZXh0cmFjdChhdXRob3JpemF0aW9uKTtcbiAgICByZXR1cm4gW1xuICAgICAgICBjaGFpbklkID8gSGV4LmZyb21OdW1iZXIoY2hhaW5JZCkgOiAnMHgnLFxuICAgICAgICBhZGRyZXNzLFxuICAgICAgICBub25jZSA/IEhleC5mcm9tTnVtYmVyKG5vbmNlKSA6ICcweCcsXG4gICAgICAgIC4uLihzaWduYXR1cmUgPyBTaWduYXR1cmUudG9UdXBsZShzaWduYXR1cmUpIDogW10pLFxuICAgIF07XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLkxpc3R9IHRvIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLlR1cGxlTGlzdH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbl8xID0gQXV0aG9yaXphdGlvbi5mcm9tKHtcbiAqICAgYWRkcmVzczogJzB4MTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3OCcsXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG5vbmNlOiA2OW4sXG4gKiB9KVxuICogY29uc3QgYXV0aG9yaXphdGlvbl8yID0gQXV0aG9yaXphdGlvbi5mcm9tKHtcbiAqICAgYWRkcmVzczogJzB4MTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3OCcsXG4gKiAgIGNoYWluSWQ6IDMsXG4gKiAgIG5vbmNlOiAyMG4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IHR1cGxlID0gQXV0aG9yaXphdGlvbi50b1R1cGxlTGlzdChbYXV0aG9yaXphdGlvbl8xLCBhdXRob3JpemF0aW9uXzJdKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyBAbG9nOiBbXG4gKiAvLyBAbG9nOiAgIFtcbiAqIC8vIEBsb2c6ICAgICBhZGRyZXNzOiAnMHgxMjM0NTY3ODkwYWJjZGVmMTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4JyxcbiAqIC8vIEBsb2c6ICAgICBjaGFpbklkOiAxLFxuICogLy8gQGxvZzogICAgIG5vbmNlOiA2OW4sXG4gKiAvLyBAbG9nOiAgIF0sXG4gKiAvLyBAbG9nOiAgIFtcbiAqIC8vIEBsb2c6ICAgICBhZGRyZXNzOiAnMHgxMjM0NTY3ODkwYWJjZGVmMTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4JyxcbiAqIC8vIEBsb2c6ICAgICBjaGFpbklkOiAzLFxuICogLy8gQGxvZzogICAgIG5vbmNlOiAyMG4sXG4gKiAvLyBAbG9nOiAgIF0sXG4gKiAvLyBAbG9nOiBdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gbGlzdCAtIEFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLkxpc3R9LlxuICogQHJldHVybnMgQW4gW0VJUC03NzAyXShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTc3MDIpIEF1dGhvcml6YXRpb24gdHVwbGUgbGlzdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVHVwbGVMaXN0KGxpc3QpIHtcbiAgICBpZiAoIWxpc3QgfHwgbGlzdC5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiBbXTtcbiAgICBjb25zdCB0dXBsZUxpc3QgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGF1dGhvcml6YXRpb24gb2YgbGlzdClcbiAgICAgICAgdHVwbGVMaXN0LnB1c2godG9UdXBsZShhdXRob3JpemF0aW9uKSk7XG4gICAgcmV0dXJuIHR1cGxlTGlzdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUF1dGhvcml6YXRpb24uanMubWFwIl0sIm5hbWVzIjpbIkhhc2giLCJIZXgiLCJSbHAiLCJTaWduYXR1cmUiLCJmcm9tIiwiYXV0aG9yaXphdGlvbiIsIm9wdGlvbnMiLCJjaGFpbklkIiwiZnJvbVJwYyIsInNpZ25hdHVyZSIsImFkZHJlc3MiLCJub25jZSIsImV4dHJhY3QiLCJOdW1iZXIiLCJCaWdJbnQiLCJmcm9tUnBjTGlzdCIsImF1dGhvcml6YXRpb25MaXN0IiwibWFwIiwiZnJvbVR1cGxlIiwidHVwbGUiLCJ5UGFyaXR5IiwiciIsInMiLCJhcmdzIiwiZnJvbVR1cGxlTGlzdCIsInR1cGxlTGlzdCIsImxpc3QiLCJwdXNoIiwiZ2V0U2lnblBheWxvYWQiLCJoYXNoIiwicHJlc2lnbiIsImtlY2NhazI1NiIsImNvbmNhdCIsImZyb21IZXgiLCJ0b1R1cGxlIiwidG9ScGMiLCJmcm9tTnVtYmVyIiwidG9ScGNMaXN0IiwidG9UdXBsZUxpc3QiLCJsZW5ndGgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Authorization.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Base64.js":
/*!*********************************************!*\
  !*** ./node_modules/ox/_esm/core/Base64.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromBytes: () => (/* binding */ fromBytes),\n/* harmony export */   fromHex: () => (/* binding */ fromHex),\n/* harmony export */   fromString: () => (/* binding */ fromString),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   toHex: () => (/* binding */ toHex),\n/* harmony export */   toString: () => (/* binding */ toString)\n/* harmony export */ });\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n\n\nconst encoder = /*#__PURE__*/ new TextEncoder();\nconst decoder = /*#__PURE__*/ new TextDecoder();\nconst integerToCharacter = /*#__PURE__*/ Object.fromEntries(Array.from(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\").map((a, i)=>[\n        i,\n        a.charCodeAt(0)\n    ]));\nconst characterToInteger = /*#__PURE__*/ {\n    ...Object.fromEntries(Array.from(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\").map((a, i)=>[\n            a.charCodeAt(0),\n            i\n        ])),\n    [\"=\".charCodeAt(0)]: 0,\n    [\"-\".charCodeAt(0)]: 62,\n    [\"_\".charCodeAt(0)]: 63\n};\n/**\n * Encodes a {@link ox#Bytes.Bytes} to a Base64-encoded string (with optional padding and/or URL-safe characters).\n *\n * @example\n * ```ts twoslash\n * import { Base64, Bytes } from 'ox'\n *\n * const value = Base64.fromBytes(Bytes.fromString('hello world'))\n * // @log: 'aGVsbG8gd29ybGQ='\n * ```\n *\n * @example\n * ### No Padding\n *\n * Turn off [padding of encoded data](https://datatracker.ietf.org/doc/html/rfc4648#section-3.2) with the `pad` option:\n *\n * ```ts twoslash\n * import { Base64, Bytes } from 'ox'\n *\n * const value = Base64.fromBytes(Bytes.fromString('hello world'), { pad: false })\n * // @log: 'aGVsbG8gd29ybGQ'\n * ```\n *\n * ### URL-safe Encoding\n *\n * Turn on [URL-safe encoding](https://datatracker.ietf.org/doc/html/rfc4648#section-5) (Base64 URL) with the `url` option:\n *\n * ```ts twoslash\n * import { Base64, Bytes } from 'ox'\n *\n * const value = Base64.fromBytes(Bytes.fromString('hello wod'), { url: true })\n * // @log: 'aGVsbG8gd29_77-9ZA=='\n * ```\n *\n * @param value - The byte array to encode.\n * @param options - Encoding options.\n * @returns The Base64 encoded string.\n */ function fromBytes(value, options = {}) {\n    const { pad = true, url = false } = options;\n    const encoded = new Uint8Array(Math.ceil(value.length / 3) * 4);\n    for(let i = 0, j = 0; j < value.length; i += 4, j += 3){\n        const y = (value[j] << 16) + (value[j + 1] << 8) + (value[j + 2] | 0);\n        encoded[i] = integerToCharacter[y >> 18];\n        encoded[i + 1] = integerToCharacter[y >> 12 & 0x3f];\n        encoded[i + 2] = integerToCharacter[y >> 6 & 0x3f];\n        encoded[i + 3] = integerToCharacter[y & 0x3f];\n    }\n    const k = value.length % 3;\n    const end = Math.floor(value.length / 3) * 4 + (k && k + 1);\n    let base64 = decoder.decode(new Uint8Array(encoded.buffer, 0, end));\n    if (pad && k === 1) base64 += \"==\";\n    if (pad && k === 2) base64 += \"=\";\n    if (url) base64 = base64.replaceAll(\"+\", \"-\").replaceAll(\"/\", \"_\");\n    return base64;\n}\n/**\n * Encodes a {@link ox#Hex.Hex} to a Base64-encoded string (with optional padding and/or URL-safe characters).\n *\n * @example\n * ```ts twoslash\n * import { Base64, Hex } from 'ox'\n *\n * const value = Base64.fromHex(Hex.fromString('hello world'))\n * // @log: 'aGVsbG8gd29ybGQ='\n * ```\n *\n * @example\n * ### No Padding\n *\n * Turn off [padding of encoded data](https://datatracker.ietf.org/doc/html/rfc4648#section-3.2) with the `pad` option:\n *\n * ```ts twoslash\n * import { Base64, Hex } from 'ox'\n *\n * const value = Base64.fromHex(Hex.fromString('hello world'), { pad: false })\n * // @log: 'aGVsbG8gd29ybGQ'\n * ```\n *\n * ### URL-safe Encoding\n *\n * Turn on [URL-safe encoding](https://datatracker.ietf.org/doc/html/rfc4648#section-5) (Base64 URL) with the `url` option:\n *\n * ```ts twoslash\n * import { Base64, Hex } from 'ox'\n *\n * const value = Base64.fromHex(Hex.fromString('hello wod'), { url: true })\n * // @log: 'aGVsbG8gd29_77-9ZA=='\n * ```\n *\n * @param value - The hex value to encode.\n * @param options - Encoding options.\n * @returns The Base64 encoded string.\n */ function fromHex(value, options = {}) {\n    return fromBytes(_Bytes_js__WEBPACK_IMPORTED_MODULE_0__.fromHex(value), options);\n}\n/**\n * Encodes a string to a Base64-encoded string (with optional padding and/or URL-safe characters).\n *\n * @example\n * ```ts twoslash\n * import { Base64 } from 'ox'\n *\n * const value = Base64.fromString('hello world')\n * // @log: 'aGVsbG8gd29ybGQ='\n * ```\n *\n * @example\n * ### No Padding\n *\n * Turn off [padding of encoded data](https://datatracker.ietf.org/doc/html/rfc4648#section-3.2) with the `pad` option:\n *\n * ```ts twoslash\n * import { Base64 } from 'ox'\n *\n * const value = Base64.fromString('hello world', { pad: false })\n * // @log: 'aGVsbG8gd29ybGQ'\n * ```\n *\n * ### URL-safe Encoding\n *\n * Turn on [URL-safe encoding](https://datatracker.ietf.org/doc/html/rfc4648#section-5) (Base64 URL) with the `url` option:\n *\n * ```ts twoslash\n * import { Base64 } from 'ox'\n *\n * const value = Base64.fromString('hello wod', { url: true })\n * // @log: 'aGVsbG8gd29_77-9ZA=='\n * ```\n *\n * @param value - The string to encode.\n * @param options - Encoding options.\n * @returns The Base64 encoded string.\n */ function fromString(value, options = {}) {\n    return fromBytes(_Bytes_js__WEBPACK_IMPORTED_MODULE_0__.fromString(value), options);\n}\n/**\n * Decodes a Base64-encoded string (with optional padding and/or URL-safe characters) to {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Base64, Bytes } from 'ox'\n *\n * const value = Base64.toBytes('aGVsbG8gd29ybGQ=')\n * // @log: Uint8Array([104, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100])\n * ```\n *\n * @param value - The string, hex value, or byte array to encode.\n * @returns The Base64 decoded {@link ox#Bytes.Bytes}.\n */ function toBytes(value) {\n    const base64 = value.replace(/=+$/, \"\");\n    const size = base64.length;\n    const decoded = new Uint8Array(size + 3);\n    encoder.encodeInto(base64 + \"===\", decoded);\n    for(let i = 0, j = 0; i < base64.length; i += 4, j += 3){\n        const x = (characterToInteger[decoded[i]] << 18) + (characterToInteger[decoded[i + 1]] << 12) + (characterToInteger[decoded[i + 2]] << 6) + characterToInteger[decoded[i + 3]];\n        decoded[j] = x >> 16;\n        decoded[j + 1] = x >> 8 & 0xff;\n        decoded[j + 2] = x & 0xff;\n    }\n    const decodedSize = (size >> 2) * 3 + (size % 4 && size % 4 - 1);\n    return new Uint8Array(decoded.buffer, 0, decodedSize);\n}\n/**\n * Decodes a Base64-encoded string (with optional padding and/or URL-safe characters) to {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Base64, Hex } from 'ox'\n *\n * const value = Base64.toHex('aGVsbG8gd29ybGQ=')\n * // @log: 0x68656c6c6f20776f726c64\n * ```\n *\n * @param value - The string, hex value, or byte array to encode.\n * @returns The Base64 decoded {@link ox#Hex.Hex}.\n */ function toHex(value) {\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(toBytes(value));\n}\n/**\n * Decodes a Base64-encoded string (with optional padding and/or URL-safe characters) to a string.\n *\n * @example\n * ```ts twoslash\n * import { Base64 } from 'ox'\n *\n * const value = Base64.toString('aGVsbG8gd29ybGQ=')\n * // @log: 'hello world'\n * ```\n *\n * @param value - The string, hex value, or byte array to encode.\n * @returns The Base64 decoded string.\n */ function toString(value) {\n    return _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.toString(toBytes(value));\n} //# sourceMappingURL=Base64.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0Jhc2U2NC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFvQztBQUNKO0FBQ2hDLE1BQU1FLFVBQVUsV0FBVyxHQUFHLElBQUlDO0FBQ2xDLE1BQU1DLFVBQVUsV0FBVyxHQUFHLElBQUlDO0FBQ2xDLE1BQU1DLHFCQUFxQixXQUFXLEdBQUdDLE9BQU9DLFdBQVcsQ0FBQ0MsTUFBTUMsSUFBSSxDQUFDLG9FQUFvRUMsR0FBRyxDQUFDLENBQUNDLEdBQUdDLElBQU07UUFBQ0E7UUFBR0QsRUFBRUUsVUFBVSxDQUFDO0tBQUc7QUFDN0ssTUFBTUMscUJBQXFCLFdBQVcsR0FBRztJQUNyQyxHQUFHUixPQUFPQyxXQUFXLENBQUNDLE1BQU1DLElBQUksQ0FBQyxvRUFBb0VDLEdBQUcsQ0FBQyxDQUFDQyxHQUFHQyxJQUFNO1lBQUNELEVBQUVFLFVBQVUsQ0FBQztZQUFJRDtTQUFFLEVBQUU7SUFDekksQ0FBQyxJQUFJQyxVQUFVLENBQUMsR0FBRyxFQUFFO0lBQ3JCLENBQUMsSUFBSUEsVUFBVSxDQUFDLEdBQUcsRUFBRTtJQUNyQixDQUFDLElBQUlBLFVBQVUsQ0FBQyxHQUFHLEVBQUU7QUFDekI7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXFDQyxHQUNNLFNBQVNFLFVBQVVDLEtBQUssRUFBRUMsVUFBVSxDQUFDLENBQUM7SUFDekMsTUFBTSxFQUFFQyxNQUFNLElBQUksRUFBRUMsTUFBTSxLQUFLLEVBQUUsR0FBR0Y7SUFDcEMsTUFBTUcsVUFBVSxJQUFJQyxXQUFXQyxLQUFLQyxJQUFJLENBQUNQLE1BQU1RLE1BQU0sR0FBRyxLQUFLO0lBQzdELElBQUssSUFBSVosSUFBSSxHQUFHYSxJQUFJLEdBQUdBLElBQUlULE1BQU1RLE1BQU0sRUFBRVosS0FBSyxHQUFHYSxLQUFLLEVBQUc7UUFDckQsTUFBTUMsSUFBSSxDQUFDVixLQUFLLENBQUNTLEVBQUUsSUFBSSxF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UzVCLEtBQUs7SUFDMUIsT0FBT2pCLCtDQUFjLENBQUNxQyxRQUFRcEI7QUFDbEMsRUFDQSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGF3LXdvcmtzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9CYXNlNjQuanM/YjIzZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBCeXRlcyBmcm9tICcuL0J5dGVzLmpzJztcbmltcG9ydCAqIGFzIEhleCBmcm9tICcuL0hleC5qcyc7XG5jb25zdCBlbmNvZGVyID0gLyojX19QVVJFX18qLyBuZXcgVGV4dEVuY29kZXIoKTtcbmNvbnN0IGRlY29kZXIgPSAvKiNfX1BVUkVfXyovIG5ldyBUZXh0RGVjb2RlcigpO1xuY29uc3QgaW50ZWdlclRvQ2hhcmFjdGVyID0gLyojX19QVVJFX18qLyBPYmplY3QuZnJvbUVudHJpZXMoQXJyYXkuZnJvbSgnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLycpLm1hcCgoYSwgaSkgPT4gW2ksIGEuY2hhckNvZGVBdCgwKV0pKTtcbmNvbnN0IGNoYXJhY3RlclRvSW50ZWdlciA9IC8qI19fUFVSRV9fKi8ge1xuICAgIC4uLk9iamVjdC5mcm9tRW50cmllcyhBcnJheS5mcm9tKCdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJykubWFwKChhLCBpKSA9PiBbYS5jaGFyQ29kZUF0KDApLCBpXSkpLFxuICAgIFsnPScuY2hhckNvZGVBdCgwKV06IDAsXG4gICAgWyctJy5jaGFyQ29kZUF0KDApXTogNjIsXG4gICAgWydfJy5jaGFyQ29kZUF0KDApXTogNjMsXG59O1xuLyoqXG4gKiBFbmNvZGVzIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB0byBhIEJhc2U2NC1lbmNvZGVkIHN0cmluZyAod2l0aCBvcHRpb25hbCBwYWRkaW5nIGFuZC9vciBVUkwtc2FmZSBjaGFyYWN0ZXJzKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJhc2U2NCwgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB2YWx1ZSA9IEJhc2U2NC5mcm9tQnl0ZXMoQnl0ZXMuZnJvbVN0cmluZygnaGVsbG8gd29ybGQnKSlcbiAqIC8vIEBsb2c6ICdhR1ZzYkc4Z2QyOXliR1E9J1xuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBObyBQYWRkaW5nXG4gKlxuICogVHVybiBvZmYgW3BhZGRpbmcgb2YgZW5jb2RlZCBkYXRhXShodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzQ2NDgjc2VjdGlvbi0zLjIpIHdpdGggdGhlIGBwYWRgIG9wdGlvbjpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQmFzZTY0LCBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHZhbHVlID0gQmFzZTY0LmZyb21CeXRlcyhCeXRlcy5mcm9tU3RyaW5nKCdoZWxsbyB3b3JsZCcpLCB7IHBhZDogZmFsc2UgfSlcbiAqIC8vIEBsb2c6ICdhR1ZzYkc4Z2QyOXliR1EnXG4gKiBgYGBcbiAqXG4gKiAjIyMgVVJMLXNhZmUgRW5jb2RpbmdcbiAqXG4gKiBUdXJuIG9uIFtVUkwtc2FmZSBlbmNvZGluZ10oaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM0NjQ4I3NlY3Rpb24tNSkgKEJhc2U2NCBVUkwpIHdpdGggdGhlIGB1cmxgIG9wdGlvbjpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQmFzZTY0LCBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHZhbHVlID0gQmFzZTY0LmZyb21CeXRlcyhCeXRlcy5mcm9tU3RyaW5nKCdoZWxsbyB3b39kJyksIHsgdXJsOiB0cnVlIH0pXG4gKiAvLyBAbG9nOiAnYUdWc2JHOGdkMjlfNzctOVpBPT0nXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgYnl0ZSBhcnJheSB0byBlbmNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEVuY29kaW5nIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgQmFzZTY0IGVuY29kZWQgc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUJ5dGVzKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHBhZCA9IHRydWUsIHVybCA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGVuY29kZWQgPSBuZXcgVWludDhBcnJheShNYXRoLmNlaWwodmFsdWUubGVuZ3RoIC8gMykgKiA0KTtcbiAgICBmb3IgKGxldCBpID0gMCwgaiA9IDA7IGogPCB2YWx1ZS5sZW5ndGg7IGkgKz0gNCwgaiArPSAzKSB7XG4gICAgICAgIGNvbnN0IHkgPSAodmFsdWVbal0gPDwgMTYpICsgKHZhbHVlW2ogKyAxXSA8PCA4KSArICh2YWx1ZVtqICsgMl0gfCAwKTtcbiAgICAgICAgZW5jb2RlZFtpXSA9IGludGVnZXJUb0NoYXJhY3Rlclt5ID4+IDE4XTtcbiAgICAgICAgZW5jb2RlZFtpICsgMV0gPSBpbnRlZ2VyVG9DaGFyYWN0ZXJbKHkgPj4gMTIpICYgMHgzZl07XG4gICAgICAgIGVuY29kZWRbaSArIDJdID0gaW50ZWdlclRvQ2hhcmFjdGVyWyh5ID4+IDYpICYgMHgzZl07XG4gICAgICAgIGVuY29kZWRbaSArIDNdID0gaW50ZWdlclRvQ2hhcmFjdGVyW3kgJiAweDNmXTtcbiAgICB9XG4gICAgY29uc3QgayA9IHZhbHVlLmxlbmd0aCAlIDM7XG4gICAgY29uc3QgZW5kID0gTWF0aC5mbG9vcih2YWx1ZS5sZW5ndGggLyAzKSAqIDQgKyAoayAmJiBrICsgMSk7XG4gICAgbGV0IGJhc2U2NCA9IGRlY29kZXIuZGVjb2RlKG5ldyBVaW50OEFycmF5KGVuY29kZWQuYnVmZmVyLCAwLCBlbmQpKTtcbiAgICBpZiAocGFkICYmIGsgPT09IDEpXG4gICAgICAgIGJhc2U2NCArPSAnPT0nO1xuICAgIGlmIChwYWQgJiYgayA9PT0gMilcbiAgICAgICAgYmFzZTY0ICs9ICc9JztcbiAgICBpZiAodXJsKVxuICAgICAgICBiYXNlNjQgPSBiYXNlNjQucmVwbGFjZUFsbCgnKycsICctJykucmVwbGFjZUFsbCgnLycsICdfJyk7XG4gICAgcmV0dXJuIGJhc2U2NDtcbn1cbi8qKlxuICogRW5jb2RlcyBhIHtAbGluayBveCNIZXguSGV4fSB0byBhIEJhc2U2NC1lbmNvZGVkIHN0cmluZyAod2l0aCBvcHRpb25hbCBwYWRkaW5nIGFuZC9vciBVUkwtc2FmZSBjaGFyYWN0ZXJzKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJhc2U2NCwgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgdmFsdWUgPSBCYXNlNjQuZnJvbUhleChIZXguZnJvbVN0cmluZygnaGVsbG8gd29ybGQnKSlcbiAqIC8vIEBsb2c6ICdhR1ZzYkc4Z2QyOXliR1E9J1xuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBObyBQYWRkaW5nXG4gKlxuICogVHVybiBvZmYgW3BhZGRpbmcgb2YgZW5jb2RlZCBkYXRhXShodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzQ2NDgjc2VjdGlvbi0zLjIpIHdpdGggdGhlIGBwYWRgIG9wdGlvbjpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQmFzZTY0LCBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB2YWx1ZSA9IEJhc2U2NC5mcm9tSGV4KEhleC5mcm9tU3RyaW5nKCdoZWxsbyB3b3JsZCcpLCB7IHBhZDogZmFsc2UgfSlcbiAqIC8vIEBsb2c6ICdhR1ZzYkc4Z2QyOXliR1EnXG4gKiBgYGBcbiAqXG4gKiAjIyMgVVJMLXNhZmUgRW5jb2RpbmdcbiAqXG4gKiBUdXJuIG9uIFtVUkwtc2FmZSBlbmNvZGluZ10oaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM0NjQ4I3NlY3Rpb24tNSkgKEJhc2U2NCBVUkwpIHdpdGggdGhlIGB1cmxgIG9wdGlvbjpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQmFzZTY0LCBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB2YWx1ZSA9IEJhc2U2NC5mcm9tSGV4KEhleC5mcm9tU3RyaW5nKCdoZWxsbyB3b39kJyksIHsgdXJsOiB0cnVlIH0pXG4gKiAvLyBAbG9nOiAnYUdWc2JHOGdkMjlfNzctOVpBPT0nXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgaGV4IHZhbHVlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gRW5jb2Rpbmcgb3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBCYXNlNjQgZW5jb2RlZCBzdHJpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tSGV4KHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gZnJvbUJ5dGVzKEJ5dGVzLmZyb21IZXgodmFsdWUpLCBvcHRpb25zKTtcbn1cbi8qKlxuICogRW5jb2RlcyBhIHN0cmluZyB0byBhIEJhc2U2NC1lbmNvZGVkIHN0cmluZyAod2l0aCBvcHRpb25hbCBwYWRkaW5nIGFuZC9vciBVUkwtc2FmZSBjaGFyYWN0ZXJzKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJhc2U2NCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHZhbHVlID0gQmFzZTY0LmZyb21TdHJpbmcoJ2hlbGxvIHdvcmxkJylcbiAqIC8vIEBsb2c6ICdhR1ZzYkc4Z2QyOXliR1E9J1xuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBObyBQYWRkaW5nXG4gKlxuICogVHVybiBvZmYgW3BhZGRpbmcgb2YgZW5jb2RlZCBkYXRhXShodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzQ2NDgjc2VjdGlvbi0zLjIpIHdpdGggdGhlIGBwYWRgIG9wdGlvbjpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQmFzZTY0IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgdmFsdWUgPSBCYXNlNjQuZnJvbVN0cmluZygnaGVsbG8gd29ybGQnLCB7IHBhZDogZmFsc2UgfSlcbiAqIC8vIEBsb2c6ICdhR1ZzYkc4Z2QyOXliR1EnXG4gKiBgYGBcbiAqXG4gKiAjIyMgVVJMLXNhZmUgRW5jb2RpbmdcbiAqXG4gKiBUdXJuIG9uIFtVUkwtc2FmZSBlbmNvZGluZ10oaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM0NjQ4I3NlY3Rpb24tNSkgKEJhc2U2NCBVUkwpIHdpdGggdGhlIGB1cmxgIG9wdGlvbjpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQmFzZTY0IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgdmFsdWUgPSBCYXNlNjQuZnJvbVN0cmluZygnaGVsbG8gd29/ZCcsIHsgdXJsOiB0cnVlIH0pXG4gKiAvLyBAbG9nOiAnYUdWc2JHOGdkMjlfNzctOVpBPT0nXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgc3RyaW5nIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gRW5jb2Rpbmcgb3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBCYXNlNjQgZW5jb2RlZCBzdHJpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tU3RyaW5nKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gZnJvbUJ5dGVzKEJ5dGVzLmZyb21TdHJpbmcodmFsdWUpLCBvcHRpb25zKTtcbn1cbi8qKlxuICogRGVjb2RlcyBhIEJhc2U2NC1lbmNvZGVkIHN0cmluZyAod2l0aCBvcHRpb25hbCBwYWRkaW5nIGFuZC9vciBVUkwtc2FmZSBjaGFyYWN0ZXJzKSB0byB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQmFzZTY0LCBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHZhbHVlID0gQmFzZTY0LnRvQnl0ZXMoJ2FHVnNiRzhnZDI5eWJHUT0nKVxuICogLy8gQGxvZzogVWludDhBcnJheShbMTA0LCAxMDEsIDEwOCwgMTA4LCAxMTEsIDMyLCAxMTksIDExMSwgMTE0LCAxMDgsIDEwMF0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgc3RyaW5nLCBoZXggdmFsdWUsIG9yIGJ5dGUgYXJyYXkgdG8gZW5jb2RlLlxuICogQHJldHVybnMgVGhlIEJhc2U2NCBkZWNvZGVkIHtAbGluayBveCNCeXRlcy5CeXRlc30uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0J5dGVzKHZhbHVlKSB7XG4gICAgY29uc3QgYmFzZTY0ID0gdmFsdWUucmVwbGFjZSgvPSskLywgJycpO1xuICAgIGNvbnN0IHNpemUgPSBiYXNlNjQubGVuZ3RoO1xuICAgIGNvbnN0IGRlY29kZWQgPSBuZXcgVWludDhBcnJheShzaXplICsgMyk7XG4gICAgZW5jb2Rlci5lbmNvZGVJbnRvKGJhc2U2NCArICc9PT0nLCBkZWNvZGVkKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaiA9IDA7IGkgPCBiYXNlNjQubGVuZ3RoOyBpICs9IDQsIGogKz0gMykge1xuICAgICAgICBjb25zdCB4ID0gKGNoYXJhY3RlclRvSW50ZWdlcltkZWNvZGVkW2ldXSA8PCAxOCkgK1xuICAgICAgICAgICAgKGNoYXJhY3RlclRvSW50ZWdlcltkZWNvZGVkW2kgKyAxXV0gPDwgMTIpICtcbiAgICAgICAgICAgIChjaGFyYWN0ZXJUb0ludGVnZXJbZGVjb2RlZFtpICsgMl1dIDw8IDYpICtcbiAgICAgICAgICAgIGNoYXJhY3RlclRvSW50ZWdlcltkZWNvZGVkW2kgKyAzXV07XG4gICAgICAgIGRlY29kZWRbal0gPSB4ID4+IDE2O1xuICAgICAgICBkZWNvZGVkW2ogKyAxXSA9ICh4ID4+IDgpICYgMHhmZjtcbiAgICAgICAgZGVjb2RlZFtqICsgMl0gPSB4ICYgMHhmZjtcbiAgICB9XG4gICAgY29uc3QgZGVjb2RlZFNpemUgPSAoc2l6ZSA+PiAyKSAqIDMgKyAoc2l6ZSAlIDQgJiYgKHNpemUgJSA0KSAtIDEpO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShkZWNvZGVkLmJ1ZmZlciwgMCwgZGVjb2RlZFNpemUpO1xufVxuLyoqXG4gKiBEZWNvZGVzIGEgQmFzZTY0LWVuY29kZWQgc3RyaW5nICh3aXRoIG9wdGlvbmFsIHBhZGRpbmcgYW5kL29yIFVSTC1zYWZlIGNoYXJhY3RlcnMpIHRvIHtAbGluayBveCNIZXguSGV4fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJhc2U2NCwgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgdmFsdWUgPSBCYXNlNjQudG9IZXgoJ2FHVnNiRzhnZDI5eWJHUT0nKVxuICogLy8gQGxvZzogMHg2ODY1NmM2YzZmMjA3NzZmNzI2YzY0XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgc3RyaW5nLCBoZXggdmFsdWUsIG9yIGJ5dGUgYXJyYXkgdG8gZW5jb2RlLlxuICogQHJldHVybnMgVGhlIEJhc2U2NCBkZWNvZGVkIHtAbGluayBveCNIZXguSGV4fS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSGV4KHZhbHVlKSB7XG4gICAgcmV0dXJuIEhleC5mcm9tQnl0ZXModG9CeXRlcyh2YWx1ZSkpO1xufVxuLyoqXG4gKiBEZWNvZGVzIGEgQmFzZTY0LWVuY29kZWQgc3RyaW5nICh3aXRoIG9wdGlvbmFsIHBhZGRpbmcgYW5kL29yIFVSTC1zYWZlIGNoYXJhY3RlcnMpIHRvIGEgc3RyaW5nLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQmFzZTY0IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgdmFsdWUgPSBCYXNlNjQudG9TdHJpbmcoJ2FHVnNiRzhnZDI5eWJHUT0nKVxuICogLy8gQGxvZzogJ2hlbGxvIHdvcmxkJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHN0cmluZywgaGV4IHZhbHVlLCBvciBieXRlIGFycmF5IHRvIGVuY29kZS5cbiAqIEByZXR1cm5zIFRoZSBCYXNlNjQgZGVjb2RlZCBzdHJpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiBCeXRlcy50b1N0cmluZyh0b0J5dGVzKHZhbHVlKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CYXNlNjQuanMubWFwIl0sIm5hbWVzIjpbIkJ5dGVzIiwiSGV4IiwiZW5jb2RlciIsIlRleHRFbmNvZGVyIiwiZGVjb2RlciIsIlRleHREZWNvZGVyIiwiaW50ZWdlclRvQ2hhcmFjdGVyIiwiT2JqZWN0IiwiZnJvbUVudHJpZXMiLCJBcnJheSIsImZyb20iLCJtYXAiLCJhIiwiaSIsImNoYXJDb2RlQXQiLCJjaGFyYWN0ZXJUb0ludGVnZXIiLCJmcm9tQnl0ZXMiLCJ2YWx1ZSIsIm9wdGlvbnMiLCJwYWQiLCJ1cmwiLCJlbmNvZGVkIiwiVWludDhBcnJheSIsIk1hdGgiLCJjZWlsIiwibGVuZ3RoIiwiaiIsInkiLCJrIiwiZW5kIiwiZmxvb3IiLCJiYXNlNjQiLCJkZWNvZGUiLCJidWZmZXIiLCJyZXBsYWNlQWxsIiwiZnJvbUhleCIsImZyb21TdHJpbmciLCJ0b0J5dGVzIiwicmVwbGFjZSIsInNpemUiLCJkZWNvZGVkIiwiZW5jb2RlSW50byIsIngiLCJkZWNvZGVkU2l6ZSIsInRvSGV4IiwidG9TdHJpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Base64.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/BlockOverrides.js":
/*!*****************************************************!*\
  !*** ./node_modules/ox/_esm/core/BlockOverrides.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromRpc: () => (/* binding */ fromRpc),\n/* harmony export */   toRpc: () => (/* binding */ toRpc)\n/* harmony export */ });\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Withdrawal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Withdrawal.js */ \"(ssr)/./node_modules/ox/_esm/core/Withdrawal.js\");\n\n\n/**\n * Converts an {@link ox#BlockOverrides.Rpc} to an {@link ox#BlockOverrides.BlockOverrides}.\n *\n * @example\n * ```ts twoslash\n * import { BlockOverrides } from 'ox'\n *\n * const blockOverrides = BlockOverrides.fromRpc({\n *   baseFeePerGas: '0x1',\n *   blobBaseFee: '0x2',\n *   feeRecipient: '0x0000000000000000000000000000000000000000',\n *   gasLimit: '0x4',\n *   number: '0x5',\n *   prevRandao: '0x6',\n *   time: '0x1234567890',\n *   withdrawals: [\n *     {\n *       address: '0x0000000000000000000000000000000000000000',\n *       amount: '0x1',\n *       index: '0x0',\n *       validatorIndex: '0x1',\n *     },\n *   ],\n * })\n * ```\n *\n * @param rpcBlockOverrides - The RPC block overrides to convert.\n * @returns An instantiated {@link ox#BlockOverrides.BlockOverrides}.\n */ function fromRpc(rpcBlockOverrides) {\n    return {\n        ...rpcBlockOverrides.baseFeePerGas && {\n            baseFeePerGas: BigInt(rpcBlockOverrides.baseFeePerGas)\n        },\n        ...rpcBlockOverrides.blobBaseFee && {\n            blobBaseFee: BigInt(rpcBlockOverrides.blobBaseFee)\n        },\n        ...rpcBlockOverrides.feeRecipient && {\n            feeRecipient: rpcBlockOverrides.feeRecipient\n        },\n        ...rpcBlockOverrides.gasLimit && {\n            gasLimit: BigInt(rpcBlockOverrides.gasLimit)\n        },\n        ...rpcBlockOverrides.number && {\n            number: BigInt(rpcBlockOverrides.number)\n        },\n        ...rpcBlockOverrides.prevRandao && {\n            prevRandao: BigInt(rpcBlockOverrides.prevRandao)\n        },\n        ...rpcBlockOverrides.time && {\n            time: BigInt(rpcBlockOverrides.time)\n        },\n        ...rpcBlockOverrides.withdrawals && {\n            withdrawals: rpcBlockOverrides.withdrawals.map(_Withdrawal_js__WEBPACK_IMPORTED_MODULE_0__.fromRpc)\n        }\n    };\n}\n/**\n * Converts an {@link ox#BlockOverrides.BlockOverrides} to an {@link ox#BlockOverrides.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { BlockOverrides } from 'ox'\n *\n * const blockOverrides = BlockOverrides.toRpc({\n *   baseFeePerGas: 1n,\n *   blobBaseFee: 2n,\n *   feeRecipient: '0x0000000000000000000000000000000000000000',\n *   gasLimit: 4n,\n *   number: 5n,\n *   prevRandao: 6n,\n *   time: 78187493520n,\n *   withdrawals: [\n *     {\n *       address: '0x0000000000000000000000000000000000000000',\n *       amount: 1n,\n *       index: 0,\n *       validatorIndex: 1,\n *     },\n *   ],\n * })\n * ```\n *\n * @param blockOverrides - The block overrides to convert.\n * @returns An instantiated {@link ox#BlockOverrides.Rpc}.\n */ function toRpc(blockOverrides) {\n    return {\n        ...typeof blockOverrides.baseFeePerGas === \"bigint\" && {\n            baseFeePerGas: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(blockOverrides.baseFeePerGas)\n        },\n        ...typeof blockOverrides.blobBaseFee === \"bigint\" && {\n            blobBaseFee: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(blockOverrides.blobBaseFee)\n        },\n        ...typeof blockOverrides.feeRecipient === \"string\" && {\n            feeRecipient: blockOverrides.feeRecipient\n        },\n        ...typeof blockOverrides.gasLimit === \"bigint\" && {\n            gasLimit: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(blockOverrides.gasLimit)\n        },\n        ...typeof blockOverrides.number === \"bigint\" && {\n            number: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(blockOverrides.number)\n        },\n        ...typeof blockOverrides.prevRandao === \"bigint\" && {\n            prevRandao: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(blockOverrides.prevRandao)\n        },\n        ...typeof blockOverrides.time === \"bigint\" && {\n            time: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(blockOverrides.time)\n        },\n        ...blockOverrides.withdrawals && {\n            withdrawals: blockOverrides.withdrawals.map(_Withdrawal_js__WEBPACK_IMPORTED_MODULE_0__.toRpc)\n        }\n    };\n} //# sourceMappingURL=BlockOverrides.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0Jsb2NrT3ZlcnJpZGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBZ0M7QUFDYztBQUM5Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQTRCQyxHQUNNLFNBQVNFLFFBQVFDLGlCQUFpQjtJQUNyQyxPQUFPO1FBQ0gsR0FBSUEsa0JBQWtCQyxhQUFhLElBQUk7WUFDbkNBLGVBQWVDLE9BQU9GLGtCQUFrQkMsYUFBYTtRQUN6RCxDQUFDO1FBQ0QsR0FBSUQsa0JBQWtCRyxXQUFXLElBQUk7WUFDakNBLGFBQWFELE9BQU9GLGtCQUFrQkcsV0FBVztRQUNyRCxDQUFDO1FBQ0QsR0FBSUgsa0JBQWtCSSxZQUFZLElBQUk7WUFDbENBLGNBQWNKLGtCQUFrQkksWUFBWTtRQUNoRCxDQUFDO1FBQ0QsR0FBSUosa0JBQWtCSyxRQUFRLElBQUk7WUFDOUJBLFVBQVVILE9BQU9GLGtCQUFrQkssUUFBUTtRQUMvQyxDQUFDO1FBQ0QsR0FBSUwsa0JBQWtCTSxNQUFNLElBQUk7WUFDNUJBLFFBQVFKLE9BQU9GLGtCQUFrQk0sTUFBTTtRQUMzQyxDQUFDO1FBQ0QsR0FBSU4sa0JBQWtCTyxVQUFVLElBQUk7WUFDaENBLFlBQVlMLE9BQU9GLGtCQUFrQk8sVUFBVTtRQUNuRCxDQUFDO1FBQ0QsR0FBSVAsa0JBQWtCUSxJQUFJLElBQUk7WUFDMUJBLE1BQU1OLE9BQU9GLGtCQUFrQlEsSUFBSTtRQUN2QyxDQUFDO1FBQ0QsR0FBSVIsa0JBQWtCUyxXQUFXLElBQUk7WUFDakNBLGFBQWFULGtCQUFrQlMsV0FBVyxDQUFDQyxHQUFHLENBQUNaLG1EQUFrQjtRQUNyRSxDQUFDO0lBQ0w7QUFDSjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBNEJDLEdBQ00sU0FBU2EsTUFBTUMsY0FBYztJQUNoQyxPQUFPO1FBQ0gsR0FBSSxPQUFPQSxlQUFlWCxhQUFhLEtBQUssWUFBWTtZQUNwREEsZUFBZUosK0NBQWMsQ0FBQ2UsZUFBZVgsYUFBYTtRQUM5RCxDQUFDO1FBQ0QsR0FBSSxPQUFPVyxlQUFlVCxXQUFXLEtBQUssWUFBWTtZQUNsREEsYUFBYU4sK0NBQWMsQ0FBQ2UsZUFBZVQsV0FBVztRQUMxRCxDQUFDO1FBQ0QsR0FBSSxPQUFPUyxlQUFlUixZQUFZLEtBQUssWUFBWTtZQUNuREEsY0FBY1EsZUFBZVIsWUFBWTtRQUM3QyxDQUFDO1FBQ0QsR0FBSSxPQUFPUSxlQUFlUCxRQUFRLEtBQUssWUFBWTtZQUMvQ0EsVUFBVVIsK0NBQWMsQ0FBQ2UsZUFBZVAsUUFBUTtRQUNwRCxDQUFDO1FBQ0QsR0FBSSxPQUFPTyxlQUFlTixNQUFNLEtBQUssWUFBWTtZQUM3Q0EsUUFBUVQsK0NBQWMsQ0FBQ2UsZUFBZU4sTUFBTTtRQUNoRCxDQUFDO1FBQ0QsR0FBSSxPQUFPTSxlQUFlTCxVQUFVLEtBQUssWUFBWTtZQUNqREEsWUFBWVYsK0NBQWMsQ0FBQ2UsZUFBZUwsVUFBVTtRQUN4RCxDQUFDO1FBQ0QsR0FBSSxPQUFPSyxlQUFlSixJQUFJLEtBQUssWUFBWTtZQUMzQ0EsTUFBTVgsK0NBQWMsQ0FBQ2UsZUFBZUosSUFBSTtRQUM1QyxDQUFDO1FBQ0QsR0FBSUksZUFBZUgsV0FBVyxJQUFJO1lBQzlCQSxhQUFhRyxlQUFlSCxXQUFXLENBQUNDLEdBQUcsQ0FBQ1osaURBQWdCO1FBQ2hFLENBQUM7SUFDTDtBQUNKLEVBQ0EsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xhdy13b3Jrcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvQmxvY2tPdmVycmlkZXMuanM/ZjYxOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBIZXggZnJvbSAnLi9IZXguanMnO1xuaW1wb3J0ICogYXMgV2l0aGRyYXdhbCBmcm9tICcuL1dpdGhkcmF3YWwuanMnO1xuLyoqXG4gKiBDb252ZXJ0cyBhbiB7QGxpbmsgb3gjQmxvY2tPdmVycmlkZXMuUnBjfSB0byBhbiB7QGxpbmsgb3gjQmxvY2tPdmVycmlkZXMuQmxvY2tPdmVycmlkZXN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQmxvY2tPdmVycmlkZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBibG9ja092ZXJyaWRlcyA9IEJsb2NrT3ZlcnJpZGVzLmZyb21ScGMoe1xuICogICBiYXNlRmVlUGVyR2FzOiAnMHgxJyxcbiAqICAgYmxvYkJhc2VGZWU6ICcweDInLFxuICogICBmZWVSZWNpcGllbnQ6ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICBnYXNMaW1pdDogJzB4NCcsXG4gKiAgIG51bWJlcjogJzB4NScsXG4gKiAgIHByZXZSYW5kYW86ICcweDYnLFxuICogICB0aW1lOiAnMHgxMjM0NTY3ODkwJyxcbiAqICAgd2l0aGRyYXdhbHM6IFtcbiAqICAgICB7XG4gKiAgICAgICBhZGRyZXNzOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgICAgIGFtb3VudDogJzB4MScsXG4gKiAgICAgICBpbmRleDogJzB4MCcsXG4gKiAgICAgICB2YWxpZGF0b3JJbmRleDogJzB4MScsXG4gKiAgICAgfSxcbiAqICAgXSxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gcnBjQmxvY2tPdmVycmlkZXMgLSBUaGUgUlBDIGJsb2NrIG92ZXJyaWRlcyB0byBjb252ZXJ0LlxuICogQHJldHVybnMgQW4gaW5zdGFudGlhdGVkIHtAbGluayBveCNCbG9ja092ZXJyaWRlcy5CbG9ja092ZXJyaWRlc30uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUnBjKHJwY0Jsb2NrT3ZlcnJpZGVzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uKHJwY0Jsb2NrT3ZlcnJpZGVzLmJhc2VGZWVQZXJHYXMgJiYge1xuICAgICAgICAgICAgYmFzZUZlZVBlckdhczogQmlnSW50KHJwY0Jsb2NrT3ZlcnJpZGVzLmJhc2VGZWVQZXJHYXMpLFxuICAgICAgICB9KSxcbiAgICAgICAgLi4uKHJwY0Jsb2NrT3ZlcnJpZGVzLmJsb2JCYXNlRmVlICYmIHtcbiAgICAgICAgICAgIGJsb2JCYXNlRmVlOiBCaWdJbnQocnBjQmxvY2tPdmVycmlkZXMuYmxvYkJhc2VGZWUpLFxuICAgICAgICB9KSxcbiAgICAgICAgLi4uKHJwY0Jsb2NrT3ZlcnJpZGVzLmZlZVJlY2lwaWVudCAmJiB7XG4gICAgICAgICAgICBmZWVSZWNpcGllbnQ6IHJwY0Jsb2NrT3ZlcnJpZGVzLmZlZVJlY2lwaWVudCxcbiAgICAgICAgfSksXG4gICAgICAgIC4uLihycGNCbG9ja092ZXJyaWRlcy5nYXNMaW1pdCAmJiB7XG4gICAgICAgICAgICBnYXNMaW1pdDogQmlnSW50KHJwY0Jsb2NrT3ZlcnJpZGVzLmdhc0xpbWl0KSxcbiAgICAgICAgfSksXG4gICAgICAgIC4uLihycGNCbG9ja092ZXJyaWRlcy5udW1iZXIgJiYge1xuICAgICAgICAgICAgbnVtYmVyOiBCaWdJbnQocnBjQmxvY2tPdmVycmlkZXMubnVtYmVyKSxcbiAgICAgICAgfSksXG4gICAgICAgIC4uLihycGNCbG9ja092ZXJyaWRlcy5wcmV2UmFuZGFvICYmIHtcbiAgICAgICAgICAgIHByZXZSYW5kYW86IEJpZ0ludChycGNCbG9ja092ZXJyaWRlcy5wcmV2UmFuZGFvKSxcbiAgICAgICAgfSksXG4gICAgICAgIC4uLihycGNCbG9ja092ZXJyaWRlcy50aW1lICYmIHtcbiAgICAgICAgICAgIHRpbWU6IEJpZ0ludChycGNCbG9ja092ZXJyaWRlcy50aW1lKSxcbiAgICAgICAgfSksXG4gICAgICAgIC4uLihycGNCbG9ja092ZXJyaWRlcy53aXRoZHJhd2FscyAmJiB7XG4gICAgICAgICAgICB3aXRoZHJhd2FsczogcnBjQmxvY2tPdmVycmlkZXMud2l0aGRyYXdhbHMubWFwKFdpdGhkcmF3YWwuZnJvbVJwYyksXG4gICAgICAgIH0pLFxuICAgIH07XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIHtAbGluayBveCNCbG9ja092ZXJyaWRlcy5CbG9ja092ZXJyaWRlc30gdG8gYW4ge0BsaW5rIG94I0Jsb2NrT3ZlcnJpZGVzLlJwY30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCbG9ja092ZXJyaWRlcyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGJsb2NrT3ZlcnJpZGVzID0gQmxvY2tPdmVycmlkZXMudG9ScGMoe1xuICogICBiYXNlRmVlUGVyR2FzOiAxbixcbiAqICAgYmxvYkJhc2VGZWU6IDJuLFxuICogICBmZWVSZWNpcGllbnQ6ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICBnYXNMaW1pdDogNG4sXG4gKiAgIG51bWJlcjogNW4sXG4gKiAgIHByZXZSYW5kYW86IDZuLFxuICogICB0aW1lOiA3ODE4NzQ5MzUyMG4sXG4gKiAgIHdpdGhkcmF3YWxzOiBbXG4gKiAgICAge1xuICogICAgICAgYWRkcmVzczogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgICAgICBhbW91bnQ6IDFuLFxuICogICAgICAgaW5kZXg6IDAsXG4gKiAgICAgICB2YWxpZGF0b3JJbmRleDogMSxcbiAqICAgICB9LFxuICogICBdLFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBibG9ja092ZXJyaWRlcyAtIFRoZSBibG9jayBvdmVycmlkZXMgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIEFuIGluc3RhbnRpYXRlZCB7QGxpbmsgb3gjQmxvY2tPdmVycmlkZXMuUnBjfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvUnBjKGJsb2NrT3ZlcnJpZGVzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uKHR5cGVvZiBibG9ja092ZXJyaWRlcy5iYXNlRmVlUGVyR2FzID09PSAnYmlnaW50JyAmJiB7XG4gICAgICAgICAgICBiYXNlRmVlUGVyR2FzOiBIZXguZnJvbU51bWJlcihibG9ja092ZXJyaWRlcy5iYXNlRmVlUGVyR2FzKSxcbiAgICAgICAgfSksXG4gICAgICAgIC4uLih0eXBlb2YgYmxvY2tPdmVycmlkZXMuYmxvYkJhc2VGZWUgPT09ICdiaWdpbnQnICYmIHtcbiAgICAgICAgICAgIGJsb2JCYXNlRmVlOiBIZXguZnJvbU51bWJlcihibG9ja092ZXJyaWRlcy5ibG9iQmFzZUZlZSksXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4odHlwZW9mIGJsb2NrT3ZlcnJpZGVzLmZlZVJlY2lwaWVudCA9PT0gJ3N0cmluZycgJiYge1xuICAgICAgICAgICAgZmVlUmVjaXBpZW50OiBibG9ja092ZXJyaWRlcy5mZWVSZWNpcGllbnQsXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4odHlwZW9mIGJsb2NrT3ZlcnJpZGVzLmdhc0xpbWl0ID09PSAnYmlnaW50JyAmJiB7XG4gICAgICAgICAgICBnYXNMaW1pdDogSGV4LmZyb21OdW1iZXIoYmxvY2tPdmVycmlkZXMuZ2FzTGltaXQpLFxuICAgICAgICB9KSxcbiAgICAgICAgLi4uKHR5cGVvZiBibG9ja092ZXJyaWRlcy5udW1iZXIgPT09ICdiaWdpbnQnICYmIHtcbiAgICAgICAgICAgIG51bWJlcjogSGV4LmZyb21OdW1iZXIoYmxvY2tPdmVycmlkZXMubnVtYmVyKSxcbiAgICAgICAgfSksXG4gICAgICAgIC4uLih0eXBlb2YgYmxvY2tPdmVycmlkZXMucHJldlJhbmRhbyA9PT0gJ2JpZ2ludCcgJiYge1xuICAgICAgICAgICAgcHJldlJhbmRhbzogSGV4LmZyb21OdW1iZXIoYmxvY2tPdmVycmlkZXMucHJldlJhbmRhbyksXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4odHlwZW9mIGJsb2NrT3ZlcnJpZGVzLnRpbWUgPT09ICdiaWdpbnQnICYmIHtcbiAgICAgICAgICAgIHRpbWU6IEhleC5mcm9tTnVtYmVyKGJsb2NrT3ZlcnJpZGVzLnRpbWUpLFxuICAgICAgICB9KSxcbiAgICAgICAgLi4uKGJsb2NrT3ZlcnJpZGVzLndpdGhkcmF3YWxzICYmIHtcbiAgICAgICAgICAgIHdpdGhkcmF3YWxzOiBibG9ja092ZXJyaWRlcy53aXRoZHJhd2Fscy5tYXAoV2l0aGRyYXdhbC50b1JwYyksXG4gICAgICAgIH0pLFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CbG9ja092ZXJyaWRlcy5qcy5tYXAiXSwibmFtZXMiOlsiSGV4IiwiV2l0aGRyYXdhbCIsImZyb21ScGMiLCJycGNCbG9ja092ZXJyaWRlcyIsImJhc2VGZWVQZXJHYXMiLCJCaWdJbnQiLCJibG9iQmFzZUZlZSIsImZlZVJlY2lwaWVudCIsImdhc0xpbWl0IiwibnVtYmVyIiwicHJldlJhbmRhbyIsInRpbWUiLCJ3aXRoZHJhd2FscyIsIm1hcCIsInRvUnBjIiwiYmxvY2tPdmVycmlkZXMiLCJmcm9tTnVtYmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/BlockOverrides.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Bytes.js":
/*!********************************************!*\
  !*** ./node_modules/ox/_esm/core/Bytes.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidBytesBooleanError: () => (/* binding */ InvalidBytesBooleanError),\n/* harmony export */   InvalidBytesTypeError: () => (/* binding */ InvalidBytesTypeError),\n/* harmony export */   SizeExceedsPaddingSizeError: () => (/* binding */ SizeExceedsPaddingSizeError),\n/* harmony export */   SizeOverflowError: () => (/* binding */ SizeOverflowError),\n/* harmony export */   SliceOffsetOutOfBoundsError: () => (/* binding */ SliceOffsetOutOfBoundsError),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   concat: () => (/* binding */ concat),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromArray: () => (/* binding */ fromArray),\n/* harmony export */   fromBoolean: () => (/* binding */ fromBoolean),\n/* harmony export */   fromHex: () => (/* binding */ fromHex),\n/* harmony export */   fromNumber: () => (/* binding */ fromNumber),\n/* harmony export */   fromString: () => (/* binding */ fromString),\n/* harmony export */   isEqual: () => (/* binding */ isEqual),\n/* harmony export */   padLeft: () => (/* binding */ padLeft),\n/* harmony export */   padRight: () => (/* binding */ padRight),\n/* harmony export */   random: () => (/* binding */ random),\n/* harmony export */   size: () => (/* binding */ size),\n/* harmony export */   slice: () => (/* binding */ slice),\n/* harmony export */   toBigInt: () => (/* binding */ toBigInt),\n/* harmony export */   toBoolean: () => (/* binding */ toBoolean),\n/* harmony export */   toHex: () => (/* binding */ toHex),\n/* harmony export */   toNumber: () => (/* binding */ toNumber),\n/* harmony export */   toString: () => (/* binding */ toString),\n/* harmony export */   trimLeft: () => (/* binding */ trimLeft),\n/* harmony export */   trimRight: () => (/* binding */ trimRight),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/curves/abstract/utils */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/bytes.js\");\n/* harmony import */ var _internal_hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/hex.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/hex.js\");\n/* harmony import */ var _Json_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Json.js */ \"(ssr)/./node_modules/ox/_esm/core/Json.js\");\n\n\n\n\n\n\nconst decoder = /*#__PURE__*/ new TextDecoder();\nconst encoder = /*#__PURE__*/ new TextEncoder();\n/**\n * Asserts if the given value is {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.assert('abc')\n * // @error: Bytes.InvalidBytesTypeError:\n * // @error: Value `\"abc\"` of type `string` is an invalid Bytes value.\n * // @error: Bytes values must be of type `Uint8Array`.\n * ```\n *\n * @param value - Value to assert.\n */ function assert(value) {\n    if (value instanceof Uint8Array) return;\n    if (!value) throw new InvalidBytesTypeError(value);\n    if (typeof value !== \"object\") throw new InvalidBytesTypeError(value);\n    if (!(\"BYTES_PER_ELEMENT\" in value)) throw new InvalidBytesTypeError(value);\n    if (value.BYTES_PER_ELEMENT !== 1 || value.constructor.name !== \"Uint8Array\") throw new InvalidBytesTypeError(value);\n}\n/**\n * Concatenates two or more {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const bytes = Bytes.concat(\n *   Bytes.from([1]),\n *   Bytes.from([69]),\n *   Bytes.from([420, 69]),\n * )\n * // @log: Uint8Array [ 1, 69, 420, 69 ]\n * ```\n *\n * @param values - Values to concatenate.\n * @returns Concatenated {@link ox#Bytes.Bytes}.\n */ function concat(...values) {\n    let length = 0;\n    for (const arr of values){\n        length += arr.length;\n    }\n    const result = new Uint8Array(length);\n    for(let i = 0, index = 0; i < values.length; i++){\n        const arr = values[i];\n        result.set(arr, index);\n        index += arr.length;\n    }\n    return result;\n}\n/**\n * Instantiates a {@link ox#Bytes.Bytes} value from a `Uint8Array`, a hex string, or an array of unsigned 8-bit integers.\n *\n * :::tip\n *\n * To instantiate from a **Boolean**, **String**, or **Number**, use one of the following:\n *\n * - `Bytes.fromBoolean`\n *\n * - `Bytes.fromString`\n *\n * - `Bytes.fromNumber`\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.from([255, 124, 5, 4])\n * // @log: Uint8Array([255, 124, 5, 4])\n *\n * const data = Bytes.from('0xdeadbeef')\n * // @log: Uint8Array([222, 173, 190, 239])\n * ```\n *\n * @param value - Value to convert.\n * @returns A {@link ox#Bytes.Bytes} instance.\n */ function from(value) {\n    if (value instanceof Uint8Array) return value;\n    if (typeof value === \"string\") return fromHex(value);\n    return fromArray(value);\n}\n/**\n * Converts an array of unsigned 8-bit integers into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromArray([255, 124, 5, 4])\n * // @log: Uint8Array([255, 124, 5, 4])\n * ```\n *\n * @param value - Value to convert.\n * @returns A {@link ox#Bytes.Bytes} instance.\n */ function fromArray(value) {\n    return value instanceof Uint8Array ? value : new Uint8Array(value);\n}\n/**\n * Encodes a boolean value into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromBoolean(true)\n * // @log: Uint8Array([1])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromBoolean(true, { size: 32 })\n * // @log: Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])\n * ```\n *\n * @param value - Boolean value to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */ function fromBoolean(value, options = {}) {\n    const { size } = options;\n    const bytes = new Uint8Array(1);\n    bytes[0] = Number(value);\n    if (typeof size === \"number\") {\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(bytes, size);\n        return padLeft(bytes, size);\n    }\n    return bytes;\n}\n/**\n * Encodes a {@link ox#Hex.Hex} value into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromHex('0x48656c6c6f20776f726c6421')\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromHex('0x48656c6c6f20776f726c6421', { size: 32 })\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n * ```\n *\n * @param value - {@link ox#Hex.Hex} value to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */ function fromHex(value, options = {}) {\n    const { size } = options;\n    let hex = value;\n    if (size) {\n        _internal_hex_js__WEBPACK_IMPORTED_MODULE_1__.assertSize(value, size);\n        hex = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.padRight(value, size);\n    }\n    let hexString = hex.slice(2);\n    if (hexString.length % 2) hexString = `0${hexString}`;\n    const length = hexString.length / 2;\n    const bytes = new Uint8Array(length);\n    for(let index = 0, j = 0; index < length; index++){\n        const nibbleLeft = _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.charCodeToBase16(hexString.charCodeAt(j++));\n        const nibbleRight = _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.charCodeToBase16(hexString.charCodeAt(j++));\n        if (nibbleLeft === undefined || nibbleRight === undefined) {\n            throw new _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError(`Invalid byte sequence (\"${hexString[j - 2]}${hexString[j - 1]}\" in \"${hexString}\").`);\n        }\n        bytes[index] = nibbleLeft << 4 | nibbleRight;\n    }\n    return bytes;\n}\n/**\n * Encodes a number value into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromNumber(420)\n * // @log: Uint8Array([1, 164])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromNumber(420, { size: 4 })\n * // @log: Uint8Array([0, 0, 1, 164])\n * ```\n *\n * @param value - Number value to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */ function fromNumber(value, options) {\n    const hex = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(value, options);\n    return fromHex(hex);\n}\n/**\n * Encodes a string into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromString('Hello world!')\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromString('Hello world!', { size: 32 })\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n * ```\n *\n * @param value - String to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */ function fromString(value, options = {}) {\n    const { size } = options;\n    const bytes = encoder.encode(value);\n    if (typeof size === \"number\") {\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(bytes, size);\n        return padRight(bytes, size);\n    }\n    return bytes;\n}\n/**\n * Checks if two {@link ox#Bytes.Bytes} values are equal.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.isEqual(Bytes.from([1]), Bytes.from([1]))\n * // @log: true\n *\n * Bytes.isEqual(Bytes.from([1]), Bytes.from([2]))\n * // @log: false\n * ```\n *\n * @param bytesA - First {@link ox#Bytes.Bytes} value.\n * @param bytesB - Second {@link ox#Bytes.Bytes} value.\n * @returns `true` if the two values are equal, otherwise `false`.\n */ function isEqual(bytesA, bytesB) {\n    return (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_4__.equalBytes)(bytesA, bytesB);\n}\n/**\n * Pads a {@link ox#Bytes.Bytes} value to the left with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.padLeft(Bytes.from([1]), 4)\n * // @log: Uint8Array([0, 0, 0, 1])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value to pad.\n * @param size - Size to pad the {@link ox#Bytes.Bytes} value to.\n * @returns Padded {@link ox#Bytes.Bytes} value.\n */ function padLeft(value, size) {\n    return _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.pad(value, {\n        dir: \"left\",\n        size\n    });\n}\n/**\n * Pads a {@link ox#Bytes.Bytes} value to the right with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.padRight(Bytes.from([1]), 4)\n * // @log: Uint8Array([1, 0, 0, 0])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value to pad.\n * @param size - Size to pad the {@link ox#Bytes.Bytes} value to.\n * @returns Padded {@link ox#Bytes.Bytes} value.\n */ function padRight(value, size) {\n    return _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.pad(value, {\n        dir: \"right\",\n        size\n    });\n}\n/**\n * Generates random {@link ox#Bytes.Bytes} of the specified length.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const bytes = Bytes.random(32)\n * // @log: Uint8Array([... x32])\n * ```\n *\n * @param length - Length of the random {@link ox#Bytes.Bytes} to generate.\n * @returns Random {@link ox#Bytes.Bytes} of the specified length.\n */ function random(length) {\n    return crypto.getRandomValues(new Uint8Array(length));\n}\n/**\n * Retrieves the size of a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.size(Bytes.from([1, 2, 3, 4]))\n * // @log: 4\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value.\n * @returns Size of the {@link ox#Bytes.Bytes} value.\n */ function size(value) {\n    return value.length;\n}\n/**\n * Returns a section of a {@link ox#Bytes.Bytes} value given a start/end bytes offset.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.slice(\n *   Bytes.from([1, 2, 3, 4, 5, 6, 7, 8, 9]),\n *   1,\n *   4,\n * )\n * // @log: Uint8Array([2, 3, 4])\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} value.\n * @param start - Start offset.\n * @param end - End offset.\n * @param options - Slice options.\n * @returns Sliced {@link ox#Bytes.Bytes} value.\n */ function slice(value, start, end, options = {}) {\n    const { strict } = options;\n    _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertStartOffset(value, start);\n    const value_ = value.slice(start, end);\n    if (strict) _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertEndOffset(value_, start, end);\n    return value_;\n}\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a bigint.\n *\n * @example\n * ```ts\n * import { Bytes } from 'ox'\n *\n * Bytes.toBigInt(Bytes.from([1, 164]))\n * // @log: 420n\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Decoding options.\n * @returns Decoded bigint.\n */ function toBigInt(bytes, options = {}) {\n    const { size } = options;\n    if (typeof size !== \"undefined\") _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(bytes, size);\n    const hex = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(bytes, options);\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.toBigInt(hex, options);\n}\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a boolean.\n *\n * @example\n * ```ts\n * import { Bytes } from 'ox'\n *\n * Bytes.toBoolean(Bytes.from([1]))\n * // @log: true\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Decoding options.\n * @returns Decoded boolean.\n */ function toBoolean(bytes, options = {}) {\n    const { size } = options;\n    let bytes_ = bytes;\n    if (typeof size !== \"undefined\") {\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(bytes_, size);\n        bytes_ = trimLeft(bytes_);\n    }\n    if (bytes_.length > 1 || bytes_[0] > 1) throw new InvalidBytesBooleanError(bytes_);\n    return Boolean(bytes_[0]);\n}\n/**\n * Encodes a {@link ox#Bytes.Bytes} value into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.toHex(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Options.\n * @returns Decoded {@link ox#Hex.Hex} value.\n */ function toHex(value, options = {}) {\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(value, options);\n}\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a number.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.toNumber(Bytes.from([1, 164]))\n * // @log: 420\n * ```\n */ function toNumber(bytes, options = {}) {\n    const { size } = options;\n    if (typeof size !== \"undefined\") _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(bytes, size);\n    const hex = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(bytes, options);\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.toNumber(hex, options);\n}\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a string.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.toString(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: 'Hello world'\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Options.\n * @returns Decoded string.\n */ function toString(bytes, options = {}) {\n    const { size } = options;\n    let bytes_ = bytes;\n    if (typeof size !== \"undefined\") {\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(bytes_, size);\n        bytes_ = trimRight(bytes_);\n    }\n    return decoder.decode(bytes_);\n}\n/**\n * Trims leading zeros from a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.trimLeft(Bytes.from([0, 0, 0, 0, 1, 2, 3]))\n * // @log: Uint8Array([1, 2, 3])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value.\n * @returns Trimmed {@link ox#Bytes.Bytes} value.\n */ function trimLeft(value) {\n    return _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.trim(value, {\n        dir: \"left\"\n    });\n}\n/**\n * Trims trailing zeros from a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.trimRight(Bytes.from([1, 2, 3, 0, 0, 0, 0]))\n * // @log: Uint8Array([1, 2, 3])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value.\n * @returns Trimmed {@link ox#Bytes.Bytes} value.\n */ function trimRight(value) {\n    return _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.trim(value, {\n        dir: \"right\"\n    });\n}\n/**\n * Checks if the given value is {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.validate('0x')\n * // @log: false\n *\n * Bytes.validate(Bytes.from([1, 2, 3]))\n * // @log: true\n * ```\n *\n * @param value - Value to check.\n * @returns `true` if the value is {@link ox#Bytes.Bytes}, otherwise `false`.\n */ function validate(value) {\n    try {\n        assert(value);\n        return true;\n    } catch  {\n        return false;\n    }\n}\n/**\n * Thrown when the bytes value cannot be represented as a boolean.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.toBoolean(Bytes.from([5]))\n * // @error: Bytes.InvalidBytesBooleanError: Bytes value `[5]` is not a valid boolean.\n * // @error: The bytes array must contain a single byte of either a `0` or `1` value.\n * ```\n */ class InvalidBytesBooleanError extends _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError {\n    constructor(bytes){\n        super(`Bytes value \\`${bytes}\\` is not a valid boolean.`, {\n            metaMessages: [\n                \"The bytes array must contain a single byte of either a `0` or `1` value.\"\n            ]\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Bytes.InvalidBytesBooleanError\"\n        });\n    }\n}\n/**\n * Thrown when a value cannot be converted to bytes.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Bytes } from 'ox'\n *\n * Bytes.from('foo')\n * // @error: Bytes.InvalidBytesTypeError: Value `foo` of type `string` is an invalid Bytes value.\n * ```\n */ class InvalidBytesTypeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError {\n    constructor(value){\n        super(`Value \\`${typeof value === \"object\" ? _Json_js__WEBPACK_IMPORTED_MODULE_5__.stringify(value) : value}\\` of type \\`${typeof value}\\` is an invalid Bytes value.`, {\n            metaMessages: [\n                \"Bytes values must be of type `Bytes`.\"\n            ]\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Bytes.InvalidBytesTypeError\"\n        });\n    }\n}\n/**\n * Thrown when a size exceeds the maximum allowed size.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.fromString('Hello World!', { size: 8 })\n * // @error: Bytes.SizeOverflowError: Size cannot exceed `8` bytes. Given size: `12` bytes.\n * ```\n */ class SizeOverflowError extends _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError {\n    constructor({ givenSize, maxSize }){\n        super(`Size cannot exceed \\`${maxSize}\\` bytes. Given size: \\`${givenSize}\\` bytes.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Bytes.SizeOverflowError\"\n        });\n    }\n}\n/**\n * Thrown when a slice offset is out-of-bounds.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.slice(Bytes.from([1, 2, 3]), 4)\n * // @error: Bytes.SliceOffsetOutOfBoundsError: Slice starting at offset `4` is out-of-bounds (size: `3`).\n * ```\n */ class SliceOffsetOutOfBoundsError extends _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError {\n    constructor({ offset, position, size }){\n        super(`Slice ${position === \"start\" ? \"starting\" : \"ending\"} at offset \\`${offset}\\` is out-of-bounds (size: \\`${size}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Bytes.SliceOffsetOutOfBoundsError\"\n        });\n    }\n}\n/**\n * Thrown when a the padding size exceeds the maximum allowed size.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.padLeft(Bytes.fromString('Hello World!'), 8)\n * // @error: [Bytes.SizeExceedsPaddingSizeError: Bytes size (`12`) exceeds padding size (`8`).\n * ```\n */ class SizeExceedsPaddingSizeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError {\n    constructor({ size, targetSize, type }){\n        super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (\\`${size}\\`) exceeds padding size (\\`${targetSize}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Bytes.SizeExceedsPaddingSizeError\"\n        });\n    }\n} //# sourceMappingURL=Bytes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0J5dGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEwRDtBQUNwQjtBQUNOO0FBQ2dCO0FBQ0U7QUFDaEI7QUFDbEMsTUFBTU0sVUFBVSxXQUFXLEdBQUcsSUFBSUM7QUFDbEMsTUFBTUMsVUFBVSxXQUFXLEdBQUcsSUFBSUM7QUFDbEM7Ozs7Ozs7Ozs7Ozs7O0NBY0MsR0FDTSxTQUFTQyxPQUFPQyxLQUFLO0lBQ3hCLElBQUlBLGlCQUFpQkMsWUFDakI7SUFDSixJQUFJLENBQUNELE9BQ0QsTUFBTSxJQUFJRSxzQkFBc0JGO0lBQ3BDLElBQUksT0FBT0EsVUFBVSxVQUNqQixNQUFNLElBQUlFLHNCQUFzQkY7SUFDcEMsSUFBSSxDQUFFLHdCQUF1QkEsS0FBSSxHQUM3QixNQUFNLElBQUlFLHNCQUFzQkY7SUFDcEMsSUFBSUEsTUFBTUcsaUJBQWlCLEtBQUssS0FBS0gsTUFBTUksV0FBVyxDQUFDQyxJQUFJLEtBQUssY0FDNUQsTUFBTSxJQUFJSCxzQkFBc0JGO0FBQ3hDO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBaUJDLEdBQ00sU0FBU00sT0FBTyxHQUFHQyxNQUFNO0lBQzVCLElBQUlDLFNBQVM7SUFDYixLQUFLLE1BQU1DLE9BQU9GLE9BQVE7UUFDdEJDLFVBQVVDLElBQUlELE1BQU07SUFDeEI7SUFDQSxNQUFNRSxTQUFTLElBQUlULFdBQVdPO0lBQzlCLElBQUssSUFBSUcsSUFBSSxHQUFHQyxRQUFRLEdBQUdELElBQUlKLE9BQU9DLE1BQU0sRUFBRUcsSUFBSztRQUMvQyxNQUFNRixNQUFNRixNQUFNLENBQUNJLEVBQUU7UUFDckJELE9BQU9HLEdBQUcsQ0FBQ0osS0FBS0c7UUFDaEJBLFNBQVNILElBQUlELE1BQU07SUFDdkI7SUFDQSxPQUFPRTtBQUNYO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBNkJDLEdBQ00sU0FB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QUFDLENBQUMscUJBQXFCLEVBQUVBLFFBQVEsd0JBQXdCLEVBQUVELFVBQVUsU0FBUyxDQUFDO1FBQ3BGUCxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLFFBQVE7WUFDaENDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1Z2RSxPQUFPO1FBQ1g7SUFDSjtBQUNKO0FBQ0E7Ozs7Ozs7Ozs7Q0FVQyxHQUNNLE1BQU00RSxvQ0FBb0N0RixpREFBZ0I7SUFDN0RjLFlBQVksRUFBRXlFLE1BQU0sRUFBRUMsUUFBUSxFQUFFM0QsSUFBSSxFQUFHLENBQUU7UUFDckMsS0FBSyxDQUFDLENBQUMsTUFBTSxFQUFFMkQsYUFBYSxVQUFVLGFBQWEsU0FBUyxhQUFhLEVBQUVELE9BQU8sNkJBQTZCLEVBQUUxRCxLQUFLLElBQUksQ0FBQztRQUMzSGdELE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsUUFBUTtZQUNoQ0MsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVnZFLE9BQU87UUFDWDtJQUNKO0FBQ0o7QUFDQTs7Ozs7Ozs7OztDQVVDLEdBQ00sTUFBTStFLG9DQUFvQ3pGLGlEQUFnQjtJQUM3RGMsWUFBWSxFQUFFZSxJQUFJLEVBQUU2RCxVQUFVLEVBQUVDLElBQUksRUFBRyxDQUFFO1FBQ3JDLEtBQUssQ0FBQyxDQUFDLEVBQUVBLEtBQUtDLE1BQU0sQ0FBQyxHQUFHQyxXQUFXLEdBQUcsRUFBRUYsS0FDbkN0RCxLQUFLLENBQUMsR0FDTnlELFdBQVcsR0FBRyxTQUFTLEVBQUVqRSxLQUFLLDRCQUE0QixFQUFFNkQsV0FBVyxJQUFJLENBQUM7UUFDakZiLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsUUFBUTtZQUNoQ0MsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVnZFLE9BQU87UUFDWDtJQUNKO0FBQ0osRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGF3LXdvcmtzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9CeXRlcy5qcz9mNjc0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGVxdWFsQnl0ZXMgfSBmcm9tICdAbm9ibGUvY3VydmVzL2Fic3RyYWN0L3V0aWxzJztcbmltcG9ydCAqIGFzIEVycm9ycyBmcm9tICcuL0Vycm9ycy5qcyc7XG5pbXBvcnQgKiBhcyBIZXggZnJvbSAnLi9IZXguanMnO1xuaW1wb3J0ICogYXMgaW50ZXJuYWwgZnJvbSAnLi9pbnRlcm5hbC9ieXRlcy5qcyc7XG5pbXBvcnQgKiBhcyBpbnRlcm5hbF9oZXggZnJvbSAnLi9pbnRlcm5hbC9oZXguanMnO1xuaW1wb3J0ICogYXMgSnNvbiBmcm9tICcuL0pzb24uanMnO1xuY29uc3QgZGVjb2RlciA9IC8qI19fUFVSRV9fKi8gbmV3IFRleHREZWNvZGVyKCk7XG5jb25zdCBlbmNvZGVyID0gLyojX19QVVJFX18qLyBuZXcgVGV4dEVuY29kZXIoKTtcbi8qKlxuICogQXNzZXJ0cyBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMuYXNzZXJ0KCdhYmMnKVxuICogLy8gQGVycm9yOiBCeXRlcy5JbnZhbGlkQnl0ZXNUeXBlRXJyb3I6XG4gKiAvLyBAZXJyb3I6IFZhbHVlIGBcImFiY1wiYCBvZiB0eXBlIGBzdHJpbmdgIGlzIGFuIGludmFsaWQgQnl0ZXMgdmFsdWUuXG4gKiAvLyBAZXJyb3I6IEJ5dGVzIHZhbHVlcyBtdXN0IGJlIG9mIHR5cGUgYFVpbnQ4QXJyYXlgLlxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVmFsdWUgdG8gYXNzZXJ0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0KHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICghdmFsdWUpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQnl0ZXNUeXBlRXJyb3IodmFsdWUpO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEJ5dGVzVHlwZUVycm9yKHZhbHVlKTtcbiAgICBpZiAoISgnQllURVNfUEVSX0VMRU1FTlQnIGluIHZhbHVlKSlcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRCeXRlc1R5cGVFcnJvcih2YWx1ZSk7XG4gICAgaWYgKHZhbHVlLkJZVEVTX1BFUl9FTEVNRU5UICE9PSAxIHx8IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgIT09ICdVaW50OEFycmF5JylcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRCeXRlc1R5cGVFcnJvcih2YWx1ZSk7XG59XG4vKipcbiAqIENvbmNhdGVuYXRlcyB0d28gb3IgbW9yZSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBieXRlcyA9IEJ5dGVzLmNvbmNhdChcbiAqICAgQnl0ZXMuZnJvbShbMV0pLFxuICogICBCeXRlcy5mcm9tKFs2OV0pLFxuICogICBCeXRlcy5mcm9tKFs0MjAsIDY5XSksXG4gKiApXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5IFsgMSwgNjksIDQyMCwgNjkgXVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlcyAtIFZhbHVlcyB0byBjb25jYXRlbmF0ZS5cbiAqIEByZXR1cm5zIENvbmNhdGVuYXRlZCB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0KC4uLnZhbHVlcykge1xuICAgIGxldCBsZW5ndGggPSAwO1xuICAgIGZvciAoY29uc3QgYXJyIG9mIHZhbHVlcykge1xuICAgICAgICBsZW5ndGggKz0gYXJyLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaW5kZXggPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IHZhbHVlc1tpXTtcbiAgICAgICAgcmVzdWx0LnNldChhcnIsIGluZGV4KTtcbiAgICAgICAgaW5kZXggKz0gYXJyLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogSW5zdGFudGlhdGVzIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZSBmcm9tIGEgYFVpbnQ4QXJyYXlgLCBhIGhleCBzdHJpbmcsIG9yIGFuIGFycmF5IG9mIHVuc2lnbmVkIDgtYml0IGludGVnZXJzLlxuICpcbiAqIDo6OnRpcFxuICpcbiAqIFRvIGluc3RhbnRpYXRlIGZyb20gYSAqKkJvb2xlYW4qKiwgKipTdHJpbmcqKiwgb3IgKipOdW1iZXIqKiwgdXNlIG9uZSBvZiB0aGUgZm9sbG93aW5nOlxuICpcbiAqIC0gYEJ5dGVzLmZyb21Cb29sZWFuYFxuICpcbiAqIC0gYEJ5dGVzLmZyb21TdHJpbmdgXG4gKlxuICogLSBgQnl0ZXMuZnJvbU51bWJlcmBcbiAqXG4gKiA6OjpcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBkYXRhID0gQnl0ZXMuZnJvbShbMjU1LCAxMjQsIDUsIDRdKVxuICogLy8gQGxvZzogVWludDhBcnJheShbMjU1LCAxMjQsIDUsIDRdKVxuICpcbiAqIGNvbnN0IGRhdGEgPSBCeXRlcy5mcm9tKCcweGRlYWRiZWVmJylcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzIyMiwgMTczLCAxOTAsIDIzOV0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgQSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IGluc3RhbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIGZyb21IZXgodmFsdWUpO1xuICAgIHJldHVybiBmcm9tQXJyYXkodmFsdWUpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiBhcnJheSBvZiB1bnNpZ25lZCA4LWJpdCBpbnRlZ2VycyBpbnRvIHtAbGluayBveCNCeXRlcy5CeXRlc30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGRhdGEgPSBCeXRlcy5mcm9tQXJyYXkoWzI1NSwgMTI0LCA1LCA0XSlcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzI1NSwgMTI0LCA1LCA0XSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBBIHtAbGluayBveCNCeXRlcy5CeXRlc30gaW5zdGFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tQXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gdmFsdWUgOiBuZXcgVWludDhBcnJheSh2YWx1ZSk7XG59XG4vKipcbiAqIEVuY29kZXMgYSBib29sZWFuIHZhbHVlIGludG8ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZGF0YSA9IEJ5dGVzLmZyb21Cb29sZWFuKHRydWUpXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5KFsxXSlcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBkYXRhID0gQnl0ZXMuZnJvbUJvb2xlYW4odHJ1ZSwgeyBzaXplOiAzMiB9KVxuICogLy8gQGxvZzogVWludDhBcnJheShbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMV0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBCb29sZWFuIHZhbHVlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gRW5jb2Rpbmcgb3B0aW9ucy5cbiAqIEByZXR1cm5zIEVuY29kZWQge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Cb29sZWFuKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpemUgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheSgxKTtcbiAgICBieXRlc1swXSA9IE51bWJlcih2YWx1ZSk7XG4gICAgaWYgKHR5cGVvZiBzaXplID09PSAnbnVtYmVyJykge1xuICAgICAgICBpbnRlcm5hbC5hc3NlcnRTaXplKGJ5dGVzLCBzaXplKTtcbiAgICAgICAgcmV0dXJuIHBhZExlZnQoYnl0ZXMsIHNpemUpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59XG4vKipcbiAqIEVuY29kZXMgYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgaW50byB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBkYXRhID0gQnl0ZXMuZnJvbUhleCgnMHg0ODY1NmM2YzZmMjA3NzZmNzI2YzY0MjEnKVxuICogLy8gQGxvZzogVWludDhBcnJheShbNzIsIDEwMSwgMTA4LCAxMDgsIDExMSwgMzIsIDg3LCAxMTEsIDExNCwgMTA4LCAxMDAsIDMzXSlcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBkYXRhID0gQnl0ZXMuZnJvbUhleCgnMHg0ODY1NmM2YzZmMjA3NzZmNzI2YzY0MjEnLCB7IHNpemU6IDMyIH0pXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5KFs3MiwgMTAxLCAxMDgsIDEwOCwgMTExLCAzMiwgODcsIDExMSwgMTE0LCAxMDgsIDEwMCwgMzMsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0ge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gRW5jb2Rpbmcgb3B0aW9ucy5cbiAqIEByZXR1cm5zIEVuY29kZWQge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21IZXgodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2l6ZSB9ID0gb3B0aW9ucztcbiAgICBsZXQgaGV4ID0gdmFsdWU7XG4gICAgaWYgKHNpemUpIHtcbiAgICAgICAgaW50ZXJuYWxfaGV4LmFzc2VydFNpemUodmFsdWUsIHNpemUpO1xuICAgICAgICBoZXggPSBIZXgucGFkUmlnaHQodmFsdWUsIHNpemUpO1xuICAgIH1cbiAgICBsZXQgaGV4U3RyaW5nID0gaGV4LnNsaWNlKDIpO1xuICAgIGlmIChoZXhTdHJpbmcubGVuZ3RoICUgMilcbiAgICAgICAgaGV4U3RyaW5nID0gYDAke2hleFN0cmluZ31gO1xuICAgIGNvbnN0IGxlbmd0aCA9IGhleFN0cmluZy5sZW5ndGggLyAyO1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpbmRleCA9IDAsIGogPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBjb25zdCBuaWJibGVMZWZ0ID0gaW50ZXJuYWwuY2hhckNvZGVUb0Jhc2UxNihoZXhTdHJpbmcuY2hhckNvZGVBdChqKyspKTtcbiAgICAgICAgY29uc3QgbmliYmxlUmlnaHQgPSBpbnRlcm5hbC5jaGFyQ29kZVRvQmFzZTE2KGhleFN0cmluZy5jaGFyQ29kZUF0KGorKykpO1xuICAgICAgICBpZiAobmliYmxlTGVmdCA9PT0gdW5kZWZpbmVkIHx8IG5pYmJsZVJpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcnMuQmFzZUVycm9yKGBJbnZhbGlkIGJ5dGUgc2VxdWVuY2UgKFwiJHtoZXhTdHJpbmdbaiAtIDJdfSR7aGV4U3RyaW5nW2ogLSAxXX1cIiBpbiBcIiR7aGV4U3RyaW5nfVwiKS5gKTtcbiAgICAgICAgfVxuICAgICAgICBieXRlc1tpbmRleF0gPSAobmliYmxlTGVmdCA8PCA0KSB8IG5pYmJsZVJpZ2h0O1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59XG4vKipcbiAqIEVuY29kZXMgYSBudW1iZXIgdmFsdWUgaW50byB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBkYXRhID0gQnl0ZXMuZnJvbU51bWJlcig0MjApXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5KFsxLCAxNjRdKVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGRhdGEgPSBCeXRlcy5mcm9tTnVtYmVyKDQyMCwgeyBzaXplOiA0IH0pXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5KFswLCAwLCAxLCAxNjRdKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gTnVtYmVyIHZhbHVlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gRW5jb2Rpbmcgb3B0aW9ucy5cbiAqIEByZXR1cm5zIEVuY29kZWQge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21OdW1iZXIodmFsdWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBoZXggPSBIZXguZnJvbU51bWJlcih2YWx1ZSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGZyb21IZXgoaGV4KTtcbn1cbi8qKlxuICogRW5jb2RlcyBhIHN0cmluZyBpbnRvIHtAbGluayBveCNCeXRlcy5CeXRlc30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGRhdGEgPSBCeXRlcy5mcm9tU3RyaW5nKCdIZWxsbyB3b3JsZCEnKVxuICogLy8gQGxvZzogVWludDhBcnJheShbNzIsIDEwMSwgMTA4LCAxMDgsIDExMSwgMzIsIDExOSwgMTExLCAxMTQsIDEwOCwgMTAwLCAzM10pXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZGF0YSA9IEJ5dGVzLmZyb21TdHJpbmcoJ0hlbGxvIHdvcmxkIScsIHsgc2l6ZTogMzIgfSlcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzcyLCAxMDEsIDEwOCwgMTA4LCAxMTEsIDMyLCA4NywgMTExLCAxMTQsIDEwOCwgMTAwLCAzMywgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBTdHJpbmcgdG8gZW5jb2RlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBFbmNvZGluZyBvcHRpb25zLlxuICogQHJldHVybnMgRW5jb2RlZCB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVN0cmluZyh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzaXplIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJ5dGVzID0gZW5jb2Rlci5lbmNvZGUodmFsdWUpO1xuICAgIGlmICh0eXBlb2Ygc2l6ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaW50ZXJuYWwuYXNzZXJ0U2l6ZShieXRlcywgc2l6ZSk7XG4gICAgICAgIHJldHVybiBwYWRSaWdodChieXRlcywgc2l6ZSk7XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbn1cbi8qKlxuICogQ2hlY2tzIGlmIHR3byB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlcyBhcmUgZXF1YWwuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLmlzRXF1YWwoQnl0ZXMuZnJvbShbMV0pLCBCeXRlcy5mcm9tKFsxXSkpXG4gKiAvLyBAbG9nOiB0cnVlXG4gKlxuICogQnl0ZXMuaXNFcXVhbChCeXRlcy5mcm9tKFsxXSksIEJ5dGVzLmZyb20oWzJdKSlcbiAqIC8vIEBsb2c6IGZhbHNlXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYnl0ZXNBIC0gRmlyc3Qge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZS5cbiAqIEBwYXJhbSBieXRlc0IgLSBTZWNvbmQge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZS5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdHdvIHZhbHVlcyBhcmUgZXF1YWwsIG90aGVyd2lzZSBgZmFsc2VgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNFcXVhbChieXRlc0EsIGJ5dGVzQikge1xuICAgIHJldHVybiBlcXVhbEJ5dGVzKGJ5dGVzQSwgYnl0ZXNCKTtcbn1cbi8qKlxuICogUGFkcyBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUgdG8gdGhlIGxlZnQgd2l0aCB6ZXJvIGJ5dGVzIHVudGlsIGl0IHJlYWNoZXMgdGhlIGdpdmVuIGBzaXplYCAoZGVmYXVsdDogMzIgYnl0ZXMpLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBCeXRlcy5wYWRMZWZ0KEJ5dGVzLmZyb20oWzFdKSwgNClcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzAsIDAsIDAsIDFdKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZSB0byBwYWQuXG4gKiBAcGFyYW0gc2l6ZSAtIFNpemUgdG8gcGFkIHRoZSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlIHRvLlxuICogQHJldHVybnMgUGFkZGVkIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYWRMZWZ0KHZhbHVlLCBzaXplKSB7XG4gICAgcmV0dXJuIGludGVybmFsLnBhZCh2YWx1ZSwgeyBkaXI6ICdsZWZ0Jywgc2l6ZSB9KTtcbn1cbi8qKlxuICogUGFkcyBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUgdG8gdGhlIHJpZ2h0IHdpdGggemVybyBieXRlcyB1bnRpbCBpdCByZWFjaGVzIHRoZSBnaXZlbiBgc2l6ZWAgKGRlZmF1bHQ6IDMyIGJ5dGVzKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMucGFkUmlnaHQoQnl0ZXMuZnJvbShbMV0pLCA0KVxuICogLy8gQGxvZzogVWludDhBcnJheShbMSwgMCwgMCwgMF0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlIHRvIHBhZC5cbiAqIEBwYXJhbSBzaXplIC0gU2l6ZSB0byBwYWQgdGhlIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUgdG8uXG4gKiBAcmV0dXJucyBQYWRkZWQge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhZFJpZ2h0KHZhbHVlLCBzaXplKSB7XG4gICAgcmV0dXJuIGludGVybmFsLnBhZCh2YWx1ZSwgeyBkaXI6ICdyaWdodCcsIHNpemUgfSk7XG59XG4vKipcbiAqIEdlbmVyYXRlcyByYW5kb20ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSBvZiB0aGUgc3BlY2lmaWVkIGxlbmd0aC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYnl0ZXMgPSBCeXRlcy5yYW5kb20oMzIpXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5KFsuLi4geDMyXSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBsZW5ndGggLSBMZW5ndGggb2YgdGhlIHJhbmRvbSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHRvIGdlbmVyYXRlLlxuICogQHJldHVybnMgUmFuZG9tIHtAbGluayBveCNCeXRlcy5CeXRlc30gb2YgdGhlIHNwZWNpZmllZCBsZW5ndGguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5kb20obGVuZ3RoKSB7XG4gICAgcmV0dXJuIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkobGVuZ3RoKSk7XG59XG4vKipcbiAqIFJldHJpZXZlcyB0aGUgc2l6ZSBvZiBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLnNpemUoQnl0ZXMuZnJvbShbMSwgMiwgMywgNF0pKVxuICogLy8gQGxvZzogNFxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZS5cbiAqIEByZXR1cm5zIFNpemUgb2YgdGhlIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaXplKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLmxlbmd0aDtcbn1cbi8qKlxuICogUmV0dXJucyBhIHNlY3Rpb24gb2YgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlIGdpdmVuIGEgc3RhcnQvZW5kIGJ5dGVzIG9mZnNldC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMuc2xpY2UoXG4gKiAgIEJ5dGVzLmZyb20oWzEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDldKSxcbiAqICAgMSxcbiAqICAgNCxcbiAqIClcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzIsIDMsIDRdKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKiBAcGFyYW0gc3RhcnQgLSBTdGFydCBvZmZzZXQuXG4gKiBAcGFyYW0gZW5kIC0gRW5kIG9mZnNldC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gU2xpY2Ugb3B0aW9ucy5cbiAqIEByZXR1cm5zIFNsaWNlZCB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2xpY2UodmFsdWUsIHN0YXJ0LCBlbmQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc3RyaWN0IH0gPSBvcHRpb25zO1xuICAgIGludGVybmFsLmFzc2VydFN0YXJ0T2Zmc2V0KHZhbHVlLCBzdGFydCk7XG4gICAgY29uc3QgdmFsdWVfID0gdmFsdWUuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgaWYgKHN0cmljdClcbiAgICAgICAgaW50ZXJuYWwuYXNzZXJ0RW5kT2Zmc2V0KHZhbHVlXywgc3RhcnQsIGVuZCk7XG4gICAgcmV0dXJuIHZhbHVlXztcbn1cbi8qKlxuICogRGVjb2RlcyBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gaW50byBhIGJpZ2ludC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMudG9CaWdJbnQoQnl0ZXMuZnJvbShbMSwgMTY0XSkpXG4gKiAvLyBAbG9nOiA0MjBuXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYnl0ZXMgLSBUaGUge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB0byBkZWNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIERlY29kaW5nIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBEZWNvZGVkIGJpZ2ludC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQmlnSW50KGJ5dGVzLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpemUgfSA9IG9wdGlvbnM7XG4gICAgaWYgKHR5cGVvZiBzaXplICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgaW50ZXJuYWwuYXNzZXJ0U2l6ZShieXRlcywgc2l6ZSk7XG4gICAgY29uc3QgaGV4ID0gSGV4LmZyb21CeXRlcyhieXRlcywgb3B0aW9ucyk7XG4gICAgcmV0dXJuIEhleC50b0JpZ0ludChoZXgsIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBEZWNvZGVzIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSBpbnRvIGEgYm9vbGVhbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMudG9Cb29sZWFuKEJ5dGVzLmZyb20oWzFdKSlcbiAqIC8vIEBsb2c6IHRydWVcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBieXRlcyAtIFRoZSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHRvIGRlY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gRGVjb2Rpbmcgb3B0aW9ucy5cbiAqIEByZXR1cm5zIERlY29kZWQgYm9vbGVhbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQm9vbGVhbihieXRlcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzaXplIH0gPSBvcHRpb25zO1xuICAgIGxldCBieXRlc18gPSBieXRlcztcbiAgICBpZiAodHlwZW9mIHNpemUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGludGVybmFsLmFzc2VydFNpemUoYnl0ZXNfLCBzaXplKTtcbiAgICAgICAgYnl0ZXNfID0gdHJpbUxlZnQoYnl0ZXNfKTtcbiAgICB9XG4gICAgaWYgKGJ5dGVzXy5sZW5ndGggPiAxIHx8IGJ5dGVzX1swXSA+IDEpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQnl0ZXNCb29sZWFuRXJyb3IoYnl0ZXNfKTtcbiAgICByZXR1cm4gQm9vbGVhbihieXRlc19bMF0pO1xufVxuLyoqXG4gKiBFbmNvZGVzIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZSBpbnRvIGEge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBCeXRlcy50b0hleChCeXRlcy5mcm9tKFs3MiwgMTAxLCAxMDgsIDEwOCwgMTExLCAzMiwgODcsIDExMSwgMTE0LCAxMDgsIDEwMCwgMzNdKSlcbiAqIC8vICcweDQ4NjU2YzZjNmYyMDU3NmY3MjZjNjQyMSdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHRvIGRlY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIERlY29kZWQge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9IZXgodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBIZXguZnJvbUJ5dGVzKHZhbHVlLCBvcHRpb25zKTtcbn1cbi8qKlxuICogRGVjb2RlcyBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gaW50byBhIG51bWJlci5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMudG9OdW1iZXIoQnl0ZXMuZnJvbShbMSwgMTY0XSkpXG4gKiAvLyBAbG9nOiA0MjBcbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9OdW1iZXIoYnl0ZXMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2l6ZSB9ID0gb3B0aW9ucztcbiAgICBpZiAodHlwZW9mIHNpemUgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICBpbnRlcm5hbC5hc3NlcnRTaXplKGJ5dGVzLCBzaXplKTtcbiAgICBjb25zdCBoZXggPSBIZXguZnJvbUJ5dGVzKGJ5dGVzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gSGV4LnRvTnVtYmVyKGhleCwgb3B0aW9ucyk7XG59XG4vKipcbiAqIERlY29kZXMgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IGludG8gYSBzdHJpbmcuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGRhdGEgPSBCeXRlcy50b1N0cmluZyhCeXRlcy5mcm9tKFs3MiwgMTAxLCAxMDgsIDEwOCwgMTExLCAzMiwgODcsIDExMSwgMTE0LCAxMDgsIDEwMCwgMzNdKSlcbiAqIC8vIEBsb2c6ICdIZWxsbyB3b3JsZCdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBieXRlcyAtIFRoZSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHRvIGRlY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIERlY29kZWQgc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9TdHJpbmcoYnl0ZXMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2l6ZSB9ID0gb3B0aW9ucztcbiAgICBsZXQgYnl0ZXNfID0gYnl0ZXM7XG4gICAgaWYgKHR5cGVvZiBzaXplICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpbnRlcm5hbC5hc3NlcnRTaXplKGJ5dGVzXywgc2l6ZSk7XG4gICAgICAgIGJ5dGVzXyA9IHRyaW1SaWdodChieXRlc18pO1xuICAgIH1cbiAgICByZXR1cm4gZGVjb2Rlci5kZWNvZGUoYnl0ZXNfKTtcbn1cbi8qKlxuICogVHJpbXMgbGVhZGluZyB6ZXJvcyBmcm9tIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMudHJpbUxlZnQoQnl0ZXMuZnJvbShbMCwgMCwgMCwgMCwgMSwgMiwgM10pKVxuICogLy8gQGxvZzogVWludDhBcnJheShbMSwgMiwgM10pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlLlxuICogQHJldHVybnMgVHJpbW1lZCB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJpbUxlZnQodmFsdWUpIHtcbiAgICByZXR1cm4gaW50ZXJuYWwudHJpbSh2YWx1ZSwgeyBkaXI6ICdsZWZ0JyB9KTtcbn1cbi8qKlxuICogVHJpbXMgdHJhaWxpbmcgemVyb3MgZnJvbSBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLnRyaW1SaWdodChCeXRlcy5mcm9tKFsxLCAyLCAzLCAwLCAwLCAwLCAwXSkpXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5KFsxLCAyLCAzXSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKiBAcmV0dXJucyBUcmltbWVkIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmltUmlnaHQodmFsdWUpIHtcbiAgICByZXR1cm4gaW50ZXJuYWwudHJpbSh2YWx1ZSwgeyBkaXI6ICdyaWdodCcgfSk7XG59XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMudmFsaWRhdGUoJzB4JylcbiAqIC8vIEBsb2c6IGZhbHNlXG4gKlxuICogQnl0ZXMudmFsaWRhdGUoQnl0ZXMuZnJvbShbMSwgMiwgM10pKVxuICogLy8gQGxvZzogdHJ1ZVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIHtAbGluayBveCNCeXRlcy5CeXRlc30sIG90aGVyd2lzZSBgZmFsc2VgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGUodmFsdWUpIHtcbiAgICB0cnkge1xuICAgICAgICBhc3NlcnQodmFsdWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd24gd2hlbiB0aGUgYnl0ZXMgdmFsdWUgY2Fubm90IGJlIHJlcHJlc2VudGVkIGFzIGEgYm9vbGVhbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMudG9Cb29sZWFuKEJ5dGVzLmZyb20oWzVdKSlcbiAqIC8vIEBlcnJvcjogQnl0ZXMuSW52YWxpZEJ5dGVzQm9vbGVhbkVycm9yOiBCeXRlcyB2YWx1ZSBgWzVdYCBpcyBub3QgYSB2YWxpZCBib29sZWFuLlxuICogLy8gQGVycm9yOiBUaGUgYnl0ZXMgYXJyYXkgbXVzdCBjb250YWluIGEgc2luZ2xlIGJ5dGUgb2YgZWl0aGVyIGEgYDBgIG9yIGAxYCB2YWx1ZS5cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZEJ5dGVzQm9vbGVhbkVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoYnl0ZXMpIHtcbiAgICAgICAgc3VwZXIoYEJ5dGVzIHZhbHVlIFxcYCR7Ynl0ZXN9XFxgIGlzIG5vdCBhIHZhbGlkIGJvb2xlYW4uYCwge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXG4gICAgICAgICAgICAgICAgJ1RoZSBieXRlcyBhcnJheSBtdXN0IGNvbnRhaW4gYSBzaW5nbGUgYnl0ZSBvZiBlaXRoZXIgYSBgMGAgb3IgYDFgIHZhbHVlLicsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0J5dGVzLkludmFsaWRCeXRlc0Jvb2xlYW5FcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd24gd2hlbiBhIHZhbHVlIGNhbm5vdCBiZSBjb252ZXJ0ZWQgdG8gYnl0ZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMuZnJvbSgnZm9vJylcbiAqIC8vIEBlcnJvcjogQnl0ZXMuSW52YWxpZEJ5dGVzVHlwZUVycm9yOiBWYWx1ZSBgZm9vYCBvZiB0eXBlIGBzdHJpbmdgIGlzIGFuIGludmFsaWQgQnl0ZXMgdmFsdWUuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRCeXRlc1R5cGVFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIHN1cGVyKGBWYWx1ZSBcXGAke3R5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgPyBKc29uLnN0cmluZ2lmeSh2YWx1ZSkgOiB2YWx1ZX1cXGAgb2YgdHlwZSBcXGAke3R5cGVvZiB2YWx1ZX1cXGAgaXMgYW4gaW52YWxpZCBCeXRlcyB2YWx1ZS5gLCB7XG4gICAgICAgICAgICBtZXRhTWVzc2FnZXM6IFsnQnl0ZXMgdmFsdWVzIG11c3QgYmUgb2YgdHlwZSBgQnl0ZXNgLiddLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0J5dGVzLkludmFsaWRCeXRlc1R5cGVFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd24gd2hlbiBhIHNpemUgZXhjZWVkcyB0aGUgbWF4aW11bSBhbGxvd2VkIHNpemUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLmZyb21TdHJpbmcoJ0hlbGxvIFdvcmxkIScsIHsgc2l6ZTogOCB9KVxuICogLy8gQGVycm9yOiBCeXRlcy5TaXplT3ZlcmZsb3dFcnJvcjogU2l6ZSBjYW5ub3QgZXhjZWVkIGA4YCBieXRlcy4gR2l2ZW4gc2l6ZTogYDEyYCBieXRlcy5cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgU2l6ZU92ZXJmbG93RXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGdpdmVuU2l6ZSwgbWF4U2l6ZSB9KSB7XG4gICAgICAgIHN1cGVyKGBTaXplIGNhbm5vdCBleGNlZWQgXFxgJHttYXhTaXplfVxcYCBieXRlcy4gR2l2ZW4gc2l6ZTogXFxgJHtnaXZlblNpemV9XFxgIGJ5dGVzLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQnl0ZXMuU2l6ZU92ZXJmbG93RXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3duIHdoZW4gYSBzbGljZSBvZmZzZXQgaXMgb3V0LW9mLWJvdW5kcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMuc2xpY2UoQnl0ZXMuZnJvbShbMSwgMiwgM10pLCA0KVxuICogLy8gQGVycm9yOiBCeXRlcy5TbGljZU9mZnNldE91dE9mQm91bmRzRXJyb3I6IFNsaWNlIHN0YXJ0aW5nIGF0IG9mZnNldCBgNGAgaXMgb3V0LW9mLWJvdW5kcyAoc2l6ZTogYDNgKS5cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgU2xpY2VPZmZzZXRPdXRPZkJvdW5kc0Vycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBvZmZzZXQsIHBvc2l0aW9uLCBzaXplLCB9KSB7XG4gICAgICAgIHN1cGVyKGBTbGljZSAke3Bvc2l0aW9uID09PSAnc3RhcnQnID8gJ3N0YXJ0aW5nJyA6ICdlbmRpbmcnfSBhdCBvZmZzZXQgXFxgJHtvZmZzZXR9XFxgIGlzIG91dC1vZi1ib3VuZHMgKHNpemU6IFxcYCR7c2l6ZX1cXGApLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQnl0ZXMuU2xpY2VPZmZzZXRPdXRPZkJvdW5kc0Vycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIGEgdGhlIHBhZGRpbmcgc2l6ZSBleGNlZWRzIHRoZSBtYXhpbXVtIGFsbG93ZWQgc2l6ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMucGFkTGVmdChCeXRlcy5mcm9tU3RyaW5nKCdIZWxsbyBXb3JsZCEnKSwgOClcbiAqIC8vIEBlcnJvcjogW0J5dGVzLlNpemVFeGNlZWRzUGFkZGluZ1NpemVFcnJvcjogQnl0ZXMgc2l6ZSAoYDEyYCkgZXhjZWVkcyBwYWRkaW5nIHNpemUgKGA4YCkuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIFNpemVFeGNlZWRzUGFkZGluZ1NpemVFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgc2l6ZSwgdGFyZ2V0U2l6ZSwgdHlwZSwgfSkge1xuICAgICAgICBzdXBlcihgJHt0eXBlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpfSR7dHlwZVxuICAgICAgICAgICAgLnNsaWNlKDEpXG4gICAgICAgICAgICAudG9Mb3dlckNhc2UoKX0gc2l6ZSAoXFxgJHtzaXplfVxcYCkgZXhjZWVkcyBwYWRkaW5nIHNpemUgKFxcYCR7dGFyZ2V0U2l6ZX1cXGApLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQnl0ZXMuU2l6ZUV4Y2VlZHNQYWRkaW5nU2l6ZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CeXRlcy5qcy5tYXAiXSwibmFtZXMiOlsiZXF1YWxCeXRlcyIsIkVycm9ycyIsIkhleCIsImludGVybmFsIiwiaW50ZXJuYWxfaGV4IiwiSnNvbiIsImRlY29kZXIiLCJUZXh0RGVjb2RlciIsImVuY29kZXIiLCJUZXh0RW5jb2RlciIsImFzc2VydCIsInZhbHVlIiwiVWludDhBcnJheSIsIkludmFsaWRCeXRlc1R5cGVFcnJvciIsIkJZVEVTX1BFUl9FTEVNRU5UIiwiY29uc3RydWN0b3IiLCJuYW1lIiwiY29uY2F0IiwidmFsdWVzIiwibGVuZ3RoIiwiYXJyIiwicmVzdWx0IiwiaSIsImluZGV4Iiwic2V0IiwiZnJvbSIsImZyb21IZXgiLCJmcm9tQXJyYXkiLCJmcm9tQm9vbGVhbiIsIm9wdGlvbnMiLCJzaXplIiwiYnl0ZXMiLCJOdW1iZXIiLCJhc3NlcnRTaXplIiwicGFkTGVmdCIsImhleCIsInBhZFJpZ2h0IiwiaGV4U3RyaW5nIiwic2xpY2UiLCJqIiwibmliYmxlTGVmdCIsImNoYXJDb2RlVG9CYXNlMTYiLCJjaGFyQ29kZUF0IiwibmliYmxlUmlnaHQiLCJ1bmRlZmluZWQiLCJCYXNlRXJyb3IiLCJmcm9tTnVtYmVyIiwiZnJvbVN0cmluZyIsImVuY29kZSIsImlzRXF1YWwiLCJieXRlc0EiLCJieXRlc0IiLCJwYWQiLCJkaXIiLCJyYW5kb20iLCJjcnlwdG8iLCJnZXRSYW5kb21WYWx1ZXMiLCJzdGFydCIsImVuZCIsInN0cmljdCIsImFzc2VydFN0YXJ0T2Zmc2V0IiwidmFsdWVfIiwiYXNzZXJ0RW5kT2Zmc2V0IiwidG9CaWdJbnQiLCJmcm9tQnl0ZXMiLCJ0b0Jvb2xlYW4iLCJieXRlc18iLCJ0cmltTGVmdCIsIkludmFsaWRCeXRlc0Jvb2xlYW5FcnJvciIsIkJvb2xlYW4iLCJ0b0hleCIsInRvTnVtYmVyIiwidG9TdHJpbmciLCJ0cmltUmlnaHQiLCJkZWNvZGUiLCJ0cmltIiwidmFsaWRhdGUiLCJtZXRhTWVzc2FnZXMiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsInN0cmluZ2lmeSIsIlNpemVPdmVyZmxvd0Vycm9yIiwiZ2l2ZW5TaXplIiwibWF4U2l6ZSIsIlNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvciIsIm9mZnNldCIsInBvc2l0aW9uIiwiU2l6ZUV4Y2VlZHNQYWRkaW5nU2l6ZUVycm9yIiwidGFyZ2V0U2l6ZSIsInR5cGUiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsInRvTG93ZXJDYXNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Bytes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Caches.js":
/*!*********************************************!*\
  !*** ./node_modules/ox/_esm/core/Caches.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checksum: () => (/* binding */ checksum),\n/* harmony export */   clear: () => (/* binding */ clear)\n/* harmony export */ });\n/* harmony import */ var _internal_lru_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/lru.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/lru.js\");\n\nconst caches = {\n    checksum: /*#__PURE__*/ new _internal_lru_js__WEBPACK_IMPORTED_MODULE_0__.LruMap(8192)\n};\nconst checksum = caches.checksum;\n/**\n * Clears all global caches.\n *\n * @example\n * ```ts\n * import { Caches } from 'ox'\n * Caches.clear()\n * ```\n */ function clear() {\n    for (const cache of Object.values(caches))cache.clear();\n} //# sourceMappingURL=Caches.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0NhY2hlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBMkM7QUFDM0MsTUFBTUMsU0FBUztJQUNYQyxVQUFVLFdBQVcsR0FBRyxJQUFJRixvREFBTUEsQ0FBQztBQUN2QztBQUNPLE1BQU1FLFdBQVdELE9BQU9DLFFBQVEsQ0FBQztBQUN4Qzs7Ozs7Ozs7Q0FRQyxHQUNNLFNBQVNDO0lBQ1osS0FBSyxNQUFNQyxTQUFTQyxPQUFPQyxNQUFNLENBQUNMLFFBQzlCRyxNQUFNRCxLQUFLO0FBQ25CLEVBQ0Esa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xhdy13b3Jrcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvQ2FjaGVzLmpzPzcwZDkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTHJ1TWFwIH0gZnJvbSAnLi9pbnRlcm5hbC9scnUuanMnO1xuY29uc3QgY2FjaGVzID0ge1xuICAgIGNoZWNrc3VtOiAvKiNfX1BVUkVfXyovIG5ldyBMcnVNYXAoODE5MiksXG59O1xuZXhwb3J0IGNvbnN0IGNoZWNrc3VtID0gY2FjaGVzLmNoZWNrc3VtO1xuLyoqXG4gKiBDbGVhcnMgYWxsIGdsb2JhbCBjYWNoZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBDYWNoZXMgfSBmcm9tICdveCdcbiAqIENhY2hlcy5jbGVhcigpXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIGZvciAoY29uc3QgY2FjaGUgb2YgT2JqZWN0LnZhbHVlcyhjYWNoZXMpKVxuICAgICAgICBjYWNoZS5jbGVhcigpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2FjaGVzLmpzLm1hcCJdLCJuYW1lcyI6WyJMcnVNYXAiLCJjYWNoZXMiLCJjaGVja3N1bSIsImNsZWFyIiwiY2FjaGUiLCJPYmplY3QiLCJ2YWx1ZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Caches.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Ens.js":
/*!******************************************!*\
  !*** ./node_modules/ox/_esm/core/Ens.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   labelhash: () => (/* binding */ labelhash),\n/* harmony export */   namehash: () => (/* binding */ namehash),\n/* harmony export */   normalize: () => (/* binding */ normalize)\n/* harmony export */ });\n/* harmony import */ var _adraffy_ens_normalize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @adraffy/ens-normalize */ \"(ssr)/./node_modules/ox/node_modules/@adraffy/ens-normalize/dist/index.mjs\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Hash.js */ \"(ssr)/./node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _internal_ens_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/ens.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/ens.js\");\n\n\n\n\n\n/**\n * Hashes ENS label.\n *\n * Since ENS labels prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS labels](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `labelhash`. You can use the built-in {@link ox#Ens.(normalize:function)} function for this.\n *\n * @example\n * ```ts twoslash\n * import { Ens } from 'ox'\n * Ens.labelhash('eth')\n * '0x4f5b812789fc606be1b3b16908db13fc7a9adf7ca72641f84d75b47069d3d7f0'\n * ```\n *\n * @param label - ENS label.\n * @returns ENS labelhash.\n */ function labelhash(label) {\n    const result = new Uint8Array(32).fill(0);\n    if (!label) return _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(result);\n    return _internal_ens_js__WEBPACK_IMPORTED_MODULE_2__.unwrapLabelhash(label) || _Hash_js__WEBPACK_IMPORTED_MODULE_3__.keccak256(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromString(label));\n}\n/**\n * Hashes ENS name.\n *\n * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `namehash`. You can use the built-in {@link ox#Ens.(normalize:function)} function for this.\n *\n * @example\n * ```ts twoslash\n * import { Ens } from 'ox'\n * Ens.namehash('wevm.eth')\n * // @log: '0xf246651c1b9a6b141d19c2604e9a58f567973833990f830d882534a747801359'\n * ```\n *\n * @param name - ENS name.\n * @returns ENS namehash.\n */ function namehash(name) {\n    let result = new Uint8Array(32).fill(0);\n    if (!name) return _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(result);\n    const labels = name.split(\".\");\n    // Iterate in reverse order building up hash\n    for(let i = labels.length - 1; i >= 0; i -= 1){\n        const hashFromEncodedLabel = _internal_ens_js__WEBPACK_IMPORTED_MODULE_2__.unwrapLabelhash(labels[i]);\n        const hashed = hashFromEncodedLabel ? _Bytes_js__WEBPACK_IMPORTED_MODULE_4__.fromHex(hashFromEncodedLabel) : _Hash_js__WEBPACK_IMPORTED_MODULE_3__.keccak256(_Bytes_js__WEBPACK_IMPORTED_MODULE_4__.fromString(labels[i]), {\n            as: \"Bytes\"\n        });\n        result = _Hash_js__WEBPACK_IMPORTED_MODULE_3__.keccak256(_Bytes_js__WEBPACK_IMPORTED_MODULE_4__.concat(result, hashed), {\n            as: \"Bytes\"\n        });\n    }\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(result);\n}\n/**\n * Normalizes ENS name according to [ENSIP-15](https://github.com/ensdomains/docs/blob/9edf9443de4333a0ea7ec658a870672d5d180d53/ens-improvement-proposals/ensip-15-normalization-standard.md).\n *\n * For more info see [ENS documentation](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) on name processing.\n *\n * @example\n * ```ts twoslash\n * import { Ens } from 'ox'\n * Ens.normalize('wevm.eth')\n * // @log: 'wevm.eth'\n * ```\n *\n * @param name - ENS name.\n * @returns Normalized ENS name.\n */ function normalize(name) {\n    return (0,_adraffy_ens_normalize__WEBPACK_IMPORTED_MODULE_0__.ens_normalize)(name);\n} //# sourceMappingURL=Ens.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0Vucy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUF1RDtBQUNuQjtBQUNGO0FBQ0Y7QUFDYztBQUM5Qzs7Ozs7Ozs7Ozs7Ozs7Q0FjQyxHQUNNLFNBQVNLLFVBQVVDLEtBQUs7SUFDM0IsTUFBTUMsU0FBUyxJQUFJQyxXQUFXLElBQUlDLElBQUksQ0FBQztJQUN2QyxJQUFJLENBQUNILE9BQ0QsT0FBT0gsOENBQWEsQ0FBQ0k7SUFDekIsT0FBUUgsNkRBQXdCLENBQUNFLFVBQVVKLCtDQUFjLENBQUNDLCtDQUFjLENBQUNHO0FBQzdFO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0NBY0MsR0FDTSxTQUFTUSxTQUFTQyxJQUFJO0lBQ3pCLElBQUlSLFNBQVMsSUFBSUMsV0FBVyxJQUFJQyxJQUFJLENBQUM7SUFDckMsSUFBSSxDQUFDTSxNQUNELE9BQU9aLDhDQUFhLENBQUNJO0lBQ3pCLE1BQU1TLFNBQVNELEtBQUtFLEtBQUssQ0FBQztJQUMxQiw0Q0FBNEM7SUFDNUMsSUFBSyxJQUFJQyxJQUFJRixPQUFPRyxNQUFNLEdBQUcsR0FBR0QsS0FBSyxHQUFHQSxLQUFLLEVBQUc7UUFDNUMsTUFBTUUsdUJBQXVCaEIsNkRBQXdCLENBQUNZLE1BQU0sQ0FBQ0UsRUFBRTtRQUMvRCxNQUFNRyxTQUFTRCx1QkFDVG5CLDhDQUFhLENBQUNtQix3QkFDZGxCLCtDQUFjLENBQUNELGlEQUFnQixDQUFDZSxNQUFNLENBQUNFLEVBQUUsR0FBRztZQUFFSyxJQUFJO1FBQVE7UUFDaEVoQixTQUFTTCwrQ0FBYyxDQUFDRCw2Q0FBWSxDQUFDTSxRQUFRYyxTQUFTO1lBQUVFLElBQUk7UUFBUTtJQUN4RTtJQUNBLE9BQU9wQiw4Q0FBYSxDQUFDSTtBQUN6QjtBQUNBOzs7Ozs7Ozs7Ozs7OztDQWNDLEdBQ00sU0FBU2tCLFVBQVVWLElBQUk7SUFDMUIsT0FBT2YscUVBQWFBLENBQUNlO0FBQ3pCLEVBQ0EsK0JBQStCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xhdy13b3Jrcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvRW5zLmpzPzhmMGEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZW5zX25vcm1hbGl6ZSB9IGZyb20gJ0BhZHJhZmZ5L2Vucy1ub3JtYWxpemUnO1xuaW1wb3J0ICogYXMgQnl0ZXMgZnJvbSAnLi9CeXRlcy5qcyc7XG5pbXBvcnQgKiBhcyBIYXNoIGZyb20gJy4vSGFzaC5qcyc7XG5pbXBvcnQgKiBhcyBIZXggZnJvbSAnLi9IZXguanMnO1xuaW1wb3J0ICogYXMgaW50ZXJuYWwgZnJvbSAnLi9pbnRlcm5hbC9lbnMuanMnO1xuLyoqXG4gKiBIYXNoZXMgRU5TIGxhYmVsLlxuICpcbiAqIFNpbmNlIEVOUyBsYWJlbHMgcHJvaGliaXQgY2VydGFpbiBmb3JiaWRkZW4gY2hhcmFjdGVycyAoZS5nLiB1bmRlcnNjb3JlKSBhbmQgaGF2ZSBvdGhlciB2YWxpZGF0aW9uIHJ1bGVzLCB5b3UgbGlrZWx5IHdhbnQgdG8gW25vcm1hbGl6ZSBFTlMgbGFiZWxzXShodHRwczovL2RvY3MuZW5zLmRvbWFpbnMvY29udHJhY3QtYXBpLXJlZmVyZW5jZS9uYW1lLXByb2Nlc3Npbmcjbm9ybWFsaXNpbmctbmFtZXMpIHdpdGggW1VUUy00NiBub3JtYWxpemF0aW9uXShodHRwczovL3VuaWNvZGUub3JnL3JlcG9ydHMvdHI0NikgYmVmb3JlIHBhc3NpbmcgdGhlbSB0byBgbGFiZWxoYXNoYC4gWW91IGNhbiB1c2UgdGhlIGJ1aWx0LWluIHtAbGluayBveCNFbnMuKG5vcm1hbGl6ZTpmdW5jdGlvbil9IGZ1bmN0aW9uIGZvciB0aGlzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgRW5zIH0gZnJvbSAnb3gnXG4gKiBFbnMubGFiZWxoYXNoKCdldGgnKVxuICogJzB4NGY1YjgxMjc4OWZjNjA2YmUxYjNiMTY5MDhkYjEzZmM3YTlhZGY3Y2E3MjY0MWY4NGQ3NWI0NzA2OWQzZDdmMCdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBsYWJlbCAtIEVOUyBsYWJlbC5cbiAqIEByZXR1cm5zIEVOUyBsYWJlbGhhc2guXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsYWJlbGhhc2gobGFiZWwpIHtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheSgzMikuZmlsbCgwKTtcbiAgICBpZiAoIWxhYmVsKVxuICAgICAgICByZXR1cm4gSGV4LmZyb21CeXRlcyhyZXN1bHQpO1xuICAgIHJldHVybiAoaW50ZXJuYWwudW53cmFwTGFiZWxoYXNoKGxhYmVsKSB8fCBIYXNoLmtlY2NhazI1NihIZXguZnJvbVN0cmluZyhsYWJlbCkpKTtcbn1cbi8qKlxuICogSGFzaGVzIEVOUyBuYW1lLlxuICpcbiAqIFNpbmNlIEVOUyBuYW1lcyBwcm9oaWJpdCBjZXJ0YWluIGZvcmJpZGRlbiBjaGFyYWN0ZXJzIChlLmcuIHVuZGVyc2NvcmUpIGFuZCBoYXZlIG90aGVyIHZhbGlkYXRpb24gcnVsZXMsIHlvdSBsaWtlbHkgd2FudCB0byBbbm9ybWFsaXplIEVOUyBuYW1lc10oaHR0cHM6Ly9kb2NzLmVucy5kb21haW5zL2NvbnRyYWN0LWFwaS1yZWZlcmVuY2UvbmFtZS1wcm9jZXNzaW5nI25vcm1hbGlzaW5nLW5hbWVzKSB3aXRoIFtVVFMtNDYgbm9ybWFsaXphdGlvbl0oaHR0cHM6Ly91bmljb2RlLm9yZy9yZXBvcnRzL3RyNDYpIGJlZm9yZSBwYXNzaW5nIHRoZW0gdG8gYG5hbWVoYXNoYC4gWW91IGNhbiB1c2UgdGhlIGJ1aWx0LWluIHtAbGluayBveCNFbnMuKG5vcm1hbGl6ZTpmdW5jdGlvbil9IGZ1bmN0aW9uIGZvciB0aGlzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgRW5zIH0gZnJvbSAnb3gnXG4gKiBFbnMubmFtZWhhc2goJ3dldm0uZXRoJylcbiAqIC8vIEBsb2c6ICcweGYyNDY2NTFjMWI5YTZiMTQxZDE5YzI2MDRlOWE1OGY1Njc5NzM4MzM5OTBmODMwZDg4MjUzNGE3NDc4MDEzNTknXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gbmFtZSAtIEVOUyBuYW1lLlxuICogQHJldHVybnMgRU5TIG5hbWVoYXNoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbmFtZWhhc2gobmFtZSkge1xuICAgIGxldCByZXN1bHQgPSBuZXcgVWludDhBcnJheSgzMikuZmlsbCgwKTtcbiAgICBpZiAoIW5hbWUpXG4gICAgICAgIHJldHVybiBIZXguZnJvbUJ5dGVzKHJlc3VsdCk7XG4gICAgY29uc3QgbGFiZWxzID0gbmFtZS5zcGxpdCgnLicpO1xuICAgIC8vIEl0ZXJhdGUgaW4gcmV2ZXJzZSBvcmRlciBidWlsZGluZyB1cCBoYXNoXG4gICAgZm9yIChsZXQgaSA9IGxhYmVscy5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICBjb25zdCBoYXNoRnJvbUVuY29kZWRMYWJlbCA9IGludGVybmFsLnVud3JhcExhYmVsaGFzaChsYWJlbHNbaV0pO1xuICAgICAgICBjb25zdCBoYXNoZWQgPSBoYXNoRnJvbUVuY29kZWRMYWJlbFxuICAgICAgICAgICAgPyBCeXRlcy5mcm9tSGV4KGhhc2hGcm9tRW5jb2RlZExhYmVsKVxuICAgICAgICAgICAgOiBIYXNoLmtlY2NhazI1NihCeXRlcy5mcm9tU3RyaW5nKGxhYmVsc1tpXSksIHsgYXM6ICdCeXRlcycgfSk7XG4gICAgICAgIHJlc3VsdCA9IEhhc2gua2VjY2FrMjU2KEJ5dGVzLmNvbmNhdChyZXN1bHQsIGhhc2hlZCksIHsgYXM6ICdCeXRlcycgfSk7XG4gICAgfVxuICAgIHJldHVybiBIZXguZnJvbUJ5dGVzKHJlc3VsdCk7XG59XG4vKipcbiAqIE5vcm1hbGl6ZXMgRU5TIG5hbWUgYWNjb3JkaW5nIHRvIFtFTlNJUC0xNV0oaHR0cHM6Ly9naXRodWIuY29tL2Vuc2RvbWFpbnMvZG9jcy9ibG9iLzllZGY5NDQzZGU0MzMzYTBlYTdlYzY1OGE4NzA2NzJkNWQxODBkNTMvZW5zLWltcHJvdmVtZW50LXByb3Bvc2Fscy9lbnNpcC0xNS1ub3JtYWxpemF0aW9uLXN0YW5kYXJkLm1kKS5cbiAqXG4gKiBGb3IgbW9yZSBpbmZvIHNlZSBbRU5TIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZG9jcy5lbnMuZG9tYWlucy9jb250cmFjdC1hcGktcmVmZXJlbmNlL25hbWUtcHJvY2Vzc2luZyNub3JtYWxpc2luZy1uYW1lcykgb24gbmFtZSBwcm9jZXNzaW5nLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgRW5zIH0gZnJvbSAnb3gnXG4gKiBFbnMubm9ybWFsaXplKCd3ZXZtLmV0aCcpXG4gKiAvLyBAbG9nOiAnd2V2bS5ldGgnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gbmFtZSAtIEVOUyBuYW1lLlxuICogQHJldHVybnMgTm9ybWFsaXplZCBFTlMgbmFtZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZShuYW1lKSB7XG4gICAgcmV0dXJuIGVuc19ub3JtYWxpemUobmFtZSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FbnMuanMubWFwIl0sIm5hbWVzIjpbImVuc19ub3JtYWxpemUiLCJCeXRlcyIsIkhhc2giLCJIZXgiLCJpbnRlcm5hbCIsImxhYmVsaGFzaCIsImxhYmVsIiwicmVzdWx0IiwiVWludDhBcnJheSIsImZpbGwiLCJmcm9tQnl0ZXMiLCJ1bndyYXBMYWJlbGhhc2giLCJrZWNjYWsyNTYiLCJmcm9tU3RyaW5nIiwibmFtZWhhc2giLCJuYW1lIiwibGFiZWxzIiwic3BsaXQiLCJpIiwibGVuZ3RoIiwiaGFzaEZyb21FbmNvZGVkTGFiZWwiLCJoYXNoZWQiLCJmcm9tSGV4IiwiYXMiLCJjb25jYXQiLCJub3JtYWxpemUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Ens.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Errors.js":
/*!*********************************************!*\
  !*** ./node_modules/ox/_esm/core/Errors.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseError: () => (/* binding */ BaseError)\n/* harmony export */ });\n/* harmony import */ var _internal_errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/errors.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/errors.js\");\n\n/**\n * Base error class inherited by all errors thrown by ox.\n *\n * @example\n * ```ts\n * import { Errors } from 'ox'\n * throw new Errors.BaseError('An error occurred')\n * ```\n */ class BaseError extends Error {\n    static setStaticOptions(options) {\n        BaseError.prototype.docsOrigin = options.docsOrigin;\n        BaseError.prototype.showVersion = options.showVersion;\n        BaseError.prototype.version = options.version;\n    }\n    constructor(shortMessage, options = {}){\n        const details = (()=>{\n            if (options.cause instanceof BaseError) {\n                if (options.cause.details) return options.cause.details;\n                if (options.cause.shortMessage) return options.cause.shortMessage;\n            }\n            if (options.cause && \"details\" in options.cause && typeof options.cause.details === \"string\") return options.cause.details;\n            if (options.cause?.message) return options.cause.message;\n            return options.details;\n        })();\n        const docsPath = (()=>{\n            if (options.cause instanceof BaseError) return options.cause.docsPath || options.docsPath;\n            return options.docsPath;\n        })();\n        const docsBaseUrl = options.docsOrigin ?? BaseError.prototype.docsOrigin;\n        const docs = `${docsBaseUrl}${docsPath ?? \"\"}`;\n        const showVersion = Boolean(options.version ?? BaseError.prototype.showVersion);\n        const version = options.version ?? BaseError.prototype.version;\n        const message = [\n            shortMessage || \"An error occurred.\",\n            ...options.metaMessages ? [\n                \"\",\n                ...options.metaMessages\n            ] : [],\n            ...details || docsPath || showVersion ? [\n                \"\",\n                details ? `Details: ${details}` : undefined,\n                docsPath ? `See: ${docs}` : undefined,\n                showVersion ? `Version: ${version}` : undefined\n            ] : []\n        ].filter((x)=>typeof x === \"string\").join(\"\\n\");\n        super(message, options.cause ? {\n            cause: options.cause\n        } : undefined);\n        Object.defineProperty(this, \"details\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"docs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"docsOrigin\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"docsPath\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"shortMessage\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"showVersion\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"cause\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"BaseError\"\n        });\n        this.cause = options.cause;\n        this.details = details;\n        this.docs = docs;\n        this.docsOrigin = docsBaseUrl;\n        this.docsPath = docsPath;\n        this.shortMessage = shortMessage;\n        this.showVersion = showVersion;\n        this.version = version;\n    }\n    walk(fn) {\n        return walk(this, fn);\n    }\n}\nObject.defineProperty(BaseError, \"defaultStaticOptions\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: {\n        docsOrigin: \"https://oxlib.sh\",\n        showVersion: false,\n        version: `ox@${(0,_internal_errors_js__WEBPACK_IMPORTED_MODULE_0__.getVersion)()}`\n    }\n});\n(()=>{\n    BaseError.setStaticOptions(BaseError.defaultStaticOptions);\n})();\n/** @internal */ function walk(err, fn) {\n    if (fn?.(err)) return err;\n    if (err && typeof err === \"object\" && \"cause\" in err && err.cause) return walk(err.cause, fn);\n    return fn ? null : err;\n} //# sourceMappingURL=Errors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFrRDtBQUNsRDs7Ozs7Ozs7Q0FRQyxHQUNNLE1BQU1DLGtCQUFrQkM7SUFDM0IsT0FBT0MsaUJBQWlCQyxPQUFPLEVBQUU7UUFDN0JILFVBQVVJLFNBQVMsQ0FBQ0MsVUFBVSxHQUFHRixRQUFRRSxVQUFVO1FBQ25ETCxVQUFVSSxTQUFTLENBQUNFLFdBQVcsR0FBR0gsUUFBUUcsV0FBVztRQUNyRE4sVUFBVUksU0FBUyxDQUFDRyxPQUFPLEdBQUdKLFFBQVFJLE9BQU87SUFDakQ7SUFDQUMsWUFBWUMsWUFBWSxFQUFFTixVQUFVLENBQUMsQ0FBQyxDQUFFO1FBQ3BDLE1BQU1PLFVBQVUsQ0FBQztZQUNiLElBQUlQLFFBQVFRLEtBQUssWUFBWVgsV0FBVztnQkFDcEMsSUFBSUcsUUFBUVEsS0FBSyxDQUFDRCxPQUFPLEVBQ3JCLE9BQU9QLFFBQVFRLEtBQUssQ0FBQ0QsT0FBTztnQkFDaEMsSUFBSVAsUUFBUVEsS0FBSyxDQUFDRixZQUFZLEVBQzFCLE9BQU9OLFFBQVFRLEtBQUssQ0FBQ0YsWUFBWTtZQUN6QztZQUNBLElBQUlOLFFBQVFRLEtBQUssSUFDYixhQUFhUixRQUFRUSxLQUFLLElBQzFCLE9BQU9SLFFBQVFRLEtBQUssQ0FBQ0QsT0FBTyxLQUFLLFVBQ2pDLE9BQU9QLFFBQVFRLEtBQUssQ0FBQ0QsT0FBTztZQUNoQyxJQUFJUCxRQUFRUSxLQUFLLEVBQUVDLFNBQ2YsT0FBT1QsUUFBUVEsS0FBSyxDQUFDQyxPQUFPO1lBQ2hDLE9BQU9ULFFBQVFPLE9BQU87UUFDMUI7UUFDQSxNQUFNRyxXQUFXLENBQUM7WUFDZCxJQUFJVixRQUFRUSxLQUFLLFlBQVlYLFdBQ3pCLE9BQU9HLFFBQVFRLEtBQUssQ0FBQ0UsUUFBUSxJQUFJVixRQUFRVSxRQUFRO1lBQ3JELE9BQU9WLFFBQVFVLFFBQVE7UUFDM0I7UUFDQSxNQUFNQyxjQUFjWCxRQUFR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QyxjQUFjO0lBQ2RDLFVBQVU7SUFDVkMsT0FBTztRQUNIdEIsWUFBWTtRQUNaQyxhQUFhO1FBQ2JDLFNBQVMsQ0FBQyxHQUFHLEVBQUVSLCtEQUFVQSxHQUFHLENBQUM7SUFDakM7QUFDSjtBQUNDO0lBQ0dDLFVBQVVFLGdCQUFnQixDQUFDRixVQUFVOEIsb0JBQW9CO0FBQzdEO0FBQ0EsY0FBYyxHQUNkLFNBQVNGLEtBQUtHLEdBQUcsRUFBRUYsRUFBRTtJQUNqQixJQUFJQSxLQUFLRSxNQUNMLE9BQU9BO0lBQ1gsSUFBSUEsT0FBTyxPQUFPQSxRQUFRLFlBQVksV0FBV0EsT0FBT0EsSUFBSXBCLEtBQUssRUFDN0QsT0FBT2lCLEtBQUtHLElBQUlwQixLQUFLLEVBQUVrQjtJQUMzQixPQUFPQSxLQUFLLE9BQU9FO0FBQ3ZCLEVBQ0Esa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xhdy13b3Jrcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvRXJyb3JzLmpzPzlkNTkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0VmVyc2lvbiB9IGZyb20gJy4vaW50ZXJuYWwvZXJyb3JzLmpzJztcbi8qKlxuICogQmFzZSBlcnJvciBjbGFzcyBpbmhlcml0ZWQgYnkgYWxsIGVycm9ycyB0aHJvd24gYnkgb3guXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBFcnJvcnMgfSBmcm9tICdveCdcbiAqIHRocm93IG5ldyBFcnJvcnMuQmFzZUVycm9yKCdBbiBlcnJvciBvY2N1cnJlZCcpXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEJhc2VFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBzdGF0aWMgc2V0U3RhdGljT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIEJhc2VFcnJvci5wcm90b3R5cGUuZG9jc09yaWdpbiA9IG9wdGlvbnMuZG9jc09yaWdpbjtcbiAgICAgICAgQmFzZUVycm9yLnByb3RvdHlwZS5zaG93VmVyc2lvbiA9IG9wdGlvbnMuc2hvd1ZlcnNpb247XG4gICAgICAgIEJhc2VFcnJvci5wcm90b3R5cGUudmVyc2lvbiA9IG9wdGlvbnMudmVyc2lvbjtcbiAgICB9XG4gICAgY29uc3RydWN0b3Ioc2hvcnRNZXNzYWdlLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgZGV0YWlscyA9ICgoKSA9PiB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jYXVzZSBpbnN0YW5jZW9mIEJhc2VFcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmNhdXNlLmRldGFpbHMpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmNhdXNlLmRldGFpbHM7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2F1c2Uuc2hvcnRNZXNzYWdlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5jYXVzZS5zaG9ydE1lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jYXVzZSAmJlxuICAgICAgICAgICAgICAgICdkZXRhaWxzJyBpbiBvcHRpb25zLmNhdXNlICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIG9wdGlvbnMuY2F1c2UuZGV0YWlscyA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuY2F1c2UuZGV0YWlscztcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNhdXNlPy5tZXNzYWdlKVxuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmNhdXNlLm1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5kZXRhaWxzO1xuICAgICAgICB9KSgpO1xuICAgICAgICBjb25zdCBkb2NzUGF0aCA9ICgoKSA9PiB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jYXVzZSBpbnN0YW5jZW9mIEJhc2VFcnJvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5jYXVzZS5kb2NzUGF0aCB8fCBvcHRpb25zLmRvY3NQYXRoO1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuZG9jc1BhdGg7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIGNvbnN0IGRvY3NCYXNlVXJsID0gb3B0aW9ucy5kb2NzT3JpZ2luID8/IEJhc2VFcnJvci5wcm90b3R5cGUuZG9jc09yaWdpbjtcbiAgICAgICAgY29uc3QgZG9jcyA9IGAke2RvY3NCYXNlVXJsfSR7ZG9jc1BhdGggPz8gJyd9YDtcbiAgICAgICAgY29uc3Qgc2hvd1ZlcnNpb24gPSBCb29sZWFuKG9wdGlvbnMudmVyc2lvbiA/PyBCYXNlRXJyb3IucHJvdG90eXBlLnNob3dWZXJzaW9uKTtcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9IG9wdGlvbnMudmVyc2lvbiA/PyBCYXNlRXJyb3IucHJvdG90eXBlLnZlcnNpb247XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBbXG4gICAgICAgICAgICBzaG9ydE1lc3NhZ2UgfHwgJ0FuIGVycm9yIG9jY3VycmVkLicsXG4gICAgICAgICAgICAuLi4ob3B0aW9ucy5tZXRhTWVzc2FnZXMgPyBbJycsIC4uLm9wdGlvbnMubWV0YU1lc3NhZ2VzXSA6IFtdKSxcbiAgICAgICAgICAgIC4uLihkZXRhaWxzIHx8IGRvY3NQYXRoIHx8IHNob3dWZXJzaW9uXG4gICAgICAgICAgICAgICAgPyBbXG4gICAgICAgICAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgICAgICAgICBkZXRhaWxzID8gYERldGFpbHM6ICR7ZGV0YWlsc31gIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBkb2NzUGF0aCA/IGBTZWU6ICR7ZG9jc31gIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBzaG93VmVyc2lvbiA/IGBWZXJzaW9uOiAke3ZlcnNpb259YCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgOiBbXSksXG4gICAgICAgIF1cbiAgICAgICAgICAgIC5maWx0ZXIoKHgpID0+IHR5cGVvZiB4ID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIC5qb2luKCdcXG4nKTtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgb3B0aW9ucy5jYXVzZSA/IHsgY2F1c2U6IG9wdGlvbnMuY2F1c2UgfSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRldGFpbHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZG9jc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkb2NzT3JpZ2luXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRvY3NQYXRoXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNob3J0TWVzc2FnZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzaG93VmVyc2lvblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2ZXJzaW9uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNhdXNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdCYXNlRXJyb3InXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNhdXNlID0gb3B0aW9ucy5jYXVzZTtcbiAgICAgICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgICAgICAgdGhpcy5kb2NzID0gZG9jcztcbiAgICAgICAgdGhpcy5kb2NzT3JpZ2luID0gZG9jc0Jhc2VVcmw7XG4gICAgICAgIHRoaXMuZG9jc1BhdGggPSBkb2NzUGF0aDtcbiAgICAgICAgdGhpcy5zaG9ydE1lc3NhZ2UgPSBzaG9ydE1lc3NhZ2U7XG4gICAgICAgIHRoaXMuc2hvd1ZlcnNpb24gPSBzaG93VmVyc2lvbjtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICB9XG4gICAgd2Fsayhmbikge1xuICAgICAgICByZXR1cm4gd2Fsayh0aGlzLCBmbik7XG4gICAgfVxufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VFcnJvciwgXCJkZWZhdWx0U3RhdGljT3B0aW9uc1wiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IHtcbiAgICAgICAgZG9jc09yaWdpbjogJ2h0dHBzOi8vb3hsaWIuc2gnLFxuICAgICAgICBzaG93VmVyc2lvbjogZmFsc2UsXG4gICAgICAgIHZlcnNpb246IGBveEAke2dldFZlcnNpb24oKX1gLFxuICAgIH1cbn0pO1xuKCgpID0+IHtcbiAgICBCYXNlRXJyb3Iuc2V0U3RhdGljT3B0aW9ucyhCYXNlRXJyb3IuZGVmYXVsdFN0YXRpY09wdGlvbnMpO1xufSkoKTtcbi8qKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIHdhbGsoZXJyLCBmbikge1xuICAgIGlmIChmbj8uKGVycikpXG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgaWYgKGVyciAmJiB0eXBlb2YgZXJyID09PSAnb2JqZWN0JyAmJiAnY2F1c2UnIGluIGVyciAmJiBlcnIuY2F1c2UpXG4gICAgICAgIHJldHVybiB3YWxrKGVyci5jYXVzZSwgZm4pO1xuICAgIHJldHVybiBmbiA/IG51bGwgOiBlcnI7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FcnJvcnMuanMubWFwIl0sIm5hbWVzIjpbImdldFZlcnNpb24iLCJCYXNlRXJyb3IiLCJFcnJvciIsInNldFN0YXRpY09wdGlvbnMiLCJvcHRpb25zIiwicHJvdG90eXBlIiwiZG9jc09yaWdpbiIsInNob3dWZXJzaW9uIiwidmVyc2lvbiIsImNvbnN0cnVjdG9yIiwic2hvcnRNZXNzYWdlIiwiZGV0YWlscyIsImNhdXNlIiwibWVzc2FnZSIsImRvY3NQYXRoIiwiZG9jc0Jhc2VVcmwiLCJkb2NzIiwiQm9vbGVhbiIsIm1ldGFNZXNzYWdlcyIsInVuZGVmaW5lZCIsImZpbHRlciIsIngiLCJqb2luIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJ2YWx1ZSIsIndhbGsiLCJmbiIsImRlZmF1bHRTdGF0aWNPcHRpb25zIiwiZXJyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Hash.js":
/*!*******************************************!*\
  !*** ./node_modules/ox/_esm/core/Hash.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   keccak256: () => (/* binding */ keccak256),\n/* harmony export */   ripemd160: () => (/* binding */ ripemd160),\n/* harmony export */   sha256: () => (/* binding */ sha256),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_ripemd160__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/hashes/ripemd160 */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/ripemd160.js\");\n/* harmony import */ var _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/sha3 */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/sha3.js\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n\n\n\n\n\n/**\n * Calculates the [Keccak256](https://en.wikipedia.org/wiki/SHA-3) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n *\n * This function is a re-export of `keccak_256` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.keccak256('0xdeadbeef')\n * // @log: '0xd4fd4e189132273036449fc9e11198c739161b4c0116a9a2dccdfa1c492006f1'\n * ```\n *\n * @example\n * ### Calculate Hash of a String\n *\n * ```ts twoslash\n * import { Hash, Hex } from 'ox'\n *\n * Hash.keccak256(Hex.fromString('hello world'))\n * // @log: '0x3ea2f1d0abf3fc66cf29eebb70cbd4e7fe762ef8a09bcc06c8edf641230afec0'\n * ```\n *\n * @example\n * ### Configure Return Type\n *\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.keccak256('0xdeadbeef', { as: 'Bytes' })\n * // @log: Uint8Array [...]\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n * @param options - Options.\n * @returns Keccak256 hash.\n */ function keccak256(value, options = {}) {\n    const { as = typeof value === \"string\" ? \"Hex\" : \"Bytes\" } = options;\n    const bytes = (0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_0__.keccak_256)(_Bytes_js__WEBPACK_IMPORTED_MODULE_1__.from(value));\n    if (as === \"Bytes\") return bytes;\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(bytes);\n}\n/**\n * Calculates the [Ripemd160](https://en.wikipedia.org/wiki/RIPEMD) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n *\n * This function is a re-export of `ripemd160` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.ripemd160('0xdeadbeef')\n * // '0x226821c2f5423e11fe9af68bd285c249db2e4b5a'\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n * @param options - Options.\n * @returns Ripemd160 hash.\n */ function ripemd160(value, options = {}) {\n    const { as = typeof value === \"string\" ? \"Hex\" : \"Bytes\" } = options;\n    const bytes = (0,_noble_hashes_ripemd160__WEBPACK_IMPORTED_MODULE_3__.ripemd160)(_Bytes_js__WEBPACK_IMPORTED_MODULE_1__.from(value));\n    if (as === \"Bytes\") return bytes;\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(bytes);\n}\n/**\n * Calculates the [Sha256](https://en.wikipedia.org/wiki/SHA-256) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n *\n * This function is a re-export of `sha256` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.sha256('0xdeadbeef')\n * // '0x5f78c33274e43fa9de5659265c1d917e25c03722dcb0b8d27db8d5feaa813953'\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n * @param options - Options.\n * @returns Sha256 hash.\n */ function sha256(value, options = {}) {\n    const { as = typeof value === \"string\" ? \"Hex\" : \"Bytes\" } = options;\n    const bytes = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__.sha256)(_Bytes_js__WEBPACK_IMPORTED_MODULE_1__.from(value));\n    if (as === \"Bytes\") return bytes;\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(bytes);\n}\n/**\n * Checks if a string is a valid hash value.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.validate('0x')\n * // @log: false\n *\n * Hash.validate('0x3ea2f1d0abf3fc66cf29eebb70cbd4e7fe762ef8a09bcc06c8edf641230afec0')\n * // @log: true\n * ```\n *\n * @param value - Value to check.\n * @returns Whether the value is a valid hash.\n */ function validate(value) {\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.validate(value) && _Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(value) === 32;\n} //# sourceMappingURL=Hash.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0hhc2guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQXVFO0FBQ0o7QUFDTDtBQUMxQjtBQUNKO0FBQ2hDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FvQ0MsR0FDTSxTQUFTUSxVQUFVQyxLQUFLLEVBQUVDLFVBQVUsQ0FBQyxDQUFDO0lBQ3pDLE1BQU0sRUFBRUMsS0FBSyxPQUFPRixVQUFVLFdBQVcsUUFBUSxPQUFPLEVBQUUsR0FBR0M7SUFDN0QsTUFBTUUsUUFBUVQsOERBQWVBLENBQUNHLDJDQUFVLENBQUNHO0lBQ3pDLElBQUlFLE9BQU8sU0FDUCxPQUFPQztJQUNYLE9BQU9MLDhDQUFhLENBQUNLO0FBQ3pCO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FnQkMsR0FDTSxTQUFTWixVQUFVUyxLQUFLLEVBQUVDLFVBQVUsQ0FBQyxDQUFDO0lBQ3pDLE1BQU0sRUFBRUMsS0FBSyxPQUFPRixVQUFVLFdBQVcsUUFBUSxPQUFPLEVBQUUsR0FBR0M7SUFDN0QsTUFBTUUsUUFBUVgsa0VBQWVBLENBQUNLLDJDQUFVLENBQUNHO0lBQ3pDLElBQUlFLE9BQU8sU0FDUCxPQUFPQztJQUNYLE9BQU9MLDhDQUFhLENBQUNLO0FBQ3pCO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FnQkMsR0FDTSxTQUFTUixPQUFPSyxLQUFLLEVBQUVDLFVBQVUsQ0FBQyxDQUFDO0lBQ3RDLE1BQU0sRUFBRUMsS0FBSyxPQUFPRixVQUFVLFdBQVcsUUFBUSxPQUFPLEVBQUUsR0FBR0M7SUFDN0QsTUFBTUUsUUFBUVAsNERBQVlBLENBQUNDLDJDQUFVLENBQUNHO0lBQ3RDLElBQUlFLE9BQU8sU0FDUCxPQUFPQztJQUNYLE9BQU9MLDhDQUFhLENBQUNLO0FBQ3pCO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FnQkMsR0FDTSxTQUFTRyxTQUFTTixLQUFLO0lBQzFCLE9BQU9GLDZDQUFZLENBQUNFLFVBQVVGLHlDQUFRLENBQUNFLFdBQVc7QUFDdEQsRUFDQSxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGF3LXdvcmtzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9IYXNoLmpzPzQ5NDUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmlwZW1kMTYwIGFzIG5vYmxlX3JpcGVtZDE2MCB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvcmlwZW1kMTYwJztcbmltcG9ydCB7IGtlY2Nha18yNTYgYXMgbm9ibGVfa2VjY2FrMjU2IH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGEzJztcbmltcG9ydCB7IHNoYTI1NiBhcyBub2JsZV9zaGEyNTYgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3NoYTI1Nic7XG5pbXBvcnQgKiBhcyBCeXRlcyBmcm9tICcuL0J5dGVzLmpzJztcbmltcG9ydCAqIGFzIEhleCBmcm9tICcuL0hleC5qcyc7XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIFtLZWNjYWsyNTZdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NIQS0zKSBoYXNoIG9mIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSBvciB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyBhIHJlLWV4cG9ydCBvZiBga2VjY2FrXzI1NmAgZnJvbSBbYEBub2JsZS9oYXNoZXNgXShodHRwczovL2dpdGh1Yi5jb20vcGF1bG1pbGxyL25vYmxlLWhhc2hlcyksIGFuIGF1ZGl0ZWQgJiBtaW5pbWFsIEpTIGhhc2hpbmcgbGlicmFyeS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhhc2ggfSBmcm9tICdveCdcbiAqXG4gKiBIYXNoLmtlY2NhazI1NignMHhkZWFkYmVlZicpXG4gKiAvLyBAbG9nOiAnMHhkNGZkNGUxODkxMzIyNzMwMzY0NDlmYzllMTExOThjNzM5MTYxYjRjMDExNmE5YTJkY2NkZmExYzQ5MjAwNmYxJ1xuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBDYWxjdWxhdGUgSGFzaCBvZiBhIFN0cmluZ1xuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIYXNoLCBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIYXNoLmtlY2NhazI1NihIZXguZnJvbVN0cmluZygnaGVsbG8gd29ybGQnKSlcbiAqIC8vIEBsb2c6ICcweDNlYTJmMWQwYWJmM2ZjNjZjZjI5ZWViYjcwY2JkNGU3ZmU3NjJlZjhhMDliY2MwNmM4ZWRmNjQxMjMwYWZlYzAnXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIENvbmZpZ3VyZSBSZXR1cm4gVHlwZVxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIYXNoIH0gZnJvbSAnb3gnXG4gKlxuICogSGFzaC5rZWNjYWsyNTYoJzB4ZGVhZGJlZWYnLCB7IGFzOiAnQnl0ZXMnIH0pXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5IFsuLi5dXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IG9yIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIEtlY2NhazI1NiBoYXNoLlxuICovXG5leHBvcnQgZnVuY3Rpb24ga2VjY2FrMjU2KHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGFzID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/ICdIZXgnIDogJ0J5dGVzJyB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBieXRlcyA9IG5vYmxlX2tlY2NhazI1NihCeXRlcy5mcm9tKHZhbHVlKSk7XG4gICAgaWYgKGFzID09PSAnQnl0ZXMnKVxuICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgcmV0dXJuIEhleC5mcm9tQnl0ZXMoYnl0ZXMpO1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBbUmlwZW1kMTYwXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9SSVBFTUQpIGhhc2ggb2YgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IG9yIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGEgcmUtZXhwb3J0IG9mIGByaXBlbWQxNjBgIGZyb20gW2BAbm9ibGUvaGFzaGVzYF0oaHR0cHM6Ly9naXRodWIuY29tL3BhdWxtaWxsci9ub2JsZS1oYXNoZXMpLCBhbiBhdWRpdGVkICYgbWluaW1hbCBKUyBoYXNoaW5nIGxpYnJhcnkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIYXNoIH0gZnJvbSAnb3gnXG4gKlxuICogSGFzaC5yaXBlbWQxNjAoJzB4ZGVhZGJlZWYnKVxuICogLy8gJzB4MjI2ODIxYzJmNTQyM2UxMWZlOWFmNjhiZDI4NWMyNDlkYjJlNGI1YSdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIHtAbGluayBveCNCeXRlcy5CeXRlc30gb3Ige0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgUmlwZW1kMTYwIGhhc2guXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByaXBlbWQxNjAodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgYXMgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gJ0hleCcgOiAnQnl0ZXMnIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJ5dGVzID0gbm9ibGVfcmlwZW1kMTYwKEJ5dGVzLmZyb20odmFsdWUpKTtcbiAgICBpZiAoYXMgPT09ICdCeXRlcycpXG4gICAgICAgIHJldHVybiBieXRlcztcbiAgICByZXR1cm4gSGV4LmZyb21CeXRlcyhieXRlcyk7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIFtTaGEyNTZdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NIQS0yNTYpIGhhc2ggb2YgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IG9yIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGEgcmUtZXhwb3J0IG9mIGBzaGEyNTZgIGZyb20gW2BAbm9ibGUvaGFzaGVzYF0oaHR0cHM6Ly9naXRodWIuY29tL3BhdWxtaWxsci9ub2JsZS1oYXNoZXMpLCBhbiBhdWRpdGVkICYgbWluaW1hbCBKUyBoYXNoaW5nIGxpYnJhcnkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIYXNoIH0gZnJvbSAnb3gnXG4gKlxuICogSGFzaC5zaGEyNTYoJzB4ZGVhZGJlZWYnKVxuICogLy8gJzB4NWY3OGMzMzI3NGU0M2ZhOWRlNTY1OTI2NWMxZDkxN2UyNWMwMzcyMmRjYjBiOGQyN2RiOGQ1ZmVhYTgxMzk1MydcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIHtAbGluayBveCNCeXRlcy5CeXRlc30gb3Ige0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgU2hhMjU2IGhhc2guXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaGEyNTYodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgYXMgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gJ0hleCcgOiAnQnl0ZXMnIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJ5dGVzID0gbm9ibGVfc2hhMjU2KEJ5dGVzLmZyb20odmFsdWUpKTtcbiAgICBpZiAoYXMgPT09ICdCeXRlcycpXG4gICAgICAgIHJldHVybiBieXRlcztcbiAgICByZXR1cm4gSGV4LmZyb21CeXRlcyhieXRlcyk7XG59XG4vKipcbiAqIENoZWNrcyBpZiBhIHN0cmluZyBpcyBhIHZhbGlkIGhhc2ggdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIYXNoIH0gZnJvbSAnb3gnXG4gKlxuICogSGFzaC52YWxpZGF0ZSgnMHgnKVxuICogLy8gQGxvZzogZmFsc2VcbiAqXG4gKiBIYXNoLnZhbGlkYXRlKCcweDNlYTJmMWQwYWJmM2ZjNjZjZjI5ZWViYjcwY2JkNGU3ZmU3NjJlZjhhMDliY2MwNmM4ZWRmNjQxMjMwYWZlYzAnKVxuICogLy8gQGxvZzogdHJ1ZVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB2YWx1ZSBpcyBhIHZhbGlkIGhhc2guXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgIHJldHVybiBIZXgudmFsaWRhdGUodmFsdWUpICYmIEhleC5zaXplKHZhbHVlKSA9PT0gMzI7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1IYXNoLmpzLm1hcCJdLCJuYW1lcyI6WyJyaXBlbWQxNjAiLCJub2JsZV9yaXBlbWQxNjAiLCJrZWNjYWtfMjU2Iiwibm9ibGVfa2VjY2FrMjU2Iiwic2hhMjU2Iiwibm9ibGVfc2hhMjU2IiwiQnl0ZXMiLCJIZXgiLCJrZWNjYWsyNTYiLCJ2YWx1ZSIsIm9wdGlvbnMiLCJhcyIsImJ5dGVzIiwiZnJvbSIsImZyb21CeXRlcyIsInZhbGlkYXRlIiwic2l6ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Hash.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Hex.js":
/*!******************************************!*\
  !*** ./node_modules/ox/_esm/core/Hex.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IntegerOutOfRangeError: () => (/* binding */ IntegerOutOfRangeError),\n/* harmony export */   InvalidHexBooleanError: () => (/* binding */ InvalidHexBooleanError),\n/* harmony export */   InvalidHexTypeError: () => (/* binding */ InvalidHexTypeError),\n/* harmony export */   InvalidHexValueError: () => (/* binding */ InvalidHexValueError),\n/* harmony export */   InvalidLengthError: () => (/* binding */ InvalidLengthError),\n/* harmony export */   SizeExceedsPaddingSizeError: () => (/* binding */ SizeExceedsPaddingSizeError),\n/* harmony export */   SizeOverflowError: () => (/* binding */ SizeOverflowError),\n/* harmony export */   SliceOffsetOutOfBoundsError: () => (/* binding */ SliceOffsetOutOfBoundsError),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   concat: () => (/* binding */ concat),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromBoolean: () => (/* binding */ fromBoolean),\n/* harmony export */   fromBytes: () => (/* binding */ fromBytes),\n/* harmony export */   fromNumber: () => (/* binding */ fromNumber),\n/* harmony export */   fromString: () => (/* binding */ fromString),\n/* harmony export */   isEqual: () => (/* binding */ isEqual),\n/* harmony export */   padLeft: () => (/* binding */ padLeft),\n/* harmony export */   padRight: () => (/* binding */ padRight),\n/* harmony export */   random: () => (/* binding */ random),\n/* harmony export */   size: () => (/* binding */ size),\n/* harmony export */   slice: () => (/* binding */ slice),\n/* harmony export */   toBigInt: () => (/* binding */ toBigInt),\n/* harmony export */   toBoolean: () => (/* binding */ toBoolean),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   toNumber: () => (/* binding */ toNumber),\n/* harmony export */   toString: () => (/* binding */ toString),\n/* harmony export */   trimLeft: () => (/* binding */ trimLeft),\n/* harmony export */   trimRight: () => (/* binding */ trimRight),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/curves/abstract/utils */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _internal_bytes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/bytes.js\");\n/* harmony import */ var _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/hex.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/hex.js\");\n/* harmony import */ var _Json_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Json.js */ \"(ssr)/./node_modules/ox/_esm/core/Json.js\");\n\n\n\n\n\n\nconst encoder = /*#__PURE__*/ new TextEncoder();\nconst hexes = /*#__PURE__*/ Array.from({\n    length: 256\n}, (_v, i)=>i.toString(16).padStart(2, \"0\"));\n/**\n * Asserts if the given value is {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert('abc')\n * // @error: InvalidHexValueTypeError:\n * // @error: Value `\"abc\"` of type `string` is an invalid hex type.\n * // @error: Hex types must be represented as `\"0x\\${string}\"`.\n * ```\n *\n * @param value - The value to assert.\n * @param options - Options.\n */ function assert(value, options = {}) {\n    const { strict = false } = options;\n    if (!value) throw new InvalidHexTypeError(value);\n    if (typeof value !== \"string\") throw new InvalidHexTypeError(value);\n    if (strict) {\n        if (!/^0x[0-9a-fA-F]*$/.test(value)) throw new InvalidHexValueError(value);\n    }\n    if (!value.startsWith(\"0x\")) throw new InvalidHexValueError(value);\n}\n/**\n * Concatenates two or more {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.concat('0x123', '0x456')\n * // @log: '0x123456'\n * ```\n *\n * @param values - The {@link ox#Hex.Hex} values to concatenate.\n * @returns The concatenated {@link ox#Hex.Hex} value.\n */ function concat(...values) {\n    return `0x${values.reduce((acc, x)=>acc + x.replace(\"0x\", \"\"), \"\")}`;\n}\n/**\n * Instantiates a {@link ox#Hex.Hex} value from a hex string or {@link ox#Bytes.Bytes} value.\n *\n * :::tip\n *\n * To instantiate from a **Boolean**, **String**, or **Number**, use one of the following:\n *\n * - `Hex.fromBoolean`\n *\n * - `Hex.fromString`\n *\n * - `Hex.fromNumber`\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.from('0x48656c6c6f20576f726c6421')\n * // @log: '0x48656c6c6f20576f726c6421'\n *\n * Hex.from(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} value to encode.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */ function from(value) {\n    if (value instanceof Uint8Array) return fromBytes(value);\n    if (Array.isArray(value)) return fromBytes(new Uint8Array(value));\n    return value;\n}\n/**\n * Encodes a boolean into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromBoolean(true)\n * // @log: '0x1'\n *\n * Hex.fromBoolean(false)\n * // @log: '0x0'\n *\n * Hex.fromBoolean(true, { size: 32 })\n * // @log: '0x0000000000000000000000000000000000000000000000000000000000000001'\n * ```\n *\n * @param value - The boolean value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */ function fromBoolean(value, options = {}) {\n    const hex = `0x${Number(value)}`;\n    if (typeof options.size === \"number\") {\n        _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(hex, options.size);\n        return padLeft(hex, options.size);\n    }\n    return hex;\n}\n/**\n * Encodes a {@link ox#Bytes.Bytes} value into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.fromBytes(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */ function fromBytes(value, options = {}) {\n    let string = \"\";\n    for(let i = 0; i < value.length; i++)string += hexes[value[i]];\n    const hex = `0x${string}`;\n    if (typeof options.size === \"number\") {\n        _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(hex, options.size);\n        return padRight(hex, options.size);\n    }\n    return hex;\n}\n/**\n * Encodes a number or bigint into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromNumber(420)\n * // @log: '0x1a4'\n *\n * Hex.fromNumber(420, { size: 32 })\n * // @log: '0x00000000000000000000000000000000000000000000000000000000000001a4'\n * ```\n *\n * @param value - The number or bigint value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */ function fromNumber(value, options = {}) {\n    const { signed, size } = options;\n    const value_ = BigInt(value);\n    let maxValue;\n    if (size) {\n        if (signed) maxValue = (1n << BigInt(size) * 8n - 1n) - 1n;\n        else maxValue = 2n ** (BigInt(size) * 8n) - 1n;\n    } else if (typeof value === \"number\") {\n        maxValue = BigInt(Number.MAX_SAFE_INTEGER);\n    }\n    const minValue = typeof maxValue === \"bigint\" && signed ? -maxValue - 1n : 0;\n    if (maxValue && value_ > maxValue || value_ < minValue) {\n        const suffix = typeof value === \"bigint\" ? \"n\" : \"\";\n        throw new IntegerOutOfRangeError({\n            max: maxValue ? `${maxValue}${suffix}` : undefined,\n            min: `${minValue}${suffix}`,\n            signed,\n            size,\n            value: `${value}${suffix}`\n        });\n    }\n    const stringValue = (signed && value_ < 0 ? BigInt.asUintN(size * 8, BigInt(value_)) : value_).toString(16);\n    const hex = `0x${stringValue}`;\n    if (size) return padLeft(hex, size);\n    return hex;\n}\n/**\n * Encodes a string into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n * Hex.fromString('Hello World!')\n * // '0x48656c6c6f20576f726c6421'\n *\n * Hex.fromString('Hello World!', { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n * ```\n *\n * @param value - The string value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */ function fromString(value, options = {}) {\n    return fromBytes(encoder.encode(value), options);\n}\n/**\n * Checks if two {@link ox#Hex.Hex} values are equal.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.isEqual('0xdeadbeef', '0xdeadbeef')\n * // @log: true\n *\n * Hex.isEqual('0xda', '0xba')\n * // @log: false\n * ```\n *\n * @param hexA - The first {@link ox#Hex.Hex} value.\n * @param hexB - The second {@link ox#Hex.Hex} value.\n * @returns `true` if the two {@link ox#Hex.Hex} values are equal, `false` otherwise.\n */ function isEqual(hexA, hexB) {\n    return (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_1__.equalBytes)(_Bytes_js__WEBPACK_IMPORTED_MODULE_2__.fromHex(hexA), _Bytes_js__WEBPACK_IMPORTED_MODULE_2__.fromHex(hexB));\n}\n/**\n * Pads a {@link ox#Hex.Hex} value to the left with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.padLeft('0x1234', 4)\n * // @log: '0x00001234'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to pad.\n * @param size - The size (in bytes) of the output hex value.\n * @returns The padded {@link ox#Hex.Hex} value.\n */ function padLeft(value, size) {\n    return _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.pad(value, {\n        dir: \"left\",\n        size\n    });\n}\n/**\n * Pads a {@link ox#Hex.Hex} value to the right with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts\n * import { Hex } from 'ox'\n *\n * Hex.padRight('0x1234', 4)\n * // @log: '0x12340000'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to pad.\n * @param size - The size (in bytes) of the output hex value.\n * @returns The padded {@link ox#Hex.Hex} value.\n */ function padRight(value, size) {\n    return _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.pad(value, {\n        dir: \"right\",\n        size\n    });\n}\n/**\n * Generates a random {@link ox#Hex.Hex} value of the specified length.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * const hex = Hex.random(32)\n * // @log: '0x...'\n * ```\n *\n * @returns Random {@link ox#Hex.Hex} value.\n */ function random(length) {\n    return fromBytes(_Bytes_js__WEBPACK_IMPORTED_MODULE_2__.random(length));\n}\n/**\n * Returns a section of a {@link ox#Bytes.Bytes} value given a start/end bytes offset.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.slice('0x0123456789', 1, 4)\n * // @log: '0x234567'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to slice.\n * @param start - The start offset (in bytes).\n * @param end - The end offset (in bytes).\n * @param options - Options.\n * @returns The sliced {@link ox#Hex.Hex} value.\n */ function slice(value, start, end, options = {}) {\n    const { strict } = options;\n    _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.assertStartOffset(value, start);\n    const value_ = `0x${value.replace(\"0x\", \"\").slice((start ?? 0) * 2, (end ?? value.length) * 2)}`;\n    if (strict) _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.assertEndOffset(value_, start, end);\n    return value_;\n}\n/**\n * Retrieves the size of a {@link ox#Hex.Hex} value (in bytes).\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.size('0xdeadbeef')\n * // @log: 4\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to get the size of.\n * @returns The size of the {@link ox#Hex.Hex} value (in bytes).\n */ function size(value) {\n    return Math.ceil((value.length - 2) / 2);\n}\n/**\n * Trims leading zeros from a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.trimLeft('0x00000000deadbeef')\n * // @log: '0xdeadbeef'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to trim.\n * @returns The trimmed {@link ox#Hex.Hex} value.\n */ function trimLeft(value) {\n    return _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.trim(value, {\n        dir: \"left\"\n    });\n}\n/**\n * Trims trailing zeros from a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.trimRight('0xdeadbeef00000000')\n * // @log: '0xdeadbeef'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to trim.\n * @returns The trimmed {@link ox#Hex.Hex} value.\n */ function trimRight(value) {\n    return _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.trim(value, {\n        dir: \"right\"\n    });\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a BigInt.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBigInt('0x1a4')\n * // @log: 420n\n *\n * Hex.toBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // @log: 420n\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded BigInt.\n */ function toBigInt(hex, options = {}) {\n    const { signed } = options;\n    if (options.size) _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(hex, options.size);\n    const value = BigInt(hex);\n    if (!signed) return value;\n    const size = (hex.length - 2) / 2;\n    const max_unsigned = (1n << BigInt(size) * 8n) - 1n;\n    const max_signed = max_unsigned >> 1n;\n    if (value <= max_signed) return value;\n    return value - max_unsigned - 1n;\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a boolean.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBoolean('0x01')\n * // @log: true\n *\n * Hex.toBoolean('0x0000000000000000000000000000000000000000000000000000000000000001', { size: 32 })\n * // @log: true\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded boolean.\n */ function toBoolean(hex, options = {}) {\n    if (options.size) _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(hex, options.size);\n    const hex_ = trimLeft(hex);\n    if (hex_ === \"0x\") return false;\n    if (hex_ === \"0x1\") return true;\n    throw new InvalidHexBooleanError(hex);\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * const data = Hex.toBytes('0x48656c6c6f20776f726c6421')\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded {@link ox#Bytes.Bytes}.\n */ function toBytes(hex, options = {}) {\n    return _Bytes_js__WEBPACK_IMPORTED_MODULE_2__.fromHex(hex, options);\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a number.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toNumber('0x1a4')\n * // @log: 420\n *\n * Hex.toNumber('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // @log: 420\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded number.\n */ function toNumber(hex, options = {}) {\n    const { signed, size } = options;\n    if (!signed && !size) return Number(hex);\n    return Number(toBigInt(hex, options));\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a string.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toString('0x48656c6c6f20576f726c6421')\n * // @log: 'Hello world!'\n *\n * Hex.toString('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {\n *  size: 32,\n * })\n * // @log: 'Hello world'\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded string.\n */ function toString(hex, options = {}) {\n    const { size } = options;\n    let bytes = _Bytes_js__WEBPACK_IMPORTED_MODULE_2__.fromHex(hex);\n    if (size) {\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_3__.assertSize(bytes, size);\n        bytes = _Bytes_js__WEBPACK_IMPORTED_MODULE_2__.trimRight(bytes);\n    }\n    return new TextDecoder().decode(bytes);\n}\n/**\n * Checks if the given value is {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.validate('0xdeadbeef')\n * // @log: true\n *\n * Hex.validate(Bytes.from([1, 2, 3]))\n * // @log: false\n * ```\n *\n * @param value - The value to check.\n * @param options - Options.\n * @returns `true` if the value is a {@link ox#Hex.Hex}, `false` otherwise.\n */ function validate(value, options = {}) {\n    const { strict = false } = options;\n    try {\n        assert(value, {\n            strict\n        });\n        return true;\n    } catch  {\n        return false;\n    }\n}\n/**\n * Thrown when the provided integer is out of range, and cannot be represented as a hex value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromNumber(420182738912731283712937129)\n * // @error: Hex.IntegerOutOfRangeError: Number \\`4.2018273891273126e+26\\` is not in safe unsigned integer range (`0` to `9007199254740991`)\n * ```\n */ class IntegerOutOfRangeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ max, min, signed, size, value }){\n        super(`Number \\`${value}\\` is not in safe${size ? ` ${size * 8}-bit` : \"\"}${signed ? \" signed\" : \" unsigned\"} integer range ${max ? `(\\`${min}\\` to \\`${max}\\`)` : `(above \\`${min}\\`)`}`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Hex.IntegerOutOfRangeError\"\n        });\n    }\n}\n/**\n * Thrown when the provided hex value cannot be represented as a boolean.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBoolean('0xa')\n * // @error: Hex.InvalidHexBooleanError: Hex value `\"0xa\"` is not a valid boolean.\n * // @error: The hex value must be `\"0x0\"` (false) or `\"0x1\"` (true).\n * ```\n */ class InvalidHexBooleanError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor(hex){\n        super(`Hex value \\`\"${hex}\"\\` is not a valid boolean.`, {\n            metaMessages: [\n                'The hex value must be `\"0x0\"` (false) or `\"0x1\"` (true).'\n            ]\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Hex.InvalidHexBooleanError\"\n        });\n    }\n}\n/**\n * Thrown when the provided value is not a valid hex type.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert(1)\n * // @error: Hex.InvalidHexTypeError: Value `1` of type `number` is an invalid hex type.\n * ```\n */ class InvalidHexTypeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor(value){\n        super(`Value \\`${typeof value === \"object\" ? _Json_js__WEBPACK_IMPORTED_MODULE_5__.stringify(value) : value}\\` of type \\`${typeof value}\\` is an invalid hex type.`, {\n            metaMessages: [\n                'Hex types must be represented as `\"0x${string}\"`.'\n            ]\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Hex.InvalidHexTypeError\"\n        });\n    }\n}\n/**\n * Thrown when the provided hex value is invalid.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert('0x0123456789abcdefg')\n * // @error: Hex.InvalidHexValueError: Value `0x0123456789abcdefg` is an invalid hex value.\n * // @error: Hex values must start with `\"0x\"` and contain only hexadecimal characters (0-9, a-f, A-F).\n * ```\n */ class InvalidHexValueError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor(value){\n        super(`Value \\`${value}\\` is an invalid hex value.`, {\n            metaMessages: [\n                'Hex values must start with `\"0x\"` and contain only hexadecimal characters (0-9, a-f, A-F).'\n            ]\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Hex.InvalidHexValueError\"\n        });\n    }\n}\n/**\n * Thrown when the provided hex value is an odd length.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.fromHex('0xabcde')\n * // @error: Hex.InvalidLengthError: Hex value `\"0xabcde\"` is an odd length (5 nibbles).\n * ```\n */ class InvalidLengthError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor(value){\n        super(`Hex value \\`\"${value}\"\\` is an odd length (${value.length - 2} nibbles).`, {\n            metaMessages: [\n                \"It must be an even length.\"\n            ]\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Hex.InvalidLengthError\"\n        });\n    }\n}\n/**\n * Thrown when the size of the value exceeds the expected max size.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromString('Hello World!', { size: 8 })\n * // @error: Hex.SizeOverflowError: Size cannot exceed `8` bytes. Given size: `12` bytes.\n * ```\n */ class SizeOverflowError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ givenSize, maxSize }){\n        super(`Size cannot exceed \\`${maxSize}\\` bytes. Given size: \\`${givenSize}\\` bytes.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Hex.SizeOverflowError\"\n        });\n    }\n}\n/**\n * Thrown when the slice offset exceeds the bounds of the value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.slice('0x0123456789', 6)\n * // @error: Hex.SliceOffsetOutOfBoundsError: Slice starting at offset `6` is out-of-bounds (size: `5`).\n * ```\n */ class SliceOffsetOutOfBoundsError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ offset, position, size }){\n        super(`Slice ${position === \"start\" ? \"starting\" : \"ending\"} at offset \\`${offset}\\` is out-of-bounds (size: \\`${size}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Hex.SliceOffsetOutOfBoundsError\"\n        });\n    }\n}\n/**\n * Thrown when the size of the value exceeds the pad size.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.padLeft('0x1a4e12a45a21323123aaa87a897a897a898a6567a578a867a98778a667a85a875a87a6a787a65a675a6a9', 32)\n * // @error: Hex.SizeExceedsPaddingSizeError: Hex size (`43`) exceeds padding size (`32`).\n * ```\n */ class SizeExceedsPaddingSizeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ size, targetSize, type }){\n        super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (\\`${size}\\`) exceeds padding size (\\`${targetSize}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Hex.SizeExceedsPaddingSizeError\"\n        });\n    }\n} //# sourceMappingURL=Hex.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0hleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEwRDtBQUN0QjtBQUNFO0FBQ2dCO0FBQ1I7QUFDWjtBQUNsQyxNQUFNTSxVQUFVLFdBQVcsR0FBRyxJQUFJQztBQUNsQyxNQUFNQyxRQUFRLFdBQVcsR0FBR0MsTUFBTUMsSUFBSSxDQUFDO0lBQUVDLFFBQVE7QUFBSSxHQUFHLENBQUNDLElBQUlDLElBQU1BLEVBQUVDLFFBQVEsQ0FBQyxJQUFJQyxRQUFRLENBQUMsR0FBRztBQUM5Rjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDTSxTQUFTQyxPQUFPQyxLQUFLLEVBQUVDLFVBQVUsQ0FBQyxDQUFDO0lBQ3RDLE1BQU0sRUFBRUMsU0FBUyxLQUFLLEVBQUUsR0FBR0Q7SUFDM0IsSUFBSSxDQUFDRCxPQUNELE1BQU0sSUFBSUcsb0JBQW9CSDtJQUNsQyxJQUFJLE9BQU9BLFVBQVUsVUFDakIsTUFBTSxJQUFJRyxvQkFBb0JIO0lBQ2xDLElBQUlFLFFBQVE7UUFDUixJQUFJLENBQUMsbUJBQW1CRSxJQUFJLENBQUNKLFFBQ3pCLE1BQU0sSUFBSUsscUJBQXFCTDtJQUN2QztJQUNBLElBQUksQ0FBQ0EsTUFBTU0sVUFBVSxDQUFDLE9BQ2xCLE1BQU0sSUFBSUQscUJBQXFCTDtBQUN2QztBQUNBOzs7Ozs7Ozs7Ozs7O0NBYUMsR0FDTSxTQUFTTyxPQUFPLEdBQUdDLE1BQU07SUFDNUIsT0FBTyxDQUFDLEVBQUUsRUFBRUEsT0FBT0MsTUFBTSxDQUFDLENBQUNDLEtBQUtDLElBQU1ELE1BQU1DLEVBQUVDLE9BQU8sQ0FBQyxNQUFNLEtBQUssSUFBSSxDQUFDO0FBQzFFO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0E0QkMsR0FDTSxTQUFTbkIsS0FBS08sS0FBSztJQUN0QixJQUFJQSxpQkFBaUJhLFlBQ2pCLE9BQU9DLFVBQVVkO0lBQ3JC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LGNBQWMsQ0FBQyxJQUFJLEVBQUUsUUFBUTtZQUNoQ0MsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVjNFLE9BQU87UUFDWDtJQUNKO0FBQ0o7QUFDQTs7Ozs7Ozs7OztDQVVDLEdBQ00sTUFBTXFGLG9DQUFvQ3BHLGlEQUFnQjtJQUM3RHFGLFlBQVksRUFBRW5ELElBQUksRUFBRW1FLFVBQVUsRUFBRUMsSUFBSSxFQUFHLENBQUU7UUFDckMsS0FBSyxDQUFDLENBQUMsRUFBRUEsS0FBS0MsTUFBTSxDQUFDLEdBQUdDLFdBQVcsR0FBRyxFQUFFRixLQUNuQ3hDLEtBQUssQ0FBQyxHQUNOMkMsV0FBVyxHQUFHLFNBQVMsRUFBRXZFLEtBQUssNEJBQTRCLEVBQUVtRSxXQUFXLElBQUksQ0FBQztRQUNqRmYsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxRQUFRO1lBQ2hDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWM0UsT0FBTztRQUNYO0lBQ0o7QUFDSixFQUNBLCtCQUErQiIsInNvdXJjZXMiOlsid2VicGFjazovL2NsYXctd29ya3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0hleC5qcz8wNDcyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGVxdWFsQnl0ZXMgfSBmcm9tICdAbm9ibGUvY3VydmVzL2Fic3RyYWN0L3V0aWxzJztcbmltcG9ydCAqIGFzIEJ5dGVzIGZyb20gJy4vQnl0ZXMuanMnO1xuaW1wb3J0ICogYXMgRXJyb3JzIGZyb20gJy4vRXJyb3JzLmpzJztcbmltcG9ydCAqIGFzIGludGVybmFsX2J5dGVzIGZyb20gJy4vaW50ZXJuYWwvYnl0ZXMuanMnO1xuaW1wb3J0ICogYXMgaW50ZXJuYWwgZnJvbSAnLi9pbnRlcm5hbC9oZXguanMnO1xuaW1wb3J0ICogYXMgSnNvbiBmcm9tICcuL0pzb24uanMnO1xuY29uc3QgZW5jb2RlciA9IC8qI19fUFVSRV9fKi8gbmV3IFRleHRFbmNvZGVyKCk7XG5jb25zdCBoZXhlcyA9IC8qI19fUFVSRV9fKi8gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sIChfdiwgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4vKipcbiAqIEFzc2VydHMgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIHtAbGluayBveCNIZXguSGV4fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC5hc3NlcnQoJ2FiYycpXG4gKiAvLyBAZXJyb3I6IEludmFsaWRIZXhWYWx1ZVR5cGVFcnJvcjpcbiAqIC8vIEBlcnJvcjogVmFsdWUgYFwiYWJjXCJgIG9mIHR5cGUgYHN0cmluZ2AgaXMgYW4gaW52YWxpZCBoZXggdHlwZS5cbiAqIC8vIEBlcnJvcjogSGV4IHR5cGVzIG11c3QgYmUgcmVwcmVzZW50ZWQgYXMgYFwiMHhcXCR7c3RyaW5nfVwiYC5cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBhc3NlcnQuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnQodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc3RyaWN0ID0gZmFsc2UgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCF2YWx1ZSlcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRIZXhUeXBlRXJyb3IodmFsdWUpO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEhleFR5cGVFcnJvcih2YWx1ZSk7XG4gICAgaWYgKHN0cmljdCkge1xuICAgICAgICBpZiAoIS9eMHhbMC05YS1mQS1GXSokLy50ZXN0KHZhbHVlKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkSGV4VmFsdWVFcnJvcih2YWx1ZSk7XG4gICAgfVxuICAgIGlmICghdmFsdWUuc3RhcnRzV2l0aCgnMHgnKSlcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRIZXhWYWx1ZUVycm9yKHZhbHVlKTtcbn1cbi8qKlxuICogQ29uY2F0ZW5hdGVzIHR3byBvciBtb3JlIHtAbGluayBveCNIZXguSGV4fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC5jb25jYXQoJzB4MTIzJywgJzB4NDU2JylcbiAqIC8vIEBsb2c6ICcweDEyMzQ1NidcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlcyB0byBjb25jYXRlbmF0ZS5cbiAqIEByZXR1cm5zIFRoZSBjb25jYXRlbmF0ZWQge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0KC4uLnZhbHVlcykge1xuICAgIHJldHVybiBgMHgke3ZhbHVlcy5yZWR1Y2UoKGFjYywgeCkgPT4gYWNjICsgeC5yZXBsYWNlKCcweCcsICcnKSwgJycpfWA7XG59XG4vKipcbiAqIEluc3RhbnRpYXRlcyBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSBmcm9tIGEgaGV4IHN0cmluZyBvciB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlLlxuICpcbiAqIDo6OnRpcFxuICpcbiAqIFRvIGluc3RhbnRpYXRlIGZyb20gYSAqKkJvb2xlYW4qKiwgKipTdHJpbmcqKiwgb3IgKipOdW1iZXIqKiwgdXNlIG9uZSBvZiB0aGUgZm9sbG93aW5nOlxuICpcbiAqIC0gYEhleC5mcm9tQm9vbGVhbmBcbiAqXG4gKiAtIGBIZXguZnJvbVN0cmluZ2BcbiAqXG4gKiAtIGBIZXguZnJvbU51bWJlcmBcbiAqXG4gKiA6OjpcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzLCBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXguZnJvbSgnMHg0ODY1NmM2YzZmMjA1NzZmNzI2YzY0MjEnKVxuICogLy8gQGxvZzogJzB4NDg2NTZjNmM2ZjIwNTc2ZjcyNmM2NDIxJ1xuICpcbiAqIEhleC5mcm9tKEJ5dGVzLmZyb20oWzcyLCAxMDEsIDEwOCwgMTA4LCAxMTEsIDMyLCA4NywgMTExLCAxMTQsIDEwOCwgMTAwLCAzM10pKVxuICogLy8gQGxvZzogJzB4NDg2NTZjNmM2ZjIwNTc2ZjcyNmM2NDIxJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUgdG8gZW5jb2RlLlxuICogQHJldHVybnMgVGhlIGVuY29kZWQge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpXG4gICAgICAgIHJldHVybiBmcm9tQnl0ZXModmFsdWUpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIGZyb21CeXRlcyhuZXcgVWludDhBcnJheSh2YWx1ZSkpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8qKlxuICogRW5jb2RlcyBhIGJvb2xlYW4gaW50byBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC5mcm9tQm9vbGVhbih0cnVlKVxuICogLy8gQGxvZzogJzB4MSdcbiAqXG4gKiBIZXguZnJvbUJvb2xlYW4oZmFsc2UpXG4gKiAvLyBAbG9nOiAnMHgwJ1xuICpcbiAqIEhleC5mcm9tQm9vbGVhbih0cnVlLCB7IHNpemU6IDMyIH0pXG4gKiAvLyBAbG9nOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGJvb2xlYW4gdmFsdWUgdG8gZW5jb2RlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgVGhlIGVuY29kZWQge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUJvb2xlYW4odmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGhleCA9IGAweCR7TnVtYmVyKHZhbHVlKX1gO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5zaXplID09PSAnbnVtYmVyJykge1xuICAgICAgICBpbnRlcm5hbC5hc3NlcnRTaXplKGhleCwgb3B0aW9ucy5zaXplKTtcbiAgICAgICAgcmV0dXJuIHBhZExlZnQoaGV4LCBvcHRpb25zLnNpemUpO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuLyoqXG4gKiBFbmNvZGVzIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZSBpbnRvIGEge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMsIEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC5mcm9tQnl0ZXMoQnl0ZXMuZnJvbShbNzIsIDEwMSwgMTA4LCAxMDgsIDExMSwgMzIsIDg3LCAxMTEsIDExNCwgMTA4LCAxMDAsIDMzXSkpXG4gKiAvLyBAbG9nOiAnMHg0ODY1NmM2YzZmMjA1NzZmNzI2YzY0MjEnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZSB0byBlbmNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgZW5jb2RlZCB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tQnl0ZXModmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCBzdHJpbmcgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKVxuICAgICAgICBzdHJpbmcgKz0gaGV4ZXNbdmFsdWVbaV1dO1xuICAgIGNvbnN0IGhleCA9IGAweCR7c3RyaW5nfWA7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnNpemUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGludGVybmFsLmFzc2VydFNpemUoaGV4LCBvcHRpb25zLnNpemUpO1xuICAgICAgICByZXR1cm4gcGFkUmlnaHQoaGV4LCBvcHRpb25zLnNpemUpO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuLyoqXG4gKiBFbmNvZGVzIGEgbnVtYmVyIG9yIGJpZ2ludCBpbnRvIGEge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LmZyb21OdW1iZXIoNDIwKVxuICogLy8gQGxvZzogJzB4MWE0J1xuICpcbiAqIEhleC5mcm9tTnVtYmVyKDQyMCwgeyBzaXplOiAzMiB9KVxuICogLy8gQGxvZzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDFhNCdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBudW1iZXIgb3IgYmlnaW50IHZhbHVlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBlbmNvZGVkIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21OdW1iZXIodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2lnbmVkLCBzaXplIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHZhbHVlXyA9IEJpZ0ludCh2YWx1ZSk7XG4gICAgbGV0IG1heFZhbHVlO1xuICAgIGlmIChzaXplKSB7XG4gICAgICAgIGlmIChzaWduZWQpXG4gICAgICAgICAgICBtYXhWYWx1ZSA9ICgxbiA8PCAoQmlnSW50KHNpemUpICogOG4gLSAxbikpIC0gMW47XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG1heFZhbHVlID0gMm4gKiogKEJpZ0ludChzaXplKSAqIDhuKSAtIDFuO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIG1heFZhbHVlID0gQmlnSW50KE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKTtcbiAgICB9XG4gICAgY29uc3QgbWluVmFsdWUgPSB0eXBlb2YgbWF4VmFsdWUgPT09ICdiaWdpbnQnICYmIHNpZ25lZCA/IC1tYXhWYWx1ZSAtIDFuIDogMDtcbiAgICBpZiAoKG1heFZhbHVlICYmIHZhbHVlXyA+IG1heFZhbHVlKSB8fCB2YWx1ZV8gPCBtaW5WYWx1ZSkge1xuICAgICAgICBjb25zdCBzdWZmaXggPSB0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnID8gJ24nIDogJyc7XG4gICAgICAgIHRocm93IG5ldyBJbnRlZ2VyT3V0T2ZSYW5nZUVycm9yKHtcbiAgICAgICAgICAgIG1heDogbWF4VmFsdWUgPyBgJHttYXhWYWx1ZX0ke3N1ZmZpeH1gIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbWluOiBgJHttaW5WYWx1ZX0ke3N1ZmZpeH1gLFxuICAgICAgICAgICAgc2lnbmVkLFxuICAgICAgICAgICAgc2l6ZSxcbiAgICAgICAgICAgIHZhbHVlOiBgJHt2YWx1ZX0ke3N1ZmZpeH1gLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3Qgc3RyaW5nVmFsdWUgPSAoc2lnbmVkICYmIHZhbHVlXyA8IDAgPyBCaWdJbnQuYXNVaW50TihzaXplICogOCwgQmlnSW50KHZhbHVlXykpIDogdmFsdWVfKS50b1N0cmluZygxNik7XG4gICAgY29uc3QgaGV4ID0gYDB4JHtzdHJpbmdWYWx1ZX1gO1xuICAgIGlmIChzaXplKVxuICAgICAgICByZXR1cm4gcGFkTGVmdChoZXgsIHNpemUpO1xuICAgIHJldHVybiBoZXg7XG59XG4vKipcbiAqIEVuY29kZXMgYSBzdHJpbmcgaW50byBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICogSGV4LmZyb21TdHJpbmcoJ0hlbGxvIFdvcmxkIScpXG4gKiAvLyAnMHg0ODY1NmM2YzZmMjA1NzZmNzI2YzY0MjEnXG4gKlxuICogSGV4LmZyb21TdHJpbmcoJ0hlbGxvIFdvcmxkIScsIHsgc2l6ZTogMzIgfSlcbiAqIC8vICcweDQ4NjU2YzZjNmYyMDU3NmY3MjZjNjQyMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgc3RyaW5nIHZhbHVlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBlbmNvZGVkIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21TdHJpbmcodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBmcm9tQnl0ZXMoZW5jb2Rlci5lbmNvZGUodmFsdWUpLCBvcHRpb25zKTtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIHR3byB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWVzIGFyZSBlcXVhbC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC5pc0VxdWFsKCcweGRlYWRiZWVmJywgJzB4ZGVhZGJlZWYnKVxuICogLy8gQGxvZzogdHJ1ZVxuICpcbiAqIEhleC5pc0VxdWFsKCcweGRhJywgJzB4YmEnKVxuICogLy8gQGxvZzogZmFsc2VcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBoZXhBIC0gVGhlIGZpcnN0IHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqIEBwYXJhbSBoZXhCIC0gVGhlIHNlY29uZCB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHR3byB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWVzIGFyZSBlcXVhbCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0VxdWFsKGhleEEsIGhleEIpIHtcbiAgICByZXR1cm4gZXF1YWxCeXRlcyhCeXRlcy5mcm9tSGV4KGhleEEpLCBCeXRlcy5mcm9tSGV4KGhleEIpKTtcbn1cbi8qKlxuICogUGFkcyBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSB0byB0aGUgbGVmdCB3aXRoIHplcm8gYnl0ZXMgdW50aWwgaXQgcmVhY2hlcyB0aGUgZ2l2ZW4gYHNpemVgIChkZWZhdWx0OiAzMiBieXRlcykuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXgucGFkTGVmdCgnMHgxMjM0JywgNClcbiAqIC8vIEBsb2c6ICcweDAwMDAxMjM0J1xuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSB0byBwYWQuXG4gKiBAcGFyYW0gc2l6ZSAtIFRoZSBzaXplIChpbiBieXRlcykgb2YgdGhlIG91dHB1dCBoZXggdmFsdWUuXG4gKiBAcmV0dXJucyBUaGUgcGFkZGVkIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhZExlZnQodmFsdWUsIHNpemUpIHtcbiAgICByZXR1cm4gaW50ZXJuYWwucGFkKHZhbHVlLCB7IGRpcjogJ2xlZnQnLCBzaXplIH0pO1xufVxuLyoqXG4gKiBQYWRzIGEge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIHRoZSByaWdodCB3aXRoIHplcm8gYnl0ZXMgdW50aWwgaXQgcmVhY2hlcyB0aGUgZ2l2ZW4gYHNpemVgIChkZWZhdWx0OiAzMiBieXRlcykuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXgucGFkUmlnaHQoJzB4MTIzNCcsIDQpXG4gKiAvLyBAbG9nOiAnMHgxMjM0MDAwMCdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgdG8gcGFkLlxuICogQHBhcmFtIHNpemUgLSBUaGUgc2l6ZSAoaW4gYnl0ZXMpIG9mIHRoZSBvdXRwdXQgaGV4IHZhbHVlLlxuICogQHJldHVybnMgVGhlIHBhZGRlZCB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYWRSaWdodCh2YWx1ZSwgc2l6ZSkge1xuICAgIHJldHVybiBpbnRlcm5hbC5wYWQodmFsdWUsIHsgZGlyOiAncmlnaHQnLCBzaXplIH0pO1xufVxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20ge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIG9mIHRoZSBzcGVjaWZpZWQgbGVuZ3RoLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgaGV4ID0gSGV4LnJhbmRvbSgzMilcbiAqIC8vIEBsb2c6ICcweC4uLidcbiAqIGBgYFxuICpcbiAqIEByZXR1cm5zIFJhbmRvbSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5kb20obGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZyb21CeXRlcyhCeXRlcy5yYW5kb20obGVuZ3RoKSk7XG59XG4vKipcbiAqIFJldHVybnMgYSBzZWN0aW9uIG9mIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZSBnaXZlbiBhIHN0YXJ0L2VuZCBieXRlcyBvZmZzZXQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXguc2xpY2UoJzB4MDEyMzQ1Njc4OScsIDEsIDQpXG4gKiAvLyBAbG9nOiAnMHgyMzQ1NjcnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIHNsaWNlLlxuICogQHBhcmFtIHN0YXJ0IC0gVGhlIHN0YXJ0IG9mZnNldCAoaW4gYnl0ZXMpLlxuICogQHBhcmFtIGVuZCAtIFRoZSBlbmQgb2Zmc2V0IChpbiBieXRlcykuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgc2xpY2VkIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNsaWNlKHZhbHVlLCBzdGFydCwgZW5kLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHN0cmljdCB9ID0gb3B0aW9ucztcbiAgICBpbnRlcm5hbC5hc3NlcnRTdGFydE9mZnNldCh2YWx1ZSwgc3RhcnQpO1xuICAgIGNvbnN0IHZhbHVlXyA9IGAweCR7dmFsdWVcbiAgICAgICAgLnJlcGxhY2UoJzB4JywgJycpXG4gICAgICAgIC5zbGljZSgoc3RhcnQgPz8gMCkgKiAyLCAoZW5kID8/IHZhbHVlLmxlbmd0aCkgKiAyKX1gO1xuICAgIGlmIChzdHJpY3QpXG4gICAgICAgIGludGVybmFsLmFzc2VydEVuZE9mZnNldCh2YWx1ZV8sIHN0YXJ0LCBlbmQpO1xuICAgIHJldHVybiB2YWx1ZV87XG59XG4vKipcbiAqIFJldHJpZXZlcyB0aGUgc2l6ZSBvZiBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSAoaW4gYnl0ZXMpLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LnNpemUoJzB4ZGVhZGJlZWYnKVxuICogLy8gQGxvZzogNFxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSB0byBnZXQgdGhlIHNpemUgb2YuXG4gKiBAcmV0dXJucyBUaGUgc2l6ZSBvZiB0aGUge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIChpbiBieXRlcykuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaXplKHZhbHVlKSB7XG4gICAgcmV0dXJuIE1hdGguY2VpbCgodmFsdWUubGVuZ3RoIC0gMikgLyAyKTtcbn1cbi8qKlxuICogVHJpbXMgbGVhZGluZyB6ZXJvcyBmcm9tIGEge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LnRyaW1MZWZ0KCcweDAwMDAwMDAwZGVhZGJlZWYnKVxuICogLy8gQGxvZzogJzB4ZGVhZGJlZWYnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIHRyaW0uXG4gKiBAcmV0dXJucyBUaGUgdHJpbW1lZCB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmltTGVmdCh2YWx1ZSkge1xuICAgIHJldHVybiBpbnRlcm5hbC50cmltKHZhbHVlLCB7IGRpcjogJ2xlZnQnIH0pO1xufVxuLyoqXG4gKiBUcmltcyB0cmFpbGluZyB6ZXJvcyBmcm9tIGEge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LnRyaW1SaWdodCgnMHhkZWFkYmVlZjAwMDAwMDAwJylcbiAqIC8vIEBsb2c6ICcweGRlYWRiZWVmJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSB0byB0cmltLlxuICogQHJldHVybnMgVGhlIHRyaW1tZWQge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJpbVJpZ2h0KHZhbHVlKSB7XG4gICAgcmV0dXJuIGludGVybmFsLnRyaW0odmFsdWUsIHsgZGlyOiAncmlnaHQnIH0pO1xufVxuLyoqXG4gKiBEZWNvZGVzIGEge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIGludG8gYSBCaWdJbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXgudG9CaWdJbnQoJzB4MWE0JylcbiAqIC8vIEBsb2c6IDQyMG5cbiAqXG4gKiBIZXgudG9CaWdJbnQoJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDFhNCcsIHsgc2l6ZTogMzIgfSlcbiAqIC8vIEBsb2c6IDQyMG5cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBoZXggLSBUaGUge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIGRlY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBkZWNvZGVkIEJpZ0ludC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQmlnSW50KGhleCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzaWduZWQgfSA9IG9wdGlvbnM7XG4gICAgaWYgKG9wdGlvbnMuc2l6ZSlcbiAgICAgICAgaW50ZXJuYWwuYXNzZXJ0U2l6ZShoZXgsIG9wdGlvbnMuc2l6ZSk7XG4gICAgY29uc3QgdmFsdWUgPSBCaWdJbnQoaGV4KTtcbiAgICBpZiAoIXNpZ25lZClcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGNvbnN0IHNpemUgPSAoaGV4Lmxlbmd0aCAtIDIpIC8gMjtcbiAgICBjb25zdCBtYXhfdW5zaWduZWQgPSAoMW4gPDwgKEJpZ0ludChzaXplKSAqIDhuKSkgLSAxbjtcbiAgICBjb25zdCBtYXhfc2lnbmVkID0gbWF4X3Vuc2lnbmVkID4+IDFuO1xuICAgIGlmICh2YWx1ZSA8PSBtYXhfc2lnbmVkKVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgcmV0dXJuIHZhbHVlIC0gbWF4X3Vuc2lnbmVkIC0gMW47XG59XG4vKipcbiAqIERlY29kZXMgYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgaW50byBhIGJvb2xlYW4uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXgudG9Cb29sZWFuKCcweDAxJylcbiAqIC8vIEBsb2c6IHRydWVcbiAqXG4gKiBIZXgudG9Cb29sZWFuKCcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnLCB7IHNpemU6IDMyIH0pXG4gKiAvLyBAbG9nOiB0cnVlXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gaGV4IC0gVGhlIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSB0byBkZWNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgZGVjb2RlZCBib29sZWFuLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9Cb29sZWFuKGhleCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKG9wdGlvbnMuc2l6ZSlcbiAgICAgICAgaW50ZXJuYWwuYXNzZXJ0U2l6ZShoZXgsIG9wdGlvbnMuc2l6ZSk7XG4gICAgY29uc3QgaGV4XyA9IHRyaW1MZWZ0KGhleCk7XG4gICAgaWYgKGhleF8gPT09ICcweCcpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoaGV4XyA9PT0gJzB4MScpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIHRocm93IG5ldyBJbnZhbGlkSGV4Qm9vbGVhbkVycm9yKGhleCk7XG59XG4vKipcbiAqIERlY29kZXMgYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgaW50byBhIHtAbGluayBveCNCeXRlcy5CeXRlc30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBkYXRhID0gSGV4LnRvQnl0ZXMoJzB4NDg2NTZjNmM2ZjIwNzc2ZjcyNmM2NDIxJylcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzcyLCAxMDEsIDEwOCwgMTA4LCAxMTEsIDMyLCA4NywgMTExLCAxMTQsIDEwOCwgMTAwLCAzM10pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gaGV4IC0gVGhlIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSB0byBkZWNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgZGVjb2RlZCB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CeXRlcyhoZXgsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBCeXRlcy5mcm9tSGV4KGhleCwgb3B0aW9ucyk7XG59XG4vKipcbiAqIERlY29kZXMgYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgaW50byBhIG51bWJlci5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC50b051bWJlcignMHgxYTQnKVxuICogLy8gQGxvZzogNDIwXG4gKlxuICogSGV4LnRvTnVtYmVyKCcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxYTQnLCB7IHNpemU6IDMyIH0pXG4gKiAvLyBAbG9nOiA0MjBcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBoZXggLSBUaGUge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIGRlY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBkZWNvZGVkIG51bWJlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvTnVtYmVyKGhleCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzaWduZWQsIHNpemUgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCFzaWduZWQgJiYgIXNpemUpXG4gICAgICAgIHJldHVybiBOdW1iZXIoaGV4KTtcbiAgICByZXR1cm4gTnVtYmVyKHRvQmlnSW50KGhleCwgb3B0aW9ucykpO1xufVxuLyoqXG4gKiBEZWNvZGVzIGEge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIGludG8gYSBzdHJpbmcuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXgudG9TdHJpbmcoJzB4NDg2NTZjNmM2ZjIwNTc2ZjcyNmM2NDIxJylcbiAqIC8vIEBsb2c6ICdIZWxsbyB3b3JsZCEnXG4gKlxuICogSGV4LnRvU3RyaW5nKCcweDQ4NjU2YzZjNmYyMDU3NmY3MjZjNjQyMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLCB7XG4gKiAgc2l6ZTogMzIsXG4gKiB9KVxuICogLy8gQGxvZzogJ0hlbGxvIHdvcmxkJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIGhleCAtIFRoZSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgdG8gZGVjb2RlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgVGhlIGRlY29kZWQgc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9TdHJpbmcoaGV4LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpemUgfSA9IG9wdGlvbnM7XG4gICAgbGV0IGJ5dGVzID0gQnl0ZXMuZnJvbUhleChoZXgpO1xuICAgIGlmIChzaXplKSB7XG4gICAgICAgIGludGVybmFsX2J5dGVzLmFzc2VydFNpemUoYnl0ZXMsIHNpemUpO1xuICAgICAgICBieXRlcyA9IEJ5dGVzLnRyaW1SaWdodChieXRlcyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoYnl0ZXMpO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIHtAbGluayBveCNIZXguSGV4fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzLCBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXgudmFsaWRhdGUoJzB4ZGVhZGJlZWYnKVxuICogLy8gQGxvZzogdHJ1ZVxuICpcbiAqIEhleC52YWxpZGF0ZShCeXRlcy5mcm9tKFsxLCAyLCAzXSkpXG4gKiAvLyBAbG9nOiBmYWxzZVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBhIHtAbGluayBveCNIZXguSGV4fSwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZSh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzdHJpY3QgPSBmYWxzZSB9ID0gb3B0aW9ucztcbiAgICB0cnkge1xuICAgICAgICBhc3NlcnQodmFsdWUsIHsgc3RyaWN0IH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd24gd2hlbiB0aGUgcHJvdmlkZWQgaW50ZWdlciBpcyBvdXQgb2YgcmFuZ2UsIGFuZCBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgYXMgYSBoZXggdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXguZnJvbU51bWJlcig0MjAxODI3Mzg5MTI3MzEyODM3MTI5MzcxMjkpXG4gKiAvLyBAZXJyb3I6IEhleC5JbnRlZ2VyT3V0T2ZSYW5nZUVycm9yOiBOdW1iZXIgXFxgNC4yMDE4MjczODkxMjczMTI2ZSsyNlxcYCBpcyBub3QgaW4gc2FmZSB1bnNpZ25lZCBpbnRlZ2VyIHJhbmdlIChgMGAgdG8gYDkwMDcxOTkyNTQ3NDA5OTFgKVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnRlZ2VyT3V0T2ZSYW5nZUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBtYXgsIG1pbiwgc2lnbmVkLCBzaXplLCB2YWx1ZSwgfSkge1xuICAgICAgICBzdXBlcihgTnVtYmVyIFxcYCR7dmFsdWV9XFxgIGlzIG5vdCBpbiBzYWZlJHtzaXplID8gYCAke3NpemUgKiA4fS1iaXRgIDogJyd9JHtzaWduZWQgPyAnIHNpZ25lZCcgOiAnIHVuc2lnbmVkJ30gaW50ZWdlciByYW5nZSAke21heCA/IGAoXFxgJHttaW59XFxgIHRvIFxcYCR7bWF4fVxcYClgIDogYChhYm92ZSBcXGAke21pbn1cXGApYH1gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0hleC5JbnRlZ2VyT3V0T2ZSYW5nZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIHRoZSBwcm92aWRlZCBoZXggdmFsdWUgY2Fubm90IGJlIHJlcHJlc2VudGVkIGFzIGEgYm9vbGVhbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC50b0Jvb2xlYW4oJzB4YScpXG4gKiAvLyBAZXJyb3I6IEhleC5JbnZhbGlkSGV4Qm9vbGVhbkVycm9yOiBIZXggdmFsdWUgYFwiMHhhXCJgIGlzIG5vdCBhIHZhbGlkIGJvb2xlYW4uXG4gKiAvLyBAZXJyb3I6IFRoZSBoZXggdmFsdWUgbXVzdCBiZSBgXCIweDBcImAgKGZhbHNlKSBvciBgXCIweDFcImAgKHRydWUpLlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkSGV4Qm9vbGVhbkVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoaGV4KSB7XG4gICAgICAgIHN1cGVyKGBIZXggdmFsdWUgXFxgXCIke2hleH1cIlxcYCBpcyBub3QgYSB2YWxpZCBib29sZWFuLmAsIHtcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogW1xuICAgICAgICAgICAgICAgICdUaGUgaGV4IHZhbHVlIG11c3QgYmUgYFwiMHgwXCJgIChmYWxzZSkgb3IgYFwiMHgxXCJgICh0cnVlKS4nLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdIZXguSW52YWxpZEhleEJvb2xlYW5FcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd24gd2hlbiB0aGUgcHJvdmlkZWQgdmFsdWUgaXMgbm90IGEgdmFsaWQgaGV4IHR5cGUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXguYXNzZXJ0KDEpXG4gKiAvLyBAZXJyb3I6IEhleC5JbnZhbGlkSGV4VHlwZUVycm9yOiBWYWx1ZSBgMWAgb2YgdHlwZSBgbnVtYmVyYCBpcyBhbiBpbnZhbGlkIGhleCB0eXBlLlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkSGV4VHlwZUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgc3VwZXIoYFZhbHVlIFxcYCR7dHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyA/IEpzb24uc3RyaW5naWZ5KHZhbHVlKSA6IHZhbHVlfVxcYCBvZiB0eXBlIFxcYCR7dHlwZW9mIHZhbHVlfVxcYCBpcyBhbiBpbnZhbGlkIGhleCB0eXBlLmAsIHtcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogWydIZXggdHlwZXMgbXVzdCBiZSByZXByZXNlbnRlZCBhcyBgXCIweCR7c3RyaW5nfVwiYC4nXSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdIZXguSW52YWxpZEhleFR5cGVFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd24gd2hlbiB0aGUgcHJvdmlkZWQgaGV4IHZhbHVlIGlzIGludmFsaWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXguYXNzZXJ0KCcweDAxMjM0NTY3ODlhYmNkZWZnJylcbiAqIC8vIEBlcnJvcjogSGV4LkludmFsaWRIZXhWYWx1ZUVycm9yOiBWYWx1ZSBgMHgwMTIzNDU2Nzg5YWJjZGVmZ2AgaXMgYW4gaW52YWxpZCBoZXggdmFsdWUuXG4gKiAvLyBAZXJyb3I6IEhleCB2YWx1ZXMgbXVzdCBzdGFydCB3aXRoIGBcIjB4XCJgIGFuZCBjb250YWluIG9ubHkgaGV4YWRlY2ltYWwgY2hhcmFjdGVycyAoMC05LCBhLWYsIEEtRikuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRIZXhWYWx1ZUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgc3VwZXIoYFZhbHVlIFxcYCR7dmFsdWV9XFxgIGlzIGFuIGludmFsaWQgaGV4IHZhbHVlLmAsIHtcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogW1xuICAgICAgICAgICAgICAgICdIZXggdmFsdWVzIG11c3Qgc3RhcnQgd2l0aCBgXCIweFwiYCBhbmQgY29udGFpbiBvbmx5IGhleGFkZWNpbWFsIGNoYXJhY3RlcnMgKDAtOSwgYS1mLCBBLUYpLicsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0hleC5JbnZhbGlkSGV4VmFsdWVFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd24gd2hlbiB0aGUgcHJvdmlkZWQgaGV4IHZhbHVlIGlzIGFuIG9kZCBsZW5ndGguXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLmZyb21IZXgoJzB4YWJjZGUnKVxuICogLy8gQGVycm9yOiBIZXguSW52YWxpZExlbmd0aEVycm9yOiBIZXggdmFsdWUgYFwiMHhhYmNkZVwiYCBpcyBhbiBvZGQgbGVuZ3RoICg1IG5pYmJsZXMpLlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkTGVuZ3RoRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICBzdXBlcihgSGV4IHZhbHVlIFxcYFwiJHt2YWx1ZX1cIlxcYCBpcyBhbiBvZGQgbGVuZ3RoICgke3ZhbHVlLmxlbmd0aCAtIDJ9IG5pYmJsZXMpLmAsIHtcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogWydJdCBtdXN0IGJlIGFuIGV2ZW4gbGVuZ3RoLiddLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0hleC5JbnZhbGlkTGVuZ3RoRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3duIHdoZW4gdGhlIHNpemUgb2YgdGhlIHZhbHVlIGV4Y2VlZHMgdGhlIGV4cGVjdGVkIG1heCBzaXplLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LmZyb21TdHJpbmcoJ0hlbGxvIFdvcmxkIScsIHsgc2l6ZTogOCB9KVxuICogLy8gQGVycm9yOiBIZXguU2l6ZU92ZXJmbG93RXJyb3I6IFNpemUgY2Fubm90IGV4Y2VlZCBgOGAgYnl0ZXMuIEdpdmVuIHNpemU6IGAxMmAgYnl0ZXMuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIFNpemVPdmVyZmxvd0Vycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBnaXZlblNpemUsIG1heFNpemUgfSkge1xuICAgICAgICBzdXBlcihgU2l6ZSBjYW5ub3QgZXhjZWVkIFxcYCR7bWF4U2l6ZX1cXGAgYnl0ZXMuIEdpdmVuIHNpemU6IFxcYCR7Z2l2ZW5TaXplfVxcYCBieXRlcy5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0hleC5TaXplT3ZlcmZsb3dFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd24gd2hlbiB0aGUgc2xpY2Ugb2Zmc2V0IGV4Y2VlZHMgdGhlIGJvdW5kcyBvZiB0aGUgdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXguc2xpY2UoJzB4MDEyMzQ1Njc4OScsIDYpXG4gKiAvLyBAZXJyb3I6IEhleC5TbGljZU9mZnNldE91dE9mQm91bmRzRXJyb3I6IFNsaWNlIHN0YXJ0aW5nIGF0IG9mZnNldCBgNmAgaXMgb3V0LW9mLWJvdW5kcyAoc2l6ZTogYDVgKS5cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgU2xpY2VPZmZzZXRPdXRPZkJvdW5kc0Vycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBvZmZzZXQsIHBvc2l0aW9uLCBzaXplLCB9KSB7XG4gICAgICAgIHN1cGVyKGBTbGljZSAke3Bvc2l0aW9uID09PSAnc3RhcnQnID8gJ3N0YXJ0aW5nJyA6ICdlbmRpbmcnfSBhdCBvZmZzZXQgXFxgJHtvZmZzZXR9XFxgIGlzIG91dC1vZi1ib3VuZHMgKHNpemU6IFxcYCR7c2l6ZX1cXGApLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnSGV4LlNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd24gd2hlbiB0aGUgc2l6ZSBvZiB0aGUgdmFsdWUgZXhjZWVkcyB0aGUgcGFkIHNpemUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXgucGFkTGVmdCgnMHgxYTRlMTJhNDVhMjEzMjMxMjNhYWE4N2E4OTdhODk3YTg5OGE2NTY3YTU3OGE4NjdhOTg3NzhhNjY3YTg1YTg3NWE4N2E2YTc4N2E2NWE2NzVhNmE5JywgMzIpXG4gKiAvLyBAZXJyb3I6IEhleC5TaXplRXhjZWVkc1BhZGRpbmdTaXplRXJyb3I6IEhleCBzaXplIChgNDNgKSBleGNlZWRzIHBhZGRpbmcgc2l6ZSAoYDMyYCkuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIFNpemVFeGNlZWRzUGFkZGluZ1NpemVFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgc2l6ZSwgdGFyZ2V0U2l6ZSwgdHlwZSwgfSkge1xuICAgICAgICBzdXBlcihgJHt0eXBlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpfSR7dHlwZVxuICAgICAgICAgICAgLnNsaWNlKDEpXG4gICAgICAgICAgICAudG9Mb3dlckNhc2UoKX0gc2l6ZSAoXFxgJHtzaXplfVxcYCkgZXhjZWVkcyBwYWRkaW5nIHNpemUgKFxcYCR7dGFyZ2V0U2l6ZX1cXGApLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnSGV4LlNpemVFeGNlZWRzUGFkZGluZ1NpemVFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJlcXVhbEJ5dGVzIiwiQnl0ZXMiLCJFcnJvcnMiLCJpbnRlcm5hbF9ieXRlcyIsImludGVybmFsIiwiSnNvbiIsImVuY29kZXIiLCJUZXh0RW5jb2RlciIsImhleGVzIiwiQXJyYXkiLCJmcm9tIiwibGVuZ3RoIiwiX3YiLCJpIiwidG9TdHJpbmciLCJwYWRTdGFydCIsImFzc2VydCIsInZhbHVlIiwib3B0aW9ucyIsInN0cmljdCIsIkludmFsaWRIZXhUeXBlRXJyb3IiLCJ0ZXN0IiwiSW52YWxpZEhleFZhbHVlRXJyb3IiLCJzdGFydHNXaXRoIiwiY29uY2F0IiwidmFsdWVzIiwicmVkdWNlIiwiYWNjIiwieCIsInJlcGxhY2UiLCJVaW50OEFycmF5IiwiZnJvbUJ5dGVzIiwiaXNBcnJheSIsImZyb21Cb29sZWFuIiwiaGV4IiwiTnVtYmVyIiwic2l6ZSIsImFzc2VydFNpemUiLCJwYWRMZWZ0Iiwic3RyaW5nIiwicGFkUmlnaHQiLCJmcm9tTnVtYmVyIiwic2lnbmVkIiwidmFsdWVfIiwiQmlnSW50IiwibWF4VmFsdWUiLCJNQVhfU0FGRV9JTlRFR0VSIiwibWluVmFsdWUiLCJzdWZmaXgiLCJJbnRlZ2VyT3V0T2ZSYW5nZUVycm9yIiwibWF4IiwidW5kZWZpbmVkIiwibWluIiwic3RyaW5nVmFsdWUiLCJhc1VpbnROIiwiZnJvbVN0cmluZyIsImVuY29kZSIsImlzRXF1YWwiLCJoZXhBIiwiaGV4QiIsImZyb21IZXgiLCJwYWQiLCJkaXIiLCJyYW5kb20iLCJzbGljZSIsInN0YXJ0IiwiZW5kIiwiYXNzZXJ0U3RhcnRPZmZzZXQiLCJhc3NlcnRFbmRPZmZzZXQiLCJNYXRoIiwiY2VpbCIsInRyaW1MZWZ0IiwidHJpbSIsInRyaW1SaWdodCIsInRvQmlnSW50IiwibWF4X3Vuc2lnbmVkIiwibWF4X3NpZ25lZCIsInRvQm9vbGVhbiIsImhleF8iLCJJbnZhbGlkSGV4Qm9vbGVhbkVycm9yIiwidG9CeXRlcyIsInRvTnVtYmVyIiwiYnl0ZXMiLCJUZXh0RGVjb2RlciIsImRlY29kZSIsInZhbGlkYXRlIiwiQmFzZUVycm9yIiwiY29uc3RydWN0b3IiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIm1ldGFNZXNzYWdlcyIsInN0cmluZ2lmeSIsIkludmFsaWRMZW5ndGhFcnJvciIsIlNpemVPdmVyZmxvd0Vycm9yIiwiZ2l2ZW5TaXplIiwibWF4U2l6ZSIsIlNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvciIsIm9mZnNldCIsInBvc2l0aW9uIiwiU2l6ZUV4Y2VlZHNQYWRkaW5nU2l6ZUVycm9yIiwidGFyZ2V0U2l6ZSIsInR5cGUiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsInRvTG93ZXJDYXNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Hex.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Json.js":
/*!*******************************************!*\
  !*** ./node_modules/ox/_esm/core/Json.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   stringify: () => (/* binding */ stringify)\n/* harmony export */ });\nconst bigIntSuffix = \"#__bigint\";\n/**\n * Parses a JSON string, with support for `bigint`.\n *\n * @example\n * ```ts twoslash\n * import { Json } from 'ox'\n *\n * const json = Json.parse('{\"foo\":\"bar\",\"baz\":\"69420694206942069420694206942069420694206942069420#__bigint\"}')\n * // @log: {\n * // @log:   foo: 'bar',\n * // @log:   baz: 69420694206942069420694206942069420694206942069420n\n * // @log: }\n * ```\n *\n * @param string - The value to parse.\n * @param reviver - A function that transforms the results.\n * @returns The parsed value.\n */ function parse(string, reviver) {\n    return JSON.parse(string, (key, value_)=>{\n        const value = value_;\n        if (typeof value === \"string\" && value.endsWith(bigIntSuffix)) return BigInt(value.slice(0, -bigIntSuffix.length));\n        return typeof reviver === \"function\" ? reviver(key, value) : value;\n    });\n}\n/**\n * Stringifies a value to its JSON representation, with support for `bigint`.\n *\n * @example\n * ```ts twoslash\n * import { Json } from 'ox'\n *\n * const json = Json.stringify({\n *   foo: 'bar',\n *   baz: 69420694206942069420694206942069420694206942069420n,\n * })\n * // @log: '{\"foo\":\"bar\",\"baz\":\"69420694206942069420694206942069420694206942069420#__bigint\"}'\n * ```\n *\n * @param value - The value to stringify.\n * @param replacer - A function that transforms the results. It is passed the key and value of the property, and must return the value to be used in the JSON string. If this function returns `undefined`, the property is not included in the resulting JSON string.\n * @param space - A string or number that determines the indentation of the JSON string. If it is a number, it indicates the number of spaces to use as indentation; if it is a string (e.g. `'\\t'`), it uses the string as the indentation character.\n * @returns The JSON string.\n */ function stringify(value, replacer, space) {\n    return JSON.stringify(value, (key, value)=>{\n        if (typeof replacer === \"function\") return replacer(key, value);\n        if (typeof value === \"bigint\") return value.toString() + bigIntSuffix;\n        return value;\n    }, space);\n} //# sourceMappingURL=Json.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0pzb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxNQUFNQSxlQUFlO0FBQ3JCOzs7Ozs7Ozs7Ozs7Ozs7OztDQWlCQyxHQUNNLFNBQVNDLE1BQU1DLE1BQU0sRUFBRUMsT0FBTztJQUNqQyxPQUFPQyxLQUFLSCxLQUFLLENBQUNDLFFBQVEsQ0FBQ0csS0FBS0M7UUFDNUIsTUFBTUMsUUFBUUQ7UUFDZCxJQUFJLE9BQU9DLFVBQVUsWUFBWUEsTUFBTUMsUUFBUSxDQUFDUixlQUM1QyxPQUFPUyxPQUFPRixNQUFNRyxLQUFLLENBQUMsR0FBRyxDQUFDVixhQUFhVyxNQUFNO1FBQ3JELE9BQU8sT0FBT1IsWUFBWSxhQUFhQSxRQUFRRSxLQUFLRSxTQUFTQTtJQUNqRTtBQUNKO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWtCQyxHQUNNLFNBQVNLLFVBQVVMLEtBQUssRUFBRU0sUUFBUSxFQUFFQyxLQUFLO0lBQzVDLE9BQU9WLEtBQUtRLFNBQVMsQ0FBQ0wsT0FBTyxDQUFDRixLQUFLRTtRQUMvQixJQUFJLE9BQU9NLGFBQWEsWUFDcEIsT0FBT0EsU0FBU1IsS0FBS0U7UUFDekIsSUFBSSxPQUFPQSxVQUFVLFVBQ2pCLE9BQU9BLE1BQU1RLFFBQVEsS0FBS2Y7UUFDOUIsT0FBT087SUFDWCxHQUFHTztBQUNQLEVBQ0EsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xhdy13b3Jrcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvSnNvbi5qcz80ZTg3Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGJpZ0ludFN1ZmZpeCA9ICcjX19iaWdpbnQnO1xuLyoqXG4gKiBQYXJzZXMgYSBKU09OIHN0cmluZywgd2l0aCBzdXBwb3J0IGZvciBgYmlnaW50YC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEpzb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBqc29uID0gSnNvbi5wYXJzZSgne1wiZm9vXCI6XCJiYXJcIixcImJhelwiOlwiNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjAjX19iaWdpbnRcIn0nKVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICBmb286ICdiYXInLFxuICogLy8gQGxvZzogICBiYXo6IDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwblxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHN0cmluZyAtIFRoZSB2YWx1ZSB0byBwYXJzZS5cbiAqIEBwYXJhbSByZXZpdmVyIC0gQSBmdW5jdGlvbiB0aGF0IHRyYW5zZm9ybXMgdGhlIHJlc3VsdHMuXG4gKiBAcmV0dXJucyBUaGUgcGFyc2VkIHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2Uoc3RyaW5nLCByZXZpdmVyKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2Uoc3RyaW5nLCAoa2V5LCB2YWx1ZV8pID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZV87XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLmVuZHNXaXRoKGJpZ0ludFN1ZmZpeCkpXG4gICAgICAgICAgICByZXR1cm4gQmlnSW50KHZhbHVlLnNsaWNlKDAsIC1iaWdJbnRTdWZmaXgubGVuZ3RoKSk7XG4gICAgICAgIHJldHVybiB0eXBlb2YgcmV2aXZlciA9PT0gJ2Z1bmN0aW9uJyA/IHJldml2ZXIoa2V5LCB2YWx1ZSkgOiB2YWx1ZTtcbiAgICB9KTtcbn1cbi8qKlxuICogU3RyaW5naWZpZXMgYSB2YWx1ZSB0byBpdHMgSlNPTiByZXByZXNlbnRhdGlvbiwgd2l0aCBzdXBwb3J0IGZvciBgYmlnaW50YC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEpzb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBqc29uID0gSnNvbi5zdHJpbmdpZnkoe1xuICogICBmb286ICdiYXInLFxuICogICBiYXo6IDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwbixcbiAqIH0pXG4gKiAvLyBAbG9nOiAne1wiZm9vXCI6XCJiYXJcIixcImJhelwiOlwiNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjAjX19iaWdpbnRcIn0nXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gc3RyaW5naWZ5LlxuICogQHBhcmFtIHJlcGxhY2VyIC0gQSBmdW5jdGlvbiB0aGF0IHRyYW5zZm9ybXMgdGhlIHJlc3VsdHMuIEl0IGlzIHBhc3NlZCB0aGUga2V5IGFuZCB2YWx1ZSBvZiB0aGUgcHJvcGVydHksIGFuZCBtdXN0IHJldHVybiB0aGUgdmFsdWUgdG8gYmUgdXNlZCBpbiB0aGUgSlNPTiBzdHJpbmcuIElmIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBgdW5kZWZpbmVkYCwgdGhlIHByb3BlcnR5IGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0aW5nIEpTT04gc3RyaW5nLlxuICogQHBhcmFtIHNwYWNlIC0gQSBzdHJpbmcgb3IgbnVtYmVyIHRoYXQgZGV0ZXJtaW5lcyB0aGUgaW5kZW50YXRpb24gb2YgdGhlIEpTT04gc3RyaW5nLiBJZiBpdCBpcyBhIG51bWJlciwgaXQgaW5kaWNhdGVzIHRoZSBudW1iZXIgb2Ygc3BhY2VzIHRvIHVzZSBhcyBpbmRlbnRhdGlvbjsgaWYgaXQgaXMgYSBzdHJpbmcgKGUuZy4gYCdcXHQnYCksIGl0IHVzZXMgdGhlIHN0cmluZyBhcyB0aGUgaW5kZW50YXRpb24gY2hhcmFjdGVyLlxuICogQHJldHVybnMgVGhlIEpTT04gc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5naWZ5KHZhbHVlLCByZXBsYWNlciwgc3BhY2UpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUsIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVwbGFjZXIgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICByZXR1cm4gcmVwbGFjZXIoa2V5LCB2YWx1ZSk7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnKVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCkgKyBiaWdJbnRTdWZmaXg7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LCBzcGFjZSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Kc29uLmpzLm1hcCJdLCJuYW1lcyI6WyJiaWdJbnRTdWZmaXgiLCJwYXJzZSIsInN0cmluZyIsInJldml2ZXIiLCJKU09OIiwia2V5IiwidmFsdWVfIiwidmFsdWUiLCJlbmRzV2l0aCIsIkJpZ0ludCIsInNsaWNlIiwibGVuZ3RoIiwic3RyaW5naWZ5IiwicmVwbGFjZXIiLCJzcGFjZSIsInRvU3RyaW5nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Json.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/P256.js":
/*!*******************************************!*\
  !*** ./node_modules/ox/_esm/core/P256.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createKeyPair: () => (/* binding */ createKeyPair),\n/* harmony export */   getPublicKey: () => (/* binding */ getPublicKey),\n/* harmony export */   getSharedSecret: () => (/* binding */ getSharedSecret),\n/* harmony export */   noble: () => (/* binding */ noble),\n/* harmony export */   randomPrivateKey: () => (/* binding */ randomPrivateKey),\n/* harmony export */   recoverPublicKey: () => (/* binding */ recoverPublicKey),\n/* harmony export */   sign: () => (/* binding */ sign),\n/* harmony export */   verify: () => (/* binding */ verify)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_p256__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/curves/p256 */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/p256.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _internal_entropy_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/entropy.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/entropy.js\");\n/* harmony import */ var _PublicKey_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PublicKey.js */ \"(ssr)/./node_modules/ox/_esm/core/PublicKey.js\");\n\n\n\n\n\n/** Re-export of noble/curves P256 utilities. */ const noble = _noble_curves_p256__WEBPACK_IMPORTED_MODULE_0__.secp256r1;\n/**\n * Creates a new P256 ECDSA key pair consisting of a private key and its corresponding public key.\n *\n * @example\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const { privateKey, publicKey } = P256.createKeyPair()\n * ```\n *\n * @param options - The options to generate the key pair.\n * @returns The generated key pair containing both private and public keys.\n */ function createKeyPair(options = {}) {\n    const { as = \"Hex\" } = options;\n    const privateKey = randomPrivateKey({\n        as\n    });\n    const publicKey = getPublicKey({\n        privateKey\n    });\n    return {\n        privateKey: privateKey,\n        publicKey\n    };\n}\n/**\n * Computes the P256 ECDSA public key from a provided private key.\n *\n * @example\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const publicKey = P256.getPublicKey({ privateKey: '0x...' })\n * ```\n *\n * @param options - The options to compute the public key.\n * @returns The computed public key.\n */ function getPublicKey(options) {\n    const { privateKey } = options;\n    const point = _noble_curves_p256__WEBPACK_IMPORTED_MODULE_0__.secp256r1.ProjectivePoint.fromPrivateKey(typeof privateKey === \"string\" ? privateKey.slice(2) : _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(privateKey).slice(2));\n    return _PublicKey_js__WEBPACK_IMPORTED_MODULE_2__.from(point);\n}\n/**\n * Computes a shared secret using ECDH (Elliptic Curve Diffie-Hellman) between a private key and a public key.\n *\n * @example\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const { privateKey: privateKeyA } = P256.createKeyPair()\n * const { publicKey: publicKeyB } = P256.createKeyPair()\n *\n * const sharedSecret = P256.getSharedSecret({\n *   privateKey: privateKeyA,\n *   publicKey: publicKeyB\n * })\n * ```\n *\n * @param options - The options to compute the shared secret.\n * @returns The computed shared secret.\n */ function getSharedSecret(options) {\n    const { as = \"Hex\", privateKey, publicKey } = options;\n    const point = _noble_curves_p256__WEBPACK_IMPORTED_MODULE_0__.secp256r1.ProjectivePoint.fromHex(_PublicKey_js__WEBPACK_IMPORTED_MODULE_2__.toHex(publicKey).slice(2));\n    const privateKeyHex = typeof privateKey === \"string\" ? privateKey.slice(2) : _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(privateKey).slice(2);\n    const sharedPoint = point.multiply(_noble_curves_p256__WEBPACK_IMPORTED_MODULE_0__.secp256r1.utils.normPrivateKeyToScalar(privateKeyHex));\n    const sharedSecret = sharedPoint.toRawBytes(true); // compressed format\n    if (as === \"Hex\") return _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(sharedSecret);\n    return sharedSecret;\n}\n/**\n * Generates a random P256 ECDSA private key.\n *\n * @example\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const privateKey = P256.randomPrivateKey()\n * ```\n *\n * @param options - The options to generate the private key.\n * @returns The generated private key.\n */ function randomPrivateKey(options = {}) {\n    const { as = \"Hex\" } = options;\n    const bytes = _noble_curves_p256__WEBPACK_IMPORTED_MODULE_0__.secp256r1.utils.randomPrivateKey();\n    if (as === \"Hex\") return _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(bytes);\n    return bytes;\n}\n/**\n * Recovers the signing public key from the signed payload and signature.\n *\n * @example\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const signature = P256.sign({ payload: '0xdeadbeef', privateKey: '0x...' })\n *\n * const publicKey = P256.recoverPublicKey({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The recovery options.\n * @returns The recovered public key.\n */ function recoverPublicKey(options) {\n    const { payload, signature } = options;\n    const { r, s, yParity } = signature;\n    const signature_ = new _noble_curves_p256__WEBPACK_IMPORTED_MODULE_0__.secp256r1.Signature(BigInt(r), BigInt(s)).addRecoveryBit(yParity);\n    const payload_ = payload instanceof Uint8Array ? _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(payload) : payload;\n    const point = signature_.recoverPublicKey(payload_.substring(2));\n    return _PublicKey_js__WEBPACK_IMPORTED_MODULE_2__.from(point);\n}\n/**\n * Signs the payload with the provided private key and returns a P256 signature.\n *\n * @example\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const signature = P256.sign({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   privateKey: '0x...' // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The signing options.\n * @returns The ECDSA {@link ox#Signature.Signature}.\n */ function sign(options) {\n    const { extraEntropy = _internal_entropy_js__WEBPACK_IMPORTED_MODULE_3__.extraEntropy, hash, payload, privateKey } = options;\n    const { r, s, recovery } = _noble_curves_p256__WEBPACK_IMPORTED_MODULE_0__.secp256r1.sign(payload instanceof Uint8Array ? payload : _Bytes_js__WEBPACK_IMPORTED_MODULE_4__.fromHex(payload), privateKey instanceof Uint8Array ? privateKey : _Bytes_js__WEBPACK_IMPORTED_MODULE_4__.fromHex(privateKey), {\n        extraEntropy: typeof extraEntropy === \"boolean\" ? extraEntropy : _Hex_js__WEBPACK_IMPORTED_MODULE_1__.from(extraEntropy).slice(2),\n        lowS: true,\n        ...hash ? {\n            prehash: true\n        } : {}\n    });\n    return {\n        r,\n        s,\n        yParity: recovery\n    };\n}\n/**\n * Verifies a payload was signed by the provided public key.\n *\n * @example\n *\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const { privateKey, publicKey } = P256.createKeyPair()\n * const signature = P256.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const verified = P256.verify({ // [!code focus]\n *   publicKey, // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The verification options.\n * @returns Whether the payload was signed by the provided public key.\n */ function verify(options) {\n    const { hash, payload, publicKey, signature } = options;\n    return _noble_curves_p256__WEBPACK_IMPORTED_MODULE_0__.secp256r1.verify(signature, payload instanceof Uint8Array ? payload : _Bytes_js__WEBPACK_IMPORTED_MODULE_4__.fromHex(payload), _PublicKey_js__WEBPACK_IMPORTED_MODULE_2__.toHex(publicKey).substring(2), ...hash ? [\n        {\n            prehash: true,\n            lowS: true\n        }\n    ] : []);\n} //# sourceMappingURL=P256.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1AyNTYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUErQztBQUNYO0FBQ0o7QUFDaUI7QUFDTDtBQUM1Qyw4Q0FBOEMsR0FDdkMsTUFBTUssUUFBUUwseURBQVNBLENBQUM7QUFDL0I7Ozs7Ozs7Ozs7OztDQVlDLEdBQ00sU0FBU00sY0FBY0MsVUFBVSxDQUFDLENBQUM7SUFDdEMsTUFBTSxFQUFFQyxLQUFLLEtBQUssRUFBRSxHQUFHRDtJQUN2QixNQUFNRSxhQUFhQyxpQkFBaUI7UUFBRUY7SUFBRztJQUN6QyxNQUFNRyxZQUFZQyxhQUFhO1FBQUVIO0lBQVc7SUFDNUMsT0FBTztRQUNIQSxZQUFZQTtRQUNaRTtJQUNKO0FBQ0o7QUFDQTs7Ozs7Ozs7Ozs7O0NBWUMsR0FDTSxTQUFTQyxhQUFhTCxPQUFPO0lBQ2hDLE1BQU0sRUFBRUUsVUFBVSxFQUFFLEdBQUdGO0lBQ3ZCLE1BQU1NLFFBQVFiLHlEQUFTQSxDQUFDYyxlQUFlLENBQUNDLGNBQWMsQ0FBQyxPQUFPTixlQUFlLFdBQ3ZFQSxXQUFXTyxLQUFLLENBQUMsS0FDakJkLDhDQUFhLENBQUNPLFlBQVlPLEtBQUssQ0FBQztJQUN0QyxPQUFPWiwrQ0FBYyxDQUFDUztBQUMxQjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FrQkMsR0FDTSxTQUFTTSxnQkFBZ0JaLE9BQU87SUFDbkMsTUFBTSxFQUFFQyxLQUFLLEtBQUssRUFBRUMsVUFBVSxFQUFFRSxTQUFTLEVBQUUsR0FBR0o7SUFDOUMsTUFBTU0sUUFBUWIseURBQVNBLENBQUNjLGVBQWUsQ0FBQ00sT0FBTyxDQUFDaEIsZ0RBQWUsQ0FBQ08sV0FBV0ssS0FBSyxDQUFDO0lBQ2pGLE1BQU1NLGdCQUFnQixPQUFPYixlQUFlLFdBQ3RDQSxXQUFXTyxLQUFLLENBQUMsS0FDakJkLDhDQUFhLENBQUNPLFlBQVlPLEtBQUssQ0FBQztJQUN0QyxNQUFNTyxjQUFjVixNQUFNVyxRQUFRLENBQUN4Qix5REFBU0EsQ0FBQ3lCLEtBQUssQ0FBQ0Msc0JBQXNCLENBQUNKO0lBQzFFLE1BQU1LLGVBQWVKLFlBQVlLLFVBQVUsQ0FBQyxPQUFPLG9CQUFvQjtJQUN2RSxJQUFJcEIsT0FBTyxPQUNQLE9BQU9OLDhDQUFhLENBQUN5QjtJQUN6QixPQUFPQTtBQUNYO0FBQ0E7Ozs7Ozs7Ozs7OztDQVlDLEdBQ00sU0FBU2pCLGlCQUFpQkgsVUFBVSxDQUFDLENBQUM7SUFDekMsTUFBTSxFQUFFQyxLQUFLLEtBQUssRUFBRSxHQUFHRDtJQUN2QixNQUFNc0IsUUFBUTdCLHlEQUFTQSxDQUFDeUIsS0FBSyxDQUFDZixnQkFBZ0I7SUFDOUMsSUFBSUYsT0FBTyxPQUNQLE9BQU9OLDhDQUFhLENBQUMyQjtJQUN6QixPQUFPQTtBQUNYO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBaUJDLEdBQ00sU0FBU0MsaUJBQWlCdkIsT0FBTztJQUNwQyxNQUFNLEVBQUV3QixPQUFPLEVBQUVDLFNBQVMsRUFBRSxHQUFHekI7SUFDL0IsTUFBTSxFQUFFMEIsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLE9BQU8sRUFBRSxHQUFHSDtJQUMxQixNQUFNSSxhQUFhLElBQUlwQyx5REFBU0EsQ0FBQ3FDLFNBQVMsQ0FBQ0MsT0FBT0wsSUFBSUssT0FBT0osSUFBSUssY0FBYyxDQUFDSjtJQUNoRixNQUFNSyxXQUFXVCxtQkFBbUJVLGFBQWF2Qyw4Q0FBYSxDQUFDNkIsV0FBV0E7SUFDMUUsTUFBTWxCLFFBQVF1QixXQUFXTixnQkFBZ0IsQ0FBQ1UsU0FBU0UsU0FBUyxDQUFDO0lBQzdELE9BQU90QywrQ0FBYyxDQUFDUztBQUMxQjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNNLFNBQVM4QixLQUFLcEMsT0FBTztJQUN4QixNQUFNLEVBQUVxQyxlQUFlekMsOERBQW9CLEVBQUUwQyxJQUFJLEVBQUVkLE9BQU8sRUFBRXRCLFVBQVUsRUFBRyxHQUFHRjtJQUM1RSxNQUFNLEVBQUUwQixDQUFDLEVBQUVDLENBQUMsRUFBRVksUUFBUSxFQUFFLEdBQUc5Qyx5REFBU0EsQ0FBQzJDLElBQUksQ0FBQ1osbUJBQW1CVSxhQUFhVixVQUFVOUIsOENBQWEsQ0FBQzhCLFVBQVV0QixzQkFBc0JnQyxhQUFhaEMsYUFBYVIsOENBQWEsQ0FBQ1EsYUFBYTtRQUNuTG1DLGNBQWMsT0FBT0EsaUJBQWlCLFlBQ2hDQSxlQUNBMUMseUNBQVEsQ0FBQzBDLGNBQWM1QixLQUFLLENBQUM7UUFDbkMrQixNQUFNO1FBQ04sR0FBSUYsT0FBTztZQUFFRyxTQUFTO1FBQUssSUFBSSxDQUFDLENBQUM7SUFDckM7SUFDQSxPQUFPO1FBQ0hmO1FBQ0FDO1FBQ0FDLFNBQVNXO0lBQ2I7QUFDSjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW9CQyxHQUNNLFNBQVNHLE9BQU8xQyxPQUFPO0lBQzFCLE1BQU0sRUFBRXNDLElBQUksRUFBRWQsT0FBTyxFQUFFcEIsU0FBUyxFQUFFcUIsU0FBUyxFQUFFLEdBQUd6QjtJQUNoRCxPQUFPUCx5REFBU0EsQ0FBQ2lELE1BQU0sQ0FBQ2pCLFdBQVdELG1CQUFtQlUsYUFBYVYsVUFBVTlCLDhDQUFhLENBQUM4QixVQUFVM0IsZ0RBQWUsQ0FBQ08sV0FBVytCLFNBQVMsQ0FBQyxPQUFRRyxPQUFPO1FBQUM7WUFBRUcsU0FBUztZQUFNRCxNQUFNO1FBQUs7S0FBRSxHQUFHLEVBQUU7QUFDak0sRUFDQSxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGF3LXdvcmtzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9QMjU2LmpzPzFlMmMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc2VjcDI1NnIxIH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9wMjU2JztcbmltcG9ydCAqIGFzIEJ5dGVzIGZyb20gJy4vQnl0ZXMuanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbmltcG9ydCAqIGFzIEVudHJvcHkgZnJvbSAnLi9pbnRlcm5hbC9lbnRyb3B5LmpzJztcbmltcG9ydCAqIGFzIFB1YmxpY0tleSBmcm9tICcuL1B1YmxpY0tleS5qcyc7XG4vKiogUmUtZXhwb3J0IG9mIG5vYmxlL2N1cnZlcyBQMjU2IHV0aWxpdGllcy4gKi9cbmV4cG9ydCBjb25zdCBub2JsZSA9IHNlY3AyNTZyMTtcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBQMjU2IEVDRFNBIGtleSBwYWlyIGNvbnNpc3Rpbmcgb2YgYSBwcml2YXRlIGtleSBhbmQgaXRzIGNvcnJlc3BvbmRpbmcgcHVibGljIGtleS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFAyNTYgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB7IHByaXZhdGVLZXksIHB1YmxpY0tleSB9ID0gUDI1Ni5jcmVhdGVLZXlQYWlyKClcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gZ2VuZXJhdGUgdGhlIGtleSBwYWlyLlxuICogQHJldHVybnMgVGhlIGdlbmVyYXRlZCBrZXkgcGFpciBjb250YWluaW5nIGJvdGggcHJpdmF0ZSBhbmQgcHVibGljIGtleXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVLZXlQYWlyKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgYXMgPSAnSGV4JyB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBwcml2YXRlS2V5ID0gcmFuZG9tUHJpdmF0ZUtleSh7IGFzIH0pO1xuICAgIGNvbnN0IHB1YmxpY0tleSA9IGdldFB1YmxpY0tleSh7IHByaXZhdGVLZXkgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJpdmF0ZUtleTogcHJpdmF0ZUtleSxcbiAgICAgICAgcHVibGljS2V5LFxuICAgIH07XG59XG4vKipcbiAqIENvbXB1dGVzIHRoZSBQMjU2IEVDRFNBIHB1YmxpYyBrZXkgZnJvbSBhIHByb3ZpZGVkIHByaXZhdGUga2V5LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgUDI1NiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHB1YmxpY0tleSA9IFAyNTYuZ2V0UHVibGljS2V5KHsgcHJpdmF0ZUtleTogJzB4Li4uJyB9KVxuICogYGBgXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyB0byBjb21wdXRlIHRoZSBwdWJsaWMga2V5LlxuICogQHJldHVybnMgVGhlIGNvbXB1dGVkIHB1YmxpYyBrZXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQdWJsaWNLZXkob3B0aW9ucykge1xuICAgIGNvbnN0IHsgcHJpdmF0ZUtleSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBwb2ludCA9IHNlY3AyNTZyMS5Qcm9qZWN0aXZlUG9pbnQuZnJvbVByaXZhdGVLZXkodHlwZW9mIHByaXZhdGVLZXkgPT09ICdzdHJpbmcnXG4gICAgICAgID8gcHJpdmF0ZUtleS5zbGljZSgyKVxuICAgICAgICA6IEhleC5mcm9tQnl0ZXMocHJpdmF0ZUtleSkuc2xpY2UoMikpO1xuICAgIHJldHVybiBQdWJsaWNLZXkuZnJvbShwb2ludCk7XG59XG4vKipcbiAqIENvbXB1dGVzIGEgc2hhcmVkIHNlY3JldCB1c2luZyBFQ0RIIChFbGxpcHRpYyBDdXJ2ZSBEaWZmaWUtSGVsbG1hbikgYmV0d2VlbiBhIHByaXZhdGUga2V5IGFuZCBhIHB1YmxpYyBrZXkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBQMjU2IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgeyBwcml2YXRlS2V5OiBwcml2YXRlS2V5QSB9ID0gUDI1Ni5jcmVhdGVLZXlQYWlyKClcbiAqIGNvbnN0IHsgcHVibGljS2V5OiBwdWJsaWNLZXlCIH0gPSBQMjU2LmNyZWF0ZUtleVBhaXIoKVxuICpcbiAqIGNvbnN0IHNoYXJlZFNlY3JldCA9IFAyNTYuZ2V0U2hhcmVkU2VjcmV0KHtcbiAqICAgcHJpdmF0ZUtleTogcHJpdmF0ZUtleUEsXG4gKiAgIHB1YmxpY0tleTogcHVibGljS2V5QlxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gY29tcHV0ZSB0aGUgc2hhcmVkIHNlY3JldC5cbiAqIEByZXR1cm5zIFRoZSBjb21wdXRlZCBzaGFyZWQgc2VjcmV0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2hhcmVkU2VjcmV0KG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGFzID0gJ0hleCcsIHByaXZhdGVLZXksIHB1YmxpY0tleSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBwb2ludCA9IHNlY3AyNTZyMS5Qcm9qZWN0aXZlUG9pbnQuZnJvbUhleChQdWJsaWNLZXkudG9IZXgocHVibGljS2V5KS5zbGljZSgyKSk7XG4gICAgY29uc3QgcHJpdmF0ZUtleUhleCA9IHR5cGVvZiBwcml2YXRlS2V5ID09PSAnc3RyaW5nJ1xuICAgICAgICA/IHByaXZhdGVLZXkuc2xpY2UoMilcbiAgICAgICAgOiBIZXguZnJvbUJ5dGVzKHByaXZhdGVLZXkpLnNsaWNlKDIpO1xuICAgIGNvbnN0IHNoYXJlZFBvaW50ID0gcG9pbnQubXVsdGlwbHkoc2VjcDI1NnIxLnV0aWxzLm5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUtleUhleCkpO1xuICAgIGNvbnN0IHNoYXJlZFNlY3JldCA9IHNoYXJlZFBvaW50LnRvUmF3Qnl0ZXModHJ1ZSk7IC8vIGNvbXByZXNzZWQgZm9ybWF0XG4gICAgaWYgKGFzID09PSAnSGV4JylcbiAgICAgICAgcmV0dXJuIEhleC5mcm9tQnl0ZXMoc2hhcmVkU2VjcmV0KTtcbiAgICByZXR1cm4gc2hhcmVkU2VjcmV0O1xufVxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gUDI1NiBFQ0RTQSBwcml2YXRlIGtleS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFAyNTYgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwcml2YXRlS2V5ID0gUDI1Ni5yYW5kb21Qcml2YXRlS2V5KClcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gZ2VuZXJhdGUgdGhlIHByaXZhdGUga2V5LlxuICogQHJldHVybnMgVGhlIGdlbmVyYXRlZCBwcml2YXRlIGtleS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbVByaXZhdGVLZXkob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBhcyA9ICdIZXgnIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJ5dGVzID0gc2VjcDI1NnIxLnV0aWxzLnJhbmRvbVByaXZhdGVLZXkoKTtcbiAgICBpZiAoYXMgPT09ICdIZXgnKVxuICAgICAgICByZXR1cm4gSGV4LmZyb21CeXRlcyhieXRlcyk7XG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuLyoqXG4gKiBSZWNvdmVycyB0aGUgc2lnbmluZyBwdWJsaWMga2V5IGZyb20gdGhlIHNpZ25lZCBwYXlsb2FkIGFuZCBzaWduYXR1cmUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBQMjU2IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gUDI1Ni5zaWduKHsgcGF5bG9hZDogJzB4ZGVhZGJlZWYnLCBwcml2YXRlS2V5OiAnMHguLi4nIH0pXG4gKlxuICogY29uc3QgcHVibGljS2V5ID0gUDI1Ni5yZWNvdmVyUHVibGljS2V5KHsgLy8gWyFjb2RlIGZvY3VzXVxuICogICBwYXlsb2FkOiAnMHhkZWFkYmVlZicsIC8vIFshY29kZSBmb2N1c11cbiAqICAgc2lnbmF0dXJlLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KSAvLyBbIWNvZGUgZm9jdXNdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSByZWNvdmVyeSBvcHRpb25zLlxuICogQHJldHVybnMgVGhlIHJlY292ZXJlZCBwdWJsaWMga2V5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVjb3ZlclB1YmxpY0tleShvcHRpb25zKSB7XG4gICAgY29uc3QgeyBwYXlsb2FkLCBzaWduYXR1cmUgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgeyByLCBzLCB5UGFyaXR5IH0gPSBzaWduYXR1cmU7XG4gICAgY29uc3Qgc2lnbmF0dXJlXyA9IG5ldyBzZWNwMjU2cjEuU2lnbmF0dXJlKEJpZ0ludChyKSwgQmlnSW50KHMpKS5hZGRSZWNvdmVyeUJpdCh5UGFyaXR5KTtcbiAgICBjb25zdCBwYXlsb2FkXyA9IHBheWxvYWQgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gSGV4LmZyb21CeXRlcyhwYXlsb2FkKSA6IHBheWxvYWQ7XG4gICAgY29uc3QgcG9pbnQgPSBzaWduYXR1cmVfLnJlY292ZXJQdWJsaWNLZXkocGF5bG9hZF8uc3Vic3RyaW5nKDIpKTtcbiAgICByZXR1cm4gUHVibGljS2V5LmZyb20ocG9pbnQpO1xufVxuLyoqXG4gKiBTaWducyB0aGUgcGF5bG9hZCB3aXRoIHRoZSBwcm92aWRlZCBwcml2YXRlIGtleSBhbmQgcmV0dXJucyBhIFAyNTYgc2lnbmF0dXJlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgUDI1NiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFAyNTYuc2lnbih7IC8vIFshY29kZSBmb2N1c11cbiAqICAgcGF5bG9hZDogJzB4ZGVhZGJlZWYnLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHByaXZhdGVLZXk6ICcweC4uLicgLy8gWyFjb2RlIGZvY3VzXVxuICogfSkgLy8gWyFjb2RlIGZvY3VzXVxuICogYGBgXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgc2lnbmluZyBvcHRpb25zLlxuICogQHJldHVybnMgVGhlIEVDRFNBIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNpZ24ob3B0aW9ucykge1xuICAgIGNvbnN0IHsgZXh0cmFFbnRyb3B5ID0gRW50cm9weS5leHRyYUVudHJvcHksIGhhc2gsIHBheWxvYWQsIHByaXZhdGVLZXksIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHsgciwgcywgcmVjb3ZlcnkgfSA9IHNlY3AyNTZyMS5zaWduKHBheWxvYWQgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gcGF5bG9hZCA6IEJ5dGVzLmZyb21IZXgocGF5bG9hZCksIHByaXZhdGVLZXkgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gcHJpdmF0ZUtleSA6IEJ5dGVzLmZyb21IZXgocHJpdmF0ZUtleSksIHtcbiAgICAgICAgZXh0cmFFbnRyb3B5OiB0eXBlb2YgZXh0cmFFbnRyb3B5ID09PSAnYm9vbGVhbidcbiAgICAgICAgICAgID8gZXh0cmFFbnRyb3B5XG4gICAgICAgICAgICA6IEhleC5mcm9tKGV4dHJhRW50cm9weSkuc2xpY2UoMiksXG4gICAgICAgIGxvd1M6IHRydWUsXG4gICAgICAgIC4uLihoYXNoID8geyBwcmVoYXNoOiB0cnVlIH0gOiB7fSksXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcixcbiAgICAgICAgcyxcbiAgICAgICAgeVBhcml0eTogcmVjb3ZlcnksXG4gICAgfTtcbn1cbi8qKlxuICogVmVyaWZpZXMgYSBwYXlsb2FkIHdhcyBzaWduZWQgYnkgdGhlIHByb3ZpZGVkIHB1YmxpYyBrZXkuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgUDI1NiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHsgcHJpdmF0ZUtleSwgcHVibGljS2V5IH0gPSBQMjU2LmNyZWF0ZUtleVBhaXIoKVxuICogY29uc3Qgc2lnbmF0dXJlID0gUDI1Ni5zaWduKHsgcGF5bG9hZDogJzB4ZGVhZGJlZWYnLCBwcml2YXRlS2V5IH0pXG4gKlxuICogY29uc3QgdmVyaWZpZWQgPSBQMjU2LnZlcmlmeSh7IC8vIFshY29kZSBmb2N1c11cbiAqICAgcHVibGljS2V5LCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHBheWxvYWQ6ICcweGRlYWRiZWVmJywgLy8gWyFjb2RlIGZvY3VzXVxuICogICBzaWduYXR1cmUsIC8vIFshY29kZSBmb2N1c11cbiAqIH0pIC8vIFshY29kZSBmb2N1c11cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIHZlcmlmaWNhdGlvbiBvcHRpb25zLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgcGF5bG9hZCB3YXMgc2lnbmVkIGJ5IHRoZSBwcm92aWRlZCBwdWJsaWMga2V5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmVyaWZ5KG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGhhc2gsIHBheWxvYWQsIHB1YmxpY0tleSwgc2lnbmF0dXJlIH0gPSBvcHRpb25zO1xuICAgIHJldHVybiBzZWNwMjU2cjEudmVyaWZ5KHNpZ25hdHVyZSwgcGF5bG9hZCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyBwYXlsb2FkIDogQnl0ZXMuZnJvbUhleChwYXlsb2FkKSwgUHVibGljS2V5LnRvSGV4KHB1YmxpY0tleSkuc3Vic3RyaW5nKDIpLCAuLi4oaGFzaCA/IFt7IHByZWhhc2g6IHRydWUsIGxvd1M6IHRydWUgfV0gOiBbXSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UDI1Ni5qcy5tYXAiXSwibmFtZXMiOlsic2VjcDI1NnIxIiwiQnl0ZXMiLCJIZXgiLCJFbnRyb3B5IiwiUHVibGljS2V5Iiwibm9ibGUiLCJjcmVhdGVLZXlQYWlyIiwib3B0aW9ucyIsImFzIiwicHJpdmF0ZUtleSIsInJhbmRvbVByaXZhdGVLZXkiLCJwdWJsaWNLZXkiLCJnZXRQdWJsaWNLZXkiLCJwb2ludCIsIlByb2plY3RpdmVQb2ludCIsImZyb21Qcml2YXRlS2V5Iiwic2xpY2UiLCJmcm9tQnl0ZXMiLCJmcm9tIiwiZ2V0U2hhcmVkU2VjcmV0IiwiZnJvbUhleCIsInRvSGV4IiwicHJpdmF0ZUtleUhleCIsInNoYXJlZFBvaW50IiwibXVsdGlwbHkiLCJ1dGlscyIsIm5vcm1Qcml2YXRlS2V5VG9TY2FsYXIiLCJzaGFyZWRTZWNyZXQiLCJ0b1Jhd0J5dGVzIiwiYnl0ZXMiLCJyZWNvdmVyUHVibGljS2V5IiwicGF5bG9hZCIsInNpZ25hdHVyZSIsInIiLCJzIiwieVBhcml0eSIsInNpZ25hdHVyZV8iLCJTaWduYXR1cmUiLCJCaWdJbnQiLCJhZGRSZWNvdmVyeUJpdCIsInBheWxvYWRfIiwiVWludDhBcnJheSIsInN1YnN0cmluZyIsInNpZ24iLCJleHRyYUVudHJvcHkiLCJoYXNoIiwicmVjb3ZlcnkiLCJsb3dTIiwicHJlaGFzaCIsInZlcmlmeSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/P256.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/PublicKey.js":
/*!************************************************!*\
  !*** ./node_modules/ox/_esm/core/PublicKey.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidCompressedPrefixError: () => (/* binding */ InvalidCompressedPrefixError),\n/* harmony export */   InvalidError: () => (/* binding */ InvalidError),\n/* harmony export */   InvalidPrefixError: () => (/* binding */ InvalidPrefixError),\n/* harmony export */   InvalidSerializedSizeError: () => (/* binding */ InvalidSerializedSizeError),\n/* harmony export */   InvalidUncompressedPrefixError: () => (/* binding */ InvalidUncompressedPrefixError),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   compress: () => (/* binding */ compress),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromBytes: () => (/* binding */ fromBytes),\n/* harmony export */   fromHex: () => (/* binding */ fromHex),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   toHex: () => (/* binding */ toHex),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Json_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Json.js */ \"(ssr)/./node_modules/ox/_esm/core/Json.js\");\n\n\n\n\n/**\n * Asserts that a {@link ox#PublicKey.PublicKey} is valid.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * PublicKey.assert({\n *   prefix: 4,\n *   y: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * })\n * // @error: PublicKey.InvalidError: Value \\`{\"y\":\"1\"}\\` is not a valid public key.\n * // @error: Public key must contain:\n * // @error: - an `x` and `prefix` value (compressed)\n * // @error: - an `x`, `y`, and `prefix` value (uncompressed)\n * ```\n *\n * @param publicKey - The public key object to assert.\n */ function assert(publicKey, options = {}) {\n    const { compressed } = options;\n    const { prefix, x, y } = publicKey;\n    // Uncompressed\n    if (compressed === false || typeof x === \"bigint\" && typeof y === \"bigint\") {\n        if (prefix !== 4) throw new InvalidPrefixError({\n            prefix,\n            cause: new InvalidUncompressedPrefixError()\n        });\n        return;\n    }\n    // Compressed\n    if (compressed === true || typeof x === \"bigint\" && typeof y === \"undefined\") {\n        if (prefix !== 3 && prefix !== 2) throw new InvalidPrefixError({\n            prefix,\n            cause: new InvalidCompressedPrefixError()\n        });\n        return;\n    }\n    // Unknown/invalid\n    throw new InvalidError({\n        publicKey\n    });\n}\n/**\n * Compresses a {@link ox#PublicKey.PublicKey}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n *\n * const compressed = PublicKey.compress(publicKey) // [!code focus]\n * // @log: {\n * // @log:   prefix: 3,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log: }\n * ```\n *\n * @param publicKey - The public key to compress.\n * @returns The compressed public key.\n */ function compress(publicKey) {\n    const { x, y } = publicKey;\n    return {\n        prefix: y % 2n === 0n ? 2 : 3,\n        x\n    };\n}\n/**\n * Instantiates a typed {@link ox#PublicKey.PublicKey} object from a {@link ox#PublicKey.PublicKey}, {@link ox#Bytes.Bytes}, or {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from('0x048318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5')\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @param value - The public key value to instantiate.\n * @returns The instantiated {@link ox#PublicKey.PublicKey}.\n */ function from(value) {\n    const publicKey = (()=>{\n        if (_Hex_js__WEBPACK_IMPORTED_MODULE_0__.validate(value)) return fromHex(value);\n        if (_Bytes_js__WEBPACK_IMPORTED_MODULE_1__.validate(value)) return fromBytes(value);\n        const { prefix, x, y } = value;\n        if (typeof x === \"bigint\" && typeof y === \"bigint\") return {\n            prefix: prefix ?? 0x04,\n            x,\n            y\n        };\n        return {\n            prefix,\n            x\n        };\n    })();\n    assert(publicKey);\n    return publicKey;\n}\n/**\n * Deserializes a {@link ox#PublicKey.PublicKey} from a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.fromBytes(new Uint8Array([128, 3, 131, ...]))\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @param publicKey - The serialized public key.\n * @returns The deserialized public key.\n */ function fromBytes(publicKey) {\n    return fromHex(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromBytes(publicKey));\n}\n/**\n * Deserializes a {@link ox#PublicKey.PublicKey} from a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.fromHex('0x8318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5')\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @example\n * ### Deserializing a Compressed Public Key\n *\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.fromHex('0x038318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed75')\n * // @log: {\n * // @log:   prefix: 3,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log: }\n * ```\n *\n * @param publicKey - The serialized public key.\n * @returns The deserialized public key.\n */ function fromHex(publicKey) {\n    if (publicKey.length !== 132 && publicKey.length !== 130 && publicKey.length !== 68) throw new InvalidSerializedSizeError({\n        publicKey\n    });\n    if (publicKey.length === 130) {\n        const x = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(publicKey, 0, 32));\n        const y = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(publicKey, 32, 64));\n        return {\n            prefix: 4,\n            x,\n            y\n        };\n    }\n    if (publicKey.length === 132) {\n        const prefix = Number(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(publicKey, 0, 1));\n        const x = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(publicKey, 1, 33));\n        const y = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(publicKey, 33, 65));\n        return {\n            prefix,\n            x,\n            y\n        };\n    }\n    const prefix = Number(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(publicKey, 0, 1));\n    const x = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(publicKey, 1, 33));\n    return {\n        prefix,\n        x\n    };\n}\n/**\n * Serializes a {@link ox#PublicKey.PublicKey} to {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n *\n * const bytes = PublicKey.toBytes(publicKey) // [!code focus]\n * // @log: Uint8Array [128, 3, 131, ...]\n * ```\n *\n * @param publicKey - The public key to serialize.\n * @returns The serialized public key.\n */ function toBytes(publicKey, options = {}) {\n    return _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.fromHex(toHex(publicKey, options));\n}\n/**\n * Serializes a {@link ox#PublicKey.PublicKey} to {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n *\n * const hex = PublicKey.toHex(publicKey) // [!code focus]\n * // @log: '0x048318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5'\n * ```\n *\n * @param publicKey - The public key to serialize.\n * @returns The serialized public key.\n */ function toHex(publicKey, options = {}) {\n    assert(publicKey);\n    const { prefix, x, y } = publicKey;\n    const { includePrefix = true } = options;\n    const publicKey_ = _Hex_js__WEBPACK_IMPORTED_MODULE_0__.concat(includePrefix ? _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromNumber(prefix, {\n        size: 1\n    }) : \"0x\", _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromNumber(x, {\n        size: 32\n    }), // If the public key is not compressed, add the y coordinate.\n    typeof y === \"bigint\" ? _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromNumber(y, {\n        size: 32\n    }) : \"0x\");\n    return publicKey_;\n}\n/**\n * Validates a {@link ox#PublicKey.PublicKey}. Returns `true` if valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const valid = PublicKey.validate({\n *   prefix: 4,\n *   y: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * })\n * // @log: false\n * ```\n *\n * @param publicKey - The public key object to assert.\n */ function validate(publicKey, options = {}) {\n    try {\n        assert(publicKey, options);\n        return true;\n    } catch (_error) {\n        return false;\n    }\n}\n/**\n * Thrown when a public key is invalid.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * PublicKey.assert({ y: 1n })\n * // @error: PublicKey.InvalidError: Value `{\"y\":1n}` is not a valid public key.\n * // @error: Public key must contain:\n * // @error: - an `x` and `prefix` value (compressed)\n * // @error: - an `x`, `y`, and `prefix` value (uncompressed)\n * ```\n */ class InvalidError extends _Errors_js__WEBPACK_IMPORTED_MODULE_2__.BaseError {\n    constructor({ publicKey }){\n        super(`Value \\`${_Json_js__WEBPACK_IMPORTED_MODULE_3__.stringify(publicKey)}\\` is not a valid public key.`, {\n            metaMessages: [\n                \"Public key must contain:\",\n                \"- an `x` and `prefix` value (compressed)\",\n                \"- an `x`, `y`, and `prefix` value (uncompressed)\"\n            ]\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"PublicKey.InvalidError\"\n        });\n    }\n}\n/** Thrown when a public key has an invalid prefix. */ class InvalidPrefixError extends _Errors_js__WEBPACK_IMPORTED_MODULE_2__.BaseError {\n    constructor({ prefix, cause }){\n        super(`Prefix \"${prefix}\" is invalid.`, {\n            cause\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"PublicKey.InvalidPrefixError\"\n        });\n    }\n}\n/** Thrown when the public key has an invalid prefix for a compressed public key. */ class InvalidCompressedPrefixError extends _Errors_js__WEBPACK_IMPORTED_MODULE_2__.BaseError {\n    constructor(){\n        super(\"Prefix must be 2 or 3 for compressed public keys.\");\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"PublicKey.InvalidCompressedPrefixError\"\n        });\n    }\n}\n/** Thrown when the public key has an invalid prefix for an uncompressed public key. */ class InvalidUncompressedPrefixError extends _Errors_js__WEBPACK_IMPORTED_MODULE_2__.BaseError {\n    constructor(){\n        super(\"Prefix must be 4 for uncompressed public keys.\");\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"PublicKey.InvalidUncompressedPrefixError\"\n        });\n    }\n}\n/** Thrown when the public key has an invalid serialized size. */ class InvalidSerializedSizeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_2__.BaseError {\n    constructor({ publicKey }){\n        super(`Value \\`${publicKey}\\` is an invalid public key size.`, {\n            metaMessages: [\n                \"Expected: 33 bytes (compressed + prefix), 64 bytes (uncompressed) or 65 bytes (uncompressed + prefix).\",\n                `Received ${_Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.from(publicKey))} bytes.`\n            ]\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"PublicKey.InvalidSerializedSizeError\"\n        });\n    }\n} //# sourceMappingURL=PublicKey.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1B1YmxpY0tleS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvQztBQUNFO0FBQ047QUFDRTtBQUNsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBa0JDLEdBQ00sU0FBU0ksT0FBT0MsU0FBUyxFQUFFQyxVQUFVLENBQUMsQ0FBQztJQUMxQyxNQUFNLEVBQUVDLFVBQVUsRUFBRSxHQUFHRDtJQUN2QixNQUFNLEVBQUVFLE1BQU0sRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUUsR0FBR0w7SUFDekIsZUFBZTtJQUNmLElBQUlFLGVBQWUsU0FDZCxPQUFPRSxNQUFNLFlBQVksT0FBT0MsTUFBTSxVQUFXO1FBQ2xELElBQUlGLFdBQVcsR0FDWCxNQUFNLElBQUlHLG1CQUFtQjtZQUN6Qkg7WUFDQUksT0FBTyxJQUFJQztRQUNmO1FBQ0o7SUFDSjtJQUNBLGFBQWE7SUFDYixJQUFJTixlQUFlLFFBQ2QsT0FBT0UsTUFBTSxZQUFZLE9BQU9DLE1BQU0sYUFBYztRQUNyRCxJQUFJRixXQUFXLEtBQUtBLFdBQVcsR0FDM0IsTUFBTSxJQUFJRyxtQkFBbUI7WUFDekJIO1lBQ0FJLE9BQU8sSUFBSUU7UUFDZjtRQUNKO0lBQ0o7SUFDQSxrQkFBa0I7SUFDbEIsTUFBTSxJQUFJQyxhQUFhO1FBQUVWO0lBQVU7QUFDdkM7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXNCQyxHQUNNLFNBQVNXLFNBQVNYLFNBQVM7SUFDOUIsTUFBTSxFQUFFSSxDQUFDLEVBQUVDLENBQUMsRUFBRSxHQUFHTDtJQUNqQixPQUFPO1FBQ0hHLFFBQVFFLElBQUksRUFBRSxLQUFLLEVBQUUsR0FBRyxJQUFJO1FBQzVCRDtJQUNKO0FBQ0o7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FtQ0MsR0FDTSxTQUFTUSxLQUFLQyxLQUFLO0lBQ3RCLE1BQU1iLFlBQVksQ0FBQztRQUNmLElBQUlILDZD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LENBQUMsRUFBRTtZQUMzRGlDLGNBQWM7Z0JBQ1Y7Z0JBQ0EsQ0FBQyxTQUFTLEVBQUVwQyx5Q0FBUSxDQUFDQSx5Q0FBUSxDQUFDRyxZQUFZLE9BQU8sQ0FBQzthQUNyRDtRQUNMO1FBQ0FrQyxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLFFBQVE7WUFDaENDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1Z6QixPQUFPO1FBQ1g7SUFDSjtBQUNKLEVBQ0EscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xhdy13b3Jrcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvUHVibGljS2V5LmpzPzM0Y2IiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQnl0ZXMgZnJvbSAnLi9CeXRlcy5qcyc7XG5pbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSAnLi9FcnJvcnMuanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbmltcG9ydCAqIGFzIEpzb24gZnJvbSAnLi9Kc29uLmpzJztcbi8qKlxuICogQXNzZXJ0cyB0aGF0IGEge0BsaW5rIG94I1B1YmxpY0tleS5QdWJsaWNLZXl9IGlzIHZhbGlkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgUHVibGljS2V5IH0gZnJvbSAnb3gnXG4gKlxuICogUHVibGljS2V5LmFzc2VydCh7XG4gKiAgIHByZWZpeDogNCxcbiAqICAgeTogNDk3ODI3NTMzNDg0NjI0OTQxOTk4MjM3MTI3MDAwMDQ1NTIzOTQ0MjU3MTkwMTQ0NTg5MTg4NzE0NTIzMjk3NzQ5MTA0NTA2MDc4MDduLFxuICogfSlcbiAqIC8vIEBlcnJvcjogUHVibGljS2V5LkludmFsaWRFcnJvcjogVmFsdWUgXFxge1wieVwiOlwiMVwifVxcYCBpcyBub3QgYSB2YWxpZCBwdWJsaWMga2V5LlxuICogLy8gQGVycm9yOiBQdWJsaWMga2V5IG11c3QgY29udGFpbjpcbiAqIC8vIEBlcnJvcjogLSBhbiBgeGAgYW5kIGBwcmVmaXhgIHZhbHVlIChjb21wcmVzc2VkKVxuICogLy8gQGVycm9yOiAtIGFuIGB4YCwgYHlgLCBhbmQgYHByZWZpeGAgdmFsdWUgKHVuY29tcHJlc3NlZClcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBwdWJsaWNLZXkgLSBUaGUgcHVibGljIGtleSBvYmplY3QgdG8gYXNzZXJ0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0KHB1YmxpY0tleSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBjb21wcmVzc2VkIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHsgcHJlZml4LCB4LCB5IH0gPSBwdWJsaWNLZXk7XG4gICAgLy8gVW5jb21wcmVzc2VkXG4gICAgaWYgKGNvbXByZXNzZWQgPT09IGZhbHNlIHx8XG4gICAgICAgICh0eXBlb2YgeCA9PT0gJ2JpZ2ludCcgJiYgdHlwZW9mIHkgPT09ICdiaWdpbnQnKSkge1xuICAgICAgICBpZiAocHJlZml4ICE9PSA0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRQcmVmaXhFcnJvcih7XG4gICAgICAgICAgICAgICAgcHJlZml4LFxuICAgICAgICAgICAgICAgIGNhdXNlOiBuZXcgSW52YWxpZFVuY29tcHJlc3NlZFByZWZpeEVycm9yKCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBDb21wcmVzc2VkXG4gICAgaWYgKGNvbXByZXNzZWQgPT09IHRydWUgfHxcbiAgICAgICAgKHR5cGVvZiB4ID09PSAnYmlnaW50JyAmJiB0eXBlb2YgeSA9PT0gJ3VuZGVmaW5lZCcpKSB7XG4gICAgICAgIGlmIChwcmVmaXggIT09IDMgJiYgcHJlZml4ICE9PSAyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRQcmVmaXhFcnJvcih7XG4gICAgICAgICAgICAgICAgcHJlZml4LFxuICAgICAgICAgICAgICAgIGNhdXNlOiBuZXcgSW52YWxpZENvbXByZXNzZWRQcmVmaXhFcnJvcigpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gVW5rbm93bi9pbnZhbGlkXG4gICAgdGhyb3cgbmV3IEludmFsaWRFcnJvcih7IHB1YmxpY0tleSB9KTtcbn1cbi8qKlxuICogQ29tcHJlc3NlcyBhIHtAbGluayBveCNQdWJsaWNLZXkuUHVibGljS2V5fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFB1YmxpY0tleSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHB1YmxpY0tleSA9IFB1YmxpY0tleS5mcm9tKHtcbiAqICAgcHJlZml4OiA0LFxuICogICB4OiA1OTI5NTk2MjgwMTExNzQ3Mjg1OTQ1NzkwODkxOTk0MTQ3MzM4OTM4MDI4NDEzMjIyNDg2MTgzOTgyMDc0NzcyOTU2NTIwMDE0OTg3N24sXG4gKiAgIHk6IDI0MDk5NjkxMjA5OTk2MjkwOTI1MjU5MzY3Njc4NTQwMjI3MTk4MjM1NDg0NTkzMzg5NDcwMzMwNjA1NjQxMDAzNTAwMjM4MDg4ODY5bixcbiAqIH0pXG4gKlxuICogY29uc3QgY29tcHJlc3NlZCA9IFB1YmxpY0tleS5jb21wcmVzcyhwdWJsaWNLZXkpIC8vIFshY29kZSBmb2N1c11cbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgcHJlZml4OiAzLFxuICogLy8gQGxvZzogICB4OiA1OTI5NTk2MjgwMTExNzQ3Mjg1OTQ1NzkwODkxOTk0MTQ3MzM4OTM4MDI4NDEzMjIyNDg2MTgzOTgyMDc0NzcyOTU2NTIwMDE0OTg3N24sXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gcHVibGljS2V5IC0gVGhlIHB1YmxpYyBrZXkgdG8gY29tcHJlc3MuXG4gKiBAcmV0dXJucyBUaGUgY29tcHJlc3NlZCBwdWJsaWMga2V5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcHJlc3MocHVibGljS2V5KSB7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBwdWJsaWNLZXk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJlZml4OiB5ICUgMm4gPT09IDBuID8gMiA6IDMsXG4gICAgICAgIHgsXG4gICAgfTtcbn1cbi8qKlxuICogSW5zdGFudGlhdGVzIGEgdHlwZWQge0BsaW5rIG94I1B1YmxpY0tleS5QdWJsaWNLZXl9IG9iamVjdCBmcm9tIGEge0BsaW5rIG94I1B1YmxpY0tleS5QdWJsaWNLZXl9LCB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LCBvciB7QGxpbmsgb3gjSGV4LkhleH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBQdWJsaWNLZXkgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwdWJsaWNLZXkgPSBQdWJsaWNLZXkuZnJvbSh7XG4gKiAgIHByZWZpeDogNCxcbiAqICAgeDogNTkyOTU5NjI4MDExMTc0NzI4NTk0NTc5MDg5MTk5NDE0NzMzODkzODAyODQxMzIyMjQ4NjE4Mzk4MjA3NDc3Mjk1NjUyMDAxNDk4NzduLFxuICogICB5OiAyNDA5OTY5MTIwOTk5NjI5MDkyNTI1OTM2NzY3ODU0MDIyNzE5ODIzNTQ4NDU5MzM4OTQ3MDMzMDYwNTY0MTAwMzUwMDIzODA4ODg2OW4sXG4gKiB9KVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICBwcmVmaXg6IDQsXG4gKiAvLyBAbG9nOiAgIHg6IDU5Mjk1OTYyODAxMTE3NDcyODU5NDU3OTA4OTE5OTQxNDczMzg5MzgwMjg0MTMyMjI0ODYxODM5ODIwNzQ3NzI5NTY1MjAwMTQ5ODc3bixcbiAqIC8vIEBsb2c6ICAgeTogMjQwOTk2OTEyMDk5OTYyOTA5MjUyNTkzNjc2Nzg1NDAyMjcxOTgyMzU0ODQ1OTMzODk0NzAzMzA2MDU2NDEwMDM1MDAyMzgwODg4NjluLFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBGcm9tIFNlcmlhbGl6ZWRcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgUHVibGljS2V5IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgcHVibGljS2V5ID0gUHVibGljS2V5LmZyb20oJzB4MDQ4MzE4NTM1YjU0MTA1ZDRhN2FhZTYwYzA4ZmM0NWY5Njg3MTgxYjRmZGZjNjI1YmQxYTc1M2ZhNzM5N2ZlZDc1MzU0N2YxMWNhODY5NjY0NmYyZjNhY2IwOGUzMTAxNmFmYWMyM2U2MzBjNWQxMWY1OWY2MWZlZjU3YjBkMmFhNScpXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIHByZWZpeDogNCxcbiAqIC8vIEBsb2c6ICAgeDogNTkyOTU5NjI4MDExMTc0NzI4NTk0NTc5MDg5MTk5NDE0NzMzODkzODAyODQxMzIyMjQ4NjE4Mzk4MjA3NDc3Mjk1NjUyMDAxNDk4NzduLFxuICogLy8gQGxvZzogICB5OiAyNDA5OTY5MTIwOTk5NjI5MDkyNTI1OTM2NzY3ODU0MDIyNzE5ODIzNTQ4NDU5MzM4OTQ3MDMzMDYwNTY0MTAwMzUwMDIzODA4ODg2OW4sXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgcHVibGljIGtleSB2YWx1ZSB0byBpbnN0YW50aWF0ZS5cbiAqIEByZXR1cm5zIFRoZSBpbnN0YW50aWF0ZWQge0BsaW5rIG94I1B1YmxpY0tleS5QdWJsaWNLZXl9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbSh2YWx1ZSkge1xuICAgIGNvbnN0IHB1YmxpY0tleSA9ICgoKSA9PiB7XG4gICAgICAgIGlmIChIZXgudmFsaWRhdGUodmFsdWUpKVxuICAgICAgICAgICAgcmV0dXJuIGZyb21IZXgodmFsdWUpO1xuICAgICAgICBpZiAoQnl0ZXMudmFsaWRhdGUodmFsdWUpKVxuICAgICAgICAgICAgcmV0dXJuIGZyb21CeXRlcyh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4LCB4LCB5IH0gPSB2YWx1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiB4ID09PSAnYmlnaW50JyAmJiB0eXBlb2YgeSA9PT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICByZXR1cm4geyBwcmVmaXg6IHByZWZpeCA/PyAweDA0LCB4LCB5IH07XG4gICAgICAgIHJldHVybiB7IHByZWZpeCwgeCB9O1xuICAgIH0pKCk7XG4gICAgYXNzZXJ0KHB1YmxpY0tleSk7XG4gICAgcmV0dXJuIHB1YmxpY0tleTtcbn1cbi8qKlxuICogRGVzZXJpYWxpemVzIGEge0BsaW5rIG94I1B1YmxpY0tleS5QdWJsaWNLZXl9IGZyb20gYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBQdWJsaWNLZXkgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwdWJsaWNLZXkgPSBQdWJsaWNLZXkuZnJvbUJ5dGVzKG5ldyBVaW50OEFycmF5KFsxMjgsIDMsIDEzMSwgLi4uXSkpXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIHByZWZpeDogNCxcbiAqIC8vIEBsb2c6ICAgeDogNTkyOTU5NjI4MDExMTc0NzI4NTk0NTc5MDg5MTk5NDE0NzMzODkzODAyODQxMzIyMjQ4NjE4Mzk4MjA3NDc3Mjk1NjUyMDAxNDk4NzduLFxuICogLy8gQGxvZzogICB5OiAyNDA5OTY5MTIwOTk5NjI5MDkyNTI1OTM2NzY3ODU0MDIyNzE5ODIzNTQ4NDU5MzM4OTQ3MDMzMDYwNTY0MTAwMzUwMDIzODA4ODg2OW4sXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gcHVibGljS2V5IC0gVGhlIHNlcmlhbGl6ZWQgcHVibGljIGtleS5cbiAqIEByZXR1cm5zIFRoZSBkZXNlcmlhbGl6ZWQgcHVibGljIGtleS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21CeXRlcyhwdWJsaWNLZXkpIHtcbiAgICByZXR1cm4gZnJvbUhleChIZXguZnJvbUJ5dGVzKHB1YmxpY0tleSkpO1xufVxuLyoqXG4gKiBEZXNlcmlhbGl6ZXMgYSB7QGxpbmsgb3gjUHVibGljS2V5LlB1YmxpY0tleX0gZnJvbSBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFB1YmxpY0tleSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHB1YmxpY0tleSA9IFB1YmxpY0tleS5mcm9tSGV4KCcweDgzMTg1MzViNTQxMDVkNGE3YWFlNjBjMDhmYzQ1Zjk2ODcxODFiNGZkZmM2MjViZDFhNzUzZmE3Mzk3ZmVkNzUzNTQ3ZjExY2E4Njk2NjQ2ZjJmM2FjYjA4ZTMxMDE2YWZhYzIzZTYzMGM1ZDExZjU5ZjYxZmVmNTdiMGQyYWE1JylcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgcHJlZml4OiA0LFxuICogLy8gQGxvZzogICB4OiA1OTI5NTk2MjgwMTExNzQ3Mjg1OTQ1NzkwODkxOTk0MTQ3MzM4OTM4MDI4NDEzMjIyNDg2MTgzOTgyMDc0NzcyOTU2NTIwMDE0OTg3N24sXG4gKiAvLyBAbG9nOiAgIHk6IDI0MDk5NjkxMjA5OTk2MjkwOTI1MjU5MzY3Njc4NTQwMjI3MTk4MjM1NDg0NTkzMzg5NDcwMzMwNjA1NjQxMDAzNTAwMjM4MDg4ODY5bixcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgRGVzZXJpYWxpemluZyBhIENvbXByZXNzZWQgUHVibGljIEtleVxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBQdWJsaWNLZXkgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwdWJsaWNLZXkgPSBQdWJsaWNLZXkuZnJvbUhleCgnMHgwMzgzMTg1MzViNTQxMDVkNGE3YWFlNjBjMDhmYzQ1Zjk2ODcxODFiNGZkZmM2MjViZDFhNzUzZmE3Mzk3ZmVkNzUnKVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICBwcmVmaXg6IDMsXG4gKiAvLyBAbG9nOiAgIHg6IDU5Mjk1OTYyODAxMTE3NDcyODU5NDU3OTA4OTE5OTQxNDczMzg5MzgwMjg0MTMyMjI0ODYxODM5ODIwNzQ3NzI5NTY1MjAwMTQ5ODc3bixcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBwdWJsaWNLZXkgLSBUaGUgc2VyaWFsaXplZCBwdWJsaWMga2V5LlxuICogQHJldHVybnMgVGhlIGRlc2VyaWFsaXplZCBwdWJsaWMga2V5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUhleChwdWJsaWNLZXkpIHtcbiAgICBpZiAocHVibGljS2V5Lmxlbmd0aCAhPT0gMTMyICYmXG4gICAgICAgIHB1YmxpY0tleS5sZW5ndGggIT09IDEzMCAmJlxuICAgICAgICBwdWJsaWNLZXkubGVuZ3RoICE9PSA2OClcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRTZXJpYWxpemVkU2l6ZUVycm9yKHsgcHVibGljS2V5IH0pO1xuICAgIGlmIChwdWJsaWNLZXkubGVuZ3RoID09PSAxMzApIHtcbiAgICAgICAgY29uc3QgeCA9IEJpZ0ludChIZXguc2xpY2UocHVibGljS2V5LCAwLCAzMikpO1xuICAgICAgICBjb25zdCB5ID0gQmlnSW50KEhleC5zbGljZShwdWJsaWNLZXksIDMyLCA2NCkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJlZml4OiA0LFxuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIHksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChwdWJsaWNLZXkubGVuZ3RoID09PSAxMzIpIHtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gTnVtYmVyKEhleC5zbGljZShwdWJsaWNLZXksIDAsIDEpKTtcbiAgICAgICAgY29uc3QgeCA9IEJpZ0ludChIZXguc2xpY2UocHVibGljS2V5LCAxLCAzMykpO1xuICAgICAgICBjb25zdCB5ID0gQmlnSW50KEhleC5zbGljZShwdWJsaWNLZXksIDMzLCA2NSkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJlZml4LFxuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIHksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHByZWZpeCA9IE51bWJlcihIZXguc2xpY2UocHVibGljS2V5LCAwLCAxKSk7XG4gICAgY29uc3QgeCA9IEJpZ0ludChIZXguc2xpY2UocHVibGljS2V5LCAxLCAzMykpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHByZWZpeCxcbiAgICAgICAgeCxcbiAgICB9O1xufVxuLyoqXG4gKiBTZXJpYWxpemVzIGEge0BsaW5rIG94I1B1YmxpY0tleS5QdWJsaWNLZXl9IHRvIHtAbGluayBveCNCeXRlcy5CeXRlc30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBQdWJsaWNLZXkgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwdWJsaWNLZXkgPSBQdWJsaWNLZXkuZnJvbSh7XG4gKiAgIHByZWZpeDogNCxcbiAqICAgeDogNTkyOTU5NjI4MDExMTc0NzI4NTk0NTc5MDg5MTk5NDE0NzMzODkzODAyODQxMzIyMjQ4NjE4Mzk4MjA3NDc3Mjk1NjUyMDAxNDk4NzduLFxuICogICB5OiAyNDA5OTY5MTIwOTk5NjI5MDkyNTI1OTM2NzY3ODU0MDIyNzE5ODIzNTQ4NDU5MzM4OTQ3MDMzMDYwNTY0MTAwMzUwMDIzODA4ODg2OW4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IGJ5dGVzID0gUHVibGljS2V5LnRvQnl0ZXMocHVibGljS2V5KSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5IFsxMjgsIDMsIDEzMSwgLi4uXVxuICogYGBgXG4gKlxuICogQHBhcmFtIHB1YmxpY0tleSAtIFRoZSBwdWJsaWMga2V5IHRvIHNlcmlhbGl6ZS5cbiAqIEByZXR1cm5zIFRoZSBzZXJpYWxpemVkIHB1YmxpYyBrZXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0J5dGVzKHB1YmxpY0tleSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIEJ5dGVzLmZyb21IZXgodG9IZXgocHVibGljS2V5LCBvcHRpb25zKSk7XG59XG4vKipcbiAqIFNlcmlhbGl6ZXMgYSB7QGxpbmsgb3gjUHVibGljS2V5LlB1YmxpY0tleX0gdG8ge0BsaW5rIG94I0hleC5IZXh9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgUHVibGljS2V5IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgcHVibGljS2V5ID0gUHVibGljS2V5LmZyb20oe1xuICogICBwcmVmaXg6IDQsXG4gKiAgIHg6IDU5Mjk1OTYyODAxMTE3NDcyODU5NDU3OTA4OTE5OTQxNDczMzg5MzgwMjg0MTMyMjI0ODYxODM5ODIwNzQ3NzI5NTY1MjAwMTQ5ODc3bixcbiAqICAgeTogMjQwOTk2OTEyMDk5OTYyOTA5MjUyNTkzNjc2Nzg1NDAyMjcxOTgyMzU0ODQ1OTMzODk0NzAzMzA2MDU2NDEwMDM1MDAyMzgwODg4NjluLFxuICogfSlcbiAqXG4gKiBjb25zdCBoZXggPSBQdWJsaWNLZXkudG9IZXgocHVibGljS2V5KSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyBAbG9nOiAnMHgwNDgzMTg1MzViNTQxMDVkNGE3YWFlNjBjMDhmYzQ1Zjk2ODcxODFiNGZkZmM2MjViZDFhNzUzZmE3Mzk3ZmVkNzUzNTQ3ZjExY2E4Njk2NjQ2ZjJmM2FjYjA4ZTMxMDE2YWZhYzIzZTYzMGM1ZDExZjU5ZjYxZmVmNTdiMGQyYWE1J1xuICogYGBgXG4gKlxuICogQHBhcmFtIHB1YmxpY0tleSAtIFRoZSBwdWJsaWMga2V5IHRvIHNlcmlhbGl6ZS5cbiAqIEByZXR1cm5zIFRoZSBzZXJpYWxpemVkIHB1YmxpYyBrZXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0hleChwdWJsaWNLZXksIG9wdGlvbnMgPSB7fSkge1xuICAgIGFzc2VydChwdWJsaWNLZXkpO1xuICAgIGNvbnN0IHsgcHJlZml4LCB4LCB5IH0gPSBwdWJsaWNLZXk7XG4gICAgY29uc3QgeyBpbmNsdWRlUHJlZml4ID0gdHJ1ZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBwdWJsaWNLZXlfID0gSGV4LmNvbmNhdChpbmNsdWRlUHJlZml4ID8gSGV4LmZyb21OdW1iZXIocHJlZml4LCB7IHNpemU6IDEgfSkgOiAnMHgnLCBIZXguZnJvbU51bWJlcih4LCB7IHNpemU6IDMyIH0pLCBcbiAgICAvLyBJZiB0aGUgcHVibGljIGtleSBpcyBub3QgY29tcHJlc3NlZCwgYWRkIHRoZSB5IGNvb3JkaW5hdGUuXG4gICAgdHlwZW9mIHkgPT09ICdiaWdpbnQnID8gSGV4LmZyb21OdW1iZXIoeSwgeyBzaXplOiAzMiB9KSA6ICcweCcpO1xuICAgIHJldHVybiBwdWJsaWNLZXlfO1xufVxuLyoqXG4gKiBWYWxpZGF0ZXMgYSB7QGxpbmsgb3gjUHVibGljS2V5LlB1YmxpY0tleX0uIFJldHVybnMgYHRydWVgIGlmIHZhbGlkLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFB1YmxpY0tleSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHZhbGlkID0gUHVibGljS2V5LnZhbGlkYXRlKHtcbiAqICAgcHJlZml4OiA0LFxuICogICB5OiA0OTc4Mjc1MzM0ODQ2MjQ5NDE5OTgyMzcxMjcwMDAwNDU1MjM5NDQyNTcxOTAxNDQ1ODkxODg3MTQ1MjMyOTc3NDkxMDQ1MDYwNzgwN24sXG4gKiB9KVxuICogLy8gQGxvZzogZmFsc2VcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBwdWJsaWNLZXkgLSBUaGUgcHVibGljIGtleSBvYmplY3QgdG8gYXNzZXJ0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGUocHVibGljS2V5LCBvcHRpb25zID0ge30pIHtcbiAgICB0cnkge1xuICAgICAgICBhc3NlcnQocHVibGljS2V5LCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3duIHdoZW4gYSBwdWJsaWMga2V5IGlzIGludmFsaWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBQdWJsaWNLZXkgfSBmcm9tICdveCdcbiAqXG4gKiBQdWJsaWNLZXkuYXNzZXJ0KHsgeTogMW4gfSlcbiAqIC8vIEBlcnJvcjogUHVibGljS2V5LkludmFsaWRFcnJvcjogVmFsdWUgYHtcInlcIjoxbn1gIGlzIG5vdCBhIHZhbGlkIHB1YmxpYyBrZXkuXG4gKiAvLyBAZXJyb3I6IFB1YmxpYyBrZXkgbXVzdCBjb250YWluOlxuICogLy8gQGVycm9yOiAtIGFuIGB4YCBhbmQgYHByZWZpeGAgdmFsdWUgKGNvbXByZXNzZWQpXG4gKiAvLyBAZXJyb3I6IC0gYW4gYHhgLCBgeWAsIGFuZCBgcHJlZml4YCB2YWx1ZSAodW5jb21wcmVzc2VkKVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHB1YmxpY0tleSB9KSB7XG4gICAgICAgIHN1cGVyKGBWYWx1ZSBcXGAke0pzb24uc3RyaW5naWZ5KHB1YmxpY0tleSl9XFxgIGlzIG5vdCBhIHZhbGlkIHB1YmxpYyBrZXkuYCwge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXG4gICAgICAgICAgICAgICAgJ1B1YmxpYyBrZXkgbXVzdCBjb250YWluOicsXG4gICAgICAgICAgICAgICAgJy0gYW4gYHhgIGFuZCBgcHJlZml4YCB2YWx1ZSAoY29tcHJlc3NlZCknLFxuICAgICAgICAgICAgICAgICctIGFuIGB4YCwgYHlgLCBhbmQgYHByZWZpeGAgdmFsdWUgKHVuY29tcHJlc3NlZCknLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdQdWJsaWNLZXkuSW52YWxpZEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKiogVGhyb3duIHdoZW4gYSBwdWJsaWMga2V5IGhhcyBhbiBpbnZhbGlkIHByZWZpeC4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkUHJlZml4RXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHByZWZpeCwgY2F1c2UgfSkge1xuICAgICAgICBzdXBlcihgUHJlZml4IFwiJHtwcmVmaXh9XCIgaXMgaW52YWxpZC5gLCB7XG4gICAgICAgICAgICBjYXVzZSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdQdWJsaWNLZXkuSW52YWxpZFByZWZpeEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKiogVGhyb3duIHdoZW4gdGhlIHB1YmxpYyBrZXkgaGFzIGFuIGludmFsaWQgcHJlZml4IGZvciBhIGNvbXByZXNzZWQgcHVibGljIGtleS4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkQ29tcHJlc3NlZFByZWZpeEVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdQcmVmaXggbXVzdCBiZSAyIG9yIDMgZm9yIGNvbXByZXNzZWQgcHVibGljIGtleXMuJyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdQdWJsaWNLZXkuSW52YWxpZENvbXByZXNzZWRQcmVmaXhFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqIFRocm93biB3aGVuIHRoZSBwdWJsaWMga2V5IGhhcyBhbiBpbnZhbGlkIHByZWZpeCBmb3IgYW4gdW5jb21wcmVzc2VkIHB1YmxpYyBrZXkuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZFVuY29tcHJlc3NlZFByZWZpeEVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdQcmVmaXggbXVzdCBiZSA0IGZvciB1bmNvbXByZXNzZWQgcHVibGljIGtleXMuJyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdQdWJsaWNLZXkuSW52YWxpZFVuY29tcHJlc3NlZFByZWZpeEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKiogVGhyb3duIHdoZW4gdGhlIHB1YmxpYyBrZXkgaGFzIGFuIGludmFsaWQgc2VyaWFsaXplZCBzaXplLiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRTZXJpYWxpemVkU2l6ZUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBwdWJsaWNLZXkgfSkge1xuICAgICAgICBzdXBlcihgVmFsdWUgXFxgJHtwdWJsaWNLZXl9XFxgIGlzIGFuIGludmFsaWQgcHVibGljIGtleSBzaXplLmAsIHtcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogW1xuICAgICAgICAgICAgICAgICdFeHBlY3RlZDogMzMgYnl0ZXMgKGNvbXByZXNzZWQgKyBwcmVmaXgpLCA2NCBieXRlcyAodW5jb21wcmVzc2VkKSBvciA2NSBieXRlcyAodW5jb21wcmVzc2VkICsgcHJlZml4KS4nLFxuICAgICAgICAgICAgICAgIGBSZWNlaXZlZCAke0hleC5zaXplKEhleC5mcm9tKHB1YmxpY0tleSkpfSBieXRlcy5gLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdQdWJsaWNLZXkuSW52YWxpZFNlcmlhbGl6ZWRTaXplRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVB1YmxpY0tleS5qcy5tYXAiXSwibmFtZXMiOlsiQnl0ZXMiLCJFcnJvcnMiLCJIZXgiLCJKc29uIiwiYXNzZXJ0IiwicHVibGljS2V5Iiwib3B0aW9ucyIsImNvbXByZXNzZWQiLCJwcmVmaXgiLCJ4IiwieSIsIkludmFsaWRQcmVmaXhFcnJvciIsImNhdXNlIiwiSW52YWxpZFVuY29tcHJlc3NlZFByZWZpeEVycm9yIiwiSW52YWxpZENvbXByZXNzZWRQcmVmaXhFcnJvciIsIkludmFsaWRFcnJvciIsImNvbXByZXNzIiwiZnJvbSIsInZhbHVlIiwidmFsaWRhdGUiLCJmcm9tSGV4IiwiZnJvbUJ5dGVzIiwibGVuZ3RoIiwiSW52YWxpZFNlcmlhbGl6ZWRTaXplRXJyb3IiLCJCaWdJbnQiLCJzbGljZSIsIk51bWJlciIsInRvQnl0ZXMiLCJ0b0hleCIsImluY2x1ZGVQcmVmaXgiLCJwdWJsaWNLZXlfIiwiY29uY2F0IiwiZnJvbU51bWJlciIsInNpemUiLCJfZXJyb3IiLCJCYXNlRXJyb3IiLCJjb25zdHJ1Y3RvciIsInN0cmluZ2lmeSIsIm1ldGFNZXNzYWdlcyIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/PublicKey.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Rlp.js":
/*!******************************************!*\
  !*** ./node_modules/ox/_esm/core/Rlp.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeRlpCursor: () => (/* binding */ decodeRlpCursor),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromBytes: () => (/* binding */ fromBytes),\n/* harmony export */   fromHex: () => (/* binding */ fromHex),\n/* harmony export */   readLength: () => (/* binding */ readLength),\n/* harmony export */   readList: () => (/* binding */ readList),\n/* harmony export */   to: () => (/* binding */ to),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   toHex: () => (/* binding */ toHex)\n/* harmony export */ });\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _internal_cursor_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/cursor.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/cursor.js\");\n\n\n\n\n/**\n * Decodes a Recursive-Length Prefix (RLP) value into a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Rlp } from 'ox'\n * Rlp.toBytes('0x8b68656c6c6f20776f726c64')\n * // Uint8Array([139, 104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100])\n * ```\n *\n * @param value - The value to decode.\n * @returns The decoded {@link ox#Bytes.Bytes} value.\n */ function toBytes(value) {\n    return to(value, \"Bytes\");\n}\n/**\n * Decodes a Recursive-Length Prefix (RLP) value into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Rlp } from 'ox'\n * Rlp.toHex('0x8b68656c6c6f20776f726c64')\n * // 0x68656c6c6f20776f726c64\n * ```\n *\n * @param value - The value to decode.\n * @returns The decoded {@link ox#Hex.Hex} value.\n */ function toHex(value) {\n    return to(value, \"Hex\");\n}\n/////////////////////////////////////////////////////////////////////////////////\n// Internal\n/////////////////////////////////////////////////////////////////////////////////\n/** @internal */ function to(value, to) {\n    const to_ = to ?? (typeof value === \"string\" ? \"Hex\" : \"Bytes\");\n    const bytes = (()=>{\n        if (typeof value === \"string\") {\n            if (value.length > 3 && value.length % 2 !== 0) throw new _Hex_js__WEBPACK_IMPORTED_MODULE_0__.InvalidLengthError(value);\n            return _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.fromHex(value);\n        }\n        return value;\n    })();\n    const cursor = _internal_cursor_js__WEBPACK_IMPORTED_MODULE_2__.create(bytes, {\n        recursiveReadLimit: Number.POSITIVE_INFINITY\n    });\n    const result = decodeRlpCursor(cursor, to_);\n    return result;\n}\n/** @internal */ /** @internal */ function decodeRlpCursor(cursor, to = \"Hex\") {\n    if (cursor.bytes.length === 0) return to === \"Hex\" ? _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromBytes(cursor.bytes) : cursor.bytes;\n    const prefix = cursor.readByte();\n    if (prefix < 0x80) cursor.decrementPosition(1);\n    // bytes\n    if (prefix < 0xc0) {\n        const length = readLength(cursor, prefix, 0x80);\n        const bytes = cursor.readBytes(length);\n        return to === \"Hex\" ? _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromBytes(bytes) : bytes;\n    }\n    // list\n    const length = readLength(cursor, prefix, 0xc0);\n    return readList(cursor, length, to);\n}\n/** @internal */ function readLength(cursor, prefix, offset) {\n    if (offset === 0x80 && prefix < 0x80) return 1;\n    if (prefix <= offset + 55) return prefix - offset;\n    if (prefix === offset + 55 + 1) return cursor.readUint8();\n    if (prefix === offset + 55 + 2) return cursor.readUint16();\n    if (prefix === offset + 55 + 3) return cursor.readUint24();\n    if (prefix === offset + 55 + 4) return cursor.readUint32();\n    throw new _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError(\"Invalid RLP prefix\");\n}\n/** @internal */ function readList(cursor, length, to) {\n    const position = cursor.position;\n    const value = [];\n    while(cursor.position - position < length)value.push(decodeRlpCursor(cursor, to));\n    return value;\n}\n/**\n * Encodes a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value into a Recursive-Length Prefix (RLP) value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Rlp } from 'ox'\n *\n * Rlp.from('0x68656c6c6f20776f726c64', { as: 'Hex' })\n * // @log: 0x8b68656c6c6f20776f726c64\n *\n * Rlp.from(Bytes.from([139, 104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100]), { as: 'Bytes' })\n * // @log: Uint8Array([104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100])\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value to encode.\n * @param options - Options.\n * @returns The RLP value.\n */ function from(value, options) {\n    const { as } = options;\n    const encodable = getEncodable(value);\n    const cursor = _internal_cursor_js__WEBPACK_IMPORTED_MODULE_2__.create(new Uint8Array(encodable.length));\n    encodable.encode(cursor);\n    if (as === \"Hex\") return _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromBytes(cursor.bytes);\n    return cursor.bytes;\n}\n/**\n * Encodes a {@link ox#Bytes.Bytes} value into a Recursive-Length Prefix (RLP) value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Rlp } from 'ox'\n *\n * Rlp.fromBytes(Bytes.from([139, 104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100]))\n * // @log: Uint8Array([104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100])\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} value to encode.\n * @param options - Options.\n * @returns The RLP value.\n */ function fromBytes(bytes, options = {}) {\n    const { as = \"Bytes\" } = options;\n    return from(bytes, {\n        as\n    });\n}\n/**\n * Encodes a {@link ox#Hex.Hex} value into a Recursive-Length Prefix (RLP) value.\n *\n * @example\n * ```ts twoslash\n * import { Rlp } from 'ox'\n *\n * Rlp.fromHex('0x68656c6c6f20776f726c64')\n * // @log: 0x8b68656c6c6f20776f726c64\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to encode.\n * @param options - Options.\n * @returns The RLP value.\n */ function fromHex(hex, options = {}) {\n    const { as = \"Hex\" } = options;\n    return from(hex, {\n        as\n    });\n}\n/////////////////////////////////////////////////////////////////////////////////\n// Internal\n/////////////////////////////////////////////////////////////////////////////////\nfunction getEncodable(bytes) {\n    if (Array.isArray(bytes)) return getEncodableList(bytes.map((x)=>getEncodable(x)));\n    return getEncodableBytes(bytes);\n}\nfunction getEncodableList(list) {\n    const bodyLength = list.reduce((acc, x)=>acc + x.length, 0);\n    const sizeOfBodyLength = getSizeOfLength(bodyLength);\n    const length = (()=>{\n        if (bodyLength <= 55) return 1 + bodyLength;\n        return 1 + sizeOfBodyLength + bodyLength;\n    })();\n    return {\n        length,\n        encode (cursor) {\n            if (bodyLength <= 55) {\n                cursor.pushByte(0xc0 + bodyLength);\n            } else {\n                cursor.pushByte(0xc0 + 55 + sizeOfBodyLength);\n                if (sizeOfBodyLength === 1) cursor.pushUint8(bodyLength);\n                else if (sizeOfBodyLength === 2) cursor.pushUint16(bodyLength);\n                else if (sizeOfBodyLength === 3) cursor.pushUint24(bodyLength);\n                else cursor.pushUint32(bodyLength);\n            }\n            for (const { encode } of list){\n                encode(cursor);\n            }\n        }\n    };\n}\nfunction getEncodableBytes(bytesOrHex) {\n    const bytes = typeof bytesOrHex === \"string\" ? _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.fromHex(bytesOrHex) : bytesOrHex;\n    const sizeOfBytesLength = getSizeOfLength(bytes.length);\n    const length = (()=>{\n        if (bytes.length === 1 && bytes[0] < 0x80) return 1;\n        if (bytes.length <= 55) return 1 + bytes.length;\n        return 1 + sizeOfBytesLength + bytes.length;\n    })();\n    return {\n        length,\n        encode (cursor) {\n            if (bytes.length === 1 && bytes[0] < 0x80) {\n                cursor.pushBytes(bytes);\n            } else if (bytes.length <= 55) {\n                cursor.pushByte(0x80 + bytes.length);\n                cursor.pushBytes(bytes);\n            } else {\n                cursor.pushByte(0x80 + 55 + sizeOfBytesLength);\n                if (sizeOfBytesLength === 1) cursor.pushUint8(bytes.length);\n                else if (sizeOfBytesLength === 2) cursor.pushUint16(bytes.length);\n                else if (sizeOfBytesLength === 3) cursor.pushUint24(bytes.length);\n                else cursor.pushUint32(bytes.length);\n                cursor.pushBytes(bytes);\n            }\n        }\n    };\n}\nfunction getSizeOfLength(length) {\n    if (length <= 0xff) return 1;\n    if (length <= 0xffff) return 2;\n    if (length <= 0xffffff) return 3;\n    if (length <= 0xffffffff) return 4;\n    throw new _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError(\"Length is too large.\");\n} //# sourceMappingURL=Rlp.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1JscC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQW9DO0FBQ0U7QUFDTjtBQUNlO0FBQy9DOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUNNLFNBQVNJLFFBQVFDLEtBQUs7SUFDekIsT0FBT0MsR0FBR0QsT0FBTztBQUNyQjtBQUNBOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUNNLFNBQVNFLE1BQU1GLEtBQUs7SUFDdkIsT0FBT0MsR0FBR0QsT0FBTztBQUNyQjtBQUNBLGlGQUFpRjtBQUNqRixXQUFXO0FBQ1gsaUZBQWlGO0FBQ2pGLGNBQWMsR0FDUCxTQUFTQyxHQUFHRCxLQUFLLEVBQUVDLEVBQUU7SUFDeEIsTUFBTUUsTUFBTUYsTUFBTyxRQUFPRCxVQUFVLFdBQVcsUUFBUSxPQUFNO0lBQzdELE1BQU1JLFFBQVEsQ0FBQztRQUNYLElBQUksT0FBT0osVUFBVSxVQUFVO1lBQzNCLElBQUlBLE1BQU1LLE1BQU0sR0FBRyxLQUFLTCxNQUFNSyxNQUFNLEdBQUcsTUFBTSxHQUN6QyxNQUFNLElBQUlSLHVEQUFzQixDQUFDRztZQUNyQyxPQUFPTCw4Q0FBYSxDQUFDSztRQUN6QjtRQUNBLE9BQU9BO0lBQ1g7SUFDQSxNQUFNUSxTQUFTVix1REFBYSxDQUFDTSxPQUFPO1FBQ2hDTSxvQkFBb0JDLE9BQU9DLGlCQUFpQjtJQUNoRDtJQUNBLE1BQU1DLFNBQVNDLGdCQUFnQk4sUUFBUUw7SUFDdkMsT0FBT1U7QUFDWDtBQUNBLGNBQWMsR0FDZCxjQUFjLEdBQ1AsU0FBU0MsZ0JBQWdCTixNQUFNLEVBQUVQLEtBQUssS0FBSztJQUM5QyxJQUFJTyxPQUFPSixLQUFLLENBQUNDLE1BQU0sS0FBSyxHQUN4QixPQUFRSixPQUFPLFFBQVFKLDhDQUFhLENBQUNXLE9BQU9KLEtBQUssSUFBSUksT0FBT0osS0FBSztJQUNyRSxNQUFNWSxTQUFTUixPQUFPUyxRQUFRO0lBQzlCLElBQUlELFNBQVMsTUFDVFIsT0FBT1Us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RDtZQUNyQixPQUNLO2dCQUNESSxPQUFPMEMsUUFBUSxDQUFDLE9BQU8sS0FBS007Z0JBQzVCLElBQUlBLHNCQUFzQixHQUN0QmhELE9BQU8yQyxTQUFTLENBQUMvQyxNQUFNQyxNQUFNO3FCQUM1QixJQUFJbUQsc0JBQXNCLEdBQzNCaEQsT0FBTzRDLFVBQVUsQ0FBQ2hELE1BQU1DLE1BQU07cUJBQzdCLElBQUltRCxzQkFBc0IsR0FDM0JoRCxPQUFPNkMsVUFBVSxDQUFDakQsTUFBTUMsTUFBTTtxQkFFOUJHLE9BQU84QyxVQUFVLENBQUNsRCxNQUFNQyxNQUFNO2dCQUNsQ0csT0FBT2lELFNBQVMsQ0FBQ3JEO1lBQ3JCO1FBQ0o7SUFDSjtBQUNKO0FBQ0EsU0FBUzZDLGdCQUFnQjVDLE1BQU07SUFDM0IsSUFBSUEsVUFBVSxNQUNWLE9BQU87SUFDWCxJQUFJQSxVQUFVLFFBQ1YsT0FBTztJQUNYLElBQUlBLFVBQVUsVUFDVixPQUFPO0lBQ1gsSUFBSUEsVUFBVSxZQUNWLE9BQU87SUFDWCxNQUFNLElBQUlULGlEQUFnQixDQUFDO0FBQy9CLEVBQ0EsK0JBQStCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xhdy13b3Jrcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvUmxwLmpzPzg2YzAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQnl0ZXMgZnJvbSAnLi9CeXRlcy5qcyc7XG5pbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSAnLi9FcnJvcnMuanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbmltcG9ydCAqIGFzIEN1cnNvciBmcm9tICcuL2ludGVybmFsL2N1cnNvci5qcyc7XG4vKipcbiAqIERlY29kZXMgYSBSZWN1cnNpdmUtTGVuZ3RoIFByZWZpeCAoUkxQKSB2YWx1ZSBpbnRvIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFJscCB9IGZyb20gJ294J1xuICogUmxwLnRvQnl0ZXMoJzB4OGI2ODY1NmM2YzZmMjA3NzZmNzI2YzY0JylcbiAqIC8vIFVpbnQ4QXJyYXkoWzEzOSwgMTA0LCAxMDEsIDEwOCwgMTA4LCAxMTEsICAzMiwgMTE5LCAxMTEsIDExNCwgMTA4LCAxMDBdKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGRlY29kZS5cbiAqIEByZXR1cm5zIFRoZSBkZWNvZGVkIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0J5dGVzKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRvKHZhbHVlLCAnQnl0ZXMnKTtcbn1cbi8qKlxuICogRGVjb2RlcyBhIFJlY3Vyc2l2ZS1MZW5ndGggUHJlZml4IChSTFApIHZhbHVlIGludG8gYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBSbHAgfSBmcm9tICdveCdcbiAqIFJscC50b0hleCgnMHg4YjY4NjU2YzZjNmYyMDc3NmY3MjZjNjQnKVxuICogLy8gMHg2ODY1NmM2YzZmMjA3NzZmNzI2YzY0XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZGVjb2RlLlxuICogQHJldHVybnMgVGhlIGRlY29kZWQge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9IZXgodmFsdWUpIHtcbiAgICByZXR1cm4gdG8odmFsdWUsICdIZXgnKTtcbn1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gSW50ZXJuYWxcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvKHZhbHVlLCB0bykge1xuICAgIGNvbnN0IHRvXyA9IHRvID8/ICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gJ0hleCcgOiAnQnl0ZXMnKTtcbiAgICBjb25zdCBieXRlcyA9ICgoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gMyAmJiB2YWx1ZS5sZW5ndGggJSAyICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBIZXguSW52YWxpZExlbmd0aEVycm9yKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBCeXRlcy5mcm9tSGV4KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSkoKTtcbiAgICBjb25zdCBjdXJzb3IgPSBDdXJzb3IuY3JlYXRlKGJ5dGVzLCB7XG4gICAgICAgIHJlY3Vyc2l2ZVJlYWRMaW1pdDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgIH0pO1xuICAgIGNvbnN0IHJlc3VsdCA9IGRlY29kZVJscEN1cnNvcihjdXJzb3IsIHRvXyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVSbHBDdXJzb3IoY3Vyc29yLCB0byA9ICdIZXgnKSB7XG4gICAgaWYgKGN1cnNvci5ieXRlcy5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiAodG8gPT09ICdIZXgnID8gSGV4LmZyb21CeXRlcyhjdXJzb3IuYnl0ZXMpIDogY3Vyc29yLmJ5dGVzKTtcbiAgICBjb25zdCBwcmVmaXggPSBjdXJzb3IucmVhZEJ5dGUoKTtcbiAgICBpZiAocHJlZml4IDwgMHg4MClcbiAgICAgICAgY3Vyc29yLmRlY3JlbWVudFBvc2l0aW9uKDEpO1xuICAgIC8vIGJ5dGVzXG4gICAgaWYgKHByZWZpeCA8IDB4YzApIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gcmVhZExlbmd0aChjdXJzb3IsIHByZWZpeCwgMHg4MCk7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gY3Vyc29yLnJlYWRCeXRlcyhsZW5ndGgpO1xuICAgICAgICByZXR1cm4gKHRvID09PSAnSGV4JyA/IEhleC5mcm9tQnl0ZXMoYnl0ZXMpIDogYnl0ZXMpO1xuICAgIH1cbiAgICAvLyBsaXN0XG4gICAgY29uc3QgbGVuZ3RoID0gcmVhZExlbmd0aChjdXJzb3IsIHByZWZpeCwgMHhjMCk7XG4gICAgcmV0dXJuIHJlYWRMaXN0KGN1cnNvciwgbGVuZ3RoLCB0byk7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gcmVhZExlbmd0aChjdXJzb3IsIHByZWZpeCwgb2Zmc2V0KSB7XG4gICAgaWYgKG9mZnNldCA9PT0gMHg4MCAmJiBwcmVmaXggPCAweDgwKVxuICAgICAgICByZXR1cm4gMTtcbiAgICBpZiAocHJlZml4IDw9IG9mZnNldCArIDU1KVxuICAgICAgICByZXR1cm4gcHJlZml4IC0gb2Zmc2V0O1xuICAgIGlmIChwcmVmaXggPT09IG9mZnNldCArIDU1ICsgMSlcbiAgICAgICAgcmV0dXJuIGN1cnNvci5yZWFkVWludDgoKTtcbiAgICBpZiAocHJlZml4ID09PSBvZmZzZXQgKyA1NSArIDIpXG4gICAgICAgIHJldHVybiBjdXJzb3IucmVhZFVpbnQxNigpO1xuICAgIGlmIChwcmVmaXggPT09IG9mZnNldCArIDU1ICsgMylcbiAgICAgICAgcmV0dXJuIGN1cnNvci5yZWFkVWludDI0KCk7XG4gICAgaWYgKHByZWZpeCA9PT0gb2Zmc2V0ICsgNTUgKyA0KVxuICAgICAgICByZXR1cm4gY3Vyc29yLnJlYWRVaW50MzIoKTtcbiAgICB0aHJvdyBuZXcgRXJyb3JzLkJhc2VFcnJvcignSW52YWxpZCBSTFAgcHJlZml4Jyk7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gcmVhZExpc3QoY3Vyc29yLCBsZW5ndGgsIHRvKSB7XG4gICAgY29uc3QgcG9zaXRpb24gPSBjdXJzb3IucG9zaXRpb247XG4gICAgY29uc3QgdmFsdWUgPSBbXTtcbiAgICB3aGlsZSAoY3Vyc29yLnBvc2l0aW9uIC0gcG9zaXRpb24gPCBsZW5ndGgpXG4gICAgICAgIHZhbHVlLnB1c2goZGVjb2RlUmxwQ3Vyc29yKGN1cnNvciwgdG8pKTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG4vKipcbiAqIEVuY29kZXMgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IG9yIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSBpbnRvIGEgUmVjdXJzaXZlLUxlbmd0aCBQcmVmaXggKFJMUCkgdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcywgUmxwIH0gZnJvbSAnb3gnXG4gKlxuICogUmxwLmZyb20oJzB4Njg2NTZjNmM2ZjIwNzc2ZjcyNmM2NCcsIHsgYXM6ICdIZXgnIH0pXG4gKiAvLyBAbG9nOiAweDhiNjg2NTZjNmM2ZjIwNzc2ZjcyNmM2NFxuICpcbiAqIFJscC5mcm9tKEJ5dGVzLmZyb20oWzEzOSwgMTA0LCAxMDEsIDEwOCwgMTA4LCAxMTEsICAzMiwgMTE5LCAxMTEsIDExNCwgMTA4LCAxMDBdKSwgeyBhczogJ0J5dGVzJyB9KVxuICogLy8gQGxvZzogVWludDhBcnJheShbMTA0LCAxMDEsIDEwOCwgMTA4LCAxMTEsICAzMiwgMTE5LCAxMTEsIDExNCwgMTA4LCAxMDBdKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHtAbGluayBveCNCeXRlcy5CeXRlc30gb3Ige0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBSTFAgdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBhcyB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBlbmNvZGFibGUgPSBnZXRFbmNvZGFibGUodmFsdWUpO1xuICAgIGNvbnN0IGN1cnNvciA9IEN1cnNvci5jcmVhdGUobmV3IFVpbnQ4QXJyYXkoZW5jb2RhYmxlLmxlbmd0aCkpO1xuICAgIGVuY29kYWJsZS5lbmNvZGUoY3Vyc29yKTtcbiAgICBpZiAoYXMgPT09ICdIZXgnKVxuICAgICAgICByZXR1cm4gSGV4LmZyb21CeXRlcyhjdXJzb3IuYnl0ZXMpO1xuICAgIHJldHVybiBjdXJzb3IuYnl0ZXM7XG59XG4vKipcbiAqIEVuY29kZXMgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlIGludG8gYSBSZWN1cnNpdmUtTGVuZ3RoIFByZWZpeCAoUkxQKSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzLCBSbHAgfSBmcm9tICdveCdcbiAqXG4gKiBSbHAuZnJvbUJ5dGVzKEJ5dGVzLmZyb20oWzEzOSwgMTA0LCAxMDEsIDEwOCwgMTA4LCAxMTEsICAzMiwgMTE5LCAxMTEsIDExNCwgMTA4LCAxMDBdKSlcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzEwNCwgMTAxLCAxMDgsIDEwOCwgMTExLCAgMzIsIDExOSwgMTExLCAxMTQsIDEwOCwgMTAwXSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBieXRlcyAtIFRoZSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBSTFAgdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tQnl0ZXMoYnl0ZXMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgYXMgPSAnQnl0ZXMnIH0gPSBvcHRpb25zO1xuICAgIHJldHVybiBmcm9tKGJ5dGVzLCB7IGFzIH0pO1xufVxuLyoqXG4gKiBFbmNvZGVzIGEge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIGludG8gYSBSZWN1cnNpdmUtTGVuZ3RoIFByZWZpeCAoUkxQKSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFJscCB9IGZyb20gJ294J1xuICpcbiAqIFJscC5mcm9tSGV4KCcweDY4NjU2YzZjNmYyMDc3NmY3MjZjNjQnKVxuICogLy8gQGxvZzogMHg4YjY4NjU2YzZjNmYyMDc3NmY3MjZjNjRcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBoZXggLSBUaGUge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBSTFAgdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tSGV4KGhleCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBhcyA9ICdIZXgnIH0gPSBvcHRpb25zO1xuICAgIHJldHVybiBmcm9tKGhleCwgeyBhcyB9KTtcbn1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gSW50ZXJuYWxcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuZnVuY3Rpb24gZ2V0RW5jb2RhYmxlKGJ5dGVzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYnl0ZXMpKVxuICAgICAgICByZXR1cm4gZ2V0RW5jb2RhYmxlTGlzdChieXRlcy5tYXAoKHgpID0+IGdldEVuY29kYWJsZSh4KSkpO1xuICAgIHJldHVybiBnZXRFbmNvZGFibGVCeXRlcyhieXRlcyk7XG59XG5mdW5jdGlvbiBnZXRFbmNvZGFibGVMaXN0KGxpc3QpIHtcbiAgICBjb25zdCBib2R5TGVuZ3RoID0gbGlzdC5yZWR1Y2UoKGFjYywgeCkgPT4gYWNjICsgeC5sZW5ndGgsIDApO1xuICAgIGNvbnN0IHNpemVPZkJvZHlMZW5ndGggPSBnZXRTaXplT2ZMZW5ndGgoYm9keUxlbmd0aCk7XG4gICAgY29uc3QgbGVuZ3RoID0gKCgpID0+IHtcbiAgICAgICAgaWYgKGJvZHlMZW5ndGggPD0gNTUpXG4gICAgICAgICAgICByZXR1cm4gMSArIGJvZHlMZW5ndGg7XG4gICAgICAgIHJldHVybiAxICsgc2l6ZU9mQm9keUxlbmd0aCArIGJvZHlMZW5ndGg7XG4gICAgfSkoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBsZW5ndGgsXG4gICAgICAgIGVuY29kZShjdXJzb3IpIHtcbiAgICAgICAgICAgIGlmIChib2R5TGVuZ3RoIDw9IDU1KSB7XG4gICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hCeXRlKDB4YzAgKyBib2R5TGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1cnNvci5wdXNoQnl0ZSgweGMwICsgNTUgKyBzaXplT2ZCb2R5TGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAoc2l6ZU9mQm9keUxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hVaW50OChib2R5TGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaXplT2ZCb2R5TGVuZ3RoID09PSAyKVxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IucHVzaFVpbnQxNihib2R5TGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaXplT2ZCb2R5TGVuZ3RoID09PSAzKVxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IucHVzaFVpbnQyNChib2R5TGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvci5wdXNoVWludDMyKGJvZHlMZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCB7IGVuY29kZSB9IG9mIGxpc3QpIHtcbiAgICAgICAgICAgICAgICBlbmNvZGUoY3Vyc29yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0RW5jb2RhYmxlQnl0ZXMoYnl0ZXNPckhleCkge1xuICAgIGNvbnN0IGJ5dGVzID0gdHlwZW9mIGJ5dGVzT3JIZXggPT09ICdzdHJpbmcnID8gQnl0ZXMuZnJvbUhleChieXRlc09ySGV4KSA6IGJ5dGVzT3JIZXg7XG4gICAgY29uc3Qgc2l6ZU9mQnl0ZXNMZW5ndGggPSBnZXRTaXplT2ZMZW5ndGgoYnl0ZXMubGVuZ3RoKTtcbiAgICBjb25zdCBsZW5ndGggPSAoKCkgPT4ge1xuICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSAxICYmIGJ5dGVzWzBdIDwgMHg4MClcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoIDw9IDU1KVxuICAgICAgICAgICAgcmV0dXJuIDEgKyBieXRlcy5sZW5ndGg7XG4gICAgICAgIHJldHVybiAxICsgc2l6ZU9mQnl0ZXNMZW5ndGggKyBieXRlcy5sZW5ndGg7XG4gICAgfSkoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBsZW5ndGgsXG4gICAgICAgIGVuY29kZShjdXJzb3IpIHtcbiAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggPT09IDEgJiYgYnl0ZXNbMF0gPCAweDgwKSB7XG4gICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hCeXRlcyhieXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChieXRlcy5sZW5ndGggPD0gNTUpIHtcbiAgICAgICAgICAgICAgICBjdXJzb3IucHVzaEJ5dGUoMHg4MCArIGJ5dGVzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hCeXRlcyhieXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJzb3IucHVzaEJ5dGUoMHg4MCArIDU1ICsgc2l6ZU9mQnl0ZXNMZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmIChzaXplT2ZCeXRlc0xlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hVaW50OChieXRlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNpemVPZkJ5dGVzTGVuZ3RoID09PSAyKVxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IucHVzaFVpbnQxNihieXRlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNpemVPZkJ5dGVzTGVuZ3RoID09PSAzKVxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IucHVzaFVpbnQyNChieXRlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hVaW50MzIoYnl0ZXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBjdXJzb3IucHVzaEJ5dGVzKGJ5dGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0U2l6ZU9mTGVuZ3RoKGxlbmd0aCkge1xuICAgIGlmIChsZW5ndGggPD0gMHhmZilcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgaWYgKGxlbmd0aCA8PSAweGZmX2ZmKVxuICAgICAgICByZXR1cm4gMjtcbiAgICBpZiAobGVuZ3RoIDw9IDB4ZmZfZmZfZmYpXG4gICAgICAgIHJldHVybiAzO1xuICAgIGlmIChsZW5ndGggPD0gMHhmZl9mZl9mZl9mZilcbiAgICAgICAgcmV0dXJuIDQ7XG4gICAgdGhyb3cgbmV3IEVycm9ycy5CYXNlRXJyb3IoJ0xlbmd0aCBpcyB0b28gbGFyZ2UuJyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SbHAuanMubWFwIl0sIm5hbWVzIjpbIkJ5dGVzIiwiRXJyb3JzIiwiSGV4IiwiQ3Vyc29yIiwidG9CeXRlcyIsInZhbHVlIiwidG8iLCJ0b0hleCIsInRvXyIsImJ5dGVzIiwibGVuZ3RoIiwiSW52YWxpZExlbmd0aEVycm9yIiwiZnJvbUhleCIsImN1cnNvciIsImNyZWF0ZSIsInJlY3Vyc2l2ZVJlYWRMaW1pdCIsIk51bWJlciIsIlBPU0lUSVZFX0lORklOSVRZIiwicmVzdWx0IiwiZGVjb2RlUmxwQ3Vyc29yIiwiZnJvbUJ5dGVzIiwicHJlZml4IiwicmVhZEJ5dGUiLCJkZWNyZW1lbnRQb3NpdGlvbiIsInJlYWRMZW5ndGgiLCJyZWFkQnl0ZXMiLCJyZWFkTGlzdCIsIm9mZnNldCIsInJlYWRVaW50OCIsInJlYWRVaW50MTYiLCJyZWFkVWludDI0IiwicmVhZFVpbnQzMiIsIkJhc2VFcnJvciIsInBvc2l0aW9uIiwicHVzaCIsImZyb20iLCJvcHRpb25zIiwiYXMiLCJlbmNvZGFibGUiLCJnZXRFbmNvZGFibGUiLCJVaW50OEFycmF5IiwiZW5jb2RlIiwiaGV4IiwiQXJyYXkiLCJpc0FycmF5IiwiZ2V0RW5jb2RhYmxlTGlzdCIsIm1hcCIsIngiLCJnZXRFbmNvZGFibGVCeXRlcyIsImxpc3QiLCJib2R5TGVuZ3RoIiwicmVkdWNlIiwiYWNjIiwic2l6ZU9mQm9keUxlbmd0aCIsImdldFNpemVPZkxlbmd0aCIsInB1c2hCeXRlIiwicHVzaFVpbnQ4IiwicHVzaFVpbnQxNiIsInB1c2hVaW50MjQiLCJwdXNoVWludDMyIiwiYnl0ZXNPckhleCIsInNpemVPZkJ5dGVzTGVuZ3RoIiwicHVzaEJ5dGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Rlp.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Secp256k1.js":
/*!************************************************!*\
  !*** ./node_modules/ox/_esm/core/Secp256k1.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createKeyPair: () => (/* binding */ createKeyPair),\n/* harmony export */   getPublicKey: () => (/* binding */ getPublicKey),\n/* harmony export */   getSharedSecret: () => (/* binding */ getSharedSecret),\n/* harmony export */   noble: () => (/* binding */ noble),\n/* harmony export */   randomPrivateKey: () => (/* binding */ randomPrivateKey),\n/* harmony export */   recoverAddress: () => (/* binding */ recoverAddress),\n/* harmony export */   recoverPublicKey: () => (/* binding */ recoverPublicKey),\n/* harmony export */   sign: () => (/* binding */ sign),\n/* harmony export */   verify: () => (/* binding */ verify)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var _Address_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Address.js */ \"(ssr)/./node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _internal_entropy_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./internal/entropy.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/entropy.js\");\n/* harmony import */ var _PublicKey_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PublicKey.js */ \"(ssr)/./node_modules/ox/_esm/core/PublicKey.js\");\n\n\n\n\n\n\n/** Re-export of noble/curves secp256k1 utilities. */ const noble = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1;\n/**\n * Creates a new secp256k1 ECDSA key pair consisting of a private key and its corresponding public key.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const { privateKey, publicKey } = Secp256k1.createKeyPair()\n * ```\n *\n * @param options - The options to generate the key pair.\n * @returns The generated key pair containing both private and public keys.\n */ function createKeyPair(options = {}) {\n    const { as = \"Hex\" } = options;\n    const privateKey = randomPrivateKey({\n        as\n    });\n    const publicKey = getPublicKey({\n        privateKey\n    });\n    return {\n        privateKey: privateKey,\n        publicKey\n    };\n}\n/**\n * Computes the secp256k1 ECDSA public key from a provided private key.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const publicKey = Secp256k1.getPublicKey({ privateKey: '0x...' })\n * ```\n *\n * @param options - The options to compute the public key.\n * @returns The computed public key.\n */ function getPublicKey(options) {\n    const { privateKey } = options;\n    const point = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.ProjectivePoint.fromPrivateKey(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.from(privateKey).slice(2));\n    return _PublicKey_js__WEBPACK_IMPORTED_MODULE_2__.from(point);\n}\n/**\n * Computes a shared secret using ECDH (Elliptic Curve Diffie-Hellman) between a private key and a public key.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const { privateKey: privateKeyA } = Secp256k1.createKeyPair()\n * const { publicKey: publicKeyB } = Secp256k1.createKeyPair()\n *\n * const sharedSecret = Secp256k1.getSharedSecret({\n *   privateKey: privateKeyA,\n *   publicKey: publicKeyB\n * })\n * ```\n *\n * @param options - The options to compute the shared secret.\n * @returns The computed shared secret.\n */ function getSharedSecret(options) {\n    const { as = \"Hex\", privateKey, publicKey } = options;\n    const point = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.ProjectivePoint.fromHex(_PublicKey_js__WEBPACK_IMPORTED_MODULE_2__.toHex(publicKey).slice(2));\n    const sharedPoint = point.multiply(_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.utils.normPrivateKeyToScalar(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.from(privateKey).slice(2)));\n    const sharedSecret = sharedPoint.toRawBytes(true); // compressed format\n    if (as === \"Hex\") return _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(sharedSecret);\n    return sharedSecret;\n}\n/**\n * Generates a random ECDSA private key on the secp256k1 curve.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const privateKey = Secp256k1.randomPrivateKey()\n * ```\n *\n * @param options - The options to generate the private key.\n * @returns The generated private key.\n */ function randomPrivateKey(options = {}) {\n    const { as = \"Hex\" } = options;\n    const bytes = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.utils.randomPrivateKey();\n    if (as === \"Hex\") return _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(bytes);\n    return bytes;\n}\n/**\n * Recovers the signing address from the signed payload and signature.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey: '0x...' })\n *\n * const address = Secp256k1.recoverAddress({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The recovery options.\n * @returns The recovered address.\n */ function recoverAddress(options) {\n    return _Address_js__WEBPACK_IMPORTED_MODULE_3__.fromPublicKey(recoverPublicKey(options));\n}\n/**\n * Recovers the signing public key from the signed payload and signature.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey: '0x...' })\n *\n * const publicKey = Secp256k1.recoverPublicKey({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The recovery options.\n * @returns The recovered public key.\n */ function recoverPublicKey(options) {\n    const { payload, signature } = options;\n    const { r, s, yParity } = signature;\n    const signature_ = new _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.Signature(BigInt(r), BigInt(s)).addRecoveryBit(yParity);\n    const point = signature_.recoverPublicKey(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.from(payload).substring(2));\n    return _PublicKey_js__WEBPACK_IMPORTED_MODULE_2__.from(point);\n}\n/**\n * Signs the payload with the provided private key.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const signature = Secp256k1.sign({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   privateKey: '0x...' // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The signing options.\n * @returns The ECDSA {@link ox#Signature.Signature}.\n */ function sign(options) {\n    const { extraEntropy = _internal_entropy_js__WEBPACK_IMPORTED_MODULE_4__.extraEntropy, hash, payload, privateKey } = options;\n    const { r, s, recovery } = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.sign(_Bytes_js__WEBPACK_IMPORTED_MODULE_5__.from(payload), _Bytes_js__WEBPACK_IMPORTED_MODULE_5__.from(privateKey), {\n        extraEntropy: typeof extraEntropy === \"boolean\" ? extraEntropy : _Hex_js__WEBPACK_IMPORTED_MODULE_1__.from(extraEntropy).slice(2),\n        lowS: true,\n        ...hash ? {\n            prehash: true\n        } : {}\n    });\n    return {\n        r,\n        s,\n        yParity: recovery\n    };\n}\n/**\n * Verifies a payload was signed by the provided address.\n *\n * @example\n * ### Verify with Ethereum Address\n *\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey: '0x...' })\n *\n * const verified = Secp256k1.verify({ // [!code focus]\n *   address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @example\n * ### Verify with Public Key\n *\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const privateKey = '0x...'\n * const publicKey = Secp256k1.getPublicKey({ privateKey })\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const verified = Secp256k1.verify({ // [!code focus]\n *   publicKey, // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The verification options.\n * @returns Whether the payload was signed by the provided address.\n */ function verify(options) {\n    const { address, hash, payload, publicKey, signature } = options;\n    if (address) return _Address_js__WEBPACK_IMPORTED_MODULE_3__.isEqual(address, recoverAddress({\n        payload,\n        signature\n    }));\n    return _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.verify(signature, _Bytes_js__WEBPACK_IMPORTED_MODULE_5__.from(payload), _PublicKey_js__WEBPACK_IMPORTED_MODULE_2__.toBytes(publicKey), ...hash ? [\n        {\n            prehash: true,\n            lowS: true\n        }\n    ] : []);\n} //# sourceMappingURL=Secp256k1.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1NlY3AyNTZrMS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb0Q7QUFDWjtBQUNKO0FBQ0o7QUFDaUI7QUFDTDtBQUM1QyxtREFBbUQsR0FDNUMsTUFBTU0sUUFBUU4sOERBQVNBLENBQUM7QUFDL0I7Ozs7Ozs7Ozs7OztDQVlDLEdBQ00sU0FBU08sY0FBY0MsVUFBVSxDQUFDLENBQUM7SUFDdEMsTUFBTSxFQUFFQyxLQUFLLEtBQUssRUFBRSxHQUFHRDtJQUN2QixNQUFNRSxhQUFhQyxpQkFBaUI7UUFBRUY7SUFBRztJQUN6QyxNQUFNRyxZQUFZQyxhQUFhO1FBQUVIO0lBQVc7SUFDNUMsT0FBTztRQUNIQSxZQUFZQTtRQUNaRTtJQUNKO0FBQ0o7QUFDQTs7Ozs7Ozs7Ozs7O0NBWUMsR0FDTSxTQUFTQyxhQUFhTCxPQUFPO0lBQ2hDLE1BQU0sRUFBRUUsVUFBVSxFQUFFLEdBQUdGO0lBQ3ZCLE1BQU1NLFFBQVFkLDhEQUFTQSxDQUFDZSxlQUFlLENBQUNDLGNBQWMsQ0FBQ2IseUNBQVEsQ0FBQ08sWUFBWVEsS0FBSyxDQUFDO0lBQ2xGLE9BQU9iLCtDQUFjLENBQUNTO0FBQzFCO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWtCQyxHQUNNLFNBQVNLLGdCQUFnQlgsT0FBTztJQUNuQyxNQUFNLEVBQUVDLEtBQUssS0FBSyxFQUFFQyxVQUFVLEVBQUVFLFNBQVMsRUFBRSxHQUFHSjtJQUM5QyxNQUFNTSxRQUFRZCw4REFBU0EsQ0FBQ2UsZUFBZSxDQUFDSyxPQUFPLENBQUNmLGdEQUFlLENBQUNPLFdBQVdNLEtBQUssQ0FBQztJQUNqRixNQUFNSSxjQUFjUixNQUFNUyxRQUFRLENBQUN2Qiw4REFBU0EsQ0FBQ3dCLEtBQUssQ0FBQ0Msc0JBQXNCLENBQUN0Qix5Q0FBUSxDQUFDTyxZQUFZUSxLQUFLLENBQUM7SUFDckcsTUFBTVEsZUFBZUosWUFBWUssVUFBVSxDQUFDLE9BQU8sb0JBQW9CO0lBQ3ZFLElBQUlsQixPQUFPLE9BQ1AsT0FBT04sOENBQWEsQ0FBQ3VCO0lBQ3pCLE9BQU9BO0FBQ1g7QUFDQTs7Ozs7Ozs7Ozs7O0NBWUMsR0FDTSxTQUFTZixpQkFBaUJILFVBQVUsQ0FBQyxDQUFDO0lBQ3pDLE1BQU0sRUFBRUMsS0FBSyxLQUFLLEVBQUUsR0FBR0Q7SUFDdkIsTUFBTXFCLFFBQVE3Qiw4REFBU0EsQ0FBQ3dCLEtBQUssQ0FBQ2IsZ0JBQWdCO0lBQzlDLElBQUlGLE9BQU8sT0FDUCxPQUFPTiw4Q0FBYSxDQUFDMEI7SUFDekIsT0FBT0E7QUFDWDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztDQWlCQyxHQUNNLFNBQVNDLGVBQWV0QixPQUFPO0lBQ2xDLE9BQU9QLHNEQUFxQixDQUFDK0IsaUJBQWlCeEI7QUFDbEQ7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FpQkMsR0FDTSxTQUFTd0IsaUJBQWlCeEIsT0FBTztJQUNwQyxNQUFNLEVBQUV5QixPQUFPLEVBQUVDLFNBQVMsRUFBRSxHQUFHMUI7SUFDL0IsTUFBTSxFQUFFMkIsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLE9BQU8sRUFBRSxHQUFHSDtJQUMxQixNQUFNSSxhQUFhLElBQUl0Qyw4REFBU0EsQ0FBQ3VDLFNBQVMsQ0FBQ0MsT0FBT0wsSUFBSUssT0FBT0osSUFBSUssY0FBYyxDQUFDSjtJQUNoRixNQUFNdkIsUUFBUXdCLFdBQVdOLGdCQUFnQixDQUFDN0IseUNBQVEsQ0FBQzhCLFNBQVNTLFNBQVMsQ0FBQztJQUN0RSxPQUFPckMsK0NBQWMsQ0FBQ1M7QUFDMUI7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDTSxTQUFTNkIsS0FBS25DLE9BQU87SUFDeEIsTUFBTSxFQUFFb0MsZUFBZXhDLDhEQUFvQixFQUFFeUMsSUFBSSxFQUFFWixPQUFPLEVBQUV2QixVQUFVLEVBQUcsR0FBR0Y7SUFDNUUsTUFBTSxFQUFFMkIsQ0FBQyxFQUFFQyxDQUFDLEVBQUVVLFFBQVEsRUFBRSxHQUFHOUMsOERBQVNBLENBQUMyQyxJQUFJLENBQUN6QywyQ0FBVSxDQUFDK0IsVUFBVS9CLDJDQUFVLENBQUNRLGFBQWE7UUFDbkZrQyxjQUFjLE9BQU9BLGlCQUFpQixZQUNoQ0EsZUFDQXpDLHlDQUFRLENBQUN5QyxjQUFjMUIsS0FBSyxDQUFDO1FBQ25DNkIsTUFBTTtRQUNOLEdBQUlGLE9BQU87WUFBRUcsU0FBUztRQUFLLElBQUksQ0FBQyxDQUFDO0lBQ3JDO0lBQ0EsT0FBTztRQUNIYjtRQUNBQztRQUNBQyxTQUFTUztJQUNiO0FBQ0o7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXFDQyxHQUNNLFNBQVNHLE9BQU96QyxPQUFPO0lBQzFCLE1BQU0sRUFBRTBDLE9BQU8sRUFBRUwsSUFBSSxFQUFFWixPQUFPLEVBQUVyQixTQUFTLEVBQUVzQixTQUFTLEVBQUUsR0FBRzFCO0lBQ3pELElBQUkwQyxTQUNBLE9BQU9qRCxnREFBZSxDQUFDaUQsU0FBU3BCLGVBQWU7UUFBRUc7UUFBU0M7SUFBVTtJQUN4RSxPQUFPbEMsOERBQVNBLENBQUNpRCxNQUFNLENBQUNmLFdBQVdoQywyQ0FBVSxDQUFDK0IsVUFBVTVCLGtEQUFpQixDQUFDTyxlQUFnQmlDLE9BQU87UUFBQztZQUFFRyxTQUFTO1lBQU1ELE1BQU07UUFBSztLQUFFLEdBQUcsRUFBRTtBQUN6SSxFQUNBLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsYXctd29ya3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1NlY3AyNTZrMS5qcz9hZWIzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHNlY3AyNTZrMSB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxJztcbmltcG9ydCAqIGFzIEFkZHJlc3MgZnJvbSAnLi9BZGRyZXNzLmpzJztcbmltcG9ydCAqIGFzIEJ5dGVzIGZyb20gJy4vQnl0ZXMuanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbmltcG9ydCAqIGFzIEVudHJvcHkgZnJvbSAnLi9pbnRlcm5hbC9lbnRyb3B5LmpzJztcbmltcG9ydCAqIGFzIFB1YmxpY0tleSBmcm9tICcuL1B1YmxpY0tleS5qcyc7XG4vKiogUmUtZXhwb3J0IG9mIG5vYmxlL2N1cnZlcyBzZWNwMjU2azEgdXRpbGl0aWVzLiAqL1xuZXhwb3J0IGNvbnN0IG5vYmxlID0gc2VjcDI1NmsxO1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHNlY3AyNTZrMSBFQ0RTQSBrZXkgcGFpciBjb25zaXN0aW5nIG9mIGEgcHJpdmF0ZSBrZXkgYW5kIGl0cyBjb3JyZXNwb25kaW5nIHB1YmxpYyBrZXkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB7IHByaXZhdGVLZXksIHB1YmxpY0tleSB9ID0gU2VjcDI1NmsxLmNyZWF0ZUtleVBhaXIoKVxuICogYGBgXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyB0byBnZW5lcmF0ZSB0aGUga2V5IHBhaXIuXG4gKiBAcmV0dXJucyBUaGUgZ2VuZXJhdGVkIGtleSBwYWlyIGNvbnRhaW5pbmcgYm90aCBwcml2YXRlIGFuZCBwdWJsaWMga2V5cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUtleVBhaXIob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBhcyA9ICdIZXgnIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHByaXZhdGVLZXkgPSByYW5kb21Qcml2YXRlS2V5KHsgYXMgfSk7XG4gICAgY29uc3QgcHVibGljS2V5ID0gZ2V0UHVibGljS2V5KHsgcHJpdmF0ZUtleSB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwcml2YXRlS2V5OiBwcml2YXRlS2V5LFxuICAgICAgICBwdWJsaWNLZXksXG4gICAgfTtcbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIHNlY3AyNTZrMSBFQ0RTQSBwdWJsaWMga2V5IGZyb20gYSBwcm92aWRlZCBwcml2YXRlIGtleS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNlY3AyNTZrMSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHB1YmxpY0tleSA9IFNlY3AyNTZrMS5nZXRQdWJsaWNLZXkoeyBwcml2YXRlS2V5OiAnMHguLi4nIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIHRvIGNvbXB1dGUgdGhlIHB1YmxpYyBrZXkuXG4gKiBAcmV0dXJucyBUaGUgY29tcHV0ZWQgcHVibGljIGtleS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFB1YmxpY0tleShvcHRpb25zKSB7XG4gICAgY29uc3QgeyBwcml2YXRlS2V5IH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHBvaW50ID0gc2VjcDI1NmsxLlByb2plY3RpdmVQb2ludC5mcm9tUHJpdmF0ZUtleShIZXguZnJvbShwcml2YXRlS2V5KS5zbGljZSgyKSk7XG4gICAgcmV0dXJuIFB1YmxpY0tleS5mcm9tKHBvaW50KTtcbn1cbi8qKlxuICogQ29tcHV0ZXMgYSBzaGFyZWQgc2VjcmV0IHVzaW5nIEVDREggKEVsbGlwdGljIEN1cnZlIERpZmZpZS1IZWxsbWFuKSBiZXR3ZWVuIGEgcHJpdmF0ZSBrZXkgYW5kIGEgcHVibGljIGtleS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNlY3AyNTZrMSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHsgcHJpdmF0ZUtleTogcHJpdmF0ZUtleUEgfSA9IFNlY3AyNTZrMS5jcmVhdGVLZXlQYWlyKClcbiAqIGNvbnN0IHsgcHVibGljS2V5OiBwdWJsaWNLZXlCIH0gPSBTZWNwMjU2azEuY3JlYXRlS2V5UGFpcigpXG4gKlxuICogY29uc3Qgc2hhcmVkU2VjcmV0ID0gU2VjcDI1NmsxLmdldFNoYXJlZFNlY3JldCh7XG4gKiAgIHByaXZhdGVLZXk6IHByaXZhdGVLZXlBLFxuICogICBwdWJsaWNLZXk6IHB1YmxpY0tleUJcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIHRvIGNvbXB1dGUgdGhlIHNoYXJlZCBzZWNyZXQuXG4gKiBAcmV0dXJucyBUaGUgY29tcHV0ZWQgc2hhcmVkIHNlY3JldC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNoYXJlZFNlY3JldChvcHRpb25zKSB7XG4gICAgY29uc3QgeyBhcyA9ICdIZXgnLCBwcml2YXRlS2V5LCBwdWJsaWNLZXkgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgcG9pbnQgPSBzZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50LmZyb21IZXgoUHVibGljS2V5LnRvSGV4KHB1YmxpY0tleSkuc2xpY2UoMikpO1xuICAgIGNvbnN0IHNoYXJlZFBvaW50ID0gcG9pbnQubXVsdGlwbHkoc2VjcDI1NmsxLnV0aWxzLm5vcm1Qcml2YXRlS2V5VG9TY2FsYXIoSGV4LmZyb20ocHJpdmF0ZUtleSkuc2xpY2UoMikpKTtcbiAgICBjb25zdCBzaGFyZWRTZWNyZXQgPSBzaGFyZWRQb2ludC50b1Jhd0J5dGVzKHRydWUpOyAvLyBjb21wcmVzc2VkIGZvcm1hdFxuICAgIGlmIChhcyA9PT0gJ0hleCcpXG4gICAgICAgIHJldHVybiBIZXguZnJvbUJ5dGVzKHNoYXJlZFNlY3JldCk7XG4gICAgcmV0dXJuIHNoYXJlZFNlY3JldDtcbn1cbi8qKlxuICogR2VuZXJhdGVzIGEgcmFuZG9tIEVDRFNBIHByaXZhdGUga2V5IG9uIHRoZSBzZWNwMjU2azEgY3VydmUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwcml2YXRlS2V5ID0gU2VjcDI1NmsxLnJhbmRvbVByaXZhdGVLZXkoKVxuICogYGBgXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyB0byBnZW5lcmF0ZSB0aGUgcHJpdmF0ZSBrZXkuXG4gKiBAcmV0dXJucyBUaGUgZ2VuZXJhdGVkIHByaXZhdGUga2V5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tUHJpdmF0ZUtleShvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGFzID0gJ0hleCcgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYnl0ZXMgPSBzZWNwMjU2azEudXRpbHMucmFuZG9tUHJpdmF0ZUtleSgpO1xuICAgIGlmIChhcyA9PT0gJ0hleCcpXG4gICAgICAgIHJldHVybiBIZXguZnJvbUJ5dGVzKGJ5dGVzKTtcbiAgICByZXR1cm4gYnl0ZXM7XG59XG4vKipcbiAqIFJlY292ZXJzIHRoZSBzaWduaW5nIGFkZHJlc3MgZnJvbSB0aGUgc2lnbmVkIHBheWxvYWQgYW5kIHNpZ25hdHVyZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNlY3AyNTZrMSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHsgcGF5bG9hZDogJzB4ZGVhZGJlZWYnLCBwcml2YXRlS2V5OiAnMHguLi4nIH0pXG4gKlxuICogY29uc3QgYWRkcmVzcyA9IFNlY3AyNTZrMS5yZWNvdmVyQWRkcmVzcyh7IC8vIFshY29kZSBmb2N1c11cbiAqICAgcGF5bG9hZDogJzB4ZGVhZGJlZWYnLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHNpZ25hdHVyZSwgLy8gWyFjb2RlIGZvY3VzXVxuICogfSkgLy8gWyFjb2RlIGZvY3VzXVxuICogYGBgXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgcmVjb3Zlcnkgb3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSByZWNvdmVyZWQgYWRkcmVzcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlY292ZXJBZGRyZXNzKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gQWRkcmVzcy5mcm9tUHVibGljS2V5KHJlY292ZXJQdWJsaWNLZXkob3B0aW9ucykpO1xufVxuLyoqXG4gKiBSZWNvdmVycyB0aGUgc2lnbmluZyBwdWJsaWMga2V5IGZyb20gdGhlIHNpZ25lZCBwYXlsb2FkIGFuZCBzaWduYXR1cmUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7IHBheWxvYWQ6ICcweGRlYWRiZWVmJywgcHJpdmF0ZUtleTogJzB4Li4uJyB9KVxuICpcbiAqIGNvbnN0IHB1YmxpY0tleSA9IFNlY3AyNTZrMS5yZWNvdmVyUHVibGljS2V5KHsgLy8gWyFjb2RlIGZvY3VzXVxuICogICBwYXlsb2FkOiAnMHhkZWFkYmVlZicsIC8vIFshY29kZSBmb2N1c11cbiAqICAgc2lnbmF0dXJlLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KSAvLyBbIWNvZGUgZm9jdXNdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSByZWNvdmVyeSBvcHRpb25zLlxuICogQHJldHVybnMgVGhlIHJlY292ZXJlZCBwdWJsaWMga2V5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVjb3ZlclB1YmxpY0tleShvcHRpb25zKSB7XG4gICAgY29uc3QgeyBwYXlsb2FkLCBzaWduYXR1cmUgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgeyByLCBzLCB5UGFyaXR5IH0gPSBzaWduYXR1cmU7XG4gICAgY29uc3Qgc2lnbmF0dXJlXyA9IG5ldyBzZWNwMjU2azEuU2lnbmF0dXJlKEJpZ0ludChyKSwgQmlnSW50KHMpKS5hZGRSZWNvdmVyeUJpdCh5UGFyaXR5KTtcbiAgICBjb25zdCBwb2ludCA9IHNpZ25hdHVyZV8ucmVjb3ZlclB1YmxpY0tleShIZXguZnJvbShwYXlsb2FkKS5zdWJzdHJpbmcoMikpO1xuICAgIHJldHVybiBQdWJsaWNLZXkuZnJvbShwb2ludCk7XG59XG4vKipcbiAqIFNpZ25zIHRoZSBwYXlsb2FkIHdpdGggdGhlIHByb3ZpZGVkIHByaXZhdGUga2V5LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2VjcDI1NmsxIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHBheWxvYWQ6ICcweGRlYWRiZWVmJywgLy8gWyFjb2RlIGZvY3VzXVxuICogICBwcml2YXRlS2V5OiAnMHguLi4nIC8vIFshY29kZSBmb2N1c11cbiAqIH0pIC8vIFshY29kZSBmb2N1c11cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIHNpZ25pbmcgb3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBFQ0RTQSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaWduKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGV4dHJhRW50cm9weSA9IEVudHJvcHkuZXh0cmFFbnRyb3B5LCBoYXNoLCBwYXlsb2FkLCBwcml2YXRlS2V5LCB9ID0gb3B0aW9ucztcbiAgICBjb25zdCB7IHIsIHMsIHJlY292ZXJ5IH0gPSBzZWNwMjU2azEuc2lnbihCeXRlcy5mcm9tKHBheWxvYWQpLCBCeXRlcy5mcm9tKHByaXZhdGVLZXkpLCB7XG4gICAgICAgIGV4dHJhRW50cm9weTogdHlwZW9mIGV4dHJhRW50cm9weSA9PT0gJ2Jvb2xlYW4nXG4gICAgICAgICAgICA/IGV4dHJhRW50cm9weVxuICAgICAgICAgICAgOiBIZXguZnJvbShleHRyYUVudHJvcHkpLnNsaWNlKDIpLFxuICAgICAgICBsb3dTOiB0cnVlLFxuICAgICAgICAuLi4oaGFzaCA/IHsgcHJlaGFzaDogdHJ1ZSB9IDoge30pLFxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHIsXG4gICAgICAgIHMsXG4gICAgICAgIHlQYXJpdHk6IHJlY292ZXJ5LFxuICAgIH07XG59XG4vKipcbiAqIFZlcmlmaWVzIGEgcGF5bG9hZCB3YXMgc2lnbmVkIGJ5IHRoZSBwcm92aWRlZCBhZGRyZXNzLlxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgVmVyaWZ5IHdpdGggRXRoZXJldW0gQWRkcmVzc1xuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7IHBheWxvYWQ6ICcweGRlYWRiZWVmJywgcHJpdmF0ZUtleTogJzB4Li4uJyB9KVxuICpcbiAqIGNvbnN0IHZlcmlmaWVkID0gU2VjcDI1NmsxLnZlcmlmeSh7IC8vIFshY29kZSBmb2N1c11cbiAqICAgYWRkcmVzczogJzB4ZjM5ZmQ2ZTUxYWFkODhmNmY0Y2U2YWI4ODI3Mjc5Y2ZmZmI5MjI2NicsIC8vIFshY29kZSBmb2N1c11cbiAqICAgcGF5bG9hZDogJzB4ZGVhZGJlZWYnLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHNpZ25hdHVyZSwgLy8gWyFjb2RlIGZvY3VzXVxuICogfSkgLy8gWyFjb2RlIGZvY3VzXVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBWZXJpZnkgd2l0aCBQdWJsaWMgS2V5XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNlY3AyNTZrMSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHByaXZhdGVLZXkgPSAnMHguLi4nXG4gKiBjb25zdCBwdWJsaWNLZXkgPSBTZWNwMjU2azEuZ2V0UHVibGljS2V5KHsgcHJpdmF0ZUtleSB9KVxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oeyBwYXlsb2FkOiAnMHhkZWFkYmVlZicsIHByaXZhdGVLZXkgfSlcbiAqXG4gKiBjb25zdCB2ZXJpZmllZCA9IFNlY3AyNTZrMS52ZXJpZnkoeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHB1YmxpY0tleSwgLy8gWyFjb2RlIGZvY3VzXVxuICogICBwYXlsb2FkOiAnMHhkZWFkYmVlZicsIC8vIFshY29kZSBmb2N1c11cbiAqICAgc2lnbmF0dXJlLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KSAvLyBbIWNvZGUgZm9jdXNdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSB2ZXJpZmljYXRpb24gb3B0aW9ucy5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHBheWxvYWQgd2FzIHNpZ25lZCBieSB0aGUgcHJvdmlkZWQgYWRkcmVzcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeShvcHRpb25zKSB7XG4gICAgY29uc3QgeyBhZGRyZXNzLCBoYXNoLCBwYXlsb2FkLCBwdWJsaWNLZXksIHNpZ25hdHVyZSB9ID0gb3B0aW9ucztcbiAgICBpZiAoYWRkcmVzcylcbiAgICAgICAgcmV0dXJuIEFkZHJlc3MuaXNFcXVhbChhZGRyZXNzLCByZWNvdmVyQWRkcmVzcyh7IHBheWxvYWQsIHNpZ25hdHVyZSB9KSk7XG4gICAgcmV0dXJuIHNlY3AyNTZrMS52ZXJpZnkoc2lnbmF0dXJlLCBCeXRlcy5mcm9tKHBheWxvYWQpLCBQdWJsaWNLZXkudG9CeXRlcyhwdWJsaWNLZXkpLCAuLi4oaGFzaCA/IFt7IHByZWhhc2g6IHRydWUsIGxvd1M6IHRydWUgfV0gOiBbXSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2VjcDI1NmsxLmpzLm1hcCJdLCJuYW1lcyI6WyJzZWNwMjU2azEiLCJBZGRyZXNzIiwiQnl0ZXMiLCJIZXgiLCJFbnRyb3B5IiwiUHVibGljS2V5Iiwibm9ibGUiLCJjcmVhdGVLZXlQYWlyIiwib3B0aW9ucyIsImFzIiwicHJpdmF0ZUtleSIsInJhbmRvbVByaXZhdGVLZXkiLCJwdWJsaWNLZXkiLCJnZXRQdWJsaWNLZXkiLCJwb2ludCIsIlByb2plY3RpdmVQb2ludCIsImZyb21Qcml2YXRlS2V5IiwiZnJvbSIsInNsaWNlIiwiZ2V0U2hhcmVkU2VjcmV0IiwiZnJvbUhleCIsInRvSGV4Iiwic2hhcmVkUG9pbnQiLCJtdWx0aXBseSIsInV0aWxzIiwibm9ybVByaXZhdGVLZXlUb1NjYWxhciIsInNoYXJlZFNlY3JldCIsInRvUmF3Qnl0ZXMiLCJmcm9tQnl0ZXMiLCJieXRlcyIsInJlY292ZXJBZGRyZXNzIiwiZnJvbVB1YmxpY0tleSIsInJlY292ZXJQdWJsaWNLZXkiLCJwYXlsb2FkIiwic2lnbmF0dXJlIiwiciIsInMiLCJ5UGFyaXR5Iiwic2lnbmF0dXJlXyIsIlNpZ25hdHVyZSIsIkJpZ0ludCIsImFkZFJlY292ZXJ5Qml0Iiwic3Vic3RyaW5nIiwic2lnbiIsImV4dHJhRW50cm9weSIsImhhc2giLCJyZWNvdmVyeSIsImxvd1MiLCJwcmVoYXNoIiwidmVyaWZ5IiwiYWRkcmVzcyIsImlzRXF1YWwiLCJ0b0J5dGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Secp256k1.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Signature.js":
/*!************************************************!*\
  !*** ./node_modules/ox/_esm/core/Signature.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidRError: () => (/* binding */ InvalidRError),\n/* harmony export */   InvalidSError: () => (/* binding */ InvalidSError),\n/* harmony export */   InvalidSerializedSizeError: () => (/* binding */ InvalidSerializedSizeError),\n/* harmony export */   InvalidVError: () => (/* binding */ InvalidVError),\n/* harmony export */   InvalidYParityError: () => (/* binding */ InvalidYParityError),\n/* harmony export */   MissingPropertiesError: () => (/* binding */ MissingPropertiesError),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   extract: () => (/* binding */ extract),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromBytes: () => (/* binding */ fromBytes),\n/* harmony export */   fromDerBytes: () => (/* binding */ fromDerBytes),\n/* harmony export */   fromDerHex: () => (/* binding */ fromDerHex),\n/* harmony export */   fromHex: () => (/* binding */ fromHex),\n/* harmony export */   fromLegacy: () => (/* binding */ fromLegacy),\n/* harmony export */   fromRpc: () => (/* binding */ fromRpc),\n/* harmony export */   fromTuple: () => (/* binding */ fromTuple),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   toDerBytes: () => (/* binding */ toDerBytes),\n/* harmony export */   toDerHex: () => (/* binding */ toDerHex),\n/* harmony export */   toHex: () => (/* binding */ toHex),\n/* harmony export */   toLegacy: () => (/* binding */ toLegacy),\n/* harmony export */   toRpc: () => (/* binding */ toRpc),\n/* harmony export */   toTuple: () => (/* binding */ toTuple),\n/* harmony export */   vToYParity: () => (/* binding */ vToYParity),\n/* harmony export */   validate: () => (/* binding */ validate),\n/* harmony export */   yParityToV: () => (/* binding */ yParityToV)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Json_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Json.js */ \"(ssr)/./node_modules/ox/_esm/core/Json.js\");\n/* harmony import */ var _Solidity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Solidity.js */ \"(ssr)/./node_modules/ox/_esm/core/Solidity.js\");\n\n\n\n\n\n\n/**\n * Asserts that a Signature is valid.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.assert({\n *   r: -49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @error: InvalidSignatureRError:\n * // @error: Value `-549...n` is an invalid r value.\n * // @error: r must be a positive integer less than 2^256.\n * ```\n *\n * @param signature - The signature object to assert.\n */ function assert(signature, options = {}) {\n    const { recovered } = options;\n    if (typeof signature.r === \"undefined\") throw new MissingPropertiesError({\n        signature\n    });\n    if (typeof signature.s === \"undefined\") throw new MissingPropertiesError({\n        signature\n    });\n    if (recovered && typeof signature.yParity === \"undefined\") throw new MissingPropertiesError({\n        signature\n    });\n    if (signature.r < 0n || signature.r > _Solidity_js__WEBPACK_IMPORTED_MODULE_0__.maxUint256) throw new InvalidRError({\n        value: signature.r\n    });\n    if (signature.s < 0n || signature.s > _Solidity_js__WEBPACK_IMPORTED_MODULE_0__.maxUint256) throw new InvalidSError({\n        value: signature.s\n    });\n    if (typeof signature.yParity === \"number\" && signature.yParity !== 0 && signature.yParity !== 1) throw new InvalidYParityError({\n        value: signature.yParity\n    });\n}\n/**\n * Deserializes a {@link ox#Bytes.Bytes} signature into a structured {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * Signature.fromBytes(new Uint8Array([128, 3, 131, ...]))\n * // @log: { r: 5231...n, s: 3522...n, yParity: 0 }\n * ```\n *\n * @param signature - The serialized signature.\n * @returns The deserialized {@link ox#Signature.Signature}.\n */ function fromBytes(signature) {\n    return fromHex(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(signature));\n}\n/**\n * Deserializes a {@link ox#Hex.Hex} signature into a structured {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.fromHex('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c')\n * // @log: { r: 5231...n, s: 3522...n, yParity: 0 }\n * ```\n *\n * @param serialized - The serialized signature.\n * @returns The deserialized {@link ox#Signature.Signature}.\n */ function fromHex(signature) {\n    if (signature.length !== 130 && signature.length !== 132) throw new InvalidSerializedSizeError({\n        signature\n    });\n    const r = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(signature, 0, 32));\n    const s = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(signature, 32, 64));\n    const yParity = (()=>{\n        const yParity = Number(`0x${signature.slice(130)}`);\n        if (Number.isNaN(yParity)) return undefined;\n        try {\n            return vToYParity(yParity);\n        } catch  {\n            throw new InvalidYParityError({\n                value: yParity\n            });\n        }\n    })();\n    if (typeof yParity === \"undefined\") return {\n        r,\n        s\n    };\n    return {\n        r,\n        s,\n        yParity\n    };\n}\n/**\n * Extracts a {@link ox#Signature.Signature} from an arbitrary object that may include signature properties.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * Signature.extract({\n *   baz: 'barry',\n *   foo: 'bar',\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n *   zebra: 'stripes',\n * })\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1\n * // @log: }\n * ```\n *\n * @param value - The arbitrary object to extract the signature from.\n * @returns The extracted {@link ox#Signature.Signature}.\n */ function extract(value) {\n    if (typeof value.r === \"undefined\") return undefined;\n    if (typeof value.s === \"undefined\") return undefined;\n    return from(value);\n}\n/**\n * Instantiates a typed {@link ox#Signature.Signature} object from a {@link ox#Signature.Signature}, {@link ox#Signature.Legacy}, {@link ox#Bytes.Bytes}, or {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db801')\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1,\n * // @log: }\n * ```\n *\n * @example\n * ### From Legacy\n *\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from({\n *   r: 47323457007453657207889730243826965761922296599680473886588287015755652701072n,\n *   s: 57228803202727131502949358313456071280488184270258293674242124340113824882788n,\n *   v: 27,\n * })\n * // @log: {\n * // @log:   r: 47323457007453657207889730243826965761922296599680473886588287015755652701072n,\n * // @log:   s: 57228803202727131502949358313456071280488184270258293674242124340113824882788n,\n * // @log:   yParity: 0\n * // @log: }\n * ```\n *\n * @param signature - The signature value to instantiate.\n * @returns The instantiated {@link ox#Signature.Signature}.\n */ function from(signature) {\n    const signature_ = (()=>{\n        if (typeof signature === \"string\") return fromHex(signature);\n        if (signature instanceof Uint8Array) return fromBytes(signature);\n        if (typeof signature.r === \"string\") return fromRpc(signature);\n        if (signature.v) return fromLegacy(signature);\n        return {\n            r: signature.r,\n            s: signature.s,\n            ...typeof signature.yParity !== \"undefined\" ? {\n                yParity: signature.yParity\n            } : {}\n        };\n    })();\n    assert(signature_);\n    return signature_;\n}\n/**\n * Converts a DER-encoded signature to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromDerBytes(new Uint8Array([132, 51, 23, ...]))\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log: }\n * ```\n *\n * @param signature - The DER-encoded signature to convert.\n * @returns The {@link ox#Signature.Signature}.\n */ function fromDerBytes(signature) {\n    return fromDerHex(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(signature));\n}\n/**\n * Converts a DER-encoded signature to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromDerHex('0x304402206e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf02204a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db8')\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log: }\n * ```\n *\n * @param signature - The DER-encoded signature to convert.\n * @returns The {@link ox#Signature.Signature}.\n */ function fromDerHex(signature) {\n    const { r, s } = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.Signature.fromDER(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.from(signature).slice(2));\n    return {\n        r,\n        s\n    };\n}\n/**\n * Converts a {@link ox#Signature.Legacy} into a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const legacy = Signature.fromLegacy({ r: 1n, s: 2n, v: 28 })\n * // @log: { r: 1n, s: 2n, yParity: 1 }\n * ```\n *\n * @param signature - The {@link ox#Signature.Legacy} to convert.\n * @returns The converted {@link ox#Signature.Signature}.\n */ function fromLegacy(signature) {\n    return {\n        r: signature.r,\n        s: signature.s,\n        yParity: vToYParity(signature.v)\n    };\n}\n/**\n * Converts a {@link ox#Signature.Rpc} into a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromRpc({\n *   r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *   s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *   yParity: '0x0',\n * })\n * ```\n *\n * @param signature - The {@link ox#Signature.Rpc} to convert.\n * @returns The converted {@link ox#Signature.Signature}.\n */ function fromRpc(signature) {\n    const yParity = (()=>{\n        const v = signature.v ? Number(signature.v) : undefined;\n        let yParity = signature.yParity ? Number(signature.yParity) : undefined;\n        if (typeof v === \"number\" && typeof yParity !== \"number\") yParity = vToYParity(v);\n        if (typeof yParity !== \"number\") throw new InvalidYParityError({\n            value: signature.yParity\n        });\n        return yParity;\n    })();\n    return {\n        r: BigInt(signature.r),\n        s: BigInt(signature.s),\n        yParity\n    };\n}\n/**\n * Converts a {@link ox#Signature.Tuple} to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromTuple(['0x01', '0x7b', '0x1c8'])\n * // @log: {\n * // @log:   r: 123n,\n * // @log:   s: 456n,\n * // @log:   yParity: 1,\n * // @log: }\n * ```\n *\n * @param tuple - The {@link ox#Signature.Tuple} to convert.\n * @returns The {@link ox#Signature.Signature}.\n */ function fromTuple(tuple) {\n    const [yParity, r, s] = tuple;\n    return from({\n        r: r === \"0x\" ? 0n : BigInt(r),\n        s: s === \"0x\" ? 0n : BigInt(s),\n        yParity: yParity === \"0x\" ? 0 : Number(yParity)\n    });\n}\n/**\n * Serializes a {@link ox#Signature.Signature} to {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toBytes({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * // @log: Uint8Array [102, 16, 10, ...]\n * ```\n *\n * @param signature - The signature to serialize.\n * @returns The serialized signature.\n */ function toBytes(signature) {\n    return _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.fromHex(toHex(signature));\n}\n/**\n * Serializes a {@link ox#Signature.Signature} to {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toHex({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * // @log: '0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c'\n * ```\n *\n * @param signature - The signature to serialize.\n * @returns The serialized signature.\n */ function toHex(signature) {\n    assert(signature);\n    const r = signature.r;\n    const s = signature.s;\n    const signature_ = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.concat(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(r, {\n        size: 32\n    }), _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(s, {\n        size: 32\n    }), // If the signature is recovered, add the recovery byte to the signature.\n    typeof signature.yParity === \"number\" ? _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(yParityToV(signature.yParity), {\n        size: 1\n    }) : \"0x\");\n    return signature_;\n}\n/**\n * Converts a {@link ox#Signature.Signature} to DER-encoded format.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * })\n *\n * const signature_der = Signature.toDerBytes(signature)\n * // @log: Uint8Array [132, 51, 23, ...]\n * ```\n *\n * @param signature - The signature to convert.\n * @returns The DER-encoded signature.\n */ function toDerBytes(signature) {\n    const sig = new _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.Signature(signature.r, signature.s);\n    return sig.toDERRawBytes();\n}\n/**\n * Converts a {@link ox#Signature.Signature} to DER-encoded format.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * })\n *\n * const signature_der = Signature.toDerHex(signature)\n * // @log: '0x304402206e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf02204a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db8'\n * ```\n *\n * @param signature - The signature to convert.\n * @returns The DER-encoded signature.\n */ function toDerHex(signature) {\n    const sig = new _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.Signature(signature.r, signature.s);\n    return `0x${sig.toDERHex()}`;\n}\n/**\n * Converts a {@link ox#Signature.Signature} into a {@link ox#Signature.Legacy}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const legacy = Signature.toLegacy({ r: 1n, s: 2n, yParity: 1 })\n * // @log: { r: 1n, s: 2n, v: 28 }\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The converted {@link ox#Signature.Legacy}.\n */ function toLegacy(signature) {\n    return {\n        r: signature.r,\n        s: signature.s,\n        v: yParityToV(signature.yParity)\n    };\n}\n/**\n * Converts a {@link ox#Signature.Signature} into a {@link ox#Signature.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toRpc({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The converted {@link ox#Signature.Rpc}.\n */ function toRpc(signature) {\n    const { r, s, yParity } = signature;\n    return {\n        r: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(r, {\n            size: 32\n        }),\n        s: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(s, {\n            size: 32\n        }),\n        yParity: yParity === 0 ? \"0x0\" : \"0x1\"\n    };\n}\n/**\n * Converts a {@link ox#Signature.Signature} to a serialized {@link ox#Signature.Tuple} to be used for signatures in Transaction Envelopes, EIP-7702 Authorization Lists, etc.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signatureTuple = Signature.toTuple({\n *   r: 123n,\n *   s: 456n,\n *   yParity: 1,\n * })\n * // @log: [yParity: '0x01', r: '0x7b', s: '0x1c8']\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The {@link ox#Signature.Tuple}.\n */ function toTuple(signature) {\n    const { r, s, yParity } = signature;\n    return [\n        yParity ? \"0x01\" : \"0x\",\n        r === 0n ? \"0x\" : _Hex_js__WEBPACK_IMPORTED_MODULE_1__.trimLeft(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(r)),\n        s === 0n ? \"0x\" : _Hex_js__WEBPACK_IMPORTED_MODULE_1__.trimLeft(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(s))\n    ];\n}\n/**\n * Validates a Signature. Returns `true` if the signature is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const valid = Signature.validate({\n *   r: -49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @log: false\n * ```\n *\n * @param signature - The signature object to assert.\n */ function validate(signature, options = {}) {\n    try {\n        assert(signature, options);\n        return true;\n    } catch  {\n        return false;\n    }\n}\n/**\n * Converts a ECDSA `v` value to a `yParity` value.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const yParity = Signature.vToYParity(28)\n * // @log: 1\n * ```\n *\n * @param v - The ECDSA `v` value to convert.\n * @returns The `yParity` value.\n */ function vToYParity(v) {\n    if (v === 0 || v === 27) return 0;\n    if (v === 1 || v === 28) return 1;\n    if (v >= 35) return v % 2 === 0 ? 1 : 0;\n    throw new InvalidVError({\n        value: v\n    });\n}\n/**\n * Converts a ECDSA `v` value to a `yParity` value.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const v = Signature.yParityToV(1)\n * // @log: 28\n * ```\n *\n * @param yParity - The ECDSA `yParity` value to convert.\n * @returns The `v` value.\n */ function yParityToV(yParity) {\n    if (yParity === 0) return 27;\n    if (yParity === 1) return 28;\n    throw new InvalidYParityError({\n        value: yParity\n    });\n}\n/** Thrown when the serialized signature is of an invalid size. */ class InvalidSerializedSizeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ signature }){\n        super(`Value \\`${signature}\\` is an invalid signature size.`, {\n            metaMessages: [\n                \"Expected: 64 bytes or 65 bytes.\",\n                `Received ${_Hex_js__WEBPACK_IMPORTED_MODULE_1__.size(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.from(signature))} bytes.`\n            ]\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Signature.InvalidSerializedSizeError\"\n        });\n    }\n}\n/** Thrown when the signature is missing either an `r`, `s`, or `yParity` property. */ class MissingPropertiesError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ signature }){\n        super(`Signature \\`${_Json_js__WEBPACK_IMPORTED_MODULE_5__.stringify(signature)}\\` is missing either an \\`r\\`, \\`s\\`, or \\`yParity\\` property.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Signature.MissingPropertiesError\"\n        });\n    }\n}\n/** Thrown when the signature has an invalid `r` value. */ class InvalidRError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ value }){\n        super(`Value \\`${value}\\` is an invalid r value. r must be a positive integer less than 2^256.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Signature.InvalidRError\"\n        });\n    }\n}\n/** Thrown when the signature has an invalid `s` value. */ class InvalidSError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ value }){\n        super(`Value \\`${value}\\` is an invalid s value. s must be a positive integer less than 2^256.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Signature.InvalidSError\"\n        });\n    }\n}\n/** Thrown when the signature has an invalid `yParity` value. */ class InvalidYParityError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ value }){\n        super(`Value \\`${value}\\` is an invalid y-parity value. Y-parity must be 0 or 1.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Signature.InvalidYParityError\"\n        });\n    }\n}\n/** Thrown when the signature has an invalid `v` value. */ class InvalidVError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ value }){\n        super(`Value \\`${value}\\` is an invalid v value. v must be 27, 28 or >=35.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Signature.InvalidVError\"\n        });\n    }\n} //# sourceMappingURL=Signature.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1NpZ25hdHVyZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvRDtBQUNoQjtBQUNFO0FBQ047QUFDRTtBQUNRO0FBQzFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FrQkMsR0FDTSxTQUFTTSxPQUFPQyxTQUFTLEVBQUVDLFVBQVUsQ0FBQyxDQUFDO0lBQzFDLE1BQU0sRUFBRUMsU0FBUyxFQUFFLEdBQUdEO0lBQ3RCLElBQUksT0FBT0QsVUFBVUcsQ0FBQyxLQUFLLGFBQ3ZCLE1BQU0sSUFBSUMsdUJBQXVCO1FBQUVKO0lBQVU7SUFDakQsSUFBSSxPQUFPQSxVQUFVSyxDQUFDLEtBQUssYUFDdkIsTUFBTSxJQUFJRCx1QkFBdUI7UUFBRUo7SUFBVTtJQUNqRCxJQUFJRSxhQUFhLE9BQU9GLFVBQVVNLE9BQU8sS0FBSyxhQUMxQyxNQUFNLElBQUlGLHVCQUF1QjtRQUFFSjtJQUFVO0lBQ2pELElBQUlBLFVBQVVHLENBQUMsR0FBRyxFQUFFLElBQUlILFVBQVVHLENBQUMsR0FBR0wsb0RBQW1CLEVBQ3JELE1BQU0sSUFBSVUsY0FBYztRQUFFQyxPQUFPVCxVQUFVRyxDQUFDO0lBQUM7SUFDakQsSUFBSUgsVUFBVUssQ0FBQyxHQUFHLEVBQUUsSUFBSUwsVUFBVUssQ0FBQyxHQUFHUCxvREFBbUIsRUFDckQsTUFBTSxJQUFJWSxjQUFjO1FBQUVELE9BQU9ULFVBQVVLLENBQUM7SUFBQztJQUNqRCxJQUFJLE9BQU9MLFVBQVVNLE9BQU8sS0FBSyxZQUM3Qk4sVUFBVU0sT0FBTyxLQUFLLEtBQ3RCTixVQUFVTSxPQUFPLEtBQUssR0FDdEIsTUFBTSxJQUFJSyxvQkFBb0I7UUFBRUYsT0FBT1QsVUFBVU0sT0FBTztJQUFDO0FBQ2pFO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0NBY0MsR0FDTSxTQUFTTSxVQUFVWixTQUFTO0lBQy9CLE9BQU9hLFFBQVFqQiw4Q0FBYSxDQUFD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O1lBQ1ZsRCxPQUFPO1FBQ1g7SUFDSjtBQUNKO0FBQ0Esd0RBQXdELEdBQ2pELE1BQU0wQyxzQkFBc0J4RCxpREFBZ0I7SUFDL0MwRCxZQUFZLEVBQUU1QyxLQUFLLEVBQUUsQ0FBRTtRQUNuQixLQUFLLENBQUMsQ0FBQyxRQUFRLEVBQUVBLE1BQU0sbURBQW1ELENBQUM7UUFDM0U4QyxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLFFBQVE7WUFDaENDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZsRCxPQUFPO1FBQ1g7SUFDSjtBQUNKLEVBQ0EscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xhdy13b3Jrcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvU2lnbmF0dXJlLmpzP2VkZWYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc2VjcDI1NmsxIH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9zZWNwMjU2azEnO1xuaW1wb3J0ICogYXMgQnl0ZXMgZnJvbSAnLi9CeXRlcy5qcyc7XG5pbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSAnLi9FcnJvcnMuanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbmltcG9ydCAqIGFzIEpzb24gZnJvbSAnLi9Kc29uLmpzJztcbmltcG9ydCAqIGFzIFNvbGlkaXR5IGZyb20gJy4vU29saWRpdHkuanMnO1xuLyoqXG4gKiBBc3NlcnRzIHRoYXQgYSBTaWduYXR1cmUgaXMgdmFsaWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBTaWduYXR1cmUuYXNzZXJ0KHtcbiAqICAgcjogLTQ5NzgyNzUzMzQ4NDYyNDk0MTk5ODIzNzEyNzAwMDA0NTUyMzk0NDI1NzE5MDE0NDU4OTE4ODcxNDUyMzI5Nzc0OTEwNDUwNjA3ODA3bixcbiAqICAgczogMzM3MjY2OTU5Nzc4NDQ0NzYyMTQ2NzY5MTMyMDExNDA0ODExMDIyMjU0NjkyODQzMDcwMTY5Mzc5MTU1OTU3NTYzNTU5Mjg0MTk3NjhuLFxuICogICB5UGFyaXR5OiAxLFxuICogfSlcbiAqIC8vIEBlcnJvcjogSW52YWxpZFNpZ25hdHVyZVJFcnJvcjpcbiAqIC8vIEBlcnJvcjogVmFsdWUgYC01NDkuLi5uYCBpcyBhbiBpbnZhbGlkIHIgdmFsdWUuXG4gKiAvLyBAZXJyb3I6IHIgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgbGVzcyB0aGFuIDJeMjU2LlxuICogYGBgXG4gKlxuICogQHBhcmFtIHNpZ25hdHVyZSAtIFRoZSBzaWduYXR1cmUgb2JqZWN0IHRvIGFzc2VydC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydChzaWduYXR1cmUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgcmVjb3ZlcmVkIH0gPSBvcHRpb25zO1xuICAgIGlmICh0eXBlb2Ygc2lnbmF0dXJlLnIgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICB0aHJvdyBuZXcgTWlzc2luZ1Byb3BlcnRpZXNFcnJvcih7IHNpZ25hdHVyZSB9KTtcbiAgICBpZiAodHlwZW9mIHNpZ25hdHVyZS5zID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgdGhyb3cgbmV3IE1pc3NpbmdQcm9wZXJ0aWVzRXJyb3IoeyBzaWduYXR1cmUgfSk7XG4gICAgaWYgKHJlY292ZXJlZCAmJiB0eXBlb2Ygc2lnbmF0dXJlLnlQYXJpdHkgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICB0aHJvdyBuZXcgTWlzc2luZ1Byb3BlcnRpZXNFcnJvcih7IHNpZ25hdHVyZSB9KTtcbiAgICBpZiAoc2lnbmF0dXJlLnIgPCAwbiB8fCBzaWduYXR1cmUuciA+IFNvbGlkaXR5Lm1heFVpbnQyNTYpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkUkVycm9yKHsgdmFsdWU6IHNpZ25hdHVyZS5yIH0pO1xuICAgIGlmIChzaWduYXR1cmUucyA8IDBuIHx8IHNpZ25hdHVyZS5zID4gU29saWRpdHkubWF4VWludDI1NilcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRTRXJyb3IoeyB2YWx1ZTogc2lnbmF0dXJlLnMgfSk7XG4gICAgaWYgKHR5cGVvZiBzaWduYXR1cmUueVBhcml0eSA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgc2lnbmF0dXJlLnlQYXJpdHkgIT09IDAgJiZcbiAgICAgICAgc2lnbmF0dXJlLnlQYXJpdHkgIT09IDEpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkWVBhcml0eUVycm9yKHsgdmFsdWU6IHNpZ25hdHVyZS55UGFyaXR5IH0pO1xufVxuLyoqXG4gKiBEZXNlcmlhbGl6ZXMgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHNpZ25hdHVyZSBpbnRvIGEgc3RydWN0dXJlZCB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIFNpZ25hdHVyZS5mcm9tQnl0ZXMobmV3IFVpbnQ4QXJyYXkoWzEyOCwgMywgMTMxLCAuLi5dKSlcbiAqIC8vIEBsb2c6IHsgcjogNTIzMS4uLm4sIHM6IDM1MjIuLi5uLCB5UGFyaXR5OiAwIH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUgc2VyaWFsaXplZCBzaWduYXR1cmUuXG4gKiBAcmV0dXJucyBUaGUgZGVzZXJpYWxpemVkIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21CeXRlcyhzaWduYXR1cmUpIHtcbiAgICByZXR1cm4gZnJvbUhleChIZXguZnJvbUJ5dGVzKHNpZ25hdHVyZSkpO1xufVxuLyoqXG4gKiBEZXNlcmlhbGl6ZXMgYSB7QGxpbmsgb3gjSGV4LkhleH0gc2lnbmF0dXJlIGludG8gYSBzdHJ1Y3R1cmVkIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIFNpZ25hdHVyZS5mcm9tSGV4KCcweDZlMTAwYTM1MmVjNmFkMWI3MDgwMjI5MGUxOGFlZWQxOTA3MDQ5NzM1NzBmM2I4ZWQ0MmNiOTgwOGUyZWE2YmY0YTkwYTIyOWEyNDQ0OTViNDE4OTA5ODc4MDZmY2JkMmQ1ZDIzZmMwZGJlNWY1MjU2YzI2MTNjMDM5ZDc2ZGI4MWMnKVxuICogLy8gQGxvZzogeyByOiA1MjMxLi4ubiwgczogMzUyMi4uLm4sIHlQYXJpdHk6IDAgfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHNlcmlhbGl6ZWQgLSBUaGUgc2VyaWFsaXplZCBzaWduYXR1cmUuXG4gKiBAcmV0dXJucyBUaGUgZGVzZXJpYWxpemVkIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21IZXgoc2lnbmF0dXJlKSB7XG4gICAgaWYgKHNpZ25hdHVyZS5sZW5ndGggIT09IDEzMCAmJiBzaWduYXR1cmUubGVuZ3RoICE9PSAxMzIpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkU2VyaWFsaXplZFNpemVFcnJvcih7IHNpZ25hdHVyZSB9KTtcbiAgICBjb25zdCByID0gQmlnSW50KEhleC5zbGljZShzaWduYXR1cmUsIDAsIDMyKSk7XG4gICAgY29uc3QgcyA9IEJpZ0ludChIZXguc2xpY2Uoc2lnbmF0dXJlLCAzMiwgNjQpKTtcbiAgICBjb25zdCB5UGFyaXR5ID0gKCgpID0+IHtcbiAgICAgICAgY29uc3QgeVBhcml0eSA9IE51bWJlcihgMHgke3NpZ25hdHVyZS5zbGljZSgxMzApfWApO1xuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKHlQYXJpdHkpKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB2VG9ZUGFyaXR5KHlQYXJpdHkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkWVBhcml0eUVycm9yKHsgdmFsdWU6IHlQYXJpdHkgfSk7XG4gICAgICAgIH1cbiAgICB9KSgpO1xuICAgIGlmICh0eXBlb2YgeVBhcml0eSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByLFxuICAgICAgICAgICAgcyxcbiAgICAgICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICByLFxuICAgICAgICBzLFxuICAgICAgICB5UGFyaXR5LFxuICAgIH07XG59XG4vKipcbiAqIEV4dHJhY3RzIGEge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9IGZyb20gYW4gYXJiaXRyYXJ5IG9iamVjdCB0aGF0IG1heSBpbmNsdWRlIHNpZ25hdHVyZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBTaWduYXR1cmUuZXh0cmFjdCh7XG4gKiAgIGJhejogJ2JhcnJ5JyxcbiAqICAgZm9vOiAnYmFyJyxcbiAqICAgcjogNDk3ODI3NTMzNDg0NjI0OTQxOTk4MjM3MTI3MDAwMDQ1NTIzOTQ0MjU3MTkwMTQ0NTg5MTg4NzE0NTIzMjk3NzQ5MTA0NTA2MDc4MDduLFxuICogICBzOiAzMzcyNjY5NTk3Nzg0NDQ3NjIxNDY3NjkxMzIwMTE0MDQ4MTEwMjIyNTQ2OTI4NDMwNzAxNjkzNzkxNTU5NTc1NjM1NTkyODQxOTc2OG4sXG4gKiAgIHlQYXJpdHk6IDEsXG4gKiAgIHplYnJhOiAnc3RyaXBlcycsXG4gKiB9KVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICByOiA0OTc4Mjc1MzM0ODQ2MjQ5NDE5OTgyMzcxMjcwMDAwNDU1MjM5NDQyNTcxOTAxNDQ1ODkxODg3MTQ1MjMyOTc3NDkxMDQ1MDYwNzgwN24sXG4gKiAvLyBAbG9nOiAgIHM6IDMzNzI2Njk1OTc3ODQ0NDc2MjE0Njc2OTEzMjAxMTQwNDgxMTAyMjI1NDY5Mjg0MzA3MDE2OTM3OTE1NTk1NzU2MzU1OTI4NDE5NzY4bixcbiAqIC8vIEBsb2c6ICAgeVBhcml0eTogMVxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGFyYml0cmFyeSBvYmplY3QgdG8gZXh0cmFjdCB0aGUgc2lnbmF0dXJlIGZyb20uXG4gKiBAcmV0dXJucyBUaGUgZXh0cmFjdGVkIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3QodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlLnIgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGlmICh0eXBlb2YgdmFsdWUucyA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIGZyb20odmFsdWUpO1xufVxuLyoqXG4gKiBJbnN0YW50aWF0ZXMgYSB0eXBlZCB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0gb2JqZWN0IGZyb20gYSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0sIHtAbGluayBveCNTaWduYXR1cmUuTGVnYWN5fSwge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSwgb3Ige0BsaW5rIG94I0hleC5IZXh9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogU2lnbmF0dXJlLmZyb20oe1xuICogICByOiA0OTc4Mjc1MzM0ODQ2MjQ5NDE5OTgyMzcxMjcwMDAwNDU1MjM5NDQyNTcxOTAxNDQ1ODkxODg3MTQ1MjMyOTc3NDkxMDQ1MDYwNzgwN24sXG4gKiAgIHM6IDMzNzI2Njk1OTc3ODQ0NDc2MjE0Njc2OTEzMjAxMTQwNDgxMTAyMjI1NDY5Mjg0MzA3MDE2OTM3OTE1NTk1NzU2MzU1OTI4NDE5NzY4bixcbiAqICAgeVBhcml0eTogMSxcbiAqIH0pXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIHI6IDQ5NzgyNzUzMzQ4NDYyNDk0MTk5ODIzNzEyNzAwMDA0NTUyMzk0NDI1NzE5MDE0NDU4OTE4ODcxNDUyMzI5Nzc0OTEwNDUwNjA3ODA3bixcbiAqIC8vIEBsb2c6ICAgczogMzM3MjY2OTU5Nzc4NDQ0NzYyMTQ2NzY5MTMyMDExNDA0ODExMDIyMjU0NjkyODQzMDcwMTY5Mzc5MTU1OTU3NTYzNTU5Mjg0MTk3NjhuLFxuICogLy8gQGxvZzogICB5UGFyaXR5OiAxXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEZyb20gU2VyaWFsaXplZFxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBTaWduYXR1cmUuZnJvbSgnMHg2ZTEwMGEzNTJlYzZhZDFiNzA4MDIyOTBlMThhZWVkMTkwNzA0OTczNTcwZjNiOGVkNDJjYjk4MDhlMmVhNmJmNGE5MGEyMjlhMjQ0NDk1YjQxODkwOTg3ODA2ZmNiZDJkNWQyM2ZjMGRiZTVmNTI1NmMyNjEzYzAzOWQ3NmRiODAxJylcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgcjogNDk3ODI3NTMzNDg0NjI0OTQxOTk4MjM3MTI3MDAwMDQ1NTIzOTQ0MjU3MTkwMTQ0NTg5MTg4NzE0NTIzMjk3NzQ5MTA0NTA2MDc4MDduLFxuICogLy8gQGxvZzogICBzOiAzMzcyNjY5NTk3Nzg0NDQ3NjIxNDY3NjkxMzIwMTE0MDQ4MTEwMjIyNTQ2OTI4NDMwNzAxNjkzNzkxNTU5NTc1NjM1NTkyODQxOTc2OG4sXG4gKiAvLyBAbG9nOiAgIHlQYXJpdHk6IDEsXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEZyb20gTGVnYWN5XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIFNpZ25hdHVyZS5mcm9tKHtcbiAqICAgcjogNDczMjM0NTcwMDc0NTM2NTcyMDc4ODk3MzAyNDM4MjY5NjU3NjE5MjIyOTY1OTk2ODA0NzM4ODY1ODgyODcwMTU3NTU2NTI3MDEwNzJuLFxuICogICBzOiA1NzIyODgwMzIwMjcyNzEzMTUwMjk0OTM1ODMxMzQ1NjA3MTI4MDQ4ODE4NDI3MDI1ODI5MzY3NDI0MjEyNDM0MDExMzgyNDg4Mjc4OG4sXG4gKiAgIHY6IDI3LFxuICogfSlcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgcjogNDczMjM0NTcwMDc0NTM2NTcyMDc4ODk3MzAyNDM4MjY5NjU3NjE5MjIyOTY1OTk2ODA0NzM4ODY1ODgyODcwMTU3NTU2NTI3MDEwNzJuLFxuICogLy8gQGxvZzogICBzOiA1NzIyODgwMzIwMjcyNzEzMTUwMjk0OTM1ODMxMzQ1NjA3MTI4MDQ4ODE4NDI3MDI1ODI5MzY3NDI0MjEyNDM0MDExMzgyNDg4Mjc4OG4sXG4gKiAvLyBAbG9nOiAgIHlQYXJpdHk6IDBcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUgc2lnbmF0dXJlIHZhbHVlIHRvIGluc3RhbnRpYXRlLlxuICogQHJldHVybnMgVGhlIGluc3RhbnRpYXRlZCB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tKHNpZ25hdHVyZSkge1xuICAgIGNvbnN0IHNpZ25hdHVyZV8gPSAoKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHNpZ25hdHVyZSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICByZXR1cm4gZnJvbUhleChzaWduYXR1cmUpO1xuICAgICAgICBpZiAoc2lnbmF0dXJlIGluc3RhbmNlb2YgVWludDhBcnJheSlcbiAgICAgICAgICAgIHJldHVybiBmcm9tQnl0ZXMoc2lnbmF0dXJlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBzaWduYXR1cmUuciA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICByZXR1cm4gZnJvbVJwYyhzaWduYXR1cmUpO1xuICAgICAgICBpZiAoc2lnbmF0dXJlLnYpXG4gICAgICAgICAgICByZXR1cm4gZnJvbUxlZ2FjeShzaWduYXR1cmUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcjogc2lnbmF0dXJlLnIsXG4gICAgICAgICAgICBzOiBzaWduYXR1cmUucyxcbiAgICAgICAgICAgIC4uLih0eXBlb2Ygc2lnbmF0dXJlLnlQYXJpdHkgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgPyB7IHlQYXJpdHk6IHNpZ25hdHVyZS55UGFyaXR5IH1cbiAgICAgICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgfTtcbiAgICB9KSgpO1xuICAgIGFzc2VydChzaWduYXR1cmVfKTtcbiAgICByZXR1cm4gc2lnbmF0dXJlXztcbn1cbi8qKlxuICogQ29udmVydHMgYSBERVItZW5jb2RlZCBzaWduYXR1cmUgdG8gYSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ25hdHVyZS5mcm9tRGVyQnl0ZXMobmV3IFVpbnQ4QXJyYXkoWzEzMiwgNTEsIDIzLCAuLi5dKSlcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgcjogNDk3ODI3NTMzNDg0NjI0OTQxOTk4MjM3MTI3MDAwMDQ1NTIzOTQ0MjU3MTkwMTQ0NTg5MTg4NzE0NTIzMjk3NzQ5MTA0NTA2MDc4MDduLFxuICogLy8gQGxvZzogICBzOiAzMzcyNjY5NTk3Nzg0NDQ3NjIxNDY3NjkxMzIwMTE0MDQ4MTEwMjIyNTQ2OTI4NDMwNzAxNjkzNzkxNTU5NTc1NjM1NTkyODQxOTc2OG4sXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2lnbmF0dXJlIC0gVGhlIERFUi1lbmNvZGVkIHNpZ25hdHVyZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21EZXJCeXRlcyhzaWduYXR1cmUpIHtcbiAgICByZXR1cm4gZnJvbURlckhleChIZXguZnJvbUJ5dGVzKHNpZ25hdHVyZSkpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIERFUi1lbmNvZGVkIHNpZ25hdHVyZSB0byBhIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ25hdHVyZS5mcm9tRGVySGV4KCcweDMwNDQwMjIwNmUxMDBhMzUyZWM2YWQxYjcwODAyMjkwZTE4YWVlZDE5MDcwNDk3MzU3MGYzYjhlZDQyY2I5ODA4ZTJlYTZiZjAyMjA0YTkwYTIyOWEyNDQ0OTViNDE4OTA5ODc4MDZmY2JkMmQ1ZDIzZmMwZGJlNWY1MjU2YzI2MTNjMDM5ZDc2ZGI4JylcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgcjogNDk3ODI3NTMzNDg0NjI0OTQxOTk4MjM3MTI3MDAwMDQ1NTIzOTQ0MjU3MTkwMTQ0NTg5MTg4NzE0NTIzMjk3NzQ5MTA0NTA2MDc4MDduLFxuICogLy8gQGxvZzogICBzOiAzMzcyNjY5NTk3Nzg0NDQ3NjIxNDY3NjkxMzIwMTE0MDQ4MTEwMjIyNTQ2OTI4NDMwNzAxNjkzNzkxNTU5NTc1NjM1NTkyODQxOTc2OG4sXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2lnbmF0dXJlIC0gVGhlIERFUi1lbmNvZGVkIHNpZ25hdHVyZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21EZXJIZXgoc2lnbmF0dXJlKSB7XG4gICAgY29uc3QgeyByLCBzIH0gPSBzZWNwMjU2azEuU2lnbmF0dXJlLmZyb21ERVIoSGV4LmZyb20oc2lnbmF0dXJlKS5zbGljZSgyKSk7XG4gICAgcmV0dXJuIHsgciwgcyB9O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIHtAbGluayBveCNTaWduYXR1cmUuTGVnYWN5fSBpbnRvIGEge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgbGVnYWN5ID0gU2lnbmF0dXJlLmZyb21MZWdhY3koeyByOiAxbiwgczogMm4sIHY6IDI4IH0pXG4gKiAvLyBAbG9nOiB7IHI6IDFuLCBzOiAybiwgeVBhcml0eTogMSB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2lnbmF0dXJlIC0gVGhlIHtAbGluayBveCNTaWduYXR1cmUuTGVnYWN5fSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIGNvbnZlcnRlZCB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tTGVnYWN5KHNpZ25hdHVyZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHI6IHNpZ25hdHVyZS5yLFxuICAgICAgICBzOiBzaWduYXR1cmUucyxcbiAgICAgICAgeVBhcml0eTogdlRvWVBhcml0eShzaWduYXR1cmUudiksXG4gICAgfTtcbn1cbi8qKlxuICogQ29udmVydHMgYSB7QGxpbmsgb3gjU2lnbmF0dXJlLlJwY30gaW50byBhIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ25hdHVyZS5mcm9tUnBjKHtcbiAqICAgcjogJzB4NjM1ZGMyMDMzZTYwMTg1YmIzNjcwOWMyOWM3NWQ2NGVhNTFkZmJkOTFjMzJlZjRiZTE5OGU0Y2ViMTY5ZmI0ZCcsXG4gKiAgIHM6ICcweDUwYzI2NjdhYzRjNzcxMDcyNzQ2YWNmZGNmMWYxNDgzMzM2ZGNjYThiZDJkZjQ3Y2Q4MzE3NWRiZTYwZjA1NDAnLFxuICogICB5UGFyaXR5OiAnMHgwJyxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2lnbmF0dXJlIC0gVGhlIHtAbGluayBveCNTaWduYXR1cmUuUnBjfSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIGNvbnZlcnRlZCB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUnBjKHNpZ25hdHVyZSkge1xuICAgIGNvbnN0IHlQYXJpdHkgPSAoKCkgPT4ge1xuICAgICAgICBjb25zdCB2ID0gc2lnbmF0dXJlLnYgPyBOdW1iZXIoc2lnbmF0dXJlLnYpIDogdW5kZWZpbmVkO1xuICAgICAgICBsZXQgeVBhcml0eSA9IHNpZ25hdHVyZS55UGFyaXR5ID8gTnVtYmVyKHNpZ25hdHVyZS55UGFyaXR5KSA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgeVBhcml0eSAhPT0gJ251bWJlcicpXG4gICAgICAgICAgICB5UGFyaXR5ID0gdlRvWVBhcml0eSh2KTtcbiAgICAgICAgaWYgKHR5cGVvZiB5UGFyaXR5ICE9PSAnbnVtYmVyJylcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkWVBhcml0eUVycm9yKHsgdmFsdWU6IHNpZ25hdHVyZS55UGFyaXR5IH0pO1xuICAgICAgICByZXR1cm4geVBhcml0eTtcbiAgICB9KSgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHI6IEJpZ0ludChzaWduYXR1cmUuciksXG4gICAgICAgIHM6IEJpZ0ludChzaWduYXR1cmUucyksXG4gICAgICAgIHlQYXJpdHksXG4gICAgfTtcbn1cbi8qKlxuICogQ29udmVydHMgYSB7QGxpbmsgb3gjU2lnbmF0dXJlLlR1cGxlfSB0byBhIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ25hdHVyZS5mcm9tVHVwbGUoWycweDAxJywgJzB4N2InLCAnMHgxYzgnXSlcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgcjogMTIzbixcbiAqIC8vIEBsb2c6ICAgczogNDU2bixcbiAqIC8vIEBsb2c6ICAgeVBhcml0eTogMSxcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB0dXBsZSAtIFRoZSB7QGxpbmsgb3gjU2lnbmF0dXJlLlR1cGxlfSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21UdXBsZSh0dXBsZSkge1xuICAgIGNvbnN0IFt5UGFyaXR5LCByLCBzXSA9IHR1cGxlO1xuICAgIHJldHVybiBmcm9tKHtcbiAgICAgICAgcjogciA9PT0gJzB4JyA/IDBuIDogQmlnSW50KHIpLFxuICAgICAgICBzOiBzID09PSAnMHgnID8gMG4gOiBCaWdJbnQocyksXG4gICAgICAgIHlQYXJpdHk6IHlQYXJpdHkgPT09ICcweCcgPyAwIDogTnVtYmVyKHlQYXJpdHkpLFxuICAgIH0pO1xufVxuLyoqXG4gKiBTZXJpYWxpemVzIGEge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9IHRvIHtAbGluayBveCNCeXRlcy5CeXRlc30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTaWduYXR1cmUudG9CeXRlcyh7XG4gKiAgIHI6IDQ5NzgyNzUzMzQ4NDYyNDk0MTk5ODIzNzEyNzAwMDA0NTUyMzk0NDI1NzE5MDE0NDU4OTE4ODcxNDUyMzI5Nzc0OTEwNDUwNjA3ODA3bixcbiAqICAgczogMzM3MjY2OTU5Nzc4NDQ0NzYyMTQ2NzY5MTMyMDExNDA0ODExMDIyMjU0NjkyODQzMDcwMTY5Mzc5MTU1OTU3NTYzNTU5Mjg0MTk3NjhuLFxuICogICB5UGFyaXR5OiAxXG4gKiB9KVxuICogLy8gQGxvZzogVWludDhBcnJheSBbMTAyLCAxNiwgMTAsIC4uLl1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUgc2lnbmF0dXJlIHRvIHNlcmlhbGl6ZS5cbiAqIEByZXR1cm5zIFRoZSBzZXJpYWxpemVkIHNpZ25hdHVyZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQnl0ZXMoc2lnbmF0dXJlKSB7XG4gICAgcmV0dXJuIEJ5dGVzLmZyb21IZXgodG9IZXgoc2lnbmF0dXJlKSk7XG59XG4vKipcbiAqIFNlcmlhbGl6ZXMgYSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0gdG8ge0BsaW5rIG94I0hleC5IZXh9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2lnbmF0dXJlLnRvSGV4KHtcbiAqICAgcjogNDk3ODI3NTMzNDg0NjI0OTQxOTk4MjM3MTI3MDAwMDQ1NTIzOTQ0MjU3MTkwMTQ0NTg5MTg4NzE0NTIzMjk3NzQ5MTA0NTA2MDc4MDduLFxuICogICBzOiAzMzcyNjY5NTk3Nzg0NDQ3NjIxNDY3NjkxMzIwMTE0MDQ4MTEwMjIyNTQ2OTI4NDMwNzAxNjkzNzkxNTU5NTc1NjM1NTkyODQxOTc2OG4sXG4gKiAgIHlQYXJpdHk6IDFcbiAqIH0pXG4gKiAvLyBAbG9nOiAnMHg2ZTEwMGEzNTJlYzZhZDFiNzA4MDIyOTBlMThhZWVkMTkwNzA0OTczNTcwZjNiOGVkNDJjYjk4MDhlMmVhNmJmNGE5MGEyMjlhMjQ0NDk1YjQxODkwOTg3ODA2ZmNiZDJkNWQyM2ZjMGRiZTVmNTI1NmMyNjEzYzAzOWQ3NmRiODFjJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIHNpZ25hdHVyZSAtIFRoZSBzaWduYXR1cmUgdG8gc2VyaWFsaXplLlxuICogQHJldHVybnMgVGhlIHNlcmlhbGl6ZWQgc2lnbmF0dXJlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9IZXgoc2lnbmF0dXJlKSB7XG4gICAgYXNzZXJ0KHNpZ25hdHVyZSk7XG4gICAgY29uc3QgciA9IHNpZ25hdHVyZS5yO1xuICAgIGNvbnN0IHMgPSBzaWduYXR1cmUucztcbiAgICBjb25zdCBzaWduYXR1cmVfID0gSGV4LmNvbmNhdChIZXguZnJvbU51bWJlcihyLCB7IHNpemU6IDMyIH0pLCBIZXguZnJvbU51bWJlcihzLCB7IHNpemU6IDMyIH0pLCBcbiAgICAvLyBJZiB0aGUgc2lnbmF0dXJlIGlzIHJlY292ZXJlZCwgYWRkIHRoZSByZWNvdmVyeSBieXRlIHRvIHRoZSBzaWduYXR1cmUuXG4gICAgdHlwZW9mIHNpZ25hdHVyZS55UGFyaXR5ID09PSAnbnVtYmVyJ1xuICAgICAgICA/IEhleC5mcm9tTnVtYmVyKHlQYXJpdHlUb1Yoc2lnbmF0dXJlLnlQYXJpdHkpLCB7IHNpemU6IDEgfSlcbiAgICAgICAgOiAnMHgnKTtcbiAgICByZXR1cm4gc2lnbmF0dXJlXztcbn1cbi8qKlxuICogQ29udmVydHMgYSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0gdG8gREVSLWVuY29kZWQgZm9ybWF0LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2lnbmF0dXJlLmZyb20oe1xuICogICByOiA0OTc4Mjc1MzM0ODQ2MjQ5NDE5OTgyMzcxMjcwMDAwNDU1MjM5NDQyNTcxOTAxNDQ1ODkxODg3MTQ1MjMyOTc3NDkxMDQ1MDYwNzgwN24sXG4gKiAgIHM6IDMzNzI2Njk1OTc3ODQ0NDc2MjE0Njc2OTEzMjAxMTQwNDgxMTAyMjI1NDY5Mjg0MzA3MDE2OTM3OTE1NTk1NzU2MzU1OTI4NDE5NzY4bixcbiAqIH0pXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlX2RlciA9IFNpZ25hdHVyZS50b0RlckJ5dGVzKHNpZ25hdHVyZSlcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkgWzEzMiwgNTEsIDIzLCAuLi5dXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2lnbmF0dXJlIC0gVGhlIHNpZ25hdHVyZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIERFUi1lbmNvZGVkIHNpZ25hdHVyZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvRGVyQnl0ZXMoc2lnbmF0dXJlKSB7XG4gICAgY29uc3Qgc2lnID0gbmV3IHNlY3AyNTZrMS5TaWduYXR1cmUoc2lnbmF0dXJlLnIsIHNpZ25hdHVyZS5zKTtcbiAgICByZXR1cm4gc2lnLnRvREVSUmF3Qnl0ZXMoKTtcbn1cbi8qKlxuICogQ29udmVydHMgYSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0gdG8gREVSLWVuY29kZWQgZm9ybWF0LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2lnbmF0dXJlLmZyb20oe1xuICogICByOiA0OTc4Mjc1MzM0ODQ2MjQ5NDE5OTgyMzcxMjcwMDAwNDU1MjM5NDQyNTcxOTAxNDQ1ODkxODg3MTQ1MjMyOTc3NDkxMDQ1MDYwNzgwN24sXG4gKiAgIHM6IDMzNzI2Njk1OTc3ODQ0NDc2MjE0Njc2OTEzMjAxMTQwNDgxMTAyMjI1NDY5Mjg0MzA3MDE2OTM3OTE1NTk1NzU2MzU1OTI4NDE5NzY4bixcbiAqIH0pXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlX2RlciA9IFNpZ25hdHVyZS50b0RlckhleChzaWduYXR1cmUpXG4gKiAvLyBAbG9nOiAnMHgzMDQ0MDIyMDZlMTAwYTM1MmVjNmFkMWI3MDgwMjI5MGUxOGFlZWQxOTA3MDQ5NzM1NzBmM2I4ZWQ0MmNiOTgwOGUyZWE2YmYwMjIwNGE5MGEyMjlhMjQ0NDk1YjQxODkwOTg3ODA2ZmNiZDJkNWQyM2ZjMGRiZTVmNTI1NmMyNjEzYzAzOWQ3NmRiOCdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUgc2lnbmF0dXJlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgREVSLWVuY29kZWQgc2lnbmF0dXJlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9EZXJIZXgoc2lnbmF0dXJlKSB7XG4gICAgY29uc3Qgc2lnID0gbmV3IHNlY3AyNTZrMS5TaWduYXR1cmUoc2lnbmF0dXJlLnIsIHNpZ25hdHVyZS5zKTtcbiAgICByZXR1cm4gYDB4JHtzaWcudG9ERVJIZXgoKX1gO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfSBpbnRvIGEge0BsaW5rIG94I1NpZ25hdHVyZS5MZWdhY3l9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgbGVnYWN5ID0gU2lnbmF0dXJlLnRvTGVnYWN5KHsgcjogMW4sIHM6IDJuLCB5UGFyaXR5OiAxIH0pXG4gKiAvLyBAbG9nOiB7IHI6IDFuLCBzOiAybiwgdjogMjggfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHNpZ25hdHVyZSAtIFRoZSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSBjb252ZXJ0ZWQge0BsaW5rIG94I1NpZ25hdHVyZS5MZWdhY3l9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9MZWdhY3koc2lnbmF0dXJlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcjogc2lnbmF0dXJlLnIsXG4gICAgICAgIHM6IHNpZ25hdHVyZS5zLFxuICAgICAgICB2OiB5UGFyaXR5VG9WKHNpZ25hdHVyZS55UGFyaXR5KSxcbiAgICB9O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfSBpbnRvIGEge0BsaW5rIG94I1NpZ25hdHVyZS5ScGN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2lnbmF0dXJlLnRvUnBjKHtcbiAqICAgcjogNDk3ODI3NTMzNDg0NjI0OTQxOTk4MjM3MTI3MDAwMDQ1NTIzOTQ0MjU3MTkwMTQ0NTg5MTg4NzE0NTIzMjk3NzQ5MTA0NTA2MDc4MDduLFxuICogICBzOiAzMzcyNjY5NTk3Nzg0NDQ3NjIxNDY3NjkxMzIwMTE0MDQ4MTEwMjIyNTQ2OTI4NDMwNzAxNjkzNzkxNTU5NTc1NjM1NTkyODQxOTc2OG4sXG4gKiAgIHlQYXJpdHk6IDFcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2lnbmF0dXJlIC0gVGhlIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIGNvbnZlcnRlZCB7QGxpbmsgb3gjU2lnbmF0dXJlLlJwY30uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1JwYyhzaWduYXR1cmUpIHtcbiAgICBjb25zdCB7IHIsIHMsIHlQYXJpdHkgfSA9IHNpZ25hdHVyZTtcbiAgICByZXR1cm4ge1xuICAgICAgICByOiBIZXguZnJvbU51bWJlcihyLCB7IHNpemU6IDMyIH0pLFxuICAgICAgICBzOiBIZXguZnJvbU51bWJlcihzLCB7IHNpemU6IDMyIH0pLFxuICAgICAgICB5UGFyaXR5OiB5UGFyaXR5ID09PSAwID8gJzB4MCcgOiAnMHgxJyxcbiAgICB9O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfSB0byBhIHNlcmlhbGl6ZWQge0BsaW5rIG94I1NpZ25hdHVyZS5UdXBsZX0gdG8gYmUgdXNlZCBmb3Igc2lnbmF0dXJlcyBpbiBUcmFuc2FjdGlvbiBFbnZlbG9wZXMsIEVJUC03NzAyIEF1dGhvcml6YXRpb24gTGlzdHMsIGV0Yy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHNpZ25hdHVyZVR1cGxlID0gU2lnbmF0dXJlLnRvVHVwbGUoe1xuICogICByOiAxMjNuLFxuICogICBzOiA0NTZuLFxuICogICB5UGFyaXR5OiAxLFxuICogfSlcbiAqIC8vIEBsb2c6IFt5UGFyaXR5OiAnMHgwMScsIHI6ICcweDdiJywgczogJzB4MWM4J11cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUge0BsaW5rIG94I1NpZ25hdHVyZS5UdXBsZX0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1R1cGxlKHNpZ25hdHVyZSkge1xuICAgIGNvbnN0IHsgciwgcywgeVBhcml0eSB9ID0gc2lnbmF0dXJlO1xuICAgIHJldHVybiBbXG4gICAgICAgIHlQYXJpdHkgPyAnMHgwMScgOiAnMHgnLFxuICAgICAgICByID09PSAwbiA/ICcweCcgOiBIZXgudHJpbUxlZnQoSGV4LmZyb21OdW1iZXIocikpLFxuICAgICAgICBzID09PSAwbiA/ICcweCcgOiBIZXgudHJpbUxlZnQoSGV4LmZyb21OdW1iZXIocykpLFxuICAgIF07XG59XG4vKipcbiAqIFZhbGlkYXRlcyBhIFNpZ25hdHVyZS4gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHNpZ25hdHVyZSBpcyB2YWxpZCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB2YWxpZCA9IFNpZ25hdHVyZS52YWxpZGF0ZSh7XG4gKiAgIHI6IC00OTc4Mjc1MzM0ODQ2MjQ5NDE5OTgyMzcxMjcwMDAwNDU1MjM5NDQyNTcxOTAxNDQ1ODkxODg3MTQ1MjMyOTc3NDkxMDQ1MDYwNzgwN24sXG4gKiAgIHM6IDMzNzI2Njk1OTc3ODQ0NDc2MjE0Njc2OTEzMjAxMTQwNDgxMTAyMjI1NDY5Mjg0MzA3MDE2OTM3OTE1NTk1NzU2MzU1OTI4NDE5NzY4bixcbiAqICAgeVBhcml0eTogMSxcbiAqIH0pXG4gKiAvLyBAbG9nOiBmYWxzZVxuICogYGBgXG4gKlxuICogQHBhcmFtIHNpZ25hdHVyZSAtIFRoZSBzaWduYXR1cmUgb2JqZWN0IHRvIGFzc2VydC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlKHNpZ25hdHVyZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgYXNzZXJ0KHNpZ25hdHVyZSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vKipcbiAqIENvbnZlcnRzIGEgRUNEU0EgYHZgIHZhbHVlIHRvIGEgYHlQYXJpdHlgIHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgeVBhcml0eSA9IFNpZ25hdHVyZS52VG9ZUGFyaXR5KDI4KVxuICogLy8gQGxvZzogMVxuICogYGBgXG4gKlxuICogQHBhcmFtIHYgLSBUaGUgRUNEU0EgYHZgIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgYHlQYXJpdHlgIHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdlRvWVBhcml0eSh2KSB7XG4gICAgaWYgKHYgPT09IDAgfHwgdiA9PT0gMjcpXG4gICAgICAgIHJldHVybiAwO1xuICAgIGlmICh2ID09PSAxIHx8IHYgPT09IDI4KVxuICAgICAgICByZXR1cm4gMTtcbiAgICBpZiAodiA+PSAzNSlcbiAgICAgICAgcmV0dXJuIHYgJSAyID09PSAwID8gMSA6IDA7XG4gICAgdGhyb3cgbmV3IEludmFsaWRWRXJyb3IoeyB2YWx1ZTogdiB9KTtcbn1cbi8qKlxuICogQ29udmVydHMgYSBFQ0RTQSBgdmAgdmFsdWUgdG8gYSBgeVBhcml0eWAgdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB2ID0gU2lnbmF0dXJlLnlQYXJpdHlUb1YoMSlcbiAqIC8vIEBsb2c6IDI4XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0geVBhcml0eSAtIFRoZSBFQ0RTQSBgeVBhcml0eWAgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSBgdmAgdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB5UGFyaXR5VG9WKHlQYXJpdHkpIHtcbiAgICBpZiAoeVBhcml0eSA9PT0gMClcbiAgICAgICAgcmV0dXJuIDI3O1xuICAgIGlmICh5UGFyaXR5ID09PSAxKVxuICAgICAgICByZXR1cm4gMjg7XG4gICAgdGhyb3cgbmV3IEludmFsaWRZUGFyaXR5RXJyb3IoeyB2YWx1ZTogeVBhcml0eSB9KTtcbn1cbi8qKiBUaHJvd24gd2hlbiB0aGUgc2VyaWFsaXplZCBzaWduYXR1cmUgaXMgb2YgYW4gaW52YWxpZCBzaXplLiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRTZXJpYWxpemVkU2l6ZUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBzaWduYXR1cmUgfSkge1xuICAgICAgICBzdXBlcihgVmFsdWUgXFxgJHtzaWduYXR1cmV9XFxgIGlzIGFuIGludmFsaWQgc2lnbmF0dXJlIHNpemUuYCwge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXG4gICAgICAgICAgICAgICAgJ0V4cGVjdGVkOiA2NCBieXRlcyBvciA2NSBieXRlcy4nLFxuICAgICAgICAgICAgICAgIGBSZWNlaXZlZCAke0hleC5zaXplKEhleC5mcm9tKHNpZ25hdHVyZSkpfSBieXRlcy5gLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdTaWduYXR1cmUuSW52YWxpZFNlcmlhbGl6ZWRTaXplRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKiBUaHJvd24gd2hlbiB0aGUgc2lnbmF0dXJlIGlzIG1pc3NpbmcgZWl0aGVyIGFuIGByYCwgYHNgLCBvciBgeVBhcml0eWAgcHJvcGVydHkuICovXG5leHBvcnQgY2xhc3MgTWlzc2luZ1Byb3BlcnRpZXNFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgc2lnbmF0dXJlIH0pIHtcbiAgICAgICAgc3VwZXIoYFNpZ25hdHVyZSBcXGAke0pzb24uc3RyaW5naWZ5KHNpZ25hdHVyZSl9XFxgIGlzIG1pc3NpbmcgZWl0aGVyIGFuIFxcYHJcXGAsIFxcYHNcXGAsIG9yIFxcYHlQYXJpdHlcXGAgcHJvcGVydHkuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdTaWduYXR1cmUuTWlzc2luZ1Byb3BlcnRpZXNFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqIFRocm93biB3aGVuIHRoZSBzaWduYXR1cmUgaGFzIGFuIGludmFsaWQgYHJgIHZhbHVlLiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRSRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHZhbHVlIH0pIHtcbiAgICAgICAgc3VwZXIoYFZhbHVlIFxcYCR7dmFsdWV9XFxgIGlzIGFuIGludmFsaWQgciB2YWx1ZS4gciBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBsZXNzIHRoYW4gMl4yNTYuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdTaWduYXR1cmUuSW52YWxpZFJFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqIFRocm93biB3aGVuIHRoZSBzaWduYXR1cmUgaGFzIGFuIGludmFsaWQgYHNgIHZhbHVlLiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRTRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHZhbHVlIH0pIHtcbiAgICAgICAgc3VwZXIoYFZhbHVlIFxcYCR7dmFsdWV9XFxgIGlzIGFuIGludmFsaWQgcyB2YWx1ZS4gcyBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBsZXNzIHRoYW4gMl4yNTYuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdTaWduYXR1cmUuSW52YWxpZFNFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqIFRocm93biB3aGVuIHRoZSBzaWduYXR1cmUgaGFzIGFuIGludmFsaWQgYHlQYXJpdHlgIHZhbHVlLiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRZUGFyaXR5RXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHZhbHVlIH0pIHtcbiAgICAgICAgc3VwZXIoYFZhbHVlIFxcYCR7dmFsdWV9XFxgIGlzIGFuIGludmFsaWQgeS1wYXJpdHkgdmFsdWUuIFktcGFyaXR5IG11c3QgYmUgMCBvciAxLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnU2lnbmF0dXJlLkludmFsaWRZUGFyaXR5RXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKiBUaHJvd24gd2hlbiB0aGUgc2lnbmF0dXJlIGhhcyBhbiBpbnZhbGlkIGB2YCB2YWx1ZS4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkVkVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyB2YWx1ZSB9KSB7XG4gICAgICAgIHN1cGVyKGBWYWx1ZSBcXGAke3ZhbHVlfVxcYCBpcyBhbiBpbnZhbGlkIHYgdmFsdWUuIHYgbXVzdCBiZSAyNywgMjggb3IgPj0zNS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1NpZ25hdHVyZS5JbnZhbGlkVkVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TaWduYXR1cmUuanMubWFwIl0sIm5hbWVzIjpbInNlY3AyNTZrMSIsIkJ5dGVzIiwiRXJyb3JzIiwiSGV4IiwiSnNvbiIsIlNvbGlkaXR5IiwiYXNzZXJ0Iiwic2lnbmF0dXJlIiwib3B0aW9ucyIsInJlY292ZXJlZCIsInIiLCJNaXNzaW5nUHJvcGVydGllc0Vycm9yIiwicyIsInlQYXJpdHkiLCJtYXhVaW50MjU2IiwiSW52YWxpZFJFcnJvciIsInZhbHVlIiwiSW52YWxpZFNFcnJvciIsIkludmFsaWRZUGFyaXR5RXJyb3IiLCJmcm9tQnl0ZXMiLCJmcm9tSGV4IiwibGVuZ3RoIiwiSW52YWxpZFNlcmlhbGl6ZWRTaXplRXJyb3IiLCJCaWdJbnQiLCJzbGljZSIsIk51bWJlciIsImlzTmFOIiwidW5kZWZpbmVkIiwidlRvWVBhcml0eSIsImV4dHJhY3QiLCJmcm9tIiwic2lnbmF0dXJlXyIsIlVpbnQ4QXJyYXkiLCJmcm9tUnBjIiwidiIsImZyb21MZWdhY3kiLCJmcm9tRGVyQnl0ZXMiLCJmcm9tRGVySGV4IiwiU2lnbmF0dXJlIiwiZnJvbURFUiIsImZyb21UdXBsZSIsInR1cGxlIiwidG9CeXRlcyIsInRvSGV4IiwiY29uY2F0IiwiZnJvbU51bWJlciIsInNpemUiLCJ5UGFyaXR5VG9WIiwidG9EZXJCeXRlcyIsInNpZyIsInRvREVSUmF3Qnl0ZXMiLCJ0b0RlckhleCIsInRvREVSSGV4IiwidG9MZWdhY3kiLCJ0b1JwYyIsInRvVHVwbGUiLCJ0cmltTGVmdCIsInZhbGlkYXRlIiwiSW52YWxpZFZFcnJvciIsIkJhc2VFcnJvciIsImNvbnN0cnVjdG9yIiwibWV0YU1lc3NhZ2VzIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJzdHJpbmdpZnkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Signature.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Solidity.js":
/*!***********************************************!*\
  !*** ./node_modules/ox/_esm/core/Solidity.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrayRegex: () => (/* binding */ arrayRegex),\n/* harmony export */   bytesRegex: () => (/* binding */ bytesRegex),\n/* harmony export */   integerRegex: () => (/* binding */ integerRegex),\n/* harmony export */   maxInt104: () => (/* binding */ maxInt104),\n/* harmony export */   maxInt112: () => (/* binding */ maxInt112),\n/* harmony export */   maxInt120: () => (/* binding */ maxInt120),\n/* harmony export */   maxInt128: () => (/* binding */ maxInt128),\n/* harmony export */   maxInt136: () => (/* binding */ maxInt136),\n/* harmony export */   maxInt144: () => (/* binding */ maxInt144),\n/* harmony export */   maxInt152: () => (/* binding */ maxInt152),\n/* harmony export */   maxInt16: () => (/* binding */ maxInt16),\n/* harmony export */   maxInt160: () => (/* binding */ maxInt160),\n/* harmony export */   maxInt168: () => (/* binding */ maxInt168),\n/* harmony export */   maxInt176: () => (/* binding */ maxInt176),\n/* harmony export */   maxInt184: () => (/* binding */ maxInt184),\n/* harmony export */   maxInt192: () => (/* binding */ maxInt192),\n/* harmony export */   maxInt200: () => (/* binding */ maxInt200),\n/* harmony export */   maxInt208: () => (/* binding */ maxInt208),\n/* harmony export */   maxInt216: () => (/* binding */ maxInt216),\n/* harmony export */   maxInt224: () => (/* binding */ maxInt224),\n/* harmony export */   maxInt232: () => (/* binding */ maxInt232),\n/* harmony export */   maxInt24: () => (/* binding */ maxInt24),\n/* harmony export */   maxInt240: () => (/* binding */ maxInt240),\n/* harmony export */   maxInt248: () => (/* binding */ maxInt248),\n/* harmony export */   maxInt256: () => (/* binding */ maxInt256),\n/* harmony export */   maxInt32: () => (/* binding */ maxInt32),\n/* harmony export */   maxInt40: () => (/* binding */ maxInt40),\n/* harmony export */   maxInt48: () => (/* binding */ maxInt48),\n/* harmony export */   maxInt56: () => (/* binding */ maxInt56),\n/* harmony export */   maxInt64: () => (/* binding */ maxInt64),\n/* harmony export */   maxInt72: () => (/* binding */ maxInt72),\n/* harmony export */   maxInt8: () => (/* binding */ maxInt8),\n/* harmony export */   maxInt80: () => (/* binding */ maxInt80),\n/* harmony export */   maxInt88: () => (/* binding */ maxInt88),\n/* harmony export */   maxInt96: () => (/* binding */ maxInt96),\n/* harmony export */   maxUint104: () => (/* binding */ maxUint104),\n/* harmony export */   maxUint112: () => (/* binding */ maxUint112),\n/* harmony export */   maxUint120: () => (/* binding */ maxUint120),\n/* harmony export */   maxUint128: () => (/* binding */ maxUint128),\n/* harmony export */   maxUint136: () => (/* binding */ maxUint136),\n/* harmony export */   maxUint144: () => (/* binding */ maxUint144),\n/* harmony export */   maxUint152: () => (/* binding */ maxUint152),\n/* harmony export */   maxUint16: () => (/* binding */ maxUint16),\n/* harmony export */   maxUint160: () => (/* binding */ maxUint160),\n/* harmony export */   maxUint168: () => (/* binding */ maxUint168),\n/* harmony export */   maxUint176: () => (/* binding */ maxUint176),\n/* harmony export */   maxUint184: () => (/* binding */ maxUint184),\n/* harmony export */   maxUint192: () => (/* binding */ maxUint192),\n/* harmony export */   maxUint200: () => (/* binding */ maxUint200),\n/* harmony export */   maxUint208: () => (/* binding */ maxUint208),\n/* harmony export */   maxUint216: () => (/* binding */ maxUint216),\n/* harmony export */   maxUint224: () => (/* binding */ maxUint224),\n/* harmony export */   maxUint232: () => (/* binding */ maxUint232),\n/* harmony export */   maxUint24: () => (/* binding */ maxUint24),\n/* harmony export */   maxUint240: () => (/* binding */ maxUint240),\n/* harmony export */   maxUint248: () => (/* binding */ maxUint248),\n/* harmony export */   maxUint256: () => (/* binding */ maxUint256),\n/* harmony export */   maxUint32: () => (/* binding */ maxUint32),\n/* harmony export */   maxUint40: () => (/* binding */ maxUint40),\n/* harmony export */   maxUint48: () => (/* binding */ maxUint48),\n/* harmony export */   maxUint56: () => (/* binding */ maxUint56),\n/* harmony export */   maxUint64: () => (/* binding */ maxUint64),\n/* harmony export */   maxUint72: () => (/* binding */ maxUint72),\n/* harmony export */   maxUint8: () => (/* binding */ maxUint8),\n/* harmony export */   maxUint80: () => (/* binding */ maxUint80),\n/* harmony export */   maxUint88: () => (/* binding */ maxUint88),\n/* harmony export */   maxUint96: () => (/* binding */ maxUint96),\n/* harmony export */   minInt104: () => (/* binding */ minInt104),\n/* harmony export */   minInt112: () => (/* binding */ minInt112),\n/* harmony export */   minInt120: () => (/* binding */ minInt120),\n/* harmony export */   minInt128: () => (/* binding */ minInt128),\n/* harmony export */   minInt136: () => (/* binding */ minInt136),\n/* harmony export */   minInt144: () => (/* binding */ minInt144),\n/* harmony export */   minInt152: () => (/* binding */ minInt152),\n/* harmony export */   minInt16: () => (/* binding */ minInt16),\n/* harmony export */   minInt160: () => (/* binding */ minInt160),\n/* harmony export */   minInt168: () => (/* binding */ minInt168),\n/* harmony export */   minInt176: () => (/* binding */ minInt176),\n/* harmony export */   minInt184: () => (/* binding */ minInt184),\n/* harmony export */   minInt192: () => (/* binding */ minInt192),\n/* harmony export */   minInt200: () => (/* binding */ minInt200),\n/* harmony export */   minInt208: () => (/* binding */ minInt208),\n/* harmony export */   minInt216: () => (/* binding */ minInt216),\n/* harmony export */   minInt224: () => (/* binding */ minInt224),\n/* harmony export */   minInt232: () => (/* binding */ minInt232),\n/* harmony export */   minInt24: () => (/* binding */ minInt24),\n/* harmony export */   minInt240: () => (/* binding */ minInt240),\n/* harmony export */   minInt248: () => (/* binding */ minInt248),\n/* harmony export */   minInt256: () => (/* binding */ minInt256),\n/* harmony export */   minInt32: () => (/* binding */ minInt32),\n/* harmony export */   minInt40: () => (/* binding */ minInt40),\n/* harmony export */   minInt48: () => (/* binding */ minInt48),\n/* harmony export */   minInt56: () => (/* binding */ minInt56),\n/* harmony export */   minInt64: () => (/* binding */ minInt64),\n/* harmony export */   minInt72: () => (/* binding */ minInt72),\n/* harmony export */   minInt8: () => (/* binding */ minInt8),\n/* harmony export */   minInt80: () => (/* binding */ minInt80),\n/* harmony export */   minInt88: () => (/* binding */ minInt88),\n/* harmony export */   minInt96: () => (/* binding */ minInt96)\n/* harmony export */ });\nconst arrayRegex = /^(.*)\\[([0-9]*)\\]$/;\n// `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n// https://regexr.com/6va55\nconst bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;\n// `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n// https://regexr.com/6v8hp\nconst integerRegex = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;\nconst maxInt8 = 2n ** (8n - 1n) - 1n;\nconst maxInt16 = 2n ** (16n - 1n) - 1n;\nconst maxInt24 = 2n ** (24n - 1n) - 1n;\nconst maxInt32 = 2n ** (32n - 1n) - 1n;\nconst maxInt40 = 2n ** (40n - 1n) - 1n;\nconst maxInt48 = 2n ** (48n - 1n) - 1n;\nconst maxInt56 = 2n ** (56n - 1n) - 1n;\nconst maxInt64 = 2n ** (64n - 1n) - 1n;\nconst maxInt72 = 2n ** (72n - 1n) - 1n;\nconst maxInt80 = 2n ** (80n - 1n) - 1n;\nconst maxInt88 = 2n ** (88n - 1n) - 1n;\nconst maxInt96 = 2n ** (96n - 1n) - 1n;\nconst maxInt104 = 2n ** (104n - 1n) - 1n;\nconst maxInt112 = 2n ** (112n - 1n) - 1n;\nconst maxInt120 = 2n ** (120n - 1n) - 1n;\nconst maxInt128 = 2n ** (128n - 1n) - 1n;\nconst maxInt136 = 2n ** (136n - 1n) - 1n;\nconst maxInt144 = 2n ** (144n - 1n) - 1n;\nconst maxInt152 = 2n ** (152n - 1n) - 1n;\nconst maxInt160 = 2n ** (160n - 1n) - 1n;\nconst maxInt168 = 2n ** (168n - 1n) - 1n;\nconst maxInt176 = 2n ** (176n - 1n) - 1n;\nconst maxInt184 = 2n ** (184n - 1n) - 1n;\nconst maxInt192 = 2n ** (192n - 1n) - 1n;\nconst maxInt200 = 2n ** (200n - 1n) - 1n;\nconst maxInt208 = 2n ** (208n - 1n) - 1n;\nconst maxInt216 = 2n ** (216n - 1n) - 1n;\nconst maxInt224 = 2n ** (224n - 1n) - 1n;\nconst maxInt232 = 2n ** (232n - 1n) - 1n;\nconst maxInt240 = 2n ** (240n - 1n) - 1n;\nconst maxInt248 = 2n ** (248n - 1n) - 1n;\nconst maxInt256 = 2n ** (256n - 1n) - 1n;\nconst minInt8 = -(2n ** (8n - 1n));\nconst minInt16 = -(2n ** (16n - 1n));\nconst minInt24 = -(2n ** (24n - 1n));\nconst minInt32 = -(2n ** (32n - 1n));\nconst minInt40 = -(2n ** (40n - 1n));\nconst minInt48 = -(2n ** (48n - 1n));\nconst minInt56 = -(2n ** (56n - 1n));\nconst minInt64 = -(2n ** (64n - 1n));\nconst minInt72 = -(2n ** (72n - 1n));\nconst minInt80 = -(2n ** (80n - 1n));\nconst minInt88 = -(2n ** (88n - 1n));\nconst minInt96 = -(2n ** (96n - 1n));\nconst minInt104 = -(2n ** (104n - 1n));\nconst minInt112 = -(2n ** (112n - 1n));\nconst minInt120 = -(2n ** (120n - 1n));\nconst minInt128 = -(2n ** (128n - 1n));\nconst minInt136 = -(2n ** (136n - 1n));\nconst minInt144 = -(2n ** (144n - 1n));\nconst minInt152 = -(2n ** (152n - 1n));\nconst minInt160 = -(2n ** (160n - 1n));\nconst minInt168 = -(2n ** (168n - 1n));\nconst minInt176 = -(2n ** (176n - 1n));\nconst minInt184 = -(2n ** (184n - 1n));\nconst minInt192 = -(2n ** (192n - 1n));\nconst minInt200 = -(2n ** (200n - 1n));\nconst minInt208 = -(2n ** (208n - 1n));\nconst minInt216 = -(2n ** (216n - 1n));\nconst minInt224 = -(2n ** (224n - 1n));\nconst minInt232 = -(2n ** (232n - 1n));\nconst minInt240 = -(2n ** (240n - 1n));\nconst minInt248 = -(2n ** (248n - 1n));\nconst minInt256 = -(2n ** (256n - 1n));\nconst maxUint8 = 2n ** 8n - 1n;\nconst maxUint16 = 2n ** 16n - 1n;\nconst maxUint24 = 2n ** 24n - 1n;\nconst maxUint32 = 2n ** 32n - 1n;\nconst maxUint40 = 2n ** 40n - 1n;\nconst maxUint48 = 2n ** 48n - 1n;\nconst maxUint56 = 2n ** 56n - 1n;\nconst maxUint64 = 2n ** 64n - 1n;\nconst maxUint72 = 2n ** 72n - 1n;\nconst maxUint80 = 2n ** 80n - 1n;\nconst maxUint88 = 2n ** 88n - 1n;\nconst maxUint96 = 2n ** 96n - 1n;\nconst maxUint104 = 2n ** 104n - 1n;\nconst maxUint112 = 2n ** 112n - 1n;\nconst maxUint120 = 2n ** 120n - 1n;\nconst maxUint128 = 2n ** 128n - 1n;\nconst maxUint136 = 2n ** 136n - 1n;\nconst maxUint144 = 2n ** 144n - 1n;\nconst maxUint152 = 2n ** 152n - 1n;\nconst maxUint160 = 2n ** 160n - 1n;\nconst maxUint168 = 2n ** 168n - 1n;\nconst maxUint176 = 2n ** 176n - 1n;\nconst maxUint184 = 2n ** 184n - 1n;\nconst maxUint192 = 2n ** 192n - 1n;\nconst maxUint200 = 2n ** 200n - 1n;\nconst maxUint208 = 2n ** 208n - 1n;\nconst maxUint216 = 2n ** 216n - 1n;\nconst maxUint224 = 2n ** 224n - 1n;\nconst maxUint232 = 2n ** 232n - 1n;\nconst maxUint240 = 2n ** 240n - 1n;\nconst maxUint248 = 2n ** 248n - 1n;\nconst maxUint256 = 2n ** 256n - 1n; //# sourceMappingURL=Solidity.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1NvbGlkaXR5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFPLE1BQU1BLGFBQWEscUJBQXFCO0FBQy9DLHNEQUFzRDtBQUN0RCwyQkFBMkI7QUFDcEIsTUFBTUMsYUFBYSx1Q0FBdUM7QUFDakUsaUZBQWlGO0FBQ2pGLDJCQUEyQjtBQUNwQixNQUFNQyxlQUFlLGlJQUFpSTtBQUN0SixNQUFNQyxVQUFVLEVBQUUsSUFBSyxHQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUNyQyxNQUFNQyxXQUFXLEVBQUUsSUFBSyxJQUFHLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN2QyxNQUFNQyxXQUFXLEVBQUUsSUFBSyxJQUFHLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN2QyxNQUFNQyxXQUFXLEVBQUUsSUFBSyxJQUFHLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN2QyxNQUFNQyxXQUFXLEVBQUUsSUFBSyxJQUFHLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN2QyxNQUFNQyxXQUFXLEVBQUUsSUFBSyxJQUFHLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN2QyxNQUFNQyxXQUFXLEVBQUUsSUFBSyxJQUFHLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN2QyxNQUFNQyxXQUFXLEVBQUUsSUFBSyxJQUFHLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN2QyxNQUFNQyxXQUFXLEVBQUUsSUFBSyxJQUFHLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN2QyxNQUFNQyxXQUFXLEVBQUUsSUFBSyxJQUFHLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN2QyxNQUFNQyxXQUFXLEVBQUUsSUFBSyxJQUFHLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN2QyxNQUFNQyxXQUFXLEVBQUUsSUFBSyxJQUFHLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN2QyxNQUFNQyxZQUFZLEVBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN6QyxNQUFNQyxZQUFZLEVBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN6QyxNQUFNQyxZQUFZLEVBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN6QyxNQUFNQyxZQUFZLEVBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN6QyxNQUFNQyxZQUFZLEVBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN6QyxNQUFNQyxZQUFZLEVBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN6QyxNQUFNQyxZQUFZLEVBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN6QyxNQUFNQyxZQUFZLEVBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN6QyxNQUFNQyxZQUFZLEVBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN6QyxNQUFNQyxZQUFZLEVBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN6QyxNQUFNQyxZQUFZLEVBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN6QyxNQUFNQyxZQUFZLEVBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN6QyxNQUFNQyxZQUFZLEVBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN6QyxNQUFNQyxZQUFZLEVBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN6QyxNQUFNQyxZQUFZLEVBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN6QyxNQUFNQyxZQUFZLEVBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN6QyxNQUFNQyxZQUFZLEVBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN6QyxNQUFNQyxZQUFZLEVBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN6QyxNQUFNQyxZQUFZLEVBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN6QyxNQUFNQyxZQUFZLEVBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztBQUN6QyxNQUFNQyxVQUFVLENBQUUsR0FBRSxJQUFLLEdBQUUsR0FBRyxFQUFFLEdBQUc7QUFDbkMsTUFBTUMsV0FBVyxDQUFFLEdBQUUsSUFBSyxJQUFHLEdBQUcsRUFBRSxHQUFHO0FBQ3JDLE1BQU1DLFdBQVcsQ0FBRSxHQUFFLElBQUssSUFBRyxHQUFHLEVBQUUsR0FBRztBQUNyQyxNQUFNQyxXQUFXLENBQUUsR0FBRSxJQUFLLElBQUcsR0FBRyxFQUFFLEdBQUc7QUFDckMsTUFBTUMsV0FBVyxDQUFFLEdBQUUsSUFBSyxJQUFHLEdBQUcsRUFBRSxHQUFHO0FBQ3JDLE1BQU1DLFdBQVcsQ0FBRSxHQUFFLElBQUssSUFBRyxHQUFHLEVBQUUsR0FBRztBQUNyQyxNQUFNQyxXQUFXLENBQUUsR0FBRSxJQUFLLElBQUcsR0FBRyxFQUFFLEdBQUc7QUFDckMsTUFBTUMsV0FBVyxDQUFFLEdBQUUsSUFBSyxJQUFHLEdBQUcsRUFBRSxHQUFHO0FBQ3JDLE1BQU1DLFdBQVcsQ0FBRSxHQUFFLElBQUssSUFBRyxHQUFHLEVBQUUsR0FBRztBQUNyQyxNQUFNQyxXQUFXLENBQUUsR0FBRSxJQUFLLElBQUcsR0FBRyxFQUFFLEdBQUc7QUFDckMsTUFBTUMsV0FBVyxDQUFFLEdBQUUsSUFBSyxJQUFHLEdBQUcsRUFBRSxHQUFHO0FBQ3JDLE1BQU1DLFdBQVcsQ0FBRSxHQUFFLElBQUssSUFBRyxHQUFHLEVBQUUsR0FBRztBQUNyQyxNQUFNQyxZQUFZLENBQUUsR0FBRSxJQUFLLEtBQUksR0FBRyxFQUFFLEdBQUc7QUFDdkMsTUFBTUMsWUFBWSxDQUFFLEdBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRSxHQUFHO0FBQ3ZDLE1BQU1DLFlBQVksQ0FBRSxHQUFFLElBQUssS0FBSSxHQUFHLEVBQUUsR0FBRztBQUN2QyxNQUFNQyxZQUFZLENBQUUsR0FBRSxJQUFLLEtBQUksR0FBRyxFQUFFLEdBQUc7QUFDdkMsTUFBTUMsWUFBWSxDQUFFLEdBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRSxHQUFHO0FBQ3ZDLE1BQU1DLFlBQVksQ0FBRSxHQUFFLElBQUssS0FBSSxHQUFHLEVBQUUsR0FBRztBQUN2QyxNQUFNQyxZQUFZLENBQUUsR0FBRSxJQUFLLEtBQUksR0FBRyxFQUFFLEdBQUc7QUFDdkMsTUFBTUMsWUFBWSxDQUFFLEdBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRSxHQUFHO0FBQ3ZDLE1BQU1DLFlBQVksQ0FBRSxHQUFFLElBQUssS0FBSSxHQUFHLEVBQUUsR0FBRztBQUN2QyxNQUFNQyxZQUFZLENBQUUsR0FBRSxJQUFLLEtBQUksR0FBRyxFQUFFLEdBQUc7QUFDdkMsTUFBTUMsWUFBWSxDQUFFLEdBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRSxHQUFHO0FBQ3ZDLE1BQU1DLFlBQVksQ0FBRSxHQUFFLElBQUssS0FBSSxHQUFHLEVBQUUsR0FBRztBQUN2QyxNQUFNQyxZQUFZLENBQUUsR0FBRSxJQUFLLEtBQUksR0FBRyxFQUFFLEdBQUc7QUFDdkMsTUFBTUMsWUFBWSxDQUFFLEdBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRSxHQUFHO0FBQ3ZDLE1BQU1DLFlBQVksQ0FBRSxHQUFFLElBQUssS0FBSSxHQUFHLEVBQUUsR0FBRztBQUN2QyxNQUFNQyxZQUFZLENBQUUsR0FBRSxJQUFLLEtBQUksR0FBRyxFQUFFLEdBQUc7QUFDdkMsTUFBTUMsWUFBWSxDQUFFLEdBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRSxHQUFHO0FBQ3ZDLE1BQU1DLFlBQVksQ0FBRSxHQUFFLElBQUssS0FBSSxHQUFHLEVBQUUsR0FBRztBQUN2QyxNQUFNQyxZQUFZLENBQUUsR0FBRSxJQUFLLEtBQUksR0FBRyxFQUFFLEdBQUc7QUFDdkMsTUFBTUMsWUFBWSxDQUFFLEdBQUUsSUFBSyxLQUFJLEdBQUcsRUFBRSxHQUFHO0FBQ3ZDLE1BQU1DLFdBQVcsRUFBRSxJQUFJLEVBQUUsR0FBRyxFQUFFLENBQUM7QUFDL0IsTUFBTUMsWUFBWSxFQUFFLElBQUksR0FBRyxHQUFHLEVBQUUsQ0FBQztBQUNqQyxNQUFNQyxZQUFZLEVBQUUsSUFBSSxHQUFHLEdBQUcsRUFBRSxDQUFDO0FBQ2pDLE1BQU1DLFlBQVksRUFBRSxJQUFJLEdBQUcsR0FBRyxFQUFFLENBQUM7QUFDakMsTUFBTUMsWUFBWSxFQUFFLElBQUksR0FBRyxHQUFHLEVBQUUsQ0FBQztBQUNqQyxNQUFNQyxZQUFZLEVBQUUsSUFBSSxHQUFHLEdBQUcsRUFBRSxDQUFDO0FBQ2pDLE1BQU1DLFlBQVksRUFBRSxJQUFJLEdBQUcsR0FBRyxFQUFFLENBQUM7QUFDakMsTUFBTUMsWUFBWSxFQUFFLElBQUksR0FBRyxHQUFHLEVBQUUsQ0FBQztBQUNqQyxNQUFNQyxZQUFZLEVBQUUsSUFBSSxHQUFHLEdBQUcsRUFBRSxDQUFDO0FBQ2pDLE1BQU1DLFlBQVksRUFBRSxJQUFJLEdBQUcsR0FBRyxFQUFFLENBQUM7QUFDakMsTUFBTUMsWUFBWSxFQUFFLElBQUksR0FBRyxHQUFHLEVBQUUsQ0FBQztBQUNqQyxNQUFNQyxZQUFZLEVBQUUsSUFBSSxHQUFHLEdBQUcsRUFBRSxDQUFDO0FBQ2pDLE1BQU1DLGFBQWEsRUFBRSxJQUFJLElBQUksR0FBRyxFQUFFLENBQUM7QUFDbkMsTUFBTUMsYUFBYSxFQUFFLElBQUksSUFBSSxHQUFHLEVBQUUsQ0FBQztBQUNuQyxNQUFNQyxhQUFhLEVBQUUsSUFBSSxJQUFJLEdBQUcsRUFBRSxDQUFDO0FBQ25DLE1BQU1DLGFBQWEsRUFBRSxJQUFJLElBQUksR0FBRyxFQUFFLENBQUM7QUFDbkMsTUFBTUMsYUFBYSxFQUFFLElBQUksSUFBSSxHQUFHLEVBQUUsQ0FBQztBQUNuQyxNQUFNQyxhQUFhLEVBQUUsSUFBSSxJQUFJLEdBQUcsRUFBRSxDQUFDO0FBQ25DLE1BQU1DLGFBQWEsRUFBRSxJQUFJLElBQUksR0FBRyxFQUFFLENBQUM7QUFDbkMsTUFBTUMsYUFBYSxFQUFFLElBQUksSUFBSSxHQUFHLEVBQUUsQ0FBQztBQUNuQyxNQUFNQyxhQUFhLEVBQUUsSUFBSSxJQUFJLEdBQUcsRUFBRSxDQUFDO0FBQ25DLE1BQU1DLGFBQWEsRUFBRSxJQUFJLElBQUksR0FBRyxFQUFFLENBQUM7QUFDbkMsTUFBTUMsYUFBYSxFQUFFLElBQUksSUFBSSxHQUFHLEVBQUUsQ0FBQztBQUNuQyxNQUFNQyxhQUFhLEVBQUUsSUFBSSxJQUFJLEdBQUcsRUFBRSxDQUFDO0FBQ25DLE1BQU1DLGFBQWEsRUFBRSxJQUFJLElBQUksR0FBRyxFQUFFLENBQUM7QUFDbkMsTUFBTUMsYUFBYSxFQUFFLElBQUksSUFBSSxHQUFHLEVBQUUsQ0FBQztBQUNuQyxNQUFNQyxhQUFhLEVBQUUsSUFBSSxJQUFJLEdBQUcsRUFBRSxDQUFDO0FBQ25DLE1BQU1DLGFBQWEsRUFBRSxJQUFJLElBQUksR0FBRyxFQUFFLENBQUM7QUFDbkMsTUFBTUMsYUFBYSxFQUFFLElBQUksSUFBSSxHQUFHLEVBQUUsQ0FBQztBQUNuQyxNQUFNQyxhQUFhLEVBQUUsSUFBSSxJQUFJLEdBQUcsRUFBRSxDQUFDO0FBQ25DLE1BQU1DLGFBQWEsRUFBRSxJQUFJLElBQUksR0FBRyxFQUFFLENBQUM7QUFDbkMsTUFBTUMsYUFBYSxFQUFFLElBQUksSUFBSSxHQUFHLEVBQUUsQ0FBQyxDQUMxQyxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGF3LXdvcmtzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9Tb2xpZGl0eS5qcz80YzNkIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBhcnJheVJlZ2V4ID0gL14oLiopXFxbKFswLTldKilcXF0kLztcbi8vIGBieXRlczxNPmA6IGJpbmFyeSB0eXBlIG9mIGBNYCBieXRlcywgYDAgPCBNIDw9IDMyYFxuLy8gaHR0cHM6Ly9yZWdleHIuY29tLzZ2YTU1XG5leHBvcnQgY29uc3QgYnl0ZXNSZWdleCA9IC9eYnl0ZXMoWzEtOV18MVswLTldfDJbMC05XXwzWzAtMl0pPyQvO1xuLy8gYCh1KWludDxNPmA6ICh1bilzaWduZWQgaW50ZWdlciB0eXBlIG9mIGBNYCBiaXRzLCBgMCA8IE0gPD0gMjU2YCwgYE0gJSA4ID09IDBgXG4vLyBodHRwczovL3JlZ2V4ci5jb20vNnY4aHBcbmV4cG9ydCBjb25zdCBpbnRlZ2VyUmVnZXggPSAvXih1P2ludCkoOHwxNnwyNHwzMnw0MHw0OHw1Nnw2NHw3Mnw4MHw4OHw5NnwxMDR8MTEyfDEyMHwxMjh8MTM2fDE0NHwxNTJ8MTYwfDE2OHwxNzZ8MTg0fDE5MnwyMDB8MjA4fDIxNnwyMjR8MjMyfDI0MHwyNDh8MjU2KT8kLztcbmV4cG9ydCBjb25zdCBtYXhJbnQ4ID0gMm4gKiogKDhuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50MTYgPSAybiAqKiAoMTZuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50MjQgPSAybiAqKiAoMjRuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50MzIgPSAybiAqKiAoMzJuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50NDAgPSAybiAqKiAoNDBuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50NDggPSAybiAqKiAoNDhuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50NTYgPSAybiAqKiAoNTZuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50NjQgPSAybiAqKiAoNjRuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50NzIgPSAybiAqKiAoNzJuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50ODAgPSAybiAqKiAoODBuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50ODggPSAybiAqKiAoODhuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50OTYgPSAybiAqKiAoOTZuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50MTA0ID0gMm4gKiogKDEwNG4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhJbnQxMTIgPSAybiAqKiAoMTEybiAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDEyMCA9IDJuICoqICgxMjBuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50MTI4ID0gMm4gKiogKDEyOG4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhJbnQxMzYgPSAybiAqKiAoMTM2biAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDE0NCA9IDJuICoqICgxNDRuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50MTUyID0gMm4gKiogKDE1Mm4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhJbnQxNjAgPSAybiAqKiAoMTYwbiAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDE2OCA9IDJuICoqICgxNjhuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50MTc2ID0gMm4gKiogKDE3Nm4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhJbnQxODQgPSAybiAqKiAoMTg0biAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDE5MiA9IDJuICoqICgxOTJuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50MjAwID0gMm4gKiogKDIwMG4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhJbnQyMDggPSAybiAqKiAoMjA4biAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDIxNiA9IDJuICoqICgyMTZuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50MjI0ID0gMm4gKiogKDIyNG4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhJbnQyMzIgPSAybiAqKiAoMjMybiAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDI0MCA9IDJuICoqICgyNDBuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50MjQ4ID0gMm4gKiogKDI0OG4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhJbnQyNTYgPSAybiAqKiAoMjU2biAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1pbkludDggPSAtKDJuICoqICg4biAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MTYgPSAtKDJuICoqICgxNm4gLSAxbikpO1xuZXhwb3J0IGNvbnN0IG1pbkludDI0ID0gLSgybiAqKiAoMjRuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQzMiA9IC0oMm4gKiogKDMybiAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50NDAgPSAtKDJuICoqICg0MG4gLSAxbikpO1xuZXhwb3J0IGNvbnN0IG1pbkludDQ4ID0gLSgybiAqKiAoNDhuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQ1NiA9IC0oMm4gKiogKDU2biAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50NjQgPSAtKDJuICoqICg2NG4gLSAxbikpO1xuZXhwb3J0IGNvbnN0IG1pbkludDcyID0gLSgybiAqKiAoNzJuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQ4MCA9IC0oMm4gKiogKDgwbiAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50ODggPSAtKDJuICoqICg4OG4gLSAxbikpO1xuZXhwb3J0IGNvbnN0IG1pbkludDk2ID0gLSgybiAqKiAoOTZuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQxMDQgPSAtKDJuICoqICgxMDRuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQxMTIgPSAtKDJuICoqICgxMTJuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQxMjAgPSAtKDJuICoqICgxMjBuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQxMjggPSAtKDJuICoqICgxMjhuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQxMzYgPSAtKDJuICoqICgxMzZuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQxNDQgPSAtKDJuICoqICgxNDRuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQxNTIgPSAtKDJuICoqICgxNTJuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQxNjAgPSAtKDJuICoqICgxNjBuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQxNjggPSAtKDJuICoqICgxNjhuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQxNzYgPSAtKDJuICoqICgxNzZuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQxODQgPSAtKDJuICoqICgxODRuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQxOTIgPSAtKDJuICoqICgxOTJuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQyMDAgPSAtKDJuICoqICgyMDBuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQyMDggPSAtKDJuICoqICgyMDhuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQyMTYgPSAtKDJuICoqICgyMTZuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQyMjQgPSAtKDJuICoqICgyMjRuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQyMzIgPSAtKDJuICoqICgyMzJuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQyNDAgPSAtKDJuICoqICgyNDBuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQyNDggPSAtKDJuICoqICgyNDhuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQyNTYgPSAtKDJuICoqICgyNTZuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtYXhVaW50OCA9IDJuICoqIDhuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDE2ID0gMm4gKiogMTZuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDI0ID0gMm4gKiogMjRuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDMyID0gMm4gKiogMzJuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDQwID0gMm4gKiogNDBuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDQ4ID0gMm4gKiogNDhuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDU2ID0gMm4gKiogNTZuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDY0ID0gMm4gKiogNjRuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDcyID0gMm4gKiogNzJuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDgwID0gMm4gKiogODBuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDg4ID0gMm4gKiogODhuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDk2ID0gMm4gKiogOTZuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDEwNCA9IDJuICoqIDEwNG4gLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhVaW50MTEyID0gMm4gKiogMTEybiAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQxMjAgPSAybiAqKiAxMjBuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDEyOCA9IDJuICoqIDEyOG4gLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhVaW50MTM2ID0gMm4gKiogMTM2biAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQxNDQgPSAybiAqKiAxNDRuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDE1MiA9IDJuICoqIDE1Mm4gLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhVaW50MTYwID0gMm4gKiogMTYwbiAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQxNjggPSAybiAqKiAxNjhuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDE3NiA9IDJuICoqIDE3Nm4gLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhVaW50MTg0ID0gMm4gKiogMTg0biAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQxOTIgPSAybiAqKiAxOTJuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDIwMCA9IDJuICoqIDIwMG4gLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhVaW50MjA4ID0gMm4gKiogMjA4biAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQyMTYgPSAybiAqKiAyMTZuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDIyNCA9IDJuICoqIDIyNG4gLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhVaW50MjMyID0gMm4gKiogMjMybiAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQyNDAgPSAybiAqKiAyNDBuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDI0OCA9IDJuICoqIDI0OG4gLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhVaW50MjU2ID0gMm4gKiogMjU2biAtIDFuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U29saWRpdHkuanMubWFwIl0sIm5hbWVzIjpbImFycmF5UmVnZXgiLCJieXRlc1JlZ2V4IiwiaW50ZWdlclJlZ2V4IiwibWF4SW50OCIsIm1heEludDE2IiwibWF4SW50MjQiLCJtYXhJbnQzMiIsIm1heEludDQwIiwibWF4SW50NDgiLCJtYXhJbnQ1NiIsIm1heEludDY0IiwibWF4SW50NzIiLCJtYXhJbnQ4MCIsIm1heEludDg4IiwibWF4SW50OTYiLCJtYXhJbnQxMDQiLCJtYXhJbnQxMTIiLCJtYXhJbnQxMjAiLCJtYXhJbnQxMjgiLCJtYXhJbnQxMzYiLCJtYXhJbnQxNDQiLCJtYXhJbnQxNTIiLCJtYXhJbnQxNjAiLCJtYXhJbnQxNjgiLCJtYXhJbnQxNzYiLCJtYXhJbnQxODQiLCJtYXhJbnQxOTIiLCJtYXhJbnQyMDAiLCJtYXhJbnQyMDgiLCJtYXhJbnQyMTYiLCJtYXhJbnQyMjQiLCJtYXhJbnQyMzIiLCJtYXhJbnQyNDAiLCJtYXhJbnQyNDgiLCJtYXhJbnQyNTYiLCJtaW5JbnQ4IiwibWluSW50MTYiLCJtaW5JbnQyNCIsIm1pbkludDMyIiwibWluSW50NDAiLCJtaW5JbnQ0OCIsIm1pbkludDU2IiwibWluSW50NjQiLCJtaW5JbnQ3MiIsIm1pbkludDgwIiwibWluSW50ODgiLCJtaW5JbnQ5NiIsIm1pbkludDEwNCIsIm1pbkludDExMiIsIm1pbkludDEyMCIsIm1pbkludDEyOCIsIm1pbkludDEzNiIsIm1pbkludDE0NCIsIm1pbkludDE1MiIsIm1pbkludDE2MCIsIm1pbkludDE2OCIsIm1pbkludDE3NiIsIm1pbkludDE4NCIsIm1pbkludDE5MiIsIm1pbkludDIwMCIsIm1pbkludDIwOCIsIm1pbkludDIxNiIsIm1pbkludDIyNCIsIm1pbkludDIzMiIsIm1pbkludDI0MCIsIm1pbkludDI0OCIsIm1pbkludDI1NiIsIm1heFVpbnQ4IiwibWF4VWludDE2IiwibWF4VWludDI0IiwibWF4VWludDMyIiwibWF4VWludDQwIiwibWF4VWludDQ4IiwibWF4VWludDU2IiwibWF4VWludDY0IiwibWF4VWludDcyIiwibWF4VWludDgwIiwibWF4VWludDg4IiwibWF4VWludDk2IiwibWF4VWludDEwNCIsIm1heFVpbnQxMTIiLCJtYXhVaW50MTIwIiwibWF4VWludDEyOCIsIm1heFVpbnQxMzYiLCJtYXhVaW50MTQ0IiwibWF4VWludDE1MiIsIm1heFVpbnQxNjAiLCJtYXhVaW50MTY4IiwibWF4VWludDE3NiIsIm1heFVpbnQxODQiLCJtYXhVaW50MTkyIiwibWF4VWludDIwMCIsIm1heFVpbnQyMDgiLCJtYXhVaW50MjE2IiwibWF4VWludDIyNCIsIm1heFVpbnQyMzIiLCJtYXhVaW50MjQwIiwibWF4VWludDI0OCIsIm1heFVpbnQyNTYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Solidity.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Transaction.js":
/*!**************************************************!*\
  !*** ./node_modules/ox/_esm/core/Transaction.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromRpc: () => (/* binding */ fromRpc),\n/* harmony export */   fromRpcType: () => (/* binding */ fromRpcType),\n/* harmony export */   toRpc: () => (/* binding */ toRpc),\n/* harmony export */   toRpcType: () => (/* binding */ toRpcType)\n/* harmony export */ });\n/* harmony import */ var _Authorization_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Authorization.js */ \"(ssr)/./node_modules/ox/_esm/core/Authorization.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Signature_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Signature.js */ \"(ssr)/./node_modules/ox/_esm/core/Signature.js\");\n\n\n\n/** Type to RPC Type mapping. */ const toRpcType = {\n    legacy: \"0x0\",\n    eip2930: \"0x1\",\n    eip1559: \"0x2\",\n    eip4844: \"0x3\",\n    eip7702: \"0x4\"\n};\n/** RPC Type to Type mapping. */ const fromRpcType = {\n    \"0x0\": \"legacy\",\n    \"0x1\": \"eip2930\",\n    \"0x2\": \"eip1559\",\n    \"0x3\": \"eip4844\",\n    \"0x4\": \"eip7702\"\n};\n/**\n * Converts an {@link ox#Transaction.Rpc} to an {@link ox#Transaction.Transaction}.\n *\n * @example\n * ```ts twoslash\n * import { Transaction } from 'ox'\n *\n * const transaction = Transaction.fromRpc({\n *   hash: '0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0',\n *   nonce: '0x357',\n *   blockHash:\n *     '0xc350d807505fb835650f0013632c5515592987ba169bbc6626d9fc54d91f0f0b',\n *   blockNumber: '0x12f296f',\n *   transactionIndex: '0x2',\n *   from: '0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6',\n *   to: '0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad',\n *   value: '0x9b6e64a8ec60000',\n *   gas: '0x43f5d',\n *   maxFeePerGas: '0x2ca6ae494',\n *   maxPriorityFeePerGas: '0x41cc3c0',\n *   input:\n *     '0x3593564c000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000006643504700000000000000000000000000000000000000000000000000000000000000040b080604000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000002800000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000009b6e64a8ec600000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000009b6e64a8ec60000000000000000000000000000000000000000000000000000019124bb5ae978c000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b80000000000000000000000000000000000000000000000000000000000000060000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b8000000000000000000000000000000fee13a103a10d593b9ae06b3e05f2e7e1c00000000000000000000000000000000000000000000000000000000000000190000000000000000000000000000000000000000000000000000000000000060000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b800000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000190240001b9872b',\n *   r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *   s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *   yParity: '0x0',\n *   chainId: '0x1',\n *   accessList: [],\n *   type: '0x2',\n * })\n * ```\n *\n * @param transaction - The RPC transaction to convert.\n * @returns An instantiated {@link ox#Transaction.Transaction}.\n */ function fromRpc(transaction, _options = {}) {\n    if (!transaction) return null;\n    const signature = _Signature_js__WEBPACK_IMPORTED_MODULE_0__.extract(transaction);\n    const transaction_ = {\n        ...transaction,\n        ...signature\n    };\n    transaction_.blockNumber = transaction.blockNumber ? BigInt(transaction.blockNumber) : null;\n    transaction_.data = transaction.input;\n    transaction_.gas = BigInt(transaction.gas ?? 0n);\n    transaction_.nonce = BigInt(transaction.nonce ?? 0n);\n    transaction_.transactionIndex = transaction.transactionIndex ? Number(transaction.transactionIndex) : null;\n    transaction_.value = BigInt(transaction.value ?? 0n);\n    if (transaction.authorizationList) transaction_.authorizationList = _Authorization_js__WEBPACK_IMPORTED_MODULE_1__.fromRpcList(transaction.authorizationList);\n    if (transaction.chainId) transaction_.chainId = Number(transaction.chainId);\n    if (transaction.gasPrice) transaction_.gasPrice = BigInt(transaction.gasPrice);\n    if (transaction.maxFeePerBlobGas) transaction_.maxFeePerBlobGas = BigInt(transaction.maxFeePerBlobGas);\n    if (transaction.maxFeePerGas) transaction_.maxFeePerGas = BigInt(transaction.maxFeePerGas);\n    if (transaction.maxPriorityFeePerGas) transaction_.maxPriorityFeePerGas = BigInt(transaction.maxPriorityFeePerGas);\n    if (transaction.type) transaction_.type = fromRpcType[transaction.type] ?? transaction.type;\n    if (signature) transaction_.v = _Signature_js__WEBPACK_IMPORTED_MODULE_0__.yParityToV(signature.yParity);\n    return transaction_;\n}\n/**\n * Converts an {@link ox#Transaction.Transaction} to an {@link ox#Transaction.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Transaction } from 'ox'\n *\n * const transaction = Transaction.toRpc({\n *   accessList: [],\n *   blockHash:\n *     '0xc350d807505fb835650f0013632c5515592987ba169bbc6626d9fc54d91f0f0b',\n *   blockNumber: 19868015n,\n *   chainId: 1,\n *   from: '0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6',\n *   gas: 278365n,\n *   hash: '0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0',\n *   input:\n *     '0x3593564c000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000006643504700000000000000000000000000000000000000000000000000000000000000040b080604000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000002800000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000009b6e64a8ec600000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000009b6e64a8ec60000000000000000000000000000000000000000000000000000019124bb5ae978c000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b80000000000000000000000000000000000000000000000000000000000000060000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b8000000000000000000000000000000fee13a103a10d593b9ae06b3e05f2e7e1c00000000000000000000000000000000000000000000000000000000000000190000000000000000000000000000000000000000000000000000000000000060000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b800000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000190240001b9872b',\n *   maxFeePerGas: 11985937556n,\n *   maxPriorityFeePerGas: 68993984n,\n *   nonce: 855n,\n *   r: 44944627813007772897391531230081695102703289123332187696115181104739239197517n,\n *   s: 36528503505192438307355164441104001310566505351980369085208178712678799181120n,\n *   to: '0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad',\n *   transactionIndex: 2,\n *   type: 'eip1559',\n *   v: 27,\n *   value: 700000000000000000n,\n *   yParity: 0,\n * })\n * ```\n *\n * @param transaction - The transaction to convert.\n * @returns An RPC-formatted transaction.\n */ function toRpc(transaction, _options) {\n    const rpc = {};\n    rpc.blockHash = transaction.blockHash;\n    rpc.blockNumber = typeof transaction.blockNumber === \"bigint\" ? _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(transaction.blockNumber) : null;\n    rpc.from = transaction.from;\n    rpc.gas = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(transaction.gas ?? 0n);\n    rpc.hash = transaction.hash;\n    rpc.input = transaction.input;\n    rpc.nonce = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(transaction.nonce ?? 0n);\n    rpc.to = transaction.to;\n    rpc.transactionIndex = transaction.transactionIndex ? _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(transaction.transactionIndex) : null;\n    rpc.type = toRpcType[transaction.type] ?? transaction.type;\n    rpc.value = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(transaction.value ?? 0n);\n    if (transaction.accessList) rpc.accessList = transaction.accessList;\n    if (transaction.authorizationList) rpc.authorizationList = _Authorization_js__WEBPACK_IMPORTED_MODULE_1__.toRpcList(transaction.authorizationList);\n    if (transaction.blobVersionedHashes) rpc.blobVersionedHashes = transaction.blobVersionedHashes;\n    if (transaction.chainId) rpc.chainId = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(transaction.chainId);\n    if (typeof transaction.gasPrice === \"bigint\") rpc.gasPrice = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(transaction.gasPrice);\n    if (typeof transaction.maxFeePerBlobGas === \"bigint\") rpc.maxFeePerBlobGas = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(transaction.maxFeePerBlobGas);\n    if (typeof transaction.maxFeePerGas === \"bigint\") rpc.maxFeePerGas = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(transaction.maxFeePerGas);\n    if (typeof transaction.maxPriorityFeePerGas === \"bigint\") rpc.maxPriorityFeePerGas = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(transaction.maxPriorityFeePerGas);\n    if (typeof transaction.r === \"bigint\") rpc.r = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(transaction.r, {\n        size: 32\n    });\n    if (typeof transaction.s === \"bigint\") rpc.s = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(transaction.s, {\n        size: 32\n    });\n    if (typeof transaction.v === \"number\") rpc.v = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(transaction.v, {\n        size: 1\n    });\n    if (typeof transaction.yParity === \"number\") rpc.yParity = transaction.yParity === 0 ? \"0x0\" : \"0x1\";\n    return rpc;\n} //# sourceMappingURL=Transaction.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1RyYW5zYWN0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBb0Q7QUFDcEI7QUFDWTtBQUM1Qyw4QkFBOEIsR0FDdkIsTUFBTUcsWUFBWTtJQUNyQkMsUUFBUTtJQUNSQyxTQUFTO0lBQ1RDLFNBQVM7SUFDVEMsU0FBUztJQUNUQyxTQUFTO0FBQ2IsRUFBRTtBQUNGLDhCQUE4QixHQUN2QixNQUFNQyxjQUFjO0lBQ3ZCLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0FBQ1gsRUFBRTtBQUNGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FpQ0MsR0FDTSxTQUFTQyxRQUFRQyxXQUFXLEVBQUVDLFdBQVcsQ0FBQyxDQUFDO0lBQzlDLElBQUksQ0FBQ0QsYUFDRCxPQUFPO0lBQ1gsTUFBTUUsWUFBWVgsa0RBQWlCLENBQUNTO0lBQ3BDLE1BQU1JLGVBQWU7UUFDakIsR0FBR0osV0FBVztRQUNkLEdBQUdFLFNBQVM7SUFDaEI7SUFDQUUsYUFBYUMsV0FBVyxHQUFHTCxZQUFZSyxXQUFXLEdBQzVDQyxPQUFPTixZQUFZSyxXQUFXLElBQzlCO0lBQ05ELGFBQWFHLElBQUksR0FBR1AsWUFBWVEsS0FBSztJQUNyQ0osYUFBYUssR0FBRyxHQUFHSCxPQUFPTixZQUFZUyxHQUFHLElBQUksRUFBRTtJQUMvQ0wsYUFBYU0sS0FBSyxHQUFHSixPQUFPTixZQUFZVSxLQUFLLElBQUksRUFBRTtJQUNuRE4sYUFBYU8sZ0JBQWdCLEdBQUdYLFlBQVlXLGdCQUFnQixHQUN0REMsT0FBT1osWUFBWVcsZ0JBQWdCLElBQ25DO0lBQ05QLGFBQWFTLEtBQUssR0FBR1AsT0FBT04sWUFBWWEsS0FBSyxJQUFJLEVBQUU7SUFDbkQsSUFBSWIsWUFBWWMsaUJBQWlCLEVBQzdCVixhQUFhVSxpQkFBaUIsR0FBR3pCLDBEQUF5QixDQUFDVyxZQUFZYyxpQkFBaUI7SUFDNUYsSUFBSWQsWUFBWWdCLE9BQU8sRUFDbkJaLGFBQWFZLE9BQU8sR0FBR0osT0FBT1osWUFBWWdCLE9BQU87SUFDckQsSUFBSWhCLFlBQVlpQixRQUFRLEVBQ3BCYixhQUFhYSxRQUFRLEdBQUdYLE9BQU9OLFlBQVlpQixRQUFRO0lBQ3ZELElBQUlqQixZQUFZa0IsZ0JBQWdCLEVBQzVCZCxhQUFhYyxnQkFBZ0IsR0FBR1osT0FBT04sWUFBWWtCLGdCQUFnQjtJQUN2RSxJQUFJbEIsWUFBWW1CLFlBQVksRUFDeEJmLGFBQWFlLFlBQVksR0FBR2IsT0FBT04sWUFBWW1CLFlBQVk7SUFDL0QsSUFBSW5CLFlBQVlvQixvQkFBb0IsRUFDaENoQixhQUFhZ0Isb0JBQW9CLEdBQUdkLE9BQU9OLFlBQVlvQixvQkFBb0I7SUFDL0UsSUFBSXBCLFlBQVlxQixJQUFJLEVBQ2hCakIsYUFBYWlCLElBQUksR0FDYnZCLFdBQVcsQ0FBQ0UsWUFBWXFCLElBQUksQ0FBQyxJQUFJckIsWUFBWXFCLElBQUk7SUFDekQsSUFBSW5CLFdBQ0FFLGFBQWFrQixDQUFDLEdBQUcvQixxREFBb0IsQ0FBQ1csVUFBVXNCLE9BQU87SUFDM0QsT0FBT3BCO0FBQ1g7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWtDQyxHQUNNLFNBQVNxQixNQUFNekIsV0FBVyxFQUFFQyxRQUFRO0lBQ3ZDLE1BQU15QixNQUFNLENBQUM7SUFDYkEsSUFBSUMsU0FBUyxHQUFHM0IsWUFBWTJCLFNBQVM7SUFDckNELElBQUlyQixXQUFXLEdBQ1gsT0FBT0wsWUFBWUssV0FBVyxLQUFLLFdBQzdCZiwrQ0FBYyxDQUFDVSxZQUFZSyxXQUFXLElBQ3RDO0lBQ1ZxQixJQUFJRyxJQUFJLEdBQUc3QixZQUFZNkIsSUFBSTtJQUMzQkgsSUFBSWpCLEdBQUcsR0FBR25CLCtDQUFjLENBQUNVLFlBQVlTLEdBQUcsSUFBSSxFQUFFO0lBQzlDaUIsSUFBSUksSUFBSSxHQUFHOUIsWUFBWThCLElBQUk7SUFDM0JKLElBQUlsQixLQUFLLEdBQUdSLFlBQVlRLEtBQUs7SUFDN0JrQixJQUFJaEIsS0FBSyxHQUFHcEIsK0NBQWMsQ0FBQ1UsWUFBWVUsS0FBSyxJQUFJLEVBQUU7SUFDbERnQixJQUFJSyxFQUFFLEdBQUcvQixZQUFZK0IsRUFBRTtJQUN2QkwsSUFBSWYsZ0JBQWdCLEdBQUdYLFlBQVlXLGdCQUFnQixHQUM3Q3JCLCtDQUFjLENBQUNVLFlBQVlXLGdCQUFnQixJQUMzQztJQUNOZSxJQUFJTCxJQUFJLEdBQUc3QixTQUFTLENBQUNRLFlBQVlxQixJQUFJLENBQUMsSUFBSXJCLFlBQVlxQixJQUFJO0lBQzFESyxJQUFJYixLQUFLLEdBQUd2QiwrQ0FBYyxDQUFDVSxZQUFZYSxLQUFLLElBQUksRUFBRTtJQUNsRCxJQUFJYixZQUFZZ0MsVUFBVSxFQUN0Qk4sSUFBSU0sVUFBVSxHQUFHaEMsWUFBWWdDLFVBQVU7SUFDM0MsSUFBSWhDLFlBQVljLGlCQUFpQixFQUM3QlksSUFBSVosaUJBQWlCLEdBQUd6Qix3REFBdUIsQ0FBQ1csWUFBWWMsaUJBQWlCO0lBQ2pGLElBQUlkLFlBQVlrQyxtQkFBbUIsRUFDL0JSLElBQUlRLG1CQUFtQixHQUFHbEMsWUFBWWtDLG1CQUFtQjtJQUM3RCxJQUFJbEMsWUFBWWdCLE9BQU8sRUFDbkJVLElBQUlWLE9BQU8sR0FBRzFCLCtDQUFjLENBQUNVLFlBQVlnQixPQUFPO0lBQ3BELElBQUksT0FBT2hCLFlBQVlpQixRQUFRLEtBQUssVUFDaENTLElBQUlULFFBQVEsR0FBRzNCLCtDQUFjLENBQUNVLFlBQVlpQixRQUFRO0lBQ3RELElBQUksT0FBT2pCLFlBQVlrQixnQkFBZ0IsS0FBSyxVQUN4Q1EsSUFBSVIsZ0JBQWdCLEdBQUc1QiwrQ0FBYyxDQUFDVSxZQUFZa0IsZ0JBQWdCO0lBQ3RFLElBQUksT0FBT2xCLFlBQVltQixZQUFZLEtBQUssVUFDcENPLElBQUlQLFlBQVksR0FBRzdCLCtDQUFjLENBQUNVLFlBQVltQixZQUFZO0lBQzlELElBQUksT0FBT25CLFlBQVlvQixvQkFBb0IsS0FBSyxVQUM1Q00sSUFBSU4sb0JBQW9CLEdBQUc5QiwrQ0FBYyxDQUFDVSxZQUFZb0Isb0JBQW9CO0lBQzlFLElBQUksT0FBT3BCLFlBQVltQyxDQUFDLEtBQUssVUFDekJULElBQUlTLENBQUMsR0FBRzdDLCtDQUFjLENBQUNVLFlBQVltQyxDQUFDLEVBQUU7UUFBRUMsTUFBTTtJQUFHO0lBQ3JELElBQUksT0FBT3BDLFlBQVlxQyxDQUFDLEtBQUssVUFDekJYLElBQUlXLENBQUMsR0FBRy9DLCtDQUFjLENBQUNVLFlBQVlxQyxDQUFDLEVBQUU7UUFBRUQsTUFBTTtJQUFHO0lBQ3JELElBQUksT0FBT3BDLFlBQVlzQixDQUFDLEtBQUssVUFDekJJLElBQUlKLENBQUMsR0FBR2hDLCtDQUFjLENBQUNVLFlBQVlzQixDQUFDLEVBQUU7UUFBRWMsTUFBTTtJQUFFO0lBQ3BELElBQUksT0FBT3BDLFlBQVl3QixPQUFPLEtBQUssVUFDL0JFLElBQUlGLE9BQU8sR0FBR3hCLFlBQVl3QixPQUFPLEtBQUssSUFBSSxRQUFRO0lBQ3RELE9BQU9FO0FBQ1gsRUFDQSx1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGF3LXdvcmtzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9UcmFuc2FjdGlvbi5qcz9lOTk4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEF1dGhvcml6YXRpb24gZnJvbSAnLi9BdXRob3JpemF0aW9uLmpzJztcbmltcG9ydCAqIGFzIEhleCBmcm9tICcuL0hleC5qcyc7XG5pbXBvcnQgKiBhcyBTaWduYXR1cmUgZnJvbSAnLi9TaWduYXR1cmUuanMnO1xuLyoqIFR5cGUgdG8gUlBDIFR5cGUgbWFwcGluZy4gKi9cbmV4cG9ydCBjb25zdCB0b1JwY1R5cGUgPSB7XG4gICAgbGVnYWN5OiAnMHgwJyxcbiAgICBlaXAyOTMwOiAnMHgxJyxcbiAgICBlaXAxNTU5OiAnMHgyJyxcbiAgICBlaXA0ODQ0OiAnMHgzJyxcbiAgICBlaXA3NzAyOiAnMHg0Jyxcbn07XG4vKiogUlBDIFR5cGUgdG8gVHlwZSBtYXBwaW5nLiAqL1xuZXhwb3J0IGNvbnN0IGZyb21ScGNUeXBlID0ge1xuICAgICcweDAnOiAnbGVnYWN5JyxcbiAgICAnMHgxJzogJ2VpcDI5MzAnLFxuICAgICcweDInOiAnZWlwMTU1OScsXG4gICAgJzB4Myc6ICdlaXA0ODQ0JyxcbiAgICAnMHg0JzogJ2VpcDc3MDInLFxufTtcbi8qKlxuICogQ29udmVydHMgYW4ge0BsaW5rIG94I1RyYW5zYWN0aW9uLlJwY30gdG8gYW4ge0BsaW5rIG94I1RyYW5zYWN0aW9uLlRyYW5zYWN0aW9ufS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFRyYW5zYWN0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgdHJhbnNhY3Rpb24gPSBUcmFuc2FjdGlvbi5mcm9tUnBjKHtcbiAqICAgaGFzaDogJzB4MzUzZmRmYzM4YTJmMjYxMTVkYWFkZWU5ZjViODM5MmNlNjJiODRmNDEwOTU3OTY3ZTJlZDU2YjM1MzM4Y2RkMCcsXG4gKiAgIG5vbmNlOiAnMHgzNTcnLFxuICogICBibG9ja0hhc2g6XG4gKiAgICAgJzB4YzM1MGQ4MDc1MDVmYjgzNTY1MGYwMDEzNjMyYzU1MTU1OTI5ODdiYTE2OWJiYzY2MjZkOWZjNTRkOTFmMGYwYicsXG4gKiAgIGJsb2NrTnVtYmVyOiAnMHgxMmYyOTZmJyxcbiAqICAgdHJhbnNhY3Rpb25JbmRleDogJzB4MicsXG4gKiAgIGZyb206ICcweDgxNGU1ZTBlMzEwMTZiOWE3ZjEzOGM3NmI3ZTdiMmJiNWMxYWI2YTYnLFxuICogICB0bzogJzB4M2ZjOTFhM2FmZDcwMzk1Y2Q0OTZjNjQ3ZDVhNmNjOWQ0YjJiN2ZhZCcsXG4gKiAgIHZhbHVlOiAnMHg5YjZlNjRhOGVjNjAwMDAnLFxuICogICBnYXM6ICcweDQzZjVkJyxcbiAqICAgbWF4RmVlUGVyR2FzOiAnMHgyY2E2YWU0OTQnLFxuICogICBtYXhQcmlvcml0eUZlZVBlckdhczogJzB4NDFjYzNjMCcsXG4gKiAgIGlucHV0OlxuICogICAgICcweDM1OTM1NjRjMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA2MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwYTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDY2NDM1MDQ3MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNDBiMDgwNjA0MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA0MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwZTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDI4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDliNmU2NGE4ZWM2MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDliNmU2NGE4ZWM2MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxOTEyNGJiNWFlOTc4YzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBjMDJhYWEzOWIyMjNmZThkMGEwZTVjNGYyN2VhZDkwODNjNzU2Y2MyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwYzU2YzdhMGVhYTgwNGY4NTRiNTM2YTVmM2Q1ZjQ5ZDJlYzRiMTJiODAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBjNTZjN2EwZWFhODA0Zjg1NGI1MzZhNWYzZDVmNDlkMmVjNGIxMmI4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwZmVlMTNhMTAzYTEwZDU5M2I5YWUwNmIzZTA1ZjJlN2UxYzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTkwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDYwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwYzU2YzdhMGVhYTgwNGY4NTRiNTM2YTVmM2Q1ZjQ5ZDJlYzRiMTJiODAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTkwMjQwMDAxYjk4NzJiJyxcbiAqICAgcjogJzB4NjM1ZGMyMDMzZTYwMTg1YmIzNjcwOWMyOWM3NWQ2NGVhNTFkZmJkOTFjMzJlZjRiZTE5OGU0Y2ViMTY5ZmI0ZCcsXG4gKiAgIHM6ICcweDUwYzI2NjdhYzRjNzcxMDcyNzQ2YWNmZGNmMWYxNDgzMzM2ZGNjYThiZDJkZjQ3Y2Q4MzE3NWRiZTYwZjA1NDAnLFxuICogICB5UGFyaXR5OiAnMHgwJyxcbiAqICAgY2hhaW5JZDogJzB4MScsXG4gKiAgIGFjY2Vzc0xpc3Q6IFtdLFxuICogICB0eXBlOiAnMHgyJyxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdHJhbnNhY3Rpb24gLSBUaGUgUlBDIHRyYW5zYWN0aW9uIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBBbiBpbnN0YW50aWF0ZWQge0BsaW5rIG94I1RyYW5zYWN0aW9uLlRyYW5zYWN0aW9ufS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21ScGModHJhbnNhY3Rpb24sIF9vcHRpb25zID0ge30pIHtcbiAgICBpZiAoIXRyYW5zYWN0aW9uKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBTaWduYXR1cmUuZXh0cmFjdCh0cmFuc2FjdGlvbik7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25fID0ge1xuICAgICAgICAuLi50cmFuc2FjdGlvbixcbiAgICAgICAgLi4uc2lnbmF0dXJlLFxuICAgIH07XG4gICAgdHJhbnNhY3Rpb25fLmJsb2NrTnVtYmVyID0gdHJhbnNhY3Rpb24uYmxvY2tOdW1iZXJcbiAgICAgICAgPyBCaWdJbnQodHJhbnNhY3Rpb24uYmxvY2tOdW1iZXIpXG4gICAgICAgIDogbnVsbDtcbiAgICB0cmFuc2FjdGlvbl8uZGF0YSA9IHRyYW5zYWN0aW9uLmlucHV0O1xuICAgIHRyYW5zYWN0aW9uXy5nYXMgPSBCaWdJbnQodHJhbnNhY3Rpb24uZ2FzID8/IDBuKTtcbiAgICB0cmFuc2FjdGlvbl8ubm9uY2UgPSBCaWdJbnQodHJhbnNhY3Rpb24ubm9uY2UgPz8gMG4pO1xuICAgIHRyYW5zYWN0aW9uXy50cmFuc2FjdGlvbkluZGV4ID0gdHJhbnNhY3Rpb24udHJhbnNhY3Rpb25JbmRleFxuICAgICAgICA/IE51bWJlcih0cmFuc2FjdGlvbi50cmFuc2FjdGlvbkluZGV4KVxuICAgICAgICA6IG51bGw7XG4gICAgdHJhbnNhY3Rpb25fLnZhbHVlID0gQmlnSW50KHRyYW5zYWN0aW9uLnZhbHVlID8/IDBuKTtcbiAgICBpZiAodHJhbnNhY3Rpb24uYXV0aG9yaXphdGlvbkxpc3QpXG4gICAgICAgIHRyYW5zYWN0aW9uXy5hdXRob3JpemF0aW9uTGlzdCA9IEF1dGhvcml6YXRpb24uZnJvbVJwY0xpc3QodHJhbnNhY3Rpb24uYXV0aG9yaXphdGlvbkxpc3QpO1xuICAgIGlmICh0cmFuc2FjdGlvbi5jaGFpbklkKVxuICAgICAgICB0cmFuc2FjdGlvbl8uY2hhaW5JZCA9IE51bWJlcih0cmFuc2FjdGlvbi5jaGFpbklkKTtcbiAgICBpZiAodHJhbnNhY3Rpb24uZ2FzUHJpY2UpXG4gICAgICAgIHRyYW5zYWN0aW9uXy5nYXNQcmljZSA9IEJpZ0ludCh0cmFuc2FjdGlvbi5nYXNQcmljZSk7XG4gICAgaWYgKHRyYW5zYWN0aW9uLm1heEZlZVBlckJsb2JHYXMpXG4gICAgICAgIHRyYW5zYWN0aW9uXy5tYXhGZWVQZXJCbG9iR2FzID0gQmlnSW50KHRyYW5zYWN0aW9uLm1heEZlZVBlckJsb2JHYXMpO1xuICAgIGlmICh0cmFuc2FjdGlvbi5tYXhGZWVQZXJHYXMpXG4gICAgICAgIHRyYW5zYWN0aW9uXy5tYXhGZWVQZXJHYXMgPSBCaWdJbnQodHJhbnNhY3Rpb24ubWF4RmVlUGVyR2FzKTtcbiAgICBpZiAodHJhbnNhY3Rpb24ubWF4UHJpb3JpdHlGZWVQZXJHYXMpXG4gICAgICAgIHRyYW5zYWN0aW9uXy5tYXhQcmlvcml0eUZlZVBlckdhcyA9IEJpZ0ludCh0cmFuc2FjdGlvbi5tYXhQcmlvcml0eUZlZVBlckdhcyk7XG4gICAgaWYgKHRyYW5zYWN0aW9uLnR5cGUpXG4gICAgICAgIHRyYW5zYWN0aW9uXy50eXBlID1cbiAgICAgICAgICAgIGZyb21ScGNUeXBlW3RyYW5zYWN0aW9uLnR5cGVdID8/IHRyYW5zYWN0aW9uLnR5cGU7XG4gICAgaWYgKHNpZ25hdHVyZSlcbiAgICAgICAgdHJhbnNhY3Rpb25fLnYgPSBTaWduYXR1cmUueVBhcml0eVRvVihzaWduYXR1cmUueVBhcml0eSk7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uXztcbn1cbi8qKlxuICogQ29udmVydHMgYW4ge0BsaW5rIG94I1RyYW5zYWN0aW9uLlRyYW5zYWN0aW9ufSB0byBhbiB7QGxpbmsgb3gjVHJhbnNhY3Rpb24uUnBjfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFRyYW5zYWN0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgdHJhbnNhY3Rpb24gPSBUcmFuc2FjdGlvbi50b1JwYyh7XG4gKiAgIGFjY2Vzc0xpc3Q6IFtdLFxuICogICBibG9ja0hhc2g6XG4gKiAgICAgJzB4YzM1MGQ4MDc1MDVmYjgzNTY1MGYwMDEzNjMyYzU1MTU1OTI5ODdiYTE2OWJiYzY2MjZkOWZjNTRkOTFmMGYwYicsXG4gKiAgIGJsb2NrTnVtYmVyOiAxOTg2ODAxNW4sXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIGZyb206ICcweDgxNGU1ZTBlMzEwMTZiOWE3ZjEzOGM3NmI3ZTdiMmJiNWMxYWI2YTYnLFxuICogICBnYXM6IDI3ODM2NW4sXG4gKiAgIGhhc2g6ICcweDM1M2ZkZmMzOGEyZjI2MTE1ZGFhZGVlOWY1YjgzOTJjZTYyYjg0ZjQxMDk1Nzk2N2UyZWQ1NmIzNTMzOGNkZDAnLFxuICogICBpbnB1dDpcbiAqICAgICAnMHgzNTkzNTY0YzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA2NjQzNTA0NzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDQwYjA4MDYwNDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwODAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGUwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyODAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDQwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA5YjZlNjRhOGVjNjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA5YjZlNjRhOGVjNjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTkxMjRiYjVhZTk3OGMwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBhMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwYzAyYWFhMzliMjIzZmU4ZDBhMGU1YzRmMjdlYWQ5MDgzYzc1NmNjMjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGM1NmM3YTBlYWE4MDRmODU0YjUzNmE1ZjNkNWY0OWQyZWM0YjEyYjgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDYwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwYzU2YzdhMGVhYTgwNGY4NTRiNTM2YTVmM2Q1ZjQ5ZDJlYzRiMTJiODAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGZlZTEzYTEwM2ExMGQ1OTNiOWFlMDZiM2UwNWYyZTdlMWMwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDE5MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA2MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGM1NmM3YTBlYWE4MDRmODU0YjUzNmE1ZjNkNWY0OWQyZWM0YjEyYjgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDE5MDI0MDAwMWI5ODcyYicsXG4gKiAgIG1heEZlZVBlckdhczogMTE5ODU5Mzc1NTZuLFxuICogICBtYXhQcmlvcml0eUZlZVBlckdhczogNjg5OTM5ODRuLFxuICogICBub25jZTogODU1bixcbiAqICAgcjogNDQ5NDQ2Mjc4MTMwMDc3NzI4OTczOTE1MzEyMzAwODE2OTUxMDI3MDMyODkxMjMzMzIxODc2OTYxMTUxODExMDQ3MzkyMzkxOTc1MTduLFxuICogICBzOiAzNjUyODUwMzUwNTE5MjQzODMwNzM1NTE2NDQ0MTEwNDAwMTMxMDU2NjUwNTM1MTk4MDM2OTA4NTIwODE3ODcxMjY3ODc5OTE4MTEyMG4sXG4gKiAgIHRvOiAnMHgzZmM5MWEzYWZkNzAzOTVjZDQ5NmM2NDdkNWE2Y2M5ZDRiMmI3ZmFkJyxcbiAqICAgdHJhbnNhY3Rpb25JbmRleDogMixcbiAqICAgdHlwZTogJ2VpcDE1NTknLFxuICogICB2OiAyNyxcbiAqICAgdmFsdWU6IDcwMDAwMDAwMDAwMDAwMDAwMG4sXG4gKiAgIHlQYXJpdHk6IDAsXG4gKiB9KVxuICogYGBgXG4gKlxuICogQHBhcmFtIHRyYW5zYWN0aW9uIC0gVGhlIHRyYW5zYWN0aW9uIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBBbiBSUEMtZm9ybWF0dGVkIHRyYW5zYWN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9ScGModHJhbnNhY3Rpb24sIF9vcHRpb25zKSB7XG4gICAgY29uc3QgcnBjID0ge307XG4gICAgcnBjLmJsb2NrSGFzaCA9IHRyYW5zYWN0aW9uLmJsb2NrSGFzaDtcbiAgICBycGMuYmxvY2tOdW1iZXIgPVxuICAgICAgICB0eXBlb2YgdHJhbnNhY3Rpb24uYmxvY2tOdW1iZXIgPT09ICdiaWdpbnQnXG4gICAgICAgICAgICA/IEhleC5mcm9tTnVtYmVyKHRyYW5zYWN0aW9uLmJsb2NrTnVtYmVyKVxuICAgICAgICAgICAgOiBudWxsO1xuICAgIHJwYy5mcm9tID0gdHJhbnNhY3Rpb24uZnJvbTtcbiAgICBycGMuZ2FzID0gSGV4LmZyb21OdW1iZXIodHJhbnNhY3Rpb24uZ2FzID8/IDBuKTtcbiAgICBycGMuaGFzaCA9IHRyYW5zYWN0aW9uLmhhc2g7XG4gICAgcnBjLmlucHV0ID0gdHJhbnNhY3Rpb24uaW5wdXQ7XG4gICAgcnBjLm5vbmNlID0gSGV4LmZyb21OdW1iZXIodHJhbnNhY3Rpb24ubm9uY2UgPz8gMG4pO1xuICAgIHJwYy50byA9IHRyYW5zYWN0aW9uLnRvO1xuICAgIHJwYy50cmFuc2FjdGlvbkluZGV4ID0gdHJhbnNhY3Rpb24udHJhbnNhY3Rpb25JbmRleFxuICAgICAgICA/IEhleC5mcm9tTnVtYmVyKHRyYW5zYWN0aW9uLnRyYW5zYWN0aW9uSW5kZXgpXG4gICAgICAgIDogbnVsbDtcbiAgICBycGMudHlwZSA9IHRvUnBjVHlwZVt0cmFuc2FjdGlvbi50eXBlXSA/PyB0cmFuc2FjdGlvbi50eXBlO1xuICAgIHJwYy52YWx1ZSA9IEhleC5mcm9tTnVtYmVyKHRyYW5zYWN0aW9uLnZhbHVlID8/IDBuKTtcbiAgICBpZiAodHJhbnNhY3Rpb24uYWNjZXNzTGlzdClcbiAgICAgICAgcnBjLmFjY2Vzc0xpc3QgPSB0cmFuc2FjdGlvbi5hY2Nlc3NMaXN0O1xuICAgIGlmICh0cmFuc2FjdGlvbi5hdXRob3JpemF0aW9uTGlzdClcbiAgICAgICAgcnBjLmF1dGhvcml6YXRpb25MaXN0ID0gQXV0aG9yaXphdGlvbi50b1JwY0xpc3QodHJhbnNhY3Rpb24uYXV0aG9yaXphdGlvbkxpc3QpO1xuICAgIGlmICh0cmFuc2FjdGlvbi5ibG9iVmVyc2lvbmVkSGFzaGVzKVxuICAgICAgICBycGMuYmxvYlZlcnNpb25lZEhhc2hlcyA9IHRyYW5zYWN0aW9uLmJsb2JWZXJzaW9uZWRIYXNoZXM7XG4gICAgaWYgKHRyYW5zYWN0aW9uLmNoYWluSWQpXG4gICAgICAgIHJwYy5jaGFpbklkID0gSGV4LmZyb21OdW1iZXIodHJhbnNhY3Rpb24uY2hhaW5JZCk7XG4gICAgaWYgKHR5cGVvZiB0cmFuc2FjdGlvbi5nYXNQcmljZSA9PT0gJ2JpZ2ludCcpXG4gICAgICAgIHJwYy5nYXNQcmljZSA9IEhleC5mcm9tTnVtYmVyKHRyYW5zYWN0aW9uLmdhc1ByaWNlKTtcbiAgICBpZiAodHlwZW9mIHRyYW5zYWN0aW9uLm1heEZlZVBlckJsb2JHYXMgPT09ICdiaWdpbnQnKVxuICAgICAgICBycGMubWF4RmVlUGVyQmxvYkdhcyA9IEhleC5mcm9tTnVtYmVyKHRyYW5zYWN0aW9uLm1heEZlZVBlckJsb2JHYXMpO1xuICAgIGlmICh0eXBlb2YgdHJhbnNhY3Rpb24ubWF4RmVlUGVyR2FzID09PSAnYmlnaW50JylcbiAgICAgICAgcnBjLm1heEZlZVBlckdhcyA9IEhleC5mcm9tTnVtYmVyKHRyYW5zYWN0aW9uLm1heEZlZVBlckdhcyk7XG4gICAgaWYgKHR5cGVvZiB0cmFuc2FjdGlvbi5tYXhQcmlvcml0eUZlZVBlckdhcyA9PT0gJ2JpZ2ludCcpXG4gICAgICAgIHJwYy5tYXhQcmlvcml0eUZlZVBlckdhcyA9IEhleC5mcm9tTnVtYmVyKHRyYW5zYWN0aW9uLm1heFByaW9yaXR5RmVlUGVyR2FzKTtcbiAgICBpZiAodHlwZW9mIHRyYW5zYWN0aW9uLnIgPT09ICdiaWdpbnQnKVxuICAgICAgICBycGMuciA9IEhleC5mcm9tTnVtYmVyKHRyYW5zYWN0aW9uLnIsIHsgc2l6ZTogMzIgfSk7XG4gICAgaWYgKHR5cGVvZiB0cmFuc2FjdGlvbi5zID09PSAnYmlnaW50JylcbiAgICAgICAgcnBjLnMgPSBIZXguZnJvbU51bWJlcih0cmFuc2FjdGlvbi5zLCB7IHNpemU6IDMyIH0pO1xuICAgIGlmICh0eXBlb2YgdHJhbnNhY3Rpb24udiA9PT0gJ251bWJlcicpXG4gICAgICAgIHJwYy52ID0gSGV4LmZyb21OdW1iZXIodHJhbnNhY3Rpb24udiwgeyBzaXplOiAxIH0pO1xuICAgIGlmICh0eXBlb2YgdHJhbnNhY3Rpb24ueVBhcml0eSA9PT0gJ251bWJlcicpXG4gICAgICAgIHJwYy55UGFyaXR5ID0gdHJhbnNhY3Rpb24ueVBhcml0eSA9PT0gMCA/ICcweDAnIDogJzB4MSc7XG4gICAgcmV0dXJuIHJwYztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRyYW5zYWN0aW9uLmpzLm1hcCJdLCJuYW1lcyI6WyJBdXRob3JpemF0aW9uIiwiSGV4IiwiU2lnbmF0dXJlIiwidG9ScGNUeXBlIiwibGVnYWN5IiwiZWlwMjkzMCIsImVpcDE1NTkiLCJlaXA0ODQ0IiwiZWlwNzcwMiIsImZyb21ScGNUeXBlIiwiZnJvbVJwYyIsInRyYW5zYWN0aW9uIiwiX29wdGlvbnMiLCJzaWduYXR1cmUiLCJleHRyYWN0IiwidHJhbnNhY3Rpb25fIiwiYmxvY2tOdW1iZXIiLCJCaWdJbnQiLCJkYXRhIiwiaW5wdXQiLCJnYXMiLCJub25jZSIsInRyYW5zYWN0aW9uSW5kZXgiLCJOdW1iZXIiLCJ2YWx1ZSIsImF1dGhvcml6YXRpb25MaXN0IiwiZnJvbVJwY0xpc3QiLCJjaGFpbklkIiwiZ2FzUHJpY2UiLCJtYXhGZWVQZXJCbG9iR2FzIiwibWF4RmVlUGVyR2FzIiwibWF4UHJpb3JpdHlGZWVQZXJHYXMiLCJ0eXBlIiwidiIsInlQYXJpdHlUb1YiLCJ5UGFyaXR5IiwidG9ScGMiLCJycGMiLCJibG9ja0hhc2giLCJmcm9tTnVtYmVyIiwiZnJvbSIsImhhc2giLCJ0byIsImFjY2Vzc0xpc3QiLCJ0b1JwY0xpc3QiLCJibG9iVmVyc2lvbmVkSGFzaGVzIiwiciIsInNpemUiLCJzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Transaction.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/TransactionRequest.js":
/*!*********************************************************!*\
  !*** ./node_modules/ox/_esm/core/TransactionRequest.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromRpc: () => (/* binding */ fromRpc),\n/* harmony export */   toRpc: () => (/* binding */ toRpc)\n/* harmony export */ });\n/* harmony import */ var _Authorization_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Authorization.js */ \"(ssr)/./node_modules/ox/_esm/core/Authorization.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Transaction_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Transaction.js */ \"(ssr)/./node_modules/ox/_esm/core/Transaction.js\");\n\n\n\n/**\n * Converts a {@link ox#TransactionRequest.Rpc} to a {@link ox#TransactionRequest.TransactionRequest}.\n *\n * @example\n * ```ts twoslash\n * import { TransactionRequest } from 'ox'\n *\n * const request = TransactionRequest.fromRpc({\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: '0x2386f26fc10000',\n * })\n * ```\n *\n * @param request - The RPC request to convert.\n * @returns A transaction request.\n */ function fromRpc(request) {\n    const request_ = request;\n    if (typeof request.authorizationList !== \"undefined\") request_.authorizationList = _Authorization_js__WEBPACK_IMPORTED_MODULE_0__.fromRpcList(request.authorizationList);\n    if (typeof request.chainId !== \"undefined\") request_.chainId = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.toNumber(request.chainId);\n    if (typeof request.gas !== \"undefined\") request_.gas = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt(request.gas);\n    if (typeof request.gasPrice !== \"undefined\") request_.gasPrice = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt(request.gasPrice);\n    if (typeof request.maxFeePerBlobGas !== \"undefined\") request_.maxFeePerBlobGas = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt(request.maxFeePerBlobGas);\n    if (typeof request.maxFeePerGas !== \"undefined\") request_.maxFeePerGas = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt(request.maxFeePerGas);\n    if (typeof request.maxPriorityFeePerGas !== \"undefined\") request_.maxPriorityFeePerGas = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt(request.maxPriorityFeePerGas);\n    if (typeof request.nonce !== \"undefined\") request_.nonce = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt(request.nonce);\n    if (typeof request.type !== \"undefined\") request_.type = _Transaction_js__WEBPACK_IMPORTED_MODULE_2__.fromRpcType[request.type] || request.type;\n    if (typeof request.value !== \"undefined\") request_.value = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt(request.value);\n    return request_;\n}\n/**\n * Converts a {@link ox#TransactionRequest.TransactionRequest} to a {@link ox#TransactionRequest.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { TransactionRequest, Value } from 'ox'\n *\n * const request = TransactionRequest.toRpc({\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('0.01'),\n * })\n * ```\n *\n * @example\n * ### Using with a Provider\n *\n * You can use {@link ox#Provider.(from:function)} to instantiate an EIP-1193 Provider and\n * send a transaction to the Wallet using the `eth_sendTransaction` method.\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { Provider, TransactionRequest, Value } from 'ox'\n *\n * const provider = Provider.from(window.ethereum!)\n *\n * const request = TransactionRequest.toRpc({\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: Value.fromEther('0.01'),\n * })\n *\n * const hash = await provider.request({ // [!code focus]\n *   method: 'eth_sendTransaction', // [!code focus]\n *   params: [request], // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param request - The request to convert.\n * @returns An RPC request.\n */ function toRpc(request) {\n    const request_rpc = {};\n    if (typeof request.accessList !== \"undefined\") request_rpc.accessList = request.accessList;\n    if (typeof request.authorizationList !== \"undefined\") request_rpc.authorizationList = _Authorization_js__WEBPACK_IMPORTED_MODULE_0__.toRpcList(request.authorizationList);\n    if (typeof request.blobVersionedHashes !== \"undefined\") request_rpc.blobVersionedHashes = request.blobVersionedHashes;\n    if (typeof request.blobs !== \"undefined\") request_rpc.blobs = request.blobs;\n    if (typeof request.chainId !== \"undefined\") request_rpc.chainId = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(request.chainId);\n    if (typeof request.data !== \"undefined\") {\n        request_rpc.data = request.data;\n        request_rpc.input = request.data;\n    } else if (typeof request.input !== \"undefined\") {\n        request_rpc.data = request.input;\n        request_rpc.input = request.input;\n    }\n    if (typeof request.from !== \"undefined\") request_rpc.from = request.from;\n    if (typeof request.gas !== \"undefined\") request_rpc.gas = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(request.gas);\n    if (typeof request.gasPrice !== \"undefined\") request_rpc.gasPrice = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(request.gasPrice);\n    if (typeof request.maxFeePerBlobGas !== \"undefined\") request_rpc.maxFeePerBlobGas = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(request.maxFeePerBlobGas);\n    if (typeof request.maxFeePerGas !== \"undefined\") request_rpc.maxFeePerGas = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(request.maxFeePerGas);\n    if (typeof request.maxPriorityFeePerGas !== \"undefined\") request_rpc.maxPriorityFeePerGas = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(request.maxPriorityFeePerGas);\n    if (typeof request.maxPriorityFeePerGas !== \"undefined\") request_rpc.maxPriorityFeePerGas = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(request.maxPriorityFeePerGas);\n    if (typeof request.nonce !== \"undefined\") request_rpc.nonce = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(request.nonce);\n    if (typeof request.to !== \"undefined\") request_rpc.to = request.to;\n    if (typeof request.type !== \"undefined\") request_rpc.type = _Transaction_js__WEBPACK_IMPORTED_MODULE_2__.toRpcType[request.type] || request.type;\n    if (typeof request.value !== \"undefined\") request_rpc.value = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(request.value);\n    return request_rpc;\n} //# sourceMappingURL=TransactionRequest.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1RyYW5zYWN0aW9uUmVxdWVzdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFvRDtBQUNwQjtBQUNnQjtBQUNoRDs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDTSxTQUFTRyxRQUFRQyxPQUFPO0lBQzNCLE1BQU1DLFdBQVdEO0lBQ2pCLElBQUksT0FBT0EsUUFBUUUsaUJBQWlCLEtBQUssYUFDckNELFNBQVNDLGlCQUFpQixHQUFHTiwwREFBeUIsQ0FBQ0ksUUFBUUUsaUJBQWlCO0lBQ3BGLElBQUksT0FBT0YsUUFBUUksT0FBTyxLQUFLLGFBQzNCSCxTQUFTRyxPQUFPLEdBQUdQLDZDQUFZLENBQUNHLFFBQVFJLE9BQU87SUFDbkQsSUFBSSxPQUFPSixRQUFRTSxHQUFHLEtBQUssYUFDdkJMLFNBQVNLLEdBQUcsR0FBR1QsNkNBQVksQ0FBQ0csUUFBUU0sR0FBRztJQUMzQyxJQUFJLE9BQU9OLFFBQVFRLFFBQVEsS0FBSyxhQUM1QlAsU0FBU08sUUFBUSxHQUFHWCw2Q0FBWSxDQUFDRyxRQUFRUSxRQUFRO0lBQ3JELElBQUksT0FBT1IsUUFBUVMsZ0JBQWdCLEtBQUssYUFDcENSLFNBQVNRLGdCQUFnQixHQUFHWiw2Q0FBWSxDQUFDRyxRQUFRUyxnQkFBZ0I7SUFDckUsSUFBSSxPQUFPVCxRQUFRVSxZQUFZLEtBQUssYUFDaENULFNBQVNTLFlBQVksR0FBR2IsNkNBQVksQ0FBQ0csUUFBUVUsWUFBWTtJQUM3RCxJQUFJLE9BQU9WLFFBQVFXLG9CQUFvQixLQUFLLGFBQ3hDVixTQUFTVSxvQkFBb0IsR0FBR2QsNkNBQVksQ0FBQ0csUUFBUVcsb0JBQW9CO0lBQzdFLElBQUksT0FBT1gsUUFBUVksS0FBSyxLQUFLLGFBQ3pCWCxTQUFTVyxLQUFLLEdBQUdmLDZDQUFZLENBQUNHLFFBQVFZLEtBQUs7SUFDL0MsSUFBSSxPQUFPWixRQUFRYSxJQUFJLEtBQUssYUFDeEJaLFNBQVNZLElBQUksR0FDVGYsd0RB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c291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xhdy13b3Jrcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvVHJhbnNhY3Rpb25SZXF1ZXN0LmpzPzEzZjIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQXV0aG9yaXphdGlvbiBmcm9tICcuL0F1dGhvcml6YXRpb24uanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbmltcG9ydCAqIGFzIFRyYW5zYWN0aW9uIGZyb20gJy4vVHJhbnNhY3Rpb24uanMnO1xuLyoqXG4gKiBDb252ZXJ0cyBhIHtAbGluayBveCNUcmFuc2FjdGlvblJlcXVlc3QuUnBjfSB0byBhIHtAbGluayBveCNUcmFuc2FjdGlvblJlcXVlc3QuVHJhbnNhY3Rpb25SZXF1ZXN0fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFRyYW5zYWN0aW9uUmVxdWVzdCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHJlcXVlc3QgPSBUcmFuc2FjdGlvblJlcXVlc3QuZnJvbVJwYyh7XG4gKiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgdmFsdWU6ICcweDIzODZmMjZmYzEwMDAwJyxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gcmVxdWVzdCAtIFRoZSBSUEMgcmVxdWVzdCB0byBjb252ZXJ0LlxuICogQHJldHVybnMgQSB0cmFuc2FjdGlvbiByZXF1ZXN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJwYyhyZXF1ZXN0KSB7XG4gICAgY29uc3QgcmVxdWVzdF8gPSByZXF1ZXN0O1xuICAgIGlmICh0eXBlb2YgcmVxdWVzdC5hdXRob3JpemF0aW9uTGlzdCAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJlcXVlc3RfLmF1dGhvcml6YXRpb25MaXN0ID0gQXV0aG9yaXphdGlvbi5mcm9tUnBjTGlzdChyZXF1ZXN0LmF1dGhvcml6YXRpb25MaXN0KTtcbiAgICBpZiAodHlwZW9mIHJlcXVlc3QuY2hhaW5JZCAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJlcXVlc3RfLmNoYWluSWQgPSBIZXgudG9OdW1iZXIocmVxdWVzdC5jaGFpbklkKTtcbiAgICBpZiAodHlwZW9mIHJlcXVlc3QuZ2FzICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgcmVxdWVzdF8uZ2FzID0gSGV4LnRvQmlnSW50KHJlcXVlc3QuZ2FzKTtcbiAgICBpZiAodHlwZW9mIHJlcXVlc3QuZ2FzUHJpY2UgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICByZXF1ZXN0Xy5nYXNQcmljZSA9IEhleC50b0JpZ0ludChyZXF1ZXN0Lmdhc1ByaWNlKTtcbiAgICBpZiAodHlwZW9mIHJlcXVlc3QubWF4RmVlUGVyQmxvYkdhcyAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJlcXVlc3RfLm1heEZlZVBlckJsb2JHYXMgPSBIZXgudG9CaWdJbnQocmVxdWVzdC5tYXhGZWVQZXJCbG9iR2FzKTtcbiAgICBpZiAodHlwZW9mIHJlcXVlc3QubWF4RmVlUGVyR2FzICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgcmVxdWVzdF8ubWF4RmVlUGVyR2FzID0gSGV4LnRvQmlnSW50KHJlcXVlc3QubWF4RmVlUGVyR2FzKTtcbiAgICBpZiAodHlwZW9mIHJlcXVlc3QubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICByZXF1ZXN0Xy5tYXhQcmlvcml0eUZlZVBlckdhcyA9IEhleC50b0JpZ0ludChyZXF1ZXN0Lm1heFByaW9yaXR5RmVlUGVyR2FzKTtcbiAgICBpZiAodHlwZW9mIHJlcXVlc3Qubm9uY2UgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICByZXF1ZXN0Xy5ub25jZSA9IEhleC50b0JpZ0ludChyZXF1ZXN0Lm5vbmNlKTtcbiAgICBpZiAodHlwZW9mIHJlcXVlc3QudHlwZSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJlcXVlc3RfLnR5cGUgPVxuICAgICAgICAgICAgVHJhbnNhY3Rpb24uZnJvbVJwY1R5cGVbcmVxdWVzdC50eXBlXSB8fCByZXF1ZXN0LnR5cGU7XG4gICAgaWYgKHR5cGVvZiByZXF1ZXN0LnZhbHVlICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgcmVxdWVzdF8udmFsdWUgPSBIZXgudG9CaWdJbnQocmVxdWVzdC52YWx1ZSk7XG4gICAgcmV0dXJuIHJlcXVlc3RfO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIHtAbGluayBveCNUcmFuc2FjdGlvblJlcXVlc3QuVHJhbnNhY3Rpb25SZXF1ZXN0fSB0byBhIHtAbGluayBveCNUcmFuc2FjdGlvblJlcXVlc3QuUnBjfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFRyYW5zYWN0aW9uUmVxdWVzdCwgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCByZXF1ZXN0ID0gVHJhbnNhY3Rpb25SZXF1ZXN0LnRvUnBjKHtcbiAqICAgdG86ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICB2YWx1ZTogVmFsdWUuZnJvbUV0aGVyKCcwLjAxJyksXG4gKiB9KVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBVc2luZyB3aXRoIGEgUHJvdmlkZXJcbiAqXG4gKiBZb3UgY2FuIHVzZSB7QGxpbmsgb3gjUHJvdmlkZXIuKGZyb206ZnVuY3Rpb24pfSB0byBpbnN0YW50aWF0ZSBhbiBFSVAtMTE5MyBQcm92aWRlciBhbmRcbiAqIHNlbmQgYSB0cmFuc2FjdGlvbiB0byB0aGUgV2FsbGV0IHVzaW5nIHRoZSBgZXRoX3NlbmRUcmFuc2FjdGlvbmAgbWV0aG9kLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgJ294L3dpbmRvdydcbiAqIGltcG9ydCB7IFByb3ZpZGVyLCBUcmFuc2FjdGlvblJlcXVlc3QsIFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgcHJvdmlkZXIgPSBQcm92aWRlci5mcm9tKHdpbmRvdy5ldGhlcmV1bSEpXG4gKlxuICogY29uc3QgcmVxdWVzdCA9IFRyYW5zYWN0aW9uUmVxdWVzdC50b1JwYyh7XG4gKiAgIHRvOiAnMHg3MDk5Nzk3MGM1MTgxMmRjM2EwMTBjN2QwMWI1MGUwZDE3ZGM3OWM4JyxcbiAqICAgdmFsdWU6IFZhbHVlLmZyb21FdGhlcignMC4wMScpLFxuICogfSlcbiAqXG4gKiBjb25zdCBoYXNoID0gYXdhaXQgcHJvdmlkZXIucmVxdWVzdCh7IC8vIFshY29kZSBmb2N1c11cbiAqICAgbWV0aG9kOiAnZXRoX3NlbmRUcmFuc2FjdGlvbicsIC8vIFshY29kZSBmb2N1c11cbiAqICAgcGFyYW1zOiBbcmVxdWVzdF0sIC8vIFshY29kZSBmb2N1c11cbiAqIH0pIC8vIFshY29kZSBmb2N1c11cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSByZXF1ZXN0IC0gVGhlIHJlcXVlc3QgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIEFuIFJQQyByZXF1ZXN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9ScGMocmVxdWVzdCkge1xuICAgIGNvbnN0IHJlcXVlc3RfcnBjID0ge307XG4gICAgaWYgKHR5cGVvZiByZXF1ZXN0LmFjY2Vzc0xpc3QgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICByZXF1ZXN0X3JwYy5hY2Nlc3NMaXN0ID0gcmVxdWVzdC5hY2Nlc3NMaXN0O1xuICAgIGlmICh0eXBlb2YgcmVxdWVzdC5hdXRob3JpemF0aW9uTGlzdCAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJlcXVlc3RfcnBjLmF1dGhvcml6YXRpb25MaXN0ID0gQXV0aG9yaXphdGlvbi50b1JwY0xpc3QocmVxdWVzdC5hdXRob3JpemF0aW9uTGlzdCk7XG4gICAgaWYgKHR5cGVvZiByZXF1ZXN0LmJsb2JWZXJzaW9uZWRIYXNoZXMgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICByZXF1ZXN0X3JwYy5ibG9iVmVyc2lvbmVkSGFzaGVzID0gcmVxdWVzdC5ibG9iVmVyc2lvbmVkSGFzaGVzO1xuICAgIGlmICh0eXBlb2YgcmVxdWVzdC5ibG9icyAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJlcXVlc3RfcnBjLmJsb2JzID0gcmVxdWVzdC5ibG9icztcbiAgICBpZiAodHlwZW9mIHJlcXVlc3QuY2hhaW5JZCAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJlcXVlc3RfcnBjLmNoYWluSWQgPSBIZXguZnJvbU51bWJlcihyZXF1ZXN0LmNoYWluSWQpO1xuICAgIGlmICh0eXBlb2YgcmVxdWVzdC5kYXRhICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXF1ZXN0X3JwYy5kYXRhID0gcmVxdWVzdC5kYXRhO1xuICAgICAgICByZXF1ZXN0X3JwYy5pbnB1dCA9IHJlcXVlc3QuZGF0YTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHJlcXVlc3QuaW5wdXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJlcXVlc3RfcnBjLmRhdGEgPSByZXF1ZXN0LmlucHV0O1xuICAgICAgICByZXF1ZXN0X3JwYy5pbnB1dCA9IHJlcXVlc3QuaW5wdXQ7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcmVxdWVzdC5mcm9tICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgcmVxdWVzdF9ycGMuZnJvbSA9IHJlcXVlc3QuZnJvbTtcbiAgICBpZiAodHlwZW9mIHJlcXVlc3QuZ2FzICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgcmVxdWVzdF9ycGMuZ2FzID0gSGV4LmZyb21OdW1iZXIocmVxdWVzdC5nYXMpO1xuICAgIGlmICh0eXBlb2YgcmVxdWVzdC5nYXNQcmljZSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJlcXVlc3RfcnBjLmdhc1ByaWNlID0gSGV4LmZyb21OdW1iZXIocmVxdWVzdC5nYXNQcmljZSk7XG4gICAgaWYgKHR5cGVvZiByZXF1ZXN0Lm1heEZlZVBlckJsb2JHYXMgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICByZXF1ZXN0X3JwYy5tYXhGZWVQZXJCbG9iR2FzID0gSGV4LmZyb21OdW1iZXIocmVxdWVzdC5tYXhGZWVQZXJCbG9iR2FzKTtcbiAgICBpZiAodHlwZW9mIHJlcXVlc3QubWF4RmVlUGVyR2FzICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgcmVxdWVzdF9ycGMubWF4RmVlUGVyR2FzID0gSGV4LmZyb21OdW1iZXIocmVxdWVzdC5tYXhGZWVQZXJHYXMpO1xuICAgIGlmICh0eXBlb2YgcmVxdWVzdC5tYXhQcmlvcml0eUZlZVBlckdhcyAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJlcXVlc3RfcnBjLm1heFByaW9yaXR5RmVlUGVyR2FzID0gSGV4LmZyb21OdW1iZXIocmVxdWVzdC5tYXhQcmlvcml0eUZlZVBlckdhcyk7XG4gICAgaWYgKHR5cGVvZiByZXF1ZXN0Lm1heFByaW9yaXR5RmVlUGVyR2FzICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgcmVxdWVzdF9ycGMubWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBIZXguZnJvbU51bWJlcihyZXF1ZXN0Lm1heFByaW9yaXR5RmVlUGVyR2FzKTtcbiAgICBpZiAodHlwZW9mIHJlcXVlc3Qubm9uY2UgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICByZXF1ZXN0X3JwYy5ub25jZSA9IEhleC5mcm9tTnVtYmVyKHJlcXVlc3Qubm9uY2UpO1xuICAgIGlmICh0eXBlb2YgcmVxdWVzdC50byAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJlcXVlc3RfcnBjLnRvID0gcmVxdWVzdC50bztcbiAgICBpZiAodHlwZW9mIHJlcXVlc3QudHlwZSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJlcXVlc3RfcnBjLnR5cGUgPVxuICAgICAgICAgICAgVHJhbnNhY3Rpb24udG9ScGNUeXBlW3JlcXVlc3QudHlwZV0gfHwgcmVxdWVzdC50eXBlO1xuICAgIGlmICh0eXBlb2YgcmVxdWVzdC52YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJlcXVlc3RfcnBjLnZhbHVlID0gSGV4LmZyb21OdW1iZXIocmVxdWVzdC52YWx1ZSk7XG4gICAgcmV0dXJuIHJlcXVlc3RfcnBjO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VHJhbnNhY3Rpb25SZXF1ZXN0LmpzLm1hcCJdLCJuYW1lcyI6WyJBdXRob3JpemF0aW9uIiwiSGV4IiwiVHJhbnNhY3Rpb24iLCJmcm9tUnBjIiwicmVxdWVzdCIsInJlcXVlc3RfIiwiYXV0aG9yaXphdGlvbkxpc3QiLCJmcm9tUnBjTGlzdCIsImNoYWluSWQiLCJ0b051bWJlciIsImdhcyIsInRvQmlnSW50IiwiZ2FzUHJpY2UiLCJtYXhGZWVQZXJCbG9iR2FzIiwibWF4RmVlUGVyR2FzIiwibWF4UHJpb3JpdHlGZWVQZXJHYXMiLCJub25jZSIsInR5cGUiLCJmcm9tUnBjVHlwZSIsInZhbHVlIiwidG9ScGMiLCJyZXF1ZXN0X3JwYyIsImFjY2Vzc0xpc3QiLCJ0b1JwY0xpc3QiLCJibG9iVmVyc2lvbmVkSGFzaGVzIiwiYmxvYnMiLCJmcm9tTnVtYmVyIiwiZGF0YSIsImlucHV0IiwiZnJvbSIsInRvIiwidG9ScGNUeXBlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/TransactionRequest.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/TxEnvelope.js":
/*!*************************************************!*\
  !*** ./node_modules/ox/_esm/core/TxEnvelope.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FeeCapTooHighError: () => (/* binding */ FeeCapTooHighError),\n/* harmony export */   GasPriceTooHighError: () => (/* binding */ GasPriceTooHighError),\n/* harmony export */   InvalidChainIdError: () => (/* binding */ InvalidChainIdError),\n/* harmony export */   InvalidSerializedError: () => (/* binding */ InvalidSerializedError),\n/* harmony export */   TipAboveFeeCapError: () => (/* binding */ TipAboveFeeCapError)\n/* harmony export */ });\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Value_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Value.js */ \"(ssr)/./node_modules/ox/_esm/core/Value.js\");\n\n\n/**\n * Thrown when a fee cap is too high.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeEip1559 } from 'ox'\n *\n * TxEnvelopeEip1559.assert({\n *   maxFeePerGas: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n * })\n * // @error: TransactionEnvelope.FeeCapTooHighError: The fee cap (`maxFeePerGas`/`maxPriorityFeePerGas` = 115792089237316195423570985008687907853269984665640564039457584007913.129639936 gwei) cannot be higher than the maximum allowed value (2^256-1).\n * ```\n */ class FeeCapTooHighError extends _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ feeCap } = {}){\n        super(`The fee cap (\\`maxFeePerGas\\`/\\`maxPriorityFeePerGas\\`${feeCap ? ` = ${_Value_js__WEBPACK_IMPORTED_MODULE_1__.formatGwei(feeCap)} gwei` : \"\"}) cannot be higher than the maximum allowed value (2^256-1).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"TransactionEnvelope.FeeCapTooHighError\"\n        });\n    }\n}\n/**\n * Thrown when a gas price is too high.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeLegacy } from 'ox'\n *\n * TxEnvelopeLegacy.assert({\n *   gasPrice: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n * })\n * // @error: TransactionEnvelope.GasPriceTooHighError: The gas price (`gasPrice` = 115792089237316195423570985008687907853269984665640564039457584007913.129639936 gwei) cannot be higher than the maximum allowed value (2^256-1).\n * ```\n */ class GasPriceTooHighError extends _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ gasPrice } = {}){\n        super(`The gas price (\\`gasPrice\\`${gasPrice ? ` = ${_Value_js__WEBPACK_IMPORTED_MODULE_1__.formatGwei(gasPrice)} gwei` : \"\"}) cannot be higher than the maximum allowed value (2^256-1).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"TransactionEnvelope.GasPriceTooHighError\"\n        });\n    }\n}\n/**\n * Thrown when a chain ID is invalid.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeEip1559 } from 'ox'\n *\n * TxEnvelopeEip1559.assert({ chainId: 0 })\n * // @error: TransactionEnvelope.InvalidChainIdError: Chain ID \"0\" is invalid.\n * ```\n */ class InvalidChainIdError extends _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ chainId }){\n        super(typeof chainId !== \"undefined\" ? `Chain ID \"${chainId}\" is invalid.` : \"Chain ID is invalid.\");\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"TransactionEnvelope.InvalidChainIdError\"\n        });\n    }\n}\n/**\n * Thrown when a serialized transaction is invalid.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeEip1559 } from 'ox'\n *\n * TxEnvelopeEip1559.deserialize('0x02c0')\n * // @error: TransactionEnvelope.InvalidSerializedError: Invalid serialized transaction of type \"eip1559\" was provided.\n * // @error: Serialized Transaction: \"0x02c0\"\n * // @error: Missing Attributes: chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to, value, data, accessList\n * ```\n */ class InvalidSerializedError extends _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ attributes, serialized, type }){\n        const missing = Object.entries(attributes).map(([key, value])=>typeof value === \"undefined\" ? key : undefined).filter(Boolean);\n        super(`Invalid serialized transaction of type \"${type}\" was provided.`, {\n            metaMessages: [\n                `Serialized Transaction: \"${serialized}\"`,\n                missing.length > 0 ? `Missing Attributes: ${missing.join(\", \")}` : \"\"\n            ].filter(Boolean)\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"TransactionEnvelope.InvalidSerializedError\"\n        });\n    }\n}\n/**\n * Thrown when a tip is higher than a fee cap.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeEip1559 } from 'ox'\n *\n * TxEnvelopeEip1559.assert({\n *   chainId: 1,\n *   maxFeePerGas: 10n,\n *   maxPriorityFeePerGas: 11n,\n * })\n * // @error: TransactionEnvelope.TipAboveFeeCapError: The provided tip (`maxPriorityFeePerGas` = 11 gwei) cannot be higher than the fee cap (`maxFeePerGas` = 10 gwei).\n * ```\n */ class TipAboveFeeCapError extends _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ maxPriorityFeePerGas, maxFeePerGas } = {}){\n        super([\n            `The provided tip (\\`maxPriorityFeePerGas\\`${maxPriorityFeePerGas ? ` = ${_Value_js__WEBPACK_IMPORTED_MODULE_1__.formatGwei(maxPriorityFeePerGas)} gwei` : \"\"}) cannot be higher than the fee cap (\\`maxFeePerGas\\`${maxFeePerGas ? ` = ${_Value_js__WEBPACK_IMPORTED_MODULE_1__.formatGwei(maxFeePerGas)} gwei` : \"\"}).`\n        ].join(\"\\n\"));\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"TransactionEnvelope.TipAboveFeeCapError\"\n        });\n    }\n} //# sourceMappingURL=TxEnvelope.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1R4RW52ZWxvcGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFzQztBQUNGO0FBQ3BDOzs7Ozs7Ozs7Ozs7O0NBYUMsR0FDTSxNQUFNRSwyQkFBMkJGLGlEQUFnQjtJQUNwREksWUFBWSxFQUFFQyxNQUFNLEVBQUcsR0FBRyxDQUFDLENBQUMsQ0FBRTtRQUMxQixLQUFLLENBQUMsQ0FBQyxzREFBc0QsRUFBRUEsU0FBUyxDQUFDLEdBQUcsRUFBRUosaURBQWdCLENBQUNJLFFBQVEsS0FBSyxDQUFDLEdBQUcsR0FBRyw0REFBNEQsQ0FBQztRQUNoTEUsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxRQUFRO1lBQ2hDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxPQUFPO1FBQ1g7SUFDSjtBQUNKO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Q0FhQyxHQUNNLE1BQU1DLDZCQUE2QmIsaURBQWdCO0lBQ3RESSxZQUFZLEVBQUVVLFFBQVEsRUFBRyxHQUFHLENBQUMsQ0FBQyxDQUFFO1FBQzVCLEtBQUssQ0FBQyxDQUFDLDJCQUEyQixFQUFFQSxXQUFXLENBQUMsR0FBRyxFQUFFYixpREFBZ0IsQ0FBQ2EsVUFBVSxLQUFLLENBQUMsR0FBRyxHQUFHLDREQUE0RCxDQUFDO1FBQ3pKUCxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLFFBQVE7WUFDaENDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU87UUFDWDtJQUNKO0FBQ0o7QUFDQTs7Ozs7Ozs7OztDQVVDLEdBQ00sTUFBTUcsNEJBQTRCZixpREFBZ0I7SUFDckRJLFlBQVksRUFBRVksT0FBTyxFQUFFLENBQUU7UUFDckIsS0FBSyxDQUFDLE9BQU9BLFlBQVksY0FDbkIsQ0FBQyxVQUFVLEVBQUVBLFFBQVEsYUFBYSxDQUFDLEdBQ25DO1FBQ05ULE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsUUFBUTtZQUNoQ0MsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVkMsT0FBTztRQUNYO0lBQ0o7QUFDSjtBQUNBOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUNNLE1BQU1LLCtCQUErQmpCLGlEQUFnQjtJQUN4REksWUFBWSxFQUFFYyxVQUFVLEVBQUVDLFVBQVUsRUFBRUMsSUFBSSxFQUFHLENBQUU7UUFDM0MsTUFBTUMsVUFBVWQsT0FBT2UsT0FBTyxDQUFDSixZQUMxQkssR0FBRyxDQUFDLENBQUMsQ0FBQ0MsS0FBS1osTUFBTSxHQUFNLE9BQU9BLFVBQVUsY0FBY1ksTUFBTUMsV0FDNURDLE1BQU0sQ0FBQ0M7UUFDWixLQUFLLENBQUMsQ0FBQyx3Q0FBd0MsRUFBRVAsS0FBSyxlQUFlLENBQUMsRUFBRTtZQUNwRVEsY0FBYztnQkFDVixDQUFDLHlCQUF5QixFQUFFVCxXQUFXLENBQUMsQ0FBQztnQkFDekNFLFFBQVFRLE1BQU0sR0FBRyxJQUFJLENBQUMsb0JBQW9CLEVBQUVSLFFBQVFTLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRzthQUN0RSxDQUFDSixNQUFNLENBQUNDO1FBQ2I7UUFDQXBCLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsUUFBUTtZQUNoQ0MsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVkMsT0FBTztRQUNYO0lBQ0o7QUFDSjtBQUNBOzs7Ozs7Ozs7Ozs7OztDQWNDLEdBQ00sTUFBTW1CLDRCQUE0Qi9CLGlEQUFnQjtJQUNyREksWUFBWSxFQUFFNEIsb0JBQW9CLEVBQUVDLFlBQVksRUFBRyxHQUFHLENBQUMsQ0FBQyxDQUFFO1FBQ3RELEtBQUssQ0FBQztZQUNGLENBQUMsMENBQTBDLEVBQUVELHVCQUN2QyxDQUFDLEdBQUcsRUFBRS9CLGlEQUFnQixDQUFDK0Isc0JBQXNCLEtBQUssQ0FBQyxHQUNuRCxHQUFHLHFEQUFxRCxFQUFFQyxlQUFlLENBQUMsR0FBRyxFQUFFaEMsaURBQWdCLENBQUNnQyxjQUFjLEtBQUssQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDO1NBQ3RJLENBQUNILElBQUksQ0FBQztRQUNQdkIsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxRQUFRO1lBQ2hDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxPQUFPO1FBQ1g7SUFDSjtBQUNKLEVBQ0Esc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xhdy13b3Jrcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvVHhFbnZlbG9wZS5qcz82NWE1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEVycm9ycyBmcm9tICcuL0Vycm9ycy5qcyc7XG5pbXBvcnQgKiBhcyBWYWx1ZSBmcm9tICcuL1ZhbHVlLmpzJztcbi8qKlxuICogVGhyb3duIHdoZW4gYSBmZWUgY2FwIGlzIHRvbyBoaWdoLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHhFbnZlbG9wZUVpcDE1NTkgfSBmcm9tICdveCdcbiAqXG4gKiBUeEVudmVsb3BlRWlwMTU1OS5hc3NlcnQoe1xuICogICBtYXhGZWVQZXJHYXM6IDJuICoqIDI1Nm4gLSAxbiArIDFuLFxuICogICBjaGFpbklkOiAxLFxuICogfSlcbiAqIC8vIEBlcnJvcjogVHJhbnNhY3Rpb25FbnZlbG9wZS5GZWVDYXBUb29IaWdoRXJyb3I6IFRoZSBmZWUgY2FwIChgbWF4RmVlUGVyR2FzYC9gbWF4UHJpb3JpdHlGZWVQZXJHYXNgID0gMTE1NzkyMDg5MjM3MzE2MTk1NDIzNTcwOTg1MDA4Njg3OTA3ODUzMjY5OTg0NjY1NjQwNTY0MDM5NDU3NTg0MDA3OTEzLjEyOTYzOTkzNiBnd2VpKSBjYW5ub3QgYmUgaGlnaGVyIHRoYW4gdGhlIG1heGltdW0gYWxsb3dlZCB2YWx1ZSAoMl4yNTYtMSkuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEZlZUNhcFRvb0hpZ2hFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgZmVlQ2FwLCB9ID0ge30pIHtcbiAgICAgICAgc3VwZXIoYFRoZSBmZWUgY2FwIChcXGBtYXhGZWVQZXJHYXNcXGAvXFxgbWF4UHJpb3JpdHlGZWVQZXJHYXNcXGAke2ZlZUNhcCA/IGAgPSAke1ZhbHVlLmZvcm1hdEd3ZWkoZmVlQ2FwKX0gZ3dlaWAgOiAnJ30pIGNhbm5vdCBiZSBoaWdoZXIgdGhhbiB0aGUgbWF4aW11bSBhbGxvd2VkIHZhbHVlICgyXjI1Ni0xKS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1RyYW5zYWN0aW9uRW52ZWxvcGUuRmVlQ2FwVG9vSGlnaEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIGEgZ2FzIHByaWNlIGlzIHRvbyBoaWdoLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHhFbnZlbG9wZUxlZ2FjeSB9IGZyb20gJ294J1xuICpcbiAqIFR4RW52ZWxvcGVMZWdhY3kuYXNzZXJ0KHtcbiAqICAgZ2FzUHJpY2U6IDJuICoqIDI1Nm4gLSAxbiArIDFuLFxuICogICBjaGFpbklkOiAxLFxuICogfSlcbiAqIC8vIEBlcnJvcjogVHJhbnNhY3Rpb25FbnZlbG9wZS5HYXNQcmljZVRvb0hpZ2hFcnJvcjogVGhlIGdhcyBwcmljZSAoYGdhc1ByaWNlYCA9IDExNTc5MjA4OTIzNzMxNjE5NTQyMzU3MDk4NTAwODY4NzkwNzg1MzI2OTk4NDY2NTY0MDU2NDAzOTQ1NzU4NDAwNzkxMy4xMjk2Mzk5MzYgZ3dlaSkgY2Fubm90IGJlIGhpZ2hlciB0aGFuIHRoZSBtYXhpbXVtIGFsbG93ZWQgdmFsdWUgKDJeMjU2LTEpLlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBHYXNQcmljZVRvb0hpZ2hFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgZ2FzUHJpY2UsIH0gPSB7fSkge1xuICAgICAgICBzdXBlcihgVGhlIGdhcyBwcmljZSAoXFxgZ2FzUHJpY2VcXGAke2dhc1ByaWNlID8gYCA9ICR7VmFsdWUuZm9ybWF0R3dlaShnYXNQcmljZSl9IGd3ZWlgIDogJyd9KSBjYW5ub3QgYmUgaGlnaGVyIHRoYW4gdGhlIG1heGltdW0gYWxsb3dlZCB2YWx1ZSAoMl4yNTYtMSkuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdUcmFuc2FjdGlvbkVudmVsb3BlLkdhc1ByaWNlVG9vSGlnaEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIGEgY2hhaW4gSUQgaXMgaW52YWxpZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFR4RW52ZWxvcGVFaXAxNTU5IH0gZnJvbSAnb3gnXG4gKlxuICogVHhFbnZlbG9wZUVpcDE1NTkuYXNzZXJ0KHsgY2hhaW5JZDogMCB9KVxuICogLy8gQGVycm9yOiBUcmFuc2FjdGlvbkVudmVsb3BlLkludmFsaWRDaGFpbklkRXJyb3I6IENoYWluIElEIFwiMFwiIGlzIGludmFsaWQuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRDaGFpbklkRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGNoYWluSWQgfSkge1xuICAgICAgICBzdXBlcih0eXBlb2YgY2hhaW5JZCAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgID8gYENoYWluIElEIFwiJHtjaGFpbklkfVwiIGlzIGludmFsaWQuYFxuICAgICAgICAgICAgOiAnQ2hhaW4gSUQgaXMgaW52YWxpZC4nKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1RyYW5zYWN0aW9uRW52ZWxvcGUuSW52YWxpZENoYWluSWRFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd24gd2hlbiBhIHNlcmlhbGl6ZWQgdHJhbnNhY3Rpb24gaXMgaW52YWxpZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFR4RW52ZWxvcGVFaXAxNTU5IH0gZnJvbSAnb3gnXG4gKlxuICogVHhFbnZlbG9wZUVpcDE1NTkuZGVzZXJpYWxpemUoJzB4MDJjMCcpXG4gKiAvLyBAZXJyb3I6IFRyYW5zYWN0aW9uRW52ZWxvcGUuSW52YWxpZFNlcmlhbGl6ZWRFcnJvcjogSW52YWxpZCBzZXJpYWxpemVkIHRyYW5zYWN0aW9uIG9mIHR5cGUgXCJlaXAxNTU5XCIgd2FzIHByb3ZpZGVkLlxuICogLy8gQGVycm9yOiBTZXJpYWxpemVkIFRyYW5zYWN0aW9uOiBcIjB4MDJjMFwiXG4gKiAvLyBAZXJyb3I6IE1pc3NpbmcgQXR0cmlidXRlczogY2hhaW5JZCwgbm9uY2UsIG1heFByaW9yaXR5RmVlUGVyR2FzLCBtYXhGZWVQZXJHYXMsIGdhcywgdG8sIHZhbHVlLCBkYXRhLCBhY2Nlc3NMaXN0XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRTZXJpYWxpemVkRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGF0dHJpYnV0ZXMsIHNlcmlhbGl6ZWQsIHR5cGUsIH0pIHtcbiAgICAgICAgY29uc3QgbWlzc2luZyA9IE9iamVjdC5lbnRyaWVzKGF0dHJpYnV0ZXMpXG4gICAgICAgICAgICAubWFwKChba2V5LCB2YWx1ZV0pID0+ICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnID8ga2V5IDogdW5kZWZpbmVkKSlcbiAgICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbik7XG4gICAgICAgIHN1cGVyKGBJbnZhbGlkIHNlcmlhbGl6ZWQgdHJhbnNhY3Rpb24gb2YgdHlwZSBcIiR7dHlwZX1cIiB3YXMgcHJvdmlkZWQuYCwge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXG4gICAgICAgICAgICAgICAgYFNlcmlhbGl6ZWQgVHJhbnNhY3Rpb246IFwiJHtzZXJpYWxpemVkfVwiYCxcbiAgICAgICAgICAgICAgICBtaXNzaW5nLmxlbmd0aCA+IDAgPyBgTWlzc2luZyBBdHRyaWJ1dGVzOiAke21pc3Npbmcuam9pbignLCAnKX1gIDogJycsXG4gICAgICAgICAgICBdLmZpbHRlcihCb29sZWFuKSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdUcmFuc2FjdGlvbkVudmVsb3BlLkludmFsaWRTZXJpYWxpemVkRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3duIHdoZW4gYSB0aXAgaXMgaGlnaGVyIHRoYW4gYSBmZWUgY2FwLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHhFbnZlbG9wZUVpcDE1NTkgfSBmcm9tICdveCdcbiAqXG4gKiBUeEVudmVsb3BlRWlwMTU1OS5hc3NlcnQoe1xuICogICBjaGFpbklkOiAxLFxuICogICBtYXhGZWVQZXJHYXM6IDEwbixcbiAqICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IDExbixcbiAqIH0pXG4gKiAvLyBAZXJyb3I6IFRyYW5zYWN0aW9uRW52ZWxvcGUuVGlwQWJvdmVGZWVDYXBFcnJvcjogVGhlIHByb3ZpZGVkIHRpcCAoYG1heFByaW9yaXR5RmVlUGVyR2FzYCA9IDExIGd3ZWkpIGNhbm5vdCBiZSBoaWdoZXIgdGhhbiB0aGUgZmVlIGNhcCAoYG1heEZlZVBlckdhc2AgPSAxMCBnd2VpKS5cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgVGlwQWJvdmVGZWVDYXBFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgbWF4UHJpb3JpdHlGZWVQZXJHYXMsIG1heEZlZVBlckdhcywgfSA9IHt9KSB7XG4gICAgICAgIHN1cGVyKFtcbiAgICAgICAgICAgIGBUaGUgcHJvdmlkZWQgdGlwIChcXGBtYXhQcmlvcml0eUZlZVBlckdhc1xcYCR7bWF4UHJpb3JpdHlGZWVQZXJHYXNcbiAgICAgICAgICAgICAgICA/IGAgPSAke1ZhbHVlLmZvcm1hdEd3ZWkobWF4UHJpb3JpdHlGZWVQZXJHYXMpfSBnd2VpYFxuICAgICAgICAgICAgICAgIDogJyd9KSBjYW5ub3QgYmUgaGlnaGVyIHRoYW4gdGhlIGZlZSBjYXAgKFxcYG1heEZlZVBlckdhc1xcYCR7bWF4RmVlUGVyR2FzID8gYCA9ICR7VmFsdWUuZm9ybWF0R3dlaShtYXhGZWVQZXJHYXMpfSBnd2VpYCA6ICcnfSkuYCxcbiAgICAgICAgXS5qb2luKCdcXG4nKSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdUcmFuc2FjdGlvbkVudmVsb3BlLlRpcEFib3ZlRmVlQ2FwRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVR4RW52ZWxvcGUuanMubWFwIl0sIm5hbWVzIjpbIkVycm9ycyIsIlZhbHVlIiwiRmVlQ2FwVG9vSGlnaEVycm9yIiwiQmFzZUVycm9yIiwiY29uc3RydWN0b3IiLCJmZWVDYXAiLCJmb3JtYXRHd2VpIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJ2YWx1ZSIsIkdhc1ByaWNlVG9vSGlnaEVycm9yIiwiZ2FzUHJpY2UiLCJJbnZhbGlkQ2hhaW5JZEVycm9yIiwiY2hhaW5JZCIsIkludmFsaWRTZXJpYWxpemVkRXJyb3IiLCJhdHRyaWJ1dGVzIiwic2VyaWFsaXplZCIsInR5cGUiLCJtaXNzaW5nIiwiZW50cmllcyIsIm1hcCIsImtleSIsInVuZGVmaW5lZCIsImZpbHRlciIsIkJvb2xlYW4iLCJtZXRhTWVzc2FnZXMiLCJsZW5ndGgiLCJqb2luIiwiVGlwQWJvdmVGZWVDYXBFcnJvciIsIm1heFByaW9yaXR5RmVlUGVyR2FzIiwibWF4RmVlUGVyR2FzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/TxEnvelope.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Value.js":
/*!********************************************!*\
  !*** ./node_modules/ox/_esm/core/Value.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidDecimalNumberError: () => (/* binding */ InvalidDecimalNumberError),\n/* harmony export */   exponents: () => (/* binding */ exponents),\n/* harmony export */   format: () => (/* binding */ format),\n/* harmony export */   formatEther: () => (/* binding */ formatEther),\n/* harmony export */   formatGwei: () => (/* binding */ formatGwei),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromEther: () => (/* binding */ fromEther),\n/* harmony export */   fromGwei: () => (/* binding */ fromGwei)\n/* harmony export */ });\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n\n/** @see https://ethereum.github.io/yellowpaper/paper.pdf */ const exponents = {\n    wei: 0,\n    gwei: 9,\n    szabo: 12,\n    finney: 15,\n    ether: 18\n};\n/**\n * Formats a `bigint` Value to its string representation (divided by the given exponent).\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.format(420_000_000_000n, 9)\n * // @log: '420'\n * ```\n *\n * @param value - The `bigint` Value to format.\n * @param decimals - The exponent to divide the `bigint` Value by.\n * @returns The string representation of the Value.\n */ function format(value, decimals = 0) {\n    let display = value.toString();\n    const negative = display.startsWith(\"-\");\n    if (negative) display = display.slice(1);\n    display = display.padStart(decimals, \"0\");\n    let [integer, fraction] = [\n        display.slice(0, display.length - decimals),\n        display.slice(display.length - decimals)\n    ];\n    fraction = fraction.replace(/(0+)$/, \"\");\n    return `${negative ? \"-\" : \"\"}${integer || \"0\"}${fraction ? `.${fraction}` : \"\"}`;\n}\n/**\n * Formats a `bigint` Value (default: wei) to a string representation of Ether.\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.formatEther(1_000_000_000_000_000_000n)\n * // @log: '1'\n * ```\n *\n * @param wei - The Value to format.\n * @param unit - The unit to format the Value in. @default 'wei'.\n * @returns The Ether string representation of the Value.\n */ function formatEther(wei, unit = \"wei\") {\n    return format(wei, exponents.ether - exponents[unit]);\n}\n/**\n * Formats a `bigint` Value (default: wei) to a string representation of Gwei.\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.formatGwei(1_000_000_000n)\n * // @log: '1'\n * ```\n *\n * @param wei - The Value to format.\n * @param unit - The unit to format the Value in. @default 'wei'.\n * @returns The Gwei string representation of the Value.\n */ function formatGwei(wei, unit = \"wei\") {\n    return format(wei, exponents.gwei - exponents[unit]);\n}\n/**\n * Parses a `string` representation of a Value to `bigint` (multiplied by the given exponent).\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.from('420', 9)\n * // @log: 420000000000n\n * ```\n *\n * @param value - The string representation of the Value.\n * @param decimals - The exponent to multiply the Value by.\n * @returns The `bigint` representation of the Value.\n */ function from(value, decimals = 0) {\n    if (!/^(-?)([0-9]*)\\.?([0-9]*)$/.test(value)) throw new InvalidDecimalNumberError({\n        value\n    });\n    let [integer = \"\", fraction = \"0\"] = value.split(\".\");\n    const negative = integer.startsWith(\"-\");\n    if (negative) integer = integer.slice(1);\n    // trim trailing zeros.\n    fraction = fraction.replace(/(0+)$/, \"\");\n    // round off if the fraction is larger than the number of decimals.\n    if (decimals === 0) {\n        if (Math.round(Number(`.${fraction}`)) === 1) integer = `${BigInt(integer) + 1n}`;\n        fraction = \"\";\n    } else if (fraction.length > decimals) {\n        const [left, unit, right] = [\n            fraction.slice(0, decimals - 1),\n            fraction.slice(decimals - 1, decimals),\n            fraction.slice(decimals)\n        ];\n        const rounded = Math.round(Number(`${unit}.${right}`));\n        if (rounded > 9) fraction = `${BigInt(left) + BigInt(1)}0`.padStart(left.length + 1, \"0\");\n        else fraction = `${left}${rounded}`;\n        if (fraction.length > decimals) {\n            fraction = fraction.slice(1);\n            integer = `${BigInt(integer) + 1n}`;\n        }\n        fraction = fraction.slice(0, decimals);\n    } else {\n        fraction = fraction.padEnd(decimals, \"0\");\n    }\n    return BigInt(`${negative ? \"-\" : \"\"}${integer}${fraction}`);\n}\n/**\n * Parses a string representation of Ether to a `bigint` Value (default: wei).\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.fromEther('420')\n * // @log: 420000000000000000000n\n * ```\n *\n * @param ether - String representation of Ether.\n * @param unit - The unit to parse to. @default 'wei'.\n * @returns A `bigint` Value.\n */ function fromEther(ether, unit = \"wei\") {\n    return from(ether, exponents.ether - exponents[unit]);\n}\n/**\n * Parses a string representation of Gwei to a `bigint` Value (default: wei).\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.fromGwei('420')\n * // @log: 420000000000n\n * ```\n *\n * @param gwei - String representation of Gwei.\n * @param unit - The unit to parse to. @default 'wei'.\n * @returns A `bigint` Value.\n */ function fromGwei(gwei, unit = \"wei\") {\n    return from(gwei, exponents.gwei - exponents[unit]);\n}\n/**\n * Thrown when a value is not a valid decimal number.\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.fromEther('123.456.789')\n * // @error: Value.InvalidDecimalNumberError: Value `123.456.789` is not a valid decimal number.\n * ```\n */ class InvalidDecimalNumberError extends _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ value }){\n        super(`Value \\`${value}\\` is not a valid decimal number.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Value.InvalidDecimalNumberError\"\n        });\n    }\n} //# sourceMappingURL=Value.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1ZhbHVlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFzQztBQUN0QywwREFBMEQsR0FDbkQsTUFBTUMsWUFBWTtJQUNyQkMsS0FBSztJQUNMQyxNQUFNO0lBQ05DLE9BQU87SUFDUEMsUUFBUTtJQUNSQyxPQUFPO0FBQ1gsRUFBRTtBQUNGOzs7Ozs7Ozs7Ozs7OztDQWNDLEdBQ00sU0FBU0MsT0FBT0MsS0FBSyxFQUFFQyxXQUFXLENBQUM7SUFDdEMsSUFBSUMsVUFBVUYsTUFBTUcsUUFBUTtJQUM1QixNQUFNQyxXQUFXRixRQUFRRyxVQUFVLENBQUM7SUFDcEMsSUFBSUQsVUFDQUYsVUFBVUEsUUFBUUksS0FBSyxDQUFDO0lBQzVCSixVQUFVQSxRQUFRSyxRQUFRLENBQUNOLFVBQVU7SUFDckMsSUFBSSxDQUFDTyxTQUFTQyxTQUFTLEdBQUc7UUFDdEJQLFFBQVFJLEtBQUssQ0FBQyxHQUFHSixRQUFRUSxNQUFNLEdBQUdUO1FBQ2xDQyxRQUFRSSxLQUFLLENBQUNKLFFBQVFRLE1BQU0sR0FBR1Q7S0FDbEM7SUFDRFEsV0FBV0EsU0FBU0UsT0FBTyxDQUFDLFNBQVM7SUFDckMsT0FBTyxDQUFDLEVBQUVQLFdBQVcsTUFBTSxHQUFHLEVBQUVJLFdBQVcsSUFBSSxFQUFFQyxXQUFXLENBQUMsQ0FBQyxFQUFFQSxTQUFTLENBQUMsR0FBRyxHQUFHLENBQUM7QUFDckY7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Q0FjQyxHQUNNLFNBQVNHLFlBQVlsQixHQUFHLEVBQUVtQixPQUFPLEtBQUs7SUFDekMsT0FBT2QsT0FBT0wsS0FBS0QsVUFBVUssS0FBSyxHQUFHTCxTQUFTLENBQUNvQixLQUFLO0FBQ3hEO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0NBY0MsR0FDTSxTQUFTQyxXQUFXcEIsR0FBRyxFQUFFbUIsT0FBTyxLQUFLO0lBQ3hDLE9BQU9kLE9BQU9MLEtBQUtELFVBQVVFLElBQUksR0FBR0YsU0FBUyxDQUFDb0IsS0FBSztBQUN2RDtBQUNBOzs7Ozs7Ozs7Ozs7OztDQWNDLEdBQ00sU0FBU0UsS0FBS2YsS0FBSyxFQUFFQyxXQUFXLENBQUM7SUFDcEMsSUFBSSxDQUFDLDRCQUE0QmUsSUFBSSxDQUFDaEIsUUFDbEMsTUFBTSxJQUFJaUIsMEJBQTBCO1FBQUVqQjtJQUFNO0lBQ2hELElBQUksQ0FBQ1EsVUFBVSxFQUFFLEVBQUVDLFdBQVcsR0FBRyxDQUFDLEdBQUdULE1BQU1rQixLQUFLLENBQUM7SUFDakQsTUFBTWQsV0FBV0ksUUFBUUgsVUFBVSxDQUFDO0lBQ3BDLElBQUlELFVBQ0FJLFVBQVVBLFFBQVFGLEtBQUssQ0FBQztJQUM1Qix1QkFBdUI7SUFDdkJHLFdBQVdBLFNBQVNFLE9BQU8sQ0FBQyxTQUFTO0lBQ3JDLG1FQUFtRTtJQUNuRSxJQUFJVixhQUFhLEdBQUc7UUFDaEIsSUFBSWtCLEtBQUtDLEtBQUssQ0FBQ0MsT0FBTyxDQUFDLENBQUMsRUFBRVosU0FBUyxDQUFDLE9BQU8sR0FDdkNELFVBQVUsQ0FBQyxFQUFFYyxPQUFPZCxXQUFXLEVBQUUsQ0FBQyxDQUFDO1FBQ3ZDQyxXQUFXO0lBQ2YsT0FDSyxJQUFJQSxTQUFTQyxNQUFNLEdBQUdULFVBQVU7UUFDakMsTUFBTSxDQUFDc0IsTUFBTVYsTUFBTVcsTUFBTSxHQUFHO1lBQ3hCZixTQUFTSCxLQUFLLENBQUMsR0FBR0wsV0FBVztZQUM3QlEsU0FBU0gsS0FBSyxDQUFDTCxXQUFXLEdBQUdBO1lBQzdCUSxTQUFTSCxLQUFLLENBQUNMO1NBQ2xCO1FBQ0QsTUFBTXdCLFVBQVVOLEtBQUtDLEtBQUssQ0FBQ0MsT0FBTyxDQUFDLEVBQUVSLEtBQUssQ0FBQyxFQUFFVyxNQUFNLENBQUM7UUFDcEQsSUFBSUMsVUFBVSxHQUNWaEIsV0FBVyxDQUFDLEVBQUVhLE9BQU9DLFFBQVFELE9BQU8sR0FBRyxDQUFDLENBQUMsQ0FBQ2YsUUFBUSxDQUFDZ0IsS0FBS2IsTUFBTSxHQUFHLEdBQUc7YUFFcEVELFdBQVcsQ0FBQyxFQUFFYyxLQUFLLEVBQUVFLFFBQVEsQ0FBQztRQUNsQyxJQUFJaEIsU0FBU0MsTUFBTSxHQUFHVCxVQUFVO1lBQzVCUSxXQUFXQSxTQUFTSCxLQUFLLENBQUM7WUFDMUJFLFVBQVUsQ0FBQyxFQUFFYyxPQUFPZCxXQUFXLEVBQUUsQ0FBQyxDQUFDO1FBQ3ZDO1FBQ0FDLFdBQVdBLFNBQVNILEtBQUssQ0FBQyxHQUFHTDtJQUNqQyxPQUNLO1FBQ0RRLFdBQVdBLFNBQVNpQixNQUFNLENBQUN6QixVQUFVO0lBQ3pDO0lBQ0EsT0FBT3FCLE9BQU8sQ0FBQyxFQUFFbEIsV0FBVyxNQUFNLEdBQUcsRUFBRUksUUFBUSxFQUFFQyxTQUFTLENBQUM7QUFDL0Q7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Q0FjQyxHQUNNLFNBQVNrQixVQUFVN0IsS0FBSyxFQUFFZSxPQUFPLEtBQUs7SUFDekMsT0FBT0UsS0FBS2pCLE9BQU9MLFVBQVVLLEtBQUssR0FBR0wsU0FBUyxDQUFDb0IsS0FBSztBQUN4RDtBQUNBOzs7Ozs7Ozs7Ozs7OztDQWNDLEdBQ00sU0FBU2UsU0FBU2pDLElBQUksRUFBRWtCLE9BQU8sS0FBSztJQUN2QyxPQUFPRSxLQUFLcEIsTUFBTUYsVUFBVUUsSUFBSSxHQUFHRixTQUFTLENBQUNvQixLQUFLO0FBQ3REO0FBQ0E7Ozs7Ozs7Ozs7Q0FVQyxHQUNNLE1BQU1JLGtDQUFrQ3pCLGlEQUFnQjtJQUMzRHNDLFlBQVksRUFBRTlCLEtBQUssRUFBRSxDQUFFO1FBQ25CLEtBQUssQ0FBQyxDQUFDLFFBQVEsRUFBRUEsTUFBTSxpQ0FBaUMsQ0FBQztRQUN6RCtCLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsUUFBUTtZQUNoQ0MsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVm5DLE9BQU87UUFDWDtJQUNKO0FBQ0osRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGF3LXdvcmtzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9WYWx1ZS5qcz8wMWU4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEVycm9ycyBmcm9tICcuL0Vycm9ycy5qcyc7XG4vKiogQHNlZSBodHRwczovL2V0aGVyZXVtLmdpdGh1Yi5pby95ZWxsb3dwYXBlci9wYXBlci5wZGYgKi9cbmV4cG9ydCBjb25zdCBleHBvbmVudHMgPSB7XG4gICAgd2VpOiAwLFxuICAgIGd3ZWk6IDksXG4gICAgc3phYm86IDEyLFxuICAgIGZpbm5leTogMTUsXG4gICAgZXRoZXI6IDE4LFxufTtcbi8qKlxuICogRm9ybWF0cyBhIGBiaWdpbnRgIFZhbHVlIHRvIGl0cyBzdHJpbmcgcmVwcmVzZW50YXRpb24gKGRpdmlkZWQgYnkgdGhlIGdpdmVuIGV4cG9uZW50KS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogVmFsdWUuZm9ybWF0KDQyMF8wMDBfMDAwXzAwMG4sIDkpXG4gKiAvLyBAbG9nOiAnNDIwJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGBiaWdpbnRgIFZhbHVlIHRvIGZvcm1hdC5cbiAqIEBwYXJhbSBkZWNpbWFscyAtIFRoZSBleHBvbmVudCB0byBkaXZpZGUgdGhlIGBiaWdpbnRgIFZhbHVlIGJ5LlxuICogQHJldHVybnMgVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgVmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXQodmFsdWUsIGRlY2ltYWxzID0gMCkge1xuICAgIGxldCBkaXNwbGF5ID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICBjb25zdCBuZWdhdGl2ZSA9IGRpc3BsYXkuc3RhcnRzV2l0aCgnLScpO1xuICAgIGlmIChuZWdhdGl2ZSlcbiAgICAgICAgZGlzcGxheSA9IGRpc3BsYXkuc2xpY2UoMSk7XG4gICAgZGlzcGxheSA9IGRpc3BsYXkucGFkU3RhcnQoZGVjaW1hbHMsICcwJyk7XG4gICAgbGV0IFtpbnRlZ2VyLCBmcmFjdGlvbl0gPSBbXG4gICAgICAgIGRpc3BsYXkuc2xpY2UoMCwgZGlzcGxheS5sZW5ndGggLSBkZWNpbWFscyksXG4gICAgICAgIGRpc3BsYXkuc2xpY2UoZGlzcGxheS5sZW5ndGggLSBkZWNpbWFscyksXG4gICAgXTtcbiAgICBmcmFjdGlvbiA9IGZyYWN0aW9uLnJlcGxhY2UoLygwKykkLywgJycpO1xuICAgIHJldHVybiBgJHtuZWdhdGl2ZSA/ICctJyA6ICcnfSR7aW50ZWdlciB8fCAnMCd9JHtmcmFjdGlvbiA/IGAuJHtmcmFjdGlvbn1gIDogJyd9YDtcbn1cbi8qKlxuICogRm9ybWF0cyBhIGBiaWdpbnRgIFZhbHVlIChkZWZhdWx0OiB3ZWkpIHRvIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIEV0aGVyLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiBWYWx1ZS5mb3JtYXRFdGhlcigxXzAwMF8wMDBfMDAwXzAwMF8wMDBfMDAwbilcbiAqIC8vIEBsb2c6ICcxJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIHdlaSAtIFRoZSBWYWx1ZSB0byBmb3JtYXQuXG4gKiBAcGFyYW0gdW5pdCAtIFRoZSB1bml0IHRvIGZvcm1hdCB0aGUgVmFsdWUgaW4uIEBkZWZhdWx0ICd3ZWknLlxuICogQHJldHVybnMgVGhlIEV0aGVyIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgVmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRFdGhlcih3ZWksIHVuaXQgPSAnd2VpJykge1xuICAgIHJldHVybiBmb3JtYXQod2VpLCBleHBvbmVudHMuZXRoZXIgLSBleHBvbmVudHNbdW5pdF0pO1xufVxuLyoqXG4gKiBGb3JtYXRzIGEgYGJpZ2ludGAgVmFsdWUgKGRlZmF1bHQ6IHdlaSkgdG8gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgR3dlaS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogVmFsdWUuZm9ybWF0R3dlaSgxXzAwMF8wMDBfMDAwbilcbiAqIC8vIEBsb2c6ICcxJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIHdlaSAtIFRoZSBWYWx1ZSB0byBmb3JtYXQuXG4gKiBAcGFyYW0gdW5pdCAtIFRoZSB1bml0IHRvIGZvcm1hdCB0aGUgVmFsdWUgaW4uIEBkZWZhdWx0ICd3ZWknLlxuICogQHJldHVybnMgVGhlIEd3ZWkgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBWYWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdEd3ZWkod2VpLCB1bml0ID0gJ3dlaScpIHtcbiAgICByZXR1cm4gZm9ybWF0KHdlaSwgZXhwb25lbnRzLmd3ZWkgLSBleHBvbmVudHNbdW5pdF0pO1xufVxuLyoqXG4gKiBQYXJzZXMgYSBgc3RyaW5nYCByZXByZXNlbnRhdGlvbiBvZiBhIFZhbHVlIHRvIGBiaWdpbnRgIChtdWx0aXBsaWVkIGJ5IHRoZSBnaXZlbiBleHBvbmVudCkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBWYWx1ZSB9IGZyb20gJ294J1xuICpcbiAqIFZhbHVlLmZyb20oJzQyMCcsIDkpXG4gKiAvLyBAbG9nOiA0MjAwMDAwMDAwMDBuXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBWYWx1ZS5cbiAqIEBwYXJhbSBkZWNpbWFscyAtIFRoZSBleHBvbmVudCB0byBtdWx0aXBseSB0aGUgVmFsdWUgYnkuXG4gKiBAcmV0dXJucyBUaGUgYGJpZ2ludGAgcmVwcmVzZW50YXRpb24gb2YgdGhlIFZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbSh2YWx1ZSwgZGVjaW1hbHMgPSAwKSB7XG4gICAgaWYgKCEvXigtPykoWzAtOV0qKVxcLj8oWzAtOV0qKSQvLnRlc3QodmFsdWUpKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZERlY2ltYWxOdW1iZXJFcnJvcih7IHZhbHVlIH0pO1xuICAgIGxldCBbaW50ZWdlciA9ICcnLCBmcmFjdGlvbiA9ICcwJ10gPSB2YWx1ZS5zcGxpdCgnLicpO1xuICAgIGNvbnN0IG5lZ2F0aXZlID0gaW50ZWdlci5zdGFydHNXaXRoKCctJyk7XG4gICAgaWYgKG5lZ2F0aXZlKVxuICAgICAgICBpbnRlZ2VyID0gaW50ZWdlci5zbGljZSgxKTtcbiAgICAvLyB0cmltIHRyYWlsaW5nIHplcm9zLlxuICAgIGZyYWN0aW9uID0gZnJhY3Rpb24ucmVwbGFjZSgvKDArKSQvLCAnJyk7XG4gICAgLy8gcm91bmQgb2ZmIGlmIHRoZSBmcmFjdGlvbiBpcyBsYXJnZXIgdGhhbiB0aGUgbnVtYmVyIG9mIGRlY2ltYWxzLlxuICAgIGlmIChkZWNpbWFscyA9PT0gMCkge1xuICAgICAgICBpZiAoTWF0aC5yb3VuZChOdW1iZXIoYC4ke2ZyYWN0aW9ufWApKSA9PT0gMSlcbiAgICAgICAgICAgIGludGVnZXIgPSBgJHtCaWdJbnQoaW50ZWdlcikgKyAxbn1gO1xuICAgICAgICBmcmFjdGlvbiA9ICcnO1xuICAgIH1cbiAgICBlbHNlIGlmIChmcmFjdGlvbi5sZW5ndGggPiBkZWNpbWFscykge1xuICAgICAgICBjb25zdCBbbGVmdCwgdW5pdCwgcmlnaHRdID0gW1xuICAgICAgICAgICAgZnJhY3Rpb24uc2xpY2UoMCwgZGVjaW1hbHMgLSAxKSxcbiAgICAgICAgICAgIGZyYWN0aW9uLnNsaWNlKGRlY2ltYWxzIC0gMSwgZGVjaW1hbHMpLFxuICAgICAgICAgICAgZnJhY3Rpb24uc2xpY2UoZGVjaW1hbHMpLFxuICAgICAgICBdO1xuICAgICAgICBjb25zdCByb3VuZGVkID0gTWF0aC5yb3VuZChOdW1iZXIoYCR7dW5pdH0uJHtyaWdodH1gKSk7XG4gICAgICAgIGlmIChyb3VuZGVkID4gOSlcbiAgICAgICAgICAgIGZyYWN0aW9uID0gYCR7QmlnSW50KGxlZnQpICsgQmlnSW50KDEpfTBgLnBhZFN0YXJ0KGxlZnQubGVuZ3RoICsgMSwgJzAnKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgZnJhY3Rpb24gPSBgJHtsZWZ0fSR7cm91bmRlZH1gO1xuICAgICAgICBpZiAoZnJhY3Rpb24ubGVuZ3RoID4gZGVjaW1hbHMpIHtcbiAgICAgICAgICAgIGZyYWN0aW9uID0gZnJhY3Rpb24uc2xpY2UoMSk7XG4gICAgICAgICAgICBpbnRlZ2VyID0gYCR7QmlnSW50KGludGVnZXIpICsgMW59YDtcbiAgICAgICAgfVxuICAgICAgICBmcmFjdGlvbiA9IGZyYWN0aW9uLnNsaWNlKDAsIGRlY2ltYWxzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZyYWN0aW9uID0gZnJhY3Rpb24ucGFkRW5kKGRlY2ltYWxzLCAnMCcpO1xuICAgIH1cbiAgICByZXR1cm4gQmlnSW50KGAke25lZ2F0aXZlID8gJy0nIDogJyd9JHtpbnRlZ2VyfSR7ZnJhY3Rpb259YCk7XG59XG4vKipcbiAqIFBhcnNlcyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBFdGhlciB0byBhIGBiaWdpbnRgIFZhbHVlIChkZWZhdWx0OiB3ZWkpLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiBWYWx1ZS5mcm9tRXRoZXIoJzQyMCcpXG4gKiAvLyBAbG9nOiA0MjAwMDAwMDAwMDAwMDAwMDAwMDBuXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZXRoZXIgLSBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgRXRoZXIuXG4gKiBAcGFyYW0gdW5pdCAtIFRoZSB1bml0IHRvIHBhcnNlIHRvLiBAZGVmYXVsdCAnd2VpJy5cbiAqIEByZXR1cm5zIEEgYGJpZ2ludGAgVmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tRXRoZXIoZXRoZXIsIHVuaXQgPSAnd2VpJykge1xuICAgIHJldHVybiBmcm9tKGV0aGVyLCBleHBvbmVudHMuZXRoZXIgLSBleHBvbmVudHNbdW5pdF0pO1xufVxuLyoqXG4gKiBQYXJzZXMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgR3dlaSB0byBhIGBiaWdpbnRgIFZhbHVlIChkZWZhdWx0OiB3ZWkpLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiBWYWx1ZS5mcm9tR3dlaSgnNDIwJylcbiAqIC8vIEBsb2c6IDQyMDAwMDAwMDAwMG5cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBnd2VpIC0gU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIEd3ZWkuXG4gKiBAcGFyYW0gdW5pdCAtIFRoZSB1bml0IHRvIHBhcnNlIHRvLiBAZGVmYXVsdCAnd2VpJy5cbiAqIEByZXR1cm5zIEEgYGJpZ2ludGAgVmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tR3dlaShnd2VpLCB1bml0ID0gJ3dlaScpIHtcbiAgICByZXR1cm4gZnJvbShnd2VpLCBleHBvbmVudHMuZ3dlaSAtIGV4cG9uZW50c1t1bml0XSk7XG59XG4vKipcbiAqIFRocm93biB3aGVuIGEgdmFsdWUgaXMgbm90IGEgdmFsaWQgZGVjaW1hbCBudW1iZXIuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBWYWx1ZSB9IGZyb20gJ294J1xuICpcbiAqIFZhbHVlLmZyb21FdGhlcignMTIzLjQ1Ni43ODknKVxuICogLy8gQGVycm9yOiBWYWx1ZS5JbnZhbGlkRGVjaW1hbE51bWJlckVycm9yOiBWYWx1ZSBgMTIzLjQ1Ni43ODlgIGlzIG5vdCBhIHZhbGlkIGRlY2ltYWwgbnVtYmVyLlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkRGVjaW1hbE51bWJlckVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyB2YWx1ZSB9KSB7XG4gICAgICAgIHN1cGVyKGBWYWx1ZSBcXGAke3ZhbHVlfVxcYCBpcyBub3QgYSB2YWxpZCBkZWNpbWFsIG51bWJlci5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1ZhbHVlLkludmFsaWREZWNpbWFsTnVtYmVyRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVZhbHVlLmpzLm1hcCJdLCJuYW1lcyI6WyJFcnJvcnMiLCJleHBvbmVudHMiLCJ3ZWkiLCJnd2VpIiwic3phYm8iLCJmaW5uZXkiLCJldGhlciIsImZvcm1hdCIsInZhbHVlIiwiZGVjaW1hbHMiLCJkaXNwbGF5IiwidG9TdHJpbmciLCJuZWdhdGl2ZSIsInN0YXJ0c1dpdGgiLCJzbGljZSIsInBhZFN0YXJ0IiwiaW50ZWdlciIsImZyYWN0aW9uIiwibGVuZ3RoIiwicmVwbGFjZSIsImZvcm1hdEV0aGVyIiwidW5pdCIsImZvcm1hdEd3ZWkiLCJmcm9tIiwidGVzdCIsIkludmFsaWREZWNpbWFsTnVtYmVyRXJyb3IiLCJzcGxpdCIsIk1hdGgiLCJyb3VuZCIsIk51bWJlciIsIkJpZ0ludCIsImxlZnQiLCJyaWdodCIsInJvdW5kZWQiLCJwYWRFbmQiLCJmcm9tRXRoZXIiLCJmcm9tR3dlaSIsIkJhc2VFcnJvciIsImNvbnN0cnVjdG9yIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Value.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/WebAuthnP256.js":
/*!***************************************************!*\
  !*** ./node_modules/ox/_esm/core/WebAuthnP256.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CredentialCreationFailedError: () => (/* binding */ CredentialCreationFailedError),\n/* harmony export */   CredentialRequestFailedError: () => (/* binding */ CredentialRequestFailedError),\n/* harmony export */   createChallenge: () => (/* binding */ createChallenge),\n/* harmony export */   createCredential: () => (/* binding */ createCredential),\n/* harmony export */   getAuthenticatorData: () => (/* binding */ getAuthenticatorData),\n/* harmony export */   getClientDataJSON: () => (/* binding */ getClientDataJSON),\n/* harmony export */   getCredentialCreationOptions: () => (/* binding */ getCredentialCreationOptions),\n/* harmony export */   getCredentialRequestOptions: () => (/* binding */ getCredentialRequestOptions),\n/* harmony export */   getSignPayload: () => (/* binding */ getSignPayload),\n/* harmony export */   sign: () => (/* binding */ sign),\n/* harmony export */   verify: () => (/* binding */ verify)\n/* harmony export */ });\n/* harmony import */ var _Base64_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Base64.js */ \"(ssr)/./node_modules/ox/_esm/core/Base64.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hash.js */ \"(ssr)/./node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _internal_webauthn_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/webauthn.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/webauthn.js\");\n/* harmony import */ var _P256_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./P256.js */ \"(ssr)/./node_modules/ox/_esm/core/P256.js\");\n\n\n\n\n\n\n\nconst createChallenge = Uint8Array.from([\n    105,\n    171,\n    180,\n    181,\n    160,\n    222,\n    75,\n    198,\n    42,\n    42,\n    32,\n    31,\n    141,\n    37,\n    186,\n    233\n]);\n/**\n * Creates a new WebAuthn P256 Credential, which can be stored and later used for signing.\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const credential = await WebAuthnP256.createCredential({ name: 'Example' }) // [!code focus]\n * // @log: {\n * // @log:   id: 'oZ48...',\n * // @log:   publicKey: { x: 51421...5123n, y: 12345...6789n },\n * // @log:   raw: PublicKeyCredential {},\n * // @log: }\n *\n * const { metadata, signature } = await WebAuthnP256.sign({\n *   credentialId: credential.id,\n *   challenge: '0xdeadbeef',\n * })\n * ```\n *\n * @param options - Credential creation options.\n * @returns A WebAuthn P256 credential.\n */ async function createCredential(options) {\n    const { createFn = window.navigator.credentials.create.bind(window.navigator.credentials), ...rest } = options;\n    const creationOptions = getCredentialCreationOptions(rest);\n    try {\n        const credential = await createFn(creationOptions);\n        if (!credential) throw new CredentialCreationFailedError();\n        const response = credential.response;\n        const publicKey = await _internal_webauthn_js__WEBPACK_IMPORTED_MODULE_0__.parseCredentialPublicKey(response);\n        return {\n            id: credential.id,\n            publicKey,\n            raw: credential\n        };\n    } catch (error) {\n        throw new CredentialCreationFailedError({\n            cause: error\n        });\n    }\n}\n/**\n * Gets the authenticator data which contains information about the\n * processing of an authenticator request (ie. from `WebAuthnP256.sign`).\n *\n * :::warning\n *\n * This function is mainly for testing purposes or for manually constructing\n * autenticator data. In most cases you will not need this function.\n * `authenticatorData` is typically returned as part of the\n * {@link ox#WebAuthnP256.(sign:function)} response (ie. an authenticator response).\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const authenticatorData = WebAuthnP256.getAuthenticatorData({\n *   rpId: 'example.com',\n *   signCount: 420,\n * })\n * // @log: \"0xa379a6f6eeafb9a55e378c118034e2751e682fab9f2d30ab13d2125586ce194705000001a4\"\n * ```\n *\n * @param options - Options to construct the authenticator data.\n * @returns The authenticator data.\n */ function getAuthenticatorData(options = {}) {\n    const { flag = 5, rpId = window.location.hostname, signCount = 0 } = options;\n    const rpIdHash = _Hash_js__WEBPACK_IMPORTED_MODULE_1__.sha256(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromString(rpId));\n    const flag_bytes = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(flag, {\n        size: 1\n    });\n    const signCount_bytes = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(signCount, {\n        size: 4\n    });\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(rpIdHash, flag_bytes, signCount_bytes);\n}\n/**\n * Constructs the Client Data in stringified JSON format which represents client data that\n * was passed to `credentials.get()` in {@link ox#WebAuthnP256.(sign:function)}.\n *\n * :::warning\n *\n * This function is mainly for testing purposes or for manually constructing\n * client data. In most cases you will not need this function.\n * `clientDataJSON` is typically returned as part of the\n * {@link ox#WebAuthnP256.(sign:function)} response (ie. an authenticator response).\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const clientDataJSON = WebAuthnP256.getClientDataJSON({\n *   challenge: '0xdeadbeef',\n *   origin: 'https://example.com',\n * })\n * // @log: \"{\"type\":\"webauthn.get\",\"challenge\":\"3q2-7w\",\"origin\":\"https://example.com\",\"crossOrigin\":false}\"\n * ```\n *\n * @param options - Options to construct the client data.\n * @returns The client data.\n */ function getClientDataJSON(options) {\n    const { challenge, crossOrigin = false, extraClientData, origin = window.location.origin } = options;\n    return JSON.stringify({\n        type: \"webauthn.get\",\n        challenge: _Base64_js__WEBPACK_IMPORTED_MODULE_3__.fromHex(challenge, {\n            url: true,\n            pad: false\n        }),\n        origin,\n        crossOrigin,\n        ...extraClientData\n    });\n}\n/**\n * Returns the creation options for a P256 WebAuthn Credential to be used with\n * the Web Authentication API.\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const options = WebAuthnP256.getCredentialCreationOptions({ name: 'Example' })\n *\n * const credential = await window.navigator.credentials.create(options)\n * ```\n *\n * @param options - Options.\n * @returns The credential creation options.\n */ function getCredentialCreationOptions(options) {\n    const { attestation = \"none\", authenticatorSelection = {\n        residentKey: \"preferred\",\n        requireResidentKey: false,\n        userVerification: \"required\"\n    }, challenge = createChallenge, excludeCredentialIds, extensions, name: name_, rp = {\n        id: window.location.hostname,\n        name: window.document.title\n    }, user } = options;\n    const name = user?.name ?? name_;\n    return {\n        publicKey: {\n            attestation,\n            authenticatorSelection,\n            challenge: typeof challenge === \"string\" ? _Bytes_js__WEBPACK_IMPORTED_MODULE_4__.fromHex(challenge) : challenge,\n            ...excludeCredentialIds ? {\n                excludeCredentials: excludeCredentialIds?.map((id)=>({\n                        id: _Base64_js__WEBPACK_IMPORTED_MODULE_3__.toBytes(id),\n                        type: \"public-key\"\n                    }))\n            } : {},\n            pubKeyCredParams: [\n                {\n                    type: \"public-key\",\n                    alg: -7\n                }\n            ],\n            ...extensions && {\n                extensions\n            },\n            rp,\n            user: {\n                id: user?.id ?? _Hash_js__WEBPACK_IMPORTED_MODULE_1__.keccak256(_Bytes_js__WEBPACK_IMPORTED_MODULE_4__.fromString(name), {\n                    as: \"Bytes\"\n                }),\n                name,\n                displayName: user?.displayName ?? name\n            }\n        }\n    };\n}\n/**\n * Returns the request options to sign a challenge with the Web Authentication API.\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const options = WebAuthnP256.getCredentialRequestOptions({\n *   challenge: '0xdeadbeef',\n * })\n *\n * const credential = await window.navigator.credentials.get(options)\n * ```\n *\n * @param options - Options.\n * @returns The credential request options.\n */ function getCredentialRequestOptions(options) {\n    const { credentialId, challenge, extensions, rpId = window.location.hostname, userVerification = \"required\" } = options;\n    return {\n        publicKey: {\n            ...credentialId ? {\n                allowCredentials: Array.isArray(credentialId) ? credentialId.map((id)=>({\n                        id: _Base64_js__WEBPACK_IMPORTED_MODULE_3__.toBytes(id),\n                        type: \"public-key\"\n                    })) : [\n                    {\n                        id: _Base64_js__WEBPACK_IMPORTED_MODULE_3__.toBytes(credentialId),\n                        type: \"public-key\"\n                    }\n                ]\n            } : {},\n            challenge: _Bytes_js__WEBPACK_IMPORTED_MODULE_4__.fromHex(challenge),\n            ...extensions && {\n                extensions\n            },\n            rpId,\n            userVerification\n        }\n    };\n}\n/**\n * Constructs the final digest that was signed and computed by the authenticator. This payload includes\n * the cryptographic `challenge`, as well as authenticator metadata (`authenticatorData` + `clientDataJSON`).\n * This value can be also used with raw P256 verification (such as {@link ox#P256.(verify:function)} or\n * {@link ox#WebCryptoP256.(verify:function)}).\n *\n * :::warning\n *\n * This function is mainly for testing purposes or for manually constructing\n * signing payloads. In most cases you will not need this function and\n * instead use {@link ox#WebAuthnP256.(sign:function)}.\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256, WebCryptoP256 } from 'ox'\n *\n * const { metadata, payload } = WebAuthnP256.getSignPayload({ // [!code focus]\n *   challenge: '0xdeadbeef', // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   metadata: {\n * // @log:     authenticatorData: \"0x49960de5880e8c687434170f6476605b8fe4aeb9a28632c7995cf3ba831d97630500000000\",\n * // @log:     challengeIndex: 23,\n * // @log:     clientDataJSON: \"{\"type\":\"webauthn.get\",\"challenge\":\"9jEFijuhEWrM4SOW-tChJbUEHEP44VcjcJ-Bqo1fTM8\",\"origin\":\"http://localhost:5173\",\"crossOrigin\":false}\",\n * // @log:     typeIndex: 1,\n * // @log:     userVerificationRequired: true,\n * // @log:   },\n * // @log:   payload: \"0x49960de5880e8c687434170f6476605b8fe4aeb9a28632c7995cf3ba831d9763050000000045086dcb06a5f234db625bcdc94e657f86b76b6fd3eb9c30543eabc1e577a4b0\",\n * // @log: }\n *\n * const { publicKey, privateKey } = await WebCryptoP256.createKeyPair()\n *\n * const signature = await WebCryptoP256.sign({\n *   payload,\n *   privateKey,\n * })\n * ```\n *\n * @param options - Options to construct the signing payload.\n * @returns The signing payload.\n */ function getSignPayload(options) {\n    const { challenge, crossOrigin, extraClientData, flag, origin, rpId, signCount, userVerification = \"required\" } = options;\n    const authenticatorData = getAuthenticatorData({\n        flag,\n        rpId,\n        signCount\n    });\n    const clientDataJSON = getClientDataJSON({\n        challenge,\n        crossOrigin,\n        extraClientData,\n        origin\n    });\n    const clientDataJSONHash = _Hash_js__WEBPACK_IMPORTED_MODULE_1__.sha256(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromString(clientDataJSON));\n    const challengeIndex = clientDataJSON.indexOf('\"challenge\"');\n    const typeIndex = clientDataJSON.indexOf('\"type\"');\n    const metadata = {\n        authenticatorData,\n        clientDataJSON,\n        challengeIndex,\n        typeIndex,\n        userVerificationRequired: userVerification === \"required\"\n    };\n    const payload = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(authenticatorData, clientDataJSONHash);\n    return {\n        metadata,\n        payload\n    };\n}\n/**\n * Signs a challenge using a stored WebAuthn P256 Credential. If no Credential is provided,\n * a prompt will be displayed for the user to select an existing Credential\n * that was previously registered.\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const credential = await WebAuthnP256.createCredential({\n *   name: 'Example',\n * })\n *\n * const { metadata, signature } = await WebAuthnP256.sign({ // [!code focus]\n *   credentialId: credential.id, // [!code focus]\n *   challenge: '0xdeadbeef', // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   metadata: {\n * // @log:     authenticatorData: '0x49960de5880e8c687434170f6476605b8fe4aeb9a28632c7995cf3ba831d97630500000000',\n * // @log:     clientDataJSON: '{\"type\":\"webauthn.get\",\"challenge\":\"9jEFijuhEWrM4SOW-tChJbUEHEP44VcjcJ-Bqo1fTM8\",\"origin\":\"http://localhost:5173\",\"crossOrigin\":false}',\n * // @log:     challengeIndex: 23,\n * // @log:     typeIndex: 1,\n * // @log:     userVerificationRequired: true,\n * // @log:   },\n * // @log:   signature: { r: 51231...4215n, s: 12345...6789n },\n * // @log: }\n * ```\n *\n * @param options - Options.\n * @returns The signature.\n */ async function sign(options) {\n    const { getFn = window.navigator.credentials.get.bind(window.navigator.credentials), ...rest } = options;\n    const requestOptions = getCredentialRequestOptions(rest);\n    try {\n        const credential = await getFn(requestOptions);\n        if (!credential) throw new CredentialRequestFailedError();\n        const response = credential.response;\n        const clientDataJSON = String.fromCharCode(...new Uint8Array(response.clientDataJSON));\n        const challengeIndex = clientDataJSON.indexOf('\"challenge\"');\n        const typeIndex = clientDataJSON.indexOf('\"type\"');\n        const signature = _internal_webauthn_js__WEBPACK_IMPORTED_MODULE_0__.parseAsn1Signature(new Uint8Array(response.signature));\n        return {\n            metadata: {\n                authenticatorData: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(new Uint8Array(response.authenticatorData)),\n                clientDataJSON,\n                challengeIndex,\n                typeIndex,\n                userVerificationRequired: requestOptions.publicKey.userVerification === \"required\"\n            },\n            signature,\n            raw: credential\n        };\n    } catch (error) {\n        throw new CredentialRequestFailedError({\n            cause: error\n        });\n    }\n}\n/**\n * Verifies a signature using the Credential's public key and the challenge which was signed.\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const credential = await WebAuthnP256.createCredential({\n *   name: 'Example',\n * })\n *\n * const { metadata, signature } = await WebAuthnP256.sign({\n *   credentialId: credential.id,\n *   challenge: '0xdeadbeef',\n * })\n *\n * const result = await WebAuthnP256.verify({ // [!code focus]\n *   metadata, // [!code focus]\n *   challenge: '0xdeadbeef', // [!code focus]\n *   publicKey: credential.publicKey, // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: true\n * ```\n *\n * @param options - Options.\n * @returns Whether the signature is valid.\n */ function verify(options) {\n    const { challenge, hash = true, metadata, publicKey, signature } = options;\n    const { authenticatorData, challengeIndex, clientDataJSON, typeIndex, userVerificationRequired } = metadata;\n    const authenticatorDataBytes = _Bytes_js__WEBPACK_IMPORTED_MODULE_4__.fromHex(authenticatorData);\n    // Check length of `authenticatorData`.\n    if (authenticatorDataBytes.length < 37) return false;\n    const flag = authenticatorDataBytes[32];\n    // Verify that the UP bit of the flags in authData is set.\n    if ((flag & 0x01) !== 0x01) return false;\n    // If user verification was determined to be required, verify that\n    // the UV bit of the flags in authData is set. Otherwise, ignore the\n    // value of the UV flag.\n    if (userVerificationRequired && (flag & 0x04) !== 0x04) return false;\n    // If the BE bit of the flags in authData is not set, verify that\n    // the BS bit is not set.\n    if ((flag & 0x08) !== 0x08 && (flag & 0x10) === 0x10) return false;\n    // Check that response is for an authentication assertion (if typeIndex is provided)\n    if (typeIndex !== undefined) {\n        const type = '\"type\":\"webauthn.get\"';\n        if (type !== clientDataJSON.slice(Number(typeIndex), type.length + 1)) return false;\n    }\n    // Extract and validate the challenge from clientDataJSON\n    const challengeMatch = challengeIndex !== undefined ? clientDataJSON.slice(Number(challengeIndex)).match(/^\"challenge\":\"(.*?)\"/) : clientDataJSON.match(/\"challenge\":\"(.*?)\"/);\n    if (!challengeMatch) return false;\n    // Validate the challenge in the clientDataJSON.\n    const [_, challenge_extracted] = challengeMatch;\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(_Base64_js__WEBPACK_IMPORTED_MODULE_3__.toBytes(challenge_extracted)) !== challenge) return false;\n    const clientDataJSONHash = _Hash_js__WEBPACK_IMPORTED_MODULE_1__.sha256(_Bytes_js__WEBPACK_IMPORTED_MODULE_4__.fromString(clientDataJSON), {\n        as: \"Bytes\"\n    });\n    const payload = _Bytes_js__WEBPACK_IMPORTED_MODULE_4__.concat(authenticatorDataBytes, clientDataJSONHash);\n    return _P256_js__WEBPACK_IMPORTED_MODULE_5__.verify({\n        hash,\n        payload,\n        publicKey,\n        signature\n    });\n}\n/** Thrown when a WebAuthn P256 credential creation fails. */ class CredentialCreationFailedError extends _Errors_js__WEBPACK_IMPORTED_MODULE_6__.BaseError {\n    constructor({ cause } = {}){\n        super(\"Failed to create credential.\", {\n            cause\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"WebAuthnP256.CredentialCreationFailedError\"\n        });\n    }\n}\n/** Thrown when a WebAuthn P256 credential request fails. */ class CredentialRequestFailedError extends _Errors_js__WEBPACK_IMPORTED_MODULE_6__.BaseError {\n    constructor({ cause } = {}){\n        super(\"Failed to request credential.\", {\n            cause\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"WebAuthnP256.CredentialRequestFailedError\"\n        });\n    }\n} //# sourceMappingURL=WebAuthnP256.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1dlYkF1dGhuUDI1Ni5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBc0M7QUFDRjtBQUNFO0FBQ0o7QUFDRjtBQUNtQjtBQUNqQjtBQUMzQixNQUFNTyxrQkFBa0JDLFdBQVdDLElBQUksQ0FBQztJQUMzQztJQUFLO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFJO0lBQUs7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFLO0lBQUk7SUFBSztDQUN4RSxFQUFFO0FBQ0g7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FzQkMsR0FDTSxlQUFlQyxpQkFBaUJDLE9BQU87SUFDMUMsTUFBTSxFQUFFQyxXQUFXQyxPQUFPQyxTQUFTLENBQUNDLFdBQVcsQ0FBQ0MsTUFBTSxDQUFDQyxJQUFJLENBQUNKLE9BQU9DLFNBQVMsQ0FBQ0MsV0FBVyxDQUFDLEVBQUUsR0FBR0csTUFBTSxHQUFHUDtJQUN2RyxNQUFNUSxrQkFBa0JDLDZCQUE2QkY7SUFDckQsSUFBSTtRQUNBLE1BQU1HLGFBQWMsTUFBTVQsU0FBU087UUFDbkMsSUFBSSxDQUFDRSxZQUNELE1BQU0sSUFBSUM7UUFDZCxNQUFNQyxXQUFXRixXQUFXRSxRQUFRO1FBQ3BDLE1BQU1DLFlBQVksTUFBTW5CLDJFQUFpQyxDQUFDa0I7UUFDMUQsT0FBTztZQUNIRyxJQUFJTCxXQUFXSyxFQUFFO1lBQ2pCRjtZQUNBRyxLQUFLTjtRQUNUO0lBQ0osRUFDQSxPQUFPTyxPQUFPO1FBQ1YsTUFBTSxJQUFJTiw4QkFBOEI7WUFDcENPLE9BQU9EO1FBQ1g7SUFDSjtBQUNKO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBMEJDLEdBQ00sU0FBU0UscUJBQXFCbkIsVUFBVSxDQUFDLENBQUM7SUFDN0MsTUFBTSxFQUFFb0IsT0FBTyxDQUFDLEVBQUVDLE9BQU9uQixPQUFPb0IsUUFBUSxDQUFDQyxRQUFRLEVBQUVDLFlBQVksQ0FBQyxFQUFF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QU87UUFDWDtJQUNKO0FBQ0o7QUFDQSwwREFBMEQsR0FDbkQsTUFBTXhCLHFDQUFxQzdGLGlEQUFnQjtJQUM5RCtHLFlBQVksRUFBRXBGLEtBQUssRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFFO1FBQ3hCLEtBQUssQ0FBQyxpQ0FBaUM7WUFDbkNBO1FBQ0o7UUFDQXFGLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsUUFBUTtZQUNoQ0MsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVkMsT0FBTztRQUNYO0lBQ0o7QUFDSixFQUNBLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsYXctd29ya3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1dlYkF1dGhuUDI1Ni5qcz9jYjAzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEJhc2U2NCBmcm9tICcuL0Jhc2U2NC5qcyc7XG5pbXBvcnQgKiBhcyBCeXRlcyBmcm9tICcuL0J5dGVzLmpzJztcbmltcG9ydCAqIGFzIEVycm9ycyBmcm9tICcuL0Vycm9ycy5qcyc7XG5pbXBvcnQgKiBhcyBIYXNoIGZyb20gJy4vSGFzaC5qcyc7XG5pbXBvcnQgKiBhcyBIZXggZnJvbSAnLi9IZXguanMnO1xuaW1wb3J0ICogYXMgaW50ZXJuYWwgZnJvbSAnLi9pbnRlcm5hbC93ZWJhdXRobi5qcyc7XG5pbXBvcnQgKiBhcyBQMjU2IGZyb20gJy4vUDI1Ni5qcyc7XG5leHBvcnQgY29uc3QgY3JlYXRlQ2hhbGxlbmdlID0gVWludDhBcnJheS5mcm9tKFtcbiAgICAxMDUsIDE3MSwgMTgwLCAxODEsIDE2MCwgMjIyLCA3NSwgMTk4LCA0MiwgNDIsIDMyLCAzMSwgMTQxLCAzNywgMTg2LCAyMzMsXG5dKTtcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBXZWJBdXRobiBQMjU2IENyZWRlbnRpYWwsIHdoaWNoIGNhbiBiZSBzdG9yZWQgYW5kIGxhdGVyIHVzZWQgZm9yIHNpZ25pbmcuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBXZWJBdXRoblAyNTYgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBjcmVkZW50aWFsID0gYXdhaXQgV2ViQXV0aG5QMjU2LmNyZWF0ZUNyZWRlbnRpYWwoeyBuYW1lOiAnRXhhbXBsZScgfSkgLy8gWyFjb2RlIGZvY3VzXVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICBpZDogJ29aNDguLi4nLFxuICogLy8gQGxvZzogICBwdWJsaWNLZXk6IHsgeDogNTE0MjEuLi41MTIzbiwgeTogMTIzNDUuLi42Nzg5biB9LFxuICogLy8gQGxvZzogICByYXc6IFB1YmxpY0tleUNyZWRlbnRpYWwge30sXG4gKiAvLyBAbG9nOiB9XG4gKlxuICogY29uc3QgeyBtZXRhZGF0YSwgc2lnbmF0dXJlIH0gPSBhd2FpdCBXZWJBdXRoblAyNTYuc2lnbih7XG4gKiAgIGNyZWRlbnRpYWxJZDogY3JlZGVudGlhbC5pZCxcbiAqICAgY2hhbGxlbmdlOiAnMHhkZWFkYmVlZicsXG4gKiB9KVxuICogYGBgXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBDcmVkZW50aWFsIGNyZWF0aW9uIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBBIFdlYkF1dGhuIFAyNTYgY3JlZGVudGlhbC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUNyZWRlbnRpYWwob3B0aW9ucykge1xuICAgIGNvbnN0IHsgY3JlYXRlRm4gPSB3aW5kb3cubmF2aWdhdG9yLmNyZWRlbnRpYWxzLmNyZWF0ZS5iaW5kKHdpbmRvdy5uYXZpZ2F0b3IuY3JlZGVudGlhbHMpLCAuLi5yZXN0IH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGNyZWF0aW9uT3B0aW9ucyA9IGdldENyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnMocmVzdCk7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY3JlZGVudGlhbCA9IChhd2FpdCBjcmVhdGVGbihjcmVhdGlvbk9wdGlvbnMpKTtcbiAgICAgICAgaWYgKCFjcmVkZW50aWFsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IENyZWRlbnRpYWxDcmVhdGlvbkZhaWxlZEVycm9yKCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gY3JlZGVudGlhbC5yZXNwb25zZTtcbiAgICAgICAgY29uc3QgcHVibGljS2V5ID0gYXdhaXQgaW50ZXJuYWwucGFyc2VDcmVkZW50aWFsUHVibGljS2V5KHJlc3BvbnNlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiBjcmVkZW50aWFsLmlkLFxuICAgICAgICAgICAgcHVibGljS2V5LFxuICAgICAgICAgICAgcmF3OiBjcmVkZW50aWFsLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IENyZWRlbnRpYWxDcmVhdGlvbkZhaWxlZEVycm9yKHtcbiAgICAgICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBHZXRzIHRoZSBhdXRoZW50aWNhdG9yIGRhdGEgd2hpY2ggY29udGFpbnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlXG4gKiBwcm9jZXNzaW5nIG9mIGFuIGF1dGhlbnRpY2F0b3IgcmVxdWVzdCAoaWUuIGZyb20gYFdlYkF1dGhuUDI1Ni5zaWduYCkuXG4gKlxuICogOjo6d2FybmluZ1xuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbWFpbmx5IGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9yIGZvciBtYW51YWxseSBjb25zdHJ1Y3RpbmdcbiAqIGF1dGVudGljYXRvciBkYXRhLiBJbiBtb3N0IGNhc2VzIHlvdSB3aWxsIG5vdCBuZWVkIHRoaXMgZnVuY3Rpb24uXG4gKiBgYXV0aGVudGljYXRvckRhdGFgIGlzIHR5cGljYWxseSByZXR1cm5lZCBhcyBwYXJ0IG9mIHRoZVxuICoge0BsaW5rIG94I1dlYkF1dGhuUDI1Ni4oc2lnbjpmdW5jdGlvbil9IHJlc3BvbnNlIChpZS4gYW4gYXV0aGVudGljYXRvciByZXNwb25zZSkuXG4gKlxuICogOjo6XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBXZWJBdXRoblAyNTYgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhdXRoZW50aWNhdG9yRGF0YSA9IFdlYkF1dGhuUDI1Ni5nZXRBdXRoZW50aWNhdG9yRGF0YSh7XG4gKiAgIHJwSWQ6ICdleGFtcGxlLmNvbScsXG4gKiAgIHNpZ25Db3VudDogNDIwLFxuICogfSlcbiAqIC8vIEBsb2c6IFwiMHhhMzc5YTZmNmVlYWZiOWE1NWUzNzhjMTE4MDM0ZTI3NTFlNjgyZmFiOWYyZDMwYWIxM2QyMTI1NTg2Y2UxOTQ3MDUwMDAwMDFhNFwiXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgdG8gY29uc3RydWN0IHRoZSBhdXRoZW50aWNhdG9yIGRhdGEuXG4gKiBAcmV0dXJucyBUaGUgYXV0aGVudGljYXRvciBkYXRhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXV0aGVudGljYXRvckRhdGEob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBmbGFnID0gNSwgcnBJZCA9IHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSwgc2lnbkNvdW50ID0gMCB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBycElkSGFzaCA9IEhhc2guc2hhMjU2KEhleC5mcm9tU3RyaW5nKHJwSWQpKTtcbiAgICBjb25zdCBmbGFnX2J5dGVzID0gSGV4LmZyb21OdW1iZXIoZmxhZywgeyBzaXplOiAxIH0pO1xuICAgIGNvbnN0IHNpZ25Db3VudF9ieXRlcyA9IEhleC5mcm9tTnVtYmVyKHNpZ25Db3VudCwgeyBzaXplOiA0IH0pO1xuICAgIHJldHVybiBIZXguY29uY2F0KHJwSWRIYXNoLCBmbGFnX2J5dGVzLCBzaWduQ291bnRfYnl0ZXMpO1xufVxuLyoqXG4gKiBDb25zdHJ1Y3RzIHRoZSBDbGllbnQgRGF0YSBpbiBzdHJpbmdpZmllZCBKU09OIGZvcm1hdCB3aGljaCByZXByZXNlbnRzIGNsaWVudCBkYXRhIHRoYXRcbiAqIHdhcyBwYXNzZWQgdG8gYGNyZWRlbnRpYWxzLmdldCgpYCBpbiB7QGxpbmsgb3gjV2ViQXV0aG5QMjU2LihzaWduOmZ1bmN0aW9uKX0uXG4gKlxuICogOjo6d2FybmluZ1xuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbWFpbmx5IGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9yIGZvciBtYW51YWxseSBjb25zdHJ1Y3RpbmdcbiAqIGNsaWVudCBkYXRhLiBJbiBtb3N0IGNhc2VzIHlvdSB3aWxsIG5vdCBuZWVkIHRoaXMgZnVuY3Rpb24uXG4gKiBgY2xpZW50RGF0YUpTT05gIGlzIHR5cGljYWxseSByZXR1cm5lZCBhcyBwYXJ0IG9mIHRoZVxuICoge0BsaW5rIG94I1dlYkF1dGhuUDI1Ni4oc2lnbjpmdW5jdGlvbil9IHJlc3BvbnNlIChpZS4gYW4gYXV0aGVudGljYXRvciByZXNwb25zZSkuXG4gKlxuICogOjo6XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBXZWJBdXRoblAyNTYgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBjbGllbnREYXRhSlNPTiA9IFdlYkF1dGhuUDI1Ni5nZXRDbGllbnREYXRhSlNPTih7XG4gKiAgIGNoYWxsZW5nZTogJzB4ZGVhZGJlZWYnLFxuICogICBvcmlnaW46ICdodHRwczovL2V4YW1wbGUuY29tJyxcbiAqIH0pXG4gKiAvLyBAbG9nOiBcIntcInR5cGVcIjpcIndlYmF1dGhuLmdldFwiLFwiY2hhbGxlbmdlXCI6XCIzcTItN3dcIixcIm9yaWdpblwiOlwiaHR0cHM6Ly9leGFtcGxlLmNvbVwiLFwiY3Jvc3NPcmlnaW5cIjpmYWxzZX1cIlxuICogYGBgXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIHRvIGNvbnN0cnVjdCB0aGUgY2xpZW50IGRhdGEuXG4gKiBAcmV0dXJucyBUaGUgY2xpZW50IGRhdGEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDbGllbnREYXRhSlNPTihvcHRpb25zKSB7XG4gICAgY29uc3QgeyBjaGFsbGVuZ2UsIGNyb3NzT3JpZ2luID0gZmFsc2UsIGV4dHJhQ2xpZW50RGF0YSwgb3JpZ2luID0gd2luZG93LmxvY2F0aW9uLm9yaWdpbiwgfSA9IG9wdGlvbnM7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgdHlwZTogJ3dlYmF1dGhuLmdldCcsXG4gICAgICAgIGNoYWxsZW5nZTogQmFzZTY0LmZyb21IZXgoY2hhbGxlbmdlLCB7IHVybDogdHJ1ZSwgcGFkOiBmYWxzZSB9KSxcbiAgICAgICAgb3JpZ2luLFxuICAgICAgICBjcm9zc09yaWdpbixcbiAgICAgICAgLi4uZXh0cmFDbGllbnREYXRhLFxuICAgIH0pO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjcmVhdGlvbiBvcHRpb25zIGZvciBhIFAyNTYgV2ViQXV0aG4gQ3JlZGVudGlhbCB0byBiZSB1c2VkIHdpdGhcbiAqIHRoZSBXZWIgQXV0aGVudGljYXRpb24gQVBJLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgV2ViQXV0aG5QMjU2IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgb3B0aW9ucyA9IFdlYkF1dGhuUDI1Ni5nZXRDcmVkZW50aWFsQ3JlYXRpb25PcHRpb25zKHsgbmFtZTogJ0V4YW1wbGUnIH0pXG4gKlxuICogY29uc3QgY3JlZGVudGlhbCA9IGF3YWl0IHdpbmRvdy5uYXZpZ2F0b3IuY3JlZGVudGlhbHMuY3JlYXRlKG9wdGlvbnMpXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgY3JlZGVudGlhbCBjcmVhdGlvbiBvcHRpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3JlZGVudGlhbENyZWF0aW9uT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgY29uc3QgeyBhdHRlc3RhdGlvbiA9ICdub25lJywgYXV0aGVudGljYXRvclNlbGVjdGlvbiA9IHtcbiAgICAgICAgcmVzaWRlbnRLZXk6ICdwcmVmZXJyZWQnLFxuICAgICAgICByZXF1aXJlUmVzaWRlbnRLZXk6IGZhbHNlLFxuICAgICAgICB1c2VyVmVyaWZpY2F0aW9uOiAncmVxdWlyZWQnLFxuICAgIH0sIGNoYWxsZW5nZSA9IGNyZWF0ZUNoYWxsZW5nZSwgZXhjbHVkZUNyZWRlbnRpYWxJZHMsIGV4dGVuc2lvbnMsIG5hbWU6IG5hbWVfLCBycCA9IHtcbiAgICAgICAgaWQ6IHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSxcbiAgICAgICAgbmFtZTogd2luZG93LmRvY3VtZW50LnRpdGxlLFxuICAgIH0sIHVzZXIsIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IG5hbWUgPSAodXNlcj8ubmFtZSA/PyBuYW1lXyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHVibGljS2V5OiB7XG4gICAgICAgICAgICBhdHRlc3RhdGlvbixcbiAgICAgICAgICAgIGF1dGhlbnRpY2F0b3JTZWxlY3Rpb24sXG4gICAgICAgICAgICBjaGFsbGVuZ2U6IHR5cGVvZiBjaGFsbGVuZ2UgPT09ICdzdHJpbmcnID8gQnl0ZXMuZnJvbUhleChjaGFsbGVuZ2UpIDogY2hhbGxlbmdlLFxuICAgICAgICAgICAgLi4uKGV4Y2x1ZGVDcmVkZW50aWFsSWRzXG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIGV4Y2x1ZGVDcmVkZW50aWFsczogZXhjbHVkZUNyZWRlbnRpYWxJZHM/Lm1hcCgoaWQpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogQmFzZTY0LnRvQnl0ZXMoaWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3B1YmxpYy1rZXknLFxuICAgICAgICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDoge30pLFxuICAgICAgICAgICAgcHViS2V5Q3JlZFBhcmFtczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3B1YmxpYy1rZXknLFxuICAgICAgICAgICAgICAgICAgICBhbGc6IC03LCAvLyBwMjU2XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAuLi4oZXh0ZW5zaW9ucyAmJiB7IGV4dGVuc2lvbnMgfSksXG4gICAgICAgICAgICBycCxcbiAgICAgICAgICAgIHVzZXI6IHtcbiAgICAgICAgICAgICAgICBpZDogdXNlcj8uaWQgPz8gSGFzaC5rZWNjYWsyNTYoQnl0ZXMuZnJvbVN0cmluZyhuYW1lKSwgeyBhczogJ0J5dGVzJyB9KSxcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIGRpc3BsYXlOYW1lOiB1c2VyPy5kaXNwbGF5TmFtZSA/PyBuYW1lLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSByZXF1ZXN0IG9wdGlvbnMgdG8gc2lnbiBhIGNoYWxsZW5nZSB3aXRoIHRoZSBXZWIgQXV0aGVudGljYXRpb24gQVBJLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgV2ViQXV0aG5QMjU2IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgb3B0aW9ucyA9IFdlYkF1dGhuUDI1Ni5nZXRDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnMoe1xuICogICBjaGFsbGVuZ2U6ICcweGRlYWRiZWVmJyxcbiAqIH0pXG4gKlxuICogY29uc3QgY3JlZGVudGlhbCA9IGF3YWl0IHdpbmRvdy5uYXZpZ2F0b3IuY3JlZGVudGlhbHMuZ2V0KG9wdGlvbnMpXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgY3JlZGVudGlhbCByZXF1ZXN0IG9wdGlvbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnMob3B0aW9ucykge1xuICAgIGNvbnN0IHsgY3JlZGVudGlhbElkLCBjaGFsbGVuZ2UsIGV4dGVuc2lvbnMsIHJwSWQgPSB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUsIHVzZXJWZXJpZmljYXRpb24gPSAncmVxdWlyZWQnLCB9ID0gb3B0aW9ucztcbiAgICByZXR1cm4ge1xuICAgICAgICBwdWJsaWNLZXk6IHtcbiAgICAgICAgICAgIC4uLihjcmVkZW50aWFsSWRcbiAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dDcmVkZW50aWFsczogQXJyYXkuaXNBcnJheShjcmVkZW50aWFsSWQpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNyZWRlbnRpYWxJZC5tYXAoKGlkKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBCYXNlNjQudG9CeXRlcyhpZCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3B1YmxpYy1rZXknLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBCYXNlNjQudG9CeXRlcyhjcmVkZW50aWFsSWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAncHVibGljLWtleScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDoge30pLFxuICAgICAgICAgICAgY2hhbGxlbmdlOiBCeXRlcy5mcm9tSGV4KGNoYWxsZW5nZSksXG4gICAgICAgICAgICAuLi4oZXh0ZW5zaW9ucyAmJiB7IGV4dGVuc2lvbnMgfSksXG4gICAgICAgICAgICBycElkLFxuICAgICAgICAgICAgdXNlclZlcmlmaWNhdGlvbixcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBDb25zdHJ1Y3RzIHRoZSBmaW5hbCBkaWdlc3QgdGhhdCB3YXMgc2lnbmVkIGFuZCBjb21wdXRlZCBieSB0aGUgYXV0aGVudGljYXRvci4gVGhpcyBwYXlsb2FkIGluY2x1ZGVzXG4gKiB0aGUgY3J5cHRvZ3JhcGhpYyBgY2hhbGxlbmdlYCwgYXMgd2VsbCBhcyBhdXRoZW50aWNhdG9yIG1ldGFkYXRhIChgYXV0aGVudGljYXRvckRhdGFgICsgYGNsaWVudERhdGFKU09OYCkuXG4gKiBUaGlzIHZhbHVlIGNhbiBiZSBhbHNvIHVzZWQgd2l0aCByYXcgUDI1NiB2ZXJpZmljYXRpb24gKHN1Y2ggYXMge0BsaW5rIG94I1AyNTYuKHZlcmlmeTpmdW5jdGlvbil9IG9yXG4gKiB7QGxpbmsgb3gjV2ViQ3J5cHRvUDI1Ni4odmVyaWZ5OmZ1bmN0aW9uKX0pLlxuICpcbiAqIDo6Ondhcm5pbmdcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIG1haW5seSBmb3IgdGVzdGluZyBwdXJwb3NlcyBvciBmb3IgbWFudWFsbHkgY29uc3RydWN0aW5nXG4gKiBzaWduaW5nIHBheWxvYWRzLiBJbiBtb3N0IGNhc2VzIHlvdSB3aWxsIG5vdCBuZWVkIHRoaXMgZnVuY3Rpb24gYW5kXG4gKiBpbnN0ZWFkIHVzZSB7QGxpbmsgb3gjV2ViQXV0aG5QMjU2LihzaWduOmZ1bmN0aW9uKX0uXG4gKlxuICogOjo6XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBXZWJBdXRoblAyNTYsIFdlYkNyeXB0b1AyNTYgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB7IG1ldGFkYXRhLCBwYXlsb2FkIH0gPSBXZWJBdXRoblAyNTYuZ2V0U2lnblBheWxvYWQoeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIGNoYWxsZW5nZTogJzB4ZGVhZGJlZWYnLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIG1ldGFkYXRhOiB7XG4gKiAvLyBAbG9nOiAgICAgYXV0aGVudGljYXRvckRhdGE6IFwiMHg0OTk2MGRlNTg4MGU4YzY4NzQzNDE3MGY2NDc2NjA1YjhmZTRhZWI5YTI4NjMyYzc5OTVjZjNiYTgzMWQ5NzYzMDUwMDAwMDAwMFwiLFxuICogLy8gQGxvZzogICAgIGNoYWxsZW5nZUluZGV4OiAyMyxcbiAqIC8vIEBsb2c6ICAgICBjbGllbnREYXRhSlNPTjogXCJ7XCJ0eXBlXCI6XCJ3ZWJhdXRobi5nZXRcIixcImNoYWxsZW5nZVwiOlwiOWpFRmlqdWhFV3JNNFNPVy10Q2hKYlVFSEVQNDRWY2pjSi1CcW8xZlRNOFwiLFwib3JpZ2luXCI6XCJodHRwOi8vbG9jYWxob3N0OjUxNzNcIixcImNyb3NzT3JpZ2luXCI6ZmFsc2V9XCIsXG4gKiAvLyBAbG9nOiAgICAgdHlwZUluZGV4OiAxLFxuICogLy8gQGxvZzogICAgIHVzZXJWZXJpZmljYXRpb25SZXF1aXJlZDogdHJ1ZSxcbiAqIC8vIEBsb2c6ICAgfSxcbiAqIC8vIEBsb2c6ICAgcGF5bG9hZDogXCIweDQ5OTYwZGU1ODgwZThjNjg3NDM0MTcwZjY0NzY2MDViOGZlNGFlYjlhMjg2MzJjNzk5NWNmM2JhODMxZDk3NjMwNTAwMDAwMDAwNDUwODZkY2IwNmE1ZjIzNGRiNjI1YmNkYzk0ZTY1N2Y4NmI3NmI2ZmQzZWI5YzMwNTQzZWFiYzFlNTc3YTRiMFwiLFxuICogLy8gQGxvZzogfVxuICpcbiAqIGNvbnN0IHsgcHVibGljS2V5LCBwcml2YXRlS2V5IH0gPSBhd2FpdCBXZWJDcnlwdG9QMjU2LmNyZWF0ZUtleVBhaXIoKVxuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IFdlYkNyeXB0b1AyNTYuc2lnbih7XG4gKiAgIHBheWxvYWQsXG4gKiAgIHByaXZhdGVLZXksXG4gKiB9KVxuICogYGBgXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIHRvIGNvbnN0cnVjdCB0aGUgc2lnbmluZyBwYXlsb2FkLlxuICogQHJldHVybnMgVGhlIHNpZ25pbmcgcGF5bG9hZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNpZ25QYXlsb2FkKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGNoYWxsZW5nZSwgY3Jvc3NPcmlnaW4sIGV4dHJhQ2xpZW50RGF0YSwgZmxhZywgb3JpZ2luLCBycElkLCBzaWduQ291bnQsIHVzZXJWZXJpZmljYXRpb24gPSAncmVxdWlyZWQnLCB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBhdXRoZW50aWNhdG9yRGF0YSA9IGdldEF1dGhlbnRpY2F0b3JEYXRhKHtcbiAgICAgICAgZmxhZyxcbiAgICAgICAgcnBJZCxcbiAgICAgICAgc2lnbkNvdW50LFxuICAgIH0pO1xuICAgIGNvbnN0IGNsaWVudERhdGFKU09OID0gZ2V0Q2xpZW50RGF0YUpTT04oe1xuICAgICAgICBjaGFsbGVuZ2UsXG4gICAgICAgIGNyb3NzT3JpZ2luLFxuICAgICAgICBleHRyYUNsaWVudERhdGEsXG4gICAgICAgIG9yaWdpbixcbiAgICB9KTtcbiAgICBjb25zdCBjbGllbnREYXRhSlNPTkhhc2ggPSBIYXNoLnNoYTI1NihIZXguZnJvbVN0cmluZyhjbGllbnREYXRhSlNPTikpO1xuICAgIGNvbnN0IGNoYWxsZW5nZUluZGV4ID0gY2xpZW50RGF0YUpTT04uaW5kZXhPZignXCJjaGFsbGVuZ2VcIicpO1xuICAgIGNvbnN0IHR5cGVJbmRleCA9IGNsaWVudERhdGFKU09OLmluZGV4T2YoJ1widHlwZVwiJyk7XG4gICAgY29uc3QgbWV0YWRhdGEgPSB7XG4gICAgICAgIGF1dGhlbnRpY2F0b3JEYXRhLFxuICAgICAgICBjbGllbnREYXRhSlNPTixcbiAgICAgICAgY2hhbGxlbmdlSW5kZXgsXG4gICAgICAgIHR5cGVJbmRleCxcbiAgICAgICAgdXNlclZlcmlmaWNhdGlvblJlcXVpcmVkOiB1c2VyVmVyaWZpY2F0aW9uID09PSAncmVxdWlyZWQnLFxuICAgIH07XG4gICAgY29uc3QgcGF5bG9hZCA9IEhleC5jb25jYXQoYXV0aGVudGljYXRvckRhdGEsIGNsaWVudERhdGFKU09OSGFzaCk7XG4gICAgcmV0dXJuIHsgbWV0YWRhdGEsIHBheWxvYWQgfTtcbn1cbi8qKlxuICogU2lnbnMgYSBjaGFsbGVuZ2UgdXNpbmcgYSBzdG9yZWQgV2ViQXV0aG4gUDI1NiBDcmVkZW50aWFsLiBJZiBubyBDcmVkZW50aWFsIGlzIHByb3ZpZGVkLFxuICogYSBwcm9tcHQgd2lsbCBiZSBkaXNwbGF5ZWQgZm9yIHRoZSB1c2VyIHRvIHNlbGVjdCBhbiBleGlzdGluZyBDcmVkZW50aWFsXG4gKiB0aGF0IHdhcyBwcmV2aW91c2x5IHJlZ2lzdGVyZWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBXZWJBdXRoblAyNTYgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBjcmVkZW50aWFsID0gYXdhaXQgV2ViQXV0aG5QMjU2LmNyZWF0ZUNyZWRlbnRpYWwoe1xuICogICBuYW1lOiAnRXhhbXBsZScsXG4gKiB9KVxuICpcbiAqIGNvbnN0IHsgbWV0YWRhdGEsIHNpZ25hdHVyZSB9ID0gYXdhaXQgV2ViQXV0aG5QMjU2LnNpZ24oeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIGNyZWRlbnRpYWxJZDogY3JlZGVudGlhbC5pZCwgLy8gWyFjb2RlIGZvY3VzXVxuICogICBjaGFsbGVuZ2U6ICcweGRlYWRiZWVmJywgLy8gWyFjb2RlIGZvY3VzXVxuICogfSkgLy8gWyFjb2RlIGZvY3VzXVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICBtZXRhZGF0YToge1xuICogLy8gQGxvZzogICAgIGF1dGhlbnRpY2F0b3JEYXRhOiAnMHg0OTk2MGRlNTg4MGU4YzY4NzQzNDE3MGY2NDc2NjA1YjhmZTRhZWI5YTI4NjMyYzc5OTVjZjNiYTgzMWQ5NzYzMDUwMDAwMDAwMCcsXG4gKiAvLyBAbG9nOiAgICAgY2xpZW50RGF0YUpTT046ICd7XCJ0eXBlXCI6XCJ3ZWJhdXRobi5nZXRcIixcImNoYWxsZW5nZVwiOlwiOWpFRmlqdWhFV3JNNFNPVy10Q2hKYlVFSEVQNDRWY2pjSi1CcW8xZlRNOFwiLFwib3JpZ2luXCI6XCJodHRwOi8vbG9jYWxob3N0OjUxNzNcIixcImNyb3NzT3JpZ2luXCI6ZmFsc2V9JyxcbiAqIC8vIEBsb2c6ICAgICBjaGFsbGVuZ2VJbmRleDogMjMsXG4gKiAvLyBAbG9nOiAgICAgdHlwZUluZGV4OiAxLFxuICogLy8gQGxvZzogICAgIHVzZXJWZXJpZmljYXRpb25SZXF1aXJlZDogdHJ1ZSxcbiAqIC8vIEBsb2c6ICAgfSxcbiAqIC8vIEBsb2c6ICAgc2lnbmF0dXJlOiB7IHI6IDUxMjMxLi4uNDIxNW4sIHM6IDEyMzQ1Li4uNjc4OW4gfSxcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBzaWduYXR1cmUuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzaWduKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGdldEZuID0gd2luZG93Lm5hdmlnYXRvci5jcmVkZW50aWFscy5nZXQuYmluZCh3aW5kb3cubmF2aWdhdG9yLmNyZWRlbnRpYWxzKSwgLi4ucmVzdCB9ID0gb3B0aW9ucztcbiAgICBjb25zdCByZXF1ZXN0T3B0aW9ucyA9IGdldENyZWRlbnRpYWxSZXF1ZXN0T3B0aW9ucyhyZXN0KTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBjcmVkZW50aWFsID0gKGF3YWl0IGdldEZuKHJlcXVlc3RPcHRpb25zKSk7XG4gICAgICAgIGlmICghY3JlZGVudGlhbClcbiAgICAgICAgICAgIHRocm93IG5ldyBDcmVkZW50aWFsUmVxdWVzdEZhaWxlZEVycm9yKCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gY3JlZGVudGlhbC5yZXNwb25zZTtcbiAgICAgICAgY29uc3QgY2xpZW50RGF0YUpTT04gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKC4uLm5ldyBVaW50OEFycmF5KHJlc3BvbnNlLmNsaWVudERhdGFKU09OKSk7XG4gICAgICAgIGNvbnN0IGNoYWxsZW5nZUluZGV4ID0gY2xpZW50RGF0YUpTT04uaW5kZXhPZignXCJjaGFsbGVuZ2VcIicpO1xuICAgICAgICBjb25zdCB0eXBlSW5kZXggPSBjbGllbnREYXRhSlNPTi5pbmRleE9mKCdcInR5cGVcIicpO1xuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBpbnRlcm5hbC5wYXJzZUFzbjFTaWduYXR1cmUobmV3IFVpbnQ4QXJyYXkocmVzcG9uc2Uuc2lnbmF0dXJlKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgICAgIGF1dGhlbnRpY2F0b3JEYXRhOiBIZXguZnJvbUJ5dGVzKG5ldyBVaW50OEFycmF5KHJlc3BvbnNlLmF1dGhlbnRpY2F0b3JEYXRhKSksXG4gICAgICAgICAgICAgICAgY2xpZW50RGF0YUpTT04sXG4gICAgICAgICAgICAgICAgY2hhbGxlbmdlSW5kZXgsXG4gICAgICAgICAgICAgICAgdHlwZUluZGV4LFxuICAgICAgICAgICAgICAgIHVzZXJWZXJpZmljYXRpb25SZXF1aXJlZDogcmVxdWVzdE9wdGlvbnMucHVibGljS2V5LnVzZXJWZXJpZmljYXRpb24gPT09ICdyZXF1aXJlZCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2lnbmF0dXJlLFxuICAgICAgICAgICAgcmF3OiBjcmVkZW50aWFsLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IENyZWRlbnRpYWxSZXF1ZXN0RmFpbGVkRXJyb3Ioe1xuICAgICAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFZlcmlmaWVzIGEgc2lnbmF0dXJlIHVzaW5nIHRoZSBDcmVkZW50aWFsJ3MgcHVibGljIGtleSBhbmQgdGhlIGNoYWxsZW5nZSB3aGljaCB3YXMgc2lnbmVkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgV2ViQXV0aG5QMjU2IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgY3JlZGVudGlhbCA9IGF3YWl0IFdlYkF1dGhuUDI1Ni5jcmVhdGVDcmVkZW50aWFsKHtcbiAqICAgbmFtZTogJ0V4YW1wbGUnLFxuICogfSlcbiAqXG4gKiBjb25zdCB7IG1ldGFkYXRhLCBzaWduYXR1cmUgfSA9IGF3YWl0IFdlYkF1dGhuUDI1Ni5zaWduKHtcbiAqICAgY3JlZGVudGlhbElkOiBjcmVkZW50aWFsLmlkLFxuICogICBjaGFsbGVuZ2U6ICcweGRlYWRiZWVmJyxcbiAqIH0pXG4gKlxuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgV2ViQXV0aG5QMjU2LnZlcmlmeSh7IC8vIFshY29kZSBmb2N1c11cbiAqICAgbWV0YWRhdGEsIC8vIFshY29kZSBmb2N1c11cbiAqICAgY2hhbGxlbmdlOiAnMHhkZWFkYmVlZicsIC8vIFshY29kZSBmb2N1c11cbiAqICAgcHVibGljS2V5OiBjcmVkZW50aWFsLnB1YmxpY0tleSwgLy8gWyFjb2RlIGZvY3VzXVxuICogICBzaWduYXR1cmUsIC8vIFshY29kZSBmb2N1c11cbiAqIH0pIC8vIFshY29kZSBmb2N1c11cbiAqIC8vIEBsb2c6IHRydWVcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHNpZ25hdHVyZSBpcyB2YWxpZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeShvcHRpb25zKSB7XG4gICAgY29uc3QgeyBjaGFsbGVuZ2UsIGhhc2ggPSB0cnVlLCBtZXRhZGF0YSwgcHVibGljS2V5LCBzaWduYXR1cmUgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgeyBhdXRoZW50aWNhdG9yRGF0YSwgY2hhbGxlbmdlSW5kZXgsIGNsaWVudERhdGFKU09OLCB0eXBlSW5kZXgsIHVzZXJWZXJpZmljYXRpb25SZXF1aXJlZCwgfSA9IG1ldGFkYXRhO1xuICAgIGNvbnN0IGF1dGhlbnRpY2F0b3JEYXRhQnl0ZXMgPSBCeXRlcy5mcm9tSGV4KGF1dGhlbnRpY2F0b3JEYXRhKTtcbiAgICAvLyBDaGVjayBsZW5ndGggb2YgYGF1dGhlbnRpY2F0b3JEYXRhYC5cbiAgICBpZiAoYXV0aGVudGljYXRvckRhdGFCeXRlcy5sZW5ndGggPCAzNylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGZsYWcgPSBhdXRoZW50aWNhdG9yRGF0YUJ5dGVzWzMyXTtcbiAgICAvLyBWZXJpZnkgdGhhdCB0aGUgVVAgYml0IG9mIHRoZSBmbGFncyBpbiBhdXRoRGF0YSBpcyBzZXQuXG4gICAgaWYgKChmbGFnICYgMHgwMSkgIT09IDB4MDEpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAvLyBJZiB1c2VyIHZlcmlmaWNhdGlvbiB3YXMgZGV0ZXJtaW5lZCB0byBiZSByZXF1aXJlZCwgdmVyaWZ5IHRoYXRcbiAgICAvLyB0aGUgVVYgYml0IG9mIHRoZSBmbGFncyBpbiBhdXRoRGF0YSBpcyBzZXQuIE90aGVyd2lzZSwgaWdub3JlIHRoZVxuICAgIC8vIHZhbHVlIG9mIHRoZSBVViBmbGFnLlxuICAgIGlmICh1c2VyVmVyaWZpY2F0aW9uUmVxdWlyZWQgJiYgKGZsYWcgJiAweDA0KSAhPT0gMHgwNClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIC8vIElmIHRoZSBCRSBiaXQgb2YgdGhlIGZsYWdzIGluIGF1dGhEYXRhIGlzIG5vdCBzZXQsIHZlcmlmeSB0aGF0XG4gICAgLy8gdGhlIEJTIGJpdCBpcyBub3Qgc2V0LlxuICAgIGlmICgoZmxhZyAmIDB4MDgpICE9PSAweDA4ICYmIChmbGFnICYgMHgxMCkgPT09IDB4MTApXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAvLyBDaGVjayB0aGF0IHJlc3BvbnNlIGlzIGZvciBhbiBhdXRoZW50aWNhdGlvbiBhc3NlcnRpb24gKGlmIHR5cGVJbmRleCBpcyBwcm92aWRlZClcbiAgICBpZiAodHlwZUluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9ICdcInR5cGVcIjpcIndlYmF1dGhuLmdldFwiJztcbiAgICAgICAgaWYgKHR5cGUgIT09IGNsaWVudERhdGFKU09OLnNsaWNlKE51bWJlcih0eXBlSW5kZXgpLCB0eXBlLmxlbmd0aCArIDEpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBFeHRyYWN0IGFuZCB2YWxpZGF0ZSB0aGUgY2hhbGxlbmdlIGZyb20gY2xpZW50RGF0YUpTT05cbiAgICBjb25zdCBjaGFsbGVuZ2VNYXRjaCA9IGNoYWxsZW5nZUluZGV4ICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBjbGllbnREYXRhSlNPTlxuICAgICAgICAgICAgLnNsaWNlKE51bWJlcihjaGFsbGVuZ2VJbmRleCkpXG4gICAgICAgICAgICAubWF0Y2goL15cImNoYWxsZW5nZVwiOlwiKC4qPylcIi8pXG4gICAgICAgIDogY2xpZW50RGF0YUpTT04ubWF0Y2goL1wiY2hhbGxlbmdlXCI6XCIoLio/KVwiLyk7XG4gICAgaWYgKCFjaGFsbGVuZ2VNYXRjaClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIC8vIFZhbGlkYXRlIHRoZSBjaGFsbGVuZ2UgaW4gdGhlIGNsaWVudERhdGFKU09OLlxuICAgIGNvbnN0IFtfLCBjaGFsbGVuZ2VfZXh0cmFjdGVkXSA9IGNoYWxsZW5nZU1hdGNoO1xuICAgIGlmIChIZXguZnJvbUJ5dGVzKEJhc2U2NC50b0J5dGVzKGNoYWxsZW5nZV9leHRyYWN0ZWQpKSAhPT0gY2hhbGxlbmdlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgY2xpZW50RGF0YUpTT05IYXNoID0gSGFzaC5zaGEyNTYoQnl0ZXMuZnJvbVN0cmluZyhjbGllbnREYXRhSlNPTiksIHtcbiAgICAgICAgYXM6ICdCeXRlcycsXG4gICAgfSk7XG4gICAgY29uc3QgcGF5bG9hZCA9IEJ5dGVzLmNvbmNhdChhdXRoZW50aWNhdG9yRGF0YUJ5dGVzLCBjbGllbnREYXRhSlNPTkhhc2gpO1xuICAgIHJldHVybiBQMjU2LnZlcmlmeSh7XG4gICAgICAgIGhhc2gsXG4gICAgICAgIHBheWxvYWQsXG4gICAgICAgIHB1YmxpY0tleSxcbiAgICAgICAgc2lnbmF0dXJlLFxuICAgIH0pO1xufVxuLyoqIFRocm93biB3aGVuIGEgV2ViQXV0aG4gUDI1NiBjcmVkZW50aWFsIGNyZWF0aW9uIGZhaWxzLiAqL1xuZXhwb3J0IGNsYXNzIENyZWRlbnRpYWxDcmVhdGlvbkZhaWxlZEVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBjYXVzZSB9ID0ge30pIHtcbiAgICAgICAgc3VwZXIoJ0ZhaWxlZCB0byBjcmVhdGUgY3JlZGVudGlhbC4nLCB7XG4gICAgICAgICAgICBjYXVzZSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdXZWJBdXRoblAyNTYuQ3JlZGVudGlhbENyZWF0aW9uRmFpbGVkRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKiBUaHJvd24gd2hlbiBhIFdlYkF1dGhuIFAyNTYgY3JlZGVudGlhbCByZXF1ZXN0IGZhaWxzLiAqL1xuZXhwb3J0IGNsYXNzIENyZWRlbnRpYWxSZXF1ZXN0RmFpbGVkRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGNhdXNlIH0gPSB7fSkge1xuICAgICAgICBzdXBlcignRmFpbGVkIHRvIHJlcXVlc3QgY3JlZGVudGlhbC4nLCB7XG4gICAgICAgICAgICBjYXVzZSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdXZWJBdXRoblAyNTYuQ3JlZGVudGlhbFJlcXVlc3RGYWlsZWRFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9V2ViQXV0aG5QMjU2LmpzLm1hcCJdLCJuYW1lcyI6WyJCYXNlNjQiLCJCeXRlcyIsIkVycm9ycyIsIkhhc2giLCJIZXgiLCJpbnRlcm5hbCIsIlAyNTYiLCJjcmVhdGVDaGFsbGVuZ2UiLCJVaW50OEFycmF5IiwiZnJvbSIsImNyZWF0ZUNyZWRlbnRpYWwiLCJvcHRpb25zIiwiY3JlYXRlRm4iLCJ3aW5kb3ciLCJuYXZpZ2F0b3IiLCJjcmVkZW50aWFscyIsImNyZWF0ZSIsImJpbmQiLCJyZXN0IiwiY3JlYXRpb25PcHRpb25zIiwiZ2V0Q3JlZGVudGlhbENyZWF0aW9uT3B0aW9ucyIsImNyZWRlbnRpYWwiLCJDcmVkZW50aWFsQ3JlYXRpb25GYWlsZWRFcnJvciIsInJlc3BvbnNlIiwicHVibGljS2V5IiwicGFyc2VDcmVkZW50aWFsUHVibGljS2V5IiwiaWQiLCJyYXciLCJlcnJvciIsImNhdXNlIiwiZ2V0QXV0aGVudGljYXRvckRhdGEiLCJmbGFnIiwicnBJZCIsImxvY2F0aW9uIiwiaG9zdG5hbWUiLCJzaWduQ291bnQiLCJycElkSGFzaCIsInNoYTI1NiIsImZyb21TdHJpbmciLCJmbGFnX2J5dGVzIiwiZnJvbU51bWJlciIsInNpemUiLCJzaWduQ291bnRfYnl0ZXMiLCJjb25jYXQiLCJnZXRDbGllbnREYXRhSlNPTiIsImNoYWxsZW5nZSIsImNyb3NzT3JpZ2luIiwiZXh0cmFDbGllbnREYXRhIiwib3JpZ2luIiwiSlNPTiIsInN0cmluZ2lmeSIsInR5cGUiLCJmcm9tSGV4IiwidXJsIiwicGFkIiwiYXR0ZXN0YXRpb24iLCJhdXRoZW50aWNhdG9yU2VsZWN0aW9uIiwicmVzaWRlbnRLZXkiLCJyZXF1aXJlUmVzaWRlbnRLZXkiLCJ1c2VyVmVyaWZpY2F0aW9uIiwiZXhjbHVkZUNyZWRlbnRpYWxJZHMiLCJleHRlbnNpb25zIiwibmFtZSIsIm5hbWVfIiwicnAiLCJkb2N1bWVudCIsInRpdGxlIiwidXNlciIsImV4Y2x1ZGVDcmVkZW50aWFscyIsIm1hcCIsInRvQnl0ZXMiLCJwdWJLZXlDcmVkUGFyYW1zIiwiYWxnIiwia2VjY2FrMjU2IiwiYXMiLCJkaXNwbGF5TmFtZSIsImdldENyZWRlbnRpYWxSZXF1ZXN0T3B0aW9ucyIsImNyZWRlbnRpYWxJZCIsImFsbG93Q3JlZGVudGlhbHMiLCJBcnJheSIsImlzQXJyYXkiLCJnZXRTaWduUGF5bG9hZCIsImF1dGhlbnRpY2F0b3JEYXRhIiwiY2xpZW50RGF0YUpTT04iLCJjbGllbnREYXRhSlNPTkhhc2giLCJjaGFsbGVuZ2VJbmRleCIsImluZGV4T2YiLCJ0eXBlSW5kZXgiLCJtZXRhZGF0YSIsInVzZXJWZXJpZmljYXRpb25SZXF1aXJlZCIsInBheWxvYWQiLCJzaWduIiwiZ2V0Rm4iLCJnZXQiLCJyZXF1ZXN0T3B0aW9ucyIsIkNyZWRlbnRpYWxSZXF1ZXN0RmFpbGVkRXJyb3IiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJzaWduYXR1cmUiLCJwYXJzZUFzbjFTaWduYXR1cmUiLCJmcm9tQnl0ZXMiLCJ2ZXJpZnkiLCJoYXNoIiwiYXV0aGVudGljYXRvckRhdGFCeXRlcyIsImxlbmd0aCIsInVuZGVmaW5lZCIsInNsaWNlIiwiTnVtYmVyIiwiY2hhbGxlbmdlTWF0Y2giLCJtYXRjaCIsIl8iLCJjaGFsbGVuZ2VfZXh0cmFjdGVkIiwiQmFzZUVycm9yIiwiY29uc3RydWN0b3IiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsInZhbHVlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/WebAuthnP256.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Withdrawal.js":
/*!*************************************************!*\
  !*** ./node_modules/ox/_esm/core/Withdrawal.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromRpc: () => (/* binding */ fromRpc),\n/* harmony export */   toRpc: () => (/* binding */ toRpc)\n/* harmony export */ });\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n\n/**\n * Converts a {@link ox#Withdrawal.Rpc} to an {@link ox#Withdrawal.Withdrawal}.\n *\n * @example\n * ```ts twoslash\n * import { Withdrawal } from 'ox'\n *\n * const withdrawal = Withdrawal.fromRpc({\n *   address: '0x00000000219ab540356cBB839Cbe05303d7705Fa',\n *   amount: '0x620323',\n *   index: '0x0',\n *   validatorIndex: '0x1',\n * })\n * // @log: {\n * // @log:   address: '0x00000000219ab540356cBB839Cbe05303d7705Fa',\n * // @log:   amount: 6423331n,\n * // @log:   index: 0,\n * // @log:   validatorIndex: 1\n * // @log: }\n * ```\n *\n * @param withdrawal - The RPC withdrawal to convert.\n * @returns An instantiated {@link ox#Withdrawal.Withdrawal}.\n */ function fromRpc(withdrawal) {\n    return {\n        ...withdrawal,\n        amount: BigInt(withdrawal.amount),\n        index: Number(withdrawal.index),\n        validatorIndex: Number(withdrawal.validatorIndex)\n    };\n}\n/**\n * Converts a {@link ox#Withdrawal.Withdrawal} to an {@link ox#Withdrawal.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Withdrawal } from 'ox'\n *\n * const withdrawal = Withdrawal.toRpc({\n *   address: '0x00000000219ab540356cBB839Cbe05303d7705Fa',\n *   amount: 6423331n,\n *   index: 0,\n *   validatorIndex: 1,\n * })\n * // @log: {\n * // @log:   address: '0x00000000219ab540356cBB839Cbe05303d7705Fa',\n * // @log:   amount: '0x620323',\n * // @log:   index: '0x0',\n * // @log:   validatorIndex: '0x1',\n * // @log: }\n * ```\n *\n * @param withdrawal - The Withdrawal to convert.\n * @returns An RPC Withdrawal.\n */ function toRpc(withdrawal) {\n    return {\n        address: withdrawal.address,\n        amount: _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromNumber(withdrawal.amount),\n        index: _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromNumber(withdrawal.index),\n        validatorIndex: _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromNumber(withdrawal.validatorIndex)\n    };\n} //# sourceMappingURL=Withdrawal.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1dpdGhkcmF3YWwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWdDO0FBQ2hDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXVCQyxHQUNNLFNBQVNDLFFBQVFDLFVBQVU7SUFDOUIsT0FBTztRQUNILEdBQUdBLFVBQVU7UUFDYkMsUUFBUUMsT0FBT0YsV0FBV0MsTUFBTTtRQUNoQ0UsT0FBT0MsT0FBT0osV0FBV0csS0FBSztRQUM5QkUsZ0JBQWdCRCxPQUFPSixXQUFXSyxjQUFjO0lBQ3BEO0FBQ0o7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F1QkMsR0FDTSxTQUFTQyxNQUFNTixVQUFVO0lBQzVCLE9BQU87UUFDSE8sU0FBU1AsV0FBV08sT0FBTztRQUMzQk4sUUFBUUgsK0NBQWMsQ0FBQ0UsV0FBV0MsTUFBTTtRQUN4Q0UsT0FBT0wsK0NBQWMsQ0FBQ0UsV0FBV0csS0FBSztRQUN0Q0UsZ0JBQWdCUCwrQ0FBYyxDQUFDRSxXQUFXSyxjQUFjO0lBQzVEO0FBQ0osRUFDQSxzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGF3LXdvcmtzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9XaXRoZHJhd2FsLmpzPzk4ZjUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbi8qKlxuICogQ29udmVydHMgYSB7QGxpbmsgb3gjV2l0aGRyYXdhbC5ScGN9IHRvIGFuIHtAbGluayBveCNXaXRoZHJhd2FsLldpdGhkcmF3YWx9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgV2l0aGRyYXdhbCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHdpdGhkcmF3YWwgPSBXaXRoZHJhd2FsLmZyb21ScGMoe1xuICogICBhZGRyZXNzOiAnMHgwMDAwMDAwMDIxOWFiNTQwMzU2Y0JCODM5Q2JlMDUzMDNkNzcwNUZhJyxcbiAqICAgYW1vdW50OiAnMHg2MjAzMjMnLFxuICogICBpbmRleDogJzB4MCcsXG4gKiAgIHZhbGlkYXRvckluZGV4OiAnMHgxJyxcbiAqIH0pXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIGFkZHJlc3M6ICcweDAwMDAwMDAwMjE5YWI1NDAzNTZjQkI4MzlDYmUwNTMwM2Q3NzA1RmEnLFxuICogLy8gQGxvZzogICBhbW91bnQ6IDY0MjMzMzFuLFxuICogLy8gQGxvZzogICBpbmRleDogMCxcbiAqIC8vIEBsb2c6ICAgdmFsaWRhdG9ySW5kZXg6IDFcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB3aXRoZHJhd2FsIC0gVGhlIFJQQyB3aXRoZHJhd2FsIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBBbiBpbnN0YW50aWF0ZWQge0BsaW5rIG94I1dpdGhkcmF3YWwuV2l0aGRyYXdhbH0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUnBjKHdpdGhkcmF3YWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi53aXRoZHJhd2FsLFxuICAgICAgICBhbW91bnQ6IEJpZ0ludCh3aXRoZHJhd2FsLmFtb3VudCksXG4gICAgICAgIGluZGV4OiBOdW1iZXIod2l0aGRyYXdhbC5pbmRleCksXG4gICAgICAgIHZhbGlkYXRvckluZGV4OiBOdW1iZXIod2l0aGRyYXdhbC52YWxpZGF0b3JJbmRleCksXG4gICAgfTtcbn1cbi8qKlxuICogQ29udmVydHMgYSB7QGxpbmsgb3gjV2l0aGRyYXdhbC5XaXRoZHJhd2FsfSB0byBhbiB7QGxpbmsgb3gjV2l0aGRyYXdhbC5ScGN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgV2l0aGRyYXdhbCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHdpdGhkcmF3YWwgPSBXaXRoZHJhd2FsLnRvUnBjKHtcbiAqICAgYWRkcmVzczogJzB4MDAwMDAwMDAyMTlhYjU0MDM1NmNCQjgzOUNiZTA1MzAzZDc3MDVGYScsXG4gKiAgIGFtb3VudDogNjQyMzMzMW4sXG4gKiAgIGluZGV4OiAwLFxuICogICB2YWxpZGF0b3JJbmRleDogMSxcbiAqIH0pXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIGFkZHJlc3M6ICcweDAwMDAwMDAwMjE5YWI1NDAzNTZjQkI4MzlDYmUwNTMwM2Q3NzA1RmEnLFxuICogLy8gQGxvZzogICBhbW91bnQ6ICcweDYyMDMyMycsXG4gKiAvLyBAbG9nOiAgIGluZGV4OiAnMHgwJyxcbiAqIC8vIEBsb2c6ICAgdmFsaWRhdG9ySW5kZXg6ICcweDEnLFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHdpdGhkcmF3YWwgLSBUaGUgV2l0aGRyYXdhbCB0byBjb252ZXJ0LlxuICogQHJldHVybnMgQW4gUlBDIFdpdGhkcmF3YWwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1JwYyh3aXRoZHJhd2FsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkcmVzczogd2l0aGRyYXdhbC5hZGRyZXNzLFxuICAgICAgICBhbW91bnQ6IEhleC5mcm9tTnVtYmVyKHdpdGhkcmF3YWwuYW1vdW50KSxcbiAgICAgICAgaW5kZXg6IEhleC5mcm9tTnVtYmVyKHdpdGhkcmF3YWwuaW5kZXgpLFxuICAgICAgICB2YWxpZGF0b3JJbmRleDogSGV4LmZyb21OdW1iZXIod2l0aGRyYXdhbC52YWxpZGF0b3JJbmRleCksXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVdpdGhkcmF3YWwuanMubWFwIl0sIm5hbWVzIjpbIkhleCIsImZyb21ScGMiLCJ3aXRoZHJhd2FsIiwiYW1vdW50IiwiQmlnSW50IiwiaW5kZXgiLCJOdW1iZXIiLCJ2YWxpZGF0b3JJbmRleCIsInRvUnBjIiwiYWRkcmVzcyIsImZyb21OdW1iZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Withdrawal.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/internal/abiItem.js":
/*!*******************************************************!*\
  !*** ./node_modules/ox/_esm/core/internal/abiItem.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAmbiguousTypes: () => (/* binding */ getAmbiguousTypes),\n/* harmony export */   isArgOfType: () => (/* binding */ isArgOfType),\n/* harmony export */   normalizeSignature: () => (/* binding */ normalizeSignature)\n/* harmony export */ });\n/* harmony import */ var _Address_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Address.js */ \"(ssr)/./node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n\n\n/** @internal */ function normalizeSignature(signature) {\n    let active = true;\n    let current = \"\";\n    let level = 0;\n    let result = \"\";\n    let valid = false;\n    for(let i = 0; i < signature.length; i++){\n        const char = signature[i];\n        // If the character is a separator, we want to reactivate.\n        if ([\n            \"(\",\n            \")\",\n            \",\"\n        ].includes(char)) active = true;\n        // If the character is a \"level\" token, we want to increment/decrement.\n        if (char === \"(\") level++;\n        if (char === \")\") level--;\n        // If we aren't active, we don't want to mutate the result.\n        if (!active) continue;\n        // If level === 0, we are at the definition level.\n        if (level === 0) {\n            if (char === \" \" && [\n                \"event\",\n                \"function\",\n                \"error\",\n                \"\"\n            ].includes(result)) result = \"\";\n            else {\n                result += char;\n                // If we are at the end of the definition, we must be finished.\n                if (char === \")\") {\n                    valid = true;\n                    break;\n                }\n            }\n            continue;\n        }\n        // Ignore spaces\n        if (char === \" \") {\n            // If the previous character is a separator, and the current section isn't empty, we want to deactivate.\n            if (signature[i - 1] !== \",\" && current !== \",\" && current !== \",(\") {\n                current = \"\";\n                active = false;\n            }\n            continue;\n        }\n        result += char;\n        current += char;\n    }\n    if (!valid) throw new _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError(\"Unable to normalize signature.\");\n    return result;\n}\n/** @internal */ function isArgOfType(arg, abiParameter) {\n    const argType = typeof arg;\n    const abiParameterType = abiParameter.type;\n    switch(abiParameterType){\n        case \"address\":\n            return _Address_js__WEBPACK_IMPORTED_MODULE_1__.validate(arg, {\n                strict: false\n            });\n        case \"bool\":\n            return argType === \"boolean\";\n        case \"function\":\n            return argType === \"string\";\n        case \"string\":\n            return argType === \"string\";\n        default:\n            {\n                if (abiParameterType === \"tuple\" && \"components\" in abiParameter) return Object.values(abiParameter.components).every((component, index)=>{\n                    return isArgOfType(Object.values(arg)[index], component);\n                });\n                // `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n                // https://regexr.com/6v8hp\n                if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType)) return argType === \"number\" || argType === \"bigint\";\n                // `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n                // https://regexr.com/6va55\n                if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType)) return argType === \"string\" || arg instanceof Uint8Array;\n                // fixed-length (`<type>[M]`) and dynamic (`<type>[]`) arrays\n                // https://regexr.com/6va6i\n                if (/[a-z]+[1-9]{0,3}(\\[[0-9]{0,}\\])+$/.test(abiParameterType)) {\n                    return Array.isArray(arg) && arg.every((x)=>isArgOfType(x, {\n                            ...abiParameter,\n                            // Pop off `[]` or `[M]` from end of type\n                            type: abiParameterType.replace(/(\\[[0-9]{0,}\\])$/, \"\")\n                        }));\n                }\n                return false;\n            }\n    }\n}\n/** @internal */ function getAmbiguousTypes(sourceParameters, targetParameters, args) {\n    for(const parameterIndex in sourceParameters){\n        const sourceParameter = sourceParameters[parameterIndex];\n        const targetParameter = targetParameters[parameterIndex];\n        if (sourceParameter.type === \"tuple\" && targetParameter.type === \"tuple\" && \"components\" in sourceParameter && \"components\" in targetParameter) return getAmbiguousTypes(sourceParameter.components, targetParameter.components, args[parameterIndex]);\n        const types = [\n            sourceParameter.type,\n            targetParameter.type\n        ];\n        const ambiguous = (()=>{\n            if (types.includes(\"address\") && types.includes(\"bytes20\")) return true;\n            if (types.includes(\"address\") && types.includes(\"string\")) return _Address_js__WEBPACK_IMPORTED_MODULE_1__.validate(args[parameterIndex], {\n                strict: false\n            });\n            if (types.includes(\"address\") && types.includes(\"bytes\")) return _Address_js__WEBPACK_IMPORTED_MODULE_1__.validate(args[parameterIndex], {\n                strict: false\n            });\n            return false;\n        })();\n        if (ambiguous) return types;\n    }\n    return;\n} //# sourceMappingURL=abiItem.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2FiaUl0ZW0uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBeUM7QUFDRjtBQUN2QyxjQUFjLEdBQ1AsU0FBU0UsbUJBQW1CQyxTQUFTO0lBQ3hDLElBQUlDLFNBQVM7SUFDYixJQUFJQyxVQUFVO0lBQ2QsSUFBSUMsUUFBUTtJQUNaLElBQUlDLFNBQVM7SUFDYixJQUFJQyxRQUFRO0lBQ1osSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlOLFVBQVVPLE1BQU0sRUFBRUQsSUFBSztRQUN2QyxNQUFNRSxPQUFPUixTQUFTLENBQUNNLEVBQUU7UUFDekIsMERBQTBEO1FBQzFELElBQUk7WUFBQztZQUFLO1lBQUs7U0FBSSxDQUFDRyxRQUFRLENBQUNELE9BQ3pCUCxTQUFTO1FBQ2IsdUVBQXVFO1FBQ3ZFLElBQUlPLFNBQVMsS0FDVEw7UUFDSixJQUFJSyxTQUFTLEtBQ1RMO1FBQ0osMkRBQTJEO1FBQzNELElBQUksQ0FBQ0YsUUFDRDtRQUNKLGtEQUFrRDtRQUNsRCxJQUFJRSxVQUFVLEdBQUc7WUFDYixJQUFJSyxTQUFTLE9BQU87Z0JBQUM7Z0JBQVM7Z0JBQVk7Z0JBQVM7YUFBRyxDQUFDQyxRQUFRLENBQUNMLFNBQzVEQSxTQUFTO2lCQUNSO2dCQUNEQSxVQUFVSTtnQkFDViwrREFBK0Q7Z0JBQy9ELElBQUlBLFNBQVMsS0FBSztvQkFDZEgsUUFBUTtvQkFDUjtnQkFDSjtZQUNKO1lBQ0E7UUFDSjtRQUNBLGdCQUFnQjtRQUNoQixJQUFJRyxTQUFTLEtBQUs7WUFDZCx3R0FBd0c7WUFDeEcsSUFBSVIsU0FBUyxDQUFDTSxJQUFJLEVBQUUsS0FBSyxPQUFPSixZQUFZLE9BQU9BLFlBQVksTUFBTTtnQkFDakVBLFVBQVU7Z0JBQ1ZELFNBQVM7WUFDYjtZQUNBO1FBQ0o7UUFDQUcsVUFBVUk7UUFDVk4sV0FBV007SUFDZjtJQUNBLElBQUksQ0FBQ0gsT0FDRCxNQUFNLElBQUlQLGlEQUFnQixDQUFDO0lBQy9CLE9BQU9NO0FBQ1g7QUFDQSxjQUFjLEdBQ1AsU0FBU08sWUFBWUMsR0FBRyxFQUFFQyxZQUFZO0lBQ3pDLE1BQU1DLFVBQVUsT0FBT0Y7SUFDdkIsTUFBTUcsbUJBQW1CRixhQUFhRyxJQUFJO0lBQzFDLE9BQVFEO1FBQ0osS0FBSztZQUNELE9BQU9sQixpREFBZ0IsQ0FBQ2UsS0FBSztnQkFBRU0sUUFBUTtZQUFNO1FBQ2pELEtBQUs7WUFDRCxPQUFPSixZQUFZO1FBQ3ZCLEtBQUs7WUFDRCxPQUFPQSxZQUFZO1FBQ3ZCLEtBQUs7WUFDRCxPQUFPQSxZQUFZO1FBQ3ZCO1lBQVM7Z0JBQ0wsSUFBSUMscUJBQXFCLFdBQVcsZ0JBQWdCRixjQUNoRCxPQUFPTSxPQUFPQyxNQUFNLENBQUNQLGFBQWFRLFVBQVUsRUFBRUMsS0FBSyxDQUFDLENBQUNDLFdBQVdDO29CQUM1RCxPQUFPYixZQUFZUSxPQUFPQyxNQUFNLENBQUNSLElBQUksQ0FBQ1ksTUFBTSxFQUFFRDtnQkFDbEQ7Z0JBQ0osaUZBQWlGO2dCQUNqRiwyQkFBMkI7Z0JBQzNCLElBQUksK0hBQStIRSxJQUFJLENBQUNWLG1CQUNwSSxPQUFPRCxZQUFZLFlBQVlBLFlBQVk7Z0JBQy9DLHNEQUFzRDtnQkFDdEQsMkJBQTJCO2dCQUMzQixJQUFJLHVDQUF1Q1csSUFBSSxDQUFDVixtQkFDNUMsT0FBT0QsWUFBWSxZQUFZRixlQUFlYztnQkFDbEQsNkRBQTZEO2dCQUM3RCwyQkFBMkI7Z0JBQzNCLElBQUksb0NBQW9DRCxJQUFJLENBQUNWLG1CQUFtQjtvQkFDNUQsT0FBUVksTUFBTUMsT0FBTyxDQUFDaEIsUUFDbEJBLElBQUlVLEtBQUssQ0FBQyxDQUFDTyxJQUFNbEIsWUFBWWtCLEdBQUc7NEJBQzVCLEdBQUdoQixZQUFZOzRCQUNmLHlDQUF5Qzs0QkFDekNHLE1BQU1ELGlCQUFpQmUsT0FBTyxDQUFDLG9CQUFvQjt3QkFDdkQ7Z0JBQ1I7Z0JBQ0EsT0FBTztZQUNYO0lBQ0o7QUFDSjtBQUNBLGNBQWMsR0FDUCxTQUFTQyxrQkFBa0JDLGdCQUFnQixFQUFFQyxnQkFBZ0IsRUFBRUMsSUFBSTtJQUN0RSxJQUFLLE1BQU1DLGtCQUFrQkgsaUJBQWtCO1FBQzNDLE1BQU1JLGtCQUFrQkosZ0JBQWdCLENBQUNHLGVBQWU7UUFDeEQsTUFBTUUsa0JBQWtCSixnQkFBZ0IsQ0FBQ0UsZUFBZTtRQUN4RCxJQUFJQyxnQkFBZ0JwQixJQUFJLEtBQUssV0FDekJxQixnQkFBZ0JyQixJQUFJLEtBQUssV0FDekIsZ0JBQWdCb0IsbUJBQ2hCLGdCQUFnQkMsaUJBQ2hCLE9BQU9OLGtCQUFrQkssZ0JBQWdCZixVQUFVLEVBQUVnQixnQkFBZ0JoQixVQUFVLEVBQUVhLElBQUksQ0FBQ0MsZUFBZTtRQUN6RyxNQUFNRyxRQUFRO1lBQUNGLGdCQUFnQnBCLElBQUk7WUFBRXFCLGdCQUFnQnJCLElBQUk7U0FBQztRQUMxRCxNQUFNdUIsWUFBWSxDQUFDO1lBQ2YsSUFBSUQsTUFBTTdCLFFBQVEsQ0FBQyxjQUFjNkIsTUFBTTdCLFFBQVEsQ0FBQyxZQUM1QyxPQUFPO1lBQ1gsSUFBSTZCLE1BQU03QixRQUFRLENBQUMsY0FBYzZCLE1BQU03QixRQUFRLENBQUMsV0FDNUMsT0FBT1osaURBQWdCLENBQUNxQyxJQUFJLENBQUNDLGVBQWUsRUFBRTtnQkFDMUNqQixRQUFRO1lBQ1o7WUFDSixJQUFJb0IsTUFBTTdCLFFBQVEsQ0FBQyxjQUFjNkIsTUFBTTdCLFFBQVEsQ0FBQyxVQUM1QyxPQUFPWixpREFBZ0IsQ0FBQ3FDLElBQUksQ0FBQ0MsZUFBZSxFQUFFO2dCQUMxQ2pCLFFBQVE7WUFDWjtZQUNKLE9BQU87UUFDWDtRQUNBLElBQUlxQixXQUNBLE9BQU9EO0lBQ2Y7SUFDQTtBQUNKLEVBQ0EsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xhdy13b3Jrcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvaW50ZXJuYWwvYWJpSXRlbS5qcz81NGUxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEFkZHJlc3MgZnJvbSAnLi4vQWRkcmVzcy5qcyc7XG5pbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSAnLi4vRXJyb3JzLmpzJztcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVTaWduYXR1cmUoc2lnbmF0dXJlKSB7XG4gICAgbGV0IGFjdGl2ZSA9IHRydWU7XG4gICAgbGV0IGN1cnJlbnQgPSAnJztcbiAgICBsZXQgbGV2ZWwgPSAwO1xuICAgIGxldCByZXN1bHQgPSAnJztcbiAgICBsZXQgdmFsaWQgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpZ25hdHVyZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjaGFyID0gc2lnbmF0dXJlW2ldO1xuICAgICAgICAvLyBJZiB0aGUgY2hhcmFjdGVyIGlzIGEgc2VwYXJhdG9yLCB3ZSB3YW50IHRvIHJlYWN0aXZhdGUuXG4gICAgICAgIGlmIChbJygnLCAnKScsICcsJ10uaW5jbHVkZXMoY2hhcikpXG4gICAgICAgICAgICBhY3RpdmUgPSB0cnVlO1xuICAgICAgICAvLyBJZiB0aGUgY2hhcmFjdGVyIGlzIGEgXCJsZXZlbFwiIHRva2VuLCB3ZSB3YW50IHRvIGluY3JlbWVudC9kZWNyZW1lbnQuXG4gICAgICAgIGlmIChjaGFyID09PSAnKCcpXG4gICAgICAgICAgICBsZXZlbCsrO1xuICAgICAgICBpZiAoY2hhciA9PT0gJyknKVxuICAgICAgICAgICAgbGV2ZWwtLTtcbiAgICAgICAgLy8gSWYgd2UgYXJlbid0IGFjdGl2ZSwgd2UgZG9uJ3Qgd2FudCB0byBtdXRhdGUgdGhlIHJlc3VsdC5cbiAgICAgICAgaWYgKCFhY3RpdmUpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgLy8gSWYgbGV2ZWwgPT09IDAsIHdlIGFyZSBhdCB0aGUgZGVmaW5pdGlvbiBsZXZlbC5cbiAgICAgICAgaWYgKGxldmVsID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoY2hhciA9PT0gJyAnICYmIFsnZXZlbnQnLCAnZnVuY3Rpb24nLCAnZXJyb3InLCAnJ10uaW5jbHVkZXMocmVzdWx0KSlcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAnJztcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBjaGFyO1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGFyZSBhdCB0aGUgZW5kIG9mIHRoZSBkZWZpbml0aW9uLCB3ZSBtdXN0IGJlIGZpbmlzaGVkLlxuICAgICAgICAgICAgICAgIGlmIChjaGFyID09PSAnKScpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZ25vcmUgc3BhY2VzXG4gICAgICAgIGlmIChjaGFyID09PSAnICcpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBwcmV2aW91cyBjaGFyYWN0ZXIgaXMgYSBzZXBhcmF0b3IsIGFuZCB0aGUgY3VycmVudCBzZWN0aW9uIGlzbid0IGVtcHR5LCB3ZSB3YW50IHRvIGRlYWN0aXZhdGUuXG4gICAgICAgICAgICBpZiAoc2lnbmF0dXJlW2kgLSAxXSAhPT0gJywnICYmIGN1cnJlbnQgIT09ICcsJyAmJiBjdXJyZW50ICE9PSAnLCgnKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9ICcnO1xuICAgICAgICAgICAgICAgIGFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9IGNoYXI7XG4gICAgICAgIGN1cnJlbnQgKz0gY2hhcjtcbiAgICB9XG4gICAgaWYgKCF2YWxpZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9ycy5CYXNlRXJyb3IoJ1VuYWJsZSB0byBub3JtYWxpemUgc2lnbmF0dXJlLicpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gaXNBcmdPZlR5cGUoYXJnLCBhYmlQYXJhbWV0ZXIpIHtcbiAgICBjb25zdCBhcmdUeXBlID0gdHlwZW9mIGFyZztcbiAgICBjb25zdCBhYmlQYXJhbWV0ZXJUeXBlID0gYWJpUGFyYW1ldGVyLnR5cGU7XG4gICAgc3dpdGNoIChhYmlQYXJhbWV0ZXJUeXBlKSB7XG4gICAgICAgIGNhc2UgJ2FkZHJlc3MnOlxuICAgICAgICAgICAgcmV0dXJuIEFkZHJlc3MudmFsaWRhdGUoYXJnLCB7IHN0cmljdDogZmFsc2UgfSk7XG4gICAgICAgIGNhc2UgJ2Jvb2wnOlxuICAgICAgICAgICAgcmV0dXJuIGFyZ1R5cGUgPT09ICdib29sZWFuJztcbiAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgcmV0dXJuIGFyZ1R5cGUgPT09ICdzdHJpbmcnO1xuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgcmV0dXJuIGFyZ1R5cGUgPT09ICdzdHJpbmcnO1xuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBpZiAoYWJpUGFyYW1ldGVyVHlwZSA9PT0gJ3R1cGxlJyAmJiAnY29tcG9uZW50cycgaW4gYWJpUGFyYW1ldGVyKVxuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKGFiaVBhcmFtZXRlci5jb21wb25lbnRzKS5ldmVyeSgoY29tcG9uZW50LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNBcmdPZlR5cGUoT2JqZWN0LnZhbHVlcyhhcmcpW2luZGV4XSwgY29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGAodSlpbnQ8TT5gOiAodW4pc2lnbmVkIGludGVnZXIgdHlwZSBvZiBgTWAgYml0cywgYDAgPCBNIDw9IDI1NmAsIGBNICUgOCA9PSAwYFxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9yZWdleHIuY29tLzZ2OGhwXG4gICAgICAgICAgICBpZiAoL151P2ludCg4fDE2fDI0fDMyfDQwfDQ4fDU2fDY0fDcyfDgwfDg4fDk2fDEwNHwxMTJ8MTIwfDEyOHwxMzZ8MTQ0fDE1MnwxNjB8MTY4fDE3NnwxODR8MTkyfDIwMHwyMDh8MjE2fDIyNHwyMzJ8MjQwfDI0OHwyNTYpPyQvLnRlc3QoYWJpUGFyYW1ldGVyVHlwZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZ1R5cGUgPT09ICdudW1iZXInIHx8IGFyZ1R5cGUgPT09ICdiaWdpbnQnO1xuICAgICAgICAgICAgLy8gYGJ5dGVzPE0+YDogYmluYXJ5IHR5cGUgb2YgYE1gIGJ5dGVzLCBgMCA8IE0gPD0gMzJgXG4gICAgICAgICAgICAvLyBodHRwczovL3JlZ2V4ci5jb20vNnZhNTVcbiAgICAgICAgICAgIGlmICgvXmJ5dGVzKFsxLTldfDFbMC05XXwyWzAtOV18M1swLTJdKT8kLy50ZXN0KGFiaVBhcmFtZXRlclR5cGUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBhcmdUeXBlID09PSAnc3RyaW5nJyB8fCBhcmcgaW5zdGFuY2VvZiBVaW50OEFycmF5O1xuICAgICAgICAgICAgLy8gZml4ZWQtbGVuZ3RoIChgPHR5cGU+W01dYCkgYW5kIGR5bmFtaWMgKGA8dHlwZT5bXWApIGFycmF5c1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9yZWdleHIuY29tLzZ2YTZpXG4gICAgICAgICAgICBpZiAoL1thLXpdK1sxLTldezAsM30oXFxbWzAtOV17MCx9XFxdKSskLy50ZXN0KGFiaVBhcmFtZXRlclR5cGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChBcnJheS5pc0FycmF5KGFyZykgJiZcbiAgICAgICAgICAgICAgICAgICAgYXJnLmV2ZXJ5KCh4KSA9PiBpc0FyZ09mVHlwZSh4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5hYmlQYXJhbWV0ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQb3Agb2ZmIGBbXWAgb3IgYFtNXWAgZnJvbSBlbmQgb2YgdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogYWJpUGFyYW1ldGVyVHlwZS5yZXBsYWNlKC8oXFxbWzAtOV17MCx9XFxdKSQvLCAnJyksXG4gICAgICAgICAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QW1iaWd1b3VzVHlwZXMoc291cmNlUGFyYW1ldGVycywgdGFyZ2V0UGFyYW1ldGVycywgYXJncykge1xuICAgIGZvciAoY29uc3QgcGFyYW1ldGVySW5kZXggaW4gc291cmNlUGFyYW1ldGVycykge1xuICAgICAgICBjb25zdCBzb3VyY2VQYXJhbWV0ZXIgPSBzb3VyY2VQYXJhbWV0ZXJzW3BhcmFtZXRlckluZGV4XTtcbiAgICAgICAgY29uc3QgdGFyZ2V0UGFyYW1ldGVyID0gdGFyZ2V0UGFyYW1ldGVyc1twYXJhbWV0ZXJJbmRleF07XG4gICAgICAgIGlmIChzb3VyY2VQYXJhbWV0ZXIudHlwZSA9PT0gJ3R1cGxlJyAmJlxuICAgICAgICAgICAgdGFyZ2V0UGFyYW1ldGVyLnR5cGUgPT09ICd0dXBsZScgJiZcbiAgICAgICAgICAgICdjb21wb25lbnRzJyBpbiBzb3VyY2VQYXJhbWV0ZXIgJiZcbiAgICAgICAgICAgICdjb21wb25lbnRzJyBpbiB0YXJnZXRQYXJhbWV0ZXIpXG4gICAgICAgICAgICByZXR1cm4gZ2V0QW1iaWd1b3VzVHlwZXMoc291cmNlUGFyYW1ldGVyLmNvbXBvbmVudHMsIHRhcmdldFBhcmFtZXRlci5jb21wb25lbnRzLCBhcmdzW3BhcmFtZXRlckluZGV4XSk7XG4gICAgICAgIGNvbnN0IHR5cGVzID0gW3NvdXJjZVBhcmFtZXRlci50eXBlLCB0YXJnZXRQYXJhbWV0ZXIudHlwZV07XG4gICAgICAgIGNvbnN0IGFtYmlndW91cyA9ICgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZXMuaW5jbHVkZXMoJ2FkZHJlc3MnKSAmJiB0eXBlcy5pbmNsdWRlcygnYnl0ZXMyMCcpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKHR5cGVzLmluY2x1ZGVzKCdhZGRyZXNzJykgJiYgdHlwZXMuaW5jbHVkZXMoJ3N0cmluZycpKVxuICAgICAgICAgICAgICAgIHJldHVybiBBZGRyZXNzLnZhbGlkYXRlKGFyZ3NbcGFyYW1ldGVySW5kZXhdLCB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmljdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodHlwZXMuaW5jbHVkZXMoJ2FkZHJlc3MnKSAmJiB0eXBlcy5pbmNsdWRlcygnYnl0ZXMnKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gQWRkcmVzcy52YWxpZGF0ZShhcmdzW3BhcmFtZXRlckluZGV4XSwge1xuICAgICAgICAgICAgICAgICAgICBzdHJpY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KSgpO1xuICAgICAgICBpZiAoYW1iaWd1b3VzKVxuICAgICAgICAgICAgcmV0dXJuIHR5cGVzO1xuICAgIH1cbiAgICByZXR1cm47XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYmlJdGVtLmpzLm1hcCJdLCJuYW1lcyI6WyJBZGRyZXNzIiwiRXJyb3JzIiwibm9ybWFsaXplU2lnbmF0dXJlIiwic2lnbmF0dXJlIiwiYWN0aXZlIiwiY3VycmVudCIsImxldmVsIiwicmVzdWx0IiwidmFsaWQiLCJpIiwibGVuZ3RoIiwiY2hhciIsImluY2x1ZGVzIiwiQmFzZUVycm9yIiwiaXNBcmdPZlR5cGUiLCJhcmciLCJhYmlQYXJhbWV0ZXIiLCJhcmdUeXBlIiwiYWJpUGFyYW1ldGVyVHlwZSIsInR5cGUiLCJ2YWxpZGF0ZSIsInN0cmljdCIsIk9iamVjdCIsInZhbHVlcyIsImNvbXBvbmVudHMiLCJldmVyeSIsImNvbXBvbmVudCIsImluZGV4IiwidGVzdCIsIlVpbnQ4QXJyYXkiLCJBcnJheSIsImlzQXJyYXkiLCJ4IiwicmVwbGFjZSIsImdldEFtYmlndW91c1R5cGVzIiwic291cmNlUGFyYW1ldGVycyIsInRhcmdldFBhcmFtZXRlcnMiLCJhcmdzIiwicGFyYW1ldGVySW5kZXgiLCJzb3VyY2VQYXJhbWV0ZXIiLCJ0YXJnZXRQYXJhbWV0ZXIiLCJ0eXBlcyIsImFtYmlndW91cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/internal/abiItem.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/internal/abiParameters.js":
/*!*************************************************************!*\
  !*** ./node_modules/ox/_esm/core/internal/abiParameters.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeAddress: () => (/* binding */ decodeAddress),\n/* harmony export */   decodeArray: () => (/* binding */ decodeArray),\n/* harmony export */   decodeBool: () => (/* binding */ decodeBool),\n/* harmony export */   decodeBytes: () => (/* binding */ decodeBytes),\n/* harmony export */   decodeNumber: () => (/* binding */ decodeNumber),\n/* harmony export */   decodeParameter: () => (/* binding */ decodeParameter),\n/* harmony export */   decodeString: () => (/* binding */ decodeString),\n/* harmony export */   decodeTuple: () => (/* binding */ decodeTuple),\n/* harmony export */   encode: () => (/* binding */ encode),\n/* harmony export */   encodeAddress: () => (/* binding */ encodeAddress),\n/* harmony export */   encodeArray: () => (/* binding */ encodeArray),\n/* harmony export */   encodeBoolean: () => (/* binding */ encodeBoolean),\n/* harmony export */   encodeBytes: () => (/* binding */ encodeBytes),\n/* harmony export */   encodeNumber: () => (/* binding */ encodeNumber),\n/* harmony export */   encodeString: () => (/* binding */ encodeString),\n/* harmony export */   encodeTuple: () => (/* binding */ encodeTuple),\n/* harmony export */   getArrayComponents: () => (/* binding */ getArrayComponents),\n/* harmony export */   hasDynamicChild: () => (/* binding */ hasDynamicChild),\n/* harmony export */   prepareParameter: () => (/* binding */ prepareParameter),\n/* harmony export */   prepareParameters: () => (/* binding */ prepareParameters)\n/* harmony export */ });\n/* harmony import */ var _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../AbiParameters.js */ \"(ssr)/./node_modules/ox/_esm/core/AbiParameters.js\");\n/* harmony import */ var _Address_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Address.js */ \"(ssr)/./node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Solidity_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Solidity.js */ \"(ssr)/./node_modules/ox/_esm/core/Solidity.js\");\n\n\n\n\n\n\n/** @internal */ function decodeParameter(cursor, param, options) {\n    const { checksumAddress, staticPosition } = options;\n    const arrayComponents = getArrayComponents(param.type);\n    if (arrayComponents) {\n        const [length, type] = arrayComponents;\n        return decodeArray(cursor, {\n            ...param,\n            type\n        }, {\n            checksumAddress,\n            length,\n            staticPosition\n        });\n    }\n    if (param.type === \"tuple\") return decodeTuple(cursor, param, {\n        checksumAddress,\n        staticPosition\n    });\n    if (param.type === \"address\") return decodeAddress(cursor, {\n        checksum: checksumAddress\n    });\n    if (param.type === \"bool\") return decodeBool(cursor);\n    if (param.type.startsWith(\"bytes\")) return decodeBytes(cursor, param, {\n        staticPosition\n    });\n    if (param.type.startsWith(\"uint\") || param.type.startsWith(\"int\")) return decodeNumber(cursor, param);\n    if (param.type === \"string\") return decodeString(cursor, {\n        staticPosition\n    });\n    throw new _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.InvalidTypeError(param.type);\n}\nconst sizeOfLength = 32;\nconst sizeOfOffset = 32;\n/** @internal */ function decodeAddress(cursor, options = {}) {\n    const { checksum = false } = options;\n    const value = cursor.readBytes(32);\n    const wrap = (address)=>checksum ? _Address_js__WEBPACK_IMPORTED_MODULE_1__.checksum(address) : address;\n    return [\n        wrap(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(_Bytes_js__WEBPACK_IMPORTED_MODULE_3__.slice(value, -20))),\n        32\n    ];\n}\n/** @internal */ function decodeArray(cursor, param, options) {\n    const { checksumAddress, length, staticPosition } = options;\n    // If the length of the array is not known in advance (dynamic array),\n    // this means we will need to wonder off to the pointer and decode.\n    if (!length) {\n        // Dealing with a dynamic type, so get the offset of the array data.\n        const offset = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(cursor.readBytes(sizeOfOffset));\n        // Start is the static position of current slot + offset.\n        const start = staticPosition + offset;\n        const startOfData = start + sizeOfLength;\n        // Get the length of the array from the offset.\n        cursor.setPosition(start);\n        const length = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(cursor.readBytes(sizeOfLength));\n        // Check if the array has any dynamic children.\n        const dynamicChild = hasDynamicChild(param);\n        let consumed = 0;\n        const value = [];\n        for(let i = 0; i < length; ++i){\n            // If any of the children is dynamic, then all elements will be offset pointer, thus size of one slot (32 bytes).\n            // Otherwise, elements will be the size of their encoding (consumed bytes).\n            cursor.setPosition(startOfData + (dynamicChild ? i * 32 : consumed));\n            const [data, consumed_] = decodeParameter(cursor, param, {\n                checksumAddress,\n                staticPosition: startOfData\n            });\n            consumed += consumed_;\n            value.push(data);\n        }\n        // As we have gone wondering, restore to the original position + next slot.\n        cursor.setPosition(staticPosition + 32);\n        return [\n            value,\n            32\n        ];\n    }\n    // If the length of the array is known in advance,\n    // and the length of an element deeply nested in the array is not known,\n    // we need to decode the offset of the array data.\n    if (hasDynamicChild(param)) {\n        // Dealing with dynamic types, so get the offset of the array data.\n        const offset = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(cursor.readBytes(sizeOfOffset));\n        // Start is the static position of current slot + offset.\n        const start = staticPosition + offset;\n        const value = [];\n        for(let i = 0; i < length; ++i){\n            // Move cursor along to the next slot (next offset pointer).\n            cursor.setPosition(start + i * 32);\n            const [data] = decodeParameter(cursor, param, {\n                checksumAddress,\n                staticPosition: start\n            });\n            value.push(data);\n        }\n        // As we have gone wondering, restore to the original position + next slot.\n        cursor.setPosition(staticPosition + 32);\n        return [\n            value,\n            32\n        ];\n    }\n    // If the length of the array is known in advance and the array is deeply static,\n    // then we can just decode each element in sequence.\n    let consumed = 0;\n    const value = [];\n    for(let i = 0; i < length; ++i){\n        const [data, consumed_] = decodeParameter(cursor, param, {\n            checksumAddress,\n            staticPosition: staticPosition + consumed\n        });\n        consumed += consumed_;\n        value.push(data);\n    }\n    return [\n        value,\n        consumed\n    ];\n}\n/** @internal */ function decodeBool(cursor) {\n    return [\n        _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toBoolean(cursor.readBytes(32), {\n            size: 32\n        }),\n        32\n    ];\n}\n/** @internal */ function decodeBytes(cursor, param, { staticPosition }) {\n    const [_, size] = param.type.split(\"bytes\");\n    if (!size) {\n        // Dealing with dynamic types, so get the offset of the bytes data.\n        const offset = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(cursor.readBytes(32));\n        // Set position of the cursor to start of bytes data.\n        cursor.setPosition(staticPosition + offset);\n        const length = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(cursor.readBytes(32));\n        // If there is no length, we have zero data.\n        if (length === 0) {\n            // As we have gone wondering, restore to the original position + next slot.\n            cursor.setPosition(staticPosition + 32);\n            return [\n                \"0x\",\n                32\n            ];\n        }\n        const data = cursor.readBytes(length);\n        // As we have gone wondering, restore to the original position + next slot.\n        cursor.setPosition(staticPosition + 32);\n        return [\n            _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(data),\n            32\n        ];\n    }\n    const value = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(cursor.readBytes(Number.parseInt(size, 10), 32));\n    return [\n        value,\n        32\n    ];\n}\n/** @internal */ function decodeNumber(cursor, param) {\n    const signed = param.type.startsWith(\"int\");\n    const size = Number.parseInt(param.type.split(\"int\")[1] || \"256\", 10);\n    const value = cursor.readBytes(32);\n    return [\n        size > 48 ? _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toBigInt(value, {\n            signed\n        }) : _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(value, {\n            signed\n        }),\n        32\n    ];\n}\n/** @internal */ function decodeTuple(cursor, param, options) {\n    const { checksumAddress, staticPosition } = options;\n    // Tuples can have unnamed components (i.e. they are arrays), so we must\n    // determine whether the tuple is named or unnamed. In the case of a named\n    // tuple, the value will be an object where each property is the name of the\n    // component. In the case of an unnamed tuple, the value will be an array.\n    const hasUnnamedChild = param.components.length === 0 || param.components.some(({ name })=>!name);\n    // Initialize the value to an object or an array, depending on whether the\n    // tuple is named or unnamed.\n    const value = hasUnnamedChild ? [] : {};\n    let consumed = 0;\n    // If the tuple has a dynamic child, we must first decode the offset to the\n    // tuple data.\n    if (hasDynamicChild(param)) {\n        // Dealing with dynamic types, so get the offset of the tuple data.\n        const offset = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(cursor.readBytes(sizeOfOffset));\n        // Start is the static position of referencing slot + offset.\n        const start = staticPosition + offset;\n        for(let i = 0; i < param.components.length; ++i){\n            const component = param.components[i];\n            cursor.setPosition(start + consumed);\n            const [data, consumed_] = decodeParameter(cursor, component, {\n                checksumAddress,\n                staticPosition: start\n            });\n            consumed += consumed_;\n            value[hasUnnamedChild ? i : component?.name] = data;\n        }\n        // As we have gone wondering, restore to the original position + next slot.\n        cursor.setPosition(staticPosition + 32);\n        return [\n            value,\n            32\n        ];\n    }\n    // If the tuple has static children, we can just decode each component\n    // in sequence.\n    for(let i = 0; i < param.components.length; ++i){\n        const component = param.components[i];\n        const [data, consumed_] = decodeParameter(cursor, component, {\n            checksumAddress,\n            staticPosition\n        });\n        value[hasUnnamedChild ? i : component?.name] = data;\n        consumed += consumed_;\n    }\n    return [\n        value,\n        consumed\n    ];\n}\n/** @internal */ function decodeString(cursor, { staticPosition }) {\n    // Get offset to start of string data.\n    const offset = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(cursor.readBytes(32));\n    // Start is the static position of current slot + offset.\n    const start = staticPosition + offset;\n    cursor.setPosition(start);\n    const length = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(cursor.readBytes(32));\n    // If there is no length, we have zero data (empty string).\n    if (length === 0) {\n        cursor.setPosition(staticPosition + 32);\n        return [\n            \"\",\n            32\n        ];\n    }\n    const data = cursor.readBytes(length, 32);\n    const value = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toString(_Bytes_js__WEBPACK_IMPORTED_MODULE_3__.trimLeft(data));\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32);\n    return [\n        value,\n        32\n    ];\n}\n/** @internal */ function prepareParameters({ checksumAddress, parameters, values }) {\n    const preparedParameters = [];\n    for(let i = 0; i < parameters.length; i++){\n        preparedParameters.push(prepareParameter({\n            checksumAddress,\n            parameter: parameters[i],\n            value: values[i]\n        }));\n    }\n    return preparedParameters;\n}\n/** @internal */ function prepareParameter({ checksumAddress = false, parameter: parameter_, value }) {\n    const parameter = parameter_;\n    const arrayComponents = getArrayComponents(parameter.type);\n    if (arrayComponents) {\n        const [length, type] = arrayComponents;\n        return encodeArray(value, {\n            checksumAddress,\n            length,\n            parameter: {\n                ...parameter,\n                type\n            }\n        });\n    }\n    if (parameter.type === \"tuple\") {\n        return encodeTuple(value, {\n            checksumAddress,\n            parameter: parameter\n        });\n    }\n    if (parameter.type === \"address\") {\n        return encodeAddress(value, {\n            checksum: checksumAddress\n        });\n    }\n    if (parameter.type === \"bool\") {\n        return encodeBoolean(value);\n    }\n    if (parameter.type.startsWith(\"uint\") || parameter.type.startsWith(\"int\")) {\n        const signed = parameter.type.startsWith(\"int\");\n        const [, , size = \"256\"] = _Solidity_js__WEBPACK_IMPORTED_MODULE_4__.integerRegex.exec(parameter.type) ?? [];\n        return encodeNumber(value, {\n            signed,\n            size: Number(size)\n        });\n    }\n    if (parameter.type.startsWith(\"bytes\")) {\n        return encodeBytes(value, {\n            type: parameter.type\n        });\n    }\n    if (parameter.type === \"string\") {\n        return encodeString(value);\n    }\n    throw new _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.InvalidTypeError(parameter.type);\n}\n/** @internal */ function encode(preparedParameters) {\n    // 1. Compute the size of the static part of the parameters.\n    let staticSize = 0;\n    for(let i = 0; i < preparedParameters.length; i++){\n        const { dynamic, encoded } = preparedParameters[i];\n        if (dynamic) staticSize += 32;\n        else staticSize += _Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(encoded);\n    }\n    // 2. Split the parameters into static and dynamic parts.\n    const staticParameters = [];\n    const dynamicParameters = [];\n    let dynamicSize = 0;\n    for(let i = 0; i < preparedParameters.length; i++){\n        const { dynamic, encoded } = preparedParameters[i];\n        if (dynamic) {\n            staticParameters.push(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(staticSize + dynamicSize, {\n                size: 32\n            }));\n            dynamicParameters.push(encoded);\n            dynamicSize += _Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(encoded);\n        } else {\n            staticParameters.push(encoded);\n        }\n    }\n    // 3. Concatenate static and dynamic parts.\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(...staticParameters, ...dynamicParameters);\n}\n/** @internal */ function encodeAddress(value, options) {\n    const { checksum = false } = options;\n    _Address_js__WEBPACK_IMPORTED_MODULE_1__.assert(value, {\n        strict: checksum\n    });\n    return {\n        dynamic: false,\n        encoded: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.padLeft(value.toLowerCase())\n    };\n}\n/** @internal */ function encodeArray(value, options) {\n    const { checksumAddress, length, parameter } = options;\n    const dynamic = length === null;\n    if (!Array.isArray(value)) throw new _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.InvalidArrayError(value);\n    if (!dynamic && value.length !== length) throw new _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.ArrayLengthMismatchError({\n        expectedLength: length,\n        givenLength: value.length,\n        type: `${parameter.type}[${length}]`\n    });\n    let dynamicChild = false;\n    const preparedParameters = [];\n    for(let i = 0; i < value.length; i++){\n        const preparedParam = prepareParameter({\n            checksumAddress,\n            parameter,\n            value: value[i]\n        });\n        if (preparedParam.dynamic) dynamicChild = true;\n        preparedParameters.push(preparedParam);\n    }\n    if (dynamic || dynamicChild) {\n        const data = encode(preparedParameters);\n        if (dynamic) {\n            const length = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(preparedParameters.length, {\n                size: 32\n            });\n            return {\n                dynamic: true,\n                encoded: preparedParameters.length > 0 ? _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(length, data) : length\n            };\n        }\n        if (dynamicChild) return {\n            dynamic: true,\n            encoded: data\n        };\n    }\n    return {\n        dynamic: false,\n        encoded: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(...preparedParameters.map(({ encoded })=>encoded))\n    };\n}\n/** @internal */ function encodeBytes(value, { type }) {\n    const [, parametersize] = type.split(\"bytes\");\n    const bytesSize = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(value);\n    if (!parametersize) {\n        let value_ = value;\n        // If the size is not divisible by 32 bytes, pad the end\n        // with empty bytes to the ceiling 32 bytes.\n        if (bytesSize % 32 !== 0) value_ = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.padRight(value_, Math.ceil((value.length - 2) / 2 / 32) * 32);\n        return {\n            dynamic: true,\n            encoded: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.padLeft(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(bytesSize, {\n                size: 32\n            })), value_)\n        };\n    }\n    if (bytesSize !== Number.parseInt(parametersize, 10)) throw new _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.BytesSizeMismatchError({\n        expectedSize: Number.parseInt(parametersize, 10),\n        value\n    });\n    return {\n        dynamic: false,\n        encoded: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.padRight(value)\n    };\n}\n/** @internal */ function encodeBoolean(value) {\n    if (typeof value !== \"boolean\") throw new _Errors_js__WEBPACK_IMPORTED_MODULE_5__.BaseError(`Invalid boolean value: \"${value}\" (type: ${typeof value}). Expected: \\`true\\` or \\`false\\`.`);\n    return {\n        dynamic: false,\n        encoded: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.padLeft(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBoolean(value))\n    };\n}\n/** @internal */ function encodeNumber(value, { signed, size }) {\n    if (typeof size === \"number\") {\n        const max = 2n ** (BigInt(size) - (signed ? 1n : 0n)) - 1n;\n        const min = signed ? -max - 1n : 0n;\n        if (value > max || value < min) throw new _Hex_js__WEBPACK_IMPORTED_MODULE_2__.IntegerOutOfRangeError({\n            max: max.toString(),\n            min: min.toString(),\n            signed,\n            size: size / 8,\n            value: value.toString()\n        });\n    }\n    return {\n        dynamic: false,\n        encoded: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(value, {\n            size: 32,\n            signed\n        })\n    };\n}\n/** @internal */ function encodeString(value) {\n    const hexValue = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromString(value);\n    const partsLength = Math.ceil(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(hexValue) / 32);\n    const parts = [];\n    for(let i = 0; i < partsLength; i++){\n        parts.push(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.padRight(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.slice(hexValue, i * 32, (i + 1) * 32)));\n    }\n    return {\n        dynamic: true,\n        encoded: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.padRight(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(hexValue), {\n            size: 32\n        })), ...parts)\n    };\n}\n/** @internal */ function encodeTuple(value, options) {\n    const { checksumAddress, parameter } = options;\n    let dynamic = false;\n    const preparedParameters = [];\n    for(let i = 0; i < parameter.components.length; i++){\n        const param_ = parameter.components[i];\n        const index = Array.isArray(value) ? i : param_.name;\n        const preparedParam = prepareParameter({\n            checksumAddress,\n            parameter: param_,\n            value: value[index]\n        });\n        preparedParameters.push(preparedParam);\n        if (preparedParam.dynamic) dynamic = true;\n    }\n    return {\n        dynamic,\n        encoded: dynamic ? encode(preparedParameters) : _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(...preparedParameters.map(({ encoded })=>encoded))\n    };\n}\n/** @internal */ function getArrayComponents(type) {\n    const matches = type.match(/^(.*)\\[(\\d+)?\\]$/);\n    return matches ? [\n        matches[2] ? Number(matches[2]) : null,\n        matches[1]\n    ] : undefined;\n}\n/** @internal */ function hasDynamicChild(param) {\n    const { type } = param;\n    if (type === \"string\") return true;\n    if (type === \"bytes\") return true;\n    if (type.endsWith(\"[]\")) return true;\n    if (type === \"tuple\") return param.components?.some(hasDynamicChild);\n    const arrayComponents = getArrayComponents(param.type);\n    if (arrayComponents && hasDynamicChild({\n        ...param,\n        type: arrayComponents[1]\n    })) return true;\n    return false;\n} //# sourceMappingURL=abiParameters.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2FiaVBhcmFtZXRlcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBcUQ7QUFDWjtBQUNKO0FBQ0U7QUFDTjtBQUNhO0FBQzlDLGNBQWMsR0FDUCxTQUFTTSxnQkFBZ0JDLE1BQU0sRUFBRUMsS0FBSyxFQUFFQyxPQUFPO0lBQ2xELE1BQU0sRUFBRUMsZUFBZSxFQUFFQyxjQUFjLEVBQUUsR0FBR0Y7SUFDNUMsTUFBTUcsa0JBQWtCQyxtQkFBbUJMLE1BQU1NLElBQUk7SUFDckQsSUFBSUYsaUJBQWlCO1FBQ2pCLE1BQU0sQ0FBQ0csUUFBUUQsS0FBSyxHQUFHRjtRQUN2QixPQUFPSSxZQUFZVCxRQUFRO1lBQUUsR0FBR0MsS0FBSztZQUFFTTtRQUFLLEdBQUc7WUFBRUo7WUFBaUJLO1lBQVFKO1FBQWU7SUFDN0Y7SUFDQSxJQUFJSCxNQUFNTSxJQUFJLEtBQUssU0FDZixPQUFPRyxZQUFZVixRQUFRQyxPQUFPO1FBQzlCRTtRQUNBQztJQUNKO0lBQ0osSUFBSUgsTUFBTU0sSUFBSSxLQUFLLFdBQ2YsT0FBT0ksY0FBY1gsUUFBUTtRQUFFWSxVQUFVVDtJQUFnQjtJQUM3RCxJQUFJRixNQUFNTSxJQUFJLEtBQUssUUFDZixPQUFPTSxXQUFXYjtJQUN0QixJQUFJQyxNQUFNTSxJQUFJLENBQUNPLFVBQVUsQ0FBQyxVQUN0QixPQUFPQyxZQUFZZixRQUFRQyxPQUFPO1FBQUVHO0lBQWU7SUFDdkQsSUFBSUgsTUFBTU0sSUFBSSxDQUFDTyxVQUFVLENBQUMsV0FBV2IsTUFBTU0sSUFBSSxDQUFDTyxVQUFVLENBQUMsUUFDdkQsT0FBT0UsYUFBYWhCLFFBQVFDO0lBQ2hDLElBQUlBLE1BQU1NLElBQUksS0FBSyxVQUNmLE9BQU9VLGFBQWFqQixRQUFRO1FBQUVJO0lBQWU7SUFDakQsTUFBTSxJQUFJWCwrREFBOEIsQ0FBQ1EsTUFBTU0sSUFBSTtBQUN2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L19lc20vY29yZS9pbnRlcm5hbC9hYmlQYXJhbWV0ZXJzLmpzP2VhOTkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQWJpUGFyYW1ldGVycyBmcm9tICcuLi9BYmlQYXJhbWV0ZXJzLmpzJztcbmltcG9ydCAqIGFzIEFkZHJlc3MgZnJvbSAnLi4vQWRkcmVzcy5qcyc7XG5pbXBvcnQgKiBhcyBCeXRlcyBmcm9tICcuLi9CeXRlcy5qcyc7XG5pbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSAnLi4vRXJyb3JzLmpzJztcbmltcG9ydCAqIGFzIEhleCBmcm9tICcuLi9IZXguanMnO1xuaW1wb3J0IHsgaW50ZWdlclJlZ2V4IH0gZnJvbSAnLi4vU29saWRpdHkuanMnO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVBhcmFtZXRlcihjdXJzb3IsIHBhcmFtLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBjaGVja3N1bUFkZHJlc3MsIHN0YXRpY1Bvc2l0aW9uIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGFycmF5Q29tcG9uZW50cyA9IGdldEFycmF5Q29tcG9uZW50cyhwYXJhbS50eXBlKTtcbiAgICBpZiAoYXJyYXlDb21wb25lbnRzKSB7XG4gICAgICAgIGNvbnN0IFtsZW5ndGgsIHR5cGVdID0gYXJyYXlDb21wb25lbnRzO1xuICAgICAgICByZXR1cm4gZGVjb2RlQXJyYXkoY3Vyc29yLCB7IC4uLnBhcmFtLCB0eXBlIH0sIHsgY2hlY2tzdW1BZGRyZXNzLCBsZW5ndGgsIHN0YXRpY1Bvc2l0aW9uIH0pO1xuICAgIH1cbiAgICBpZiAocGFyYW0udHlwZSA9PT0gJ3R1cGxlJylcbiAgICAgICAgcmV0dXJuIGRlY29kZVR1cGxlKGN1cnNvciwgcGFyYW0sIHtcbiAgICAgICAgICAgIGNoZWNrc3VtQWRkcmVzcyxcbiAgICAgICAgICAgIHN0YXRpY1Bvc2l0aW9uLFxuICAgICAgICB9KTtcbiAgICBpZiAocGFyYW0udHlwZSA9PT0gJ2FkZHJlc3MnKVxuICAgICAgICByZXR1cm4gZGVjb2RlQWRkcmVzcyhjdXJzb3IsIHsgY2hlY2tzdW06IGNoZWNrc3VtQWRkcmVzcyB9KTtcbiAgICBpZiAocGFyYW0udHlwZSA9PT0gJ2Jvb2wnKVxuICAgICAgICByZXR1cm4gZGVjb2RlQm9vbChjdXJzb3IpO1xuICAgIGlmIChwYXJhbS50eXBlLnN0YXJ0c1dpdGgoJ2J5dGVzJykpXG4gICAgICAgIHJldHVybiBkZWNvZGVCeXRlcyhjdXJzb3IsIHBhcmFtLCB7IHN0YXRpY1Bvc2l0aW9uIH0pO1xuICAgIGlmIChwYXJhbS50eXBlLnN0YXJ0c1dpdGgoJ3VpbnQnKSB8fCBwYXJhbS50eXBlLnN0YXJ0c1dpdGgoJ2ludCcpKVxuICAgICAgICByZXR1cm4gZGVjb2RlTnVtYmVyKGN1cnNvciwgcGFyYW0pO1xuICAgIGlmIChwYXJhbS50eXBlID09PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIGRlY29kZVN0cmluZyhjdXJzb3IsIHsgc3RhdGljUG9zaXRpb24gfSk7XG4gICAgdGhyb3cgbmV3IEFiaVBhcmFtZXRlcnMuSW52YWxpZFR5cGVFcnJvcihwYXJhbS50eXBlKTtcbn1cbmNvbnN0IHNpemVPZkxlbmd0aCA9IDMyO1xuY29uc3Qgc2l6ZU9mT2Zmc2V0ID0gMzI7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlQWRkcmVzcyhjdXJzb3IsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgY2hlY2tzdW0gPSBmYWxzZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCB2YWx1ZSA9IGN1cnNvci5yZWFkQnl0ZXMoMzIpO1xuICAgIGNvbnN0IHdyYXAgPSAoYWRkcmVzcykgPT4gY2hlY2tzdW0gPyBBZGRyZXNzLmNoZWNrc3VtKGFkZHJlc3MpIDogYWRkcmVzcztcbiAgICByZXR1cm4gW3dyYXAoSGV4LmZyb21CeXRlcyhCeXRlcy5zbGljZSh2YWx1ZSwgLTIwKSkpLCAzMl07XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlQXJyYXkoY3Vyc29yLCBwYXJhbSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgY2hlY2tzdW1BZGRyZXNzLCBsZW5ndGgsIHN0YXRpY1Bvc2l0aW9uIH0gPSBvcHRpb25zO1xuICAgIC8vIElmIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5IGlzIG5vdCBrbm93biBpbiBhZHZhbmNlIChkeW5hbWljIGFycmF5KSxcbiAgICAvLyB0aGlzIG1lYW5zIHdlIHdpbGwgbmVlZCB0byB3b25kZXIgb2ZmIHRvIHRoZSBwb2ludGVyIGFuZCBkZWNvZGUuXG4gICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgLy8gRGVhbGluZyB3aXRoIGEgZHluYW1pYyB0eXBlLCBzbyBnZXQgdGhlIG9mZnNldCBvZiB0aGUgYXJyYXkgZGF0YS5cbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gQnl0ZXMudG9OdW1iZXIoY3Vyc29yLnJlYWRCeXRlcyhzaXplT2ZPZmZzZXQpKTtcbiAgICAgICAgLy8gU3RhcnQgaXMgdGhlIHN0YXRpYyBwb3NpdGlvbiBvZiBjdXJyZW50IHNsb3QgKyBvZmZzZXQuXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gc3RhdGljUG9zaXRpb24gKyBvZmZzZXQ7XG4gICAgICAgIGNvbnN0IHN0YXJ0T2ZEYXRhID0gc3RhcnQgKyBzaXplT2ZMZW5ndGg7XG4gICAgICAgIC8vIEdldCB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheSBmcm9tIHRoZSBvZmZzZXQuXG4gICAgICAgIGN1cnNvci5zZXRQb3NpdGlvbihzdGFydCk7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IEJ5dGVzLnRvTnVtYmVyKGN1cnNvci5yZWFkQnl0ZXMoc2l6ZU9mTGVuZ3RoKSk7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBhcnJheSBoYXMgYW55IGR5bmFtaWMgY2hpbGRyZW4uXG4gICAgICAgIGNvbnN0IGR5bmFtaWNDaGlsZCA9IGhhc0R5bmFtaWNDaGlsZChwYXJhbSk7XG4gICAgICAgIGxldCBjb25zdW1lZCA9IDA7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIC8vIElmIGFueSBvZiB0aGUgY2hpbGRyZW4gaXMgZHluYW1pYywgdGhlbiBhbGwgZWxlbWVudHMgd2lsbCBiZSBvZmZzZXQgcG9pbnRlciwgdGh1cyBzaXplIG9mIG9uZSBzbG90ICgzMiBieXRlcykuXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIGVsZW1lbnRzIHdpbGwgYmUgdGhlIHNpemUgb2YgdGhlaXIgZW5jb2RpbmcgKGNvbnN1bWVkIGJ5dGVzKS5cbiAgICAgICAgICAgIGN1cnNvci5zZXRQb3NpdGlvbihzdGFydE9mRGF0YSArIChkeW5hbWljQ2hpbGQgPyBpICogMzIgOiBjb25zdW1lZCkpO1xuICAgICAgICAgICAgY29uc3QgW2RhdGEsIGNvbnN1bWVkX10gPSBkZWNvZGVQYXJhbWV0ZXIoY3Vyc29yLCBwYXJhbSwge1xuICAgICAgICAgICAgICAgIGNoZWNrc3VtQWRkcmVzcyxcbiAgICAgICAgICAgICAgICBzdGF0aWNQb3NpdGlvbjogc3RhcnRPZkRhdGEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN1bWVkICs9IGNvbnN1bWVkXztcbiAgICAgICAgICAgIHZhbHVlLnB1c2goZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXMgd2UgaGF2ZSBnb25lIHdvbmRlcmluZywgcmVzdG9yZSB0byB0aGUgb3JpZ2luYWwgcG9zaXRpb24gKyBuZXh0IHNsb3QuXG4gICAgICAgIGN1cnNvci5zZXRQb3NpdGlvbihzdGF0aWNQb3NpdGlvbiArIDMyKTtcbiAgICAgICAgcmV0dXJuIFt2YWx1ZSwgMzJdO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheSBpcyBrbm93biBpbiBhZHZhbmNlLFxuICAgIC8vIGFuZCB0aGUgbGVuZ3RoIG9mIGFuIGVsZW1lbnQgZGVlcGx5IG5lc3RlZCBpbiB0aGUgYXJyYXkgaXMgbm90IGtub3duLFxuICAgIC8vIHdlIG5lZWQgdG8gZGVjb2RlIHRoZSBvZmZzZXQgb2YgdGhlIGFycmF5IGRhdGEuXG4gICAgaWYgKGhhc0R5bmFtaWNDaGlsZChwYXJhbSkpIHtcbiAgICAgICAgLy8gRGVhbGluZyB3aXRoIGR5bmFtaWMgdHlwZXMsIHNvIGdldCB0aGUgb2Zmc2V0IG9mIHRoZSBhcnJheSBkYXRhLlxuICAgICAgICBjb25zdCBvZmZzZXQgPSBCeXRlcy50b051bWJlcihjdXJzb3IucmVhZEJ5dGVzKHNpemVPZk9mZnNldCkpO1xuICAgICAgICAvLyBTdGFydCBpcyB0aGUgc3RhdGljIHBvc2l0aW9uIG9mIGN1cnJlbnQgc2xvdCArIG9mZnNldC5cbiAgICAgICAgY29uc3Qgc3RhcnQgPSBzdGF0aWNQb3NpdGlvbiArIG9mZnNldDtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgLy8gTW92ZSBjdXJzb3IgYWxvbmcgdG8gdGhlIG5leHQgc2xvdCAobmV4dCBvZmZzZXQgcG9pbnRlcikuXG4gICAgICAgICAgICBjdXJzb3Iuc2V0UG9zaXRpb24oc3RhcnQgKyBpICogMzIpO1xuICAgICAgICAgICAgY29uc3QgW2RhdGFdID0gZGVjb2RlUGFyYW1ldGVyKGN1cnNvciwgcGFyYW0sIHtcbiAgICAgICAgICAgICAgICBjaGVja3N1bUFkZHJlc3MsXG4gICAgICAgICAgICAgICAgc3RhdGljUG9zaXRpb246IHN0YXJ0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YWx1ZS5wdXNoKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFzIHdlIGhhdmUgZ29uZSB3b25kZXJpbmcsIHJlc3RvcmUgdG8gdGhlIG9yaWdpbmFsIHBvc2l0aW9uICsgbmV4dCBzbG90LlxuICAgICAgICBjdXJzb3Iuc2V0UG9zaXRpb24oc3RhdGljUG9zaXRpb24gKyAzMik7XG4gICAgICAgIHJldHVybiBbdmFsdWUsIDMyXTtcbiAgICB9XG4gICAgLy8gSWYgdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkgaXMga25vd24gaW4gYWR2YW5jZSBhbmQgdGhlIGFycmF5IGlzIGRlZXBseSBzdGF0aWMsXG4gICAgLy8gdGhlbiB3ZSBjYW4ganVzdCBkZWNvZGUgZWFjaCBlbGVtZW50IGluIHNlcXVlbmNlLlxuICAgIGxldCBjb25zdW1lZCA9IDA7XG4gICAgY29uc3QgdmFsdWUgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IFtkYXRhLCBjb25zdW1lZF9dID0gZGVjb2RlUGFyYW1ldGVyKGN1cnNvciwgcGFyYW0sIHtcbiAgICAgICAgICAgIGNoZWNrc3VtQWRkcmVzcyxcbiAgICAgICAgICAgIHN0YXRpY1Bvc2l0aW9uOiBzdGF0aWNQb3NpdGlvbiArIGNvbnN1bWVkLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3VtZWQgKz0gY29uc3VtZWRfO1xuICAgICAgICB2YWx1ZS5wdXNoKGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gW3ZhbHVlLCBjb25zdW1lZF07XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlQm9vbChjdXJzb3IpIHtcbiAgICByZXR1cm4gW0J5dGVzLnRvQm9vbGVhbihjdXJzb3IucmVhZEJ5dGVzKDMyKSwgeyBzaXplOiAzMiB9KSwgMzJdO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUJ5dGVzKGN1cnNvciwgcGFyYW0sIHsgc3RhdGljUG9zaXRpb24gfSkge1xuICAgIGNvbnN0IFtfLCBzaXplXSA9IHBhcmFtLnR5cGUuc3BsaXQoJ2J5dGVzJyk7XG4gICAgaWYgKCFzaXplKSB7XG4gICAgICAgIC8vIERlYWxpbmcgd2l0aCBkeW5hbWljIHR5cGVzLCBzbyBnZXQgdGhlIG9mZnNldCBvZiB0aGUgYnl0ZXMgZGF0YS5cbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gQnl0ZXMudG9OdW1iZXIoY3Vyc29yLnJlYWRCeXRlcygzMikpO1xuICAgICAgICAvLyBTZXQgcG9zaXRpb24gb2YgdGhlIGN1cnNvciB0byBzdGFydCBvZiBieXRlcyBkYXRhLlxuICAgICAgICBjdXJzb3Iuc2V0UG9zaXRpb24oc3RhdGljUG9zaXRpb24gKyBvZmZzZXQpO1xuICAgICAgICBjb25zdCBsZW5ndGggPSBCeXRlcy50b051bWJlcihjdXJzb3IucmVhZEJ5dGVzKDMyKSk7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIGxlbmd0aCwgd2UgaGF2ZSB6ZXJvIGRhdGEuXG4gICAgICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIEFzIHdlIGhhdmUgZ29uZSB3b25kZXJpbmcsIHJlc3RvcmUgdG8gdGhlIG9yaWdpbmFsIHBvc2l0aW9uICsgbmV4dCBzbG90LlxuICAgICAgICAgICAgY3Vyc29yLnNldFBvc2l0aW9uKHN0YXRpY1Bvc2l0aW9uICsgMzIpO1xuICAgICAgICAgICAgcmV0dXJuIFsnMHgnLCAzMl07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IGN1cnNvci5yZWFkQnl0ZXMobGVuZ3RoKTtcbiAgICAgICAgLy8gQXMgd2UgaGF2ZSBnb25lIHdvbmRlcmluZywgcmVzdG9yZSB0byB0aGUgb3JpZ2luYWwgcG9zaXRpb24gKyBuZXh0IHNsb3QuXG4gICAgICAgIGN1cnNvci5zZXRQb3NpdGlvbihzdGF0aWNQb3NpdGlvbiArIDMyKTtcbiAgICAgICAgcmV0dXJuIFtIZXguZnJvbUJ5dGVzKGRhdGEpLCAzMl07XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gSGV4LmZyb21CeXRlcyhjdXJzb3IucmVhZEJ5dGVzKE51bWJlci5wYXJzZUludChzaXplLCAxMCksIDMyKSk7XG4gICAgcmV0dXJuIFt2YWx1ZSwgMzJdO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZU51bWJlcihjdXJzb3IsIHBhcmFtKSB7XG4gICAgY29uc3Qgc2lnbmVkID0gcGFyYW0udHlwZS5zdGFydHNXaXRoKCdpbnQnKTtcbiAgICBjb25zdCBzaXplID0gTnVtYmVyLnBhcnNlSW50KHBhcmFtLnR5cGUuc3BsaXQoJ2ludCcpWzFdIHx8ICcyNTYnLCAxMCk7XG4gICAgY29uc3QgdmFsdWUgPSBjdXJzb3IucmVhZEJ5dGVzKDMyKTtcbiAgICByZXR1cm4gW1xuICAgICAgICBzaXplID4gNDhcbiAgICAgICAgICAgID8gQnl0ZXMudG9CaWdJbnQodmFsdWUsIHsgc2lnbmVkIH0pXG4gICAgICAgICAgICA6IEJ5dGVzLnRvTnVtYmVyKHZhbHVlLCB7IHNpZ25lZCB9KSxcbiAgICAgICAgMzIsXG4gICAgXTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVUdXBsZShjdXJzb3IsIHBhcmFtLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBjaGVja3N1bUFkZHJlc3MsIHN0YXRpY1Bvc2l0aW9uIH0gPSBvcHRpb25zO1xuICAgIC8vIFR1cGxlcyBjYW4gaGF2ZSB1bm5hbWVkIGNvbXBvbmVudHMgKGkuZS4gdGhleSBhcmUgYXJyYXlzKSwgc28gd2UgbXVzdFxuICAgIC8vIGRldGVybWluZSB3aGV0aGVyIHRoZSB0dXBsZSBpcyBuYW1lZCBvciB1bm5hbWVkLiBJbiB0aGUgY2FzZSBvZiBhIG5hbWVkXG4gICAgLy8gdHVwbGUsIHRoZSB2YWx1ZSB3aWxsIGJlIGFuIG9iamVjdCB3aGVyZSBlYWNoIHByb3BlcnR5IGlzIHRoZSBuYW1lIG9mIHRoZVxuICAgIC8vIGNvbXBvbmVudC4gSW4gdGhlIGNhc2Ugb2YgYW4gdW5uYW1lZCB0dXBsZSwgdGhlIHZhbHVlIHdpbGwgYmUgYW4gYXJyYXkuXG4gICAgY29uc3QgaGFzVW5uYW1lZENoaWxkID0gcGFyYW0uY29tcG9uZW50cy5sZW5ndGggPT09IDAgfHwgcGFyYW0uY29tcG9uZW50cy5zb21lKCh7IG5hbWUgfSkgPT4gIW5hbWUpO1xuICAgIC8vIEluaXRpYWxpemUgdGhlIHZhbHVlIHRvIGFuIG9iamVjdCBvciBhbiBhcnJheSwgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlXG4gICAgLy8gdHVwbGUgaXMgbmFtZWQgb3IgdW5uYW1lZC5cbiAgICBjb25zdCB2YWx1ZSA9IGhhc1VubmFtZWRDaGlsZCA/IFtdIDoge307XG4gICAgbGV0IGNvbnN1bWVkID0gMDtcbiAgICAvLyBJZiB0aGUgdHVwbGUgaGFzIGEgZHluYW1pYyBjaGlsZCwgd2UgbXVzdCBmaXJzdCBkZWNvZGUgdGhlIG9mZnNldCB0byB0aGVcbiAgICAvLyB0dXBsZSBkYXRhLlxuICAgIGlmIChoYXNEeW5hbWljQ2hpbGQocGFyYW0pKSB7XG4gICAgICAgIC8vIERlYWxpbmcgd2l0aCBkeW5hbWljIHR5cGVzLCBzbyBnZXQgdGhlIG9mZnNldCBvZiB0aGUgdHVwbGUgZGF0YS5cbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gQnl0ZXMudG9OdW1iZXIoY3Vyc29yLnJlYWRCeXRlcyhzaXplT2ZPZmZzZXQpKTtcbiAgICAgICAgLy8gU3RhcnQgaXMgdGhlIHN0YXRpYyBwb3NpdGlvbiBvZiByZWZlcmVuY2luZyBzbG90ICsgb2Zmc2V0LlxuICAgICAgICBjb25zdCBzdGFydCA9IHN0YXRpY1Bvc2l0aW9uICsgb2Zmc2V0O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmFtLmNvbXBvbmVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IHBhcmFtLmNvbXBvbmVudHNbaV07XG4gICAgICAgICAgICBjdXJzb3Iuc2V0UG9zaXRpb24oc3RhcnQgKyBjb25zdW1lZCk7XG4gICAgICAgICAgICBjb25zdCBbZGF0YSwgY29uc3VtZWRfXSA9IGRlY29kZVBhcmFtZXRlcihjdXJzb3IsIGNvbXBvbmVudCwge1xuICAgICAgICAgICAgICAgIGNoZWNrc3VtQWRkcmVzcyxcbiAgICAgICAgICAgICAgICBzdGF0aWNQb3NpdGlvbjogc3RhcnQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN1bWVkICs9IGNvbnN1bWVkXztcbiAgICAgICAgICAgIHZhbHVlW2hhc1VubmFtZWRDaGlsZCA/IGkgOiBjb21wb25lbnQ/Lm5hbWVdID0gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBcyB3ZSBoYXZlIGdvbmUgd29uZGVyaW5nLCByZXN0b3JlIHRvIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiArIG5leHQgc2xvdC5cbiAgICAgICAgY3Vyc29yLnNldFBvc2l0aW9uKHN0YXRpY1Bvc2l0aW9uICsgMzIpO1xuICAgICAgICByZXR1cm4gW3ZhbHVlLCAzMl07XG4gICAgfVxuICAgIC8vIElmIHRoZSB0dXBsZSBoYXMgc3RhdGljIGNoaWxkcmVuLCB3ZSBjYW4ganVzdCBkZWNvZGUgZWFjaCBjb21wb25lbnRcbiAgICAvLyBpbiBzZXF1ZW5jZS5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmFtLmNvbXBvbmVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgY29tcG9uZW50ID0gcGFyYW0uY29tcG9uZW50c1tpXTtcbiAgICAgICAgY29uc3QgW2RhdGEsIGNvbnN1bWVkX10gPSBkZWNvZGVQYXJhbWV0ZXIoY3Vyc29yLCBjb21wb25lbnQsIHtcbiAgICAgICAgICAgIGNoZWNrc3VtQWRkcmVzcyxcbiAgICAgICAgICAgIHN0YXRpY1Bvc2l0aW9uLFxuICAgICAgICB9KTtcbiAgICAgICAgdmFsdWVbaGFzVW5uYW1lZENoaWxkID8gaSA6IGNvbXBvbmVudD8ubmFtZV0gPSBkYXRhO1xuICAgICAgICBjb25zdW1lZCArPSBjb25zdW1lZF87XG4gICAgfVxuICAgIHJldHVybiBbdmFsdWUsIGNvbnN1bWVkXTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVTdHJpbmcoY3Vyc29yLCB7IHN0YXRpY1Bvc2l0aW9uIH0pIHtcbiAgICAvLyBHZXQgb2Zmc2V0IHRvIHN0YXJ0IG9mIHN0cmluZyBkYXRhLlxuICAgIGNvbnN0IG9mZnNldCA9IEJ5dGVzLnRvTnVtYmVyKGN1cnNvci5yZWFkQnl0ZXMoMzIpKTtcbiAgICAvLyBTdGFydCBpcyB0aGUgc3RhdGljIHBvc2l0aW9uIG9mIGN1cnJlbnQgc2xvdCArIG9mZnNldC5cbiAgICBjb25zdCBzdGFydCA9IHN0YXRpY1Bvc2l0aW9uICsgb2Zmc2V0O1xuICAgIGN1cnNvci5zZXRQb3NpdGlvbihzdGFydCk7XG4gICAgY29uc3QgbGVuZ3RoID0gQnl0ZXMudG9OdW1iZXIoY3Vyc29yLnJlYWRCeXRlcygzMikpO1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIGxlbmd0aCwgd2UgaGF2ZSB6ZXJvIGRhdGEgKGVtcHR5IHN0cmluZykuXG4gICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjdXJzb3Iuc2V0UG9zaXRpb24oc3RhdGljUG9zaXRpb24gKyAzMik7XG4gICAgICAgIHJldHVybiBbJycsIDMyXTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IGN1cnNvci5yZWFkQnl0ZXMobGVuZ3RoLCAzMik7XG4gICAgY29uc3QgdmFsdWUgPSBCeXRlcy50b1N0cmluZyhCeXRlcy50cmltTGVmdChkYXRhKSk7XG4gICAgLy8gQXMgd2UgaGF2ZSBnb25lIHdvbmRlcmluZywgcmVzdG9yZSB0byB0aGUgb3JpZ2luYWwgcG9zaXRpb24gKyBuZXh0IHNsb3QuXG4gICAgY3Vyc29yLnNldFBvc2l0aW9uKHN0YXRpY1Bvc2l0aW9uICsgMzIpO1xuICAgIHJldHVybiBbdmFsdWUsIDMyXTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmVwYXJlUGFyYW1ldGVycyh7IGNoZWNrc3VtQWRkcmVzcywgcGFyYW1ldGVycywgdmFsdWVzLCB9KSB7XG4gICAgY29uc3QgcHJlcGFyZWRQYXJhbWV0ZXJzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJhbWV0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHByZXBhcmVkUGFyYW1ldGVycy5wdXNoKHByZXBhcmVQYXJhbWV0ZXIoe1xuICAgICAgICAgICAgY2hlY2tzdW1BZGRyZXNzLFxuICAgICAgICAgICAgcGFyYW1ldGVyOiBwYXJhbWV0ZXJzW2ldLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlc1tpXSxcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gcHJlcGFyZWRQYXJhbWV0ZXJzO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByZXBhcmVQYXJhbWV0ZXIoeyBjaGVja3N1bUFkZHJlc3MgPSBmYWxzZSwgcGFyYW1ldGVyOiBwYXJhbWV0ZXJfLCB2YWx1ZSwgfSkge1xuICAgIGNvbnN0IHBhcmFtZXRlciA9IHBhcmFtZXRlcl87XG4gICAgY29uc3QgYXJyYXlDb21wb25lbnRzID0gZ2V0QXJyYXlDb21wb25lbnRzKHBhcmFtZXRlci50eXBlKTtcbiAgICBpZiAoYXJyYXlDb21wb25lbnRzKSB7XG4gICAgICAgIGNvbnN0IFtsZW5ndGgsIHR5cGVdID0gYXJyYXlDb21wb25lbnRzO1xuICAgICAgICByZXR1cm4gZW5jb2RlQXJyYXkodmFsdWUsIHtcbiAgICAgICAgICAgIGNoZWNrc3VtQWRkcmVzcyxcbiAgICAgICAgICAgIGxlbmd0aCxcbiAgICAgICAgICAgIHBhcmFtZXRlcjoge1xuICAgICAgICAgICAgICAgIC4uLnBhcmFtZXRlcixcbiAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChwYXJhbWV0ZXIudHlwZSA9PT0gJ3R1cGxlJykge1xuICAgICAgICByZXR1cm4gZW5jb2RlVHVwbGUodmFsdWUsIHtcbiAgICAgICAgICAgIGNoZWNrc3VtQWRkcmVzcyxcbiAgICAgICAgICAgIHBhcmFtZXRlcjogcGFyYW1ldGVyLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHBhcmFtZXRlci50eXBlID09PSAnYWRkcmVzcycpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZUFkZHJlc3ModmFsdWUsIHtcbiAgICAgICAgICAgIGNoZWNrc3VtOiBjaGVja3N1bUFkZHJlc3MsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAocGFyYW1ldGVyLnR5cGUgPT09ICdib29sJykge1xuICAgICAgICByZXR1cm4gZW5jb2RlQm9vbGVhbih2YWx1ZSk7XG4gICAgfVxuICAgIGlmIChwYXJhbWV0ZXIudHlwZS5zdGFydHNXaXRoKCd1aW50JykgfHwgcGFyYW1ldGVyLnR5cGUuc3RhcnRzV2l0aCgnaW50JykpIHtcbiAgICAgICAgY29uc3Qgc2lnbmVkID0gcGFyYW1ldGVyLnR5cGUuc3RhcnRzV2l0aCgnaW50Jyk7XG4gICAgICAgIGNvbnN0IFssICwgc2l6ZSA9ICcyNTYnXSA9IGludGVnZXJSZWdleC5leGVjKHBhcmFtZXRlci50eXBlKSA/PyBbXTtcbiAgICAgICAgcmV0dXJuIGVuY29kZU51bWJlcih2YWx1ZSwge1xuICAgICAgICAgICAgc2lnbmVkLFxuICAgICAgICAgICAgc2l6ZTogTnVtYmVyKHNpemUpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHBhcmFtZXRlci50eXBlLnN0YXJ0c1dpdGgoJ2J5dGVzJykpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZUJ5dGVzKHZhbHVlLCB7IHR5cGU6IHBhcmFtZXRlci50eXBlIH0pO1xuICAgIH1cbiAgICBpZiAocGFyYW1ldGVyLnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVTdHJpbmcodmFsdWUpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgQWJpUGFyYW1ldGVycy5JbnZhbGlkVHlwZUVycm9yKHBhcmFtZXRlci50eXBlKTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGUocHJlcGFyZWRQYXJhbWV0ZXJzKSB7XG4gICAgLy8gMS4gQ29tcHV0ZSB0aGUgc2l6ZSBvZiB0aGUgc3RhdGljIHBhcnQgb2YgdGhlIHBhcmFtZXRlcnMuXG4gICAgbGV0IHN0YXRpY1NpemUgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlcGFyZWRQYXJhbWV0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHsgZHluYW1pYywgZW5jb2RlZCB9ID0gcHJlcGFyZWRQYXJhbWV0ZXJzW2ldO1xuICAgICAgICBpZiAoZHluYW1pYylcbiAgICAgICAgICAgIHN0YXRpY1NpemUgKz0gMzI7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHN0YXRpY1NpemUgKz0gSGV4LnNpemUoZW5jb2RlZCk7XG4gICAgfVxuICAgIC8vIDIuIFNwbGl0IHRoZSBwYXJhbWV0ZXJzIGludG8gc3RhdGljIGFuZCBkeW5hbWljIHBhcnRzLlxuICAgIGNvbnN0IHN0YXRpY1BhcmFtZXRlcnMgPSBbXTtcbiAgICBjb25zdCBkeW5hbWljUGFyYW1ldGVycyA9IFtdO1xuICAgIGxldCBkeW5hbWljU2l6ZSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVwYXJlZFBhcmFtZXRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgeyBkeW5hbWljLCBlbmNvZGVkIH0gPSBwcmVwYXJlZFBhcmFtZXRlcnNbaV07XG4gICAgICAgIGlmIChkeW5hbWljKSB7XG4gICAgICAgICAgICBzdGF0aWNQYXJhbWV0ZXJzLnB1c2goSGV4LmZyb21OdW1iZXIoc3RhdGljU2l6ZSArIGR5bmFtaWNTaXplLCB7IHNpemU6IDMyIH0pKTtcbiAgICAgICAgICAgIGR5bmFtaWNQYXJhbWV0ZXJzLnB1c2goZW5jb2RlZCk7XG4gICAgICAgICAgICBkeW5hbWljU2l6ZSArPSBIZXguc2l6ZShlbmNvZGVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRpY1BhcmFtZXRlcnMucHVzaChlbmNvZGVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyAzLiBDb25jYXRlbmF0ZSBzdGF0aWMgYW5kIGR5bmFtaWMgcGFydHMuXG4gICAgcmV0dXJuIEhleC5jb25jYXQoLi4uc3RhdGljUGFyYW1ldGVycywgLi4uZHluYW1pY1BhcmFtZXRlcnMpO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZUFkZHJlc3ModmFsdWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGNoZWNrc3VtID0gZmFsc2UgfSA9IG9wdGlvbnM7XG4gICAgQWRkcmVzcy5hc3NlcnQodmFsdWUsIHsgc3RyaWN0OiBjaGVja3N1bSB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkeW5hbWljOiBmYWxzZSxcbiAgICAgICAgZW5jb2RlZDogSGV4LnBhZExlZnQodmFsdWUudG9Mb3dlckNhc2UoKSksXG4gICAgfTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVBcnJheSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgY2hlY2tzdW1BZGRyZXNzLCBsZW5ndGgsIHBhcmFtZXRlciB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBkeW5hbWljID0gbGVuZ3RoID09PSBudWxsO1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpXG4gICAgICAgIHRocm93IG5ldyBBYmlQYXJhbWV0ZXJzLkludmFsaWRBcnJheUVycm9yKHZhbHVlKTtcbiAgICBpZiAoIWR5bmFtaWMgJiYgdmFsdWUubGVuZ3RoICE9PSBsZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBBYmlQYXJhbWV0ZXJzLkFycmF5TGVuZ3RoTWlzbWF0Y2hFcnJvcih7XG4gICAgICAgICAgICBleHBlY3RlZExlbmd0aDogbGVuZ3RoLFxuICAgICAgICAgICAgZ2l2ZW5MZW5ndGg6IHZhbHVlLmxlbmd0aCxcbiAgICAgICAgICAgIHR5cGU6IGAke3BhcmFtZXRlci50eXBlfVske2xlbmd0aH1dYCxcbiAgICAgICAgfSk7XG4gICAgbGV0IGR5bmFtaWNDaGlsZCA9IGZhbHNlO1xuICAgIGNvbnN0IHByZXBhcmVkUGFyYW1ldGVycyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcHJlcGFyZWRQYXJhbSA9IHByZXBhcmVQYXJhbWV0ZXIoe1xuICAgICAgICAgICAgY2hlY2tzdW1BZGRyZXNzLFxuICAgICAgICAgICAgcGFyYW1ldGVyLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlW2ldLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHByZXBhcmVkUGFyYW0uZHluYW1pYylcbiAgICAgICAgICAgIGR5bmFtaWNDaGlsZCA9IHRydWU7XG4gICAgICAgIHByZXBhcmVkUGFyYW1ldGVycy5wdXNoKHByZXBhcmVkUGFyYW0pO1xuICAgIH1cbiAgICBpZiAoZHluYW1pYyB8fCBkeW5hbWljQ2hpbGQpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGVuY29kZShwcmVwYXJlZFBhcmFtZXRlcnMpO1xuICAgICAgICBpZiAoZHluYW1pYykge1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gSGV4LmZyb21OdW1iZXIocHJlcGFyZWRQYXJhbWV0ZXJzLmxlbmd0aCwgeyBzaXplOiAzMiB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZHluYW1pYzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbmNvZGVkOiBwcmVwYXJlZFBhcmFtZXRlcnMubGVuZ3RoID4gMCA/IEhleC5jb25jYXQobGVuZ3RoLCBkYXRhKSA6IGxlbmd0aCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGR5bmFtaWNDaGlsZClcbiAgICAgICAgICAgIHJldHVybiB7IGR5bmFtaWM6IHRydWUsIGVuY29kZWQ6IGRhdGEgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZHluYW1pYzogZmFsc2UsXG4gICAgICAgIGVuY29kZWQ6IEhleC5jb25jYXQoLi4ucHJlcGFyZWRQYXJhbWV0ZXJzLm1hcCgoeyBlbmNvZGVkIH0pID0+IGVuY29kZWQpKSxcbiAgICB9O1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZUJ5dGVzKHZhbHVlLCB7IHR5cGUgfSkge1xuICAgIGNvbnN0IFssIHBhcmFtZXRlcnNpemVdID0gdHlwZS5zcGxpdCgnYnl0ZXMnKTtcbiAgICBjb25zdCBieXRlc1NpemUgPSBIZXguc2l6ZSh2YWx1ZSk7XG4gICAgaWYgKCFwYXJhbWV0ZXJzaXplKSB7XG4gICAgICAgIGxldCB2YWx1ZV8gPSB2YWx1ZTtcbiAgICAgICAgLy8gSWYgdGhlIHNpemUgaXMgbm90IGRpdmlzaWJsZSBieSAzMiBieXRlcywgcGFkIHRoZSBlbmRcbiAgICAgICAgLy8gd2l0aCBlbXB0eSBieXRlcyB0byB0aGUgY2VpbGluZyAzMiBieXRlcy5cbiAgICAgICAgaWYgKGJ5dGVzU2l6ZSAlIDMyICE9PSAwKVxuICAgICAgICAgICAgdmFsdWVfID0gSGV4LnBhZFJpZ2h0KHZhbHVlXywgTWF0aC5jZWlsKCh2YWx1ZS5sZW5ndGggLSAyKSAvIDIgLyAzMikgKiAzMik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkeW5hbWljOiB0cnVlLFxuICAgICAgICAgICAgZW5jb2RlZDogSGV4LmNvbmNhdChIZXgucGFkTGVmdChIZXguZnJvbU51bWJlcihieXRlc1NpemUsIHsgc2l6ZTogMzIgfSkpLCB2YWx1ZV8pLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoYnl0ZXNTaXplICE9PSBOdW1iZXIucGFyc2VJbnQocGFyYW1ldGVyc2l6ZSwgMTApKVxuICAgICAgICB0aHJvdyBuZXcgQWJpUGFyYW1ldGVycy5CeXRlc1NpemVNaXNtYXRjaEVycm9yKHtcbiAgICAgICAgICAgIGV4cGVjdGVkU2l6ZTogTnVtYmVyLnBhcnNlSW50KHBhcmFtZXRlcnNpemUsIDEwKSxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICB9KTtcbiAgICByZXR1cm4geyBkeW5hbWljOiBmYWxzZSwgZW5jb2RlZDogSGV4LnBhZFJpZ2h0KHZhbHVlKSB9O1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZUJvb2xlYW4odmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnYm9vbGVhbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcnMuQmFzZUVycm9yKGBJbnZhbGlkIGJvb2xlYW4gdmFsdWU6IFwiJHt2YWx1ZX1cIiAodHlwZTogJHt0eXBlb2YgdmFsdWV9KS4gRXhwZWN0ZWQ6IFxcYHRydWVcXGAgb3IgXFxgZmFsc2VcXGAuYCk7XG4gICAgcmV0dXJuIHsgZHluYW1pYzogZmFsc2UsIGVuY29kZWQ6IEhleC5wYWRMZWZ0KEhleC5mcm9tQm9vbGVhbih2YWx1ZSkpIH07XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlTnVtYmVyKHZhbHVlLCB7IHNpZ25lZCwgc2l6ZSB9KSB7XG4gICAgaWYgKHR5cGVvZiBzaXplID09PSAnbnVtYmVyJykge1xuICAgICAgICBjb25zdCBtYXggPSAybiAqKiAoQmlnSW50KHNpemUpIC0gKHNpZ25lZCA/IDFuIDogMG4pKSAtIDFuO1xuICAgICAgICBjb25zdCBtaW4gPSBzaWduZWQgPyAtbWF4IC0gMW4gOiAwbjtcbiAgICAgICAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEhleC5JbnRlZ2VyT3V0T2ZSYW5nZUVycm9yKHtcbiAgICAgICAgICAgICAgICBtYXg6IG1heC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIG1pbjogbWluLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgc2lnbmVkLFxuICAgICAgICAgICAgICAgIHNpemU6IHNpemUgLyA4LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZS50b1N0cmluZygpLFxuICAgICAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGR5bmFtaWM6IGZhbHNlLFxuICAgICAgICBlbmNvZGVkOiBIZXguZnJvbU51bWJlcih2YWx1ZSwge1xuICAgICAgICAgICAgc2l6ZTogMzIsXG4gICAgICAgICAgICBzaWduZWQsXG4gICAgICAgIH0pLFxuICAgIH07XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlU3RyaW5nKHZhbHVlKSB7XG4gICAgY29uc3QgaGV4VmFsdWUgPSBIZXguZnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgY29uc3QgcGFydHNMZW5ndGggPSBNYXRoLmNlaWwoSGV4LnNpemUoaGV4VmFsdWUpIC8gMzIpO1xuICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0c0xlbmd0aDsgaSsrKSB7XG4gICAgICAgIHBhcnRzLnB1c2goSGV4LnBhZFJpZ2h0KEhleC5zbGljZShoZXhWYWx1ZSwgaSAqIDMyLCAoaSArIDEpICogMzIpKSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGR5bmFtaWM6IHRydWUsXG4gICAgICAgIGVuY29kZWQ6IEhleC5jb25jYXQoSGV4LnBhZFJpZ2h0KEhleC5mcm9tTnVtYmVyKEhleC5zaXplKGhleFZhbHVlKSwgeyBzaXplOiAzMiB9KSksIC4uLnBhcnRzKSxcbiAgICB9O1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZVR1cGxlKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBjaGVja3N1bUFkZHJlc3MsIHBhcmFtZXRlciB9ID0gb3B0aW9ucztcbiAgICBsZXQgZHluYW1pYyA9IGZhbHNlO1xuICAgIGNvbnN0IHByZXBhcmVkUGFyYW1ldGVycyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyYW1ldGVyLmNvbXBvbmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcGFyYW1fID0gcGFyYW1ldGVyLmNvbXBvbmVudHNbaV07XG4gICAgICAgIGNvbnN0IGluZGV4ID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyBpIDogcGFyYW1fLm5hbWU7XG4gICAgICAgIGNvbnN0IHByZXBhcmVkUGFyYW0gPSBwcmVwYXJlUGFyYW1ldGVyKHtcbiAgICAgICAgICAgIGNoZWNrc3VtQWRkcmVzcyxcbiAgICAgICAgICAgIHBhcmFtZXRlcjogcGFyYW1fLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlW2luZGV4XSxcbiAgICAgICAgfSk7XG4gICAgICAgIHByZXBhcmVkUGFyYW1ldGVycy5wdXNoKHByZXBhcmVkUGFyYW0pO1xuICAgICAgICBpZiAocHJlcGFyZWRQYXJhbS5keW5hbWljKVxuICAgICAgICAgICAgZHluYW1pYyA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGR5bmFtaWMsXG4gICAgICAgIGVuY29kZWQ6IGR5bmFtaWNcbiAgICAgICAgICAgID8gZW5jb2RlKHByZXBhcmVkUGFyYW1ldGVycylcbiAgICAgICAgICAgIDogSGV4LmNvbmNhdCguLi5wcmVwYXJlZFBhcmFtZXRlcnMubWFwKCh7IGVuY29kZWQgfSkgPT4gZW5jb2RlZCkpLFxuICAgIH07XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXJyYXlDb21wb25lbnRzKHR5cGUpIHtcbiAgICBjb25zdCBtYXRjaGVzID0gdHlwZS5tYXRjaCgvXiguKilcXFsoXFxkKyk/XFxdJC8pO1xuICAgIHJldHVybiBtYXRjaGVzXG4gICAgICAgID8gLy8gUmV0dXJuIGBudWxsYCBpZiB0aGUgYXJyYXkgaXMgZHluYW1pYy5cbiAgICAgICAgICAgIFttYXRjaGVzWzJdID8gTnVtYmVyKG1hdGNoZXNbMl0pIDogbnVsbCwgbWF0Y2hlc1sxXV1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gaGFzRHluYW1pY0NoaWxkKHBhcmFtKSB7XG4gICAgY29uc3QgeyB0eXBlIH0gPSBwYXJhbTtcbiAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmICh0eXBlID09PSAnYnl0ZXMnKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAodHlwZS5lbmRzV2l0aCgnW10nKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKHR5cGUgPT09ICd0dXBsZScpXG4gICAgICAgIHJldHVybiBwYXJhbS5jb21wb25lbnRzPy5zb21lKGhhc0R5bmFtaWNDaGlsZCk7XG4gICAgY29uc3QgYXJyYXlDb21wb25lbnRzID0gZ2V0QXJyYXlDb21wb25lbnRzKHBhcmFtLnR5cGUpO1xuICAgIGlmIChhcnJheUNvbXBvbmVudHMgJiZcbiAgICAgICAgaGFzRHluYW1pY0NoaWxkKHtcbiAgICAgICAgICAgIC4uLnBhcmFtLFxuICAgICAgICAgICAgdHlwZTogYXJyYXlDb21wb25lbnRzWzFdLFxuICAgICAgICB9KSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWJpUGFyYW1ldGVycy5qcy5tYXAiXSwibmFtZXMiOlsiQWJpUGFyYW1ldGVycyIsIkFkZHJlc3MiLCJCeXRlcyIsIkVycm9ycyIsIkhleCIsImludGVnZXJSZWdleCIsImRlY29kZVBhcmFtZXRlciIsImN1cnNvciIsInBhcmFtIiwib3B0aW9ucyIsImNoZWNrc3VtQWRkcmVzcyIsInN0YXRpY1Bvc2l0aW9uIiwiYXJyYXlDb21wb25lbnRzIiwiZ2V0QXJyYXlDb21wb25lbnRzIiwidHlwZSIsImxlbmd0aCIsImRlY29kZUFycmF5IiwiZGVjb2RlVHVwbGUiLCJkZWNvZGVBZGRyZXNzIiwiY2hlY2tzdW0iLCJkZWNvZGVCb29sIiwic3RhcnRzV2l0aCIsImRlY29kZUJ5dGVzIiwiZGVjb2RlTnVtYmVyIiwiZGVjb2RlU3RyaW5nIiwiSW52YWxpZFR5cGVFcnJvciIsInNpemVPZkxlbmd0aCIsInNpemVPZk9mZnNldCIsInZhbHVlIiwicmVhZEJ5dGVzIiwid3JhcCIsImFkZHJlc3MiLCJmcm9tQnl0ZXMiLCJzbGljZSIsIm9mZnNldCIsInRvTnVtYmVyIiwic3RhcnQiLCJzdGFydE9mRGF0YSIsInNldFBvc2l0aW9uIiwiZHluYW1pY0NoaWxkIiwiaGFzRHluYW1pY0NoaWxkIiwiY29uc3VtZWQiLCJpIiwiZGF0YSIsImNvbnN1bWVkXyIsInB1c2giLCJ0b0Jvb2xlYW4iLCJzaXplIiwiXyIsInNwbGl0IiwiTnVtYmVyIiwicGFyc2VJbnQiLCJzaWduZWQiLCJ0b0JpZ0ludCIsImhhc1VubmFtZWRDaGlsZCIsImNvbXBvbmVudHMiLCJzb21lIiwibmFtZSIsImNvbXBvbmVudCIsInRvU3RyaW5nIiwidHJpbUxlZnQiLCJwcmVwYXJlUGFyYW1ldGVycyIsInBhcmFtZXRlcnMiLCJ2YWx1ZXMiLCJwcmVwYXJlZFBhcmFtZXRlcnMiLCJwcmVwYXJlUGFyYW1ldGVyIiwicGFyYW1ldGVyIiwicGFyYW1ldGVyXyIsImVuY29kZUFycmF5IiwiZW5jb2RlVHVwbGUiLCJlbmNvZGVBZGRyZXNzIiwiZW5jb2RlQm9vbGVhbiIsImV4ZWMiLCJlbmNvZGVOdW1iZXIiLCJlbmNvZGVCeXRlcyIsImVuY29kZVN0cmluZyIsImVuY29kZSIsInN0YXRpY1NpemUiLCJkeW5hbWljIiwiZW5jb2RlZCIsInN0YXRpY1BhcmFtZXRlcnMiLCJkeW5hbWljUGFyYW1ldGVycyIsImR5bmFtaWNTaXplIiwiZnJvbU51bWJlciIsImNvbmNhdCIsImFzc2VydCIsInN0cmljdCIsInBhZExlZnQiLCJ0b0xvd2VyQ2FzZSIsIkFycmF5IiwiaXNBcnJheSIsIkludmFsaWRBcnJheUVycm9yIiwiQXJyYXlMZW5ndGhNaXNtYXRjaEVycm9yIiwiZXhwZWN0ZWRMZW5ndGgiLCJnaXZlbkxlbmd0aCIsInByZXBhcmVkUGFyYW0iLCJtYXAiLCJwYXJhbWV0ZXJzaXplIiwiYnl0ZXNTaXplIiwidmFsdWVfIiwicGFkUmlnaHQiLCJNYXRoIiwiY2VpbCIsIkJ5dGVzU2l6ZU1pc21hdGNoRXJyb3IiLCJleHBlY3RlZFNpemUiLCJCYXNlRXJyb3IiLCJmcm9tQm9vbGVhbiIsIm1heCIsIkJpZ0ludCIsIm1pbiIsIkludGVnZXJPdXRPZlJhbmdlRXJyb3IiLCJoZXhWYWx1ZSIsImZyb21TdHJpbmciLCJwYXJ0c0xlbmd0aCIsInBhcnRzIiwicGFyYW1fIiwiaW5kZXgiLCJtYXRjaGVzIiwibWF0Y2giLCJ1bmRlZmluZWQiLCJlbmRzV2l0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/internal/abiParameters.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/internal/bytes.js":
/*!*****************************************************!*\
  !*** ./node_modules/ox/_esm/core/internal/bytes.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertEndOffset: () => (/* binding */ assertEndOffset),\n/* harmony export */   assertSize: () => (/* binding */ assertSize),\n/* harmony export */   assertStartOffset: () => (/* binding */ assertStartOffset),\n/* harmony export */   charCodeMap: () => (/* binding */ charCodeMap),\n/* harmony export */   charCodeToBase16: () => (/* binding */ charCodeToBase16),\n/* harmony export */   pad: () => (/* binding */ pad),\n/* harmony export */   trim: () => (/* binding */ trim)\n/* harmony export */ });\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/Bytes.js\");\n\n/** @internal */ function assertSize(bytes, size_) {\n    if (_Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(bytes) > size_) throw new _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.SizeOverflowError({\n        givenSize: _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(bytes),\n        maxSize: size_\n    });\n}\n/** @internal */ function assertStartOffset(value, start) {\n    if (typeof start === \"number\" && start > 0 && start > _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(value) - 1) throw new _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.SliceOffsetOutOfBoundsError({\n        offset: start,\n        position: \"start\",\n        size: _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(value)\n    });\n}\n/** @internal */ function assertEndOffset(value, start, end) {\n    if (typeof start === \"number\" && typeof end === \"number\" && _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(value) !== end - start) {\n        throw new _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.SliceOffsetOutOfBoundsError({\n            offset: end,\n            position: \"end\",\n            size: _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(value)\n        });\n    }\n}\n/** @internal */ const charCodeMap = {\n    zero: 48,\n    nine: 57,\n    A: 65,\n    F: 70,\n    a: 97,\n    f: 102\n};\n/** @internal */ function charCodeToBase16(char) {\n    if (char >= charCodeMap.zero && char <= charCodeMap.nine) return char - charCodeMap.zero;\n    if (char >= charCodeMap.A && char <= charCodeMap.F) return char - (charCodeMap.A - 10);\n    if (char >= charCodeMap.a && char <= charCodeMap.f) return char - (charCodeMap.a - 10);\n    return undefined;\n}\n/** @internal */ function pad(bytes, options = {}) {\n    const { dir, size = 32 } = options;\n    if (size === 0) return bytes;\n    if (bytes.length > size) throw new _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.SizeExceedsPaddingSizeError({\n        size: bytes.length,\n        targetSize: size,\n        type: \"Bytes\"\n    });\n    const paddedBytes = new Uint8Array(size);\n    for(let i = 0; i < size; i++){\n        const padEnd = dir === \"right\";\n        paddedBytes[padEnd ? i : size - i - 1] = bytes[padEnd ? i : bytes.length - i - 1];\n    }\n    return paddedBytes;\n}\n/** @internal */ function trim(value, options = {}) {\n    const { dir = \"left\" } = options;\n    let data = value;\n    let sliceLength = 0;\n    for(let i = 0; i < data.length - 1; i++){\n        if (data[dir === \"left\" ? i : data.length - i - 1].toString() === \"0\") sliceLength++;\n        else break;\n    }\n    data = dir === \"left\" ? data.slice(sliceLength) : data.slice(0, data.length - sliceLength);\n    return data;\n} //# sourceMappingURL=bytes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2J5dGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQXFDO0FBQ3JDLGNBQWMsR0FDUCxTQUFTQyxXQUFXQyxLQUFLLEVBQUVDLEtBQUs7SUFDbkMsSUFBSUgsMkNBQVUsQ0FBQ0UsU0FBU0MsT0FDcEIsTUFBTSxJQUFJSCx3REFBdUIsQ0FBQztRQUM5Qk0sV0FBV04sMkNBQVUsQ0FBQ0U7UUFDdEJLLFNBQVNKO0lBQ2I7QUFDUjtBQUNBLGNBQWMsR0FDUCxTQUFTSyxrQkFBa0JDLEtBQUssRUFBRUMsS0FBSztJQUMxQyxJQUFJLE9BQU9BLFVBQVUsWUFBWUEsUUFBUSxLQUFLQSxRQUFRViwyQ0FBVSxDQUFDUyxTQUFTLEdBQ3RFLE1BQU0sSUFBSVQsa0VBQWlDLENBQUM7UUFDeENZLFFBQVFGO1FBQ1JHLFVBQVU7UUFDVlQsTUFBTUosMkNBQVUsQ0FBQ1M7SUFDckI7QUFDUjtBQUNBLGNBQWMsR0FDUCxTQUFTSyxnQkFBZ0JMLEtBQUssRUFBRUMsS0FBSyxFQUFFSyxHQUFHO0lBQzdDLElBQUksT0FBT0wsVUFBVSxZQUNqQixPQUFPSyxRQUFRLFlBQ2ZmLDJDQUFVLENBQUNTLFdBQVdNLE1BQU1MLE9BQU87UUFDbkMsTUFBTSxJQUFJVixrRUFBaUMsQ0FBQztZQUN4Q1ksUUFBUUc7WUFDUkYsVUFBVTtZQUNWVCxNQUFNSiwyQ0FBVSxDQUFDUztRQUNyQjtJQUNKO0FBQ0o7QUFDQSxjQUFjLEdBQ1AsTUFBTU8sY0FBYztJQUN2QkMsTUFBTTtJQUNOQyxNQUFNO0lBQ05DLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7QUFDUCxFQUFFO0FBQ0YsY0FBYyxHQUNQLFNBQVNDLGlCQUFpQkMsSUFBSTtJQUNqQyxJQUFJQSxRQUFRUixZQUFZQyxJQUFJLElBQUlPLFFBQVFSLFlBQVlFLElBQUksRUFDcEQsT0FBT00sT0FBT1IsWUFBWUMsSUFBSTtJQUNsQyxJQUFJTyxRQUFRUixZQUFZRyxDQUFDLElBQUlLLFFBQVFSLFlBQVlJLENBQUMsRUFDOUMsT0FBT0ksT0FBUVIsQ0FBQUEsWUFBWUcsQ0FBQyxHQUFHLEVBQUM7SUFDcEMsSUFBSUssUUFBUVIsWUFBWUssQ0FBQyxJQUFJRyxRQUFRUixZQUFZTSxDQUFDLEVBQzlDLE9BQU9FLE9BQVFSLENBQUFBLFlBQVlLLENBQUMsR0FBRyxFQUFDO0lBQ3BDLE9BQU9JO0FBQ1g7QUFDQSxjQUFjLEdBQ1AsU0FBU0MsSUFBSXhCLEtBQUssRUFBRXlCLFVBQVUsQ0FBQyxDQUFDO0lBQ25DLE1BQU0sRUFBRUMsR0FBRyxFQUFFeEIsT0FBTyxFQUFFLEVBQUUsR0FBR3VCO0lBQzNCLElBQUl2QixTQUFTLEdBQ1QsT0FBT0Y7SUFDWCxJQUFJQSxNQUFNMkIsTUFBTSxHQUFHekIsTUFDZixNQUFNLElBQUlKLGtFQUFpQyxDQUFDO1FBQ3hDSSxNQUFNRixNQUFNMkIsTUFBTTtRQUNsQkUsWUFBWTNCO1FBQ1o0QixNQUFNO0lBQ1Y7SUFDSixNQUFNQyxjQUFjLElBQUlDLFdBQVc5QjtJQUNuQyxJQUFLLElBQUkrQixJQUFJLEdBQUdBLElBQUkvQixNQUFNK0IsSUFBSztRQUMzQixNQUFNQyxTQUFTUixRQUFRO1FBQ3ZCSyxXQUFXLENBQUNHLFNBQVNELElBQUkvQixPQUFPK0IsSUFBSSxFQUFFLEdBQ2xDakMsS0FBSyxDQUFDa0MsU0FBU0QsSUFBSWpDLE1BQU0yQixNQUFNLEdBQUdNLElBQUksRUFBRTtJQUNoRDtJQUNBLE9BQU9GO0FBQ1g7QUFDQSxjQUFjLEdBQ1AsU0FBU0ksS0FBSzVCLEtBQUssRUFBRWtCLFVBQVUsQ0FBQyxDQUFDO0lBQ3BDLE1BQU0sRUFBRUMsTUFBTSxNQUFNLEVBQUUsR0FBR0Q7SUFDekIsSUFBSVcsT0FBTzdCO0lBQ1gsSUFBSThCLGNBQWM7SUFDbEIsSUFBSyxJQUFJSixJQUFJLEdBQUdBLElBQUlHLEtBQUtULE1BQU0sR0FBRyxHQUFHTSxJQUFLO1FBQ3RDLElBQUlHLElBQUksQ0FBQ1YsUUFBUSxTQUFTTyxJQUFJRyxLQUFLVCxNQUFNLEdBQUdNLElBQUksRUFBRSxDQUFDSyxRQUFRLE9BQU8sS0FDOUREO2FBRUE7SUFDUjtJQUNBRCxPQUNJVixRQUFRLFNBQ0ZVLEtBQUtHLEtBQUssQ0FBQ0YsZUFDWEQsS0FBS0csS0FBSyxDQUFDLEdBQUdILEtBQUtULE1BQU0sR0FBR1U7SUFDdEMsT0FBT0Q7QUFDWCxFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsYXctd29ya3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2J5dGVzLmpzPzUxMGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQnl0ZXMgZnJvbSAnLi4vQnl0ZXMuanMnO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFNpemUoYnl0ZXMsIHNpemVfKSB7XG4gICAgaWYgKEJ5dGVzLnNpemUoYnl0ZXMpID4gc2l6ZV8pXG4gICAgICAgIHRocm93IG5ldyBCeXRlcy5TaXplT3ZlcmZsb3dFcnJvcih7XG4gICAgICAgICAgICBnaXZlblNpemU6IEJ5dGVzLnNpemUoYnl0ZXMpLFxuICAgICAgICAgICAgbWF4U2l6ZTogc2l6ZV8sXG4gICAgICAgIH0pO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFN0YXJ0T2Zmc2V0KHZhbHVlLCBzdGFydCkge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdudW1iZXInICYmIHN0YXJ0ID4gMCAmJiBzdGFydCA+IEJ5dGVzLnNpemUodmFsdWUpIC0gMSlcbiAgICAgICAgdGhyb3cgbmV3IEJ5dGVzLlNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvcih7XG4gICAgICAgICAgICBvZmZzZXQ6IHN0YXJ0LFxuICAgICAgICAgICAgcG9zaXRpb246ICdzdGFydCcsXG4gICAgICAgICAgICBzaXplOiBCeXRlcy5zaXplKHZhbHVlKSxcbiAgICAgICAgfSk7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0RW5kT2Zmc2V0KHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgdHlwZW9mIGVuZCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgQnl0ZXMuc2l6ZSh2YWx1ZSkgIT09IGVuZCAtIHN0YXJ0KSB7XG4gICAgICAgIHRocm93IG5ldyBCeXRlcy5TbGljZU9mZnNldE91dE9mQm91bmRzRXJyb3Ioe1xuICAgICAgICAgICAgb2Zmc2V0OiBlbmQsXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2VuZCcsXG4gICAgICAgICAgICBzaXplOiBCeXRlcy5zaXplKHZhbHVlKSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IGNoYXJDb2RlTWFwID0ge1xuICAgIHplcm86IDQ4LFxuICAgIG5pbmU6IDU3LFxuICAgIEE6IDY1LFxuICAgIEY6IDcwLFxuICAgIGE6IDk3LFxuICAgIGY6IDEwMixcbn07XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gY2hhckNvZGVUb0Jhc2UxNihjaGFyKSB7XG4gICAgaWYgKGNoYXIgPj0gY2hhckNvZGVNYXAuemVybyAmJiBjaGFyIDw9IGNoYXJDb2RlTWFwLm5pbmUpXG4gICAgICAgIHJldHVybiBjaGFyIC0gY2hhckNvZGVNYXAuemVybztcbiAgICBpZiAoY2hhciA+PSBjaGFyQ29kZU1hcC5BICYmIGNoYXIgPD0gY2hhckNvZGVNYXAuRilcbiAgICAgICAgcmV0dXJuIGNoYXIgLSAoY2hhckNvZGVNYXAuQSAtIDEwKTtcbiAgICBpZiAoY2hhciA+PSBjaGFyQ29kZU1hcC5hICYmIGNoYXIgPD0gY2hhckNvZGVNYXAuZilcbiAgICAgICAgcmV0dXJuIGNoYXIgLSAoY2hhckNvZGVNYXAuYSAtIDEwKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhZChieXRlcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBkaXIsIHNpemUgPSAzMiB9ID0gb3B0aW9ucztcbiAgICBpZiAoc2l6ZSA9PT0gMClcbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIGlmIChieXRlcy5sZW5ndGggPiBzaXplKVxuICAgICAgICB0aHJvdyBuZXcgQnl0ZXMuU2l6ZUV4Y2VlZHNQYWRkaW5nU2l6ZUVycm9yKHtcbiAgICAgICAgICAgIHNpemU6IGJ5dGVzLmxlbmd0aCxcbiAgICAgICAgICAgIHRhcmdldFNpemU6IHNpemUsXG4gICAgICAgICAgICB0eXBlOiAnQnl0ZXMnLFxuICAgICAgICB9KTtcbiAgICBjb25zdCBwYWRkZWRCeXRlcyA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHBhZEVuZCA9IGRpciA9PT0gJ3JpZ2h0JztcbiAgICAgICAgcGFkZGVkQnl0ZXNbcGFkRW5kID8gaSA6IHNpemUgLSBpIC0gMV0gPVxuICAgICAgICAgICAgYnl0ZXNbcGFkRW5kID8gaSA6IGJ5dGVzLmxlbmd0aCAtIGkgLSAxXTtcbiAgICB9XG4gICAgcmV0dXJuIHBhZGRlZEJ5dGVzO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyaW0odmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgZGlyID0gJ2xlZnQnIH0gPSBvcHRpb25zO1xuICAgIGxldCBkYXRhID0gdmFsdWU7XG4gICAgbGV0IHNsaWNlTGVuZ3RoID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGlmIChkYXRhW2RpciA9PT0gJ2xlZnQnID8gaSA6IGRhdGEubGVuZ3RoIC0gaSAtIDFdLnRvU3RyaW5nKCkgPT09ICcwJylcbiAgICAgICAgICAgIHNsaWNlTGVuZ3RoKys7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkYXRhID1cbiAgICAgICAgZGlyID09PSAnbGVmdCdcbiAgICAgICAgICAgID8gZGF0YS5zbGljZShzbGljZUxlbmd0aClcbiAgICAgICAgICAgIDogZGF0YS5zbGljZSgwLCBkYXRhLmxlbmd0aCAtIHNsaWNlTGVuZ3RoKTtcbiAgICByZXR1cm4gZGF0YTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ5dGVzLmpzLm1hcCJdLCJuYW1lcyI6WyJCeXRlcyIsImFzc2VydFNpemUiLCJieXRlcyIsInNpemVfIiwic2l6ZSIsIlNpemVPdmVyZmxvd0Vycm9yIiwiZ2l2ZW5TaXplIiwibWF4U2l6ZSIsImFzc2VydFN0YXJ0T2Zmc2V0IiwidmFsdWUiLCJzdGFydCIsIlNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvciIsIm9mZnNldCIsInBvc2l0aW9uIiwiYXNzZXJ0RW5kT2Zmc2V0IiwiZW5kIiwiY2hhckNvZGVNYXAiLCJ6ZXJvIiwibmluZSIsIkEiLCJGIiwiYSIsImYiLCJjaGFyQ29kZVRvQmFzZTE2IiwiY2hhciIsInVuZGVmaW5lZCIsInBhZCIsIm9wdGlvbnMiLCJkaXIiLCJsZW5ndGgiLCJTaXplRXhjZWVkc1BhZGRpbmdTaXplRXJyb3IiLCJ0YXJnZXRTaXplIiwidHlwZSIsInBhZGRlZEJ5dGVzIiwiVWludDhBcnJheSIsImkiLCJwYWRFbmQiLCJ0cmltIiwiZGF0YSIsInNsaWNlTGVuZ3RoIiwidG9TdHJpbmciLCJzbGljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/internal/bytes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/internal/cursor.js":
/*!******************************************************!*\
  !*** ./node_modules/ox/_esm/core/internal/cursor.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NegativeOffsetError: () => (/* binding */ NegativeOffsetError),\n/* harmony export */   PositionOutOfBoundsError: () => (/* binding */ PositionOutOfBoundsError),\n/* harmony export */   RecursiveReadLimitExceededError: () => (/* binding */ RecursiveReadLimitExceededError),\n/* harmony export */   create: () => (/* binding */ create)\n/* harmony export */ });\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n\nconst staticCursor = {\n    bytes: new Uint8Array(),\n    dataView: new DataView(new ArrayBuffer(0)),\n    position: 0,\n    positionReadCount: new Map(),\n    recursiveReadCount: 0,\n    recursiveReadLimit: Number.POSITIVE_INFINITY,\n    assertReadLimit () {\n        if (this.recursiveReadCount >= this.recursiveReadLimit) throw new RecursiveReadLimitExceededError({\n            count: this.recursiveReadCount + 1,\n            limit: this.recursiveReadLimit\n        });\n    },\n    assertPosition (position) {\n        if (position < 0 || position > this.bytes.length - 1) throw new PositionOutOfBoundsError({\n            length: this.bytes.length,\n            position\n        });\n    },\n    decrementPosition (offset) {\n        if (offset < 0) throw new NegativeOffsetError({\n            offset\n        });\n        const position = this.position - offset;\n        this.assertPosition(position);\n        this.position = position;\n    },\n    getReadCount (position) {\n        return this.positionReadCount.get(position || this.position) || 0;\n    },\n    incrementPosition (offset) {\n        if (offset < 0) throw new NegativeOffsetError({\n            offset\n        });\n        const position = this.position + offset;\n        this.assertPosition(position);\n        this.position = position;\n    },\n    inspectByte (position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position);\n        return this.bytes[position];\n    },\n    inspectBytes (length, position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position + length - 1);\n        return this.bytes.subarray(position, position + length);\n    },\n    inspectUint8 (position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position);\n        return this.bytes[position];\n    },\n    inspectUint16 (position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position + 1);\n        return this.dataView.getUint16(position);\n    },\n    inspectUint24 (position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position + 2);\n        return (this.dataView.getUint16(position) << 8) + this.dataView.getUint8(position + 2);\n    },\n    inspectUint32 (position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position + 3);\n        return this.dataView.getUint32(position);\n    },\n    pushByte (byte) {\n        this.assertPosition(this.position);\n        this.bytes[this.position] = byte;\n        this.position++;\n    },\n    pushBytes (bytes) {\n        this.assertPosition(this.position + bytes.length - 1);\n        this.bytes.set(bytes, this.position);\n        this.position += bytes.length;\n    },\n    pushUint8 (value) {\n        this.assertPosition(this.position);\n        this.bytes[this.position] = value;\n        this.position++;\n    },\n    pushUint16 (value) {\n        this.assertPosition(this.position + 1);\n        this.dataView.setUint16(this.position, value);\n        this.position += 2;\n    },\n    pushUint24 (value) {\n        this.assertPosition(this.position + 2);\n        this.dataView.setUint16(this.position, value >> 8);\n        this.dataView.setUint8(this.position + 2, value & ~4294967040);\n        this.position += 3;\n    },\n    pushUint32 (value) {\n        this.assertPosition(this.position + 3);\n        this.dataView.setUint32(this.position, value);\n        this.position += 4;\n    },\n    readByte () {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectByte();\n        this.position++;\n        return value;\n    },\n    readBytes (length, size) {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectBytes(length);\n        this.position += size ?? length;\n        return value;\n    },\n    readUint8 () {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectUint8();\n        this.position += 1;\n        return value;\n    },\n    readUint16 () {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectUint16();\n        this.position += 2;\n        return value;\n    },\n    readUint24 () {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectUint24();\n        this.position += 3;\n        return value;\n    },\n    readUint32 () {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectUint32();\n        this.position += 4;\n        return value;\n    },\n    get remaining () {\n        return this.bytes.length - this.position;\n    },\n    setPosition (position) {\n        const oldPosition = this.position;\n        this.assertPosition(position);\n        this.position = position;\n        return ()=>this.position = oldPosition;\n    },\n    _touch () {\n        if (this.recursiveReadLimit === Number.POSITIVE_INFINITY) return;\n        const count = this.getReadCount();\n        this.positionReadCount.set(this.position, count + 1);\n        if (count > 0) this.recursiveReadCount++;\n    }\n};\n/** @internal */ function create(bytes, { recursiveReadLimit = 8192 } = {}) {\n    const cursor = Object.create(staticCursor);\n    cursor.bytes = bytes;\n    cursor.dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n    cursor.positionReadCount = new Map();\n    cursor.recursiveReadLimit = recursiveReadLimit;\n    return cursor;\n}\n/** @internal */ class NegativeOffsetError extends _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ offset }){\n        super(`Offset \\`${offset}\\` cannot be negative.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Cursor.NegativeOffsetError\"\n        });\n    }\n}\n/** @internal */ class PositionOutOfBoundsError extends _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ length, position }){\n        super(`Position \\`${position}\\` is out of bounds (\\`0 < position < ${length}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Cursor.PositionOutOfBoundsError\"\n        });\n    }\n}\n/** @internal */ class RecursiveReadLimitExceededError extends _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ count, limit }){\n        super(`Recursive read limit of \\`${limit}\\` exceeded (recursive read count: \\`${count}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Cursor.RecursiveReadLimitExceededError\"\n        });\n    }\n} //# sourceMappingURL=cursor.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2N1cnNvci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUF1QztBQUN2QyxNQUFNQyxlQUFlO0lBQ2pCQyxPQUFPLElBQUlDO0lBQ1hDLFVBQVUsSUFBSUMsU0FBUyxJQUFJQyxZQUFZO0lBQ3ZDQyxVQUFVO0lBQ1ZDLG1CQUFtQixJQUFJQztJQUN2QkMsb0JBQW9CO0lBQ3BCQyxvQkFBb0JDLE9BQU9DLGlCQUFpQjtJQUM1Q0M7UUFDSSxJQUFJLElBQUksQ0FBQ0osa0JBQWtCLElBQUksSUFBSSxDQUFDQyxrQkFBa0IsRUFDbEQsTUFBTSxJQUFJSSxnQ0FBZ0M7WUFDdENDLE9BQU8sSUFBSSxDQUFDTixrQkFBa0IsR0FBRztZQUNqQ08sT0FBTyxJQUFJLENBQUNOLGtCQUFrQjtRQUNsQztJQUNSO0lBQ0FPLGdCQUFlWCxRQUFRO1FBQ25CLElBQUlBLFdBQVcsS0FBS0EsV0FBVyxJQUFJLENBQUNMLEtBQUssQ0FBQ2lCLE1BQU0sR0FBRyxHQUMvQyxNQUFNLElBQUlDLHlCQUF5QjtZQUMvQkQsUUFBUSxJQUFJLENBQUNqQixLQUFLLENBQUNpQixNQUFNO1lBQ3pCWjtRQUNKO0lBQ1I7SUFDQWMsbUJBQWtCQyxNQUFNO1FBQ3BCLElBQUlBLFNBQVMsR0FDVCxNQUFNLElBQUlDLG9CQUFvQjtZQUFFRDtRQUFPO1FBQzNDLE1BQU1mLFdBQVcsSUFBSSxDQUFDQSxRQUFRLEdBQUdlO1FBQ2pDLElBQUksQ0FBQ0osY0FBYyxDQUFDWDtRQUNwQixJQUFJLENBQUNBLFFBQVEsR0FBR0E7SUFDcEI7SUFDQWlCLGNBQWFqQixRQUFRO1FBQ2pCLE9BQU8sSUFBSSxDQUFDQyxpQkFBaUIsQ0FBQ2lCLEdBQUcsQ0FBQ2xCLFlBQVksSUFBSSxDQUFDQSxRQUFRLEtBQUs7SUFDcEU7SUFDQW1CLG1CQUFrQkosTUFBTTtRQUNwQixJQUFJQSxTQUFTLEdBQ1QsTUFBTSxJQUFJQyxvQkFBb0I7WUFBRUQ7UUFB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SUFBSUM7SUFDL0JxRCxPQUFPbkQsa0JBQWtCLEdBQUdBO0lBQzVCLE9BQU9tRDtBQUNYO0FBQ0EsY0FBYyxHQUNQLE1BQU12Qyw0QkFBNEJ2QixpREFBZ0I7SUFDckRvRSxZQUFZLEVBQUU5QyxNQUFNLEVBQUUsQ0FBRTtRQUNwQixLQUFLLENBQUMsQ0FBQyxTQUFTLEVBQUVBLE9BQU8sc0JBQXNCLENBQUM7UUFDaER5QyxPQUFPTSxjQUFjLENBQUMsSUFBSSxFQUFFLFFBQVE7WUFDaENDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1Y3QixPQUFPO1FBQ1g7SUFDSjtBQUNKO0FBQ0EsY0FBYyxHQUNQLE1BQU12QixpQ0FBaUNwQixpREFBZ0I7SUFDMURvRSxZQUFZLEVBQUVqRCxNQUFNLEVBQUVaLFFBQVEsRUFBRSxDQUFFO1FBQzlCLEtBQUssQ0FBQyxDQUFDLFdBQVcsRUFBRUEsU0FBUyxzQ0FBc0MsRUFBRVksT0FBTyxJQUFJLENBQUM7UUFDakY0QyxPQUFPTSxjQUFjLENBQUMsSUFBSSxFQUFFLFFBQVE7WUFDaENDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1Y3QixPQUFPO1FBQ1g7SUFDSjtBQUNKO0FBQ0EsY0FBYyxHQUNQLE1BQU01Qix3Q0FBd0NmLGlEQUFnQjtJQUNqRW9FLFlBQVksRUFBRXBELEtBQUssRUFBRUMsS0FBSyxFQUFFLENBQUU7UUFDMUIsS0FBSyxDQUFDLENBQUMsMEJBQTBCLEVBQUVBLE1BQU0scUNBQXFDLEVBQUVELE1BQU0sSUFBSSxDQUFDO1FBQzNGK0MsT0FBT00sY0FBYyxDQUFDLElBQUksRUFBRSxRQUFRO1lBQ2hDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWN0IsT0FBTztRQUNYO0lBQ0o7QUFDSixFQUNBLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsYXctd29ya3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2N1cnNvci5qcz83YWQzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEVycm9ycyBmcm9tICcuLi9FcnJvcnMuanMnO1xuY29uc3Qgc3RhdGljQ3Vyc29yID0ge1xuICAgIGJ5dGVzOiBuZXcgVWludDhBcnJheSgpLFxuICAgIGRhdGFWaWV3OiBuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDApKSxcbiAgICBwb3NpdGlvbjogMCxcbiAgICBwb3NpdGlvblJlYWRDb3VudDogbmV3IE1hcCgpLFxuICAgIHJlY3Vyc2l2ZVJlYWRDb3VudDogMCxcbiAgICByZWN1cnNpdmVSZWFkTGltaXQ6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICBhc3NlcnRSZWFkTGltaXQoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlY3Vyc2l2ZVJlYWRDb3VudCA+PSB0aGlzLnJlY3Vyc2l2ZVJlYWRMaW1pdClcbiAgICAgICAgICAgIHRocm93IG5ldyBSZWN1cnNpdmVSZWFkTGltaXRFeGNlZWRlZEVycm9yKHtcbiAgICAgICAgICAgICAgICBjb3VudDogdGhpcy5yZWN1cnNpdmVSZWFkQ291bnQgKyAxLFxuICAgICAgICAgICAgICAgIGxpbWl0OiB0aGlzLnJlY3Vyc2l2ZVJlYWRMaW1pdCxcbiAgICAgICAgICAgIH0pO1xuICAgIH0sXG4gICAgYXNzZXJ0UG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMCB8fCBwb3NpdGlvbiA+IHRoaXMuYnl0ZXMubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgIHRocm93IG5ldyBQb3NpdGlvbk91dE9mQm91bmRzRXJyb3Ioe1xuICAgICAgICAgICAgICAgIGxlbmd0aDogdGhpcy5ieXRlcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICB9KTtcbiAgICB9LFxuICAgIGRlY3JlbWVudFBvc2l0aW9uKG9mZnNldCkge1xuICAgICAgICBpZiAob2Zmc2V0IDwgMClcbiAgICAgICAgICAgIHRocm93IG5ldyBOZWdhdGl2ZU9mZnNldEVycm9yKHsgb2Zmc2V0IH0pO1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMucG9zaXRpb24gLSBvZmZzZXQ7XG4gICAgICAgIHRoaXMuYXNzZXJ0UG9zaXRpb24ocG9zaXRpb24pO1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgfSxcbiAgICBnZXRSZWFkQ291bnQocG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb25SZWFkQ291bnQuZ2V0KHBvc2l0aW9uIHx8IHRoaXMucG9zaXRpb24pIHx8IDA7XG4gICAgfSxcbiAgICBpbmNyZW1lbnRQb3NpdGlvbihvZmZzZXQpIHtcbiAgICAgICAgaWYgKG9mZnNldCA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgTmVnYXRpdmVPZmZzZXRFcnJvcih7IG9mZnNldCB9KTtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uICsgb2Zmc2V0O1xuICAgICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgIH0sXG4gICAgaW5zcGVjdEJ5dGUocG9zaXRpb25fKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gcG9zaXRpb25fID8/IHRoaXMucG9zaXRpb247XG4gICAgICAgIHRoaXMuYXNzZXJ0UG9zaXRpb24ocG9zaXRpb24pO1xuICAgICAgICByZXR1cm4gdGhpcy5ieXRlc1twb3NpdGlvbl07XG4gICAgfSxcbiAgICBpbnNwZWN0Qnl0ZXMobGVuZ3RoLCBwb3NpdGlvbl8pIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbl8gPz8gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgdGhpcy5hc3NlcnRQb3NpdGlvbihwb3NpdGlvbiArIGxlbmd0aCAtIDEpO1xuICAgICAgICByZXR1cm4gdGhpcy5ieXRlcy5zdWJhcnJheShwb3NpdGlvbiwgcG9zaXRpb24gKyBsZW5ndGgpO1xuICAgIH0sXG4gICAgaW5zcGVjdFVpbnQ4KHBvc2l0aW9uXykge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHBvc2l0aW9uXyA/PyB0aGlzLnBvc2l0aW9uO1xuICAgICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZXNbcG9zaXRpb25dO1xuICAgIH0sXG4gICAgaW5zcGVjdFVpbnQxNihwb3NpdGlvbl8pIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbl8gPz8gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgdGhpcy5hc3NlcnRQb3NpdGlvbihwb3NpdGlvbiArIDEpO1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhVmlldy5nZXRVaW50MTYocG9zaXRpb24pO1xuICAgIH0sXG4gICAgaW5zcGVjdFVpbnQyNChwb3NpdGlvbl8pIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbl8gPz8gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgdGhpcy5hc3NlcnRQb3NpdGlvbihwb3NpdGlvbiArIDIpO1xuICAgICAgICByZXR1cm4gKCh0aGlzLmRhdGFWaWV3LmdldFVpbnQxNihwb3NpdGlvbikgPDwgOCkgK1xuICAgICAgICAgICAgdGhpcy5kYXRhVmlldy5nZXRVaW50OChwb3NpdGlvbiArIDIpKTtcbiAgICB9LFxuICAgIGluc3BlY3RVaW50MzIocG9zaXRpb25fKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gcG9zaXRpb25fID8/IHRoaXMucG9zaXRpb247XG4gICAgICAgIHRoaXMuYXNzZXJ0UG9zaXRpb24ocG9zaXRpb24gKyAzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVZpZXcuZ2V0VWludDMyKHBvc2l0aW9uKTtcbiAgICB9LFxuICAgIHB1c2hCeXRlKGJ5dGUpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRQb3NpdGlvbih0aGlzLnBvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5ieXRlc1t0aGlzLnBvc2l0aW9uXSA9IGJ5dGU7XG4gICAgICAgIHRoaXMucG9zaXRpb24rKztcbiAgICB9LFxuICAgIHB1c2hCeXRlcyhieXRlcykge1xuICAgICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHRoaXMucG9zaXRpb24gKyBieXRlcy5sZW5ndGggLSAxKTtcbiAgICAgICAgdGhpcy5ieXRlcy5zZXQoYnl0ZXMsIHRoaXMucG9zaXRpb24pO1xuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IGJ5dGVzLmxlbmd0aDtcbiAgICB9LFxuICAgIHB1c2hVaW50OCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHRoaXMucG9zaXRpb24pO1xuICAgICAgICB0aGlzLmJ5dGVzW3RoaXMucG9zaXRpb25dID0gdmFsdWU7XG4gICAgICAgIHRoaXMucG9zaXRpb24rKztcbiAgICB9LFxuICAgIHB1c2hVaW50MTYodmFsdWUpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRQb3NpdGlvbih0aGlzLnBvc2l0aW9uICsgMSk7XG4gICAgICAgIHRoaXMuZGF0YVZpZXcuc2V0VWludDE2KHRoaXMucG9zaXRpb24sIHZhbHVlKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSAyO1xuICAgIH0sXG4gICAgcHVzaFVpbnQyNCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHRoaXMucG9zaXRpb24gKyAyKTtcbiAgICAgICAgdGhpcy5kYXRhVmlldy5zZXRVaW50MTYodGhpcy5wb3NpdGlvbiwgdmFsdWUgPj4gOCk7XG4gICAgICAgIHRoaXMuZGF0YVZpZXcuc2V0VWludDgodGhpcy5wb3NpdGlvbiArIDIsIHZhbHVlICYgfjQyOTQ5NjcwNDApO1xuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IDM7XG4gICAgfSxcbiAgICBwdXNoVWludDMyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0UG9zaXRpb24odGhpcy5wb3NpdGlvbiArIDMpO1xuICAgICAgICB0aGlzLmRhdGFWaWV3LnNldFVpbnQzMih0aGlzLnBvc2l0aW9uLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gNDtcbiAgICB9LFxuICAgIHJlYWRCeXRlKCkge1xuICAgICAgICB0aGlzLmFzc2VydFJlYWRMaW1pdCgpO1xuICAgICAgICB0aGlzLl90b3VjaCgpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuaW5zcGVjdEJ5dGUoKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbisrO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICByZWFkQnl0ZXMobGVuZ3RoLCBzaXplKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0UmVhZExpbWl0KCk7XG4gICAgICAgIHRoaXMuX3RvdWNoKCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5pbnNwZWN0Qnl0ZXMobGVuZ3RoKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSBzaXplID8/IGxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgcmVhZFVpbnQ4KCkge1xuICAgICAgICB0aGlzLmFzc2VydFJlYWRMaW1pdCgpO1xuICAgICAgICB0aGlzLl90b3VjaCgpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuaW5zcGVjdFVpbnQ4KCk7XG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gMTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgcmVhZFVpbnQxNigpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRSZWFkTGltaXQoKTtcbiAgICAgICAgdGhpcy5fdG91Y2goKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmluc3BlY3RVaW50MTYoKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSAyO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICByZWFkVWludDI0KCkge1xuICAgICAgICB0aGlzLmFzc2VydFJlYWRMaW1pdCgpO1xuICAgICAgICB0aGlzLl90b3VjaCgpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuaW5zcGVjdFVpbnQyNCgpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IDM7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHJlYWRVaW50MzIoKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0UmVhZExpbWl0KCk7XG4gICAgICAgIHRoaXMuX3RvdWNoKCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5pbnNwZWN0VWludDMyKCk7XG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gNDtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgZ2V0IHJlbWFpbmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZXMubGVuZ3RoIC0gdGhpcy5wb3NpdGlvbjtcbiAgICB9LFxuICAgIHNldFBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgIGNvbnN0IG9sZFBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgdGhpcy5hc3NlcnRQb3NpdGlvbihwb3NpdGlvbik7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICAgICAgcmV0dXJuICgpID0+ICh0aGlzLnBvc2l0aW9uID0gb2xkUG9zaXRpb24pO1xuICAgIH0sXG4gICAgX3RvdWNoKCkge1xuICAgICAgICBpZiAodGhpcy5yZWN1cnNpdmVSZWFkTGltaXQgPT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgY291bnQgPSB0aGlzLmdldFJlYWRDb3VudCgpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uUmVhZENvdW50LnNldCh0aGlzLnBvc2l0aW9uLCBjb3VudCArIDEpO1xuICAgICAgICBpZiAoY291bnQgPiAwKVxuICAgICAgICAgICAgdGhpcy5yZWN1cnNpdmVSZWFkQ291bnQrKztcbiAgICB9LFxufTtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoYnl0ZXMsIHsgcmVjdXJzaXZlUmVhZExpbWl0ID0gOF8xOTIgfSA9IHt9KSB7XG4gICAgY29uc3QgY3Vyc29yID0gT2JqZWN0LmNyZWF0ZShzdGF0aWNDdXJzb3IpO1xuICAgIGN1cnNvci5ieXRlcyA9IGJ5dGVzO1xuICAgIGN1cnNvci5kYXRhVmlldyA9IG5ldyBEYXRhVmlldyhieXRlcy5idWZmZXIsIGJ5dGVzLmJ5dGVPZmZzZXQsIGJ5dGVzLmJ5dGVMZW5ndGgpO1xuICAgIGN1cnNvci5wb3NpdGlvblJlYWRDb3VudCA9IG5ldyBNYXAoKTtcbiAgICBjdXJzb3IucmVjdXJzaXZlUmVhZExpbWl0ID0gcmVjdXJzaXZlUmVhZExpbWl0O1xuICAgIHJldHVybiBjdXJzb3I7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY2xhc3MgTmVnYXRpdmVPZmZzZXRFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgb2Zmc2V0IH0pIHtcbiAgICAgICAgc3VwZXIoYE9mZnNldCBcXGAke29mZnNldH1cXGAgY2Fubm90IGJlIG5lZ2F0aXZlLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQ3Vyc29yLk5lZ2F0aXZlT2Zmc2V0RXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjbGFzcyBQb3NpdGlvbk91dE9mQm91bmRzRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGxlbmd0aCwgcG9zaXRpb24gfSkge1xuICAgICAgICBzdXBlcihgUG9zaXRpb24gXFxgJHtwb3NpdGlvbn1cXGAgaXMgb3V0IG9mIGJvdW5kcyAoXFxgMCA8IHBvc2l0aW9uIDwgJHtsZW5ndGh9XFxgKS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0N1cnNvci5Qb3NpdGlvbk91dE9mQm91bmRzRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjbGFzcyBSZWN1cnNpdmVSZWFkTGltaXRFeGNlZWRlZEVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBjb3VudCwgbGltaXQgfSkge1xuICAgICAgICBzdXBlcihgUmVjdXJzaXZlIHJlYWQgbGltaXQgb2YgXFxgJHtsaW1pdH1cXGAgZXhjZWVkZWQgKHJlY3Vyc2l2ZSByZWFkIGNvdW50OiBcXGAke2NvdW50fVxcYCkuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdDdXJzb3IuUmVjdXJzaXZlUmVhZExpbWl0RXhjZWVkZWRFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3Vyc29yLmpzLm1hcCJdLCJuYW1lcyI6WyJFcnJvcnMiLCJzdGF0aWNDdXJzb3IiLCJieXRlcyIsIlVpbnQ4QXJyYXkiLCJkYXRhVmlldyIsIkRhdGFWaWV3IiwiQXJyYXlCdWZmZXIiLCJwb3NpdGlvbiIsInBvc2l0aW9uUmVhZENvdW50IiwiTWFwIiwicmVjdXJzaXZlUmVhZENvdW50IiwicmVjdXJzaXZlUmVhZExpbWl0IiwiTnVtYmVyIiwiUE9TSVRJVkVfSU5GSU5JVFkiLCJhc3NlcnRSZWFkTGltaXQiLCJSZWN1cnNpdmVSZWFkTGltaXRFeGNlZWRlZEVycm9yIiwiY291bnQiLCJsaW1pdCIsImFzc2VydFBvc2l0aW9uIiwibGVuZ3RoIiwiUG9zaXRpb25PdXRPZkJvdW5kc0Vycm9yIiwiZGVjcmVtZW50UG9zaXRpb24iLCJvZmZzZXQiLCJOZWdhdGl2ZU9mZnNldEVycm9yIiwiZ2V0UmVhZENvdW50IiwiZ2V0IiwiaW5jcmVtZW50UG9zaXRpb24iLCJpbnNwZWN0Qnl0ZSIsInBvc2l0aW9uXyIsImluc3BlY3RCeXRlcyIsInN1YmFycmF5IiwiaW5zcGVjdFVpbnQ4IiwiaW5zcGVjdFVpbnQxNiIsImdldFVpbnQxNiIsImluc3BlY3RVaW50MjQiLCJnZXRVaW50OCIsImluc3BlY3RVaW50MzIiLCJnZXRVaW50MzIiLCJwdXNoQnl0ZSIsImJ5dGUiLCJwdXNoQnl0ZXMiLCJzZXQiLCJwdXNoVWludDgiLCJ2YWx1ZSIsInB1c2hVaW50MTYiLCJzZXRVaW50MTYiLCJwdXNoVWludDI0Iiwic2V0VWludDgiLCJwdXNoVWludDMyIiwic2V0VWludDMyIiwicmVhZEJ5dGUiLCJfdG91Y2giLCJyZWFkQnl0ZXMiLCJzaXplIiwicmVhZFVpbnQ4IiwicmVhZFVpbnQxNiIsInJlYWRVaW50MjQiLCJyZWFkVWludDMyIiwicmVtYWluaW5nIiwic2V0UG9zaXRpb24iLCJvbGRQb3NpdGlvbiIsImNyZWF0ZSIsImN1cnNvciIsIk9iamVjdCIsImJ1ZmZlciIsImJ5dGVPZmZzZXQiLCJieXRlTGVuZ3RoIiwiQmFzZUVycm9yIiwiY29uc3RydWN0b3IiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/internal/cursor.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/internal/ens.js":
/*!***************************************************!*\
  !*** ./node_modules/ox/_esm/core/internal/ens.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   packetToBytes: () => (/* binding */ packetToBytes),\n/* harmony export */   unwrapLabelhash: () => (/* binding */ unwrapLabelhash),\n/* harmony export */   wrapLabelhash: () => (/* binding */ wrapLabelhash)\n/* harmony export */ });\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../index.js */ \"(ssr)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Ens_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Ens.js */ \"(ssr)/./node_modules/ox/_esm/core/Ens.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n\n\n\n/**\n * @internal\n * Encodes a [DNS packet](https://docs.ens.domains/resolution/names#dns) into a ByteArray containing a UDP payload.\n */ function packetToBytes(packet) {\n    // strip leading and trailing `.`\n    const value = packet.replace(/^\\.|\\.$/gm, \"\");\n    if (value.length === 0) return new Uint8Array(1);\n    const bytes = new Uint8Array(_index_js__WEBPACK_IMPORTED_MODULE_0__.fromString(value).byteLength + 2);\n    let offset = 0;\n    const list = value.split(\".\");\n    for(let i = 0; i < list.length; i++){\n        let encoded = _index_js__WEBPACK_IMPORTED_MODULE_0__.fromString(list[i]);\n        // if the length is > 255, make the encoded label value a labelhash\n        // this is compatible with the universal resolver\n        if (encoded.byteLength > 255) encoded = _index_js__WEBPACK_IMPORTED_MODULE_0__.fromString(wrapLabelhash(_Ens_js__WEBPACK_IMPORTED_MODULE_1__.labelhash(list[i])));\n        bytes[offset] = encoded.length;\n        bytes.set(encoded, offset + 1);\n        offset += encoded.length + 1;\n    }\n    if (bytes.byteLength !== offset + 1) return bytes.slice(0, offset + 1);\n    return bytes;\n}\n/** @internal */ function wrapLabelhash(hash) {\n    return `[${hash.slice(2)}]`;\n}\n/** @internal */ function unwrapLabelhash(label) {\n    if (label.length !== 66) return null;\n    if (label.indexOf(\"[\") !== 0) return null;\n    if (label.indexOf(\"]\") !== 65) return null;\n    const hash = `0x${label.slice(1, 65)}`;\n    if (!_Hex_js__WEBPACK_IMPORTED_MODULE_2__.validate(hash, {\n        strict: true\n    })) return null;\n    return hash;\n} //# sourceMappingURL=ens.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2Vucy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBdUM7QUFDTjtBQUNBO0FBQ2pDOzs7Q0FHQyxHQUNNLFNBQVNHLGNBQWNDLE1BQU07SUFDaEMsaUNBQWlDO0lBQ2pDLE1BQU1DLFFBQVFELE9BQU9FLE9BQU8sQ0FBQyxhQUFhO0lBQzFDLElBQUlELE1BQU1FLE1BQU0sS0FBSyxHQUNqQixPQUFPLElBQUlDLFdBQVc7SUFDMUIsTUFBTUMsUUFBUSxJQUFJRCxXQUFXUixpREFBZ0IsQ0FBQ0ssT0FBT00sVUFBVSxHQUFHO0lBQ2xFLElBQUlDLFNBQVM7SUFDYixNQUFNQyxPQUFPUixNQUFNUyxLQUFLLENBQUM7SUFDekIsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlGLEtBQUtOLE1BQU0sRUFBRVEsSUFBSztRQUNsQyxJQUFJQyxVQUFVaEIsaURBQWdCLENBQUNhLElBQUksQ0FBQ0UsRUFBRTtRQUN0QyxtRUFBbUU7UUFDbkUsaURBQWlEO1FBQ2pELElBQUlDLFFBQVFMLFVBQVUsR0FBRyxLQUNyQkssVUFBVWhCLGlEQUFnQixDQUFDaUIsY0FBY2hCLDhDQUFhLENBQUNZLElBQUksQ0FBQ0UsRUFBRTtRQUNsRU4sS0FBSyxDQUFDRyxPQUFPLEdBQUdJLFFBQVFULE1BQU07UUFDOUJFLE1BQU1VLEdBQUcsQ0FBQ0gsU0FBU0osU0FBUztRQUM1QkEsVUFBVUksUUFBUVQsTUFBTSxHQUFHO0lBQy9CO0lBQ0EsSUFBSUUsTUFBTUUsVUFBVSxLQUFLQyxTQUFTLEdBQzlCLE9BQU9ILE1BQU1XLEtBQUssQ0FBQyxHQUFHUixTQUFTO0lBQ25DLE9BQU9IO0FBQ1g7QUFDQSxjQUFjLEdBQ1AsU0FBU1EsY0FBY0ksSUFBSTtJQUM5QixPQUFPLENBQUMsQ0FBQyxFQUFFQSxLQUFLRCxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDL0I7QUFDQSxjQUFjLEdBQ1AsU0FBU0UsZ0JBQWdCQyxLQUFLO0lBQ2pDLElBQUlBLE1BQU1oQixNQUFNLEtBQUssSUFDakIsT0FBTztJQUNYLElBQUlnQixNQUFNQyxPQUFPLENBQUMsU0FBUyxHQUN2QixPQUFPO0lBQ1gsSUFBSUQsTUFBTUMsT0FBTyxDQUFDLFNBQVMsSUFDdkIsT0FBTztJQUNYLE1BQU1ILE9BQU8sQ0FBQyxFQUFFLEVBQUVFLE1BQU1ILEtBQUssQ0FBQyxHQUFHLElBQUksQ0FBQztJQUN0QyxJQUFJLENBQUNsQiw2Q0FBWSxDQUFDbUIsTUFBTTtRQUFFSyxRQUFRO0lBQUssSUFDbkMsT0FBTztJQUNYLE9BQU9MO0FBQ1gsRUFDQSwrQkFBK0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGF3LXdvcmtzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9pbnRlcm5hbC9lbnMuanM/MTFkYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCeXRlcyB9IGZyb20gJy4uLy4uL2luZGV4LmpzJztcbmltcG9ydCAqIGFzIEVucyBmcm9tICcuLi9FbnMuanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4uL0hleC5qcyc7XG4vKipcbiAqIEBpbnRlcm5hbFxuICogRW5jb2RlcyBhIFtETlMgcGFja2V0XShodHRwczovL2RvY3MuZW5zLmRvbWFpbnMvcmVzb2x1dGlvbi9uYW1lcyNkbnMpIGludG8gYSBCeXRlQXJyYXkgY29udGFpbmluZyBhIFVEUCBwYXlsb2FkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFja2V0VG9CeXRlcyhwYWNrZXQpIHtcbiAgICAvLyBzdHJpcCBsZWFkaW5nIGFuZCB0cmFpbGluZyBgLmBcbiAgICBjb25zdCB2YWx1ZSA9IHBhY2tldC5yZXBsYWNlKC9eXFwufFxcLiQvZ20sICcnKTtcbiAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoMSk7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShCeXRlcy5mcm9tU3RyaW5nKHZhbHVlKS5ieXRlTGVuZ3RoICsgMik7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgY29uc3QgbGlzdCA9IHZhbHVlLnNwbGl0KCcuJyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBlbmNvZGVkID0gQnl0ZXMuZnJvbVN0cmluZyhsaXN0W2ldKTtcbiAgICAgICAgLy8gaWYgdGhlIGxlbmd0aCBpcyA+IDI1NSwgbWFrZSB0aGUgZW5jb2RlZCBsYWJlbCB2YWx1ZSBhIGxhYmVsaGFzaFxuICAgICAgICAvLyB0aGlzIGlzIGNvbXBhdGlibGUgd2l0aCB0aGUgdW5pdmVyc2FsIHJlc29sdmVyXG4gICAgICAgIGlmIChlbmNvZGVkLmJ5dGVMZW5ndGggPiAyNTUpXG4gICAgICAgICAgICBlbmNvZGVkID0gQnl0ZXMuZnJvbVN0cmluZyh3cmFwTGFiZWxoYXNoKEVucy5sYWJlbGhhc2gobGlzdFtpXSkpKTtcbiAgICAgICAgYnl0ZXNbb2Zmc2V0XSA9IGVuY29kZWQubGVuZ3RoO1xuICAgICAgICBieXRlcy5zZXQoZW5jb2RlZCwgb2Zmc2V0ICsgMSk7XG4gICAgICAgIG9mZnNldCArPSBlbmNvZGVkLmxlbmd0aCArIDE7XG4gICAgfVxuICAgIGlmIChieXRlcy5ieXRlTGVuZ3RoICE9PSBvZmZzZXQgKyAxKVxuICAgICAgICByZXR1cm4gYnl0ZXMuc2xpY2UoMCwgb2Zmc2V0ICsgMSk7XG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdyYXBMYWJlbGhhc2goaGFzaCkge1xuICAgIHJldHVybiBgWyR7aGFzaC5zbGljZSgyKX1dYDtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiB1bndyYXBMYWJlbGhhc2gobGFiZWwpIHtcbiAgICBpZiAobGFiZWwubGVuZ3RoICE9PSA2NilcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgaWYgKGxhYmVsLmluZGV4T2YoJ1snKSAhPT0gMClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgaWYgKGxhYmVsLmluZGV4T2YoJ10nKSAhPT0gNjUpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IGhhc2ggPSBgMHgke2xhYmVsLnNsaWNlKDEsIDY1KX1gO1xuICAgIGlmICghSGV4LnZhbGlkYXRlKGhhc2gsIHsgc3RyaWN0OiB0cnVlIH0pKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gaGFzaDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVucy5qcy5tYXAiXSwibmFtZXMiOlsiQnl0ZXMiLCJFbnMiLCJIZXgiLCJwYWNrZXRUb0J5dGVzIiwicGFja2V0IiwidmFsdWUiLCJyZXBsYWNlIiwibGVuZ3RoIiwiVWludDhBcnJheSIsImJ5dGVzIiwiZnJvbVN0cmluZyIsImJ5dGVMZW5ndGgiLCJvZmZzZXQiLCJsaXN0Iiwic3BsaXQiLCJpIiwiZW5jb2RlZCIsIndyYXBMYWJlbGhhc2giLCJsYWJlbGhhc2giLCJzZXQiLCJzbGljZSIsImhhc2giLCJ1bndyYXBMYWJlbGhhc2giLCJsYWJlbCIsImluZGV4T2YiLCJ2YWxpZGF0ZSIsInN0cmljdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/internal/ens.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/internal/entropy.js":
/*!*******************************************************!*\
  !*** ./node_modules/ox/_esm/core/internal/entropy.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   extraEntropy: () => (/* binding */ extraEntropy),\n/* harmony export */   setExtraEntropy: () => (/* binding */ setExtraEntropy)\n/* harmony export */ });\nlet extraEntropy = false;\n/** @internal */ function setExtraEntropy(entropy) {\n    extraEntropy = entropy;\n} //# sourceMappingURL=entropy.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2VudHJvcHkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTyxJQUFJQSxlQUFlLE1BQU07QUFDaEMsY0FBYyxHQUNQLFNBQVNDLGdCQUFnQkMsT0FBTztJQUNuQ0YsZUFBZUU7QUFDbkIsRUFDQSxtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGF3LXdvcmtzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9pbnRlcm5hbC9lbnRyb3B5LmpzPzU0YzkiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGxldCBleHRyYUVudHJvcHkgPSBmYWxzZTtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRFeHRyYUVudHJvcHkoZW50cm9weSkge1xuICAgIGV4dHJhRW50cm9weSA9IGVudHJvcHk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbnRyb3B5LmpzLm1hcCJdLCJuYW1lcyI6WyJleHRyYUVudHJvcHkiLCJzZXRFeHRyYUVudHJvcHkiLCJlbnRyb3B5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/internal/entropy.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/internal/errors.js":
/*!******************************************************!*\
  !*** ./node_modules/ox/_esm/core/internal/errors.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getUrl: () => (/* binding */ getUrl),\n/* harmony export */   getVersion: () => (/* binding */ getVersion),\n/* harmony export */   prettyPrint: () => (/* binding */ prettyPrint)\n/* harmony export */ });\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../version.js */ \"(ssr)/./node_modules/ox/_esm/core/version.js\");\n\n/** @internal */ function getUrl(url) {\n    return url;\n}\n/** @internal */ function getVersion() {\n    return _version_js__WEBPACK_IMPORTED_MODULE_0__.version;\n}\n/** @internal */ function prettyPrint(args) {\n    if (!args) return \"\";\n    const entries = Object.entries(args).map(([key, value])=>{\n        if (value === undefined || value === false) return null;\n        return [\n            key,\n            value\n        ];\n    }).filter(Boolean);\n    const maxLength = entries.reduce((acc, [key])=>Math.max(acc, key.length), 0);\n    return entries.map(([key, value])=>`  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`).join(\"\\n\");\n} //# sourceMappingURL=errors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXdDO0FBQ3hDLGNBQWMsR0FDUCxTQUFTQyxPQUFPQyxHQUFHO0lBQ3RCLE9BQU9BO0FBQ1g7QUFDQSxjQUFjLEdBQ1AsU0FBU0M7SUFDWixPQUFPSCxnREFBT0E7QUFDbEI7QUFDQSxjQUFjLEdBQ1AsU0FBU0ksWUFBWUMsSUFBSTtJQUM1QixJQUFJLENBQUNBLE1BQ0QsT0FBTztJQUNYLE1BQU1DLFVBQVVDLE9BQU9ELE9BQU8sQ0FBQ0QsTUFDMUJHLEdBQUcsQ0FBQyxDQUFDLENBQUNDLEtBQUtDLE1BQU07UUFDbEIsSUFBSUEsVUFBVUMsYUFBYUQsVUFBVSxPQUNqQyxPQUFPO1FBQ1gsT0FBTztZQUFDRDtZQUFLQztTQUFNO0lBQ3ZCLEdBQ0tFLE1BQU0sQ0FBQ0M7SUFDWixNQUFNQyxZQUFZUixRQUFRUyxNQUFNLENBQUMsQ0FBQ0MsS0FBSyxDQUFDUCxJQUFJLEdBQUtRLEtBQUtDLEdBQUcsQ0FBQ0YsS0FBS1AsSUFBSVUsTUFBTSxHQUFHO0lBQzVFLE9BQU9iLFFBQ0ZFLEdBQUcsQ0FBQyxDQUFDLENBQUNDLEtBQUtDLE1BQU0sR0FBSyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUVELElBQUksQ0FBQyxDQUFDLENBQUNXLE1BQU0sQ0FBQ04sWUFBWSxHQUFHLEVBQUUsRUFBRUosTUFBTSxDQUFDLEVBQ3RFVyxJQUFJLENBQUM7QUFDZCxFQUNBLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsYXctd29ya3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2Vycm9ycy5qcz9hZTZlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHZlcnNpb24gfSBmcm9tICcuLi92ZXJzaW9uLmpzJztcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRVcmwodXJsKSB7XG4gICAgcmV0dXJuIHVybDtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRWZXJzaW9uKCkge1xuICAgIHJldHVybiB2ZXJzaW9uO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByZXR0eVByaW50KGFyZ3MpIHtcbiAgICBpZiAoIWFyZ3MpXG4gICAgICAgIHJldHVybiAnJztcbiAgICBjb25zdCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoYXJncylcbiAgICAgICAgLm1hcCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBmYWxzZSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gW2tleSwgdmFsdWVdO1xuICAgIH0pXG4gICAgICAgIC5maWx0ZXIoQm9vbGVhbik7XG4gICAgY29uc3QgbWF4TGVuZ3RoID0gZW50cmllcy5yZWR1Y2UoKGFjYywgW2tleV0pID0+IE1hdGgubWF4KGFjYywga2V5Lmxlbmd0aCksIDApO1xuICAgIHJldHVybiBlbnRyaWVzXG4gICAgICAgIC5tYXAoKFtrZXksIHZhbHVlXSkgPT4gYCAgJHtgJHtrZXl9OmAucGFkRW5kKG1heExlbmd0aCArIDEpfSAgJHt2YWx1ZX1gKVxuICAgICAgICAuam9pbignXFxuJyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvcnMuanMubWFwIl0sIm5hbWVzIjpbInZlcnNpb24iLCJnZXRVcmwiLCJ1cmwiLCJnZXRWZXJzaW9uIiwicHJldHR5UHJpbnQiLCJhcmdzIiwiZW50cmllcyIsIk9iamVjdCIsIm1hcCIsImtleSIsInZhbHVlIiwidW5kZWZpbmVkIiwiZmlsdGVyIiwiQm9vbGVhbiIsIm1heExlbmd0aCIsInJlZHVjZSIsImFjYyIsIk1hdGgiLCJtYXgiLCJsZW5ndGgiLCJwYWRFbmQiLCJqb2luIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/internal/errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/internal/hex.js":
/*!***************************************************!*\
  !*** ./node_modules/ox/_esm/core/internal/hex.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertEndOffset: () => (/* binding */ assertEndOffset),\n/* harmony export */   assertSize: () => (/* binding */ assertSize),\n/* harmony export */   assertStartOffset: () => (/* binding */ assertStartOffset),\n/* harmony export */   pad: () => (/* binding */ pad),\n/* harmony export */   trim: () => (/* binding */ trim)\n/* harmony export */ });\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n\n/** @internal */ function assertSize(hex, size_) {\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(hex) > size_) throw new _Hex_js__WEBPACK_IMPORTED_MODULE_0__.SizeOverflowError({\n        givenSize: _Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(hex),\n        maxSize: size_\n    });\n}\n/** @internal */ function assertStartOffset(value, start) {\n    if (typeof start === \"number\" && start > 0 && start > _Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(value) - 1) throw new _Hex_js__WEBPACK_IMPORTED_MODULE_0__.SliceOffsetOutOfBoundsError({\n        offset: start,\n        position: \"start\",\n        size: _Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(value)\n    });\n}\n/** @internal */ function assertEndOffset(value, start, end) {\n    if (typeof start === \"number\" && typeof end === \"number\" && _Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(value) !== end - start) {\n        throw new _Hex_js__WEBPACK_IMPORTED_MODULE_0__.SliceOffsetOutOfBoundsError({\n            offset: end,\n            position: \"end\",\n            size: _Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(value)\n        });\n    }\n}\n/** @internal */ function pad(hex_, options = {}) {\n    const { dir, size = 32 } = options;\n    if (size === 0) return hex_;\n    const hex = hex_.replace(\"0x\", \"\");\n    if (hex.length > size * 2) throw new _Hex_js__WEBPACK_IMPORTED_MODULE_0__.SizeExceedsPaddingSizeError({\n        size: Math.ceil(hex.length / 2),\n        targetSize: size,\n        type: \"Hex\"\n    });\n    return `0x${hex[dir === \"right\" ? \"padEnd\" : \"padStart\"](size * 2, \"0\")}`;\n}\n/** @internal */ function trim(value, options = {}) {\n    const { dir = \"left\" } = options;\n    let data = value.replace(\"0x\", \"\");\n    let sliceLength = 0;\n    for(let i = 0; i < data.length - 1; i++){\n        if (data[dir === \"left\" ? i : data.length - i - 1].toString() === \"0\") sliceLength++;\n        else break;\n    }\n    data = dir === \"left\" ? data.slice(sliceLength) : data.slice(0, data.length - sliceLength);\n    if (data === \"0\") return \"0x\";\n    if (dir === \"right\" && data.length % 2 === 1) return `0x${data}0`;\n    return `0x${data}`;\n} //# sourceMappingURL=hex.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2hleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBaUM7QUFDakMsY0FBYyxHQUNQLFNBQVNDLFdBQVdDLEdBQUcsRUFBRUMsS0FBSztJQUNqQyxJQUFJSCx5Q0FBUSxDQUFDRSxPQUFPQyxPQUNoQixNQUFNLElBQUlILHNEQUFxQixDQUFDO1FBQzVCTSxXQUFXTix5Q0FBUSxDQUFDRTtRQUNwQkssU0FBU0o7SUFDYjtBQUNSO0FBQ0EsY0FBYyxHQUNQLFNBQVNLLGtCQUFrQkMsS0FBSyxFQUFFQyxLQUFLO0lBQzFDLElBQUksT0FBT0EsVUFBVSxZQUFZQSxRQUFRLEtBQUtBLFFBQVFWLHlDQUFRLENBQUNTLFNBQVMsR0FDcEUsTUFBTSxJQUFJVCxnRUFBK0IsQ0FBQztRQUN0Q1ksUUFBUUY7UUFDUkcsVUFBVTtRQUNWVCxNQUFNSix5Q0FBUSxDQUFDUztJQUNuQjtBQUNSO0FBQ0EsY0FBYyxHQUNQLFNBQVNLLGdCQUFnQkwsS0FBSyxFQUFFQyxLQUFLLEVBQUVLLEdBQUc7SUFDN0MsSUFBSSxPQUFPTCxVQUFVLFlBQ2pCLE9BQU9LLFFBQVEsWUFDZmYseUNBQVEsQ0FBQ1MsV0FBV00sTUFBTUwsT0FBTztRQUNqQyxNQUFNLElBQUlWLGdFQUErQixDQUFDO1lBQ3RDWSxRQUFRRztZQUNSRixVQUFVO1lBQ1ZULE1BQU1KLHlDQUFRLENBQUNTO1FBQ25CO0lBQ0o7QUFDSjtBQUNBLGNBQWMsR0FDUCxTQUFTTyxJQUFJQyxJQUFJLEVBQUVDLFVBQVUsQ0FBQyxDQUFDO0lBQ2xDLE1BQU0sRUFBRUMsR0FBRyxFQUFFZixPQUFPLEVBQUUsRUFBRSxHQUFHYztJQUMzQixJQUFJZCxTQUFTLEdBQ1QsT0FBT2E7SUFDWCxNQUFNZixNQUFNZSxLQUFLRyxPQUFPLENBQUMsTUFBTTtJQUMvQixJQUFJbEIsSUFBSW1CLE1BQU0sR0FBR2pCLE9BQU8sR0FDcEIsTUFBTSxJQUFJSixnRUFBK0IsQ0FBQztRQUN0Q0ksTUFBTW1CLEtBQUtDLElBQUksQ0FBQ3RCLElBQUltQixNQUFNLEdBQUc7UUFDN0JJLFlBQVlyQjtRQUNac0IsTUFBTTtJQUNWO0lBQ0osT0FBTyxDQUFDLEVBQUUsRUFBRXhCLEdBQUcsQ0FBQ2lCLFFBQVEsVUFBVSxXQUFXLFdBQVcsQ0FBQ2YsT0FBTyxHQUFHLEtBQUssQ0FBQztBQUM3RTtBQUNBLGNBQWMsR0FDUCxTQUFTdUIsS0FBS2xCLEtBQUssRUFBRVMsVUFBVSxDQUFDLENBQUM7SUFDcEMsTUFBTSxFQUFFQyxNQUFNLE1BQU0sRUFBRSxHQUFHRDtJQUN6QixJQUFJVSxPQUFPbkIsTUFBTVcsT0FBTyxDQUFDLE1BQU07SUFDL0IsSUFBSVMsY0FBYztJQUNsQixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUYsS0FBS1AsTUFBTSxHQUFHLEdBQUdTLElBQUs7UUFDdEMsSUFBSUYsSUFBSSxDQUFDVCxRQUFRLFNBQVNXLElBQUlGLEtBQUtQLE1BQU0sR0FBR1MsSUFBSSxFQUFFLENBQUNDLFFBQVEsT0FBTyxLQUM5REY7YUFFQTtJQUNSO0lBQ0FELE9BQ0lULFFBQVEsU0FDRlMsS0FBS0ksS0FBSyxDQUFDSCxlQUNYRCxLQUFLSSxLQUFLLENBQUMsR0FBR0osS0FBS1AsTUFBTSxHQUFHUTtJQUN0QyxJQUFJRCxTQUFTLEtBQ1QsT0FBTztJQUNYLElBQUlULFFBQVEsV0FBV1MsS0FBS1AsTUFBTSxHQUFHLE1BQU0sR0FDdkMsT0FBTyxDQUFDLEVBQUUsRUFBRU8sS0FBSyxDQUFDLENBQUM7SUFDdkIsT0FBTyxDQUFDLEVBQUUsRUFBRUEsS0FBSyxDQUFDO0FBQ3RCLEVBQ0EsK0JBQStCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xhdy13b3Jrcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvaW50ZXJuYWwvaGV4LmpzPzlmYzAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgSGV4IGZyb20gJy4uL0hleC5qcyc7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0U2l6ZShoZXgsIHNpemVfKSB7XG4gICAgaWYgKEhleC5zaXplKGhleCkgPiBzaXplXylcbiAgICAgICAgdGhyb3cgbmV3IEhleC5TaXplT3ZlcmZsb3dFcnJvcih7XG4gICAgICAgICAgICBnaXZlblNpemU6IEhleC5zaXplKGhleCksXG4gICAgICAgICAgICBtYXhTaXplOiBzaXplXyxcbiAgICAgICAgfSk7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0U3RhcnRPZmZzZXQodmFsdWUsIHN0YXJ0KSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ251bWJlcicgJiYgc3RhcnQgPiAwICYmIHN0YXJ0ID4gSGV4LnNpemUodmFsdWUpIC0gMSlcbiAgICAgICAgdGhyb3cgbmV3IEhleC5TbGljZU9mZnNldE91dE9mQm91bmRzRXJyb3Ioe1xuICAgICAgICAgICAgb2Zmc2V0OiBzdGFydCxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnc3RhcnQnLFxuICAgICAgICAgICAgc2l6ZTogSGV4LnNpemUodmFsdWUpLFxuICAgICAgICB9KTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRFbmRPZmZzZXQodmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnbnVtYmVyJyAmJlxuICAgICAgICB0eXBlb2YgZW5kID09PSAnbnVtYmVyJyAmJlxuICAgICAgICBIZXguc2l6ZSh2YWx1ZSkgIT09IGVuZCAtIHN0YXJ0KSB7XG4gICAgICAgIHRocm93IG5ldyBIZXguU2xpY2VPZmZzZXRPdXRPZkJvdW5kc0Vycm9yKHtcbiAgICAgICAgICAgIG9mZnNldDogZW5kLFxuICAgICAgICAgICAgcG9zaXRpb246ICdlbmQnLFxuICAgICAgICAgICAgc2l6ZTogSGV4LnNpemUodmFsdWUpLFxuICAgICAgICB9KTtcbiAgICB9XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gcGFkKGhleF8sIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgZGlyLCBzaXplID0gMzIgfSA9IG9wdGlvbnM7XG4gICAgaWYgKHNpemUgPT09IDApXG4gICAgICAgIHJldHVybiBoZXhfO1xuICAgIGNvbnN0IGhleCA9IGhleF8ucmVwbGFjZSgnMHgnLCAnJyk7XG4gICAgaWYgKGhleC5sZW5ndGggPiBzaXplICogMilcbiAgICAgICAgdGhyb3cgbmV3IEhleC5TaXplRXhjZWVkc1BhZGRpbmdTaXplRXJyb3Ioe1xuICAgICAgICAgICAgc2l6ZTogTWF0aC5jZWlsKGhleC5sZW5ndGggLyAyKSxcbiAgICAgICAgICAgIHRhcmdldFNpemU6IHNpemUsXG4gICAgICAgICAgICB0eXBlOiAnSGV4JyxcbiAgICAgICAgfSk7XG4gICAgcmV0dXJuIGAweCR7aGV4W2RpciA9PT0gJ3JpZ2h0JyA/ICdwYWRFbmQnIDogJ3BhZFN0YXJ0J10oc2l6ZSAqIDIsICcwJyl9YDtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmltKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGRpciA9ICdsZWZ0JyB9ID0gb3B0aW9ucztcbiAgICBsZXQgZGF0YSA9IHZhbHVlLnJlcGxhY2UoJzB4JywgJycpO1xuICAgIGxldCBzbGljZUxlbmd0aCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBpZiAoZGF0YVtkaXIgPT09ICdsZWZ0JyA/IGkgOiBkYXRhLmxlbmd0aCAtIGkgLSAxXS50b1N0cmluZygpID09PSAnMCcpXG4gICAgICAgICAgICBzbGljZUxlbmd0aCsrO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgZGF0YSA9XG4gICAgICAgIGRpciA9PT0gJ2xlZnQnXG4gICAgICAgICAgICA/IGRhdGEuc2xpY2Uoc2xpY2VMZW5ndGgpXG4gICAgICAgICAgICA6IGRhdGEuc2xpY2UoMCwgZGF0YS5sZW5ndGggLSBzbGljZUxlbmd0aCk7XG4gICAgaWYgKGRhdGEgPT09ICcwJylcbiAgICAgICAgcmV0dXJuICcweCc7XG4gICAgaWYgKGRpciA9PT0gJ3JpZ2h0JyAmJiBkYXRhLmxlbmd0aCAlIDIgPT09IDEpXG4gICAgICAgIHJldHVybiBgMHgke2RhdGF9MGA7XG4gICAgcmV0dXJuIGAweCR7ZGF0YX1gO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJIZXgiLCJhc3NlcnRTaXplIiwiaGV4Iiwic2l6ZV8iLCJzaXplIiwiU2l6ZU92ZXJmbG93RXJyb3IiLCJnaXZlblNpemUiLCJtYXhTaXplIiwiYXNzZXJ0U3RhcnRPZmZzZXQiLCJ2YWx1ZSIsInN0YXJ0IiwiU2xpY2VPZmZzZXRPdXRPZkJvdW5kc0Vycm9yIiwib2Zmc2V0IiwicG9zaXRpb24iLCJhc3NlcnRFbmRPZmZzZXQiLCJlbmQiLCJwYWQiLCJoZXhfIiwib3B0aW9ucyIsImRpciIsInJlcGxhY2UiLCJsZW5ndGgiLCJTaXplRXhjZWVkc1BhZGRpbmdTaXplRXJyb3IiLCJNYXRoIiwiY2VpbCIsInRhcmdldFNpemUiLCJ0eXBlIiwidHJpbSIsImRhdGEiLCJzbGljZUxlbmd0aCIsImkiLCJ0b1N0cmluZyIsInNsaWNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/internal/hex.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/internal/lru.js":
/*!***************************************************!*\
  !*** ./node_modules/ox/_esm/core/internal/lru.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LruMap: () => (/* binding */ LruMap)\n/* harmony export */ });\n/**\n * @internal\n *\n * Map with a LRU (Least recently used) policy.\n * @see https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU\n */ class LruMap extends Map {\n    constructor(size){\n        super();\n        Object.defineProperty(this, \"maxSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.maxSize = size;\n    }\n    get(key) {\n        const value = super.get(key);\n        if (super.has(key) && value !== undefined) {\n            this.delete(key);\n            super.set(key, value);\n        }\n        return value;\n    }\n    set(key, value) {\n        super.set(key, value);\n        if (this.maxSize && this.size > this.maxSize) {\n            const firstKey = this.keys().next().value;\n            if (firstKey) this.delete(firstKey);\n        }\n        return this;\n    }\n} //# sourceMappingURL=lru.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2xydS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7Ozs7O0NBS0MsR0FDTSxNQUFNQSxlQUFlQztJQUN4QkMsWUFBWUMsSUFBSSxDQUFFO1FBQ2QsS0FBSztRQUNMQyxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLFdBQVc7WUFDbkNDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtRQUNBLElBQUksQ0FBQ0MsT0FBTyxHQUFHUDtJQUNuQjtJQUNBUSxJQUFJQyxHQUFHLEVBQUU7UUFDTCxNQUFNSCxRQUFRLEtBQUssQ0FBQ0UsSUFBSUM7UUFDeEIsSUFBSSxLQUFLLENBQUNDLElBQUlELFFBQVFILFVBQVVLLFdBQVc7WUFDdkMsSUFBSSxDQUFDQyxNQUFNLENBQUNIO1lBQ1osS0FBSyxDQUFDSSxJQUFJSixLQUFLSDtRQUNuQjtRQUNBLE9BQU9BO0lBQ1g7SUFDQU8sSUFBSUosR0FBRyxFQUFFSCxLQUFLLEVBQUU7UUFDWixLQUFLLENBQUNPLElBQUlKLEtBQUtIO1FBQ2YsSUFBSSxJQUFJLENBQUNDLE9BQU8sSUFBSSxJQUFJLENBQUNQLElBQUksR0FBRyxJQUFJLENBQUNPLE9BQU8sRUFBRTtZQUMxQyxNQUFNTyxXQUFXLElBQUksQ0FBQ0MsSUFBSSxHQUFHQyxJQUFJLEdBQUdWLEtBQUs7WUFDekMsSUFBSVEsVUFDQSxJQUFJLENBQUNGLE1BQU0sQ0FBQ0U7UUFDcEI7UUFDQSxPQUFPLElBQUk7SUFDZjtBQUNKLEVBQ0EsK0JBQStCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xhdy13b3Jrcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvaW50ZXJuYWwvbHJ1LmpzPzVkMjgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAaW50ZXJuYWxcbiAqXG4gKiBNYXAgd2l0aCBhIExSVSAoTGVhc3QgcmVjZW50bHkgdXNlZCkgcG9saWN5LlxuICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DYWNoZV9yZXBsYWNlbWVudF9wb2xpY2llcyNMUlVcbiAqL1xuZXhwb3J0IGNsYXNzIExydU1hcCBleHRlbmRzIE1hcCB7XG4gICAgY29uc3RydWN0b3Ioc2l6ZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXhTaXplXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWF4U2l6ZSA9IHNpemU7XG4gICAgfVxuICAgIGdldChrZXkpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBzdXBlci5nZXQoa2V5KTtcbiAgICAgICAgaWYgKHN1cGVyLmhhcyhrZXkpICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICBzdXBlci5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBzdXBlci5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIGlmICh0aGlzLm1heFNpemUgJiYgdGhpcy5zaXplID4gdGhpcy5tYXhTaXplKSB7XG4gICAgICAgICAgICBjb25zdCBmaXJzdEtleSA9IHRoaXMua2V5cygpLm5leHQoKS52YWx1ZTtcbiAgICAgICAgICAgIGlmIChmaXJzdEtleSlcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGV0ZShmaXJzdEtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bHJ1LmpzLm1hcCJdLCJuYW1lcyI6WyJMcnVNYXAiLCJNYXAiLCJjb25zdHJ1Y3RvciIsInNpemUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsInZhbHVlIiwibWF4U2l6ZSIsImdldCIsImtleSIsImhhcyIsInVuZGVmaW5lZCIsImRlbGV0ZSIsInNldCIsImZpcnN0S2V5Iiwia2V5cyIsIm5leHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/internal/lru.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/internal/webauthn.js":
/*!********************************************************!*\
  !*** ./node_modules/ox/_esm/core/internal/webauthn.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseAsn1Signature: () => (/* binding */ parseAsn1Signature),\n/* harmony export */   parseCredentialPublicKey: () => (/* binding */ parseCredentialPublicKey)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_p256__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/curves/p256 */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/p256.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _PublicKey_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../PublicKey.js */ \"(ssr)/./node_modules/ox/_esm/core/PublicKey.js\");\n/* harmony import */ var _WebAuthnP256_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../WebAuthnP256.js */ \"(ssr)/./node_modules/ox/_esm/core/WebAuthnP256.js\");\n\n\n\n\n/**\n * Parses an ASN.1 signature into a r and s value.\n *\n * @internal\n */ function parseAsn1Signature(bytes) {\n    const r_start = bytes[4] === 0 ? 5 : 4;\n    const r_end = r_start + 32;\n    const s_start = bytes[r_end + 2] === 0 ? r_end + 3 : r_end + 2;\n    const r = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromBytes(bytes.slice(r_start, r_end)));\n    const s = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromBytes(bytes.slice(s_start)));\n    return {\n        r,\n        s: s > _noble_curves_p256__WEBPACK_IMPORTED_MODULE_1__.p256.CURVE.n / 2n ? _noble_curves_p256__WEBPACK_IMPORTED_MODULE_1__.p256.CURVE.n - s : s\n    };\n}\n/**\n * Parses a public key into x and y coordinates from the public key\n * defined on the credential.\n *\n * @internal\n */ async function parseCredentialPublicKey(response) {\n    try {\n        const publicKeyBuffer = response.getPublicKey();\n        if (!publicKeyBuffer) throw new _WebAuthnP256_js__WEBPACK_IMPORTED_MODULE_2__.CredentialCreationFailedError();\n        // Converting `publicKeyBuffer` throws when credential is created by 1Password Firefox Add-on\n        const publicKeyBytes = new Uint8Array(publicKeyBuffer);\n        const cryptoKey = await crypto.subtle.importKey(\"spki\", new Uint8Array(publicKeyBytes), {\n            name: \"ECDSA\",\n            namedCurve: \"P-256\",\n            hash: \"SHA-256\"\n        }, true, [\n            \"verify\"\n        ]);\n        const publicKey = new Uint8Array(await crypto.subtle.exportKey(\"raw\", cryptoKey));\n        return _PublicKey_js__WEBPACK_IMPORTED_MODULE_3__.from(publicKey);\n    } catch (error) {\n        // Fallback for 1Password Firefox Add-on restricts access to certain credential properties\n        // so we need to use `attestationObject` to extract the public key.\n        // https://github.com/passwordless-id/webauthn/issues/50#issuecomment-2072902094\n        if (error.message !== \"Permission denied to access object\") throw error;\n        const data = new Uint8Array(response.attestationObject);\n        const coordinateLength = 0x20;\n        const cborPrefix = 0x58;\n        const findStart = (key)=>{\n            const coordinate = new Uint8Array([\n                key,\n                cborPrefix,\n                coordinateLength\n            ]);\n            for(let i = 0; i < data.length - coordinate.length; i++)if (coordinate.every((byte, j)=>data[i + j] === byte)) return i + coordinate.length;\n            throw new _WebAuthnP256_js__WEBPACK_IMPORTED_MODULE_2__.CredentialCreationFailedError();\n        };\n        const xStart = findStart(0x21);\n        const yStart = findStart(0x22);\n        return _PublicKey_js__WEBPACK_IMPORTED_MODULE_3__.from(new Uint8Array([\n            0x04,\n            ...data.slice(xStart, xStart + coordinateLength),\n            ...data.slice(yStart, yStart + coordinateLength)\n        ]));\n    }\n} //# sourceMappingURL=webauthn.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL3dlYmF1dGhuLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUEwQztBQUNUO0FBQ1k7QUFDc0I7QUFDbkU7Ozs7Q0FJQyxHQUNNLFNBQVNJLG1CQUFtQkMsS0FBSztJQUNwQyxNQUFNQyxVQUFVRCxLQUFLLENBQUMsRUFBRSxLQUFLLElBQUksSUFBSTtJQUNyQyxNQUFNRSxRQUFRRCxVQUFVO0lBQ3hCLE1BQU1FLFVBQVVILEtBQUssQ0FBQ0UsUUFBUSxFQUFFLEtBQUssSUFBSUEsUUFBUSxJQUFJQSxRQUFRO0lBQzdELE1BQU1FLElBQUlDLE9BQU9ULDhDQUFhLENBQUNJLE1BQU1PLEtBQUssQ0FBQ04sU0FBU0M7SUFDcEQsTUFBTU0sSUFBSUgsT0FBT1QsOENBQWEsQ0FBQ0ksTUFBTU8sS0FBSyxDQUFDSjtJQUMzQyxPQUFPO1FBQ0hDO1FBQ0FJLEdBQUdBLElBQUliLG9EQUFJQSxDQUFDYyxLQUFLLENBQUNDLENBQUMsR0FBRyxFQUFFLEdBQUdmLG9EQUFJQSxDQUFDYyxLQUFLLENBQUNDLENBQUMsR0FBR0YsSUFBSUE7SUFDbEQ7QUFDSjtBQUNBOzs7OztDQUtDLEdBQ00sZUFBZUcseUJBQXlCQyxRQUFRO0lBQ25ELElBQUk7UUFDQSxNQUFNQyxrQkFBa0JELFNBQVNFLFlBQVk7UUFDN0MsSUFBSSxDQUFDRCxpQkFDRCxNQUFNLElBQUlmLDJFQUE2QkE7UUFDM0MsNkZBQTZGO1FBQzdGLE1BQU1pQixpQkFBaUIsSUFBSUMsV0FBV0g7UUFDdEMsTUFBTUksWUFBWSxNQUFNQyxPQUFPQyxNQUFNLENBQUNDLFNBQVMsQ0FBQyxRQUFRLElBQUlKLFdBQVdELGlCQUFpQjtZQUNwRk0sTUFBTTtZQUNOQyxZQUFZO1lBQ1pDLE1BQU07UUFDVixHQUFHLE1BQU07WUFBQztTQUFTO1FBQ25CLE1BQU1DLFlBQVksSUFBSVIsV0FBVyxNQUFNRSxPQUFPQyxNQUFNLENBQUNNLFNBQVMsQ0FBQyxPQUFPUjtRQUN0RSxPQUFPcEIsK0NBQWMsQ0FBQzJCO0lBQzFCLEVBQ0EsT0FBT0csT0FBTztRQUNWLDBGQUEwRjtRQUMxRixtRUFBbUU7UUFDbkUsZ0ZBQWdGO1FBQ2hGLElBQUlBLE1BQU1DLE9BQU8sS0FBSyxzQ0FDbEIsTUFBTUQ7UUFDVixNQUFNRSxPQUFPLElBQUliLFdBQVdKLFNBQVNrQixpQkFBaUI7UUFDdEQsTUFBTUMsbUJBQW1CO1FBQ3pCLE1BQU1DLGFBQWE7UUFDbkIsTUFBTUMsWUFBWSxDQUFDQztZQUNmLE1BQU1DLGFBQWEsSUFBSW5CLFdBQVc7Z0JBQUNrQjtnQkFBS0Y7Z0JBQVlEO2FBQWlCO1lBQ3JFLElBQUssSUFBSUssSUFBSSxHQUFHQSxJQUFJUCxLQUFLUSxNQUFNLEdBQUdGLFdBQVdFLE1BQU0sRUFBRUQsSUFDakQsSUFBSUQsV0FBV0csS0FBSyxDQUFDLENBQUNDLE1BQU1DLElBQU1YLElBQUksQ0FBQ08sSUFBSUksRUFBRSxLQUFLRCxPQUM5QyxPQUFPSCxJQUFJRCxXQUFXRSxNQUFNO1lBQ3BDLE1BQU0sSUFBSXZDLDJFQUE2QkE7UUFDM0M7UUFDQSxNQUFNMkMsU0FBU1IsVUFBVTtRQUN6QixNQUFNUyxTQUFTVCxVQUFVO1FBQ3pCLE9BQU9wQywrQ0FBYyxDQUFDLElBQUltQixXQUFXO1lBQ2pDO2VBQ0dhLEtBQUt0QixLQUFLLENBQUNrQyxRQUFRQSxTQUFTVjtlQUM1QkYsS0FBS3RCLEtBQUssQ0FBQ21DLFFBQVFBLFNBQVNYO1NBQ2xDO0lBQ0w7QUFDSixFQUNBLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsYXctd29ya3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL3dlYmF1dGhuLmpzPzBjYTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcDI1NiB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvcDI1Nic7XG5pbXBvcnQgKiBhcyBIZXggZnJvbSAnLi4vSGV4LmpzJztcbmltcG9ydCAqIGFzIFB1YmxpY0tleSBmcm9tICcuLi9QdWJsaWNLZXkuanMnO1xuaW1wb3J0IHsgQ3JlZGVudGlhbENyZWF0aW9uRmFpbGVkRXJyb3IgfSBmcm9tICcuLi9XZWJBdXRoblAyNTYuanMnO1xuLyoqXG4gKiBQYXJzZXMgYW4gQVNOLjEgc2lnbmF0dXJlIGludG8gYSByIGFuZCBzIHZhbHVlLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VBc24xU2lnbmF0dXJlKGJ5dGVzKSB7XG4gICAgY29uc3Qgcl9zdGFydCA9IGJ5dGVzWzRdID09PSAwID8gNSA6IDQ7XG4gICAgY29uc3Qgcl9lbmQgPSByX3N0YXJ0ICsgMzI7XG4gICAgY29uc3Qgc19zdGFydCA9IGJ5dGVzW3JfZW5kICsgMl0gPT09IDAgPyByX2VuZCArIDMgOiByX2VuZCArIDI7XG4gICAgY29uc3QgciA9IEJpZ0ludChIZXguZnJvbUJ5dGVzKGJ5dGVzLnNsaWNlKHJfc3RhcnQsIHJfZW5kKSkpO1xuICAgIGNvbnN0IHMgPSBCaWdJbnQoSGV4LmZyb21CeXRlcyhieXRlcy5zbGljZShzX3N0YXJ0KSkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHIsXG4gICAgICAgIHM6IHMgPiBwMjU2LkNVUlZFLm4gLyAybiA/IHAyNTYuQ1VSVkUubiAtIHMgOiBzLFxuICAgIH07XG59XG4vKipcbiAqIFBhcnNlcyBhIHB1YmxpYyBrZXkgaW50byB4IGFuZCB5IGNvb3JkaW5hdGVzIGZyb20gdGhlIHB1YmxpYyBrZXlcbiAqIGRlZmluZWQgb24gdGhlIGNyZWRlbnRpYWwuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwYXJzZUNyZWRlbnRpYWxQdWJsaWNLZXkocmVzcG9uc2UpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBwdWJsaWNLZXlCdWZmZXIgPSByZXNwb25zZS5nZXRQdWJsaWNLZXkoKTtcbiAgICAgICAgaWYgKCFwdWJsaWNLZXlCdWZmZXIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgQ3JlZGVudGlhbENyZWF0aW9uRmFpbGVkRXJyb3IoKTtcbiAgICAgICAgLy8gQ29udmVydGluZyBgcHVibGljS2V5QnVmZmVyYCB0aHJvd3Mgd2hlbiBjcmVkZW50aWFsIGlzIGNyZWF0ZWQgYnkgMVBhc3N3b3JkIEZpcmVmb3ggQWRkLW9uXG4gICAgICAgIGNvbnN0IHB1YmxpY0tleUJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkocHVibGljS2V5QnVmZmVyKTtcbiAgICAgICAgY29uc3QgY3J5cHRvS2V5ID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoJ3Nwa2knLCBuZXcgVWludDhBcnJheShwdWJsaWNLZXlCeXRlcyksIHtcbiAgICAgICAgICAgIG5hbWU6ICdFQ0RTQScsXG4gICAgICAgICAgICBuYW1lZEN1cnZlOiAnUC0yNTYnLFxuICAgICAgICAgICAgaGFzaDogJ1NIQS0yNTYnLFxuICAgICAgICB9LCB0cnVlLCBbJ3ZlcmlmeSddKTtcbiAgICAgICAgY29uc3QgcHVibGljS2V5ID0gbmV3IFVpbnQ4QXJyYXkoYXdhaXQgY3J5cHRvLnN1YnRsZS5leHBvcnRLZXkoJ3JhdycsIGNyeXB0b0tleSkpO1xuICAgICAgICByZXR1cm4gUHVibGljS2V5LmZyb20ocHVibGljS2V5KTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIEZhbGxiYWNrIGZvciAxUGFzc3dvcmQgRmlyZWZveCBBZGQtb24gcmVzdHJpY3RzIGFjY2VzcyB0byBjZXJ0YWluIGNyZWRlbnRpYWwgcHJvcGVydGllc1xuICAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIHVzZSBgYXR0ZXN0YXRpb25PYmplY3RgIHRvIGV4dHJhY3QgdGhlIHB1YmxpYyBrZXkuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wYXNzd29yZGxlc3MtaWQvd2ViYXV0aG4vaXNzdWVzLzUwI2lzc3VlY29tbWVudC0yMDcyOTAyMDk0XG4gICAgICAgIGlmIChlcnJvci5tZXNzYWdlICE9PSAnUGVybWlzc2lvbiBkZW5pZWQgdG8gYWNjZXNzIG9iamVjdCcpXG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KHJlc3BvbnNlLmF0dGVzdGF0aW9uT2JqZWN0KTtcbiAgICAgICAgY29uc3QgY29vcmRpbmF0ZUxlbmd0aCA9IDB4MjA7XG4gICAgICAgIGNvbnN0IGNib3JQcmVmaXggPSAweDU4O1xuICAgICAgICBjb25zdCBmaW5kU3RhcnQgPSAoa2V5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb29yZGluYXRlID0gbmV3IFVpbnQ4QXJyYXkoW2tleSwgY2JvclByZWZpeCwgY29vcmRpbmF0ZUxlbmd0aF0pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aCAtIGNvb3JkaW5hdGUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKGNvb3JkaW5hdGUuZXZlcnkoKGJ5dGUsIGopID0+IGRhdGFbaSArIGpdID09PSBieXRlKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkgKyBjb29yZGluYXRlLmxlbmd0aDtcbiAgICAgICAgICAgIHRocm93IG5ldyBDcmVkZW50aWFsQ3JlYXRpb25GYWlsZWRFcnJvcigpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB4U3RhcnQgPSBmaW5kU3RhcnQoMHgyMSk7XG4gICAgICAgIGNvbnN0IHlTdGFydCA9IGZpbmRTdGFydCgweDIyKTtcbiAgICAgICAgcmV0dXJuIFB1YmxpY0tleS5mcm9tKG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgICAgIDB4MDQsXG4gICAgICAgICAgICAuLi5kYXRhLnNsaWNlKHhTdGFydCwgeFN0YXJ0ICsgY29vcmRpbmF0ZUxlbmd0aCksXG4gICAgICAgICAgICAuLi5kYXRhLnNsaWNlKHlTdGFydCwgeVN0YXJ0ICsgY29vcmRpbmF0ZUxlbmd0aCksXG4gICAgICAgIF0pKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWJhdXRobi5qcy5tYXAiXSwibmFtZXMiOlsicDI1NiIsIkhleCIsIlB1YmxpY0tleSIsIkNyZWRlbnRpYWxDcmVhdGlvbkZhaWxlZEVycm9yIiwicGFyc2VBc24xU2lnbmF0dXJlIiwiYnl0ZXMiLCJyX3N0YXJ0Iiwicl9lbmQiLCJzX3N0YXJ0IiwiciIsIkJpZ0ludCIsImZyb21CeXRlcyIsInNsaWNlIiwicyIsIkNVUlZFIiwibiIsInBhcnNlQ3JlZGVudGlhbFB1YmxpY0tleSIsInJlc3BvbnNlIiwicHVibGljS2V5QnVmZmVyIiwiZ2V0UHVibGljS2V5IiwicHVibGljS2V5Qnl0ZXMiLCJVaW50OEFycmF5IiwiY3J5cHRvS2V5IiwiY3J5cHRvIiwic3VidGxlIiwiaW1wb3J0S2V5IiwibmFtZSIsIm5hbWVkQ3VydmUiLCJoYXNoIiwicHVibGljS2V5IiwiZXhwb3J0S2V5IiwiZnJvbSIsImVycm9yIiwibWVzc2FnZSIsImRhdGEiLCJhdHRlc3RhdGlvbk9iamVjdCIsImNvb3JkaW5hdGVMZW5ndGgiLCJjYm9yUHJlZml4IiwiZmluZFN0YXJ0Iiwia2V5IiwiY29vcmRpbmF0ZSIsImkiLCJsZW5ndGgiLCJldmVyeSIsImJ5dGUiLCJqIiwieFN0YXJ0IiwieVN0YXJ0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/internal/webauthn.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/version.js":
/*!**********************************************!*\
  !*** ./node_modules/ox/_esm/core/version.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/** @internal */ const version = \"0.1.1\"; //# sourceMappingURL=version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGNBQWMsR0FDUCxNQUFNQSxVQUFVLFFBQVEsQ0FDL0IsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xhdy13b3Jrcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvdmVyc2lvbi5qcz84MmNjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCB2ZXJzaW9uID0gJzAuMS4xJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlcnNpb24uanMubWFwIl0sIm5hbWVzIjpbInZlcnNpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/erc6492/SignatureErc6492.js":
/*!**********************************************************!*\
  !*** ./node_modules/ox/_esm/erc6492/SignatureErc6492.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidWrappedSignatureError: () => (/* binding */ InvalidWrappedSignatureError),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   magicBytes: () => (/* binding */ magicBytes),\n/* harmony export */   universalSignatureValidatorAbi: () => (/* binding */ universalSignatureValidatorAbi),\n/* harmony export */   universalSignatureValidatorBytecode: () => (/* binding */ universalSignatureValidatorBytecode),\n/* harmony export */   unwrap: () => (/* binding */ unwrap),\n/* harmony export */   validate: () => (/* binding */ validate),\n/* harmony export */   wrap: () => (/* binding */ wrap)\n/* harmony export */ });\n/* harmony import */ var _core_AbiParameters_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/AbiParameters.js */ \"(ssr)/./node_modules/ox/_esm/core/AbiParameters.js\");\n/* harmony import */ var _core_Errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _core_Hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n\n\n\n/**\n * Magic bytes used to identify ERC-6492 wrapped signatures.\n */ const magicBytes = \"0x6492649264926492649264926492649264926492649264926492649264926492\";\n/**\n * Deployless ERC-6492 signature verification bytecode.\n */ const universalSignatureValidatorBytecode = \"0x608060405234801561001057600080fd5b5060405161069438038061069483398101604081905261002f9161051e565b600061003c848484610048565b9050806000526001601ff35b60007f64926492649264926492649264926492649264926492649264926492649264926100748361040c565b036101e7576000606080848060200190518101906100929190610577565b60405192955090935091506000906001600160a01b038516906100b69085906105dd565b6000604051808303816000865af19150503d80600081146100f3576040519150601f19603f3d011682016040523d82523d6000602084013e6100f8565b606091505b50509050876001600160a01b03163b60000361016057806101605760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90610190908b9087906004016105f9565b602060405180830381865afa1580156101ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101d19190610633565b6001600160e01b03191614945050505050610405565b6001600160a01b0384163b1561027a57604051630b135d3f60e11b808252906001600160a01b03861690631626ba7e9061022790879087906004016105f9565b602060405180830381865afa158015610244573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102689190610633565b6001600160e01b031916149050610405565b81516041146102df5760405162461bcd60e51b815260206004820152603a602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e6774680000000000006064820152608401610157565b6102e7610425565b5060208201516040808401518451859392600091859190811061030c5761030c61065d565b016020015160f81c9050601b811480159061032b57508060ff16601c14155b1561038c5760405162461bcd60e51b815260206004820152603b602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c756500000000006064820152608401610157565b60408051600081526020810180835289905260ff83169181019190915260608101849052608081018390526001600160a01b0389169060019060a0016020604051602081039080840390855afa1580156103ea573d6000803e3d6000fd5b505050602060405103516001600160a01b0316149450505050505b9392505050565b600060208251101561041d57600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b038116811461045857600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561048c578181015183820152602001610474565b50506000910152565b600082601f8301126104a657600080fd5b81516001600160401b038111156104bf576104bf61045b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156104ed576104ed61045b565b60405281815283820160200185101561050557600080fd5b610516826020830160208701610471565b949350505050565b60008060006060848603121561053357600080fd5b835161053e81610443565b6020850151604086015191945092506001600160401b0381111561056157600080fd5b61056d86828701610495565b9150509250925092565b60008060006060848603121561058c57600080fd5b835161059781610443565b60208501519093506001600160401b038111156105b357600080fd5b6105bf86828701610495565b604086015190935090506001600160401b0381111561056157600080fd5b600082516105ef818460208701610471565b9190910192915050565b828152604060208201526000825180604084015261061e816060850160208701610471565b601f01601f1916919091016060019392505050565b60006020828403121561064557600080fd5b81516001600160e01b03198116811461040557600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572\";\n/**\n * ABI for the ERC-6492 universal deployless signature validator contract.\n *\n * Constructor return value is `0x1` (valid) or `0x0` (invalid).\n */ const universalSignatureValidatorAbi = [\n    {\n        inputs: [\n            {\n                name: \"_signer\",\n                type: \"address\"\n            },\n            {\n                name: \"_hash\",\n                type: \"bytes32\"\n            },\n            {\n                name: \"_signature\",\n                type: \"bytes\"\n            }\n        ],\n        stateMutability: \"nonpayable\",\n        type: \"constructor\"\n    },\n    {\n        inputs: [\n            {\n                name: \"_signer\",\n                type: \"address\"\n            },\n            {\n                name: \"_hash\",\n                type: \"bytes32\"\n            },\n            {\n                name: \"_signature\",\n                type: \"bytes\"\n            }\n        ],\n        outputs: [\n            {\n                type: \"bool\"\n            }\n        ],\n        stateMutability: \"nonpayable\",\n        type: \"function\",\n        name: \"isValidSig\"\n    }\n];\n/**\n * Asserts that the wrapped signature is valid.\n *\n * @example\n * ```ts twoslash\n * import { SignatureErc6492 } from 'ox/erc6492'\n *\n * SignatureErc6492.assert('0xdeadbeef')\n * // @error: InvalidWrappedSignatureError: Value `0xdeadbeef` is an invalid ERC-6492 wrapped signature.\n * ```\n *\n * @param wrapped - The wrapped signature to assert.\n */ function assert(wrapped) {\n    if (_core_Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(wrapped, -32) !== magicBytes) throw new InvalidWrappedSignatureError(wrapped);\n}\n/**\n * Parses an [ERC-6492 wrapped signature](https://eips.ethereum.org/EIPS/eip-6492#specification) into its constituent parts.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1 } from 'ox'\n * import { SignatureErc6492 } from 'ox/erc6492' // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload: '0x...',\n *   privateKey: '0x...',\n * })\n *\n * // Instantiate from serialized format. // [!code focus]\n * const wrapped = SignatureErc6492.from('0x...') // [!code focus]\n * // @log: { data: '0x...', signature: { ... }, to: '0x...', } // [!code focus]\n *\n * // Instantiate from constituent parts. // [!code focus]\n * const wrapped = SignatureErc6492.from({ // [!code focus]\n *   data: '0x...', // [!code focus]\n *   signature, // [!code focus]\n *   to: '0x...', // [!code focus]\n * })\n * // @log: { data: '0x...', signature: { ... }, to: '0x...', }\n * ```\n *\n * @param wrapped - Wrapped signature to parse.\n * @returns Wrapped signature.\n */ function from(wrapped) {\n    if (typeof wrapped === \"string\") return unwrap(wrapped);\n    return wrapped;\n}\n/**\n * Parses an [ERC-6492 wrapped signature](https://eips.ethereum.org/EIPS/eip-6492#specification) into its constituent parts.\n *\n * @example\n * ```ts twoslash\n * import { SignatureErc6492 } from 'ox/erc6492'\n *\n * const { data, signature, to } = SignatureErc6492.unwrap('0x...')\n * ```\n *\n * @param wrapped - Wrapped signature to parse.\n * @returns Wrapped signature.\n */ function unwrap(wrapped) {\n    assert(wrapped);\n    const [to, data, signature] = _core_AbiParameters_js__WEBPACK_IMPORTED_MODULE_1__.decode(_core_AbiParameters_js__WEBPACK_IMPORTED_MODULE_1__.from(\"address, bytes, bytes\"), wrapped);\n    return {\n        data,\n        signature,\n        to\n    };\n}\n/**\n * Serializes an [ERC-6492 wrapped signature](https://eips.ethereum.org/EIPS/eip-6492#specification).\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1, Signature } from 'ox'\n * import { SignatureErc6492 } from 'ox/erc6492' // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload: '0x...',\n *   privateKey: '0x...',\n * })\n *\n * const wrapped = SignatureErc6492.wrap({ // [!code focus]\n *   data: '0xdeadbeef', // [!code focus]\n *   signature: Signature.toHex(signature), // [!code focus]\n *   to: '0x00000000219ab540356cBB839Cbe05303d7705Fa', // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param value - Wrapped signature to serialize.\n * @returns Serialized wrapped signature.\n */ function wrap(value) {\n    const { data, signature, to } = value;\n    return _core_Hex_js__WEBPACK_IMPORTED_MODULE_0__.concat(_core_AbiParameters_js__WEBPACK_IMPORTED_MODULE_1__.encode(_core_AbiParameters_js__WEBPACK_IMPORTED_MODULE_1__.from(\"address, bytes, bytes\"), [\n        to,\n        data,\n        signature\n    ]), magicBytes);\n}\n/**\n * Validates a wrapped signature. Returns `true` if the wrapped signature is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { SignatureErc6492 } from 'ox/erc6492'\n *\n * const valid = SignatureErc6492.validate('0xdeadbeef')\n * // @log: false\n * ```\n *\n * @param wrapped - The wrapped signature to validate.\n * @returns `true` if the wrapped signature is valid, `false` otherwise.\n */ function validate(wrapped) {\n    try {\n        assert(wrapped);\n        return true;\n    } catch  {\n        return false;\n    }\n}\n/** Thrown when the ERC-6492 wrapped signature is invalid. */ class InvalidWrappedSignatureError extends _core_Errors_js__WEBPACK_IMPORTED_MODULE_2__.BaseError {\n    constructor(wrapped){\n        super(`Value \\`${wrapped}\\` is an invalid ERC-6492 wrapped signature.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"SignatureErc6492.InvalidWrappedSignatureError\"\n        });\n    }\n} //# sourceMappingURL=SignatureErc6492.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9lcmM2NDkyL1NpZ25hdHVyZUVyYzY0OTIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQTBEO0FBQ2Q7QUFDTjtBQUN0Qzs7Q0FFQyxHQUNNLE1BQU1HLGFBQWEscUVBQXFFO0FBQy9GOztDQUVDLEdBQ00sTUFBTUMsc0NBQXNDLDZ5R0FBNnlHO0FBQ2gyRzs7OztDQUlDLEdBQ00sTUFBTUMsaUNBQWlDO0lBQzFDO1FBQ0lDLFFBQVE7WUFDSjtnQkFDSUMsTUFBTTtnQkFDTkMsTUFBTTtZQUNWO1lBQ0E7Z0JBQ0lELE1BQU07Z0JBQ05DLE1BQU07WUFDVjtZQUNBO2dCQUNJRCxNQUFNO2dCQUNOQyxNQUFNO1lBQ1Y7U0FDSDtRQUNEQyxpQkFBaUI7UUFDakJELE1BQU07SUFDVjtJQUNBO1FBQ0lGLFFBQVE7WUFDSjtnQkFDSUMsTUFBTTtnQkFDTkMsTUFBTTtZQUNWO1lBQ0E7Z0JBQ0lELE1BQU07Z0JBQ05DLE1BQU07WUFDVjtZQUNBO2dCQUNJRCxNQUFNO2dCQUNOQyxNQUFNO1lBQ1Y7U0FDSDtRQUNERSxTQUFTO1lBQ0w7Z0JBQ0lGLE1BQU07WUFDVjtTQUNIO1FBQ0RDLGlCQUFpQjtRQUNqQkQsTUFBTTtRQUNORCxNQUFNO0lBQ1Y7Q0FDSCxDQUFDO0FBQ0Y7Ozs7Ozs7Ozs7OztDQVlDLEdBQ00sU0FBU0ksT0FBT0MsT0FBTztJQUMxQixJQUFJViwrQ0FBUyxDQUFDVSxTQUFTLENBQUMsUUFBUVQsWUFDNUIsTUFBTSxJQUFJVyw2QkFBNkJGO0FBQy9DO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBNkJDLEdBQ00sU0FBU0csS0FBS0gsT0FBTztJQUN4QixJQUFJLE9BQU9BLFlBQVksVUFDbkIsT0FBT0ksT0FBT0o7SUFDbEIsT0FBT0E7QUFDWDtBQUNBOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUNNLFNBQVNJLE9BQU9KLE9BQU87SUFDMUJELE9BQU9DO0lBQ1AsTUFBTSxDQUFDSyxJQUFJQyxNQUFNQyxVQUFVLEdBQUduQiwwREFBb0IsQ0FBQ0Esd0RBQWtCLENBQUMsMEJBQTBCWTtJQUNoRyxPQUFPO1FBQUVNO1FBQU1DO1FBQVdGO0lBQUc7QUFDakM7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXNCQyxHQUNNLFNBQVNJLEtBQUtDLEtBQUs7SUFDdEIsTUFBTSxFQUFFSixJQUFJLEVBQUVDLFNBQVMsRUFBRUYsRUFBRSxFQUFFLEdBQUdLO0lBQ2hDLE9BQU9wQixnREFBVSxDQUFDRiwwREFBb0IsQ0FBQ0Esd0RBQWtCLENBQUMsMEJBQTBCO1FBQ2hGaUI7UUFDQUM7UUFDQUM7S0FDSCxHQUFHaEI7QUFDUjtBQUNBOzs7Ozs7Ozs7Ozs7O0NBYUMsR0FDTSxTQUFTc0IsU0FBU2IsT0FBTztJQUM1QixJQUFJO1FBQ0FELE9BQU9DO1FBQ1AsT0FBTztJQUNYLEVBQ0EsT0FBTTtRQUNGLE9BQU87SUFDWDtBQUNKO0FBQ0EsMkRBQTJELEdBQ3BELE1BQU1FLHFDQUFxQ2Isc0RBQWdCO0lBQzlEMEIsWUFBWWYsT0FBTyxDQUFFO1FBQ2pCLEtBQUssQ0FBQyxDQUFDLFFBQVEsRUFBRUEsUUFBUSw0Q0FBNEMsQ0FBQztRQUN0RWdCLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsUUFBUTtZQUNoQ0MsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVlYsT0FBTztRQUNYO0lBQ0o7QUFDSixFQUNBLDRDQUE0QyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsYXctd29ya3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9lcmM2NDkyL1NpZ25hdHVyZUVyYzY0OTIuanM/ZWM0NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBBYmlQYXJhbWV0ZXJzIGZyb20gJy4uL2NvcmUvQWJpUGFyYW1ldGVycy5qcyc7XG5pbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSAnLi4vY29yZS9FcnJvcnMuanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4uL2NvcmUvSGV4LmpzJztcbi8qKlxuICogTWFnaWMgYnl0ZXMgdXNlZCB0byBpZGVudGlmeSBFUkMtNjQ5MiB3cmFwcGVkIHNpZ25hdHVyZXMuXG4gKi9cbmV4cG9ydCBjb25zdCBtYWdpY0J5dGVzID0gJzB4NjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5Mic7XG4vKipcbiAqIERlcGxveWxlc3MgRVJDLTY0OTIgc2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBieXRlY29kZS5cbiAqL1xuZXhwb3J0IGNvbnN0IHVuaXZlcnNhbFNpZ25hdHVyZVZhbGlkYXRvckJ5dGVjb2RlID0gJzB4NjA4MDYwNDA1MjM0ODAxNTYxMDAxMDU3NjAwMDgwZmQ1YjUwNjA0MDUxNjEwNjk0MzgwMzgwNjEwNjk0ODMzOTgxMDE2MDQwODE5MDUyNjEwMDJmOTE2MTA1MWU1NjViNjAwMDYxMDAzYzg0ODQ4NDYxMDA0ODU2NWI5MDUwODA2MDAwNTI2MDAxNjAxZmYzNWI2MDAwN2Y2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjEwMDc0ODM2MTA0MGM1NjViMDM2MTAxZTc1NzYwMDA2MDYwODA4NDgwNjAyMDAxOTA1MTgxMDE5MDYxMDA5MjkxOTA2MTA1Nzc1NjViNjA0MDUxOTI5NTUwOTA5MzUwOTE1MDYwMDA5MDYwMDE2MDAxNjBhMDFiMDM4NTE2OTA2MTAwYjY5MDg1OTA2MTA1ZGQ1NjViNjAwMDYwNDA1MTgwODMwMzgxNjAwMDg2NWFmMTkxNTA1MDNkODA2MDAwODExNDYxMDBmMzU3NjA0MDUxOTE1MDYwMWYxOTYwM2YzZDAxMTY4MjAxNjA0MDUyM2Q4MjUyM2Q2MDAwNjAyMDg0MDEzZTYxMDBmODU2NWI2MDYwOTE1MDViNTA1MDkwNTA4NzYwMDE2MDAxNjBhMDFiMDMxNjNiNjAwMDAzNjEwMTYwNTc4MDYxMDE2MDU3NjA0MDUxNjI0NjFiY2Q2MGU1MWI4MTUyNjAyMDYwMDQ4MjAxNTI2MDFlNjAyNDgyMDE1MjdmNTM2OTY3NmU2MTc0NzU3MjY1NTY2MTZjNjk2NDYxNzQ2ZjcyM2EyMDY0NjU3MDZjNmY3OTZkNjU2ZTc0MDAwMDYwNDQ4MjAxNTI2MDY0MDE1YjYwNDA1MTgwOTEwMzkwZmQ1YjYwNDA1MTYzMGIxMzVkM2Y2MGUxMWI4MDgyNTI5MDYwMDE2MDAxNjBhMDFiMDM4YTE2OTA2MzE2MjZiYTdlOTA2MTAxOTA5MDhiOTA4NzkwNjAwNDAxNjEwNWY5NTY1YjYwMjA2MDQwNTE4MDgzMDM4MTg2NWFmYTE1ODAxNTYxMDFhZDU3M2Q2MDAwODAzZTNkNjAwMGZkNWI1MDUwNTA1MDYwNDA1MTNkNjAxZjE5NjAxZjgyMDExNjgyMDE4MDYwNDA1MjUwODEwMTkwNjEwMWQxOTE5MDYxMDYzMzU2NWI2MDAxNjAwMTYwZTAxYjAzMTkxNjE0OTQ1MDUwNTA1MDUwNjEwNDA1NTY1YjYwMDE2MDAxNjBhMDFiMDM4NDE2M2IxNTYxMDI3YTU3NjA0MDUxNjMwYjEzNWQzZjYwZTExYjgwODI1MjkwNjAwMTYwMDE2MGEwMWIwMzg2MTY5MDYzMTYyNmJhN2U5MDYxMDIyNzkwODc5MDg3OTA2MDA0MDE2MTA1Zjk1NjViNjAyMDYwNDA1MTgwODMwMzgxODY1YWZhMTU4MDE1NjEwMjQ0NTczZDYwMDA4MDNlM2Q2MDAwZmQ1YjUwNTA1MDUwNjA0MDUxM2Q2MDFmMTk2MDFmODIwMTE2ODIwMTgwNjA0MDUyNTA4MTAxOTA2MTAyNjg5MTkwNjEwNjMzNTY1YjYwMDE2MDAxNjBlMDFiMDMxOTE2MTQ5MDUwNjEwNDA1NTY1YjgxNTE2MDQxMTQ2MTAyZGY1NzYwNDA1MTYyNDYxYmNkNjBlNTFiODE1MjYwMjA2MDA0ODIwMTUyNjAzYTYwMjQ4MjAxNTI2MDAwODA1MTYwMjA2MTA2NzQ4MzM5ODE1MTkxNTI2MDQ0ODIwMTUyN2YzYTIwNjk2ZTc2NjE2YzY5NjQyMDczNjk2NzZlNjE3NDc1NzI2NTIwNmM2NTZlNjc3NDY4MDAwMDAwMDAwMDAwNjA2NDgyMDE1MjYwODQwMTYxMDE1NzU2NWI2MTAyZTc2MTA0MjU1NjViNTA2MDIwODIwMTUxNjA0MDgwODQwMTUxODQ1MTg1OTM5MjYwMDA5MTg1OTE5MDgxMTA2MTAzMGM1NzYxMDMwYzYxMDY1ZDU2NWIwMTYwMjAwMTUxNjBmODFjOTA1MDYwMWI4MTE0ODAxNTkwNjEwMzJiNTc1MDgwNjBmZjE2NjAxYzE0MTU1YjE1NjEwMzhjNTc2MDQwNTE2MjQ2MWJjZDYwZTUxYjgxNTI2MDIwNjAwNDgyMDE1MjYwM2I2MDI0ODIwMTUyNjAwMDgwNTE2MDIwNjEwNjc0ODMzOTgxNTE5MTUyNjA0NDgyMDE1MjdmM2EyMDY5NmU3NjYxNmM2OTY0MjA3MzY5Njc2ZTYxNzQ3NTcyNjUyMDc2MjA3NjYxNmM3NTY1MDAwMDAwMDAwMDYwNjQ4MjAxNTI2MDg0MDE2MTAxNTc1NjViNjA0MDgwNTE2MDAwODE1MjYwMjA4MTAxODA4MzUyODk5MDUyNjBmZjgzMTY5MTgxMDE5MTkwOTE1MjYwNjA4MTAxODQ5MDUyNjA4MDgxMDE4MzkwNTI2MDAxNjAwMTYwYTAxYjAzODkxNjkwNjAwMTkwNjBhMDAxNjAyMDYwNDA1MTYwMjA4MTAzOTA4MDg0MDM5MDg1NWFmYTE1ODAxNTYxMDNlYTU3M2Q2MDAwODAzZTNkNjAwMGZkNWI1MDUwNTA2MDIwNjA0MDUxMDM1MTYwMDE2MDAxNjBhMDFiMDMxNjE0OTQ1MDUwNTA1MDUwNWI5MzkyNTA1MDUwNTY1YjYwMDA2MDIwODI1MTEwMTU2MTA0MWQ1NzYwMDA4MGZkNWI1MDgwNTEwMTUxOTA1NjViNjA0MDUxODA2MDYwMDE2MDQwNTI4MDYwMDM5MDYwMjA4MjAyODAzNjgzMzc1MDkxOTI5MTUwNTA1NjViNjAwMTYwMDE2MGEwMWIwMzgxMTY4MTE0NjEwNDU4NTc2MDAwODBmZDViNTA1NjViNjM0ZTQ4N2I3MTYwZTAxYjYwMDA1MjYwNDE2MDA0NTI2MDI0NjAwMGZkNWI2MDAwNWI4MzgxMTAxNTYxMDQ4YzU3ODE4MTAxNTE4MzgyMDE1MjYwMjAwMTYxMDQ3NDU2NWI1MDUwNjAwMDkxMDE1MjU2NWI2MDAwODI2MDFmODMwMTEyNjEwNGE2NTc2MDAwODBmZDViODE1MTYwMDE2MDAxNjA0MDFiMDM4MTExMTU2MTA0YmY1NzYxMDRiZjYxMDQ1YjU2NWI2MDQwNTE2MDFmODIwMTYwMWYxOTkwODExNjYwM2YwMTE2ODEwMTYwMDE2MDAxNjA0MDFiMDM4MTExODI4MjEwMTcxNTYxMDRlZDU3NjEwNGVkNjEwNDViNTY1YjYwNDA1MjgxODE1MjgzODIwMTYwMjAwMTg1MTAxNTYxMDUwNTU3NjAwMDgwZmQ1YjYxMDUxNjgyNjAyMDgzMDE2MDIwODcwMTYxMDQ3MTU2NWI5NDkzNTA1MDUwNTA1NjViNjAwMDgwNjAwMDYwNjA4NDg2MDMxMjE1NjEwNTMzNTc2MDAwODBmZDViODM1MTYxMDUzZTgxNjEwNDQzNTY1YjYwMjA4NTAxNTE2MDQwODYwMTUxOTE5NDUwOTI1MDYwMDE2MDAxNjA0MDFiMDM4MTExMTU2MTA1NjE1NzYwMDA4MGZkNWI2MTA1NmQ4NjgyODcwMTYxMDQ5NTU2NWI5MTUwNTA5MjUwOTI1MDkyNTY1YjYwMDA4MDYwMDA2MDYwODQ4NjAzMTIxNTYxMDU4YzU3NjAwMDgwZmQ1YjgzNTE2MTA1OTc4MTYxMDQ0MzU2NWI2MDIwODUwMTUxOTA5MzUwNjAwMTYwMDE2MDQwMWIwMzgxMTExNTYxMDViMzU3NjAwMDgwZmQ1YjYxMDViZjg2ODI4NzAxNjEwNDk1NTY1YjYwNDA4NjAxNTE5MDkzNTA5MDUwNjAwMTYwMDE2MDQwMWIwMzgxMTExNTYxMDU2MTU3NjAwMDgwZmQ1YjYwMDA4MjUxNjEwNWVmODE4NDYwMjA4NzAxNjEwNDcxNTY1YjkxOTA5MTAxOTI5MTUwNTA1NjViODI4MTUyNjA0MDYwMjA4MjAxNTI2MDAwODI1MTgwNjA0MDg0MDE1MjYxMDYxZTgxNjA2MDg1MDE2MDIwODcwMTYxMDQ3MTU2NWI2MDFmMDE2MDFmMTkxNjkxOTA5MTAxNjA2MDAxOTM5MjUwNTA1MDU2NWI2MDAwNjAyMDgyODQwMzEyMTU2MTA2NDU1NzYwMDA4MGZkNWI4MTUxNjAwMTYwMDE2MGUwMWIwMzE5ODExNjgxMTQ2MTA0MDU1NzYwMDA4MGZkNWI2MzRlNDg3YjcxNjBlMDFiNjAwMDUyNjAzMjYwMDQ1MjYwMjQ2MDAwZmRmZTUzNjk2NzZlNjE3NDc1NzI2NTU2NjE2YzY5NjQ2MTc0NmY3MjIzNzI2NTYzNmY3NjY1NzI1MzY5Njc2ZTY1NzInO1xuLyoqXG4gKiBBQkkgZm9yIHRoZSBFUkMtNjQ5MiB1bml2ZXJzYWwgZGVwbG95bGVzcyBzaWduYXR1cmUgdmFsaWRhdG9yIGNvbnRyYWN0LlxuICpcbiAqIENvbnN0cnVjdG9yIHJldHVybiB2YWx1ZSBpcyBgMHgxYCAodmFsaWQpIG9yIGAweDBgIChpbnZhbGlkKS5cbiAqL1xuZXhwb3J0IGNvbnN0IHVuaXZlcnNhbFNpZ25hdHVyZVZhbGlkYXRvckFiaSA9IFtcbiAgICB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdfc2lnbmVyJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdfaGFzaCcsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2J5dGVzMzInLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnX3NpZ25hdHVyZScsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2J5dGVzJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogJ25vbnBheWFibGUnLFxuICAgICAgICB0eXBlOiAnY29uc3RydWN0b3InLFxuICAgIH0sXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnX3NpZ25lcicsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnX2hhc2gnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdieXRlczMyJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ19zaWduYXR1cmUnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdieXRlcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBvdXRwdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2Jvb2wnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAnbm9ucGF5YWJsZScsXG4gICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgICAgIG5hbWU6ICdpc1ZhbGlkU2lnJyxcbiAgICB9LFxuXTtcbi8qKlxuICogQXNzZXJ0cyB0aGF0IHRoZSB3cmFwcGVkIHNpZ25hdHVyZSBpcyB2YWxpZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZUVyYzY0OTIgfSBmcm9tICdveC9lcmM2NDkyJ1xuICpcbiAqIFNpZ25hdHVyZUVyYzY0OTIuYXNzZXJ0KCcweGRlYWRiZWVmJylcbiAqIC8vIEBlcnJvcjogSW52YWxpZFdyYXBwZWRTaWduYXR1cmVFcnJvcjogVmFsdWUgYDB4ZGVhZGJlZWZgIGlzIGFuIGludmFsaWQgRVJDLTY0OTIgd3JhcHBlZCBzaWduYXR1cmUuXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gd3JhcHBlZCAtIFRoZSB3cmFwcGVkIHNpZ25hdHVyZSB0byBhc3NlcnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnQod3JhcHBlZCkge1xuICAgIGlmIChIZXguc2xpY2Uod3JhcHBlZCwgLTMyKSAhPT0gbWFnaWNCeXRlcylcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRXcmFwcGVkU2lnbmF0dXJlRXJyb3Iod3JhcHBlZCk7XG59XG4vKipcbiAqIFBhcnNlcyBhbiBbRVJDLTY0OTIgd3JhcHBlZCBzaWduYXR1cmVdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNjQ5MiNzcGVjaWZpY2F0aW9uKSBpbnRvIGl0cyBjb25zdGl0dWVudCBwYXJ0cy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgU2VjcDI1NmsxIH0gZnJvbSAnb3gnXG4gKiBpbXBvcnQgeyBTaWduYXR1cmVFcmM2NDkyIH0gZnJvbSAnb3gvZXJjNjQ5MicgLy8gWyFjb2RlIGZvY3VzXVxuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHtcbiAqICAgcGF5bG9hZDogJzB4Li4uJyxcbiAqICAgcHJpdmF0ZUtleTogJzB4Li4uJyxcbiAqIH0pXG4gKlxuICogLy8gSW5zdGFudGlhdGUgZnJvbSBzZXJpYWxpemVkIGZvcm1hdC4gLy8gWyFjb2RlIGZvY3VzXVxuICogY29uc3Qgd3JhcHBlZCA9IFNpZ25hdHVyZUVyYzY0OTIuZnJvbSgnMHguLi4nKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyBAbG9nOiB7IGRhdGE6ICcweC4uLicsIHNpZ25hdHVyZTogeyAuLi4gfSwgdG86ICcweC4uLicsIH0gLy8gWyFjb2RlIGZvY3VzXVxuICpcbiAqIC8vIEluc3RhbnRpYXRlIGZyb20gY29uc3RpdHVlbnQgcGFydHMuIC8vIFshY29kZSBmb2N1c11cbiAqIGNvbnN0IHdyYXBwZWQgPSBTaWduYXR1cmVFcmM2NDkyLmZyb20oeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIGRhdGE6ICcweC4uLicsIC8vIFshY29kZSBmb2N1c11cbiAqICAgc2lnbmF0dXJlLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHRvOiAnMHguLi4nLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KVxuICogLy8gQGxvZzogeyBkYXRhOiAnMHguLi4nLCBzaWduYXR1cmU6IHsgLi4uIH0sIHRvOiAnMHguLi4nLCB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gd3JhcHBlZCAtIFdyYXBwZWQgc2lnbmF0dXJlIHRvIHBhcnNlLlxuICogQHJldHVybnMgV3JhcHBlZCBzaWduYXR1cmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tKHdyYXBwZWQpIHtcbiAgICBpZiAodHlwZW9mIHdyYXBwZWQgPT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gdW53cmFwKHdyYXBwZWQpO1xuICAgIHJldHVybiB3cmFwcGVkO1xufVxuLyoqXG4gKiBQYXJzZXMgYW4gW0VSQy02NDkyIHdyYXBwZWQgc2lnbmF0dXJlXShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTY0OTIjc3BlY2lmaWNhdGlvbikgaW50byBpdHMgY29uc3RpdHVlbnQgcGFydHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmVFcmM2NDkyIH0gZnJvbSAnb3gvZXJjNjQ5MidcbiAqXG4gKiBjb25zdCB7IGRhdGEsIHNpZ25hdHVyZSwgdG8gfSA9IFNpZ25hdHVyZUVyYzY0OTIudW53cmFwKCcweC4uLicpXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gd3JhcHBlZCAtIFdyYXBwZWQgc2lnbmF0dXJlIHRvIHBhcnNlLlxuICogQHJldHVybnMgV3JhcHBlZCBzaWduYXR1cmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bndyYXAod3JhcHBlZCkge1xuICAgIGFzc2VydCh3cmFwcGVkKTtcbiAgICBjb25zdCBbdG8sIGRhdGEsIHNpZ25hdHVyZV0gPSBBYmlQYXJhbWV0ZXJzLmRlY29kZShBYmlQYXJhbWV0ZXJzLmZyb20oJ2FkZHJlc3MsIGJ5dGVzLCBieXRlcycpLCB3cmFwcGVkKTtcbiAgICByZXR1cm4geyBkYXRhLCBzaWduYXR1cmUsIHRvIH07XG59XG4vKipcbiAqIFNlcmlhbGl6ZXMgYW4gW0VSQy02NDkyIHdyYXBwZWQgc2lnbmF0dXJlXShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTY0OTIjc3BlY2lmaWNhdGlvbikuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEsIFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICogaW1wb3J0IHsgU2lnbmF0dXJlRXJjNjQ5MiB9IGZyb20gJ294L2VyYzY0OTInIC8vIFshY29kZSBmb2N1c11cbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7XG4gKiAgIHBheWxvYWQ6ICcweC4uLicsXG4gKiAgIHByaXZhdGVLZXk6ICcweC4uLicsXG4gKiB9KVxuICpcbiAqIGNvbnN0IHdyYXBwZWQgPSBTaWduYXR1cmVFcmM2NDkyLndyYXAoeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIGRhdGE6ICcweGRlYWRiZWVmJywgLy8gWyFjb2RlIGZvY3VzXVxuICogICBzaWduYXR1cmU6IFNpZ25hdHVyZS50b0hleChzaWduYXR1cmUpLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHRvOiAnMHgwMDAwMDAwMDIxOWFiNTQwMzU2Y0JCODM5Q2JlMDUzMDNkNzcwNUZhJywgLy8gWyFjb2RlIGZvY3VzXVxuICogfSkgLy8gWyFjb2RlIGZvY3VzXVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gV3JhcHBlZCBzaWduYXR1cmUgdG8gc2VyaWFsaXplLlxuICogQHJldHVybnMgU2VyaWFsaXplZCB3cmFwcGVkIHNpZ25hdHVyZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdyYXAodmFsdWUpIHtcbiAgICBjb25zdCB7IGRhdGEsIHNpZ25hdHVyZSwgdG8gfSA9IHZhbHVlO1xuICAgIHJldHVybiBIZXguY29uY2F0KEFiaVBhcmFtZXRlcnMuZW5jb2RlKEFiaVBhcmFtZXRlcnMuZnJvbSgnYWRkcmVzcywgYnl0ZXMsIGJ5dGVzJyksIFtcbiAgICAgICAgdG8sXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHNpZ25hdHVyZSxcbiAgICBdKSwgbWFnaWNCeXRlcyk7XG59XG4vKipcbiAqIFZhbGlkYXRlcyBhIHdyYXBwZWQgc2lnbmF0dXJlLiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgd3JhcHBlZCBzaWduYXR1cmUgaXMgdmFsaWQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlRXJjNjQ5MiB9IGZyb20gJ294L2VyYzY0OTInXG4gKlxuICogY29uc3QgdmFsaWQgPSBTaWduYXR1cmVFcmM2NDkyLnZhbGlkYXRlKCcweGRlYWRiZWVmJylcbiAqIC8vIEBsb2c6IGZhbHNlXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gd3JhcHBlZCAtIFRoZSB3cmFwcGVkIHNpZ25hdHVyZSB0byB2YWxpZGF0ZS5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgd3JhcHBlZCBzaWduYXR1cmUgaXMgdmFsaWQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGUod3JhcHBlZCkge1xuICAgIHRyeSB7XG4gICAgICAgIGFzc2VydCh3cmFwcGVkKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKiBUaHJvd24gd2hlbiB0aGUgRVJDLTY0OTIgd3JhcHBlZCBzaWduYXR1cmUgaXMgaW52YWxpZC4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkV3JhcHBlZFNpZ25hdHVyZUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3Iod3JhcHBlZCkge1xuICAgICAgICBzdXBlcihgVmFsdWUgXFxgJHt3cmFwcGVkfVxcYCBpcyBhbiBpbnZhbGlkIEVSQy02NDkyIHdyYXBwZWQgc2lnbmF0dXJlLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnU2lnbmF0dXJlRXJjNjQ5Mi5JbnZhbGlkV3JhcHBlZFNpZ25hdHVyZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TaWduYXR1cmVFcmM2NDkyLmpzLm1hcCJdLCJuYW1lcyI6WyJBYmlQYXJhbWV0ZXJzIiwiRXJyb3JzIiwiSGV4IiwibWFnaWNCeXRlcyIsInVuaXZlcnNhbFNpZ25hdHVyZVZhbGlkYXRvckJ5dGVjb2RlIiwidW5pdmVyc2FsU2lnbmF0dXJlVmFsaWRhdG9yQWJpIiwiaW5wdXRzIiwibmFtZSIsInR5cGUiLCJzdGF0ZU11dGFiaWxpdHkiLCJvdXRwdXRzIiwiYXNzZXJ0Iiwid3JhcHBlZCIsInNsaWNlIiwiSW52YWxpZFdyYXBwZWRTaWduYXR1cmVFcnJvciIsImZyb20iLCJ1bndyYXAiLCJ0byIsImRhdGEiLCJzaWduYXR1cmUiLCJkZWNvZGUiLCJ3cmFwIiwidmFsdWUiLCJjb25jYXQiLCJlbmNvZGUiLCJ2YWxpZGF0ZSIsIkJhc2VFcnJvciIsImNvbnN0cnVjdG9yIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/erc6492/SignatureErc6492.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/erc8010/SignatureErc8010.js":
/*!**********************************************************!*\
  !*** ./node_modules/ox/_esm/erc8010/SignatureErc8010.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidWrappedSignatureError: () => (/* binding */ InvalidWrappedSignatureError),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   magicBytes: () => (/* binding */ magicBytes),\n/* harmony export */   suffixParameters: () => (/* binding */ suffixParameters),\n/* harmony export */   unwrap: () => (/* binding */ unwrap),\n/* harmony export */   validate: () => (/* binding */ validate),\n/* harmony export */   wrap: () => (/* binding */ wrap)\n/* harmony export */ });\n/* harmony import */ var _core_AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/AbiParameters.js */ \"(ssr)/./node_modules/ox/_esm/core/AbiParameters.js\");\n/* harmony import */ var _core_Authorization_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/Authorization.js */ \"(ssr)/./node_modules/ox/_esm/core/Authorization.js\");\n/* harmony import */ var _core_Errors_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _core_Secp256k1_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/Secp256k1.js */ \"(ssr)/./node_modules/ox/_esm/core/Secp256k1.js\");\n/* harmony import */ var _core_Signature_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/Signature.js */ \"(ssr)/./node_modules/ox/_esm/core/Signature.js\");\n\n\n\n\n\n\n/**\n * Magic bytes used to identify ERC-8010 wrapped signatures.\n */ const magicBytes = \"0x8010801080108010801080108010801080108010801080108010801080108010\";\n/** Suffix ABI parameters for the ERC-8010 wrapped signature. */ const suffixParameters = _core_AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.from(\"(uint256 chainId, address delegation, uint256 nonce, uint8 yParity, uint256 r, uint256 s), address to, bytes data\");\n/**\n * Asserts that the wrapped signature is valid.\n *\n * @example\n * ```ts twoslash\n * import { SignatureErc8010 } from 'ox/erc8010'\n *\n * SignatureErc8010.assert('0xdeadbeef')\n * // @error: InvalidWrappedSignatureError: Value `0xdeadbeef` is an invalid ERC-8010 wrapped signature.\n * ```\n *\n * @param value - The value to assert.\n */ function assert(value) {\n    if (typeof value === \"string\") {\n        if (_core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(value, -32) !== magicBytes) throw new InvalidWrappedSignatureError(value);\n    } else _core_Signature_js__WEBPACK_IMPORTED_MODULE_2__.assert(value.authorization);\n}\n/**\n * Parses an [ERC-8010 wrapped signature](https://github.com/jxom/ERCs/blob/16f7e3891fff2e1e9c25dea0485497739db8a816/ERCS/erc-8010.md) into its constituent parts.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1 } from 'ox'\n * import { SignatureErc8010 } from 'ox/erc8010' // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload: '0x...',\n *   privateKey: '0x...',\n * })\n *\n * // Instantiate from serialized format. // [!code focus]\n * const wrapped = SignatureErc8010.from('0x...') // [!code focus]\n * // @log: { authorization: { ... }, data: '0x...', signature: { ... } } // [!code focus]\n *\n * // Instantiate from constituent parts. // [!code focus]\n * const wrapped = SignatureErc8010.from({ // [!code focus]\n *   authorization: { ... }, // [!code focus]\n *   data: '0x...', // [!code focus]\n *   signature, // [!code focus]\n * })\n * // @log: { authorization: { ... }, data: '0x...', signature: { ... } }\n * ```\n *\n * @param value - Value to parse.\n * @returns Parsed value.\n */ function from(value) {\n    if (typeof value === \"string\") return unwrap(value);\n    return value;\n}\n/**\n * Unwraps an [ERC-8010 wrapped signature](https://github.com/jxom/ERCs/blob/16f7e3891fff2e1e9c25dea0485497739db8a816/ERCS/erc-8010.md) into its constituent parts.\n *\n * @example\n * ```ts twoslash\n * import { SignatureErc8010 } from 'ox/erc8010'\n *\n * const { authorization, data, signature } = SignatureErc8010.unwrap('0x...')\n * ```\n *\n * @param wrapped - Wrapped signature to unwrap.\n * @returns Unwrapped signature.\n */ function unwrap(wrapped) {\n    assert(wrapped);\n    const suffixLength = _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.toNumber(_core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(wrapped, -64, -32));\n    const suffix = _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(wrapped, -suffixLength - 64, -64);\n    const signature = _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(wrapped, 0, -suffixLength - 64);\n    const [auth, to, data] = _core_AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.decode(suffixParameters, suffix);\n    const authorization = _core_Authorization_js__WEBPACK_IMPORTED_MODULE_3__.from({\n        address: auth.delegation,\n        chainId: Number(auth.chainId),\n        nonce: auth.nonce,\n        yParity: auth.yParity,\n        r: auth.r,\n        s: auth.s\n    });\n    return {\n        authorization,\n        signature,\n        ...data && data !== \"0x\" ? {\n            data,\n            to\n        } : {}\n    };\n}\n/**\n * Wraps a signature into [ERC-8010 format](https://github.com/jxom/ERCs/blob/16f7e3891fff2e1e9c25dea0485497739db8a816/ERCS/erc-8010.md).\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, Signature } from 'ox'\n * import { SignatureErc8010 } from 'ox/erc8010' // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload: '0x...',\n *   privateKey: '0x...',\n * })\n *\n * const wrapped = SignatureErc8010.wrap({ // [!code focus]\n *   authorization: { ... }, // [!code focus]\n *   data: '0xdeadbeef', // [!code focus]\n *   signature: Signature.toHex(signature), // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param value - Values to wrap.\n * @returns Wrapped signature.\n */ function wrap(value) {\n    const { data, signature } = value;\n    assert(value);\n    const self = _core_Secp256k1_js__WEBPACK_IMPORTED_MODULE_4__.recoverAddress({\n        payload: _core_Authorization_js__WEBPACK_IMPORTED_MODULE_3__.getSignPayload(value.authorization),\n        signature: _core_Signature_js__WEBPACK_IMPORTED_MODULE_2__.from(value.authorization)\n    });\n    const suffix = _core_AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.encode(suffixParameters, [\n        {\n            ...value.authorization,\n            delegation: value.authorization.address,\n            chainId: BigInt(value.authorization.chainId)\n        },\n        value.to ?? self,\n        data ?? \"0x\"\n    ]);\n    const suffixLength = _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(_core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.size(suffix), {\n        size: 32\n    });\n    return _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.concat(signature, suffix, suffixLength, magicBytes);\n}\n/**\n * Validates a wrapped signature. Returns `true` if the wrapped signature is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { SignatureErc8010 } from 'ox/erc8010'\n *\n * const valid = SignatureErc8010.validate('0xdeadbeef')\n * // @log: false\n * ```\n *\n * @param value - The value to validate.\n * @returns `true` if the value is valid, `false` otherwise.\n */ function validate(value) {\n    try {\n        assert(value);\n        return true;\n    } catch  {\n        return false;\n    }\n}\n/** Thrown when the ERC-8010 wrapped signature is invalid. */ class InvalidWrappedSignatureError extends _core_Errors_js__WEBPACK_IMPORTED_MODULE_5__.BaseError {\n    constructor(wrapped){\n        super(`Value \\`${wrapped}\\` is an invalid ERC-8010 wrapped signature.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"SignatureErc8010.InvalidWrappedSignatureError\"\n        });\n    }\n} //# sourceMappingURL=SignatureErc8010.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9lcmM4MDEwL1NpZ25hdHVyZUVyYzgwMTAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMEQ7QUFDQTtBQUNkO0FBQ047QUFDWTtBQUNBO0FBQ2xEOztDQUVDLEdBQ00sTUFBTU0sYUFBYSxxRUFBcUU7QUFDL0YsOERBQThELEdBQ3ZELE1BQU1DLG1CQUFtQlAsd0RBQWtCLENBQUMscUhBQXFIO0FBQ3hLOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUNNLFNBQVNTLE9BQU9DLEtBQUs7SUFDeEIsSUFBSSxPQUFPQSxVQUFVLFVBQVU7UUFDM0IsSUFBSVAsK0NBQVMsQ0FBQ08sT0FBTyxDQUFDLFFBQVFKLFlBQzFCLE1BQU0sSUFBSU0sNkJBQTZCRjtJQUMvQyxPQUVJTCxzREFBZ0IsQ0FBQ0ssTUFBTUcsYUFBYTtBQUM1QztBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQTZCQyxHQUNNLFNBQVNMLEtBQUtFLEtBQUs7SUFDdEIsSUFBSSxPQUFPQSxVQUFVLFVBQ2pCLE9BQU9JLE9BQU9KO0lBQ2xCLE9BQU9BO0FBQ1g7QUFDQTs7Ozs7Ozs7Ozs7O0NBWUMsR0FDTSxTQUFTSSxPQUFPQyxPQUFPO0lBQzFCTixPQUFPTTtJQUNQLE1BQU1DLGVBQWViLGtEQUFZLENBQUNBLCtDQUFTLENBQUNZLFNBQVMsQ0FBQyxJQUFJLENBQUM7SUFDM0QsTUFBTUcsU0FBU2YsK0NBQVMsQ0FBQ1ksU0FBUyxDQUFDQyxlQUFlLElBQUksQ0FBQztJQUN2RCxNQUFNRyxZQUFZaEIsK0NBQVMsQ0FBQ1ksU0FBUyxHQUFHLENBQUNDLGVBQWU7SUFDeEQsTUFBTSxDQUFDSSxNQUFNQyxJQUFJQyxLQUFLLEdBQUd0QiwwREFBb0IsQ0FBQ08sa0JBQWtCVztJQUNoRSxNQUFNTCxnQkFBZ0JaLHdEQUFrQixDQUFDO1FBQ3JDdUIsU0FBU0osS0FBS0ssVUFBVTtRQUN4QkMsU0FBU0MsT0FBT1AsS0FBS00sT0FBTztRQUM1QkUsT0FBT1IsS0FBS1EsS0FBSztRQUNqQkMsU0FBU1QsS0FBS1MsT0FBTztRQUNyQkMsR0FBR1YsS0FBS1UsQ0FBQztRQUNUQyxHQUFHWCxLQUFLVyxDQUFDO0lBQ2I7SUFDQSxPQUFPO1FBQ0hsQjtRQUNBTTtRQUNBLEdBQUlHLFFBQVFBLFNBQVMsT0FBTztZQUFFQTtZQUFNRDtRQUFHLElBQUksQ0FBQyxDQUFDO0lBQ2pEO0FBQ0o7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F1QkMsR0FDTSxTQUFTVyxLQUFLdEIsS0FBSztJQUN0QixNQUFNLEVBQUVZLElBQUksRUFBRUgsU0FBUyxFQUFFLEdBQUdUO0lBQzVCRCxPQUFPQztJQUNQLE1BQU11QixPQUFPN0IsOERBQXdCLENBQUM7UUFDbEMrQixTQUFTbEMsa0VBQTRCLENBQUNTLE1BQU1HLGFBQWE7UUFDekRNLFdBQVdkLG9EQUFjLENBQUNLLE1BQU1HLGFBQWE7SUFDakQ7SUFDQSxNQUFNSyxTQUFTbEIsMERBQW9CLENBQUNPLGtCQUFrQjtRQUNsRDtZQUNJLEdBQUdHLE1BQU1HLGFBQWE7WUFDdEJZLFlBQVlmLE1BQU1HLGFBQWEsQ0FBQ1csT0FBTztZQUN2Q0UsU0FBU1ksT0FBTzVCLE1BQU1HLGFBQWEsQ0FBQ2EsT0FBTztRQUMvQztRQUNBaEIsTUFBTVcsRUFBRSxJQUFJWTtRQUNaWCxRQUFRO0tBQ1g7SUFDRCxNQUFNTixlQUFlYixvREFBYyxDQUFDQSw4Q0FBUSxDQUFDZSxTQUFTO1FBQUVzQixNQUFNO0lBQUc7SUFDakUsT0FBT3JDLGdEQUFVLENBQUNnQixXQUFXRCxRQUFRRixjQUFjVjtBQUN2RDtBQUNBOzs7Ozs7Ozs7Ozs7O0NBYUMsR0FDTSxTQUFTb0MsU0FBU2hDLEtBQUs7SUFDMUIsSUFBSTtRQUNBRCxPQUFPQztRQUNQLE9BQU87SUFDWCxFQUNBLE9BQU07UUFDRixPQUFPO0lBQ1g7QUFDSjtBQUNBLDJEQUEyRCxHQUNwRCxNQUFNRSxxQ0FBcUNWLHNEQUFnQjtJQUM5RDBDLFlBQVk3QixPQUFPLENBQUU7UUFDakIsS0FBSyxDQUFDLENBQUMsUUFBUSxFQUFFQSxRQUFRLDRDQUE0QyxDQUFDO1FBQ3RFOEIsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxRQUFRO1lBQ2hDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWdkMsT0FBTztRQUNYO0lBQ0o7QUFDSixFQUNBLDRDQUE0QyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsYXctd29ya3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9lcmM4MDEwL1NpZ25hdHVyZUVyYzgwMTAuanM/MDg5MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBBYmlQYXJhbWV0ZXJzIGZyb20gJy4uL2NvcmUvQWJpUGFyYW1ldGVycy5qcyc7XG5pbXBvcnQgKiBhcyBBdXRob3JpemF0aW9uIGZyb20gJy4uL2NvcmUvQXV0aG9yaXphdGlvbi5qcyc7XG5pbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSAnLi4vY29yZS9FcnJvcnMuanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4uL2NvcmUvSGV4LmpzJztcbmltcG9ydCAqIGFzIFNlY3AyNTZrMSBmcm9tICcuLi9jb3JlL1NlY3AyNTZrMS5qcyc7XG5pbXBvcnQgKiBhcyBTaWduYXR1cmUgZnJvbSAnLi4vY29yZS9TaWduYXR1cmUuanMnO1xuLyoqXG4gKiBNYWdpYyBieXRlcyB1c2VkIHRvIGlkZW50aWZ5IEVSQy04MDEwIHdyYXBwZWQgc2lnbmF0dXJlcy5cbiAqL1xuZXhwb3J0IGNvbnN0IG1hZ2ljQnl0ZXMgPSAnMHg4MDEwODAxMDgwMTA4MDEwODAxMDgwMTA4MDEwODAxMDgwMTA4MDEwODAxMDgwMTA4MDEwODAxMDgwMTA4MDEwJztcbi8qKiBTdWZmaXggQUJJIHBhcmFtZXRlcnMgZm9yIHRoZSBFUkMtODAxMCB3cmFwcGVkIHNpZ25hdHVyZS4gKi9cbmV4cG9ydCBjb25zdCBzdWZmaXhQYXJhbWV0ZXJzID0gQWJpUGFyYW1ldGVycy5mcm9tKCcodWludDI1NiBjaGFpbklkLCBhZGRyZXNzIGRlbGVnYXRpb24sIHVpbnQyNTYgbm9uY2UsIHVpbnQ4IHlQYXJpdHksIHVpbnQyNTYgciwgdWludDI1NiBzKSwgYWRkcmVzcyB0bywgYnl0ZXMgZGF0YScpO1xuLyoqXG4gKiBBc3NlcnRzIHRoYXQgdGhlIHdyYXBwZWQgc2lnbmF0dXJlIGlzIHZhbGlkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlRXJjODAxMCB9IGZyb20gJ294L2VyYzgwMTAnXG4gKlxuICogU2lnbmF0dXJlRXJjODAxMC5hc3NlcnQoJzB4ZGVhZGJlZWYnKVxuICogLy8gQGVycm9yOiBJbnZhbGlkV3JhcHBlZFNpZ25hdHVyZUVycm9yOiBWYWx1ZSBgMHhkZWFkYmVlZmAgaXMgYW4gaW52YWxpZCBFUkMtODAxMCB3cmFwcGVkIHNpZ25hdHVyZS5cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBhc3NlcnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnQodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoSGV4LnNsaWNlKHZhbHVlLCAtMzIpICE9PSBtYWdpY0J5dGVzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRXcmFwcGVkU2lnbmF0dXJlRXJyb3IodmFsdWUpO1xuICAgIH1cbiAgICBlbHNlXG4gICAgICAgIFNpZ25hdHVyZS5hc3NlcnQodmFsdWUuYXV0aG9yaXphdGlvbik7XG59XG4vKipcbiAqIFBhcnNlcyBhbiBbRVJDLTgwMTAgd3JhcHBlZCBzaWduYXR1cmVdKGh0dHBzOi8vZ2l0aHViLmNvbS9qeG9tL0VSQ3MvYmxvYi8xNmY3ZTM4OTFmZmYyZTFlOWMyNWRlYTA0ODU0OTc3MzlkYjhhODE2L0VSQ1MvZXJjLTgwMTAubWQpIGludG8gaXRzIGNvbnN0aXR1ZW50IHBhcnRzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEgfSBmcm9tICdveCdcbiAqIGltcG9ydCB7IFNpZ25hdHVyZUVyYzgwMTAgfSBmcm9tICdveC9lcmM4MDEwJyAvLyBbIWNvZGUgZm9jdXNdXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oe1xuICogICBwYXlsb2FkOiAnMHguLi4nLFxuICogICBwcml2YXRlS2V5OiAnMHguLi4nLFxuICogfSlcbiAqXG4gKiAvLyBJbnN0YW50aWF0ZSBmcm9tIHNlcmlhbGl6ZWQgZm9ybWF0LiAvLyBbIWNvZGUgZm9jdXNdXG4gKiBjb25zdCB3cmFwcGVkID0gU2lnbmF0dXJlRXJjODAxMC5mcm9tKCcweC4uLicpIC8vIFshY29kZSBmb2N1c11cbiAqIC8vIEBsb2c6IHsgYXV0aG9yaXphdGlvbjogeyAuLi4gfSwgZGF0YTogJzB4Li4uJywgc2lnbmF0dXJlOiB7IC4uLiB9IH0gLy8gWyFjb2RlIGZvY3VzXVxuICpcbiAqIC8vIEluc3RhbnRpYXRlIGZyb20gY29uc3RpdHVlbnQgcGFydHMuIC8vIFshY29kZSBmb2N1c11cbiAqIGNvbnN0IHdyYXBwZWQgPSBTaWduYXR1cmVFcmM4MDEwLmZyb20oeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIGF1dGhvcml6YXRpb246IHsgLi4uIH0sIC8vIFshY29kZSBmb2N1c11cbiAqICAgZGF0YTogJzB4Li4uJywgLy8gWyFjb2RlIGZvY3VzXVxuICogICBzaWduYXR1cmUsIC8vIFshY29kZSBmb2N1c11cbiAqIH0pXG4gKiAvLyBAbG9nOiB7IGF1dGhvcml6YXRpb246IHsgLi4uIH0sIGRhdGE6ICcweC4uLicsIHNpZ25hdHVyZTogeyAuLi4gfSB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZSB0byBwYXJzZS5cbiAqIEByZXR1cm5zIFBhcnNlZCB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb20odmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIHVud3JhcCh2YWx1ZSk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuLyoqXG4gKiBVbndyYXBzIGFuIFtFUkMtODAxMCB3cmFwcGVkIHNpZ25hdHVyZV0oaHR0cHM6Ly9naXRodWIuY29tL2p4b20vRVJDcy9ibG9iLzE2ZjdlMzg5MWZmZjJlMWU5YzI1ZGVhMDQ4NTQ5NzczOWRiOGE4MTYvRVJDUy9lcmMtODAxMC5tZCkgaW50byBpdHMgY29uc3RpdHVlbnQgcGFydHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmVFcmM4MDEwIH0gZnJvbSAnb3gvZXJjODAxMCdcbiAqXG4gKiBjb25zdCB7IGF1dGhvcml6YXRpb24sIGRhdGEsIHNpZ25hdHVyZSB9ID0gU2lnbmF0dXJlRXJjODAxMC51bndyYXAoJzB4Li4uJylcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB3cmFwcGVkIC0gV3JhcHBlZCBzaWduYXR1cmUgdG8gdW53cmFwLlxuICogQHJldHVybnMgVW53cmFwcGVkIHNpZ25hdHVyZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVud3JhcCh3cmFwcGVkKSB7XG4gICAgYXNzZXJ0KHdyYXBwZWQpO1xuICAgIGNvbnN0IHN1ZmZpeExlbmd0aCA9IEhleC50b051bWJlcihIZXguc2xpY2Uod3JhcHBlZCwgLTY0LCAtMzIpKTtcbiAgICBjb25zdCBzdWZmaXggPSBIZXguc2xpY2Uod3JhcHBlZCwgLXN1ZmZpeExlbmd0aCAtIDY0LCAtNjQpO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IEhleC5zbGljZSh3cmFwcGVkLCAwLCAtc3VmZml4TGVuZ3RoIC0gNjQpO1xuICAgIGNvbnN0IFthdXRoLCB0bywgZGF0YV0gPSBBYmlQYXJhbWV0ZXJzLmRlY29kZShzdWZmaXhQYXJhbWV0ZXJzLCBzdWZmaXgpO1xuICAgIGNvbnN0IGF1dGhvcml6YXRpb24gPSBBdXRob3JpemF0aW9uLmZyb20oe1xuICAgICAgICBhZGRyZXNzOiBhdXRoLmRlbGVnYXRpb24sXG4gICAgICAgIGNoYWluSWQ6IE51bWJlcihhdXRoLmNoYWluSWQpLFxuICAgICAgICBub25jZTogYXV0aC5ub25jZSxcbiAgICAgICAgeVBhcml0eTogYXV0aC55UGFyaXR5LFxuICAgICAgICByOiBhdXRoLnIsXG4gICAgICAgIHM6IGF1dGgucyxcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhdXRob3JpemF0aW9uLFxuICAgICAgICBzaWduYXR1cmUsXG4gICAgICAgIC4uLihkYXRhICYmIGRhdGEgIT09ICcweCcgPyB7IGRhdGEsIHRvIH0gOiB7fSksXG4gICAgfTtcbn1cbi8qKlxuICogV3JhcHMgYSBzaWduYXR1cmUgaW50byBbRVJDLTgwMTAgZm9ybWF0XShodHRwczovL2dpdGh1Yi5jb20vanhvbS9FUkNzL2Jsb2IvMTZmN2UzODkxZmZmMmUxZTljMjVkZWEwNDg1NDk3NzM5ZGI4YTgxNi9FUkNTL2VyYy04MDEwLm1kKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgU2VjcDI1NmsxLCBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqIGltcG9ydCB7IFNpZ25hdHVyZUVyYzgwMTAgfSBmcm9tICdveC9lcmM4MDEwJyAvLyBbIWNvZGUgZm9jdXNdXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oe1xuICogICBwYXlsb2FkOiAnMHguLi4nLFxuICogICBwcml2YXRlS2V5OiAnMHguLi4nLFxuICogfSlcbiAqXG4gKiBjb25zdCB3cmFwcGVkID0gU2lnbmF0dXJlRXJjODAxMC53cmFwKHsgLy8gWyFjb2RlIGZvY3VzXVxuICogICBhdXRob3JpemF0aW9uOiB7IC4uLiB9LCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIGRhdGE6ICcweGRlYWRiZWVmJywgLy8gWyFjb2RlIGZvY3VzXVxuICogICBzaWduYXR1cmU6IFNpZ25hdHVyZS50b0hleChzaWduYXR1cmUpLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KSAvLyBbIWNvZGUgZm9jdXNdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZXMgdG8gd3JhcC5cbiAqIEByZXR1cm5zIFdyYXBwZWQgc2lnbmF0dXJlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gd3JhcCh2YWx1ZSkge1xuICAgIGNvbnN0IHsgZGF0YSwgc2lnbmF0dXJlIH0gPSB2YWx1ZTtcbiAgICBhc3NlcnQodmFsdWUpO1xuICAgIGNvbnN0IHNlbGYgPSBTZWNwMjU2azEucmVjb3ZlckFkZHJlc3Moe1xuICAgICAgICBwYXlsb2FkOiBBdXRob3JpemF0aW9uLmdldFNpZ25QYXlsb2FkKHZhbHVlLmF1dGhvcml6YXRpb24pLFxuICAgICAgICBzaWduYXR1cmU6IFNpZ25hdHVyZS5mcm9tKHZhbHVlLmF1dGhvcml6YXRpb24pLFxuICAgIH0pO1xuICAgIGNvbnN0IHN1ZmZpeCA9IEFiaVBhcmFtZXRlcnMuZW5jb2RlKHN1ZmZpeFBhcmFtZXRlcnMsIFtcbiAgICAgICAge1xuICAgICAgICAgICAgLi4udmFsdWUuYXV0aG9yaXphdGlvbixcbiAgICAgICAgICAgIGRlbGVnYXRpb246IHZhbHVlLmF1dGhvcml6YXRpb24uYWRkcmVzcyxcbiAgICAgICAgICAgIGNoYWluSWQ6IEJpZ0ludCh2YWx1ZS5hdXRob3JpemF0aW9uLmNoYWluSWQpLFxuICAgICAgICB9LFxuICAgICAgICB2YWx1ZS50byA/PyBzZWxmLFxuICAgICAgICBkYXRhID8/ICcweCcsXG4gICAgXSk7XG4gICAgY29uc3Qgc3VmZml4TGVuZ3RoID0gSGV4LmZyb21OdW1iZXIoSGV4LnNpemUoc3VmZml4KSwgeyBzaXplOiAzMiB9KTtcbiAgICByZXR1cm4gSGV4LmNvbmNhdChzaWduYXR1cmUsIHN1ZmZpeCwgc3VmZml4TGVuZ3RoLCBtYWdpY0J5dGVzKTtcbn1cbi8qKlxuICogVmFsaWRhdGVzIGEgd3JhcHBlZCBzaWduYXR1cmUuIFJldHVybnMgYHRydWVgIGlmIHRoZSB3cmFwcGVkIHNpZ25hdHVyZSBpcyB2YWxpZCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmVFcmM4MDEwIH0gZnJvbSAnb3gvZXJjODAxMCdcbiAqXG4gKiBjb25zdCB2YWxpZCA9IFNpZ25hdHVyZUVyYzgwMTAudmFsaWRhdGUoJzB4ZGVhZGJlZWYnKVxuICogLy8gQGxvZzogZmFsc2VcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byB2YWxpZGF0ZS5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgdmFsaWQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGUodmFsdWUpIHtcbiAgICB0cnkge1xuICAgICAgICBhc3NlcnQodmFsdWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLyoqIFRocm93biB3aGVuIHRoZSBFUkMtODAxMCB3cmFwcGVkIHNpZ25hdHVyZSBpcyBpbnZhbGlkLiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRXcmFwcGVkU2lnbmF0dXJlRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih3cmFwcGVkKSB7XG4gICAgICAgIHN1cGVyKGBWYWx1ZSBcXGAke3dyYXBwZWR9XFxgIGlzIGFuIGludmFsaWQgRVJDLTgwMTAgd3JhcHBlZCBzaWduYXR1cmUuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdTaWduYXR1cmVFcmM4MDEwLkludmFsaWRXcmFwcGVkU2lnbmF0dXJlRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNpZ25hdHVyZUVyYzgwMTAuanMubWFwIl0sIm5hbWVzIjpbIkFiaVBhcmFtZXRlcnMiLCJBdXRob3JpemF0aW9uIiwiRXJyb3JzIiwiSGV4IiwiU2VjcDI1NmsxIiwiU2lnbmF0dXJlIiwibWFnaWNCeXRlcyIsInN1ZmZpeFBhcmFtZXRlcnMiLCJmcm9tIiwiYXNzZXJ0IiwidmFsdWUiLCJzbGljZSIsIkludmFsaWRXcmFwcGVkU2lnbmF0dXJlRXJyb3IiLCJhdXRob3JpemF0aW9uIiwidW53cmFwIiwid3JhcHBlZCIsInN1ZmZpeExlbmd0aCIsInRvTnVtYmVyIiwic3VmZml4Iiwic2lnbmF0dXJlIiwiYXV0aCIsInRvIiwiZGF0YSIsImRlY29kZSIsImFkZHJlc3MiLCJkZWxlZ2F0aW9uIiwiY2hhaW5JZCIsIk51bWJlciIsIm5vbmNlIiwieVBhcml0eSIsInIiLCJzIiwid3JhcCIsInNlbGYiLCJyZWNvdmVyQWRkcmVzcyIsInBheWxvYWQiLCJnZXRTaWduUGF5bG9hZCIsImVuY29kZSIsIkJpZ0ludCIsImZyb21OdW1iZXIiLCJzaXplIiwiY29uY2F0IiwidmFsaWRhdGUiLCJCYXNlRXJyb3IiLCJjb25zdHJ1Y3RvciIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/erc8010/SignatureErc8010.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/tempo/AuthorizationTempo.js":
/*!**********************************************************!*\
  !*** ./node_modules/ox/_esm/tempo/AuthorizationTempo.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromRpc: () => (/* binding */ fromRpc),\n/* harmony export */   fromRpcList: () => (/* binding */ fromRpcList),\n/* harmony export */   fromTuple: () => (/* binding */ fromTuple),\n/* harmony export */   fromTupleList: () => (/* binding */ fromTupleList),\n/* harmony export */   getSignPayload: () => (/* binding */ getSignPayload),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   toRpc: () => (/* binding */ toRpc),\n/* harmony export */   toRpcList: () => (/* binding */ toRpcList),\n/* harmony export */   toTuple: () => (/* binding */ toTuple),\n/* harmony export */   toTupleList: () => (/* binding */ toTupleList)\n/* harmony export */ });\n/* harmony import */ var _core_Hash_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Hash.js */ \"(ssr)/./node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _core_Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _core_Rlp_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/Rlp.js */ \"(ssr)/./node_modules/ox/_esm/core/Rlp.js\");\n/* harmony import */ var _SignatureEnvelope_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SignatureEnvelope.js */ \"(ssr)/./node_modules/ox/_esm/tempo/SignatureEnvelope.js\");\n\n\n\n\n/**\n * Converts an EIP-7702 Authorization object into a typed {@link ox#AuthorizationTempo.AuthorizationTempo}.\n *\n * Tempo extends EIP-7702 to support secp256k1, P256, and WebAuthn signature types.\n *\n * [Tempo Authorization Specification](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction#tempo-authorization-list)\n *\n * @example\n * An Authorization can be instantiated from an EIP-7702 Authorization tuple in object format.\n *\n * ```ts twoslash\n * import { AuthorizationTempo } from 'ox/tempo'\n *\n * const authorization = AuthorizationTempo.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n * ```\n *\n * @example\n * ### Attaching Signatures (Secp256k1)\n *\n * Standard Ethereum ECDSA signature using the secp256k1 curve.\n *\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n * import { AuthorizationTempo } from 'ox/tempo'\n *\n * const privateKey = Secp256k1.randomPrivateKey()\n *\n * const authorization = AuthorizationTempo.from({\n *   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   chainId: 1,\n *   nonce: 40n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: AuthorizationTempo.getSignPayload(authorization),\n *   privateKey,\n * })\n *\n * const authorization_signed = AuthorizationTempo.from(\n *   authorization,\n *   { signature }, // [!code focus]\n * )\n * ```\n *\n * @example\n * ### Attaching Signatures (P256)\n *\n * ECDSA signature using the P-256 (secp256r1) curve. Requires embedding the\n * public key and a `prehash` flag indicating whether the payload was hashed\n * before signing.\n *\n * ```ts twoslash\n * import { P256 } from 'ox'\n * import { AuthorizationTempo, SignatureEnvelope } from 'ox/tempo'\n *\n * const { privateKey, publicKey } = P256.createKeyPair()\n *\n * const authorization = AuthorizationTempo.from({\n *   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   chainId: 1,\n *   nonce: 40n,\n * })\n *\n * const signature = P256.sign({\n *   payload: AuthorizationTempo.getSignPayload(authorization),\n *   privateKey,\n * })\n * const signatureEnvelope = SignatureEnvelope.from({\n *   signature,\n *   publicKey,\n *   prehash: false,\n * })\n *\n * const authorization_signed = AuthorizationTempo.from(\n *   authorization,\n *   { signature: signatureEnvelope }, // [!code focus]\n * )\n * ```\n *\n * @example\n * ### Attaching Signatures (P256 WebCrypto)\n *\n * When using WebCrypto keys, `prehash` must be `true` since WebCrypto always\n * hashes the payload internally before signing.\n *\n * ```ts twoslash\n * // @noErrors\n * import { WebCryptoP256 } from 'ox'\n * import { AuthorizationTempo, SignatureEnvelope } from 'ox/tempo'\n *\n * const { privateKey, publicKey } = await WebCryptoP256.createKeyPair()\n *\n * const authorization = AuthorizationTempo.from({\n *   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   chainId: 1,\n *   nonce: 40n,\n * })\n *\n * const signature = await WebCryptoP256.sign({\n *   payload: AuthorizationTempo.getSignPayload(authorization),\n *   privateKey,\n * })\n * const signatureEnvelope = SignatureEnvelope.from({\n *   signature,\n *   publicKey,\n *   prehash: true,\n * })\n *\n * const authorization_signed = AuthorizationTempo.from(\n *   authorization,\n *   { signature: signatureEnvelope }, // [!code focus]\n * )\n * ```\n *\n * @example\n * ### Attaching Signatures (WebAuthn)\n *\n * Passkey-based signature using WebAuthn. Includes authenticator metadata\n * (authenticatorData and clientDataJSON) along with the P-256 signature and\n * public key.\n *\n * ```ts twoslash\n * // @noErrors\n * import { WebAuthnP256 } from 'ox'\n * import { AuthorizationTempo, SignatureEnvelope } from 'ox/tempo'\n *\n * const credential = await WebAuthnP256.createCredential({ name: 'Example' })\n *\n * const authorization = AuthorizationTempo.from({\n *   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   chainId: 1,\n *   nonce: 40n,\n * })\n *\n * const { metadata, signature } = await WebAuthnP256.sign({\n *   challenge: AuthorizationTempo.getSignPayload(authorization),\n *   credentialId: credential.id,\n * })\n * const signatureEnvelope = SignatureEnvelope.from({\n *   signature,\n *   publicKey: credential.publicKey,\n *   metadata,\n * })\n *\n * const authorization_signed = AuthorizationTempo.from(\n *   authorization,\n *   { signature: signatureEnvelope }, // [!code focus]\n * )\n * ```\n *\n * @param authorization - An [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) AA Authorization tuple in object format.\n * @param options - AA Authorization options.\n * @returns The {@link ox#AuthorizationTempo.AuthorizationTempo}.\n */ function from(authorization, options = {}) {\n    if (typeof authorization.chainId === \"string\") return fromRpc(authorization);\n    if (options.signature) {\n        return {\n            ...authorization,\n            signature: options.signature\n        };\n    }\n    return authorization;\n}\n/**\n * Converts an {@link ox#AuthorizationTempo.Rpc} to an {@link ox#AuthorizationTempo.AuthorizationTempo}.\n *\n * @example\n * ```ts twoslash\n * import { AuthorizationTempo } from 'ox/tempo'\n *\n * const authorization = AuthorizationTempo.fromRpc({\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: '0x1',\n *   nonce: '0x1',\n *   signature: {\n *     type: 'secp256k1',\n *     r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *     s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *     yParity: '0x0',\n *   },\n * })\n * ```\n *\n * @param authorization - The RPC-formatted AA Authorization.\n * @returns A signed {@link ox#AuthorizationTempo.AuthorizationTempo}.\n */ function fromRpc(authorization) {\n    const { address, chainId, nonce } = authorization;\n    const signature = _SignatureEnvelope_js__WEBPACK_IMPORTED_MODULE_0__.fromRpc(authorization.signature);\n    return {\n        address,\n        chainId: Number(chainId),\n        nonce: BigInt(nonce),\n        signature\n    };\n}\n/**\n * Converts an {@link ox#AuthorizationTempo.ListRpc} to an {@link ox#AuthorizationTempo.List}.\n *\n * @example\n * ```ts twoslash\n * import { AuthorizationTempo } from 'ox/tempo'\n *\n * const authorizationList = AuthorizationTempo.fromRpcList([{\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: '0x1',\n *   nonce: '0x1',\n *   signature: {\n *     type: 'secp256k1',\n *     r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *     s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *     yParity: '0x0',\n *   },\n * }])\n * ```\n *\n * @param authorizationList - The RPC-formatted AA Authorization list.\n * @returns A signed {@link ox#AuthorizationTempo.List}.\n */ function fromRpcList(authorizationList) {\n    return authorizationList.map((x)=>fromRpc(x));\n}\n/**\n * Converts an {@link ox#AuthorizationTempo.Tuple} to an {@link ox#AuthorizationTempo.AuthorizationTempo}.\n *\n * @example\n * ```ts twoslash\n * import { AuthorizationTempo } from 'ox/tempo'\n *\n * const authorization = AuthorizationTempo.fromTuple([\n *   '0x1',\n *   '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   '0x3'\n * ])\n * // @log: {\n * // @log:   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:   chainId: 1,\n * // @log:   nonce: 3n\n * // @log: }\n * ```\n *\n * @example\n * It is also possible to append a serialized SignatureEnvelope to the end of an AA Authorization tuple.\n *\n * ```ts twoslash\n * import { AuthorizationTempo } from 'ox/tempo'\n *\n * const authorization = AuthorizationTempo.fromTuple([\n *   '0x1',\n *   '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   '0x3',\n *   '0x01a068a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b907e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064',\n * ])\n * // @log: {\n * // @log:   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:   chainId: 1,\n * // @log:   nonce: 3n\n * // @log:   signature: {\n * // @log:     r: BigInt('0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90'),\n * // @log:     s: BigInt('0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'),\n * // @log:     yParity: 0,\n * // @log:   },\n * // @log: }\n * ```\n *\n * @param tuple - The [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) AA Authorization tuple.\n * @returns The {@link ox#AuthorizationTempo.AuthorizationTempo}.\n */ function fromTuple(tuple) {\n    const [chainId, address, nonce, signatureSerialized] = tuple;\n    const args = {\n        address,\n        chainId: chainId === \"0x\" ? 0 : Number(chainId),\n        nonce: nonce === \"0x\" ? 0n : BigInt(nonce)\n    };\n    if (signatureSerialized) args.signature = _SignatureEnvelope_js__WEBPACK_IMPORTED_MODULE_0__.deserialize(signatureSerialized);\n    return from(args);\n}\n/**\n * Converts an {@link ox#AuthorizationTempo.TupleList} to an {@link ox#AuthorizationTempo.List}.\n *\n * @example\n * ```ts twoslash\n * import { AuthorizationTempo } from 'ox/tempo'\n *\n * const authorizationList = AuthorizationTempo.fromTupleList([\n *   ['0x1', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x3'],\n *   ['0x3', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x14'],\n * ])\n * // @log: [\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 1,\n * // @log:     nonce: 3n,\n * // @log:   },\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 3,\n * // @log:     nonce: 20n,\n * // @log:   },\n * // @log: ]\n * ```\n *\n * @example\n * It is also possible to append a serialized SignatureEnvelope to the end of an AA Authorization tuple.\n *\n * ```ts twoslash\n * import { AuthorizationTempo } from 'ox/tempo'\n *\n * const authorizationList = AuthorizationTempo.fromTupleList([\n *   ['0x1', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x3', '0x01a068a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b907e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'],\n *   ['0x3', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x14', '0x01a068a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b907e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'],\n * ])\n * // @log: [\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 1,\n * // @log:     nonce: 3n,\n * // @log:     signature: {\n * // @log:       r: BigInt('0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90'),\n * // @log:       s: BigInt('0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'),\n * // @log:       yParity: 0,\n * // @log:     },\n * // @log:   },\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 3,\n * // @log:     nonce: 20n,\n * // @log:     signature: {\n * // @log:       r: BigInt('0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90'),\n * // @log:       s: BigInt('0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'),\n * // @log:       yParity: 0,\n * // @log:     },\n * // @log:   },\n * // @log: ]\n * ```\n *\n * @param tupleList - The [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) AA Authorization tuple list.\n * @returns An {@link ox#AuthorizationTempo.List}.\n */ function fromTupleList(tupleList) {\n    const list = [];\n    for (const tuple of tupleList)list.push(fromTuple(tuple));\n    return list;\n}\n/**\n * Computes the sign payload for an {@link ox#AuthorizationTempo.AuthorizationTempo} in [EIP-7702 format](https://eips.ethereum.org/EIPS/eip-7702): `keccak256('0x05' || rlp([chain_id, address, nonce]))`.\n *\n * @example\n * ### Secp256k1\n *\n * Standard Ethereum ECDSA signature using the secp256k1 curve.\n *\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n * import { AuthorizationTempo } from 'ox/tempo'\n *\n * const privateKey = Secp256k1.randomPrivateKey()\n *\n * const authorization = AuthorizationTempo.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const payload = AuthorizationTempo.getSignPayload(authorization) // [!code focus]\n *\n * const signature = Secp256k1.sign({ payload, privateKey })\n * const authorization_signed = AuthorizationTempo.from(\n *   authorization,\n *   { signature }\n * )\n * ```\n *\n * @example\n * ### P256\n *\n * ECDSA signature using the P-256 (secp256r1) curve. Requires embedding the\n * public key and a `prehash` flag indicating whether the payload was hashed\n * before signing.\n *\n * ```ts twoslash\n * import { P256 } from 'ox'\n * import { AuthorizationTempo, SignatureEnvelope } from 'ox/tempo'\n *\n * const { privateKey, publicKey } = P256.createKeyPair()\n *\n * const authorization = AuthorizationTempo.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const payload = AuthorizationTempo.getSignPayload(authorization) // [!code focus]\n *\n * const signature = P256.sign({ payload, privateKey })\n * const signatureEnvelope = SignatureEnvelope.from({\n *   prehash: false,\n *   publicKey,\n *   signature,\n * })\n * const authorization_signed = AuthorizationTempo.from(\n *   authorization,\n *   { signature: signatureEnvelope }\n * )\n * ```\n *\n * @example\n * ### P256 (WebCrypto)\n *\n * When using WebCrypto keys, `prehash` must be `true` since WebCrypto always\n * hashes the payload internally before signing.\n *\n * ```ts twoslash\n * // @noErrors\n * import { WebCryptoP256 } from 'ox'\n * import { AuthorizationTempo, SignatureEnvelope } from 'ox/tempo'\n *\n * const { privateKey, publicKey } = await WebCryptoP256.createKeyPair()\n *\n * const authorization = AuthorizationTempo.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const payload = AuthorizationTempo.getSignPayload(authorization) // [!code focus]\n *\n * const signature = await WebCryptoP256.sign({ payload, privateKey })\n * const signatureEnvelope = SignatureEnvelope.from({\n *   prehash: true,\n *   publicKey,\n *   signature,\n * })\n * const authorization_signed = AuthorizationTempo.from(\n *   authorization,\n *   { signature: signatureEnvelope }\n * )\n * ```\n *\n * @example\n * ### WebAuthn\n *\n * Passkey-based signature using WebAuthn. Includes authenticator metadata\n * (authenticatorData and clientDataJSON) along with the P-256 signature and\n * public key.\n *\n * ```ts twoslash\n * // @noErrors\n * import { WebAuthnP256 } from 'ox'\n * import { AuthorizationTempo, SignatureEnvelope } from 'ox/tempo'\n *\n * const credential = await WebAuthnP256.createCredential({ name: 'Example' })\n *\n * const authorization = AuthorizationTempo.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const challenge = AuthorizationTempo.getSignPayload(authorization) // [!code focus]\n *\n * const { metadata, signature } = await WebAuthnP256.sign({\n *   challenge,\n *   credentialId: credential.id,\n * })\n * const signatureEnvelope = SignatureEnvelope.from({\n *   signature,\n *   publicKey: credential.publicKey,\n *   metadata,\n * })\n * const authorization_signed = AuthorizationTempo.from(\n *   authorization,\n *   { signature: signatureEnvelope }\n * )\n * ```\n *\n * @param authorization - The {@link ox#AuthorizationTempo.AuthorizationTempo}.\n * @returns The sign payload.\n */ function getSignPayload(authorization) {\n    return hash(authorization, {\n        presign: true\n    });\n}\n/**\n * Computes the hash for an {@link ox#AuthorizationTempo.AuthorizationTempo} in [EIP-7702 format](https://eips.ethereum.org/EIPS/eip-7702): `keccak256('0x05' || rlp([chain_id, address, nonce]))`.\n *\n * @example\n * ```ts twoslash\n * import { AuthorizationTempo } from 'ox/tempo'\n *\n * const authorization = AuthorizationTempo.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const hash = AuthorizationTempo.hash(authorization) // [!code focus]\n * ```\n *\n * @param authorization - The {@link ox#AuthorizationTempo.AuthorizationTempo}.\n * @returns The hash.\n */ function hash(authorization, options = {}) {\n    const { presign } = options;\n    return _core_Hash_js__WEBPACK_IMPORTED_MODULE_1__.keccak256(_core_Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(\"0x05\", _core_Rlp_js__WEBPACK_IMPORTED_MODULE_3__.fromHex(toTuple(presign ? {\n        address: authorization.address,\n        chainId: authorization.chainId,\n        nonce: authorization.nonce\n    } : authorization))));\n}\n/**\n * Converts an {@link ox#AuthorizationTempo.AuthorizationTempo} to an {@link ox#AuthorizationTempo.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { AuthorizationTempo } from 'ox/tempo'\n *\n * const authorization = AuthorizationTempo.toRpc({\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: 1,\n *   nonce: 1n,\n *   signature: {\n *     type: 'secp256k1',\n *     signature: {\n *       r: 44944627813007772897391531230081695102703289123332187696115181104739239197517n,\n *       s: 36528503505192438307355164441104001310566505351980369085208178712678799181120n,\n *       yParity: 0,\n *     },\n *   },\n * })\n * ```\n *\n * @param authorization - An AA Authorization.\n * @returns An RPC-formatted AA Authorization.\n */ function toRpc(authorization) {\n    const { address, chainId, nonce, signature } = authorization;\n    return {\n        address,\n        chainId: _core_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(chainId),\n        nonce: _core_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(nonce),\n        signature: _SignatureEnvelope_js__WEBPACK_IMPORTED_MODULE_0__.toRpc(signature)\n    };\n}\n/**\n * Converts an {@link ox#AuthorizationTempo.List} to an {@link ox#AuthorizationTempo.ListRpc}.\n *\n * @example\n * ```ts twoslash\n * import { AuthorizationTempo } from 'ox/tempo'\n *\n * const authorization = AuthorizationTempo.toRpcList([{\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: 1,\n *   nonce: 1n,\n *   signature: {\n *     type: 'secp256k1',\n *     signature: {\n *       r: 44944627813007772897391531230081695102703289123332187696115181104739239197517n,\n *       s: 36528503505192438307355164441104001310566505351980369085208178712678799181120n,\n *       yParity: 0,\n *     },\n *   },\n * }])\n * ```\n *\n * @param authorizationList - An AA Authorization List.\n * @returns An RPC-formatted AA Authorization List.\n */ function toRpcList(authorizationList) {\n    return authorizationList.map((x)=>toRpc(x));\n}\n/**\n * Converts an {@link ox#AuthorizationTempo.AuthorizationTempo} to an {@link ox#AuthorizationTempo.Tuple}.\n *\n * @example\n * ```ts twoslash\n * import { AuthorizationTempo } from 'ox/tempo'\n *\n * const authorization = AuthorizationTempo.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const tuple = AuthorizationTempo.toTuple(authorization) // [!code focus]\n * // @log: [\n * // @log:   address: '0x1234567890abcdef1234567890abcdef12345678',\n * // @log:   chainId: 1,\n * // @log:   nonce: 69n,\n * // @log: ]\n * ```\n *\n * @param authorization - The {@link ox#AuthorizationTempo.AuthorizationTempo}.\n * @returns An [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) AA Authorization tuple.\n */ function toTuple(authorization) {\n    const { address, chainId, nonce } = authorization;\n    const signature = authorization.signature ? _SignatureEnvelope_js__WEBPACK_IMPORTED_MODULE_0__.serialize(authorization.signature) : undefined;\n    return [\n        chainId ? _core_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(chainId) : \"0x\",\n        address,\n        nonce ? _core_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(nonce) : \"0x\",\n        ...signature ? [\n            signature\n        ] : []\n    ];\n}\n/**\n * Converts an {@link ox#AuthorizationTempo.List} to an {@link ox#AuthorizationTempo.TupleList}.\n *\n * @example\n * ```ts twoslash\n * import { AuthorizationTempo } from 'ox/tempo'\n *\n * const authorization_1 = AuthorizationTempo.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n * const authorization_2 = AuthorizationTempo.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 3,\n *   nonce: 20n,\n * })\n *\n * const tuple = AuthorizationTempo.toTupleList([authorization_1, authorization_2]) // [!code focus]\n * // @log: [\n * // @log:   [\n * // @log:     address: '0x1234567890abcdef1234567890abcdef12345678',\n * // @log:     chainId: 1,\n * // @log:     nonce: 69n,\n * // @log:   ],\n * // @log:   [\n * // @log:     address: '0x1234567890abcdef1234567890abcdef12345678',\n * // @log:     chainId: 3,\n * // @log:     nonce: 20n,\n * // @log:   ],\n * // @log: ]\n * ```\n *\n * @param list - An {@link ox#AuthorizationTempo.List}.\n * @returns An [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) AA Authorization tuple list.\n */ function toTupleList(list) {\n    if (!list || list.length === 0) return [];\n    const tupleList = [];\n    for (const authorization of list)tupleList.push(toTuple(authorization));\n    return tupleList;\n} //# sourceMappingURL=AuthorizationTempo.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS90ZW1wby9BdXRob3JpemF0aW9uVGVtcG8uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXdDO0FBQ0Y7QUFDQTtBQUNzQjtBQUM1RDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQTZKQyxHQUNNLFNBQVNJLEtBQUtDLGFBQWEsRUFBRUMsVUFBVSxDQUFDLENBQUM7SUFDNUMsSUFBSSxPQUFPRCxjQUFjRSxPQUFPLEtBQUssVUFDakMsT0FBT0MsUUFBUUg7SUFDbkIsSUFBSUMsUUFBUUcsU0FBUyxFQUFFO1FBQ25CLE9BQU87WUFBRSxHQUFHSixhQUFhO1lBQUVJLFdBQVdILFFBQVFHLFNBQVM7UUFBQztJQUM1RDtJQUNBLE9BQU9KO0FBQ1g7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXNCQyxHQUNNLFNBQVNHLFFBQVFILGFBQWE7SUFDakMsTUFBTSxFQUFFSyxPQUFPLEVBQUVILE9BQU8sRUFBRUksS0FBSyxFQUFFLEdBQUdOO0lBQ3BDLE1BQU1JLFlBQVlOLDBEQUF5QixDQUFDRSxjQUFjSSxTQUFTO0lBQ25FLE9BQU87UUFDSEM7UUFDQUgsU0FBU0ssT0FBT0w7UUFDaEJJLE9BQU9FLE9BQU9GO1FBQ2RGO0lBQ0o7QUFDSjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBc0JDLEdBQ00sU0FBU0ssWUFBWUMsaUJBQWlCO0lBQ3pDLE9BQU9BLGtCQUFrQkMsR0FBRyxDQUFDLENBQUNDLElBQU1ULFFBQVFTO0FBQ2hEO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQTZDQyxHQUNNLFNBQVNDLFVBQVVD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a3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS90ZW1wby9BdXRob3JpemF0aW9uVGVtcG8uanM/MzRkZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBIYXNoIGZyb20gJy4uL2NvcmUvSGFzaC5qcyc7XG5pbXBvcnQgKiBhcyBIZXggZnJvbSAnLi4vY29yZS9IZXguanMnO1xuaW1wb3J0ICogYXMgUmxwIGZyb20gJy4uL2NvcmUvUmxwLmpzJztcbmltcG9ydCAqIGFzIFNpZ25hdHVyZUVudmVsb3BlIGZyb20gJy4vU2lnbmF0dXJlRW52ZWxvcGUuanMnO1xuLyoqXG4gKiBDb252ZXJ0cyBhbiBFSVAtNzcwMiBBdXRob3JpemF0aW9uIG9iamVjdCBpbnRvIGEgdHlwZWQge0BsaW5rIG94I0F1dGhvcml6YXRpb25UZW1wby5BdXRob3JpemF0aW9uVGVtcG99LlxuICpcbiAqIFRlbXBvIGV4dGVuZHMgRUlQLTc3MDIgdG8gc3VwcG9ydCBzZWNwMjU2azEsIFAyNTYsIGFuZCBXZWJBdXRobiBzaWduYXR1cmUgdHlwZXMuXG4gKlxuICogW1RlbXBvIEF1dGhvcml6YXRpb24gU3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly9kb2NzLnRlbXBvLnh5ei9wcm90b2NvbC90cmFuc2FjdGlvbnMvc3BlYy10ZW1wby10cmFuc2FjdGlvbiN0ZW1wby1hdXRob3JpemF0aW9uLWxpc3QpXG4gKlxuICogQGV4YW1wbGVcbiAqIEFuIEF1dGhvcml6YXRpb24gY2FuIGJlIGluc3RhbnRpYXRlZCBmcm9tIGFuIEVJUC03NzAyIEF1dGhvcml6YXRpb24gdHVwbGUgaW4gb2JqZWN0IGZvcm1hdC5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQXV0aG9yaXphdGlvblRlbXBvIH0gZnJvbSAnb3gvdGVtcG8nXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEF1dGhvcml6YXRpb25UZW1wby5mcm9tKHtcbiAqICAgYWRkcmVzczogJzB4MTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3OCcsXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG5vbmNlOiA2OW4sXG4gKiB9KVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBBdHRhY2hpbmcgU2lnbmF0dXJlcyAoU2VjcDI1NmsxKVxuICpcbiAqIFN0YW5kYXJkIEV0aGVyZXVtIEVDRFNBIHNpZ25hdHVyZSB1c2luZyB0aGUgc2VjcDI1NmsxIGN1cnZlLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEgfSBmcm9tICdveCdcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb25UZW1wbyB9IGZyb20gJ294L3RlbXBvJ1xuICpcbiAqIGNvbnN0IHByaXZhdGVLZXkgPSBTZWNwMjU2azEucmFuZG9tUHJpdmF0ZUtleSgpXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEF1dGhvcml6YXRpb25UZW1wby5mcm9tKHtcbiAqICAgYWRkcmVzczogJzB4YmU5NWMzZjU1NGU5ZmM4NWVjNTFiZTY5YTNkODA3YTBkNTViY2YyYycsXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG5vbmNlOiA0MG4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHtcbiAqICAgcGF5bG9hZDogQXV0aG9yaXphdGlvblRlbXBvLmdldFNpZ25QYXlsb2FkKGF1dGhvcml6YXRpb24pLFxuICogICBwcml2YXRlS2V5LFxuICogfSlcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uX3NpZ25lZCA9IEF1dGhvcml6YXRpb25UZW1wby5mcm9tKFxuICogICBhdXRob3JpemF0aW9uLFxuICogICB7IHNpZ25hdHVyZSB9LCAvLyBbIWNvZGUgZm9jdXNdXG4gKiApXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEF0dGFjaGluZyBTaWduYXR1cmVzIChQMjU2KVxuICpcbiAqIEVDRFNBIHNpZ25hdHVyZSB1c2luZyB0aGUgUC0yNTYgKHNlY3AyNTZyMSkgY3VydmUuIFJlcXVpcmVzIGVtYmVkZGluZyB0aGVcbiAqIHB1YmxpYyBrZXkgYW5kIGEgYHByZWhhc2hgIGZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBwYXlsb2FkIHdhcyBoYXNoZWRcbiAqIGJlZm9yZSBzaWduaW5nLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBQMjU2IH0gZnJvbSAnb3gnXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uVGVtcG8sIFNpZ25hdHVyZUVudmVsb3BlIH0gZnJvbSAnb3gvdGVtcG8nXG4gKlxuICogY29uc3QgeyBwcml2YXRlS2V5LCBwdWJsaWNLZXkgfSA9IFAyNTYuY3JlYXRlS2V5UGFpcigpXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEF1dGhvcml6YXRpb25UZW1wby5mcm9tKHtcbiAqICAgYWRkcmVzczogJzB4YmU5NWMzZjU1NGU5ZmM4NWVjNTFiZTY5YTNkODA3YTBkNTViY2YyYycsXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG5vbmNlOiA0MG4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFAyNTYuc2lnbih7XG4gKiAgIHBheWxvYWQ6IEF1dGhvcml6YXRpb25UZW1wby5nZXRTaWduUGF5bG9hZChhdXRob3JpemF0aW9uKSxcbiAqICAgcHJpdmF0ZUtleSxcbiAqIH0pXG4gKiBjb25zdCBzaWduYXR1cmVFbnZlbG9wZSA9IFNpZ25hdHVyZUVudmVsb3BlLmZyb20oe1xuICogICBzaWduYXR1cmUsXG4gKiAgIHB1YmxpY0tleSxcbiAqICAgcHJlaGFzaDogZmFsc2UsXG4gKiB9KVxuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb25fc2lnbmVkID0gQXV0aG9yaXphdGlvblRlbXBvLmZyb20oXG4gKiAgIGF1dGhvcml6YXRpb24sXG4gKiAgIHsgc2lnbmF0dXJlOiBzaWduYXR1cmVFbnZlbG9wZSB9LCAvLyBbIWNvZGUgZm9jdXNdXG4gKiApXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEF0dGFjaGluZyBTaWduYXR1cmVzIChQMjU2IFdlYkNyeXB0bylcbiAqXG4gKiBXaGVuIHVzaW5nIFdlYkNyeXB0byBrZXlzLCBgcHJlaGFzaGAgbXVzdCBiZSBgdHJ1ZWAgc2luY2UgV2ViQ3J5cHRvIGFsd2F5c1xuICogaGFzaGVzIHRoZSBwYXlsb2FkIGludGVybmFsbHkgYmVmb3JlIHNpZ25pbmcuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgV2ViQ3J5cHRvUDI1NiB9IGZyb20gJ294J1xuICogaW1wb3J0IHsgQXV0aG9yaXphdGlvblRlbXBvLCBTaWduYXR1cmVFbnZlbG9wZSB9IGZyb20gJ294L3RlbXBvJ1xuICpcbiAqIGNvbnN0IHsgcHJpdmF0ZUtleSwgcHVibGljS2V5IH0gPSBhd2FpdCBXZWJDcnlwdG9QMjU2LmNyZWF0ZUtleVBhaXIoKVxuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb24gPSBBdXRob3JpemF0aW9uVGVtcG8uZnJvbSh7XG4gKiAgIGFkZHJlc3M6ICcweGJlOTVjM2Y1NTRlOWZjODVlYzUxYmU2OWEzZDgwN2EwZDU1YmNmMmMnLFxuICogICBjaGFpbklkOiAxLFxuICogICBub25jZTogNDBuLFxuICogfSlcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBXZWJDcnlwdG9QMjU2LnNpZ24oe1xuICogICBwYXlsb2FkOiBBdXRob3JpemF0aW9uVGVtcG8uZ2V0U2lnblBheWxvYWQoYXV0aG9yaXphdGlvbiksXG4gKiAgIHByaXZhdGVLZXksXG4gKiB9KVxuICogY29uc3Qgc2lnbmF0dXJlRW52ZWxvcGUgPSBTaWduYXR1cmVFbnZlbG9wZS5mcm9tKHtcbiAqICAgc2lnbmF0dXJlLFxuICogICBwdWJsaWNLZXksXG4gKiAgIHByZWhhc2g6IHRydWUsXG4gKiB9KVxuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb25fc2lnbmVkID0gQXV0aG9yaXphdGlvblRlbXBvLmZyb20oXG4gKiAgIGF1dGhvcml6YXRpb24sXG4gKiAgIHsgc2lnbmF0dXJlOiBzaWduYXR1cmVFbnZlbG9wZSB9LCAvLyBbIWNvZGUgZm9jdXNdXG4gKiApXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEF0dGFjaGluZyBTaWduYXR1cmVzIChXZWJBdXRobilcbiAqXG4gKiBQYXNza2V5LWJhc2VkIHNpZ25hdHVyZSB1c2luZyBXZWJBdXRobi4gSW5jbHVkZXMgYXV0aGVudGljYXRvciBtZXRhZGF0YVxuICogKGF1dGhlbnRpY2F0b3JEYXRhIGFuZCBjbGllbnREYXRhSlNPTikgYWxvbmcgd2l0aCB0aGUgUC0yNTYgc2lnbmF0dXJlIGFuZFxuICogcHVibGljIGtleS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBXZWJBdXRoblAyNTYgfSBmcm9tICdveCdcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb25UZW1wbywgU2lnbmF0dXJlRW52ZWxvcGUgfSBmcm9tICdveC90ZW1wbydcbiAqXG4gKiBjb25zdCBjcmVkZW50aWFsID0gYXdhaXQgV2ViQXV0aG5QMjU2LmNyZWF0ZUNyZWRlbnRpYWwoeyBuYW1lOiAnRXhhbXBsZScgfSlcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uID0gQXV0aG9yaXphdGlvblRlbXBvLmZyb20oe1xuICogICBhZGRyZXNzOiAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJyxcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbm9uY2U6IDQwbixcbiAqIH0pXG4gKlxuICogY29uc3QgeyBtZXRhZGF0YSwgc2lnbmF0dXJlIH0gPSBhd2FpdCBXZWJBdXRoblAyNTYuc2lnbih7XG4gKiAgIGNoYWxsZW5nZTogQXV0aG9yaXphdGlvblRlbXBvLmdldFNpZ25QYXlsb2FkKGF1dGhvcml6YXRpb24pLFxuICogICBjcmVkZW50aWFsSWQ6IGNyZWRlbnRpYWwuaWQsXG4gKiB9KVxuICogY29uc3Qgc2lnbmF0dXJlRW52ZWxvcGUgPSBTaWduYXR1cmVFbnZlbG9wZS5mcm9tKHtcbiAqICAgc2lnbmF0dXJlLFxuICogICBwdWJsaWNLZXk6IGNyZWRlbnRpYWwucHVibGljS2V5LFxuICogICBtZXRhZGF0YSxcbiAqIH0pXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbl9zaWduZWQgPSBBdXRob3JpemF0aW9uVGVtcG8uZnJvbShcbiAqICAgYXV0aG9yaXphdGlvbixcbiAqICAgeyBzaWduYXR1cmU6IHNpZ25hdHVyZUVudmVsb3BlIH0sIC8vIFshY29kZSBmb2N1c11cbiAqIClcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRob3JpemF0aW9uIC0gQW4gW0VJUC03NzAyXShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTc3MDIpIEFBIEF1dGhvcml6YXRpb24gdHVwbGUgaW4gb2JqZWN0IGZvcm1hdC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gQUEgQXV0aG9yaXphdGlvbiBvcHRpb25zLlxuICogQHJldHVybnMgVGhlIHtAbGluayBveCNBdXRob3JpemF0aW9uVGVtcG8uQXV0aG9yaXphdGlvblRlbXBvfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb20oYXV0aG9yaXphdGlvbiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKHR5cGVvZiBhdXRob3JpemF0aW9uLmNoYWluSWQgPT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gZnJvbVJwYyhhdXRob3JpemF0aW9uKTtcbiAgICBpZiAob3B0aW9ucy5zaWduYXR1cmUpIHtcbiAgICAgICAgcmV0dXJuIHsgLi4uYXV0aG9yaXphdGlvbiwgc2lnbmF0dXJlOiBvcHRpb25zLnNpZ25hdHVyZSB9O1xuICAgIH1cbiAgICByZXR1cm4gYXV0aG9yaXphdGlvbjtcbn1cbi8qKlxuICogQ29udmVydHMgYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb25UZW1wby5ScGN9IHRvIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uVGVtcG8uQXV0aG9yaXphdGlvblRlbXBvfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb25UZW1wbyB9IGZyb20gJ294L3RlbXBvJ1xuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb24gPSBBdXRob3JpemF0aW9uVGVtcG8uZnJvbVJwYyh7XG4gKiAgIGFkZHJlc3M6ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICBjaGFpbklkOiAnMHgxJyxcbiAqICAgbm9uY2U6ICcweDEnLFxuICogICBzaWduYXR1cmU6IHtcbiAqICAgICB0eXBlOiAnc2VjcDI1NmsxJyxcbiAqICAgICByOiAnMHg2MzVkYzIwMzNlNjAxODViYjM2NzA5YzI5Yzc1ZDY0ZWE1MWRmYmQ5MWMzMmVmNGJlMTk4ZTRjZWIxNjlmYjRkJyxcbiAqICAgICBzOiAnMHg1MGMyNjY3YWM0Yzc3MTA3Mjc0NmFjZmRjZjFmMTQ4MzMzNmRjY2E4YmQyZGY0N2NkODMxNzVkYmU2MGYwNTQwJyxcbiAqICAgICB5UGFyaXR5OiAnMHgwJyxcbiAqICAgfSxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYXV0aG9yaXphdGlvbiAtIFRoZSBSUEMtZm9ybWF0dGVkIEFBIEF1dGhvcml6YXRpb24uXG4gKiBAcmV0dXJucyBBIHNpZ25lZCB7QGxpbmsgb3gjQXV0aG9yaXphdGlvblRlbXBvLkF1dGhvcml6YXRpb25UZW1wb30uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUnBjKGF1dGhvcml6YXRpb24pIHtcbiAgICBjb25zdCB7IGFkZHJlc3MsIGNoYWluSWQsIG5vbmNlIH0gPSBhdXRob3JpemF0aW9uO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ25hdHVyZUVudmVsb3BlLmZyb21ScGMoYXV0aG9yaXphdGlvbi5zaWduYXR1cmUpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGFkZHJlc3MsXG4gICAgICAgIGNoYWluSWQ6IE51bWJlcihjaGFpbklkKSxcbiAgICAgICAgbm9uY2U6IEJpZ0ludChub25jZSksXG4gICAgICAgIHNpZ25hdHVyZSxcbiAgICB9O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvblRlbXBvLkxpc3RScGN9IHRvIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uVGVtcG8uTGlzdH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uVGVtcG8gfSBmcm9tICdveC90ZW1wbydcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uTGlzdCA9IEF1dGhvcml6YXRpb25UZW1wby5mcm9tUnBjTGlzdChbe1xuICogICBhZGRyZXNzOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgY2hhaW5JZDogJzB4MScsXG4gKiAgIG5vbmNlOiAnMHgxJyxcbiAqICAgc2lnbmF0dXJlOiB7XG4gKiAgICAgdHlwZTogJ3NlY3AyNTZrMScsXG4gKiAgICAgcjogJzB4NjM1ZGMyMDMzZTYwMTg1YmIzNjcwOWMyOWM3NWQ2NGVhNTFkZmJkOTFjMzJlZjRiZTE5OGU0Y2ViMTY5ZmI0ZCcsXG4gKiAgICAgczogJzB4NTBjMjY2N2FjNGM3NzEwNzI3NDZhY2ZkY2YxZjE0ODMzMzZkY2NhOGJkMmRmNDdjZDgzMTc1ZGJlNjBmMDU0MCcsXG4gKiAgICAgeVBhcml0eTogJzB4MCcsXG4gKiAgIH0sXG4gKiB9XSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRob3JpemF0aW9uTGlzdCAtIFRoZSBSUEMtZm9ybWF0dGVkIEFBIEF1dGhvcml6YXRpb24gbGlzdC5cbiAqIEByZXR1cm5zIEEgc2lnbmVkIHtAbGluayBveCNBdXRob3JpemF0aW9uVGVtcG8uTGlzdH0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUnBjTGlzdChhdXRob3JpemF0aW9uTGlzdCkge1xuICAgIHJldHVybiBhdXRob3JpemF0aW9uTGlzdC5tYXAoKHgpID0+IGZyb21ScGMoeCkpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvblRlbXBvLlR1cGxlfSB0byBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvblRlbXBvLkF1dGhvcml6YXRpb25UZW1wb30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uVGVtcG8gfSBmcm9tICdveC90ZW1wbydcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uID0gQXV0aG9yaXphdGlvblRlbXBvLmZyb21UdXBsZShbXG4gKiAgICcweDEnLFxuICogICAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJyxcbiAqICAgJzB4MydcbiAqIF0pXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIGFkZHJlc3M6ICcweGJlOTVjM2Y1NTRlOWZjODVlYzUxYmU2OWEzZDgwN2EwZDU1YmNmMmMnLFxuICogLy8gQGxvZzogICBjaGFpbklkOiAxLFxuICogLy8gQGxvZzogICBub25jZTogM25cbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBJdCBpcyBhbHNvIHBvc3NpYmxlIHRvIGFwcGVuZCBhIHNlcmlhbGl6ZWQgU2lnbmF0dXJlRW52ZWxvcGUgdG8gdGhlIGVuZCBvZiBhbiBBQSBBdXRob3JpemF0aW9uIHR1cGxlLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uVGVtcG8gfSBmcm9tICdveC90ZW1wbydcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uID0gQXV0aG9yaXphdGlvblRlbXBvLmZyb21UdXBsZShbXG4gKiAgICcweDEnLFxuICogICAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJyxcbiAqICAgJzB4MycsXG4gKiAgICcweDAxYTA2OGEwMjBhMjA5ZDNkNTZjNDZmMzhjYzUwYTMzZjcwNGY0YTlhMTBhNTkzNzdmOGRkNzYyYWM2NjkxMGU5YjkwN2U4NjVhZDA1YzQwMzVhYjU3OTI3ODdkNGEwMjk3YTQzNjE3YWU4OTc5MzBhNmZlNGQ4MjJiOGZhZWE1MjA2NCcsXG4gKiBdKVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICBhZGRyZXNzOiAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJyxcbiAqIC8vIEBsb2c6ICAgY2hhaW5JZDogMSxcbiAqIC8vIEBsb2c6ICAgbm9uY2U6IDNuXG4gKiAvLyBAbG9nOiAgIHNpZ25hdHVyZToge1xuICogLy8gQGxvZzogICAgIHI6IEJpZ0ludCgnMHg2OGEwMjBhMjA5ZDNkNTZjNDZmMzhjYzUwYTMzZjcwNGY0YTlhMTBhNTkzNzdmOGRkNzYyYWM2NjkxMGU5YjkwJyksXG4gKiAvLyBAbG9nOiAgICAgczogQmlnSW50KCcweDdlODY1YWQwNWM0MDM1YWI1NzkyNzg3ZDRhMDI5N2E0MzYxN2FlODk3OTMwYTZmZTRkODIyYjhmYWVhNTIwNjQnKSxcbiAqIC8vIEBsb2c6ICAgICB5UGFyaXR5OiAwLFxuICogLy8gQGxvZzogICB9LFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHR1cGxlIC0gVGhlIFtFSVAtNzcwMl0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC03NzAyKSBBQSBBdXRob3JpemF0aW9uIHR1cGxlLlxuICogQHJldHVybnMgVGhlIHtAbGluayBveCNBdXRob3JpemF0aW9uVGVtcG8uQXV0aG9yaXphdGlvblRlbXBvfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21UdXBsZSh0dXBsZSkge1xuICAgIGNvbnN0IFtjaGFpbklkLCBhZGRyZXNzLCBub25jZSwgc2lnbmF0dXJlU2VyaWFsaXplZF0gPSB0dXBsZTtcbiAgICBjb25zdCBhcmdzID0ge1xuICAgICAgICBhZGRyZXNzLFxuICAgICAgICBjaGFpbklkOiBjaGFpbklkID09PSAnMHgnID8gMCA6IE51bWJlcihjaGFpbklkKSxcbiAgICAgICAgbm9uY2U6IG5vbmNlID09PSAnMHgnID8gMG4gOiBCaWdJbnQobm9uY2UpLFxuICAgIH07XG4gICAgaWYgKHNpZ25hdHVyZVNlcmlhbGl6ZWQpXG4gICAgICAgIGFyZ3Muc2lnbmF0dXJlID0gU2lnbmF0dXJlRW52ZWxvcGUuZGVzZXJpYWxpemUoc2lnbmF0dXJlU2VyaWFsaXplZCk7XG4gICAgcmV0dXJuIGZyb20oYXJncyk7XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uVGVtcG8uVHVwbGVMaXN0fSB0byBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvblRlbXBvLkxpc3R9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQXV0aG9yaXphdGlvblRlbXBvIH0gZnJvbSAnb3gvdGVtcG8nXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbkxpc3QgPSBBdXRob3JpemF0aW9uVGVtcG8uZnJvbVR1cGxlTGlzdChbXG4gKiAgIFsnMHgxJywgJzB4YmU5NWMzZjU1NGU5ZmM4NWVjNTFiZTY5YTNkODA3YTBkNTViY2YyYycsICcweDMnXSxcbiAqICAgWycweDMnLCAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJywgJzB4MTQnXSxcbiAqIF0pXG4gKiAvLyBAbG9nOiBbXG4gKiAvLyBAbG9nOiAgIHtcbiAqIC8vIEBsb2c6ICAgICBhZGRyZXNzOiAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJyxcbiAqIC8vIEBsb2c6ICAgICBjaGFpbklkOiAxLFxuICogLy8gQGxvZzogICAgIG5vbmNlOiAzbixcbiAqIC8vIEBsb2c6ICAgfSxcbiAqIC8vIEBsb2c6ICAge1xuICogLy8gQGxvZzogICAgIGFkZHJlc3M6ICcweGJlOTVjM2Y1NTRlOWZjODVlYzUxYmU2OWEzZDgwN2EwZDU1YmNmMmMnLFxuICogLy8gQGxvZzogICAgIGNoYWluSWQ6IDMsXG4gKiAvLyBAbG9nOiAgICAgbm9uY2U6IDIwbixcbiAqIC8vIEBsb2c6ICAgfSxcbiAqIC8vIEBsb2c6IF1cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBJdCBpcyBhbHNvIHBvc3NpYmxlIHRvIGFwcGVuZCBhIHNlcmlhbGl6ZWQgU2lnbmF0dXJlRW52ZWxvcGUgdG8gdGhlIGVuZCBvZiBhbiBBQSBBdXRob3JpemF0aW9uIHR1cGxlLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uVGVtcG8gfSBmcm9tICdveC90ZW1wbydcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uTGlzdCA9IEF1dGhvcml6YXRpb25UZW1wby5mcm9tVHVwbGVMaXN0KFtcbiAqICAgWycweDEnLCAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJywgJzB4MycsICcweDAxYTA2OGEwMjBhMjA5ZDNkNTZjNDZmMzhjYzUwYTMzZjcwNGY0YTlhMTBhNTkzNzdmOGRkNzYyYWM2NjkxMGU5YjkwN2U4NjVhZDA1YzQwMzVhYjU3OTI3ODdkNGEwMjk3YTQzNjE3YWU4OTc5MzBhNmZlNGQ4MjJiOGZhZWE1MjA2NCddLFxuICogICBbJzB4MycsICcweGJlOTVjM2Y1NTRlOWZjODVlYzUxYmU2OWEzZDgwN2EwZDU1YmNmMmMnLCAnMHgxNCcsICcweDAxYTA2OGEwMjBhMjA5ZDNkNTZjNDZmMzhjYzUwYTMzZjcwNGY0YTlhMTBhNTkzNzdmOGRkNzYyYWM2NjkxMGU5YjkwN2U4NjVhZDA1YzQwMzVhYjU3OTI3ODdkNGEwMjk3YTQzNjE3YWU4OTc5MzBhNmZlNGQ4MjJiOGZhZWE1MjA2NCddLFxuICogXSlcbiAqIC8vIEBsb2c6IFtcbiAqIC8vIEBsb2c6ICAge1xuICogLy8gQGxvZzogICAgIGFkZHJlc3M6ICcweGJlOTVjM2Y1NTRlOWZjODVlYzUxYmU2OWEzZDgwN2EwZDU1YmNmMmMnLFxuICogLy8gQGxvZzogICAgIGNoYWluSWQ6IDEsXG4gKiAvLyBAbG9nOiAgICAgbm9uY2U6IDNuLFxuICogLy8gQGxvZzogICAgIHNpZ25hdHVyZToge1xuICogLy8gQGxvZzogICAgICAgcjogQmlnSW50KCcweDY4YTAyMGEyMDlkM2Q1NmM0NmYzOGNjNTBhMzNmNzA0ZjRhOWExMGE1OTM3N2Y4ZGQ3NjJhYzY2OTEwZTliOTAnKSxcbiAqIC8vIEBsb2c6ICAgICAgIHM6IEJpZ0ludCgnMHg3ZTg2NWFkMDVjNDAzNWFiNTc5Mjc4N2Q0YTAyOTdhNDM2MTdhZTg5NzkzMGE2ZmU0ZDgyMmI4ZmFlYTUyMDY0JyksXG4gKiAvLyBAbG9nOiAgICAgICB5UGFyaXR5OiAwLFxuICogLy8gQGxvZzogICAgIH0sXG4gKiAvLyBAbG9nOiAgIH0sXG4gKiAvLyBAbG9nOiAgIHtcbiAqIC8vIEBsb2c6ICAgICBhZGRyZXNzOiAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJyxcbiAqIC8vIEBsb2c6ICAgICBjaGFpbklkOiAzLFxuICogLy8gQGxvZzogICAgIG5vbmNlOiAyMG4sXG4gKiAvLyBAbG9nOiAgICAgc2lnbmF0dXJlOiB7XG4gKiAvLyBAbG9nOiAgICAgICByOiBCaWdJbnQoJzB4NjhhMDIwYTIwOWQzZDU2YzQ2ZjM4Y2M1MGEzM2Y3MDRmNGE5YTEwYTU5Mzc3ZjhkZDc2MmFjNjY5MTBlOWI5MCcpLFxuICogLy8gQGxvZzogICAgICAgczogQmlnSW50KCcweDdlODY1YWQwNWM0MDM1YWI1NzkyNzg3ZDRhMDI5N2E0MzYxN2FlODk3OTMwYTZmZTRkODIyYjhmYWVhNTIwNjQnKSxcbiAqIC8vIEBsb2c6ICAgICAgIHlQYXJpdHk6IDAsXG4gKiAvLyBAbG9nOiAgICAgfSxcbiAqIC8vIEBsb2c6ICAgfSxcbiAqIC8vIEBsb2c6IF1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB0dXBsZUxpc3QgLSBUaGUgW0VJUC03NzAyXShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTc3MDIpIEFBIEF1dGhvcml6YXRpb24gdHVwbGUgbGlzdC5cbiAqIEByZXR1cm5zIEFuIHtAbGluayBveCNBdXRob3JpemF0aW9uVGVtcG8uTGlzdH0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVHVwbGVMaXN0KHR1cGxlTGlzdCkge1xuICAgIGNvbnN0IGxpc3QgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHR1cGxlIG9mIHR1cGxlTGlzdClcbiAgICAgICAgbGlzdC5wdXNoKGZyb21UdXBsZSh0dXBsZSkpO1xuICAgIHJldHVybiBsaXN0O1xufVxuLyoqXG4gKiBDb21wdXRlcyB0aGUgc2lnbiBwYXlsb2FkIGZvciBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvblRlbXBvLkF1dGhvcml6YXRpb25UZW1wb30gaW4gW0VJUC03NzAyIGZvcm1hdF0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC03NzAyKTogYGtlY2NhazI1NignMHgwNScgfHwgcmxwKFtjaGFpbl9pZCwgYWRkcmVzcywgbm9uY2VdKSlgLlxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgU2VjcDI1NmsxXG4gKlxuICogU3RhbmRhcmQgRXRoZXJldW0gRUNEU0Egc2lnbmF0dXJlIHVzaW5nIHRoZSBzZWNwMjU2azEgY3VydmUuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNlY3AyNTZrMSB9IGZyb20gJ294J1xuICogaW1wb3J0IHsgQXV0aG9yaXphdGlvblRlbXBvIH0gZnJvbSAnb3gvdGVtcG8nXG4gKlxuICogY29uc3QgcHJpdmF0ZUtleSA9IFNlY3AyNTZrMS5yYW5kb21Qcml2YXRlS2V5KClcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uID0gQXV0aG9yaXphdGlvblRlbXBvLmZyb20oe1xuICogICBhZGRyZXNzOiAnMHgxMjM0NTY3ODkwYWJjZGVmMTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4JyxcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbm9uY2U6IDY5bixcbiAqIH0pXG4gKlxuICogY29uc3QgcGF5bG9hZCA9IEF1dGhvcml6YXRpb25UZW1wby5nZXRTaWduUGF5bG9hZChhdXRob3JpemF0aW9uKSAvLyBbIWNvZGUgZm9jdXNdXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oeyBwYXlsb2FkLCBwcml2YXRlS2V5IH0pXG4gKiBjb25zdCBhdXRob3JpemF0aW9uX3NpZ25lZCA9IEF1dGhvcml6YXRpb25UZW1wby5mcm9tKFxuICogICBhdXRob3JpemF0aW9uLFxuICogICB7IHNpZ25hdHVyZSB9XG4gKiApXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIFAyNTZcbiAqXG4gKiBFQ0RTQSBzaWduYXR1cmUgdXNpbmcgdGhlIFAtMjU2IChzZWNwMjU2cjEpIGN1cnZlLiBSZXF1aXJlcyBlbWJlZGRpbmcgdGhlXG4gKiBwdWJsaWMga2V5IGFuZCBhIGBwcmVoYXNoYCBmbGFnIGluZGljYXRpbmcgd2hldGhlciB0aGUgcGF5bG9hZCB3YXMgaGFzaGVkXG4gKiBiZWZvcmUgc2lnbmluZy5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgUDI1NiB9IGZyb20gJ294J1xuICogaW1wb3J0IHsgQXV0aG9yaXphdGlvblRlbXBvLCBTaWduYXR1cmVFbnZlbG9wZSB9IGZyb20gJ294L3RlbXBvJ1xuICpcbiAqIGNvbnN0IHsgcHJpdmF0ZUtleSwgcHVibGljS2V5IH0gPSBQMjU2LmNyZWF0ZUtleVBhaXIoKVxuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb24gPSBBdXRob3JpemF0aW9uVGVtcG8uZnJvbSh7XG4gKiAgIGFkZHJlc3M6ICcweDEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3ODkwYWJjZGVmMTIzNDU2NzgnLFxuICogICBjaGFpbklkOiAxLFxuICogICBub25jZTogNjluLFxuICogfSlcbiAqXG4gKiBjb25zdCBwYXlsb2FkID0gQXV0aG9yaXphdGlvblRlbXBvLmdldFNpZ25QYXlsb2FkKGF1dGhvcml6YXRpb24pIC8vIFshY29kZSBmb2N1c11cbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBQMjU2LnNpZ24oeyBwYXlsb2FkLCBwcml2YXRlS2V5IH0pXG4gKiBjb25zdCBzaWduYXR1cmVFbnZlbG9wZSA9IFNpZ25hdHVyZUVudmVsb3BlLmZyb20oe1xuICogICBwcmVoYXNoOiBmYWxzZSxcbiAqICAgcHVibGljS2V5LFxuICogICBzaWduYXR1cmUsXG4gKiB9KVxuICogY29uc3QgYXV0aG9yaXphdGlvbl9zaWduZWQgPSBBdXRob3JpemF0aW9uVGVtcG8uZnJvbShcbiAqICAgYXV0aG9yaXphdGlvbixcbiAqICAgeyBzaWduYXR1cmU6IHNpZ25hdHVyZUVudmVsb3BlIH1cbiAqIClcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgUDI1NiAoV2ViQ3J5cHRvKVxuICpcbiAqIFdoZW4gdXNpbmcgV2ViQ3J5cHRvIGtleXMsIGBwcmVoYXNoYCBtdXN0IGJlIGB0cnVlYCBzaW5jZSBXZWJDcnlwdG8gYWx3YXlzXG4gKiBoYXNoZXMgdGhlIHBheWxvYWQgaW50ZXJuYWxseSBiZWZvcmUgc2lnbmluZy5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBXZWJDcnlwdG9QMjU2IH0gZnJvbSAnb3gnXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uVGVtcG8sIFNpZ25hdHVyZUVudmVsb3BlIH0gZnJvbSAnb3gvdGVtcG8nXG4gKlxuICogY29uc3QgeyBwcml2YXRlS2V5LCBwdWJsaWNLZXkgfSA9IGF3YWl0IFdlYkNyeXB0b1AyNTYuY3JlYXRlS2V5UGFpcigpXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEF1dGhvcml6YXRpb25UZW1wby5mcm9tKHtcbiAqICAgYWRkcmVzczogJzB4MTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3OCcsXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG5vbmNlOiA2OW4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IHBheWxvYWQgPSBBdXRob3JpemF0aW9uVGVtcG8uZ2V0U2lnblBheWxvYWQoYXV0aG9yaXphdGlvbikgLy8gWyFjb2RlIGZvY3VzXVxuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IFdlYkNyeXB0b1AyNTYuc2lnbih7IHBheWxvYWQsIHByaXZhdGVLZXkgfSlcbiAqIGNvbnN0IHNpZ25hdHVyZUVudmVsb3BlID0gU2lnbmF0dXJlRW52ZWxvcGUuZnJvbSh7XG4gKiAgIHByZWhhc2g6IHRydWUsXG4gKiAgIHB1YmxpY0tleSxcbiAqICAgc2lnbmF0dXJlLFxuICogfSlcbiAqIGNvbnN0IGF1dGhvcml6YXRpb25fc2lnbmVkID0gQXV0aG9yaXphdGlvblRlbXBvLmZyb20oXG4gKiAgIGF1dGhvcml6YXRpb24sXG4gKiAgIHsgc2lnbmF0dXJlOiBzaWduYXR1cmVFbnZlbG9wZSB9XG4gKiApXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIFdlYkF1dGhuXG4gKlxuICogUGFzc2tleS1iYXNlZCBzaWduYXR1cmUgdXNpbmcgV2ViQXV0aG4uIEluY2x1ZGVzIGF1dGhlbnRpY2F0b3IgbWV0YWRhdGFcbiAqIChhdXRoZW50aWNhdG9yRGF0YSBhbmQgY2xpZW50RGF0YUpTT04pIGFsb25nIHdpdGggdGhlIFAtMjU2IHNpZ25hdHVyZSBhbmRcbiAqIHB1YmxpYyBrZXkuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgV2ViQXV0aG5QMjU2IH0gZnJvbSAnb3gnXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uVGVtcG8sIFNpZ25hdHVyZUVudmVsb3BlIH0gZnJvbSAnb3gvdGVtcG8nXG4gKlxuICogY29uc3QgY3JlZGVudGlhbCA9IGF3YWl0IFdlYkF1dGhuUDI1Ni5jcmVhdGVDcmVkZW50aWFsKHsgbmFtZTogJ0V4YW1wbGUnIH0pXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEF1dGhvcml6YXRpb25UZW1wby5mcm9tKHtcbiAqICAgYWRkcmVzczogJzB4MTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3OCcsXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG5vbmNlOiA2OW4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IGNoYWxsZW5nZSA9IEF1dGhvcml6YXRpb25UZW1wby5nZXRTaWduUGF5bG9hZChhdXRob3JpemF0aW9uKSAvLyBbIWNvZGUgZm9jdXNdXG4gKlxuICogY29uc3QgeyBtZXRhZGF0YSwgc2lnbmF0dXJlIH0gPSBhd2FpdCBXZWJBdXRoblAyNTYuc2lnbih7XG4gKiAgIGNoYWxsZW5nZSxcbiAqICAgY3JlZGVudGlhbElkOiBjcmVkZW50aWFsLmlkLFxuICogfSlcbiAqIGNvbnN0IHNpZ25hdHVyZUVudmVsb3BlID0gU2lnbmF0dXJlRW52ZWxvcGUuZnJvbSh7XG4gKiAgIHNpZ25hdHVyZSxcbiAqICAgcHVibGljS2V5OiBjcmVkZW50aWFsLnB1YmxpY0tleSxcbiAqICAgbWV0YWRhdGEsXG4gKiB9KVxuICogY29uc3QgYXV0aG9yaXphdGlvbl9zaWduZWQgPSBBdXRob3JpemF0aW9uVGVtcG8uZnJvbShcbiAqICAgYXV0aG9yaXphdGlvbixcbiAqICAgeyBzaWduYXR1cmU6IHNpZ25hdHVyZUVudmVsb3BlIH1cbiAqIClcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRob3JpemF0aW9uIC0gVGhlIHtAbGluayBveCNBdXRob3JpemF0aW9uVGVtcG8uQXV0aG9yaXphdGlvblRlbXBvfS5cbiAqIEByZXR1cm5zIFRoZSBzaWduIHBheWxvYWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTaWduUGF5bG9hZChhdXRob3JpemF0aW9uKSB7XG4gICAgcmV0dXJuIGhhc2goYXV0aG9yaXphdGlvbiwgeyBwcmVzaWduOiB0cnVlIH0pO1xufVxuLyoqXG4gKiBDb21wdXRlcyB0aGUgaGFzaCBmb3IgYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb25UZW1wby5BdXRob3JpemF0aW9uVGVtcG99IGluIFtFSVAtNzcwMiBmb3JtYXRdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNzcwMik6IGBrZWNjYWsyNTYoJzB4MDUnIHx8IHJscChbY2hhaW5faWQsIGFkZHJlc3MsIG5vbmNlXSkpYC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb25UZW1wbyB9IGZyb20gJ294L3RlbXBvJ1xuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb24gPSBBdXRob3JpemF0aW9uVGVtcG8uZnJvbSh7XG4gKiAgIGFkZHJlc3M6ICcweDEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3ODkwYWJjZGVmMTIzNDU2NzgnLFxuICogICBjaGFpbklkOiAxLFxuICogICBub25jZTogNjluLFxuICogfSlcbiAqXG4gKiBjb25zdCBoYXNoID0gQXV0aG9yaXphdGlvblRlbXBvLmhhc2goYXV0aG9yaXphdGlvbikgLy8gWyFjb2RlIGZvY3VzXVxuICogYGBgXG4gKlxuICogQHBhcmFtIGF1dGhvcml6YXRpb24gLSBUaGUge0BsaW5rIG94I0F1dGhvcml6YXRpb25UZW1wby5BdXRob3JpemF0aW9uVGVtcG99LlxuICogQHJldHVybnMgVGhlIGhhc2guXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNoKGF1dGhvcml6YXRpb24sIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgcHJlc2lnbiB9ID0gb3B0aW9ucztcbiAgICByZXR1cm4gSGFzaC5rZWNjYWsyNTYoSGV4LmNvbmNhdCgnMHgwNScsIFJscC5mcm9tSGV4KHRvVHVwbGUocHJlc2lnblxuICAgICAgICA/IHtcbiAgICAgICAgICAgIGFkZHJlc3M6IGF1dGhvcml6YXRpb24uYWRkcmVzcyxcbiAgICAgICAgICAgIGNoYWluSWQ6IGF1dGhvcml6YXRpb24uY2hhaW5JZCxcbiAgICAgICAgICAgIG5vbmNlOiBhdXRob3JpemF0aW9uLm5vbmNlLFxuICAgICAgICB9XG4gICAgICAgIDogYXV0aG9yaXphdGlvbikpKSk7XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uVGVtcG8uQXV0aG9yaXphdGlvblRlbXBvfSB0byBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvblRlbXBvLlJwY30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uVGVtcG8gfSBmcm9tICdveC90ZW1wbydcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uID0gQXV0aG9yaXphdGlvblRlbXBvLnRvUnBjKHtcbiAqICAgYWRkcmVzczogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG5vbmNlOiAxbixcbiAqICAgc2lnbmF0dXJlOiB7XG4gKiAgICAgdHlwZTogJ3NlY3AyNTZrMScsXG4gKiAgICAgc2lnbmF0dXJlOiB7XG4gKiAgICAgICByOiA0NDk0NDYyNzgxMzAwNzc3Mjg5NzM5MTUzMTIzMDA4MTY5NTEwMjcwMzI4OTEyMzMzMjE4NzY5NjExNTE4MTEwNDczOTIzOTE5NzUxN24sXG4gKiAgICAgICBzOiAzNjUyODUwMzUwNTE5MjQzODMwNzM1NTE2NDQ0MTEwNDAwMTMxMDU2NjUwNTM1MTk4MDM2OTA4NTIwODE3ODcxMjY3ODc5OTE4MTEyMG4sXG4gKiAgICAgICB5UGFyaXR5OiAwLFxuICogICAgIH0sXG4gKiAgIH0sXG4gKiB9KVxuICogYGBgXG4gKlxuICogQHBhcmFtIGF1dGhvcml6YXRpb24gLSBBbiBBQSBBdXRob3JpemF0aW9uLlxuICogQHJldHVybnMgQW4gUlBDLWZvcm1hdHRlZCBBQSBBdXRob3JpemF0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9ScGMoYXV0aG9yaXphdGlvbikge1xuICAgIGNvbnN0IHsgYWRkcmVzcywgY2hhaW5JZCwgbm9uY2UsIHNpZ25hdHVyZSB9ID0gYXV0aG9yaXphdGlvbjtcbiAgICByZXR1cm4ge1xuICAgICAgICBhZGRyZXNzLFxuICAgICAgICBjaGFpbklkOiBIZXguZnJvbU51bWJlcihjaGFpbklkKSxcbiAgICAgICAgbm9uY2U6IEhleC5mcm9tTnVtYmVyKG5vbmNlKSxcbiAgICAgICAgc2lnbmF0dXJlOiBTaWduYXR1cmVFbnZlbG9wZS50b1JwYyhzaWduYXR1cmUpLFxuICAgIH07XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uVGVtcG8uTGlzdH0gdG8gYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb25UZW1wby5MaXN0UnBjfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb25UZW1wbyB9IGZyb20gJ294L3RlbXBvJ1xuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb24gPSBBdXRob3JpemF0aW9uVGVtcG8udG9ScGNMaXN0KFt7XG4gKiAgIGFkZHJlc3M6ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICBjaGFpbklkOiAxLFxuICogICBub25jZTogMW4sXG4gKiAgIHNpZ25hdHVyZToge1xuICogICAgIHR5cGU6ICdzZWNwMjU2azEnLFxuICogICAgIHNpZ25hdHVyZToge1xuICogICAgICAgcjogNDQ5NDQ2Mjc4MTMwMDc3NzI4OTczOTE1MzEyMzAwODE2OTUxMDI3MDMyODkxMjMzMzIxODc2OTYxMTUxODExMDQ3MzkyMzkxOTc1MTduLFxuICogICAgICAgczogMzY1Mjg1MDM1MDUxOTI0MzgzMDczNTUxNjQ0NDExMDQwMDEzMTA1NjY1MDUzNTE5ODAzNjkwODUyMDgxNzg3MTI2Nzg3OTkxODExMjBuLFxuICogICAgICAgeVBhcml0eTogMCxcbiAqICAgICB9LFxuICogICB9LFxuICogfV0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYXV0aG9yaXphdGlvbkxpc3QgLSBBbiBBQSBBdXRob3JpemF0aW9uIExpc3QuXG4gKiBAcmV0dXJucyBBbiBSUEMtZm9ybWF0dGVkIEFBIEF1dGhvcml6YXRpb24gTGlzdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvUnBjTGlzdChhdXRob3JpemF0aW9uTGlzdCkge1xuICAgIHJldHVybiBhdXRob3JpemF0aW9uTGlzdC5tYXAoKHgpID0+IHRvUnBjKHgpKTtcbn1cbi8qKlxuICogQ29udmVydHMgYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb25UZW1wby5BdXRob3JpemF0aW9uVGVtcG99IHRvIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uVGVtcG8uVHVwbGV9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQXV0aG9yaXphdGlvblRlbXBvIH0gZnJvbSAnb3gvdGVtcG8nXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEF1dGhvcml6YXRpb25UZW1wby5mcm9tKHtcbiAqICAgYWRkcmVzczogJzB4MTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3OCcsXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG5vbmNlOiA2OW4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IHR1cGxlID0gQXV0aG9yaXphdGlvblRlbXBvLnRvVHVwbGUoYXV0aG9yaXphdGlvbikgLy8gWyFjb2RlIGZvY3VzXVxuICogLy8gQGxvZzogW1xuICogLy8gQGxvZzogICBhZGRyZXNzOiAnMHgxMjM0NTY3ODkwYWJjZGVmMTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4JyxcbiAqIC8vIEBsb2c6ICAgY2hhaW5JZDogMSxcbiAqIC8vIEBsb2c6ICAgbm9uY2U6IDY5bixcbiAqIC8vIEBsb2c6IF1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRob3JpemF0aW9uIC0gVGhlIHtAbGluayBveCNBdXRob3JpemF0aW9uVGVtcG8uQXV0aG9yaXphdGlvblRlbXBvfS5cbiAqIEByZXR1cm5zIEFuIFtFSVAtNzcwMl0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC03NzAyKSBBQSBBdXRob3JpemF0aW9uIHR1cGxlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9UdXBsZShhdXRob3JpemF0aW9uKSB7XG4gICAgY29uc3QgeyBhZGRyZXNzLCBjaGFpbklkLCBub25jZSB9ID0gYXV0aG9yaXphdGlvbjtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBhdXRob3JpemF0aW9uLnNpZ25hdHVyZVxuICAgICAgICA/IFNpZ25hdHVyZUVudmVsb3BlLnNlcmlhbGl6ZShhdXRob3JpemF0aW9uLnNpZ25hdHVyZSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgY2hhaW5JZCA/IEhleC5mcm9tTnVtYmVyKGNoYWluSWQpIDogJzB4JyxcbiAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgbm9uY2UgPyBIZXguZnJvbU51bWJlcihub25jZSkgOiAnMHgnLFxuICAgICAgICAuLi4oc2lnbmF0dXJlID8gW3NpZ25hdHVyZV0gOiBbXSksXG4gICAgXTtcbn1cbi8qKlxuICogQ29udmVydHMgYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb25UZW1wby5MaXN0fSB0byBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvblRlbXBvLlR1cGxlTGlzdH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uVGVtcG8gfSBmcm9tICdveC90ZW1wbydcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uXzEgPSBBdXRob3JpemF0aW9uVGVtcG8uZnJvbSh7XG4gKiAgIGFkZHJlc3M6ICcweDEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3ODkwYWJjZGVmMTIzNDU2NzgnLFxuICogICBjaGFpbklkOiAxLFxuICogICBub25jZTogNjluLFxuICogfSlcbiAqIGNvbnN0IGF1dGhvcml6YXRpb25fMiA9IEF1dGhvcml6YXRpb25UZW1wby5mcm9tKHtcbiAqICAgYWRkcmVzczogJzB4MTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3OCcsXG4gKiAgIGNoYWluSWQ6IDMsXG4gKiAgIG5vbmNlOiAyMG4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IHR1cGxlID0gQXV0aG9yaXphdGlvblRlbXBvLnRvVHVwbGVMaXN0KFthdXRob3JpemF0aW9uXzEsIGF1dGhvcml6YXRpb25fMl0pIC8vIFshY29kZSBmb2N1c11cbiAqIC8vIEBsb2c6IFtcbiAqIC8vIEBsb2c6ICAgW1xuICogLy8gQGxvZzogICAgIGFkZHJlc3M6ICcweDEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3ODkwYWJjZGVmMTIzNDU2NzgnLFxuICogLy8gQGxvZzogICAgIGNoYWluSWQ6IDEsXG4gKiAvLyBAbG9nOiAgICAgbm9uY2U6IDY5bixcbiAqIC8vIEBsb2c6ICAgXSxcbiAqIC8vIEBsb2c6ICAgW1xuICogLy8gQGxvZzogICAgIGFkZHJlc3M6ICcweDEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3ODkwYWJjZGVmMTIzNDU2NzgnLFxuICogLy8gQGxvZzogICAgIGNoYWluSWQ6IDMsXG4gKiAvLyBAbG9nOiAgICAgbm9uY2U6IDIwbixcbiAqIC8vIEBsb2c6ICAgXSxcbiAqIC8vIEBsb2c6IF1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBsaXN0IC0gQW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb25UZW1wby5MaXN0fS5cbiAqIEByZXR1cm5zIEFuIFtFSVAtNzcwMl0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC03NzAyKSBBQSBBdXRob3JpemF0aW9uIHR1cGxlIGxpc3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1R1cGxlTGlzdChsaXN0KSB7XG4gICAgaWYgKCFsaXN0IHx8IGxpc3QubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gW107XG4gICAgY29uc3QgdHVwbGVMaXN0ID0gW107XG4gICAgZm9yIChjb25zdCBhdXRob3JpemF0aW9uIG9mIGxpc3QpXG4gICAgICAgIHR1cGxlTGlzdC5wdXNoKHRvVHVwbGUoYXV0aG9yaXphdGlvbikpO1xuICAgIHJldHVybiB0dXBsZUxpc3Q7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BdXRob3JpemF0aW9uVGVtcG8uanMubWFwIl0sIm5hbWVzIjpbIkhhc2giLCJIZXgiLCJSbHAiLCJTaWduYXR1cmVFbnZlbG9wZSIsImZyb20iLCJhdXRob3JpemF0aW9uIiwib3B0aW9ucyIsImNoYWluSWQiLCJmcm9tUnBjIiwic2lnbmF0dXJlIiwiYWRkcmVzcyIsIm5vbmNlIiwiTnVtYmVyIiwiQmlnSW50IiwiZnJvbVJwY0xpc3QiLCJhdXRob3JpemF0aW9uTGlzdCIsIm1hcCIsIngiLCJmcm9tVHVwbGUiLCJ0dXBsZSIsInNpZ25hdHVyZVNlcmlhbGl6ZWQiLCJhcmdzIiwiZGVzZXJpYWxpemUiLCJmcm9tVHVwbGVMaXN0IiwidHVwbGVMaXN0IiwibGlzdCIsInB1c2giLCJnZXRTaWduUGF5bG9hZCIsImhhc2giLCJwcmVzaWduIiwia2VjY2FrMjU2IiwiY29uY2F0IiwiZnJvbUhleCIsInRvVHVwbGUiLCJ0b1JwYyIsImZyb21OdW1iZXIiLCJ0b1JwY0xpc3QiLCJzZXJpYWxpemUiLCJ1bmRlZmluZWQiLCJ0b1R1cGxlTGlzdCIsImxlbmd0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/tempo/AuthorizationTempo.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/tempo/KeyAuthorization.js":
/*!********************************************************!*\
  !*** ./node_modules/ox/_esm/tempo/KeyAuthorization.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromRpc: () => (/* binding */ fromRpc),\n/* harmony export */   fromTuple: () => (/* binding */ fromTuple),\n/* harmony export */   getSignPayload: () => (/* binding */ getSignPayload),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   toRpc: () => (/* binding */ toRpc),\n/* harmony export */   toTuple: () => (/* binding */ toTuple)\n/* harmony export */ });\n/* harmony import */ var _core_Hash_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/Hash.js */ \"(ssr)/./node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _core_Rlp_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/Rlp.js */ \"(ssr)/./node_modules/ox/_esm/core/Rlp.js\");\n/* harmony import */ var _SignatureEnvelope_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SignatureEnvelope.js */ \"(ssr)/./node_modules/ox/_esm/tempo/SignatureEnvelope.js\");\n\n\n\n\n/**\n * Converts a Key Authorization object into a typed {@link ox#KeyAuthorization.KeyAuthorization}.\n *\n * Use this to create an unsigned key authorization, then sign it with the root key using\n * {@link ox#KeyAuthorization.(getSignPayload:function)} and attach the signature. The signed authorization\n * can be included in a {@link ox#TxEnvelopeTempo.TxEnvelopeTempo} via the\n * `keyAuthorization` field to provision the access key on-chain.\n *\n * [Access Keys Specification](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction#access-keys)\n *\n * @example\n * ### Secp256k1 Key\n *\n * Standard Ethereum ECDSA key using the secp256k1 curve.\n *\n * ```ts twoslash\n * import { Address, Secp256k1, Value } from 'ox'\n * import { KeyAuthorization } from 'ox/tempo'\n *\n * const privateKey = Secp256k1.randomPrivateKey()\n * const address = Address.fromPublicKey(Secp256k1.getPublicKey({ privateKey }))\n *\n * const authorization = KeyAuthorization.from({\n *   address,\n *   expiry: 1234567890,\n *   type: 'secp256k1',\n *   limits: [{\n *     token: '0x20c0000000000000000000000000000000000001',\n *     limit: Value.from('10', 6),\n *   }],\n * })\n * ```\n *\n * @example\n * ### WebCryptoP256 Key\n *\n * ```ts twoslash\n * import { Address, WebCryptoP256, Value } from 'ox'\n * import { KeyAuthorization } from 'ox/tempo'\n *\n * const keyPair = await WebCryptoP256.createKeyPair()\n * const address = Address.fromPublicKey(keyPair.publicKey)\n *\n * const authorization = KeyAuthorization.from({\n *   address,\n *   expiry: 1234567890,\n *   type: 'p256',\n *   limits: [{\n *     token: '0x20c0000000000000000000000000000000000001',\n *     limit: Value.from('10', 6),\n *   }],\n * })\n * ```\n *\n * @example\n * ### Attaching Signatures (Secp256k1)\n *\n * Attach a signature to a Key Authorization using a Secp256k1 private key to\n * authorize another Secp256k1 key on the account.\n *\n * ```ts twoslash\n * import { Address, Secp256k1, Value } from 'ox'\n * import { KeyAuthorization } from 'ox/tempo'\n *\n * const privateKey = '0x...'\n * const address = Address.fromPublicKey(Secp256k1.getPublicKey({ privateKey }))\n *\n * const authorization = KeyAuthorization.from({\n *   address,\n *   expiry: 1234567890,\n *   type: 'secp256k1',\n *   limits: [{\n *     token: '0x20c0000000000000000000000000000000000001',\n *     limit: Value.from('10', 6),\n *   }],\n * })\n *\n * const rootPrivateKey = '0x...'\n * const signature = Secp256k1.sign({\n *   payload: KeyAuthorization.getSignPayload(authorization),\n *   privateKey: rootPrivateKey,\n * })\n *\n * const authorization_signed = KeyAuthorization.from(authorization, { signature })\n * ```\n *\n * @example\n * ### Attaching Signatures (WebAuthn)\n *\n * Attach a signature to a Key Authorization using a WebAuthn credential to\n * authorize a new WebCryptoP256 key on the account.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Address, Value, WebCryptoP256, WebAuthnP256 } from 'ox'\n * import { KeyAuthorization, SignatureEnvelope } from 'ox/tempo'\n *\n * const keyPair = await WebCryptoP256.createKeyPair()\n * const address = Address.fromPublicKey(keyPair.publicKey)\n *\n * const authorization = KeyAuthorization.from({\n *   address,\n *   expiry: 1234567890,\n *   type: 'p256',\n *   limits: [{\n *     token: '0x20c0000000000000000000000000000000000001',\n *     limit: Value.from('10', 6),\n *   }],\n * })\n *\n * const credential = await WebAuthnP256.createCredential({ name: 'Example' })\n *\n * const { metadata, signature } = await WebAuthnP256.sign({\n *   challenge: KeyAuthorization.getSignPayload(authorization),\n *   credentialId: credential.id,\n * })\n *\n * const signatureEnvelope = SignatureEnvelope.from({ // [!code focus]\n *   signature, // [!code focus]\n *   publicKey: credential.publicKey, // [!code focus]\n *   metadata, // [!code focus]\n * })\n * const authorization_signed = KeyAuthorization.from(\n *   authorization,\n *   { signature: signatureEnvelope }, // [!code focus]\n * )\n * ```\n *\n * @param authorization - A Key Authorization tuple in object format.\n * @param options - Key Authorization options.\n * @returns The {@link ox#KeyAuthorization.KeyAuthorization}.\n */ function from(authorization, options = {}) {\n    if (typeof authorization.expiry === \"string\") return fromRpc(authorization);\n    if (options.signature) return {\n        ...authorization,\n        signature: _SignatureEnvelope_js__WEBPACK_IMPORTED_MODULE_0__.from(options.signature)\n    };\n    return authorization;\n}\n/**\n * Converts an {@link ox#AuthorizationTempo.Rpc} to an {@link ox#AuthorizationTempo.AuthorizationTempo}.\n *\n * @example\n * ```ts twoslash\n * import { KeyAuthorization } from 'ox/tempo'\n *\n * const keyAuthorization = KeyAuthorization.fromRpc({\n *   expiry: '0x174876e800',\n *   keyId: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   keyType: 'secp256k1',\n *   limits: [{ token: '0x20c0000000000000000000000000000000000001', limit: '0xf4240' }],\n *   signature: {\n *     type: 'secp256k1',\n *     r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *     s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *     yParity: '0x0'\n *   },\n * })\n * ```\n *\n * @param authorization - The RPC-formatted Key Authorization.\n * @returns A signed {@link ox#AuthorizationTempo.AuthorizationTempo}.\n */ function fromRpc(authorization) {\n    const { chainId = \"0x0\", keyId, expiry = 0, limits, keyType } = authorization;\n    const signature = _SignatureEnvelope_js__WEBPACK_IMPORTED_MODULE_0__.fromRpc(authorization.signature);\n    return {\n        address: keyId,\n        chainId: chainId === \"0x\" ? 0n : _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt(chainId),\n        expiry: Number(expiry),\n        limits: limits?.map((limit)=>({\n                token: limit.token,\n                limit: BigInt(limit.limit)\n            })),\n        signature,\n        type: keyType\n    };\n}\n/**\n * Converts an {@link ox#KeyAuthorization.Tuple} to an {@link ox#KeyAuthorization.KeyAuthorization}.\n *\n * @example\n * ```ts twoslash\n * import { KeyAuthorization } from 'ox/tempo'\n *\n * const authorization = KeyAuthorization.fromTuple([\n *   [\n *     '0x',\n *     '0x00',\n *     '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *     '0x174876e800',\n *     [['0x20c0000000000000000000000000000000000001', '0xf4240']],\n *   ],\n *   '0x01a068a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b907e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064',\n * ])\n * ```\n *\n * @example\n * Unsigned Key Authorization tuple (no signature):\n *\n * ```ts twoslash\n * import { KeyAuthorization } from 'ox/tempo'\n *\n * const authorization = KeyAuthorization.fromTuple([\n *   [\n *     '0x',\n *     '0x00',\n *     '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *     '0x174876e800',\n *     [['0x20c0000000000000000000000000000000000001', '0xf4240']],\n *   ],\n * ])\n * ```\n *\n * @param tuple - The Key Authorization tuple.\n * @returns The {@link ox#KeyAuthorization.KeyAuthorization}.\n */ function fromTuple(tuple) {\n    const [authorization, signatureSerialized] = tuple;\n    const [chainId, keyType_hex, keyId, expiry, limits] = authorization;\n    const keyType = (()=>{\n        switch(keyType_hex){\n            case \"0x\":\n            case \"0x00\":\n                return \"secp256k1\";\n            case \"0x01\":\n                return \"p256\";\n            case \"0x02\":\n                return \"webAuthn\";\n            default:\n                throw new Error(`Invalid key type: ${keyType_hex}`);\n        }\n    })();\n    const args = {\n        address: keyId,\n        expiry: typeof expiry !== \"undefined\" ? _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.toNumber(expiry) : undefined,\n        type: keyType,\n        ...chainId !== \"0x\" ? {\n            chainId: _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt(chainId)\n        } : {},\n        ...typeof expiry !== \"undefined\" ? {\n            expiry: _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.toNumber(expiry)\n        } : {},\n        ...typeof limits !== \"undefined\" ? {\n            limits: limits.map(([token, limit])=>({\n                    token,\n                    limit: BigInt(limit)\n                }))\n        } : {}\n    };\n    if (signatureSerialized) args.signature = _SignatureEnvelope_js__WEBPACK_IMPORTED_MODULE_0__.deserialize(signatureSerialized);\n    return from(args);\n}\n/**\n * Computes the sign payload for an {@link ox#KeyAuthorization.KeyAuthorization}.\n *\n * The root key must sign this payload to authorize the access key. The resulting signature\n * is attached to the key authorization via {@link ox#KeyAuthorization.(from:function)} with the\n * `signature` option.\n *\n * [Access Keys Specification](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction#access-keys)\n *\n * @example\n * ```ts twoslash\n * import { Address, Secp256k1, Value } from 'ox'\n * import { KeyAuthorization } from 'ox/tempo'\n *\n * const privateKey = '0x...'\n * const address = Address.fromPublicKey(Secp256k1.getPublicKey({ privateKey }))\n *\n * const authorization = KeyAuthorization.from({\n *   address,\n *   expiry: 1234567890,\n *   type: 'secp256k1',\n *   limits: [{\n *     token: '0x20c0000000000000000000000000000000000001',\n *     limit: Value.from('10', 6),\n *   }],\n * })\n *\n * const payload = KeyAuthorization.getSignPayload(authorization) // [!code focus]\n * ```\n *\n * @param authorization - The {@link ox#KeyAuthorization.KeyAuthorization}.\n * @returns The sign payload.\n */ function getSignPayload(authorization) {\n    return hash(authorization);\n}\n/**\n * Computes the hash for an {@link ox#KeyAuthorization.KeyAuthorization}.\n *\n * @example\n * ```ts twoslash\n * import { KeyAuthorization } from 'ox/tempo'\n * import { Value } from 'ox'\n *\n * const authorization = KeyAuthorization.from({\n *   expiry: 1234567890,\n *   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   type: 'secp256k1',\n *   limits: [{\n *     token: '0x20c0000000000000000000000000000000000001',\n *     limit: Value.from('10', 6)\n *   }],\n * })\n *\n * const hash = KeyAuthorization.hash(authorization) // [!code focus]\n * ```\n *\n * @param authorization - The {@link ox#KeyAuthorization.KeyAuthorization}.\n * @returns The hash.\n */ function hash(authorization) {\n    const [authorizationTuple] = toTuple(authorization);\n    const serialized = _core_Rlp_js__WEBPACK_IMPORTED_MODULE_2__.fromHex(authorizationTuple);\n    return _core_Hash_js__WEBPACK_IMPORTED_MODULE_3__.keccak256(serialized);\n}\n/**\n * Converts an {@link ox#KeyAuthorization.KeyAuthorization} to an {@link ox#KeyAuthorization.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { KeyAuthorization } from 'ox/tempo'\n * import { Value } from 'ox'\n *\n * const authorization = KeyAuthorization.toRpc({\n *   expiry: 1234567890,\n *   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   type: 'secp256k1',\n *   limits: [{\n *     token: '0x20c0000000000000000000000000000000000001',\n *     limit: Value.from('10', 6)\n *   }],\n *   signature: {\n *     type: 'secp256k1',\n *     signature: {\n *       r: 44944627813007772897391531230081695102703289123332187696115181104739239197517n,\n *       s: 36528503505192438307355164441104001310566505351980369085208178712678799181120n,\n *       yParity: 0,\n *     },\n *   },\n * })\n * ```\n *\n * @param authorization - A Key Authorization.\n * @returns An RPC-formatted Key Authorization.\n */ function toRpc(authorization) {\n    const { address, chainId = 0n, expiry, limits, type, signature } = authorization;\n    return {\n        chainId: chainId === 0n ? \"0x\" : _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(chainId),\n        expiry: typeof expiry === \"number\" ? _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(expiry) : null,\n        limits: limits?.map(({ token, limit })=>({\n                token,\n                limit: _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(limit)\n            })),\n        keyId: address,\n        signature: _SignatureEnvelope_js__WEBPACK_IMPORTED_MODULE_0__.toRpc(signature),\n        keyType: type\n    };\n}\n/**\n * Converts an {@link ox#KeyAuthorization.KeyAuthorization} to an {@link ox#KeyAuthorization.Tuple}.\n *\n * @example\n * ```ts twoslash\n * import { KeyAuthorization } from 'ox/tempo'\n * import { Value } from 'ox'\n *\n * const authorization = KeyAuthorization.from({\n *   expiry: 1234567890,\n *   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   type: 'secp256k1',\n *   limits: [{\n *     token: '0x20c0000000000000000000000000000000000001',\n *     limit: Value.from('10', 6)\n *   }],\n * })\n *\n * const tuple = KeyAuthorization.toTuple(authorization) // [!code focus]\n * // @log: [\n * // @log:   '0x174876e800',\n * // @log:   [['0x20c0000000000000000000000000000000000001', '0xf4240']],\n * // @log:   '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:   'secp256k1',\n * // @log: ]\n * ```\n *\n * @param authorization - The {@link ox#KeyAuthorization.KeyAuthorization}.\n * @returns A Tempo Key Authorization tuple.\n */ function toTuple(authorization) {\n    const { address, chainId = 0n, expiry, limits } = authorization;\n    const signature = authorization.signature ? _SignatureEnvelope_js__WEBPACK_IMPORTED_MODULE_0__.serialize(authorization.signature) : undefined;\n    const type = (()=>{\n        switch(authorization.type){\n            case \"secp256k1\":\n                return \"0x\";\n            case \"p256\":\n                return \"0x01\";\n            case \"webAuthn\":\n                return \"0x02\";\n            default:\n                throw new Error(`Invalid key type: ${authorization.type}`);\n        }\n    })();\n    const authorizationTuple = [\n        chainId === 0n ? \"0x\" : _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(chainId),\n        type,\n        address,\n        typeof expiry === \"number\" ? _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(expiry) : undefined,\n        limits?.map((limit)=>[\n                limit.token,\n                _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(limit.limit)\n            ]) ?? undefined\n    ].filter(Boolean);\n    return [\n        authorizationTuple,\n        ...signature ? [\n            signature\n        ] : []\n    ];\n} //# sourceMappingURL=KeyAuthorization.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS90ZW1wby9LZXlBdXRob3JpemF0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQXdDO0FBQ0Y7QUFDQTtBQUNzQjtBQUM1RDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FtSUMsR0FDTSxTQUFTSSxLQUFLQyxhQUFhLEVBQUVDLFVBQVUsQ0FBQyxDQUFDO0lBQzVDLElBQUksT0FBT0QsY0FBY0UsTUFBTSxLQUFLLFVBQ2hDLE9BQU9DLFFBQVFIO0lBQ25CLElBQUlDLFFBQVFHLFNBQVMsRUFDakIsT0FBTztRQUNILEdBQUdKLGFBQWE7UUFDaEJJLFdBQVdOLHVEQUFzQixDQUFDRyxRQUFRRyxTQUFTO0lBQ3ZEO0lBQ0osT0FBT0o7QUFDWDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXVCQyxHQUNNLFNBQVNHLFFBQVFILGFBQWE7SUFDakMsTUFBTSxFQUFFSyxVQUFVLEtBQUssRUFBRUMsS0FBSyxFQUFFSixTQUFTLENBQUMsRUFBRUssTUFBTSxFQUFFQyxPQUFPLEVBQUUsR0FBR1I7SUFDaEUsTUFBTUksWUFBWU4sMERBQXlCLENBQUNFLGNBQWNJLFNBQVM7SUFDbkUsT0FBTztRQUNISyxTQUFTSDtRQUNURCxTQUFTQSxZQUFZLE9BQU8sRUFBRSxHQUFHVCxrREFBWSxDQUFDUztRQUM5Q0gsUUFBUVMsT0FBT1Q7UUFDZkssUUFBUUEsUUFBUUssSUFBSSxDQUFDQyxRQUFXO2dCQUM1QkMsT0FBT0QsTUFBTUMsS0FBSztnQkFDbEJELE9BQU9FLE9BQU9GLE1BQU1BLEtBQUs7WUFDN0I7UUFDQVQ7UUFDQVksTUFBTVI7SUFDVjtBQUNKO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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Q0EsTUFBTVkscUJBQXFCO1FBQ3ZCdkIsWUFBWSxFQUFFLEdBQUcsT0FBT1Qsb0RBQWMsQ0FBQ1M7UUFDdkNXO1FBQ0FQO1FBQ0EsT0FBT1AsV0FBVyxXQUFXTixvREFBYyxDQUFDTSxVQUFVc0I7UUFDdERqQixRQUFRSyxJQUFJLENBQUNDLFFBQVU7Z0JBQUNBLE1BQU1DLEtBQUs7Z0JBQUVsQixvREFBYyxDQUFDaUIsTUFBTUEsS0FBSzthQUFFLEtBQzdEVztLQUNQLENBQUNZLE1BQU0sQ0FBQ0M7SUFDVCxPQUFPO1FBQUNUO1dBQXdCeEIsWUFBWTtZQUFDQTtTQUFVLEdBQUcsRUFBRTtLQUFFO0FBQ2xFLEVBQ0EsNENBQTRDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xhdy13b3Jrcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9fZXNtL3RlbXBvL0tleUF1dGhvcml6YXRpb24uanM/MTM1YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBIYXNoIGZyb20gJy4uL2NvcmUvSGFzaC5qcyc7XG5pbXBvcnQgKiBhcyBIZXggZnJvbSAnLi4vY29yZS9IZXguanMnO1xuaW1wb3J0ICogYXMgUmxwIGZyb20gJy4uL2NvcmUvUmxwLmpzJztcbmltcG9ydCAqIGFzIFNpZ25hdHVyZUVudmVsb3BlIGZyb20gJy4vU2lnbmF0dXJlRW52ZWxvcGUuanMnO1xuLyoqXG4gKiBDb252ZXJ0cyBhIEtleSBBdXRob3JpemF0aW9uIG9iamVjdCBpbnRvIGEgdHlwZWQge0BsaW5rIG94I0tleUF1dGhvcml6YXRpb24uS2V5QXV0aG9yaXphdGlvbn0uXG4gKlxuICogVXNlIHRoaXMgdG8gY3JlYXRlIGFuIHVuc2lnbmVkIGtleSBhdXRob3JpemF0aW9uLCB0aGVuIHNpZ24gaXQgd2l0aCB0aGUgcm9vdCBrZXkgdXNpbmdcbiAqIHtAbGluayBveCNLZXlBdXRob3JpemF0aW9uLihnZXRTaWduUGF5bG9hZDpmdW5jdGlvbil9IGFuZCBhdHRhY2ggdGhlIHNpZ25hdHVyZS4gVGhlIHNpZ25lZCBhdXRob3JpemF0aW9uXG4gKiBjYW4gYmUgaW5jbHVkZWQgaW4gYSB7QGxpbmsgb3gjVHhFbnZlbG9wZVRlbXBvLlR4RW52ZWxvcGVUZW1wb30gdmlhIHRoZVxuICogYGtleUF1dGhvcml6YXRpb25gIGZpZWxkIHRvIHByb3Zpc2lvbiB0aGUgYWNjZXNzIGtleSBvbi1jaGFpbi5cbiAqXG4gKiBbQWNjZXNzIEtleXMgU3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly9kb2NzLnRlbXBvLnh5ei9wcm90b2NvbC90cmFuc2FjdGlvbnMvc3BlYy10ZW1wby10cmFuc2FjdGlvbiNhY2Nlc3Mta2V5cylcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIFNlY3AyNTZrMSBLZXlcbiAqXG4gKiBTdGFuZGFyZCBFdGhlcmV1bSBFQ0RTQSBrZXkgdXNpbmcgdGhlIHNlY3AyNTZrMSBjdXJ2ZS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWRkcmVzcywgU2VjcDI1NmsxLCBWYWx1ZSB9IGZyb20gJ294J1xuICogaW1wb3J0IHsgS2V5QXV0aG9yaXphdGlvbiB9IGZyb20gJ294L3RlbXBvJ1xuICpcbiAqIGNvbnN0IHByaXZhdGVLZXkgPSBTZWNwMjU2azEucmFuZG9tUHJpdmF0ZUtleSgpXG4gKiBjb25zdCBhZGRyZXNzID0gQWRkcmVzcy5mcm9tUHVibGljS2V5KFNlY3AyNTZrMS5nZXRQdWJsaWNLZXkoeyBwcml2YXRlS2V5IH0pKVxuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb24gPSBLZXlBdXRob3JpemF0aW9uLmZyb20oe1xuICogICBhZGRyZXNzLFxuICogICBleHBpcnk6IDEyMzQ1Njc4OTAsXG4gKiAgIHR5cGU6ICdzZWNwMjU2azEnLFxuICogICBsaW1pdHM6IFt7XG4gKiAgICAgdG9rZW46ICcweDIwYzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnLFxuICogICAgIGxpbWl0OiBWYWx1ZS5mcm9tKCcxMCcsIDYpLFxuICogICB9XSxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIFdlYkNyeXB0b1AyNTYgS2V5XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFkZHJlc3MsIFdlYkNyeXB0b1AyNTYsIFZhbHVlIH0gZnJvbSAnb3gnXG4gKiBpbXBvcnQgeyBLZXlBdXRob3JpemF0aW9uIH0gZnJvbSAnb3gvdGVtcG8nXG4gKlxuICogY29uc3Qga2V5UGFpciA9IGF3YWl0IFdlYkNyeXB0b1AyNTYuY3JlYXRlS2V5UGFpcigpXG4gKiBjb25zdCBhZGRyZXNzID0gQWRkcmVzcy5mcm9tUHVibGljS2V5KGtleVBhaXIucHVibGljS2V5KVxuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb24gPSBLZXlBdXRob3JpemF0aW9uLmZyb20oe1xuICogICBhZGRyZXNzLFxuICogICBleHBpcnk6IDEyMzQ1Njc4OTAsXG4gKiAgIHR5cGU6ICdwMjU2JyxcbiAqICAgbGltaXRzOiBbe1xuICogICAgIHRva2VuOiAnMHgyMGMwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJyxcbiAqICAgICBsaW1pdDogVmFsdWUuZnJvbSgnMTAnLCA2KSxcbiAqICAgfV0sXG4gKiB9KVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBBdHRhY2hpbmcgU2lnbmF0dXJlcyAoU2VjcDI1NmsxKVxuICpcbiAqIEF0dGFjaCBhIHNpZ25hdHVyZSB0byBhIEtleSBBdXRob3JpemF0aW9uIHVzaW5nIGEgU2VjcDI1NmsxIHByaXZhdGUga2V5IHRvXG4gKiBhdXRob3JpemUgYW5vdGhlciBTZWNwMjU2azEga2V5IG9uIHRoZSBhY2NvdW50LlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBZGRyZXNzLCBTZWNwMjU2azEsIFZhbHVlIH0gZnJvbSAnb3gnXG4gKiBpbXBvcnQgeyBLZXlBdXRob3JpemF0aW9uIH0gZnJvbSAnb3gvdGVtcG8nXG4gKlxuICogY29uc3QgcHJpdmF0ZUtleSA9ICcweC4uLidcbiAqIGNvbnN0IGFkZHJlc3MgPSBBZGRyZXNzLmZyb21QdWJsaWNLZXkoU2VjcDI1NmsxLmdldFB1YmxpY0tleSh7IHByaXZhdGVLZXkgfSkpXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEtleUF1dGhvcml6YXRpb24uZnJvbSh7XG4gKiAgIGFkZHJlc3MsXG4gKiAgIGV4cGlyeTogMTIzNDU2Nzg5MCxcbiAqICAgdHlwZTogJ3NlY3AyNTZrMScsXG4gKiAgIGxpbWl0czogW3tcbiAqICAgICB0b2tlbjogJzB4MjBjMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsXG4gKiAgICAgbGltaXQ6IFZhbHVlLmZyb20oJzEwJywgNiksXG4gKiAgIH1dLFxuICogfSlcbiAqXG4gKiBjb25zdCByb290UHJpdmF0ZUtleSA9ICcweC4uLidcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHtcbiAqICAgcGF5bG9hZDogS2V5QXV0aG9yaXphdGlvbi5nZXRTaWduUGF5bG9hZChhdXRob3JpemF0aW9uKSxcbiAqICAgcHJpdmF0ZUtleTogcm9vdFByaXZhdGVLZXksXG4gKiB9KVxuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb25fc2lnbmVkID0gS2V5QXV0aG9yaXphdGlvbi5mcm9tKGF1dGhvcml6YXRpb24sIHsgc2lnbmF0dXJlIH0pXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEF0dGFjaGluZyBTaWduYXR1cmVzIChXZWJBdXRobilcbiAqXG4gKiBBdHRhY2ggYSBzaWduYXR1cmUgdG8gYSBLZXkgQXV0aG9yaXphdGlvbiB1c2luZyBhIFdlYkF1dGhuIGNyZWRlbnRpYWwgdG9cbiAqIGF1dGhvcml6ZSBhIG5ldyBXZWJDcnlwdG9QMjU2IGtleSBvbiB0aGUgYWNjb3VudC5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBBZGRyZXNzLCBWYWx1ZSwgV2ViQ3J5cHRvUDI1NiwgV2ViQXV0aG5QMjU2IH0gZnJvbSAnb3gnXG4gKiBpbXBvcnQgeyBLZXlBdXRob3JpemF0aW9uLCBTaWduYXR1cmVFbnZlbG9wZSB9IGZyb20gJ294L3RlbXBvJ1xuICpcbiAqIGNvbnN0IGtleVBhaXIgPSBhd2FpdCBXZWJDcnlwdG9QMjU2LmNyZWF0ZUtleVBhaXIoKVxuICogY29uc3QgYWRkcmVzcyA9IEFkZHJlc3MuZnJvbVB1YmxpY0tleShrZXlQYWlyLnB1YmxpY0tleSlcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uID0gS2V5QXV0aG9yaXphdGlvbi5mcm9tKHtcbiAqICAgYWRkcmVzcyxcbiAqICAgZXhwaXJ5OiAxMjM0NTY3ODkwLFxuICogICB0eXBlOiAncDI1NicsXG4gKiAgIGxpbWl0czogW3tcbiAqICAgICB0b2tlbjogJzB4MjBjMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsXG4gKiAgICAgbGltaXQ6IFZhbHVlLmZyb20oJzEwJywgNiksXG4gKiAgIH1dLFxuICogfSlcbiAqXG4gKiBjb25zdCBjcmVkZW50aWFsID0gYXdhaXQgV2ViQXV0aG5QMjU2LmNyZWF0ZUNyZWRlbnRpYWwoeyBuYW1lOiAnRXhhbXBsZScgfSlcbiAqXG4gKiBjb25zdCB7IG1ldGFkYXRhLCBzaWduYXR1cmUgfSA9IGF3YWl0IFdlYkF1dGhuUDI1Ni5zaWduKHtcbiAqICAgY2hhbGxlbmdlOiBLZXlBdXRob3JpemF0aW9uLmdldFNpZ25QYXlsb2FkKGF1dGhvcml6YXRpb24pLFxuICogICBjcmVkZW50aWFsSWQ6IGNyZWRlbnRpYWwuaWQsXG4gKiB9KVxuICpcbiAqIGNvbnN0IHNpZ25hdHVyZUVudmVsb3BlID0gU2lnbmF0dXJlRW52ZWxvcGUuZnJvbSh7IC8vIFshY29kZSBmb2N1c11cbiAqICAgc2lnbmF0dXJlLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHB1YmxpY0tleTogY3JlZGVudGlhbC5wdWJsaWNLZXksIC8vIFshY29kZSBmb2N1c11cbiAqICAgbWV0YWRhdGEsIC8vIFshY29kZSBmb2N1c11cbiAqIH0pXG4gKiBjb25zdCBhdXRob3JpemF0aW9uX3NpZ25lZCA9IEtleUF1dGhvcml6YXRpb24uZnJvbShcbiAqICAgYXV0aG9yaXphdGlvbixcbiAqICAgeyBzaWduYXR1cmU6IHNpZ25hdHVyZUVudmVsb3BlIH0sIC8vIFshY29kZSBmb2N1c11cbiAqIClcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRob3JpemF0aW9uIC0gQSBLZXkgQXV0aG9yaXphdGlvbiB0dXBsZSBpbiBvYmplY3QgZm9ybWF0LlxuICogQHBhcmFtIG9wdGlvbnMgLSBLZXkgQXV0aG9yaXphdGlvbiBvcHRpb25zLlxuICogQHJldHVybnMgVGhlIHtAbGluayBveCNLZXlBdXRob3JpemF0aW9uLktleUF1dGhvcml6YXRpb259LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbShhdXRob3JpemF0aW9uLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAodHlwZW9mIGF1dGhvcml6YXRpb24uZXhwaXJ5ID09PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIGZyb21ScGMoYXV0aG9yaXphdGlvbik7XG4gICAgaWYgKG9wdGlvbnMuc2lnbmF0dXJlKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uYXV0aG9yaXphdGlvbixcbiAgICAgICAgICAgIHNpZ25hdHVyZTogU2lnbmF0dXJlRW52ZWxvcGUuZnJvbShvcHRpb25zLnNpZ25hdHVyZSksXG4gICAgICAgIH07XG4gICAgcmV0dXJuIGF1dGhvcml6YXRpb247XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uVGVtcG8uUnBjfSB0byBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvblRlbXBvLkF1dGhvcml6YXRpb25UZW1wb30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBLZXlBdXRob3JpemF0aW9uIH0gZnJvbSAnb3gvdGVtcG8nXG4gKlxuICogY29uc3Qga2V5QXV0aG9yaXphdGlvbiA9IEtleUF1dGhvcml6YXRpb24uZnJvbVJwYyh7XG4gKiAgIGV4cGlyeTogJzB4MTc0ODc2ZTgwMCcsXG4gKiAgIGtleUlkOiAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJyxcbiAqICAga2V5VHlwZTogJ3NlY3AyNTZrMScsXG4gKiAgIGxpbWl0czogW3sgdG9rZW46ICcweDIwYzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnLCBsaW1pdDogJzB4ZjQyNDAnIH1dLFxuICogICBzaWduYXR1cmU6IHtcbiAqICAgICB0eXBlOiAnc2VjcDI1NmsxJyxcbiAqICAgICByOiAnMHg2MzVkYzIwMzNlNjAxODViYjM2NzA5YzI5Yzc1ZDY0ZWE1MWRmYmQ5MWMzMmVmNGJlMTk4ZTRjZWIxNjlmYjRkJyxcbiAqICAgICBzOiAnMHg1MGMyNjY3YWM0Yzc3MTA3Mjc0NmFjZmRjZjFmMTQ4MzMzNmRjY2E4YmQyZGY0N2NkODMxNzVkYmU2MGYwNTQwJyxcbiAqICAgICB5UGFyaXR5OiAnMHgwJ1xuICogICB9LFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRob3JpemF0aW9uIC0gVGhlIFJQQy1mb3JtYXR0ZWQgS2V5IEF1dGhvcml6YXRpb24uXG4gKiBAcmV0dXJucyBBIHNpZ25lZCB7QGxpbmsgb3gjQXV0aG9yaXphdGlvblRlbXBvLkF1dGhvcml6YXRpb25UZW1wb30uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUnBjKGF1dGhvcml6YXRpb24pIHtcbiAgICBjb25zdCB7IGNoYWluSWQgPSAnMHgwJywga2V5SWQsIGV4cGlyeSA9IDAsIGxpbWl0cywga2V5VHlwZSB9ID0gYXV0aG9yaXphdGlvbjtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBTaWduYXR1cmVFbnZlbG9wZS5mcm9tUnBjKGF1dGhvcml6YXRpb24uc2lnbmF0dXJlKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhZGRyZXNzOiBrZXlJZCxcbiAgICAgICAgY2hhaW5JZDogY2hhaW5JZCA9PT0gJzB4JyA/IDBuIDogSGV4LnRvQmlnSW50KGNoYWluSWQpLFxuICAgICAgICBleHBpcnk6IE51bWJlcihleHBpcnkpLFxuICAgICAgICBsaW1pdHM6IGxpbWl0cz8ubWFwKChsaW1pdCkgPT4gKHtcbiAgICAgICAgICAgIHRva2VuOiBsaW1pdC50b2tlbixcbiAgICAgICAgICAgIGxpbWl0OiBCaWdJbnQobGltaXQubGltaXQpLFxuICAgICAgICB9KSksXG4gICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgdHlwZToga2V5VHlwZSxcbiAgICB9O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiB7QGxpbmsgb3gjS2V5QXV0aG9yaXphdGlvbi5UdXBsZX0gdG8gYW4ge0BsaW5rIG94I0tleUF1dGhvcml6YXRpb24uS2V5QXV0aG9yaXphdGlvbn0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBLZXlBdXRob3JpemF0aW9uIH0gZnJvbSAnb3gvdGVtcG8nXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEtleUF1dGhvcml6YXRpb24uZnJvbVR1cGxlKFtcbiAqICAgW1xuICogICAgICcweCcsXG4gKiAgICAgJzB4MDAnLFxuICogICAgICcweGJlOTVjM2Y1NTRlOWZjODVlYzUxYmU2OWEzZDgwN2EwZDU1YmNmMmMnLFxuICogICAgICcweDE3NDg3NmU4MDAnLFxuICogICAgIFtbJzB4MjBjMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsICcweGY0MjQwJ11dLFxuICogICBdLFxuICogICAnMHgwMWEwNjhhMDIwYTIwOWQzZDU2YzQ2ZjM4Y2M1MGEzM2Y3MDRmNGE5YTEwYTU5Mzc3ZjhkZDc2MmFjNjY5MTBlOWI5MDdlODY1YWQwNWM0MDM1YWI1NzkyNzg3ZDRhMDI5N2E0MzYxN2FlODk3OTMwYTZmZTRkODIyYjhmYWVhNTIwNjQnLFxuICogXSlcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBVbnNpZ25lZCBLZXkgQXV0aG9yaXphdGlvbiB0dXBsZSAobm8gc2lnbmF0dXJlKTpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgS2V5QXV0aG9yaXphdGlvbiB9IGZyb20gJ294L3RlbXBvJ1xuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb24gPSBLZXlBdXRob3JpemF0aW9uLmZyb21UdXBsZShbXG4gKiAgIFtcbiAqICAgICAnMHgnLFxuICogICAgICcweDAwJyxcbiAqICAgICAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJyxcbiAqICAgICAnMHgxNzQ4NzZlODAwJyxcbiAqICAgICBbWycweDIwYzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnLCAnMHhmNDI0MCddXSxcbiAqICAgXSxcbiAqIF0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdHVwbGUgLSBUaGUgS2V5IEF1dGhvcml6YXRpb24gdHVwbGUuXG4gKiBAcmV0dXJucyBUaGUge0BsaW5rIG94I0tleUF1dGhvcml6YXRpb24uS2V5QXV0aG9yaXphdGlvbn0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVHVwbGUodHVwbGUpIHtcbiAgICBjb25zdCBbYXV0aG9yaXphdGlvbiwgc2lnbmF0dXJlU2VyaWFsaXplZF0gPSB0dXBsZTtcbiAgICBjb25zdCBbY2hhaW5JZCwga2V5VHlwZV9oZXgsIGtleUlkLCBleHBpcnksIGxpbWl0c10gPSBhdXRob3JpemF0aW9uO1xuICAgIGNvbnN0IGtleVR5cGUgPSAoKCkgPT4ge1xuICAgICAgICBzd2l0Y2ggKGtleVR5cGVfaGV4KSB7XG4gICAgICAgICAgICBjYXNlICcweCc6XG4gICAgICAgICAgICBjYXNlICcweDAwJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3NlY3AyNTZrMSc7XG4gICAgICAgICAgICBjYXNlICcweDAxJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3AyNTYnO1xuICAgICAgICAgICAgY2FzZSAnMHgwMic6XG4gICAgICAgICAgICAgICAgcmV0dXJuICd3ZWJBdXRobic7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBrZXkgdHlwZTogJHtrZXlUeXBlX2hleH1gKTtcbiAgICAgICAgfVxuICAgIH0pKCk7XG4gICAgY29uc3QgYXJncyA9IHtcbiAgICAgICAgYWRkcmVzczoga2V5SWQsXG4gICAgICAgIGV4cGlyeTogdHlwZW9mIGV4cGlyeSAhPT0gJ3VuZGVmaW5lZCcgPyBIZXgudG9OdW1iZXIoZXhwaXJ5KSA6IHVuZGVmaW5lZCxcbiAgICAgICAgdHlwZToga2V5VHlwZSxcbiAgICAgICAgLi4uKGNoYWluSWQgIT09ICcweCcgPyB7IGNoYWluSWQ6IEhleC50b0JpZ0ludChjaGFpbklkKSB9IDoge30pLFxuICAgICAgICAuLi4odHlwZW9mIGV4cGlyeSAhPT0gJ3VuZGVmaW5lZCcgPyB7IGV4cGlyeTogSGV4LnRvTnVtYmVyKGV4cGlyeSkgfSA6IHt9KSxcbiAgICAgICAgLi4uKHR5cGVvZiBsaW1pdHMgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBsaW1pdHM6IGxpbWl0cy5tYXAoKFt0b2tlbiwgbGltaXRdKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICB0b2tlbixcbiAgICAgICAgICAgICAgICAgICAgbGltaXQ6IEJpZ0ludChsaW1pdCksXG4gICAgICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7fSksXG4gICAgfTtcbiAgICBpZiAoc2lnbmF0dXJlU2VyaWFsaXplZClcbiAgICAgICAgYXJncy5zaWduYXR1cmUgPSBTaWduYXR1cmVFbnZlbG9wZS5kZXNlcmlhbGl6ZShzaWduYXR1cmVTZXJpYWxpemVkKTtcbiAgICByZXR1cm4gZnJvbShhcmdzKTtcbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIHNpZ24gcGF5bG9hZCBmb3IgYW4ge0BsaW5rIG94I0tleUF1dGhvcml6YXRpb24uS2V5QXV0aG9yaXphdGlvbn0uXG4gKlxuICogVGhlIHJvb3Qga2V5IG11c3Qgc2lnbiB0aGlzIHBheWxvYWQgdG8gYXV0aG9yaXplIHRoZSBhY2Nlc3Mga2V5LiBUaGUgcmVzdWx0aW5nIHNpZ25hdHVyZVxuICogaXMgYXR0YWNoZWQgdG8gdGhlIGtleSBhdXRob3JpemF0aW9uIHZpYSB7QGxpbmsgb3gjS2V5QXV0aG9yaXphdGlvbi4oZnJvbTpmdW5jdGlvbil9IHdpdGggdGhlXG4gKiBgc2lnbmF0dXJlYCBvcHRpb24uXG4gKlxuICogW0FjY2VzcyBLZXlzIFNwZWNpZmljYXRpb25dKGh0dHBzOi8vZG9jcy50ZW1wby54eXovcHJvdG9jb2wvdHJhbnNhY3Rpb25zL3NwZWMtdGVtcG8tdHJhbnNhY3Rpb24jYWNjZXNzLWtleXMpXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBZGRyZXNzLCBTZWNwMjU2azEsIFZhbHVlIH0gZnJvbSAnb3gnXG4gKiBpbXBvcnQgeyBLZXlBdXRob3JpemF0aW9uIH0gZnJvbSAnb3gvdGVtcG8nXG4gKlxuICogY29uc3QgcHJpdmF0ZUtleSA9ICcweC4uLidcbiAqIGNvbnN0IGFkZHJlc3MgPSBBZGRyZXNzLmZyb21QdWJsaWNLZXkoU2VjcDI1NmsxLmdldFB1YmxpY0tleSh7IHByaXZhdGVLZXkgfSkpXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEtleUF1dGhvcml6YXRpb24uZnJvbSh7XG4gKiAgIGFkZHJlc3MsXG4gKiAgIGV4cGlyeTogMTIzNDU2Nzg5MCxcbiAqICAgdHlwZTogJ3NlY3AyNTZrMScsXG4gKiAgIGxpbWl0czogW3tcbiAqICAgICB0b2tlbjogJzB4MjBjMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsXG4gKiAgICAgbGltaXQ6IFZhbHVlLmZyb20oJzEwJywgNiksXG4gKiAgIH1dLFxuICogfSlcbiAqXG4gKiBjb25zdCBwYXlsb2FkID0gS2V5QXV0aG9yaXphdGlvbi5nZXRTaWduUGF5bG9hZChhdXRob3JpemF0aW9uKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYXV0aG9yaXphdGlvbiAtIFRoZSB7QGxpbmsgb3gjS2V5QXV0aG9yaXphdGlvbi5LZXlBdXRob3JpemF0aW9ufS5cbiAqIEByZXR1cm5zIFRoZSBzaWduIHBheWxvYWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTaWduUGF5bG9hZChhdXRob3JpemF0aW9uKSB7XG4gICAgcmV0dXJuIGhhc2goYXV0aG9yaXphdGlvbik7XG59XG4vKipcbiAqIENvbXB1dGVzIHRoZSBoYXNoIGZvciBhbiB7QGxpbmsgb3gjS2V5QXV0aG9yaXphdGlvbi5LZXlBdXRob3JpemF0aW9ufS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEtleUF1dGhvcml6YXRpb24gfSBmcm9tICdveC90ZW1wbydcbiAqIGltcG9ydCB7IFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEtleUF1dGhvcml6YXRpb24uZnJvbSh7XG4gKiAgIGV4cGlyeTogMTIzNDU2Nzg5MCxcbiAqICAgYWRkcmVzczogJzB4YmU5NWMzZjU1NGU5ZmM4NWVjNTFiZTY5YTNkODA3YTBkNTViY2YyYycsXG4gKiAgIHR5cGU6ICdzZWNwMjU2azEnLFxuICogICBsaW1pdHM6IFt7XG4gKiAgICAgdG9rZW46ICcweDIwYzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnLFxuICogICAgIGxpbWl0OiBWYWx1ZS5mcm9tKCcxMCcsIDYpXG4gKiAgIH1dLFxuICogfSlcbiAqXG4gKiBjb25zdCBoYXNoID0gS2V5QXV0aG9yaXphdGlvbi5oYXNoKGF1dGhvcml6YXRpb24pIC8vIFshY29kZSBmb2N1c11cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRob3JpemF0aW9uIC0gVGhlIHtAbGluayBveCNLZXlBdXRob3JpemF0aW9uLktleUF1dGhvcml6YXRpb259LlxuICogQHJldHVybnMgVGhlIGhhc2guXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNoKGF1dGhvcml6YXRpb24pIHtcbiAgICBjb25zdCBbYXV0aG9yaXphdGlvblR1cGxlXSA9IHRvVHVwbGUoYXV0aG9yaXphdGlvbik7XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IFJscC5mcm9tSGV4KGF1dGhvcml6YXRpb25UdXBsZSk7XG4gICAgcmV0dXJuIEhhc2gua2VjY2FrMjU2KHNlcmlhbGl6ZWQpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiB7QGxpbmsgb3gjS2V5QXV0aG9yaXphdGlvbi5LZXlBdXRob3JpemF0aW9ufSB0byBhbiB7QGxpbmsgb3gjS2V5QXV0aG9yaXphdGlvbi5ScGN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgS2V5QXV0aG9yaXphdGlvbiB9IGZyb20gJ294L3RlbXBvJ1xuICogaW1wb3J0IHsgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uID0gS2V5QXV0aG9yaXphdGlvbi50b1JwYyh7XG4gKiAgIGV4cGlyeTogMTIzNDU2Nzg5MCxcbiAqICAgYWRkcmVzczogJzB4YmU5NWMzZjU1NGU5ZmM4NWVjNTFiZTY5YTNkODA3YTBkNTViY2YyYycsXG4gKiAgIHR5cGU6ICdzZWNwMjU2azEnLFxuICogICBsaW1pdHM6IFt7XG4gKiAgICAgdG9rZW46ICcweDIwYzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnLFxuICogICAgIGxpbWl0OiBWYWx1ZS5mcm9tKCcxMCcsIDYpXG4gKiAgIH1dLFxuICogICBzaWduYXR1cmU6IHtcbiAqICAgICB0eXBlOiAnc2VjcDI1NmsxJyxcbiAqICAgICBzaWduYXR1cmU6IHtcbiAqICAgICAgIHI6IDQ0OTQ0NjI3ODEzMDA3NzcyODk3MzkxNTMxMjMwMDgxNjk1MTAyNzAzMjg5MTIzMzMyMTg3Njk2MTE1MTgxMTA0NzM5MjM5MTk3NTE3bixcbiAqICAgICAgIHM6IDM2NTI4NTAzNTA1MTkyNDM4MzA3MzU1MTY0NDQxMTA0MDAxMzEwNTY2NTA1MzUxOTgwMzY5MDg1MjA4MTc4NzEyNjc4Nzk5MTgxMTIwbixcbiAqICAgICAgIHlQYXJpdHk6IDAsXG4gKiAgICAgfSxcbiAqICAgfSxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYXV0aG9yaXphdGlvbiAtIEEgS2V5IEF1dGhvcml6YXRpb24uXG4gKiBAcmV0dXJucyBBbiBSUEMtZm9ybWF0dGVkIEtleSBBdXRob3JpemF0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9ScGMoYXV0aG9yaXphdGlvbikge1xuICAgIGNvbnN0IHsgYWRkcmVzcywgY2hhaW5JZCA9IDBuLCBleHBpcnksIGxpbWl0cywgdHlwZSwgc2lnbmF0dXJlLCB9ID0gYXV0aG9yaXphdGlvbjtcbiAgICByZXR1cm4ge1xuICAgICAgICBjaGFpbklkOiBjaGFpbklkID09PSAwbiA/ICcweCcgOiBIZXguZnJvbU51bWJlcihjaGFpbklkKSxcbiAgICAgICAgZXhwaXJ5OiB0eXBlb2YgZXhwaXJ5ID09PSAnbnVtYmVyJyA/IEhleC5mcm9tTnVtYmVyKGV4cGlyeSkgOiBudWxsLFxuICAgICAgICBsaW1pdHM6IGxpbWl0cz8ubWFwKCh7IHRva2VuLCBsaW1pdCB9KSA9PiAoe1xuICAgICAgICAgICAgdG9rZW4sXG4gICAgICAgICAgICBsaW1pdDogSGV4LmZyb21OdW1iZXIobGltaXQpLFxuICAgICAgICB9KSksXG4gICAgICAgIGtleUlkOiBhZGRyZXNzLFxuICAgICAgICBzaWduYXR1cmU6IFNpZ25hdHVyZUVudmVsb3BlLnRvUnBjKHNpZ25hdHVyZSksXG4gICAgICAgIGtleVR5cGU6IHR5cGUsXG4gICAgfTtcbn1cbi8qKlxuICogQ29udmVydHMgYW4ge0BsaW5rIG94I0tleUF1dGhvcml6YXRpb24uS2V5QXV0aG9yaXphdGlvbn0gdG8gYW4ge0BsaW5rIG94I0tleUF1dGhvcml6YXRpb24uVHVwbGV9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgS2V5QXV0aG9yaXphdGlvbiB9IGZyb20gJ294L3RlbXBvJ1xuICogaW1wb3J0IHsgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uID0gS2V5QXV0aG9yaXphdGlvbi5mcm9tKHtcbiAqICAgZXhwaXJ5OiAxMjM0NTY3ODkwLFxuICogICBhZGRyZXNzOiAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJyxcbiAqICAgdHlwZTogJ3NlY3AyNTZrMScsXG4gKiAgIGxpbWl0czogW3tcbiAqICAgICB0b2tlbjogJzB4MjBjMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsXG4gKiAgICAgbGltaXQ6IFZhbHVlLmZyb20oJzEwJywgNilcbiAqICAgfV0sXG4gKiB9KVxuICpcbiAqIGNvbnN0IHR1cGxlID0gS2V5QXV0aG9yaXphdGlvbi50b1R1cGxlKGF1dGhvcml6YXRpb24pIC8vIFshY29kZSBmb2N1c11cbiAqIC8vIEBsb2c6IFtcbiAqIC8vIEBsb2c6ICAgJzB4MTc0ODc2ZTgwMCcsXG4gKiAvLyBAbG9nOiAgIFtbJzB4MjBjMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsICcweGY0MjQwJ11dLFxuICogLy8gQGxvZzogICAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJyxcbiAqIC8vIEBsb2c6ICAgJ3NlY3AyNTZrMScsXG4gKiAvLyBAbG9nOiBdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYXV0aG9yaXphdGlvbiAtIFRoZSB7QGxpbmsgb3gjS2V5QXV0aG9yaXphdGlvbi5LZXlBdXRob3JpemF0aW9ufS5cbiAqIEByZXR1cm5zIEEgVGVtcG8gS2V5IEF1dGhvcml6YXRpb24gdHVwbGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1R1cGxlKGF1dGhvcml6YXRpb24pIHtcbiAgICBjb25zdCB7IGFkZHJlc3MsIGNoYWluSWQgPSAwbiwgZXhwaXJ5LCBsaW1pdHMgfSA9IGF1dGhvcml6YXRpb247XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gYXV0aG9yaXphdGlvbi5zaWduYXR1cmVcbiAgICAgICAgPyBTaWduYXR1cmVFbnZlbG9wZS5zZXJpYWxpemUoYXV0aG9yaXphdGlvbi5zaWduYXR1cmUpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IHR5cGUgPSAoKCkgPT4ge1xuICAgICAgICBzd2l0Y2ggKGF1dGhvcml6YXRpb24udHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnc2VjcDI1NmsxJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJzB4JztcbiAgICAgICAgICAgIGNhc2UgJ3AyNTYnOlxuICAgICAgICAgICAgICAgIHJldHVybiAnMHgwMSc7XG4gICAgICAgICAgICBjYXNlICd3ZWJBdXRobic6XG4gICAgICAgICAgICAgICAgcmV0dXJuICcweDAyJztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGtleSB0eXBlOiAke2F1dGhvcml6YXRpb24udHlwZX1gKTtcbiAgICAgICAgfVxuICAgIH0pKCk7XG4gICAgY29uc3QgYXV0aG9yaXphdGlvblR1cGxlID0gW1xuICAgICAgICBjaGFpbklkID09PSAwbiA/ICcweCcgOiBIZXguZnJvbU51bWJlcihjaGFpbklkKSxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgdHlwZW9mIGV4cGlyeSA9PT0gJ251bWJlcicgPyBIZXguZnJvbU51bWJlcihleHBpcnkpIDogdW5kZWZpbmVkLFxuICAgICAgICBsaW1pdHM/Lm1hcCgobGltaXQpID0+IFtsaW1pdC50b2tlbiwgSGV4LmZyb21OdW1iZXIobGltaXQubGltaXQpXSkgPz9cbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICBdLmZpbHRlcihCb29sZWFuKTtcbiAgICByZXR1cm4gW2F1dGhvcml6YXRpb25UdXBsZSwgLi4uKHNpZ25hdHVyZSA/IFtzaWduYXR1cmVdIDogW10pXTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUtleUF1dGhvcml6YXRpb24uanMubWFwIl0sIm5hbWVzIjpbIkhhc2giLCJIZXgiLCJSbHAiLCJTaWduYXR1cmVFbnZlbG9wZSIsImZyb20iLCJhdXRob3JpemF0aW9uIiwib3B0aW9ucyIsImV4cGlyeSIsImZyb21ScGMiLCJzaWduYXR1cmUiLCJjaGFpbklkIiwia2V5SWQiLCJsaW1pdHMiLCJrZXlUeXBlIiwiYWRkcmVzcyIsInRvQmlnSW50IiwiTnVtYmVyIiwibWFwIiwibGltaXQiLCJ0b2tlbiIsIkJpZ0ludCIsInR5cGUiLCJmcm9tVHVwbGUiLCJ0dXBsZSIsInNpZ25hdHVyZVNlcmlhbGl6ZWQiLCJrZXlUeXBlX2hleCIsIkVycm9yIiwiYXJncyIsInRvTnVtYmVyIiwidW5kZWZpbmVkIiwiZGVzZXJpYWxpemUiLCJnZXRTaWduUGF5bG9hZCIsImhhc2giLCJhdXRob3JpemF0aW9uVHVwbGUiLCJ0b1R1cGxlIiwic2VyaWFsaXplZCIsImZyb21IZXgiLCJrZWNjYWsyNTYiLCJ0b1JwYyIsImZyb21OdW1iZXIiLCJzZXJpYWxpemUiLCJmaWx0ZXIiLCJCb29sZWFuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/tempo/KeyAuthorization.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/tempo/SignatureEnvelope.js":
/*!*********************************************************!*\
  !*** ./node_modules/ox/_esm/tempo/SignatureEnvelope.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CoercionError: () => (/* binding */ CoercionError),\n/* harmony export */   InvalidSerializedError: () => (/* binding */ InvalidSerializedError),\n/* harmony export */   MissingPropertiesError: () => (/* binding */ MissingPropertiesError),\n/* harmony export */   VerificationError: () => (/* binding */ VerificationError),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   deserialize: () => (/* binding */ deserialize),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromRpc: () => (/* binding */ fromRpc),\n/* harmony export */   getType: () => (/* binding */ getType),\n/* harmony export */   magicBytes: () => (/* binding */ magicBytes),\n/* harmony export */   serialize: () => (/* binding */ serialize),\n/* harmony export */   toRpc: () => (/* binding */ toRpc),\n/* harmony export */   types: () => (/* binding */ types),\n/* harmony export */   validate: () => (/* binding */ validate),\n/* harmony export */   verify: () => (/* binding */ verify)\n/* harmony export */ });\n/* harmony import */ var _core_Address_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/Address.js */ \"(ssr)/./node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _core_Errors_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core/Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _core_Json_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../core/Json.js */ \"(ssr)/./node_modules/ox/_esm/core/Json.js\");\n/* harmony import */ var _core_P256_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/P256.js */ \"(ssr)/./node_modules/ox/_esm/core/P256.js\");\n/* harmony import */ var _core_Secp256k1_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/Secp256k1.js */ \"(ssr)/./node_modules/ox/_esm/core/Secp256k1.js\");\n/* harmony import */ var _core_Signature_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Signature.js */ \"(ssr)/./node_modules/ox/_esm/core/Signature.js\");\n/* harmony import */ var _core_WebAuthnP256_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/WebAuthnP256.js */ \"(ssr)/./node_modules/ox/_esm/core/WebAuthnP256.js\");\n\n\n\n\n\n\n\n\n/** Signature type identifiers for encoding/decoding */ const serializedP256Type = \"0x01\";\nconst serializedWebAuthnType = \"0x02\";\nconst serializedKeychainType = \"0x03\";\n/** Serialized magic identifier for Tempo signature envelopes. */ const magicBytes = \"0x7777777777777777777777777777777777777777777777777777777777777777\"; // 32 \"T\"s\n/** List of supported signature types. */ const types = [\n    \"secp256k1\",\n    \"p256\",\n    \"webAuthn\"\n];\n/**\n * Asserts that a {@link ox#SignatureEnvelope.SignatureEnvelope} is valid.\n *\n * @example\n * ```ts twoslash\n * import { SignatureEnvelope } from 'ox/tempo'\n *\n * SignatureEnvelope.assert({\n *   type: 'secp256k1',\n *   signature: {\n *     r: 0n,\n *     s: 0n,\n *     yParity: 0,\n *   },\n * })\n * ```\n *\n * @param envelope - The signature envelope to assert.\n * @throws `CoercionError` if the envelope type cannot be determined.\n */ function assert(envelope) {\n    const type = getType(envelope);\n    if (type === \"secp256k1\") {\n        const secp256k1 = envelope;\n        _core_Signature_js__WEBPACK_IMPORTED_MODULE_0__.assert(secp256k1.signature);\n        return;\n    }\n    if (type === \"p256\") {\n        const p256 = envelope;\n        const missing = [];\n        if (typeof p256.signature?.r !== \"bigint\") missing.push(\"signature.r\");\n        if (typeof p256.signature?.s !== \"bigint\") missing.push(\"signature.s\");\n        if (typeof p256.prehash !== \"boolean\") missing.push(\"prehash\");\n        if (!p256.publicKey) missing.push(\"publicKey\");\n        else {\n            if (typeof p256.publicKey.x !== \"bigint\") missing.push(\"publicKey.x\");\n            if (typeof p256.publicKey.y !== \"bigint\") missing.push(\"publicKey.y\");\n        }\n        if (missing.length > 0) throw new MissingPropertiesError({\n            envelope,\n            missing,\n            type: \"p256\"\n        });\n        return;\n    }\n    if (type === \"webAuthn\") {\n        const webauthn = envelope;\n        const missing = [];\n        if (typeof webauthn.signature?.r !== \"bigint\") missing.push(\"signature.r\");\n        if (typeof webauthn.signature?.s !== \"bigint\") missing.push(\"signature.s\");\n        if (!webauthn.metadata) missing.push(\"metadata\");\n        else {\n            if (!webauthn.metadata.authenticatorData) missing.push(\"metadata.authenticatorData\");\n            if (!webauthn.metadata.clientDataJSON) missing.push(\"metadata.clientDataJSON\");\n        }\n        if (!webauthn.publicKey) missing.push(\"publicKey\");\n        else {\n            if (typeof webauthn.publicKey.x !== \"bigint\") missing.push(\"publicKey.x\");\n            if (typeof webauthn.publicKey.y !== \"bigint\") missing.push(\"publicKey.y\");\n        }\n        if (missing.length > 0) throw new MissingPropertiesError({\n            envelope,\n            missing,\n            type: \"webAuthn\"\n        });\n        return;\n    }\n    if (type === \"keychain\") {\n        const keychain = envelope;\n        assert(keychain.inner);\n        return;\n    }\n}\n/**\n * Deserializes a hex-encoded signature envelope into a typed signature object.\n *\n * Wire format detection:\n * - 65 bytes (no prefix): secp256k1 signature\n * - Type `0x01` + 129 bytes: P256 signature (r, s, pubKeyX, pubKeyY, prehash)\n * - Type `0x02` + variable: WebAuthn signature (webauthnData, r, s, pubKeyX, pubKeyY)\n * - Type `0x03` + 20 bytes + inner: Keychain signature (userAddress + inner signature)\n *\n * [Signature Types](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction#signature-types)\n *\n * @example\n * ```ts twoslash\n * import { SignatureEnvelope } from 'ox/tempo'\n *\n * const envelope = SignatureEnvelope.deserialize('0x...')\n * ```\n *\n * @param serialized - The hex-encoded signature envelope to deserialize.\n * @returns The deserialized signature envelope.\n * @throws `CoercionError` if the serialized value cannot be coerced to a valid signature envelope.\n */ function deserialize(value) {\n    const serialized = value.endsWith(magicBytes.slice(2)) ? _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(value, 0, -_core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.size(magicBytes)) : value;\n    const size = _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.size(serialized);\n    // Backward compatibility: 65 bytes means secp256k1 without type identifier\n    if (size === 65) {\n        const signature = _core_Signature_js__WEBPACK_IMPORTED_MODULE_0__.fromHex(serialized);\n        _core_Signature_js__WEBPACK_IMPORTED_MODULE_0__.assert(signature);\n        return {\n            signature,\n            type: \"secp256k1\"\n        };\n    }\n    // For all other lengths, first byte is the type identifier\n    const typeId = _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(serialized, 0, 1);\n    const data = _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(serialized, 1);\n    const dataSize = _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.size(data);\n    if (typeId === serializedP256Type) {\n        // P256: 32 (r) + 32 (s) + 32 (pubKeyX) + 32 (pubKeyY) + 1 (prehash) = 129 bytes\n        if (dataSize !== 129) throw new InvalidSerializedError({\n            reason: `Invalid P256 signature envelope size: expected 129 bytes, got ${dataSize} bytes`,\n            serialized\n        });\n        return {\n            publicKey: {\n                prefix: 4,\n                x: _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt(_core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(data, 64, 96)),\n                y: _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt(_core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(data, 96, 128))\n            },\n            prehash: _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.toNumber(_core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(data, 128, 129)) !== 0,\n            signature: {\n                r: _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt(_core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(data, 0, 32)),\n                s: _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt(_core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(data, 32, 64))\n            },\n            type: \"p256\"\n        };\n    }\n    if (typeId === serializedWebAuthnType) {\n        // WebAuthn: variable (webauthnData) + 32 (r) + 32 (s) + 32 (pubKeyX) + 32 (pubKeyY)\n        // Minimum: 128 bytes (at least some authenticator data + signature components)\n        if (dataSize < 128) throw new InvalidSerializedError({\n            reason: `Invalid WebAuthn signature envelope size: expected at least 128 bytes, got ${dataSize} bytes`,\n            serialized\n        });\n        const webauthnDataSize = dataSize - 128;\n        const webauthnData = _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(data, 0, webauthnDataSize);\n        // Parse webauthnData into authenticatorData and clientDataJSON\n        // According to the Rust code, it's authenticatorData || clientDataJSON\n        // We need to find the split point (minimum authenticatorData is 37 bytes)\n        let authenticatorData;\n        let clientDataJSON;\n        // Try to find the JSON start (clientDataJSON should start with '{')\n        for(let split = 37; split < webauthnDataSize; split++){\n            const potentialJson = _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.toString(_core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(webauthnData, split));\n            if (potentialJson.startsWith(\"{\") && potentialJson.endsWith(\"}\")) {\n                try {\n                    JSON.parse(potentialJson);\n                    authenticatorData = _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(webauthnData, 0, split);\n                    clientDataJSON = potentialJson;\n                    break;\n                } catch  {}\n            }\n        }\n        if (!authenticatorData || !clientDataJSON) throw new InvalidSerializedError({\n            reason: \"Unable to parse WebAuthn metadata: could not extract valid authenticatorData and clientDataJSON\",\n            serialized\n        });\n        return {\n            publicKey: {\n                prefix: 4,\n                x: _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt(_core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(data, webauthnDataSize + 64, webauthnDataSize + 96)),\n                y: _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt(_core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(data, webauthnDataSize + 96, webauthnDataSize + 128))\n            },\n            metadata: {\n                authenticatorData,\n                clientDataJSON\n            },\n            signature: {\n                r: _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt(_core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(data, webauthnDataSize, webauthnDataSize + 32)),\n                s: _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt(_core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(data, webauthnDataSize + 32, webauthnDataSize + 64))\n            },\n            type: \"webAuthn\"\n        };\n    }\n    if (typeId === serializedKeychainType) {\n        const userAddress = _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(data, 0, 20);\n        const inner = deserialize(_core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(data, 20));\n        return {\n            userAddress,\n            inner,\n            type: \"keychain\"\n        };\n    }\n    throw new InvalidSerializedError({\n        reason: `Unknown signature type identifier: ${typeId}. Expected ${serializedP256Type} (P256) or ${serializedWebAuthnType} (WebAuthn)`,\n        serialized\n    });\n}\n/**\n * Coerces a value to a signature envelope.\n *\n * Accepts either a serialized hex string or an existing signature envelope object.\n * Use this to wrap raw signatures from {@link ox#Secp256k1.(sign:function)}, {@link ox#P256.(sign:function)},\n * {@link ox#WebCryptoP256.(sign:function)}, or {@link ox#WebAuthnP256.(sign:function)} into the envelope format\n * required by Tempo transactions.\n *\n * [Signature Types](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction#signature-types)\n *\n * @example\n * ### Secp256k1\n *\n * Standard Ethereum ECDSA signature using the secp256k1 curve.\n *\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n * import { SignatureEnvelope } from 'ox/tempo'\n *\n * const privateKey = Secp256k1.randomPrivateKey()\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const envelope = SignatureEnvelope.from(signature)\n * ```\n *\n * @example\n * ### P256\n *\n * ECDSA signature using the P-256 (secp256r1) curve. Requires embedding the\n * public key.\n *\n * ```ts twoslash\n * import { P256 } from 'ox'\n * import { SignatureEnvelope } from 'ox/tempo'\n *\n * const { privateKey, publicKey } = P256.createKeyPair()\n * const signature = P256.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const envelope = SignatureEnvelope.from({\n *   signature,\n *   publicKey,\n * })\n * ```\n *\n * @example\n * ### P256 (WebCrypto)\n *\n * When using WebCrypto keys, `prehash` must be `true` since WebCrypto always\n * SHA256 hashes the digest before signing.\n *\n * ```ts twoslash\n * // @noErrors\n * import { WebCryptoP256 } from 'ox'\n * import { SignatureEnvelope } from 'ox/tempo'\n *\n * const { privateKey, publicKey } = await WebCryptoP256.createKeyPair()\n * const signature = await WebCryptoP256.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const envelope = SignatureEnvelope.from({\n *   signature,\n *   publicKey,\n *   prehash: true,\n * })\n * ```\n *\n * @example\n * ### WebAuthn\n *\n * Passkey-based signature using WebAuthn. Includes authenticator metadata\n * (authenticatorData and clientDataJSON) along with the P-256 signature and\n * public key.\n *\n * ```ts twoslash\n * // @noErrors\n * import { WebAuthnP256 } from 'ox'\n * import { SignatureEnvelope } from 'ox/tempo'\n *\n * const credential = await WebAuthnP256.createCredential({\n *   name: 'Example',\n * })\n *\n * const { metadata, signature } = await WebAuthnP256.sign({\n *   challenge: '0xdeadbeef',\n *   credentialId: credential.id,\n * })\n *\n * const envelope = SignatureEnvelope.from({\n *   signature,\n *   publicKey: credential.publicKey,\n *   metadata,\n * })\n * ```\n *\n * @example\n * ### Keychain\n *\n * Wraps another signature type with a user address, used for delegated signing\n * via access keys on behalf of a root account.\n *\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n * import { SignatureEnvelope } from 'ox/tempo'\n *\n * const privateKey = Secp256k1.randomPrivateKey()\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const envelope = SignatureEnvelope.from({\n *   userAddress: '0x1234567890123456789012345678901234567890',\n *   inner: SignatureEnvelope.from(signature),\n * })\n * ```\n *\n * @param value - The value to coerce (either a hex string or signature envelope).\n * @returns The signature envelope.\n */ function from(value) {\n    if (typeof value === \"string\") return deserialize(value);\n    if (typeof value === \"object\" && value !== null && \"r\" in value && \"s\" in value && \"yParity\" in value) return {\n        signature: value,\n        type: \"secp256k1\"\n    };\n    const type = getType(value);\n    return {\n        ...value,\n        ...type === \"p256\" ? {\n            prehash: value.prehash\n        } : {},\n        type\n    };\n}\n/**\n * Converts an RPC-formatted signature envelope to a typed signature envelope.\n *\n * @example\n * ```ts twoslash\n * import { SignatureEnvelope } from 'ox/tempo'\n *\n * const envelope = SignatureEnvelope.fromRpc({\n *   r: '0x0',\n *   s: '0x0',\n *   yParity: '0x0',\n *   type: 'secp256k1',\n * })\n * ```\n *\n * @param envelope - The RPC signature envelope to convert.\n * @returns The signature envelope with bigint values.\n */ function fromRpc(envelope) {\n    if (envelope.type === \"secp256k1\") return {\n        signature: _core_Signature_js__WEBPACK_IMPORTED_MODULE_0__.fromRpc(envelope),\n        type: \"secp256k1\"\n    };\n    if (envelope.type === \"p256\") {\n        return {\n            prehash: envelope.preHash,\n            publicKey: {\n                prefix: 4,\n                x: _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt(envelope.pubKeyX),\n                y: _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt(envelope.pubKeyY)\n            },\n            signature: {\n                r: _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt(envelope.r),\n                s: _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt(envelope.s)\n            },\n            type: \"p256\"\n        };\n    }\n    if (envelope.type === \"webAuthn\") {\n        const webauthnData = envelope.webauthnData;\n        const webauthnDataSize = _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.size(webauthnData);\n        // Parse webauthnData into authenticatorData and clientDataJSON\n        let authenticatorData;\n        let clientDataJSON;\n        // Try to find the JSON start (clientDataJSON should start with '{')\n        for(let split = 37; split < webauthnDataSize; split++){\n            const potentialJson = _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.toString(_core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(webauthnData, split));\n            if (potentialJson.startsWith(\"{\") && potentialJson.endsWith(\"}\")) {\n                try {\n                    JSON.parse(potentialJson);\n                    authenticatorData = _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(webauthnData, 0, split);\n                    clientDataJSON = potentialJson;\n                    break;\n                } catch  {}\n            }\n        }\n        if (!authenticatorData || !clientDataJSON) throw new InvalidSerializedError({\n            reason: \"Unable to parse WebAuthn metadata: could not extract valid authenticatorData and clientDataJSON\",\n            serialized: webauthnData\n        });\n        return {\n            metadata: {\n                authenticatorData,\n                clientDataJSON\n            },\n            publicKey: {\n                prefix: 4,\n                x: _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt(envelope.pubKeyX),\n                y: _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt(envelope.pubKeyY)\n            },\n            signature: {\n                r: _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt(envelope.r),\n                s: _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt(envelope.s)\n            },\n            type: \"webAuthn\"\n        };\n    }\n    if (envelope.type === \"keychain\" || \"userAddress\" in envelope && \"signature\" in envelope) return {\n        type: \"keychain\",\n        userAddress: envelope.userAddress,\n        inner: fromRpc(envelope.signature)\n    };\n    throw new CoercionError({\n        envelope\n    });\n}\n/**\n * Determines the signature type of an envelope.\n *\n * @example\n * ```ts twoslash\n * import { SignatureEnvelope } from 'ox/tempo'\n *\n * const type = SignatureEnvelope.getType({\n *   signature: { r: 0n, s: 0n, yParity: 0 },\n * })\n * // @log: 'secp256k1'\n * ```\n *\n * @param envelope - The signature envelope to inspect.\n * @returns The signature type ('secp256k1', 'p256', or 'webAuthn').\n * @throws `CoercionError` if the envelope type cannot be determined.\n */ function getType(envelope) {\n    if (typeof envelope !== \"object\" || envelope === null) throw new CoercionError({\n        envelope\n    });\n    if (\"type\" in envelope && envelope.type) return envelope.type;\n    // Detect secp256k1 signature (backwards compatibility: also support flat structure)\n    if (\"signature\" in envelope && !(\"publicKey\" in envelope) && typeof envelope.signature === \"object\" && envelope.signature !== null && \"r\" in envelope.signature && \"s\" in envelope.signature && \"yParity\" in envelope.signature) return \"secp256k1\";\n    // Detect secp256k1 signature (flat structure)\n    if (\"r\" in envelope && \"s\" in envelope && \"yParity\" in envelope) return \"secp256k1\";\n    // Detect P256 signature\n    if (\"signature\" in envelope && \"prehash\" in envelope && \"publicKey\" in envelope && typeof envelope.prehash === \"boolean\") return \"p256\";\n    // Detect WebAuthn signature\n    if (\"signature\" in envelope && \"metadata\" in envelope && \"publicKey\" in envelope) return \"webAuthn\";\n    // Detect Keychain signature\n    if (\"userAddress\" in envelope && \"inner\" in envelope) return \"keychain\";\n    throw new CoercionError({\n        envelope\n    });\n}\n/**\n * Serializes a signature envelope to a hex-encoded string.\n *\n * Wire format:\n * - secp256k1: 65 bytes (no type prefix, for backward compatibility)\n * - P256: `0x01` + r (32) + s (32) + pubKeyX (32) + pubKeyY (32) + prehash (1) = 130 bytes\n * - WebAuthn: `0x02` + webauthnData (variable) + r (32) + s (32) + pubKeyX (32) + pubKeyY (32)\n * - Keychain: `0x03` + userAddress (20) + inner signature (recursive)\n *\n * [Signature Types](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction#signature-types)\n *\n * @example\n * ```ts twoslash\n * import { SignatureEnvelope } from 'ox/tempo'\n *\n * const serialized = SignatureEnvelope.serialize({\n *   signature: { r: 0n, s: 0n, yParity: 0 },\n *   type: 'secp256k1',\n * })\n * ```\n *\n * @param envelope - The signature envelope to serialize.\n * @returns The hex-encoded serialized signature.\n * @throws `CoercionError` if the envelope cannot be serialized.\n */ function serialize(envelope, options = {}) {\n    const type = getType(envelope);\n    // Backward compatibility: no type identifier for secp256k1\n    if (type === \"secp256k1\") {\n        const secp256k1 = envelope;\n        return _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.concat(_core_Signature_js__WEBPACK_IMPORTED_MODULE_0__.toHex(secp256k1.signature), options.magic ? magicBytes : \"0x\");\n    }\n    if (type === \"p256\") {\n        const p256 = envelope;\n        // Format: 1 byte (type) + 32 (r) + 32 (s) + 32 (pubKeyX) + 32 (pubKeyY) + 1 (prehash)\n        return _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.concat(serializedP256Type, _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(p256.signature.r, {\n            size: 32\n        }), _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(p256.signature.s, {\n            size: 32\n        }), _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(p256.publicKey.x, {\n            size: 32\n        }), _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(p256.publicKey.y, {\n            size: 32\n        }), _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(p256.prehash ? 1 : 0, {\n            size: 1\n        }), options.magic ? magicBytes : \"0x\");\n    }\n    if (type === \"webAuthn\") {\n        const webauthn = envelope;\n        // Format: 1 byte (type) + variable (authenticatorData || clientDataJSON) + 32 (r) + 32 (s) + 32 (pubKeyX) + 32 (pubKeyY)\n        const webauthnData = _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.concat(webauthn.metadata.authenticatorData, _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromString(webauthn.metadata.clientDataJSON));\n        return _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.concat(serializedWebAuthnType, webauthnData, _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(webauthn.signature.r, {\n            size: 32\n        }), _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(webauthn.signature.s, {\n            size: 32\n        }), _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(webauthn.publicKey.x, {\n            size: 32\n        }), _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(webauthn.publicKey.y, {\n            size: 32\n        }), options.magic ? magicBytes : \"0x\");\n    }\n    if (type === \"keychain\") {\n        const keychain = envelope;\n        return _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.concat(serializedKeychainType, keychain.userAddress, serialize(keychain.inner), options.magic ? magicBytes : \"0x\");\n    }\n    throw new CoercionError({\n        envelope\n    });\n}\n/**\n * Converts a signature envelope to RPC format.\n *\n * @example\n * ```ts twoslash\n * import { SignatureEnvelope } from 'ox/tempo'\n *\n * const rpc = SignatureEnvelope.toRpc({\n *   signature: { r: 0n, s: 0n, yParity: 0 },\n *   type: 'secp256k1',\n * })\n * ```\n *\n * @param envelope - The signature envelope to convert.\n * @returns The RPC signature envelope with hex values.\n */ function toRpc(envelope) {\n    const type = getType(envelope);\n    if (type === \"secp256k1\") {\n        const secp256k1 = envelope;\n        return {\n            ..._core_Signature_js__WEBPACK_IMPORTED_MODULE_0__.toRpc(secp256k1.signature),\n            type: \"secp256k1\"\n        };\n    }\n    if (type === \"p256\") {\n        const p256 = envelope;\n        return {\n            preHash: p256.prehash,\n            pubKeyX: _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(p256.publicKey.x, {\n                size: 32\n            }),\n            pubKeyY: _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(p256.publicKey.y, {\n                size: 32\n            }),\n            r: _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(p256.signature.r, {\n                size: 32\n            }),\n            s: _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(p256.signature.s, {\n                size: 32\n            }),\n            type: \"p256\"\n        };\n    }\n    if (type === \"webAuthn\") {\n        const webauthn = envelope;\n        const webauthnData = _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.concat(webauthn.metadata.authenticatorData, _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromString(webauthn.metadata.clientDataJSON));\n        return {\n            pubKeyX: _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(webauthn.publicKey.x, {\n                size: 32\n            }),\n            pubKeyY: _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(webauthn.publicKey.y, {\n                size: 32\n            }),\n            r: _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(webauthn.signature.r, {\n                size: 32\n            }),\n            s: _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(webauthn.signature.s, {\n                size: 32\n            }),\n            type: \"webAuthn\",\n            webauthnData\n        };\n    }\n    if (type === \"keychain\") {\n        const keychain = envelope;\n        return {\n            type: \"keychain\",\n            userAddress: keychain.userAddress,\n            signature: toRpc(keychain.inner)\n        };\n    }\n    throw new CoercionError({\n        envelope\n    });\n}\n/**\n * Validates a signature envelope. Returns `true` if the envelope is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { SignatureEnvelope } from 'ox/tempo'\n *\n * const valid = SignatureEnvelope.validate({\n *   signature: { r: 0n, s: 0n, yParity: 0 },\n *   type: 'secp256k1',\n * })\n * // @log: true\n * ```\n *\n * @param envelope - The signature envelope to validate.\n * @returns `true` if valid, `false` otherwise.\n */ function validate(envelope) {\n    try {\n        assert(envelope);\n        return true;\n    } catch  {\n        return false;\n    }\n}\n/**\n * Verifies a signature envelope against a digest/payload.\n *\n * Supports `secp256k1`, `p256`, and `webAuthn` signature types.\n *\n * :::warning\n * `keychain` signatures are not supported and will throw an error.\n * :::\n *\n * @example\n * ### Secp256k1\n *\n * ```ts twoslash\n * import { SignatureEnvelope } from 'ox/tempo'\n * import { Secp256k1 } from 'ox'\n *\n * const privateKey = Secp256k1.randomPrivateKey()\n * const publicKey = Secp256k1.getPublicKey({ privateKey })\n * const payload = '0xdeadbeef'\n *\n * const signature = Secp256k1.sign({ payload, privateKey })\n * const envelope = SignatureEnvelope.from(signature)\n *\n * const valid = SignatureEnvelope.verify(envelope, {\n *   payload,\n *   publicKey,\n * })\n * // @log: true\n * ```\n *\n * @example\n * ### P256\n *\n * For P256 signatures, the `address` or `publicKey` must match the embedded\n * public key in the signature envelope.\n *\n * ```ts twoslash\n * import { SignatureEnvelope } from 'ox/tempo'\n * import { P256 } from 'ox'\n *\n * const privateKey = P256.randomPrivateKey()\n * const publicKey = P256.getPublicKey({ privateKey })\n * const payload = '0xdeadbeef'\n *\n * const signature = P256.sign({ payload, privateKey })\n * const envelope = SignatureEnvelope.from({ prehash: false, publicKey, signature })\n *\n * const valid = SignatureEnvelope.verify(envelope, {\n *   payload,\n *   publicKey,\n * })\n * // @log: true\n * ```\n *\n * @example\n * ### WebCryptoP256\n *\n * ```ts twoslash\n * import { SignatureEnvelope } from 'ox/tempo'\n * import { WebCryptoP256 } from 'ox'\n *\n * const { privateKey, publicKey } = await WebCryptoP256.createKeyPair()\n * const payload = '0xdeadbeef'\n *\n * const signature = await WebCryptoP256.sign({ payload, privateKey })\n * const envelope = SignatureEnvelope.from({ prehash: true, publicKey, signature })\n *\n * const valid = SignatureEnvelope.verify(envelope, {\n *   payload,\n *   publicKey,\n * })\n * // @log: true\n * ```\n *\n * @example\n * ### WebAuthnP256\n *\n * ```ts twoslash\n * import { SignatureEnvelope } from 'ox/tempo'\n * import { WebAuthnP256 } from 'ox'\n *\n * const credential = await WebAuthnP256.createCredential({ name: 'Example' })\n * const payload = '0xdeadbeef'\n *\n * const { metadata, signature } = await WebAuthnP256.sign({\n *   challenge: payload,\n *   credentialId: credential.id,\n * })\n * const envelope = SignatureEnvelope.from({\n *   metadata,\n *   signature,\n *   publicKey: credential.publicKey,\n * })\n *\n * const valid = SignatureEnvelope.verify(envelope, {\n *   payload,\n *   publicKey: credential.publicKey,\n * })\n * // @log: true\n * ```\n *\n * @param parameters - Verification parameters.\n * @returns `true` if the signature is valid, `false` otherwise.\n */ function verify(signature, parameters) {\n    const { payload } = parameters;\n    const address = (()=>{\n        if (parameters.address) return parameters.address;\n        if (parameters.publicKey) return _core_Address_js__WEBPACK_IMPORTED_MODULE_2__.fromPublicKey(parameters.publicKey);\n        return undefined;\n    })();\n    if (!address) return false;\n    const envelope = from(signature);\n    if (envelope.type === \"secp256k1\") {\n        if (!address) return false;\n        return _core_Secp256k1_js__WEBPACK_IMPORTED_MODULE_3__.verify({\n            address,\n            payload,\n            signature: envelope.signature\n        });\n    }\n    if (envelope.type === \"p256\") {\n        const envelopeAddress = _core_Address_js__WEBPACK_IMPORTED_MODULE_2__.fromPublicKey(envelope.publicKey);\n        if (!_core_Address_js__WEBPACK_IMPORTED_MODULE_2__.isEqual(envelopeAddress, address)) return false;\n        return _core_P256_js__WEBPACK_IMPORTED_MODULE_4__.verify({\n            hash: envelope.prehash,\n            publicKey: envelope.publicKey,\n            payload,\n            signature: envelope.signature\n        });\n    }\n    if (envelope.type === \"webAuthn\") {\n        const envelopeAddress = _core_Address_js__WEBPACK_IMPORTED_MODULE_2__.fromPublicKey(envelope.publicKey);\n        if (!_core_Address_js__WEBPACK_IMPORTED_MODULE_2__.isEqual(envelopeAddress, address)) return false;\n        return _core_WebAuthnP256_js__WEBPACK_IMPORTED_MODULE_5__.verify({\n            challenge: _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.from(payload),\n            metadata: envelope.metadata,\n            publicKey: envelope.publicKey,\n            signature: envelope.signature\n        });\n    }\n    throw new VerificationError(`Unable to verify signature envelope of type \"${envelope.type}\".`);\n}\n/**\n * Error thrown when a signature envelope cannot be coerced to a valid type.\n */ class CoercionError extends _core_Errors_js__WEBPACK_IMPORTED_MODULE_6__.BaseError {\n    constructor({ envelope }){\n        super(`Unable to coerce value (\\`${_core_Json_js__WEBPACK_IMPORTED_MODULE_7__.stringify(envelope)}\\`) to a valid signature envelope.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"SignatureEnvelope.CoercionError\"\n        });\n    }\n}\n/**\n * Error thrown when a signature envelope is missing required properties.\n */ class MissingPropertiesError extends _core_Errors_js__WEBPACK_IMPORTED_MODULE_6__.BaseError {\n    constructor({ envelope, missing, type }){\n        super(`Signature envelope of type \"${type}\" is missing required properties: ${missing.map((m)=>`\\`${m}\\``).join(\", \")}.\\n\\nProvided: ${_core_Json_js__WEBPACK_IMPORTED_MODULE_7__.stringify(envelope)}`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"SignatureEnvelope.MissingPropertiesError\"\n        });\n    }\n}\n/**\n * Error thrown when a serialized signature envelope cannot be deserialized.\n */ class InvalidSerializedError extends _core_Errors_js__WEBPACK_IMPORTED_MODULE_6__.BaseError {\n    constructor({ reason, serialized }){\n        super(`Unable to deserialize signature envelope: ${reason}`, {\n            metaMessages: [\n                `Serialized: ${serialized}`\n            ]\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"SignatureEnvelope.InvalidSerializedError\"\n        });\n    }\n}\n/**\n * Error thrown when a signature envelope fails to verify.\n */ class VerificationError extends _core_Errors_js__WEBPACK_IMPORTED_MODULE_6__.BaseError {\n    constructor(){\n        super(...arguments);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"SignatureEnvelope.VerificationError\"\n        });\n    }\n} //# sourceMappingURL=SignatureEnvelope.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS90ZW1wby9TaWduYXR1cmVFbnZlbG9wZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE4QztBQUNGO0FBQ047QUFDRTtBQUNHO0FBQ1U7QUFDSDtBQUNTO0FBQzNELHFEQUFxRCxHQUNyRCxNQUFNUSxxQkFBcUI7QUFDM0IsTUFBTUMseUJBQXlCO0FBQy9CLE1BQU1DLHlCQUF5QjtBQUMvQiwrREFBK0QsR0FDeEQsTUFBTUMsYUFBYSxxRUFBcUUsQ0FBQyxVQUFVO0FBQzFHLHVDQUF1QyxHQUNoQyxNQUFNQyxRQUFRO0lBQUM7SUFBYTtJQUFRO0NBQVcsQ0FBQztBQUN2RDs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW1CQyxHQUNNLFNBQVNDLE9BQU9DLFFBQVE7SUFDM0IsTUFBTUMsT0FBT0MsUUFBUUY7SUFDckIsSUFBSUMsU0FBUyxhQUFhO1FBQ3RCLE1BQU1FLFlBQVlIO1FBQ2xCUixzREFBZ0IsQ0FBQ1csVUFBVUMsU0FBUztRQUNwQztJQUNKO0lBQ0EsSUFBSUgsU0FBUyxRQUFRO1FBQ2pCLE1BQU1JLE9BQU9MO1FBQ2IsTUFBTU0sVUFBVSxFQUFFO1FBQ2xCLElBQUksT0FBT0QsS0FBS0QsU0FBUyxFQUFFRyxNQUFNLFVBQzdCRCxRQUFRRSxJQUFJLENBQUM7UUFDakIsSUFBSSxPQUFPSCxLQUFLRCxTQUFTLEVBQUVLLE1BQU0sVUFDN0JILFFBQVFFLElBQUksQ0FBQztRQUNqQixJQUFJLE9BQU9ILEtBQUtLLE9BQU8sS0FBSyxXQUN4QkosUUFBUUUsSUFBSSxDQUFDO1FBQ2pCLElBQUksQ0FBQ0gsS0FBS00sU0FBUyxFQUNmTCxRQUFRRSxJQUFJLENBQUM7YUFDWjtZQUNELElBQUksT0FBT0gsS0FBS00sU0FBUyxDQUFDQyxDQUFDLEtBQUssVUFDNUJOLFFBQVFFLElBQUksQ0FBQztZQUNqQixJQUFJLE9BQU9ILEtBQUtNLFNBQVMsQ0FBQ0UsQ0FBQyxLQUFLLFVBQzVCUCxR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RCxPQUFPO1FBQ1g7SUFDSjtBQUNKO0FBQ0E7O0NBRUMsR0FDTSxNQUFNUywrQkFBK0I3QyxzREFBZ0I7SUFDeERzRixZQUFZLEVBQUV4QyxNQUFNLEVBQUVULFVBQVUsRUFBRyxDQUFFO1FBQ2pDLEtBQUssQ0FBQyxDQUFDLDBDQUEwQyxFQUFFUyxPQUFPLENBQUMsRUFBRTtZQUN6RGtELGNBQWM7Z0JBQUMsQ0FBQyxZQUFZLEVBQUUzRCxXQUFXLENBQUM7YUFBQztRQUMvQztRQUNBbUQsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxRQUFRO1lBQ2hDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWeEQsT0FBTztRQUNYO0lBQ0o7QUFDSjtBQUNBOztDQUVDLEdBQ00sTUFBTWdELDBCQUEwQnBGLHNEQUFnQjtJQUNuRHNGLGFBQWM7UUFDVixLQUFLLElBQUlXO1FBQ1RULE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsUUFBUTtZQUNoQ0MsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVnhELE9BQU87UUFDWDtJQUNKO0FBQ0osRUFDQSw2Q0FBNkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGF3LXdvcmtzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L19lc20vdGVtcG8vU2lnbmF0dXJlRW52ZWxvcGUuanM/YzI2NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBBZGRyZXNzIGZyb20gJy4uL2NvcmUvQWRkcmVzcy5qcyc7XG5pbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSAnLi4vY29yZS9FcnJvcnMuanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4uL2NvcmUvSGV4LmpzJztcbmltcG9ydCAqIGFzIEpzb24gZnJvbSAnLi4vY29yZS9Kc29uLmpzJztcbmltcG9ydCAqIGFzIG94X1AyNTYgZnJvbSAnLi4vY29yZS9QMjU2LmpzJztcbmltcG9ydCAqIGFzIG94X1NlY3AyNTZrMSBmcm9tICcuLi9jb3JlL1NlY3AyNTZrMS5qcyc7XG5pbXBvcnQgKiBhcyBTaWduYXR1cmUgZnJvbSAnLi4vY29yZS9TaWduYXR1cmUuanMnO1xuaW1wb3J0ICogYXMgb3hfV2ViQXV0aG5QMjU2IGZyb20gJy4uL2NvcmUvV2ViQXV0aG5QMjU2LmpzJztcbi8qKiBTaWduYXR1cmUgdHlwZSBpZGVudGlmaWVycyBmb3IgZW5jb2RpbmcvZGVjb2RpbmcgKi9cbmNvbnN0IHNlcmlhbGl6ZWRQMjU2VHlwZSA9ICcweDAxJztcbmNvbnN0IHNlcmlhbGl6ZWRXZWJBdXRoblR5cGUgPSAnMHgwMic7XG5jb25zdCBzZXJpYWxpemVkS2V5Y2hhaW5UeXBlID0gJzB4MDMnO1xuLyoqIFNlcmlhbGl6ZWQgbWFnaWMgaWRlbnRpZmllciBmb3IgVGVtcG8gc2lnbmF0dXJlIGVudmVsb3Blcy4gKi9cbmV4cG9ydCBjb25zdCBtYWdpY0J5dGVzID0gJzB4Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nyc7IC8vIDMyIFwiVFwic1xuLyoqIExpc3Qgb2Ygc3VwcG9ydGVkIHNpZ25hdHVyZSB0eXBlcy4gKi9cbmV4cG9ydCBjb25zdCB0eXBlcyA9IFsnc2VjcDI1NmsxJywgJ3AyNTYnLCAnd2ViQXV0aG4nXTtcbi8qKlxuICogQXNzZXJ0cyB0aGF0IGEge0BsaW5rIG94I1NpZ25hdHVyZUVudmVsb3BlLlNpZ25hdHVyZUVudmVsb3BlfSBpcyB2YWxpZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZUVudmVsb3BlIH0gZnJvbSAnb3gvdGVtcG8nXG4gKlxuICogU2lnbmF0dXJlRW52ZWxvcGUuYXNzZXJ0KHtcbiAqICAgdHlwZTogJ3NlY3AyNTZrMScsXG4gKiAgIHNpZ25hdHVyZToge1xuICogICAgIHI6IDBuLFxuICogICAgIHM6IDBuLFxuICogICAgIHlQYXJpdHk6IDAsXG4gKiAgIH0sXG4gKiB9KVxuICogYGBgXG4gKlxuICogQHBhcmFtIGVudmVsb3BlIC0gVGhlIHNpZ25hdHVyZSBlbnZlbG9wZSB0byBhc3NlcnQuXG4gKiBAdGhyb3dzIGBDb2VyY2lvbkVycm9yYCBpZiB0aGUgZW52ZWxvcGUgdHlwZSBjYW5ub3QgYmUgZGV0ZXJtaW5lZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydChlbnZlbG9wZSkge1xuICAgIGNvbnN0IHR5cGUgPSBnZXRUeXBlKGVudmVsb3BlKTtcbiAgICBpZiAodHlwZSA9PT0gJ3NlY3AyNTZrMScpIHtcbiAgICAgICAgY29uc3Qgc2VjcDI1NmsxID0gZW52ZWxvcGU7XG4gICAgICAgIFNpZ25hdHVyZS5hc3NlcnQoc2VjcDI1NmsxLnNpZ25hdHVyZSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09ICdwMjU2Jykge1xuICAgICAgICBjb25zdCBwMjU2ID0gZW52ZWxvcGU7XG4gICAgICAgIGNvbnN0IG1pc3NpbmcgPSBbXTtcbiAgICAgICAgaWYgKHR5cGVvZiBwMjU2LnNpZ25hdHVyZT8uciAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICBtaXNzaW5nLnB1c2goJ3NpZ25hdHVyZS5yJyk7XG4gICAgICAgIGlmICh0eXBlb2YgcDI1Ni5zaWduYXR1cmU/LnMgIT09ICdiaWdpbnQnKVxuICAgICAgICAgICAgbWlzc2luZy5wdXNoKCdzaWduYXR1cmUucycpO1xuICAgICAgICBpZiAodHlwZW9mIHAyNTYucHJlaGFzaCAhPT0gJ2Jvb2xlYW4nKVxuICAgICAgICAgICAgbWlzc2luZy5wdXNoKCdwcmVoYXNoJyk7XG4gICAgICAgIGlmICghcDI1Ni5wdWJsaWNLZXkpXG4gICAgICAgICAgICBtaXNzaW5nLnB1c2goJ3B1YmxpY0tleScpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcDI1Ni5wdWJsaWNLZXkueCAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICAgICAgbWlzc2luZy5wdXNoKCdwdWJsaWNLZXkueCcpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwMjU2LnB1YmxpY0tleS55ICE9PSAnYmlnaW50JylcbiAgICAgICAgICAgICAgICBtaXNzaW5nLnB1c2goJ3B1YmxpY0tleS55Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pc3NpbmcubGVuZ3RoID4gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBNaXNzaW5nUHJvcGVydGllc0Vycm9yKHsgZW52ZWxvcGUsIG1pc3NpbmcsIHR5cGU6ICdwMjU2JyB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ3dlYkF1dGhuJykge1xuICAgICAgICBjb25zdCB3ZWJhdXRobiA9IGVudmVsb3BlO1xuICAgICAgICBjb25zdCBtaXNzaW5nID0gW107XG4gICAgICAgIGlmICh0eXBlb2Ygd2ViYXV0aG4uc2lnbmF0dXJlPy5yICE9PSAnYmlnaW50JylcbiAgICAgICAgICAgIG1pc3NpbmcucHVzaCgnc2lnbmF0dXJlLnInKTtcbiAgICAgICAgaWYgKHR5cGVvZiB3ZWJhdXRobi5zaWduYXR1cmU/LnMgIT09ICdiaWdpbnQnKVxuICAgICAgICAgICAgbWlzc2luZy5wdXNoKCdzaWduYXR1cmUucycpO1xuICAgICAgICBpZiAoIXdlYmF1dGhuLm1ldGFkYXRhKVxuICAgICAgICAgICAgbWlzc2luZy5wdXNoKCdtZXRhZGF0YScpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghd2ViYXV0aG4ubWV0YWRhdGEuYXV0aGVudGljYXRvckRhdGEpXG4gICAgICAgICAgICAgICAgbWlzc2luZy5wdXNoKCdtZXRhZGF0YS5hdXRoZW50aWNhdG9yRGF0YScpO1xuICAgICAgICAgICAgaWYgKCF3ZWJhdXRobi5tZXRhZGF0YS5jbGllbnREYXRhSlNPTilcbiAgICAgICAgICAgICAgICBtaXNzaW5nLnB1c2goJ21ldGFkYXRhLmNsaWVudERhdGFKU09OJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF3ZWJhdXRobi5wdWJsaWNLZXkpXG4gICAgICAgICAgICBtaXNzaW5nLnB1c2goJ3B1YmxpY0tleScpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2ViYXV0aG4ucHVibGljS2V5LnggIT09ICdiaWdpbnQnKVxuICAgICAgICAgICAgICAgIG1pc3NpbmcucHVzaCgncHVibGljS2V5LngnKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2ViYXV0aG4ucHVibGljS2V5LnkgIT09ICdiaWdpbnQnKVxuICAgICAgICAgICAgICAgIG1pc3NpbmcucHVzaCgncHVibGljS2V5LnknKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWlzc2luZy5sZW5ndGggPiAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IE1pc3NpbmdQcm9wZXJ0aWVzRXJyb3IoeyBlbnZlbG9wZSwgbWlzc2luZywgdHlwZTogJ3dlYkF1dGhuJyB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ2tleWNoYWluJykge1xuICAgICAgICBjb25zdCBrZXljaGFpbiA9IGVudmVsb3BlO1xuICAgICAgICBhc3NlcnQoa2V5Y2hhaW4uaW5uZXIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxufVxuLyoqXG4gKiBEZXNlcmlhbGl6ZXMgYSBoZXgtZW5jb2RlZCBzaWduYXR1cmUgZW52ZWxvcGUgaW50byBhIHR5cGVkIHNpZ25hdHVyZSBvYmplY3QuXG4gKlxuICogV2lyZSBmb3JtYXQgZGV0ZWN0aW9uOlxuICogLSA2NSBieXRlcyAobm8gcHJlZml4KTogc2VjcDI1NmsxIHNpZ25hdHVyZVxuICogLSBUeXBlIGAweDAxYCArIDEyOSBieXRlczogUDI1NiBzaWduYXR1cmUgKHIsIHMsIHB1YktleVgsIHB1YktleVksIHByZWhhc2gpXG4gKiAtIFR5cGUgYDB4MDJgICsgdmFyaWFibGU6IFdlYkF1dGhuIHNpZ25hdHVyZSAod2ViYXV0aG5EYXRhLCByLCBzLCBwdWJLZXlYLCBwdWJLZXlZKVxuICogLSBUeXBlIGAweDAzYCArIDIwIGJ5dGVzICsgaW5uZXI6IEtleWNoYWluIHNpZ25hdHVyZSAodXNlckFkZHJlc3MgKyBpbm5lciBzaWduYXR1cmUpXG4gKlxuICogW1NpZ25hdHVyZSBUeXBlc10oaHR0cHM6Ly9kb2NzLnRlbXBvLnh5ei9wcm90b2NvbC90cmFuc2FjdGlvbnMvc3BlYy10ZW1wby10cmFuc2FjdGlvbiNzaWduYXR1cmUtdHlwZXMpXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmVFbnZlbG9wZSB9IGZyb20gJ294L3RlbXBvJ1xuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gU2lnbmF0dXJlRW52ZWxvcGUuZGVzZXJpYWxpemUoJzB4Li4uJylcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzZXJpYWxpemVkIC0gVGhlIGhleC1lbmNvZGVkIHNpZ25hdHVyZSBlbnZlbG9wZSB0byBkZXNlcmlhbGl6ZS5cbiAqIEByZXR1cm5zIFRoZSBkZXNlcmlhbGl6ZWQgc2lnbmF0dXJlIGVudmVsb3BlLlxuICogQHRocm93cyBgQ29lcmNpb25FcnJvcmAgaWYgdGhlIHNlcmlhbGl6ZWQgdmFsdWUgY2Fubm90IGJlIGNvZXJjZWQgdG8gYSB2YWxpZCBzaWduYXR1cmUgZW52ZWxvcGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXNlcmlhbGl6ZSh2YWx1ZSkge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSB2YWx1ZS5lbmRzV2l0aChtYWdpY0J5dGVzLnNsaWNlKDIpKVxuICAgICAgICA/IEhleC5zbGljZSh2YWx1ZSwgMCwgLUhleC5zaXplKG1hZ2ljQnl0ZXMpKVxuICAgICAgICA6IHZhbHVlO1xuICAgIGNvbnN0IHNpemUgPSBIZXguc2l6ZShzZXJpYWxpemVkKTtcbiAgICAvLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5OiA2NSBieXRlcyBtZWFucyBzZWNwMjU2azEgd2l0aG91dCB0eXBlIGlkZW50aWZpZXJcbiAgICBpZiAoc2l6ZSA9PT0gNjUpIHtcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gU2lnbmF0dXJlLmZyb21IZXgoc2VyaWFsaXplZCk7XG4gICAgICAgIFNpZ25hdHVyZS5hc3NlcnQoc2lnbmF0dXJlKTtcbiAgICAgICAgcmV0dXJuIHsgc2lnbmF0dXJlLCB0eXBlOiAnc2VjcDI1NmsxJyB9O1xuICAgIH1cbiAgICAvLyBGb3IgYWxsIG90aGVyIGxlbmd0aHMsIGZpcnN0IGJ5dGUgaXMgdGhlIHR5cGUgaWRlbnRpZmllclxuICAgIGNvbnN0IHR5cGVJZCA9IEhleC5zbGljZShzZXJpYWxpemVkLCAwLCAxKTtcbiAgICBjb25zdCBkYXRhID0gSGV4LnNsaWNlKHNlcmlhbGl6ZWQsIDEpO1xuICAgIGNvbnN0IGRhdGFTaXplID0gSGV4LnNpemUoZGF0YSk7XG4gICAgaWYgKHR5cGVJZCA9PT0gc2VyaWFsaXplZFAyNTZUeXBlKSB7XG4gICAgICAgIC8vIFAyNTY6IDMyIChyKSArIDMyIChzKSArIDMyIChwdWJLZXlYKSArIDMyIChwdWJLZXlZKSArIDEgKHByZWhhc2gpID0gMTI5IGJ5dGVzXG4gICAgICAgIGlmIChkYXRhU2l6ZSAhPT0gMTI5KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRTZXJpYWxpemVkRXJyb3Ioe1xuICAgICAgICAgICAgICAgIHJlYXNvbjogYEludmFsaWQgUDI1NiBzaWduYXR1cmUgZW52ZWxvcGUgc2l6ZTogZXhwZWN0ZWQgMTI5IGJ5dGVzLCBnb3QgJHtkYXRhU2l6ZX0gYnl0ZXNgLFxuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHB1YmxpY0tleToge1xuICAgICAgICAgICAgICAgIHByZWZpeDogNCxcbiAgICAgICAgICAgICAgICB4OiBIZXgudG9CaWdJbnQoSGV4LnNsaWNlKGRhdGEsIDY0LCA5NikpLFxuICAgICAgICAgICAgICAgIHk6IEhleC50b0JpZ0ludChIZXguc2xpY2UoZGF0YSwgOTYsIDEyOCkpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByZWhhc2g6IEhleC50b051bWJlcihIZXguc2xpY2UoZGF0YSwgMTI4LCAxMjkpKSAhPT0gMCxcbiAgICAgICAgICAgIHNpZ25hdHVyZToge1xuICAgICAgICAgICAgICAgIHI6IEhleC50b0JpZ0ludChIZXguc2xpY2UoZGF0YSwgMCwgMzIpKSxcbiAgICAgICAgICAgICAgICBzOiBIZXgudG9CaWdJbnQoSGV4LnNsaWNlKGRhdGEsIDMyLCA2NCkpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHR5cGU6ICdwMjU2JyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVJZCA9PT0gc2VyaWFsaXplZFdlYkF1dGhuVHlwZSkge1xuICAgICAgICAvLyBXZWJBdXRobjogdmFyaWFibGUgKHdlYmF1dGhuRGF0YSkgKyAzMiAocikgKyAzMiAocykgKyAzMiAocHViS2V5WCkgKyAzMiAocHViS2V5WSlcbiAgICAgICAgLy8gTWluaW11bTogMTI4IGJ5dGVzIChhdCBsZWFzdCBzb21lIGF1dGhlbnRpY2F0b3IgZGF0YSArIHNpZ25hdHVyZSBjb21wb25lbnRzKVxuICAgICAgICBpZiAoZGF0YVNpemUgPCAxMjgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFNlcmlhbGl6ZWRFcnJvcih7XG4gICAgICAgICAgICAgICAgcmVhc29uOiBgSW52YWxpZCBXZWJBdXRobiBzaWduYXR1cmUgZW52ZWxvcGUgc2l6ZTogZXhwZWN0ZWQgYXQgbGVhc3QgMTI4IGJ5dGVzLCBnb3QgJHtkYXRhU2l6ZX0gYnl0ZXNgLFxuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgd2ViYXV0aG5EYXRhU2l6ZSA9IGRhdGFTaXplIC0gMTI4O1xuICAgICAgICBjb25zdCB3ZWJhdXRobkRhdGEgPSBIZXguc2xpY2UoZGF0YSwgMCwgd2ViYXV0aG5EYXRhU2l6ZSk7XG4gICAgICAgIC8vIFBhcnNlIHdlYmF1dGhuRGF0YSBpbnRvIGF1dGhlbnRpY2F0b3JEYXRhIGFuZCBjbGllbnREYXRhSlNPTlxuICAgICAgICAvLyBBY2NvcmRpbmcgdG8gdGhlIFJ1c3QgY29kZSwgaXQncyBhdXRoZW50aWNhdG9yRGF0YSB8fCBjbGllbnREYXRhSlNPTlxuICAgICAgICAvLyBXZSBuZWVkIHRvIGZpbmQgdGhlIHNwbGl0IHBvaW50IChtaW5pbXVtIGF1dGhlbnRpY2F0b3JEYXRhIGlzIDM3IGJ5dGVzKVxuICAgICAgICBsZXQgYXV0aGVudGljYXRvckRhdGE7XG4gICAgICAgIGxldCBjbGllbnREYXRhSlNPTjtcbiAgICAgICAgLy8gVHJ5IHRvIGZpbmQgdGhlIEpTT04gc3RhcnQgKGNsaWVudERhdGFKU09OIHNob3VsZCBzdGFydCB3aXRoICd7JylcbiAgICAgICAgZm9yIChsZXQgc3BsaXQgPSAzNzsgc3BsaXQgPCB3ZWJhdXRobkRhdGFTaXplOyBzcGxpdCsrKSB7XG4gICAgICAgICAgICBjb25zdCBwb3RlbnRpYWxKc29uID0gSGV4LnRvU3RyaW5nKEhleC5zbGljZSh3ZWJhdXRobkRhdGEsIHNwbGl0KSk7XG4gICAgICAgICAgICBpZiAocG90ZW50aWFsSnNvbi5zdGFydHNXaXRoKCd7JykgJiYgcG90ZW50aWFsSnNvbi5lbmRzV2l0aCgnfScpKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgSlNPTi5wYXJzZShwb3RlbnRpYWxKc29uKTtcbiAgICAgICAgICAgICAgICAgICAgYXV0aGVudGljYXRvckRhdGEgPSBIZXguc2xpY2Uod2ViYXV0aG5EYXRhLCAwLCBzcGxpdCk7XG4gICAgICAgICAgICAgICAgICAgIGNsaWVudERhdGFKU09OID0gcG90ZW50aWFsSnNvbjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIHsgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghYXV0aGVudGljYXRvckRhdGEgfHwgIWNsaWVudERhdGFKU09OKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRTZXJpYWxpemVkRXJyb3Ioe1xuICAgICAgICAgICAgICAgIHJlYXNvbjogJ1VuYWJsZSB0byBwYXJzZSBXZWJBdXRobiBtZXRhZGF0YTogY291bGQgbm90IGV4dHJhY3QgdmFsaWQgYXV0aGVudGljYXRvckRhdGEgYW5kIGNsaWVudERhdGFKU09OJyxcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwdWJsaWNLZXk6IHtcbiAgICAgICAgICAgICAgICBwcmVmaXg6IDQsXG4gICAgICAgICAgICAgICAgeDogSGV4LnRvQmlnSW50KEhleC5zbGljZShkYXRhLCB3ZWJhdXRobkRhdGFTaXplICsgNjQsIHdlYmF1dGhuRGF0YVNpemUgKyA5NikpLFxuICAgICAgICAgICAgICAgIHk6IEhleC50b0JpZ0ludChIZXguc2xpY2UoZGF0YSwgd2ViYXV0aG5EYXRhU2l6ZSArIDk2LCB3ZWJhdXRobkRhdGFTaXplICsgMTI4KSksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgICAgICBhdXRoZW50aWNhdG9yRGF0YSxcbiAgICAgICAgICAgICAgICBjbGllbnREYXRhSlNPTixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzaWduYXR1cmU6IHtcbiAgICAgICAgICAgICAgICByOiBIZXgudG9CaWdJbnQoSGV4LnNsaWNlKGRhdGEsIHdlYmF1dGhuRGF0YVNpemUsIHdlYmF1dGhuRGF0YVNpemUgKyAzMikpLFxuICAgICAgICAgICAgICAgIHM6IEhleC50b0JpZ0ludChIZXguc2xpY2UoZGF0YSwgd2ViYXV0aG5EYXRhU2l6ZSArIDMyLCB3ZWJhdXRobkRhdGFTaXplICsgNjQpKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0eXBlOiAnd2ViQXV0aG4nLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAodHlwZUlkID09PSBzZXJpYWxpemVkS2V5Y2hhaW5UeXBlKSB7XG4gICAgICAgIGNvbnN0IHVzZXJBZGRyZXNzID0gSGV4LnNsaWNlKGRhdGEsIDAsIDIwKTtcbiAgICAgICAgY29uc3QgaW5uZXIgPSBkZXNlcmlhbGl6ZShIZXguc2xpY2UoZGF0YSwgMjApKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVzZXJBZGRyZXNzLFxuICAgICAgICAgICAgaW5uZXIsXG4gICAgICAgICAgICB0eXBlOiAna2V5Y2hhaW4nLFxuICAgICAgICB9O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgSW52YWxpZFNlcmlhbGl6ZWRFcnJvcih7XG4gICAgICAgIHJlYXNvbjogYFVua25vd24gc2lnbmF0dXJlIHR5cGUgaWRlbnRpZmllcjogJHt0eXBlSWR9LiBFeHBlY3RlZCAke3NlcmlhbGl6ZWRQMjU2VHlwZX0gKFAyNTYpIG9yICR7c2VyaWFsaXplZFdlYkF1dGhuVHlwZX0gKFdlYkF1dGhuKWAsXG4gICAgICAgIHNlcmlhbGl6ZWQsXG4gICAgfSk7XG59XG4vKipcbiAqIENvZXJjZXMgYSB2YWx1ZSB0byBhIHNpZ25hdHVyZSBlbnZlbG9wZS5cbiAqXG4gKiBBY2NlcHRzIGVpdGhlciBhIHNlcmlhbGl6ZWQgaGV4IHN0cmluZyBvciBhbiBleGlzdGluZyBzaWduYXR1cmUgZW52ZWxvcGUgb2JqZWN0LlxuICogVXNlIHRoaXMgdG8gd3JhcCByYXcgc2lnbmF0dXJlcyBmcm9tIHtAbGluayBveCNTZWNwMjU2azEuKHNpZ246ZnVuY3Rpb24pfSwge0BsaW5rIG94I1AyNTYuKHNpZ246ZnVuY3Rpb24pfSxcbiAqIHtAbGluayBveCNXZWJDcnlwdG9QMjU2LihzaWduOmZ1bmN0aW9uKX0sIG9yIHtAbGluayBveCNXZWJBdXRoblAyNTYuKHNpZ246ZnVuY3Rpb24pfSBpbnRvIHRoZSBlbnZlbG9wZSBmb3JtYXRcbiAqIHJlcXVpcmVkIGJ5IFRlbXBvIHRyYW5zYWN0aW9ucy5cbiAqXG4gKiBbU2lnbmF0dXJlIFR5cGVzXShodHRwczovL2RvY3MudGVtcG8ueHl6L3Byb3RvY29sL3RyYW5zYWN0aW9ucy9zcGVjLXRlbXBvLXRyYW5zYWN0aW9uI3NpZ25hdHVyZS10eXBlcylcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIFNlY3AyNTZrMVxuICpcbiAqIFN0YW5kYXJkIEV0aGVyZXVtIEVDRFNBIHNpZ25hdHVyZSB1c2luZyB0aGUgc2VjcDI1NmsxIGN1cnZlLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEgfSBmcm9tICdveCdcbiAqIGltcG9ydCB7IFNpZ25hdHVyZUVudmVsb3BlIH0gZnJvbSAnb3gvdGVtcG8nXG4gKlxuICogY29uc3QgcHJpdmF0ZUtleSA9IFNlY3AyNTZrMS5yYW5kb21Qcml2YXRlS2V5KClcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHsgcGF5bG9hZDogJzB4ZGVhZGJlZWYnLCBwcml2YXRlS2V5IH0pXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBTaWduYXR1cmVFbnZlbG9wZS5mcm9tKHNpZ25hdHVyZSlcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgUDI1NlxuICpcbiAqIEVDRFNBIHNpZ25hdHVyZSB1c2luZyB0aGUgUC0yNTYgKHNlY3AyNTZyMSkgY3VydmUuIFJlcXVpcmVzIGVtYmVkZGluZyB0aGVcbiAqIHB1YmxpYyBrZXkuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFAyNTYgfSBmcm9tICdveCdcbiAqIGltcG9ydCB7IFNpZ25hdHVyZUVudmVsb3BlIH0gZnJvbSAnb3gvdGVtcG8nXG4gKlxuICogY29uc3QgeyBwcml2YXRlS2V5LCBwdWJsaWNLZXkgfSA9IFAyNTYuY3JlYXRlS2V5UGFpcigpXG4gKiBjb25zdCBzaWduYXR1cmUgPSBQMjU2LnNpZ24oeyBwYXlsb2FkOiAnMHhkZWFkYmVlZicsIHByaXZhdGVLZXkgfSlcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFNpZ25hdHVyZUVudmVsb3BlLmZyb20oe1xuICogICBzaWduYXR1cmUsXG4gKiAgIHB1YmxpY0tleSxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIFAyNTYgKFdlYkNyeXB0bylcbiAqXG4gKiBXaGVuIHVzaW5nIFdlYkNyeXB0byBrZXlzLCBgcHJlaGFzaGAgbXVzdCBiZSBgdHJ1ZWAgc2luY2UgV2ViQ3J5cHRvIGFsd2F5c1xuICogU0hBMjU2IGhhc2hlcyB0aGUgZGlnZXN0IGJlZm9yZSBzaWduaW5nLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IFdlYkNyeXB0b1AyNTYgfSBmcm9tICdveCdcbiAqIGltcG9ydCB7IFNpZ25hdHVyZUVudmVsb3BlIH0gZnJvbSAnb3gvdGVtcG8nXG4gKlxuICogY29uc3QgeyBwcml2YXRlS2V5LCBwdWJsaWNLZXkgfSA9IGF3YWl0IFdlYkNyeXB0b1AyNTYuY3JlYXRlS2V5UGFpcigpXG4gKiBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBXZWJDcnlwdG9QMjU2LnNpZ24oeyBwYXlsb2FkOiAnMHhkZWFkYmVlZicsIHByaXZhdGVLZXkgfSlcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFNpZ25hdHVyZUVudmVsb3BlLmZyb20oe1xuICogICBzaWduYXR1cmUsXG4gKiAgIHB1YmxpY0tleSxcbiAqICAgcHJlaGFzaDogdHJ1ZSxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIFdlYkF1dGhuXG4gKlxuICogUGFzc2tleS1iYXNlZCBzaWduYXR1cmUgdXNpbmcgV2ViQXV0aG4uIEluY2x1ZGVzIGF1dGhlbnRpY2F0b3IgbWV0YWRhdGFcbiAqIChhdXRoZW50aWNhdG9yRGF0YSBhbmQgY2xpZW50RGF0YUpTT04pIGFsb25nIHdpdGggdGhlIFAtMjU2IHNpZ25hdHVyZSBhbmRcbiAqIHB1YmxpYyBrZXkuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgV2ViQXV0aG5QMjU2IH0gZnJvbSAnb3gnXG4gKiBpbXBvcnQgeyBTaWduYXR1cmVFbnZlbG9wZSB9IGZyb20gJ294L3RlbXBvJ1xuICpcbiAqIGNvbnN0IGNyZWRlbnRpYWwgPSBhd2FpdCBXZWJBdXRoblAyNTYuY3JlYXRlQ3JlZGVudGlhbCh7XG4gKiAgIG5hbWU6ICdFeGFtcGxlJyxcbiAqIH0pXG4gKlxuICogY29uc3QgeyBtZXRhZGF0YSwgc2lnbmF0dXJlIH0gPSBhd2FpdCBXZWJBdXRoblAyNTYuc2lnbih7XG4gKiAgIGNoYWxsZW5nZTogJzB4ZGVhZGJlZWYnLFxuICogICBjcmVkZW50aWFsSWQ6IGNyZWRlbnRpYWwuaWQsXG4gKiB9KVxuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gU2lnbmF0dXJlRW52ZWxvcGUuZnJvbSh7XG4gKiAgIHNpZ25hdHVyZSxcbiAqICAgcHVibGljS2V5OiBjcmVkZW50aWFsLnB1YmxpY0tleSxcbiAqICAgbWV0YWRhdGEsXG4gKiB9KVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBLZXljaGFpblxuICpcbiAqIFdyYXBzIGFub3RoZXIgc2lnbmF0dXJlIHR5cGUgd2l0aCBhIHVzZXIgYWRkcmVzcywgdXNlZCBmb3IgZGVsZWdhdGVkIHNpZ25pbmdcbiAqIHZpYSBhY2Nlc3Mga2V5cyBvbiBiZWhhbGYgb2YgYSByb290IGFjY291bnQuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNlY3AyNTZrMSB9IGZyb20gJ294J1xuICogaW1wb3J0IHsgU2lnbmF0dXJlRW52ZWxvcGUgfSBmcm9tICdveC90ZW1wbydcbiAqXG4gKiBjb25zdCBwcml2YXRlS2V5ID0gU2VjcDI1NmsxLnJhbmRvbVByaXZhdGVLZXkoKVxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oeyBwYXlsb2FkOiAnMHhkZWFkYmVlZicsIHByaXZhdGVLZXkgfSlcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFNpZ25hdHVyZUVudmVsb3BlLmZyb20oe1xuICogICB1c2VyQWRkcmVzczogJzB4MTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MCcsXG4gKiAgIGlubmVyOiBTaWduYXR1cmVFbnZlbG9wZS5mcm9tKHNpZ25hdHVyZSksXG4gKiB9KVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNvZXJjZSAoZWl0aGVyIGEgaGV4IHN0cmluZyBvciBzaWduYXR1cmUgZW52ZWxvcGUpLlxuICogQHJldHVybnMgVGhlIHNpZ25hdHVyZSBlbnZlbG9wZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb20odmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIGRlc2VyaWFsaXplKHZhbHVlKTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICB2YWx1ZSAhPT0gbnVsbCAmJlxuICAgICAgICAncicgaW4gdmFsdWUgJiZcbiAgICAgICAgJ3MnIGluIHZhbHVlICYmXG4gICAgICAgICd5UGFyaXR5JyBpbiB2YWx1ZSlcbiAgICAgICAgcmV0dXJuIHsgc2lnbmF0dXJlOiB2YWx1ZSwgdHlwZTogJ3NlY3AyNTZrMScgfTtcbiAgICBjb25zdCB0eXBlID0gZ2V0VHlwZSh2YWx1ZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4udmFsdWUsXG4gICAgICAgIC4uLih0eXBlID09PSAncDI1NicgPyB7IHByZWhhc2g6IHZhbHVlLnByZWhhc2ggfSA6IHt9KSxcbiAgICAgICAgdHlwZSxcbiAgICB9O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiBSUEMtZm9ybWF0dGVkIHNpZ25hdHVyZSBlbnZlbG9wZSB0byBhIHR5cGVkIHNpZ25hdHVyZSBlbnZlbG9wZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZUVudmVsb3BlIH0gZnJvbSAnb3gvdGVtcG8nXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBTaWduYXR1cmVFbnZlbG9wZS5mcm9tUnBjKHtcbiAqICAgcjogJzB4MCcsXG4gKiAgIHM6ICcweDAnLFxuICogICB5UGFyaXR5OiAnMHgwJyxcbiAqICAgdHlwZTogJ3NlY3AyNTZrMScsXG4gKiB9KVxuICogYGBgXG4gKlxuICogQHBhcmFtIGVudmVsb3BlIC0gVGhlIFJQQyBzaWduYXR1cmUgZW52ZWxvcGUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSBzaWduYXR1cmUgZW52ZWxvcGUgd2l0aCBiaWdpbnQgdmFsdWVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJwYyhlbnZlbG9wZSkge1xuICAgIGlmIChlbnZlbG9wZS50eXBlID09PSAnc2VjcDI1NmsxJylcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNpZ25hdHVyZTogU2lnbmF0dXJlLmZyb21ScGMoZW52ZWxvcGUpLFxuICAgICAgICAgICAgdHlwZTogJ3NlY3AyNTZrMScsXG4gICAgICAgIH07XG4gICAgaWYgKGVudmVsb3BlLnR5cGUgPT09ICdwMjU2Jykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJlaGFzaDogZW52ZWxvcGUucHJlSGFzaCxcbiAgICAgICAgICAgIHB1YmxpY0tleToge1xuICAgICAgICAgICAgICAgIHByZWZpeDogNCxcbiAgICAgICAgICAgICAgICB4OiBIZXgudG9CaWdJbnQoZW52ZWxvcGUucHViS2V5WCksXG4gICAgICAgICAgICAgICAgeTogSGV4LnRvQmlnSW50KGVudmVsb3BlLnB1YktleVkpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNpZ25hdHVyZToge1xuICAgICAgICAgICAgICAgIHI6IEhleC50b0JpZ0ludChlbnZlbG9wZS5yKSxcbiAgICAgICAgICAgICAgICBzOiBIZXgudG9CaWdJbnQoZW52ZWxvcGUucyksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHlwZTogJ3AyNTYnLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoZW52ZWxvcGUudHlwZSA9PT0gJ3dlYkF1dGhuJykge1xuICAgICAgICBjb25zdCB3ZWJhdXRobkRhdGEgPSBlbnZlbG9wZS53ZWJhdXRobkRhdGE7XG4gICAgICAgIGNvbnN0IHdlYmF1dGhuRGF0YVNpemUgPSBIZXguc2l6ZSh3ZWJhdXRobkRhdGEpO1xuICAgICAgICAvLyBQYXJzZSB3ZWJhdXRobkRhdGEgaW50byBhdXRoZW50aWNhdG9yRGF0YSBhbmQgY2xpZW50RGF0YUpTT05cbiAgICAgICAgbGV0IGF1dGhlbnRpY2F0b3JEYXRhO1xuICAgICAgICBsZXQgY2xpZW50RGF0YUpTT047XG4gICAgICAgIC8vIFRyeSB0byBmaW5kIHRoZSBKU09OIHN0YXJ0IChjbGllbnREYXRhSlNPTiBzaG91bGQgc3RhcnQgd2l0aCAneycpXG4gICAgICAgIGZvciAobGV0IHNwbGl0ID0gMzc7IHNwbGl0IDwgd2ViYXV0aG5EYXRhU2l6ZTsgc3BsaXQrKykge1xuICAgICAgICAgICAgY29uc3QgcG90ZW50aWFsSnNvbiA9IEhleC50b1N0cmluZyhIZXguc2xpY2Uod2ViYXV0aG5EYXRhLCBzcGxpdCkpO1xuICAgICAgICAgICAgaWYgKHBvdGVudGlhbEpzb24uc3RhcnRzV2l0aCgneycpICYmIHBvdGVudGlhbEpzb24uZW5kc1dpdGgoJ30nKSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIEpTT04ucGFyc2UocG90ZW50aWFsSnNvbik7XG4gICAgICAgICAgICAgICAgICAgIGF1dGhlbnRpY2F0b3JEYXRhID0gSGV4LnNsaWNlKHdlYmF1dGhuRGF0YSwgMCwgc3BsaXQpO1xuICAgICAgICAgICAgICAgICAgICBjbGllbnREYXRhSlNPTiA9IHBvdGVudGlhbEpzb247XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCB7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWF1dGhlbnRpY2F0b3JEYXRhIHx8ICFjbGllbnREYXRhSlNPTilcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkU2VyaWFsaXplZEVycm9yKHtcbiAgICAgICAgICAgICAgICByZWFzb246ICdVbmFibGUgdG8gcGFyc2UgV2ViQXV0aG4gbWV0YWRhdGE6IGNvdWxkIG5vdCBleHRyYWN0IHZhbGlkIGF1dGhlbnRpY2F0b3JEYXRhIGFuZCBjbGllbnREYXRhSlNPTicsXG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZDogd2ViYXV0aG5EYXRhLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgICAgIGF1dGhlbnRpY2F0b3JEYXRhLFxuICAgICAgICAgICAgICAgIGNsaWVudERhdGFKU09OLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHB1YmxpY0tleToge1xuICAgICAgICAgICAgICAgIHByZWZpeDogNCxcbiAgICAgICAgICAgICAgICB4OiBIZXgudG9CaWdJbnQoZW52ZWxvcGUucHViS2V5WCksXG4gICAgICAgICAgICAgICAgeTogSGV4LnRvQmlnSW50KGVudmVsb3BlLnB1YktleVkpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNpZ25hdHVyZToge1xuICAgICAgICAgICAgICAgIHI6IEhleC50b0JpZ0ludChlbnZlbG9wZS5yKSxcbiAgICAgICAgICAgICAgICBzOiBIZXgudG9CaWdJbnQoZW52ZWxvcGUucyksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHlwZTogJ3dlYkF1dGhuJyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGVudmVsb3BlLnR5cGUgPT09ICdrZXljaGFpbicgfHxcbiAgICAgICAgKCd1c2VyQWRkcmVzcycgaW4gZW52ZWxvcGUgJiYgJ3NpZ25hdHVyZScgaW4gZW52ZWxvcGUpKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2tleWNoYWluJyxcbiAgICAgICAgICAgIHVzZXJBZGRyZXNzOiBlbnZlbG9wZS51c2VyQWRkcmVzcyxcbiAgICAgICAgICAgIGlubmVyOiBmcm9tUnBjKGVudmVsb3BlLnNpZ25hdHVyZSksXG4gICAgICAgIH07XG4gICAgdGhyb3cgbmV3IENvZXJjaW9uRXJyb3IoeyBlbnZlbG9wZSB9KTtcbn1cbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgc2lnbmF0dXJlIHR5cGUgb2YgYW4gZW52ZWxvcGUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmVFbnZlbG9wZSB9IGZyb20gJ294L3RlbXBvJ1xuICpcbiAqIGNvbnN0IHR5cGUgPSBTaWduYXR1cmVFbnZlbG9wZS5nZXRUeXBlKHtcbiAqICAgc2lnbmF0dXJlOiB7IHI6IDBuLCBzOiAwbiwgeVBhcml0eTogMCB9LFxuICogfSlcbiAqIC8vIEBsb2c6ICdzZWNwMjU2azEnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZW52ZWxvcGUgLSBUaGUgc2lnbmF0dXJlIGVudmVsb3BlIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyBUaGUgc2lnbmF0dXJlIHR5cGUgKCdzZWNwMjU2azEnLCAncDI1NicsIG9yICd3ZWJBdXRobicpLlxuICogQHRocm93cyBgQ29lcmNpb25FcnJvcmAgaWYgdGhlIGVudmVsb3BlIHR5cGUgY2Fubm90IGJlIGRldGVybWluZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRUeXBlKGVudmVsb3BlKSB7XG4gICAgaWYgKHR5cGVvZiBlbnZlbG9wZSAhPT0gJ29iamVjdCcgfHwgZW52ZWxvcGUgPT09IG51bGwpXG4gICAgICAgIHRocm93IG5ldyBDb2VyY2lvbkVycm9yKHsgZW52ZWxvcGUgfSk7XG4gICAgaWYgKCd0eXBlJyBpbiBlbnZlbG9wZSAmJiBlbnZlbG9wZS50eXBlKVxuICAgICAgICByZXR1cm4gZW52ZWxvcGUudHlwZTtcbiAgICAvLyBEZXRlY3Qgc2VjcDI1NmsxIHNpZ25hdHVyZSAoYmFja3dhcmRzIGNvbXBhdGliaWxpdHk6IGFsc28gc3VwcG9ydCBmbGF0IHN0cnVjdHVyZSlcbiAgICBpZiAoJ3NpZ25hdHVyZScgaW4gZW52ZWxvcGUgJiZcbiAgICAgICAgISgncHVibGljS2V5JyBpbiBlbnZlbG9wZSkgJiZcbiAgICAgICAgdHlwZW9mIGVudmVsb3BlLnNpZ25hdHVyZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgZW52ZWxvcGUuc2lnbmF0dXJlICE9PSBudWxsICYmXG4gICAgICAgICdyJyBpbiBlbnZlbG9wZS5zaWduYXR1cmUgJiZcbiAgICAgICAgJ3MnIGluIGVudmVsb3BlLnNpZ25hdHVyZSAmJlxuICAgICAgICAneVBhcml0eScgaW4gZW52ZWxvcGUuc2lnbmF0dXJlKVxuICAgICAgICByZXR1cm4gJ3NlY3AyNTZrMSc7XG4gICAgLy8gRGV0ZWN0IHNlY3AyNTZrMSBzaWduYXR1cmUgKGZsYXQgc3RydWN0dXJlKVxuICAgIGlmICgncicgaW4gZW52ZWxvcGUgJiYgJ3MnIGluIGVudmVsb3BlICYmICd5UGFyaXR5JyBpbiBlbnZlbG9wZSlcbiAgICAgICAgcmV0dXJuICdzZWNwMjU2azEnO1xuICAgIC8vIERldGVjdCBQMjU2IHNpZ25hdHVyZVxuICAgIGlmICgnc2lnbmF0dXJlJyBpbiBlbnZlbG9wZSAmJlxuICAgICAgICAncHJlaGFzaCcgaW4gZW52ZWxvcGUgJiZcbiAgICAgICAgJ3B1YmxpY0tleScgaW4gZW52ZWxvcGUgJiZcbiAgICAgICAgdHlwZW9mIGVudmVsb3BlLnByZWhhc2ggPT09ICdib29sZWFuJylcbiAgICAgICAgcmV0dXJuICdwMjU2JztcbiAgICAvLyBEZXRlY3QgV2ViQXV0aG4gc2lnbmF0dXJlXG4gICAgaWYgKCdzaWduYXR1cmUnIGluIGVudmVsb3BlICYmXG4gICAgICAgICdtZXRhZGF0YScgaW4gZW52ZWxvcGUgJiZcbiAgICAgICAgJ3B1YmxpY0tleScgaW4gZW52ZWxvcGUpXG4gICAgICAgIHJldHVybiAnd2ViQXV0aG4nO1xuICAgIC8vIERldGVjdCBLZXljaGFpbiBzaWduYXR1cmVcbiAgICBpZiAoJ3VzZXJBZGRyZXNzJyBpbiBlbnZlbG9wZSAmJiAnaW5uZXInIGluIGVudmVsb3BlKVxuICAgICAgICByZXR1cm4gJ2tleWNoYWluJztcbiAgICB0aHJvdyBuZXcgQ29lcmNpb25FcnJvcih7XG4gICAgICAgIGVudmVsb3BlLFxuICAgIH0pO1xufVxuLyoqXG4gKiBTZXJpYWxpemVzIGEgc2lnbmF0dXJlIGVudmVsb3BlIHRvIGEgaGV4LWVuY29kZWQgc3RyaW5nLlxuICpcbiAqIFdpcmUgZm9ybWF0OlxuICogLSBzZWNwMjU2azE6IDY1IGJ5dGVzIChubyB0eXBlIHByZWZpeCwgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkpXG4gKiAtIFAyNTY6IGAweDAxYCArIHIgKDMyKSArIHMgKDMyKSArIHB1YktleVggKDMyKSArIHB1YktleVkgKDMyKSArIHByZWhhc2ggKDEpID0gMTMwIGJ5dGVzXG4gKiAtIFdlYkF1dGhuOiBgMHgwMmAgKyB3ZWJhdXRobkRhdGEgKHZhcmlhYmxlKSArIHIgKDMyKSArIHMgKDMyKSArIHB1YktleVggKDMyKSArIHB1YktleVkgKDMyKVxuICogLSBLZXljaGFpbjogYDB4MDNgICsgdXNlckFkZHJlc3MgKDIwKSArIGlubmVyIHNpZ25hdHVyZSAocmVjdXJzaXZlKVxuICpcbiAqIFtTaWduYXR1cmUgVHlwZXNdKGh0dHBzOi8vZG9jcy50ZW1wby54eXovcHJvdG9jb2wvdHJhbnNhY3Rpb25zL3NwZWMtdGVtcG8tdHJhbnNhY3Rpb24jc2lnbmF0dXJlLXR5cGVzKVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlRW52ZWxvcGUgfSBmcm9tICdveC90ZW1wbydcbiAqXG4gKiBjb25zdCBzZXJpYWxpemVkID0gU2lnbmF0dXJlRW52ZWxvcGUuc2VyaWFsaXplKHtcbiAqICAgc2lnbmF0dXJlOiB7IHI6IDBuLCBzOiAwbiwgeVBhcml0eTogMCB9LFxuICogICB0eXBlOiAnc2VjcDI1NmsxJyxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZW52ZWxvcGUgLSBUaGUgc2lnbmF0dXJlIGVudmVsb3BlIHRvIHNlcmlhbGl6ZS5cbiAqIEByZXR1cm5zIFRoZSBoZXgtZW5jb2RlZCBzZXJpYWxpemVkIHNpZ25hdHVyZS5cbiAqIEB0aHJvd3MgYENvZXJjaW9uRXJyb3JgIGlmIHRoZSBlbnZlbG9wZSBjYW5ub3QgYmUgc2VyaWFsaXplZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZShlbnZlbG9wZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgdHlwZSA9IGdldFR5cGUoZW52ZWxvcGUpO1xuICAgIC8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHk6IG5vIHR5cGUgaWRlbnRpZmllciBmb3Igc2VjcDI1NmsxXG4gICAgaWYgKHR5cGUgPT09ICdzZWNwMjU2azEnKSB7XG4gICAgICAgIGNvbnN0IHNlY3AyNTZrMSA9IGVudmVsb3BlO1xuICAgICAgICByZXR1cm4gSGV4LmNvbmNhdChTaWduYXR1cmUudG9IZXgoc2VjcDI1NmsxLnNpZ25hdHVyZSksIG9wdGlvbnMubWFnaWMgPyBtYWdpY0J5dGVzIDogJzB4Jyk7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAncDI1NicpIHtcbiAgICAgICAgY29uc3QgcDI1NiA9IGVudmVsb3BlO1xuICAgICAgICAvLyBGb3JtYXQ6IDEgYnl0ZSAodHlwZSkgKyAzMiAocikgKyAzMiAocykgKyAzMiAocHViS2V5WCkgKyAzMiAocHViS2V5WSkgKyAxIChwcmVoYXNoKVxuICAgICAgICByZXR1cm4gSGV4LmNvbmNhdChzZXJpYWxpemVkUDI1NlR5cGUsIEhleC5mcm9tTnVtYmVyKHAyNTYuc2lnbmF0dXJlLnIsIHsgc2l6ZTogMzIgfSksIEhleC5mcm9tTnVtYmVyKHAyNTYuc2lnbmF0dXJlLnMsIHsgc2l6ZTogMzIgfSksIEhleC5mcm9tTnVtYmVyKHAyNTYucHVibGljS2V5LngsIHsgc2l6ZTogMzIgfSksIEhleC5mcm9tTnVtYmVyKHAyNTYucHVibGljS2V5LnksIHsgc2l6ZTogMzIgfSksIEhleC5mcm9tTnVtYmVyKHAyNTYucHJlaGFzaCA/IDEgOiAwLCB7IHNpemU6IDEgfSksIG9wdGlvbnMubWFnaWMgPyBtYWdpY0J5dGVzIDogJzB4Jyk7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAnd2ViQXV0aG4nKSB7XG4gICAgICAgIGNvbnN0IHdlYmF1dGhuID0gZW52ZWxvcGU7XG4gICAgICAgIC8vIEZvcm1hdDogMSBieXRlICh0eXBlKSArIHZhcmlhYmxlIChhdXRoZW50aWNhdG9yRGF0YSB8fCBjbGllbnREYXRhSlNPTikgKyAzMiAocikgKyAzMiAocykgKyAzMiAocHViS2V5WCkgKyAzMiAocHViS2V5WSlcbiAgICAgICAgY29uc3Qgd2ViYXV0aG5EYXRhID0gSGV4LmNvbmNhdCh3ZWJhdXRobi5tZXRhZGF0YS5hdXRoZW50aWNhdG9yRGF0YSwgSGV4LmZyb21TdHJpbmcod2ViYXV0aG4ubWV0YWRhdGEuY2xpZW50RGF0YUpTT04pKTtcbiAgICAgICAgcmV0dXJuIEhleC5jb25jYXQoc2VyaWFsaXplZFdlYkF1dGhuVHlwZSwgd2ViYXV0aG5EYXRhLCBIZXguZnJvbU51bWJlcih3ZWJhdXRobi5zaWduYXR1cmUuciwgeyBzaXplOiAzMiB9KSwgSGV4LmZyb21OdW1iZXIod2ViYXV0aG4uc2lnbmF0dXJlLnMsIHsgc2l6ZTogMzIgfSksIEhleC5mcm9tTnVtYmVyKHdlYmF1dGhuLnB1YmxpY0tleS54LCB7IHNpemU6IDMyIH0pLCBIZXguZnJvbU51bWJlcih3ZWJhdXRobi5wdWJsaWNLZXkueSwgeyBzaXplOiAzMiB9KSwgb3B0aW9ucy5tYWdpYyA/IG1hZ2ljQnl0ZXMgOiAnMHgnKTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09ICdrZXljaGFpbicpIHtcbiAgICAgICAgY29uc3Qga2V5Y2hhaW4gPSBlbnZlbG9wZTtcbiAgICAgICAgcmV0dXJuIEhleC5jb25jYXQoc2VyaWFsaXplZEtleWNoYWluVHlwZSwga2V5Y2hhaW4udXNlckFkZHJlc3MsIHNlcmlhbGl6ZShrZXljaGFpbi5pbm5lciksIG9wdGlvbnMubWFnaWMgPyBtYWdpY0J5dGVzIDogJzB4Jyk7XG4gICAgfVxuICAgIHRocm93IG5ldyBDb2VyY2lvbkVycm9yKHsgZW52ZWxvcGUgfSk7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgc2lnbmF0dXJlIGVudmVsb3BlIHRvIFJQQyBmb3JtYXQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmVFbnZlbG9wZSB9IGZyb20gJ294L3RlbXBvJ1xuICpcbiAqIGNvbnN0IHJwYyA9IFNpZ25hdHVyZUVudmVsb3BlLnRvUnBjKHtcbiAqICAgc2lnbmF0dXJlOiB7IHI6IDBuLCBzOiAwbiwgeVBhcml0eTogMCB9LFxuICogICB0eXBlOiAnc2VjcDI1NmsxJyxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZW52ZWxvcGUgLSBUaGUgc2lnbmF0dXJlIGVudmVsb3BlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgUlBDIHNpZ25hdHVyZSBlbnZlbG9wZSB3aXRoIGhleCB2YWx1ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1JwYyhlbnZlbG9wZSkge1xuICAgIGNvbnN0IHR5cGUgPSBnZXRUeXBlKGVudmVsb3BlKTtcbiAgICBpZiAodHlwZSA9PT0gJ3NlY3AyNTZrMScpIHtcbiAgICAgICAgY29uc3Qgc2VjcDI1NmsxID0gZW52ZWxvcGU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5TaWduYXR1cmUudG9ScGMoc2VjcDI1NmsxLnNpZ25hdHVyZSksXG4gICAgICAgICAgICB0eXBlOiAnc2VjcDI1NmsxJyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09ICdwMjU2Jykge1xuICAgICAgICBjb25zdCBwMjU2ID0gZW52ZWxvcGU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwcmVIYXNoOiBwMjU2LnByZWhhc2gsXG4gICAgICAgICAgICBwdWJLZXlYOiBIZXguZnJvbU51bWJlcihwMjU2LnB1YmxpY0tleS54LCB7IHNpemU6IDMyIH0pLFxuICAgICAgICAgICAgcHViS2V5WTogSGV4LmZyb21OdW1iZXIocDI1Ni5wdWJsaWNLZXkueSwgeyBzaXplOiAzMiB9KSxcbiAgICAgICAgICAgIHI6IEhleC5mcm9tTnVtYmVyKHAyNTYuc2lnbmF0dXJlLnIsIHsgc2l6ZTogMzIgfSksXG4gICAgICAgICAgICBzOiBIZXguZnJvbU51bWJlcihwMjU2LnNpZ25hdHVyZS5zLCB7IHNpemU6IDMyIH0pLFxuICAgICAgICAgICAgdHlwZTogJ3AyNTYnLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ3dlYkF1dGhuJykge1xuICAgICAgICBjb25zdCB3ZWJhdXRobiA9IGVudmVsb3BlO1xuICAgICAgICBjb25zdCB3ZWJhdXRobkRhdGEgPSBIZXguY29uY2F0KHdlYmF1dGhuLm1ldGFkYXRhLmF1dGhlbnRpY2F0b3JEYXRhLCBIZXguZnJvbVN0cmluZyh3ZWJhdXRobi5tZXRhZGF0YS5jbGllbnREYXRhSlNPTikpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHViS2V5WDogSGV4LmZyb21OdW1iZXIod2ViYXV0aG4ucHVibGljS2V5LngsIHsgc2l6ZTogMzIgfSksXG4gICAgICAgICAgICBwdWJLZXlZOiBIZXguZnJvbU51bWJlcih3ZWJhdXRobi5wdWJsaWNLZXkueSwgeyBzaXplOiAzMiB9KSxcbiAgICAgICAgICAgIHI6IEhleC5mcm9tTnVtYmVyKHdlYmF1dGhuLnNpZ25hdHVyZS5yLCB7IHNpemU6IDMyIH0pLFxuICAgICAgICAgICAgczogSGV4LmZyb21OdW1iZXIod2ViYXV0aG4uc2lnbmF0dXJlLnMsIHsgc2l6ZTogMzIgfSksXG4gICAgICAgICAgICB0eXBlOiAnd2ViQXV0aG4nLFxuICAgICAgICAgICAgd2ViYXV0aG5EYXRhLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ2tleWNoYWluJykge1xuICAgICAgICBjb25zdCBrZXljaGFpbiA9IGVudmVsb3BlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2tleWNoYWluJyxcbiAgICAgICAgICAgIHVzZXJBZGRyZXNzOiBrZXljaGFpbi51c2VyQWRkcmVzcyxcbiAgICAgICAgICAgIHNpZ25hdHVyZTogdG9ScGMoa2V5Y2hhaW4uaW5uZXIpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgQ29lcmNpb25FcnJvcih7IGVudmVsb3BlIH0pO1xufVxuLyoqXG4gKiBWYWxpZGF0ZXMgYSBzaWduYXR1cmUgZW52ZWxvcGUuIFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnZlbG9wZSBpcyB2YWxpZCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmVFbnZlbG9wZSB9IGZyb20gJ294L3RlbXBvJ1xuICpcbiAqIGNvbnN0IHZhbGlkID0gU2lnbmF0dXJlRW52ZWxvcGUudmFsaWRhdGUoe1xuICogICBzaWduYXR1cmU6IHsgcjogMG4sIHM6IDBuLCB5UGFyaXR5OiAwIH0sXG4gKiAgIHR5cGU6ICdzZWNwMjU2azEnLFxuICogfSlcbiAqIC8vIEBsb2c6IHRydWVcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBlbnZlbG9wZSAtIFRoZSBzaWduYXR1cmUgZW52ZWxvcGUgdG8gdmFsaWRhdGUuXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdmFsaWQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGUoZW52ZWxvcGUpIHtcbiAgICB0cnkge1xuICAgICAgICBhc3NlcnQoZW52ZWxvcGUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLyoqXG4gKiBWZXJpZmllcyBhIHNpZ25hdHVyZSBlbnZlbG9wZSBhZ2FpbnN0IGEgZGlnZXN0L3BheWxvYWQuXG4gKlxuICogU3VwcG9ydHMgYHNlY3AyNTZrMWAsIGBwMjU2YCwgYW5kIGB3ZWJBdXRobmAgc2lnbmF0dXJlIHR5cGVzLlxuICpcbiAqIDo6Ondhcm5pbmdcbiAqIGBrZXljaGFpbmAgc2lnbmF0dXJlcyBhcmUgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAqIDo6OlxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgU2VjcDI1NmsxXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZUVudmVsb3BlIH0gZnJvbSAnb3gvdGVtcG8nXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwcml2YXRlS2V5ID0gU2VjcDI1NmsxLnJhbmRvbVByaXZhdGVLZXkoKVxuICogY29uc3QgcHVibGljS2V5ID0gU2VjcDI1NmsxLmdldFB1YmxpY0tleSh7IHByaXZhdGVLZXkgfSlcbiAqIGNvbnN0IHBheWxvYWQgPSAnMHhkZWFkYmVlZidcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7IHBheWxvYWQsIHByaXZhdGVLZXkgfSlcbiAqIGNvbnN0IGVudmVsb3BlID0gU2lnbmF0dXJlRW52ZWxvcGUuZnJvbShzaWduYXR1cmUpXG4gKlxuICogY29uc3QgdmFsaWQgPSBTaWduYXR1cmVFbnZlbG9wZS52ZXJpZnkoZW52ZWxvcGUsIHtcbiAqICAgcGF5bG9hZCxcbiAqICAgcHVibGljS2V5LFxuICogfSlcbiAqIC8vIEBsb2c6IHRydWVcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgUDI1NlxuICpcbiAqIEZvciBQMjU2IHNpZ25hdHVyZXMsIHRoZSBgYWRkcmVzc2Agb3IgYHB1YmxpY0tleWAgbXVzdCBtYXRjaCB0aGUgZW1iZWRkZWRcbiAqIHB1YmxpYyBrZXkgaW4gdGhlIHNpZ25hdHVyZSBlbnZlbG9wZS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlRW52ZWxvcGUgfSBmcm9tICdveC90ZW1wbydcbiAqIGltcG9ydCB7IFAyNTYgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwcml2YXRlS2V5ID0gUDI1Ni5yYW5kb21Qcml2YXRlS2V5KClcbiAqIGNvbnN0IHB1YmxpY0tleSA9IFAyNTYuZ2V0UHVibGljS2V5KHsgcHJpdmF0ZUtleSB9KVxuICogY29uc3QgcGF5bG9hZCA9ICcweGRlYWRiZWVmJ1xuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFAyNTYuc2lnbih7IHBheWxvYWQsIHByaXZhdGVLZXkgfSlcbiAqIGNvbnN0IGVudmVsb3BlID0gU2lnbmF0dXJlRW52ZWxvcGUuZnJvbSh7IHByZWhhc2g6IGZhbHNlLCBwdWJsaWNLZXksIHNpZ25hdHVyZSB9KVxuICpcbiAqIGNvbnN0IHZhbGlkID0gU2lnbmF0dXJlRW52ZWxvcGUudmVyaWZ5KGVudmVsb3BlLCB7XG4gKiAgIHBheWxvYWQsXG4gKiAgIHB1YmxpY0tleSxcbiAqIH0pXG4gKiAvLyBAbG9nOiB0cnVlXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIFdlYkNyeXB0b1AyNTZcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlRW52ZWxvcGUgfSBmcm9tICdveC90ZW1wbydcbiAqIGltcG9ydCB7IFdlYkNyeXB0b1AyNTYgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB7IHByaXZhdGVLZXksIHB1YmxpY0tleSB9ID0gYXdhaXQgV2ViQ3J5cHRvUDI1Ni5jcmVhdGVLZXlQYWlyKClcbiAqIGNvbnN0IHBheWxvYWQgPSAnMHhkZWFkYmVlZidcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBXZWJDcnlwdG9QMjU2LnNpZ24oeyBwYXlsb2FkLCBwcml2YXRlS2V5IH0pXG4gKiBjb25zdCBlbnZlbG9wZSA9IFNpZ25hdHVyZUVudmVsb3BlLmZyb20oeyBwcmVoYXNoOiB0cnVlLCBwdWJsaWNLZXksIHNpZ25hdHVyZSB9KVxuICpcbiAqIGNvbnN0IHZhbGlkID0gU2lnbmF0dXJlRW52ZWxvcGUudmVyaWZ5KGVudmVsb3BlLCB7XG4gKiAgIHBheWxvYWQsXG4gKiAgIHB1YmxpY0tleSxcbiAqIH0pXG4gKiAvLyBAbG9nOiB0cnVlXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIFdlYkF1dGhuUDI1NlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmVFbnZlbG9wZSB9IGZyb20gJ294L3RlbXBvJ1xuICogaW1wb3J0IHsgV2ViQXV0aG5QMjU2IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgY3JlZGVudGlhbCA9IGF3YWl0IFdlYkF1dGhuUDI1Ni5jcmVhdGVDcmVkZW50aWFsKHsgbmFtZTogJ0V4YW1wbGUnIH0pXG4gKiBjb25zdCBwYXlsb2FkID0gJzB4ZGVhZGJlZWYnXG4gKlxuICogY29uc3QgeyBtZXRhZGF0YSwgc2lnbmF0dXJlIH0gPSBhd2FpdCBXZWJBdXRoblAyNTYuc2lnbih7XG4gKiAgIGNoYWxsZW5nZTogcGF5bG9hZCxcbiAqICAgY3JlZGVudGlhbElkOiBjcmVkZW50aWFsLmlkLFxuICogfSlcbiAqIGNvbnN0IGVudmVsb3BlID0gU2lnbmF0dXJlRW52ZWxvcGUuZnJvbSh7XG4gKiAgIG1ldGFkYXRhLFxuICogICBzaWduYXR1cmUsXG4gKiAgIHB1YmxpY0tleTogY3JlZGVudGlhbC5wdWJsaWNLZXksXG4gKiB9KVxuICpcbiAqIGNvbnN0IHZhbGlkID0gU2lnbmF0dXJlRW52ZWxvcGUudmVyaWZ5KGVudmVsb3BlLCB7XG4gKiAgIHBheWxvYWQsXG4gKiAgIHB1YmxpY0tleTogY3JlZGVudGlhbC5wdWJsaWNLZXksXG4gKiB9KVxuICogLy8gQGxvZzogdHJ1ZVxuICogYGBgXG4gKlxuICogQHBhcmFtIHBhcmFtZXRlcnMgLSBWZXJpZmljYXRpb24gcGFyYW1ldGVycy5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgc2lnbmF0dXJlIGlzIHZhbGlkLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeShzaWduYXR1cmUsIHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCB7IHBheWxvYWQgfSA9IHBhcmFtZXRlcnM7XG4gICAgY29uc3QgYWRkcmVzcyA9ICgoKSA9PiB7XG4gICAgICAgIGlmIChwYXJhbWV0ZXJzLmFkZHJlc3MpXG4gICAgICAgICAgICByZXR1cm4gcGFyYW1ldGVycy5hZGRyZXNzO1xuICAgICAgICBpZiAocGFyYW1ldGVycy5wdWJsaWNLZXkpXG4gICAgICAgICAgICByZXR1cm4gQWRkcmVzcy5mcm9tUHVibGljS2V5KHBhcmFtZXRlcnMucHVibGljS2V5KTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9KSgpO1xuICAgIGlmICghYWRkcmVzcylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGVudmVsb3BlID0gZnJvbShzaWduYXR1cmUpO1xuICAgIGlmIChlbnZlbG9wZS50eXBlID09PSAnc2VjcDI1NmsxJykge1xuICAgICAgICBpZiAoIWFkZHJlc3MpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiBveF9TZWNwMjU2azEudmVyaWZ5KHtcbiAgICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgICBwYXlsb2FkLFxuICAgICAgICAgICAgc2lnbmF0dXJlOiBlbnZlbG9wZS5zaWduYXR1cmUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZW52ZWxvcGUudHlwZSA9PT0gJ3AyNTYnKSB7XG4gICAgICAgIGNvbnN0IGVudmVsb3BlQWRkcmVzcyA9IEFkZHJlc3MuZnJvbVB1YmxpY0tleShlbnZlbG9wZS5wdWJsaWNLZXkpO1xuICAgICAgICBpZiAoIUFkZHJlc3MuaXNFcXVhbChlbnZlbG9wZUFkZHJlc3MsIGFkZHJlc3MpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gb3hfUDI1Ni52ZXJpZnkoe1xuICAgICAgICAgICAgaGFzaDogZW52ZWxvcGUucHJlaGFzaCxcbiAgICAgICAgICAgIHB1YmxpY0tleTogZW52ZWxvcGUucHVibGljS2V5LFxuICAgICAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgICAgIHNpZ25hdHVyZTogZW52ZWxvcGUuc2lnbmF0dXJlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGVudmVsb3BlLnR5cGUgPT09ICd3ZWJBdXRobicpIHtcbiAgICAgICAgY29uc3QgZW52ZWxvcGVBZGRyZXNzID0gQWRkcmVzcy5mcm9tUHVibGljS2V5KGVudmVsb3BlLnB1YmxpY0tleSk7XG4gICAgICAgIGlmICghQWRkcmVzcy5pc0VxdWFsKGVudmVsb3BlQWRkcmVzcywgYWRkcmVzcykpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiBveF9XZWJBdXRoblAyNTYudmVyaWZ5KHtcbiAgICAgICAgICAgIGNoYWxsZW5nZTogSGV4LmZyb20ocGF5bG9hZCksXG4gICAgICAgICAgICBtZXRhZGF0YTogZW52ZWxvcGUubWV0YWRhdGEsXG4gICAgICAgICAgICBwdWJsaWNLZXk6IGVudmVsb3BlLnB1YmxpY0tleSxcbiAgICAgICAgICAgIHNpZ25hdHVyZTogZW52ZWxvcGUuc2lnbmF0dXJlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFZlcmlmaWNhdGlvbkVycm9yKGBVbmFibGUgdG8gdmVyaWZ5IHNpZ25hdHVyZSBlbnZlbG9wZSBvZiB0eXBlIFwiJHtlbnZlbG9wZS50eXBlfVwiLmApO1xufVxuLyoqXG4gKiBFcnJvciB0aHJvd24gd2hlbiBhIHNpZ25hdHVyZSBlbnZlbG9wZSBjYW5ub3QgYmUgY29lcmNlZCB0byBhIHZhbGlkIHR5cGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBDb2VyY2lvbkVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBlbnZlbG9wZSB9KSB7XG4gICAgICAgIHN1cGVyKGBVbmFibGUgdG8gY29lcmNlIHZhbHVlIChcXGAke0pzb24uc3RyaW5naWZ5KGVudmVsb3BlKX1cXGApIHRvIGEgdmFsaWQgc2lnbmF0dXJlIGVudmVsb3BlLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnU2lnbmF0dXJlRW52ZWxvcGUuQ29lcmNpb25FcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBFcnJvciB0aHJvd24gd2hlbiBhIHNpZ25hdHVyZSBlbnZlbG9wZSBpcyBtaXNzaW5nIHJlcXVpcmVkIHByb3BlcnRpZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBNaXNzaW5nUHJvcGVydGllc0Vycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBlbnZlbG9wZSwgbWlzc2luZywgdHlwZSwgfSkge1xuICAgICAgICBzdXBlcihgU2lnbmF0dXJlIGVudmVsb3BlIG9mIHR5cGUgXCIke3R5cGV9XCIgaXMgbWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0aWVzOiAke21pc3NpbmcubWFwKChtKSA9PiBgXFxgJHttfVxcYGApLmpvaW4oJywgJyl9LlxcblxcblByb3ZpZGVkOiAke0pzb24uc3RyaW5naWZ5KGVudmVsb3BlKX1gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1NpZ25hdHVyZUVudmVsb3BlLk1pc3NpbmdQcm9wZXJ0aWVzRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogRXJyb3IgdGhyb3duIHdoZW4gYSBzZXJpYWxpemVkIHNpZ25hdHVyZSBlbnZlbG9wZSBjYW5ub3QgYmUgZGVzZXJpYWxpemVkLlxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZFNlcmlhbGl6ZWRFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgcmVhc29uLCBzZXJpYWxpemVkLCB9KSB7XG4gICAgICAgIHN1cGVyKGBVbmFibGUgdG8gZGVzZXJpYWxpemUgc2lnbmF0dXJlIGVudmVsb3BlOiAke3JlYXNvbn1gLCB7XG4gICAgICAgICAgICBtZXRhTWVzc2FnZXM6IFtgU2VyaWFsaXplZDogJHtzZXJpYWxpemVkfWBdLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1NpZ25hdHVyZUVudmVsb3BlLkludmFsaWRTZXJpYWxpemVkRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogRXJyb3IgdGhyb3duIHdoZW4gYSBzaWduYXR1cmUgZW52ZWxvcGUgZmFpbHMgdG8gdmVyaWZ5LlxuICovXG5leHBvcnQgY2xhc3MgVmVyaWZpY2F0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1NpZ25hdHVyZUVudmVsb3BlLlZlcmlmaWNhdGlvbkVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TaWduYXR1cmVFbnZlbG9wZS5qcy5tYXAiXSwibmFtZXMiOlsiQWRkcmVzcyIsIkVycm9ycyIsIkhleCIsIkpzb24iLCJveF9QMjU2Iiwib3hfU2VjcDI1NmsxIiwiU2lnbmF0dXJlIiwib3hfV2ViQXV0aG5QMjU2Iiwic2VyaWFsaXplZFAyNTZUeXBlIiwic2VyaWFsaXplZFdlYkF1dGhuVHlwZSIsInNlcmlhbGl6ZWRLZXljaGFpblR5cGUiLCJtYWdpY0J5dGVzIiwidHlwZXMiLCJhc3NlcnQiLCJlbnZlbG9wZSIsInR5cGUiLCJnZXRUeXBlIiwic2VjcDI1NmsxIiwic2lnbmF0dXJlIiwicDI1NiIsIm1pc3NpbmciLCJyIiwicHVzaCIsInMiLCJwcmVoYXNoIiwicHVibGljS2V5IiwieCIsInkiLCJsZW5ndGgiLCJNaXNzaW5nUHJvcGVydGllc0Vycm9yIiwid2ViYXV0aG4iLCJtZXRhZGF0YSIsImF1dGhlbnRpY2F0b3JEYXRhIiwiY2xpZW50RGF0YUpTT04iLCJrZXljaGFpbiIsImlubmVyIiwiZGVzZXJpYWxpemUiLCJ2YWx1ZSIsInNlcmlhbGl6ZWQiLCJlbmRzV2l0aCIsInNsaWNlIiwic2l6ZSIsImZyb21IZXgiLCJ0eXBlSWQiLCJkYXRhIiwiZGF0YVNpemUiLCJJbnZhbGlkU2VyaWFsaXplZEVycm9yIiwicmVhc29uIiwicHJlZml4IiwidG9CaWdJbnQiLCJ0b051bWJlciIsIndlYmF1dGhuRGF0YVNpemUiLCJ3ZWJhdXRobkRhdGEiLCJzcGxpdCIsInBvdGVudGlhbEpzb24iLCJ0b1N0cmluZyIsInN0YXJ0c1dpdGgiLCJKU09OIiwicGFyc2UiLCJ1c2VyQWRkcmVzcyIsImZyb20iLCJmcm9tUnBjIiwicHJlSGFzaCIsInB1YktleVgiLCJwdWJLZXlZIiwiQ29lcmNpb25FcnJvciIsInNlcmlhbGl6ZSIsIm9wdGlvbnMiLCJjb25jYXQiLCJ0b0hleCIsIm1hZ2ljIiwiZnJvbU51bWJlciIsImZyb21TdHJpbmciLCJ0b1JwYyIsInZhbGlkYXRlIiwidmVyaWZ5IiwicGFyYW1ldGVycyIsInBheWxvYWQiLCJhZGRyZXNzIiwiZnJvbVB1YmxpY0tleSIsInVuZGVmaW5lZCIsImVudmVsb3BlQWRkcmVzcyIsImlzRXF1YWwiLCJoYXNoIiwiY2hhbGxlbmdlIiwiVmVyaWZpY2F0aW9uRXJyb3IiLCJCYXNlRXJyb3IiLCJjb25zdHJ1Y3RvciIsInN0cmluZ2lmeSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwibWFwIiwibSIsImpvaW4iLCJtZXRhTWVzc2FnZXMiLCJhcmd1bWVudHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/tempo/SignatureEnvelope.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/tempo/TokenId.js":
/*!***********************************************!*\
  !*** ./node_modules/ox/_esm/tempo/TokenId.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   compute: () => (/* binding */ compute),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromAddress: () => (/* binding */ fromAddress),\n/* harmony export */   toAddress: () => (/* binding */ toAddress)\n/* harmony export */ });\n/* harmony import */ var _core_AbiParameters_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/AbiParameters.js */ \"(ssr)/./node_modules/ox/_esm/core/AbiParameters.js\");\n/* harmony import */ var _core_Address_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Address.js */ \"(ssr)/./node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _core_Hash_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/Hash.js */ \"(ssr)/./node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _core_Hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n\n\n\n\nconst tip20Prefix = \"0x20c0\";\n/**\n * Converts a token ID or address to a token ID.\n *\n * TIP-20 is Tempo's native token standard for stablecoins with deterministic addresses\n * derived from sequential token IDs (prefix `0x20c0`).\n *\n * [TIP-20 Token Standard](https://docs.tempo.xyz/protocol/tip20/overview)\n *\n * @example\n * ```ts twoslash\n * import { TokenId } from 'ox/tempo'\n *\n * const tokenId = TokenId.from(1n)\n * ```\n *\n * @param tokenIdOrAddress - The token ID or address.\n * @returns The token ID.\n */ function from(tokenIdOrAddress) {\n    if (typeof tokenIdOrAddress === \"bigint\" || typeof tokenIdOrAddress === \"number\") return BigInt(tokenIdOrAddress);\n    return fromAddress(tokenIdOrAddress);\n}\n/**\n * Converts a TIP-20 token address to a token ID.\n *\n * [TIP-20 Token Standard](https://docs.tempo.xyz/protocol/tip20/overview)\n *\n * @example\n * ```ts twoslash\n * import { TokenId } from 'ox/tempo'\n *\n * const tokenId = TokenId.fromAddress('0x20c00000000000000000000000000000000000000001')\n * ```\n *\n * @param address - The token address.\n * @returns The token ID.\n */ function fromAddress(address) {\n    if (!address.toLowerCase().startsWith(tip20Prefix)) throw new Error(\"invalid tip20 address.\");\n    return _core_Hex_js__WEBPACK_IMPORTED_MODULE_0__.toBigInt(_core_Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(address, tip20Prefix.length));\n}\n/**\n * Converts a TIP-20 token ID to an address.\n *\n * [TIP-20 Token Standard](https://docs.tempo.xyz/protocol/tip20/overview)\n *\n * @example\n * ```ts twoslash\n * import { TokenId } from 'ox/tempo'\n *\n * const address = TokenId.toAddress(1n)\n * ```\n *\n * @param tokenId - The token ID.\n * @returns The address.\n */ function toAddress(tokenId) {\n    if (typeof tokenId === \"string\") {\n        _core_Address_js__WEBPACK_IMPORTED_MODULE_1__.assert(tokenId);\n        return tokenId;\n    }\n    const tokenIdHex = _core_Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromNumber(tokenId, {\n        size: 18\n    });\n    return _core_Hex_js__WEBPACK_IMPORTED_MODULE_0__.concat(tip20Prefix, tokenIdHex);\n}\n/**\n * Computes a deterministic TIP-20 token address from a sender address and salt.\n *\n * The address is computed as: `TIP20_PREFIX (12 bytes) || keccak256(abi.encode(sender, salt))[:8]`\n *\n * [TIP-20 Token Standard](https://docs.tempo.xyz/protocol/tip20/overview)\n *\n * @example\n * ```ts twoslash\n * import { TokenId } from 'ox/tempo'\n *\n * const id = TokenId.compute({\n *   sender: '0x1234567890123456789012345678901234567890',\n *   salt: '0x0000000000000000000000000000000000000000000000000000000000000001',\n * })\n * ```\n *\n * @param value - The sender address and salt.\n * @returns The computed TIP-20 token id.\n */ function compute(value) {\n    const hash = _core_Hash_js__WEBPACK_IMPORTED_MODULE_2__.keccak256(_core_AbiParameters_js__WEBPACK_IMPORTED_MODULE_3__.encode(_core_AbiParameters_js__WEBPACK_IMPORTED_MODULE_3__.from(\"address, bytes32\"), [\n        value.sender,\n        value.salt\n    ]));\n    return _core_Hex_js__WEBPACK_IMPORTED_MODULE_0__.toBigInt(_core_Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(hash, 0, 8));\n} //# sourceMappingURL=TokenId.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS90ZW1wby9Ub2tlbklkLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQTBEO0FBQ1o7QUFDTjtBQUNGO0FBQ3RDLE1BQU1JLGNBQWM7QUFDcEI7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBaUJDLEdBQ00sU0FBU0MsS0FBS0MsZ0JBQWdCO0lBQ2pDLElBQUksT0FBT0EscUJBQXFCLFlBQzVCLE9BQU9BLHFCQUFxQixVQUM1QixPQUFPQyxPQUFPRDtJQUNsQixPQUFPRSxZQUFZRjtBQUN2QjtBQUNBOzs7Ozs7Ozs7Ozs7OztDQWNDLEdBQ00sU0FBU0UsWUFBWUMsT0FBTztJQUMvQixJQUFJLENBQUNBLFFBQVFDLFdBQVcsR0FBR0MsVUFBVSxDQUFDUCxjQUNsQyxNQUFNLElBQUlRLE1BQU07SUFDcEIsT0FBT1Qsa0RBQVksQ0FBQ0EsK0NBQVMsQ0FBQ00sU0FBU0wsWUFBWVcsTUFBTTtBQUM3RDtBQUNBOzs7Ozs7Ozs7Ozs7OztDQWNDLEdBQ00sU0FBU0MsVUFBVUMsT0FBTztJQUM3QixJQUFJLE9BQU9BLFlBQVksVUFBVTtRQUM3QmhCLG9EQUFjLENBQUNnQjtRQUNmLE9BQU9BO0lBQ1g7SUFDQSxNQUFNRSxhQUFhaEIsb0RBQWMsQ0FBQ2MsU0FBUztRQUFFSSxNQUFNO0lBQUc7SUFDdEQsT0FBT2xCLGdEQUFVLENBQUNDLGFBQWFlO0FBQ25DO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FtQkMsR0FDTSxTQUFTSSxRQUFRQyxLQUFLO0lBQ3pCLE1BQU1DLE9BQU92QixvREFBYyxDQUFDRiwwREFBb0IsQ0FBQ0Esd0RBQWtCLENBQUMscUJBQXFCO1FBQ3JGd0IsTUFBTUksTUFBTTtRQUNaSixNQUFNSyxJQUFJO0tBQ2I7SUFDRCxPQUFPMUIsa0RBQVksQ0FBQ0EsK0NBQVMsQ0FBQ3NCLE1BQU0sR0FBRztBQUMzQyxFQUNBLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsYXctd29ya3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS90ZW1wby9Ub2tlbklkLmpzPzYzNzgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQWJpUGFyYW1ldGVycyBmcm9tICcuLi9jb3JlL0FiaVBhcmFtZXRlcnMuanMnO1xuaW1wb3J0ICogYXMgQWRkcmVzcyBmcm9tICcuLi9jb3JlL0FkZHJlc3MuanMnO1xuaW1wb3J0ICogYXMgSGFzaCBmcm9tICcuLi9jb3JlL0hhc2guanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4uL2NvcmUvSGV4LmpzJztcbmNvbnN0IHRpcDIwUHJlZml4ID0gJzB4MjBjMCc7XG4vKipcbiAqIENvbnZlcnRzIGEgdG9rZW4gSUQgb3IgYWRkcmVzcyB0byBhIHRva2VuIElELlxuICpcbiAqIFRJUC0yMCBpcyBUZW1wbydzIG5hdGl2ZSB0b2tlbiBzdGFuZGFyZCBmb3Igc3RhYmxlY29pbnMgd2l0aCBkZXRlcm1pbmlzdGljIGFkZHJlc3Nlc1xuICogZGVyaXZlZCBmcm9tIHNlcXVlbnRpYWwgdG9rZW4gSURzIChwcmVmaXggYDB4MjBjMGApLlxuICpcbiAqIFtUSVAtMjAgVG9rZW4gU3RhbmRhcmRdKGh0dHBzOi8vZG9jcy50ZW1wby54eXovcHJvdG9jb2wvdGlwMjAvb3ZlcnZpZXcpXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBUb2tlbklkIH0gZnJvbSAnb3gvdGVtcG8nXG4gKlxuICogY29uc3QgdG9rZW5JZCA9IFRva2VuSWQuZnJvbSgxbilcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB0b2tlbklkT3JBZGRyZXNzIC0gVGhlIHRva2VuIElEIG9yIGFkZHJlc3MuXG4gKiBAcmV0dXJucyBUaGUgdG9rZW4gSUQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tKHRva2VuSWRPckFkZHJlc3MpIHtcbiAgICBpZiAodHlwZW9mIHRva2VuSWRPckFkZHJlc3MgPT09ICdiaWdpbnQnIHx8XG4gICAgICAgIHR5cGVvZiB0b2tlbklkT3JBZGRyZXNzID09PSAnbnVtYmVyJylcbiAgICAgICAgcmV0dXJuIEJpZ0ludCh0b2tlbklkT3JBZGRyZXNzKTtcbiAgICByZXR1cm4gZnJvbUFkZHJlc3ModG9rZW5JZE9yQWRkcmVzcyk7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgVElQLTIwIHRva2VuIGFkZHJlc3MgdG8gYSB0b2tlbiBJRC5cbiAqXG4gKiBbVElQLTIwIFRva2VuIFN0YW5kYXJkXShodHRwczovL2RvY3MudGVtcG8ueHl6L3Byb3RvY29sL3RpcDIwL292ZXJ2aWV3KVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVG9rZW5JZCB9IGZyb20gJ294L3RlbXBvJ1xuICpcbiAqIGNvbnN0IHRva2VuSWQgPSBUb2tlbklkLmZyb21BZGRyZXNzKCcweDIwYzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJylcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhZGRyZXNzIC0gVGhlIHRva2VuIGFkZHJlc3MuXG4gKiBAcmV0dXJucyBUaGUgdG9rZW4gSUQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tQWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgaWYgKCFhZGRyZXNzLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCh0aXAyMFByZWZpeCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB0aXAyMCBhZGRyZXNzLicpO1xuICAgIHJldHVybiBIZXgudG9CaWdJbnQoSGV4LnNsaWNlKGFkZHJlc3MsIHRpcDIwUHJlZml4Lmxlbmd0aCkpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIFRJUC0yMCB0b2tlbiBJRCB0byBhbiBhZGRyZXNzLlxuICpcbiAqIFtUSVAtMjAgVG9rZW4gU3RhbmRhcmRdKGh0dHBzOi8vZG9jcy50ZW1wby54eXovcHJvdG9jb2wvdGlwMjAvb3ZlcnZpZXcpXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBUb2tlbklkIH0gZnJvbSAnb3gvdGVtcG8nXG4gKlxuICogY29uc3QgYWRkcmVzcyA9IFRva2VuSWQudG9BZGRyZXNzKDFuKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHRva2VuSWQgLSBUaGUgdG9rZW4gSUQuXG4gKiBAcmV0dXJucyBUaGUgYWRkcmVzcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQWRkcmVzcyh0b2tlbklkKSB7XG4gICAgaWYgKHR5cGVvZiB0b2tlbklkID09PSAnc3RyaW5nJykge1xuICAgICAgICBBZGRyZXNzLmFzc2VydCh0b2tlbklkKTtcbiAgICAgICAgcmV0dXJuIHRva2VuSWQ7XG4gICAgfVxuICAgIGNvbnN0IHRva2VuSWRIZXggPSBIZXguZnJvbU51bWJlcih0b2tlbklkLCB7IHNpemU6IDE4IH0pO1xuICAgIHJldHVybiBIZXguY29uY2F0KHRpcDIwUHJlZml4LCB0b2tlbklkSGV4KTtcbn1cbi8qKlxuICogQ29tcHV0ZXMgYSBkZXRlcm1pbmlzdGljIFRJUC0yMCB0b2tlbiBhZGRyZXNzIGZyb20gYSBzZW5kZXIgYWRkcmVzcyBhbmQgc2FsdC5cbiAqXG4gKiBUaGUgYWRkcmVzcyBpcyBjb21wdXRlZCBhczogYFRJUDIwX1BSRUZJWCAoMTIgYnl0ZXMpIHx8IGtlY2NhazI1NihhYmkuZW5jb2RlKHNlbmRlciwgc2FsdCkpWzo4XWBcbiAqXG4gKiBbVElQLTIwIFRva2VuIFN0YW5kYXJkXShodHRwczovL2RvY3MudGVtcG8ueHl6L3Byb3RvY29sL3RpcDIwL292ZXJ2aWV3KVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVG9rZW5JZCB9IGZyb20gJ294L3RlbXBvJ1xuICpcbiAqIGNvbnN0IGlkID0gVG9rZW5JZC5jb21wdXRlKHtcbiAqICAgc2VuZGVyOiAnMHgxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwJyxcbiAqICAgc2FsdDogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsXG4gKiB9KVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHNlbmRlciBhZGRyZXNzIGFuZCBzYWx0LlxuICogQHJldHVybnMgVGhlIGNvbXB1dGVkIFRJUC0yMCB0b2tlbiBpZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGUodmFsdWUpIHtcbiAgICBjb25zdCBoYXNoID0gSGFzaC5rZWNjYWsyNTYoQWJpUGFyYW1ldGVycy5lbmNvZGUoQWJpUGFyYW1ldGVycy5mcm9tKCdhZGRyZXNzLCBieXRlczMyJyksIFtcbiAgICAgICAgdmFsdWUuc2VuZGVyLFxuICAgICAgICB2YWx1ZS5zYWx0LFxuICAgIF0pKTtcbiAgICByZXR1cm4gSGV4LnRvQmlnSW50KEhleC5zbGljZShoYXNoLCAwLCA4KSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Ub2tlbklkLmpzLm1hcCJdLCJuYW1lcyI6WyJBYmlQYXJhbWV0ZXJzIiwiQWRkcmVzcyIsIkhhc2giLCJIZXgiLCJ0aXAyMFByZWZpeCIsImZyb20iLCJ0b2tlbklkT3JBZGRyZXNzIiwiQmlnSW50IiwiZnJvbUFkZHJlc3MiLCJhZGRyZXNzIiwidG9Mb3dlckNhc2UiLCJzdGFydHNXaXRoIiwiRXJyb3IiLCJ0b0JpZ0ludCIsInNsaWNlIiwibGVuZ3RoIiwidG9BZGRyZXNzIiwidG9rZW5JZCIsImFzc2VydCIsInRva2VuSWRIZXgiLCJmcm9tTnVtYmVyIiwic2l6ZSIsImNvbmNhdCIsImNvbXB1dGUiLCJ2YWx1ZSIsImhhc2giLCJrZWNjYWsyNTYiLCJlbmNvZGUiLCJzZW5kZXIiLCJzYWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/tempo/TokenId.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/tempo/Transaction.js":
/*!***************************************************!*\
  !*** ./node_modules/ox/_esm/tempo/Transaction.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromRpc: () => (/* binding */ fromRpc),\n/* harmony export */   fromRpcType: () => (/* binding */ fromRpcType),\n/* harmony export */   toRpc: () => (/* binding */ toRpc),\n/* harmony export */   toRpcType: () => (/* binding */ toRpcType)\n/* harmony export */ });\n/* harmony import */ var _core_Hex_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _core_Signature_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/Signature.js */ \"(ssr)/./node_modules/ox/_esm/core/Signature.js\");\n/* harmony import */ var _core_Transaction_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Transaction.js */ \"(ssr)/./node_modules/ox/_esm/core/Transaction.js\");\n/* harmony import */ var _AuthorizationTempo_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AuthorizationTempo.js */ \"(ssr)/./node_modules/ox/_esm/tempo/AuthorizationTempo.js\");\n/* harmony import */ var _KeyAuthorization_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./KeyAuthorization.js */ \"(ssr)/./node_modules/ox/_esm/tempo/KeyAuthorization.js\");\n/* harmony import */ var _SignatureEnvelope_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SignatureEnvelope.js */ \"(ssr)/./node_modules/ox/_esm/tempo/SignatureEnvelope.js\");\n\n\n\n\n\n\n/** Type to RPC Type mapping. */ const toRpcType = {\n    ..._core_Transaction_js__WEBPACK_IMPORTED_MODULE_0__.toRpcType,\n    tempo: \"0x76\"\n};\n/** RPC Type to Type mapping. */ const fromRpcType = {\n    ..._core_Transaction_js__WEBPACK_IMPORTED_MODULE_0__.fromRpcType,\n    \"0x76\": \"tempo\"\n};\n/**\n * Converts an {@link ox#Transaction.Rpc} to an {@link ox#Transaction.Transaction}.\n *\n * @example\n * ```ts twoslash\n * import { Transaction } from 'ox/tempo'\n *\n * const transaction = Transaction.fromRpc({\n *   hash: '0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0',\n *   nonce: '0x357',\n *   blockHash:\n *     '0xc350d807505fb835650f0013632c5515592987ba169bbc6626d9fc54d91f0f0b',\n *   blockNumber: '0x12f296f',\n *   calls: [\n *     {\n *       input: '0xdeadbeef',\n *       to: '0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad',\n *       value: '0x9b6e64a8ec60000',\n *     },\n *   ],\n *   feeToken: '0x20c0000000000000000000000000000000000000',\n *   transactionIndex: '0x2',\n *   from: '0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6',\n *   value: '0x9b6e64a8ec60000',\n *   gas: '0x43f5d',\n *   maxFeePerGas: '0x2ca6ae494',\n *   maxPriorityFeePerGas: '0x41cc3c0',\n *   input:\n *     '0x3593564c000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000006643504700000000000000000000000000000000000000000000000000000000000000040b080604000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000002800000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000009b6e64a8ec600000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000009b6e64a8ec60000000000000000000000000000000000000000000000000000019124bb5ae978c000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b80000000000000000000000000000000000000000000000000000000000000060000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b8000000000000000000000000000000fee13a103a10d593b9ae06b3e05f2e7e1c00000000000000000000000000000000000000000000000000000000000000190000000000000000000000000000000000000000000000000000000000000060000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b800000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000190240001b9872b',\n *   signature: {\n *     r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *     s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *     type: 'secp256k1',\n *     yParity: '0x0',\n *   },\n *   chainId: '0x1',\n *   accessList: [],\n *   type: '0x76',\n * })\n * ```\n *\n * @param transaction - The RPC transaction to convert.\n * @returns An instantiated {@link ox#Transaction.Transaction}.\n */ function fromRpc(transaction, _options = {}) {\n    if (!transaction) return null;\n    const transaction_ = _core_Transaction_js__WEBPACK_IMPORTED_MODULE_0__.fromRpc(transaction);\n    transaction_.type = fromRpcType[transaction.type];\n    if (transaction.aaAuthorizationList) {\n        transaction_.authorizationList = _AuthorizationTempo_js__WEBPACK_IMPORTED_MODULE_1__.fromRpcList(transaction.aaAuthorizationList);\n        delete transaction_.aaAuthorizationList;\n    }\n    if (transaction.calls) transaction_.calls = transaction.calls.map((call)=>({\n            to: call.to,\n            value: call.value && call.value !== \"0x\" ? BigInt(call.value) : undefined,\n            // @ts-expect-error\n            data: call.input || call.data || \"0x\"\n        }));\n    if (transaction.feeToken) transaction_.feeToken = transaction.feeToken;\n    if (transaction.nonceKey) transaction_.nonceKey = BigInt(transaction.nonceKey);\n    if (transaction.signature) transaction_.signature = _SignatureEnvelope_js__WEBPACK_IMPORTED_MODULE_2__.fromRpc(transaction.signature);\n    if (transaction.validAfter) transaction_.validAfter = Number(transaction.validAfter);\n    if (transaction.validBefore) transaction_.validBefore = Number(transaction.validBefore);\n    if (transaction.keyAuthorization) transaction_.keyAuthorization = _KeyAuthorization_js__WEBPACK_IMPORTED_MODULE_3__.fromRpc(transaction.keyAuthorization);\n    if (transaction.feePayerSignature) {\n        transaction_.feePayerSignature = _core_Signature_js__WEBPACK_IMPORTED_MODULE_4__.fromRpc(transaction.feePayerSignature);\n        transaction_.feePayerSignature.v = _core_Signature_js__WEBPACK_IMPORTED_MODULE_4__.yParityToV(transaction_.feePayerSignature.yParity);\n    }\n    return transaction_;\n}\n/**\n * Converts an {@link ox#Transaction.Transaction} to an {@link ox#Transaction.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Transaction } from 'ox/tempo'\n *\n * const transaction = Transaction.toRpc({\n *   accessList: [],\n *   blockHash:\n *     '0xc350d807505fb835650f0013632c5515592987ba169bbc6626d9fc54d91f0f0b',\n *   blockNumber: 19868015n,\n *   calls: [\n *     {\n *       data: '0xdeadbeef',\n *       to: '0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad',\n *       value: 700000000000000000n,\n *     },\n *   ],\n *   chainId: 1,\n *   feeToken: '0x20c0000000000000000000000000000000000000',\n *   from: '0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6',\n *   gas: 278365n,\n *   hash: '0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0',\n *   input:\n *     '0x3593564c000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000006643504700000000000000000000000000000000000000000000000000000000000000040b080604000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000002800000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000009b6e64a8ec600000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000009b6e64a8ec60000000000000000000000000000000000000000000000000000019124bb5ae978c000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b80000000000000000000000000000000000000000000000000000000000000060000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b8000000000000000000000000000000fee13a103a10d593b9ae06b3e05f2e7e1c00000000000000000000000000000000000000000000000000000000000000190000000000000000000000000000000000000000000000000000000000000060000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b800000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000190240001b9872b',\n *   maxFeePerGas: 11985937556n,\n *   maxPriorityFeePerGas: 68993984n,\n *   nonce: 855n,\n *   signature: {\n *     signature: {\n *       r: 44944627813007772897391531230081695102703289123332187696115181104739239197517n,\n *       s: 36528503505192438307355164441104001310566505351980369085208178712678799181120n,\n *       yParity: 0,\n *     },\n *     type: 'secp256k1',\n *   },\n *   transactionIndex: 2,\n *   type: 'tempo',\n * })\n * ```\n *\n * @param transaction - The transaction to convert.\n * @returns An RPC-formatted transaction.\n */ function toRpc(transaction, _options) {\n    const rpc = _core_Transaction_js__WEBPACK_IMPORTED_MODULE_0__.toRpc(transaction);\n    rpc.type = toRpcType[transaction.type];\n    if (transaction.authorizationList) rpc.aaAuthorizationList = _AuthorizationTempo_js__WEBPACK_IMPORTED_MODULE_1__.toRpcList(transaction.authorizationList);\n    if (transaction.calls) rpc.calls = transaction.calls.map((call)=>({\n            to: call.to,\n            value: call.value ? _core_Hex_js__WEBPACK_IMPORTED_MODULE_5__.fromNumber(call.value) : undefined,\n            data: call.data\n        }));\n    if (transaction.feeToken) rpc.feeToken = transaction.feeToken;\n    if (transaction.keyAuthorization) rpc.keyAuthorization = _KeyAuthorization_js__WEBPACK_IMPORTED_MODULE_3__.toRpc(transaction.keyAuthorization);\n    if (transaction.feePayerSignature) {\n        rpc.feePayerSignature = _core_Signature_js__WEBPACK_IMPORTED_MODULE_4__.toRpc(transaction.feePayerSignature);\n        rpc.feePayerSignature.v = _core_Hex_js__WEBPACK_IMPORTED_MODULE_5__.fromNumber(_core_Signature_js__WEBPACK_IMPORTED_MODULE_4__.yParityToV(transaction.feePayerSignature?.yParity));\n    }\n    if (transaction.signature) rpc.signature = _SignatureEnvelope_js__WEBPACK_IMPORTED_MODULE_2__.toRpc(transaction.signature);\n    if (typeof transaction.validAfter === \"number\") rpc.validAfter = _core_Hex_js__WEBPACK_IMPORTED_MODULE_5__.fromNumber(transaction.validAfter);\n    if (typeof transaction.validBefore === \"number\") rpc.validBefore = _core_Hex_js__WEBPACK_IMPORTED_MODULE_5__.fromNumber(transaction.validBefore);\n    return rpc;\n} //# sourceMappingURL=Transaction.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS90ZW1wby9UcmFuc2FjdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQXNDO0FBQ1k7QUFDTztBQUNLO0FBQ0o7QUFDRTtBQUM1RCw4QkFBOEIsR0FDdkIsTUFBTU0sWUFBWTtJQUNyQixHQUFHSiwyREFBd0I7SUFDM0JLLE9BQU87QUFDWCxFQUFFO0FBQ0YsOEJBQThCLEdBQ3ZCLE1BQU1DLGNBQWM7SUFDdkIsR0FBR04sNkRBQTBCO0lBQzdCLFFBQVE7QUFDWixFQUFFO0FBQ0Y7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0EyQ0MsR0FDTSxTQUFTTyxRQUFRQyxXQUFXLEVBQUVDLFdBQVcsQ0FBQyxDQUFDO0lBQzlDLElBQUksQ0FBQ0QsYUFDRCxPQUFPO0lBQ1gsTUFBTUUsZUFBZVYseURBQXNCLENBQUNRO0lBQzVDRSxhQUFhQyxJQUFJLEdBQUdMLFdBQVcsQ0FBQ0UsWUFBWUcsSUFBSSxDQUFDO0lBQ2pELElBQUlILFlBQVlJLG1CQUFtQixFQUFFO1FBQ2pDRixhQUFhRyxpQkFBaUIsR0FBR1osK0RBQThCLENBQUNPLFlBQVlJLG1CQUFtQjtRQUMvRixPQUFPRixhQUFhRSxtQkFBbUI7SUFDM0M7SUFDQSxJQUFJSixZQUFZTyxLQUFLLEVBQ2pCTCxhQUFhSyxLQUFLLEdBQUdQLFlBQVlPLEtBQUssQ0FBQ0MsR0FBRyxDQUFDLENBQUNDLE9BQVU7WUFDbERDLElBQUlELEtBQUtDLEVBQUU7WUFDWEMsT0FBT0YsS0FBS0UsS0FBSyxJQUFJRixLQUFLRSxLQUFLLEtBQUssT0FBT0MsT0FBT0gsS0FBS0UsS0FBSyxJQUFJRTtZQUNoRSxtQkFBbUI7WUFDbkJDLE1BQU1MLEtBQUtNLEtBQUssSUFBSU4sS0FBS0ssSUFBSSxJQUFJO1FBQ3JDO0lBQ0osSUFBSWQsWUFBWWdCLFFBQVEsRUFDcEJkLGFBQWFjLFFBQVEsR0FBR2hCLFlBQVlnQixRQUFRO0lBQ2hELElBQUloQixZQUFZaUIsUUFBUSxFQUNwQmYsYUFBYWUsUUFBUSxHQUFHTCxPQUFPWixZQUFZaUIsUUFBUTtJQUN2RCxJQUFJakIsWUFBWWtCLFNBQVMsRUFDckJoQixhQUFhZ0IsU0FBUyxHQUFHdkIsMERBQXlCLENBQUNLLFlBQVlrQixTQUFTO0lBQzVFLElBQUlsQixZQUFZbUIsVUFBVSxFQUN0QmpCLGFBQWFpQixVQUFVLEdBQUdDLE9BQU9wQixZQUFZbUIsVUFBVTtJQUMzRCxJQUFJbkIsWUFBWXFCLFdBQVcsRUFDdkJuQixhQUFhbUIsV0FBVyxHQUFHRCxPQUFPcEIsWUFBWXFCLFdBQVc7SUFDN0QsSUFBSXJCLFlBQVlzQixnQkFBZ0IsRUFDNUJwQixhQUFhb0IsZ0JBQWdCLEdBQUc1Qix5REFBd0IsQ0FBQ00sWUFBWXNCLGdCQUFnQjtJQUN6RixJQUFJdEIsWUFBWXVCLGlCQUFpQixFQUFFO1FBQy9CckIsYUFBYXFCLGlCQUFpQixHQUFHaEMsdURBQWlCLENBQUNTLFlBQVl1QixpQkFBaUI7UUFDaEZyQixhQUFhcUIsaUJBQWlCLENBQUNDLENBQUMsR0FBR2pDLDBEQUFvQixDQUFDVyxhQUFhcUIsaUJBQWlCLENBQUNHLE9BQU87SUFDbEc7SUFDQSxPQUFPeEI7QUFDWDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQTRDQyxHQUNNLFNBQVN5QixNQUFNM0IsV0FBVyxFQUFFQyxRQUFRO0lBQ3ZDLE1BQU0yQixNQUFNcEMsdURBQW9CLENBQUNRO0lBQ2pDNEIsSUFBSXpCLElBQUksR0FBR1AsU0FBUyxDQUFDSSxZQUFZRyxJQUFJLENBQUM7SUFDdEMsSUFBSUgsWUFBWUssaUJBQWlCLEVBQzdCdUIsSUFBSXhCLG1CQUFtQixHQUFHWCw2REFBNEIsQ0FBQ08sWUFBWUssaUJBQWlCO0lBQ3hGLElBQUlMLFlBQVlPLEtBQUssRUFDakJxQixJQUFJckIsS0FBSyxHQUFHUCxZQUFZTyxLQUFLLENBQUNDLEdBQUcsQ0FBQyxDQUFDQyxPQUFVO1lBQ3pDQyxJQUFJRCxLQUFLQyxFQUFFO1lBQ1hDLE9BQU9GLEtBQUtFLEtBQUssR0FBR3JCLG9EQUFjLENBQUNtQixLQUFLRSxLQUFLLElBQUlFO1lBQ2pEQyxNQUFNTCxLQUFLSyxJQUFJO1FBQ25CO0lBQ0osSUFBSWQsWUFBWWdCLFFBQVEsRUFDcEJZLElBQUlaLFFBQVEsR0FBR2hCLFlBQVlnQixRQUFRO0lBQ3ZDLElBQUloQixZQUFZc0IsZ0JBQWdCLEVBQzVCTSxJQUFJTixnQkFBZ0IsR0FBRzVCLHVEQUFzQixDQUFDTSxZQUFZc0IsZ0JBQWdCO0lBQzlFLElBQUl0QixZQUFZdUIsaUJBQWlCLEVBQUU7UUFDL0JLLElBQUlMLGlCQUFpQixHQUFHaEMscURBQWUsQ0FBQ1MsWUFBWXVCLGlCQUFpQjtRQUNyRUssSUFBSUwsaUJBQWlCLENBQUNDLENBQUMsR0FBR2xDLG9EQUFjLENBQUNDLDBEQUFvQixDQUFDUyxZQUFZdUIsaUJBQWlCLEVBQUVHO0lBQ2pHO0lBQ0EsSUFBSTFCLFlBQVlrQixTQUFTLEVBQ3JCVSxJQUFJVixTQUFTLEdBQUd2Qix3REFBdUIsQ0FBQ0ssWUFBWWtCLFNBQVM7SUFDakUsSUFBSSxPQUFPbEIsWUFBWW1CLFVBQVUsS0FBSyxVQUNsQ1MsSUFBSVQsVUFBVSxHQUFHN0Isb0RBQWMsQ0FBQ1UsWUFBWW1CLFVBQVU7SUFDMUQsSUFBSSxPQUFPbkIsWUFBWXFCLFdBQVcsS0FBSyxVQUNuQ08sSUFBSVAsV0FBVyxHQUFHL0Isb0RBQWMsQ0FBQ1UsWUFBWXFCLFdBQVc7SUFDNUQsT0FBT087QUFDWCxFQUNBLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsYXctd29ya3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS90ZW1wby9UcmFuc2FjdGlvbi5qcz9lZGIyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEhleCBmcm9tICcuLi9jb3JlL0hleC5qcyc7XG5pbXBvcnQgKiBhcyBTaWduYXR1cmUgZnJvbSAnLi4vY29yZS9TaWduYXR1cmUuanMnO1xuaW1wb3J0ICogYXMgb3hfVHJhbnNhY3Rpb24gZnJvbSAnLi4vY29yZS9UcmFuc2FjdGlvbi5qcyc7XG5pbXBvcnQgKiBhcyBBdXRob3JpemF0aW9uVGVtcG8gZnJvbSAnLi9BdXRob3JpemF0aW9uVGVtcG8uanMnO1xuaW1wb3J0ICogYXMgS2V5QXV0aG9yaXphdGlvbiBmcm9tICcuL0tleUF1dGhvcml6YXRpb24uanMnO1xuaW1wb3J0ICogYXMgU2lnbmF0dXJlRW52ZWxvcGUgZnJvbSAnLi9TaWduYXR1cmVFbnZlbG9wZS5qcyc7XG4vKiogVHlwZSB0byBSUEMgVHlwZSBtYXBwaW5nLiAqL1xuZXhwb3J0IGNvbnN0IHRvUnBjVHlwZSA9IHtcbiAgICAuLi5veF9UcmFuc2FjdGlvbi50b1JwY1R5cGUsXG4gICAgdGVtcG86ICcweDc2Jyxcbn07XG4vKiogUlBDIFR5cGUgdG8gVHlwZSBtYXBwaW5nLiAqL1xuZXhwb3J0IGNvbnN0IGZyb21ScGNUeXBlID0ge1xuICAgIC4uLm94X1RyYW5zYWN0aW9uLmZyb21ScGNUeXBlLFxuICAgICcweDc2JzogJ3RlbXBvJyxcbn07XG4vKipcbiAqIENvbnZlcnRzIGFuIHtAbGluayBveCNUcmFuc2FjdGlvbi5ScGN9IHRvIGFuIHtAbGluayBveCNUcmFuc2FjdGlvbi5UcmFuc2FjdGlvbn0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBUcmFuc2FjdGlvbiB9IGZyb20gJ294L3RlbXBvJ1xuICpcbiAqIGNvbnN0IHRyYW5zYWN0aW9uID0gVHJhbnNhY3Rpb24uZnJvbVJwYyh7XG4gKiAgIGhhc2g6ICcweDM1M2ZkZmMzOGEyZjI2MTE1ZGFhZGVlOWY1YjgzOTJjZTYyYjg0ZjQxMDk1Nzk2N2UyZWQ1NmIzNTMzOGNkZDAnLFxuICogICBub25jZTogJzB4MzU3JyxcbiAqICAgYmxvY2tIYXNoOlxuICogICAgICcweGMzNTBkODA3NTA1ZmI4MzU2NTBmMDAxMzYzMmM1NTE1NTkyOTg3YmExNjliYmM2NjI2ZDlmYzU0ZDkxZjBmMGInLFxuICogICBibG9ja051bWJlcjogJzB4MTJmMjk2ZicsXG4gKiAgIGNhbGxzOiBbXG4gKiAgICAge1xuICogICAgICAgaW5wdXQ6ICcweGRlYWRiZWVmJyxcbiAqICAgICAgIHRvOiAnMHgzZmM5MWEzYWZkNzAzOTVjZDQ5NmM2NDdkNWE2Y2M5ZDRiMmI3ZmFkJyxcbiAqICAgICAgIHZhbHVlOiAnMHg5YjZlNjRhOGVjNjAwMDAnLFxuICogICAgIH0sXG4gKiAgIF0sXG4gKiAgIGZlZVRva2VuOiAnMHgyMGMwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgdHJhbnNhY3Rpb25JbmRleDogJzB4MicsXG4gKiAgIGZyb206ICcweDgxNGU1ZTBlMzEwMTZiOWE3ZjEzOGM3NmI3ZTdiMmJiNWMxYWI2YTYnLFxuICogICB2YWx1ZTogJzB4OWI2ZTY0YThlYzYwMDAwJyxcbiAqICAgZ2FzOiAnMHg0M2Y1ZCcsXG4gKiAgIG1heEZlZVBlckdhczogJzB4MmNhNmFlNDk0JyxcbiAqICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6ICcweDQxY2MzYzAnLFxuICogICBpbnB1dDpcbiAqICAgICAnMHgzNTkzNTY0YzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA2NjQzNTA0NzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDQwYjA4MDYwNDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwODAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGUwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyODAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDQwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA5YjZlNjRhOGVjNjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA5YjZlNjRhOGVjNjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTkxMjRiYjVhZTk3OGMwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBhMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwYzAyYWFhMzliMjIzZmU4ZDBhMGU1YzRmMjdlYWQ5MDgzYzc1NmNjMjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGM1NmM3YTBlYWE4MDRmODU0YjUzNmE1ZjNkNWY0OWQyZWM0YjEyYjgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDYwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwYzU2YzdhMGVhYTgwNGY4NTRiNTM2YTVmM2Q1ZjQ5ZDJlYzRiMTJiODAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGZlZTEzYTEwM2ExMGQ1OTNiOWFlMDZiM2UwNWYyZTdlMWMwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDE5MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA2MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGM1NmM3YTBlYWE4MDRmODU0YjUzNmE1ZjNkNWY0OWQyZWM0YjEyYjgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDE5MDI0MDAwMWI5ODcyYicsXG4gKiAgIHNpZ25hdHVyZToge1xuICogICAgIHI6ICcweDYzNWRjMjAzM2U2MDE4NWJiMzY3MDljMjljNzVkNjRlYTUxZGZiZDkxYzMyZWY0YmUxOThlNGNlYjE2OWZiNGQnLFxuICogICAgIHM6ICcweDUwYzI2NjdhYzRjNzcxMDcyNzQ2YWNmZGNmMWYxNDgzMzM2ZGNjYThiZDJkZjQ3Y2Q4MzE3NWRiZTYwZjA1NDAnLFxuICogICAgIHR5cGU6ICdzZWNwMjU2azEnLFxuICogICAgIHlQYXJpdHk6ICcweDAnLFxuICogICB9LFxuICogICBjaGFpbklkOiAnMHgxJyxcbiAqICAgYWNjZXNzTGlzdDogW10sXG4gKiAgIHR5cGU6ICcweDc2JyxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdHJhbnNhY3Rpb24gLSBUaGUgUlBDIHRyYW5zYWN0aW9uIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBBbiBpbnN0YW50aWF0ZWQge0BsaW5rIG94I1RyYW5zYWN0aW9uLlRyYW5zYWN0aW9ufS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21ScGModHJhbnNhY3Rpb24sIF9vcHRpb25zID0ge30pIHtcbiAgICBpZiAoIXRyYW5zYWN0aW9uKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCB0cmFuc2FjdGlvbl8gPSBveF9UcmFuc2FjdGlvbi5mcm9tUnBjKHRyYW5zYWN0aW9uKTtcbiAgICB0cmFuc2FjdGlvbl8udHlwZSA9IGZyb21ScGNUeXBlW3RyYW5zYWN0aW9uLnR5cGVdO1xuICAgIGlmICh0cmFuc2FjdGlvbi5hYUF1dGhvcml6YXRpb25MaXN0KSB7XG4gICAgICAgIHRyYW5zYWN0aW9uXy5hdXRob3JpemF0aW9uTGlzdCA9IEF1dGhvcml6YXRpb25UZW1wby5mcm9tUnBjTGlzdCh0cmFuc2FjdGlvbi5hYUF1dGhvcml6YXRpb25MaXN0KTtcbiAgICAgICAgZGVsZXRlIHRyYW5zYWN0aW9uXy5hYUF1dGhvcml6YXRpb25MaXN0O1xuICAgIH1cbiAgICBpZiAodHJhbnNhY3Rpb24uY2FsbHMpXG4gICAgICAgIHRyYW5zYWN0aW9uXy5jYWxscyA9IHRyYW5zYWN0aW9uLmNhbGxzLm1hcCgoY2FsbCkgPT4gKHtcbiAgICAgICAgICAgIHRvOiBjYWxsLnRvLFxuICAgICAgICAgICAgdmFsdWU6IGNhbGwudmFsdWUgJiYgY2FsbC52YWx1ZSAhPT0gJzB4JyA/IEJpZ0ludChjYWxsLnZhbHVlKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIGRhdGE6IGNhbGwuaW5wdXQgfHwgY2FsbC5kYXRhIHx8ICcweCcsXG4gICAgICAgIH0pKTtcbiAgICBpZiAodHJhbnNhY3Rpb24uZmVlVG9rZW4pXG4gICAgICAgIHRyYW5zYWN0aW9uXy5mZWVUb2tlbiA9IHRyYW5zYWN0aW9uLmZlZVRva2VuO1xuICAgIGlmICh0cmFuc2FjdGlvbi5ub25jZUtleSlcbiAgICAgICAgdHJhbnNhY3Rpb25fLm5vbmNlS2V5ID0gQmlnSW50KHRyYW5zYWN0aW9uLm5vbmNlS2V5KTtcbiAgICBpZiAodHJhbnNhY3Rpb24uc2lnbmF0dXJlKVxuICAgICAgICB0cmFuc2FjdGlvbl8uc2lnbmF0dXJlID0gU2lnbmF0dXJlRW52ZWxvcGUuZnJvbVJwYyh0cmFuc2FjdGlvbi5zaWduYXR1cmUpO1xuICAgIGlmICh0cmFuc2FjdGlvbi52YWxpZEFmdGVyKVxuICAgICAgICB0cmFuc2FjdGlvbl8udmFsaWRBZnRlciA9IE51bWJlcih0cmFuc2FjdGlvbi52YWxpZEFmdGVyKTtcbiAgICBpZiAodHJhbnNhY3Rpb24udmFsaWRCZWZvcmUpXG4gICAgICAgIHRyYW5zYWN0aW9uXy52YWxpZEJlZm9yZSA9IE51bWJlcih0cmFuc2FjdGlvbi52YWxpZEJlZm9yZSk7XG4gICAgaWYgKHRyYW5zYWN0aW9uLmtleUF1dGhvcml6YXRpb24pXG4gICAgICAgIHRyYW5zYWN0aW9uXy5rZXlBdXRob3JpemF0aW9uID0gS2V5QXV0aG9yaXphdGlvbi5mcm9tUnBjKHRyYW5zYWN0aW9uLmtleUF1dGhvcml6YXRpb24pO1xuICAgIGlmICh0cmFuc2FjdGlvbi5mZWVQYXllclNpZ25hdHVyZSkge1xuICAgICAgICB0cmFuc2FjdGlvbl8uZmVlUGF5ZXJTaWduYXR1cmUgPSBTaWduYXR1cmUuZnJvbVJwYyh0cmFuc2FjdGlvbi5mZWVQYXllclNpZ25hdHVyZSk7XG4gICAgICAgIHRyYW5zYWN0aW9uXy5mZWVQYXllclNpZ25hdHVyZS52ID0gU2lnbmF0dXJlLnlQYXJpdHlUb1YodHJhbnNhY3Rpb25fLmZlZVBheWVyU2lnbmF0dXJlLnlQYXJpdHkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNhY3Rpb25fO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiB7QGxpbmsgb3gjVHJhbnNhY3Rpb24uVHJhbnNhY3Rpb259IHRvIGFuIHtAbGluayBveCNUcmFuc2FjdGlvbi5ScGN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHJhbnNhY3Rpb24gfSBmcm9tICdveC90ZW1wbydcbiAqXG4gKiBjb25zdCB0cmFuc2FjdGlvbiA9IFRyYW5zYWN0aW9uLnRvUnBjKHtcbiAqICAgYWNjZXNzTGlzdDogW10sXG4gKiAgIGJsb2NrSGFzaDpcbiAqICAgICAnMHhjMzUwZDgwNzUwNWZiODM1NjUwZjAwMTM2MzJjNTUxNTU5Mjk4N2JhMTY5YmJjNjYyNmQ5ZmM1NGQ5MWYwZjBiJyxcbiAqICAgYmxvY2tOdW1iZXI6IDE5ODY4MDE1bixcbiAqICAgY2FsbHM6IFtcbiAqICAgICB7XG4gKiAgICAgICBkYXRhOiAnMHhkZWFkYmVlZicsXG4gKiAgICAgICB0bzogJzB4M2ZjOTFhM2FmZDcwMzk1Y2Q0OTZjNjQ3ZDVhNmNjOWQ0YjJiN2ZhZCcsXG4gKiAgICAgICB2YWx1ZTogNzAwMDAwMDAwMDAwMDAwMDAwbixcbiAqICAgICB9LFxuICogICBdLFxuICogICBjaGFpbklkOiAxLFxuICogICBmZWVUb2tlbjogJzB4MjBjMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIGZyb206ICcweDgxNGU1ZTBlMzEwMTZiOWE3ZjEzOGM3NmI3ZTdiMmJiNWMxYWI2YTYnLFxuICogICBnYXM6IDI3ODM2NW4sXG4gKiAgIGhhc2g6ICcweDM1M2ZkZmMzOGEyZjI2MTE1ZGFhZGVlOWY1YjgzOTJjZTYyYjg0ZjQxMDk1Nzk2N2UyZWQ1NmIzNTMzOGNkZDAnLFxuICogICBpbnB1dDpcbiAqICAgICAnMHgzNTkzNTY0YzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA2NjQzNTA0NzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDQwYjA4MDYwNDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwODAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGUwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyODAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDQwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA5YjZlNjRhOGVjNjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA5YjZlNjRhOGVjNjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTkxMjRiYjVhZTk3OGMwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBhMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwYzAyYWFhMzliMjIzZmU4ZDBhMGU1YzRmMjdlYWQ5MDgzYzc1NmNjMjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGM1NmM3YTBlYWE4MDRmODU0YjUzNmE1ZjNkNWY0OWQyZWM0YjEyYjgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDYwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwYzU2YzdhMGVhYTgwNGY4NTRiNTM2YTVmM2Q1ZjQ5ZDJlYzRiMTJiODAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGZlZTEzYTEwM2ExMGQ1OTNiOWFlMDZiM2UwNWYyZTdlMWMwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDE5MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA2MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGM1NmM3YTBlYWE4MDRmODU0YjUzNmE1ZjNkNWY0OWQyZWM0YjEyYjgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDE5MDI0MDAwMWI5ODcyYicsXG4gKiAgIG1heEZlZVBlckdhczogMTE5ODU5Mzc1NTZuLFxuICogICBtYXhQcmlvcml0eUZlZVBlckdhczogNjg5OTM5ODRuLFxuICogICBub25jZTogODU1bixcbiAqICAgc2lnbmF0dXJlOiB7XG4gKiAgICAgc2lnbmF0dXJlOiB7XG4gKiAgICAgICByOiA0NDk0NDYyNzgxMzAwNzc3Mjg5NzM5MTUzMTIzMDA4MTY5NTEwMjcwMzI4OTEyMzMzMjE4NzY5NjExNTE4MTEwNDczOTIzOTE5NzUxN24sXG4gKiAgICAgICBzOiAzNjUyODUwMzUwNTE5MjQzODMwNzM1NTE2NDQ0MTEwNDAwMTMxMDU2NjUwNTM1MTk4MDM2OTA4NTIwODE3ODcxMjY3ODc5OTE4MTEyMG4sXG4gKiAgICAgICB5UGFyaXR5OiAwLFxuICogICAgIH0sXG4gKiAgICAgdHlwZTogJ3NlY3AyNTZrMScsXG4gKiAgIH0sXG4gKiAgIHRyYW5zYWN0aW9uSW5kZXg6IDIsXG4gKiAgIHR5cGU6ICd0ZW1wbycsXG4gKiB9KVxuICogYGBgXG4gKlxuICogQHBhcmFtIHRyYW5zYWN0aW9uIC0gVGhlIHRyYW5zYWN0aW9uIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBBbiBSUEMtZm9ybWF0dGVkIHRyYW5zYWN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9ScGModHJhbnNhY3Rpb24sIF9vcHRpb25zKSB7XG4gICAgY29uc3QgcnBjID0gb3hfVHJhbnNhY3Rpb24udG9ScGModHJhbnNhY3Rpb24pO1xuICAgIHJwYy50eXBlID0gdG9ScGNUeXBlW3RyYW5zYWN0aW9uLnR5cGVdO1xuICAgIGlmICh0cmFuc2FjdGlvbi5hdXRob3JpemF0aW9uTGlzdClcbiAgICAgICAgcnBjLmFhQXV0aG9yaXphdGlvbkxpc3QgPSBBdXRob3JpemF0aW9uVGVtcG8udG9ScGNMaXN0KHRyYW5zYWN0aW9uLmF1dGhvcml6YXRpb25MaXN0KTtcbiAgICBpZiAodHJhbnNhY3Rpb24uY2FsbHMpXG4gICAgICAgIHJwYy5jYWxscyA9IHRyYW5zYWN0aW9uLmNhbGxzLm1hcCgoY2FsbCkgPT4gKHtcbiAgICAgICAgICAgIHRvOiBjYWxsLnRvLFxuICAgICAgICAgICAgdmFsdWU6IGNhbGwudmFsdWUgPyBIZXguZnJvbU51bWJlcihjYWxsLnZhbHVlKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGRhdGE6IGNhbGwuZGF0YSxcbiAgICAgICAgfSkpO1xuICAgIGlmICh0cmFuc2FjdGlvbi5mZWVUb2tlbilcbiAgICAgICAgcnBjLmZlZVRva2VuID0gdHJhbnNhY3Rpb24uZmVlVG9rZW47XG4gICAgaWYgKHRyYW5zYWN0aW9uLmtleUF1dGhvcml6YXRpb24pXG4gICAgICAgIHJwYy5rZXlBdXRob3JpemF0aW9uID0gS2V5QXV0aG9yaXphdGlvbi50b1JwYyh0cmFuc2FjdGlvbi5rZXlBdXRob3JpemF0aW9uKTtcbiAgICBpZiAodHJhbnNhY3Rpb24uZmVlUGF5ZXJTaWduYXR1cmUpIHtcbiAgICAgICAgcnBjLmZlZVBheWVyU2lnbmF0dXJlID0gU2lnbmF0dXJlLnRvUnBjKHRyYW5zYWN0aW9uLmZlZVBheWVyU2lnbmF0dXJlKTtcbiAgICAgICAgcnBjLmZlZVBheWVyU2lnbmF0dXJlLnYgPSBIZXguZnJvbU51bWJlcihTaWduYXR1cmUueVBhcml0eVRvVih0cmFuc2FjdGlvbi5mZWVQYXllclNpZ25hdHVyZT8ueVBhcml0eSkpO1xuICAgIH1cbiAgICBpZiAodHJhbnNhY3Rpb24uc2lnbmF0dXJlKVxuICAgICAgICBycGMuc2lnbmF0dXJlID0gU2lnbmF0dXJlRW52ZWxvcGUudG9ScGModHJhbnNhY3Rpb24uc2lnbmF0dXJlKTtcbiAgICBpZiAodHlwZW9mIHRyYW5zYWN0aW9uLnZhbGlkQWZ0ZXIgPT09ICdudW1iZXInKVxuICAgICAgICBycGMudmFsaWRBZnRlciA9IEhleC5mcm9tTnVtYmVyKHRyYW5zYWN0aW9uLnZhbGlkQWZ0ZXIpO1xuICAgIGlmICh0eXBlb2YgdHJhbnNhY3Rpb24udmFsaWRCZWZvcmUgPT09ICdudW1iZXInKVxuICAgICAgICBycGMudmFsaWRCZWZvcmUgPSBIZXguZnJvbU51bWJlcih0cmFuc2FjdGlvbi52YWxpZEJlZm9yZSk7XG4gICAgcmV0dXJuIHJwYztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRyYW5zYWN0aW9uLmpzLm1hcCJdLCJuYW1lcyI6WyJIZXgiLCJTaWduYXR1cmUiLCJveF9UcmFuc2FjdGlvbiIsIkF1dGhvcml6YXRpb25UZW1wbyIsIktleUF1dGhvcml6YXRpb24iLCJTaWduYXR1cmVFbnZlbG9wZSIsInRvUnBjVHlwZSIsInRlbXBvIiwiZnJvbVJwY1R5cGUiLCJmcm9tUnBjIiwidHJhbnNhY3Rpb24iLCJfb3B0aW9ucyIsInRyYW5zYWN0aW9uXyIsInR5cGUiLCJhYUF1dGhvcml6YXRpb25MaXN0IiwiYXV0aG9yaXphdGlvbkxpc3QiLCJmcm9tUnBjTGlzdCIsImNhbGxzIiwibWFwIiwiY2FsbCIsInRvIiwidmFsdWUiLCJCaWdJbnQiLCJ1bmRlZmluZWQiLCJkYXRhIiwiaW5wdXQiLCJmZWVUb2tlbiIsIm5vbmNlS2V5Iiwic2lnbmF0dXJlIiwidmFsaWRBZnRlciIsIk51bWJlciIsInZhbGlkQmVmb3JlIiwia2V5QXV0aG9yaXphdGlvbiIsImZlZVBheWVyU2lnbmF0dXJlIiwidiIsInlQYXJpdHlUb1YiLCJ5UGFyaXR5IiwidG9ScGMiLCJycGMiLCJ0b1JwY0xpc3QiLCJmcm9tTnVtYmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/tempo/Transaction.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/tempo/TransactionRequest.js":
/*!**********************************************************!*\
  !*** ./node_modules/ox/_esm/tempo/TransactionRequest.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toRpc: () => (/* binding */ toRpc)\n/* harmony export */ });\n/* harmony import */ var _core_Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _core_TransactionRequest_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/TransactionRequest.js */ \"(ssr)/./node_modules/ox/_esm/core/TransactionRequest.js\");\n/* harmony import */ var _AuthorizationTempo_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AuthorizationTempo.js */ \"(ssr)/./node_modules/ox/_esm/tempo/AuthorizationTempo.js\");\n/* harmony import */ var _KeyAuthorization_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./KeyAuthorization.js */ \"(ssr)/./node_modules/ox/_esm/tempo/KeyAuthorization.js\");\n/* harmony import */ var _TokenId_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./TokenId.js */ \"(ssr)/./node_modules/ox/_esm/tempo/TokenId.js\");\n/* harmony import */ var _Transaction_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Transaction.js */ \"(ssr)/./node_modules/ox/_esm/tempo/Transaction.js\");\n\n\n\n\n\n\n/**\n * Converts a {@link ox#TransactionRequest.TransactionRequest} to a {@link ox#TransactionRequest.Rpc}.\n *\n * @see {@link https://docs.tempo.xyz/protocol/transactions Tempo Transactions}\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n * import { TransactionRequest } from 'ox/tempo'\n *\n * const request = TransactionRequest.toRpc({\n *   calls: [{\n *     data: '0xdeadbeef',\n *     to: '0xcafebabecafebabecafebabecafebabecafebabe',\n *   }],\n *   feeToken: '0x20c0000000000000000000000000000000000000',\n * })\n * ```\n *\n * @example\n * ### Using with a Provider\n *\n * You can use {@link ox#Provider.(from:function)} to instantiate an EIP-1193 Provider and\n * send a transaction to the Wallet using the `eth_sendTransaction` method.\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { Provider, Value } from 'ox'\n * import { TransactionRequest } from 'ox/tempo'\n *\n * const provider = Provider.from(window.ethereum!)\n *\n * const request = TransactionRequest.toRpc({\n *   calls: [{\n *     data: '0xdeadbeef',\n *     to: '0xcafebabecafebabecafebabecafebabecafebabe',\n *   }],\n *   feeToken: '0x20c0000000000000000000000000000000000000',\n * })\n *\n * const hash = await provider.request({ // [!code focus]\n *   method: 'eth_sendTransaction', // [!code focus]\n *   params: [request], // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param request - The request to convert.\n * @returns An RPC request.\n */ function toRpc(request) {\n    const request_rpc = _core_TransactionRequest_js__WEBPACK_IMPORTED_MODULE_0__.toRpc({\n        ...request,\n        authorizationList: undefined\n    });\n    if (request.authorizationList) request_rpc.authorizationList = _AuthorizationTempo_js__WEBPACK_IMPORTED_MODULE_1__.toRpcList(request.authorizationList);\n    if (request.calls) request_rpc.calls = request.calls.map((call)=>({\n            to: call.to,\n            value: call.value ? _core_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(call.value) : \"0x\",\n            data: call.data ?? \"0x\"\n        }));\n    if (typeof request.feeToken !== \"undefined\") request_rpc.feeToken = _TokenId_js__WEBPACK_IMPORTED_MODULE_3__.toAddress(request.feeToken);\n    if (request.keyAuthorization) request_rpc.keyAuthorization = _KeyAuthorization_js__WEBPACK_IMPORTED_MODULE_4__.toRpc(request.keyAuthorization);\n    if (typeof request.validBefore !== \"undefined\") request_rpc.validBefore = _core_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(request.validBefore);\n    if (typeof request.validAfter !== \"undefined\") request_rpc.validAfter = _core_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(request.validAfter);\n    const nonceKey = (()=>{\n        if (request.nonceKey === \"random\") return _core_Hex_js__WEBPACK_IMPORTED_MODULE_2__.random(6);\n        if (typeof request.nonceKey === \"bigint\") return _core_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(request.nonceKey);\n        return undefined;\n    })();\n    if (nonceKey) request_rpc.nonceKey = nonceKey;\n    if (typeof request.calls !== \"undefined\" || typeof request.feeToken !== \"undefined\" || typeof request.keyAuthorization !== \"undefined\" || typeof request.nonceKey !== \"undefined\" || typeof request.validBefore !== \"undefined\" || typeof request.validAfter !== \"undefined\" || request.type === \"tempo\") {\n        request_rpc.type = _Transaction_js__WEBPACK_IMPORTED_MODULE_5__.toRpcType.tempo;\n        delete request_rpc.data;\n        delete request_rpc.input;\n        delete request_rpc.to;\n        delete request_rpc.value;\n    }\n    return request_rpc;\n} //# sourceMappingURL=TransactionRequest.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS90ZW1wby9UcmFuc2FjdGlvblJlcXVlc3QuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFzQztBQUNpQztBQUNUO0FBQ0o7QUFDbEI7QUFDUTtBQUNoRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBZ0RDLEdBQ00sU0FBU00sTUFBTUMsT0FBTztJQUN6QixNQUFNQyxjQUFjUCw4REFBMkIsQ0FBQztRQUM1QyxHQUFHTSxPQUFPO1FBQ1ZFLG1CQUFtQkM7SUFDdkI7SUFDQSxJQUFJSCxRQUFRRSxpQkFBaUIsRUFDekJELFlBQVlDLGlCQUFpQixHQUFHUCw2REFBNEIsQ0FBQ0ssUUFBUUUsaUJBQWlCO0lBQzFGLElBQUlGLFFBQVFLLEtBQUssRUFDYkosWUFBWUksS0FBSyxHQUFHTCxRQUFRSyxLQUFLLENBQUNDLEdBQUcsQ0FBQyxDQUFDQyxPQUFVO1lBQzdDQyxJQUFJRCxLQUFLQyxFQUFFO1lBQ1hDLE9BQU9GLEtBQUtFLEtBQUssR0FBR2hCLG9EQUFjLENBQUNjLEtBQUtFLEtBQUssSUFBSTtZQUNqREUsTUFBTUosS0FBS0ksSUFBSSxJQUFJO1FBQ3ZCO0lBQ0osSUFBSSxPQUFPWCxRQUFRWSxRQUFRLEtBQUssYUFDNUJYLFlBQVlXLFFBQVEsR0FBR2Ysa0RBQWlCLENBQUNHLFFBQVFZLFFBQVE7SUFDN0QsSUFBSVosUUFBUWMsZ0JBQWdCLEVBQ3hCYixZQUFZYSxnQkFBZ0IsR0FBR2xCLHVEQUFzQixDQUFDSSxRQUFRYyxnQkFBZ0I7SUFDbEYsSUFBSSxPQUFPZCxRQUFRZSxXQUFXLEtBQUssYUFDL0JkLFlBQVljLFdBQVcsR0FBR3RCLG9EQUFjLENBQUNPLFFBQVFlLFdBQVc7SUFDaEUsSUFBSSxPQUFPZixRQUFRZ0IsVUFBVSxLQUFLLGFBQzlCZixZQUFZZSxVQUFVLEdBQUd2QixvREFBYyxDQUFDTyxRQUFRZ0IsVUFBVTtJQUM5RCxNQUFNQyxXQUFXLENBQUM7UUFDZCxJQUFJakIsUUFBUWlCLFFBQVEsS0FBSyxVQUNyQixPQUFPeEIsZ0RBQVUsQ0FBQztRQUN0QixJQUFJLE9BQU9PLFFBQVFpQixRQUFRLEtBQUssVUFDNUIsT0FBT3hCLG9EQUFjLENBQUNPLFFBQVFpQixRQUFRO1FBQzFDLE9BQU9kO0lBQ1g7SUFDQSxJQUFJYyxVQUNBaEIsWUFBWWdCLFFBQVEsR0FBR0E7SUFDM0IsSUFBSSxPQUFPakIsUUFBUUssS0FBSyxLQUFLLGVBQ3pCLE9BQU9MLFFBQVFZLFFBQVEsS0FBSyxlQUM1QixPQUFPWixRQUFRYyxnQkFBZ0IsS0FBSyxlQUNwQyxPQUFPZCxRQUFRaUIsUUFBUSxLQUFLLGVBQzVCLE9BQU9qQixRQUFRZSxXQUFXLEtBQUssZUFDL0IsT0FBT2YsUUFBUWdCLFVBQVUsS0FBSyxlQUM5QmhCLFFBQVFtQixJQUFJLEtBQUssU0FBUztRQUMxQmxCLFlBQVlrQixJQUFJLEdBQUdyQixzREFBcUIsQ0FBQ3VCLEtBQUs7UUFDOUMsT0FBT3BCLFlBQVlVLElBQUk7UUFDdkIsT0FBT1YsWUFBWXFCLEtBQUs7UUFDeEIsT0FBT3JCLFlBQVlPLEVBQUU7UUFDckIsT0FBT1AsWUFBWVEsS0FBSztJQUM1QjtJQUNBLE9BQU9SO0FBQ1gsRUFDQSw4Q0FBOEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGF3LXdvcmtzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L19lc20vdGVtcG8vVHJhbnNhY3Rpb25SZXF1ZXN0LmpzPzMyYzUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgSGV4IGZyb20gJy4uL2NvcmUvSGV4LmpzJztcbmltcG9ydCAqIGFzIG94X1RyYW5zYWN0aW9uUmVxdWVzdCBmcm9tICcuLi9jb3JlL1RyYW5zYWN0aW9uUmVxdWVzdC5qcyc7XG5pbXBvcnQgKiBhcyBBdXRob3JpemF0aW9uVGVtcG8gZnJvbSAnLi9BdXRob3JpemF0aW9uVGVtcG8uanMnO1xuaW1wb3J0ICogYXMgS2V5QXV0aG9yaXphdGlvbiBmcm9tICcuL0tleUF1dGhvcml6YXRpb24uanMnO1xuaW1wb3J0ICogYXMgVG9rZW5JZCBmcm9tICcuL1Rva2VuSWQuanMnO1xuaW1wb3J0ICogYXMgVHJhbnNhY3Rpb24gZnJvbSAnLi9UcmFuc2FjdGlvbi5qcyc7XG4vKipcbiAqIENvbnZlcnRzIGEge0BsaW5rIG94I1RyYW5zYWN0aW9uUmVxdWVzdC5UcmFuc2FjdGlvblJlcXVlc3R9IHRvIGEge0BsaW5rIG94I1RyYW5zYWN0aW9uUmVxdWVzdC5ScGN9LlxuICpcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZG9jcy50ZW1wby54eXovcHJvdG9jb2wvdHJhbnNhY3Rpb25zIFRlbXBvIFRyYW5zYWN0aW9uc31cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFZhbHVlIH0gZnJvbSAnb3gnXG4gKiBpbXBvcnQgeyBUcmFuc2FjdGlvblJlcXVlc3QgfSBmcm9tICdveC90ZW1wbydcbiAqXG4gKiBjb25zdCByZXF1ZXN0ID0gVHJhbnNhY3Rpb25SZXF1ZXN0LnRvUnBjKHtcbiAqICAgY2FsbHM6IFt7XG4gKiAgICAgZGF0YTogJzB4ZGVhZGJlZWYnLFxuICogICAgIHRvOiAnMHhjYWZlYmFiZWNhZmViYWJlY2FmZWJhYmVjYWZlYmFiZWNhZmViYWJlJyxcbiAqICAgfV0sXG4gKiAgIGZlZVRva2VuOiAnMHgyMGMwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIFVzaW5nIHdpdGggYSBQcm92aWRlclxuICpcbiAqIFlvdSBjYW4gdXNlIHtAbGluayBveCNQcm92aWRlci4oZnJvbTpmdW5jdGlvbil9IHRvIGluc3RhbnRpYXRlIGFuIEVJUC0xMTkzIFByb3ZpZGVyIGFuZFxuICogc2VuZCBhIHRyYW5zYWN0aW9uIHRvIHRoZSBXYWxsZXQgdXNpbmcgdGhlIGBldGhfc2VuZFRyYW5zYWN0aW9uYCBtZXRob2QuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCAnb3gvd2luZG93J1xuICogaW1wb3J0IHsgUHJvdmlkZXIsIFZhbHVlIH0gZnJvbSAnb3gnXG4gKiBpbXBvcnQgeyBUcmFuc2FjdGlvblJlcXVlc3QgfSBmcm9tICdveC90ZW1wbydcbiAqXG4gKiBjb25zdCBwcm92aWRlciA9IFByb3ZpZGVyLmZyb20od2luZG93LmV0aGVyZXVtISlcbiAqXG4gKiBjb25zdCByZXF1ZXN0ID0gVHJhbnNhY3Rpb25SZXF1ZXN0LnRvUnBjKHtcbiAqICAgY2FsbHM6IFt7XG4gKiAgICAgZGF0YTogJzB4ZGVhZGJlZWYnLFxuICogICAgIHRvOiAnMHhjYWZlYmFiZWNhZmViYWJlY2FmZWJhYmVjYWZlYmFiZWNhZmViYWJlJyxcbiAqICAgfV0sXG4gKiAgIGZlZVRva2VuOiAnMHgyMGMwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqIH0pXG4gKlxuICogY29uc3QgaGFzaCA9IGF3YWl0IHByb3ZpZGVyLnJlcXVlc3QoeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIG1ldGhvZDogJ2V0aF9zZW5kVHJhbnNhY3Rpb24nLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHBhcmFtczogW3JlcXVlc3RdLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KSAvLyBbIWNvZGUgZm9jdXNdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gcmVxdWVzdCAtIFRoZSByZXF1ZXN0IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBBbiBSUEMgcmVxdWVzdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvUnBjKHJlcXVlc3QpIHtcbiAgICBjb25zdCByZXF1ZXN0X3JwYyA9IG94X1RyYW5zYWN0aW9uUmVxdWVzdC50b1JwYyh7XG4gICAgICAgIC4uLnJlcXVlc3QsXG4gICAgICAgIGF1dGhvcml6YXRpb25MaXN0OiB1bmRlZmluZWQsXG4gICAgfSk7XG4gICAgaWYgKHJlcXVlc3QuYXV0aG9yaXphdGlvbkxpc3QpXG4gICAgICAgIHJlcXVlc3RfcnBjLmF1dGhvcml6YXRpb25MaXN0ID0gQXV0aG9yaXphdGlvblRlbXBvLnRvUnBjTGlzdChyZXF1ZXN0LmF1dGhvcml6YXRpb25MaXN0KTtcbiAgICBpZiAocmVxdWVzdC5jYWxscylcbiAgICAgICAgcmVxdWVzdF9ycGMuY2FsbHMgPSByZXF1ZXN0LmNhbGxzLm1hcCgoY2FsbCkgPT4gKHtcbiAgICAgICAgICAgIHRvOiBjYWxsLnRvLFxuICAgICAgICAgICAgdmFsdWU6IGNhbGwudmFsdWUgPyBIZXguZnJvbU51bWJlcihjYWxsLnZhbHVlKSA6ICcweCcsXG4gICAgICAgICAgICBkYXRhOiBjYWxsLmRhdGEgPz8gJzB4JyxcbiAgICAgICAgfSkpO1xuICAgIGlmICh0eXBlb2YgcmVxdWVzdC5mZWVUb2tlbiAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJlcXVlc3RfcnBjLmZlZVRva2VuID0gVG9rZW5JZC50b0FkZHJlc3MocmVxdWVzdC5mZWVUb2tlbik7XG4gICAgaWYgKHJlcXVlc3Qua2V5QXV0aG9yaXphdGlvbilcbiAgICAgICAgcmVxdWVzdF9ycGMua2V5QXV0aG9yaXphdGlvbiA9IEtleUF1dGhvcml6YXRpb24udG9ScGMocmVxdWVzdC5rZXlBdXRob3JpemF0aW9uKTtcbiAgICBpZiAodHlwZW9mIHJlcXVlc3QudmFsaWRCZWZvcmUgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICByZXF1ZXN0X3JwYy52YWxpZEJlZm9yZSA9IEhleC5mcm9tTnVtYmVyKHJlcXVlc3QudmFsaWRCZWZvcmUpO1xuICAgIGlmICh0eXBlb2YgcmVxdWVzdC52YWxpZEFmdGVyICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgcmVxdWVzdF9ycGMudmFsaWRBZnRlciA9IEhleC5mcm9tTnVtYmVyKHJlcXVlc3QudmFsaWRBZnRlcik7XG4gICAgY29uc3Qgbm9uY2VLZXkgPSAoKCkgPT4ge1xuICAgICAgICBpZiAocmVxdWVzdC5ub25jZUtleSA9PT0gJ3JhbmRvbScpXG4gICAgICAgICAgICByZXR1cm4gSGV4LnJhbmRvbSg2KTtcbiAgICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0Lm5vbmNlS2V5ID09PSAnYmlnaW50JylcbiAgICAgICAgICAgIHJldHVybiBIZXguZnJvbU51bWJlcihyZXF1ZXN0Lm5vbmNlS2V5KTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9KSgpO1xuICAgIGlmIChub25jZUtleSlcbiAgICAgICAgcmVxdWVzdF9ycGMubm9uY2VLZXkgPSBub25jZUtleTtcbiAgICBpZiAodHlwZW9mIHJlcXVlc3QuY2FsbHMgIT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgIHR5cGVvZiByZXF1ZXN0LmZlZVRva2VuICE9PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICB0eXBlb2YgcmVxdWVzdC5rZXlBdXRob3JpemF0aW9uICE9PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICB0eXBlb2YgcmVxdWVzdC5ub25jZUtleSAhPT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAgICAgdHlwZW9mIHJlcXVlc3QudmFsaWRCZWZvcmUgIT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgIHR5cGVvZiByZXF1ZXN0LnZhbGlkQWZ0ZXIgIT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgIHJlcXVlc3QudHlwZSA9PT0gJ3RlbXBvJykge1xuICAgICAgICByZXF1ZXN0X3JwYy50eXBlID0gVHJhbnNhY3Rpb24udG9ScGNUeXBlLnRlbXBvO1xuICAgICAgICBkZWxldGUgcmVxdWVzdF9ycGMuZGF0YTtcbiAgICAgICAgZGVsZXRlIHJlcXVlc3RfcnBjLmlucHV0O1xuICAgICAgICBkZWxldGUgcmVxdWVzdF9ycGMudG87XG4gICAgICAgIGRlbGV0ZSByZXF1ZXN0X3JwYy52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcXVlc3RfcnBjO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VHJhbnNhY3Rpb25SZXF1ZXN0LmpzLm1hcCJdLCJuYW1lcyI6WyJIZXgiLCJveF9UcmFuc2FjdGlvblJlcXVlc3QiLCJBdXRob3JpemF0aW9uVGVtcG8iLCJLZXlBdXRob3JpemF0aW9uIiwiVG9rZW5JZCIsIlRyYW5zYWN0aW9uIiwidG9ScGMiLCJyZXF1ZXN0IiwicmVxdWVzdF9ycGMiLCJhdXRob3JpemF0aW9uTGlzdCIsInVuZGVmaW5lZCIsInRvUnBjTGlzdCIsImNhbGxzIiwibWFwIiwiY2FsbCIsInRvIiwidmFsdWUiLCJmcm9tTnVtYmVyIiwiZGF0YSIsImZlZVRva2VuIiwidG9BZGRyZXNzIiwia2V5QXV0aG9yaXphdGlvbiIsInZhbGlkQmVmb3JlIiwidmFsaWRBZnRlciIsIm5vbmNlS2V5IiwicmFuZG9tIiwidHlwZSIsInRvUnBjVHlwZSIsInRlbXBvIiwiaW5wdXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/tempo/TransactionRequest.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/tempo/TxEnvelopeTempo.js":
/*!*******************************************************!*\
  !*** ./node_modules/ox/_esm/tempo/TxEnvelopeTempo.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CallsEmptyError: () => (/* binding */ CallsEmptyError),\n/* harmony export */   InvalidValidityWindowError: () => (/* binding */ InvalidValidityWindowError),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   deserialize: () => (/* binding */ deserialize),\n/* harmony export */   feePayerMagic: () => (/* binding */ feePayerMagic),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   getFeePayerSignPayload: () => (/* binding */ getFeePayerSignPayload),\n/* harmony export */   getSignPayload: () => (/* binding */ getSignPayload),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   serialize: () => (/* binding */ serialize),\n/* harmony export */   serializedType: () => (/* binding */ serializedType),\n/* harmony export */   type: () => (/* binding */ type),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/* harmony import */ var _core_AccessList_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/AccessList.js */ \"(ssr)/./node_modules/ox/_esm/core/AccessList.js\");\n/* harmony import */ var _core_Address_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Address.js */ \"(ssr)/./node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _core_Errors_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../core/Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _core_Hash_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../core/Hash.js */ \"(ssr)/./node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _core_Hex_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _core_Rlp_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/Rlp.js */ \"(ssr)/./node_modules/ox/_esm/core/Rlp.js\");\n/* harmony import */ var _core_Signature_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core/Signature.js */ \"(ssr)/./node_modules/ox/_esm/core/Signature.js\");\n/* harmony import */ var _core_TxEnvelope_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/TxEnvelope.js */ \"(ssr)/./node_modules/ox/_esm/core/TxEnvelope.js\");\n/* harmony import */ var _AuthorizationTempo_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./AuthorizationTempo.js */ \"(ssr)/./node_modules/ox/_esm/tempo/AuthorizationTempo.js\");\n/* harmony import */ var _KeyAuthorization_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./KeyAuthorization.js */ \"(ssr)/./node_modules/ox/_esm/tempo/KeyAuthorization.js\");\n/* harmony import */ var _SignatureEnvelope_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./SignatureEnvelope.js */ \"(ssr)/./node_modules/ox/_esm/tempo/SignatureEnvelope.js\");\n/* harmony import */ var _TokenId_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./TokenId.js */ \"(ssr)/./node_modules/ox/_esm/tempo/TokenId.js\");\n\n\n\n\n\n\n\n\n\n\n\n\nconst feePayerMagic = \"0x78\";\nconst serializedType = \"0x76\";\nconst type = \"tempo\";\n/**\n * Asserts a {@link ox#TxEnvelopeTempo.TxEnvelopeTempo} is valid.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeTempo } from 'ox/tempo'\n *\n * TxEnvelopeTempo.assert({\n *   calls: [{ to: '0x0000000000000000000000000000000000000000', value: 0n }],\n *   chainId: 1,\n *   maxFeePerGas: 1000000000n,\n * })\n * ```\n *\n * @param envelope - The transaction envelope to assert.\n */ function assert(envelope) {\n    const { calls, chainId, maxFeePerGas, maxPriorityFeePerGas, validBefore, validAfter } = envelope;\n    // Calls must not be empty\n    if (!calls || calls.length === 0) throw new CallsEmptyError();\n    // validBefore must be greater than validAfter if both are set\n    if (typeof validBefore === \"number\" && typeof validAfter === \"number\" && validBefore <= validAfter) {\n        throw new InvalidValidityWindowError({\n            validBefore: validBefore,\n            validAfter: validAfter\n        });\n    }\n    // Validate each call\n    if (calls) {\n        for (const call of calls)if (call.to) _core_Address_js__WEBPACK_IMPORTED_MODULE_0__.assert(call.to, {\n            strict: false\n        });\n    }\n    // Validate chain ID\n    if (chainId <= 0) throw new _core_TxEnvelope_js__WEBPACK_IMPORTED_MODULE_1__.InvalidChainIdError({\n        chainId\n    });\n    // Validate max fee per gas\n    if (maxFeePerGas && BigInt(maxFeePerGas) > 2n ** 256n - 1n) throw new _core_TxEnvelope_js__WEBPACK_IMPORTED_MODULE_1__.FeeCapTooHighError({\n        feeCap: maxFeePerGas\n    });\n    if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas) throw new _core_TxEnvelope_js__WEBPACK_IMPORTED_MODULE_1__.TipAboveFeeCapError({\n        maxFeePerGas,\n        maxPriorityFeePerGas\n    });\n}\n/**\n * Deserializes a {@link ox#TxEnvelopeTempo.TxEnvelopeTempo} from its serialized form.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeTempo } from 'ox/tempo'\n *\n * const envelope = TxEnvelopeTempo.deserialize('0x76f84a0182031184773594008477359400809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c0808080')\n * // @log: {\n * // @log:   type: 'tempo',\n * // @log:   nonce: 785n,\n * // @log:   maxFeePerGas: 2000000000n,\n * // @log:   gas: 1000000n,\n * // @log:   calls: [{ to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', value: 1000000000000000000n }],\n * // @log: }\n * ```\n *\n * @param serialized - The serialized transaction.\n * @returns Deserialized Transaction Envelope.\n */ function deserialize(serialized) {\n    const transactionArray = _core_Rlp_js__WEBPACK_IMPORTED_MODULE_2__.toHex(_core_Hex_js__WEBPACK_IMPORTED_MODULE_3__.slice(serialized, 1));\n    const [chainId, maxPriorityFeePerGas, maxFeePerGas, gas, calls, accessList, nonceKey, nonce, validBefore, validAfter, feeToken, feePayerSignatureOrSender, authorizationList, keyAuthorizationOrSignature, maybeSignature] = transactionArray;\n    const keyAuthorization = Array.isArray(keyAuthorizationOrSignature) ? keyAuthorizationOrSignature : undefined;\n    const signature = keyAuthorization ? maybeSignature : keyAuthorizationOrSignature;\n    if (!(transactionArray.length === 13 || transactionArray.length === 14 || transactionArray.length === 15)) throw new _core_TxEnvelope_js__WEBPACK_IMPORTED_MODULE_1__.InvalidSerializedError({\n        attributes: {\n            authorizationList,\n            chainId,\n            maxPriorityFeePerGas,\n            maxFeePerGas,\n            gas,\n            calls,\n            accessList,\n            keyAuthorization,\n            nonceKey,\n            nonce,\n            validBefore,\n            validAfter,\n            feeToken,\n            feePayerSignatureOrSender,\n            ...transactionArray.length > 12 ? {\n                signature\n            } : {}\n        },\n        serialized,\n        type\n    });\n    let transaction = {\n        chainId: Number(chainId),\n        type\n    };\n    if (_core_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(gas) && gas !== \"0x\") transaction.gas = BigInt(gas);\n    if (_core_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(nonce)) transaction.nonce = nonce === \"0x\" ? 0n : BigInt(nonce);\n    if (_core_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(maxFeePerGas) && maxFeePerGas !== \"0x\") transaction.maxFeePerGas = BigInt(maxFeePerGas);\n    if (_core_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(maxPriorityFeePerGas) && maxPriorityFeePerGas !== \"0x\") transaction.maxPriorityFeePerGas = BigInt(maxPriorityFeePerGas);\n    if (_core_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(nonceKey)) transaction.nonceKey = nonceKey === \"0x\" ? 0n : BigInt(nonceKey);\n    if (_core_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(validBefore) && validBefore !== \"0x\") transaction.validBefore = Number(validBefore);\n    if (_core_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(validAfter) && validAfter !== \"0x\") transaction.validAfter = Number(validAfter);\n    if (_core_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(feeToken) && feeToken !== \"0x\") transaction.feeToken = feeToken;\n    // Parse calls array\n    if (calls && calls !== \"0x\") {\n        const callsArray = calls;\n        transaction.calls = callsArray.map((callTuple)=>{\n            const [to, value, data] = callTuple;\n            const call = {};\n            if (to && to !== \"0x\") call.to = to;\n            if (value && value !== \"0x\") call.value = BigInt(value);\n            if (data && data !== \"0x\") call.data = data;\n            return call;\n        });\n    }\n    if (accessList?.length !== 0 && accessList !== \"0x\") transaction.accessList = _core_AccessList_js__WEBPACK_IMPORTED_MODULE_4__.fromTupleList(accessList);\n    if (authorizationList?.length !== 0 && authorizationList !== \"0x\") transaction.authorizationList = _AuthorizationTempo_js__WEBPACK_IMPORTED_MODULE_5__.fromTupleList(authorizationList);\n    if (feePayerSignatureOrSender !== \"0x\" && feePayerSignatureOrSender !== undefined) {\n        if (feePayerSignatureOrSender === \"0x00\" || _core_Address_js__WEBPACK_IMPORTED_MODULE_0__.validate(feePayerSignatureOrSender)) transaction.feePayerSignature = null;\n        else transaction.feePayerSignature = _core_Signature_js__WEBPACK_IMPORTED_MODULE_6__.fromTuple(feePayerSignatureOrSender);\n    }\n    if (keyAuthorization) transaction.keyAuthorization = _KeyAuthorization_js__WEBPACK_IMPORTED_MODULE_7__.fromTuple(keyAuthorization);\n    const signatureEnvelope = signature ? _SignatureEnvelope_js__WEBPACK_IMPORTED_MODULE_8__.deserialize(signature) : undefined;\n    if (signatureEnvelope) transaction = {\n        ...transaction,\n        signature: signatureEnvelope\n    };\n    assert(transaction);\n    return transaction;\n}\n/**\n * Converts an arbitrary transaction object into a Tempo Transaction Envelope.\n *\n * Use this to create transaction envelopes with Tempo-specific features like batched calls,\n * fee tokens, access keys, and scheduled execution. Attach a signature using the `signature`\n * option after signing with {@link ox#TxEnvelopeTempo.(getSignPayload:function)}.\n *\n * [Tempo Transaction Specification](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction)\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n * import { TxEnvelopeTempo } from 'ox/tempo'\n *\n * const envelope = TxEnvelopeTempo.from({ // [!code focus]\n *   chainId: 1, // [!code focus]\n *   calls: [{ // [!code focus]\n *     data: '0xdeadbeef', // [!code focus]\n *     to: '0x0000000000000000000000000000000000000000', // [!code focus]\n *   }], // [!code focus]\n *   maxFeePerGas: Value.fromGwei('10'), // [!code focus]\n *   maxPriorityFeePerGas: Value.fromGwei('1'), // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the transaction envelope.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, Value } from 'ox'\n * import { TxEnvelopeTempo } from 'ox/tempo'\n *\n * const envelope = TxEnvelopeTempo.from({\n *   chainId: 1,\n *   calls: [{\n *     data: '0xdeadbeef',\n *     to: '0x0000000000000000000000000000000000000000',\n *   }],\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TxEnvelopeTempo.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const envelope_signed = TxEnvelopeTempo.from(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   chainId: 1,\n * // @log:   calls: [{ to: '0x0000000000000000000000000000000000000000', value: 1000000000000000000n }],\n * // @log:   maxFeePerGas: 10000000000n,\n * // @log:   maxPriorityFeePerGas: 1000000000n,\n * // @log:   type: 'tempo',\n * // @log:   r: 125...n,\n * // @log:   s: 642...n,\n * // @log:   yParity: 0,\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * It is possible to instantiate a Tempo Transaction Envelope from a {@link ox#TxEnvelopeTempo.Serialized} value.\n *\n * ```ts twoslash\n * import { TxEnvelopeTempo } from 'ox/tempo'\n *\n * const envelope = TxEnvelopeTempo.from('0x76f84a0182031184773594008477359400809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c0808080')\n * // @log: {\n * // @log:   chainId: 1,\n * // @log:   calls: [{\n * // @log:     data: '0xdeadbeef',\n * // @log:     to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n * // @log:   }],\n * // @log:   maxFeePerGas: 10000000000n,\n * // @log:   type: 'tempo',\n * // @log: }\n * ```\n *\n * @param envelope - The transaction object to convert.\n * @param options - Options.\n * @returns A Tempo Transaction Envelope.\n */ function from(envelope, options = {}) {\n    const { feePayerSignature, signature } = options;\n    const envelope_ = typeof envelope === \"string\" ? deserialize(envelope) : envelope;\n    assert(envelope_);\n    return {\n        ...envelope_,\n        ...signature ? {\n            signature: _SignatureEnvelope_js__WEBPACK_IMPORTED_MODULE_8__.from(signature)\n        } : {},\n        ...feePayerSignature ? {\n            feePayerSignature: _core_Signature_js__WEBPACK_IMPORTED_MODULE_6__.from(feePayerSignature)\n        } : {},\n        type: \"tempo\"\n    };\n}\n/**\n * Serializes a {@link ox#TxEnvelopeTempo.TxEnvelopeTempo}.\n *\n * RLP-encodes the transaction with type prefix `0x76`. For fee sponsorship, use `format: 'feePayer'`\n * to serialize with the fee payer magic `0x78` and the sender address.\n *\n * [RLP Encoding](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction#rlp-encoding)\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Value } from 'ox'\n * import { TxEnvelopeTempo } from 'ox/tempo'\n *\n * const envelope = TxEnvelopeTempo.from({\n *   chainId: 1,\n *   calls: [{\n *     data: '0xdeadbeef',\n *     to: '0x0000000000000000000000000000000000000000',\n *   }],\n *   maxFeePerGas: Value.fromGwei('10'),\n * })\n *\n * const serialized = TxEnvelopeTempo.serialize(envelope) // [!code focus]\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the serialized Transaction Envelope.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, Value } from 'ox'\n * import { TxEnvelopeTempo } from 'ox/tempo'\n *\n * const envelope = TxEnvelopeTempo.from({\n *   chainId: 1,\n *   calls: [{\n *     data: '0xdeadbeef',\n *     to: '0x0000000000000000000000000000000000000000',\n *   }],\n *   maxFeePerGas: Value.fromGwei('10'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TxEnvelopeTempo.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const serialized = TxEnvelopeTempo.serialize(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n *\n * // ... send `serialized` transaction to JSON-RPC `eth_sendRawTransaction`\n * ```\n *\n * @param envelope - The Transaction Envelope to serialize.\n * @param options - Options.\n * @returns The serialized Transaction Envelope.\n */ function serialize(envelope, options = {}) {\n    const { accessList, authorizationList, calls, chainId, feeToken, gas, keyAuthorization, nonce, nonceKey, maxFeePerGas, maxPriorityFeePerGas, validBefore, validAfter } = envelope;\n    assert(envelope);\n    const accessTupleList = _core_AccessList_js__WEBPACK_IMPORTED_MODULE_4__.toTupleList(accessList);\n    const signature = options.signature || envelope.signature;\n    const authorizationTupleList = _AuthorizationTempo_js__WEBPACK_IMPORTED_MODULE_5__.toTupleList(authorizationList);\n    // Encode calls as RLP list of [to, value, data] tuples\n    const callsTupleList = calls.map((call)=>[\n            call.to ?? \"0x\",\n            call.value ? _core_Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(call.value) : \"0x\",\n            call.data ?? \"0x\"\n        ]);\n    const feePayerSignatureOrSender = (()=>{\n        if (options.sender) return options.sender;\n        const feePayerSignature = typeof options.feePayerSignature !== \"undefined\" ? options.feePayerSignature : envelope.feePayerSignature;\n        if (feePayerSignature === null) return \"0x00\";\n        if (!feePayerSignature) return \"0x\";\n        return _core_Signature_js__WEBPACK_IMPORTED_MODULE_6__.toTuple(feePayerSignature);\n    })();\n    const serialized = [\n        _core_Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(chainId),\n        maxPriorityFeePerGas ? _core_Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(maxPriorityFeePerGas) : \"0x\",\n        maxFeePerGas ? _core_Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(maxFeePerGas) : \"0x\",\n        gas ? _core_Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(gas) : \"0x\",\n        callsTupleList,\n        accessTupleList,\n        nonceKey ? _core_Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(nonceKey) : \"0x\",\n        nonce ? _core_Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(nonce) : \"0x\",\n        typeof validBefore === \"number\" ? _core_Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(validBefore) : \"0x\",\n        typeof validAfter === \"number\" ? _core_Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(validAfter) : \"0x\",\n        typeof feeToken === \"bigint\" || typeof feeToken === \"string\" ? _TokenId_js__WEBPACK_IMPORTED_MODULE_9__.toAddress(feeToken) : \"0x\",\n        feePayerSignatureOrSender,\n        authorizationTupleList,\n        ...keyAuthorization ? [\n            _KeyAuthorization_js__WEBPACK_IMPORTED_MODULE_7__.toTuple(keyAuthorization)\n        ] : [],\n        ...signature ? [\n            _SignatureEnvelope_js__WEBPACK_IMPORTED_MODULE_8__.serialize(_SignatureEnvelope_js__WEBPACK_IMPORTED_MODULE_8__.from(signature))\n        ] : []\n    ];\n    return _core_Hex_js__WEBPACK_IMPORTED_MODULE_3__.concat(options.format === \"feePayer\" ? feePayerMagic : serializedType, _core_Rlp_js__WEBPACK_IMPORTED_MODULE_2__.fromHex(serialized));\n}\n/**\n * Returns the payload to sign for a {@link ox#TxEnvelopeTempo.TxEnvelopeTempo}.\n *\n * Computes the keccak256 hash of the unsigned serialized transaction. Sign this payload\n * with secp256k1, P256, or WebAuthn, then attach the signature via {@link ox#TxEnvelopeTempo.(from:function)}.\n *\n * [Tempo Transaction Specification](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction)\n *\n * @example\n * The example below demonstrates how to compute the sign payload which can be used\n * with ECDSA signing utilities like {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1 } from 'ox'\n * import { TxEnvelopeTempo } from 'ox/tempo'\n *\n * const envelope = TxEnvelopeTempo.from({\n *   chainId: 1,\n *   calls: [{\n *     data: '0xdeadbeef',\n *     to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   }],\n *   nonce: 0n,\n *   maxFeePerGas: 1000000000n,\n *   gas: 21000n,\n * })\n *\n * const payload = TxEnvelopeTempo.getSignPayload(envelope) // [!code focus]\n * // @log: '0x...'\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param envelope - The transaction envelope to get the sign payload for.\n * @returns The sign payload.\n */ function getSignPayload(envelope) {\n    return hash(envelope, {\n        presign: true\n    });\n}\n/**\n * Hashes a {@link ox#TxEnvelopeTempo.TxEnvelopeTempo}. This is the \"transaction hash\".\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1 } from 'ox'\n * import { TxEnvelopeTempo } from 'ox/tempo'\n *\n * const envelope = TxEnvelopeTempo.from({\n *   chainId: 1,\n *   calls: [{\n *     data: '0xdeadbeef',\n *     to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   }],\n *   nonce: 0n,\n *   maxFeePerGas: 1000000000n,\n *   gas: 21000n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TxEnvelopeTempo.getSignPayload(envelope),\n *   privateKey: '0x...'\n * })\n *\n * const envelope_signed = TxEnvelopeTempo.from(envelope, { signature })\n *\n * const hash = TxEnvelopeTempo.hash(envelope_signed) // [!code focus]\n * ```\n *\n * @param envelope - The Tempo Transaction Envelope to hash.\n * @param options - Options.\n * @returns The hash of the transaction envelope.\n */ function hash(envelope, options = {}) {\n    const serialized = serialize({\n        ...envelope,\n        ...options.presign ? {\n            signature: undefined\n        } : {}\n    });\n    return _core_Hash_js__WEBPACK_IMPORTED_MODULE_10__.keccak256(serialized);\n}\n/**\n * Returns the fee payer payload to sign for a {@link ox#TxEnvelopeTempo.TxEnvelopeTempo}.\n *\n * Fee sponsorship uses a dual-signature scheme: the sender signs the transaction, then a fee payer\n * signs over the transaction with the sender's address to commit to paying fees. The fee payer's\n * signature includes the `feeToken` and `sender_address`, using magic byte `0x78` for domain separation.\n *\n * [Fee Payer Signature](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction#fee-payer-signature)\n * [Fee Sponsorship Guide](https://docs.tempo.xyz/protocol/transactions#fee-sponsorship)\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1 } from 'ox'\n * import { TxEnvelopeTempo } from 'ox/tempo'\n *\n * const envelope = TxEnvelopeTempo.from({\n *   chainId: 1,\n *   calls: [{\n *     data: '0xdeadbeef',\n *     to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   }],\n *   nonce: 0n,\n *   maxFeePerGas: 1000000000n,\n *   gas: 21000n,\n * })\n *\n * const payload = TxEnvelopeTempo.getFeePayerSignPayload(envelope, {\n *   sender: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045'\n * }) // [!code focus]\n * // @log: '0x...'\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param envelope - The transaction envelope to get the fee payer sign payload for.\n * @param options - Options.\n * @returns The fee payer sign payload.\n */ function getFeePayerSignPayload(envelope, options) {\n    const { sender } = options;\n    const serialized = serialize({\n        ...envelope,\n        signature: undefined\n    }, {\n        sender,\n        format: \"feePayer\"\n    });\n    return _core_Hash_js__WEBPACK_IMPORTED_MODULE_10__.keccak256(serialized);\n}\n/**\n * Validates a {@link ox#TxEnvelopeTempo.TxEnvelopeTempo}. Returns `true` if the envelope is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeTempo } from 'ox/tempo'\n *\n * const valid = TxEnvelopeTempo.validate({\n *   calls: [{\n *     data: '0xdeadbeef',\n *     to: '0x0000000000000000000000000000000000000000',\n *   }],\n *   chainId: 1,\n *   maxFeePerGas: 1000000000n,\n * })\n * // @log: true\n * ```\n *\n * @param envelope - The transaction envelope to validate.\n */ function validate(envelope) {\n    try {\n        assert(envelope);\n        return true;\n    } catch  {\n        return false;\n    }\n}\n/**\n * Thrown when a transaction's calls list is empty.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeTempo } from 'ox/tempo'\n *\n * TxEnvelopeTempo.assert({\n *   calls: [],\n *   chainId: 1,\n * })\n * // @error: TxEnvelopeTempo.CallsEmptyError: Calls list cannot be empty.\n * ```\n */ class CallsEmptyError extends _core_Errors_js__WEBPACK_IMPORTED_MODULE_11__.BaseError {\n    constructor(){\n        super(\"Calls list cannot be empty.\");\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"TxEnvelopeTempo.CallsEmptyError\"\n        });\n    }\n}\n/**\n * Thrown when validBefore is not greater than validAfter.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeTempo } from 'ox/tempo'\n *\n * TxEnvelopeTempo.assert({\n *   calls: [{ to: '0x0000000000000000000000000000000000000000' }],\n *   chainId: 1,\n *   validBefore: 100,\n *   validAfter: 200,\n * })\n * // @error: TxEnvelopeTempo.InvalidValidityWindowError: validBefore (100) must be greater than validAfter (200).\n * ```\n */ class InvalidValidityWindowError extends _core_Errors_js__WEBPACK_IMPORTED_MODULE_11__.BaseError {\n    constructor({ validBefore, validAfter }){\n        super(`validBefore (${validBefore}) must be greater than validAfter (${validAfter}).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"TxEnvelopeTempo.InvalidValidityWindowError\"\n        });\n    }\n} //# sourceMappingURL=TxEnvelopeTempo.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS90ZW1wby9UeEVudmVsb3BlVGVtcG8uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvRDtBQUNOO0FBQ0Y7QUFDSjtBQUNGO0FBQ0E7QUFDWTtBQUNXO0FBQ0M7QUFDSjtBQUNFO0FBQ3BCO0FBQ2pDLE1BQU1ZLGdCQUFnQixPQUFPO0FBQzdCLE1BQU1DLGlCQUFpQixPQUFPO0FBQzlCLE1BQU1DLE9BQU8sUUFBUTtBQUM1Qjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDTSxTQUFTQyxPQUFPQyxRQUFRO0lBQzNCLE1BQU0sRUFBRUMsS0FBSyxFQUFFQyxPQUFPLEVBQUVDLFlBQVksRUFBRUMsb0JBQW9CLEVBQUVDLFdBQVcsRUFBRUMsVUFBVSxFQUFHLEdBQUdOO0lBQ3pGLDBCQUEwQjtJQUMxQixJQUFJLENBQUNDLFNBQVNBLE1BQU1NLE1BQU0sS0FBSyxHQUMzQixNQUFNLElBQUlDO0lBQ2QsOERBQThEO0lBQzlELElBQUksT0FBT0gsZ0JBQWdCLFlBQ3ZCLE9BQU9DLGVBQWUsWUFDdEJELGVBQWVDLFlBQVk7UUFDM0IsTUFBTSxJQUFJRywyQkFBMkI7WUFDakNKLGFBQWFBO1lBQ2JDLFlBQVlBO1FBQ2hCO0lBQ0o7SUFDQSxxQkFBcUI7SUFDckIsSUFBSUwsT0FDQTtRQUFBLEtBQUssTUFBTVMsUUFBUVQsTUFDZixJQUFJUyxLQUFLQyxFQUFFLEVBQ1AxQixvREFBYyxDQUFDeUIsS0FBS0MsRUFBRSxFQUFFO1lBQUVDLFFBQVE7UUFBTTtJQUFFO0lBQ3RELG9CQUFvQjtJQUNwQixJQUFJVixXQUFXLEdBQ1gsTUFBTSxJQUFJWCxvRUFBdUMsQ0FBQztRQUFFVztJQUFRO0lBQ2hFLDJCQUEyQjtJQUMzQixJQUFJQyxnQkFBZ0JXLE9BQU9YLGdCQUFnQixFQUFFLElBQUksSUFBSSxHQUFHLEVBQUUsRUFDdEQsTUFBTSxJQUFJWixtRUFBc0MsQ0FBQztRQUM3Q3lCLFFBQVFiO0lB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O0lBQ25CLE1BQU1qQyxhQUFhbUMsVUFBVTtRQUFFLEdBQUd0RCxRQUFRO1FBQUVvQyxXQUFXRDtJQUFVLEdBQUc7UUFDaEV5QjtRQUNBSSxRQUFRO0lBQ1o7SUFDQSxPQUFPN0UscURBQWMsQ0FBQ2dDO0FBQzFCO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FtQkMsR0FDTSxTQUFTc0IsU0FBU3pDLFFBQVE7SUFDN0IsSUFBSTtRQUNBRCxPQUFPQztRQUNQLE9BQU87SUFDWCxFQUNBLE9BQU07UUFDRixPQUFPO0lBQ1g7QUFDSjtBQUNBOzs7Ozs7Ozs7Ozs7O0NBYUMsR0FDTSxNQUFNUSx3QkFBd0J0Qix1REFBZ0I7SUFDakRzRixhQUFjO1FBQ1YsS0FBSyxDQUFDO1FBQ05DLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsUUFBUTtZQUNoQ0MsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVmhDLE9BQU87UUFDWDtJQUNKO0FBQ0o7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDTSxNQUFNcEMsbUNBQW1DdkIsdURBQWdCO0lBQzVEc0YsWUFBWSxFQUFFbkUsV0FBVyxFQUFFQyxVQUFVLEVBQUcsQ0FBRTtRQUN0QyxLQUFLLENBQUMsQ0FBQyxhQUFhLEVBQUVELFlBQVksbUNBQW1DLEVBQUVDLFdBQVcsRUFBRSxDQUFDO1FBQ3JGbUUsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxRQUFRO1lBQ2hDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWaEMsT0FBTztRQUNYO0lBQ0o7QUFDSixFQUNBLDJDQUEyQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsYXctd29ya3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS90ZW1wby9UeEVudmVsb3BlVGVtcG8uanM/OTdiMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBBY2Nlc3NMaXN0IGZyb20gJy4uL2NvcmUvQWNjZXNzTGlzdC5qcyc7XG5pbXBvcnQgKiBhcyBBZGRyZXNzIGZyb20gJy4uL2NvcmUvQWRkcmVzcy5qcyc7XG5pbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSAnLi4vY29yZS9FcnJvcnMuanMnO1xuaW1wb3J0ICogYXMgSGFzaCBmcm9tICcuLi9jb3JlL0hhc2guanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4uL2NvcmUvSGV4LmpzJztcbmltcG9ydCAqIGFzIFJscCBmcm9tICcuLi9jb3JlL1JscC5qcyc7XG5pbXBvcnQgKiBhcyBTaWduYXR1cmUgZnJvbSAnLi4vY29yZS9TaWduYXR1cmUuanMnO1xuaW1wb3J0ICogYXMgVHJhbnNhY3Rpb25FbnZlbG9wZSBmcm9tICcuLi9jb3JlL1R4RW52ZWxvcGUuanMnO1xuaW1wb3J0ICogYXMgQXV0aG9yaXphdGlvblRlbXBvIGZyb20gJy4vQXV0aG9yaXphdGlvblRlbXBvLmpzJztcbmltcG9ydCAqIGFzIEtleUF1dGhvcml6YXRpb24gZnJvbSAnLi9LZXlBdXRob3JpemF0aW9uLmpzJztcbmltcG9ydCAqIGFzIFNpZ25hdHVyZUVudmVsb3BlIGZyb20gJy4vU2lnbmF0dXJlRW52ZWxvcGUuanMnO1xuaW1wb3J0ICogYXMgVG9rZW5JZCBmcm9tICcuL1Rva2VuSWQuanMnO1xuZXhwb3J0IGNvbnN0IGZlZVBheWVyTWFnaWMgPSAnMHg3OCc7XG5leHBvcnQgY29uc3Qgc2VyaWFsaXplZFR5cGUgPSAnMHg3Nic7XG5leHBvcnQgY29uc3QgdHlwZSA9ICd0ZW1wbyc7XG4vKipcbiAqIEFzc2VydHMgYSB7QGxpbmsgb3gjVHhFbnZlbG9wZVRlbXBvLlR4RW52ZWxvcGVUZW1wb30gaXMgdmFsaWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBUeEVudmVsb3BlVGVtcG8gfSBmcm9tICdveC90ZW1wbydcbiAqXG4gKiBUeEVudmVsb3BlVGVtcG8uYXNzZXJ0KHtcbiAqICAgY2FsbHM6IFt7IHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJywgdmFsdWU6IDBuIH1dLFxuICogICBjaGFpbklkOiAxLFxuICogICBtYXhGZWVQZXJHYXM6IDEwMDAwMDAwMDBuLFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBlbnZlbG9wZSAtIFRoZSB0cmFuc2FjdGlvbiBlbnZlbG9wZSB0byBhc3NlcnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnQoZW52ZWxvcGUpIHtcbiAgICBjb25zdCB7IGNhbGxzLCBjaGFpbklkLCBtYXhGZWVQZXJHYXMsIG1heFByaW9yaXR5RmVlUGVyR2FzLCB2YWxpZEJlZm9yZSwgdmFsaWRBZnRlciwgfSA9IGVudmVsb3BlO1xuICAgIC8vIENhbGxzIG11c3Qgbm90IGJlIGVtcHR5XG4gICAgaWYgKCFjYWxscyB8fCBjYWxscy5sZW5ndGggPT09IDApXG4gICAgICAgIHRocm93IG5ldyBDYWxsc0VtcHR5RXJyb3IoKTtcbiAgICAvLyB2YWxpZEJlZm9yZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB2YWxpZEFmdGVyIGlmIGJvdGggYXJlIHNldFxuICAgIGlmICh0eXBlb2YgdmFsaWRCZWZvcmUgPT09ICdudW1iZXInICYmXG4gICAgICAgIHR5cGVvZiB2YWxpZEFmdGVyID09PSAnbnVtYmVyJyAmJlxuICAgICAgICB2YWxpZEJlZm9yZSA8PSB2YWxpZEFmdGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkVmFsaWRpdHlXaW5kb3dFcnJvcih7XG4gICAgICAgICAgICB2YWxpZEJlZm9yZTogdmFsaWRCZWZvcmUsXG4gICAgICAgICAgICB2YWxpZEFmdGVyOiB2YWxpZEFmdGVyLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gVmFsaWRhdGUgZWFjaCBjYWxsXG4gICAgaWYgKGNhbGxzKVxuICAgICAgICBmb3IgKGNvbnN0IGNhbGwgb2YgY2FsbHMpXG4gICAgICAgICAgICBpZiAoY2FsbC50bylcbiAgICAgICAgICAgICAgICBBZGRyZXNzLmFzc2VydChjYWxsLnRvLCB7IHN0cmljdDogZmFsc2UgfSk7XG4gICAgLy8gVmFsaWRhdGUgY2hhaW4gSURcbiAgICBpZiAoY2hhaW5JZCA8PSAwKVxuICAgICAgICB0aHJvdyBuZXcgVHJhbnNhY3Rpb25FbnZlbG9wZS5JbnZhbGlkQ2hhaW5JZEVycm9yKHsgY2hhaW5JZCB9KTtcbiAgICAvLyBWYWxpZGF0ZSBtYXggZmVlIHBlciBnYXNcbiAgICBpZiAobWF4RmVlUGVyR2FzICYmIEJpZ0ludChtYXhGZWVQZXJHYXMpID4gMm4gKiogMjU2biAtIDFuKVxuICAgICAgICB0aHJvdyBuZXcgVHJhbnNhY3Rpb25FbnZlbG9wZS5GZWVDYXBUb29IaWdoRXJyb3Ioe1xuICAgICAgICAgICAgZmVlQ2FwOiBtYXhGZWVQZXJHYXMsXG4gICAgICAgIH0pO1xuICAgIGlmIChtYXhQcmlvcml0eUZlZVBlckdhcyAmJlxuICAgICAgICBtYXhGZWVQZXJHYXMgJiZcbiAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXMgPiBtYXhGZWVQZXJHYXMpXG4gICAgICAgIHRocm93IG5ldyBUcmFuc2FjdGlvbkVudmVsb3BlLlRpcEFib3ZlRmVlQ2FwRXJyb3Ioe1xuICAgICAgICAgICAgbWF4RmVlUGVyR2FzLFxuICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXMsXG4gICAgICAgIH0pO1xufVxuLyoqXG4gKiBEZXNlcmlhbGl6ZXMgYSB7QGxpbmsgb3gjVHhFbnZlbG9wZVRlbXBvLlR4RW52ZWxvcGVUZW1wb30gZnJvbSBpdHMgc2VyaWFsaXplZCBmb3JtLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHhFbnZlbG9wZVRlbXBvIH0gZnJvbSAnb3gvdGVtcG8nXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUeEVudmVsb3BlVGVtcG8uZGVzZXJpYWxpemUoJzB4NzZmODRhMDE4MjAzMTE4NDc3MzU5NDAwODQ3NzM1OTQwMDgwOTQ3MDk5Nzk3MGM1MTgxMmRjM2EwMTBjN2QwMWI1MGUwZDE3ZGM3OWM4ODgwZGUwYjZiM2E3NjQwMDAwODBjMDgwODA4MCcpXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIHR5cGU6ICd0ZW1wbycsXG4gKiAvLyBAbG9nOiAgIG5vbmNlOiA3ODVuLFxuICogLy8gQGxvZzogICBtYXhGZWVQZXJHYXM6IDIwMDAwMDAwMDBuLFxuICogLy8gQGxvZzogICBnYXM6IDEwMDAwMDBuLFxuICogLy8gQGxvZzogICBjYWxsczogW3sgdG86ICcweDcwOTk3OTcwYzUxODEyZGMzYTAxMGM3ZDAxYjUwZTBkMTdkYzc5YzgnLCB2YWx1ZTogMTAwMDAwMDAwMDAwMDAwMDAwMG4gfV0sXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2VyaWFsaXplZCAtIFRoZSBzZXJpYWxpemVkIHRyYW5zYWN0aW9uLlxuICogQHJldHVybnMgRGVzZXJpYWxpemVkIFRyYW5zYWN0aW9uIEVudmVsb3BlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVzZXJpYWxpemUoc2VyaWFsaXplZCkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uQXJyYXkgPSBSbHAudG9IZXgoSGV4LnNsaWNlKHNlcmlhbGl6ZWQsIDEpKTtcbiAgICBjb25zdCBbY2hhaW5JZCwgbWF4UHJpb3JpdHlGZWVQZXJHYXMsIG1heEZlZVBlckdhcywgZ2FzLCBjYWxscywgYWNjZXNzTGlzdCwgbm9uY2VLZXksIG5vbmNlLCB2YWxpZEJlZm9yZSwgdmFsaWRBZnRlciwgZmVlVG9rZW4sIGZlZVBheWVyU2lnbmF0dXJlT3JTZW5kZXIsIGF1dGhvcml6YXRpb25MaXN0LCBrZXlBdXRob3JpemF0aW9uT3JTaWduYXR1cmUsIG1heWJlU2lnbmF0dXJlLF0gPSB0cmFuc2FjdGlvbkFycmF5O1xuICAgIGNvbnN0IGtleUF1dGhvcml6YXRpb24gPSBBcnJheS5pc0FycmF5KGtleUF1dGhvcml6YXRpb25PclNpZ25hdHVyZSlcbiAgICAgICAgPyBrZXlBdXRob3JpemF0aW9uT3JTaWduYXR1cmVcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0ga2V5QXV0aG9yaXphdGlvblxuICAgICAgICA/IG1heWJlU2lnbmF0dXJlXG4gICAgICAgIDoga2V5QXV0aG9yaXphdGlvbk9yU2lnbmF0dXJlO1xuICAgIGlmICghKHRyYW5zYWN0aW9uQXJyYXkubGVuZ3RoID09PSAxMyB8fFxuICAgICAgICB0cmFuc2FjdGlvbkFycmF5Lmxlbmd0aCA9PT0gMTQgfHxcbiAgICAgICAgdHJhbnNhY3Rpb25BcnJheS5sZW5ndGggPT09IDE1KSlcbiAgICAgICAgdGhyb3cgbmV3IFRyYW5zYWN0aW9uRW52ZWxvcGUuSW52YWxpZFNlcmlhbGl6ZWRFcnJvcih7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgYXV0aG9yaXphdGlvbkxpc3QsXG4gICAgICAgICAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhcyxcbiAgICAgICAgICAgICAgICBtYXhGZWVQZXJHYXMsXG4gICAgICAgICAgICAgICAgZ2FzLFxuICAgICAgICAgICAgICAgIGNhbGxzLFxuICAgICAgICAgICAgICAgIGFjY2Vzc0xpc3QsXG4gICAgICAgICAgICAgICAga2V5QXV0aG9yaXphdGlvbixcbiAgICAgICAgICAgICAgICBub25jZUtleSxcbiAgICAgICAgICAgICAgICBub25jZSxcbiAgICAgICAgICAgICAgICB2YWxpZEJlZm9yZSxcbiAgICAgICAgICAgICAgICB2YWxpZEFmdGVyLFxuICAgICAgICAgICAgICAgIGZlZVRva2VuLFxuICAgICAgICAgICAgICAgIGZlZVBheWVyU2lnbmF0dXJlT3JTZW5kZXIsXG4gICAgICAgICAgICAgICAgLi4uKHRyYW5zYWN0aW9uQXJyYXkubGVuZ3RoID4gMTJcbiAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmUsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgOiB7fSksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2VyaWFsaXplZCxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgIH0pO1xuICAgIGxldCB0cmFuc2FjdGlvbiA9IHtcbiAgICAgICAgY2hhaW5JZDogTnVtYmVyKGNoYWluSWQpLFxuICAgICAgICB0eXBlLFxuICAgIH07XG4gICAgaWYgKEhleC52YWxpZGF0ZShnYXMpICYmIGdhcyAhPT0gJzB4JylcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2FzID0gQmlnSW50KGdhcyk7XG4gICAgaWYgKEhleC52YWxpZGF0ZShub25jZSkpXG4gICAgICAgIHRyYW5zYWN0aW9uLm5vbmNlID0gbm9uY2UgPT09ICcweCcgPyAwbiA6IEJpZ0ludChub25jZSk7XG4gICAgaWYgKEhleC52YWxpZGF0ZShtYXhGZWVQZXJHYXMpICYmIG1heEZlZVBlckdhcyAhPT0gJzB4JylcbiAgICAgICAgdHJhbnNhY3Rpb24ubWF4RmVlUGVyR2FzID0gQmlnSW50KG1heEZlZVBlckdhcyk7XG4gICAgaWYgKEhleC52YWxpZGF0ZShtYXhQcmlvcml0eUZlZVBlckdhcykgJiYgbWF4UHJpb3JpdHlGZWVQZXJHYXMgIT09ICcweCcpXG4gICAgICAgIHRyYW5zYWN0aW9uLm1heFByaW9yaXR5RmVlUGVyR2FzID0gQmlnSW50KG1heFByaW9yaXR5RmVlUGVyR2FzKTtcbiAgICBpZiAoSGV4LnZhbGlkYXRlKG5vbmNlS2V5KSlcbiAgICAgICAgdHJhbnNhY3Rpb24ubm9uY2VLZXkgPSBub25jZUtleSA9PT0gJzB4JyA/IDBuIDogQmlnSW50KG5vbmNlS2V5KTtcbiAgICBpZiAoSGV4LnZhbGlkYXRlKHZhbGlkQmVmb3JlKSAmJiB2YWxpZEJlZm9yZSAhPT0gJzB4JylcbiAgICAgICAgdHJhbnNhY3Rpb24udmFsaWRCZWZvcmUgPSBOdW1iZXIodmFsaWRCZWZvcmUpO1xuICAgIGlmIChIZXgudmFsaWRhdGUodmFsaWRBZnRlcikgJiYgdmFsaWRBZnRlciAhPT0gJzB4JylcbiAgICAgICAgdHJhbnNhY3Rpb24udmFsaWRBZnRlciA9IE51bWJlcih2YWxpZEFmdGVyKTtcbiAgICBpZiAoSGV4LnZhbGlkYXRlKGZlZVRva2VuKSAmJiBmZWVUb2tlbiAhPT0gJzB4JylcbiAgICAgICAgdHJhbnNhY3Rpb24uZmVlVG9rZW4gPSBmZWVUb2tlbjtcbiAgICAvLyBQYXJzZSBjYWxscyBhcnJheVxuICAgIGlmIChjYWxscyAmJiBjYWxscyAhPT0gJzB4Jykge1xuICAgICAgICBjb25zdCBjYWxsc0FycmF5ID0gY2FsbHM7XG4gICAgICAgIHRyYW5zYWN0aW9uLmNhbGxzID0gY2FsbHNBcnJheS5tYXAoKGNhbGxUdXBsZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgW3RvLCB2YWx1ZSwgZGF0YV0gPSBjYWxsVHVwbGU7XG4gICAgICAgICAgICBjb25zdCBjYWxsID0ge307XG4gICAgICAgICAgICBpZiAodG8gJiYgdG8gIT09ICcweCcpXG4gICAgICAgICAgICAgICAgY2FsbC50byA9IHRvO1xuICAgICAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlICE9PSAnMHgnKVxuICAgICAgICAgICAgICAgIGNhbGwudmFsdWUgPSBCaWdJbnQodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGRhdGEgJiYgZGF0YSAhPT0gJzB4JylcbiAgICAgICAgICAgICAgICBjYWxsLmRhdGEgPSBkYXRhO1xuICAgICAgICAgICAgcmV0dXJuIGNhbGw7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoYWNjZXNzTGlzdD8ubGVuZ3RoICE9PSAwICYmIGFjY2Vzc0xpc3QgIT09ICcweCcpXG4gICAgICAgIHRyYW5zYWN0aW9uLmFjY2Vzc0xpc3QgPSBBY2Nlc3NMaXN0LmZyb21UdXBsZUxpc3QoYWNjZXNzTGlzdCk7XG4gICAgaWYgKGF1dGhvcml6YXRpb25MaXN0Py5sZW5ndGggIT09IDAgJiYgYXV0aG9yaXphdGlvbkxpc3QgIT09ICcweCcpXG4gICAgICAgIHRyYW5zYWN0aW9uLmF1dGhvcml6YXRpb25MaXN0ID0gQXV0aG9yaXphdGlvblRlbXBvLmZyb21UdXBsZUxpc3QoYXV0aG9yaXphdGlvbkxpc3QpO1xuICAgIGlmIChmZWVQYXllclNpZ25hdHVyZU9yU2VuZGVyICE9PSAnMHgnICYmXG4gICAgICAgIGZlZVBheWVyU2lnbmF0dXJlT3JTZW5kZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoZmVlUGF5ZXJTaWduYXR1cmVPclNlbmRlciA9PT0gJzB4MDAnIHx8XG4gICAgICAgICAgICBBZGRyZXNzLnZhbGlkYXRlKGZlZVBheWVyU2lnbmF0dXJlT3JTZW5kZXIpKVxuICAgICAgICAgICAgdHJhbnNhY3Rpb24uZmVlUGF5ZXJTaWduYXR1cmUgPSBudWxsO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5mZWVQYXllclNpZ25hdHVyZSA9IFNpZ25hdHVyZS5mcm9tVHVwbGUoZmVlUGF5ZXJTaWduYXR1cmVPclNlbmRlcik7XG4gICAgfVxuICAgIGlmIChrZXlBdXRob3JpemF0aW9uKVxuICAgICAgICB0cmFuc2FjdGlvbi5rZXlBdXRob3JpemF0aW9uID0gS2V5QXV0aG9yaXphdGlvbi5mcm9tVHVwbGUoa2V5QXV0aG9yaXphdGlvbik7XG4gICAgY29uc3Qgc2lnbmF0dXJlRW52ZWxvcGUgPSBzaWduYXR1cmVcbiAgICAgICAgPyBTaWduYXR1cmVFbnZlbG9wZS5kZXNlcmlhbGl6ZShzaWduYXR1cmUpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGlmIChzaWduYXR1cmVFbnZlbG9wZSlcbiAgICAgICAgdHJhbnNhY3Rpb24gPSB7XG4gICAgICAgICAgICAuLi50cmFuc2FjdGlvbixcbiAgICAgICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlRW52ZWxvcGUsXG4gICAgICAgIH07XG4gICAgYXNzZXJ0KHRyYW5zYWN0aW9uKTtcbiAgICByZXR1cm4gdHJhbnNhY3Rpb247XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIGFyYml0cmFyeSB0cmFuc2FjdGlvbiBvYmplY3QgaW50byBhIFRlbXBvIFRyYW5zYWN0aW9uIEVudmVsb3BlLlxuICpcbiAqIFVzZSB0aGlzIHRvIGNyZWF0ZSB0cmFuc2FjdGlvbiBlbnZlbG9wZXMgd2l0aCBUZW1wby1zcGVjaWZpYyBmZWF0dXJlcyBsaWtlIGJhdGNoZWQgY2FsbHMsXG4gKiBmZWUgdG9rZW5zLCBhY2Nlc3Mga2V5cywgYW5kIHNjaGVkdWxlZCBleGVjdXRpb24uIEF0dGFjaCBhIHNpZ25hdHVyZSB1c2luZyB0aGUgYHNpZ25hdHVyZWBcbiAqIG9wdGlvbiBhZnRlciBzaWduaW5nIHdpdGgge0BsaW5rIG94I1R4RW52ZWxvcGVUZW1wby4oZ2V0U2lnblBheWxvYWQ6ZnVuY3Rpb24pfS5cbiAqXG4gKiBbVGVtcG8gVHJhbnNhY3Rpb24gU3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly9kb2NzLnRlbXBvLnh5ei9wcm90b2NvbC90cmFuc2FjdGlvbnMvc3BlYy10ZW1wby10cmFuc2FjdGlvbilcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFZhbHVlIH0gZnJvbSAnb3gnXG4gKiBpbXBvcnQgeyBUeEVudmVsb3BlVGVtcG8gfSBmcm9tICdveC90ZW1wbydcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFR4RW52ZWxvcGVUZW1wby5mcm9tKHsgLy8gWyFjb2RlIGZvY3VzXVxuICogICBjaGFpbklkOiAxLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIGNhbGxzOiBbeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgICAgZGF0YTogJzB4ZGVhZGJlZWYnLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgICAgdG86ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIH1dLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIG1heEZlZVBlckdhczogVmFsdWUuZnJvbUd3ZWkoJzEwJyksIC8vIFshY29kZSBmb2N1c11cbiAqICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IFZhbHVlLmZyb21Hd2VpKCcxJyksIC8vIFshY29kZSBmb2N1c11cbiAqIH0pIC8vIFshY29kZSBmb2N1c11cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgQXR0YWNoaW5nIFNpZ25hdHVyZXNcbiAqXG4gKiBJdCBpcyBwb3NzaWJsZSB0byBhdHRhY2ggYSBgc2lnbmF0dXJlYCB0byB0aGUgdHJhbnNhY3Rpb24gZW52ZWxvcGUuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgU2VjcDI1NmsxLCBWYWx1ZSB9IGZyb20gJ294J1xuICogaW1wb3J0IHsgVHhFbnZlbG9wZVRlbXBvIH0gZnJvbSAnb3gvdGVtcG8nXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUeEVudmVsb3BlVGVtcG8uZnJvbSh7XG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIGNhbGxzOiBbe1xuICogICAgIGRhdGE6ICcweGRlYWRiZWVmJyxcbiAqICAgICB0bzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIH1dLFxuICogICBtYXhGZWVQZXJHYXM6IFZhbHVlLmZyb21Hd2VpKCcxMCcpLFxuICogICBtYXhQcmlvcml0eUZlZVBlckdhczogVmFsdWUuZnJvbUd3ZWkoJzEnKSxcbiAqIH0pXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oe1xuICogICBwYXlsb2FkOiBUeEVudmVsb3BlVGVtcG8uZ2V0U2lnblBheWxvYWQoZW52ZWxvcGUpLFxuICogICBwcml2YXRlS2V5OiAnMHguLi4nLFxuICogfSlcbiAqXG4gKiBjb25zdCBlbnZlbG9wZV9zaWduZWQgPSBUeEVudmVsb3BlVGVtcG8uZnJvbShlbnZlbG9wZSwgeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHNpZ25hdHVyZSwgLy8gWyFjb2RlIGZvY3VzXVxuICogfSkgLy8gWyFjb2RlIGZvY3VzXVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICBjaGFpbklkOiAxLFxuICogLy8gQGxvZzogICBjYWxsczogW3sgdG86ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLCB2YWx1ZTogMTAwMDAwMDAwMDAwMDAwMDAwMG4gfV0sXG4gKiAvLyBAbG9nOiAgIG1heEZlZVBlckdhczogMTAwMDAwMDAwMDBuLFxuICogLy8gQGxvZzogICBtYXhQcmlvcml0eUZlZVBlckdhczogMTAwMDAwMDAwMG4sXG4gKiAvLyBAbG9nOiAgIHR5cGU6ICd0ZW1wbycsXG4gKiAvLyBAbG9nOiAgIHI6IDEyNS4uLm4sXG4gKiAvLyBAbG9nOiAgIHM6IDY0Mi4uLm4sXG4gKiAvLyBAbG9nOiAgIHlQYXJpdHk6IDAsXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEZyb20gU2VyaWFsaXplZFxuICpcbiAqIEl0IGlzIHBvc3NpYmxlIHRvIGluc3RhbnRpYXRlIGEgVGVtcG8gVHJhbnNhY3Rpb24gRW52ZWxvcGUgZnJvbSBhIHtAbGluayBveCNUeEVudmVsb3BlVGVtcG8uU2VyaWFsaXplZH0gdmFsdWUuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFR4RW52ZWxvcGVUZW1wbyB9IGZyb20gJ294L3RlbXBvJ1xuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHhFbnZlbG9wZVRlbXBvLmZyb20oJzB4NzZmODRhMDE4MjAzMTE4NDc3MzU5NDAwODQ3NzM1OTQwMDgwOTQ3MDk5Nzk3MGM1MTgxMmRjM2EwMTBjN2QwMWI1MGUwZDE3ZGM3OWM4ODgwZGUwYjZiM2E3NjQwMDAwODBjMDgwODA4MCcpXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIGNoYWluSWQ6IDEsXG4gKiAvLyBAbG9nOiAgIGNhbGxzOiBbe1xuICogLy8gQGxvZzogICAgIGRhdGE6ICcweGRlYWRiZWVmJyxcbiAqIC8vIEBsb2c6ICAgICB0bzogJzB4NzA5OTc5NzBjNTE4MTJkYzNhMDEwYzdkMDFiNTBlMGQxN2RjNzljOCcsXG4gKiAvLyBAbG9nOiAgIH1dLFxuICogLy8gQGxvZzogICBtYXhGZWVQZXJHYXM6IDEwMDAwMDAwMDAwbixcbiAqIC8vIEBsb2c6ICAgdHlwZTogJ3RlbXBvJyxcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBlbnZlbG9wZSAtIFRoZSB0cmFuc2FjdGlvbiBvYmplY3QgdG8gY29udmVydC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIEEgVGVtcG8gVHJhbnNhY3Rpb24gRW52ZWxvcGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tKGVudmVsb3BlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGZlZVBheWVyU2lnbmF0dXJlLCBzaWduYXR1cmUgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgZW52ZWxvcGVfID0gKHR5cGVvZiBlbnZlbG9wZSA9PT0gJ3N0cmluZycgPyBkZXNlcmlhbGl6ZShlbnZlbG9wZSkgOiBlbnZlbG9wZSk7XG4gICAgYXNzZXJ0KGVudmVsb3BlXyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZW52ZWxvcGVfLFxuICAgICAgICAuLi4oc2lnbmF0dXJlID8geyBzaWduYXR1cmU6IFNpZ25hdHVyZUVudmVsb3BlLmZyb20oc2lnbmF0dXJlKSB9IDoge30pLFxuICAgICAgICAuLi4oZmVlUGF5ZXJTaWduYXR1cmVcbiAgICAgICAgICAgID8geyBmZWVQYXllclNpZ25hdHVyZTogU2lnbmF0dXJlLmZyb20oZmVlUGF5ZXJTaWduYXR1cmUpIH1cbiAgICAgICAgICAgIDoge30pLFxuICAgICAgICB0eXBlOiAndGVtcG8nLFxuICAgIH07XG59XG4vKipcbiAqIFNlcmlhbGl6ZXMgYSB7QGxpbmsgb3gjVHhFbnZlbG9wZVRlbXBvLlR4RW52ZWxvcGVUZW1wb30uXG4gKlxuICogUkxQLWVuY29kZXMgdGhlIHRyYW5zYWN0aW9uIHdpdGggdHlwZSBwcmVmaXggYDB4NzZgLiBGb3IgZmVlIHNwb25zb3JzaGlwLCB1c2UgYGZvcm1hdDogJ2ZlZVBheWVyJ2BcbiAqIHRvIHNlcmlhbGl6ZSB3aXRoIHRoZSBmZWUgcGF5ZXIgbWFnaWMgYDB4NzhgIGFuZCB0aGUgc2VuZGVyIGFkZHJlc3MuXG4gKlxuICogW1JMUCBFbmNvZGluZ10oaHR0cHM6Ly9kb2NzLnRlbXBvLnh5ei9wcm90b2NvbC90cmFuc2FjdGlvbnMvc3BlYy10ZW1wby10cmFuc2FjdGlvbiNybHAtZW5jb2RpbmcpXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IFZhbHVlIH0gZnJvbSAnb3gnXG4gKiBpbXBvcnQgeyBUeEVudmVsb3BlVGVtcG8gfSBmcm9tICdveC90ZW1wbydcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFR4RW52ZWxvcGVUZW1wby5mcm9tKHtcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgY2FsbHM6IFt7XG4gKiAgICAgZGF0YTogJzB4ZGVhZGJlZWYnLFxuICogICAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgfV0sXG4gKiAgIG1heEZlZVBlckdhczogVmFsdWUuZnJvbUd3ZWkoJzEwJyksXG4gKiB9KVxuICpcbiAqIGNvbnN0IHNlcmlhbGl6ZWQgPSBUeEVudmVsb3BlVGVtcG8uc2VyaWFsaXplKGVudmVsb3BlKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEF0dGFjaGluZyBTaWduYXR1cmVzXG4gKlxuICogSXQgaXMgcG9zc2libGUgdG8gYXR0YWNoIGEgYHNpZ25hdHVyZWAgdG8gdGhlIHNlcmlhbGl6ZWQgVHJhbnNhY3Rpb24gRW52ZWxvcGUuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgU2VjcDI1NmsxLCBWYWx1ZSB9IGZyb20gJ294J1xuICogaW1wb3J0IHsgVHhFbnZlbG9wZVRlbXBvIH0gZnJvbSAnb3gvdGVtcG8nXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUeEVudmVsb3BlVGVtcG8uZnJvbSh7XG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIGNhbGxzOiBbe1xuICogICAgIGRhdGE6ICcweGRlYWRiZWVmJyxcbiAqICAgICB0bzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIH1dLFxuICogICBtYXhGZWVQZXJHYXM6IFZhbHVlLmZyb21Hd2VpKCcxMCcpLFxuICogfSlcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7XG4gKiAgIHBheWxvYWQ6IFR4RW52ZWxvcGVUZW1wby5nZXRTaWduUGF5bG9hZChlbnZlbG9wZSksXG4gKiAgIHByaXZhdGVLZXk6ICcweC4uLicsXG4gKiB9KVxuICpcbiAqIGNvbnN0IHNlcmlhbGl6ZWQgPSBUeEVudmVsb3BlVGVtcG8uc2VyaWFsaXplKGVudmVsb3BlLCB7IC8vIFshY29kZSBmb2N1c11cbiAqICAgc2lnbmF0dXJlLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KSAvLyBbIWNvZGUgZm9jdXNdXG4gKlxuICogLy8gLi4uIHNlbmQgYHNlcmlhbGl6ZWRgIHRyYW5zYWN0aW9uIHRvIEpTT04tUlBDIGBldGhfc2VuZFJhd1RyYW5zYWN0aW9uYFxuICogYGBgXG4gKlxuICogQHBhcmFtIGVudmVsb3BlIC0gVGhlIFRyYW5zYWN0aW9uIEVudmVsb3BlIHRvIHNlcmlhbGl6ZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBzZXJpYWxpemVkIFRyYW5zYWN0aW9uIEVudmVsb3BlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplKGVudmVsb3BlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGFjY2Vzc0xpc3QsIGF1dGhvcml6YXRpb25MaXN0LCBjYWxscywgY2hhaW5JZCwgZmVlVG9rZW4sIGdhcywga2V5QXV0aG9yaXphdGlvbiwgbm9uY2UsIG5vbmNlS2V5LCBtYXhGZWVQZXJHYXMsIG1heFByaW9yaXR5RmVlUGVyR2FzLCB2YWxpZEJlZm9yZSwgdmFsaWRBZnRlciwgfSA9IGVudmVsb3BlO1xuICAgIGFzc2VydChlbnZlbG9wZSk7XG4gICAgY29uc3QgYWNjZXNzVHVwbGVMaXN0ID0gQWNjZXNzTGlzdC50b1R1cGxlTGlzdChhY2Nlc3NMaXN0KTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBvcHRpb25zLnNpZ25hdHVyZSB8fCBlbnZlbG9wZS5zaWduYXR1cmU7XG4gICAgY29uc3QgYXV0aG9yaXphdGlvblR1cGxlTGlzdCA9IEF1dGhvcml6YXRpb25UZW1wby50b1R1cGxlTGlzdChhdXRob3JpemF0aW9uTGlzdCk7XG4gICAgLy8gRW5jb2RlIGNhbGxzIGFzIFJMUCBsaXN0IG9mIFt0bywgdmFsdWUsIGRhdGFdIHR1cGxlc1xuICAgIGNvbnN0IGNhbGxzVHVwbGVMaXN0ID0gY2FsbHMubWFwKChjYWxsKSA9PiBbXG4gICAgICAgIGNhbGwudG8gPz8gJzB4JyxcbiAgICAgICAgY2FsbC52YWx1ZSA/IEhleC5mcm9tTnVtYmVyKGNhbGwudmFsdWUpIDogJzB4JyxcbiAgICAgICAgY2FsbC5kYXRhID8/ICcweCcsXG4gICAgXSk7XG4gICAgY29uc3QgZmVlUGF5ZXJTaWduYXR1cmVPclNlbmRlciA9ICgoKSA9PiB7XG4gICAgICAgIGlmIChvcHRpb25zLnNlbmRlcilcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLnNlbmRlcjtcbiAgICAgICAgY29uc3QgZmVlUGF5ZXJTaWduYXR1cmUgPSB0eXBlb2Ygb3B0aW9ucy5mZWVQYXllclNpZ25hdHVyZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgID8gb3B0aW9ucy5mZWVQYXllclNpZ25hdHVyZVxuICAgICAgICAgICAgOiBlbnZlbG9wZS5mZWVQYXllclNpZ25hdHVyZTtcbiAgICAgICAgaWYgKGZlZVBheWVyU2lnbmF0dXJlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuICcweDAwJztcbiAgICAgICAgaWYgKCFmZWVQYXllclNpZ25hdHVyZSlcbiAgICAgICAgICAgIHJldHVybiAnMHgnO1xuICAgICAgICByZXR1cm4gU2lnbmF0dXJlLnRvVHVwbGUoZmVlUGF5ZXJTaWduYXR1cmUpO1xuICAgIH0pKCk7XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IFtcbiAgICAgICAgSGV4LmZyb21OdW1iZXIoY2hhaW5JZCksXG4gICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzID8gSGV4LmZyb21OdW1iZXIobWF4UHJpb3JpdHlGZWVQZXJHYXMpIDogJzB4JyxcbiAgICAgICAgbWF4RmVlUGVyR2FzID8gSGV4LmZyb21OdW1iZXIobWF4RmVlUGVyR2FzKSA6ICcweCcsXG4gICAgICAgIGdhcyA/IEhleC5mcm9tTnVtYmVyKGdhcykgOiAnMHgnLFxuICAgICAgICBjYWxsc1R1cGxlTGlzdCxcbiAgICAgICAgYWNjZXNzVHVwbGVMaXN0LFxuICAgICAgICBub25jZUtleSA/IEhleC5mcm9tTnVtYmVyKG5vbmNlS2V5KSA6ICcweCcsXG4gICAgICAgIG5vbmNlID8gSGV4LmZyb21OdW1iZXIobm9uY2UpIDogJzB4JyxcbiAgICAgICAgdHlwZW9mIHZhbGlkQmVmb3JlID09PSAnbnVtYmVyJyA/IEhleC5mcm9tTnVtYmVyKHZhbGlkQmVmb3JlKSA6ICcweCcsXG4gICAgICAgIHR5cGVvZiB2YWxpZEFmdGVyID09PSAnbnVtYmVyJyA/IEhleC5mcm9tTnVtYmVyKHZhbGlkQWZ0ZXIpIDogJzB4JyxcbiAgICAgICAgdHlwZW9mIGZlZVRva2VuID09PSAnYmlnaW50JyB8fCB0eXBlb2YgZmVlVG9rZW4gPT09ICdzdHJpbmcnXG4gICAgICAgICAgICA/IFRva2VuSWQudG9BZGRyZXNzKGZlZVRva2VuKVxuICAgICAgICAgICAgOiAnMHgnLFxuICAgICAgICBmZWVQYXllclNpZ25hdHVyZU9yU2VuZGVyLFxuICAgICAgICBhdXRob3JpemF0aW9uVHVwbGVMaXN0LFxuICAgICAgICAuLi4oa2V5QXV0aG9yaXphdGlvbiA/IFtLZXlBdXRob3JpemF0aW9uLnRvVHVwbGUoa2V5QXV0aG9yaXphdGlvbildIDogW10pLFxuICAgICAgICAuLi4oc2lnbmF0dXJlXG4gICAgICAgICAgICA/IFtTaWduYXR1cmVFbnZlbG9wZS5zZXJpYWxpemUoU2lnbmF0dXJlRW52ZWxvcGUuZnJvbShzaWduYXR1cmUpKV1cbiAgICAgICAgICAgIDogW10pLFxuICAgIF07XG4gICAgcmV0dXJuIEhleC5jb25jYXQob3B0aW9ucy5mb3JtYXQgPT09ICdmZWVQYXllcicgPyBmZWVQYXllck1hZ2ljIDogc2VyaWFsaXplZFR5cGUsIFJscC5mcm9tSGV4KHNlcmlhbGl6ZWQpKTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgcGF5bG9hZCB0byBzaWduIGZvciBhIHtAbGluayBveCNUeEVudmVsb3BlVGVtcG8uVHhFbnZlbG9wZVRlbXBvfS5cbiAqXG4gKiBDb21wdXRlcyB0aGUga2VjY2FrMjU2IGhhc2ggb2YgdGhlIHVuc2lnbmVkIHNlcmlhbGl6ZWQgdHJhbnNhY3Rpb24uIFNpZ24gdGhpcyBwYXlsb2FkXG4gKiB3aXRoIHNlY3AyNTZrMSwgUDI1Niwgb3IgV2ViQXV0aG4sIHRoZW4gYXR0YWNoIHRoZSBzaWduYXR1cmUgdmlhIHtAbGluayBveCNUeEVudmVsb3BlVGVtcG8uKGZyb206ZnVuY3Rpb24pfS5cbiAqXG4gKiBbVGVtcG8gVHJhbnNhY3Rpb24gU3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly9kb2NzLnRlbXBvLnh5ei9wcm90b2NvbC90cmFuc2FjdGlvbnMvc3BlYy10ZW1wby10cmFuc2FjdGlvbilcbiAqXG4gKiBAZXhhbXBsZVxuICogVGhlIGV4YW1wbGUgYmVsb3cgZGVtb25zdHJhdGVzIGhvdyB0byBjb21wdXRlIHRoZSBzaWduIHBheWxvYWQgd2hpY2ggY2FuIGJlIHVzZWRcbiAqIHdpdGggRUNEU0Egc2lnbmluZyB1dGlsaXRpZXMgbGlrZSB7QGxpbmsgb3gjU2VjcDI1NmsxLihzaWduOmZ1bmN0aW9uKX0uXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgU2VjcDI1NmsxIH0gZnJvbSAnb3gnXG4gKiBpbXBvcnQgeyBUeEVudmVsb3BlVGVtcG8gfSBmcm9tICdveC90ZW1wbydcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFR4RW52ZWxvcGVUZW1wby5mcm9tKHtcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgY2FsbHM6IFt7XG4gKiAgICAgZGF0YTogJzB4ZGVhZGJlZWYnLFxuICogICAgIHRvOiAnMHg3MDk5Nzk3MGM1MTgxMmRjM2EwMTBjN2QwMWI1MGUwZDE3ZGM3OWM4JyxcbiAqICAgfV0sXG4gKiAgIG5vbmNlOiAwbixcbiAqICAgbWF4RmVlUGVyR2FzOiAxMDAwMDAwMDAwbixcbiAqICAgZ2FzOiAyMTAwMG4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IHBheWxvYWQgPSBUeEVudmVsb3BlVGVtcG8uZ2V0U2lnblBheWxvYWQoZW52ZWxvcGUpIC8vIFshY29kZSBmb2N1c11cbiAqIC8vIEBsb2c6ICcweC4uLidcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7IHBheWxvYWQsIHByaXZhdGVLZXk6ICcweC4uLicgfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBlbnZlbG9wZSAtIFRoZSB0cmFuc2FjdGlvbiBlbnZlbG9wZSB0byBnZXQgdGhlIHNpZ24gcGF5bG9hZCBmb3IuXG4gKiBAcmV0dXJucyBUaGUgc2lnbiBwYXlsb2FkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2lnblBheWxvYWQoZW52ZWxvcGUpIHtcbiAgICByZXR1cm4gaGFzaChlbnZlbG9wZSwgeyBwcmVzaWduOiB0cnVlIH0pO1xufVxuLyoqXG4gKiBIYXNoZXMgYSB7QGxpbmsgb3gjVHhFbnZlbG9wZVRlbXBvLlR4RW52ZWxvcGVUZW1wb30uIFRoaXMgaXMgdGhlIFwidHJhbnNhY3Rpb24gaGFzaFwiLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEgfSBmcm9tICdveCdcbiAqIGltcG9ydCB7IFR4RW52ZWxvcGVUZW1wbyB9IGZyb20gJ294L3RlbXBvJ1xuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHhFbnZlbG9wZVRlbXBvLmZyb20oe1xuICogICBjaGFpbklkOiAxLFxuICogICBjYWxsczogW3tcbiAqICAgICBkYXRhOiAnMHhkZWFkYmVlZicsXG4gKiAgICAgdG86ICcweDcwOTk3OTcwYzUxODEyZGMzYTAxMGM3ZDAxYjUwZTBkMTdkYzc5YzgnLFxuICogICB9XSxcbiAqICAgbm9uY2U6IDBuLFxuICogICBtYXhGZWVQZXJHYXM6IDEwMDAwMDAwMDBuLFxuICogICBnYXM6IDIxMDAwbixcbiAqIH0pXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oe1xuICogICBwYXlsb2FkOiBUeEVudmVsb3BlVGVtcG8uZ2V0U2lnblBheWxvYWQoZW52ZWxvcGUpLFxuICogICBwcml2YXRlS2V5OiAnMHguLi4nXG4gKiB9KVxuICpcbiAqIGNvbnN0IGVudmVsb3BlX3NpZ25lZCA9IFR4RW52ZWxvcGVUZW1wby5mcm9tKGVudmVsb3BlLCB7IHNpZ25hdHVyZSB9KVxuICpcbiAqIGNvbnN0IGhhc2ggPSBUeEVudmVsb3BlVGVtcG8uaGFzaChlbnZlbG9wZV9zaWduZWQpIC8vIFshY29kZSBmb2N1c11cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBlbnZlbG9wZSAtIFRoZSBUZW1wbyBUcmFuc2FjdGlvbiBFbnZlbG9wZSB0byBoYXNoLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgVGhlIGhhc2ggb2YgdGhlIHRyYW5zYWN0aW9uIGVudmVsb3BlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzaChlbnZlbG9wZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IHNlcmlhbGl6ZSh7XG4gICAgICAgIC4uLmVudmVsb3BlLFxuICAgICAgICAuLi4ob3B0aW9ucy5wcmVzaWduXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBzaWduYXR1cmU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge30pLFxuICAgIH0pO1xuICAgIHJldHVybiBIYXNoLmtlY2NhazI1NihzZXJpYWxpemVkKTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgZmVlIHBheWVyIHBheWxvYWQgdG8gc2lnbiBmb3IgYSB7QGxpbmsgb3gjVHhFbnZlbG9wZVRlbXBvLlR4RW52ZWxvcGVUZW1wb30uXG4gKlxuICogRmVlIHNwb25zb3JzaGlwIHVzZXMgYSBkdWFsLXNpZ25hdHVyZSBzY2hlbWU6IHRoZSBzZW5kZXIgc2lnbnMgdGhlIHRyYW5zYWN0aW9uLCB0aGVuIGEgZmVlIHBheWVyXG4gKiBzaWducyBvdmVyIHRoZSB0cmFuc2FjdGlvbiB3aXRoIHRoZSBzZW5kZXIncyBhZGRyZXNzIHRvIGNvbW1pdCB0byBwYXlpbmcgZmVlcy4gVGhlIGZlZSBwYXllcidzXG4gKiBzaWduYXR1cmUgaW5jbHVkZXMgdGhlIGBmZWVUb2tlbmAgYW5kIGBzZW5kZXJfYWRkcmVzc2AsIHVzaW5nIG1hZ2ljIGJ5dGUgYDB4NzhgIGZvciBkb21haW4gc2VwYXJhdGlvbi5cbiAqXG4gKiBbRmVlIFBheWVyIFNpZ25hdHVyZV0oaHR0cHM6Ly9kb2NzLnRlbXBvLnh5ei9wcm90b2NvbC90cmFuc2FjdGlvbnMvc3BlYy10ZW1wby10cmFuc2FjdGlvbiNmZWUtcGF5ZXItc2lnbmF0dXJlKVxuICogW0ZlZSBTcG9uc29yc2hpcCBHdWlkZV0oaHR0cHM6Ly9kb2NzLnRlbXBvLnh5ei9wcm90b2NvbC90cmFuc2FjdGlvbnMjZmVlLXNwb25zb3JzaGlwKVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEgfSBmcm9tICdveCdcbiAqIGltcG9ydCB7IFR4RW52ZWxvcGVUZW1wbyB9IGZyb20gJ294L3RlbXBvJ1xuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHhFbnZlbG9wZVRlbXBvLmZyb20oe1xuICogICBjaGFpbklkOiAxLFxuICogICBjYWxsczogW3tcbiAqICAgICBkYXRhOiAnMHhkZWFkYmVlZicsXG4gKiAgICAgdG86ICcweDcwOTk3OTcwYzUxODEyZGMzYTAxMGM3ZDAxYjUwZTBkMTdkYzc5YzgnLFxuICogICB9XSxcbiAqICAgbm9uY2U6IDBuLFxuICogICBtYXhGZWVQZXJHYXM6IDEwMDAwMDAwMDBuLFxuICogICBnYXM6IDIxMDAwbixcbiAqIH0pXG4gKlxuICogY29uc3QgcGF5bG9hZCA9IFR4RW52ZWxvcGVUZW1wby5nZXRGZWVQYXllclNpZ25QYXlsb2FkKGVudmVsb3BlLCB7XG4gKiAgIHNlbmRlcjogJzB4ZDhkYTZiZjI2OTY0YWY5ZDdlZWQ5ZTAzZTUzNDE1ZDM3YWE5NjA0NSdcbiAqIH0pIC8vIFshY29kZSBmb2N1c11cbiAqIC8vIEBsb2c6ICcweC4uLidcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7IHBheWxvYWQsIHByaXZhdGVLZXk6ICcweC4uLicgfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBlbnZlbG9wZSAtIFRoZSB0cmFuc2FjdGlvbiBlbnZlbG9wZSB0byBnZXQgdGhlIGZlZSBwYXllciBzaWduIHBheWxvYWQgZm9yLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgVGhlIGZlZSBwYXllciBzaWduIHBheWxvYWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRGZWVQYXllclNpZ25QYXlsb2FkKGVudmVsb3BlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBzZW5kZXIgfSA9IG9wdGlvbnM7XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IHNlcmlhbGl6ZSh7IC4uLmVudmVsb3BlLCBzaWduYXR1cmU6IHVuZGVmaW5lZCB9LCB7XG4gICAgICAgIHNlbmRlcixcbiAgICAgICAgZm9ybWF0OiAnZmVlUGF5ZXInLFxuICAgIH0pO1xuICAgIHJldHVybiBIYXNoLmtlY2NhazI1NihzZXJpYWxpemVkKTtcbn1cbi8qKlxuICogVmFsaWRhdGVzIGEge0BsaW5rIG94I1R4RW52ZWxvcGVUZW1wby5UeEVudmVsb3BlVGVtcG99LiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW52ZWxvcGUgaXMgdmFsaWQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHhFbnZlbG9wZVRlbXBvIH0gZnJvbSAnb3gvdGVtcG8nXG4gKlxuICogY29uc3QgdmFsaWQgPSBUeEVudmVsb3BlVGVtcG8udmFsaWRhdGUoe1xuICogICBjYWxsczogW3tcbiAqICAgICBkYXRhOiAnMHhkZWFkYmVlZicsXG4gKiAgICAgdG86ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICB9XSxcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbWF4RmVlUGVyR2FzOiAxMDAwMDAwMDAwbixcbiAqIH0pXG4gKiAvLyBAbG9nOiB0cnVlXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZW52ZWxvcGUgLSBUaGUgdHJhbnNhY3Rpb24gZW52ZWxvcGUgdG8gdmFsaWRhdGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZShlbnZlbG9wZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGFzc2VydChlbnZlbG9wZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIGEgdHJhbnNhY3Rpb24ncyBjYWxscyBsaXN0IGlzIGVtcHR5LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHhFbnZlbG9wZVRlbXBvIH0gZnJvbSAnb3gvdGVtcG8nXG4gKlxuICogVHhFbnZlbG9wZVRlbXBvLmFzc2VydCh7XG4gKiAgIGNhbGxzOiBbXSxcbiAqICAgY2hhaW5JZDogMSxcbiAqIH0pXG4gKiAvLyBAZXJyb3I6IFR4RW52ZWxvcGVUZW1wby5DYWxsc0VtcHR5RXJyb3I6IENhbGxzIGxpc3QgY2Fubm90IGJlIGVtcHR5LlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBDYWxsc0VtcHR5RXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ0NhbGxzIGxpc3QgY2Fubm90IGJlIGVtcHR5LicpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnVHhFbnZlbG9wZVRlbXBvLkNhbGxzRW1wdHlFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd24gd2hlbiB2YWxpZEJlZm9yZSBpcyBub3QgZ3JlYXRlciB0aGFuIHZhbGlkQWZ0ZXIuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBUeEVudmVsb3BlVGVtcG8gfSBmcm9tICdveC90ZW1wbydcbiAqXG4gKiBUeEVudmVsb3BlVGVtcG8uYXNzZXJ0KHtcbiAqICAgY2FsbHM6IFt7IHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyB9XSxcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgdmFsaWRCZWZvcmU6IDEwMCxcbiAqICAgdmFsaWRBZnRlcjogMjAwLFxuICogfSlcbiAqIC8vIEBlcnJvcjogVHhFbnZlbG9wZVRlbXBvLkludmFsaWRWYWxpZGl0eVdpbmRvd0Vycm9yOiB2YWxpZEJlZm9yZSAoMTAwKSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB2YWxpZEFmdGVyICgyMDApLlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkVmFsaWRpdHlXaW5kb3dFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgdmFsaWRCZWZvcmUsIHZhbGlkQWZ0ZXIsIH0pIHtcbiAgICAgICAgc3VwZXIoYHZhbGlkQmVmb3JlICgke3ZhbGlkQmVmb3JlfSkgbXVzdCBiZSBncmVhdGVyIHRoYW4gdmFsaWRBZnRlciAoJHt2YWxpZEFmdGVyfSkuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdUeEVudmVsb3BlVGVtcG8uSW52YWxpZFZhbGlkaXR5V2luZG93RXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVR4RW52ZWxvcGVUZW1wby5qcy5tYXAiXSwibmFtZXMiOlsiQWNjZXNzTGlzdCIsIkFkZHJlc3MiLCJFcnJvcnMiLCJIYXNoIiwiSGV4IiwiUmxwIiwiU2lnbmF0dXJlIiwiVHJhbnNhY3Rpb25FbnZlbG9wZSIsIkF1dGhvcml6YXRpb25UZW1wbyIsIktleUF1dGhvcml6YXRpb24iLCJTaWduYXR1cmVFbnZlbG9wZSIsIlRva2VuSWQiLCJmZWVQYXllck1hZ2ljIiwic2VyaWFsaXplZFR5cGUiLCJ0eXBlIiwiYXNzZXJ0IiwiZW52ZWxvcGUiLCJjYWxscyIsImNoYWluSWQiLCJtYXhGZWVQZXJHYXMiLCJtYXhQcmlvcml0eUZlZVBlckdhcyIsInZhbGlkQmVmb3JlIiwidmFsaWRBZnRlciIsImxlbmd0aCIsIkNhbGxzRW1wdHlFcnJvciIsIkludmFsaWRWYWxpZGl0eVdpbmRvd0Vycm9yIiwiY2FsbCIsInRvIiwic3RyaWN0IiwiSW52YWxpZENoYWluSWRFcnJvciIsIkJpZ0ludCIsIkZlZUNhcFRvb0hpZ2hFcnJvciIsImZlZUNhcCIsIlRpcEFib3ZlRmVlQ2FwRXJyb3IiLCJkZXNlcmlhbGl6ZSIsInNlcmlhbGl6ZWQiLCJ0cmFuc2FjdGlvbkFycmF5IiwidG9IZXgiLCJzbGljZSIsImdhcyIsImFjY2Vzc0xpc3QiLCJub25jZUtleSIsIm5vbmNlIiwiZmVlVG9rZW4iLCJmZWVQYXllclNpZ25hdHVyZU9yU2VuZGVyIiwiYXV0aG9yaXphdGlvbkxpc3QiLCJrZXlBdXRob3JpemF0aW9uT3JTaWduYXR1cmUiLCJtYXliZVNpZ25hdHVyZSIsImtleUF1dGhvcml6YXRpb24iLCJBcnJheSIsImlzQXJyYXkiLCJ1bmRlZmluZWQiLCJzaWduYXR1cmUiLCJJbnZhbGlkU2VyaWFsaXplZEVycm9yIiwiYXR0cmlidXRlcyIsInRyYW5zYWN0aW9uIiwiTnVtYmVyIiwidmFsaWRhdGUiLCJjYWxsc0FycmF5IiwibWFwIiwiY2FsbFR1cGxlIiwidmFsdWUiLCJkYXRhIiwiZnJvbVR1cGxlTGlzdCIsImZlZVBheWVyU2lnbmF0dXJlIiwiZnJvbVR1cGxlIiwic2lnbmF0dXJlRW52ZWxvcGUiLCJmcm9tIiwib3B0aW9ucyIsImVudmVsb3BlXyIsInNlcmlhbGl6ZSIsImFjY2Vzc1R1cGxlTGlzdCIsInRvVHVwbGVMaXN0IiwiYXV0aG9yaXphdGlvblR1cGxlTGlzdCIsImNhbGxzVHVwbGVMaXN0IiwiZnJvbU51bWJlciIsInNlbmRlciIsInRvVHVwbGUiLCJ0b0FkZHJlc3MiLCJjb25jYXQiLCJmb3JtYXQiLCJmcm9tSGV4IiwiZ2V0U2lnblBheWxvYWQiLCJoYXNoIiwicHJlc2lnbiIsImtlY2NhazI1NiIsImdldEZlZVBheWVyU2lnblBheWxvYWQiLCJCYXNlRXJyb3IiLCJjb25zdHJ1Y3RvciIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/tempo/TxEnvelopeTempo.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/@adraffy/ens-normalize/dist/index.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/ox/node_modules/@adraffy/ens-normalize/dist/index.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ens_beautify: () => (/* binding */ ens_beautify),\n/* harmony export */   ens_emoji: () => (/* binding */ ens_emoji),\n/* harmony export */   ens_normalize: () => (/* binding */ ens_normalize),\n/* harmony export */   ens_normalize_fragment: () => (/* binding */ ens_normalize_fragment),\n/* harmony export */   ens_split: () => (/* binding */ ens_split),\n/* harmony export */   ens_tokenize: () => (/* binding */ ens_tokenize),\n/* harmony export */   is_combining_mark: () => (/* binding */ is_combining_mark),\n/* harmony export */   nfc: () => (/* binding */ nfc),\n/* harmony export */   nfd: () => (/* binding */ nfd),\n/* harmony export */   safe_str_from_cps: () => (/* binding */ safe_str_from_cps),\n/* harmony export */   should_escape: () => (/* binding */ should_escape)\n/* harmony export */ });\n// created 2025-09-14T17:56:24.099Z\n// compressed base64-encoded blob for include-ens data\n// source: https://github.com/adraffy/ens-normalize.js/blob/main/src/make.js\n// see: https://github.com/adraffy/ens-normalize.js#security\n// SHA-256: 92cbf3a1af3c3c0a91aee0dc542072775f4ebbbc526a84189a12da2d56f5accd\nvar COMPRESSED$1 = \"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\";\nconst FENCED = new Map([\n    [\n        8217,\n        \"apostrophe\"\n    ],\n    [\n        8260,\n        \"fraction slash\"\n    ],\n    [\n        12539,\n        \"middle dot\"\n    ]\n]);\nconst NSM_MAX = 4;\nfunction decode_arithmetic(bytes) {\n    let pos = 0;\n    function u16() {\n        return bytes[pos++] << 8 | bytes[pos++];\n    }\n    // decode the frequency table\n    let symbol_count = u16();\n    let total = 1;\n    let acc = [\n        0,\n        1\n    ]; // first symbol has frequency 1\n    for(let i = 1; i < symbol_count; i++){\n        acc.push(total += u16());\n    }\n    // skip the sized-payload that the last 3 symbols index into\n    let skip = u16();\n    let pos_payload = pos;\n    pos += skip;\n    let read_width = 0;\n    let read_buffer = 0;\n    function read_bit() {\n        if (read_width == 0) {\n            // this will read beyond end of buffer\n            // but (undefined|0) => zero pad\n            read_buffer = read_buffer << 8 | bytes[pos++];\n            read_width = 8;\n        }\n        return read_buffer >> --read_width & 1;\n    }\n    const N = 31;\n    const FULL = 2 ** N;\n    const HALF = FULL >>> 1;\n    const QRTR = HALF >> 1;\n    const MASK = FULL - 1;\n    // fill register\n    let register = 0;\n    for(let i = 0; i < N; i++)register = register << 1 | read_bit();\n    let symbols = [];\n    let low = 0;\n    let range = FULL; // treat like a float\n    while(true){\n        let value = Math.floor(((register - low + 1) * total - 1) / range);\n        let start = 0;\n        let end = symbol_count;\n        while(end - start > 1){\n            let mid = start + end >>> 1;\n            if (value < acc[mid]) {\n                end = mid;\n            } else {\n                start = mid;\n            }\n        }\n        if (start == 0) break; // first symbol is end mark\n        symbols.push(start);\n        let a = low + Math.floor(range * acc[start] / total);\n        let b = low + Math.floor(range * acc[start + 1] / total) - 1;\n        while(((a ^ b) & HALF) == 0){\n            register = register << 1 & MASK | read_bit();\n            a = a << 1 & MASK;\n            b = b << 1 & MASK | 1;\n        }\n        while(a & ~b & QRTR){\n            register = register & HALF | register << 1 & MASK >>> 1 | read_bit();\n            a = a << 1 ^ HALF;\n            b = (b ^ HALF) << 1 | HALF | 1;\n        }\n        low = a;\n        range = 1 + b - a;\n    }\n    let offset = symbol_count - 4;\n    return symbols.map((x)=>{\n        switch(x - offset){\n            case 3:\n                return offset + 0x10100 + (bytes[pos_payload++] << 16 | bytes[pos_payload++] << 8 | bytes[pos_payload++]);\n            case 2:\n                return offset + 0x100 + (bytes[pos_payload++] << 8 | bytes[pos_payload++]);\n            case 1:\n                return offset + bytes[pos_payload++];\n            default:\n                return x - 1;\n        }\n    });\n}\n// returns an iterator which returns the next symbol\nfunction read_payload(v) {\n    let pos = 0;\n    return ()=>v[pos++];\n}\nfunction read_compressed_payload(s) {\n    return read_payload(decode_arithmetic(unsafe_atob(s)));\n}\n// unsafe in the sense:\n// expected well-formed Base64 w/o padding \n// 20220922: added for https://github.com/adraffy/ens-normalize.js/issues/4\nfunction unsafe_atob(s) {\n    let lookup = [];\n    [\n        ...\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"\n    ].forEach((c, i)=>lookup[c.charCodeAt(0)] = i);\n    let n = s.length;\n    let ret = new Uint8Array(6 * n >> 3);\n    for(let i = 0, pos = 0, width = 0, carry = 0; i < n; i++){\n        carry = carry << 6 | lookup[s.charCodeAt(i)];\n        width += 6;\n        if (width >= 8) {\n            ret[pos++] = carry >> (width -= 8);\n        }\n    }\n    return ret;\n}\n// eg. [0,1,2,3...] => [0,-1,1,-2,...]\nfunction signed(i) {\n    return i & 1 ? ~i >> 1 : i >> 1;\n}\nfunction read_deltas(n, next) {\n    let v = Array(n);\n    for(let i = 0, x = 0; i < n; i++)v[i] = x += signed(next());\n    return v;\n}\n// [123][5] => [0 3] [1 1] [0 0]\nfunction read_sorted(next, prev = 0) {\n    let ret = [];\n    while(true){\n        let x = next();\n        let n = next();\n        if (!n) break;\n        prev += x;\n        for(let i = 0; i < n; i++){\n            ret.push(prev + i);\n        }\n        prev += n + 1;\n    }\n    return ret;\n}\nfunction read_sorted_arrays(next) {\n    return read_array_while(()=>{\n        let v = read_sorted(next);\n        if (v.length) return v;\n    });\n}\n// returns map of x => ys\nfunction read_mapped(next) {\n    let ret = [];\n    while(true){\n        let w = next();\n        if (w == 0) break;\n        ret.push(read_linear_table(w, next));\n    }\n    while(true){\n        let w = next() - 1;\n        if (w < 0) break;\n        ret.push(read_replacement_table(w, next));\n    }\n    return ret.flat();\n}\n// read until next is falsy\n// return array of read values\nfunction read_array_while(next) {\n    let v = [];\n    while(true){\n        let x = next(v.length);\n        if (!x) break;\n        v.push(x);\n    }\n    return v;\n}\n// read w columns of length n\n// return as n rows of length w\nfunction read_transposed(n, w, next) {\n    let m = Array(n).fill().map(()=>[]);\n    for(let i = 0; i < w; i++){\n        read_deltas(n, next).forEach((x, j)=>m[j].push(x));\n    }\n    return m;\n}\n// returns [[x, ys], [x+dx, ys+dy], [x+2*dx, ys+2*dy], ...]\n// where dx/dy = steps, n = run size, w = length of y\nfunction read_linear_table(w, next) {\n    let dx = 1 + next();\n    let dy = next();\n    let vN = read_array_while(next);\n    let m = read_transposed(vN.length, 1 + w, next);\n    return m.flatMap((v, i)=>{\n        let [x, ...ys] = v;\n        return Array(vN[i]).fill().map((_, j)=>{\n            let j_dy = j * dy;\n            return [\n                x + j * dx,\n                ys.map((y)=>y + j_dy)\n            ];\n        });\n    });\n}\n// return [[x, ys...], ...]\n// where w = length of y\nfunction read_replacement_table(w, next) {\n    let n = 1 + next();\n    let m = read_transposed(n, 1 + w, next);\n    return m.map((v)=>[\n            v[0],\n            v.slice(1)\n        ]);\n}\nfunction read_trie(next) {\n    let ret = [];\n    let sorted = read_sorted(next);\n    expand(decode([]), []);\n    return ret; // not sorted\n    function decode(Q) {\n        let S = next(); // state: valid, save, check\n        let B = read_array_while(()=>{\n            let cps = read_sorted(next).map((i)=>sorted[i]);\n            if (cps.length) return decode(cps);\n        });\n        return {\n            S,\n            B,\n            Q\n        };\n    }\n    function expand({ S, B }, cps, saved) {\n        if (S & 4 && saved === cps[cps.length - 1]) return;\n        if (S & 2) saved = cps[cps.length - 1];\n        if (S & 1) ret.push(cps);\n        for (let br of B){\n            for (let cp of br.Q){\n                expand(br, [\n                    ...cps,\n                    cp\n                ], saved);\n            }\n        }\n    }\n}\nfunction hex_cp(cp) {\n    return cp.toString(16).toUpperCase().padStart(2, \"0\");\n}\nfunction quote_cp(cp) {\n    return `{${hex_cp(cp)}}`; // raffy convention: like \"\\u{X}\" w/o the \"\\u\"\n}\n/*\r\nexport function explode_cp(s) {\r\n\treturn [...s].map(c => c.codePointAt(0));\r\n}\r\n*/ function explode_cp(s) {\n    let cps = [];\n    for(let pos = 0, len = s.length; pos < len;){\n        let cp = s.codePointAt(pos);\n        pos += cp < 0x10000 ? 1 : 2;\n        cps.push(cp);\n    }\n    return cps;\n}\nfunction str_from_cps(cps) {\n    const chunk = 4096;\n    let len = cps.length;\n    if (len < chunk) return String.fromCodePoint(...cps);\n    let buf = [];\n    for(let i = 0; i < len;){\n        buf.push(String.fromCodePoint(...cps.slice(i, i += chunk)));\n    }\n    return buf.join(\"\");\n}\nfunction compare_arrays(a, b) {\n    let n = a.length;\n    let c = n - b.length;\n    for(let i = 0; c == 0 && i < n; i++)c = a[i] - b[i];\n    return c;\n}\nfunction array_replace(v, a, b) {\n    let prev = 0;\n    while(true){\n        let next = v.indexOf(a, prev);\n        if (next < 0) break;\n        v[next] = b;\n        prev = next + 1;\n    }\n}\n// created 2025-09-14T17:56:24.099Z\n// compressed base64-encoded blob for include-nf data\n// source: https://github.com/adraffy/ens-normalize.js/blob/main/src/make.js\n// see: https://github.com/adraffy/ens-normalize.js#security\n// SHA-256: 9ef43cc7215aa7a53e4ed9afa3b4f2f8ce00a2c708b9eb96aa409ae6fa3fb6af\nvar COMPRESSED = \"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\";\n// https://unicode.org/reports/tr15/\n// for reference implementation\n// see: /derive/nf.js\n// algorithmic hangul\n// https://www.unicode.org/versions/Unicode15.0.0/ch03.pdf (page 144)\nconst S0 = 0xAC00;\nconst L0 = 0x1100;\nconst V0 = 0x1161;\nconst T0 = 0x11A7;\nconst L_COUNT = 19;\nconst V_COUNT = 21;\nconst T_COUNT = 28;\nconst N_COUNT = V_COUNT * T_COUNT;\nconst S_COUNT = L_COUNT * N_COUNT;\nconst S1 = S0 + S_COUNT;\nconst L1 = L0 + L_COUNT;\nconst V1 = V0 + V_COUNT;\nconst T1 = T0 + T_COUNT;\nfunction unpack_cc(packed) {\n    return packed >> 24 & 0xFF;\n}\nfunction unpack_cp(packed) {\n    return packed & 0xFFFFFF;\n}\nlet SHIFTED_RANK, EXCLUSIONS, DECOMP, RECOMP;\n// export function nf_deinit() {\n// \tif (!SHIFTED_RANK) return;\n// \tSHIFTED_RANK = EXCLUSIONS = DECOMP = RECOMP = undefined;\n// }\nfunction init$1() {\n    //console.time('nf');\n    let r = read_compressed_payload(COMPRESSED);\n    SHIFTED_RANK = new Map(read_sorted_arrays(r).flatMap((v, i)=>v.map((x)=>[\n                x,\n                i + 1 << 24\n            ]))); // pre-shifted\n    EXCLUSIONS = new Set(read_sorted(r));\n    DECOMP = new Map();\n    RECOMP = new Map();\n    for (let [cp, cps] of read_mapped(r)){\n        if (!EXCLUSIONS.has(cp) && cps.length == 2) {\n            let [a, b] = cps;\n            let bucket = RECOMP.get(a);\n            if (!bucket) {\n                bucket = new Map();\n                RECOMP.set(a, bucket);\n            }\n            bucket.set(b, cp);\n        }\n        DECOMP.set(cp, cps.reverse()); // stored reversed\n    }\n//console.timeEnd('nf');\n// 20230905: 11ms\n}\nfunction is_hangul(cp) {\n    return cp >= S0 && cp < S1;\n}\nfunction compose_pair(a, b) {\n    if (a >= L0 && a < L1 && b >= V0 && b < V1) {\n        return S0 + (a - L0) * N_COUNT + (b - V0) * T_COUNT;\n    } else if (is_hangul(a) && b > T0 && b < T1 && (a - S0) % T_COUNT == 0) {\n        return a + (b - T0);\n    } else {\n        let recomp = RECOMP.get(a);\n        if (recomp) {\n            recomp = recomp.get(b);\n            if (recomp) {\n                return recomp;\n            }\n        }\n        return -1;\n    }\n}\nfunction decomposed(cps) {\n    if (!SHIFTED_RANK) init$1();\n    let ret = [];\n    let buf = [];\n    let check_order = false;\n    function add(cp) {\n        let cc = SHIFTED_RANK.get(cp);\n        if (cc) {\n            check_order = true;\n            cp |= cc;\n        }\n        ret.push(cp);\n    }\n    for (let cp of cps){\n        while(true){\n            if (cp < 0x80) {\n                ret.push(cp);\n            } else if (is_hangul(cp)) {\n                let s_index = cp - S0;\n                let l_index = s_index / N_COUNT | 0;\n                let v_index = s_index % N_COUNT / T_COUNT | 0;\n                let t_index = s_index % T_COUNT;\n                add(L0 + l_index);\n                add(V0 + v_index);\n                if (t_index > 0) add(T0 + t_index);\n            } else {\n                let mapped = DECOMP.get(cp);\n                if (mapped) {\n                    buf.push(...mapped);\n                } else {\n                    add(cp);\n                }\n            }\n            if (!buf.length) break;\n            cp = buf.pop();\n        }\n    }\n    if (check_order && ret.length > 1) {\n        let prev_cc = unpack_cc(ret[0]);\n        for(let i = 1; i < ret.length; i++){\n            let cc = unpack_cc(ret[i]);\n            if (cc == 0 || prev_cc <= cc) {\n                prev_cc = cc;\n                continue;\n            }\n            let j = i - 1;\n            while(true){\n                let tmp = ret[j + 1];\n                ret[j + 1] = ret[j];\n                ret[j] = tmp;\n                if (!j) break;\n                prev_cc = unpack_cc(ret[--j]);\n                if (prev_cc <= cc) break;\n            }\n            prev_cc = unpack_cc(ret[i]);\n        }\n    }\n    return ret;\n}\nfunction composed_from_decomposed(v) {\n    let ret = [];\n    let stack = [];\n    let prev_cp = -1;\n    let prev_cc = 0;\n    for (let packed of v){\n        let cc = unpack_cc(packed);\n        let cp = unpack_cp(packed);\n        if (prev_cp == -1) {\n            if (cc == 0) {\n                prev_cp = cp;\n            } else {\n                ret.push(cp);\n            }\n        } else if (prev_cc > 0 && prev_cc >= cc) {\n            if (cc == 0) {\n                ret.push(prev_cp, ...stack);\n                stack.length = 0;\n                prev_cp = cp;\n            } else {\n                stack.push(cp);\n            }\n            prev_cc = cc;\n        } else {\n            let composed = compose_pair(prev_cp, cp);\n            if (composed >= 0) {\n                prev_cp = composed;\n            } else if (prev_cc == 0 && cc == 0) {\n                ret.push(prev_cp);\n                prev_cp = cp;\n            } else {\n                stack.push(cp);\n                prev_cc = cc;\n            }\n        }\n    }\n    if (prev_cp >= 0) {\n        ret.push(prev_cp, ...stack);\n    }\n    return ret;\n}\n// note: cps can be iterable\nfunction nfd(cps) {\n    return decomposed(cps).map(unpack_cp);\n}\nfunction nfc(cps) {\n    return composed_from_decomposed(decomposed(cps));\n}\nconst HYPHEN = 0x2D;\nconst STOP = 0x2E;\nconst STOP_CH = \".\";\nconst FE0F = 0xFE0F;\nconst UNIQUE_PH = 1;\n// 20230913: replace [...v] with Array_from(v) to avoid large spreads\nconst Array_from = (x)=>Array.from(x); // Array.from.bind(Array);\nfunction group_has_cp(g, cp) {\n    // 20230913: keep primary and secondary distinct instead of creating valid union\n    return g.P.has(cp) || g.Q.has(cp);\n}\nclass Emoji extends Array {\n    get is_emoji() {\n        return true;\n    }\n}\nlet MAPPED, IGNORED, CM, NSM, ESCAPE, NFC_CHECK, GROUPS, WHOLE_VALID, WHOLE_MAP, VALID, EMOJI_LIST, EMOJI_ROOT;\n// export function ens_deinit() {\n// \tnf_deinit();\n// \tif (!MAPPED) return;\n// \tMAPPED = IGNORED = CM = NSM = ESCAPE = NFC_CHECK = GROUPS = WHOLE_VALID = WHOLE_MAP = VALID = EMOJI_LIST = EMOJI_ROOT = undefined;\n// }\nfunction init() {\n    if (MAPPED) return;\n    let r = read_compressed_payload(COMPRESSED$1);\n    const read_sorted_array = ()=>read_sorted(r);\n    const read_sorted_set = ()=>new Set(read_sorted_array());\n    const set_add_many = (set, v)=>v.forEach((x)=>set.add(x));\n    MAPPED = new Map(read_mapped(r));\n    IGNORED = read_sorted_set(); // ignored characters are not valid, so just read raw codepoints\n    /*\r\n\t// direct include from payload is smaller than the decompression code\r\n\tconst FENCED = new Map(read_array_while(() => {\r\n\t\tlet cp = r();\r\n\t\tif (cp) return [cp, read_str(r())];\r\n\t}));\r\n\t*/ // 20230217: we still need all CM for proper error formatting\n    // but norm only needs NSM subset that are potentially-valid\n    CM = read_sorted_array();\n    NSM = new Set(read_sorted_array().map((i)=>CM[i]));\n    CM = new Set(CM);\n    ESCAPE = read_sorted_set(); // characters that should not be printed\n    NFC_CHECK = read_sorted_set(); // only needed to illustrate ens_tokenize() transformations\n    let chunks = read_sorted_arrays(r);\n    let unrestricted = r();\n    //const read_chunked = () => new Set(read_sorted_array().flatMap(i => chunks[i]).concat(read_sorted_array()));\n    const read_chunked = ()=>{\n        // 20230921: build set in parts, 2x faster\n        let set = new Set();\n        read_sorted_array().forEach((i)=>set_add_many(set, chunks[i]));\n        set_add_many(set, read_sorted_array());\n        return set;\n    };\n    GROUPS = read_array_while((i)=>{\n        // minifier property mangling seems unsafe\n        // so these are manually renamed to single chars\n        let N = read_array_while(r).map((x)=>x + 0x60);\n        if (N.length) {\n            let R = i >= unrestricted; // unrestricted then restricted\n            N[0] -= 32; // capitalize\n            N = str_from_cps(N);\n            if (R) N = `Restricted[${N}]`;\n            let P = read_chunked(); // primary\n            let Q = read_chunked(); // secondary\n            let M = !r(); // not-whitelisted, check for NSM\n            // *** this code currently isn't needed ***\n            /*\r\n\t\t\tlet V = [...P, ...Q].sort((a, b) => a-b); // derive: sorted valid\r\n\t\t\tlet M = r()-1; // number of combining mark\r\n\t\t\tif (M < 0) { // whitelisted\r\n\t\t\t\tM = new Map(read_array_while(() => {\r\n\t\t\t\t\tlet i = r();\r\n\t\t\t\t\tif (i) return [V[i-1], read_array_while(() => {\r\n\t\t\t\t\t\tlet v = read_array_while(r);\r\n\t\t\t\t\t\tif (v.length) return v.map(x => x-1);\r\n\t\t\t\t\t})];\r\n\t\t\t\t}));\r\n\t\t\t}*/ return {\n                N,\n                P,\n                Q,\n                M,\n                R\n            };\n        }\n    });\n    // decode compressed wholes\n    WHOLE_VALID = read_sorted_set();\n    WHOLE_MAP = new Map();\n    let wholes = read_sorted_array().concat(Array_from(WHOLE_VALID)).sort((a, b)=>a - b); // must be sorted\n    wholes.forEach((cp, i)=>{\n        let d = r();\n        let w = wholes[i] = d ? wholes[i - d] : {\n            V: [],\n            M: new Map()\n        };\n        w.V.push(cp); // add to member set\n        if (!WHOLE_VALID.has(cp)) {\n            WHOLE_MAP.set(cp, w); // register with whole map\n        }\n    });\n    // compute confusable-extent complements\n    // usage: WHOLE_MAP.get(cp).M.get(cp) = complement set\n    for (let { V, M } of new Set(WHOLE_MAP.values())){\n        // connect all groups that have each whole character\n        let recs = [];\n        for (let cp of V){\n            let gs = GROUPS.filter((g)=>group_has_cp(g, cp));\n            let rec = recs.find(({ G })=>gs.some((g)=>G.has(g)));\n            if (!rec) {\n                rec = {\n                    G: new Set(),\n                    V: []\n                };\n                recs.push(rec);\n            }\n            rec.V.push(cp);\n            set_add_many(rec.G, gs);\n        }\n        // per character cache groups which are not a member of the extent\n        let union = recs.flatMap((x)=>Array_from(x.G)); // all of the groups used by this whole\n        for (let { G, V } of recs){\n            let complement = new Set(union.filter((g)=>!G.has(g))); // groups not covered by the extent\n            for (let cp of V){\n                M.set(cp, complement); // this is the same reference\n            }\n        }\n    }\n    // compute valid set\n    // 20230924: VALID was union but can be re-used\n    VALID = new Set(); // exists in 1+ groups\n    let multi = new Set(); // exists in 2+ groups\n    const add_to_union = (cp)=>VALID.has(cp) ? multi.add(cp) : VALID.add(cp);\n    for (let g of GROUPS){\n        for (let cp of g.P)add_to_union(cp);\n        for (let cp of g.Q)add_to_union(cp);\n    }\n    // dual purpose WHOLE_MAP: return placeholder if unique non-confusable\n    for (let cp of VALID){\n        if (!WHOLE_MAP.has(cp) && !multi.has(cp)) {\n            WHOLE_MAP.set(cp, UNIQUE_PH);\n        }\n    }\n    // add all decomposed parts\n    // see derive: \"Valid is Closed (via Brute-force)\"\n    set_add_many(VALID, nfd(VALID));\n    // decode emoji\n    // 20230719: emoji are now fully-expanded to avoid quirk logic \n    EMOJI_LIST = read_trie(r).map((v)=>Emoji.from(v)).sort(compare_arrays);\n    EMOJI_ROOT = new Map(); // this has approx 7K nodes (2+ per emoji)\n    for (let cps of EMOJI_LIST){\n        // 20230719: change to *slightly* stricter algorithm which disallows \n        // insertion of misplaced FE0F in emoji sequences (matching ENSIP-15)\n        // example: beautified [A B] (eg. flag emoji) \n        //  before: allow: [A FE0F B], error: [A FE0F FE0F B] \n        //   after: error: both\n        // note: this code now matches ENSNormalize.{cs,java} logic\n        let prev = [\n            EMOJI_ROOT\n        ];\n        for (let cp of cps){\n            let next = prev.map((node)=>{\n                let child = node.get(cp);\n                if (!child) {\n                    // should this be object? \n                    // (most have 1-2 items, few have many)\n                    // 20230719: no, v8 default map is 4?\n                    child = new Map();\n                    node.set(cp, child);\n                }\n                return child;\n            });\n            if (cp === FE0F) {\n                prev.push(...next); // less than 20 elements\n            } else {\n                prev = next;\n            }\n        }\n        for (let x of prev){\n            x.V = cps;\n        }\n    }\n}\n// if escaped: {HEX}\n//       else: \"x\" {HEX}\nfunction quoted_cp(cp) {\n    return (should_escape(cp) ? \"\" : `${bidi_qq(safe_str_from_cps([\n        cp\n    ]))} `) + quote_cp(cp);\n}\n// 20230211: some messages can be mixed-directional and result in spillover\n// use 200E after a quoted string to force the remainder of a string from \n// acquring the direction of the quote\n// https://www.w3.org/International/questions/qa-bidi-unicode-controls#exceptions\nfunction bidi_qq(s) {\n    return `\"${s}\"\\u200E`; // strong LTR\n}\nfunction check_label_extension(cps) {\n    if (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {\n        throw new Error(`invalid label extension: \"${str_from_cps(cps.slice(0, 4))}\"`); // this can only be ascii so cant be bidi\n    }\n}\nfunction check_leading_underscore(cps) {\n    const UNDERSCORE = 0x5F;\n    for(let i = cps.lastIndexOf(UNDERSCORE); i > 0;){\n        if (cps[--i] !== UNDERSCORE) {\n            throw new Error(\"underscore allowed only at start\");\n        }\n    }\n}\n// check that a fenced cp is not leading, trailing, or touching another fenced cp\nfunction check_fenced(cps) {\n    let cp = cps[0];\n    let prev = FENCED.get(cp);\n    if (prev) throw error_placement(`leading ${prev}`);\n    let n = cps.length;\n    let last = -1; // prevents trailing from throwing\n    for(let i = 1; i < n; i++){\n        cp = cps[i];\n        let match = FENCED.get(cp);\n        if (match) {\n            // since cps[0] isn't fenced, cps[1] cannot throw\n            if (last == i) throw error_placement(`${prev} + ${match}`);\n            last = i + 1;\n            prev = match;\n        }\n    }\n    if (last == n) throw error_placement(`trailing ${prev}`);\n}\n// create a safe to print string \n// invisibles are escaped\n// leading cm uses placeholder\n// if cps exceed max, middle truncate with ellipsis\n// quoter(cp) => string, eg. 3000 => \"{3000}\"\n// note: in html, you'd call this function then replace [<>&] with entities\nfunction safe_str_from_cps(cps, max = Infinity, quoter = quote_cp) {\n    //if (Number.isInteger(cps)) cps = [cps];\n    //if (!Array.isArray(cps)) throw new TypeError(`expected codepoints`);\n    let buf = [];\n    if (is_combining_mark(cps[0])) buf.push(\"‚óå\");\n    if (cps.length > max) {\n        max >>= 1;\n        cps = [\n            ...cps.slice(0, max),\n            0x2026,\n            ...cps.slice(-max)\n        ];\n    }\n    let prev = 0;\n    let n = cps.length;\n    for(let i = 0; i < n; i++){\n        let cp = cps[i];\n        if (should_escape(cp)) {\n            buf.push(str_from_cps(cps.slice(prev, i)));\n            buf.push(quoter(cp));\n            prev = i + 1;\n        }\n    }\n    buf.push(str_from_cps(cps.slice(prev, n)));\n    return buf.join(\"\");\n}\n// note: set(s) cannot be exposed because they can be modified\n// note: Object.freeze() doesn't work\nfunction is_combining_mark(cp, only_nsm) {\n    init();\n    return only_nsm ? NSM.has(cp) : CM.has(cp);\n}\nfunction should_escape(cp) {\n    init();\n    return ESCAPE.has(cp);\n}\n// return all supported emoji as fully-qualified emoji \n// ordered by length then lexicographic \nfunction ens_emoji() {\n    init();\n    return EMOJI_LIST.map((x)=>x.slice()); // emoji are exposed so copy\n}\nfunction ens_normalize_fragment(frag, decompose) {\n    init();\n    let nf = decompose ? nfd : nfc;\n    return frag.split(STOP_CH).map((label)=>str_from_cps(tokens_from_str(explode_cp(label), nf, filter_fe0f).flat())).join(STOP_CH);\n}\nfunction ens_normalize(name) {\n    return flatten(split(name, nfc, filter_fe0f));\n}\nfunction ens_beautify(name) {\n    let labels = split(name, nfc, (x)=>x); // emoji not exposed\n    for (let { type, output, error } of labels){\n        if (error) break; // flatten will throw\n        // replace leading/trailing hyphen\n        // 20230121: consider beautifing all or leading/trailing hyphen to unicode variant\n        // not exactly the same in every font, but very similar: \"-\" vs \"‚Äê\"\n        /*\r\n\t\tconst UNICODE_HYPHEN = 0x2010;\r\n\t\t// maybe this should replace all for visual consistancy?\r\n\t\t// `node tools/reg-count.js regex ^-\\{2,\\}` => 592\r\n\t\t//for (let i = 0; i < output.length; i++) if (output[i] == 0x2D) output[i] = 0x2010;\r\n\t\tif (output[0] == HYPHEN) output[0] = UNICODE_HYPHEN;\r\n\t\tlet end = output.length-1;\r\n\t\tif (output[end] == HYPHEN) output[end] = UNICODE_HYPHEN;\r\n\t\t*/ // 20230123: WHATWG URL uses \"CheckHyphens\" false\n        // https://url.spec.whatwg.org/#idna\n        // update ethereum symbol\n        // Œæ => Œû if not greek\n        if (type !== \"Greek\") array_replace(output, 0x3BE, 0x39E);\n    // 20221213: fixes bidi subdomain issue, but breaks invariant (200E is disallowed)\n    // could be fixed with special case for: 2D (.) + 200E (LTR)\n    // https://discuss.ens.domains/t/bidi-label-ordering-spoof/15824\n    //output.splice(0, 0, 0x200E);\n    }\n    return flatten(labels);\n}\nfunction ens_split(name, preserve_emoji) {\n    return split(name, nfc, preserve_emoji ? (x)=>x.slice() : filter_fe0f); // emoji are exposed so copy\n}\nfunction split(name, nf, ef) {\n    if (!name) return []; // 20230719: empty name allowance\n    init();\n    let offset = 0;\n    // https://unicode.org/reports/tr46/#Validity_Criteria\n    // 4.) \"The label must not contain a U+002E ( . ) FULL STOP.\"\n    return name.split(STOP_CH).map((label)=>{\n        let input = explode_cp(label);\n        let info = {\n            input,\n            offset\n        };\n        offset += input.length + 1; // + stop\n        try {\n            // 1.) \"The label must be in Unicode Normalization Form NFC\"\n            let tokens = info.tokens = tokens_from_str(input, nf, ef);\n            let token_count = tokens.length;\n            let type;\n            if (!token_count) {\n                //norm = [];\n                //type = 'None'; // use this instead of next match, \"ASCII\"\n                // 20230120: change to strict\n                // https://discuss.ens.domains/t/ens-name-normalization-2nd/14564/59\n                throw new Error(`empty label`);\n            }\n            let norm = info.output = tokens.flat();\n            check_leading_underscore(norm);\n            let emoji = info.emoji = token_count > 1 || tokens[0].is_emoji; // same as: tokens.some(x => x.is_emoji);\n            if (!emoji && norm.every((cp)=>cp < 0x80)) {\n                // 20230123: matches matches WHATWG, see note 3.3\n                check_label_extension(norm); // only needed for ascii\n                // cant have fenced\n                // cant have cm\n                // cant have wholes\n                // see derive: \"Fastpath ASCII\"\n                type = \"ASCII\";\n            } else {\n                let chars = tokens.flatMap((x)=>x.is_emoji ? [] : x); // all of the nfc tokens concat together\n                if (!chars.length) {\n                    type = \"Emoji\";\n                } else {\n                    // 5.) \"The label must not begin with a combining mark, that is: General_Category=Mark.\"\n                    if (CM.has(norm[0])) throw error_placement(\"leading combining mark\");\n                    for(let i = 1; i < token_count; i++){\n                        let cps = tokens[i];\n                        if (!cps.is_emoji && CM.has(cps[0])) {\n                            // bidi_qq() not needed since emoji is LTR and cps is a CM\n                            throw error_placement(`emoji + combining mark: \"${str_from_cps(tokens[i - 1])} + ${safe_str_from_cps([\n                                cps[0]\n                            ])}\"`);\n                        }\n                    }\n                    check_fenced(norm);\n                    let unique = Array_from(new Set(chars));\n                    let [g] = determine_group(unique); // take the first match\n                    // see derive: \"Matching Groups have Same CM Style\"\n                    // alternative: could form a hybrid type: Latin/Japanese/...\t\n                    check_group(g, chars); // need text in order\n                    check_whole(g, unique); // only need unique text (order would be required for multiple-char confusables)\n                    type = g.N;\n                // 20230121: consider exposing restricted flag\n                // it's simpler to just check for 'Restricted'\n                // or even better: type.endsWith(']')\n                //if (g.R) info.restricted = true;\n                }\n            }\n            info.type = type;\n        } catch (err) {\n            info.error = err; // use full error object\n        }\n        return info;\n    });\n}\nfunction check_whole(group, unique) {\n    let maker;\n    let shared = [];\n    for (let cp of unique){\n        let whole = WHOLE_MAP.get(cp);\n        if (whole === UNIQUE_PH) return; // unique, non-confusable\n        if (whole) {\n            let set = whole.M.get(cp); // groups which have a character that look-like this character\n            maker = maker ? maker.filter((g)=>set.has(g)) : Array_from(set);\n            if (!maker.length) return; // confusable intersection is empty\n        } else {\n            shared.push(cp);\n        }\n    }\n    if (maker) {\n        // we have 1+ confusable\n        // check if any of the remaining groups\n        // contain the shared characters too\n        for (let g of maker){\n            if (shared.every((cp)=>group_has_cp(g, cp))) {\n                throw new Error(`whole-script confusable: ${group.N}/${g.N}`);\n            }\n        }\n    }\n}\n// assumption: unique.size > 0\n// returns list of matching groups\nfunction determine_group(unique) {\n    let groups = GROUPS;\n    for (let cp of unique){\n        // note: we need to dodge CM that are whitelisted\n        // but that code isn't currently necessary\n        let gs = groups.filter((g)=>group_has_cp(g, cp));\n        if (!gs.length) {\n            if (!GROUPS.some((g)=>group_has_cp(g, cp))) {\n                // the character was composed of valid parts\n                // but it's NFC form is invalid\n                // 20230716: change to more exact statement, see: ENSNormalize.{cs,java}\n                // note: this doesn't have to be a composition\n                // 20230720: change to full check\n                throw error_disallowed(cp); // this should be rare\n            } else {\n                // there is no group that contains all these characters\n                // throw using the highest priority group that matched\n                // https://www.unicode.org/reports/tr39/#mixed_script_confusables\n                throw error_group_member(groups[0], cp);\n            }\n        }\n        groups = gs;\n        if (gs.length == 1) break; // there is only one group left\n    }\n    // there are at least 1 group(s) with all of these characters\n    return groups;\n}\n// throw on first error\nfunction flatten(split) {\n    return split.map(({ input, error, output })=>{\n        if (error) {\n            // don't print label again if just a single label\n            let msg = error.message;\n            // bidi_qq() only necessary if msg is digits\n            throw new Error(split.length == 1 ? msg : `Invalid label ${bidi_qq(safe_str_from_cps(input, 63))}: ${msg}`);\n        }\n        return str_from_cps(output);\n    }).join(STOP_CH);\n}\nfunction error_disallowed(cp) {\n    // TODO: add cp to error?\n    return new Error(`disallowed character: ${quoted_cp(cp)}`);\n}\nfunction error_group_member(g, cp) {\n    let quoted = quoted_cp(cp);\n    let gg = GROUPS.find((g)=>g.P.has(cp)); // only check primary\n    if (gg) {\n        quoted = `${gg.N} ${quoted}`;\n    }\n    return new Error(`illegal mixture: ${g.N} + ${quoted}`);\n}\nfunction error_placement(where) {\n    return new Error(`illegal placement: ${where}`);\n}\n// assumption: cps.length > 0\n// assumption: cps[0] isn't a CM\n// assumption: the previous character isn't an emoji\nfunction check_group(g, cps) {\n    for (let cp of cps){\n        if (!group_has_cp(g, cp)) {\n            // for whitelisted scripts, this will throw illegal mixture on invalid cm, eg. \"e{300}{300}\"\n            // at the moment, it's unnecessary to introduce an extra error type\n            // until there exists a whitelisted multi-character\n            //   eg. if (M < 0 && is_combining_mark(cp)) { ... }\n            // there are 3 cases:\n            //   1. illegal cm for wrong group => mixture error\n            //   2. illegal cm for same group => cm error\n            //       requires set of whitelist cm per group: \n            //        eg. new Set([...g.P, ...g.Q].flatMap(nfc).filter(cp => CM.has(cp)))\n            //   3. wrong group => mixture error\n            throw error_group_member(g, cp);\n        }\n    }\n    //if (M >= 0) { // we have a known fixed cm count\n    if (g.M) {\n        let decomposed = nfd(cps);\n        for(let i = 1, e = decomposed.length; i < e; i++){\n            // 20230210: bugfix: using cps instead of decomposed h/t Carbon225\n            /*\r\n\t\t\tif (CM.has(decomposed[i])) {\r\n\t\t\t\tlet j = i + 1;\r\n\t\t\t\twhile (j < e && CM.has(decomposed[j])) j++;\r\n\t\t\t\tif (j - i > M) {\r\n\t\t\t\t\tthrow new Error(`too many combining marks: ${g.N} ${bidi_qq(str_from_cps(decomposed.slice(i-1, j)))} (${j-i}/${M})`);\r\n\t\t\t\t}\r\n\t\t\t\ti = j;\r\n\t\t\t}\r\n\t\t\t*/ // 20230217: switch to NSM counting\n            // https://www.unicode.org/reports/tr39/#Optional_Detection\n            if (NSM.has(decomposed[i])) {\n                let j = i + 1;\n                for(let cp; j < e && NSM.has(cp = decomposed[j]); j++){\n                    // a. Forbid sequences of the same nonspacing mark.\n                    for(let k = i; k < j; k++){\n                        if (decomposed[k] == cp) {\n                            throw new Error(`duplicate non-spacing marks: ${quoted_cp(cp)}`);\n                        }\n                    }\n                }\n                // parse to end so we have full nsm count\n                // b. Forbid sequences of more than 4 nonspacing marks (gc=Mn or gc=Me).\n                if (j - i > NSM_MAX) {\n                    // note: this slice starts with a base char or spacing-mark cm\n                    throw new Error(`excessive non-spacing marks: ${bidi_qq(safe_str_from_cps(decomposed.slice(i - 1, j)))} (${j - i}/${NSM_MAX})`);\n                }\n                i = j;\n            }\n        }\n    }\n// *** this code currently isn't needed ***\n/*\r\n\tlet cm_whitelist = M instanceof Map;\r\n\tfor (let i = 0, e = cps.length; i < e; ) {\r\n\t\tlet cp = cps[i++];\r\n\t\tlet seqs = cm_whitelist && M.get(cp);\r\n\t\tif (seqs) { \r\n\t\t\t// list of codepoints that can follow\r\n\t\t\t// if this exists, this will always be 1+\r\n\t\t\tlet j = i;\r\n\t\t\twhile (j < e && CM.has(cps[j])) j++;\r\n\t\t\tlet cms = cps.slice(i, j);\r\n\t\t\tlet match = seqs.find(seq => !compare_arrays(seq, cms));\r\n\t\t\tif (!match) throw new Error(`disallowed combining mark sequence: \"${safe_str_from_cps([cp, ...cms])}\"`);\r\n\t\t\ti = j;\r\n\t\t} else if (!V.has(cp)) {\r\n\t\t\t// https://www.unicode.org/reports/tr39/#mixed_script_confusables\r\n\t\t\tlet quoted = quoted_cp(cp);\r\n\t\t\tfor (let cp of cps) {\r\n\t\t\t\tlet u = UNIQUE.get(cp);\r\n\t\t\t\tif (u && u !== g) {\r\n\t\t\t\t\t// if both scripts are restricted this error is confusing\r\n\t\t\t\t\t// because we don't differentiate RestrictedA from RestrictedB \r\n\t\t\t\t\tif (!u.R) quoted = `${quoted} is ${u.N}`;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthrow new Error(`disallowed ${g.N} character: ${quoted}`);\r\n\t\t\t//throw new Error(`disallowed character: ${quoted} (expected ${g.N})`);\r\n\t\t\t//throw new Error(`${g.N} does not allow: ${quoted}`);\r\n\t\t}\r\n\t}\r\n\tif (!cm_whitelist) {\r\n\t\tlet decomposed = nfd(cps);\r\n\t\tfor (let i = 1, e = decomposed.length; i < e; i++) { // we know it can't be cm leading\r\n\t\t\tif (CM.has(decomposed[i])) {\r\n\t\t\t\tlet j = i + 1;\r\n\t\t\t\twhile (j < e && CM.has(decomposed[j])) j++;\r\n\t\t\t\tif (j - i > M) {\r\n\t\t\t\t\tthrow new Error(`too many combining marks: \"${str_from_cps(decomposed.slice(i-1, j))}\" (${j-i}/${M})`);\r\n\t\t\t\t}\r\n\t\t\t\ti = j;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t*/ }\n// given a list of codepoints\n// returns a list of lists, where emoji are a fully-qualified (as Array subclass)\n// eg. explode_cp(\"abcüí©d\") => [[61, 62, 63], Emoji[1F4A9, FE0F], [64]]\n// 20230818: rename for 'process' name collision h/t Javarome\n// https://github.com/adraffy/ens-normalize.js/issues/23\nfunction tokens_from_str(input, nf, ef) {\n    let ret = [];\n    let chars = [];\n    input = input.slice().reverse(); // flip so we can pop\n    while(input.length){\n        let emoji = consume_emoji_reversed(input);\n        if (emoji) {\n            if (chars.length) {\n                ret.push(nf(chars));\n                chars = [];\n            }\n            ret.push(ef(emoji));\n        } else {\n            let cp = input.pop();\n            if (VALID.has(cp)) {\n                chars.push(cp);\n            } else {\n                let cps = MAPPED.get(cp);\n                if (cps) {\n                    chars.push(...cps); // less than 10 elements\n                } else if (!IGNORED.has(cp)) {\n                    // 20230912: unicode 15.1 changed the order of processing such that\n                    // disallowed parts are only rejected after NFC\n                    // https://unicode.org/reports/tr46/#Validity_Criteria\n                    // this doesn't impact normalization as of today\n                    // technically, this error can be removed as the group logic will apply similar logic\n                    // however the error type might be less clear\n                    throw error_disallowed(cp);\n                }\n            }\n        }\n    }\n    if (chars.length) {\n        ret.push(nf(chars));\n    }\n    return ret;\n}\nfunction filter_fe0f(cps) {\n    return cps.filter((cp)=>cp != FE0F);\n}\n// given array of codepoints\n// returns the longest valid emoji sequence (or undefined if no match)\n// *MUTATES* the supplied array\n// disallows interleaved ignored characters\n// fills (optional) eaten array with matched codepoints\nfunction consume_emoji_reversed(cps, eaten) {\n    let node = EMOJI_ROOT;\n    let emoji;\n    let pos = cps.length;\n    while(pos){\n        node = node.get(cps[--pos]);\n        if (!node) break;\n        let { V } = node;\n        if (V) {\n            emoji = V;\n            if (eaten) eaten.push(...cps.slice(pos).reverse()); // (optional) copy input, used for ens_tokenize()\n            cps.length = pos; // truncate\n        }\n    }\n    return emoji;\n}\n// ************************************************************\n// tokenizer \nconst TY_VALID = \"valid\";\nconst TY_MAPPED = \"mapped\";\nconst TY_IGNORED = \"ignored\";\nconst TY_DISALLOWED = \"disallowed\";\nconst TY_EMOJI = \"emoji\";\nconst TY_NFC = \"nfc\";\nconst TY_STOP = \"stop\";\nfunction ens_tokenize(name, { nf = true } = {}) {\n    init();\n    let input = explode_cp(name).reverse();\n    let eaten = [];\n    let tokens = [];\n    while(input.length){\n        let emoji = consume_emoji_reversed(input, eaten);\n        if (emoji) {\n            tokens.push({\n                type: TY_EMOJI,\n                emoji: emoji.slice(),\n                input: eaten,\n                cps: filter_fe0f(emoji)\n            });\n            eaten = []; // reset buffer\n        } else {\n            let cp = input.pop();\n            if (cp == STOP) {\n                tokens.push({\n                    type: TY_STOP,\n                    cp\n                });\n            } else if (VALID.has(cp)) {\n                tokens.push({\n                    type: TY_VALID,\n                    cps: [\n                        cp\n                    ]\n                });\n            } else if (IGNORED.has(cp)) {\n                tokens.push({\n                    type: TY_IGNORED,\n                    cp\n                });\n            } else {\n                let cps = MAPPED.get(cp);\n                if (cps) {\n                    tokens.push({\n                        type: TY_MAPPED,\n                        cp,\n                        cps: cps.slice()\n                    });\n                } else {\n                    tokens.push({\n                        type: TY_DISALLOWED,\n                        cp\n                    });\n                }\n            }\n        }\n    }\n    if (nf) {\n        for(let i = 0, start = -1; i < tokens.length; i++){\n            let token = tokens[i];\n            if (is_valid_or_mapped(token.type)) {\n                if (requires_check(token.cps)) {\n                    let end = i + 1;\n                    for(let pos = end; pos < tokens.length; pos++){\n                        let { type, cps } = tokens[pos];\n                        if (is_valid_or_mapped(type)) {\n                            if (!requires_check(cps)) break;\n                            end = pos + 1;\n                        } else if (type !== TY_IGNORED) {\n                            break;\n                        }\n                    }\n                    if (start < 0) start = i;\n                    let slice = tokens.slice(start, end);\n                    let cps0 = slice.flatMap((x)=>is_valid_or_mapped(x.type) ? x.cps : []); // strip junk tokens\n                    let cps = nfc(cps0);\n                    if (compare_arrays(cps, cps0)) {\n                        tokens.splice(start, end - start, {\n                            type: TY_NFC,\n                            input: cps0,\n                            cps,\n                            tokens0: collapse_valid_tokens(slice),\n                            tokens: ens_tokenize(str_from_cps(cps), {\n                                nf: false\n                            })\n                        });\n                        i = start;\n                    } else {\n                        i = end - 1; // skip to end of slice\n                    }\n                    start = -1; // reset\n                } else {\n                    start = i; // remember last\n                }\n            } else if (token.type !== TY_IGNORED) {\n                start = -1; // reset\n            }\n        }\n    }\n    return collapse_valid_tokens(tokens);\n}\nfunction is_valid_or_mapped(type) {\n    return type == TY_VALID || type == TY_MAPPED;\n}\nfunction requires_check(cps) {\n    return cps.some((cp)=>NFC_CHECK.has(cp));\n}\nfunction collapse_valid_tokens(tokens) {\n    for(let i = 0; i < tokens.length; i++){\n        if (tokens[i].type == TY_VALID) {\n            let j = i + 1;\n            while(j < tokens.length && tokens[j].type == TY_VALID)j++;\n            tokens.splice(i, j - i, {\n                type: TY_VALID,\n                cps: tokens.slice(i, j).flatMap((x)=>x.cps)\n            });\n        }\n    }\n    return tokens;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0BhZHJhZmZ5L2Vucy1ub3JtYWxpemUvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQSxtQ0FBbUM7QUFDbkMsc0RBQXNEO0FBQ3RELDRFQUE0RTtBQUM1RSw0REFBNEQ7QUFDNUQsNEVBQTRFO0FBQzVFLElBQUlBLGVBQWU7QUFDbkIsTUFBTUMsU0FBUyxJQUFJQyxJQUFJO0lBQUM7UUFBQztRQUFLO0tBQWE7SUFBQztRQUFDO1FBQUs7S0FBaUI7SUFBQztRQUFDO1FBQU07S0FBYTtDQUFDO0FBQ3pGLE1BQU1DLFVBQVU7QUFFaEIsU0FBU0Msa0JBQWtCQyxLQUFLO0lBQy9CLElBQUlDLE1BQU07SUFDVixTQUFTQztRQUFRLE9BQU8sS0FBTSxDQUFDRCxNQUFNLElBQUksSUFBS0QsS0FBSyxDQUFDQyxNQUFNO0lBQUU7SUFFNUQsNkJBQTZCO0lBQzdCLElBQUlFLGVBQWVEO0lBQ25CLElBQUlFLFFBQVE7SUFDWixJQUFJQyxNQUFNO1FBQUM7UUFBRztLQUFFLEVBQUUsK0JBQStCO0lBQ2pELElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJSCxjQUFjRyxJQUFLO1FBQ3RDRCxJQUFJRSxJQUFJLENBQUNILFNBQVNGO0lBQ25CO0lBRUEsNERBQTREO0lBQzVELElBQUlNLE9BQU9OO0lBQ1gsSUFBSU8sY0FBY1I7SUFDbEJBLE9BQU9PO0lBRVAsSUFBSUUsYUFBYTtJQUNqQixJQUFJQyxjQUFjO0lBQ2xCLFNBQVNDO1FBQ1IsSUFBSUYsY0FBYyxHQUFHO1lBQ3BCLHNDQUFzQztZQUN0QyxnQ0FBZ0M7WUFDaENDLGNBQWMsZUFBZ0IsSUFBS1gsS0FBSyxDQUFDQyxNQUFNO1lBQy9DUyxhQUFhO1FBQ2Q7UUFDQSxPQUFPLGVBQWdCLEVBQUVBLGFBQWM7SUFDeEM7SUFFQSxNQUFNRyxJQUFJO0lBQ1YsTUFBTUMsT0FBTyxLQUFHRDtJQUNoQixNQUFNRSxPQUFPRCxTQUFT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QkFDTCxPQUFPO3dCQUNObkIsSUFBSW9CLE1BQU0sR0FBRyx1QkFBdUI7b0JBQ3JDO29CQUNBRCxRQUFRLENBQUMsR0FBRyxRQUFRO2dCQUNyQixPQUFPO29CQUNOQSxRQUFRbkIsR0FBRyxnQkFBZ0I7Z0JBQzVCO1lBQ0QsT0FBTyxJQUFJaVIsTUFBTTNDLElBQUksS0FBS3FDLFlBQVk7Z0JBQ3JDeFAsUUFBUSxDQUFDLEdBQUcsUUFBUTtZQUNyQjtRQUNEO0lBQ0Q7SUFDQSxPQUFPb1Esc0JBQXNCekM7QUFDOUI7QUFFQSxTQUFTb0MsbUJBQW1CNUMsSUFBSTtJQUMvQixPQUFPQSxRQUFRbUMsWUFBWW5DLFFBQVFvQztBQUNwQztBQUVBLFNBQVNTLGVBQWV4TSxHQUFHO0lBQzFCLE9BQU9BLElBQUlvSCxJQUFJLENBQUNqSCxDQUFBQSxLQUFNcUYsVUFBVTNDLEdBQUcsQ0FBQzFDO0FBQ3JDO0FBRUEsU0FBU3lNLHNCQUFzQnpDLE1BQU07SUFDcEMsSUFBSyxJQUFJOU8sSUFBSSxHQUFHQSxJQUFJOE8sT0FBT3pNLE1BQU0sRUFBRXJDLElBQUs7UUFDdkMsSUFBSThPLE1BQU0sQ0FBQzlPLEVBQUUsQ0FBQ3NPLElBQUksSUFBSW1DLFVBQVU7WUFDL0IsSUFBSS9NLElBQUkxRCxJQUFJO1lBQ1osTUFBTzBELElBQUlvTCxPQUFPek0sTUFBTSxJQUFJeU0sTUFBTSxDQUFDcEwsRUFBRSxDQUFDNEssSUFBSSxJQUFJbUMsU0FBVS9NO1lBQ3hEb0wsT0FBT3VDLE1BQU0sQ0FBQ3JSLEdBQUcwRCxJQUFJMUQsR0FBRztnQkFBQ3NPLE1BQU1tQztnQkFBVTlMLEtBQUttSyxPQUFPM0ssS0FBSyxDQUFDbkUsR0FBRzBELEdBQUdJLE9BQU8sQ0FBQ3BDLENBQUFBLElBQUtBLEVBQUVpRCxHQUFHO1lBQUM7UUFDckY7SUFDRDtJQUNBLE9BQU9tSztBQUNSO0FBRWtLIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xhdy13b3Jrcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvQGFkcmFmZnkvZW5zLW5vcm1hbGl6ZS9kaXN0L2luZGV4Lm1qcz82Yzg1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGNyZWF0ZWQgMjAyNS0wOS0xNFQxNzo1NjoyNC4wOTlaXG4vLyBjb21wcmVzc2VkIGJhc2U2NC1lbmNvZGVkIGJsb2IgZm9yIGluY2x1ZGUtZW5zIGRhdGFcbi8vIHNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL2FkcmFmZnkvZW5zLW5vcm1hbGl6ZS5qcy9ibG9iL21haW4vc3JjL21ha2UuanNcbi8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2FkcmFmZnkvZW5zLW5vcm1hbGl6ZS5qcyNzZWN1cml0eVxuLy8gU0hBLTI1NjogOTJjYmYzYTFhZjNjM2MwYTkxYWVlMGRjNTQyMDcyNzc1ZjRlYmJiYzUyNmE4NDE4OWExMmRhMmQ1NmY1YWNjZFxudmFyIENPTVBSRVNTRUQkMSA9ICdBRWtWTVFudkRWMEIwd0tXQVFZQlFnRHBBVFFBb1FEY0FJVUFwd0JzQU9NQWNBQ1RBRVVBaWdCUkFIa0FQZ0EvQUN3QU53QW9BR0lBSGdBdkFDc0FKUUFYQUM4QUhBQWhBQ0lBTHdBVkFDc0FFUUFpQUFzQUd3QVJBQmdBRndBN0FDb0FLd0FzQURRQUZnQXRBQklBSEFBaEFBNEFIUUFkQUJVQUZnQVpBQTBBRGdBWEFCQUFHUUFVQUJJRXRBWVFBU0lVT2pmREJkTUFzUUN1UHdGbkFLVUJBMTBqQUs1L0x5OHZMd0UvcHdVSjYvMEhQd2JrTVFWWEJWZ0FQU3M1QVBhMkVRYkl3UXVVQ2tFRHlKNHpBc1VLTHdLT29RS0cyRCtPYjRrQ3hjc0NnL0lCSDk4SkFQS3RBVUVDTFkwS1A0OEE0d0RpQ2hVQUY5UzV5QXdMUFowRUczY0EvUUk1R0wwUDZ3a0dLZWtGQklGbkRSc0hMUUNyQUdtUjc2V2Nmd0JiQnBNakJ1a0FHd0E3REpNQVd4VmJxZnQ3dXljTTJ5RFBDTHNwQTdFVU93RDNMV3VqQUtGOUdBQVhCQ1hYRmdFZEFMa1p6UVQ2Q1NCTU53bVhDWWdlRzFaWlRPT0RRZ0FUQUF3QUZRQU9hMVFBSVFBT0FFZnVGZGc5OHpsWXlwWG1MZ29RSFY5TldEM3NBQk1BREFBVkFBNXJJRnhBbHdERDZ3QWJBRGtNeFFBYkZWdXArM0VCMjI0Y0hRVmJCZUlDMEo4Q3hMQUtUQnlrWlJSekdtMU05UUM3RFdjQzRRQUxMVFNKRjhtUkFvRjdBUk1iQUwwTlp3TGhBQXN0QVVoUUpaRk1DZ010K3dVeUNkZHBGNjBCMTBNQVNTc1Nkd0l4RmlFQzZ5ZTVOMnNBT2VFQjlTVUF4dzdMdFFFYlk0RUFzUVVBQlFDSzAwa0ZHOE1mQnhjQXFDZlJBYUVyTFFPYkFHY0JDaGsrN1RkMEJCZ1hBS29CeHdJaEFOTXJFbk02ODFDd0JaQTZkeWMxU0FYNkp3VlpCVml2dUFWcE8xMUNFanBZUVpkN2syWmZvZmdMRXdQRkJ5WHhkeU1FbzBzQ1UxTUNkUnVySndHUG82VTFXd05GRndTRFlRa0EwUWFyUHk4akJ5a0NPVjBBYXdGaEgzRUFneDBaQUpVQlNiY0FKMmtYQWEvRkF6Y3RJVU5UQVc5WkJtVUNaUUR4U1JjREtRRUZBRWxCQUtzQVhRQnpBQ3UxQmdmejd4bU5md0FKSVFBcEFMTWJSd0hSQWRzSEN6R1hlSUhvQUFvQUVRQTBBRDBBT0ROM2VkUEFFRjhRWEFGTkNVeHNPaFVMQXF3UHBndmxFUlVNMFNyTDA5Z0FOS2tINndOVEIrc0RVd05UQitzSDZ3TlRCK3NEVXdOVEExTURVeHdLOEJyVHdCQmZEMGdFYlFXT0JZc0UxZ2lESmtrUmdRY29DTkpVRFhRZUhFY0RSUUQ4SXlWSkhEdVRNd3NsUWt3TVRRTUgvRFpDYktkOU9BTkhNYXRVOVpDaUE4c3lUemxzQVI1eEVxQUFLZzl6SERXMVRuNTZSM0dnQ2t0UHJyVi9TV0pPWndLK09xZy8rQW9oQ1pOdnUzZE9CajBRRnllaEVQTU1Md0d4QVRjTjZVdlVCTzBHTndURkgza1pGUS9KbFpnSW9TM1pET2ttM3k2ZGdGWWo4U3AvQmVsTDhEelpDMGxSWkE5VkMyRUozenBmZ1VvREhRRUpJb2NLMlEwMUNHa1E3d3JGWnczaEVVRUhOUVBSU1pZQW9RYjlDdzBkTVJXeEpneGlxQXNGT1hNRzl4cnlDNHNtcXhNbGV2Z0Z6eG9kQmtrQkpScjdBTXN1NDRXc1dpMWNHRTliQmY4TElTUERGS1JRSEEwaFFMTjRSQm9YQnhFbHBRS05RMnhLZzFFeUhvOGg4anc1RFdJdUQxRjRCL0U4QVJsTEMzMDhta2FuUlFvUnpqNkpQVVFpUlV3b0JERjdMQ3NuaHduTEQ0RU10WHh1QVZVSkhRbXRERzBUTFJFVE44RUlOUWNWS1pjZ0p4RUlIVWFSWUpZRTg1c0Q3eFBOQXdjRk93azlCdzhEc1J3cEV5b1ZKUVVKZ1NEVEF1ODIwUzZ2QW90V2ZBRVRCY2NQSVIvYkVFeEgzQTdsQ0pjQ1lRTi9KZWNBS1JVZEFCTWlsd2cvWHdCYmo5UlRBUzdIQ01OcWFDTndBMk1VNDEwUmJ3ZU5EbE1Ib3h3dkZic2MzWERFWGdlR0JDaWZxd2xYQVhFSmxRRmJCTjhJQlRWWGpKd2dQV2RQaTFRWWx5QmRRVHRkK0FJdERHRVZtMFM1aDNRQ2h3OW5FaGNCTVFGdkJ6VU0vUUp6RWVrUlp4Q1JDT2VHQURXeE0vUTZJUVJMSVg4Z0RRb2pBMHRzeWdzakp2VU05R1VCbnhKZUF3ZzBPWGZxWjZkZ3NpQVgrUWNWTXNGQlhDSHRDNDVQeVF5WUdyMFlQbFFxR2VBSHV3UHZHdThuNWtGVEJmc0Rudzg2U1RQcUJMa0xaUWlIQ1RzQVJRNmZFd2ZUR0dZS2JZek1BUzJIQWJPVkExT05md0pyaXdZekJ3Y0FZd2VEQlhYaEFCa0Nvd2lmQUFFQXl3TlRBRFVDcVFlWkFCVUFnVDBCT1FNakt3RWQ0UUtMQTQ4SUxjY0JrU3NCN3lVRUY3OE1FUUR6TTI1R0FzT3RBb0JtWnA0RjJWUUNpZ0pGTVFGSklRUUJTa05OQTZ0dDNRRFhBRWNHRDl0REFSR25Sc2NXM3o4QjIyc25BTU1BOXdBQk1RY0JQUUhKQWU5cEFMTUJXd3N0Q1o2dnNRRko1U1VBZndBUlp3SFRBb1VBMlFBeEFIdnRBVThBU1FWVjlRWFBBa3RGQVEwdEZDZFRYUUczQXhzQkx3RUpBSFVHeDRtaHhRTWJCR2tIendJUUZ4WGRBdThxQjdFREl0c1R5VUxCQXIzYVVRQXlFZ28wQ3JVS3RCOWY4MXd2QWkxdVBVd0FDaCtrUHNNL1NnVk5PMDg3VkR0UE8xUTdUenRVTzA4N1ZEdFBPMVFEazd2ZXU5NEthRjlCWWVjTW9nM1FSTVE2UlJQWFlFMWdMaFBFTGJNVXZSWEtKVklaT1JxNEp3RWw0RlVGRHdBdHoyWXNDQ2cwY1JlNEFEc3BaSU05WTRJZUxBcEhIT05UalZUMExSY0FyVXVlTTZzTnFCc1JSRHdGUTNYcFlpWVdDZ29lQW1SOUFtSStWMG1yVnpjY0FxSHpBbWlVQW1ZRkFwK0FPQmNIQW1ZM0FtWWlCR29FZXdOL0R3TitqamtDT1hNVE9YNDZIeDhDYkJrQ01qSTRCZ0p0d3dKdHF1dUdMMk5CSndGakFOb0EzUUJHQVFlVURJa0ErZ2UrQUFteEFuY3JBbmFlT3dKNVJ6OENlTFlaV05kRnFrYlRBbnc3QW5yRUFuMEZBbnpzQlZVRkhFZjhTSGxmSUFBbkVVbFVTbGNSRTBySUF0RDlBdERJU3lNRGlFc0RoK0pFd1pFdUF2S2RYUDhEQTZwTHlrd3BJY3ROU0UyckFvczdBb3JVdlJjREdUOWpBYk1DampNQ2psZzhrMzBDanRVQ2psaDBVYkJUTVFaUzBGU0JBcFAzQXBNSUFPVUFHRlVhVmF0VnpBSXNGeW1SZ2pMZGVHSkZOelVDbDVzQzc2NVlIYVFBVlNFQ2xvc0NsbmlZQUtWWnFGb0ZmVWtBTndLV3NRS1dTbHhBWE0wQ21jY0NtV0JjeGwwREZRS2Nsem0rT3BrQ25CSUNuNWNDbnJTR0FCa0xMU1lMQXAzdEFwNk9BTEU1WVRCaDZ3S2V6d0tnYWdHbEFwNmJHd0tlU3FGanhHUWpJU2NDSjZzQ0pub0NvUGNDb0VnQ290a0NvY0FDcGlzQ3Bjb0NwL3NBZVFLbjdtaDRhSzMvUldvWWFzMENyTjhDcktvQ3JXTUNyUDRDVnhrQ1ZkZ0NzZDNUQXg5S2JKTUNzcmtKQXJMa0UyemNiVjl0UkZzREpja0N0bGczTzI2TUF5bEJBcmhhQXJsREVRSzVKbk53TW5EZEFyMFZBcnZXY0pJRE1nMEN2b1J4L2dNemJRSytGbk1lYzBzQ3c4Y0N3d0J6Zm5SSE1VRjAzQU04b3dNOGxnTTl1d0xGZUFMR1F3TEdESVVDeUdWTkFzaEFBc2xMQXNrcUFtU1pBdDNPZUhWZGVLcDVJVXZNQXhpZlp2NENZZkFaNzVVZ2V3ZGVqbDYzRFFMUFp3TFBhQ3RIVDg3dkQ1c0F3cWtDejI4QkplWURUZzUrUndFQzNDTUMyNFlDMGtzRFVsZ0RVMXNBL1FOVmlJQ0ZPOGNTNlZ4QmdoaUN6NExLZzRrQzJzTUMyZHFFRElSRnB6Z0RocUVBS3dOa0NvWnRWZlVBVVFMZllRTGV0Rzl6QXVJcjdSQUI4eXdqQWZTWEFmTE9nd0xyN3dMcGJIVUM2dlVDNnVBQTlVTUJ0UUx1aFFMcm1KYW1sdjhDN2pzRGhkeVlkWERjY1owQzh2OEFaUU9PRXBtUEF2Y1BBNUZxQTVLREF2ZVVBdm5WQXZoaW1oaWFwN2N6bXhvRG5YOEMvdllCRndBMW54aWZyd01GaVFPbVpnT20xUUROd1FNR1pxR0VvZ0VGQXd4RkFRc0JHd2RwQmwyMVl3RUF0d1JudXcySEhxOEpBQk54TlFBZkF5OFNTUU9GZXdGZkl4MEFqT3NBSFFEbW53T2JqUWl6Qmh1ZndRQ25CUkc3NlIwOVBoWjRCV2czUGtBclFpRkN0Rjl4RVYrOEFKYkZCVElBa0V3Wm03azdKbUF5RWJyUERpOFl4aGlKeWZZRlZ3VllCVmNGV0FWakJWZ0ZWd1ZZQlZjRldBVlhCVmdGVndWWVJoVUkxNFZuQWdJQ0NtUmU2U3NFeVFPeEJpKzd1d0M3QktlN0FPZEFLUmF5QlVZK2FUNXdRajlDdGw5MU4xL29BRmdSTTZzQWpQN01hOHY4cHVkR2VqMG1Jd1FyRmljMk5YNXQzMnJCOFJuQ0xHa0JhOWR1TUJjRlh3VnF5Y0hKdUFqUFNWc0FBQUFLZkY1OWk3NEFNeitCQUFNVzBRYmxyU01GQUl6REN3TUJEUURsWlIwOUpCOUtRckZDdkVFNEkxOG5ZRFluT0NNSndUMEtSRDlEUG5nK2dUNXdQbkVDaVVLOFNVSTdYOHRPVDJwTkNpeHJWQzlxQzI0ZlgrQXpPaHNKWjVzS1lpTXJQQjBtUXF0Q3ZDdk1BY3Y4WDhrT0h5NEpDQWtpZnAzZmFqb3RTaGZKcThtc0NXWEJ5OHdLWUVGZkQrVVFveEVBazQwZFJVSWxHNmx0T2M0NENqTS9RejV3UWo4Y0J3b2RURWRzV3l3dFd1RzhFZ3A5N1IwclFqOGNYUWhLQ1E0elZFTkNOd1E3UTV3c0NvRWJMVUkvRy9VSVV5SWpHREF4QUFXUFlmQmVDbkZreVdBTFlDMGpia05nR1RrQ0d4NWdzd1lDYXhCbFRtQk5FUUZrNTJBVllKVmdmV0N6WUV0Z2tXZ1dGd2ExRHR4VnFieGFDME1XcXdHN0s4M0JBaDhWQUJ3REhnRjVBbXd2TUpWU2dBR0tDcmhIR2dEa0kzU09Dc29OcGszcUFac0NoNXhQQlVCZkFQZjNCd0EwRmxjTUM2VU1KQis2cjBlQWdRdzBBQlVUbnl1Q0NIb0MwZ3RMWlJFYkFOaE9CblVFQ2g1YUFERUF0cml0QUpRbkN4WnZxeVE0bnhrQld3R0dDZndEMmUwUEJxb0dTZ2E1QUIzTFZhbGFDYnRoRTRrTExUOE91d0c3QVNJQ1Ixb29LQ2dnSGg4aExCSW1CaUVNalFCVUFtNVhrRW1WQVc0ZkQzRkhBZE4xRDg1UklCbXBzRTNxQnhFRlRGOEE5L2NIQUhvR0pHd0tLd3VsT0RBdHg2OVdEUXNBWDd3TEFHTkFsUWg2QU9wTjd5SWJ2d0F4QUxhNHJRQ1VKeTA3RHM0Q2tCaDdVTHRZeUhSeWpzT2xtdy9aRlVrYjdBRXBFRndTQmgvbEFjY0pPaENUQlE4ckREWUxBQkVBcytBaUFRSUFwQURoQUppQ0NySnJPUzhBRkFCYkc4WXViSFlxRGNFUUFqc2tITlBoSEI0TEczMENld1RCQ3FyeGJBQW5MUTZtTHM2aEhBZTdDUUFRT2crN0drY2N6YUYzSGdFOUtsOGNMczRSR1FCOXE5b2NBdXVnQ0FIQ0FVTHo1QjlsQWI0SnR3ejZDRHdLUGdBRndBczlBa3NOdXdpOERUd0t2QWs4RHJzRm1BRWJhd291enFFcUQ0c2E0UUhEQVJFV093Q2dDenNMdXhDN0JCaXFlOXdBTzJzTVBBQUNwZ204QlJ2UTlRVUJ2Z0g2YnNvR2V3RzdEMDBSRXJ3QkFRRHFBUUFBZEJWYkJoYkxGUHh2RjdzWU94amJMN1p0dmdOSXFMc0FCN3NBTHJzQzZ3NVdBQXE3QkFBZXV3SlZJQ3AvRlR3VnV3RytKK1FBc2xvQnZTamdvN3ZJQUFGYkFBRzdBQUpiQUFMakFBZzdBQTY3QWdBYnU2VmJEci9FQVBRQWFQdW9Pd01CdTVVblN3RG4zUm03Q0JwN0NLRUZDdjl3QU4rN3A3c2F1Nk9MZVhJRys2bWJnd0FTdXdZYkN3RzhBQUNHQUcyN0JnQUx1NmM3QVJvN3VnaWhuTW9CdXd2dEI4Q3BPd0RoZXdHL0FBRGxBQlc3QUFiN0FBbTdBR21MQUJxN0dMdU9hUlg3QUE1ckFDNUxIZ0FHdXdBWHV3Z2hBQTFLQWNJQXQ2OG1BY0FBQUxRQURwc0FIQnNCdi83aENxRUFCY1lMRlJYYkFBZWJBRUs3QVFJQWFic0FDM3NBSGJzQUNMc0pvUUFGeWdCdW54blZBSkVJSVFBRnlnQUJPd0FIMndBZG13Z2hBQWFhQUFsN0FCc3JBRzBiQU9hN2dBQUlXd0FVdXdraEFBYktBT09MQUFrN0M2RU94UHRmQUFjN0FHNmNRRWdBUndBRE93QUpyUU0zQUFjYkFCbDdBYnYvQWFiN0FBb2JBQW83QUFuN3Arc0d1d0FKR3dBREN3QVFPd0FJUEFBVU93QVJhd0FQaXdBTjZ3QU51d0FaQ3dZV0d3QVZPd0J1bXhtN0FMb2JMZ0FUT3dNQWFTc0tBT0ZMQUFJN0FBUlNBQmQ3QlJzQUJ0QUFHTHNBQy9zQVg3c0FhL3NBNUlzQnV3QVhkZ0c4QUFGeUM2RUFCVW9BYlhZQUIvc0E1WHNBSEdzZUFYc29VZ0E1UlFEK0J3ME1jZ0FvS25BQnBBVUlYZ0c4WGlNTUNRZHZTMnhmS29rZlBCUmlMVFlEb1FxMEFkZ0FGZ0xSQTI0QmRuSkhVaFFoQTA4Q0ZUNEJMQVlEYzBhOGUxSjZRQUFwQURFQit3QlRDdHNBZTVBc0FTc0FkdVVORVRKR0FVb0FWd1VBQVZBQkI0ck1BSGc3QkNDbEFGb0ExaFVBbFdnM0g0c0F6V3V4QU0vVUZnakNkWE1iR0ZZZENkRUJpSkNySWxOVFRVZ1NQTUtKK1FCL0hEZEFLU3ZnRVpkUEFISUJLU3d3S1VJWkR3TXdWUVQzeGU0QVMyWGNBR29DY1FJL0VYbzZ4M2d1TmRVR0JRQVFHeDBLQ0F3cUJCOGRLVTVUVGdpNXVnQUtFczBBSmdBQkdnQ0dBSWtBampVQTdnQzBBT0FBblR3QXV3Q3JBS1lBb1FEeUFKOEEwd0NjQU9zQkRBRUhBTUFBZVFCYUFNc0F6UUVIQU5jQTZ3Q0lBS0lCTlFEakFOZ0ExUU1CQnlvejFOVFUxTGJBM00zUXprTXlGd0ZOQVZjdlJ3RlZBV1FCWXdGV0FVZExRMFZvRFFGT0ZRY0lBekkyREFjQUlnMGtKaWtzT0RvNlBUMDlQajhPUUI1UlVWRlJVMU5TVXlsVVZWZFdWaHhkWVdGZ1ltRWpabWh3YjNKeWNuSnljblIwZEhSMGRIUjBkSFIwZG5aM2RuVmJBRURzQUVVQWxnQjBBQzRBWXZJQWlnQlRBRk1BTXdKejZRQ0gvL0x5QUdBQWord0Ftd0JMQUY0QVlQbjVxZ0NCQUlFQVpRQlNBSzBBSGdDeUFIOENQQUkvQVBnQTR3RDZBUG9BNUFEN0FPVUE1UURrQU9JQUtRSjNBVTBCUEFFNkFWQUJPZ0U2QVRvQk5RRTBBVFFCTkFFWUFWUVBBQ3NJQUFCTkZ3b1dBeFVXRGdDS0FKSUFvZ0JMQUdRWUFpMEFjQUJwQUpFREVnTWtLZ01lUVQ1SEtRQ0xBa3NBd3dKVEFxQUF1Z0tTQXBJQ2tnS1NBcElDa2dLSEFwSUNrZ0tTQXBJQ2tnS1NBcEVDa1FLVUFwd0Nrd0tTQXBJQ2tBS1FBcEFDa0FLT0FwRUNjUUhRQXBNQ213S1NBcElDa1JaNUN3RDZCUU9uQWwwQ05oY0JVQkExQXQ0UkNpc1RBVW8zRTAyUkFYZWtQQUZsV1FEL0F6MUhBUUFBa3lrZUdJOXFBQ2xnQUdrQUxnQ0pBNVRNaS9DdWhGb0Z1aXNPd2hFQm5kVjBLZ3NFSXpGc0FUTmFiQUd5QU41K2dIOStnSDZCZ29KK2c0YUVmb1dJaG9DSGdvaUNpWDZLZm90K2pJcU5mbzUrajRLUWZwRitrbjZUZnBTRGxZaVdncGQrMmdMYWJPRUMyR3dBZ213a2JLQUFnMnhzQkVrRVJnUklCRXNFU1FSUEJFd0VSd1JOQkU4RVRnUktCRXdFVHdDV1ptd0Fvd09JYkFDMFpnRUZiQURKVVd4c0FNOXNBZ3hzQVBaYWJBRDJBUmtBOWdEMEFQUUE5UUQwQTMxZWJOU0VJMlhBQVBZQTlBRDBBUFVBOUJ4c2JBQ0pXbXdBOWdDSkFSa0E5Z0NKQUw0QTZBQUlBUFlBaVFOOVhtelVoQ05sd0J4c0FQZGFiQUVaQVBZQTlnRDBBUFFBOVFEMEFQY0E5QUQwQVBVQTlBTjlYbXpVaENObHdCeHNiQUNKV213QkdRRDJBSWtBOWdDSkF1MEE5Z0NKQUw0Q053RDNBSWtEZlY1czFJUWpaY0FjYkFKREFUWnNBa29CT1d3Q1M4RnNiQUpYYkd3RG53THRBNThEbndPZ0E2QURvQU9nMUlRalpjQUdBMzFlYkJ4c2JBQ0pXbXdCR1FPZkFJa0Rud0NKQXUwRG53Q0pBTDRDTndPZkFJblVoQ05sd0FZRGZWNXNIR3dFUG13QWlRUS9BSWtHalRGdElERnMxbTRES0d3RHJBSnNiQUJWV3Y0Vk1nSnNiQUNKQW13QVZBRUF1bDVzQW14ZWJHd0FpVjVzQW14ZWJEM1lBRWxzMWdKc2JFYkN4eFAveDVCQXBBMEtZRkE4OUFzalR4OTdFSG1KUVB5b2NJdEMySm5ORlJDRW5GVTZTRlREb0kwUHhlUk5Sb05SV2twelZuV1c4cFRhZ2tObWdmK2pHdXBxWjNldTUwTEFGbmMrT3pmSndkdWIxQWRwT3k3NlZuaWpXTlIvQ01FZXZpa1FrRnlRdUx1UGFqeFdpOWNocU9vTUo3cXBDTjRzeDNMSkc0TXl1OGtENjh3QzYraUF3dCtwVTFKRWVZMTNycENWa1hTWmZpblZLbjR4WnB4c0kzTHA4YkpMcko5dWprcklhbE1SQkFjdi9HU0tFdG93emNFbjVYbUp3MkJhZ0I4VjJVV0pvSkhaMTRTWGhNN3AwWGVHRk91dzZtbHZ5cTk5V1lwNVh4ck82cnU5bm40UkhjT2tKN2h4NVVxV3RtYW43eVZNTHpZWFFlZlFSVWRJWTcwUllRRTgrYUF6Q05TR1FrWGlIZm5IWVJNaSt4Y3pLRGRaTGszQVYxZ3p4a2tTSExqQnd1cThzaElKKy9SQWJxanFRYnVnRmhlMHJxa2x1NDMyRUVSa001azl5MURYemRzNDZvTHFLQXg2T2hQVDJXaXFFZmhhSVRuN09GOVk2OTRBbUttVXZicFdwMHhKcURhZjNqZU5KWG5LNk5wbkdjRk9tYmNsYkFSQys1KzVVNTJ1Znc1YjBIaCsyTHJyTmltdlplNGVZbUFwUnNabkpFMzEwU3FCKzF4QjZyU0pmblYxZjJEMGF3QjE4T2Mwc1hBRnFJbGdIZ1dpYVpHZHZQNUNKVVNzQ1RDUVVDMzM1K2lTa3dQbExKSjVsd2pUU245THcyMk5iSzFUdTh3K2JVcEh0RFJEUGhvN0d1bjhhdzJKenU5aStOME90L2tQTWJMQWIvclVRODJrZnBrODVxTERrZnhMbDM5UVBEbmdvNzJHWWgvWGlnYnBjbTFwQTIzRDJ5d3QzRDhHZ01PYW8wNDB3RHFrSHhPRXgwT2hDK1ptSGlJZGpLN3lSYmZKRDJvdVpiQWVkaEQzcDdzOFdEbUNKZk5mb3JnRFlQR0FYU0kwOGZUalBaNUIzN2xjNVZYR3pjMXZKbWliRHdCTlZ6WHVhVXpnN041SDRCeHFqaEora3o5SExVSnlzN2JwQkRZQVB2YnV0MTNBd0pDV2QwNTl0UzhZVFlnQzhId3JrZXdCZmExTFNTcG1Ncjl1UjJFZWtUaUFNSCtNeDRBR3pnYnF1Y2N3QkRsTG1SaGdYTC9ZaUxQQ0ViNmQyazVxSjZvODAwcWRkQUJrcHF0N05HK3NjMnV2SFp3WnM1N1cxQUhURk0xS2tNU2hhc0FEQWgyRnZ6YnpKT3pWRE1TM1psVDJCU0ZLZG5rWkZCNkp5cUpiaG02WEFOaXM5VHJ0ekpkbFBWcCtybDh2M25Ja2U2Sm91N20yVEt1NTNWb3VudXBna3oyTHpyUVBoaGF0TElHN3JmRi9nVUtXcDE1WDNMS3QrWnZ1Q0RTcVBVaWdGOXlKbnRpbUMxSEpSN1lqL2RVckxBWFdyVCsxdG53UEpKTEdLQWxRNVZlTkRXUktDVHQydnozckp1bzQrZ0l0NzUvTWtmbC9nU1pibFo5ci9TRWVlb3NaWG5lbGkveE5oMVdWQ3ZrUnQyUm55eWp0TWtNcWh6WGgxUFZPQ2JJTHF2MHI3ckdZbTBDSEl5S2RoSEw5MGNsOUUxSTZlRXRRVEN0NlJYajhNMEhIckhDSExWUnBOTTZXSWJUNUJDTUdWbkwwbzU4OTVxU1JiQ0p6KzVJOFBHTWhBTi9Ycmo0QmdJZGxLcWxIdEJIcVRKd21LMTY5dG9aMklXeE56ckFiSUc3emg4NVEvTEcyQTR5QmNhQmVsNTJ6ZHVub2tCMGx2M0E3a1huVEk3TTZabmZaN253dWo1bGtHaHFTcFcrdzVDSS9GbVJscGxCRWJuWnkxWnhTM0RMOHJmMVlXaE81WGl2V1pCU1JoMWdGc2pqeWozcVJHMWNtLzZvcnM3V3NFaWY2V1J4bnMxTUtEWmE2S3JiZk1RL3N3SWIrMm5iMHRxeEhlaWk2RmNnVmVBakUvWHdhYzFvd3gwNGRKS0c4UjVZUWdITm5FZkhmMHFiOFdPblUwZVFTamF6cStJSzdjU3VDcVl6UEVVQi94K1FnR1pxTTNkQm9Zdk52WlZPSERrYmdkaWxXZGFncU81Ymt5YlhmTHB5TVB1R3E4bXZBQUVaR2JSNlJ3WEdsVzlFck9XVGZuamZ4NmRYRkpxQmowT0JTR0Z6NGxXUWFzTk9tVkplTjRTRldTTGZPR0IvN2VoVjVZdW9OTlJPSFpFRzlFbFZ1TW5xYkRNTXVEbGVPdC9jTi9nc1d4R3cxMjhtd1U4L0h4a09LcWRUWm5JN2RIa2E2N1dDVGYvRm1CcnhwTkNhS0oxR3hCVENTUzdNTmZoTmo4UzRHdG90ZzZaM0FNOWNBZVZST25wcFVNYWlWNWpqdWRMbk5xb1ZyS08xL0ZpakxsQWM3NGt4eWR4S1gxUlF1TXFIUjYzZWVjWXI1bzZNSitCNzhWc0xsQ3JwZWxXaDZHT3JDT0JJb1FtSWNkcEpMMXB3RTJ6elpxQmtlY0dUZEs4S01PQjZyMWVOUlVSeXJ6Nk04OTlUWmFvUy92Tk94SGYrNWdPUlUrT3lZSWNJVzZkaVAyNUdIRjZ1OFROanVML0dKekNuTExYZDAxS3JzalJhNTF2NCtPL1ZJQVdYRVNKeGZ4V2p2NjI4SitjV1VRcG9EK1l5dHpzM2pTTVJKMjMvWFQrdlVkdFVNTERRcTF2bklvZWcvR2pXaDg4TVQ2azlkUnFEYVErdm9kaWxGZ3ZqdU53NXBKcElkOW1md3lZZUxDR2IzQm1IWGRmUWZoZlBSUWF1cGUvZjhURzRCazNlREtsWUJhRUsza1pZTk4yU2R4ejQ3bS92WUJ4dklPS3RucXBsQjFwZWJ6dVhtQXIvTXV6UUNrbktlNjUzZHphV1FRN01VaFdZV3Z6SVp3TGUxdjByWHhJbUxheitBa0F1K3NZaWtob3VORjNFVzZ3NGNyWjZNdVVpRGJJQXg4WGhBZmVnY3ZXNng5QlBiMy9zQ3hHV3U5WXlhdHFFeEIrVFNtNjlxSWtJOUl3aGpyY256TUUraldCeDRtTlFtNVd3THpValN5WTRGWjBhTUY1WUZsWFVENGhMNFhmT2VZdjVyRGUyczJEL0NuKzI4Zlo5VUNuT1F2WEZNblFxZmMwRytacU9XV0Q5bC9saXFVUGFOUXpaanhDSHBVQUQ4UmNjOTBNbmlRMDJ1Z0hXc1V1cEZVdmhDOXVzWTd6TlB0NUYyak83cWd6aGFmc1FTZDUwamdMckM2UXg2YnBIYlhSM1dOQXUxQnpHbXdieitlYkdtd1RqZHkwMDZZNnppcFA3bi9PSmx2U21icStTWStuZWZBVktLNkVCTVBiY2U1bjNJZFJJOCt2YnhDcE41M3J3M1R2Z05kczFTdU1pdUxHeHQ4OUw3MW14UERlYW5HaHlIdk9qbU81NnRuVnBvSGFsUW5MNlRxTnVxS3NIakhDSUtCNHBDZ2o0V3lZUHZSdll2cWk1RU1yN2xOM01vdFBSL0tIN0pVRDFsWmJVMFF6ZmJyRUJKbnVRaVZBeUFDOXZ3WFdwMlRSVTEvMGFhcHlBSDJjYmdsRUhWQWRsKzFyYjF1MTQ3dVYwdGQxZU5vUVpzcUhySU1JWVZQWHRMazJUSVUzY0pFMDhQam9ZTkRwZkYvSWNKbllRSGw2bnNwbGN6WDNSZ2FoNE5iSkpIbC8vNXNjVXVmcXNTZC8va2JJUzQwNlpXb01QLy8ramhHVXN3WC81blZOei9qQWo5S21YUHRBbU1pSytraGhibjF3L21FTHpaTVQvV3hjVy8veS9qc0hhT00vNjFvQVcvQ2pZaEp0WTYyMi9UdE1ZdVA3YmlsQnZiaVQzdkI5bjhJY0ZQbndNNzhIMEtmaFlEUmRZNVBoV0o0aldSUXpCK0hUNU5WWlY1NkxHODJoY1FtcytqT1RUL2M5WTlzeDVyUGkxL3dCN2YvK2M1VWZVQ0trM2l3d0N1eXdVYzJNR25Bd3NYZjFFNWhvSTU1eDFRL1FieStzV0g4TlJqYXZaOFZhRHNkaTFOVVZoSDg2QkpIWDF5YUZ0MXcxT1llTDVMVm1kTis1UStLdVR2WEVQRHpVQ2c2eHAwSGhzVWhUV1NlN01aTU0vNnJzVFViMC9uYlVFM1lRbEdHdDQ4a1QxLzZjbmY2eUhudkh0UXg5RW9zT1hOMDc3eXlFcS9qRTNZVGlHLzVTRUptWEZlb2NKSjFFQWQ2dktlSzZWRWRKTE9aMWttL0V3T25aV0NRcHpDTEtQSHhyZmg0eUpoR3EvLzJkb3MyRS8zK01PY2RXNUVzZ0lkbVRRVVFldHpSeTVmUUhoREJsMzdYYld6c3FPL2NBU0VEanlzdDEvOE5FUk9xVkF4V25kZFFWK3VtSjhJcktWZ0t2R2FUYzBHc1E0czhoME9zcWw1UUt3bGRkUERqSmhLSW55V3FZVUttbWxJdHMrRkljWFo2eU02Y2xqYnNqVUcya3NTT2t1SXc0c1lIZmZSTmdCT0xBcHZENlhyUjZSdDByVjJVZjhJcG5JVVZuYjlUd3Q5MVFqQWFEL2RTdFNXRHhnN2FZWStWWElnbnVvd1lkT2tqeXdhMmhsZ3JuSTZQamFVM2UzVWpRNVlrNW1kSUpHeUhudjMvUCsxRWtNYXYxeUZ5RitGZUpFL1JYbldCdytOaDBhT282VEdsS1g3ZCtka1A5K2JydnI3OVNkdFhKdGNEL2FYQkdpTU5mRzYvTlFuaVFIWVFsSzc4RkVIRHFPaCtiREkwbysyVWIwaDUzRUwvdmx6anJCY3pWRVp6MmJPdHZJTCtESXpEa2s5bkNXdDd0bHFzcTNsOUpNdEprM3I1SEcyaUo5Yi9YMTFURzZ3d01BakhMUTJvYXNhTUVzeWRoODhRUHZJK2htcUlIaHZhbHBLb0tPdWVKUjBlWjlKOEcyYWxOT0lPeTk4and2YmM4N0V3azlkKzVHL3RVaWpUbWxiakZsREtYVjA1SGFsS3hhUlRydWNjNzNPbjd5ekFQUzZmMnY0b2dpYVd5V2VWNzNkdi9Nc1FUNUhqUnJzWVY5ZExBY0kzVCt6QzJxRVZJTnlOcEVob0tWK3hWU3VXdFQ0QWhCZnBuWjd1bklNK0hYM21zSTBIaUkrUCt6MlBGZ2tqR2k1UHFFYkcvd05JV2VSVWpQdERFZ2JidWJOK0k0SmFETHJXOWJvclJCRG9iN1pGeCtKZEtlRlZVS1ZlV3FiL2M4OE9sN0RoTTBzdUx0dUVkOHRrRFNNVEQzREZ4OFVwaFBJTkhNSGk1MWhBUHR0WEw0RWt0dC9sS0VVRy9SNHFaS29oSGpWcEFjUElNaUh5V3I2eFI4L0VXbk5KdkJGRVQ3NnlDZGs1ZXI3QURCLzFiZ29JbWhwU2laL29tWmpQS1BDRWVac093dlBtWEwrMXZsSk5lR08zVHp5U21HQTFYNmU1OGdMcmF6RE03MWp5d00xWEw4ektITjZHM2tCMzFZOHZMdFA5ODJOOTc1U1pYazJKd0R2bXY3QVkvYURzRkZrMXYrbkU3L2hidnVPV2hCSDRrdWVtZVlvelBrMksyMlZ4L1lHaURUTFU3WWlscE90Mjl1M1JaTUJoNFVKamxUUDVJdHhUeld2NmViTDliK0dTVTFWc20yUzhMTWZWZkpjemFCU3FFOEoxQTRZVWpwc0FMTDcrK2J3Q1BYRmhhdWZkcERGdEJsSGI5bWFrZVlicWRnOWx0dksvSHdGL3JORTZLcnRXVWtFY3htVEI3SXl1NVRpVmFJZ1cvWXh6UWhwQXJsaUlNa09vSzVMN1NoVnRGK0RZcVYwMW1rN2Z3b3AwNGhRUndnNEtGbXI1ejluWWYwNVZWcWtTZTdnZm54NWJ4eGxRMHFFVjBqaXd6ZjA2NHFHMTFpRXFqSGNVZ0RXV3NEcy9MRUdselgzMVQ1S1ZMKzdENEVvS2ltN0hCYWdpcVJvNUpJM1dmREJncEtJcnVXejlqL0o2SHA1US9FSmJNV0I4TmVTTXVGYXJOdzNBRVlQQkp0WVFPLzRvRC9aZ1BUU1EwNmRpMEVldW1YNUVicmRUaE8rZnZZRVZTeEx0WjNBSmtlZTBYbjBzRHdOdGlpWmhKakpSRHVHMVlSS0Ixdk91bGZkOUpqSGV5dStVSFRtcnRyYS9wbSs4Uml4aDRXS2lMYUxPQ3hJYlpOb1dSWlN5eVVHTFBqQWFBbytTUUJwZk8ydXJ1V3J6RnhMbHB2clhKTk1DV3RsSkRLR0FubFdLNXhwVTJ0Y3hYYmVEK3NiZGZ3WVh0L3FUd0RrNlVxWFIvYVV0MDk5RGhTTmw0Tms4bVh3cHcrYjBudmpLT0c2TWcxUFJYanJNVU1BTnZOZ0VBcnY4bk1KczN2ajFhSGk4TUh6L1VmSldXemtjclNwWlROQmhkdVhsR1I3aStpcC9USERwNVI5S1JOY0RLRUNndHdnWGc0RUZONUhIZmlrUC9YdnNvQ2tIVGcrTmJzRDhHbDZla25rNEFyd24vQldHSjBoZ1cwL2dVS3J6dUdaaHViN2lnUlAzYWJldHBJbSsyNHhFT2xXbDNZS3BtMnFUQkZ2WDhkZERSdm0xTGN3bkNKdUVmWngxMnFQWTlUcm50TUlRc3YzMTZ6dnB5V255U3RYOFZVNGo2dFFrK0NXbExCVUNKUjZNZEg5Q3A3ZzJxZG4yV005cUZiUkVtZWpIMDlkbFdFUG04aFBGMEw3Unh3UlJkaUNzMERQOGV3azZBcG9FTGtLVTloY2tTZGJuWG04VUhKbWFOWGp4di9xMGZUVHB1OHJubDlsTjB2UUNwRFJiQ3RjejEyckdSRkVBN0NmZzdGaFpuNVFGa05tdjFaVVJLRXNpWmNlMW5TOUs3SHJ3cEM3eUpWNFh0M2VBVmJMSmZvWEhydHdHNjBaOGd3YVNubXhvTDNzMlpsUnFnZ1pOL01IbzFvVVM0TCtHd09iRkk1OTZMZDRNdmk4bCtjUW1GMWdKcGtwbkRpbzdUdU8zNW5wYU1IaVd6RnFQU1gzcU5na0lQR3VYMHFHWW5QSVZzTTkwMVl1OG9abk9aT1kxVGJ0SWRGVU5LTnEyZFA4U0o0Ri9WQ0V6SWpGMC9SaCs3VXJaajgwdEM2cm9nblZIM21xYThlQ3MvbGNRVTFQamo5OGtCbUFLRGJaVVR3b3N2MDJVdW5SUjNuMFg2YytmNzNtdHdCNy9XYlExNmdPNDMxRXR3WmJORzFTTTRUWlBCbnNRU0VTbHNmRzJKTFFYeDV4V2Y0Ym1RL3hjVkNQSVNBWDU4OTdKeEhLTEQvWGtndTU3K0FCUjIrTU10RWJYNjQrTU5sQkhwS0M3c2psV1ZFU2hmNXFBK2RHYzU5TEZWbFpyWC9FbnE5ei92K3duWjFIRXJteG1qSmp4T0EraEFqVlVXZ3RxNnlnQWkvOGV3SkRqVU1GdzN6aFFGdGJ5VExEUEZkMjFKaTVTNVFQWm85bk1TeGRnMStER0ZTTjB3bFd0N1hlWVBiSHFMZmxpVjBKMWtPaFFOcDBWYlVQeTBNUzJNczY2T3h0U1d2YVVMYVdIbmZBQStzaWVWVmd0akR3TjNuS29uV2Fwa1NLUk44QktLSlFwQ2ZxbzhSUUk1dWRoZnU1czUrN3Z3c3BwbUFKRGd6MkdOQTdkNDNWZGJWMmwvU3J2RXU0UllzbG1OSm1mU09WYnNzeEFoU1l5Nld4cElRZERCMEZWQnBaNklNOHlyODFRTitYTFozbi93ZWQvUitzNkxzbGt4S2J6enN0L0drUmJlNnJGbXR2SkN3cjFUNDRFVE0rSU1nT25qVU8wZUc2YTFuMnc3bHdNMW9GQnZ6TVVXUmtORk92S2N4M29TYjVYZGVuWjVkWHN1dGU2bmtSeXBCaVNkQXRBMmZ4QWQ4VWRMT1pXL01CN2Zab0V1RmhlUVhpamRhRjhrdWFSWm9TZVdkS09rS3NHWUVHYVhmYURLVHUwV01UY0xuaVFzN0tSQ3o5aUszU1ArWTJ4SWprZlZHcUZMU1E2dmgrQTF1NkZkZndYc3YxVlBNZmkyY3htZE0rL3hUZ01YRXlvMlpHY1EyWW1Qc2dobllkdjIrejQ4SnBHWkE0dFVLMXAxcTJWZFZ4eWZ5cFhFWGNyeEtLdG10OFVkVzdzSFdtS01xRHVCQk0zSi9KVVF4OGVVWU40cEo1b1JxdmRpUEhVMW8vV1BqaUt2bmxDcU9keXhseEY1NEw5UHJ0TEQxTmVqWjlhWkRpdlZyNlpmTUZLMS9wc1Z5Z29QSUFucGhjSldXYjkrNUlLTUttZ1JRVUxzVFBaaTZCdzR3UDMyelZFb0tjSHBQNzNDa0ZBcVM5OG5TYUdvV0RqREppYUFDSm40cDVvMWpxOVI0UTRWY2liaFhGLy9MSFAwYmRmNjNrUlZaZFJiYmhHZTdzRFFjeVdTNXRwa2ZlWUhuZmYyNVdLKzRGcHpMbEFjYmFLbUhkSUJxT3czZklteDF1cVFJQURIMFR5SHpGbHFURzZuTW9ZODFzdlAwVDZCSXlFTE1TOHRNZStFMXA2VEZQNnNWcFphNlZOYVR1bXVmRDVhajlnb1JhOVNBbWRKVDRIaEkycjBlZ2o4VXJnRmI4TDU5d0dMbllsemtMQWlVZDNtL1dXSUlFVTYxa1BvRWpkM2dJVnkvZmlCY2dxUXFIbm9YcEwwU3FMR2RHR2duN0RRZVZNU1lXSGZqbm8xRm5nSUtQOWNqWWFUbGNSUDZiWnVuakhQMTMvbGJWbTRhd3RpODk0cFRmL1pOTnFyNE9SK3REVmllL20rckM4UXBWblJic0NNUHVrT0g4N0Iyak00QUc2cEh1WGwxeDlTaUtkaFlKVk9oZm8vK1NDYUdqVVcyQ29vZ0wxRkZoRkdOOW8rYWNvVkxsMFNYcy8zdnJTY2NtWmVBRjNOZXdGdU9nL1AxMlFZS1FGK1NIK0tZY05uc0FoSUFFTFBCVWdyZS9LUlVKRUErS1BEME1IUmp2KzNKL2oyWjIzTXVKbWtmeTdsZVdjTXN0aTh3WExTSGdYRkpUYWtzeDFXb2k2b2xqd3hGVklKRzEyU0JTWkxOSkRiWE1ZUGVrbWlYVDRGY2xLSTM1QkZncW5ZcEtmY3NyK2Y4SFVYUW9ISjlVWVo0SjVZTWlISHlBeGc2ZWlkaG9kZ3FKMkh0Zi94WUV4K0cwelhjaHV6bHQ4aGNBbCtBVDhOQ1E0b3JGYzREZXJhYkYxZW5BN05UTG52dFpoM0ZVd3FJT3ZZN1E0RFltb0RId1hUU3c1VU5OaDZyN2owQi9lek1ZSk1EY3c0KzZnQ1RaWDRZUSs3WHM4ZGU3MnZzUjNjbWZweElYNjQvNktSMXAzVlg0RjZ2ZkhFenh6YXJoOGFESDRHMURGb0JCTTZucFhGcEsrUmgrV3JjRmNsQWVBeGkwUG9hUjlDcE94eEdMU2R2eEtWU3c4b09PYW5HL3NvS0ltUm9wTjM4QWRjVWhoTTJHVC9QZ1FlU1FyRzEybmp1SkpENVo3dldmQVptRnliWUxkU0E5MWtCNGFvQmhvajFaLy9LTklWVnVqcWFMTFJ3Q2tieW40dmgwNzM5QzlWOWlTanliZU9JZVNPdk5zN0xXMWE3RVV0Tm9LQW5PR01MNFU4S0JYcGZydzczV2pBc3pKRzRRc2NxK1hyM2taV1I0T21tMHhUNnFFOXk2Rk5TcHN0VjRvbk1aU3FDRUorM1ZYOXFqdmR4NVFWck0wV1h4bVBaeGVqZGZuaWhjRkFqenY1UGpsVGw2aWNrRGJIZTYrTGNoNTJwak9QcWsrbTNSWitiaDJKU01HdEZCdU9EYk1jaHJwUlZsdDE2TlRRMDVQczBJRHRXbFVtV2ZQMnZYOE00WUR5bkl1T1o0Q2s5MSs1OTFCOThHdzlmdyt5UW9nVFI4Q1NnMHphSnUrcmxCby9tcjNBKzFOemlGK2tkdWJ6K3doYzg1N0FadDZEd0lCSUY1KzV5aWFhZjNCeVFwMUZtM3NPa1pEQXp3c1lTUVRNL0t2Nmlka3VnRjYzRkRvYkRkVVkzaHVydVUrc0NhQnVSUitIbU9vd3ZtWm9CalpITmg3N1NYRnRtWS9vT1VFN2lmTjduQkhBbzgzUy94dmNTNkg0Q2kydS85SWQ2Mld2NlVpK3pNTkxBemhma1RrVmNXMkJ3cm5ZdnB1cjBaRGx6cytaTHNtR1RXdmQxODkydDc4Z3gxWWpFSnVzR2N4cGhqTGtWMFVmQUtsZWtmU0JWV0hFMmFoazRBYmJSbUh5TDdHWWR0S2ZkbElOd3JjZEp1ZjNDZWUxbmZVb2pEUW4vWW1JdEVTT0ZodEx6cmtFdjRrMlhwTVU5b2FKUTNWVUMrMUlOaDZCRTY4cGtIYW1lR0ptNEd2ZGIyNFEwZlhXeGQ5VHAzQTltekZTZTRxWERHR0RJVjRBQUdWMWpJRGZ2ZWtuSDFUd1dwVVQ2SGlReEtQM0FBSEpOa0plUmxqL21YQm1TNFMxajhGSzZZbXBLN2p5eUFpUmJzTUNDTG9KY3gwMWZ2Z3BNdktRUnh1OUlPd3ltY29uUWpENTZnN2tzT3JjT2VvVGJpdXM0Sm5HZXNBUzFEdGdkYW9waFlzdzF3R0lzTVMzUDdLNmRvRTNLNWN6em5xUFFMU1JSRi9ZbHpiNU50U0tzTDMzU2dza0ZOQ0Y0a2huNUxXYUR4STIzWlJpMmh6cU44dVc4VXpaRUJZeTY4K1Z0R0xTeW1RclhHVWxyMm5PMkJiQklUNVZoMVJtR0F5RFhhVzBGUHJweDN3djJVWWRGazl0U2wrOTA2Yk14Q3VYUWFLRFFQL1UxOVVFY1ZHSzRnbWtzTDhsQW9yeFFTQU93cGVZWDl4clpzaDZ5b0dhTC9YNU8zdGdRQzhPTSsvR3Z4blc5WHZBdHUvSnhBaWd5ZGZTbVpmcVpmZzFYT2NITk9wTGxOOGo2NE9aMzZsNXFhd0RCSjYyWWFUdnhlTm1tNWdvd0NkQm9zZ2NwSE9nTmd3QStza25OOFhtc1IySVlDaGNhZmw5YkdOTVovbkI1Z3VXdXZFeml2NlFJMmJQMkR0eUtXRy9xVWpaTWF4eSt3QVNra1ZHdHV3R3R5d2tUWUc2TVlyWkJvMTh2WWN3dzQ4Ry8rZitlSVRBL3FNd2JMbEpDMFMzKy9haTJwUHZrT2hSUlZtR1R1U3VwYXhoSWsweG9YTHRpeEN4U0FuNFozT25VUzN3QnFWc2NMSTRQM0dQN2kvNmd4WXNzd3NWbWt2RFhGTGhPL09LY3VyOGZsZWdDU0tpcW1WcElSdkN6Z2JqRUEwbVhQbitSRXhYWS8yT0UxZi9CWXVXcFJRWThnQ0RwTU9ZQng5R240dEwzaGloU0lSMWl4aDJQSUlUN2NyMmdVSmJmczc2RUtZRzUySmswVVpGL1BRa0J4R3VGQ0VXWG5HNnVlL2hUSXFqVFJxMXNvdFZyS3J3SUdIRHJJVHl1YW5VemJJWWRnZEVlVjg4SzFWRDgyVFlCMkI2MUZ0K3RCMUtxSFBtVDkraFdvYVYraUYzU3V2dEpxdm5vTGFBOHd4ckQ1NkFVTVVMRWd6TzlTdkJjQkFmcXovZHpNWXp3TXQvWUxzekRibUdlMWJjSEhmRk1jdkdxbDliZi90cCtIcmo0cTE4YU5uZnRHam1YVGZ3czM5ZW1uNy81SUJ4b2c5TXJtZnRBQTVPcTRhd2VubThIaW1XTzcyZHdWbEhjSG11dFZNZHJNSHcrcDJ2enB6VCtCMGlJWitJRXBwbHdXaENsY1hseGh4QXNGM0NIUm5uYVVFcXEzQnlRK2NxaGU1U3ZSNFNGeGgvTFpvUXd0ajhRWlFHVDFCelkyRU1wWW5VY1pXUUVQbHdGWncrN1VyeUs5cVY4S2dydVlzdnlNb0sxNktJMnNONFNPYmxyVndoeWlMOCtJQlo4Y3BVaHNKUVNVN1RGSEFpK0wyRjBzbjB5K0Z0RE9EbG51aWYyTWJhOFFkZFBaWVl4alRzSWdrTWUzTTYrN2tYeFVmWnZiQ1VseXE3MUoxZU5jekdrNlZxdzZyU3gySzN2TStEakx4RFJHeldlcFRPMnFUVC9XOFM3dTBRWGN5RlVhaGNCNHZxOHhDWVRweThpc3d0bnl6N0t4NmxnVEVRSjlScWtnRUlONkRPVXFCMHVSZGVZdURhN0FQN1p5OXorWmxUc21WUjV2dFY3MW0zZG1kdE5lV2doYnI1UG5QSnRqWEF6Y3Zaanh5Vjk2VkV4L0IxVEEwSUVRU0k1MHl3R3VJYm1BWWRRZy9sL3J4aFFMWCs2dU9MeUZzYVV0Nm10anBBSmtMZmVobkI2TWxPSG5OT3JXTHZDQnFWQlMwN2pjTSs0UnpMRWVkM2YzLzBYd3A5MlUrbmF0YU5IeUVnbm51WVI2UFhFalJMRVR6MHhydDNVZ2xmSzdCbjRhTmxYRzdjWmNvNGxNemlMdjUrTWgySkN3dzNtejY5WjlaTVJSL3h2NUVLSjM4SUZ4S2Q5ZHc1Q2dQSVhqYS9nekFzaE1iRjE0L3FCSWdOa2RVUWVQOFlFN1NySUNHdGlUbkFLVHlBOWNYYTNPYXVESHhaT2RUUDd5dVlCekQxVWNIc3RJTzE2RnhGMWJSVUFsU2tzekk4M1l1ZlRjaFU4T1Bubm96RGw5YlMweTZDbm5qR3dnajlNNjFjWGNac2xqamhMZVQvVnErMzBTY04yUGNUL2RPb3hVRHFEUzM4K09wQ0N6TERkbndIUWMzRUNRVklrYXhtZFBhWlRTZGZwMmpqR3pTZE5MTTV5UFFzZ0pEbCtabmhjbERRaThsdFVua3FXSjMyM0l2VFpQTjhybjArRXNoTDFjeDlQaWFMVHpVc3J5bjlacDJOdC9kZXRVQWg0Ti8ySTNkbE1RcWpIRnhTaWh2MHV5a3pmbHE1Y2xNeTJaQmF4b0ViMC9RTXAwM0lRUXVzM3ZuWmQvTk9tU3NtZ3FYcUtGUDNvenlEZ1k3UlFTK25wYWJlL2hORys1c2E1RnR2TDh2MHVZdWFnMk5ld1lrY29sM1RPVGFkcHVuY0NuRGdPR3BtTG5UUTFQRVBVTjJjTnNyVzhMWWZJditoemZiN3ZvZCtpcFhIem1iZ2o1RnpjNlJjVC81UEQ3VlE4blRKQk5qMXVya1ZVeDl1SnZUV21xWTA4T0M4MHJHRExhV1h2MjQzVkIxNmdqdDRYdHdwNUgyVURSMExpS1cyNEVkL3NPTzhqbDF5RVUvWEFiM2g3U2NLbkNGeS9WM3NJQ3JrWTFEMEs5ZlNva0hJTDBzNS83RExTaExBUFhSYlY3ZmJ2NHFqNk93SEM5ZDVQbEVPWDNMUnBRM1A3aGNTQUtsSUtQRE04M3lwejU2VTUrckplbzBjeVV0Qzd3bHRMOHdxRWlOU2dac0RXekFDYzdSRm9acWhsRDArc2loSUJRbGtRVFhtdlV5SU9aaGtRWDJ6cU1FNVZSQzdtczFzYTNDWStvZE1uM21NQmlUdkNNS25uQ3hnNVpQTHE0R1VEQjRqRjhCcjJLNHg0c3hmV2pHWFFhdEoyNUkxSnlySXYyWjRiUDFqS3c1QytCMi9zMHY0ZEdVT3NhUzZJUElRVjNFVFErRjJmU2wyQlBCWEh6eVlOOFZtd1dJcktlTVg5cHlHV3VBT1ZYd2t4SnNSQmFCVnpMaFpEUDhPTkduY2tuTDVEcFR4SE4zMkdnRldNd3NjMEdtTDBvUkRtUlQ4dTJsdmpBS1VJaTBNbVhoSUhTbEZlaDNRaDVwUDZhcDRZVWQ2YjU2OVpJYUhneWEyQXlEMTJjUHhZMEluL1BCanpEY3RUYUtKQ1UreGM2bTlSa05MREVFOGd1dnh0SlA4c2w4TjliTHF3MEYvcWVqYUJsY0hZcXczMXpZcHN1dFFwMDdoc1AxdmhHZGw0aEoxd0E3T0NzQUhuS2o5ODc5dVNISUxFbXVaNnZJMWxUNHR2bldDVktaaGhZcldIVzlvUEtQS3BiT0M2RlRqZi9PdFV2d21pWHIyeWt2eUx6SEdRZXlTN0JlblpwTDNOL0NhRjVUN0drbWw3SlhONWNqMFBLYURwWlZJbUQ2MUZ1TWdGSFBxU0h2dDRFajRLQmRBZmRjb08zQWpRUEx3d3RLc2dHTSt0eTRsTlpNQkVJdEpTUkx1bkc1Y2tyTS9CZW9YV29QWlZ2RW9JekxnRlFZUHVwTXdaQ1hpczRXMlNDSjJ6c2VmWnFDaithVGZTcTFGWWRVajJVZUpBTHZWVGY3dnV1aWtPRTFIaXQzVUlBR1VpL3NxZ011bTl2dzIxOHkxRmxZLzlYbk9qaTlucWhHQWNNWUlDYzdCaXFMWmo1TitjS0V1U0F1aXlXYk1nODFaRDFsSG92eS93ZTJlYUNjQ3Y0TXpFVzNPMG1WQS90MnhkQTBjeFRWYlhtRmhuK3RBUkRwdkR6NWZ0THIxNU9BQW12bzJRaUFreStmZVZPNGJHaWJ2Mm5sQm1CenF4MGxFRGZFbTRVbkVzMTFwYm53WmxKLzBZNzMvd0JQWWZUTlppSktSNzNUemRDVzFCZmZpSnE5YkxqUW1hS25VMCtnTjhzZmUyNUlLU1VDb29Rd3hlUERyRm4zYS96VWdXeHZQb1RZVlhmb2JZL0dWMnFxVGtlVkRWOUQ4NjU3ZmhZMC93aWFKNU5mTHhoWGJFL25heHMzNE4waGQ2dnhOZmRtMVRDbm96bS9OS1NDVGhjaG9ZZ01GN1oydHpYRm92UmZzTlZrZjg2SmpyTTYwcjdVSXVWM2JzbWZyTU9xempYak42SFBCRzI1ekNKM1FMdWV5U2JqOW9GdlgvSHhXQnFoMzFQQlB4ZHVDVkF4TXFDOUhLK1lMM29CWnFCcnVvaDZMS3ZkTXFvejBQWVhVQnJ3Ymlpb3lFOFRqNUltakptaU9PV0xiQVp2SVovbDlySVBsangzVDVnbEoyZXdsZnVJVDVHbG9kUXNBZi9JRXRtWWtNTDVTUlFHeHh3VytybFprRDhiZWxKTnUwOUl0d3g5eERVTFRuZW1WRGVvamRiZ2NkMmdLR005YU8wMEppdnRiczdaeU9TRThJUGg5OEdmdmF0RDhVZDV1SGNaZkFmTWlQU2xJeGQ0VXFlU0R6dU5mYktEdUZlcGt5Qy9zM2o5ZmF3bWhZMWI5TnFEaTBaUzVlUDM1bDdyTDJlSzVRbFdMbHlDbXh4OEFGYUZpVHVEMnBNVXhaVjVtQlNKdUpkdU9hcTJacldwdTI4REU4amwvaGlzQno3YkdXSDZxTEYwYXlXTnExU2VqdGNzOEtRclFxSms1UDlRSERZSE9Jb2xnTnNNRG1FYVdjVGVsZ2hiZkZDRHFXcnE2WUx3RFd5K202OGVjNW5TaGdxMmZkdVVCcFFVdUtLS2dudHRhVVg5UFJmTW14cUp5VTdlMFJMcjFiZXYrZ2UxS0swYlp5aEhLS0RFOGdRWDlWZjdyTkhXT3hCdFpjeHd3R3VzeU1wSDc3cVdaeFhzUW1iZ0lHaHRpTytnU1NSQ3l1L2VrK09Gc3oxSE1pUUgwSUhWN1BqSmkzZHN6WWZGcDh1ZTloNCtBZkt0ZTRNVGllaFB2eE5jbS9UMXQ5dnNGWng4ckhONWllNzdyMmp6Wk9xL0VtNFErSDlzTmNaYWtmOUhuekNjMWZKaXhwcHhQOEZRQUJtVm5xYTZHYkpod2FrYTdXSDdXZG96MVd4T2pTTlY4TjlzZ1c1UzNQcGdrdXQrVFRDa2pBK0FvZFVPazFLSVIrOEc4UzNXclNaRzRueXFmSjZGRWpYbDZhL0xFb1JNSFpVcWZQUld2d3FydFhZeTlJVXNtVUd6a3FpNzZpYjROQU5DZTVEbnlPeG5GUlo5ZDhGZEJWQmpyYTNpTnVaaEp1V1c1T21pL2hCaWdxRHNnMG11MkFoZkpEWGR3eU1JSjMzSEhIUGZTMkp0amVnUmVqWDExbTQxVGJOTCtRcDdtUjBnOUNQS1RqOVBJanVTeWNHTi9ZUG96WEk0emFyWHVBZUx2NUNIS3RLY0pLUmJkNlIyb0xOaUV0MFQ4K1FJVkpIN3p0OW5jS01nZDQ5dlYyUDFBeVNjWjlRemJ1M20zTEJudXU2ZHc3YUUwYjZyNGt6VmtJL0dVUzg4bUE1M0wvckx0bnRrRmxaWEd0SW9xTlAybUQzZVZ2MDhBVlZQVDN3Sm44MXpwYkpWOVN1cVo2UGQxZ2UwWnoyUkZIZUNkVjVDTFBmdEg5VjVvOStWekZ1NFIwUWV1bXFEd1VoWG4zSXlZb3RkSm54cjFsM0JxV25RVkFlREJFT3RQeUpReDFxNSttT0RpQ2xYdFllQkxUV3RzSjQyQU1CY2YvSUZJaHBmaFlPMDhoc2cwSWsrRHBRRk5PS1JlSzNvM2N1ZGt4V1gwc29QdEk1ZVNGT0E2eU55bFMrSVFqclF0WVEvNXM0VWNpeEpmb2t1bUJVanBIOW9mU2pVVHdQQ2FwR0ZuZGZxcUc1SUhlTU12ZmcrODhTWG03Yk55ams2cEdLekwrV3hEQWRxS3RRNzJXV1ZiT2szSSt1ZUd1YW1tbUIycHZGWnZxSWNVL2x2VzNuOStyMmx5Y25RTEU0T1g5UjFqSWdXNGNEakozdjhkQWE2Nm1WY2ZDN3B0Q3I1aW82bUNhQTlxSTlUOUZGV3FvMVpBYU14Z3hBdThhWHFtYU9ZcnlNTkQyc1RVZm9IdnhjWUs3aEVpSmhDTFlGRHgzUEJoRTk3YzJhMHViMS9lUEpjeUpPcXI3VWFUQVBUSit4dlp0amIvNDBzbG9ZMWx0Um5Ua1dJTG1JUDJiN1MzQWRYQ1IrWWlBck1VSHdkbmNwanB5REdmenFHT1VvQXVhYW1XekFNYWNRdGIzNC9NMzJGRWdSNWxVRWY4ZlJ6RnJaVWh6UWowZlI3LzZnZHpkblZWdmNTbmVMbXRxSjkzMFZDQ0RPUlk4Q1ZkUVdkby9TM1BOa1gzcFFzUFZLV0lZR0FNckZab3E4YlEvT0pCRFNYUDdLU0JkTDNRTjBacWQzOTNwNlZGYzdEbmxuRmlOMDBTWTVOdXg3eWFkZUlNMFVwbDJyVnN1OC9WQUknO1xuY29uc3QgRkVOQ0VEID0gbmV3IE1hcChbWzgyMTcsXCJhcG9zdHJvcGhlXCJdLFs4MjYwLFwiZnJhY3Rpb24gc2xhc2hcIl0sWzEyNTM5LFwibWlkZGxlIGRvdFwiXV0pO1xuY29uc3QgTlNNX01BWCA9IDQ7XG5cbmZ1bmN0aW9uIGRlY29kZV9hcml0aG1ldGljKGJ5dGVzKSB7XHJcblx0bGV0IHBvcyA9IDA7XHJcblx0ZnVuY3Rpb24gdTE2KCkgeyByZXR1cm4gKGJ5dGVzW3BvcysrXSA8PCA4KSB8IGJ5dGVzW3BvcysrXTsgfVxyXG5cdFxyXG5cdC8vIGRlY29kZSB0aGUgZnJlcXVlbmN5IHRhYmxlXHJcblx0bGV0IHN5bWJvbF9jb3VudCA9IHUxNigpO1xyXG5cdGxldCB0b3RhbCA9IDE7XHJcblx0bGV0IGFjYyA9IFswLCAxXTsgLy8gZmlyc3Qgc3ltYm9sIGhhcyBmcmVxdWVuY3kgMVxyXG5cdGZvciAobGV0IGkgPSAxOyBpIDwgc3ltYm9sX2NvdW50OyBpKyspIHtcclxuXHRcdGFjYy5wdXNoKHRvdGFsICs9IHUxNigpKTtcclxuXHR9XHJcblxyXG5cdC8vIHNraXAgdGhlIHNpemVkLXBheWxvYWQgdGhhdCB0aGUgbGFzdCAzIHN5bWJvbHMgaW5kZXggaW50b1xyXG5cdGxldCBza2lwID0gdTE2KCk7XHJcblx0bGV0IHBvc19wYXlsb2FkID0gcG9zO1xyXG5cdHBvcyArPSBza2lwO1xyXG5cclxuXHRsZXQgcmVhZF93aWR0aCA9IDA7XHJcblx0bGV0IHJlYWRfYnVmZmVyID0gMDsgXHJcblx0ZnVuY3Rpb24gcmVhZF9iaXQoKSB7XHJcblx0XHRpZiAocmVhZF93aWR0aCA9PSAwKSB7XHJcblx0XHRcdC8vIHRoaXMgd2lsbCByZWFkIGJleW9uZCBlbmQgb2YgYnVmZmVyXHJcblx0XHRcdC8vIGJ1dCAodW5kZWZpbmVkfDApID0+IHplcm8gcGFkXHJcblx0XHRcdHJlYWRfYnVmZmVyID0gKHJlYWRfYnVmZmVyIDw8IDgpIHwgYnl0ZXNbcG9zKytdO1xyXG5cdFx0XHRyZWFkX3dpZHRoID0gODtcclxuXHRcdH1cclxuXHRcdHJldHVybiAocmVhZF9idWZmZXIgPj4gLS1yZWFkX3dpZHRoKSAmIDE7XHJcblx0fVxyXG5cclxuXHRjb25zdCBOID0gMzE7XHJcblx0Y29uc3QgRlVMTCA9IDIqKk47XHJcblx0Y29uc3QgSEFMRiA9IEZVTEwgPj4+IDE7XHJcblx0Y29uc3QgUVJUUiA9IEhBTEYgPj4gMTtcclxuXHRjb25zdCBNQVNLID0gRlVMTCAtIDE7XHJcblxyXG5cdC8vIGZpbGwgcmVnaXN0ZXJcclxuXHRsZXQgcmVnaXN0ZXIgPSAwO1xyXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgTjsgaSsrKSByZWdpc3RlciA9IChyZWdpc3RlciA8PCAxKSB8IHJlYWRfYml0KCk7XHJcblxyXG5cdGxldCBzeW1ib2xzID0gW107XHJcblx0bGV0IGxvdyA9IDA7XHJcblx0bGV0IHJhbmdlID0gRlVMTDsgLy8gdHJlYXQgbGlrZSBhIGZsb2F0XHJcblx0d2hpbGUgKHRydWUpIHtcclxuXHRcdGxldCB2YWx1ZSA9IE1hdGguZmxvb3IoKCgocmVnaXN0ZXIgLSBsb3cgKyAxKSAqIHRvdGFsKSAtIDEpIC8gcmFuZ2UpO1xyXG5cdFx0bGV0IHN0YXJ0ID0gMDtcclxuXHRcdGxldCBlbmQgPSBzeW1ib2xfY291bnQ7XHJcblx0XHR3aGlsZSAoZW5kIC0gc3RhcnQgPiAxKSB7IC8vIGJpbmFyeSBzZWFyY2hcclxuXHRcdFx0bGV0IG1pZCA9IChzdGFydCArIGVuZCkgPj4+IDE7XHJcblx0XHRcdGlmICh2YWx1ZSA8IGFjY1ttaWRdKSB7XHJcblx0XHRcdFx0ZW5kID0gbWlkO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHN0YXJ0ID0gbWlkO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRpZiAoc3RhcnQgPT0gMCkgYnJlYWs7IC8vIGZpcnN0IHN5bWJvbCBpcyBlbmQgbWFya1xyXG5cdFx0c3ltYm9scy5wdXNoKHN0YXJ0KTtcclxuXHRcdGxldCBhID0gbG93ICsgTWF0aC5mbG9vcihyYW5nZSAqIGFjY1tzdGFydF0gICAvIHRvdGFsKTtcclxuXHRcdGxldCBiID0gbG93ICsgTWF0aC5mbG9vcihyYW5nZSAqIGFjY1tzdGFydCsxXSAvIHRvdGFsKSAtIDE7XHJcblx0XHR3aGlsZSAoKChhIF4gYikgJiBIQUxGKSA9PSAwKSB7XHJcblx0XHRcdHJlZ2lzdGVyID0gKHJlZ2lzdGVyIDw8IDEpICYgTUFTSyB8IHJlYWRfYml0KCk7XHJcblx0XHRcdGEgPSAoYSA8PCAxKSAmIE1BU0s7XHJcblx0XHRcdGIgPSAoYiA8PCAxKSAmIE1BU0sgfCAxO1xyXG5cdFx0fVxyXG5cdFx0d2hpbGUgKGEgJiB+YiAmIFFSVFIpIHtcclxuXHRcdFx0cmVnaXN0ZXIgPSAocmVnaXN0ZXIgJiBIQUxGKSB8ICgocmVnaXN0ZXIgPDwgMSkgJiAoTUFTSyA+Pj4gMSkpIHwgcmVhZF9iaXQoKTtcclxuXHRcdFx0YSA9IChhIDw8IDEpIF4gSEFMRjtcclxuXHRcdFx0YiA9ICgoYiBeIEhBTEYpIDw8IDEpIHwgSEFMRiB8IDE7XHJcblx0XHR9XHJcblx0XHRsb3cgPSBhO1xyXG5cdFx0cmFuZ2UgPSAxICsgYiAtIGE7XHJcblx0fVxyXG5cdGxldCBvZmZzZXQgPSBzeW1ib2xfY291bnQgLSA0O1xyXG5cdHJldHVybiBzeW1ib2xzLm1hcCh4ID0+IHsgLy8gaW5kZXggaW50byBwYXlsb2FkXHJcblx0XHRzd2l0Y2ggKHggLSBvZmZzZXQpIHtcclxuXHRcdFx0Y2FzZSAzOiByZXR1cm4gb2Zmc2V0ICsgMHgxMDEwMCArICgoYnl0ZXNbcG9zX3BheWxvYWQrK10gPDwgMTYpIHwgKGJ5dGVzW3Bvc19wYXlsb2FkKytdIDw8IDgpIHwgYnl0ZXNbcG9zX3BheWxvYWQrK10pO1xyXG5cdFx0XHRjYXNlIDI6IHJldHVybiBvZmZzZXQgKyAweDEwMCArICgoYnl0ZXNbcG9zX3BheWxvYWQrK10gPDwgOCkgfCBieXRlc1twb3NfcGF5bG9hZCsrXSk7XHJcblx0XHRcdGNhc2UgMTogcmV0dXJuIG9mZnNldCArIGJ5dGVzW3Bvc19wYXlsb2FkKytdO1xyXG5cdFx0XHRkZWZhdWx0OiByZXR1cm4geCAtIDE7XHJcblx0XHR9XHJcblx0fSk7XHJcbn1cdFxyXG5cclxuLy8gcmV0dXJucyBhbiBpdGVyYXRvciB3aGljaCByZXR1cm5zIHRoZSBuZXh0IHN5bWJvbFxyXG5mdW5jdGlvbiByZWFkX3BheWxvYWQodikge1xyXG5cdGxldCBwb3MgPSAwO1xyXG5cdHJldHVybiAoKSA9PiB2W3BvcysrXTtcclxufVxyXG5mdW5jdGlvbiByZWFkX2NvbXByZXNzZWRfcGF5bG9hZChzKSB7XHJcblx0cmV0dXJuIHJlYWRfcGF5bG9hZChkZWNvZGVfYXJpdGhtZXRpYyh1bnNhZmVfYXRvYihzKSkpO1xyXG59XHJcblxyXG4vLyB1bnNhZmUgaW4gdGhlIHNlbnNlOlxyXG4vLyBleHBlY3RlZCB3ZWxsLWZvcm1lZCBCYXNlNjQgdy9vIHBhZGRpbmcgXHJcbi8vIDIwMjIwOTIyOiBhZGRlZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL2FkcmFmZnkvZW5zLW5vcm1hbGl6ZS5qcy9pc3N1ZXMvNFxyXG5mdW5jdGlvbiB1bnNhZmVfYXRvYihzKSB7XHJcblx0bGV0IGxvb2t1cCA9IFtdO1xyXG5cdFsuLi4nQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyddLmZvckVhY2goKGMsIGkpID0+IGxvb2t1cFtjLmNoYXJDb2RlQXQoMCldID0gaSk7XHJcblx0bGV0IG4gPSBzLmxlbmd0aDtcclxuXHRsZXQgcmV0ID0gbmV3IFVpbnQ4QXJyYXkoKDYgKiBuKSA+PiAzKTtcclxuXHRmb3IgKGxldCBpID0gMCwgcG9zID0gMCwgd2lkdGggPSAwLCBjYXJyeSA9IDA7IGkgPCBuOyBpKyspIHtcclxuXHRcdGNhcnJ5ID0gKGNhcnJ5IDw8IDYpIHwgbG9va3VwW3MuY2hhckNvZGVBdChpKV07XHJcblx0XHR3aWR0aCArPSA2O1xyXG5cdFx0aWYgKHdpZHRoID49IDgpIHtcclxuXHRcdFx0cmV0W3BvcysrXSA9IChjYXJyeSA+PiAod2lkdGggLT0gOCkpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gcmV0O1xyXG59XHJcblxyXG4vLyBlZy4gWzAsMSwyLDMuLi5dID0+IFswLC0xLDEsLTIsLi4uXVxyXG5mdW5jdGlvbiBzaWduZWQoaSkgeyBcclxuXHRyZXR1cm4gKGkgJiAxKSA/ICh+aSA+PiAxKSA6IChpID4+IDEpO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZWFkX2RlbHRhcyhuLCBuZXh0KSB7XHJcblx0bGV0IHYgPSBBcnJheShuKTtcclxuXHRmb3IgKGxldCBpID0gMCwgeCA9IDA7IGkgPCBuOyBpKyspIHZbaV0gPSB4ICs9IHNpZ25lZChuZXh0KCkpO1xyXG5cdHJldHVybiB2O1xyXG59XHJcblxyXG4vLyBbMTIzXVs1XSA9PiBbMCAzXSBbMSAxXSBbMCAwXVxyXG5mdW5jdGlvbiByZWFkX3NvcnRlZChuZXh0LCBwcmV2ID0gMCkge1xyXG5cdGxldCByZXQgPSBbXTtcclxuXHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0bGV0IHggPSBuZXh0KCk7XHJcblx0XHRsZXQgbiA9IG5leHQoKTtcclxuXHRcdGlmICghbikgYnJlYWs7XHJcblx0XHRwcmV2ICs9IHg7XHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xyXG5cdFx0XHRyZXQucHVzaChwcmV2ICsgaSk7XHJcblx0XHR9XHJcblx0XHRwcmV2ICs9IG4gKyAxO1xyXG5cdH1cclxuXHRyZXR1cm4gcmV0O1xyXG59XHJcblxyXG5mdW5jdGlvbiByZWFkX3NvcnRlZF9hcnJheXMobmV4dCkge1xyXG5cdHJldHVybiByZWFkX2FycmF5X3doaWxlKCgpID0+IHsgXHJcblx0XHRsZXQgdiA9IHJlYWRfc29ydGVkKG5leHQpO1xyXG5cdFx0aWYgKHYubGVuZ3RoKSByZXR1cm4gdjtcclxuXHR9KTtcclxufVxyXG5cclxuLy8gcmV0dXJucyBtYXAgb2YgeCA9PiB5c1xyXG5mdW5jdGlvbiByZWFkX21hcHBlZChuZXh0KSB7XHJcblx0bGV0IHJldCA9IFtdO1xyXG5cdHdoaWxlICh0cnVlKSB7XHJcblx0XHRsZXQgdyA9IG5leHQoKTtcclxuXHRcdGlmICh3ID09IDApIGJyZWFrO1xyXG5cdFx0cmV0LnB1c2gocmVhZF9saW5lYXJfdGFibGUodywgbmV4dCkpO1xyXG5cdH1cclxuXHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0bGV0IHcgPSBuZXh0KCkgLSAxO1xyXG5cdFx0aWYgKHcgPCAwKSBicmVhaztcclxuXHRcdHJldC5wdXNoKHJlYWRfcmVwbGFjZW1lbnRfdGFibGUodywgbmV4dCkpO1xyXG5cdH1cclxuXHRyZXR1cm4gcmV0LmZsYXQoKTtcclxufVxyXG5cclxuLy8gcmVhZCB1bnRpbCBuZXh0IGlzIGZhbHN5XHJcbi8vIHJldHVybiBhcnJheSBvZiByZWFkIHZhbHVlc1xyXG5mdW5jdGlvbiByZWFkX2FycmF5X3doaWxlKG5leHQpIHtcclxuXHRsZXQgdiA9IFtdO1xyXG5cdHdoaWxlICh0cnVlKSB7XHJcblx0XHRsZXQgeCA9IG5leHQodi5sZW5ndGgpO1xyXG5cdFx0aWYgKCF4KSBicmVhaztcclxuXHRcdHYucHVzaCh4KTtcclxuXHR9XHJcblx0cmV0dXJuIHY7XHJcbn1cclxuXHJcbi8vIHJlYWQgdyBjb2x1bW5zIG9mIGxlbmd0aCBuXHJcbi8vIHJldHVybiBhcyBuIHJvd3Mgb2YgbGVuZ3RoIHdcclxuZnVuY3Rpb24gcmVhZF90cmFuc3Bvc2VkKG4sIHcsIG5leHQpIHtcclxuXHRsZXQgbSA9IEFycmF5KG4pLmZpbGwoKS5tYXAoKCkgPT4gW10pO1xyXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgdzsgaSsrKSB7XHJcblx0XHRyZWFkX2RlbHRhcyhuLCBuZXh0KS5mb3JFYWNoKCh4LCBqKSA9PiBtW2pdLnB1c2goeCkpO1xyXG5cdH1cclxuXHRyZXR1cm4gbTtcclxufVxyXG4gXHJcbi8vIHJldHVybnMgW1t4LCB5c10sIFt4K2R4LCB5cytkeV0sIFt4KzIqZHgsIHlzKzIqZHldLCAuLi5dXHJcbi8vIHdoZXJlIGR4L2R5ID0gc3RlcHMsIG4gPSBydW4gc2l6ZSwgdyA9IGxlbmd0aCBvZiB5XHJcbmZ1bmN0aW9uIHJlYWRfbGluZWFyX3RhYmxlKHcsIG5leHQpIHtcclxuXHRsZXQgZHggPSAxICsgbmV4dCgpO1xyXG5cdGxldCBkeSA9IG5leHQoKTtcclxuXHRsZXQgdk4gPSByZWFkX2FycmF5X3doaWxlKG5leHQpO1xyXG5cdGxldCBtID0gcmVhZF90cmFuc3Bvc2VkKHZOLmxlbmd0aCwgMSt3LCBuZXh0KTtcclxuXHRyZXR1cm4gbS5mbGF0TWFwKCh2LCBpKSA9PiB7XHJcblx0XHRsZXQgW3gsIC4uLnlzXSA9IHY7XHJcblx0XHRyZXR1cm4gQXJyYXkodk5baV0pLmZpbGwoKS5tYXAoKF8sIGopID0+IHtcclxuXHRcdFx0bGV0IGpfZHkgPSBqICogZHk7XHJcblx0XHRcdHJldHVybiBbeCArIGogKiBkeCwgeXMubWFwKHkgPT4geSArIGpfZHkpXTtcclxuXHRcdH0pO1xyXG5cdH0pO1xyXG59XHJcblxyXG4vLyByZXR1cm4gW1t4LCB5cy4uLl0sIC4uLl1cclxuLy8gd2hlcmUgdyA9IGxlbmd0aCBvZiB5XHJcbmZ1bmN0aW9uIHJlYWRfcmVwbGFjZW1lbnRfdGFibGUodywgbmV4dCkgeyBcclxuXHRsZXQgbiA9IDEgKyBuZXh0KCk7XHJcblx0bGV0IG0gPSByZWFkX3RyYW5zcG9zZWQobiwgMSt3LCBuZXh0KTtcclxuXHRyZXR1cm4gbS5tYXAodiA9PiBbdlswXSwgdi5zbGljZSgxKV0pO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gcmVhZF90cmllKG5leHQpIHtcclxuXHRsZXQgcmV0ID0gW107XHJcblx0bGV0IHNvcnRlZCA9IHJlYWRfc29ydGVkKG5leHQpOyBcclxuXHRleHBhbmQoZGVjb2RlKFtdKSwgW10pO1xyXG5cdHJldHVybiByZXQ7IC8vIG5vdCBzb3J0ZWRcclxuXHRmdW5jdGlvbiBkZWNvZGUoUSkgeyAvLyBjaGFyYWN0ZXJzIHRoYXQgbGVhZCBpbnRvIHRoaXMgbm9kZVxyXG5cdFx0bGV0IFMgPSBuZXh0KCk7IC8vIHN0YXRlOiB2YWxpZCwgc2F2ZSwgY2hlY2tcclxuXHRcdGxldCBCID0gcmVhZF9hcnJheV93aGlsZSgoKSA9PiB7IC8vIGJ1Y2tldHMgbGVhZGluZyB0byBuZXcgbm9kZXNcclxuXHRcdFx0bGV0IGNwcyA9IHJlYWRfc29ydGVkKG5leHQpLm1hcChpID0+IHNvcnRlZFtpXSk7XHJcblx0XHRcdGlmIChjcHMubGVuZ3RoKSByZXR1cm4gZGVjb2RlKGNwcyk7XHJcblx0XHR9KTtcclxuXHRcdHJldHVybiB7UywgQiwgUX07XHJcblx0fVxyXG5cdGZ1bmN0aW9uIGV4cGFuZCh7UywgQn0sIGNwcywgc2F2ZWQpIHtcclxuXHRcdGlmIChTICYgNCAmJiBzYXZlZCA9PT0gY3BzW2Nwcy5sZW5ndGgtMV0pIHJldHVybjtcclxuXHRcdGlmIChTICYgMikgc2F2ZWQgPSBjcHNbY3BzLmxlbmd0aC0xXTtcclxuXHRcdGlmIChTICYgMSkgcmV0LnB1c2goY3BzKTsgXHJcblx0XHRmb3IgKGxldCBiciBvZiBCKSB7XHJcblx0XHRcdGZvciAobGV0IGNwIG9mIGJyLlEpIHtcclxuXHRcdFx0XHRleHBhbmQoYnIsIFsuLi5jcHMsIGNwXSwgc2F2ZWQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG59XG5cbmZ1bmN0aW9uIGhleF9jcChjcCkge1xyXG5cdHJldHVybiBjcC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKS5wYWRTdGFydCgyLCAnMCcpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBxdW90ZV9jcChjcCkge1xyXG5cdHJldHVybiBgeyR7aGV4X2NwKGNwKX19YDsgLy8gcmFmZnkgY29udmVudGlvbjogbGlrZSBcIlxcdXtYfVwiIHcvbyB0aGUgXCJcXHVcIlxyXG59XHJcblxyXG4vKlxyXG5leHBvcnQgZnVuY3Rpb24gZXhwbG9kZV9jcChzKSB7XHJcblx0cmV0dXJuIFsuLi5zXS5tYXAoYyA9PiBjLmNvZGVQb2ludEF0KDApKTtcclxufVxyXG4qL1xyXG5mdW5jdGlvbiBleHBsb2RlX2NwKHMpIHsgLy8gdGhpcyBpcyBhYm91dCAyeCBmYXN0ZXJcclxuXHRsZXQgY3BzID0gW107XHJcblx0Zm9yIChsZXQgcG9zID0gMCwgbGVuID0gcy5sZW5ndGg7IHBvcyA8IGxlbjsgKSB7XHJcblx0XHRsZXQgY3AgPSBzLmNvZGVQb2ludEF0KHBvcyk7XHJcblx0XHRwb3MgKz0gY3AgPCAweDEwMDAwID8gMSA6IDI7XHJcblx0XHRjcHMucHVzaChjcCk7XHJcblx0fVxyXG5cdHJldHVybiBjcHM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHN0cl9mcm9tX2NwcyhjcHMpIHtcclxuXHRjb25zdCBjaHVuayA9IDQwOTY7XHJcblx0bGV0IGxlbiA9IGNwcy5sZW5ndGg7XHJcblx0aWYgKGxlbiA8IGNodW5rKSByZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQoLi4uY3BzKTtcclxuXHRsZXQgYnVmID0gW107XHJcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICkge1xyXG5cdFx0YnVmLnB1c2goU3RyaW5nLmZyb21Db2RlUG9pbnQoLi4uY3BzLnNsaWNlKGksIGkgKz0gY2h1bmspKSk7XHJcblx0fVxyXG5cdHJldHVybiBidWYuam9pbignJyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbXBhcmVfYXJyYXlzKGEsIGIpIHtcclxuXHRsZXQgbiA9IGEubGVuZ3RoO1xyXG5cdGxldCBjID0gbiAtIGIubGVuZ3RoO1xyXG5cdGZvciAobGV0IGkgPSAwOyBjID09IDAgJiYgaSA8IG47IGkrKykgYyA9IGFbaV0gLSBiW2ldO1xyXG5cdHJldHVybiBjO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhcnJheV9yZXBsYWNlKHYsIGEsIGIpIHtcclxuXHRsZXQgcHJldiA9IDA7XHJcblx0d2hpbGUgKHRydWUpIHtcclxuXHRcdGxldCBuZXh0ID0gdi5pbmRleE9mKGEsIHByZXYpO1xyXG5cdFx0aWYgKG5leHQgPCAwKSBicmVhaztcclxuXHRcdHZbbmV4dF0gPSBiOyBcclxuXHRcdHByZXYgPSBuZXh0ICsgMTtcclxuXHR9XHJcbn1cblxuLy8gY3JlYXRlZCAyMDI1LTA5LTE0VDE3OjU2OjI0LjA5OVpcbi8vIGNvbXByZXNzZWQgYmFzZTY0LWVuY29kZWQgYmxvYiBmb3IgaW5jbHVkZS1uZiBkYXRhXG4vLyBzb3VyY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9hZHJhZmZ5L2Vucy1ub3JtYWxpemUuanMvYmxvYi9tYWluL3NyYy9tYWtlLmpzXG4vLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9hZHJhZmZ5L2Vucy1ub3JtYWxpemUuanMjc2VjdXJpdHlcbi8vIFNIQS0yNTY6IDllZjQzY2M3MjE1YWE3YTUzZTRlZDlhZmEzYjRmMmY4Y2UwMGEyYzcwOGI5ZWI5NmFhNDA5YWU2ZmEzZmI2YWZcbnZhciBDT01QUkVTU0VEID0gJ0FFVURXQUhTQ0dZQVR3RFZBRElBZGdBaUFEUUFGQUF0QUJRQUlRQVBBQ2NBRFFBU0FBc0FHUUFKQUJJQUNRQVJBQVVBQ3dBRkFBd0FCUUFRQUFNQUJ3QUVBQW9BQlFBSkFBSUFDZ0FCQUFRQUZBQUxBQUlBQ3dBQkFBSUFBUUFIQUFNQUF3QUVBQXNBREFBTUFBd0FDd0FOQUEwQUF3QUtBQWtBQkFBZEFBWUFad0RUQWVjRE5BQ3hDbUlCOHhoWkFxZm9DMTkwVUdjVGhnQnVyd2Y3UFQwOVBiMDlBamdKdW04T2pEbGx4SFlVS1hBUHh6cTZ0QUJBeGdLOHlzVXZXQWdNUFQwOVBUMDlQU3M2TFQySGNnV1hXd0ZMb1NNRUVFbDVSRlZNS3ZPMFhROEV4RGRKTW5JZ1BpODl1ajAwTXN2Qlh4RVBBR1BDRHdCblFLb0Vid1J3QkhFRWNnUnpCSFFFZFFSMkJIY0VlQVI2QkhzRWZBUitCSUFFZ2ZuZEJRb0JZZ1VMQVdJRkRBRmlCTmNFMkFUWkJSQUZFUVV2QmRBTEZBc1ZEUGNOQncxM0RZY09NQTR4RGpNQjRCbGxISTBCMmdyYkFNRHBITGtRN1FIVkFQUk5RUUZuR1JVRWcweUVCMnVhSkVNQUpwSUJwb2I1QUVSU01BS05vQVhxYVFMUkJNQ3pFaUMrQVo0RVdSSkpGYkV1N1FEUUxBUnRFYmdFQ3hEd0FiL1J5QWsxQVY0bkQyY0VRUUtUQXpzQUdwb2JQZ0FhaEFHUENyeXNkeTBPQUt3QWZGSWNCQVFGVW1vQS9QdFpBRGtCSWFkVmoyVU1VZ3g1SWw0QU5RQzl2TElCREFIVUdWc1E4d0N6ZlFJYkdWY0NIQlpIQVo4Q0JBZ1hPaEc3QXFNWjRNNysxTTBVQVBETkFXc0MrbWNKRGU4QUFRQTk5emtFWExJQ3lRb3pBbzZsQW9iY1A1SnZqUUxGendLRDlnVS9PRDhGRVFDdEVRTDZiVytuQUtVRXZ6akRIc3VSeVV2T0ZIY2FjVXo1QXFJRlJTRTJrenNCRVFDdWFRTDVEUVRsY2dPNnR3U3BUaVVnQ3dJRkNBVVhCSFFFcVFWNnN3QVZ4VWxtVG1zQ3dqcXNQL3dLSlFtWGI3OTNVZ1pCRUJzbnBSRDNERE1CdFFFN0RlMUwyQVR4QmpzRXlSOTlHUmtQelpXY0NLVXQzUXp0SnVNdW9ZQmFJL1VxZ3dYdFMvUTgzUXROVVdnUFdRdGxDZU02WTRGT0F5RUJEU0tMQ3QwTk9RaHRFUE1LeVdzTjVSRkZCemtEMVVtYUFLVUhBUXNSSFRVVnRTWVFZcXdMQ1RsM0J2c2E5Z3VQSnE4VEtYcjhCZE1hSVFaTkFTa2Evd0RQTHVlRnNGb3hYQnhQWHdZREN5VWp4eFNvVUNBTkpVQzNlRWdhR3djVkpha0NrVU53U29kUk5oNlRJZlk4UFExbUxoTlJmQWYxUEFVWlR3dUJQSjVHcTBVT0VkSStqVDFJSWtsTUxBUTFmeXd2SjRzSnp3K0ZETGw4Y2dGWkNTRUpzUXh4RXpFUkZ6ZkZDRGtIR1MyWEpDY1ZDQ0ZHbFdDYUJQZWZBL01UMFFNTEJUOEpRUWNUQTdVY0xSTXVGU2tGRFlFazF3THpOdFV1c3dLUFZvQUJGd1hMRHlVZjN4QlFSK0FPNlFpYkFtVURneVhyQUMwVklRQVhJcHNJUTJNQVg0L1lVd1V1eXdqSGFtd2pkQU5uRk9kaEVYTUhrUTVYQjZjY014Vy9IT0Z3eUY0TGhnZ29vNjhKV3dGMUNaa0JYd1RqQ0FrMVc0eWdJRUZuVTR0WUdKc2dZVUUvWGZ3Q01ReGxGWjlFdllkNEFvc1BheEliQVRVQmN3YzVEUUVDZHhIdEVXc1FsUWpyaGdRMXRUUDRPaVVFVHlHRElCRUtKd05QYk00TEp5YjVEUGhwQWFNU1lnTU1ORDEzN21lcllMWWtGLzBIR1RMRlFXQWg4UXVTVDgwTW5CckJHRUpVTGhua0I3OEQ4eHJ6SitwQlZ3WC9BNk1ERXpwTk0rNEV2UXRwQ0lzSlB3QkpEcU1YQjljWWFncHhqTkFCTVlzQnQ1a0RWNUdEQW0rUEJqY0hDd0JuQzRjRmVlVUFIUUtuQ0tNQUJRRFBBMWNBT1FLdEI1MEFHUUNGUVFFOUF5Y3ZBU0hsQW84RGt3Z3h5d0dWTHdIektRUWJ3d3dWQVBjM2Jrb0N3N0VDZ0dwbW9nWGRXQUtPQWtrMUFVMGxCQVZPUjFFRHIzSGhBTnNBU3dZVDMwY0JGYXRLeXhyalF3SGZieXNBeHdEN0FBVTFCd1ZCQWMwQjgyMEF0d0ZmQ3pFSm9yTzFBVTNwS1FDREFCVnJBZGNDaVFEZEFEVUFmL0VCVXdCTkJWbjVCZE1DVDBrQkVURVlLMWRoQWJzREh3RXpBUTBBZVFiTGphWEpCeDhFYlFmVEFoQWJGZUVDN3k0SHRRRURJdDhUelVMRkFyM2VWYUZnQW1TQkFtSkNXMDJ2V3pjZ0FxSDNBbWlZQW1ZSkFwK0VPQnNMQW1ZN0FtWW1CRzRFZndOL0V3TitramtHT1hjWE9ZSTZJeU1DYkIwQ01qWTRDZ0p0eHdKdHJ1K0tNMmRGS3dGbkFONEE0UUJLQlFlWURJMEEvZ3ZDQUEyMUFuY3ZBbmFpUHdKNVMwTUNlTG9kWE50RnJrYlhBbncvQW5ySUFuMEpBbnp3QlZrRklFZ0FTSDFqSkFLQmJRS0FBQUtBQlFKL3JrbFlTbHNWRjByTUF0RUJBdERNU3ljRGlFOERoK1pFeFpFeUF2S2hYUU1EQTY1THprd3RKUVBQVFV4TnJ3S0xQd0tLMk1FYkJ4MURad1czQW80M0FvNWNRSmVCQW83WkFvNWNlRkcwVXpVS1V0UlVoUUtUK3dLVERBRHBBQnhWSGxXdlZkQUdMQnNwbFlZeTRYaG1SVHM1QXBlZkF1K3lXQ0dvQUZrbEFwYVBBcFo4bkFDcFdheGFDWUZOQURzQ2xyVUNsazVjUkZ6UkFwbkxBcGxrWE1wZEJ4a0NuSnM1d2pxZEFwd1dBcCtiQXA2NGlnQWREekVxRHdLZDhRS2VrZ0MxUFdFMFllOENudE1Db0c0QnFRS2VueDhDbms2bFk4aGtKeVVyQWlldkFpWitBcUQ3QXFCTUFxTGRBcUhFQXFZdkFxWE9BcWYvQUgwQ3AvSm9mR2l4QUFOSmFoeHEwUUtzNHdLc3JnS3Rad0t0QWdKWEhRSlYzQUt4NGRjREgwNXNsd0t5dlEwQ3N1Z1hiT0J0WTIxSVh3TWx6UUsyWERzL2JwQURLVVVDdUY0Q3VVY1ZBcmtxZDNBMmNPRUN2UmtDdTlwd2xnTXlFUUsraUhJQ0F6TnhBcjRhY3lKelR3TER5d0xEQkhPQ2RFczFSWFRnQXp5bkF6eWFBejIvQXNWOEFzWkhBc1lRaVFMSWFWRUN5RVFDeVU4Q3lTNENaSjBDM2RKNGVXRjRybmtsUzlBREdLTm5BZ0poOUJuemxTUjdDMTZTWHJzUkFzOXJBczlzTDB0VDB2TVRud0RHclFMUGN3RXA2Z05PRW41TEJRTGNKd0xiaWdMU1R3TlNYQU5UWHdFQkExV01nSWsvQU1zVzdXQkZnaHlDMDRMT2c0MEMyc2NDMmQ2RUVJUkpwendEaHFVQUx3TmtEb1p4V2ZrQVZRTGZaUUxldUhOM0F1SXY3UlFCOHpBbkFmU2JBZkxTaHdMcjh3THBjSGtDNnZrQzZ1UUErVWNCdVFMdWlRTHJuSmFxbHdNQzdqOERoZUNZZVhEZ2NhRUM4d01BYVFPT0ZwbVRBdmNUQTVGdUE1S0hBdmVZQXZuWkF2aG1taHlhcTdzM214NERuWU1DL3ZvQkd3QTVueHlmc3dNRmpRT21hZ09tMlFEUnhRTUdhcUdJb2dVSkF3eEpBdFFBUHdNQTRVRVhVd0VSOHdOckI1ZG5CUUNUTFN1M3I3M2JBWW1aRkg4UkJEa0IreWtGSVE2ZENaOEFrdjBUdFJRcnhRTDNMU2NBcFFDM0JibU9rUmMveHFkdFFTNFVKbzB1QVVNQmdQd0J0U1lBZFFNT0JHMEFMQUlXREtFQUFBb0NQUUpxQTkwRGZnU1JBU0JGQlNGOENnQUZBRVFBRXdBMkVnSjNBUUFGMVFOcjd3ckZBZ0QzQ3A4bnY3RzM1UUdSSVVGQ0Fla1VmeEUwd0lrQUJBQWJBRm9DUlFLRWl3QUdPbE02bEkxdEFMZzZqenJRQUkwNHdUcmNBS1VBNkFETEFUcUJPanM1L0RuNU8zYUpPbHM3bm9rNmJ6a1lBVllCTXdGc0JTODFYVFdlTmEwMVpqVjFOYlkxeFRXQ05aRTEwalhoTlo0MXJUWHVOZjAxc2pYQk5nSTJFVFhHTmRVMkZqWW5OZDQxN1RZdU5qMDJMalV0SVRZNk5qMDJQRGJKTndnRWtEeFhOamcyM1RjZ053ODJ5aUEzaVRjd0NnU3dQR2MySkRjWk4ydzZqVGNoUXRSREIwTGdRd3NjRHc4Sm15aHRLRkZWQmdEcGZ3RHBzQUQrbXhROTF3THBOU01BclFDOUJiZU9rUmRMeHB0ekJMOE1EQU1NQVFnREFBa0tDd3NMQ1FvR0JBVlZCSS9EdndEejliMjlrYVVDYjBRdHNSVE5MdDRlR0JjU0hBTVpGaFlaRWhZRUFSQUVCVUVjUVJ4QkhFRWNRUnhCSEVFYVFSeEJIRUZDU1R4QlBFbElTVWhCTmtNMlFUWWJOa2xJU1ZtQlZJZ0VMZ0VhSlprQzdhTUFvUUNqQmNHT214ZE54cnNCdndHSkFhUWNFWjBlUENrbE1BQWhNdkFJTUFMNTRnQzdCbThFZXNjanpRTXBBUlFwS2dEVUhxU3ZBajVHcXdyN1lyTVVBQ1Q5QU4zcnBGMjdIN2ZzZC90d1B0NGwrVVcxeVFZS0J0MkNneTdxSnBHaUxjZEUyUDFjUVNJbVVicUo2SUNIMjdINGtuUU1JUk1yRmtIdTNzeDZ0QzM1WStlTEloNGU0Q01LSjREZnlWKzhtZnRhNDk5UkNBSjB4ZmVaUjhQc29ZT0FwdmE5cGpHbjRQaHZ5WlM3L2g1Skx1aGF1Y2ZqdVUrWjU4NHd3cU5PNGhXWW1hQkNjamdRUGFsZTFiam9Iek1VYnV0L3pUZ3hIeEJuQXlyZEtwRjRJUk1BU0xCdEQvanZpeUxlQ2dqOHR3V2pBZDNIY2hOL3VxYWVSWWVISmdsN0pFWTkvY1RydnRmeWJ4L3IzWS9OdHhKOWRwK01UVm1pUzlid0JINzNzOERpNTYvTWErbVRQTUhxNFQxeUVHMWZXY3FyMHUraHJHbkpFdlUxSkpBbS9tYVFTcktyYXpJeXZTa0RGa2o4VVVsZkJxOGJhbmlUR1BuZzZZWlJMNjYxckROdzR3LzFnMmZpZ0cwSWhYbkw3d29zZC9zVk5vNWRZU21NQlRQNWM3cllMalJkQ3dnOHF1d2xqT01QZjYzRDhJQ0FMMHI3MVhSaXlGSGRnd0hid2ZnblBPZjRMempmMnYraitJaURIRzJpc3A1eVVuelNEeURSYjRpL1ZzMHFIU0hxOFBpRVEvSm5CUDdQeG5qTjBqNmdUNEFWQWVSeC8xbzlWbkVVbFV3dkZyekpxSGs5anhBdzRzWXhDbnJ4YWVCZENGRktibkU3eit4NTRGNVc3WlpzVTZreDhRb2N1bDZGb0FISHkwMUZHTC9ubmU2MW1uNCt1WVhmUTFVY2NuK0hNTEtFK2NaelQ4QkIxRTNGUnNrT2dKclJzcTI1cmF1TG04K3VhbVhwa1MvYlR5Nnkxd0RiQ3JXNGVENTMya1RXcnROVW1WVlpPSW4vQysvSlI5S1ZSNWlHOVRZOGlhVDY3dWJtL3doTDF4Yktab3F0WSthNmZOeE1KcmcyMTFiR1lKRFVrWU1OV0EwQk1CKys5ek9tNkVpazRyb3FzOUNDRUZXMGx5QUswUGJ2bHp2b3hyWnVZL09FaE5XL2wvNjNVMTVPZC9SU3ZtRHZYcEdMaVZtZUdpNVBEU0gyYll6NW8yZzZ3RkRRMkZiWmdZZ1RGOHJQbHZBMWlmalpEM05MdEZkWGRwU0lKdmdLUjdHcGpKV0c3R1pHYXdQb21JSDhCNXRVbXRISDlMcE0rL0tRS3VuRVBhMUdpUWtDWHY0Q25tOURMT1JvMmpvaWNIZFBEWjY0b2JRclBaNWJncWNra2owRzYvTkVpUFlCWTRiQ2tMN1c4RzVZenNVYjZHYWtGanlrU1BrVDdKR2VMZUI2dUpPR01tK3g3TjM4MUJDRGZiSkZ4MGR0TGdWOVE0NzdCZkwxZnZpdFg1YW5WL29ZZnhlWWwrZUY1eDViQjgrRXAvTDJuc21kNTZhS0Y0YUFENEdiSldzZEt5QlcyMnhFbUFEM1hkYnRzTXlBRm9SNW1PbGEwZ0VkOVUvWVZCN3p2SEdwSGJRb25heTlTdjBiUThpWjhwaWFYVnJLYzVBRzFBbXFxZ2FFdnpIU1AyV3V4N2FaVFdoNnF1VkRWVTAxSnRNSVZSZENGd2xTYmJxcWhvRmx5enNvdFF6UmV4RnZaL01xVVNGdTNPaFJJdU5CYnVmdkJwZFZnYjhYZEdKNDgvbEpQQ1o3ZHNPdWpUVGJLUFNFdkdYa09uRzJYZGk4L25NM0VNUnFJVGQ1UWVVN2lPaktxQzdVUkpZNlRuTHNIaWoyMnhBSEtuVlJENU1EdEJZbm9HRnFaR01EbVhDVzZPaitCQVd3MTRoRVNZL3hMRjZiTGt1MDZBSGtpWFRIUENGWjBmOVlTcXFvMjdlQWhoUzY3T3JBMkhldDRNOUpNM2ptL3lSWDZiWXhuZm16WWw1cVFkSHhOMDhGc051V0RyV2Q0dk1VWTJRRDNocjh2UzczU0NUa0ZvWFpSM3hOek9RdDhkLzZIZmpCbVhxdnJFNkVHa0x6SzZZSzJVMi9rc1UvaVVIK0x2VklzSkkrcmkyQUwva2xvK1NoZER5ZnM1QTgzaTJwcmtNczUxSUtSN1pjcWpaSmk1WDMrYmQ4R2x5V3Z0ZGR4S0VvRXFTZ0VPN0E4aklnZjJuSDBoOEZqTTdvQjZ5dGUzWDVtcEwwaS9FNFJ4MENvdEtuSUxKai92SnFvNFZrUFE5M2pSdFJWZmFpdFFQcWxkbDV4UllQcTgzODdaMERjblp2T2VJT04wSHQxK1AyN2tGTEdRSWNMQlg0Rkczc2ZmY2NOSGg1Y1BmenA5SU5vUnRxVnRkVmlKZmc4UmpuWGlJei9NTnFFTjZ6dnpYM2hNenlXQzdvU29YSVQxNHViYzBhYlBYOFJwOUdWYTVOSS84aXYrNmVsYTFvVG5jYmRpbVJLbnJiUmZmRFIvWDRuSCtiZ3FBdUhXbDdoT2FlWFBXVnpJZVJsN2dhK0p6RDRTeDNtbGovcTZSYS9FMkhoRGYyMWVFelRMTkdmQ1pzWSsveXhaelF6SUF1aWpHNjVpaTRPL3dhQUpDckVKYVdkL0RSQUtNUTU2NzhEdzVBVDdSQ0t6ZGFkSXdkOExzRCtEZ1BCQVNtV3NVbGY4UjBrMXcvMms0bE8yV3BiNHpNSTZFSlZKczB4ay93bjgvZlJVUHFyREtoYmpIUjQxU3FnRk14NVJHTVB1ZHVGd2x1NWxLODl0VzExc1RxaVgvNUVmR3M1bk8reTlGS3ZnWEtQT0VtZ0UwNUVLTkw2U2piM3hTNDBIM0JWUGhtMEVTT1pnQWpab3ltYzhiZTBpbkRWbzRKZEpWZitOS2QzdE4vQ2FCN0dTaGhIMjdxZjk1Tm9GWlZYLzZaa1IybFgrQ2dXclEySU5na2grYmJNejY4K3VKM0Nsc2g4SFNNUEVRdEF0K0JCRTZmWERhYjdLSWxzS3hVMWxJWFcvS1dWc3RwZFBhbkowcGRYcFFpbkR5VVFqdFk3WlZjZmllY1J4UkRNQVVoSEZVMmNFYWNpUStodGlQTVB4MWtkdnRXRzlUNDR3M3IwMzdsakhCRkpkWVIwcjU1cXZNUml4dEFFRkpBcUE0VDFFUzg3RkF4N1Vvelhhc3l0ZzhNZnRaWXQwcmpZZ0xlNkVKNWFXdnkycXNjQlNCUTd5ZWhvSklBM3dJSVo5dWtma3lCYjZxbnVlNWtvOFc1MHJwVjRrWHFXakk1bmJHUlhyTlcwdEJaSFhsWTQ4blNnY1VYQkhXVDRHY2dMWkpvTGxLSm5WOTZrQ1lwcTllV0hoN3hKemtDQXlyUXVRNUFKMHFxL3VaM3RvSmdsTnRlcmV2K1FtMEtYeFBnLytZYkZSSmRmaGJwMXdPblZPRVlkVkhUeWE2Q3RPMGFmaEVhQmh4M29Id0NiNUtxNlJ3SER6Rk1sMnZmakw4R3d6Y0NvVGo3d1plK1VGbllEVjJ5S3BQVTlkYmEyOWdZQmROcUpnL0tYb3pPK0NKVGxLbWxLaG5xVGY1ZG9lUzM1RFpGVitjWUpRVmpkK29WWS9HdGMvNlhQelV4YjFnTXFmNmNFak5Ob1JDOEFPYnJwK2Z4MGNWdEd1NGZmQzJUZ1hSQzh6UGw4bW9VSENCNUhaMjVkODdtbHNpaUswYU53QnRjRVFqUk5CVC9Rclhidy84YVZYZEtNSG45RXFZRUtFeXhTR1RwWVFPYWVzMUcxUXE4cERncWtadGxPMkhSeUNYcG1lTTdUU3JSUGtBaDAwNEJmaXNWcEY2elA0NG4ySnZ4ei9nT1ZvY05DeXk5VjZsa29kMjhRTTRwYmFNdlZKaWdEL3czQnJzalNKclhscWM0dWxCWU9DY2VpQk40Yi9nSGFqWXl1cGJoRXQ2M2E2MTlBeTR3c0w2YTZ3NkIrQTdUbm95RTdCbGlXSEpmelZ4eElLTS9XM00vSjhCeDk5T3A4NjNROGVOdUlNR1J4KytWYllmam0rVkdZQkEzQXAvS0V1L3d4Qk5CcEpKbmN3SFBHNDVWOEdoOThaSXJHQ2MyME13aWpHb3daYmNTN2QxbkVnY09XNWNkZFpwSEwyWFBBSVJiQ29saWhlWnpYVHZCeFpPWTNpTVNEU0tEcklDeUovaVFzMXZkcGxWZEgvSnJMSnNRMmp0VG5mQ3JJVElnaHEzS0ZYM3FBZ0xXQUlwOElmZk5TZFRZcHRuYkdmYzhzK3FjcjN6eXp5SHAxYUpnK2p4VEY0a0Qxcnk1V2F1djVWM3huT0d3VEZlY056WFNMSEJXMjAvcENRams0dW9yRDBwbEloTVNUYzc5Ky9yNFJLUENsUllUQllleDFPYjVjcnRmdlJRQkJ2NnJlLzZGaHRDcXRkdWFnNjdnbHFSQTc3LzN1bGJsaDlZUnRNZER4a0N5SkRlTm5BdUNMUFFGbWRSUldKdEgyMFo4RHN0ZkpmKzVvajVTU0I2NGQwaUY1L1lhNEtmVFd4Zml2ajlBcDIvemJZYVRvLzFnTzN0TTZSWXNDWmhhck1CRnI3Rm02MW1MU3JRbkVJNE9GMWdiVlM0ay9KRTlVb3RPcm5MSlp1c3dvV29kQ1NWOHpieWJrSlNWSVA3bjhVYUU5eENSMzlySlptZjI3SE9BUFZPR2M5cGRrUVVjUnJJMHF5VkY5WjNqMVJIRGJ4SWZ3Yld6bVBWandJZFBKdnRtQll3RVFJVXNJVzFTOTM5aGNWaWtLMDBvelBSSTAyY3FoelZVTnpwT3hWZHJ3UlB2bGgxYUlPZjB4RkVxRDNZa0duQ25GYWgvY0ZOM0oyZ0I3TitiWlNHYXd3a0tGdTF0cFFNcnAxVysyN1lOa3lUMFRwY0ZwVHFnT3FxTGFicmdjQ1VQeGg5N21SRU9HeTR4SXR6UTl4U2w2cnErOEJac0hjclFGUmVTK1FlTXhKM1A2Q25MOUVQL2VPTERqdW1MaHZyY1FycFBpa25zb2ZiekJ2OWdUUDBsVStUSVZ3RTZFN0NjS2ZUMzZxK1ppRU9ISjlheWYwZHlVSkxlekFiMk04YU5Id2QwK09KbXNWZ1R6UldBJztcblxuLy8gaHR0cHM6Ly91bmljb2RlLm9yZy9yZXBvcnRzL3RyMTUvXHJcbi8vIGZvciByZWZlcmVuY2UgaW1wbGVtZW50YXRpb25cclxuLy8gc2VlOiAvZGVyaXZlL25mLmpzXHJcblxyXG5cclxuLy8gYWxnb3JpdGhtaWMgaGFuZ3VsXHJcbi8vIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL3ZlcnNpb25zL1VuaWNvZGUxNS4wLjAvY2gwMy5wZGYgKHBhZ2UgMTQ0KVxyXG5jb25zdCBTMCA9IDB4QUMwMDtcclxuY29uc3QgTDAgPSAweDExMDA7XHJcbmNvbnN0IFYwID0gMHgxMTYxO1xyXG5jb25zdCBUMCA9IDB4MTFBNztcclxuY29uc3QgTF9DT1VOVCA9IDE5O1xyXG5jb25zdCBWX0NPVU5UID0gMjE7XHJcbmNvbnN0IFRfQ09VTlQgPSAyODtcclxuY29uc3QgTl9DT1VOVCA9IFZfQ09VTlQgKiBUX0NPVU5UO1xyXG5jb25zdCBTX0NPVU5UID0gTF9DT1VOVCAqIE5fQ09VTlQ7XHJcbmNvbnN0IFMxID0gUzAgKyBTX0NPVU5UO1xyXG5jb25zdCBMMSA9IEwwICsgTF9DT1VOVDtcclxuY29uc3QgVjEgPSBWMCArIFZfQ09VTlQ7XHJcbmNvbnN0IFQxID0gVDAgKyBUX0NPVU5UO1xyXG5cclxuZnVuY3Rpb24gdW5wYWNrX2NjKHBhY2tlZCkge1xyXG5cdHJldHVybiAocGFja2VkID4+IDI0KSAmIDB4RkY7XHJcbn1cclxuZnVuY3Rpb24gdW5wYWNrX2NwKHBhY2tlZCkge1xyXG5cdHJldHVybiBwYWNrZWQgJiAweEZGRkZGRjtcclxufVxyXG5cclxubGV0IFNISUZURURfUkFOSywgRVhDTFVTSU9OUywgREVDT01QLCBSRUNPTVA7XHJcblxyXG4vLyBleHBvcnQgZnVuY3Rpb24gbmZfZGVpbml0KCkge1xyXG4vLyBcdGlmICghU0hJRlRFRF9SQU5LKSByZXR1cm47XHJcbi8vIFx0U0hJRlRFRF9SQU5LID0gRVhDTFVTSU9OUyA9IERFQ09NUCA9IFJFQ09NUCA9IHVuZGVmaW5lZDtcclxuLy8gfVxyXG5cclxuZnVuY3Rpb24gaW5pdCQxKCkge1xyXG5cdC8vY29uc29sZS50aW1lKCduZicpO1xyXG5cdGxldCByID0gcmVhZF9jb21wcmVzc2VkX3BheWxvYWQoQ09NUFJFU1NFRCk7XHJcblx0U0hJRlRFRF9SQU5LID0gbmV3IE1hcChyZWFkX3NvcnRlZF9hcnJheXMocikuZmxhdE1hcCgodiwgaSkgPT4gdi5tYXAoeCA9PiBbeCwgKGkrMSkgPDwgMjRdKSkpOyAvLyBwcmUtc2hpZnRlZFxyXG5cdEVYQ0xVU0lPTlMgPSBuZXcgU2V0KHJlYWRfc29ydGVkKHIpKTtcclxuXHRERUNPTVAgPSBuZXcgTWFwKCk7XHJcblx0UkVDT01QID0gbmV3IE1hcCgpO1xyXG5cdGZvciAobGV0IFtjcCwgY3BzXSBvZiByZWFkX21hcHBlZChyKSkge1xyXG5cdFx0aWYgKCFFWENMVVNJT05TLmhhcyhjcCkgJiYgY3BzLmxlbmd0aCA9PSAyKSB7XHJcblx0XHRcdGxldCBbYSwgYl0gPSBjcHM7XHJcblx0XHRcdGxldCBidWNrZXQgPSBSRUNPTVAuZ2V0KGEpO1xyXG5cdFx0XHRpZiAoIWJ1Y2tldCkge1xyXG5cdFx0XHRcdGJ1Y2tldCA9IG5ldyBNYXAoKTtcclxuXHRcdFx0XHRSRUNPTVAuc2V0KGEsIGJ1Y2tldCk7XHJcblx0XHRcdH1cclxuXHRcdFx0YnVja2V0LnNldChiLCBjcCk7XHJcblx0XHR9XHJcblx0XHRERUNPTVAuc2V0KGNwLCBjcHMucmV2ZXJzZSgpKTsgLy8gc3RvcmVkIHJldmVyc2VkXHJcblx0fVxyXG5cdC8vY29uc29sZS50aW1lRW5kKCduZicpO1xyXG5cdC8vIDIwMjMwOTA1OiAxMW1zXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzX2hhbmd1bChjcCkge1xyXG5cdHJldHVybiBjcCA+PSBTMCAmJiBjcCA8IFMxO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb21wb3NlX3BhaXIoYSwgYikge1xyXG5cdGlmIChhID49IEwwICYmIGEgPCBMMSAmJiBiID49IFYwICYmIGIgPCBWMSkge1xyXG5cdFx0cmV0dXJuIFMwICsgKGEgLSBMMCkgKiBOX0NPVU5UICsgKGIgLSBWMCkgKiBUX0NPVU5UO1xyXG5cdH0gZWxzZSBpZiAoaXNfaGFuZ3VsKGEpICYmIGIgPiBUMCAmJiBiIDwgVDEgJiYgKGEgLSBTMCkgJSBUX0NPVU5UID09IDApIHtcclxuXHRcdHJldHVybiBhICsgKGIgLSBUMCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdGxldCByZWNvbXAgPSBSRUNPTVAuZ2V0KGEpO1xyXG5cdFx0aWYgKHJlY29tcCkge1xyXG5cdFx0XHRyZWNvbXAgPSByZWNvbXAuZ2V0KGIpO1xyXG5cdFx0XHRpZiAocmVjb21wKSB7XHJcblx0XHRcdFx0cmV0dXJuIHJlY29tcDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIC0xO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gZGVjb21wb3NlZChjcHMpIHtcclxuXHRpZiAoIVNISUZURURfUkFOSykgaW5pdCQxKCk7XHJcblx0bGV0IHJldCA9IFtdO1xyXG5cdGxldCBidWYgPSBbXTtcclxuXHRsZXQgY2hlY2tfb3JkZXIgPSBmYWxzZTtcclxuXHRmdW5jdGlvbiBhZGQoY3ApIHtcclxuXHRcdGxldCBjYyA9IFNISUZURURfUkFOSy5nZXQoY3ApO1xyXG5cdFx0aWYgKGNjKSB7XHJcblx0XHRcdGNoZWNrX29yZGVyID0gdHJ1ZTtcclxuXHRcdFx0Y3AgfD0gY2M7XHJcblx0XHR9XHJcblx0XHRyZXQucHVzaChjcCk7XHJcblx0fVxyXG5cdGZvciAobGV0IGNwIG9mIGNwcykge1xyXG5cdFx0d2hpbGUgKHRydWUpIHtcclxuXHRcdFx0aWYgKGNwIDwgMHg4MCkge1xyXG5cdFx0XHRcdHJldC5wdXNoKGNwKTtcclxuXHRcdFx0fSBlbHNlIGlmIChpc19oYW5ndWwoY3ApKSB7XHJcblx0XHRcdFx0bGV0IHNfaW5kZXggPSBjcCAtIFMwO1xyXG5cdFx0XHRcdGxldCBsX2luZGV4ID0gc19pbmRleCAvIE5fQ09VTlQgfCAwO1xyXG5cdFx0XHRcdGxldCB2X2luZGV4ID0gKHNfaW5kZXggJSBOX0NPVU5UKSAvIFRfQ09VTlQgfCAwO1xyXG5cdFx0XHRcdGxldCB0X2luZGV4ID0gc19pbmRleCAlIFRfQ09VTlQ7XHJcblx0XHRcdFx0YWRkKEwwICsgbF9pbmRleCk7XHJcblx0XHRcdFx0YWRkKFYwICsgdl9pbmRleCk7XHJcblx0XHRcdFx0aWYgKHRfaW5kZXggPiAwKSBhZGQoVDAgKyB0X2luZGV4KTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRsZXQgbWFwcGVkID0gREVDT01QLmdldChjcCk7XHJcblx0XHRcdFx0aWYgKG1hcHBlZCkge1xyXG5cdFx0XHRcdFx0YnVmLnB1c2goLi4ubWFwcGVkKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0YWRkKGNwKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKCFidWYubGVuZ3RoKSBicmVhaztcclxuXHRcdFx0Y3AgPSBidWYucG9wKCk7XHJcblx0XHR9XHJcblx0fVxyXG5cdGlmIChjaGVja19vcmRlciAmJiByZXQubGVuZ3RoID4gMSkge1xyXG5cdFx0bGV0IHByZXZfY2MgPSB1bnBhY2tfY2MocmV0WzBdKTtcclxuXHRcdGZvciAobGV0IGkgPSAxOyBpIDwgcmV0Lmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGxldCBjYyA9IHVucGFja19jYyhyZXRbaV0pO1xyXG5cdFx0XHRpZiAoY2MgPT0gMCB8fCBwcmV2X2NjIDw9IGNjKSB7XHJcblx0XHRcdFx0cHJldl9jYyA9IGNjO1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGxldCBqID0gaS0xO1xyXG5cdFx0XHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0XHRcdGxldCB0bXAgPSByZXRbaisxXTtcclxuXHRcdFx0XHRyZXRbaisxXSA9IHJldFtqXTtcclxuXHRcdFx0XHRyZXRbal0gPSB0bXA7XHJcblx0XHRcdFx0aWYgKCFqKSBicmVhaztcclxuXHRcdFx0XHRwcmV2X2NjID0gdW5wYWNrX2NjKHJldFstLWpdKTtcclxuXHRcdFx0XHRpZiAocHJldl9jYyA8PSBjYykgYnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdFx0cHJldl9jYyA9IHVucGFja19jYyhyZXRbaV0pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gcmV0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb21wb3NlZF9mcm9tX2RlY29tcG9zZWQodikge1xyXG5cdGxldCByZXQgPSBbXTtcclxuXHRsZXQgc3RhY2sgPSBbXTtcclxuXHRsZXQgcHJldl9jcCA9IC0xO1xyXG5cdGxldCBwcmV2X2NjID0gMDtcclxuXHRmb3IgKGxldCBwYWNrZWQgb2Ygdikge1xyXG5cdFx0bGV0IGNjID0gdW5wYWNrX2NjKHBhY2tlZCk7XHJcblx0XHRsZXQgY3AgPSB1bnBhY2tfY3AocGFja2VkKTtcclxuXHRcdGlmIChwcmV2X2NwID09IC0xKSB7XHJcblx0XHRcdGlmIChjYyA9PSAwKSB7XHJcblx0XHRcdFx0cHJldl9jcCA9IGNwO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHJldC5wdXNoKGNwKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIGlmIChwcmV2X2NjID4gMCAmJiBwcmV2X2NjID49IGNjKSB7XHJcblx0XHRcdGlmIChjYyA9PSAwKSB7XHJcblx0XHRcdFx0cmV0LnB1c2gocHJldl9jcCwgLi4uc3RhY2spO1xyXG5cdFx0XHRcdHN0YWNrLmxlbmd0aCA9IDA7XHJcblx0XHRcdFx0cHJldl9jcCA9IGNwO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHN0YWNrLnB1c2goY3ApO1xyXG5cdFx0XHR9XHJcblx0XHRcdHByZXZfY2MgPSBjYztcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGxldCBjb21wb3NlZCA9IGNvbXBvc2VfcGFpcihwcmV2X2NwLCBjcCk7XHJcblx0XHRcdGlmIChjb21wb3NlZCA+PSAwKSB7XHJcblx0XHRcdFx0cHJldl9jcCA9IGNvbXBvc2VkO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHByZXZfY2MgPT0gMCAmJiBjYyA9PSAwKSB7XHJcblx0XHRcdFx0cmV0LnB1c2gocHJldl9jcCk7XHJcblx0XHRcdFx0cHJldl9jcCA9IGNwO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHN0YWNrLnB1c2goY3ApO1xyXG5cdFx0XHRcdHByZXZfY2MgPSBjYztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAocHJldl9jcCA+PSAwKSB7XHJcblx0XHRyZXQucHVzaChwcmV2X2NwLCAuLi5zdGFjayk7XHRcclxuXHR9XHJcblx0cmV0dXJuIHJldDtcclxufVxyXG5cclxuLy8gbm90ZTogY3BzIGNhbiBiZSBpdGVyYWJsZVxyXG5mdW5jdGlvbiBuZmQoY3BzKSB7XHJcblx0cmV0dXJuIGRlY29tcG9zZWQoY3BzKS5tYXAodW5wYWNrX2NwKTtcclxufVxyXG5mdW5jdGlvbiBuZmMoY3BzKSB7XHJcblx0cmV0dXJuIGNvbXBvc2VkX2Zyb21fZGVjb21wb3NlZChkZWNvbXBvc2VkKGNwcykpO1xyXG59XG5cbmNvbnN0IEhZUEhFTiA9IDB4MkQ7XHJcbmNvbnN0IFNUT1AgPSAweDJFO1xyXG5jb25zdCBTVE9QX0NIID0gJy4nO1xyXG5jb25zdCBGRTBGID0gMHhGRTBGO1xyXG5jb25zdCBVTklRVUVfUEggPSAxO1xyXG5cclxuLy8gMjAyMzA5MTM6IHJlcGxhY2UgWy4uLnZdIHdpdGggQXJyYXlfZnJvbSh2KSB0byBhdm9pZCBsYXJnZSBzcHJlYWRzXHJcbmNvbnN0IEFycmF5X2Zyb20gPSB4ID0+IEFycmF5LmZyb20oeCk7IC8vIEFycmF5LmZyb20uYmluZChBcnJheSk7XHJcblxyXG5mdW5jdGlvbiBncm91cF9oYXNfY3AoZywgY3ApIHtcclxuXHQvLyAyMDIzMDkxMzoga2VlcCBwcmltYXJ5IGFuZCBzZWNvbmRhcnkgZGlzdGluY3QgaW5zdGVhZCBvZiBjcmVhdGluZyB2YWxpZCB1bmlvblxyXG5cdHJldHVybiBnLlAuaGFzKGNwKSB8fCBnLlEuaGFzKGNwKTtcclxufVxyXG5cclxuY2xhc3MgRW1vamkgZXh0ZW5kcyBBcnJheSB7XHJcblx0Z2V0IGlzX2Vtb2ppKCkgeyByZXR1cm4gdHJ1ZTsgfSAvLyBmcmVlIHRhZ2dpbmcgc3lzdGVtXHJcbn1cclxuXHJcbmxldCBNQVBQRUQsIElHTk9SRUQsIENNLCBOU00sIEVTQ0FQRSwgTkZDX0NIRUNLLCBHUk9VUFMsIFdIT0xFX1ZBTElELCBXSE9MRV9NQVAsIFZBTElELCBFTU9KSV9MSVNULCBFTU9KSV9ST09UO1xyXG5cclxuLy8gZXhwb3J0IGZ1bmN0aW9uIGVuc19kZWluaXQoKSB7XHJcbi8vIFx0bmZfZGVpbml0KCk7XHJcbi8vIFx0aWYgKCFNQVBQRUQpIHJldHVybjtcclxuLy8gXHRNQVBQRUQgPSBJR05PUkVEID0gQ00gPSBOU00gPSBFU0NBUEUgPSBORkNfQ0hFQ0sgPSBHUk9VUFMgPSBXSE9MRV9WQUxJRCA9IFdIT0xFX01BUCA9IFZBTElEID0gRU1PSklfTElTVCA9IEVNT0pJX1JPT1QgPSB1bmRlZmluZWQ7XHJcbi8vIH1cclxuXHJcbmZ1bmN0aW9uIGluaXQoKSB7XHJcblx0aWYgKE1BUFBFRCkgcmV0dXJuO1xyXG5cdFxyXG5cdGxldCByID0gcmVhZF9jb21wcmVzc2VkX3BheWxvYWQoQ09NUFJFU1NFRCQxKTtcclxuXHRjb25zdCByZWFkX3NvcnRlZF9hcnJheSA9ICgpID0+IHJlYWRfc29ydGVkKHIpO1xyXG5cdGNvbnN0IHJlYWRfc29ydGVkX3NldCA9ICgpID0+IG5ldyBTZXQocmVhZF9zb3J0ZWRfYXJyYXkoKSk7XHJcblx0Y29uc3Qgc2V0X2FkZF9tYW55ID0gKHNldCwgdikgPT4gdi5mb3JFYWNoKHggPT4gc2V0LmFkZCh4KSk7XHJcblxyXG5cdE1BUFBFRCA9IG5ldyBNYXAocmVhZF9tYXBwZWQocikpOyBcclxuXHRJR05PUkVEID0gcmVhZF9zb3J0ZWRfc2V0KCk7IC8vIGlnbm9yZWQgY2hhcmFjdGVycyBhcmUgbm90IHZhbGlkLCBzbyBqdXN0IHJlYWQgcmF3IGNvZGVwb2ludHNcclxuXHJcblx0LypcclxuXHQvLyBkaXJlY3QgaW5jbHVkZSBmcm9tIHBheWxvYWQgaXMgc21hbGxlciB0aGFuIHRoZSBkZWNvbXByZXNzaW9uIGNvZGVcclxuXHRjb25zdCBGRU5DRUQgPSBuZXcgTWFwKHJlYWRfYXJyYXlfd2hpbGUoKCkgPT4ge1xyXG5cdFx0bGV0IGNwID0gcigpO1xyXG5cdFx0aWYgKGNwKSByZXR1cm4gW2NwLCByZWFkX3N0cihyKCkpXTtcclxuXHR9KSk7XHJcblx0Ki9cclxuXHQvLyAyMDIzMDIxNzogd2Ugc3RpbGwgbmVlZCBhbGwgQ00gZm9yIHByb3BlciBlcnJvciBmb3JtYXR0aW5nXHJcblx0Ly8gYnV0IG5vcm0gb25seSBuZWVkcyBOU00gc3Vic2V0IHRoYXQgYXJlIHBvdGVudGlhbGx5LXZhbGlkXHJcblx0Q00gPSByZWFkX3NvcnRlZF9hcnJheSgpO1xyXG5cdE5TTSA9IG5ldyBTZXQocmVhZF9zb3J0ZWRfYXJyYXkoKS5tYXAoaSA9PiBDTVtpXSkpO1xyXG5cdENNID0gbmV3IFNldChDTSk7XHJcblx0XHJcblx0RVNDQVBFID0gcmVhZF9zb3J0ZWRfc2V0KCk7IC8vIGNoYXJhY3RlcnMgdGhhdCBzaG91bGQgbm90IGJlIHByaW50ZWRcclxuXHRORkNfQ0hFQ0sgPSByZWFkX3NvcnRlZF9zZXQoKTsgLy8gb25seSBuZWVkZWQgdG8gaWxsdXN0cmF0ZSBlbnNfdG9rZW5pemUoKSB0cmFuc2Zvcm1hdGlvbnNcclxuXHJcblx0bGV0IGNodW5rcyA9IHJlYWRfc29ydGVkX2FycmF5cyhyKTtcclxuXHRsZXQgdW5yZXN0cmljdGVkID0gcigpO1xyXG5cdC8vY29uc3QgcmVhZF9jaHVua2VkID0gKCkgPT4gbmV3IFNldChyZWFkX3NvcnRlZF9hcnJheSgpLmZsYXRNYXAoaSA9PiBjaHVua3NbaV0pLmNvbmNhdChyZWFkX3NvcnRlZF9hcnJheSgpKSk7XHJcblx0Y29uc3QgcmVhZF9jaHVua2VkID0gKCkgPT4ge1xyXG5cdFx0Ly8gMjAyMzA5MjE6IGJ1aWxkIHNldCBpbiBwYXJ0cywgMnggZmFzdGVyXHJcblx0XHRsZXQgc2V0ID0gbmV3IFNldCgpO1xyXG5cdFx0cmVhZF9zb3J0ZWRfYXJyYXkoKS5mb3JFYWNoKGkgPT4gc2V0X2FkZF9tYW55KHNldCwgY2h1bmtzW2ldKSk7XHJcblx0XHRzZXRfYWRkX21hbnkoc2V0LCByZWFkX3NvcnRlZF9hcnJheSgpKTtcclxuXHRcdHJldHVybiBzZXQ7IFxyXG5cdH07XHJcblx0R1JPVVBTID0gcmVhZF9hcnJheV93aGlsZShpID0+IHtcclxuXHRcdC8vIG1pbmlmaWVyIHByb3BlcnR5IG1hbmdsaW5nIHNlZW1zIHVuc2FmZVxyXG5cdFx0Ly8gc28gdGhlc2UgYXJlIG1hbnVhbGx5IHJlbmFtZWQgdG8gc2luZ2xlIGNoYXJzXHJcblx0XHRsZXQgTiA9IHJlYWRfYXJyYXlfd2hpbGUocikubWFwKHggPT4geCsweDYwKTtcclxuXHRcdGlmIChOLmxlbmd0aCkge1xyXG5cdFx0XHRsZXQgUiA9IGkgPj0gdW5yZXN0cmljdGVkOyAvLyB1bnJlc3RyaWN0ZWQgdGhlbiByZXN0cmljdGVkXHJcblx0XHRcdE5bMF0gLT0gMzI7IC8vIGNhcGl0YWxpemVcclxuXHRcdFx0TiA9IHN0cl9mcm9tX2NwcyhOKTtcclxuXHRcdFx0aWYgKFIpIE49YFJlc3RyaWN0ZWRbJHtOfV1gO1xyXG5cdFx0XHRsZXQgUCA9IHJlYWRfY2h1bmtlZCgpOyAvLyBwcmltYXJ5XHJcblx0XHRcdGxldCBRID0gcmVhZF9jaHVua2VkKCk7IC8vIHNlY29uZGFyeVxyXG5cdFx0XHRsZXQgTSA9ICFyKCk7IC8vIG5vdC13aGl0ZWxpc3RlZCwgY2hlY2sgZm9yIE5TTVxyXG5cdFx0XHQvLyAqKiogdGhpcyBjb2RlIGN1cnJlbnRseSBpc24ndCBuZWVkZWQgKioqXHJcblx0XHRcdC8qXHJcblx0XHRcdGxldCBWID0gWy4uLlAsIC4uLlFdLnNvcnQoKGEsIGIpID0+IGEtYik7IC8vIGRlcml2ZTogc29ydGVkIHZhbGlkXHJcblx0XHRcdGxldCBNID0gcigpLTE7IC8vIG51bWJlciBvZiBjb21iaW5pbmcgbWFya1xyXG5cdFx0XHRpZiAoTSA8IDApIHsgLy8gd2hpdGVsaXN0ZWRcclxuXHRcdFx0XHRNID0gbmV3IE1hcChyZWFkX2FycmF5X3doaWxlKCgpID0+IHtcclxuXHRcdFx0XHRcdGxldCBpID0gcigpO1xyXG5cdFx0XHRcdFx0aWYgKGkpIHJldHVybiBbVltpLTFdLCByZWFkX2FycmF5X3doaWxlKCgpID0+IHtcclxuXHRcdFx0XHRcdFx0bGV0IHYgPSByZWFkX2FycmF5X3doaWxlKHIpO1xyXG5cdFx0XHRcdFx0XHRpZiAodi5sZW5ndGgpIHJldHVybiB2Lm1hcCh4ID0+IHgtMSk7XHJcblx0XHRcdFx0XHR9KV07XHJcblx0XHRcdFx0fSkpO1xyXG5cdFx0XHR9Ki9cclxuXHRcdFx0cmV0dXJuIHtOLCBQLCBRLCBNLCBSfTtcclxuXHRcdH1cclxuXHR9KTtcclxuXHJcblx0Ly8gZGVjb2RlIGNvbXByZXNzZWQgd2hvbGVzXHJcblx0V0hPTEVfVkFMSUQgPSByZWFkX3NvcnRlZF9zZXQoKTtcclxuXHRXSE9MRV9NQVAgPSBuZXcgTWFwKCk7XHJcblx0bGV0IHdob2xlcyA9IHJlYWRfc29ydGVkX2FycmF5KCkuY29uY2F0KEFycmF5X2Zyb20oV0hPTEVfVkFMSUQpKS5zb3J0KChhLCBiKSA9PiBhLWIpOyAvLyBtdXN0IGJlIHNvcnRlZFxyXG5cdHdob2xlcy5mb3JFYWNoKChjcCwgaSkgPT4ge1xyXG5cdFx0bGV0IGQgPSByKCk7IFxyXG5cdFx0bGV0IHcgPSB3aG9sZXNbaV0gPSBkID8gd2hvbGVzW2ktZF0gOiB7VjogW10sIE06IG5ldyBNYXAoKX07XHJcblx0XHR3LlYucHVzaChjcCk7IC8vIGFkZCB0byBtZW1iZXIgc2V0XHJcblx0XHRpZiAoIVdIT0xFX1ZBTElELmhhcyhjcCkpIHtcclxuXHRcdFx0V0hPTEVfTUFQLnNldChjcCwgdyk7ICAvLyByZWdpc3RlciB3aXRoIHdob2xlIG1hcFxyXG5cdFx0fVxyXG5cdH0pO1xyXG5cclxuXHQvLyBjb21wdXRlIGNvbmZ1c2FibGUtZXh0ZW50IGNvbXBsZW1lbnRzXHJcblx0Ly8gdXNhZ2U6IFdIT0xFX01BUC5nZXQoY3ApLk0uZ2V0KGNwKSA9IGNvbXBsZW1lbnQgc2V0XHJcblx0Zm9yIChsZXQge1YsIE19IG9mIG5ldyBTZXQoV0hPTEVfTUFQLnZhbHVlcygpKSkge1xyXG5cdFx0Ly8gY29ubmVjdCBhbGwgZ3JvdXBzIHRoYXQgaGF2ZSBlYWNoIHdob2xlIGNoYXJhY3RlclxyXG5cdFx0bGV0IHJlY3MgPSBbXTtcclxuXHRcdGZvciAobGV0IGNwIG9mIFYpIHtcclxuXHRcdFx0bGV0IGdzID0gR1JPVVBTLmZpbHRlcihnID0+IGdyb3VwX2hhc19jcChnLCBjcCkpO1xyXG5cdFx0XHRsZXQgcmVjID0gcmVjcy5maW5kKCh7R30pID0+IGdzLnNvbWUoZyA9PiBHLmhhcyhnKSkpO1xyXG5cdFx0XHRpZiAoIXJlYykge1xyXG5cdFx0XHRcdHJlYyA9IHtHOiBuZXcgU2V0KCksIFY6IFtdfTtcclxuXHRcdFx0XHRyZWNzLnB1c2gocmVjKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZWMuVi5wdXNoKGNwKTtcclxuXHRcdFx0c2V0X2FkZF9tYW55KHJlYy5HLCBncyk7XHJcblx0XHR9XHJcblx0XHQvLyBwZXIgY2hhcmFjdGVyIGNhY2hlIGdyb3VwcyB3aGljaCBhcmUgbm90IGEgbWVtYmVyIG9mIHRoZSBleHRlbnRcclxuXHRcdGxldCB1bmlvbiA9IHJlY3MuZmxhdE1hcCh4ID0+IEFycmF5X2Zyb20oeC5HKSk7IC8vIGFsbCBvZiB0aGUgZ3JvdXBzIHVzZWQgYnkgdGhpcyB3aG9sZVxyXG5cdFx0Zm9yIChsZXQge0csIFZ9IG9mIHJlY3MpIHtcclxuXHRcdFx0bGV0IGNvbXBsZW1lbnQgPSBuZXcgU2V0KHVuaW9uLmZpbHRlcihnID0+ICFHLmhhcyhnKSkpOyAvLyBncm91cHMgbm90IGNvdmVyZWQgYnkgdGhlIGV4dGVudFxyXG5cdFx0XHRmb3IgKGxldCBjcCBvZiBWKSB7XHJcblx0XHRcdFx0TS5zZXQoY3AsIGNvbXBsZW1lbnQpOyAvLyB0aGlzIGlzIHRoZSBzYW1lIHJlZmVyZW5jZVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBjb21wdXRlIHZhbGlkIHNldFxyXG5cdC8vIDIwMjMwOTI0OiBWQUxJRCB3YXMgdW5pb24gYnV0IGNhbiBiZSByZS11c2VkXHJcblx0VkFMSUQgPSBuZXcgU2V0KCk7IC8vIGV4aXN0cyBpbiAxKyBncm91cHNcclxuXHRsZXQgbXVsdGkgPSBuZXcgU2V0KCk7IC8vIGV4aXN0cyBpbiAyKyBncm91cHNcclxuXHRjb25zdCBhZGRfdG9fdW5pb24gPSBjcCA9PiBWQUxJRC5oYXMoY3ApID8gbXVsdGkuYWRkKGNwKSA6IFZBTElELmFkZChjcCk7XHJcblx0Zm9yIChsZXQgZyBvZiBHUk9VUFMpIHtcclxuXHRcdGZvciAobGV0IGNwIG9mIGcuUCkgYWRkX3RvX3VuaW9uKGNwKTtcclxuXHRcdGZvciAobGV0IGNwIG9mIGcuUSkgYWRkX3RvX3VuaW9uKGNwKTtcclxuXHR9XHJcblx0Ly8gZHVhbCBwdXJwb3NlIFdIT0xFX01BUDogcmV0dXJuIHBsYWNlaG9sZGVyIGlmIHVuaXF1ZSBub24tY29uZnVzYWJsZVxyXG5cdGZvciAobGV0IGNwIG9mIFZBTElEKSB7XHJcblx0XHRpZiAoIVdIT0xFX01BUC5oYXMoY3ApICYmICFtdWx0aS5oYXMoY3ApKSB7XHJcblx0XHRcdFdIT0xFX01BUC5zZXQoY3AsIFVOSVFVRV9QSCk7XHJcblx0XHR9XHJcblx0fVxyXG5cdC8vIGFkZCBhbGwgZGVjb21wb3NlZCBwYXJ0c1xyXG5cdC8vIHNlZSBkZXJpdmU6IFwiVmFsaWQgaXMgQ2xvc2VkICh2aWEgQnJ1dGUtZm9yY2UpXCJcclxuXHRzZXRfYWRkX21hbnkoVkFMSUQsIG5mZChWQUxJRCkpO1xyXG5cdFxyXG5cdC8vIGRlY29kZSBlbW9qaVxyXG5cdC8vIDIwMjMwNzE5OiBlbW9qaSBhcmUgbm93IGZ1bGx5LWV4cGFuZGVkIHRvIGF2b2lkIHF1aXJrIGxvZ2ljIFxyXG5cdEVNT0pJX0xJU1QgPSByZWFkX3RyaWUocikubWFwKHYgPT4gRW1vamkuZnJvbSh2KSkuc29ydChjb21wYXJlX2FycmF5cyk7XHJcblx0RU1PSklfUk9PVCA9IG5ldyBNYXAoKTsgLy8gdGhpcyBoYXMgYXBwcm94IDdLIG5vZGVzICgyKyBwZXIgZW1vamkpXHJcblx0Zm9yIChsZXQgY3BzIG9mIEVNT0pJX0xJU1QpIHtcclxuXHRcdC8vIDIwMjMwNzE5OiBjaGFuZ2UgdG8gKnNsaWdodGx5KiBzdHJpY3RlciBhbGdvcml0aG0gd2hpY2ggZGlzYWxsb3dzIFxyXG5cdFx0Ly8gaW5zZXJ0aW9uIG9mIG1pc3BsYWNlZCBGRTBGIGluIGVtb2ppIHNlcXVlbmNlcyAobWF0Y2hpbmcgRU5TSVAtMTUpXHJcblx0XHQvLyBleGFtcGxlOiBiZWF1dGlmaWVkIFtBIEJdIChlZy4gZmxhZyBlbW9qaSkgXHJcblx0XHQvLyAgYmVmb3JlOiBhbGxvdzogW0EgRkUwRiBCXSwgZXJyb3I6IFtBIEZFMEYgRkUwRiBCXSBcclxuXHRcdC8vICAgYWZ0ZXI6IGVycm9yOiBib3RoXHJcblx0XHQvLyBub3RlOiB0aGlzIGNvZGUgbm93IG1hdGNoZXMgRU5TTm9ybWFsaXplLntjcyxqYXZhfSBsb2dpY1xyXG5cdFx0bGV0IHByZXYgPSBbRU1PSklfUk9PVF07XHJcblx0XHRmb3IgKGxldCBjcCBvZiBjcHMpIHtcclxuXHRcdFx0bGV0IG5leHQgPSBwcmV2Lm1hcChub2RlID0+IHtcclxuXHRcdFx0XHRsZXQgY2hpbGQgPSBub2RlLmdldChjcCk7XHJcblx0XHRcdFx0aWYgKCFjaGlsZCkge1xyXG5cdFx0XHRcdFx0Ly8gc2hvdWxkIHRoaXMgYmUgb2JqZWN0PyBcclxuXHRcdFx0XHRcdC8vIChtb3N0IGhhdmUgMS0yIGl0ZW1zLCBmZXcgaGF2ZSBtYW55KVxyXG5cdFx0XHRcdFx0Ly8gMjAyMzA3MTk6IG5vLCB2OCBkZWZhdWx0IG1hcCBpcyA0P1xyXG5cdFx0XHRcdFx0Y2hpbGQgPSBuZXcgTWFwKCk7XHJcblx0XHRcdFx0XHRub2RlLnNldChjcCwgY2hpbGQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gY2hpbGQ7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRpZiAoY3AgPT09IEZFMEYpIHtcclxuXHRcdFx0XHRwcmV2LnB1c2goLi4ubmV4dCk7IC8vIGxlc3MgdGhhbiAyMCBlbGVtZW50c1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHByZXYgPSBuZXh0O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRmb3IgKGxldCB4IG9mIHByZXYpIHtcclxuXHRcdFx0eC5WID0gY3BzO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuLy8gaWYgZXNjYXBlZDoge0hFWH1cclxuLy8gICAgICAgZWxzZTogXCJ4XCIge0hFWH1cclxuZnVuY3Rpb24gcXVvdGVkX2NwKGNwKSB7XHJcblx0cmV0dXJuIChzaG91bGRfZXNjYXBlKGNwKSA/ICcnIDogYCR7YmlkaV9xcShzYWZlX3N0cl9mcm9tX2NwcyhbY3BdKSl9IGApICsgcXVvdGVfY3AoY3ApO1xyXG59XHJcblxyXG4vLyAyMDIzMDIxMTogc29tZSBtZXNzYWdlcyBjYW4gYmUgbWl4ZWQtZGlyZWN0aW9uYWwgYW5kIHJlc3VsdCBpbiBzcGlsbG92ZXJcclxuLy8gdXNlIDIwMEUgYWZ0ZXIgYSBxdW90ZWQgc3RyaW5nIHRvIGZvcmNlIHRoZSByZW1haW5kZXIgb2YgYSBzdHJpbmcgZnJvbSBcclxuLy8gYWNxdXJpbmcgdGhlIGRpcmVjdGlvbiBvZiB0aGUgcXVvdGVcclxuLy8gaHR0cHM6Ly93d3cudzMub3JnL0ludGVybmF0aW9uYWwvcXVlc3Rpb25zL3FhLWJpZGktdW5pY29kZS1jb250cm9scyNleGNlcHRpb25zXHJcbmZ1bmN0aW9uIGJpZGlfcXEocykge1xyXG5cdHJldHVybiBgXCIke3N9XCJcXHUyMDBFYDsgLy8gc3Ryb25nIExUUlxyXG59XHJcblxyXG5mdW5jdGlvbiBjaGVja19sYWJlbF9leHRlbnNpb24oY3BzKSB7XHJcblx0aWYgKGNwcy5sZW5ndGggPj0gNCAmJiBjcHNbMl0gPT0gSFlQSEVOICYmIGNwc1szXSA9PSBIWVBIRU4pIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBsYWJlbCBleHRlbnNpb246IFwiJHtzdHJfZnJvbV9jcHMoY3BzLnNsaWNlKDAsIDQpKX1cImApOyAvLyB0aGlzIGNhbiBvbmx5IGJlIGFzY2lpIHNvIGNhbnQgYmUgYmlkaVxyXG5cdH1cclxufVxyXG5mdW5jdGlvbiBjaGVja19sZWFkaW5nX3VuZGVyc2NvcmUoY3BzKSB7XHJcblx0Y29uc3QgVU5ERVJTQ09SRSA9IDB4NUY7XHJcblx0Zm9yIChsZXQgaSA9IGNwcy5sYXN0SW5kZXhPZihVTkRFUlNDT1JFKTsgaSA+IDA7ICkge1xyXG5cdFx0aWYgKGNwc1stLWldICE9PSBVTkRFUlNDT1JFKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcigndW5kZXJzY29yZSBhbGxvd2VkIG9ubHkgYXQgc3RhcnQnKTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuLy8gY2hlY2sgdGhhdCBhIGZlbmNlZCBjcCBpcyBub3QgbGVhZGluZywgdHJhaWxpbmcsIG9yIHRvdWNoaW5nIGFub3RoZXIgZmVuY2VkIGNwXHJcbmZ1bmN0aW9uIGNoZWNrX2ZlbmNlZChjcHMpIHtcclxuXHRsZXQgY3AgPSBjcHNbMF07XHJcblx0bGV0IHByZXYgPSBGRU5DRUQuZ2V0KGNwKTtcclxuXHRpZiAocHJldikgdGhyb3cgZXJyb3JfcGxhY2VtZW50KGBsZWFkaW5nICR7cHJldn1gKTtcclxuXHRsZXQgbiA9IGNwcy5sZW5ndGg7XHJcblx0bGV0IGxhc3QgPSAtMTsgLy8gcHJldmVudHMgdHJhaWxpbmcgZnJvbSB0aHJvd2luZ1xyXG5cdGZvciAobGV0IGkgPSAxOyBpIDwgbjsgaSsrKSB7XHJcblx0XHRjcCA9IGNwc1tpXTtcclxuXHRcdGxldCBtYXRjaCA9IEZFTkNFRC5nZXQoY3ApO1xyXG5cdFx0aWYgKG1hdGNoKSB7XHJcblx0XHRcdC8vIHNpbmNlIGNwc1swXSBpc24ndCBmZW5jZWQsIGNwc1sxXSBjYW5ub3QgdGhyb3dcclxuXHRcdFx0aWYgKGxhc3QgPT0gaSkgdGhyb3cgZXJyb3JfcGxhY2VtZW50KGAke3ByZXZ9ICsgJHttYXRjaH1gKTtcclxuXHRcdFx0bGFzdCA9IGkgKyAxO1xyXG5cdFx0XHRwcmV2ID0gbWF0Y2g7XHJcblx0XHR9XHJcblx0fVxyXG5cdGlmIChsYXN0ID09IG4pIHRocm93IGVycm9yX3BsYWNlbWVudChgdHJhaWxpbmcgJHtwcmV2fWApO1xyXG59XHJcblxyXG4vLyBjcmVhdGUgYSBzYWZlIHRvIHByaW50IHN0cmluZyBcclxuLy8gaW52aXNpYmxlcyBhcmUgZXNjYXBlZFxyXG4vLyBsZWFkaW5nIGNtIHVzZXMgcGxhY2Vob2xkZXJcclxuLy8gaWYgY3BzIGV4Y2VlZCBtYXgsIG1pZGRsZSB0cnVuY2F0ZSB3aXRoIGVsbGlwc2lzXHJcbi8vIHF1b3RlcihjcCkgPT4gc3RyaW5nLCBlZy4gMzAwMCA9PiBcInszMDAwfVwiXHJcbi8vIG5vdGU6IGluIGh0bWwsIHlvdSdkIGNhbGwgdGhpcyBmdW5jdGlvbiB0aGVuIHJlcGxhY2UgWzw+Jl0gd2l0aCBlbnRpdGllc1xyXG5mdW5jdGlvbiBzYWZlX3N0cl9mcm9tX2NwcyhjcHMsIG1heCA9IEluZmluaXR5LCBxdW90ZXIgPSBxdW90ZV9jcCkge1xyXG5cdC8vaWYgKE51bWJlci5pc0ludGVnZXIoY3BzKSkgY3BzID0gW2Nwc107XHJcblx0Ly9pZiAoIUFycmF5LmlzQXJyYXkoY3BzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihgZXhwZWN0ZWQgY29kZXBvaW50c2ApO1xyXG5cdGxldCBidWYgPSBbXTtcclxuXHRpZiAoaXNfY29tYmluaW5nX21hcmsoY3BzWzBdKSkgYnVmLnB1c2goJ+KXjCcpO1xyXG5cdGlmIChjcHMubGVuZ3RoID4gbWF4KSB7XHJcblx0XHRtYXggPj49IDE7XHJcblx0XHRjcHMgPSBbLi4uY3BzLnNsaWNlKDAsIG1heCksIDB4MjAyNiwgLi4uY3BzLnNsaWNlKC1tYXgpXTtcclxuXHR9XHJcblx0bGV0IHByZXYgPSAwO1xyXG5cdGxldCBuID0gY3BzLmxlbmd0aDtcclxuXHRmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xyXG5cdFx0bGV0IGNwID0gY3BzW2ldO1xyXG5cdFx0aWYgKHNob3VsZF9lc2NhcGUoY3ApKSB7XHJcblx0XHRcdGJ1Zi5wdXNoKHN0cl9mcm9tX2NwcyhjcHMuc2xpY2UocHJldiwgaSkpKTtcclxuXHRcdFx0YnVmLnB1c2gocXVvdGVyKGNwKSk7XHJcblx0XHRcdHByZXYgPSBpICsgMTtcclxuXHRcdH1cclxuXHR9XHJcblx0YnVmLnB1c2goc3RyX2Zyb21fY3BzKGNwcy5zbGljZShwcmV2LCBuKSkpO1xyXG5cdHJldHVybiBidWYuam9pbignJyk7XHJcbn1cclxuXHJcbi8vIG5vdGU6IHNldChzKSBjYW5ub3QgYmUgZXhwb3NlZCBiZWNhdXNlIHRoZXkgY2FuIGJlIG1vZGlmaWVkXHJcbi8vIG5vdGU6IE9iamVjdC5mcmVlemUoKSBkb2Vzbid0IHdvcmtcclxuZnVuY3Rpb24gaXNfY29tYmluaW5nX21hcmsoY3AsIG9ubHlfbnNtKSB7IC8vIDIwMjQwMTI3OiBhZGQgZXh0cmEgYXJndW1lbnRcclxuXHRpbml0KCk7XHJcblx0cmV0dXJuIG9ubHlfbnNtID8gTlNNLmhhcyhjcCkgOiBDTS5oYXMoY3ApO1xyXG59XHJcbmZ1bmN0aW9uIHNob3VsZF9lc2NhcGUoY3ApIHtcclxuXHRpbml0KCk7XHJcblx0cmV0dXJuIEVTQ0FQRS5oYXMoY3ApO1xyXG59XHJcblxyXG4vLyByZXR1cm4gYWxsIHN1cHBvcnRlZCBlbW9qaSBhcyBmdWxseS1xdWFsaWZpZWQgZW1vamkgXHJcbi8vIG9yZGVyZWQgYnkgbGVuZ3RoIHRoZW4gbGV4aWNvZ3JhcGhpYyBcclxuZnVuY3Rpb24gZW5zX2Vtb2ppKCkge1xyXG5cdGluaXQoKTtcclxuXHRyZXR1cm4gRU1PSklfTElTVC5tYXAoeCA9PiB4LnNsaWNlKCkpOyAvLyBlbW9qaSBhcmUgZXhwb3NlZCBzbyBjb3B5XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVuc19ub3JtYWxpemVfZnJhZ21lbnQoZnJhZywgZGVjb21wb3NlKSB7XHJcblx0aW5pdCgpO1xyXG5cdGxldCBuZiA9IGRlY29tcG9zZSA/IG5mZCA6IG5mYztcclxuXHRyZXR1cm4gZnJhZy5zcGxpdChTVE9QX0NIKS5tYXAobGFiZWwgPT4gc3RyX2Zyb21fY3BzKHRva2Vuc19mcm9tX3N0cihleHBsb2RlX2NwKGxhYmVsKSwgbmYsIGZpbHRlcl9mZTBmKS5mbGF0KCkpKS5qb2luKFNUT1BfQ0gpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBlbnNfbm9ybWFsaXplKG5hbWUpIHtcclxuXHRyZXR1cm4gZmxhdHRlbihzcGxpdChuYW1lLCBuZmMsIGZpbHRlcl9mZTBmKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVuc19iZWF1dGlmeShuYW1lKSB7XHJcblx0bGV0IGxhYmVscyA9IHNwbGl0KG5hbWUsIG5mYywgeCA9PiB4KTsgLy8gZW1vamkgbm90IGV4cG9zZWRcclxuXHRmb3IgKGxldCB7dHlwZSwgb3V0cHV0LCBlcnJvcn0gb2YgbGFiZWxzKSB7XHJcblx0XHRpZiAoZXJyb3IpIGJyZWFrOyAvLyBmbGF0dGVuIHdpbGwgdGhyb3dcclxuXHJcblx0XHQvLyByZXBsYWNlIGxlYWRpbmcvdHJhaWxpbmcgaHlwaGVuXHJcblx0XHQvLyAyMDIzMDEyMTogY29uc2lkZXIgYmVhdXRpZmluZyBhbGwgb3IgbGVhZGluZy90cmFpbGluZyBoeXBoZW4gdG8gdW5pY29kZSB2YXJpYW50XHJcblx0XHQvLyBub3QgZXhhY3RseSB0aGUgc2FtZSBpbiBldmVyeSBmb250LCBidXQgdmVyeSBzaW1pbGFyOiBcIi1cIiB2cyBcIuKAkFwiXHJcblx0XHQvKlxyXG5cdFx0Y29uc3QgVU5JQ09ERV9IWVBIRU4gPSAweDIwMTA7XHJcblx0XHQvLyBtYXliZSB0aGlzIHNob3VsZCByZXBsYWNlIGFsbCBmb3IgdmlzdWFsIGNvbnNpc3RhbmN5P1xyXG5cdFx0Ly8gYG5vZGUgdG9vbHMvcmVnLWNvdW50LmpzIHJlZ2V4IF4tXFx7MixcXH1gID0+IDU5MlxyXG5cdFx0Ly9mb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dC5sZW5ndGg7IGkrKykgaWYgKG91dHB1dFtpXSA9PSAweDJEKSBvdXRwdXRbaV0gPSAweDIwMTA7XHJcblx0XHRpZiAob3V0cHV0WzBdID09IEhZUEhFTikgb3V0cHV0WzBdID0gVU5JQ09ERV9IWVBIRU47XHJcblx0XHRsZXQgZW5kID0gb3V0cHV0Lmxlbmd0aC0xO1xyXG5cdFx0aWYgKG91dHB1dFtlbmRdID09IEhZUEhFTikgb3V0cHV0W2VuZF0gPSBVTklDT0RFX0hZUEhFTjtcclxuXHRcdCovXHJcblx0XHQvLyAyMDIzMDEyMzogV0hBVFdHIFVSTCB1c2VzIFwiQ2hlY2tIeXBoZW5zXCIgZmFsc2VcclxuXHRcdC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jaWRuYVxyXG5cclxuXHRcdC8vIHVwZGF0ZSBldGhlcmV1bSBzeW1ib2xcclxuXHRcdC8vIM6+ID0+IM6eIGlmIG5vdCBncmVla1xyXG5cdFx0aWYgKHR5cGUgIT09ICdHcmVlaycpIGFycmF5X3JlcGxhY2Uob3V0cHV0LCAweDNCRSwgMHgzOUUpO1xyXG5cclxuXHRcdC8vIDIwMjIxMjEzOiBmaXhlcyBiaWRpIHN1YmRvbWFpbiBpc3N1ZSwgYnV0IGJyZWFrcyBpbnZhcmlhbnQgKDIwMEUgaXMgZGlzYWxsb3dlZClcclxuXHRcdC8vIGNvdWxkIGJlIGZpeGVkIHdpdGggc3BlY2lhbCBjYXNlIGZvcjogMkQgKC4pICsgMjAwRSAoTFRSKVxyXG5cdFx0Ly8gaHR0cHM6Ly9kaXNjdXNzLmVucy5kb21haW5zL3QvYmlkaS1sYWJlbC1vcmRlcmluZy1zcG9vZi8xNTgyNFxyXG5cdFx0Ly9vdXRwdXQuc3BsaWNlKDAsIDAsIDB4MjAwRSk7XHJcblx0fVxyXG5cdHJldHVybiBmbGF0dGVuKGxhYmVscyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVuc19zcGxpdChuYW1lLCBwcmVzZXJ2ZV9lbW9qaSkge1xyXG5cdHJldHVybiBzcGxpdChuYW1lLCBuZmMsIHByZXNlcnZlX2Vtb2ppID8geCA9PiB4LnNsaWNlKCkgOiBmaWx0ZXJfZmUwZik7IC8vIGVtb2ppIGFyZSBleHBvc2VkIHNvIGNvcHlcclxufVxyXG5cclxuZnVuY3Rpb24gc3BsaXQobmFtZSwgbmYsIGVmKSB7XHJcblx0aWYgKCFuYW1lKSByZXR1cm4gW107IC8vIDIwMjMwNzE5OiBlbXB0eSBuYW1lIGFsbG93YW5jZVxyXG5cdGluaXQoKTtcclxuXHRsZXQgb2Zmc2V0ID0gMDtcclxuXHQvLyBodHRwczovL3VuaWNvZGUub3JnL3JlcG9ydHMvdHI0Ni8jVmFsaWRpdHlfQ3JpdGVyaWFcclxuXHQvLyA0LikgXCJUaGUgbGFiZWwgbXVzdCBub3QgY29udGFpbiBhIFUrMDAyRSAoIC4gKSBGVUxMIFNUT1AuXCJcclxuXHRyZXR1cm4gbmFtZS5zcGxpdChTVE9QX0NIKS5tYXAobGFiZWwgPT4ge1xyXG5cdFx0bGV0IGlucHV0ID0gZXhwbG9kZV9jcChsYWJlbCk7XHJcblx0XHRsZXQgaW5mbyA9IHtcclxuXHRcdFx0aW5wdXQsXHJcblx0XHRcdG9mZnNldCwgLy8gY29kZXBvaW50LCBub3Qgc3Vic3RyaW5nIVxyXG5cdFx0fTtcclxuXHRcdG9mZnNldCArPSBpbnB1dC5sZW5ndGggKyAxOyAvLyArIHN0b3BcclxuXHRcdHRyeSB7XHJcblx0XHRcdC8vIDEuKSBcIlRoZSBsYWJlbCBtdXN0IGJlIGluIFVuaWNvZGUgTm9ybWFsaXphdGlvbiBGb3JtIE5GQ1wiXHJcblx0XHRcdGxldCB0b2tlbnMgPSBpbmZvLnRva2VucyA9IHRva2Vuc19mcm9tX3N0cihpbnB1dCwgbmYsIGVmKTtcclxuXHRcdFx0bGV0IHRva2VuX2NvdW50ID0gdG9rZW5zLmxlbmd0aDtcclxuXHRcdFx0bGV0IHR5cGU7XHJcblx0XHRcdGlmICghdG9rZW5fY291bnQpIHsgLy8gdGhlIGxhYmVsIHdhcyBlZmZlY3RpdmVseSBlbXB0eSAoY291bGQgb2YgaGFkIGlnbm9yZWQgY2hhcmFjdGVycylcclxuXHRcdFx0XHQvL25vcm0gPSBbXTtcclxuXHRcdFx0XHQvL3R5cGUgPSAnTm9uZSc7IC8vIHVzZSB0aGlzIGluc3RlYWQgb2YgbmV4dCBtYXRjaCwgXCJBU0NJSVwiXHJcblx0XHRcdFx0Ly8gMjAyMzAxMjA6IGNoYW5nZSB0byBzdHJpY3RcclxuXHRcdFx0XHQvLyBodHRwczovL2Rpc2N1c3MuZW5zLmRvbWFpbnMvdC9lbnMtbmFtZS1ub3JtYWxpemF0aW9uLTJuZC8xNDU2NC81OVxyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihgZW1wdHkgbGFiZWxgKTtcclxuXHRcdFx0fSBcclxuXHRcdFx0bGV0IG5vcm0gPSBpbmZvLm91dHB1dCA9IHRva2Vucy5mbGF0KCk7XHJcblx0XHRcdGNoZWNrX2xlYWRpbmdfdW5kZXJzY29yZShub3JtKTtcclxuXHRcdFx0bGV0IGVtb2ppID0gaW5mby5lbW9qaSA9IHRva2VuX2NvdW50ID4gMSB8fCB0b2tlbnNbMF0uaXNfZW1vamk7IC8vIHNhbWUgYXM6IHRva2Vucy5zb21lKHggPT4geC5pc19lbW9qaSk7XHJcblx0XHRcdGlmICghZW1vamkgJiYgbm9ybS5ldmVyeShjcCA9PiBjcCA8IDB4ODApKSB7IC8vIHNwZWNpYWwgY2FzZSBmb3IgYXNjaWlcclxuXHRcdFx0XHQvLyAyMDIzMDEyMzogbWF0Y2hlcyBtYXRjaGVzIFdIQVRXRywgc2VlIG5vdGUgMy4zXHJcblx0XHRcdFx0Y2hlY2tfbGFiZWxfZXh0ZW5zaW9uKG5vcm0pOyAvLyBvbmx5IG5lZWRlZCBmb3IgYXNjaWlcclxuXHRcdFx0XHQvLyBjYW50IGhhdmUgZmVuY2VkXHJcblx0XHRcdFx0Ly8gY2FudCBoYXZlIGNtXHJcblx0XHRcdFx0Ly8gY2FudCBoYXZlIHdob2xlc1xyXG5cdFx0XHRcdC8vIHNlZSBkZXJpdmU6IFwiRmFzdHBhdGggQVNDSUlcIlxyXG5cdFx0XHRcdHR5cGUgPSAnQVNDSUknO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGxldCBjaGFycyA9IHRva2Vucy5mbGF0TWFwKHggPT4geC5pc19lbW9qaSA/IFtdIDogeCk7IC8vIGFsbCBvZiB0aGUgbmZjIHRva2VucyBjb25jYXQgdG9nZXRoZXJcclxuXHRcdFx0XHRpZiAoIWNoYXJzLmxlbmd0aCkgeyAvLyB0aGVyZXMgbm8gdGV4dCwganVzdCBlbW9qaVxyXG5cdFx0XHRcdFx0dHlwZSA9ICdFbW9qaSc7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdC8vIDUuKSBcIlRoZSBsYWJlbCBtdXN0IG5vdCBiZWdpbiB3aXRoIGEgY29tYmluaW5nIG1hcmssIHRoYXQgaXM6IEdlbmVyYWxfQ2F0ZWdvcnk9TWFyay5cIlxyXG5cdFx0XHRcdFx0aWYgKENNLmhhcyhub3JtWzBdKSkgdGhyb3cgZXJyb3JfcGxhY2VtZW50KCdsZWFkaW5nIGNvbWJpbmluZyBtYXJrJyk7XHJcblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMTsgaSA8IHRva2VuX2NvdW50OyBpKyspIHsgLy8gd2UndmUgYWxyZWFkeSBjaGVja2VkIHRoZSBmaXJzdCB0b2tlblxyXG5cdFx0XHRcdFx0XHRsZXQgY3BzID0gdG9rZW5zW2ldO1xyXG5cdFx0XHRcdFx0XHRpZiAoIWNwcy5pc19lbW9qaSAmJiBDTS5oYXMoY3BzWzBdKSkgeyAvLyBldmVyeSB0ZXh0IHRva2VuIGhhcyBlbW9qaSBuZWlnaGJvcnMsIGVnLiBFdEVFRXRFdC4uLlxyXG5cdFx0XHRcdFx0XHRcdC8vIGJpZGlfcXEoKSBub3QgbmVlZGVkIHNpbmNlIGVtb2ppIGlzIExUUiBhbmQgY3BzIGlzIGEgQ01cclxuXHRcdFx0XHRcdFx0XHR0aHJvdyBlcnJvcl9wbGFjZW1lbnQoYGVtb2ppICsgY29tYmluaW5nIG1hcms6IFwiJHtzdHJfZnJvbV9jcHModG9rZW5zW2ktMV0pfSArICR7c2FmZV9zdHJfZnJvbV9jcHMoW2Nwc1swXV0pfVwiYCk7IFxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRjaGVja19mZW5jZWQobm9ybSk7XHJcblx0XHRcdFx0XHRsZXQgdW5pcXVlID0gQXJyYXlfZnJvbShuZXcgU2V0KGNoYXJzKSk7XHJcblx0XHRcdFx0XHRsZXQgW2ddID0gZGV0ZXJtaW5lX2dyb3VwKHVuaXF1ZSk7IC8vIHRha2UgdGhlIGZpcnN0IG1hdGNoXHJcblx0XHRcdFx0XHQvLyBzZWUgZGVyaXZlOiBcIk1hdGNoaW5nIEdyb3VwcyBoYXZlIFNhbWUgQ00gU3R5bGVcIlxyXG5cdFx0XHRcdFx0Ly8gYWx0ZXJuYXRpdmU6IGNvdWxkIGZvcm0gYSBoeWJyaWQgdHlwZTogTGF0aW4vSmFwYW5lc2UvLi4uXHRcclxuXHRcdFx0XHRcdGNoZWNrX2dyb3VwKGcsIGNoYXJzKTsgLy8gbmVlZCB0ZXh0IGluIG9yZGVyXHJcblx0XHRcdFx0XHRjaGVja193aG9sZShnLCB1bmlxdWUpOyAvLyBvbmx5IG5lZWQgdW5pcXVlIHRleHQgKG9yZGVyIHdvdWxkIGJlIHJlcXVpcmVkIGZvciBtdWx0aXBsZS1jaGFyIGNvbmZ1c2FibGVzKVxyXG5cdFx0XHRcdFx0dHlwZSA9IGcuTjtcclxuXHRcdFx0XHRcdC8vIDIwMjMwMTIxOiBjb25zaWRlciBleHBvc2luZyByZXN0cmljdGVkIGZsYWdcclxuXHRcdFx0XHRcdC8vIGl0J3Mgc2ltcGxlciB0byBqdXN0IGNoZWNrIGZvciAnUmVzdHJpY3RlZCdcclxuXHRcdFx0XHRcdC8vIG9yIGV2ZW4gYmV0dGVyOiB0eXBlLmVuZHNXaXRoKCddJylcclxuXHRcdFx0XHRcdC8vaWYgKGcuUikgaW5mby5yZXN0cmljdGVkID0gdHJ1ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0aW5mby50eXBlID0gdHlwZTtcclxuXHRcdH0gY2F0Y2ggKGVycikge1xyXG5cdFx0XHRpbmZvLmVycm9yID0gZXJyOyAvLyB1c2UgZnVsbCBlcnJvciBvYmplY3RcclxuXHRcdH1cclxuXHRcdHJldHVybiBpbmZvO1xyXG5cdH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjaGVja193aG9sZShncm91cCwgdW5pcXVlKSB7XHJcblx0bGV0IG1ha2VyO1xyXG5cdGxldCBzaGFyZWQgPSBbXTtcclxuXHRmb3IgKGxldCBjcCBvZiB1bmlxdWUpIHtcclxuXHRcdGxldCB3aG9sZSA9IFdIT0xFX01BUC5nZXQoY3ApO1xyXG5cdFx0aWYgKHdob2xlID09PSBVTklRVUVfUEgpIHJldHVybjsgLy8gdW5pcXVlLCBub24tY29uZnVzYWJsZVxyXG5cdFx0aWYgKHdob2xlKSB7XHJcblx0XHRcdGxldCBzZXQgPSB3aG9sZS5NLmdldChjcCk7IC8vIGdyb3VwcyB3aGljaCBoYXZlIGEgY2hhcmFjdGVyIHRoYXQgbG9vay1saWtlIHRoaXMgY2hhcmFjdGVyXHJcblx0XHRcdG1ha2VyID0gbWFrZXIgPyBtYWtlci5maWx0ZXIoZyA9PiBzZXQuaGFzKGcpKSA6IEFycmF5X2Zyb20oc2V0KTtcclxuXHRcdFx0aWYgKCFtYWtlci5sZW5ndGgpIHJldHVybjsgLy8gY29uZnVzYWJsZSBpbnRlcnNlY3Rpb24gaXMgZW1wdHlcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHNoYXJlZC5wdXNoKGNwKTsgXHJcblx0XHR9XHJcblx0fVxyXG5cdGlmIChtYWtlcikge1xyXG5cdFx0Ly8gd2UgaGF2ZSAxKyBjb25mdXNhYmxlXHJcblx0XHQvLyBjaGVjayBpZiBhbnkgb2YgdGhlIHJlbWFpbmluZyBncm91cHNcclxuXHRcdC8vIGNvbnRhaW4gdGhlIHNoYXJlZCBjaGFyYWN0ZXJzIHRvb1xyXG5cdFx0Zm9yIChsZXQgZyBvZiBtYWtlcikge1xyXG5cdFx0XHRpZiAoc2hhcmVkLmV2ZXJ5KGNwID0+IGdyb3VwX2hhc19jcChnLCBjcCkpKSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGB3aG9sZS1zY3JpcHQgY29uZnVzYWJsZTogJHtncm91cC5OfS8ke2cuTn1gKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuLy8gYXNzdW1wdGlvbjogdW5pcXVlLnNpemUgPiAwXHJcbi8vIHJldHVybnMgbGlzdCBvZiBtYXRjaGluZyBncm91cHNcclxuZnVuY3Rpb24gZGV0ZXJtaW5lX2dyb3VwKHVuaXF1ZSkge1xyXG5cdGxldCBncm91cHMgPSBHUk9VUFM7XHJcblx0Zm9yIChsZXQgY3Agb2YgdW5pcXVlKSB7XHJcblx0XHQvLyBub3RlOiB3ZSBuZWVkIHRvIGRvZGdlIENNIHRoYXQgYXJlIHdoaXRlbGlzdGVkXHJcblx0XHQvLyBidXQgdGhhdCBjb2RlIGlzbid0IGN1cnJlbnRseSBuZWNlc3NhcnlcclxuXHRcdGxldCBncyA9IGdyb3Vwcy5maWx0ZXIoZyA9PiBncm91cF9oYXNfY3AoZywgY3ApKTtcclxuXHRcdGlmICghZ3MubGVuZ3RoKSB7XHJcblx0XHRcdGlmICghR1JPVVBTLnNvbWUoZyA9PiBncm91cF9oYXNfY3AoZywgY3ApKSkgeyBcclxuXHRcdFx0XHQvLyB0aGUgY2hhcmFjdGVyIHdhcyBjb21wb3NlZCBvZiB2YWxpZCBwYXJ0c1xyXG5cdFx0XHRcdC8vIGJ1dCBpdCdzIE5GQyBmb3JtIGlzIGludmFsaWRcclxuXHRcdFx0XHQvLyAyMDIzMDcxNjogY2hhbmdlIHRvIG1vcmUgZXhhY3Qgc3RhdGVtZW50LCBzZWU6IEVOU05vcm1hbGl6ZS57Y3MsamF2YX1cclxuXHRcdFx0XHQvLyBub3RlOiB0aGlzIGRvZXNuJ3QgaGF2ZSB0byBiZSBhIGNvbXBvc2l0aW9uXHJcblx0XHRcdFx0Ly8gMjAyMzA3MjA6IGNoYW5nZSB0byBmdWxsIGNoZWNrXHJcblx0XHRcdFx0dGhyb3cgZXJyb3JfZGlzYWxsb3dlZChjcCk7IC8vIHRoaXMgc2hvdWxkIGJlIHJhcmVcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHQvLyB0aGVyZSBpcyBubyBncm91cCB0aGF0IGNvbnRhaW5zIGFsbCB0aGVzZSBjaGFyYWN0ZXJzXHJcblx0XHRcdFx0Ly8gdGhyb3cgdXNpbmcgdGhlIGhpZ2hlc3QgcHJpb3JpdHkgZ3JvdXAgdGhhdCBtYXRjaGVkXHJcblx0XHRcdFx0Ly8gaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM5LyNtaXhlZF9zY3JpcHRfY29uZnVzYWJsZXNcclxuXHRcdFx0XHR0aHJvdyBlcnJvcl9ncm91cF9tZW1iZXIoZ3JvdXBzWzBdLCBjcCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGdyb3VwcyA9IGdzO1xyXG5cdFx0aWYgKGdzLmxlbmd0aCA9PSAxKSBicmVhazsgLy8gdGhlcmUgaXMgb25seSBvbmUgZ3JvdXAgbGVmdFxyXG5cdH1cclxuXHQvLyB0aGVyZSBhcmUgYXQgbGVhc3QgMSBncm91cChzKSB3aXRoIGFsbCBvZiB0aGVzZSBjaGFyYWN0ZXJzXHJcblx0cmV0dXJuIGdyb3VwcztcclxufVxyXG5cclxuLy8gdGhyb3cgb24gZmlyc3QgZXJyb3JcclxuZnVuY3Rpb24gZmxhdHRlbihzcGxpdCkge1xyXG5cdHJldHVybiBzcGxpdC5tYXAoKHtpbnB1dCwgZXJyb3IsIG91dHB1dH0pID0+IHtcclxuXHRcdGlmIChlcnJvcikge1xyXG5cdFx0XHQvLyBkb24ndCBwcmludCBsYWJlbCBhZ2FpbiBpZiBqdXN0IGEgc2luZ2xlIGxhYmVsXHJcblx0XHRcdGxldCBtc2cgPSBlcnJvci5tZXNzYWdlO1xyXG5cdFx0XHQvLyBiaWRpX3FxKCkgb25seSBuZWNlc3NhcnkgaWYgbXNnIGlzIGRpZ2l0c1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3Ioc3BsaXQubGVuZ3RoID09IDEgPyBtc2cgOiBgSW52YWxpZCBsYWJlbCAke2JpZGlfcXEoc2FmZV9zdHJfZnJvbV9jcHMoaW5wdXQsIDYzKSl9OiAke21zZ31gKTsgXHJcblx0XHR9XHJcblx0XHRyZXR1cm4gc3RyX2Zyb21fY3BzKG91dHB1dCk7XHJcblx0fSkuam9pbihTVE9QX0NIKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZXJyb3JfZGlzYWxsb3dlZChjcCkge1xyXG5cdC8vIFRPRE86IGFkZCBjcCB0byBlcnJvcj9cclxuXHRyZXR1cm4gbmV3IEVycm9yKGBkaXNhbGxvd2VkIGNoYXJhY3RlcjogJHtxdW90ZWRfY3AoY3ApfWApOyBcclxufVxyXG5mdW5jdGlvbiBlcnJvcl9ncm91cF9tZW1iZXIoZywgY3ApIHtcclxuXHRsZXQgcXVvdGVkID0gcXVvdGVkX2NwKGNwKTtcclxuXHRsZXQgZ2cgPSBHUk9VUFMuZmluZChnID0+IGcuUC5oYXMoY3ApKTsgLy8gb25seSBjaGVjayBwcmltYXJ5XHJcblx0aWYgKGdnKSB7XHJcblx0XHRxdW90ZWQgPSBgJHtnZy5OfSAke3F1b3RlZH1gO1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3IEVycm9yKGBpbGxlZ2FsIG1peHR1cmU6ICR7Zy5OfSArICR7cXVvdGVkfWApO1xyXG59XHJcbmZ1bmN0aW9uIGVycm9yX3BsYWNlbWVudCh3aGVyZSkge1xyXG5cdHJldHVybiBuZXcgRXJyb3IoYGlsbGVnYWwgcGxhY2VtZW50OiAke3doZXJlfWApO1xyXG59XHJcblxyXG4vLyBhc3N1bXB0aW9uOiBjcHMubGVuZ3RoID4gMFxyXG4vLyBhc3N1bXB0aW9uOiBjcHNbMF0gaXNuJ3QgYSBDTVxyXG4vLyBhc3N1bXB0aW9uOiB0aGUgcHJldmlvdXMgY2hhcmFjdGVyIGlzbid0IGFuIGVtb2ppXHJcbmZ1bmN0aW9uIGNoZWNrX2dyb3VwKGcsIGNwcykge1xyXG5cdGZvciAobGV0IGNwIG9mIGNwcykge1xyXG5cdFx0aWYgKCFncm91cF9oYXNfY3AoZywgY3ApKSB7XHJcblx0XHRcdC8vIGZvciB3aGl0ZWxpc3RlZCBzY3JpcHRzLCB0aGlzIHdpbGwgdGhyb3cgaWxsZWdhbCBtaXh0dXJlIG9uIGludmFsaWQgY20sIGVnLiBcImV7MzAwfXszMDB9XCJcclxuXHRcdFx0Ly8gYXQgdGhlIG1vbWVudCwgaXQncyB1bm5lY2Vzc2FyeSB0byBpbnRyb2R1Y2UgYW4gZXh0cmEgZXJyb3IgdHlwZVxyXG5cdFx0XHQvLyB1bnRpbCB0aGVyZSBleGlzdHMgYSB3aGl0ZWxpc3RlZCBtdWx0aS1jaGFyYWN0ZXJcclxuXHRcdFx0Ly8gICBlZy4gaWYgKE0gPCAwICYmIGlzX2NvbWJpbmluZ19tYXJrKGNwKSkgeyAuLi4gfVxyXG5cdFx0XHQvLyB0aGVyZSBhcmUgMyBjYXNlczpcclxuXHRcdFx0Ly8gICAxLiBpbGxlZ2FsIGNtIGZvciB3cm9uZyBncm91cCA9PiBtaXh0dXJlIGVycm9yXHJcblx0XHRcdC8vICAgMi4gaWxsZWdhbCBjbSBmb3Igc2FtZSBncm91cCA9PiBjbSBlcnJvclxyXG5cdFx0XHQvLyAgICAgICByZXF1aXJlcyBzZXQgb2Ygd2hpdGVsaXN0IGNtIHBlciBncm91cDogXHJcblx0XHRcdC8vICAgICAgICBlZy4gbmV3IFNldChbLi4uZy5QLCAuLi5nLlFdLmZsYXRNYXAobmZjKS5maWx0ZXIoY3AgPT4gQ00uaGFzKGNwKSkpXHJcblx0XHRcdC8vICAgMy4gd3JvbmcgZ3JvdXAgPT4gbWl4dHVyZSBlcnJvclxyXG5cdFx0XHR0aHJvdyBlcnJvcl9ncm91cF9tZW1iZXIoZywgY3ApO1xyXG5cdFx0fVxyXG5cdH1cclxuXHQvL2lmIChNID49IDApIHsgLy8gd2UgaGF2ZSBhIGtub3duIGZpeGVkIGNtIGNvdW50XHJcblx0aWYgKGcuTSkgeyAvLyB3ZSBuZWVkIHRvIGNoZWNrIGZvciBOU01cclxuXHRcdGxldCBkZWNvbXBvc2VkID0gbmZkKGNwcyk7XHJcblx0XHRmb3IgKGxldCBpID0gMSwgZSA9IGRlY29tcG9zZWQubGVuZ3RoOyBpIDwgZTsgaSsrKSB7IC8vIHNlZTogYXNzdW1wdGlvblxyXG5cdFx0XHQvLyAyMDIzMDIxMDogYnVnZml4OiB1c2luZyBjcHMgaW5zdGVhZCBvZiBkZWNvbXBvc2VkIGgvdCBDYXJib24yMjVcclxuXHRcdFx0LypcclxuXHRcdFx0aWYgKENNLmhhcyhkZWNvbXBvc2VkW2ldKSkge1xyXG5cdFx0XHRcdGxldCBqID0gaSArIDE7XHJcblx0XHRcdFx0d2hpbGUgKGogPCBlICYmIENNLmhhcyhkZWNvbXBvc2VkW2pdKSkgaisrO1xyXG5cdFx0XHRcdGlmIChqIC0gaSA+IE0pIHtcclxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgdG9vIG1hbnkgY29tYmluaW5nIG1hcmtzOiAke2cuTn0gJHtiaWRpX3FxKHN0cl9mcm9tX2NwcyhkZWNvbXBvc2VkLnNsaWNlKGktMSwgaikpKX0gKCR7ai1pfS8ke019KWApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpID0gajtcclxuXHRcdFx0fVxyXG5cdFx0XHQqL1xyXG5cdFx0XHQvLyAyMDIzMDIxNzogc3dpdGNoIHRvIE5TTSBjb3VudGluZ1xyXG5cdFx0XHQvLyBodHRwczovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzkvI09wdGlvbmFsX0RldGVjdGlvblxyXG5cdFx0XHRpZiAoTlNNLmhhcyhkZWNvbXBvc2VkW2ldKSkge1xyXG5cdFx0XHRcdGxldCBqID0gaSArIDE7XHJcblx0XHRcdFx0Zm9yIChsZXQgY3A7IGogPCBlICYmIE5TTS5oYXMoY3AgPSBkZWNvbXBvc2VkW2pdKTsgaisrKSB7XHJcblx0XHRcdFx0XHQvLyBhLiBGb3JiaWQgc2VxdWVuY2VzIG9mIHRoZSBzYW1lIG5vbnNwYWNpbmcgbWFyay5cclxuXHRcdFx0XHRcdGZvciAobGV0IGsgPSBpOyBrIDwgajsgaysrKSB7IC8vIE8obl4yKSBidXQgbiA8IDEwMFxyXG5cdFx0XHRcdFx0XHRpZiAoZGVjb21wb3NlZFtrXSA9PSBjcCkge1xyXG5cdFx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgZHVwbGljYXRlIG5vbi1zcGFjaW5nIG1hcmtzOiAke3F1b3RlZF9jcChjcCl9YCk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Ly8gcGFyc2UgdG8gZW5kIHNvIHdlIGhhdmUgZnVsbCBuc20gY291bnRcclxuXHRcdFx0XHQvLyBiLiBGb3JiaWQgc2VxdWVuY2VzIG9mIG1vcmUgdGhhbiA0IG5vbnNwYWNpbmcgbWFya3MgKGdjPU1uIG9yIGdjPU1lKS5cclxuXHRcdFx0XHRpZiAoaiAtIGkgPiBOU01fTUFYKSB7XHJcblx0XHRcdFx0XHQvLyBub3RlOiB0aGlzIHNsaWNlIHN0YXJ0cyB3aXRoIGEgYmFzZSBjaGFyIG9yIHNwYWNpbmctbWFyayBjbVxyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBleGNlc3NpdmUgbm9uLXNwYWNpbmcgbWFya3M6ICR7YmlkaV9xcShzYWZlX3N0cl9mcm9tX2NwcyhkZWNvbXBvc2VkLnNsaWNlKGktMSwgaikpKX0gKCR7ai1pfS8ke05TTV9NQVh9KWApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpID0gajtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHQvLyAqKiogdGhpcyBjb2RlIGN1cnJlbnRseSBpc24ndCBuZWVkZWQgKioqXHJcblx0LypcclxuXHRsZXQgY21fd2hpdGVsaXN0ID0gTSBpbnN0YW5jZW9mIE1hcDtcclxuXHRmb3IgKGxldCBpID0gMCwgZSA9IGNwcy5sZW5ndGg7IGkgPCBlOyApIHtcclxuXHRcdGxldCBjcCA9IGNwc1tpKytdO1xyXG5cdFx0bGV0IHNlcXMgPSBjbV93aGl0ZWxpc3QgJiYgTS5nZXQoY3ApO1xyXG5cdFx0aWYgKHNlcXMpIHsgXHJcblx0XHRcdC8vIGxpc3Qgb2YgY29kZXBvaW50cyB0aGF0IGNhbiBmb2xsb3dcclxuXHRcdFx0Ly8gaWYgdGhpcyBleGlzdHMsIHRoaXMgd2lsbCBhbHdheXMgYmUgMStcclxuXHRcdFx0bGV0IGogPSBpO1xyXG5cdFx0XHR3aGlsZSAoaiA8IGUgJiYgQ00uaGFzKGNwc1tqXSkpIGorKztcclxuXHRcdFx0bGV0IGNtcyA9IGNwcy5zbGljZShpLCBqKTtcclxuXHRcdFx0bGV0IG1hdGNoID0gc2Vxcy5maW5kKHNlcSA9PiAhY29tcGFyZV9hcnJheXMoc2VxLCBjbXMpKTtcclxuXHRcdFx0aWYgKCFtYXRjaCkgdGhyb3cgbmV3IEVycm9yKGBkaXNhbGxvd2VkIGNvbWJpbmluZyBtYXJrIHNlcXVlbmNlOiBcIiR7c2FmZV9zdHJfZnJvbV9jcHMoW2NwLCAuLi5jbXNdKX1cImApO1xyXG5cdFx0XHRpID0gajtcclxuXHRcdH0gZWxzZSBpZiAoIVYuaGFzKGNwKSkge1xyXG5cdFx0XHQvLyBodHRwczovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzkvI21peGVkX3NjcmlwdF9jb25mdXNhYmxlc1xyXG5cdFx0XHRsZXQgcXVvdGVkID0gcXVvdGVkX2NwKGNwKTtcclxuXHRcdFx0Zm9yIChsZXQgY3Agb2YgY3BzKSB7XHJcblx0XHRcdFx0bGV0IHUgPSBVTklRVUUuZ2V0KGNwKTtcclxuXHRcdFx0XHRpZiAodSAmJiB1ICE9PSBnKSB7XHJcblx0XHRcdFx0XHQvLyBpZiBib3RoIHNjcmlwdHMgYXJlIHJlc3RyaWN0ZWQgdGhpcyBlcnJvciBpcyBjb25mdXNpbmdcclxuXHRcdFx0XHRcdC8vIGJlY2F1c2Ugd2UgZG9uJ3QgZGlmZmVyZW50aWF0ZSBSZXN0cmljdGVkQSBmcm9tIFJlc3RyaWN0ZWRCIFxyXG5cdFx0XHRcdFx0aWYgKCF1LlIpIHF1b3RlZCA9IGAke3F1b3RlZH0gaXMgJHt1Lk59YDtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYGRpc2FsbG93ZWQgJHtnLk59IGNoYXJhY3RlcjogJHtxdW90ZWR9YCk7XHJcblx0XHRcdC8vdGhyb3cgbmV3IEVycm9yKGBkaXNhbGxvd2VkIGNoYXJhY3RlcjogJHtxdW90ZWR9IChleHBlY3RlZCAke2cuTn0pYCk7XHJcblx0XHRcdC8vdGhyb3cgbmV3IEVycm9yKGAke2cuTn0gZG9lcyBub3QgYWxsb3c6ICR7cXVvdGVkfWApO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAoIWNtX3doaXRlbGlzdCkge1xyXG5cdFx0bGV0IGRlY29tcG9zZWQgPSBuZmQoY3BzKTtcclxuXHRcdGZvciAobGV0IGkgPSAxLCBlID0gZGVjb21wb3NlZC5sZW5ndGg7IGkgPCBlOyBpKyspIHsgLy8gd2Uga25vdyBpdCBjYW4ndCBiZSBjbSBsZWFkaW5nXHJcblx0XHRcdGlmIChDTS5oYXMoZGVjb21wb3NlZFtpXSkpIHtcclxuXHRcdFx0XHRsZXQgaiA9IGkgKyAxO1xyXG5cdFx0XHRcdHdoaWxlIChqIDwgZSAmJiBDTS5oYXMoZGVjb21wb3NlZFtqXSkpIGorKztcclxuXHRcdFx0XHRpZiAoaiAtIGkgPiBNKSB7XHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYHRvbyBtYW55IGNvbWJpbmluZyBtYXJrczogXCIke3N0cl9mcm9tX2NwcyhkZWNvbXBvc2VkLnNsaWNlKGktMSwgaikpfVwiICgke2otaX0vJHtNfSlgKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aSA9IGo7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0Ki9cclxufVxyXG5cclxuLy8gZ2l2ZW4gYSBsaXN0IG9mIGNvZGVwb2ludHNcclxuLy8gcmV0dXJucyBhIGxpc3Qgb2YgbGlzdHMsIHdoZXJlIGVtb2ppIGFyZSBhIGZ1bGx5LXF1YWxpZmllZCAoYXMgQXJyYXkgc3ViY2xhc3MpXHJcbi8vIGVnLiBleHBsb2RlX2NwKFwiYWJj8J+SqWRcIikgPT4gW1s2MSwgNjIsIDYzXSwgRW1vamlbMUY0QTksIEZFMEZdLCBbNjRdXVxyXG4vLyAyMDIzMDgxODogcmVuYW1lIGZvciAncHJvY2VzcycgbmFtZSBjb2xsaXNpb24gaC90IEphdmFyb21lXHJcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hZHJhZmZ5L2Vucy1ub3JtYWxpemUuanMvaXNzdWVzLzIzXHJcbmZ1bmN0aW9uIHRva2Vuc19mcm9tX3N0cihpbnB1dCwgbmYsIGVmKSB7XHJcblx0bGV0IHJldCA9IFtdO1xyXG5cdGxldCBjaGFycyA9IFtdO1xyXG5cdGlucHV0ID0gaW5wdXQuc2xpY2UoKS5yZXZlcnNlKCk7IC8vIGZsaXAgc28gd2UgY2FuIHBvcFxyXG5cdHdoaWxlIChpbnB1dC5sZW5ndGgpIHtcclxuXHRcdGxldCBlbW9qaSA9IGNvbnN1bWVfZW1vamlfcmV2ZXJzZWQoaW5wdXQpO1xyXG5cdFx0aWYgKGVtb2ppKSB7XHJcblx0XHRcdGlmIChjaGFycy5sZW5ndGgpIHtcclxuXHRcdFx0XHRyZXQucHVzaChuZihjaGFycykpO1xyXG5cdFx0XHRcdGNoYXJzID0gW107XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0LnB1c2goZWYoZW1vamkpKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGxldCBjcCA9IGlucHV0LnBvcCgpO1xyXG5cdFx0XHRpZiAoVkFMSUQuaGFzKGNwKSkge1xyXG5cdFx0XHRcdGNoYXJzLnB1c2goY3ApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGxldCBjcHMgPSBNQVBQRUQuZ2V0KGNwKTtcclxuXHRcdFx0XHRpZiAoY3BzKSB7XHJcblx0XHRcdFx0XHRjaGFycy5wdXNoKC4uLmNwcyk7IC8vIGxlc3MgdGhhbiAxMCBlbGVtZW50c1xyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIUlHTk9SRUQuaGFzKGNwKSkge1xyXG5cdFx0XHRcdFx0Ly8gMjAyMzA5MTI6IHVuaWNvZGUgMTUuMSBjaGFuZ2VkIHRoZSBvcmRlciBvZiBwcm9jZXNzaW5nIHN1Y2ggdGhhdFxyXG5cdFx0XHRcdFx0Ly8gZGlzYWxsb3dlZCBwYXJ0cyBhcmUgb25seSByZWplY3RlZCBhZnRlciBORkNcclxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vdW5pY29kZS5vcmcvcmVwb3J0cy90cjQ2LyNWYWxpZGl0eV9Dcml0ZXJpYVxyXG5cdFx0XHRcdFx0Ly8gdGhpcyBkb2Vzbid0IGltcGFjdCBub3JtYWxpemF0aW9uIGFzIG9mIHRvZGF5XHJcblx0XHRcdFx0XHQvLyB0ZWNobmljYWxseSwgdGhpcyBlcnJvciBjYW4gYmUgcmVtb3ZlZCBhcyB0aGUgZ3JvdXAgbG9naWMgd2lsbCBhcHBseSBzaW1pbGFyIGxvZ2ljXHJcblx0XHRcdFx0XHQvLyBob3dldmVyIHRoZSBlcnJvciB0eXBlIG1pZ2h0IGJlIGxlc3MgY2xlYXJcclxuXHRcdFx0XHRcdHRocm93IGVycm9yX2Rpc2FsbG93ZWQoY3ApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAoY2hhcnMubGVuZ3RoKSB7XHJcblx0XHRyZXQucHVzaChuZihjaGFycykpO1xyXG5cdH1cclxuXHRyZXR1cm4gcmV0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBmaWx0ZXJfZmUwZihjcHMpIHtcclxuXHRyZXR1cm4gY3BzLmZpbHRlcihjcCA9PiBjcCAhPSBGRTBGKTtcclxufVxyXG5cclxuLy8gZ2l2ZW4gYXJyYXkgb2YgY29kZXBvaW50c1xyXG4vLyByZXR1cm5zIHRoZSBsb25nZXN0IHZhbGlkIGVtb2ppIHNlcXVlbmNlIChvciB1bmRlZmluZWQgaWYgbm8gbWF0Y2gpXHJcbi8vICpNVVRBVEVTKiB0aGUgc3VwcGxpZWQgYXJyYXlcclxuLy8gZGlzYWxsb3dzIGludGVybGVhdmVkIGlnbm9yZWQgY2hhcmFjdGVyc1xyXG4vLyBmaWxscyAob3B0aW9uYWwpIGVhdGVuIGFycmF5IHdpdGggbWF0Y2hlZCBjb2RlcG9pbnRzXHJcbmZ1bmN0aW9uIGNvbnN1bWVfZW1vamlfcmV2ZXJzZWQoY3BzLCBlYXRlbikge1xyXG5cdGxldCBub2RlID0gRU1PSklfUk9PVDtcclxuXHRsZXQgZW1vamk7XHJcblx0bGV0IHBvcyA9IGNwcy5sZW5ndGg7XHJcblx0d2hpbGUgKHBvcykge1xyXG5cdFx0bm9kZSA9IG5vZGUuZ2V0KGNwc1stLXBvc10pO1xyXG5cdFx0aWYgKCFub2RlKSBicmVhaztcclxuXHRcdGxldCB7Vn0gPSBub2RlO1xyXG5cdFx0aWYgKFYpIHsgLy8gdGhpcyBpcyBhIHZhbGlkIGVtb2ppIChzbyBmYXIpXHJcblx0XHRcdGVtb2ppID0gVjtcclxuXHRcdFx0aWYgKGVhdGVuKSBlYXRlbi5wdXNoKC4uLmNwcy5zbGljZShwb3MpLnJldmVyc2UoKSk7IC8vIChvcHRpb25hbCkgY29weSBpbnB1dCwgdXNlZCBmb3IgZW5zX3Rva2VuaXplKClcclxuXHRcdFx0Y3BzLmxlbmd0aCA9IHBvczsgLy8gdHJ1bmNhdGVcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIGVtb2ppO1xyXG59XHJcblxyXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuLy8gdG9rZW5pemVyIFxyXG5cclxuY29uc3QgVFlfVkFMSUQgPSAndmFsaWQnO1xyXG5jb25zdCBUWV9NQVBQRUQgPSAnbWFwcGVkJztcclxuY29uc3QgVFlfSUdOT1JFRCA9ICdpZ25vcmVkJztcclxuY29uc3QgVFlfRElTQUxMT1dFRCA9ICdkaXNhbGxvd2VkJztcclxuY29uc3QgVFlfRU1PSkkgPSAnZW1vamknO1xyXG5jb25zdCBUWV9ORkMgPSAnbmZjJztcclxuY29uc3QgVFlfU1RPUCA9ICdzdG9wJztcclxuXHJcbmZ1bmN0aW9uIGVuc190b2tlbml6ZShuYW1lLCB7XHJcblx0bmYgPSB0cnVlLCAvLyBjb2xsYXBzZSB1bm5vcm1hbGl6ZWQgcnVucyBpbnRvIGEgc2luZ2xlIHRva2VuXHJcbn0gPSB7fSkge1xyXG5cdGluaXQoKTtcclxuXHRsZXQgaW5wdXQgPSBleHBsb2RlX2NwKG5hbWUpLnJldmVyc2UoKTtcclxuXHRsZXQgZWF0ZW4gPSBbXTtcclxuXHRsZXQgdG9rZW5zID0gW107XHJcblx0d2hpbGUgKGlucHV0Lmxlbmd0aCkge1xyXG5cdFx0bGV0IGVtb2ppID0gY29uc3VtZV9lbW9qaV9yZXZlcnNlZChpbnB1dCwgZWF0ZW4pO1xyXG5cdFx0aWYgKGVtb2ppKSB7XHJcblx0XHRcdHRva2Vucy5wdXNoKHtcclxuXHRcdFx0XHR0eXBlOiBUWV9FTU9KSSxcclxuXHRcdFx0XHRlbW9qaTogZW1vamkuc2xpY2UoKSwgLy8gY29weSBlbW9qaVxyXG5cdFx0XHRcdGlucHV0OiBlYXRlbixcclxuXHRcdFx0XHRjcHM6IGZpbHRlcl9mZTBmKGVtb2ppKVxyXG5cdFx0XHR9KTtcclxuXHRcdFx0ZWF0ZW4gPSBbXTsgLy8gcmVzZXQgYnVmZmVyXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRsZXQgY3AgPSBpbnB1dC5wb3AoKTtcclxuXHRcdFx0aWYgKGNwID09IFNUT1ApIHtcclxuXHRcdFx0XHR0b2tlbnMucHVzaCh7dHlwZTogVFlfU1RPUCwgY3B9KTtcclxuXHRcdFx0fSBlbHNlIGlmIChWQUxJRC5oYXMoY3ApKSB7XHJcblx0XHRcdFx0dG9rZW5zLnB1c2goe3R5cGU6IFRZX1ZBTElELCBjcHM6IFtjcF19KTtcclxuXHRcdFx0fSBlbHNlIGlmIChJR05PUkVELmhhcyhjcCkpIHtcclxuXHRcdFx0XHR0b2tlbnMucHVzaCh7dHlwZTogVFlfSUdOT1JFRCwgY3B9KTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRsZXQgY3BzID0gTUFQUEVELmdldChjcCk7XHJcblx0XHRcdFx0aWYgKGNwcykge1xyXG5cdFx0XHRcdFx0dG9rZW5zLnB1c2goe3R5cGU6IFRZX01BUFBFRCwgY3AsIGNwczogY3BzLnNsaWNlKCl9KTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dG9rZW5zLnB1c2goe3R5cGU6IFRZX0RJU0FMTE9XRUQsIGNwfSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cdGlmIChuZikge1xyXG5cdFx0Zm9yIChsZXQgaSA9IDAsIHN0YXJ0ID0gLTE7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0bGV0IHRva2VuID0gdG9rZW5zW2ldO1xyXG5cdFx0XHRpZiAoaXNfdmFsaWRfb3JfbWFwcGVkKHRva2VuLnR5cGUpKSB7XHJcblx0XHRcdFx0aWYgKHJlcXVpcmVzX2NoZWNrKHRva2VuLmNwcykpIHsgLy8gbm9ybWFsaXphdGlvbiBtaWdodCBiZSBuZWVkZWRcclxuXHRcdFx0XHRcdGxldCBlbmQgPSBpICsgMTtcclxuXHRcdFx0XHRcdGZvciAobGV0IHBvcyA9IGVuZDsgcG9zIDwgdG9rZW5zLmxlbmd0aDsgcG9zKyspIHsgLy8gZmluZCBhZGphY2VudCB0ZXh0XHJcblx0XHRcdFx0XHRcdGxldCB7dHlwZSwgY3BzfSA9IHRva2Vuc1twb3NdO1xyXG5cdFx0XHRcdFx0XHRpZiAoaXNfdmFsaWRfb3JfbWFwcGVkKHR5cGUpKSB7XHJcblx0XHRcdFx0XHRcdFx0aWYgKCFyZXF1aXJlc19jaGVjayhjcHMpKSBicmVhaztcclxuXHRcdFx0XHRcdFx0XHRlbmQgPSBwb3MgKyAxO1xyXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHR5cGUgIT09IFRZX0lHTk9SRUQpIHsgLy8gfHwgdHlwZSAhPT0gVFlfRElTQUxMT1dFRCkgeyBcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSBpO1xyXG5cdFx0XHRcdFx0bGV0IHNsaWNlID0gdG9rZW5zLnNsaWNlKHN0YXJ0LCBlbmQpO1xyXG5cdFx0XHRcdFx0bGV0IGNwczAgPSBzbGljZS5mbGF0TWFwKHggPT4gaXNfdmFsaWRfb3JfbWFwcGVkKHgudHlwZSkgPyB4LmNwcyA6IFtdKTsgLy8gc3RyaXAganVuayB0b2tlbnNcclxuXHRcdFx0XHRcdGxldCBjcHMgPSBuZmMoY3BzMCk7XHJcblx0XHRcdFx0XHRpZiAoY29tcGFyZV9hcnJheXMoY3BzLCBjcHMwKSkgeyAvLyBidW5kbGUgaW50byBhbiBuZmMgdG9rZW5cclxuXHRcdFx0XHRcdFx0dG9rZW5zLnNwbGljZShzdGFydCwgZW5kIC0gc3RhcnQsIHtcclxuXHRcdFx0XHRcdFx0XHR0eXBlOiBUWV9ORkMsIFxyXG5cdFx0XHRcdFx0XHRcdGlucHV0OiBjcHMwLCAvLyB0aGVyZSBhcmUgMyBzdGF0ZXM6IHRva2VuczAgPT0ocHJvY2Vzcyk9PiBpbnB1dCA9PShuZmMpPT4gdG9rZW5zL2Nwc1xyXG5cdFx0XHRcdFx0XHRcdGNwcywgXHJcblx0XHRcdFx0XHRcdFx0dG9rZW5zMDogY29sbGFwc2VfdmFsaWRfdG9rZW5zKHNsaWNlKSxcclxuXHRcdFx0XHRcdFx0XHR0b2tlbnM6IGVuc190b2tlbml6ZShzdHJfZnJvbV9jcHMoY3BzKSwge25mOiBmYWxzZX0pXHJcblx0XHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0XHRpID0gc3RhcnQ7XHJcblx0XHRcdFx0XHR9IGVsc2UgeyBcclxuXHRcdFx0XHRcdFx0aSA9IGVuZCAtIDE7IC8vIHNraXAgdG8gZW5kIG9mIHNsaWNlXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRzdGFydCA9IC0xOyAvLyByZXNldFxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRzdGFydCA9IGk7IC8vIHJlbWVtYmVyIGxhc3RcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSBpZiAodG9rZW4udHlwZSAhPT0gVFlfSUdOT1JFRCkgeyAvLyAyMDIyMTAyNDogaXMgdGhpcyBjb3JyZWN0P1xyXG5cdFx0XHRcdHN0YXJ0ID0gLTE7IC8vIHJlc2V0XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIGNvbGxhcHNlX3ZhbGlkX3Rva2Vucyh0b2tlbnMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc192YWxpZF9vcl9tYXBwZWQodHlwZSkge1xyXG5cdHJldHVybiB0eXBlID09IFRZX1ZBTElEIHx8IHR5cGUgPT0gVFlfTUFQUEVEO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZXF1aXJlc19jaGVjayhjcHMpIHtcclxuXHRyZXR1cm4gY3BzLnNvbWUoY3AgPT4gTkZDX0NIRUNLLmhhcyhjcCkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb2xsYXBzZV92YWxpZF90b2tlbnModG9rZW5zKSB7XHJcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdGlmICh0b2tlbnNbaV0udHlwZSA9PSBUWV9WQUxJRCkge1xyXG5cdFx0XHRsZXQgaiA9IGkgKyAxO1xyXG5cdFx0XHR3aGlsZSAoaiA8IHRva2Vucy5sZW5ndGggJiYgdG9rZW5zW2pdLnR5cGUgPT0gVFlfVkFMSUQpIGorKztcclxuXHRcdFx0dG9rZW5zLnNwbGljZShpLCBqIC0gaSwge3R5cGU6IFRZX1ZBTElELCBjcHM6IHRva2Vucy5zbGljZShpLCBqKS5mbGF0TWFwKHggPT4geC5jcHMpfSk7XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiB0b2tlbnM7XHJcbn1cblxuZXhwb3J0IHsgZW5zX2JlYXV0aWZ5LCBlbnNfZW1vamksIGVuc19ub3JtYWxpemUsIGVuc19ub3JtYWxpemVfZnJhZ21lbnQsIGVuc19zcGxpdCwgZW5zX3Rva2VuaXplLCBpc19jb21iaW5pbmdfbWFyaywgbmZjLCBuZmQsIHNhZmVfc3RyX2Zyb21fY3BzLCBzaG91bGRfZXNjYXBlIH07XG4iXSwibmFtZXMiOlsiQ09NUFJFU1NFRCQxIiwiRkVOQ0VEIiwiTWFwIiwiTlNNX01BWCIsImRlY29kZV9hcml0aG1ldGljIiwiYnl0ZXMiLCJwb3MiLCJ1MTYiLCJzeW1ib2xfY291bnQiLCJ0b3RhbCIsImFjYyIsImkiLCJwdXNoIiwic2tpcCIsInBvc19wYXlsb2FkIiwicmVhZF93aWR0aCIsInJlYWRfYnVmZmVyIiwicmVhZF9iaXQiLCJOIiwiRlVMTCIsIkhBTEYiLCJRUlRSIiwiTUFTSyIsInJlZ2lzdGVyIiwic3ltYm9scyIsImxvdyIsInJhbmdlIiwidmFsdWUiLCJNYXRoIiwiZmxvb3IiLCJzdGFydCIsImVuZCIsIm1pZCIsImEiLCJiIiwib2Zmc2V0IiwibWFwIiwieCIsInJlYWRfcGF5bG9hZCIsInYiLCJyZWFkX2NvbXByZXNzZWRfcGF5bG9hZCIsInMiLCJ1bnNhZmVfYXRvYiIsImxvb2t1cCIsImZvckVhY2giLCJjIiwiY2hhckNvZGVBdCIsIm4iLCJsZW5ndGgiLCJyZXQiLCJVaW50OEFycmF5Iiwid2lkdGgiLCJjYXJyeSIsInNpZ25lZCIsInJlYWRfZGVsdGFzIiwibmV4dCIsIkFycmF5IiwicmVhZF9zb3J0ZWQiLCJwcmV2IiwicmVhZF9zb3J0ZWRfYXJyYXlzIiwicmVhZF9hcnJheV93aGlsZSIsInJlYWRfbWFwcGVkIiwidyIsInJlYWRfbGluZWFyX3RhYmxlIiwicmVhZF9yZXBsYWNlbWVudF90YWJsZSIsImZsYXQiLCJyZWFkX3RyYW5zcG9zZWQiLCJtIiwiZmlsbCIsImoiLCJkeCIsImR5Iiwidk4iLCJmbGF0TWFwIiwieXMiLCJfIiwial9keSIsInkiLCJzbGljZSIsInJlYWRfdHJpZSIsInNvcnRlZCIsImV4cGFuZCIsImRlY29kZSIsIlEiLCJTIiwiQiIsImNwcyIsInNhdmVkIiwiYnIiLCJjcCIsImhleF9jcCIsInRvU3RyaW5nIiwidG9VcHBlckNhc2UiLCJwYWRTdGFydCIsInF1b3RlX2NwIiwiZXhwbG9kZV9jcCIsImxlbiIsImNvZGVQb2ludEF0Iiwic3RyX2Zyb21fY3BzIiwiY2h1bmsiLCJTdHJpbmciLCJmcm9tQ29kZVBvaW50IiwiYnVmIiwiam9pbiIsImNvbXBhcmVfYXJyYXlzIiwiYXJyYXlfcmVwbGFjZSIsImluZGV4T2YiLCJDT01QUkVTU0VEIiwiUzAiLCJMMCIsIlYwIiwiVDAiLCJMX0NPVU5UIiwiVl9DT1VOVCIsIlRfQ09VTlQiLCJOX0NPVU5UIiwiU19DT1VOVCIsIlMxIiwiTDEiLCJWMSIsIlQxIiwidW5wYWNrX2NjIiwicGFja2VkIiwidW5wYWNrX2NwIiwiU0hJRlRFRF9SQU5LIiwiRVhDTFVTSU9OUyIsIkRFQ09NUCIsIlJFQ09NUCIsImluaXQkMSIsInIiLCJTZXQiLCJoYXMiLCJidWNrZXQiLCJnZXQiLCJzZXQiLCJyZXZlcnNlIiwiaXNfaGFuZ3VsIiwiY29tcG9zZV9wYWlyIiwicmVjb21wIiwiZGVjb21wb3NlZCIsImNoZWNrX29yZGVyIiwiYWRkIiwiY2MiLCJzX2luZGV4IiwibF9pbmRleCIsInZfaW5kZXgiLCJ0X2luZGV4IiwibWFwcGVkIiwicG9wIiwicHJldl9jYyIsInRtcCIsImNvbXBvc2VkX2Zyb21fZGVjb21wb3NlZCIsInN0YWNrIiwicHJldl9jcCIsImNvbXBvc2VkIiwibmZkIiwibmZjIiwiSFlQSEVOIiwiU1RPUCIsIlNUT1BfQ0giLCJGRTBGIiwiVU5JUVVFX1BIIiwiQXJyYXlfZnJvbSIsImZyb20iLCJncm91cF9oYXNfY3AiLCJnIiwiUCIsIkVtb2ppIiwiaXNfZW1vamkiLCJNQVBQRUQiLCJJR05PUkVEIiwiQ00iLCJOU00iLCJFU0NBUEUiLCJORkNfQ0hFQ0siLCJHUk9VUFMiLCJXSE9MRV9WQUxJRCIsIldIT0xFX01BUCIsIlZBTElEIiwiRU1PSklfTElTVCIsIkVNT0pJX1JPT1QiLCJpbml0IiwicmVhZF9zb3J0ZWRfYXJyYXkiLCJyZWFkX3NvcnRlZF9zZXQiLCJzZXRfYWRkX21hbnkiLCJjaHVua3MiLCJ1bnJlc3RyaWN0ZWQiLCJyZWFkX2NodW5rZWQiLCJSIiwiTSIsIndob2xlcyIsImNvbmNhdCIsInNvcnQiLCJkIiwiViIsInZhbHVlcyIsInJlY3MiLCJncyIsImZpbHRlciIsInJlYyIsImZpbmQiLCJHIiwic29tZSIsInVuaW9uIiwiY29tcGxlbWVudCIsIm11bHRpIiwiYWRkX3RvX3VuaW9uIiwibm9kZSIsImNoaWxkIiwicXVvdGVkX2NwIiwic2hvdWxkX2VzY2FwZSIsImJpZGlfcXEiLCJzYWZlX3N0cl9mcm9tX2NwcyIsImNoZWNrX2xhYmVsX2V4dGVuc2lvbiIsIkVycm9yIiwiY2hlY2tfbGVhZGluZ191bmRlcnNjb3JlIiwiVU5ERVJTQ09SRSIsImxhc3RJbmRleE9mIiwiY2hlY2tfZmVuY2VkIiwiZXJyb3JfcGxhY2VtZW50IiwibGFzdCIsIm1hdGNoIiwibWF4IiwiSW5maW5pdHkiLCJxdW90ZXIiLCJpc19jb21iaW5pbmdfbWFyayIsIm9ubHlfbnNtIiwiZW5zX2Vtb2ppIiwiZW5zX25vcm1hbGl6ZV9mcmFnbWVudCIsImZyYWciLCJkZWNvbXBvc2UiLCJuZiIsInNwbGl0IiwibGFiZWwiLCJ0b2tlbnNfZnJvbV9zdHIiLCJmaWx0ZXJfZmUwZiIsImVuc19ub3JtYWxpemUiLCJuYW1lIiwiZmxhdHRlbiIsImVuc19iZWF1dGlmeSIsImxhYmVscyIsInR5cGUiLCJvdXRwdXQiLCJlcnJvciIsImVuc19zcGxpdCIsInByZXNlcnZlX2Vtb2ppIiwiZWYiLCJpbnB1dCIsImluZm8iLCJ0b2tlbnMiLCJ0b2tlbl9jb3VudCIsIm5vcm0iLCJlbW9qaSIsImV2ZXJ5IiwiY2hhcnMiLCJ1bmlxdWUiLCJkZXRlcm1pbmVfZ3JvdXAiLCJjaGVja19ncm91cCIsImNoZWNrX3dob2xlIiwiZXJyIiwiZ3JvdXAiLCJtYWtlciIsInNoYXJlZCIsIndob2xlIiwiZ3JvdXBzIiwiZXJyb3JfZGlzYWxsb3dlZCIsImVycm9yX2dyb3VwX21lbWJlciIsIm1zZyIsIm1lc3NhZ2UiLCJxdW90ZWQiLCJnZyIsIndoZXJlIiwiZSIsImsiLCJjb25zdW1lX2Vtb2ppX3JldmVyc2VkIiwiZWF0ZW4iLCJUWV9WQUxJRCIsIlRZX01BUFBFRCIsIlRZX0lHTk9SRUQiLCJUWV9ESVNBTExPV0VEIiwiVFlfRU1PSkkiLCJUWV9ORkMiLCJUWV9TVE9QIiwiZW5zX3Rva2VuaXplIiwidG9rZW4iLCJpc192YWxpZF9vcl9tYXBwZWQiLCJyZXF1aXJlc19jaGVjayIsImNwczAiLCJzcGxpY2UiLCJ0b2tlbnMwIiwiY29sbGFwc2VfdmFsaWRfdG9rZW5zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/@adraffy/ens-normalize/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/_shortw_utils.js":
/*!*************************************************************************!*\
  !*** ./node_modules/ox/node_modules/@noble/curves/esm/_shortw_utils.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCurve: () => (/* binding */ createCurve),\n/* harmony export */   getHash: () => (/* binding */ getHash)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/hmac */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/**\n * Utilities for short weierstrass curves, combined with noble-hashes.\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\n\n/** connects noble-curves to noble-hashes */ function getHash(hash) {\n    return {\n        hash,\n        hmac: (key, ...msgs)=>(0,_noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__.hmac)(hash, key, (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(...msgs)),\n        randomBytes: _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.randomBytes\n    };\n}\nfunction createCurve(curveDef, defHash) {\n    const create = (hash)=>(0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__.weierstrass)({\n            ...curveDef,\n            ...getHash(hash)\n        });\n    return {\n        ...create(defHash),\n        create\n    };\n} //# sourceMappingURL=_shortw_utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL19zaG9ydHdfdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7O0NBR0MsR0FDRCxvRUFBb0UsR0FDMUI7QUFDcUI7QUFDUDtBQUN4RCwwQ0FBMEMsR0FDbkMsU0FBU0ksUUFBUUMsSUFBSTtJQUN4QixPQUFPO1FBQ0hBO1FBQ0FMLE1BQU0sQ0FBQ00sS0FBSyxHQUFHQyxPQUFTUCx3REFBSUEsQ0FBQ0ssTUFBTUMsS0FBS0wsZ0VBQVdBLElBQUlNO1FBQ3ZETCxXQUFXQSw4REFBQUE7SUFDZjtBQUNKO0FBQ08sU0FBU00sWUFBWUMsUUFBUSxFQUFFQyxPQUFPO0lBQ3pDLE1BQU1DLFNBQVMsQ0FBQ04sT0FBU0YscUVBQVdBLENBQUM7WUFBRSxHQUFHTSxRQUFRO1lBQUUsR0FBR0wsUUFBUUMsS0FBSztRQUFDO0lBQ3JFLE9BQU87UUFBRSxHQUFHTSxPQUFPRCxRQUFRO1FBQUVDO0lBQU87QUFDeEMsRUFDQSx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGF3LXdvcmtzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9fc2hvcnR3X3V0aWxzLmpzPzIxYTQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBVdGlsaXRpZXMgZm9yIHNob3J0IHdlaWVyc3RyYXNzIGN1cnZlcywgY29tYmluZWQgd2l0aCBub2JsZS1oYXNoZXMuXG4gKiBAbW9kdWxlXG4gKi9cbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7IGhtYWMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL2htYWMnO1xuaW1wb3J0IHsgY29uY2F0Qnl0ZXMsIHJhbmRvbUJ5dGVzIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy91dGlscyc7XG5pbXBvcnQgeyB3ZWllcnN0cmFzcyB9IGZyb20gXCIuL2Fic3RyYWN0L3dlaWVyc3RyYXNzLmpzXCI7XG4vKiogY29ubmVjdHMgbm9ibGUtY3VydmVzIHRvIG5vYmxlLWhhc2hlcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEhhc2goaGFzaCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGhhc2gsXG4gICAgICAgIGhtYWM6IChrZXksIC4uLm1zZ3MpID0+IGhtYWMoaGFzaCwga2V5LCBjb25jYXRCeXRlcyguLi5tc2dzKSksXG4gICAgICAgIHJhbmRvbUJ5dGVzLFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ3VydmUoY3VydmVEZWYsIGRlZkhhc2gpIHtcbiAgICBjb25zdCBjcmVhdGUgPSAoaGFzaCkgPT4gd2VpZXJzdHJhc3MoeyAuLi5jdXJ2ZURlZiwgLi4uZ2V0SGFzaChoYXNoKSB9KTtcbiAgICByZXR1cm4geyAuLi5jcmVhdGUoZGVmSGFzaCksIGNyZWF0ZSB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3Nob3J0d191dGlscy5qcy5tYXAiXSwibmFtZXMiOlsiaG1hYyIsImNvbmNhdEJ5dGVzIiwicmFuZG9tQnl0ZXMiLCJ3ZWllcnN0cmFzcyIsImdldEhhc2giLCJoYXNoIiwia2V5IiwibXNncyIsImNyZWF0ZUN1cnZlIiwiY3VydmVEZWYiLCJkZWZIYXNoIiwiY3JlYXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/_shortw_utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/abstract/curve.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ox/node_modules/@noble/curves/esm/abstract/curve.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   pippenger: () => (/* binding */ pippenger),\n/* harmony export */   precomputeMSMUnsafe: () => (/* binding */ precomputeMSMUnsafe),\n/* harmony export */   validateBasic: () => (/* binding */ validateBasic),\n/* harmony export */   wNAF: () => (/* binding */ wNAF)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/abstract/utils.js\");\n/**\n * Methods for elliptic curve multiplication by scalars.\n * Contains wNAF, pippenger\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nfunction constTimeNegate(condition, item) {\n    const neg = item.negate();\n    return condition ? neg : item;\n}\nfunction validateW(W, bits) {\n    if (!Number.isSafeInteger(W) || W <= 0 || W > bits) throw new Error(\"invalid window size, expected [1..\" + bits + \"], got W=\" + W);\n}\nfunction calcWOpts(W, scalarBits) {\n    validateW(W, scalarBits);\n    const windows = Math.ceil(scalarBits / W) + 1; // W=8 33. Not 32, because we skip zero\n    const windowSize = 2 ** (W - 1); // W=8 128. Not 256, because we skip zero\n    const maxNumber = 2 ** W; // W=8 256\n    const mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(W); // W=8 255 == mask 0b11111111\n    const shiftBy = BigInt(W); // W=8 8\n    return {\n        windows,\n        windowSize,\n        mask,\n        maxNumber,\n        shiftBy\n    };\n}\nfunction calcOffsets(n, window, wOpts) {\n    const { windowSize, mask, maxNumber, shiftBy } = wOpts;\n    let wbits = Number(n & mask); // extract W bits.\n    let nextN = n >> shiftBy; // shift number by W bits.\n    // What actually happens here:\n    // const highestBit = Number(mask ^ (mask >> 1n));\n    // let wbits2 = wbits - 1; // skip zero\n    // if (wbits2 & highestBit) { wbits2 ^= Number(mask); // (~);\n    // split if bits > max: +224 => 256-32\n    if (wbits > windowSize) {\n        // we skip zero, which means instead of `>= size-1`, we do `> size`\n        wbits -= maxNumber; // -32, can be maxNumber - wbits, but then we need to set isNeg here.\n        nextN += _1n; // +256 (carry)\n    }\n    const offsetStart = window * windowSize;\n    const offset = offsetStart + Math.abs(wbits) - 1; // -1 because we skip zero\n    const isZero = wbits === 0; // is current window slice a 0?\n    const isNeg = wbits < 0; // is current window slice negative?\n    const isNegF = window % 2 !== 0; // fake random statement for noise\n    const offsetF = offsetStart; // fake offset for noise\n    return {\n        nextN,\n        offset,\n        isZero,\n        isNeg,\n        isNegF,\n        offsetF\n    };\n}\nfunction validateMSMPoints(points, c) {\n    if (!Array.isArray(points)) throw new Error(\"array expected\");\n    points.forEach((p, i)=>{\n        if (!(p instanceof c)) throw new Error(\"invalid point at index \" + i);\n    });\n}\nfunction validateMSMScalars(scalars, field) {\n    if (!Array.isArray(scalars)) throw new Error(\"array of scalars expected\");\n    scalars.forEach((s, i)=>{\n        if (!field.isValid(s)) throw new Error(\"invalid scalar at index \" + i);\n    });\n}\n// Since points in different groups cannot be equal (different object constructor),\n// we can have single place to store precomputes.\n// Allows to make points frozen / immutable.\nconst pointPrecomputes = new WeakMap();\nconst pointWindowSizes = new WeakMap();\nfunction getW(P) {\n    return pointWindowSizes.get(P) || 1;\n}\n/**\n * Elliptic curve multiplication of Point by scalar. Fragile.\n * Scalars should always be less than curve order: this should be checked inside of a curve itself.\n * Creates precomputation tables for fast multiplication:\n * - private scalar is split by fixed size windows of W bits\n * - every window point is collected from window's table & added to accumulator\n * - since windows are different, same point inside tables won't be accessed more than once per calc\n * - each multiplication is 'Math.ceil(CURVE_ORDER / ùëä) + 1' point additions (fixed for any scalar)\n * - +1 window is neccessary for wNAF\n * - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n *\n * @todo Research returning 2d JS array of windows, instead of a single window.\n * This would allow windows to be in different memory locations\n */ function wNAF(c, bits) {\n    return {\n        constTimeNegate,\n        hasPrecomputes (elm) {\n            return getW(elm) !== 1;\n        },\n        // non-const time multiplication ladder\n        unsafeLadder (elm, n, p = c.ZERO) {\n            let d = elm;\n            while(n > _0n){\n                if (n & _1n) p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(ùëä‚àí1) * (Math.ceil(ùëõ / ùëä) + 1), where:\n         * - ùëä is the window size\n         * - ùëõ is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @param elm Point instance\n         * @param W window size\n         * @returns precomputed point tables flattened to a single array\n         */ precomputeWindow (elm, W) {\n            const { windows, windowSize } = calcWOpts(W, bits);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for(let window = 0; window < windows; window++){\n                base = p;\n                points.push(base);\n                // i=1, bc we skip 0\n                for(let i = 1; i < windowSize; i++){\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */ wNAF (W, precomputes, n) {\n            // Smaller version:\n            // https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541\n            // TODO: check the scalar is less than group order?\n            // wNAF behavior is undefined otherwise. But have to carefully remove\n            // other checks before wNAF. ORDER == bits here.\n            // Accumulators\n            let p = c.ZERO;\n            let f = c.BASE;\n            // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n            // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n            // there is negate now: it is possible that negated element from low value\n            // would be the same as high element, which will create carry into next window.\n            // It's not obvious how this can fail, but still worth investigating later.\n            const wo = calcWOpts(W, bits);\n            for(let window = 0; window < wo.windows; window++){\n                // (n === _0n) is handled and not early-exited. isEven and offsetF are used for noise\n                const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window, wo);\n                n = nextN;\n                if (isZero) {\n                    // bits are 0: add garbage to fake point\n                    // Important part for const-time getPublicKey: add random \"noise\" point to f.\n                    f = f.add(constTimeNegate(isNegF, precomputes[offsetF]));\n                } else {\n                    // bits are 1: add to result point\n                    p = p.add(constTimeNegate(isNeg, precomputes[offset]));\n                }\n            }\n            // Return both real and fake points: JIT won't eliminate f.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return {\n                p,\n                f\n            };\n        },\n        /**\n         * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @param acc accumulator point to add result of multiplication\n         * @returns point\n         */ wNAFUnsafe (W, precomputes, n, acc = c.ZERO) {\n            const wo = calcWOpts(W, bits);\n            for(let window = 0; window < wo.windows; window++){\n                if (n === _0n) break; // Early-exit, skip 0 value\n                const { nextN, offset, isZero, isNeg } = calcOffsets(n, window, wo);\n                n = nextN;\n                if (isZero) {\n                    continue;\n                } else {\n                    const item = precomputes[offset];\n                    acc = acc.add(isNeg ? item.negate() : item); // Re-using acc allows to save adds in MSM\n                }\n            }\n            return acc;\n        },\n        getPrecomputes (W, P, transform) {\n            // Calculate precomputes on a first run, reuse them after\n            let comp = pointPrecomputes.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1) pointPrecomputes.set(P, transform(comp));\n            }\n            return comp;\n        },\n        wNAFCached (P, n, transform) {\n            const W = getW(P);\n            return this.wNAF(W, this.getPrecomputes(W, P, transform), n);\n        },\n        wNAFCachedUnsafe (P, n, transform, prev) {\n            const W = getW(P);\n            if (W === 1) return this.unsafeLadder(P, n, prev); // For W=1 ladder is ~x2 faster\n            return this.wNAFUnsafe(W, this.getPrecomputes(W, P, transform), n, prev);\n        },\n        // We calculate precomputes for elliptic curve point multiplication\n        // using windowed method. This specifies window size and\n        // stores precomputed values. Usually only base point would be precomputed.\n        setWindowSize (P, W) {\n            validateW(W, bits);\n            pointWindowSizes.set(P, W);\n            pointPrecomputes.delete(P);\n        }\n    };\n}\n/**\n * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * 30x faster vs naive addition on L=4096, 10x faster than precomputes.\n * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.\n * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @param scalars array of L scalars (aka private keys / bigints)\n */ function pippenger(c, fieldN, points, scalars) {\n    // If we split scalars by some window (let's say 8 bits), every chunk will only\n    // take 256 buckets even if there are 4096 scalars, also re-uses double.\n    // TODO:\n    // - https://eprint.iacr.org/2024/750.pdf\n    // - https://tches.iacr.org/index.php/TCHES/article/view/10287\n    // 0 is accepted in scalars\n    validateMSMPoints(points, c);\n    validateMSMScalars(scalars, fieldN);\n    const plength = points.length;\n    const slength = scalars.length;\n    if (plength !== slength) throw new Error(\"arrays of points and scalars must have equal length\");\n    // if (plength === 0) throw new Error('array must be of length >= 2');\n    const zero = c.ZERO;\n    const wbits = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitLen)(BigInt(plength));\n    let windowSize = 1; // bits\n    if (wbits > 12) windowSize = wbits - 3;\n    else if (wbits > 4) windowSize = wbits - 2;\n    else if (wbits > 0) windowSize = 2;\n    const MASK = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(windowSize);\n    const buckets = new Array(Number(MASK) + 1).fill(zero); // +1 for zero array\n    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;\n    let sum = zero;\n    for(let i = lastBits; i >= 0; i -= windowSize){\n        buckets.fill(zero);\n        for(let j = 0; j < slength; j++){\n            const scalar = scalars[j];\n            const wbits = Number(scalar >> BigInt(i) & MASK);\n            buckets[wbits] = buckets[wbits].add(points[j]);\n        }\n        let resI = zero; // not using this will do small speed-up, but will lose ct\n        // Skip first bucket, because it is zero\n        for(let j = buckets.length - 1, sumI = zero; j > 0; j--){\n            sumI = sumI.add(buckets[j]);\n            resI = resI.add(sumI);\n        }\n        sum = sum.add(resI);\n        if (i !== 0) for(let j = 0; j < windowSize; j++)sum = sum.double();\n    }\n    return sum;\n}\n/**\n * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @returns function which multiplies points with scaars\n */ function precomputeMSMUnsafe(c, fieldN, points, windowSize) {\n    /**\n     * Performance Analysis of Window-based Precomputation\n     *\n     * Base Case (256-bit scalar, 8-bit window):\n     * - Standard precomputation requires:\n     *   - 31 additions per scalar √ó 256 scalars = 7,936 ops\n     *   - Plus 255 summary additions = 8,191 total ops\n     *   Note: Summary additions can be optimized via accumulator\n     *\n     * Chunked Precomputation Analysis:\n     * - Using 32 chunks requires:\n     *   - 255 additions per chunk\n     *   - 256 doublings\n     *   - Total: (255 √ó 32) + 256 = 8,416 ops\n     *\n     * Memory Usage Comparison:\n     * Window Size | Standard Points | Chunked Points\n     * ------------|-----------------|---------------\n     *     4-bit   |     520         |      15\n     *     8-bit   |    4,224        |     255\n     *    10-bit   |   13,824        |   1,023\n     *    16-bit   |  557,056        |  65,535\n     *\n     * Key Advantages:\n     * 1. Enables larger window sizes due to reduced memory overhead\n     * 2. More efficient for smaller scalar counts:\n     *    - 16 chunks: (16 √ó 255) + 256 = 4,336 ops\n     *    - ~2x faster than standard 8,191 ops\n     *\n     * Limitations:\n     * - Not suitable for plain precomputes (requires 256 constant doublings)\n     * - Performance degrades with larger scalar counts:\n     *   - Optimal for ~256 scalars\n     *   - Less efficient for 4096+ scalars (Pippenger preferred)\n     */ validateW(windowSize, fieldN.BITS);\n    validateMSMPoints(points, c);\n    const zero = c.ZERO;\n    const tableSize = 2 ** windowSize - 1; // table size (without zero)\n    const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item\n    const MASK = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(windowSize);\n    const tables = points.map((p)=>{\n        const res = [];\n        for(let i = 0, acc = p; i < tableSize; i++){\n            res.push(acc);\n            acc = acc.add(p);\n        }\n        return res;\n    });\n    return (scalars)=>{\n        validateMSMScalars(scalars, fieldN);\n        if (scalars.length > points.length) throw new Error(\"array of scalars must be smaller than array of points\");\n        let res = zero;\n        for(let i = 0; i < chunks; i++){\n            // No need to double if accumulator is still zero.\n            if (res !== zero) for(let j = 0; j < windowSize; j++)res = res.double();\n            const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);\n            for(let j = 0; j < scalars.length; j++){\n                const n = scalars[j];\n                const curr = Number(n >> shiftBy & MASK);\n                if (!curr) continue; // skip zero scalars chunks\n                res = res.add(tables[j][curr - 1]);\n            }\n        }\n        return res;\n    };\n}\nfunction validateBasic(curve) {\n    (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.validateField)(curve.Fp);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(curve, {\n        n: \"bigint\",\n        h: \"bigint\",\n        Gx: \"field\",\n        Gy: \"field\"\n    }, {\n        nBitLength: \"isSafeInteger\",\n        nByteLength: \"isSafeInteger\"\n    });\n    // Set defaults\n    return Object.freeze({\n        ...(0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.nLength)(curve.n, curve.nBitLength),\n        ...curve,\n        ...{\n            p: curve.Fp.ORDER\n        }\n    });\n} //# sourceMappingURL=curve.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L2N1cnZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOzs7O0NBSUMsR0FDRCxvRUFBb0UsR0FDZDtBQUNPO0FBQzdELE1BQU1LLE1BQU1DLE9BQU87QUFDbkIsTUFBTUMsTUFBTUQsT0FBTztBQUNuQixTQUFTRSxnQkFBZ0JDLFNBQVMsRUFBRUMsSUFBSTtJQUNwQyxNQUFNQyxNQUFNRCxLQUFLRSxNQUFNO0lBQ3ZCLE9BQU9ILFlBQVlFLE1BQU1EO0FBQzdCO0FBQ0EsU0FBU0csVUFBVUMsQ0FBQyxFQUFFQyxJQUFJO0lBQ3RCLElBQUksQ0FBQ0MsT0FBT0MsYUFBYSxDQUFDSCxNQUFNQSxLQUFLLEtBQUtBLElBQUlDLE1BQzFDLE1BQU0sSUFBSUcsTUFBTSx1Q0FBdUNILE9BQU8sY0FBY0Q7QUFDcEY7QUFDQSxTQUFTSyxVQUFVTCxDQUFDLEVBQUVNLFVBQVU7SUFDNUJQLFVBQVVDLEdBQUdNO0lBQ2IsTUFBTUMsVUFBVUMsS0FBS0MsSUFBSSxDQUFDSCxhQUFhTixLQUFLLEdBQUcsdUNBQXVDO0lBQ3RGLE1BQU1VLGFBQWEsS0FBTVYsQ0FBQUEsSUFBSSxJQUFJLHlDQUF5QztJQUMxRSxNQUFNVyxZQUFZLEtBQUtYLEdBQUcsVUFBVTtJQUNwQyxNQUFNWSxPQUFPdkIsa0RBQU9BLENBQUNXLElBQUksNkJBQTZCO0lBQ3RELE1BQU1hLFVBQVVyQixPQUFPUSxJQUFJLFFBQVE7SUFDbkMsT0FBTztRQUFFTztRQUFTRztRQUFZRTtRQUFNRDtRQUFXRTtJQUFRO0FBQzNEO0FBQ0EsU0FBU0MsWUFBWUMsQ0FBQyxFQUFFQyxNQUFNLEVBQUVDLEtBQUs7SUFDakMsTUFBTSxFQUFFUCxVQUFVLEVBQUVFLElBQUksRUFBRUQsU0FBUyxFQUFFRSxPQUFPLEVBQUUsR0FBR0k7SUFDakQsSUFBSUMsUUFBUWhCLE9BQU9hLElBQUlILE9BQU8sa0JBQWtC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LE1BQU0sQ0FBQ1AsRUFBRSxDQUFDVSxPQUFPLEVBQUU7WUFDckM7UUFDSjtRQUNBLE9BQU9EO0lBQ1g7QUFDSjtBQUNPLFNBQVNFLGNBQWNDLEtBQUs7SUFDL0I5RywwREFBYUEsQ0FBQzhHLE1BQU1DLEVBQUU7SUFDdEI1Ryx5REFBY0EsQ0FBQzJHLE9BQU87UUFDbEJsRixHQUFHO1FBQ0hvRixHQUFHO1FBQ0hDLElBQUk7UUFDSkMsSUFBSTtJQUNSLEdBQUc7UUFDQ0MsWUFBWTtRQUNaQyxhQUFhO0lBQ2pCO0lBQ0EsZUFBZTtJQUNmLE9BQU9DLE9BQU9DLE1BQU0sQ0FBQztRQUNqQixHQUFHdkgsb0RBQU9BLENBQUMrRyxNQUFNbEYsQ0FBQyxFQUFFa0YsTUFBTUssVUFBVSxDQUFDO1FBQ3JDLEdBQUdMLEtBQUs7UUFDUixHQUFHO1lBQUVoRSxHQUFHZ0UsTUFBTUMsRUFBRSxDQUFDUSxLQUFLO1FBQUMsQ0FBQztJQUM1QjtBQUNKLEVBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xhdy13b3Jrcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvY3VydmUuanM/ZWVjMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE1ldGhvZHMgZm9yIGVsbGlwdGljIGN1cnZlIG11bHRpcGxpY2F0aW9uIGJ5IHNjYWxhcnMuXG4gKiBDb250YWlucyB3TkFGLCBwaXBwZW5nZXJcbiAqIEBtb2R1bGVcbiAqL1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHsgbkxlbmd0aCwgdmFsaWRhdGVGaWVsZCB9IGZyb20gXCIuL21vZHVsYXIuanNcIjtcbmltcG9ydCB7IGJpdExlbiwgYml0TWFzaywgdmFsaWRhdGVPYmplY3QgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuY29uc3QgXzBuID0gQmlnSW50KDApO1xuY29uc3QgXzFuID0gQmlnSW50KDEpO1xuZnVuY3Rpb24gY29uc3RUaW1lTmVnYXRlKGNvbmRpdGlvbiwgaXRlbSkge1xuICAgIGNvbnN0IG5lZyA9IGl0ZW0ubmVnYXRlKCk7XG4gICAgcmV0dXJuIGNvbmRpdGlvbiA/IG5lZyA6IGl0ZW07XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVcoVywgYml0cykge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoVykgfHwgVyA8PSAwIHx8IFcgPiBiaXRzKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgd2luZG93IHNpemUsIGV4cGVjdGVkIFsxLi4nICsgYml0cyArICddLCBnb3QgVz0nICsgVyk7XG59XG5mdW5jdGlvbiBjYWxjV09wdHMoVywgc2NhbGFyQml0cykge1xuICAgIHZhbGlkYXRlVyhXLCBzY2FsYXJCaXRzKTtcbiAgICBjb25zdCB3aW5kb3dzID0gTWF0aC5jZWlsKHNjYWxhckJpdHMgLyBXKSArIDE7IC8vIFc9OCAzMy4gTm90IDMyLCBiZWNhdXNlIHdlIHNraXAgemVyb1xuICAgIGNvbnN0IHdpbmRvd1NpemUgPSAyICoqIChXIC0gMSk7IC8vIFc9OCAxMjguIE5vdCAyNTYsIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgY29uc3QgbWF4TnVtYmVyID0gMiAqKiBXOyAvLyBXPTggMjU2XG4gICAgY29uc3QgbWFzayA9IGJpdE1hc2soVyk7IC8vIFc9OCAyNTUgPT0gbWFzayAwYjExMTExMTExXG4gICAgY29uc3Qgc2hpZnRCeSA9IEJpZ0ludChXKTsgLy8gVz04IDhcbiAgICByZXR1cm4geyB3aW5kb3dzLCB3aW5kb3dTaXplLCBtYXNrLCBtYXhOdW1iZXIsIHNoaWZ0QnkgfTtcbn1cbmZ1bmN0aW9uIGNhbGNPZmZzZXRzKG4sIHdpbmRvdywgd09wdHMpIHtcbiAgICBjb25zdCB7IHdpbmRvd1NpemUsIG1hc2ssIG1heE51bWJlciwgc2hpZnRCeSB9ID0gd09wdHM7XG4gICAgbGV0IHdiaXRzID0gTnVtYmVyKG4gJiBtYXNrKTsgLy8gZXh0cmFjdCBXIGJpdHMuXG4gICAgbGV0IG5leHROID0gbiA+PiBzaGlmdEJ5OyAvLyBzaGlmdCBudW1iZXIgYnkgVyBiaXRzLlxuICAgIC8vIFdoYXQgYWN0dWFsbHkgaGFwcGVucyBoZXJlOlxuICAgIC8vIGNvbnN0IGhpZ2hlc3RCaXQgPSBOdW1iZXIobWFzayBeIChtYXNrID4+IDFuKSk7XG4gICAgLy8gbGV0IHdiaXRzMiA9IHdiaXRzIC0gMTsgLy8gc2tpcCB6ZXJvXG4gICAgLy8gaWYgKHdiaXRzMiAmIGhpZ2hlc3RCaXQpIHsgd2JpdHMyIF49IE51bWJlcihtYXNrKTsgLy8gKH4pO1xuICAgIC8vIHNwbGl0IGlmIGJpdHMgPiBtYXg6ICsyMjQgPT4gMjU2LTMyXG4gICAgaWYgKHdiaXRzID4gd2luZG93U2l6ZSkge1xuICAgICAgICAvLyB3ZSBza2lwIHplcm8sIHdoaWNoIG1lYW5zIGluc3RlYWQgb2YgYD49IHNpemUtMWAsIHdlIGRvIGA+IHNpemVgXG4gICAgICAgIHdiaXRzIC09IG1heE51bWJlcjsgLy8gLTMyLCBjYW4gYmUgbWF4TnVtYmVyIC0gd2JpdHMsIGJ1dCB0aGVuIHdlIG5lZWQgdG8gc2V0IGlzTmVnIGhlcmUuXG4gICAgICAgIG5leHROICs9IF8xbjsgLy8gKzI1NiAoY2FycnkpXG4gICAgfVxuICAgIGNvbnN0IG9mZnNldFN0YXJ0ID0gd2luZG93ICogd2luZG93U2l6ZTtcbiAgICBjb25zdCBvZmZzZXQgPSBvZmZzZXRTdGFydCArIE1hdGguYWJzKHdiaXRzKSAtIDE7IC8vIC0xIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgY29uc3QgaXNaZXJvID0gd2JpdHMgPT09IDA7IC8vIGlzIGN1cnJlbnQgd2luZG93IHNsaWNlIGEgMD9cbiAgICBjb25zdCBpc05lZyA9IHdiaXRzIDwgMDsgLy8gaXMgY3VycmVudCB3aW5kb3cgc2xpY2UgbmVnYXRpdmU/XG4gICAgY29uc3QgaXNOZWdGID0gd2luZG93ICUgMiAhPT0gMDsgLy8gZmFrZSByYW5kb20gc3RhdGVtZW50IGZvciBub2lzZVxuICAgIGNvbnN0IG9mZnNldEYgPSBvZmZzZXRTdGFydDsgLy8gZmFrZSBvZmZzZXQgZm9yIG5vaXNlXG4gICAgcmV0dXJuIHsgbmV4dE4sIG9mZnNldCwgaXNaZXJvLCBpc05lZywgaXNOZWdGLCBvZmZzZXRGIH07XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU1TTVBvaW50cyhwb2ludHMsIGMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocG9pbnRzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcnJheSBleHBlY3RlZCcpO1xuICAgIHBvaW50cy5mb3JFYWNoKChwLCBpKSA9PiB7XG4gICAgICAgIGlmICghKHAgaW5zdGFuY2VvZiBjKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwb2ludCBhdCBpbmRleCAnICsgaSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU1TTVNjYWxhcnMoc2NhbGFycywgZmllbGQpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NhbGFycykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYXJyYXkgb2Ygc2NhbGFycyBleHBlY3RlZCcpO1xuICAgIHNjYWxhcnMuZm9yRWFjaCgocywgaSkgPT4ge1xuICAgICAgICBpZiAoIWZpZWxkLmlzVmFsaWQocykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2NhbGFyIGF0IGluZGV4ICcgKyBpKTtcbiAgICB9KTtcbn1cbi8vIFNpbmNlIHBvaW50cyBpbiBkaWZmZXJlbnQgZ3JvdXBzIGNhbm5vdCBiZSBlcXVhbCAoZGlmZmVyZW50IG9iamVjdCBjb25zdHJ1Y3RvciksXG4vLyB3ZSBjYW4gaGF2ZSBzaW5nbGUgcGxhY2UgdG8gc3RvcmUgcHJlY29tcHV0ZXMuXG4vLyBBbGxvd3MgdG8gbWFrZSBwb2ludHMgZnJvemVuIC8gaW1tdXRhYmxlLlxuY29uc3QgcG9pbnRQcmVjb21wdXRlcyA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCBwb2ludFdpbmRvd1NpemVzID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIGdldFcoUCkge1xuICAgIHJldHVybiBwb2ludFdpbmRvd1NpemVzLmdldChQKSB8fCAxO1xufVxuLyoqXG4gKiBFbGxpcHRpYyBjdXJ2ZSBtdWx0aXBsaWNhdGlvbiBvZiBQb2ludCBieSBzY2FsYXIuIEZyYWdpbGUuXG4gKiBTY2FsYXJzIHNob3VsZCBhbHdheXMgYmUgbGVzcyB0aGFuIGN1cnZlIG9yZGVyOiB0aGlzIHNob3VsZCBiZSBjaGVja2VkIGluc2lkZSBvZiBhIGN1cnZlIGl0c2VsZi5cbiAqIENyZWF0ZXMgcHJlY29tcHV0YXRpb24gdGFibGVzIGZvciBmYXN0IG11bHRpcGxpY2F0aW9uOlxuICogLSBwcml2YXRlIHNjYWxhciBpcyBzcGxpdCBieSBmaXhlZCBzaXplIHdpbmRvd3Mgb2YgVyBiaXRzXG4gKiAtIGV2ZXJ5IHdpbmRvdyBwb2ludCBpcyBjb2xsZWN0ZWQgZnJvbSB3aW5kb3cncyB0YWJsZSAmIGFkZGVkIHRvIGFjY3VtdWxhdG9yXG4gKiAtIHNpbmNlIHdpbmRvd3MgYXJlIGRpZmZlcmVudCwgc2FtZSBwb2ludCBpbnNpZGUgdGFibGVzIHdvbid0IGJlIGFjY2Vzc2VkIG1vcmUgdGhhbiBvbmNlIHBlciBjYWxjXG4gKiAtIGVhY2ggbXVsdGlwbGljYXRpb24gaXMgJ01hdGguY2VpbChDVVJWRV9PUkRFUiAvIPCdkYopICsgMScgcG9pbnQgYWRkaXRpb25zIChmaXhlZCBmb3IgYW55IHNjYWxhcilcbiAqIC0gKzEgd2luZG93IGlzIG5lY2Nlc3NhcnkgZm9yIHdOQUZcbiAqIC0gd05BRiByZWR1Y2VzIHRhYmxlIHNpemU6IDJ4IGxlc3MgbWVtb3J5ICsgMnggZmFzdGVyIGdlbmVyYXRpb24sIGJ1dCAxMCUgc2xvd2VyIG11bHRpcGxpY2F0aW9uXG4gKlxuICogQHRvZG8gUmVzZWFyY2ggcmV0dXJuaW5nIDJkIEpTIGFycmF5IG9mIHdpbmRvd3MsIGluc3RlYWQgb2YgYSBzaW5nbGUgd2luZG93LlxuICogVGhpcyB3b3VsZCBhbGxvdyB3aW5kb3dzIHRvIGJlIGluIGRpZmZlcmVudCBtZW1vcnkgbG9jYXRpb25zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3TkFGKGMsIGJpdHMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb25zdFRpbWVOZWdhdGUsXG4gICAgICAgIGhhc1ByZWNvbXB1dGVzKGVsbSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldFcoZWxtKSAhPT0gMTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gbm9uLWNvbnN0IHRpbWUgbXVsdGlwbGljYXRpb24gbGFkZGVyXG4gICAgICAgIHVuc2FmZUxhZGRlcihlbG0sIG4sIHAgPSBjLlpFUk8pIHtcbiAgICAgICAgICAgIGxldCBkID0gZWxtO1xuICAgICAgICAgICAgd2hpbGUgKG4gPiBfMG4pIHtcbiAgICAgICAgICAgICAgICBpZiAobiAmIF8xbilcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAuYWRkKGQpO1xuICAgICAgICAgICAgICAgIGQgPSBkLmRvdWJsZSgpO1xuICAgICAgICAgICAgICAgIG4gPj49IF8xbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHdOQUYgcHJlY29tcHV0YXRpb24gd2luZG93LiBVc2VkIGZvciBjYWNoaW5nLlxuICAgICAgICAgKiBEZWZhdWx0IHdpbmRvdyBzaXplIGlzIHNldCBieSBgdXRpbHMucHJlY29tcHV0ZSgpYCBhbmQgaXMgZXF1YWwgdG8gOC5cbiAgICAgICAgICogTnVtYmVyIG9mIHByZWNvbXB1dGVkIHBvaW50cyBkZXBlbmRzIG9uIHRoZSBjdXJ2ZSBzaXplOlxuICAgICAgICAgKiAyXijwnZGK4oiSMSkgKiAoTWF0aC5jZWlsKPCdkZsgLyDwnZGKKSArIDEpLCB3aGVyZTpcbiAgICAgICAgICogLSDwnZGKIGlzIHRoZSB3aW5kb3cgc2l6ZVxuICAgICAgICAgKiAtIPCdkZsgaXMgdGhlIGJpdGxlbmd0aCBvZiB0aGUgY3VydmUgb3JkZXIuXG4gICAgICAgICAqIEZvciBhIDI1Ni1iaXQgY3VydmUgYW5kIHdpbmRvdyBzaXplIDgsIHRoZSBudW1iZXIgb2YgcHJlY29tcHV0ZWQgcG9pbnRzIGlzIDEyOCAqIDMzID0gNDIyNC5cbiAgICAgICAgICogQHBhcmFtIGVsbSBQb2ludCBpbnN0YW5jZVxuICAgICAgICAgKiBAcGFyYW0gVyB3aW5kb3cgc2l6ZVxuICAgICAgICAgKiBAcmV0dXJucyBwcmVjb21wdXRlZCBwb2ludCB0YWJsZXMgZmxhdHRlbmVkIHRvIGEgc2luZ2xlIGFycmF5XG4gICAgICAgICAqL1xuICAgICAgICBwcmVjb21wdXRlV2luZG93KGVsbSwgVykge1xuICAgICAgICAgICAgY29uc3QgeyB3aW5kb3dzLCB3aW5kb3dTaXplIH0gPSBjYWxjV09wdHMoVywgYml0cyk7XG4gICAgICAgICAgICBjb25zdCBwb2ludHMgPSBbXTtcbiAgICAgICAgICAgIGxldCBwID0gZWxtO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSBwO1xuICAgICAgICAgICAgZm9yIChsZXQgd2luZG93ID0gMDsgd2luZG93IDwgd2luZG93czsgd2luZG93KyspIHtcbiAgICAgICAgICAgICAgICBiYXNlID0gcDtcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaChiYXNlKTtcbiAgICAgICAgICAgICAgICAvLyBpPTEsIGJjIHdlIHNraXAgMFxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgd2luZG93U2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhc2UgPSBiYXNlLmFkZChwKTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goYmFzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHAgPSBiYXNlLmRvdWJsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEltcGxlbWVudHMgZWMgbXVsdGlwbGljYXRpb24gdXNpbmcgcHJlY29tcHV0ZWQgdGFibGVzIGFuZCB3LWFyeSBub24tYWRqYWNlbnQgZm9ybS5cbiAgICAgICAgICogQHBhcmFtIFcgd2luZG93IHNpemVcbiAgICAgICAgICogQHBhcmFtIHByZWNvbXB1dGVzIHByZWNvbXB1dGVkIHRhYmxlc1xuICAgICAgICAgKiBAcGFyYW0gbiBzY2FsYXIgKHdlIGRvbid0IGNoZWNrIGhlcmUsIGJ1dCBzaG91bGQgYmUgbGVzcyB0aGFuIGN1cnZlIG9yZGVyKVxuICAgICAgICAgKiBAcmV0dXJucyByZWFsIGFuZCBmYWtlIChmb3IgY29uc3QtdGltZSkgcG9pbnRzXG4gICAgICAgICAqL1xuICAgICAgICB3TkFGKFcsIHByZWNvbXB1dGVzLCBuKSB7XG4gICAgICAgICAgICAvLyBTbWFsbGVyIHZlcnNpb246XG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcGF1bG1pbGxyL25vYmxlLXNlY3AyNTZrMS9ibG9iLzQ3Y2IxNjY5YjZlNTA2YWQ2NmIzNWZlN2Q3NjEzMmFlOTc0NjVkYTIvaW5kZXgudHMjTDUwMi1MNTQxXG4gICAgICAgICAgICAvLyBUT0RPOiBjaGVjayB0aGUgc2NhbGFyIGlzIGxlc3MgdGhhbiBncm91cCBvcmRlcj9cbiAgICAgICAgICAgIC8vIHdOQUYgYmVoYXZpb3IgaXMgdW5kZWZpbmVkIG90aGVyd2lzZS4gQnV0IGhhdmUgdG8gY2FyZWZ1bGx5IHJlbW92ZVxuICAgICAgICAgICAgLy8gb3RoZXIgY2hlY2tzIGJlZm9yZSB3TkFGLiBPUkRFUiA9PSBiaXRzIGhlcmUuXG4gICAgICAgICAgICAvLyBBY2N1bXVsYXRvcnNcbiAgICAgICAgICAgIGxldCBwID0gYy5aRVJPO1xuICAgICAgICAgICAgbGV0IGYgPSBjLkJBU0U7XG4gICAgICAgICAgICAvLyBUaGlzIGNvZGUgd2FzIGZpcnN0IHdyaXR0ZW4gd2l0aCBhc3N1bXB0aW9uIHRoYXQgJ2YnIGFuZCAncCcgd2lsbCBuZXZlciBiZSBpbmZpbml0eSBwb2ludDpcbiAgICAgICAgICAgIC8vIHNpbmNlIGVhY2ggYWRkaXRpb24gaXMgbXVsdGlwbGllZCBieSAyICoqIFcsIGl0IGNhbm5vdCBjYW5jZWwgZWFjaCBvdGhlci4gSG93ZXZlcixcbiAgICAgICAgICAgIC8vIHRoZXJlIGlzIG5lZ2F0ZSBub3c6IGl0IGlzIHBvc3NpYmxlIHRoYXQgbmVnYXRlZCBlbGVtZW50IGZyb20gbG93IHZhbHVlXG4gICAgICAgICAgICAvLyB3b3VsZCBiZSB0aGUgc2FtZSBhcyBoaWdoIGVsZW1lbnQsIHdoaWNoIHdpbGwgY3JlYXRlIGNhcnJ5IGludG8gbmV4dCB3aW5kb3cuXG4gICAgICAgICAgICAvLyBJdCdzIG5vdCBvYnZpb3VzIGhvdyB0aGlzIGNhbiBmYWlsLCBidXQgc3RpbGwgd29ydGggaW52ZXN0aWdhdGluZyBsYXRlci5cbiAgICAgICAgICAgIGNvbnN0IHdvID0gY2FsY1dPcHRzKFcsIGJpdHMpO1xuICAgICAgICAgICAgZm9yIChsZXQgd2luZG93ID0gMDsgd2luZG93IDwgd28ud2luZG93czsgd2luZG93KyspIHtcbiAgICAgICAgICAgICAgICAvLyAobiA9PT0gXzBuKSBpcyBoYW5kbGVkIGFuZCBub3QgZWFybHktZXhpdGVkLiBpc0V2ZW4gYW5kIG9mZnNldEYgYXJlIHVzZWQgZm9yIG5vaXNlXG4gICAgICAgICAgICAgICAgY29uc3QgeyBuZXh0Tiwgb2Zmc2V0LCBpc1plcm8sIGlzTmVnLCBpc05lZ0YsIG9mZnNldEYgfSA9IGNhbGNPZmZzZXRzKG4sIHdpbmRvdywgd28pO1xuICAgICAgICAgICAgICAgIG4gPSBuZXh0TjtcbiAgICAgICAgICAgICAgICBpZiAoaXNaZXJvKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGJpdHMgYXJlIDA6IGFkZCBnYXJiYWdlIHRvIGZha2UgcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gSW1wb3J0YW50IHBhcnQgZm9yIGNvbnN0LXRpbWUgZ2V0UHVibGljS2V5OiBhZGQgcmFuZG9tIFwibm9pc2VcIiBwb2ludCB0byBmLlxuICAgICAgICAgICAgICAgICAgICBmID0gZi5hZGQoY29uc3RUaW1lTmVnYXRlKGlzTmVnRiwgcHJlY29tcHV0ZXNbb2Zmc2V0Rl0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGJpdHMgYXJlIDE6IGFkZCB0byByZXN1bHQgcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAuYWRkKGNvbnN0VGltZU5lZ2F0ZShpc05lZywgcHJlY29tcHV0ZXNbb2Zmc2V0XSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJldHVybiBib3RoIHJlYWwgYW5kIGZha2UgcG9pbnRzOiBKSVQgd29uJ3QgZWxpbWluYXRlIGYuXG4gICAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50IHRoZXJlIGlzIGEgd2F5IHRvIEYgYmUgaW5maW5pdHktcG9pbnQgZXZlbiBpZiBwIGlzIG5vdCxcbiAgICAgICAgICAgIC8vIHdoaWNoIG1ha2VzIGl0IGxlc3MgY29uc3QtdGltZTogYXJvdW5kIDEgYmlnaW50IG11bHRpcGx5LlxuICAgICAgICAgICAgcmV0dXJuIHsgcCwgZiB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogSW1wbGVtZW50cyBlYyB1bnNhZmUgKG5vbiBjb25zdC10aW1lKSBtdWx0aXBsaWNhdGlvbiB1c2luZyBwcmVjb21wdXRlZCB0YWJsZXMgYW5kIHctYXJ5IG5vbi1hZGphY2VudCBmb3JtLlxuICAgICAgICAgKiBAcGFyYW0gVyB3aW5kb3cgc2l6ZVxuICAgICAgICAgKiBAcGFyYW0gcHJlY29tcHV0ZXMgcHJlY29tcHV0ZWQgdGFibGVzXG4gICAgICAgICAqIEBwYXJhbSBuIHNjYWxhciAod2UgZG9uJ3QgY2hlY2sgaGVyZSwgYnV0IHNob3VsZCBiZSBsZXNzIHRoYW4gY3VydmUgb3JkZXIpXG4gICAgICAgICAqIEBwYXJhbSBhY2MgYWNjdW11bGF0b3IgcG9pbnQgdG8gYWRkIHJlc3VsdCBvZiBtdWx0aXBsaWNhdGlvblxuICAgICAgICAgKiBAcmV0dXJucyBwb2ludFxuICAgICAgICAgKi9cbiAgICAgICAgd05BRlVuc2FmZShXLCBwcmVjb21wdXRlcywgbiwgYWNjID0gYy5aRVJPKSB7XG4gICAgICAgICAgICBjb25zdCB3byA9IGNhbGNXT3B0cyhXLCBiaXRzKTtcbiAgICAgICAgICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IHdvLndpbmRvd3M7IHdpbmRvdysrKSB7XG4gICAgICAgICAgICAgICAgaWYgKG4gPT09IF8wbilcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIEVhcmx5LWV4aXQsIHNraXAgMCB2YWx1ZVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgbmV4dE4sIG9mZnNldCwgaXNaZXJvLCBpc05lZyB9ID0gY2FsY09mZnNldHMobiwgd2luZG93LCB3byk7XG4gICAgICAgICAgICAgICAgbiA9IG5leHROO1xuICAgICAgICAgICAgICAgIGlmIChpc1plcm8pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2luZG93IGJpdHMgYXJlIDA6IHNraXAgcHJvY2Vzc2luZy5cbiAgICAgICAgICAgICAgICAgICAgLy8gTW92ZSB0byBuZXh0IHdpbmRvdy5cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gcHJlY29tcHV0ZXNbb2Zmc2V0XTtcbiAgICAgICAgICAgICAgICAgICAgYWNjID0gYWNjLmFkZChpc05lZyA/IGl0ZW0ubmVnYXRlKCkgOiBpdGVtKTsgLy8gUmUtdXNpbmcgYWNjIGFsbG93cyB0byBzYXZlIGFkZHMgaW4gTVNNXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0UHJlY29tcHV0ZXMoVywgUCwgdHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgcHJlY29tcHV0ZXMgb24gYSBmaXJzdCBydW4sIHJldXNlIHRoZW0gYWZ0ZXJcbiAgICAgICAgICAgIGxldCBjb21wID0gcG9pbnRQcmVjb21wdXRlcy5nZXQoUCk7XG4gICAgICAgICAgICBpZiAoIWNvbXApIHtcbiAgICAgICAgICAgICAgICBjb21wID0gdGhpcy5wcmVjb21wdXRlV2luZG93KFAsIFcpO1xuICAgICAgICAgICAgICAgIGlmIChXICE9PSAxKVxuICAgICAgICAgICAgICAgICAgICBwb2ludFByZWNvbXB1dGVzLnNldChQLCB0cmFuc2Zvcm0oY29tcCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbXA7XG4gICAgICAgIH0sXG4gICAgICAgIHdOQUZDYWNoZWQoUCwgbiwgdHJhbnNmb3JtKSB7XG4gICAgICAgICAgICBjb25zdCBXID0gZ2V0VyhQKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndOQUYoVywgdGhpcy5nZXRQcmVjb21wdXRlcyhXLCBQLCB0cmFuc2Zvcm0pLCBuKTtcbiAgICAgICAgfSxcbiAgICAgICAgd05BRkNhY2hlZFVuc2FmZShQLCBuLCB0cmFuc2Zvcm0sIHByZXYpIHtcbiAgICAgICAgICAgIGNvbnN0IFcgPSBnZXRXKFApO1xuICAgICAgICAgICAgaWYgKFcgPT09IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5zYWZlTGFkZGVyKFAsIG4sIHByZXYpOyAvLyBGb3IgVz0xIGxhZGRlciBpcyB+eDIgZmFzdGVyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy53TkFGVW5zYWZlKFcsIHRoaXMuZ2V0UHJlY29tcHV0ZXMoVywgUCwgdHJhbnNmb3JtKSwgbiwgcHJldik7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFdlIGNhbGN1bGF0ZSBwcmVjb21wdXRlcyBmb3IgZWxsaXB0aWMgY3VydmUgcG9pbnQgbXVsdGlwbGljYXRpb25cbiAgICAgICAgLy8gdXNpbmcgd2luZG93ZWQgbWV0aG9kLiBUaGlzIHNwZWNpZmllcyB3aW5kb3cgc2l6ZSBhbmRcbiAgICAgICAgLy8gc3RvcmVzIHByZWNvbXB1dGVkIHZhbHVlcy4gVXN1YWxseSBvbmx5IGJhc2UgcG9pbnQgd291bGQgYmUgcHJlY29tcHV0ZWQuXG4gICAgICAgIHNldFdpbmRvd1NpemUoUCwgVykge1xuICAgICAgICAgICAgdmFsaWRhdGVXKFcsIGJpdHMpO1xuICAgICAgICAgICAgcG9pbnRXaW5kb3dTaXplcy5zZXQoUCwgVyk7XG4gICAgICAgICAgICBwb2ludFByZWNvbXB1dGVzLmRlbGV0ZShQKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBQaXBwZW5nZXIgYWxnb3JpdGhtIGZvciBtdWx0aS1zY2FsYXIgbXVsdGlwbGljYXRpb24gKE1TTSwgUGEgKyBRYiArIFJjICsgLi4uKS5cbiAqIDMweCBmYXN0ZXIgdnMgbmFpdmUgYWRkaXRpb24gb24gTD00MDk2LCAxMHggZmFzdGVyIHRoYW4gcHJlY29tcHV0ZXMuXG4gKiBGb3IgTj0yNTRiaXQsIEw9MSwgaXQgZG9lczogMTAyNCBBREQgKyAyNTQgREJMLiBGb3IgTD01OiAxNTM2IEFERCArIDI1NCBEQkwuXG4gKiBBbGdvcml0aG1pY2FsbHkgY29uc3RhbnQtdGltZSAoZm9yIHNhbWUgTCksIGV2ZW4gd2hlbiAxIHBvaW50ICsgc2NhbGFyLCBvciB3aGVuIHNjYWxhciA9IDAuXG4gKiBAcGFyYW0gYyBDdXJ2ZSBQb2ludCBjb25zdHJ1Y3RvclxuICogQHBhcmFtIGZpZWxkTiBmaWVsZCBvdmVyIENVUlZFLk4gLSBpbXBvcnRhbnQgdGhhdCBpdCdzIG5vdCBvdmVyIENVUlZFLlBcbiAqIEBwYXJhbSBwb2ludHMgYXJyYXkgb2YgTCBjdXJ2ZSBwb2ludHNcbiAqIEBwYXJhbSBzY2FsYXJzIGFycmF5IG9mIEwgc2NhbGFycyAoYWthIHByaXZhdGUga2V5cyAvIGJpZ2ludHMpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwaXBwZW5nZXIoYywgZmllbGROLCBwb2ludHMsIHNjYWxhcnMpIHtcbiAgICAvLyBJZiB3ZSBzcGxpdCBzY2FsYXJzIGJ5IHNvbWUgd2luZG93IChsZXQncyBzYXkgOCBiaXRzKSwgZXZlcnkgY2h1bmsgd2lsbCBvbmx5XG4gICAgLy8gdGFrZSAyNTYgYnVja2V0cyBldmVuIGlmIHRoZXJlIGFyZSA0MDk2IHNjYWxhcnMsIGFsc28gcmUtdXNlcyBkb3VibGUuXG4gICAgLy8gVE9ETzpcbiAgICAvLyAtIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMjQvNzUwLnBkZlxuICAgIC8vIC0gaHR0cHM6Ly90Y2hlcy5pYWNyLm9yZy9pbmRleC5waHAvVENIRVMvYXJ0aWNsZS92aWV3LzEwMjg3XG4gICAgLy8gMCBpcyBhY2NlcHRlZCBpbiBzY2FsYXJzXG4gICAgdmFsaWRhdGVNU01Qb2ludHMocG9pbnRzLCBjKTtcbiAgICB2YWxpZGF0ZU1TTVNjYWxhcnMoc2NhbGFycywgZmllbGROKTtcbiAgICBjb25zdCBwbGVuZ3RoID0gcG9pbnRzLmxlbmd0aDtcbiAgICBjb25zdCBzbGVuZ3RoID0gc2NhbGFycy5sZW5ndGg7XG4gICAgaWYgKHBsZW5ndGggIT09IHNsZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYXJyYXlzIG9mIHBvaW50cyBhbmQgc2NhbGFycyBtdXN0IGhhdmUgZXF1YWwgbGVuZ3RoJyk7XG4gICAgLy8gaWYgKHBsZW5ndGggPT09IDApIHRocm93IG5ldyBFcnJvcignYXJyYXkgbXVzdCBiZSBvZiBsZW5ndGggPj0gMicpO1xuICAgIGNvbnN0IHplcm8gPSBjLlpFUk87XG4gICAgY29uc3Qgd2JpdHMgPSBiaXRMZW4oQmlnSW50KHBsZW5ndGgpKTtcbiAgICBsZXQgd2luZG93U2l6ZSA9IDE7IC8vIGJpdHNcbiAgICBpZiAod2JpdHMgPiAxMilcbiAgICAgICAgd2luZG93U2l6ZSA9IHdiaXRzIC0gMztcbiAgICBlbHNlIGlmICh3Yml0cyA+IDQpXG4gICAgICAgIHdpbmRvd1NpemUgPSB3Yml0cyAtIDI7XG4gICAgZWxzZSBpZiAod2JpdHMgPiAwKVxuICAgICAgICB3aW5kb3dTaXplID0gMjtcbiAgICBjb25zdCBNQVNLID0gYml0TWFzayh3aW5kb3dTaXplKTtcbiAgICBjb25zdCBidWNrZXRzID0gbmV3IEFycmF5KE51bWJlcihNQVNLKSArIDEpLmZpbGwoemVybyk7IC8vICsxIGZvciB6ZXJvIGFycmF5XG4gICAgY29uc3QgbGFzdEJpdHMgPSBNYXRoLmZsb29yKChmaWVsZE4uQklUUyAtIDEpIC8gd2luZG93U2l6ZSkgKiB3aW5kb3dTaXplO1xuICAgIGxldCBzdW0gPSB6ZXJvO1xuICAgIGZvciAobGV0IGkgPSBsYXN0Qml0czsgaSA+PSAwOyBpIC09IHdpbmRvd1NpemUpIHtcbiAgICAgICAgYnVja2V0cy5maWxsKHplcm8pO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNsZW5ndGg7IGorKykge1xuICAgICAgICAgICAgY29uc3Qgc2NhbGFyID0gc2NhbGFyc1tqXTtcbiAgICAgICAgICAgIGNvbnN0IHdiaXRzID0gTnVtYmVyKChzY2FsYXIgPj4gQmlnSW50KGkpKSAmIE1BU0spO1xuICAgICAgICAgICAgYnVja2V0c1t3Yml0c10gPSBidWNrZXRzW3diaXRzXS5hZGQocG9pbnRzW2pdKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzSSA9IHplcm87IC8vIG5vdCB1c2luZyB0aGlzIHdpbGwgZG8gc21hbGwgc3BlZWQtdXAsIGJ1dCB3aWxsIGxvc2UgY3RcbiAgICAgICAgLy8gU2tpcCBmaXJzdCBidWNrZXQsIGJlY2F1c2UgaXQgaXMgemVyb1xuICAgICAgICBmb3IgKGxldCBqID0gYnVja2V0cy5sZW5ndGggLSAxLCBzdW1JID0gemVybzsgaiA+IDA7IGotLSkge1xuICAgICAgICAgICAgc3VtSSA9IHN1bUkuYWRkKGJ1Y2tldHNbal0pO1xuICAgICAgICAgICAgcmVzSSA9IHJlc0kuYWRkKHN1bUkpO1xuICAgICAgICB9XG4gICAgICAgIHN1bSA9IHN1bS5hZGQocmVzSSk7XG4gICAgICAgIGlmIChpICE9PSAwKVxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB3aW5kb3dTaXplOyBqKyspXG4gICAgICAgICAgICAgICAgc3VtID0gc3VtLmRvdWJsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gc3VtO1xufVxuLyoqXG4gKiBQcmVjb21wdXRlZCBtdWx0aS1zY2FsYXIgbXVsdGlwbGljYXRpb24gKE1TTSwgUGEgKyBRYiArIFJjICsgLi4uKS5cbiAqIEBwYXJhbSBjIEN1cnZlIFBvaW50IGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gZmllbGROIGZpZWxkIG92ZXIgQ1VSVkUuTiAtIGltcG9ydGFudCB0aGF0IGl0J3Mgbm90IG92ZXIgQ1VSVkUuUFxuICogQHBhcmFtIHBvaW50cyBhcnJheSBvZiBMIGN1cnZlIHBvaW50c1xuICogQHJldHVybnMgZnVuY3Rpb24gd2hpY2ggbXVsdGlwbGllcyBwb2ludHMgd2l0aCBzY2FhcnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByZWNvbXB1dGVNU01VbnNhZmUoYywgZmllbGROLCBwb2ludHMsIHdpbmRvd1NpemUpIHtcbiAgICAvKipcbiAgICAgKiBQZXJmb3JtYW5jZSBBbmFseXNpcyBvZiBXaW5kb3ctYmFzZWQgUHJlY29tcHV0YXRpb25cbiAgICAgKlxuICAgICAqIEJhc2UgQ2FzZSAoMjU2LWJpdCBzY2FsYXIsIDgtYml0IHdpbmRvdyk6XG4gICAgICogLSBTdGFuZGFyZCBwcmVjb21wdXRhdGlvbiByZXF1aXJlczpcbiAgICAgKiAgIC0gMzEgYWRkaXRpb25zIHBlciBzY2FsYXIgw5cgMjU2IHNjYWxhcnMgPSA3LDkzNiBvcHNcbiAgICAgKiAgIC0gUGx1cyAyNTUgc3VtbWFyeSBhZGRpdGlvbnMgPSA4LDE5MSB0b3RhbCBvcHNcbiAgICAgKiAgIE5vdGU6IFN1bW1hcnkgYWRkaXRpb25zIGNhbiBiZSBvcHRpbWl6ZWQgdmlhIGFjY3VtdWxhdG9yXG4gICAgICpcbiAgICAgKiBDaHVua2VkIFByZWNvbXB1dGF0aW9uIEFuYWx5c2lzOlxuICAgICAqIC0gVXNpbmcgMzIgY2h1bmtzIHJlcXVpcmVzOlxuICAgICAqICAgLSAyNTUgYWRkaXRpb25zIHBlciBjaHVua1xuICAgICAqICAgLSAyNTYgZG91YmxpbmdzXG4gICAgICogICAtIFRvdGFsOiAoMjU1IMOXIDMyKSArIDI1NiA9IDgsNDE2IG9wc1xuICAgICAqXG4gICAgICogTWVtb3J5IFVzYWdlIENvbXBhcmlzb246XG4gICAgICogV2luZG93IFNpemUgfCBTdGFuZGFyZCBQb2ludHMgfCBDaHVua2VkIFBvaW50c1xuICAgICAqIC0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS1cbiAgICAgKiAgICAgNC1iaXQgICB8ICAgICA1MjAgICAgICAgICB8ICAgICAgMTVcbiAgICAgKiAgICAgOC1iaXQgICB8ICAgIDQsMjI0ICAgICAgICB8ICAgICAyNTVcbiAgICAgKiAgICAxMC1iaXQgICB8ICAgMTMsODI0ICAgICAgICB8ICAgMSwwMjNcbiAgICAgKiAgICAxNi1iaXQgICB8ICA1NTcsMDU2ICAgICAgICB8ICA2NSw1MzVcbiAgICAgKlxuICAgICAqIEtleSBBZHZhbnRhZ2VzOlxuICAgICAqIDEuIEVuYWJsZXMgbGFyZ2VyIHdpbmRvdyBzaXplcyBkdWUgdG8gcmVkdWNlZCBtZW1vcnkgb3ZlcmhlYWRcbiAgICAgKiAyLiBNb3JlIGVmZmljaWVudCBmb3Igc21hbGxlciBzY2FsYXIgY291bnRzOlxuICAgICAqICAgIC0gMTYgY2h1bmtzOiAoMTYgw5cgMjU1KSArIDI1NiA9IDQsMzM2IG9wc1xuICAgICAqICAgIC0gfjJ4IGZhc3RlciB0aGFuIHN0YW5kYXJkIDgsMTkxIG9wc1xuICAgICAqXG4gICAgICogTGltaXRhdGlvbnM6XG4gICAgICogLSBOb3Qgc3VpdGFibGUgZm9yIHBsYWluIHByZWNvbXB1dGVzIChyZXF1aXJlcyAyNTYgY29uc3RhbnQgZG91YmxpbmdzKVxuICAgICAqIC0gUGVyZm9ybWFuY2UgZGVncmFkZXMgd2l0aCBsYXJnZXIgc2NhbGFyIGNvdW50czpcbiAgICAgKiAgIC0gT3B0aW1hbCBmb3IgfjI1NiBzY2FsYXJzXG4gICAgICogICAtIExlc3MgZWZmaWNpZW50IGZvciA0MDk2KyBzY2FsYXJzIChQaXBwZW5nZXIgcHJlZmVycmVkKVxuICAgICAqL1xuICAgIHZhbGlkYXRlVyh3aW5kb3dTaXplLCBmaWVsZE4uQklUUyk7XG4gICAgdmFsaWRhdGVNU01Qb2ludHMocG9pbnRzLCBjKTtcbiAgICBjb25zdCB6ZXJvID0gYy5aRVJPO1xuICAgIGNvbnN0IHRhYmxlU2l6ZSA9IDIgKiogd2luZG93U2l6ZSAtIDE7IC8vIHRhYmxlIHNpemUgKHdpdGhvdXQgemVybylcbiAgICBjb25zdCBjaHVua3MgPSBNYXRoLmNlaWwoZmllbGROLkJJVFMgLyB3aW5kb3dTaXplKTsgLy8gY2h1bmtzIG9mIGl0ZW1cbiAgICBjb25zdCBNQVNLID0gYml0TWFzayh3aW5kb3dTaXplKTtcbiAgICBjb25zdCB0YWJsZXMgPSBwb2ludHMubWFwKChwKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgYWNjID0gcDsgaSA8IHRhYmxlU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICByZXMucHVzaChhY2MpO1xuICAgICAgICAgICAgYWNjID0gYWNjLmFkZChwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0pO1xuICAgIHJldHVybiAoc2NhbGFycykgPT4ge1xuICAgICAgICB2YWxpZGF0ZU1TTVNjYWxhcnMoc2NhbGFycywgZmllbGROKTtcbiAgICAgICAgaWYgKHNjYWxhcnMubGVuZ3RoID4gcG9pbnRzLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXJyYXkgb2Ygc2NhbGFycyBtdXN0IGJlIHNtYWxsZXIgdGhhbiBhcnJheSBvZiBwb2ludHMnKTtcbiAgICAgICAgbGV0IHJlcyA9IHplcm87XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2h1bmtzOyBpKyspIHtcbiAgICAgICAgICAgIC8vIE5vIG5lZWQgdG8gZG91YmxlIGlmIGFjY3VtdWxhdG9yIGlzIHN0aWxsIHplcm8uXG4gICAgICAgICAgICBpZiAocmVzICE9PSB6ZXJvKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgd2luZG93U2l6ZTsgaisrKVxuICAgICAgICAgICAgICAgICAgICByZXMgPSByZXMuZG91YmxlKCk7XG4gICAgICAgICAgICBjb25zdCBzaGlmdEJ5ID0gQmlnSW50KGNodW5rcyAqIHdpbmRvd1NpemUgLSAoaSArIDEpICogd2luZG93U2l6ZSk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNjYWxhcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuID0gc2NhbGFyc1tqXTtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyID0gTnVtYmVyKChuID4+IHNoaWZ0QnkpICYgTUFTSyk7XG4gICAgICAgICAgICAgICAgaWYgKCFjdXJyKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gc2tpcCB6ZXJvIHNjYWxhcnMgY2h1bmtzXG4gICAgICAgICAgICAgICAgcmVzID0gcmVzLmFkZCh0YWJsZXNbal1bY3VyciAtIDFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVCYXNpYyhjdXJ2ZSkge1xuICAgIHZhbGlkYXRlRmllbGQoY3VydmUuRnApO1xuICAgIHZhbGlkYXRlT2JqZWN0KGN1cnZlLCB7XG4gICAgICAgIG46ICdiaWdpbnQnLFxuICAgICAgICBoOiAnYmlnaW50JyxcbiAgICAgICAgR3g6ICdmaWVsZCcsXG4gICAgICAgIEd5OiAnZmllbGQnLFxuICAgIH0sIHtcbiAgICAgICAgbkJpdExlbmd0aDogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBuQnl0ZUxlbmd0aDogJ2lzU2FmZUludGVnZXInLFxuICAgIH0pO1xuICAgIC8vIFNldCBkZWZhdWx0c1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgLi4ubkxlbmd0aChjdXJ2ZS5uLCBjdXJ2ZS5uQml0TGVuZ3RoKSxcbiAgICAgICAgLi4uY3VydmUsXG4gICAgICAgIC4uLnsgcDogY3VydmUuRnAuT1JERVIgfSxcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWN1cnZlLmpzLm1hcCJdLCJuYW1lcyI6WyJuTGVuZ3RoIiwidmFsaWRhdGVGaWVsZCIsImJpdExlbiIsImJpdE1hc2siLCJ2YWxpZGF0ZU9iamVjdCIsIl8wbiIsIkJpZ0ludCIsIl8xbiIsImNvbnN0VGltZU5lZ2F0ZSIsImNvbmRpdGlvbiIsIml0ZW0iLCJuZWciLCJuZWdhdGUiLCJ2YWxpZGF0ZVciLCJXIiwiYml0cyIsIk51bWJlciIsImlzU2FmZUludGVnZXIiLCJFcnJvciIsImNhbGNXT3B0cyIsInNjYWxhckJpdHMiLCJ3aW5kb3dzIiwiTWF0aCIsImNlaWwiLCJ3aW5kb3dTaXplIiwibWF4TnVtYmVyIiwibWFzayIsInNoaWZ0QnkiLCJjYWxjT2Zmc2V0cyIsIm4iLCJ3aW5kb3ciLCJ3T3B0cyIsIndiaXRzIiwibmV4dE4iLCJvZmZzZXRTdGFydCIsIm9mZnNldCIsImFicyIsImlzWmVybyIsImlzTmVnIiwiaXNOZWdGIiwib2Zmc2V0RiIsInZhbGlkYXRlTVNNUG9pbnRzIiwicG9pbnRzIiwiYyIsIkFycmF5IiwiaXNBcnJheSIsImZvckVhY2giLCJwIiwiaSIsInZhbGlkYXRlTVNNU2NhbGFycyIsInNjYWxhcnMiLCJmaWVsZCIsInMiLCJpc1ZhbGlkIiwicG9pbnRQcmVjb21wdXRlcyIsIldlYWtNYXAiLCJwb2ludFdpbmRvd1NpemVzIiwiZ2V0VyIsIlAiLCJnZXQiLCJ3TkFGIiwiaGFzUHJlY29tcHV0ZXMiLCJlbG0iLCJ1bnNhZmVMYWRkZXIiLCJaRVJPIiwiZCIsImFkZCIsImRvdWJsZSIsInByZWNvbXB1dGVXaW5kb3ciLCJiYXNlIiwicHVzaCIsInByZWNvbXB1dGVzIiwiZiIsIkJBU0UiLCJ3byIsIndOQUZVbnNhZmUiLCJhY2MiLCJnZXRQcmVjb21wdXRlcyIsInRyYW5zZm9ybSIsImNvbXAiLCJzZXQiLCJ3TkFGQ2FjaGVkIiwid05BRkNhY2hlZFVuc2FmZSIsInByZXYiLCJzZXRXaW5kb3dTaXplIiwiZGVsZXRlIiwicGlwcGVuZ2VyIiwiZmllbGROIiwicGxlbmd0aCIsImxlbmd0aCIsInNsZW5ndGgiLCJ6ZXJvIiwiTUFTSyIsImJ1Y2tldHMiLCJmaWxsIiwibGFzdEJpdHMiLCJmbG9vciIsIkJJVFMiLCJzdW0iLCJqIiwic2NhbGFyIiwicmVzSSIsInN1bUkiLCJwcmVjb21wdXRlTVNNVW5zYWZlIiwidGFibGVTaXplIiwiY2h1bmtzIiwidGFibGVzIiwibWFwIiwicmVzIiwiY3VyciIsInZhbGlkYXRlQmFzaWMiLCJjdXJ2ZSIsIkZwIiwiaCIsIkd4IiwiR3kiLCJuQml0TGVuZ3RoIiwibkJ5dGVMZW5ndGgiLCJPYmplY3QiLCJmcmVlemUiLCJPUkRFUiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/abstract/curve.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/abstract/hash-to-curve.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/ox/node_modules/@noble/curves/esm/abstract/hash-to-curve.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createHasher: () => (/* binding */ createHasher),\n/* harmony export */   expand_message_xmd: () => (/* binding */ expand_message_xmd),\n/* harmony export */   expand_message_xof: () => (/* binding */ expand_message_xof),\n/* harmony export */   hash_to_field: () => (/* binding */ hash_to_field),\n/* harmony export */   isogenyMap: () => (/* binding */ isogenyMap)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/abstract/utils.js\");\n\n\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n    anum(value);\n    anum(length);\n    if (value < 0 || value >= 1 << 8 * length) throw new Error(\"invalid I2OSP input: \" + value);\n    const res = Array.from({\n        length\n    }).fill(0);\n    for(let i = length - 1; i >= 0; i--){\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for(let i = 0; i < a.length; i++){\n        arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n}\nfunction anum(item) {\n    if (!Number.isSafeInteger(item)) throw new Error(\"number expected\");\n}\n/**\n * Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits.\n * [RFC 9380 5.3.1](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1).\n */ function expand_message_xmd(msg, DST, lenInBytes, H) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    if (DST.length > 255) DST = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)(\"H2C-OVERSIZE-DST-\"), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (lenInBytes > 65535 || ell > 255) throw new Error(\"expand_message_xmd: invalid lenInBytes\");\n    const DST_prime = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(b_0, i2osp(1, 1), DST_prime));\n    for(let i = 1; i <= ell; i++){\n        const args = [\n            strxor(b_0, b[i - 1]),\n            i2osp(i + 1, 1),\n            DST_prime\n        ];\n        b[i] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...args));\n    }\n    const pseudo_random_bytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\n/**\n * Produces a uniformly random byte string using an extendable-output function (XOF) H.\n * 1. The collision resistance of H MUST be at least k bits.\n * 2. H MUST be an XOF that has been proved indifferentiable from\n *    a random oracle under a reasonable cryptographic assumption.\n * [RFC 9380 5.3.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2).\n */ function expand_message_xof(msg, DST, lenInBytes, k, H) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil(2 * k / 8);\n        DST = H.create({\n            dkLen\n        }).update((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)(\"H2C-OVERSIZE-DST-\")).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255) throw new Error(\"expand_message_xof: invalid lenInBytes\");\n    return H.create({\n        dkLen: lenInBytes\n    }).update(msg).update(i2osp(lenInBytes, 2))// 2. DST_prime = DST || I2OSP(len(DST), 1)\n    .update(DST).update(i2osp(DST.length, 1)).digest();\n}\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F.\n * [RFC 9380 5.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.2).\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */ function hash_to_field(msg, count, options) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(options, {\n        DST: \"stringOrUint8Array\",\n        p: \"bigint\",\n        m: \"isSafeInteger\",\n        k: \"isSafeInteger\",\n        hash: \"hash\"\n    });\n    const { p, k, m, hash, expand, DST: _DST } = options;\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    anum(count);\n    const DST = typeof _DST === \"string\" ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)(_DST) : _DST;\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === \"xmd\") {\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n    } else if (expand === \"xof\") {\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    } else if (expand === \"_internal_pass\") {\n        // for internal tests only\n        prb = msg;\n    } else {\n        throw new Error('expand must be \"xmd\" or \"xof\"');\n    }\n    const u = new Array(count);\n    for(let i = 0; i < count; i++){\n        const e = new Array(m);\n        for(let j = 0; j < m; j++){\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.mod)(os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nfunction isogenyMap(field, map) {\n    // Make same order as in spec\n    const coeff = map.map((i)=>Array.from(i).reverse());\n    return (x, y)=>{\n        const [xn, xd, yn, yd] = coeff.map((val)=>val.reduce((acc, i)=>field.add(field.mul(acc, x), i)));\n        // 6.6.3\n        // Exceptional cases of iso_map are inputs that cause the denominator of\n        // either rational function to evaluate to zero; such cases MUST return\n        // the identity point on E.\n        const [xd_inv, yd_inv] = (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.FpInvertBatch)(field, [\n            xd,\n            yd\n        ], true);\n        x = field.mul(xn, xd_inv); // xNum / xDen\n        y = field.mul(y, field.mul(yn, yd_inv)); // y * (yNum / yDev)\n        return {\n            x,\n            y\n        };\n    };\n}\n/** Creates hash-to-curve methods from EC Point and mapToCurve function. */ function createHasher(Point, mapToCurve, defaults) {\n    if (typeof mapToCurve !== \"function\") throw new Error(\"mapToCurve() must be defined\");\n    function map(num) {\n        return Point.fromAffine(mapToCurve(num));\n    }\n    function clear(initial) {\n        const P = initial.clearCofactor();\n        if (P.equals(Point.ZERO)) return Point.ZERO; // zero will throw in assert\n        P.assertValidity();\n        return P;\n    }\n    return {\n        defaults,\n        // Encodes byte string to elliptic curve.\n        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        hashToCurve (msg, options) {\n            const u = hash_to_field(msg, 2, {\n                ...defaults,\n                DST: defaults.DST,\n                ...options\n            });\n            const u0 = map(u[0]);\n            const u1 = map(u[1]);\n            return clear(u0.add(u1));\n        },\n        // Encodes byte string to elliptic curve.\n        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        encodeToCurve (msg, options) {\n            const u = hash_to_field(msg, 1, {\n                ...defaults,\n                DST: defaults.encodeDST,\n                ...options\n            });\n            return clear(map(u[0]));\n        },\n        // Same as encodeToCurve, but without hash\n        mapToCurve (scalars) {\n            if (!Array.isArray(scalars)) throw new Error(\"expected array of bigints\");\n            for (const i of scalars)if (typeof i !== \"bigint\") throw new Error(\"expected array of bigints\");\n            return clear(map(scalars));\n        }\n    };\n} //# sourceMappingURL=hash-to-curve.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L2hhc2gtdG8tY3VydmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFrRDtBQUM2QztBQUMvRiw2RkFBNkY7QUFDN0YsTUFBTU8sUUFBUUosc0RBQWVBO0FBQzdCLDRDQUE0QztBQUM1QyxTQUFTSyxNQUFNQyxLQUFLLEVBQUVDLE1BQU07SUFDeEJDLEtBQUtGO0lBQ0xFLEtBQUtEO0lBQ0wsSUFBSUQsUUFBUSxLQUFLQSxTQUFTLEtBQU0sSUFBSUMsUUFDaEMsTUFBTSxJQUFJRSxNQUFNLDBCQUEwQkg7SUFDOUMsTUFBTUksTUFBTUMsTUFBTUMsSUFBSSxDQUFDO1FBQUVMO0lBQU8sR0FBR00sSUFBSSxDQUFDO0lBQ3hDLElBQUssSUFBSUMsSUFBSVAsU0FBUyxHQUFHTyxLQUFLLEdBQUdBLElBQUs7UUFDbENKLEdBQUcsQ0FBQ0ksRUFBRSxHQUFHUixRQUFRO1FBQ2pCQSxXQUFXO0lBQ2Y7SUFDQSxPQUFPLElBQUlTLFdBQVdMO0FBQzFCO0FBQ0EsU0FBU00sT0FBT0MsQ0FBQyxFQUFFQyxDQUFDO0lBQ2hCLE1BQU1DLE1BQU0sSUFBSUosV0FBV0UsRUFBRVYsTUFBTTtJQUNuQyxJQUFLLElBQUlPLElBQUksR0FBR0EsSUFBSUcsRUFBRVYsTUFBTSxFQUFFTyxJQUFLO1FBQy9CSyxHQUFHLENBQUNMLEVBQUUsR0FBR0csQ0FBQyxDQUFDSCxFQUFFLEdBQUdJLENBQUMsQ0FBQ0osRUFBRTtJQUN4QjtJQUNBLE9BQU9LO0FBQ1g7QUFDQSxTQUFTWCxLQUFLWSxJQUFJO0lBQ2QsSUFBSSxDQUFDQyxPQUFPQyxhQUFhLENBQUNGLE9BQ3RCLE1BQU0sSUFBSVgsTUFBTTtBQUN4QjtBQUNBOzs7Q0FHQyxHQUNNLFNBQVNjLG1CQUFtQkMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLFVBQVUsRUFBRUMsQ0FBQztJQUN0RDVCLGlEQUFNQSxDQUFDeUI7SUFD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eEIsS0FBSyxHQUFHO2dCQUFFLEdBQUdnRSxRQUFRO2dCQUFFL0QsS0FBSytELFNBQVMvRCxHQUFHO2dCQUFFLEdBQUd5QixPQUFPO1lBQUM7WUFDN0UsTUFBTWlELEtBQUs5QixJQUFJUixDQUFDLENBQUMsRUFBRTtZQUNuQixNQUFNdUMsS0FBSy9CLElBQUlSLENBQUMsQ0FBQyxFQUFFO1lBQ25CLE9BQU84QixNQUFNUSxHQUFHbEIsR0FBRyxDQUFDbUI7UUFDeEI7UUFDQSx5Q0FBeUM7UUFDekMsd0VBQXdFO1FBQ3hFQyxlQUFjN0UsR0FBRyxFQUFFMEIsT0FBTztZQUN0QixNQUFNVyxJQUFJYixjQUFjeEIsS0FBSyxHQUFHO2dCQUFFLEdBQUdnRSxRQUFRO2dCQUFFL0QsS0FBSytELFNBQVNjLFNBQVM7Z0JBQUUsR0FBR3BELE9BQU87WUFBQztZQUNuRixPQUFPeUMsTUFBTXRCLElBQUlSLENBQUMsQ0FBQyxFQUFFO1FBQ3pCO1FBQ0EsMENBQTBDO1FBQzFDMEIsWUFBV2dCLE9BQU87WUFDZCxJQUFJLENBQUM1RixNQUFNNkYsT0FBTyxDQUFDRCxVQUNmLE1BQU0sSUFBSTlGLE1BQU07WUFDcEIsS0FBSyxNQUFNSyxLQUFLeUYsUUFDWixJQUFJLE9BQU96RixNQUFNLFVBQ2IsTUFBTSxJQUFJTCxNQUFNO1lBQ3hCLE9BQU9rRixNQUFNdEIsSUFBSWtDO1FBQ3JCO0lBQ0o7QUFDSixFQUNBLHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsYXctd29ya3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L2hhc2gtdG8tY3VydmUuanM/ZTVhNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBGcEludmVydEJhdGNoLCBtb2QgfSBmcm9tIFwiLi9tb2R1bGFyLmpzXCI7XG5pbXBvcnQgeyBhYnl0ZXMsIGJ5dGVzVG9OdW1iZXJCRSwgY29uY2F0Qnl0ZXMsIHV0ZjhUb0J5dGVzLCB2YWxpZGF0ZU9iamVjdCB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG4vLyBPY3RldCBTdHJlYW0gdG8gSW50ZWdlci4gXCJzcGVjXCIgaW1wbGVtZW50YXRpb24gb2Ygb3MyaXAgaXMgMi41eCBzbG93ZXIgdnMgYnl0ZXNUb051bWJlckJFLlxuY29uc3Qgb3MyaXAgPSBieXRlc1RvTnVtYmVyQkU7XG4vLyBJbnRlZ2VyIHRvIE9jdGV0IFN0cmVhbSAobnVtYmVyVG9CeXRlc0JFKVxuZnVuY3Rpb24gaTJvc3AodmFsdWUsIGxlbmd0aCkge1xuICAgIGFudW0odmFsdWUpO1xuICAgIGFudW0obGVuZ3RoKTtcbiAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID49IDEgPDwgKDggKiBsZW5ndGgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgSTJPU1AgaW5wdXQ6ICcgKyB2YWx1ZSk7XG4gICAgY29uc3QgcmVzID0gQXJyYXkuZnJvbSh7IGxlbmd0aCB9KS5maWxsKDApO1xuICAgIGZvciAobGV0IGkgPSBsZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICByZXNbaV0gPSB2YWx1ZSAmIDB4ZmY7XG4gICAgICAgIHZhbHVlID4+Pj0gODtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHJlcyk7XG59XG5mdW5jdGlvbiBzdHJ4b3IoYSwgYikge1xuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KGEubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gYVtpXSBeIGJbaV07XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG59XG5mdW5jdGlvbiBhbnVtKGl0ZW0pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGl0ZW0pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ251bWJlciBleHBlY3RlZCcpO1xufVxuLyoqXG4gKiBQcm9kdWNlcyBhIHVuaWZvcm1seSByYW5kb20gYnl0ZSBzdHJpbmcgdXNpbmcgYSBjcnlwdG9ncmFwaGljIGhhc2ggZnVuY3Rpb24gSCB0aGF0IG91dHB1dHMgYiBiaXRzLlxuICogW1JGQyA5MzgwIDUuMy4xXShodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMy4xKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4cGFuZF9tZXNzYWdlX3htZChtc2csIERTVCwgbGVuSW5CeXRlcywgSCkge1xuICAgIGFieXRlcyhtc2cpO1xuICAgIGFieXRlcyhEU1QpO1xuICAgIGFudW0obGVuSW5CeXRlcyk7XG4gICAgLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjMuM1xuICAgIGlmIChEU1QubGVuZ3RoID4gMjU1KVxuICAgICAgICBEU1QgPSBIKGNvbmNhdEJ5dGVzKHV0ZjhUb0J5dGVzKCdIMkMtT1ZFUlNJWkUtRFNULScpLCBEU1QpKTtcbiAgICBjb25zdCB7IG91dHB1dExlbjogYl9pbl9ieXRlcywgYmxvY2tMZW46IHJfaW5fYnl0ZXMgfSA9IEg7XG4gICAgY29uc3QgZWxsID0gTWF0aC5jZWlsKGxlbkluQnl0ZXMgLyBiX2luX2J5dGVzKTtcbiAgICBpZiAobGVuSW5CeXRlcyA+IDY1NTM1IHx8IGVsbCA+IDI1NSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBhbmRfbWVzc2FnZV94bWQ6IGludmFsaWQgbGVuSW5CeXRlcycpO1xuICAgIGNvbnN0IERTVF9wcmltZSA9IGNvbmNhdEJ5dGVzKERTVCwgaTJvc3AoRFNULmxlbmd0aCwgMSkpO1xuICAgIGNvbnN0IFpfcGFkID0gaTJvc3AoMCwgcl9pbl9ieXRlcyk7XG4gICAgY29uc3QgbF9pX2Jfc3RyID0gaTJvc3AobGVuSW5CeXRlcywgMik7IC8vIGxlbl9pbl9ieXRlc19zdHJcbiAgICBjb25zdCBiID0gbmV3IEFycmF5KGVsbCk7XG4gICAgY29uc3QgYl8wID0gSChjb25jYXRCeXRlcyhaX3BhZCwgbXNnLCBsX2lfYl9zdHIsIGkyb3NwKDAsIDEpLCBEU1RfcHJpbWUpKTtcbiAgICBiWzBdID0gSChjb25jYXRCeXRlcyhiXzAsIGkyb3NwKDEsIDEpLCBEU1RfcHJpbWUpKTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBlbGw7IGkrKykge1xuICAgICAgICBjb25zdCBhcmdzID0gW3N0cnhvcihiXzAsIGJbaSAtIDFdKSwgaTJvc3AoaSArIDEsIDEpLCBEU1RfcHJpbWVdO1xuICAgICAgICBiW2ldID0gSChjb25jYXRCeXRlcyguLi5hcmdzKSk7XG4gICAgfVxuICAgIGNvbnN0IHBzZXVkb19yYW5kb21fYnl0ZXMgPSBjb25jYXRCeXRlcyguLi5iKTtcbiAgICByZXR1cm4gcHNldWRvX3JhbmRvbV9ieXRlcy5zbGljZSgwLCBsZW5JbkJ5dGVzKTtcbn1cbi8qKlxuICogUHJvZHVjZXMgYSB1bmlmb3JtbHkgcmFuZG9tIGJ5dGUgc3RyaW5nIHVzaW5nIGFuIGV4dGVuZGFibGUtb3V0cHV0IGZ1bmN0aW9uIChYT0YpIEguXG4gKiAxLiBUaGUgY29sbGlzaW9uIHJlc2lzdGFuY2Ugb2YgSCBNVVNUIGJlIGF0IGxlYXN0IGsgYml0cy5cbiAqIDIuIEggTVVTVCBiZSBhbiBYT0YgdGhhdCBoYXMgYmVlbiBwcm92ZWQgaW5kaWZmZXJlbnRpYWJsZSBmcm9tXG4gKiAgICBhIHJhbmRvbSBvcmFjbGUgdW5kZXIgYSByZWFzb25hYmxlIGNyeXB0b2dyYXBoaWMgYXNzdW1wdGlvbi5cbiAqIFtSRkMgOTM4MCA1LjMuMl0oaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjMuMikuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHBhbmRfbWVzc2FnZV94b2YobXNnLCBEU1QsIGxlbkluQnl0ZXMsIGssIEgpIHtcbiAgICBhYnl0ZXMobXNnKTtcbiAgICBhYnl0ZXMoRFNUKTtcbiAgICBhbnVtKGxlbkluQnl0ZXMpO1xuICAgIC8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjNcbiAgICAvLyBEU1QgPSBIKCdIMkMtT1ZFUlNJWkUtRFNULScgfHwgYV92ZXJ5X2xvbmdfRFNULCBNYXRoLmNlaWwoKGxlbkluQnl0ZXMgKiBrKSAvIDgpKTtcbiAgICBpZiAoRFNULmxlbmd0aCA+IDI1NSkge1xuICAgICAgICBjb25zdCBka0xlbiA9IE1hdGguY2VpbCgoMiAqIGspIC8gOCk7XG4gICAgICAgIERTVCA9IEguY3JlYXRlKHsgZGtMZW4gfSkudXBkYXRlKHV0ZjhUb0J5dGVzKCdIMkMtT1ZFUlNJWkUtRFNULScpKS51cGRhdGUoRFNUKS5kaWdlc3QoKTtcbiAgICB9XG4gICAgaWYgKGxlbkluQnl0ZXMgPiA2NTUzNSB8fCBEU1QubGVuZ3RoID4gMjU1KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGFuZF9tZXNzYWdlX3hvZjogaW52YWxpZCBsZW5JbkJ5dGVzJyk7XG4gICAgcmV0dXJuIChILmNyZWF0ZSh7IGRrTGVuOiBsZW5JbkJ5dGVzIH0pXG4gICAgICAgIC51cGRhdGUobXNnKVxuICAgICAgICAudXBkYXRlKGkyb3NwKGxlbkluQnl0ZXMsIDIpKVxuICAgICAgICAvLyAyLiBEU1RfcHJpbWUgPSBEU1QgfHwgSTJPU1AobGVuKERTVCksIDEpXG4gICAgICAgIC51cGRhdGUoRFNUKVxuICAgICAgICAudXBkYXRlKGkyb3NwKERTVC5sZW5ndGgsIDEpKVxuICAgICAgICAuZGlnZXN0KCkpO1xufVxuLyoqXG4gKiBIYXNoZXMgYXJiaXRyYXJ5LWxlbmd0aCBieXRlIHN0cmluZ3MgdG8gYSBsaXN0IG9mIG9uZSBvciBtb3JlIGVsZW1lbnRzIG9mIGEgZmluaXRlIGZpZWxkIEYuXG4gKiBbUkZDIDkzODAgNS4yXShodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMikuXG4gKiBAcGFyYW0gbXNnIGEgYnl0ZSBzdHJpbmcgY29udGFpbmluZyB0aGUgbWVzc2FnZSB0byBoYXNoXG4gKiBAcGFyYW0gY291bnQgdGhlIG51bWJlciBvZiBlbGVtZW50cyBvZiBGIHRvIG91dHB1dFxuICogQHBhcmFtIG9wdGlvbnMgYHtEU1Q6IHN0cmluZywgcDogYmlnaW50LCBtOiBudW1iZXIsIGs6IG51bWJlciwgZXhwYW5kOiAneG1kJyB8ICd4b2YnLCBoYXNoOiBIfWAsIHNlZSBhYm92ZVxuICogQHJldHVybnMgW3VfMCwgLi4uLCB1Xyhjb3VudCAtIDEpXSwgYSBsaXN0IG9mIGZpZWxkIGVsZW1lbnRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzaF90b19maWVsZChtc2csIGNvdW50LCBvcHRpb25zKSB7XG4gICAgdmFsaWRhdGVPYmplY3Qob3B0aW9ucywge1xuICAgICAgICBEU1Q6ICdzdHJpbmdPclVpbnQ4QXJyYXknLFxuICAgICAgICBwOiAnYmlnaW50JyxcbiAgICAgICAgbTogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBrOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgICAgIGhhc2g6ICdoYXNoJyxcbiAgICB9KTtcbiAgICBjb25zdCB7IHAsIGssIG0sIGhhc2gsIGV4cGFuZCwgRFNUOiBfRFNUIH0gPSBvcHRpb25zO1xuICAgIGFieXRlcyhtc2cpO1xuICAgIGFudW0oY291bnQpO1xuICAgIGNvbnN0IERTVCA9IHR5cGVvZiBfRFNUID09PSAnc3RyaW5nJyA/IHV0ZjhUb0J5dGVzKF9EU1QpIDogX0RTVDtcbiAgICBjb25zdCBsb2cycCA9IHAudG9TdHJpbmcoMikubGVuZ3RoO1xuICAgIGNvbnN0IEwgPSBNYXRoLmNlaWwoKGxvZzJwICsgaykgLyA4KTsgLy8gc2VjdGlvbiA1LjEgb2YgaWV0ZiBkcmFmdCBsaW5rIGFib3ZlXG4gICAgY29uc3QgbGVuX2luX2J5dGVzID0gY291bnQgKiBtICogTDtcbiAgICBsZXQgcHJiOyAvLyBwc2V1ZG9fcmFuZG9tX2J5dGVzXG4gICAgaWYgKGV4cGFuZCA9PT0gJ3htZCcpIHtcbiAgICAgICAgcHJiID0gZXhwYW5kX21lc3NhZ2VfeG1kKG1zZywgRFNULCBsZW5faW5fYnl0ZXMsIGhhc2gpO1xuICAgIH1cbiAgICBlbHNlIGlmIChleHBhbmQgPT09ICd4b2YnKSB7XG4gICAgICAgIHByYiA9IGV4cGFuZF9tZXNzYWdlX3hvZihtc2csIERTVCwgbGVuX2luX2J5dGVzLCBrLCBoYXNoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXhwYW5kID09PSAnX2ludGVybmFsX3Bhc3MnKSB7XG4gICAgICAgIC8vIGZvciBpbnRlcm5hbCB0ZXN0cyBvbmx5XG4gICAgICAgIHByYiA9IG1zZztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwYW5kIG11c3QgYmUgXCJ4bWRcIiBvciBcInhvZlwiJyk7XG4gICAgfVxuICAgIGNvbnN0IHUgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICBjb25zdCBlID0gbmV3IEFycmF5KG0pO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG07IGorKykge1xuICAgICAgICAgICAgY29uc3QgZWxtX29mZnNldCA9IEwgKiAoaiArIGkgKiBtKTtcbiAgICAgICAgICAgIGNvbnN0IHR2ID0gcHJiLnN1YmFycmF5KGVsbV9vZmZzZXQsIGVsbV9vZmZzZXQgKyBMKTtcbiAgICAgICAgICAgIGVbal0gPSBtb2Qob3MyaXAodHYpLCBwKTtcbiAgICAgICAgfVxuICAgICAgICB1W2ldID0gZTtcbiAgICB9XG4gICAgcmV0dXJuIHU7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNvZ2VueU1hcChmaWVsZCwgbWFwKSB7XG4gICAgLy8gTWFrZSBzYW1lIG9yZGVyIGFzIGluIHNwZWNcbiAgICBjb25zdCBjb2VmZiA9IG1hcC5tYXAoKGkpID0+IEFycmF5LmZyb20oaSkucmV2ZXJzZSgpKTtcbiAgICByZXR1cm4gKHgsIHkpID0+IHtcbiAgICAgICAgY29uc3QgW3huLCB4ZCwgeW4sIHlkXSA9IGNvZWZmLm1hcCgodmFsKSA9PiB2YWwucmVkdWNlKChhY2MsIGkpID0+IGZpZWxkLmFkZChmaWVsZC5tdWwoYWNjLCB4KSwgaSkpKTtcbiAgICAgICAgLy8gNi42LjNcbiAgICAgICAgLy8gRXhjZXB0aW9uYWwgY2FzZXMgb2YgaXNvX21hcCBhcmUgaW5wdXRzIHRoYXQgY2F1c2UgdGhlIGRlbm9taW5hdG9yIG9mXG4gICAgICAgIC8vIGVpdGhlciByYXRpb25hbCBmdW5jdGlvbiB0byBldmFsdWF0ZSB0byB6ZXJvOyBzdWNoIGNhc2VzIE1VU1QgcmV0dXJuXG4gICAgICAgIC8vIHRoZSBpZGVudGl0eSBwb2ludCBvbiBFLlxuICAgICAgICBjb25zdCBbeGRfaW52LCB5ZF9pbnZdID0gRnBJbnZlcnRCYXRjaChmaWVsZCwgW3hkLCB5ZF0sIHRydWUpO1xuICAgICAgICB4ID0gZmllbGQubXVsKHhuLCB4ZF9pbnYpOyAvLyB4TnVtIC8geERlblxuICAgICAgICB5ID0gZmllbGQubXVsKHksIGZpZWxkLm11bCh5biwgeWRfaW52KSk7IC8vIHkgKiAoeU51bSAvIHlEZXYpXG4gICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICB9O1xufVxuLyoqIENyZWF0ZXMgaGFzaC10by1jdXJ2ZSBtZXRob2RzIGZyb20gRUMgUG9pbnQgYW5kIG1hcFRvQ3VydmUgZnVuY3Rpb24uICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSGFzaGVyKFBvaW50LCBtYXBUb0N1cnZlLCBkZWZhdWx0cykge1xuICAgIGlmICh0eXBlb2YgbWFwVG9DdXJ2ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXBUb0N1cnZlKCkgbXVzdCBiZSBkZWZpbmVkJyk7XG4gICAgZnVuY3Rpb24gbWFwKG51bSkge1xuICAgICAgICByZXR1cm4gUG9pbnQuZnJvbUFmZmluZShtYXBUb0N1cnZlKG51bSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbGVhcihpbml0aWFsKSB7XG4gICAgICAgIGNvbnN0IFAgPSBpbml0aWFsLmNsZWFyQ29mYWN0b3IoKTtcbiAgICAgICAgaWYgKFAuZXF1YWxzKFBvaW50LlpFUk8pKVxuICAgICAgICAgICAgcmV0dXJuIFBvaW50LlpFUk87IC8vIHplcm8gd2lsbCB0aHJvdyBpbiBhc3NlcnRcbiAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICByZXR1cm4gUDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVmYXVsdHMsXG4gICAgICAgIC8vIEVuY29kZXMgYnl0ZSBzdHJpbmcgdG8gZWxsaXB0aWMgY3VydmUuXG4gICAgICAgIC8vIGhhc2hfdG9fY3VydmUgZnJvbSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTNcbiAgICAgICAgaGFzaFRvQ3VydmUobXNnLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCB1ID0gaGFzaF90b19maWVsZChtc2csIDIsIHsgLi4uZGVmYXVsdHMsIERTVDogZGVmYXVsdHMuRFNULCAuLi5vcHRpb25zIH0pO1xuICAgICAgICAgICAgY29uc3QgdTAgPSBtYXAodVswXSk7XG4gICAgICAgICAgICBjb25zdCB1MSA9IG1hcCh1WzFdKTtcbiAgICAgICAgICAgIHJldHVybiBjbGVhcih1MC5hZGQodTEpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gRW5jb2RlcyBieXRlIHN0cmluZyB0byBlbGxpcHRpYyBjdXJ2ZS5cbiAgICAgICAgLy8gZW5jb2RlX3RvX2N1cnZlIGZyb20gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi0zXG4gICAgICAgIGVuY29kZVRvQ3VydmUobXNnLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCB1ID0gaGFzaF90b19maWVsZChtc2csIDEsIHsgLi4uZGVmYXVsdHMsIERTVDogZGVmYXVsdHMuZW5jb2RlRFNULCAuLi5vcHRpb25zIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGNsZWFyKG1hcCh1WzBdKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFNhbWUgYXMgZW5jb2RlVG9DdXJ2ZSwgYnV0IHdpdGhvdXQgaGFzaFxuICAgICAgICBtYXBUb0N1cnZlKHNjYWxhcnMpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzY2FsYXJzKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIGFycmF5IG9mIGJpZ2ludHMnKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaSBvZiBzY2FsYXJzKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgYXJyYXkgb2YgYmlnaW50cycpO1xuICAgICAgICAgICAgcmV0dXJuIGNsZWFyKG1hcChzY2FsYXJzKSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhc2gtdG8tY3VydmUuanMubWFwIl0sIm5hbWVzIjpbIkZwSW52ZXJ0QmF0Y2giLCJtb2QiLCJhYnl0ZXMiLCJieXRlc1RvTnVtYmVyQkUiLCJjb25jYXRCeXRlcyIsInV0ZjhUb0J5dGVzIiwidmFsaWRhdGVPYmplY3QiLCJvczJpcCIsImkyb3NwIiwidmFsdWUiLCJsZW5ndGgiLCJhbnVtIiwiRXJyb3IiLCJyZXMiLCJBcnJheSIsImZyb20iLCJmaWxsIiwiaSIsIlVpbnQ4QXJyYXkiLCJzdHJ4b3IiLCJhIiwiYiIsImFyciIsIml0ZW0iLCJOdW1iZXIiLCJpc1NhZmVJbnRlZ2VyIiwiZXhwYW5kX21lc3NhZ2VfeG1kIiwibXNnIiwiRFNUIiwibGVuSW5CeXRlcyIsIkgiLCJvdXRwdXRMZW4iLCJiX2luX2J5dGVzIiwiYmxvY2tMZW4iLCJyX2luX2J5dGVzIiwiZWxsIiwiTWF0aCIsImNlaWwiLCJEU1RfcHJpbWUiLCJaX3BhZCIsImxfaV9iX3N0ciIsImJfMCIsImFyZ3MiLCJwc2V1ZG9fcmFuZG9tX2J5dGVzIiwic2xpY2UiLCJleHBhbmRfbWVzc2FnZV94b2YiLCJrIiwiZGtMZW4iLCJjcmVhdGUiLCJ1cGRhdGUiLCJkaWdlc3QiLCJoYXNoX3RvX2ZpZWxkIiwiY291bnQiLCJvcHRpb25zIiwicCIsIm0iLCJoYXNoIiwiZXhwYW5kIiwiX0RTVCIsImxvZzJwIiwidG9TdHJpbmciLCJMIiwibGVuX2luX2J5dGVzIiwicHJiIiwidSIsImUiLCJqIiwiZWxtX29mZnNldCIsInR2Iiwic3ViYXJyYXkiLCJpc29nZW55TWFwIiwiZmllbGQiLCJtYXAiLCJjb2VmZiIsInJldmVyc2UiLCJ4IiwieSIsInhuIiwieGQiLCJ5biIsInlkIiwidmFsIiwicmVkdWNlIiwiYWNjIiwiYWRkIiwibXVsIiwieGRfaW52IiwieWRfaW52IiwiY3JlYXRlSGFzaGVyIiwiUG9pbnQiLCJtYXBUb0N1cnZlIiwiZGVmYXVsdHMiLCJudW0iLCJmcm9tQWZmaW5lIiwiY2xlYXIiLCJpbml0aWFsIiwiUCIsImNsZWFyQ29mYWN0b3IiLCJlcXVhbHMiLCJaRVJPIiwiYXNzZXJ0VmFsaWRpdHkiLCJoYXNoVG9DdXJ2ZSIsInUwIiwidTEiLCJlbmNvZGVUb0N1cnZlIiwiZW5jb2RlRFNUIiwic2NhbGFycyIsImlzQXJyYXkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/abstract/hash-to-curve.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/abstract/modular.js":
/*!****************************************************************************!*\
  !*** ./node_modules/ox/node_modules/@noble/curves/esm/abstract/modular.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Field: () => (/* binding */ Field),\n/* harmony export */   FpDiv: () => (/* binding */ FpDiv),\n/* harmony export */   FpInvertBatch: () => (/* binding */ FpInvertBatch),\n/* harmony export */   FpIsSquare: () => (/* binding */ FpIsSquare),\n/* harmony export */   FpLegendre: () => (/* binding */ FpLegendre),\n/* harmony export */   FpPow: () => (/* binding */ FpPow),\n/* harmony export */   FpSqrt: () => (/* binding */ FpSqrt),\n/* harmony export */   FpSqrtEven: () => (/* binding */ FpSqrtEven),\n/* harmony export */   FpSqrtOdd: () => (/* binding */ FpSqrtOdd),\n/* harmony export */   getFieldBytesLength: () => (/* binding */ getFieldBytesLength),\n/* harmony export */   getMinHashLength: () => (/* binding */ getMinHashLength),\n/* harmony export */   hashToPrivateScalar: () => (/* binding */ hashToPrivateScalar),\n/* harmony export */   invert: () => (/* binding */ invert),\n/* harmony export */   isNegativeLE: () => (/* binding */ isNegativeLE),\n/* harmony export */   mapHashToField: () => (/* binding */ mapHashToField),\n/* harmony export */   mod: () => (/* binding */ mod),\n/* harmony export */   nLength: () => (/* binding */ nLength),\n/* harmony export */   pow: () => (/* binding */ pow),\n/* harmony export */   pow2: () => (/* binding */ pow2),\n/* harmony export */   tonelliShanks: () => (/* binding */ tonelliShanks),\n/* harmony export */   validateField: () => (/* binding */ validateField)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/abstract/utils.js\");\n/**\n * Utils for modular division and finite fields.\n * A finite field over 11 is integer number operations `mod 11`.\n * There is no division: it is replaced by modular multiplicative inverse.\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = /* @__PURE__ */ BigInt(2), _3n = /* @__PURE__ */ BigInt(3);\n// prettier-ignore\nconst _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5), _8n = /* @__PURE__ */ BigInt(8);\n// Calculates a modulo b\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * TODO: remove.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */ function pow(num, power, modulo) {\n    return FpPow(Field(modulo), num, power);\n}\n/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */ function pow2(x, power, modulo) {\n    let res = x;\n    while(power-- > _0n){\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n/**\n * Inverses number over modulo.\n * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).\n */ function invert(number, modulo) {\n    if (number === _0n) throw new Error(\"invert: expected non-zero number\");\n    if (modulo <= _0n) throw new Error(\"invert: expected positive modulus, got \" + modulo);\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while(a !== _0n){\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n) throw new Error(\"invert: does not exist\");\n    return mod(x, modulo);\n}\n// Not all roots are possible! Example which will throw:\n// const NUM =\n// n = 72057594037927816n;\n// Fp = Field(BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab'));\nfunction sqrt3mod4(Fp, n) {\n    const p1div4 = (Fp.ORDER + _1n) / _4n;\n    const root = Fp.pow(n, p1div4);\n    // Throw if root^2 != n\n    if (!Fp.eql(Fp.sqr(root), n)) throw new Error(\"Cannot find square root\");\n    return root;\n}\nfunction sqrt5mod8(Fp, n) {\n    const p5div8 = (Fp.ORDER - _5n) / _8n;\n    const n2 = Fp.mul(n, _2n);\n    const v = Fp.pow(n2, p5div8);\n    const nv = Fp.mul(n, v);\n    const i = Fp.mul(Fp.mul(nv, _2n), v);\n    const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n    if (!Fp.eql(Fp.sqr(root), n)) throw new Error(\"Cannot find square root\");\n    return root;\n}\n// TODO: Commented-out for now. Provide test vectors.\n// Tonelli is too slow for extension fields Fp2.\n// That means we can't use sqrt (c1, c2...) even for initialization constants.\n// if (P % _16n === _9n) return sqrt9mod16;\n// // prettier-ignore\n// function sqrt9mod16<T>(Fp: IField<T>, n: T, p7div16?: bigint) {\n//   if (p7div16 === undefined) p7div16 = (Fp.ORDER + BigInt(7)) / _16n;\n//   const c1 = Fp.sqrt(Fp.neg(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n//   const c2 = Fp.sqrt(c1);             //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n//   const c3 = Fp.sqrt(Fp.neg(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n//   const c4 = p7div16;                 //  4. c4 = (q + 7) / 16        # Integer arithmetic\n//   let tv1 = Fp.pow(n, c4);            //  1. tv1 = x^c4\n//   let tv2 = Fp.mul(c1, tv1);          //  2. tv2 = c1 * tv1\n//   const tv3 = Fp.mul(c2, tv1);        //  3. tv3 = c2 * tv1\n//   let tv4 = Fp.mul(c3, tv1);          //  4. tv4 = c3 * tv1\n//   const e1 = Fp.eql(Fp.sqr(tv2), n);  //  5.  e1 = (tv2^2) == x\n//   const e2 = Fp.eql(Fp.sqr(tv3), n);  //  6.  e2 = (tv3^2) == x\n//   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n//   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n//   const e3 = Fp.eql(Fp.sqr(tv2), n);  //  9.  e3 = (tv2^2) == x\n//   return Fp.cmov(tv1, tv2, e3); // 10.  z = CMOV(tv1, tv2, e3) # Select the sqrt from tv1 and tv2\n// }\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */ function tonelliShanks(P) {\n    // Initialization (precomputation).\n    if (P < BigInt(3)) throw new Error(\"sqrt is not defined for small field\");\n    // Factor P - 1 = Q * 2^S, where Q is odd\n    let Q = P - _1n;\n    let S = 0;\n    while(Q % _2n === _0n){\n        Q /= _2n;\n        S++;\n    }\n    // Find the first quadratic non-residue Z >= 2\n    let Z = _2n;\n    const _Fp = Field(P);\n    while(FpLegendre(_Fp, Z) === 1){\n        // Basic primality test for P. After x iterations, chance of\n        // not finding quadratic non-residue is 2^x, so 2^1000.\n        if (Z++ > 1000) throw new Error(\"Cannot find square root: probably non-prime P\");\n    }\n    // Fast-path; usually done before Z, but we do \"primality test\".\n    if (S === 1) return sqrt3mod4;\n    // Slow-path\n    // TODO: test on Fp2 and others\n    let cc = _Fp.pow(Z, Q); // c = z^Q\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        if (Fp.is0(n)) return n;\n        // Check if n is a quadratic residue using Legendre symbol\n        if (FpLegendre(Fp, n) !== 1) throw new Error(\"Cannot find square root\");\n        // Initialize variables for the main loop\n        let M = S;\n        let c = Fp.mul(Fp.ONE, cc); // c = z^Q, move cc from field _Fp into field Fp\n        let t = Fp.pow(n, Q); // t = n^Q, first guess at the fudge factor\n        let R = Fp.pow(n, Q1div2); // R = n^((Q+1)/2), first guess at the square root\n        // Main loop\n        // while t != 1\n        while(!Fp.eql(t, Fp.ONE)){\n            if (Fp.is0(t)) return Fp.ZERO; // if t=0 return R=0\n            let i = 1;\n            // Find the smallest i >= 1 such that t^(2^i) ‚â° 1 (mod P)\n            let t_tmp = Fp.sqr(t); // t^(2^1)\n            while(!Fp.eql(t_tmp, Fp.ONE)){\n                i++;\n                t_tmp = Fp.sqr(t_tmp); // t^(2^2)...\n                if (i === M) throw new Error(\"Cannot find square root\");\n            }\n            // Calculate the exponent for b: 2^(M - i - 1)\n            const exponent = _1n << BigInt(M - i - 1); // bigint is important\n            const b = Fp.pow(c, exponent); // b = 2^(M - i - 1)\n            // Update variables\n            M = i;\n            c = Fp.sqr(b); // c = b^2\n            t = Fp.mul(t, c); // t = (t * b^2)\n            R = Fp.mul(R, b); // R = R*b\n        }\n        return R;\n    };\n}\n/**\n * Square root for a finite field. Will try optimized versions first:\n *\n * 1. P ‚â° 3 (mod 4)\n * 2. P ‚â° 5 (mod 8)\n * 3. Tonelli-Shanks algorithm\n *\n * Different algorithms can give different roots, it is up to user to decide which one they want.\n * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n */ function FpSqrt(P) {\n    // P ‚â° 3 (mod 4) => ‚àön = n^((P+1)/4)\n    if (P % _4n === _3n) return sqrt3mod4;\n    // P ‚â° 5 (mod 8) => Atkin algorithm, page 10 of https://eprint.iacr.org/2012/685.pdf\n    if (P % _8n === _5n) return sqrt5mod8;\n    // P ‚â° 9 (mod 16) not implemented, see above\n    // Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nconst isNegativeLE = (num, modulo)=>(mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    \"create\",\n    \"isValid\",\n    \"is0\",\n    \"neg\",\n    \"inv\",\n    \"sqrt\",\n    \"sqr\",\n    \"eql\",\n    \"add\",\n    \"sub\",\n    \"mul\",\n    \"pow\",\n    \"div\",\n    \"addN\",\n    \"subN\",\n    \"mulN\",\n    \"sqrN\"\n];\nfunction validateField(field) {\n    const initial = {\n        ORDER: \"bigint\",\n        MASK: \"bigint\",\n        BYTES: \"isSafeInteger\",\n        BITS: \"isSafeInteger\"\n    };\n    const opts = FIELD_FIELDS.reduce((map, val)=>{\n        map[val] = \"function\";\n        return map;\n    }, initial);\n    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(field, opts);\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */ function FpPow(Fp, num, power) {\n    if (power < _0n) throw new Error(\"invalid exponent, negatives unsupported\");\n    if (power === _0n) return Fp.ONE;\n    if (power === _1n) return num;\n    let p = Fp.ONE;\n    let d = num;\n    while(power > _0n){\n        if (power & _1n) p = Fp.mul(p, d);\n        d = Fp.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * Exception-free. Will return `undefined` for 0 elements.\n * @param passZero map 0 to 0 (instead of undefined)\n */ function FpInvertBatch(Fp, nums, passZero = false) {\n    const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : undefined);\n    // Walk from first to last, multiply them by each other MOD p\n    const multipliedAcc = nums.reduce((acc, num, i)=>{\n        if (Fp.is0(num)) return acc;\n        inverted[i] = acc;\n        return Fp.mul(acc, num);\n    }, Fp.ONE);\n    // Invert last element\n    const invertedAcc = Fp.inv(multipliedAcc);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i)=>{\n        if (Fp.is0(num)) return acc;\n        inverted[i] = Fp.mul(acc, inverted[i]);\n        return Fp.mul(acc, num);\n    }, invertedAcc);\n    return inverted;\n}\n// TODO: remove\nfunction FpDiv(Fp, lhs, rhs) {\n    return Fp.mul(lhs, typeof rhs === \"bigint\" ? invert(rhs, Fp.ORDER) : Fp.inv(rhs));\n}\n/**\n * Legendre symbol.\n * Legendre constant is used to calculate Legendre symbol (a | p)\n * which denotes the value of a^((p-1)/2) (mod p).\n *\n * * (a | p) ‚â° 1    if a is a square (mod p), quadratic residue\n * * (a | p) ‚â° -1   if a is not a square (mod p), quadratic non residue\n * * (a | p) ‚â° 0    if a ‚â° 0 (mod p)\n */ function FpLegendre(Fp, n) {\n    // We can use 3rd argument as optional cache of this value\n    // but seems unneeded for now. The operation is very fast.\n    const p1mod2 = (Fp.ORDER - _1n) / _2n;\n    const powered = Fp.pow(n, p1mod2);\n    const yes = Fp.eql(powered, Fp.ONE);\n    const zero = Fp.eql(powered, Fp.ZERO);\n    const no = Fp.eql(powered, Fp.neg(Fp.ONE));\n    if (!yes && !zero && !no) throw new Error(\"invalid Legendre symbol result\");\n    return yes ? 1 : zero ? 0 : -1;\n}\n// This function returns True whenever the value x is a square in the field F.\nfunction FpIsSquare(Fp, n) {\n    const l = FpLegendre(Fp, n);\n    return l === 1;\n}\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    if (nBitLength !== undefined) (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.anumber)(nBitLength);\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return {\n        nBitLength: _nBitLength,\n        nByteLength\n    };\n}\n/**\n * Initializes a finite field over prime.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * Fragile: always run a benchmark on a change.\n * Security note: operations don't check 'isValid' for all elements for performance reasons,\n * it is caller responsibility to check this.\n * This is low-level code, please make sure you know what you're doing.\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */ function Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n) throw new Error(\"invalid field: expected ORDER > 0, got \" + ORDER);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048) throw new Error(\"invalid field: expected ORDER of <= 2048 bytes\");\n    let sqrtP; // cached sqrtP\n    const f = Object.freeze({\n        ORDER,\n        isLE,\n        BITS,\n        BYTES,\n        MASK: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num)=>mod(num, ORDER),\n        isValid: (num)=>{\n            if (typeof num !== \"bigint\") throw new Error(\"invalid field element: expected bigint, got \" + typeof num);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num)=>num === _0n,\n        isOdd: (num)=>(num & _1n) === _1n,\n        neg: (num)=>mod(-num, ORDER),\n        eql: (lhs, rhs)=>lhs === rhs,\n        sqr: (num)=>mod(num * num, ORDER),\n        add: (lhs, rhs)=>mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs)=>mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs)=>mod(lhs * rhs, ORDER),\n        pow: (num, power)=>FpPow(f, num, power),\n        div: (lhs, rhs)=>mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num)=>num * num,\n        addN: (lhs, rhs)=>lhs + rhs,\n        subN: (lhs, rhs)=>lhs - rhs,\n        mulN: (lhs, rhs)=>lhs * rhs,\n        inv: (num)=>invert(num, ORDER),\n        sqrt: redef.sqrt || ((n)=>{\n            if (!sqrtP) sqrtP = FpSqrt(ORDER);\n            return sqrtP(f, n);\n        }),\n        toBytes: (num)=>isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(num, BYTES) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(num, BYTES),\n        fromBytes: (bytes)=>{\n            if (bytes.length !== BYTES) throw new Error(\"Field.fromBytes: expected \" + BYTES + \" bytes, got \" + bytes.length);\n            return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(bytes) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(bytes);\n        },\n        // TODO: we don't need it here, move out to separate fn\n        invertBatch: (lst)=>FpInvertBatch(f, lst),\n        // We can't move this out because Fp6, Fp12 implement it\n        // and it's unclear what to return in there.\n        cmov: (a, b, c)=>c ? b : a\n    });\n    return Object.freeze(f);\n}\nfunction FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nfunction FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use `mapKeyToField` instead\n */ function hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"privateHash\", hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024) throw new Error(\"hashToPrivateScalar: expected \" + minLen + \"-1024 bytes of input, got \" + hashLen);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(hash) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */ function getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== \"bigint\") throw new Error(\"field order must be bigint\");\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */ function getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */ function mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024) throw new Error(\"expected \" + minLen + \"-1024 bytes of input, got \" + len);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(key) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(reduced, fieldLen) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(reduced, fieldLen);\n} //# sourceMappingURL=modular.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L21vZHVsYXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Q0FLQyxHQUNELG9FQUFvRSxHQUN0QjtBQUN5RjtBQUN2SSxrQkFBa0I7QUFDbEIsTUFBTVEsTUFBTUMsT0FBTyxJQUFJQyxNQUFNRCxPQUFPLElBQUlFLE1BQU0sYUFBYSxHQUFHRixPQUFPLElBQUlHLE1BQU0sYUFBYSxHQUFHSCxPQUFPO0FBQ3RHLGtCQUFrQjtBQUNsQixNQUFNSSxNQUFNLGFBQWEsR0FBR0osT0FBTyxJQUFJSyxNQUFNLGFBQWEsR0FBR0wsT0FBTyxJQUFJTSxNQUFNLGFBQWEsR0FBR04sT0FBTztBQUNyRyx3QkFBd0I7QUFDakIsU0FBU08sSUFBSUMsQ0FBQyxFQUFFQyxDQUFDO0lBQ3BCLE1BQU1DLFNBQVNGLElBQUlDO0lBQ25CLE9BQU9DLFVBQVVYLE1BQU1XLFNBQVNELElBQUlDO0FBQ3hDO0FBQ0E7Ozs7OztDQU1DLEdBQ00sU0FBU0MsSUFBSUMsR0FBRyxFQUFFQyxLQUFLLEVBQUVDLE1BQU07SUFDbEMsT0FBT0MsTUFBTUMsTUFBTUYsU0FBU0YsS0FBS0M7QUFDckM7QUFDQSwwREFBMEQsR0FDbkQsU0FBU0ksS0FBS0MsQ0FBQyxFQUFFTCxLQUFLLEVBQUVDLE1BQU07SUFDakMsSUFBSUssTUFBTUQ7SUFDVixNQUFPTCxVQUFVZCxJQUFLO1FBQ2xCb0IsT0FBT0E7UUFDUEEsT0FBT0w7SUFDWDtJQUNBLE9BQU9LO0FBQ1g7QUFDQTs7O0NBR0MsR0FDTSxTQUFTQyxPQUFPQyxNQUFNLEVBQUVQLE1BQU07SUFDakMsSUFBSU8sV0FBV3RCLEtBQ1gsTUFBTSxJQUFJdUIsTUFBTTtJQUNwQixJQUFJUixVQUFVZixLQUNWLE1BQU0sSUFBSXVCLE1BQU0sNENBQTRDUjtJQUNoRSxrRkFBa0Y7SUFDbEYsSUFBSU4sSUFB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ZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L21vZHVsYXIuanM/MjNlYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFV0aWxzIGZvciBtb2R1bGFyIGRpdmlzaW9uIGFuZCBmaW5pdGUgZmllbGRzLlxuICogQSBmaW5pdGUgZmllbGQgb3ZlciAxMSBpcyBpbnRlZ2VyIG51bWJlciBvcGVyYXRpb25zIGBtb2QgMTFgLlxuICogVGhlcmUgaXMgbm8gZGl2aXNpb246IGl0IGlzIHJlcGxhY2VkIGJ5IG1vZHVsYXIgbXVsdGlwbGljYXRpdmUgaW52ZXJzZS5cbiAqIEBtb2R1bGVcbiAqL1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHsgYW51bWJlciB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvdXRpbHMnO1xuaW1wb3J0IHsgYml0TWFzaywgYnl0ZXNUb051bWJlckJFLCBieXRlc1RvTnVtYmVyTEUsIGVuc3VyZUJ5dGVzLCBudW1iZXJUb0J5dGVzQkUsIG51bWJlclRvQnl0ZXNMRSwgdmFsaWRhdGVPYmplY3QsIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzBuID0gQmlnSW50KDApLCBfMW4gPSBCaWdJbnQoMSksIF8ybiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMiksIF8zbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMyk7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF80biA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoNCksIF81biA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoNSksIF84biA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoOCk7XG4vLyBDYWxjdWxhdGVzIGEgbW9kdWxvIGJcbmV4cG9ydCBmdW5jdGlvbiBtb2QoYSwgYikge1xuICAgIGNvbnN0IHJlc3VsdCA9IGEgJSBiO1xuICAgIHJldHVybiByZXN1bHQgPj0gXzBuID8gcmVzdWx0IDogYiArIHJlc3VsdDtcbn1cbi8qKlxuICogRWZmaWNpZW50bHkgcmFpc2UgbnVtIHRvIHBvd2VyIGFuZCBkbyBtb2R1bGFyIGRpdmlzaW9uLlxuICogVW5zYWZlIGluIHNvbWUgY29udGV4dHM6IHVzZXMgbGFkZGVyLCBzbyBjYW4gZXhwb3NlIGJpZ2ludCBiaXRzLlxuICogVE9ETzogcmVtb3ZlLlxuICogQGV4YW1wbGVcbiAqIHBvdygybiwgNm4sIDExbikgLy8gNjRuICUgMTFuID09IDluXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwb3cobnVtLCBwb3dlciwgbW9kdWxvKSB7XG4gICAgcmV0dXJuIEZwUG93KEZpZWxkKG1vZHVsbyksIG51bSwgcG93ZXIpO1xufVxuLyoqIERvZXMgYHheKDJecG93ZXIpYCBtb2QgcC4gYHBvdzIoMzAsIDQpYCA9PSBgMzBeKDJeNClgICovXG5leHBvcnQgZnVuY3Rpb24gcG93Mih4LCBwb3dlciwgbW9kdWxvKSB7XG4gICAgbGV0IHJlcyA9IHg7XG4gICAgd2hpbGUgKHBvd2VyLS0gPiBfMG4pIHtcbiAgICAgICAgcmVzICo9IHJlcztcbiAgICAgICAgcmVzICU9IG1vZHVsbztcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8qKlxuICogSW52ZXJzZXMgbnVtYmVyIG92ZXIgbW9kdWxvLlxuICogSW1wbGVtZW50ZWQgdXNpbmcgW0V1Y2xpZGVhbiBHQ0RdKGh0dHBzOi8vYnJpbGxpYW50Lm9yZy93aWtpL2V4dGVuZGVkLWV1Y2xpZGVhbi1hbGdvcml0aG0vKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludmVydChudW1iZXIsIG1vZHVsbykge1xuICAgIGlmIChudW1iZXIgPT09IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZlcnQ6IGV4cGVjdGVkIG5vbi16ZXJvIG51bWJlcicpO1xuICAgIGlmIChtb2R1bG8gPD0gXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmVydDogZXhwZWN0ZWQgcG9zaXRpdmUgbW9kdWx1cywgZ290ICcgKyBtb2R1bG8pO1xuICAgIC8vIEZlcm1hdCdzIGxpdHRsZSB0aGVvcmVtIFwiQ1QtbGlrZVwiIHZlcnNpb24gaW52KG4pID0gbl4obS0yKSBtb2QgbSBpcyAzMHggc2xvd2VyLlxuICAgIGxldCBhID0gbW9kKG51bWJlciwgbW9kdWxvKTtcbiAgICBsZXQgYiA9IG1vZHVsbztcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBsZXQgeCA9IF8wbiwgeSA9IF8xbiwgdSA9IF8xbiwgdiA9IF8wbjtcbiAgICB3aGlsZSAoYSAhPT0gXzBuKSB7XG4gICAgICAgIC8vIEpJVCBhcHBsaWVzIG9wdGltaXphdGlvbiBpZiB0aG9zZSB0d28gbGluZXMgZm9sbG93IGVhY2ggb3RoZXJcbiAgICAgICAgY29uc3QgcSA9IGIgLyBhO1xuICAgICAgICBjb25zdCByID0gYiAlIGE7XG4gICAgICAgIGNvbnN0IG0gPSB4IC0gdSAqIHE7XG4gICAgICAgIGNvbnN0IG4gPSB5IC0gdiAqIHE7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBiID0gYSwgYSA9IHIsIHggPSB1LCB5ID0gdiwgdSA9IG0sIHYgPSBuO1xuICAgIH1cbiAgICBjb25zdCBnY2QgPSBiO1xuICAgIGlmIChnY2QgIT09IF8xbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZlcnQ6IGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgcmV0dXJuIG1vZCh4LCBtb2R1bG8pO1xufVxuLy8gTm90IGFsbCByb290cyBhcmUgcG9zc2libGUhIEV4YW1wbGUgd2hpY2ggd2lsbCB0aHJvdzpcbi8vIGNvbnN0IE5VTSA9XG4vLyBuID0gNzIwNTc1OTQwMzc5Mjc4MTZuO1xuLy8gRnAgPSBGaWVsZChCaWdJbnQoJzB4MWEwMTExZWEzOTdmZTY5YTRiMWJhN2I2NDM0YmFjZDc2NDc3NGI4NGYzODUxMmJmNjczMGQyYTBmNmIwZjYyNDFlYWJmZmZlYjE1M2ZmZmZiOWZlZmZmZmZmZmZhYWFiJykpO1xuZnVuY3Rpb24gc3FydDNtb2Q0KEZwLCBuKSB7XG4gICAgY29uc3QgcDFkaXY0ID0gKEZwLk9SREVSICsgXzFuKSAvIF80bjtcbiAgICBjb25zdCByb290ID0gRnAucG93KG4sIHAxZGl2NCk7XG4gICAgLy8gVGhyb3cgaWYgcm9vdF4yICE9IG5cbiAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIG4pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgcmV0dXJuIHJvb3Q7XG59XG5mdW5jdGlvbiBzcXJ0NW1vZDgoRnAsIG4pIHtcbiAgICBjb25zdCBwNWRpdjggPSAoRnAuT1JERVIgLSBfNW4pIC8gXzhuO1xuICAgIGNvbnN0IG4yID0gRnAubXVsKG4sIF8ybik7XG4gICAgY29uc3QgdiA9IEZwLnBvdyhuMiwgcDVkaXY4KTtcbiAgICBjb25zdCBudiA9IEZwLm11bChuLCB2KTtcbiAgICBjb25zdCBpID0gRnAubXVsKEZwLm11bChudiwgXzJuKSwgdik7XG4gICAgY29uc3Qgcm9vdCA9IEZwLm11bChudiwgRnAuc3ViKGksIEZwLk9ORSkpO1xuICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICByZXR1cm4gcm9vdDtcbn1cbi8vIFRPRE86IENvbW1lbnRlZC1vdXQgZm9yIG5vdy4gUHJvdmlkZSB0ZXN0IHZlY3RvcnMuXG4vLyBUb25lbGxpIGlzIHRvbyBzbG93IGZvciBleHRlbnNpb24gZmllbGRzIEZwMi5cbi8vIFRoYXQgbWVhbnMgd2UgY2FuJ3QgdXNlIHNxcnQgKGMxLCBjMi4uLikgZXZlbiBmb3IgaW5pdGlhbGl6YXRpb24gY29uc3RhbnRzLlxuLy8gaWYgKFAgJSBfMTZuID09PSBfOW4pIHJldHVybiBzcXJ0OW1vZDE2O1xuLy8gLy8gcHJldHRpZXItaWdub3JlXG4vLyBmdW5jdGlvbiBzcXJ0OW1vZDE2PFQ+KEZwOiBJRmllbGQ8VD4sIG46IFQsIHA3ZGl2MTY/OiBiaWdpbnQpIHtcbi8vICAgaWYgKHA3ZGl2MTYgPT09IHVuZGVmaW5lZCkgcDdkaXYxNiA9IChGcC5PUkRFUiArIEJpZ0ludCg3KSkgLyBfMTZuO1xuLy8gICBjb25zdCBjMSA9IEZwLnNxcnQoRnAubmVnKEZwLk9ORSkpOyAvLyAgMS4gYzEgPSBzcXJ0KC0xKSBpbiBGLCBpLmUuLCAoYzFeMikgPT0gLTEgaW4gRlxuLy8gICBjb25zdCBjMiA9IEZwLnNxcnQoYzEpOyAgICAgICAgICAgICAvLyAgMi4gYzIgPSBzcXJ0KGMxKSBpbiBGLCBpLmUuLCAoYzJeMikgPT0gYzEgaW4gRlxuLy8gICBjb25zdCBjMyA9IEZwLnNxcnQoRnAubmVnKGMxKSk7ICAgICAvLyAgMy4gYzMgPSBzcXJ0KC1jMSkgaW4gRiwgaS5lLiwgKGMzXjIpID09IC1jMSBpbiBGXG4vLyAgIGNvbnN0IGM0ID0gcDdkaXYxNjsgICAgICAgICAgICAgICAgIC8vICA0LiBjNCA9IChxICsgNykgLyAxNiAgICAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbi8vICAgbGV0IHR2MSA9IEZwLnBvdyhuLCBjNCk7ICAgICAgICAgICAgLy8gIDEuIHR2MSA9IHheYzRcbi8vICAgbGV0IHR2MiA9IEZwLm11bChjMSwgdHYxKTsgICAgICAgICAgLy8gIDIuIHR2MiA9IGMxICogdHYxXG4vLyAgIGNvbnN0IHR2MyA9IEZwLm11bChjMiwgdHYxKTsgICAgICAgIC8vICAzLiB0djMgPSBjMiAqIHR2MVxuLy8gICBsZXQgdHY0ID0gRnAubXVsKGMzLCB0djEpOyAgICAgICAgICAvLyAgNC4gdHY0ID0gYzMgKiB0djFcbi8vICAgY29uc3QgZTEgPSBGcC5lcWwoRnAuc3FyKHR2MiksIG4pOyAgLy8gIDUuICBlMSA9ICh0djJeMikgPT0geFxuLy8gICBjb25zdCBlMiA9IEZwLmVxbChGcC5zcXIodHYzKSwgbik7ICAvLyAgNi4gIGUyID0gKHR2M14yKSA9PSB4XG4vLyAgIHR2MSA9IEZwLmNtb3YodHYxLCB0djIsIGUxKTsgLy8gIDcuIHR2MSA9IENNT1YodHYxLCB0djIsIGUxKSAgIyBTZWxlY3QgdHYyIGlmICh0djJeMikgPT0geFxuLy8gICB0djIgPSBGcC5jbW92KHR2NCwgdHYzLCBlMik7IC8vICA4LiB0djIgPSBDTU9WKHR2NCwgdHYzLCBlMikgICMgU2VsZWN0IHR2MyBpZiAodHYzXjIpID09IHhcbi8vICAgY29uc3QgZTMgPSBGcC5lcWwoRnAuc3FyKHR2MiksIG4pOyAgLy8gIDkuICBlMyA9ICh0djJeMikgPT0geFxuLy8gICByZXR1cm4gRnAuY21vdih0djEsIHR2MiwgZTMpOyAvLyAxMC4gIHogPSBDTU9WKHR2MSwgdHYyLCBlMykgIyBTZWxlY3QgdGhlIHNxcnQgZnJvbSB0djEgYW5kIHR2MlxuLy8gfVxuLyoqXG4gKiBUb25lbGxpLVNoYW5rcyBzcXVhcmUgcm9vdCBzZWFyY2ggYWxnb3JpdGhtLlxuICogMS4gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxMi82ODUucGRmIChwYWdlIDEyKVxuICogMi4gU3F1YXJlIFJvb3RzIGZyb20gMTsgMjQsIDUxLCAxMCB0byBEYW4gU2hhbmtzXG4gKiBAcGFyYW0gUCBmaWVsZCBvcmRlclxuICogQHJldHVybnMgZnVuY3Rpb24gdGhhdCB0YWtlcyBmaWVsZCBGcCAoY3JlYXRlZCBmcm9tIFApIGFuZCBudW1iZXIgblxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9uZWxsaVNoYW5rcyhQKSB7XG4gICAgLy8gSW5pdGlhbGl6YXRpb24gKHByZWNvbXB1dGF0aW9uKS5cbiAgICBpZiAoUCA8IEJpZ0ludCgzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzcXJ0IGlzIG5vdCBkZWZpbmVkIGZvciBzbWFsbCBmaWVsZCcpO1xuICAgIC8vIEZhY3RvciBQIC0gMSA9IFEgKiAyXlMsIHdoZXJlIFEgaXMgb2RkXG4gICAgbGV0IFEgPSBQIC0gXzFuO1xuICAgIGxldCBTID0gMDtcbiAgICB3aGlsZSAoUSAlIF8ybiA9PT0gXzBuKSB7XG4gICAgICAgIFEgLz0gXzJuO1xuICAgICAgICBTKys7XG4gICAgfVxuICAgIC8vIEZpbmQgdGhlIGZpcnN0IHF1YWRyYXRpYyBub24tcmVzaWR1ZSBaID49IDJcbiAgICBsZXQgWiA9IF8ybjtcbiAgICBjb25zdCBfRnAgPSBGaWVsZChQKTtcbiAgICB3aGlsZSAoRnBMZWdlbmRyZShfRnAsIFopID09PSAxKSB7XG4gICAgICAgIC8vIEJhc2ljIHByaW1hbGl0eSB0ZXN0IGZvciBQLiBBZnRlciB4IGl0ZXJhdGlvbnMsIGNoYW5jZSBvZlxuICAgICAgICAvLyBub3QgZmluZGluZyBxdWFkcmF0aWMgbm9uLXJlc2lkdWUgaXMgMl54LCBzbyAyXjEwMDAuXG4gICAgICAgIGlmIChaKysgPiAxMDAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdDogcHJvYmFibHkgbm9uLXByaW1lIFAnKTtcbiAgICB9XG4gICAgLy8gRmFzdC1wYXRoOyB1c3VhbGx5IGRvbmUgYmVmb3JlIFosIGJ1dCB3ZSBkbyBcInByaW1hbGl0eSB0ZXN0XCIuXG4gICAgaWYgKFMgPT09IDEpXG4gICAgICAgIHJldHVybiBzcXJ0M21vZDQ7XG4gICAgLy8gU2xvdy1wYXRoXG4gICAgLy8gVE9ETzogdGVzdCBvbiBGcDIgYW5kIG90aGVyc1xuICAgIGxldCBjYyA9IF9GcC5wb3coWiwgUSk7IC8vIGMgPSB6XlFcbiAgICBjb25zdCBRMWRpdjIgPSAoUSArIF8xbikgLyBfMm47XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHRvbmVsbGlTbG93KEZwLCBuKSB7XG4gICAgICAgIGlmIChGcC5pczAobikpXG4gICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgLy8gQ2hlY2sgaWYgbiBpcyBhIHF1YWRyYXRpYyByZXNpZHVlIHVzaW5nIExlZ2VuZHJlIHN5bWJvbFxuICAgICAgICBpZiAoRnBMZWdlbmRyZShGcCwgbikgIT09IDEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgIC8vIEluaXRpYWxpemUgdmFyaWFibGVzIGZvciB0aGUgbWFpbiBsb29wXG4gICAgICAgIGxldCBNID0gUztcbiAgICAgICAgbGV0IGMgPSBGcC5tdWwoRnAuT05FLCBjYyk7IC8vIGMgPSB6XlEsIG1vdmUgY2MgZnJvbSBmaWVsZCBfRnAgaW50byBmaWVsZCBGcFxuICAgICAgICBsZXQgdCA9IEZwLnBvdyhuLCBRKTsgLy8gdCA9IG5eUSwgZmlyc3QgZ3Vlc3MgYXQgdGhlIGZ1ZGdlIGZhY3RvclxuICAgICAgICBsZXQgUiA9IEZwLnBvdyhuLCBRMWRpdjIpOyAvLyBSID0gbl4oKFErMSkvMiksIGZpcnN0IGd1ZXNzIGF0IHRoZSBzcXVhcmUgcm9vdFxuICAgICAgICAvLyBNYWluIGxvb3BcbiAgICAgICAgLy8gd2hpbGUgdCAhPSAxXG4gICAgICAgIHdoaWxlICghRnAuZXFsKHQsIEZwLk9ORSkpIHtcbiAgICAgICAgICAgIGlmIChGcC5pczAodCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEZwLlpFUk87IC8vIGlmIHQ9MCByZXR1cm4gUj0wXG4gICAgICAgICAgICBsZXQgaSA9IDE7XG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBzbWFsbGVzdCBpID49IDEgc3VjaCB0aGF0IHReKDJeaSkg4omhIDEgKG1vZCBQKVxuICAgICAgICAgICAgbGV0IHRfdG1wID0gRnAuc3FyKHQpOyAvLyB0XigyXjEpXG4gICAgICAgICAgICB3aGlsZSAoIUZwLmVxbCh0X3RtcCwgRnAuT05FKSkge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICB0X3RtcCA9IEZwLnNxcih0X3RtcCk7IC8vIHReKDJeMikuLi5cbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gTSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBleHBvbmVudCBmb3IgYjogMl4oTSAtIGkgLSAxKVxuICAgICAgICAgICAgY29uc3QgZXhwb25lbnQgPSBfMW4gPDwgQmlnSW50KE0gLSBpIC0gMSk7IC8vIGJpZ2ludCBpcyBpbXBvcnRhbnRcbiAgICAgICAgICAgIGNvbnN0IGIgPSBGcC5wb3coYywgZXhwb25lbnQpOyAvLyBiID0gMl4oTSAtIGkgLSAxKVxuICAgICAgICAgICAgLy8gVXBkYXRlIHZhcmlhYmxlc1xuICAgICAgICAgICAgTSA9IGk7XG4gICAgICAgICAgICBjID0gRnAuc3FyKGIpOyAvLyBjID0gYl4yXG4gICAgICAgICAgICB0ID0gRnAubXVsKHQsIGMpOyAvLyB0ID0gKHQgKiBiXjIpXG4gICAgICAgICAgICBSID0gRnAubXVsKFIsIGIpOyAvLyBSID0gUipiXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFI7XG4gICAgfTtcbn1cbi8qKlxuICogU3F1YXJlIHJvb3QgZm9yIGEgZmluaXRlIGZpZWxkLiBXaWxsIHRyeSBvcHRpbWl6ZWQgdmVyc2lvbnMgZmlyc3Q6XG4gKlxuICogMS4gUCDiiaEgMyAobW9kIDQpXG4gKiAyLiBQIOKJoSA1IChtb2QgOClcbiAqIDMuIFRvbmVsbGktU2hhbmtzIGFsZ29yaXRobVxuICpcbiAqIERpZmZlcmVudCBhbGdvcml0aG1zIGNhbiBnaXZlIGRpZmZlcmVudCByb290cywgaXQgaXMgdXAgdG8gdXNlciB0byBkZWNpZGUgd2hpY2ggb25lIHRoZXkgd2FudC5cbiAqIEZvciBleGFtcGxlIHRoZXJlIGlzIEZwU3FydE9kZC9GcFNxcnRFdmVuIHRvIGNob2ljZSByb290IGJhc2VkIG9uIG9kZG5lc3MgKHVzZWQgZm9yIGhhc2gtdG8tY3VydmUpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gRnBTcXJ0KFApIHtcbiAgICAvLyBQIOKJoSAzIChtb2QgNCkgPT4g4oiabiA9IG5eKChQKzEpLzQpXG4gICAgaWYgKFAgJSBfNG4gPT09IF8zbilcbiAgICAgICAgcmV0dXJuIHNxcnQzbW9kNDtcbiAgICAvLyBQIOKJoSA1IChtb2QgOCkgPT4gQXRraW4gYWxnb3JpdGhtLCBwYWdlIDEwIG9mIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTIvNjg1LnBkZlxuICAgIGlmIChQICUgXzhuID09PSBfNW4pXG4gICAgICAgIHJldHVybiBzcXJ0NW1vZDg7XG4gICAgLy8gUCDiiaEgOSAobW9kIDE2KSBub3QgaW1wbGVtZW50ZWQsIHNlZSBhYm92ZVxuICAgIC8vIFRvbmVsbGktU2hhbmtzIGFsZ29yaXRobVxuICAgIHJldHVybiB0b25lbGxpU2hhbmtzKFApO1xufVxuLy8gTGl0dGxlLWVuZGlhbiBjaGVjayBmb3IgZmlyc3QgTEUgYml0IChsYXN0IEJFIGJpdCk7XG5leHBvcnQgY29uc3QgaXNOZWdhdGl2ZUxFID0gKG51bSwgbW9kdWxvKSA9PiAobW9kKG51bSwgbW9kdWxvKSAmIF8xbikgPT09IF8xbjtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgRklFTERfRklFTERTID0gW1xuICAgICdjcmVhdGUnLCAnaXNWYWxpZCcsICdpczAnLCAnbmVnJywgJ2ludicsICdzcXJ0JywgJ3NxcicsXG4gICAgJ2VxbCcsICdhZGQnLCAnc3ViJywgJ211bCcsICdwb3cnLCAnZGl2JyxcbiAgICAnYWRkTicsICdzdWJOJywgJ211bE4nLCAnc3FyTidcbl07XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVGaWVsZChmaWVsZCkge1xuICAgIGNvbnN0IGluaXRpYWwgPSB7XG4gICAgICAgIE9SREVSOiAnYmlnaW50JyxcbiAgICAgICAgTUFTSzogJ2JpZ2ludCcsXG4gICAgICAgIEJZVEVTOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgICAgIEJJVFM6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICB9O1xuICAgIGNvbnN0IG9wdHMgPSBGSUVMRF9GSUVMRFMucmVkdWNlKChtYXAsIHZhbCkgPT4ge1xuICAgICAgICBtYXBbdmFsXSA9ICdmdW5jdGlvbic7XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgfSwgaW5pdGlhbCk7XG4gICAgcmV0dXJuIHZhbGlkYXRlT2JqZWN0KGZpZWxkLCBvcHRzKTtcbn1cbi8vIEdlbmVyaWMgZmllbGQgZnVuY3Rpb25zXG4vKipcbiAqIFNhbWUgYXMgYHBvd2AgYnV0IGZvciBGcDogbm9uLWNvbnN0YW50LXRpbWUuXG4gKiBVbnNhZmUgaW4gc29tZSBjb250ZXh0czogdXNlcyBsYWRkZXIsIHNvIGNhbiBleHBvc2UgYmlnaW50IGJpdHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGcFBvdyhGcCwgbnVtLCBwb3dlcikge1xuICAgIGlmIChwb3dlciA8IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGV4cG9uZW50LCBuZWdhdGl2ZXMgdW5zdXBwb3J0ZWQnKTtcbiAgICBpZiAocG93ZXIgPT09IF8wbilcbiAgICAgICAgcmV0dXJuIEZwLk9ORTtcbiAgICBpZiAocG93ZXIgPT09IF8xbilcbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICBsZXQgcCA9IEZwLk9ORTtcbiAgICBsZXQgZCA9IG51bTtcbiAgICB3aGlsZSAocG93ZXIgPiBfMG4pIHtcbiAgICAgICAgaWYgKHBvd2VyICYgXzFuKVxuICAgICAgICAgICAgcCA9IEZwLm11bChwLCBkKTtcbiAgICAgICAgZCA9IEZwLnNxcihkKTtcbiAgICAgICAgcG93ZXIgPj49IF8xbjtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG59XG4vKipcbiAqIEVmZmljaWVudGx5IGludmVydCBhbiBhcnJheSBvZiBGaWVsZCBlbGVtZW50cy5cbiAqIEV4Y2VwdGlvbi1mcmVlLiBXaWxsIHJldHVybiBgdW5kZWZpbmVkYCBmb3IgMCBlbGVtZW50cy5cbiAqIEBwYXJhbSBwYXNzWmVybyBtYXAgMCB0byAwIChpbnN0ZWFkIG9mIHVuZGVmaW5lZClcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZwSW52ZXJ0QmF0Y2goRnAsIG51bXMsIHBhc3NaZXJvID0gZmFsc2UpIHtcbiAgICBjb25zdCBpbnZlcnRlZCA9IG5ldyBBcnJheShudW1zLmxlbmd0aCkuZmlsbChwYXNzWmVybyA/IEZwLlpFUk8gOiB1bmRlZmluZWQpO1xuICAgIC8vIFdhbGsgZnJvbSBmaXJzdCB0byBsYXN0LCBtdWx0aXBseSB0aGVtIGJ5IGVhY2ggb3RoZXIgTU9EIHBcbiAgICBjb25zdCBtdWx0aXBsaWVkQWNjID0gbnVtcy5yZWR1Y2UoKGFjYywgbnVtLCBpKSA9PiB7XG4gICAgICAgIGlmIChGcC5pczAobnVtKSlcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIGludmVydGVkW2ldID0gYWNjO1xuICAgICAgICByZXR1cm4gRnAubXVsKGFjYywgbnVtKTtcbiAgICB9LCBGcC5PTkUpO1xuICAgIC8vIEludmVydCBsYXN0IGVsZW1lbnRcbiAgICBjb25zdCBpbnZlcnRlZEFjYyA9IEZwLmludihtdWx0aXBsaWVkQWNjKTtcbiAgICAvLyBXYWxrIGZyb20gbGFzdCB0byBmaXJzdCwgbXVsdGlwbHkgdGhlbSBieSBpbnZlcnRlZCBlYWNoIG90aGVyIE1PRCBwXG4gICAgbnVtcy5yZWR1Y2VSaWdodCgoYWNjLCBudW0sIGkpID0+IHtcbiAgICAgICAgaWYgKEZwLmlzMChudW0pKVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgaW52ZXJ0ZWRbaV0gPSBGcC5tdWwoYWNjLCBpbnZlcnRlZFtpXSk7XG4gICAgICAgIHJldHVybiBGcC5tdWwoYWNjLCBudW0pO1xuICAgIH0sIGludmVydGVkQWNjKTtcbiAgICByZXR1cm4gaW52ZXJ0ZWQ7XG59XG4vLyBUT0RPOiByZW1vdmVcbmV4cG9ydCBmdW5jdGlvbiBGcERpdihGcCwgbGhzLCByaHMpIHtcbiAgICByZXR1cm4gRnAubXVsKGxocywgdHlwZW9mIHJocyA9PT0gJ2JpZ2ludCcgPyBpbnZlcnQocmhzLCBGcC5PUkRFUikgOiBGcC5pbnYocmhzKSk7XG59XG4vKipcbiAqIExlZ2VuZHJlIHN5bWJvbC5cbiAqIExlZ2VuZHJlIGNvbnN0YW50IGlzIHVzZWQgdG8gY2FsY3VsYXRlIExlZ2VuZHJlIHN5bWJvbCAoYSB8IHApXG4gKiB3aGljaCBkZW5vdGVzIHRoZSB2YWx1ZSBvZiBhXigocC0xKS8yKSAobW9kIHApLlxuICpcbiAqICogKGEgfCBwKSDiiaEgMSAgICBpZiBhIGlzIGEgc3F1YXJlIChtb2QgcCksIHF1YWRyYXRpYyByZXNpZHVlXG4gKiAqIChhIHwgcCkg4omhIC0xICAgaWYgYSBpcyBub3QgYSBzcXVhcmUgKG1vZCBwKSwgcXVhZHJhdGljIG5vbiByZXNpZHVlXG4gKiAqIChhIHwgcCkg4omhIDAgICAgaWYgYSDiiaEgMCAobW9kIHApXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGcExlZ2VuZHJlKEZwLCBuKSB7XG4gICAgLy8gV2UgY2FuIHVzZSAzcmQgYXJndW1lbnQgYXMgb3B0aW9uYWwgY2FjaGUgb2YgdGhpcyB2YWx1ZVxuICAgIC8vIGJ1dCBzZWVtcyB1bm5lZWRlZCBmb3Igbm93LiBUaGUgb3BlcmF0aW9uIGlzIHZlcnkgZmFzdC5cbiAgICBjb25zdCBwMW1vZDIgPSAoRnAuT1JERVIgLSBfMW4pIC8gXzJuO1xuICAgIGNvbnN0IHBvd2VyZWQgPSBGcC5wb3cobiwgcDFtb2QyKTtcbiAgICBjb25zdCB5ZXMgPSBGcC5lcWwocG93ZXJlZCwgRnAuT05FKTtcbiAgICBjb25zdCB6ZXJvID0gRnAuZXFsKHBvd2VyZWQsIEZwLlpFUk8pO1xuICAgIGNvbnN0IG5vID0gRnAuZXFsKHBvd2VyZWQsIEZwLm5lZyhGcC5PTkUpKTtcbiAgICBpZiAoIXllcyAmJiAhemVybyAmJiAhbm8pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBMZWdlbmRyZSBzeW1ib2wgcmVzdWx0Jyk7XG4gICAgcmV0dXJuIHllcyA/IDEgOiB6ZXJvID8gMCA6IC0xO1xufVxuLy8gVGhpcyBmdW5jdGlvbiByZXR1cm5zIFRydWUgd2hlbmV2ZXIgdGhlIHZhbHVlIHggaXMgYSBzcXVhcmUgaW4gdGhlIGZpZWxkIEYuXG5leHBvcnQgZnVuY3Rpb24gRnBJc1NxdWFyZShGcCwgbikge1xuICAgIGNvbnN0IGwgPSBGcExlZ2VuZHJlKEZwLCBuKTtcbiAgICByZXR1cm4gbCA9PT0gMTtcbn1cbi8vIENVUlZFLm4gbGVuZ3Roc1xuZXhwb3J0IGZ1bmN0aW9uIG5MZW5ndGgobiwgbkJpdExlbmd0aCkge1xuICAgIC8vIEJpdCBzaXplLCBieXRlIHNpemUgb2YgQ1VSVkUublxuICAgIGlmIChuQml0TGVuZ3RoICE9PSB1bmRlZmluZWQpXG4gICAgICAgIGFudW1iZXIobkJpdExlbmd0aCk7XG4gICAgY29uc3QgX25CaXRMZW5ndGggPSBuQml0TGVuZ3RoICE9PSB1bmRlZmluZWQgPyBuQml0TGVuZ3RoIDogbi50b1N0cmluZygyKS5sZW5ndGg7XG4gICAgY29uc3QgbkJ5dGVMZW5ndGggPSBNYXRoLmNlaWwoX25CaXRMZW5ndGggLyA4KTtcbiAgICByZXR1cm4geyBuQml0TGVuZ3RoOiBfbkJpdExlbmd0aCwgbkJ5dGVMZW5ndGggfTtcbn1cbi8qKlxuICogSW5pdGlhbGl6ZXMgYSBmaW5pdGUgZmllbGQgb3ZlciBwcmltZS5cbiAqIE1ham9yIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbnM6XG4gKiAqIGEpIGRlbm9ybWFsaXplZCBvcGVyYXRpb25zIGxpa2UgbXVsTiBpbnN0ZWFkIG9mIG11bFxuICogKiBiKSBzYW1lIG9iamVjdCBzaGFwZTogbmV2ZXIgYWRkIG9yIHJlbW92ZSBrZXlzXG4gKiAqIGMpIE9iamVjdC5mcmVlemVcbiAqIEZyYWdpbGU6IGFsd2F5cyBydW4gYSBiZW5jaG1hcmsgb24gYSBjaGFuZ2UuXG4gKiBTZWN1cml0eSBub3RlOiBvcGVyYXRpb25zIGRvbid0IGNoZWNrICdpc1ZhbGlkJyBmb3IgYWxsIGVsZW1lbnRzIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLFxuICogaXQgaXMgY2FsbGVyIHJlc3BvbnNpYmlsaXR5IHRvIGNoZWNrIHRoaXMuXG4gKiBUaGlzIGlzIGxvdy1sZXZlbCBjb2RlLCBwbGVhc2UgbWFrZSBzdXJlIHlvdSBrbm93IHdoYXQgeW91J3JlIGRvaW5nLlxuICogQHBhcmFtIE9SREVSIHByaW1lIHBvc2l0aXZlIGJpZ2ludFxuICogQHBhcmFtIGJpdExlbiBob3cgbWFueSBiaXRzIHRoZSBmaWVsZCBjb25zdW1lc1xuICogQHBhcmFtIGlzTEUgKGRlZjogZmFsc2UpIGlmIGVuY29kaW5nIC8gZGVjb2Rpbmcgc2hvdWxkIGJlIGluIGxpdHRsZS1lbmRpYW5cbiAqIEBwYXJhbSByZWRlZiBvcHRpb25hbCBmYXN0ZXIgcmVkZWZpbml0aW9ucyBvZiBzcXJ0IGFuZCBvdGhlciBtZXRob2RzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGaWVsZChPUkRFUiwgYml0TGVuLCBpc0xFID0gZmFsc2UsIHJlZGVmID0ge30pIHtcbiAgICBpZiAoT1JERVIgPD0gXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZmllbGQ6IGV4cGVjdGVkIE9SREVSID4gMCwgZ290ICcgKyBPUkRFUik7XG4gICAgY29uc3QgeyBuQml0TGVuZ3RoOiBCSVRTLCBuQnl0ZUxlbmd0aDogQllURVMgfSA9IG5MZW5ndGgoT1JERVIsIGJpdExlbik7XG4gICAgaWYgKEJZVEVTID4gMjA0OClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGZpZWxkOiBleHBlY3RlZCBPUkRFUiBvZiA8PSAyMDQ4IGJ5dGVzJyk7XG4gICAgbGV0IHNxcnRQOyAvLyBjYWNoZWQgc3FydFBcbiAgICBjb25zdCBmID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIE9SREVSLFxuICAgICAgICBpc0xFLFxuICAgICAgICBCSVRTLFxuICAgICAgICBCWVRFUyxcbiAgICAgICAgTUFTSzogYml0TWFzayhCSVRTKSxcbiAgICAgICAgWkVSTzogXzBuLFxuICAgICAgICBPTkU6IF8xbixcbiAgICAgICAgY3JlYXRlOiAobnVtKSA9PiBtb2QobnVtLCBPUkRFUiksXG4gICAgICAgIGlzVmFsaWQ6IChudW0pID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbnVtICE9PSAnYmlnaW50JylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZmllbGQgZWxlbWVudDogZXhwZWN0ZWQgYmlnaW50LCBnb3QgJyArIHR5cGVvZiBudW0pO1xuICAgICAgICAgICAgcmV0dXJuIF8wbiA8PSBudW0gJiYgbnVtIDwgT1JERVI7IC8vIDAgaXMgdmFsaWQgZWxlbWVudCwgYnV0IGl0J3Mgbm90IGludmVydGlibGVcbiAgICAgICAgfSxcbiAgICAgICAgaXMwOiAobnVtKSA9PiBudW0gPT09IF8wbixcbiAgICAgICAgaXNPZGQ6IChudW0pID0+IChudW0gJiBfMW4pID09PSBfMW4sXG4gICAgICAgIG5lZzogKG51bSkgPT4gbW9kKC1udW0sIE9SREVSKSxcbiAgICAgICAgZXFsOiAobGhzLCByaHMpID0+IGxocyA9PT0gcmhzLFxuICAgICAgICBzcXI6IChudW0pID0+IG1vZChudW0gKiBudW0sIE9SREVSKSxcbiAgICAgICAgYWRkOiAobGhzLCByaHMpID0+IG1vZChsaHMgKyByaHMsIE9SREVSKSxcbiAgICAgICAgc3ViOiAobGhzLCByaHMpID0+IG1vZChsaHMgLSByaHMsIE9SREVSKSxcbiAgICAgICAgbXVsOiAobGhzLCByaHMpID0+IG1vZChsaHMgKiByaHMsIE9SREVSKSxcbiAgICAgICAgcG93OiAobnVtLCBwb3dlcikgPT4gRnBQb3coZiwgbnVtLCBwb3dlciksXG4gICAgICAgIGRpdjogKGxocywgcmhzKSA9PiBtb2QobGhzICogaW52ZXJ0KHJocywgT1JERVIpLCBPUkRFUiksXG4gICAgICAgIC8vIFNhbWUgYXMgYWJvdmUsIGJ1dCBkb2Vzbid0IG5vcm1hbGl6ZVxuICAgICAgICBzcXJOOiAobnVtKSA9PiBudW0gKiBudW0sXG4gICAgICAgIGFkZE46IChsaHMsIHJocykgPT4gbGhzICsgcmhzLFxuICAgICAgICBzdWJOOiAobGhzLCByaHMpID0+IGxocyAtIHJocyxcbiAgICAgICAgbXVsTjogKGxocywgcmhzKSA9PiBsaHMgKiByaHMsXG4gICAgICAgIGludjogKG51bSkgPT4gaW52ZXJ0KG51bSwgT1JERVIpLFxuICAgICAgICBzcXJ0OiByZWRlZi5zcXJ0IHx8XG4gICAgICAgICAgICAoKG4pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXNxcnRQKVxuICAgICAgICAgICAgICAgICAgICBzcXJ0UCA9IEZwU3FydChPUkRFUik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNxcnRQKGYsIG4pO1xuICAgICAgICAgICAgfSksXG4gICAgICAgIHRvQnl0ZXM6IChudW0pID0+IChpc0xFID8gbnVtYmVyVG9CeXRlc0xFKG51bSwgQllURVMpIDogbnVtYmVyVG9CeXRlc0JFKG51bSwgQllURVMpKSxcbiAgICAgICAgZnJvbUJ5dGVzOiAoYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggIT09IEJZVEVTKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmllbGQuZnJvbUJ5dGVzOiBleHBlY3RlZCAnICsgQllURVMgKyAnIGJ5dGVzLCBnb3QgJyArIGJ5dGVzLmxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gaXNMRSA/IGJ5dGVzVG9OdW1iZXJMRShieXRlcykgOiBieXRlc1RvTnVtYmVyQkUoYnl0ZXMpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBUT0RPOiB3ZSBkb24ndCBuZWVkIGl0IGhlcmUsIG1vdmUgb3V0IHRvIHNlcGFyYXRlIGZuXG4gICAgICAgIGludmVydEJhdGNoOiAobHN0KSA9PiBGcEludmVydEJhdGNoKGYsIGxzdCksXG4gICAgICAgIC8vIFdlIGNhbid0IG1vdmUgdGhpcyBvdXQgYmVjYXVzZSBGcDYsIEZwMTIgaW1wbGVtZW50IGl0XG4gICAgICAgIC8vIGFuZCBpdCdzIHVuY2xlYXIgd2hhdCB0byByZXR1cm4gaW4gdGhlcmUuXG4gICAgICAgIGNtb3Y6IChhLCBiLCBjKSA9PiAoYyA/IGIgOiBhKSxcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShmKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBGcFNxcnRPZGQoRnAsIGVsbSkge1xuICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZpZWxkIGRvZXNuJ3QgaGF2ZSBpc09kZFwiKTtcbiAgICBjb25zdCByb290ID0gRnAuc3FydChlbG0pO1xuICAgIHJldHVybiBGcC5pc09kZChyb290KSA/IHJvb3QgOiBGcC5uZWcocm9vdCk7XG59XG5leHBvcnQgZnVuY3Rpb24gRnBTcXJ0RXZlbihGcCwgZWxtKSB7XG4gICAgaWYgKCFGcC5pc09kZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmllbGQgZG9lc24ndCBoYXZlIGlzT2RkXCIpO1xuICAgIGNvbnN0IHJvb3QgPSBGcC5zcXJ0KGVsbSk7XG4gICAgcmV0dXJuIEZwLmlzT2RkKHJvb3QpID8gRnAubmVnKHJvb3QpIDogcm9vdDtcbn1cbi8qKlxuICogXCJDb25zdGFudC10aW1lXCIgcHJpdmF0ZSBrZXkgZ2VuZXJhdGlvbiB1dGlsaXR5LlxuICogU2FtZSBhcyBtYXBLZXlUb0ZpZWxkLCBidXQgYWNjZXB0cyBsZXNzIGJ5dGVzICg0MCBpbnN0ZWFkIG9mIDQ4IGZvciAzMi1ieXRlIGZpZWxkKS5cbiAqIFdoaWNoIG1ha2VzIGl0IHNsaWdodGx5IG1vcmUgYmlhc2VkLCBsZXNzIHNlY3VyZS5cbiAqIEBkZXByZWNhdGVkIHVzZSBgbWFwS2V5VG9GaWVsZGAgaW5zdGVhZFxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzaFRvUHJpdmF0ZVNjYWxhcihoYXNoLCBncm91cE9yZGVyLCBpc0xFID0gZmFsc2UpIHtcbiAgICBoYXNoID0gZW5zdXJlQnl0ZXMoJ3ByaXZhdGVIYXNoJywgaGFzaCk7XG4gICAgY29uc3QgaGFzaExlbiA9IGhhc2gubGVuZ3RoO1xuICAgIGNvbnN0IG1pbkxlbiA9IG5MZW5ndGgoZ3JvdXBPcmRlcikubkJ5dGVMZW5ndGggKyA4O1xuICAgIGlmIChtaW5MZW4gPCAyNCB8fCBoYXNoTGVuIDwgbWluTGVuIHx8IGhhc2hMZW4gPiAxMDI0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hhc2hUb1ByaXZhdGVTY2FsYXI6IGV4cGVjdGVkICcgKyBtaW5MZW4gKyAnLTEwMjQgYnl0ZXMgb2YgaW5wdXQsIGdvdCAnICsgaGFzaExlbik7XG4gICAgY29uc3QgbnVtID0gaXNMRSA/IGJ5dGVzVG9OdW1iZXJMRShoYXNoKSA6IGJ5dGVzVG9OdW1iZXJCRShoYXNoKTtcbiAgICByZXR1cm4gbW9kKG51bSwgZ3JvdXBPcmRlciAtIF8xbikgKyBfMW47XG59XG4vKipcbiAqIFJldHVybnMgdG90YWwgbnVtYmVyIG9mIGJ5dGVzIGNvbnN1bWVkIGJ5IHRoZSBmaWVsZCBlbGVtZW50LlxuICogRm9yIGV4YW1wbGUsIDMyIGJ5dGVzIGZvciB1c3VhbCAyNTYtYml0IHdlaWVyc3RyYXNzIGN1cnZlLlxuICogQHBhcmFtIGZpZWxkT3JkZXIgbnVtYmVyIG9mIGZpZWxkIGVsZW1lbnRzLCB1c3VhbGx5IENVUlZFLm5cbiAqIEByZXR1cm5zIGJ5dGUgbGVuZ3RoIG9mIGZpZWxkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRGaWVsZEJ5dGVzTGVuZ3RoKGZpZWxkT3JkZXIpIHtcbiAgICBpZiAodHlwZW9mIGZpZWxkT3JkZXIgIT09ICdiaWdpbnQnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpZWxkIG9yZGVyIG11c3QgYmUgYmlnaW50Jyk7XG4gICAgY29uc3QgYml0TGVuZ3RoID0gZmllbGRPcmRlci50b1N0cmluZygyKS5sZW5ndGg7XG4gICAgcmV0dXJuIE1hdGguY2VpbChiaXRMZW5ndGggLyA4KTtcbn1cbi8qKlxuICogUmV0dXJucyBtaW5pbWFsIGFtb3VudCBvZiBieXRlcyB0aGF0IGNhbiBiZSBzYWZlbHkgcmVkdWNlZFxuICogYnkgZmllbGQgb3JkZXIuXG4gKiBTaG91bGQgYmUgMl4tMTI4IGZvciAxMjgtYml0IGN1cnZlIHN1Y2ggYXMgUDI1Ni5cbiAqIEBwYXJhbSBmaWVsZE9yZGVyIG51bWJlciBvZiBmaWVsZCBlbGVtZW50cywgdXN1YWxseSBDVVJWRS5uXG4gKiBAcmV0dXJucyBieXRlIGxlbmd0aCBvZiB0YXJnZXQgaGFzaFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWluSGFzaExlbmd0aChmaWVsZE9yZGVyKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gZ2V0RmllbGRCeXRlc0xlbmd0aChmaWVsZE9yZGVyKTtcbiAgICByZXR1cm4gbGVuZ3RoICsgTWF0aC5jZWlsKGxlbmd0aCAvIDIpO1xufVxuLyoqXG4gKiBcIkNvbnN0YW50LXRpbWVcIiBwcml2YXRlIGtleSBnZW5lcmF0aW9uIHV0aWxpdHkuXG4gKiBDYW4gdGFrZSAobiArIG4vMikgb3IgbW9yZSBieXRlcyBvZiB1bmlmb3JtIGlucHV0IGUuZy4gZnJvbSBDU1BSTkcgb3IgS0RGXG4gKiBhbmQgY29udmVydCB0aGVtIGludG8gcHJpdmF0ZSBzY2FsYXIsIHdpdGggdGhlIG1vZHVsbyBiaWFzIGJlaW5nIG5lZ2xpZ2libGUuXG4gKiBOZWVkcyBhdCBsZWFzdCA0OCBieXRlcyBvZiBpbnB1dCBmb3IgMzItYnl0ZSBwcml2YXRlIGtleS5cbiAqIGh0dHBzOi8vcmVzZWFyY2gua3VkZWxza2lzZWN1cml0eS5jb20vMjAyMC8wNy8yOC90aGUtZGVmaW5pdGl2ZS1ndWlkZS10by1tb2R1bG8tYmlhcy1hbmQtaG93LXRvLWF2b2lkLWl0L1xuICogRklQUyAxODYtNSwgQS4yIGh0dHBzOi8vY3NyYy5uaXN0Lmdvdi9wdWJsaWNhdGlvbnMvZGV0YWlsL2ZpcHMvMTg2LzUvZmluYWxcbiAqIFJGQyA5MzgwLCBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTVcbiAqIEBwYXJhbSBoYXNoIGhhc2ggb3V0cHV0IGZyb20gU0hBMyBvciBhIHNpbWlsYXIgZnVuY3Rpb25cbiAqIEBwYXJhbSBncm91cE9yZGVyIHNpemUgb2Ygc3ViZ3JvdXAgLSAoZS5nLiBzZWNwMjU2azEuQ1VSVkUubilcbiAqIEBwYXJhbSBpc0xFIGludGVycHJldCBoYXNoIGJ5dGVzIGFzIExFIG51bVxuICogQHJldHVybnMgdmFsaWQgcHJpdmF0ZSBzY2FsYXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcEhhc2hUb0ZpZWxkKGtleSwgZmllbGRPcmRlciwgaXNMRSA9IGZhbHNlKSB7XG4gICAgY29uc3QgbGVuID0ga2V5Lmxlbmd0aDtcbiAgICBjb25zdCBmaWVsZExlbiA9IGdldEZpZWxkQnl0ZXNMZW5ndGgoZmllbGRPcmRlcik7XG4gICAgY29uc3QgbWluTGVuID0gZ2V0TWluSGFzaExlbmd0aChmaWVsZE9yZGVyKTtcbiAgICAvLyBObyBzbWFsbCBudW1iZXJzOiBuZWVkIHRvIHVuZGVyc3RhbmQgYmlhcyBzdG9yeS4gTm8gaHVnZSBudW1iZXJzOiBlYXNpZXIgdG8gZGV0ZWN0IEpTIHRpbWluZ3MuXG4gICAgaWYgKGxlbiA8IDE2IHx8IGxlbiA8IG1pbkxlbiB8fCBsZW4gPiAxMDI0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkICcgKyBtaW5MZW4gKyAnLTEwMjQgYnl0ZXMgb2YgaW5wdXQsIGdvdCAnICsgbGVuKTtcbiAgICBjb25zdCBudW0gPSBpc0xFID8gYnl0ZXNUb051bWJlckxFKGtleSkgOiBieXRlc1RvTnVtYmVyQkUoa2V5KTtcbiAgICAvLyBgbW9kKHgsIDExKWAgY2FuIHNvbWV0aW1lcyBwcm9kdWNlIDAuIGBtb2QoeCwgMTApICsgMWAgaXMgdGhlIHNhbWUsIGJ1dCBubyAwXG4gICAgY29uc3QgcmVkdWNlZCA9IG1vZChudW0sIGZpZWxkT3JkZXIgLSBfMW4pICsgXzFuO1xuICAgIHJldHVybiBpc0xFID8gbnVtYmVyVG9CeXRlc0xFKHJlZHVjZWQsIGZpZWxkTGVuKSA6IG51bWJlclRvQnl0ZXNCRShyZWR1Y2VkLCBmaWVsZExlbik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGFyLmpzLm1hcCJdLCJuYW1lcyI6WyJhbnVtYmVyIiwiYml0TWFzayIsImJ5dGVzVG9OdW1iZXJCRSIsImJ5dGVzVG9OdW1iZXJMRSIsImVuc3VyZUJ5dGVzIiwibnVtYmVyVG9CeXRlc0JFIiwibnVtYmVyVG9CeXRlc0xFIiwidmFsaWRhdGVPYmplY3QiLCJfMG4iLCJCaWdJbnQiLCJfMW4iLCJfMm4iLCJfM24iLCJfNG4iLCJfNW4iLCJfOG4iLCJtb2QiLCJhIiwiYiIsInJlc3VsdCIsInBvdyIsIm51bSIsInBvd2VyIiwibW9kdWxvIiwiRnBQb3ciLCJGaWVsZCIsInBvdzIiLCJ4IiwicmVzIiwiaW52ZXJ0IiwibnVtYmVyIiwiRXJyb3IiLCJ5IiwidSIsInYiLCJxIiwiciIsIm0iLCJuIiwiZ2NkIiwic3FydDNtb2Q0IiwiRnAiLCJwMWRpdjQiLCJPUkRFUiIsInJvb3QiLCJlcWwiLCJzcXIiLCJzcXJ0NW1vZDgiLCJwNWRpdjgiLCJuMiIsIm11bCIsIm52IiwiaSIsInN1YiIsIk9ORSIsInRvbmVsbGlTaGFua3MiLCJQIiwiUSIsIlMiLCJaIiwiX0ZwIiwiRnBMZWdlbmRyZSIsImNjIiwiUTFkaXYyIiwidG9uZWxsaVNsb3ciLCJpczAiLCJNIiwiYyIsInQiLCJSIiwiWkVSTyIsInRfdG1wIiwiZXhwb25lbnQiLCJGcFNxcnQiLCJpc05lZ2F0aXZlTEUiLCJGSUVMRF9GSUVMRFMiLCJ2YWxpZGF0ZUZpZWxkIiwiZmllbGQiLCJpbml0aWFsIiwiTUFTSyIsIkJZVEVTIiwiQklUUyIsIm9wdHMiLCJyZWR1Y2UiLCJtYXAiLCJ2YWwiLCJwIiwiZCIsIkZwSW52ZXJ0QmF0Y2giLCJudW1zIiwicGFzc1plcm8iLCJpbnZlcnRlZCIsIkFycmF5IiwibGVuZ3RoIiwiZmlsbCIsInVuZGVmaW5lZCIsIm11bHRpcGxpZWRBY2MiLCJhY2MiLCJpbnZlcnRlZEFjYyIsImludiIsInJlZHVjZVJpZ2h0IiwiRnBEaXYiLCJsaHMiLCJyaHMiLCJwMW1vZDIiLCJwb3dlcmVkIiwieWVzIiwiemVybyIsIm5vIiwibmVnIiwiRnBJc1NxdWFyZSIsImwiLCJuTGVuZ3RoIiwibkJpdExlbmd0aCIsIl9uQml0TGVuZ3RoIiwidG9TdHJpbmciLCJuQnl0ZUxlbmd0aCIsIk1hdGgiLCJjZWlsIiwiYml0TGVuIiwiaXNMRSIsInJlZGVmIiwic3FydFAiLCJmIiwiT2JqZWN0IiwiZnJlZXplIiwiY3JlYXRlIiwiaXNWYWxpZCIsImlzT2RkIiwiYWRkIiwiZGl2Iiwic3FyTiIsImFkZE4iLCJzdWJOIiwibXVsTiIsInNxcnQiLCJ0b0J5dGVzIiwiZnJvbUJ5dGVzIiwiYnl0ZXMiLCJpbnZlcnRCYXRjaCIsImxzdCIsImNtb3YiLCJGcFNxcnRPZGQiLCJlbG0iLCJGcFNxcnRFdmVuIiwiaGFzaFRvUHJpdmF0ZVNjYWxhciIsImhhc2giLCJncm91cE9yZGVyIiwiaGFzaExlbiIsIm1pbkxlbiIsImdldEZpZWxkQnl0ZXNMZW5ndGgiLCJmaWVsZE9yZGVyIiwiYml0TGVuZ3RoIiwiZ2V0TWluSGFzaExlbmd0aCIsIm1hcEhhc2hUb0ZpZWxkIiwia2V5IiwibGVuIiwiZmllbGRMZW4iLCJyZWR1Y2VkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/abstract/modular.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/abstract/utils.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ox/node_modules/@noble/curves/esm/abstract/utils.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   aInRange: () => (/* binding */ aInRange),\n/* harmony export */   abool: () => (/* binding */ abool),\n/* harmony export */   abytes: () => (/* binding */ abytes),\n/* harmony export */   bitGet: () => (/* binding */ bitGet),\n/* harmony export */   bitLen: () => (/* binding */ bitLen),\n/* harmony export */   bitMask: () => (/* binding */ bitMask),\n/* harmony export */   bitSet: () => (/* binding */ bitSet),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   bytesToNumberBE: () => (/* binding */ bytesToNumberBE),\n/* harmony export */   bytesToNumberLE: () => (/* binding */ bytesToNumberLE),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createHmacDrbg: () => (/* binding */ createHmacDrbg),\n/* harmony export */   ensureBytes: () => (/* binding */ ensureBytes),\n/* harmony export */   equalBytes: () => (/* binding */ equalBytes),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   hexToNumber: () => (/* binding */ hexToNumber),\n/* harmony export */   inRange: () => (/* binding */ inRange),\n/* harmony export */   isBytes: () => (/* binding */ isBytes),\n/* harmony export */   memoized: () => (/* binding */ memoized),\n/* harmony export */   notImplemented: () => (/* binding */ notImplemented),\n/* harmony export */   numberToBytesBE: () => (/* binding */ numberToBytesBE),\n/* harmony export */   numberToBytesLE: () => (/* binding */ numberToBytesLE),\n/* harmony export */   numberToHexUnpadded: () => (/* binding */ numberToHexUnpadded),\n/* harmony export */   numberToVarBytesBE: () => (/* binding */ numberToVarBytesBE),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   validateObject: () => (/* binding */ validateObject)\n/* harmony export */ });\n/**\n * Hex, bytes and number utilities.\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nfunction isBytes(a) {\n    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === \"Uint8Array\";\n}\nfunction abytes(item) {\n    if (!isBytes(item)) throw new Error(\"Uint8Array expected\");\n}\nfunction abool(title, value) {\n    if (typeof value !== \"boolean\") throw new Error(title + \" boolean expected, got \" + value);\n}\n// Used in weierstrass, der\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? \"0\" + hex : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    return hex === \"\" ? _0n : BigInt(\"0x\" + hex); // Big Endian\n}\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin = // @ts-ignore\ntypeof Uint8Array.from([]).toHex === \"function\" && typeof Uint8Array.fromHex === \"function\";\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({\n    length: 256\n}, (_, i)=>i.toString(16).padStart(2, \"0\"));\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */ function bytesToHex(bytes) {\n    abytes(bytes);\n    // @ts-ignore\n    if (hasHexBuiltin) return bytes.toHex();\n    // pre-caching improves the speed 6x\n    let hex = \"\";\n    for(let i = 0; i < bytes.length; i++){\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = {\n    _0: 48,\n    _9: 57,\n    A: 65,\n    F: 70,\n    a: 97,\n    f: 102\n};\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */ function hexToBytes(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    // @ts-ignore\n    if (hasHexBuiltin) return Uint8Array.fromHex(hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2) throw new Error(\"hex string expected, got unpadded hex of length \" + hl);\n    const array = new Uint8Array(al);\n    for(let ai = 0, hi = 0; ai < al; ai++, hi += 2){\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction bytesToNumberLE(bytes) {\n    abytes(bytes);\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nfunction numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, \"0\"));\n}\nfunction numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */ function ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === \"string\") {\n        try {\n            res = hexToBytes(hex);\n        } catch (e) {\n            throw new Error(title + \" must be hex string or Uint8Array, cause: \" + e);\n        }\n    } else if (isBytes(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    } else {\n        throw new Error(title + \" must be hex string or Uint8Array\");\n    }\n    const len = res.length;\n    if (typeof expectedLength === \"number\" && len !== expectedLength) throw new Error(title + \" of length \" + expectedLength + \" expected, got \" + len);\n    return res;\n}\n/**\n * Copies several Uint8Arrays into one.\n */ function concatBytes(...arrays) {\n    let sum = 0;\n    for(let i = 0; i < arrays.length; i++){\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for(let i = 0, pad = 0; i < arrays.length; i++){\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// Compares 2 u8a-s in kinda constant time\nfunction equalBytes(a, b) {\n    if (a.length !== b.length) return false;\n    let diff = 0;\n    for(let i = 0; i < a.length; i++)diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */ function utf8ToBytes(str) {\n    if (typeof str !== \"string\") throw new Error(\"string expected\");\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n// Is positive bigint\nconst isPosBig = (n)=>typeof n === \"bigint\" && _0n <= n;\nfunction inRange(n, min, max) {\n    return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n}\n/**\n * Asserts min <= n < max. NOTE: It's < max and not <= max.\n * @example\n * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\n */ function aInRange(title, n, min, max) {\n    // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\n    // consider P=256n, min=0n, max=P\n    // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\n    // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\n    // - our way is the cleanest:               `inRange('x', x, 0n, P)\n    if (!inRange(n, min, max)) throw new Error(\"expected valid \" + title + \": \" + min + \" <= n < \" + max + \", got \" + n);\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n * TODO: merge with nLength in modular\n */ function bitLen(n) {\n    let len;\n    for(len = 0; n > _0n; n >>= _1n, len += 1);\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */ function bitGet(n, pos) {\n    return n >> BigInt(pos) & _1n;\n}\n/**\n * Sets single bit at position.\n */ function bitSet(n, pos, value) {\n    return n | (value ? _1n : _0n) << BigInt(pos);\n}\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */ const bitMask = (n)=>(_1n << BigInt(n)) - _1n;\n// DRBG\nconst u8n = (len)=>new Uint8Array(len); // creates Uint8Array\nconst u8fr = (arr)=>Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */ function createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== \"number\" || hashLen < 2) throw new Error(\"hashLen must be a number\");\n    if (typeof qByteLen !== \"number\" || qByteLen < 2) throw new Error(\"qByteLen must be a number\");\n    if (typeof hmacFn !== \"function\") throw new Error(\"hmacFn must be a function\");\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = ()=>{\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b)=>hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n(0))=>{\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([\n            0x00\n        ]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0) return;\n        k = h(u8fr([\n            0x01\n        ]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = ()=>{\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000) throw new Error(\"drbg: tried 1000 values\");\n        let len = 0;\n        const out = [];\n        while(len < qByteLen){\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred)=>{\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while(!(res = pred(gen())))reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val)=>typeof val === \"bigint\",\n    function: (val)=>typeof val === \"function\",\n    boolean: (val)=>typeof val === \"boolean\",\n    string: (val)=>typeof val === \"string\",\n    stringOrUint8Array: (val)=>typeof val === \"string\" || isBytes(val),\n    isSafeInteger: (val)=>Number.isSafeInteger(val),\n    array: (val)=>Array.isArray(val),\n    field: (val, object)=>object.Fp.isValid(val),\n    hash: (val)=>typeof val === \"function\" && Number.isSafeInteger(val.outputLen)\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional)=>{\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== \"function\") throw new Error(\"invalid validator function\");\n        const val = object[fieldName];\n        if (isOptional && val === undefined) return;\n        if (!checkVal(val, object)) {\n            throw new Error(\"param \" + String(fieldName) + \" is invalid. Expected \" + type + \", got \" + val);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))checkField(fieldName, type, true);\n    return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n/**\n * throws not implemented error\n */ const notImplemented = ()=>{\n    throw new Error(\"not implemented\");\n};\n/**\n * Memoizes (caches) computation result.\n * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\n */ function memoized(fn) {\n    const map = new WeakMap();\n    return (arg, ...args)=>{\n        const val = map.get(arg);\n        if (val !== undefined) return val;\n        const computed = fn(arg, ...args);\n        map.set(arg, computed);\n        return computed;\n    };\n} //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7OztDQUdDLEdBQ0Qsb0VBQW9FLEdBQ3BFLDBFQUEwRTtBQUMxRSw4REFBOEQ7QUFDOUQsK0VBQStFO0FBQy9FLHVDQUF1QztBQUN2QyxNQUFNQSxNQUFNLGFBQWEsR0FBR0MsT0FBTztBQUNuQyxNQUFNQyxNQUFNLGFBQWEsR0FBR0QsT0FBTztBQUM1QixTQUFTRSxRQUFRQyxDQUFDO0lBQ3JCLE9BQU9BLGFBQWFDLGNBQWVDLFlBQVlDLE1BQU0sQ0FBQ0gsTUFBTUEsRUFBRUksV0FBVyxDQUFDQyxJQUFJLEtBQUs7QUFDdkY7QUFDTyxTQUFTQyxPQUFPQyxJQUFJO0lBQ3ZCLElBQUksQ0FBQ1IsUUFBUVEsT0FDVCxNQUFNLElBQUlDLE1BQU07QUFDeEI7QUFDTyxTQUFTQyxNQUFNQyxLQUFLLEVBQUVDLEtBQUs7SUFDOUIsSUFBSSxPQUFPQSxVQUFVLFdBQ2pCLE1BQU0sSUFBSUgsTUFBTUUsUUFBUSw0QkFBNEJDO0FBQzVEO0FBQ0EsMkJBQTJCO0FBQ3BCLFNBQVNDLG9CQUFvQkMsR0FBRztJQUNuQyxNQUFNQyxNQUFNRCxJQUFJRSxRQUFRLENBQUM7SUFDekIsT0FBT0QsSUFBSUUsTUFBTSxHQUFHLElBQUksTUFBTUYsTUFBTUE7QUFDeEM7QUFDTyxTQUFTRyxZQUFZSCxHQUFHO0lBQzNCLElBQUksT0FBT0EsUUFBUSxVQUNmLE1BQU0sSUFBSU4sTUFBTSw4QkFBOEIsT0FBT007SUFDekQsT0FBT0EsUUFBUSxLQUFLbEIsTUFBTUMsT0FBTyxPQUFPaUIsTUFBTSxhQUFhO0FBQy9EO0FBQ0EseUZBQXlGO0FBQ3pGLE1BQU1JLGdCQUNOLGFBQWE7QUFDYixPQUFPakIsV0FBV2tCLElBQUksQ0FBQyxFQUFFLEVBQUVDLEtBQUssS0FBSyxjQUFjLE9B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QU07SUFDaEMsT0FBT1Y7QUFDWDtBQUNBLHNCQUFzQjtBQUN0Qix1RUFBdUU7QUFDdkUsZ0ZBQWdGO0FBQ2hGLDRCQUE0QjtBQUM1QiwyREFBMkQ7QUFDM0QscUVBQXFFO0FBQ3JFLCtEQUErRDtBQUMvRCw0REFBNEQ7QUFDNUQ7O0NBRUMsR0FDTSxNQUFNZ0IsaUJBQWlCO0lBQzFCLE1BQU0sSUFBSTFILE1BQU07QUFDcEIsRUFBRTtBQUNGOzs7Q0FHQyxHQUNNLFNBQVMySCxTQUFTQyxFQUFFO0lBQ3ZCLE1BQU1DLE1BQU0sSUFBSUM7SUFDaEIsT0FBTyxDQUFDQyxLQUFLLEdBQUdDO1FBQ1osTUFBTS9CLE1BQU00QixJQUFJSSxHQUFHLENBQUNGO1FBQ3BCLElBQUk5QixRQUFRM0QsV0FDUixPQUFPMkQ7UUFDWCxNQUFNaUMsV0FBV04sR0FBR0csUUFBUUM7UUFDNUJILElBQUlyRSxHQUFHLENBQUN1RSxLQUFLRztRQUNiLE9BQU9BO0lBQ1g7QUFDSixFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsYXctd29ya3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L3V0aWxzLmpzPzJjYjEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBIZXgsIGJ5dGVzIGFuZCBudW1iZXIgdXRpbGl0aWVzLlxuICogQG1vZHVsZVxuICovXG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyAxMDAgbGluZXMgb2YgY29kZSBpbiB0aGUgZmlsZSBhcmUgZHVwbGljYXRlZCBmcm9tIG5vYmxlLWhhc2hlcyAodXRpbHMpLlxuLy8gVGhpcyBpcyBPSzogYGFic3RyYWN0YCBkaXJlY3RvcnkgZG9lcyBub3QgdXNlIG5vYmxlLWhhc2hlcy5cbi8vIFVzZXIgbWF5IG9wdC1pbiBpbnRvIHVzaW5nIGRpZmZlcmVudCBoYXNoaW5nIGxpYnJhcnkuIFRoaXMgd2F5LCBub2JsZS1oYXNoZXNcbi8vIHdvbid0IGJlIGluY2x1ZGVkIGludG8gdGhlaXIgYnVuZGxlLlxuY29uc3QgXzBuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMSk7XG5leHBvcnQgZnVuY3Rpb24gaXNCeXRlcyhhKSB7XG4gICAgcmV0dXJuIGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IChBcnJheUJ1ZmZlci5pc1ZpZXcoYSkgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFieXRlcyhpdGVtKSB7XG4gICAgaWYgKCFpc0J5dGVzKGl0ZW0pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhYm9vbCh0aXRsZSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnYm9vbGVhbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcih0aXRsZSArICcgYm9vbGVhbiBleHBlY3RlZCwgZ290ICcgKyB2YWx1ZSk7XG59XG4vLyBVc2VkIGluIHdlaWVyc3RyYXNzLCBkZXJcbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb0hleFVucGFkZGVkKG51bSkge1xuICAgIGNvbnN0IGhleCA9IG51bS50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIGhleC5sZW5ndGggJiAxID8gJzAnICsgaGV4IDogaGV4O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhleFRvTnVtYmVyKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIHJldHVybiBoZXggPT09ICcnID8gXzBuIDogQmlnSW50KCcweCcgKyBoZXgpOyAvLyBCaWcgRW5kaWFuXG59XG4vLyBCdWlsdC1pbiBoZXggY29udmVyc2lvbiBodHRwczovL2Nhbml1c2UuY29tL21kbi1qYXZhc2NyaXB0X2J1aWx0aW5zX3VpbnQ4YXJyYXlfZnJvbWhleFxuY29uc3QgaGFzSGV4QnVpbHRpbiA9IFxuLy8gQHRzLWlnbm9yZVxudHlwZW9mIFVpbnQ4QXJyYXkuZnJvbShbXSkudG9IZXggPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFVpbnQ4QXJyYXkuZnJvbUhleCA9PT0gJ2Z1bmN0aW9uJztcbi8vIEFycmF5IHdoZXJlIGluZGV4IDB4ZjAgKDI0MCkgaXMgbWFwcGVkIHRvIHN0cmluZyAnZjAnXG5jb25zdCBoZXhlcyA9IC8qIEBfX1BVUkVfXyAqLyBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyNTYgfSwgKF8sIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuLyoqXG4gKiBDb252ZXJ0IGJ5dGUgYXJyYXkgdG8gaGV4IHN0cmluZy4gVXNlcyBidWlsdC1pbiBmdW5jdGlvbiwgd2hlbiBhdmFpbGFibGUuXG4gKiBAZXhhbXBsZSBieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pKSAvLyAnY2FmZTAxMjMnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvSGV4KGJ5dGVzKSB7XG4gICAgYWJ5dGVzKGJ5dGVzKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKGhhc0hleEJ1aWx0aW4pXG4gICAgICAgIHJldHVybiBieXRlcy50b0hleCgpO1xuICAgIC8vIHByZS1jYWNoaW5nIGltcHJvdmVzIHRoZSBzcGVlZCA2eFxuICAgIGxldCBoZXggPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhleCArPSBoZXhlc1tieXRlc1tpXV07XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG4vLyBXZSB1c2Ugb3B0aW1pemVkIHRlY2huaXF1ZSB0byBjb252ZXJ0IGhleCBzdHJpbmcgdG8gYnl0ZSBhcnJheVxuY29uc3QgYXNjaWlzID0geyBfMDogNDgsIF85OiA1NywgQTogNjUsIEY6IDcwLCBhOiA5NywgZjogMTAyIH07XG5mdW5jdGlvbiBhc2NpaVRvQmFzZTE2KGNoKSB7XG4gICAgaWYgKGNoID49IGFzY2lpcy5fMCAmJiBjaCA8PSBhc2NpaXMuXzkpXG4gICAgICAgIHJldHVybiBjaCAtIGFzY2lpcy5fMDsgLy8gJzInID0+IDUwLTQ4XG4gICAgaWYgKGNoID49IGFzY2lpcy5BICYmIGNoIDw9IGFzY2lpcy5GKVxuICAgICAgICByZXR1cm4gY2ggLSAoYXNjaWlzLkEgLSAxMCk7IC8vICdCJyA9PiA2Ni0oNjUtMTApXG4gICAgaWYgKGNoID49IGFzY2lpcy5hICYmIGNoIDw9IGFzY2lpcy5mKVxuICAgICAgICByZXR1cm4gY2ggLSAoYXNjaWlzLmEgLSAxMCk7IC8vICdiJyA9PiA5OC0oOTctMTApXG4gICAgcmV0dXJuO1xufVxuLyoqXG4gKiBDb252ZXJ0IGhleCBzdHJpbmcgdG8gYnl0ZSBhcnJheS4gVXNlcyBidWlsdC1pbiBmdW5jdGlvbiwgd2hlbiBhdmFpbGFibGUuXG4gKiBAZXhhbXBsZSBoZXhUb0J5dGVzKCdjYWZlMDEyMycpIC8vIFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb0J5dGVzKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAoaGFzSGV4QnVpbHRpbilcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbUhleChoZXgpO1xuICAgIGNvbnN0IGhsID0gaGV4Lmxlbmd0aDtcbiAgICBjb25zdCBhbCA9IGhsIC8gMjtcbiAgICBpZiAoaGwgJSAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCB1bnBhZGRlZCBoZXggb2YgbGVuZ3RoICcgKyBobCk7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShhbCk7XG4gICAgZm9yIChsZXQgYWkgPSAwLCBoaSA9IDA7IGFpIDwgYWw7IGFpKyssIGhpICs9IDIpIHtcbiAgICAgICAgY29uc3QgbjEgPSBhc2NpaVRvQmFzZTE2KGhleC5jaGFyQ29kZUF0KGhpKSk7XG4gICAgICAgIGNvbnN0IG4yID0gYXNjaWlUb0Jhc2UxNihoZXguY2hhckNvZGVBdChoaSArIDEpKTtcbiAgICAgICAgaWYgKG4xID09PSB1bmRlZmluZWQgfHwgbjIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgY2hhciA9IGhleFtoaV0gKyBoZXhbaGkgKyAxXTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IG5vbi1oZXggY2hhcmFjdGVyIFwiJyArIGNoYXIgKyAnXCIgYXQgaW5kZXggJyArIGhpKTtcbiAgICAgICAgfVxuICAgICAgICBhcnJheVthaV0gPSBuMSAqIDE2ICsgbjI7IC8vIG11bHRpcGx5IGZpcnN0IG9jdGV0LCBlLmcuICdhMycgPT4gMTAqMTYrMyA9PiAxNjAgKyAzID0+IDE2M1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG4vLyBCRTogQmlnIEVuZGlhbiwgTEU6IExpdHRsZSBFbmRpYW5cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvTnVtYmVyQkUoYnl0ZXMpIHtcbiAgICByZXR1cm4gaGV4VG9OdW1iZXIoYnl0ZXNUb0hleChieXRlcykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXJMRShieXRlcykge1xuICAgIGFieXRlcyhieXRlcyk7XG4gICAgcmV0dXJuIGhleFRvTnVtYmVyKGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKGJ5dGVzKS5yZXZlcnNlKCkpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb0J5dGVzQkUobiwgbGVuKSB7XG4gICAgcmV0dXJuIGhleFRvQnl0ZXMobi50b1N0cmluZygxNikucGFkU3RhcnQobGVuICogMiwgJzAnKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9CeXRlc0xFKG4sIGxlbikge1xuICAgIHJldHVybiBudW1iZXJUb0J5dGVzQkUobiwgbGVuKS5yZXZlcnNlKCk7XG59XG4vLyBVbnBhZGRlZCwgcmFyZWx5IHVzZWRcbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb1ZhckJ5dGVzQkUobikge1xuICAgIHJldHVybiBoZXhUb0J5dGVzKG51bWJlclRvSGV4VW5wYWRkZWQobikpO1xufVxuLyoqXG4gKiBUYWtlcyBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXksIGNvbnZlcnRzIHRvIFVpbnQ4QXJyYXkuXG4gKiBWYWxpZGF0ZXMgb3V0cHV0IGxlbmd0aC5cbiAqIFdpbGwgdGhyb3cgZXJyb3IgZm9yIG90aGVyIHR5cGVzLlxuICogQHBhcmFtIHRpdGxlIGRlc2NyaXB0aXZlIHRpdGxlIGZvciBhbiBlcnJvciBlLmcuICdwcml2YXRlIGtleSdcbiAqIEBwYXJhbSBoZXggaGV4IHN0cmluZyBvciBVaW50OEFycmF5XG4gKiBAcGFyYW0gZXhwZWN0ZWRMZW5ndGggb3B0aW9uYWwsIHdpbGwgY29tcGFyZSB0byByZXN1bHQgYXJyYXkncyBsZW5ndGhcbiAqIEByZXR1cm5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVCeXRlcyh0aXRsZSwgaGV4LCBleHBlY3RlZExlbmd0aCkge1xuICAgIGxldCByZXM7XG4gICAgaWYgKHR5cGVvZiBoZXggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXMgPSBoZXhUb0J5dGVzKGhleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0aXRsZSArICcgbXVzdCBiZSBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXksIGNhdXNlOiAnICsgZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNCeXRlcyhoZXgpKSB7XG4gICAgICAgIC8vIFVpbnQ4QXJyYXkuZnJvbSgpIGluc3RlYWQgb2YgaGFzaC5zbGljZSgpIGJlY2F1c2Ugbm9kZS5qcyBCdWZmZXJcbiAgICAgICAgLy8gaXMgaW5zdGFuY2Ugb2YgVWludDhBcnJheSwgYW5kIGl0cyBzbGljZSgpIGNyZWF0ZXMgKiptdXRhYmxlKiogY29weVxuICAgICAgICByZXMgPSBVaW50OEFycmF5LmZyb20oaGV4KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih0aXRsZSArICcgbXVzdCBiZSBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXknKTtcbiAgICB9XG4gICAgY29uc3QgbGVuID0gcmVzLmxlbmd0aDtcbiAgICBpZiAodHlwZW9mIGV4cGVjdGVkTGVuZ3RoID09PSAnbnVtYmVyJyAmJiBsZW4gIT09IGV4cGVjdGVkTGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGl0bGUgKyAnIG9mIGxlbmd0aCAnICsgZXhwZWN0ZWRMZW5ndGggKyAnIGV4cGVjdGVkLCBnb3QgJyArIGxlbik7XG4gICAgcmV0dXJuIHJlcztcbn1cbi8qKlxuICogQ29waWVzIHNldmVyYWwgVWludDhBcnJheXMgaW50byBvbmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXRCeXRlcyguLi5hcnJheXMpIHtcbiAgICBsZXQgc3VtID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhID0gYXJyYXlzW2ldO1xuICAgICAgICBhYnl0ZXMoYSk7XG4gICAgICAgIHN1bSArPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoc3VtKTtcbiAgICBmb3IgKGxldCBpID0gMCwgcGFkID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhID0gYXJyYXlzW2ldO1xuICAgICAgICByZXMuc2V0KGEsIHBhZCk7XG4gICAgICAgIHBhZCArPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8vIENvbXBhcmVzIDIgdThhLXMgaW4ga2luZGEgY29uc3RhbnQgdGltZVxuZXhwb3J0IGZ1bmN0aW9uIGVxdWFsQnl0ZXMoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgZGlmZiA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKVxuICAgICAgICBkaWZmIHw9IGFbaV0gXiBiW2ldO1xuICAgIHJldHVybiBkaWZmID09PSAwO1xufVxuLyoqXG4gKiBAZXhhbXBsZSB1dGY4VG9CeXRlcygnYWJjJykgLy8gbmV3IFVpbnQ4QXJyYXkoWzk3LCA5OCwgOTldKVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0cmluZyBleHBlY3RlZCcpO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSk7IC8vIGh0dHBzOi8vYnVnemlsLmxhLzE2ODE4MDlcbn1cbi8vIElzIHBvc2l0aXZlIGJpZ2ludFxuY29uc3QgaXNQb3NCaWcgPSAobikgPT4gdHlwZW9mIG4gPT09ICdiaWdpbnQnICYmIF8wbiA8PSBuO1xuZXhwb3J0IGZ1bmN0aW9uIGluUmFuZ2UobiwgbWluLCBtYXgpIHtcbiAgICByZXR1cm4gaXNQb3NCaWcobikgJiYgaXNQb3NCaWcobWluKSAmJiBpc1Bvc0JpZyhtYXgpICYmIG1pbiA8PSBuICYmIG4gPCBtYXg7XG59XG4vKipcbiAqIEFzc2VydHMgbWluIDw9IG4gPCBtYXguIE5PVEU6IEl0J3MgPCBtYXggYW5kIG5vdCA8PSBtYXguXG4gKiBAZXhhbXBsZVxuICogYUluUmFuZ2UoJ3gnLCB4LCAxbiwgMjU2bik7IC8vIHdvdWxkIGFzc3VtZSB4IGlzIGluICgxbi4uMjU1bilcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFJblJhbmdlKHRpdGxlLCBuLCBtaW4sIG1heCkge1xuICAgIC8vIFdoeSBtaW4gPD0gbiA8IG1heCBhbmQgbm90IGEgKG1pbiA8IG4gPCBtYXgpIE9SIGIgKG1pbiA8PSBuIDw9IG1heCk/XG4gICAgLy8gY29uc2lkZXIgUD0yNTZuLCBtaW49MG4sIG1heD1QXG4gICAgLy8gLSBhIGZvciBtaW49MCB3b3VsZCByZXF1aXJlIC0xOiAgICAgICAgICBgaW5SYW5nZSgneCcsIHgsIC0xbiwgUClgXG4gICAgLy8gLSBiIHdvdWxkIGNvbW1vbmx5IHJlcXVpcmUgc3VidHJhY3Rpb246ICBgaW5SYW5nZSgneCcsIHgsIDBuLCBQIC0gMW4pYFxuICAgIC8vIC0gb3VyIHdheSBpcyB0aGUgY2xlYW5lc3Q6ICAgICAgICAgICAgICAgYGluUmFuZ2UoJ3gnLCB4LCAwbiwgUClcbiAgICBpZiAoIWluUmFuZ2UobiwgbWluLCBtYXgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIHZhbGlkICcgKyB0aXRsZSArICc6ICcgKyBtaW4gKyAnIDw9IG4gPCAnICsgbWF4ICsgJywgZ290ICcgKyBuKTtcbn1cbi8vIEJpdCBvcGVyYXRpb25zXG4vKipcbiAqIENhbGN1bGF0ZXMgYW1vdW50IG9mIGJpdHMgaW4gYSBiaWdpbnQuXG4gKiBTYW1lIGFzIGBuLnRvU3RyaW5nKDIpLmxlbmd0aGBcbiAqIFRPRE86IG1lcmdlIHdpdGggbkxlbmd0aCBpbiBtb2R1bGFyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaXRMZW4obikge1xuICAgIGxldCBsZW47XG4gICAgZm9yIChsZW4gPSAwOyBuID4gXzBuOyBuID4+PSBfMW4sIGxlbiArPSAxKVxuICAgICAgICA7XG4gICAgcmV0dXJuIGxlbjtcbn1cbi8qKlxuICogR2V0cyBzaW5nbGUgYml0IGF0IHBvc2l0aW9uLlxuICogTk9URTogZmlyc3QgYml0IHBvc2l0aW9uIGlzIDAgKHNhbWUgYXMgYXJyYXlzKVxuICogU2FtZSBhcyBgISErQXJyYXkuZnJvbShuLnRvU3RyaW5nKDIpKS5yZXZlcnNlKClbcG9zXWBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpdEdldChuLCBwb3MpIHtcbiAgICByZXR1cm4gKG4gPj4gQmlnSW50KHBvcykpICYgXzFuO1xufVxuLyoqXG4gKiBTZXRzIHNpbmdsZSBiaXQgYXQgcG9zaXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaXRTZXQobiwgcG9zLCB2YWx1ZSkge1xuICAgIHJldHVybiBuIHwgKCh2YWx1ZSA/IF8xbiA6IF8wbikgPDwgQmlnSW50KHBvcykpO1xufVxuLyoqXG4gKiBDYWxjdWxhdGUgbWFzayBmb3IgTiBiaXRzLiBOb3QgdXNpbmcgKiogb3BlcmF0b3Igd2l0aCBiaWdpbnRzIGJlY2F1c2Ugb2Ygb2xkIGVuZ2luZXMuXG4gKiBTYW1lIGFzIEJpZ0ludChgMGIke0FycmF5KGkpLmZpbGwoJzEnKS5qb2luKCcnKX1gKVxuICovXG5leHBvcnQgY29uc3QgYml0TWFzayA9IChuKSA9PiAoXzFuIDw8IEJpZ0ludChuKSkgLSBfMW47XG4vLyBEUkJHXG5jb25zdCB1OG4gPSAobGVuKSA9PiBuZXcgVWludDhBcnJheShsZW4pOyAvLyBjcmVhdGVzIFVpbnQ4QXJyYXlcbmNvbnN0IHU4ZnIgPSAoYXJyKSA9PiBVaW50OEFycmF5LmZyb20oYXJyKTsgLy8gYW5vdGhlciBzaG9ydGN1dFxuLyoqXG4gKiBNaW5pbWFsIEhNQUMtRFJCRyBmcm9tIE5JU1QgODAwLTkwIGZvciBSRkM2OTc5IHNpZ3MuXG4gKiBAcmV0dXJucyBmdW5jdGlvbiB0aGF0IHdpbGwgY2FsbCBEUkJHIHVudGlsIDJuZCBhcmcgcmV0dXJucyBzb21ldGhpbmcgbWVhbmluZ2Z1bFxuICogQGV4YW1wbGVcbiAqICAgY29uc3QgZHJiZyA9IGNyZWF0ZUhtYWNEUkJHPEtleT4oMzIsIDMyLCBobWFjKTtcbiAqICAgZHJiZyhzZWVkLCBieXRlc1RvS2V5KTsgLy8gYnl0ZXNUb0tleSBtdXN0IHJldHVybiBLZXkgb3IgdW5kZWZpbmVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVIbWFjRHJiZyhoYXNoTGVuLCBxQnl0ZUxlbiwgaG1hY0ZuKSB7XG4gICAgaWYgKHR5cGVvZiBoYXNoTGVuICE9PSAnbnVtYmVyJyB8fCBoYXNoTGVuIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoYXNoTGVuIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICBpZiAodHlwZW9mIHFCeXRlTGVuICE9PSAnbnVtYmVyJyB8fCBxQnl0ZUxlbiA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncUJ5dGVMZW4gbXVzdCBiZSBhIG51bWJlcicpO1xuICAgIGlmICh0eXBlb2YgaG1hY0ZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2htYWNGbiBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAvLyBTdGVwIEIsIFN0ZXAgQzogc2V0IGhhc2hMZW4gdG8gOCpjZWlsKGhsZW4vOClcbiAgICBsZXQgdiA9IHU4bihoYXNoTGVuKTsgLy8gTWluaW1hbCBub24tZnVsbC1zcGVjIEhNQUMtRFJCRyBmcm9tIE5JU1QgODAwLTkwIGZvciBSRkM2OTc5IHNpZ3MuXG4gICAgbGV0IGsgPSB1OG4oaGFzaExlbik7IC8vIFN0ZXBzIEIgYW5kIEMgb2YgUkZDNjk3OSAzLjI6IHNldCBoYXNoTGVuLCBpbiBvdXIgY2FzZSBhbHdheXMgc2FtZVxuICAgIGxldCBpID0gMDsgLy8gSXRlcmF0aW9ucyBjb3VudGVyLCB3aWxsIHRocm93IHdoZW4gb3ZlciAxMDAwXG4gICAgY29uc3QgcmVzZXQgPSAoKSA9PiB7XG4gICAgICAgIHYuZmlsbCgxKTtcbiAgICAgICAgay5maWxsKDApO1xuICAgICAgICBpID0gMDtcbiAgICB9O1xuICAgIGNvbnN0IGggPSAoLi4uYikgPT4gaG1hY0ZuKGssIHYsIC4uLmIpOyAvLyBobWFjKGspKHYsIC4uLnZhbHVlcylcbiAgICBjb25zdCByZXNlZWQgPSAoc2VlZCA9IHU4bigwKSkgPT4ge1xuICAgICAgICAvLyBITUFDLURSQkcgcmVzZWVkKCkgZnVuY3Rpb24uIFN0ZXBzIEQtR1xuICAgICAgICBrID0gaCh1OGZyKFsweDAwXSksIHNlZWQpOyAvLyBrID0gaG1hYyhrIHx8IHYgfHwgMHgwMCB8fCBzZWVkKVxuICAgICAgICB2ID0gaCgpOyAvLyB2ID0gaG1hYyhrIHx8IHYpXG4gICAgICAgIGlmIChzZWVkLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgayA9IGgodThmcihbMHgwMV0pLCBzZWVkKTsgLy8gayA9IGhtYWMoayB8fCB2IHx8IDB4MDEgfHwgc2VlZClcbiAgICAgICAgdiA9IGgoKTsgLy8gdiA9IGhtYWMoayB8fCB2KVxuICAgIH07XG4gICAgY29uc3QgZ2VuID0gKCkgPT4ge1xuICAgICAgICAvLyBITUFDLURSQkcgZ2VuZXJhdGUoKSBmdW5jdGlvblxuICAgICAgICBpZiAoaSsrID49IDEwMDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RyYmc6IHRyaWVkIDEwMDAgdmFsdWVzJyk7XG4gICAgICAgIGxldCBsZW4gPSAwO1xuICAgICAgICBjb25zdCBvdXQgPSBbXTtcbiAgICAgICAgd2hpbGUgKGxlbiA8IHFCeXRlTGVuKSB7XG4gICAgICAgICAgICB2ID0gaCgpO1xuICAgICAgICAgICAgY29uc3Qgc2wgPSB2LnNsaWNlKCk7XG4gICAgICAgICAgICBvdXQucHVzaChzbCk7XG4gICAgICAgICAgICBsZW4gKz0gdi5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbmNhdEJ5dGVzKC4uLm91dCk7XG4gICAgfTtcbiAgICBjb25zdCBnZW5VbnRpbCA9IChzZWVkLCBwcmVkKSA9PiB7XG4gICAgICAgIHJlc2V0KCk7XG4gICAgICAgIHJlc2VlZChzZWVkKTsgLy8gU3RlcHMgRC1HXG4gICAgICAgIGxldCByZXMgPSB1bmRlZmluZWQ7IC8vIFN0ZXAgSDogZ3JpbmQgdW50aWwgayBpcyBpbiBbMS4ubi0xXVxuICAgICAgICB3aGlsZSAoIShyZXMgPSBwcmVkKGdlbigpKSkpXG4gICAgICAgICAgICByZXNlZWQoKTtcbiAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIHJldHVybiBnZW5VbnRpbDtcbn1cbi8vIFZhbGlkYXRpbmcgY3VydmVzIGFuZCBmaWVsZHNcbmNvbnN0IHZhbGlkYXRvckZucyA9IHtcbiAgICBiaWdpbnQ6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdiaWdpbnQnLFxuICAgIGZ1bmN0aW9uOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nLFxuICAgIGJvb2xlYW46ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdib29sZWFuJyxcbiAgICBzdHJpbmc6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnLFxuICAgIHN0cmluZ09yVWludDhBcnJheTogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgfHwgaXNCeXRlcyh2YWwpLFxuICAgIGlzU2FmZUludGVnZXI6ICh2YWwpID0+IE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbCksXG4gICAgYXJyYXk6ICh2YWwpID0+IEFycmF5LmlzQXJyYXkodmFsKSxcbiAgICBmaWVsZDogKHZhbCwgb2JqZWN0KSA9PiBvYmplY3QuRnAuaXNWYWxpZCh2YWwpLFxuICAgIGhhc2g6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicgJiYgTnVtYmVyLmlzU2FmZUludGVnZXIodmFsLm91dHB1dExlbiksXG59O1xuLy8gdHlwZSBSZWNvcmQ8SyBleHRlbmRzIHN0cmluZyB8IG51bWJlciB8IHN5bWJvbCwgVD4gPSB7IFtQIGluIEtdOiBUOyB9XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVPYmplY3Qob2JqZWN0LCB2YWxpZGF0b3JzLCBvcHRWYWxpZGF0b3JzID0ge30pIHtcbiAgICBjb25zdCBjaGVja0ZpZWxkID0gKGZpZWxkTmFtZSwgdHlwZSwgaXNPcHRpb25hbCkgPT4ge1xuICAgICAgICBjb25zdCBjaGVja1ZhbCA9IHZhbGlkYXRvckZuc1t0eXBlXTtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGVja1ZhbCAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB2YWxpZGF0b3IgZnVuY3Rpb24nKTtcbiAgICAgICAgY29uc3QgdmFsID0gb2JqZWN0W2ZpZWxkTmFtZV07XG4gICAgICAgIGlmIChpc09wdGlvbmFsICYmIHZhbCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIWNoZWNrVmFsKHZhbCwgb2JqZWN0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYXJhbSAnICsgU3RyaW5nKGZpZWxkTmFtZSkgKyAnIGlzIGludmFsaWQuIEV4cGVjdGVkICcgKyB0eXBlICsgJywgZ290ICcgKyB2YWwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIHR5cGVdIG9mIE9iamVjdC5lbnRyaWVzKHZhbGlkYXRvcnMpKVxuICAgICAgICBjaGVja0ZpZWxkKGZpZWxkTmFtZSwgdHlwZSwgZmFsc2UpO1xuICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgdHlwZV0gb2YgT2JqZWN0LmVudHJpZXMob3B0VmFsaWRhdG9ycykpXG4gICAgICAgIGNoZWNrRmllbGQoZmllbGROYW1lLCB0eXBlLCB0cnVlKTtcbiAgICByZXR1cm4gb2JqZWN0O1xufVxuLy8gdmFsaWRhdGUgdHlwZSB0ZXN0c1xuLy8gY29uc3QgbzogeyBhOiBudW1iZXI7IGI6IG51bWJlcjsgYzogbnVtYmVyIH0gPSB7IGE6IDEsIGI6IDUsIGM6IDYgfTtcbi8vIGNvbnN0IHowID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAnaXNTYWZlSW50ZWdlcicgfSwgeyBjOiAnYmlnaW50JyB9KTsgLy8gT2shXG4vLyAvLyBTaG91bGQgZmFpbCB0eXBlLWNoZWNrXG4vLyBjb25zdCB6MSA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ3RtcCcgfSwgeyBjOiAnenonIH0pO1xuLy8gY29uc3QgejIgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdpc1NhZmVJbnRlZ2VyJyB9LCB7IGM6ICd6eicgfSk7XG4vLyBjb25zdCB6MyA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgdGVzdDogJ2Jvb2xlYW4nLCB6OiAnYnVnJyB9KTtcbi8vIGNvbnN0IHo0ID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAnYm9vbGVhbicsIHo6ICdidWcnIH0pO1xuLyoqXG4gKiB0aHJvd3Mgbm90IGltcGxlbWVudGVkIGVycm9yXG4gKi9cbmV4cG9ydCBjb25zdCBub3RJbXBsZW1lbnRlZCA9ICgpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xufTtcbi8qKlxuICogTWVtb2l6ZXMgKGNhY2hlcykgY29tcHV0YXRpb24gcmVzdWx0LlxuICogVXNlcyBXZWFrTWFwOiB0aGUgdmFsdWUgaXMgZ29pbmcgYXV0by1jbGVhbmVkIGJ5IEdDIGFmdGVyIGxhc3QgcmVmZXJlbmNlIGlzIHJlbW92ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZW1vaXplZChmbikge1xuICAgIGNvbnN0IG1hcCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgcmV0dXJuIChhcmcsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgY29uc3QgdmFsID0gbWFwLmdldChhcmcpO1xuICAgICAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICBjb25zdCBjb21wdXRlZCA9IGZuKGFyZywgLi4uYXJncyk7XG4gICAgICAgIG1hcC5zZXQoYXJnLCBjb21wdXRlZCk7XG4gICAgICAgIHJldHVybiBjb21wdXRlZDtcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbIl8wbiIsIkJpZ0ludCIsIl8xbiIsImlzQnl0ZXMiLCJhIiwiVWludDhBcnJheSIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwiY29uc3RydWN0b3IiLCJuYW1lIiwiYWJ5dGVzIiwiaXRlbSIsIkVycm9yIiwiYWJvb2wiLCJ0aXRsZSIsInZhbHVlIiwibnVtYmVyVG9IZXhVbnBhZGRlZCIsIm51bSIsImhleCIsInRvU3RyaW5nIiwibGVuZ3RoIiwiaGV4VG9OdW1iZXIiLCJoYXNIZXhCdWlsdGluIiwiZnJvbSIsInRvSGV4IiwiZnJvbUhleCIsImhleGVzIiwiQXJyYXkiLCJfIiwiaSIsInBhZFN0YXJ0IiwiYnl0ZXNUb0hleCIsImJ5dGVzIiwiYXNjaWlzIiwiXzAiLCJfOSIsIkEiLCJGIiwiZiIsImFzY2lpVG9CYXNlMTYiLCJjaCIsImhleFRvQnl0ZXMiLCJobCIsImFsIiwiYXJyYXkiLCJhaSIsImhpIiwibjEiLCJjaGFyQ29kZUF0IiwibjIiLCJ1bmRlZmluZWQiLCJjaGFyIiwiYnl0ZXNUb051bWJlckJFIiwiYnl0ZXNUb051bWJlckxFIiwicmV2ZXJzZSIsIm51bWJlclRvQnl0ZXNCRSIsIm4iLCJsZW4iLCJudW1iZXJUb0J5dGVzTEUiLCJudW1iZXJUb1ZhckJ5dGVzQkUiLCJlbnN1cmVCeXRlcyIsImV4cGVjdGVkTGVuZ3RoIiwicmVzIiwiZSIsImNvbmNhdEJ5dGVzIiwiYXJyYXlzIiwic3VtIiwicGFkIiwic2V0IiwiZXF1YWxCeXRlcyIsImIiLCJkaWZmIiwidXRmOFRvQnl0ZXMiLCJzdHIiLCJUZXh0RW5jb2RlciIsImVuY29kZSIsImlzUG9zQmlnIiwiaW5SYW5nZSIsIm1pbiIsIm1heCIsImFJblJhbmdlIiwiYml0TGVuIiwiYml0R2V0IiwicG9zIiwiYml0U2V0IiwiYml0TWFzayIsInU4biIsInU4ZnIiLCJhcnIiLCJjcmVhdGVIbWFjRHJiZyIsImhhc2hMZW4iLCJxQnl0ZUxlbiIsImhtYWNGbiIsInYiLCJrIiwicmVzZXQiLCJmaWxsIiwiaCIsInJlc2VlZCIsInNlZWQiLCJnZW4iLCJvdXQiLCJzbCIsInNsaWNlIiwicHVzaCIsImdlblVudGlsIiwicHJlZCIsInZhbGlkYXRvckZucyIsImJpZ2ludCIsInZhbCIsImZ1bmN0aW9uIiwiYm9vbGVhbiIsInN0cmluZyIsInN0cmluZ09yVWludDhBcnJheSIsImlzU2FmZUludGVnZXIiLCJOdW1iZXIiLCJpc0FycmF5IiwiZmllbGQiLCJvYmplY3QiLCJGcCIsImlzVmFsaWQiLCJoYXNoIiwib3V0cHV0TGVuIiwidmFsaWRhdGVPYmplY3QiLCJ2YWxpZGF0b3JzIiwib3B0VmFsaWRhdG9ycyIsImNoZWNrRmllbGQiLCJmaWVsZE5hbWUiLCJ0eXBlIiwiaXNPcHRpb25hbCIsImNoZWNrVmFsIiwiU3RyaW5nIiwiT2JqZWN0IiwiZW50cmllcyIsIm5vdEltcGxlbWVudGVkIiwibWVtb2l6ZWQiLCJmbiIsIm1hcCIsIldlYWtNYXAiLCJhcmciLCJhcmdzIiwiZ2V0IiwiY29tcHV0ZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/abstract/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/abstract/weierstrass.js":
/*!********************************************************************************!*\
  !*** ./node_modules/ox/node_modules/@noble/curves/esm/abstract/weierstrass.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DER: () => (/* binding */ DER),\n/* harmony export */   DERErr: () => (/* binding */ DERErr),\n/* harmony export */   SWUFpSqrtRatio: () => (/* binding */ SWUFpSqrtRatio),\n/* harmony export */   mapToCurveSimpleSWU: () => (/* binding */ mapToCurveSimpleSWU),\n/* harmony export */   weierstrass: () => (/* binding */ weierstrass),\n/* harmony export */   weierstrassPoints: () => (/* binding */ weierstrassPoints)\n/* harmony export */ });\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/abstract/curve.js\");\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/abstract/utils.js\");\n/**\n * Short Weierstrass curve methods. The formula is: y¬≤ = x¬≥ + ax + b.\n *\n * ### Parameters\n *\n * To initialize a weierstrass curve, one needs to pass following params:\n *\n * * a: formula param\n * * b: formula param\n * * Fp: finite field of prime characteristic P; may be complex (Fp2). Arithmetics is done in field\n * * n: order of prime subgroup a.k.a total amount of valid curve points\n * * Gx: Base point (x, y) aka generator point. Gx = x coordinate\n * * Gy: ...y coordinate\n * * h: cofactor, usually 1. h*n = curve group order (n is only subgroup order)\n * * lowS: whether to enable (default) or disable \"low-s\" non-malleable signatures\n *\n * ### Design rationale for types\n *\n * * Interaction between classes from different curves should fail:\n *   `k256.Point.BASE.add(p256.Point.BASE)`\n * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime\n * * Different calls of `curve()` would return different classes -\n *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,\n *   it won't affect others\n *\n * TypeScript can't infer types for classes created inside a function. Classes is one instance\n * of nominative types in TypeScript and interfaces only check for shape, so it's hard to create\n * unique type for every function call.\n *\n * We can use generic types via some param, like curve opts, but that would:\n *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)\n *     which is hard to debug.\n *     2. Params can be generic and we can't enforce them to be constant value:\n *     if somebody creates curve from non-constant params,\n *     it would be allowed to interact with other curves with non-constant params\n *\n * @todo https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // prettier-ignore\n\n// prettier-ignore\n\n// prettier-ignore\n\nfunction validateSigVerOpts(opts) {\n    if (opts.lowS !== undefined) (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abool)(\"lowS\", opts.lowS);\n    if (opts.prehash !== undefined) (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abool)(\"prehash\", opts.prehash);\n}\nfunction validatePointOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.validateBasic)(curve);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(opts, {\n        a: \"field\",\n        b: \"field\"\n    }, {\n        allowInfinityPoint: \"boolean\",\n        allowedPrivateKeyLengths: \"array\",\n        clearCofactor: \"function\",\n        fromBytes: \"function\",\n        isTorsionFree: \"function\",\n        toBytes: \"function\",\n        wrapPrivateKey: \"boolean\"\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error(\"invalid endo: CURVE.a must be 0\");\n        }\n        if (typeof endo !== \"object\" || typeof endo.beta !== \"bigint\" || typeof endo.splitScalar !== \"function\") {\n            throw new Error('invalid endo: expected \"beta\": bigint and \"splitScalar\": function');\n        }\n    }\n    return Object.freeze({\n        ...opts\n    });\n}\nclass DERErr extends Error {\n    constructor(m = \"\"){\n        super(m);\n    }\n}\n/**\n * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:\n *\n *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]\n *\n * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html\n */ const DER = {\n    // asn.1 DER encoding utils\n    Err: DERErr,\n    // Basic building block is TLV (Tag-Length-Value)\n    _tlv: {\n        encode: (tag, data)=>{\n            const { Err: E } = DER;\n            if (tag < 0 || tag > 256) throw new E(\"tlv.encode: wrong tag\");\n            if (data.length & 1) throw new E(\"tlv.encode: unpadded data\");\n            const dataLen = data.length / 2;\n            const len = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToHexUnpadded)(dataLen);\n            if (len.length / 2 & 128) throw new E(\"tlv.encode: long form length too big\");\n            // length of length with long form flag\n            const lenLen = dataLen > 127 ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToHexUnpadded)(len.length / 2 | 128) : \"\";\n            const t = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToHexUnpadded)(tag);\n            return t + lenLen + len + data;\n        },\n        // v - value, l - left bytes (unparsed)\n        decode (tag, data) {\n            const { Err: E } = DER;\n            let pos = 0;\n            if (tag < 0 || tag > 256) throw new E(\"tlv.encode: wrong tag\");\n            if (data.length < 2 || data[pos++] !== tag) throw new E(\"tlv.decode: wrong tlv\");\n            const first = data[pos++];\n            const isLong = !!(first & 128); // First bit of first length byte is flag for short/long form\n            let length = 0;\n            if (!isLong) length = first;\n            else {\n                // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]\n                const lenLen = first & 127;\n                if (!lenLen) throw new E(\"tlv.decode(long): indefinite length not supported\");\n                if (lenLen > 4) throw new E(\"tlv.decode(long): byte length is too big\"); // this will overflow u32 in js\n                const lengthBytes = data.subarray(pos, pos + lenLen);\n                if (lengthBytes.length !== lenLen) throw new E(\"tlv.decode: length bytes not complete\");\n                if (lengthBytes[0] === 0) throw new E(\"tlv.decode(long): zero leftmost byte\");\n                for (const b of lengthBytes)length = length << 8 | b;\n                pos += lenLen;\n                if (length < 128) throw new E(\"tlv.decode(long): not minimal encoding\");\n            }\n            const v = data.subarray(pos, pos + length);\n            if (v.length !== length) throw new E(\"tlv.decode: wrong value length\");\n            return {\n                v,\n                l: data.subarray(pos + length)\n            };\n        }\n    },\n    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n    // since we always use positive integers here. It must always be empty:\n    // - add zero byte if exists\n    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n    _int: {\n        encode (num) {\n            const { Err: E } = DER;\n            if (num < _0n) throw new E(\"integer: negative integers are not allowed\");\n            let hex = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToHexUnpadded)(num);\n            // Pad with zero byte if negative flag is present\n            if (Number.parseInt(hex[0], 16) & 8) hex = \"00\" + hex;\n            if (hex.length & 1) throw new E(\"unexpected DER parsing assertion: unpadded hex\");\n            return hex;\n        },\n        decode (data) {\n            const { Err: E } = DER;\n            if (data[0] & 128) throw new E(\"invalid signature integer: negative\");\n            if (data[0] === 0x00 && !(data[1] & 128)) throw new E(\"invalid signature integer: unnecessary leading zero\");\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(data);\n        }\n    },\n    toSig (hex) {\n        // parse DER signature\n        const { Err: E, _int: int, _tlv: tlv } = DER;\n        const data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"signature\", hex);\n        const { v: seqBytes, l: seqLeftBytes } = tlv.decode(0x30, data);\n        if (seqLeftBytes.length) throw new E(\"invalid signature: left bytes after parsing\");\n        const { v: rBytes, l: rLeftBytes } = tlv.decode(0x02, seqBytes);\n        const { v: sBytes, l: sLeftBytes } = tlv.decode(0x02, rLeftBytes);\n        if (sLeftBytes.length) throw new E(\"invalid signature: left bytes after parsing\");\n        return {\n            r: int.decode(rBytes),\n            s: int.decode(sBytes)\n        };\n    },\n    hexFromSig (sig) {\n        const { _tlv: tlv, _int: int } = DER;\n        const rs = tlv.encode(0x02, int.encode(sig.r));\n        const ss = tlv.encode(0x02, int.encode(sig.s));\n        const seq = rs + ss;\n        return tlv.encode(0x30, seq);\n    }\n};\nfunction numToSizedHex(num, size) {\n    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(num, size));\n}\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nfunction weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const Fn = (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.Field)(CURVE.n, CURVE.nBitLength);\n    const toBytes = CURVE.toBytes || ((_c, point, _isCompressed)=>{\n        const a = point.toAffine();\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(Uint8Array.from([\n            0x04\n        ]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n    });\n    const fromBytes = CURVE.fromBytes || ((bytes)=>{\n        // const head = bytes[0];\n        const tail = bytes.subarray(1);\n        // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n        return {\n            x,\n            y\n        };\n    });\n    /**\n     * y¬≤ = x¬≥ + ax + b: Short weierstrass curve formula. Takes x, returns y¬≤.\n     * @returns y¬≤\n     */ function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x¬≤ * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x¬≥ + a * x + b\n    }\n    function isValidXY(x, y) {\n        const left = Fp.sqr(y); // y¬≤\n        const right = weierstrassEquation(x); // x¬≥ + ax + b\n        return Fp.eql(left, right);\n    }\n    // Validate whether the passed curve params are valid.\n    // Test 1: equation y¬≤ = x¬≥ + ax + b should work for generator point.\n    if (!isValidXY(CURVE.Gx, CURVE.Gy)) throw new Error(\"bad curve params: generator point\");\n    // Test 2: discriminant Œî part should be non-zero: 4a¬≥ + 27b¬≤ != 0.\n    // Guarantees curve is genus-1, smooth (non-singular).\n    const _4a3 = Fp.mul(Fp.pow(CURVE.a, _3n), _4n);\n    const _27b2 = Fp.mul(Fp.sqr(CURVE.b), BigInt(27));\n    if (Fp.is0(Fp.add(_4a3, _27b2))) throw new Error(\"bad curve params: a or b\");\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.inRange)(num, _1n, CURVE.n);\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: N } = CURVE;\n        if (lengths && typeof key !== \"bigint\") {\n            if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isBytes)(key)) key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== \"string\" || !lengths.includes(key.length)) throw new Error(\"invalid private key\");\n            key = key.padStart(nByteLength * 2, \"0\");\n        }\n        let num;\n        try {\n            num = typeof key === \"bigint\" ? key : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"private key\", key, nByteLength));\n        } catch (error) {\n            throw new Error(\"invalid private key, expected hex or \" + nByteLength + \" bytes, got \" + typeof key);\n        }\n        if (wrapPrivateKey) num = (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.mod)(num, N); // disabled by default, enabled for BLS\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange)(\"private key\", num, _1n, N); // num in range [1..N-1]\n        return num;\n    }\n    function aprjpoint(other) {\n        if (!(other instanceof Point)) throw new Error(\"ProjectivePoint expected\");\n    }\n    // Memoized toAffine / validity check. They are heavy. Points are immutable.\n    // Converts Projective point to affine (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    // (X, Y, Z) ‚àã (x=X/Z, y=Y/Z)\n    const toAffineMemo = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memoized)((p, iz)=>{\n        const { px: x, py: y, pz: z } = p;\n        // Fast-path for normalized points\n        if (Fp.eql(z, Fp.ONE)) return {\n            x,\n            y\n        };\n        const is0 = p.is0();\n        // If invZ was 0, we return zero point. However we still want to execute\n        // all operations, so we replace invZ with a random number, 1.\n        if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(z);\n        const ax = Fp.mul(x, iz);\n        const ay = Fp.mul(y, iz);\n        const zz = Fp.mul(z, iz);\n        if (is0) return {\n            x: Fp.ZERO,\n            y: Fp.ZERO\n        };\n        if (!Fp.eql(zz, Fp.ONE)) throw new Error(\"invZ was invalid\");\n        return {\n            x: ax,\n            y: ay\n        };\n    });\n    // NOTE: on exception this will crash 'cached' and no value will be set.\n    // Otherwise true will be return\n    const assertValidMemo = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memoized)((p)=>{\n        if (p.is0()) {\n            // (0, 1, 0) aka ZERO is invalid in most contexts.\n            // In BLS, ZERO can be serialized, so we allow it.\n            // (0, 0, 0) is invalid representation of ZERO.\n            if (CURVE.allowInfinityPoint && !Fp.is0(p.py)) return;\n            throw new Error(\"bad point: ZERO\");\n        }\n        // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n        const { x, y } = p.toAffine();\n        // Check if x, y are valid field elements\n        if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error(\"bad point: x or y not FE\");\n        if (!isValidXY(x, y)) throw new Error(\"bad point: equation left != right\");\n        if (!p.isTorsionFree()) throw new Error(\"bad point: not in prime-order subgroup\");\n        return true;\n    });\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (X, Y, Z) ‚àã (x=X/Z, y=Y/Z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */ class Point {\n        constructor(px, py, pz){\n            if (px == null || !Fp.isValid(px)) throw new Error(\"x required\");\n            if (py == null || !Fp.isValid(py) || Fp.is0(py)) throw new Error(\"y required\");\n            if (pz == null || !Fp.isValid(pz)) throw new Error(\"z required\");\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            Object.freeze(this);\n        }\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error(\"invalid affine point\");\n            if (p instanceof Point) throw new Error(\"projective point not allowed\");\n            const is0 = (i)=>Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y)) return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */ static normalizeZ(points) {\n            const toInv = (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.FpInvertBatch)(Fp, points.map((p)=>p.pz));\n            return points.map((p, i)=>p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */ static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"pointHex\", hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // Multiscalar Multiplication\n        static msm(points, scalars) {\n            return (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.pippenger)(Point, Fn, points, scalars);\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            wnaf.setWindowSize(this, windowSize);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            assertValidMemo(this);\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd) return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */ equals(other) {\n            aprjpoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */ negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            aprjpoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, n, Point.normalizeZ);\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */ multiplyUnsafe(sc) {\n            const { endo, n: N } = CURVE;\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange)(\"scalar\", sc, _0n, N);\n            const I = Point.ZERO;\n            if (sc === _0n) return I;\n            if (this.is0() || sc === _1n) return this;\n            // Case a: no endomorphism. Case b: has precomputes.\n            if (!endo || wnaf.hasPrecomputes(this)) return wnaf.wNAFCachedUnsafe(this, sc, Point.normalizeZ);\n            // Case c: endomorphism\n            /** See docs for {@link EndomorphismOpts} */ let { k1neg, k1, k2neg, k2 } = endo.splitScalar(sc);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while(k1 > _0n || k2 > _0n){\n                if (k1 & _1n) k1p = k1p.add(d);\n                if (k2 & _1n) k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n;\n                k2 >>= _1n;\n            }\n            if (k1neg) k1p = k1p.negate();\n            if (k2neg) k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */ multiply(scalar) {\n            const { endo, n: N } = CURVE;\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange)(\"scalar\", scalar, _1n, N);\n            let point, fake; // Fake point is used to const-time mult\n            /** See docs for {@link EndomorphismOpts} */ if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(scalar);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            } else {\n                const { p, f } = this.wNAF(scalar);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([\n                point,\n                fake\n            ])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */ multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            )=>a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a);\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z) ‚àã (x=x/z, y=y/z)\n        toAffine(iz) {\n            return toAffineMemo(this, iz);\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n) return true; // No subgroups, always torsion-free\n            if (isTorsionFree) return isTorsionFree(Point, this);\n            throw new Error(\"isTorsionFree() has not been declared for the elliptic curve\");\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n) return this; // Fast-path\n            if (clearCofactor) return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes(isCompressed = true) {\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abool)(\"isCompressed\", isCompressed);\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abool)(\"isCompressed\", isCompressed);\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(this.toRawBytes(isCompressed));\n        }\n    }\n    // base / generator point\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    // zero / infinity / identity point\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO); // 0, 1, 0\n    const { endo, nBitLength } = CURVE;\n    const wnaf = (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.wNAF)(Point, endo ? Math.ceil(nBitLength / 2) : nBitLength);\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder\n    };\n}\nfunction validateOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.validateBasic)(curve);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(opts, {\n        hash: \"hash\",\n        hmac: \"function\",\n        randomBytes: \"function\"\n    }, {\n        bits2int: \"function\",\n        bits2int_modN: \"function\",\n        lowS: \"boolean\"\n    });\n    return Object.freeze({\n        lowS: true,\n        ...opts\n    });\n}\n/**\n * Creates short weierstrass curve and ECDSA signature methods for it.\n * @example\n * import { Field } from '@noble/curves/abstract/modular';\n * // Before that, define BigInt-s: a, b, p, n, Gx, Gy\n * const curve = weierstrass({ a, b, Fp: Field(p), n, Gx, Gy, h: 1n })\n */ function weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER, nByteLength, nBitLength } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function modN(a) {\n        return (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.mod)(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.invert)(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({\n        ...CURVE,\n        toBytes (_c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = _utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes;\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abool)(\"isCompressed\", isCompressed);\n            if (isCompressed) {\n                return cat(Uint8Array.from([\n                    point.hasEvenY() ? 0x02 : 0x03\n                ]), x);\n            } else {\n                return cat(Uint8Array.from([\n                    0x04\n                ]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes (bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(tail);\n                if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.inRange)(x, _1n, Fp.ORDER)) throw new Error(\"Point is not on curve\");\n                const y2 = weierstrassEquation(x); // y¬≤ = x¬≥ + ax + b\n                let y;\n                try {\n                    y = Fp.sqrt(y2); // y = y¬≤ ^ (p+1)/4\n                } catch (sqrtError) {\n                    const suffix = sqrtError instanceof Error ? \": \" + sqrtError.message : \"\";\n                    throw new Error(\"Point is not on curve\" + suffix);\n                }\n                const isYOdd = (y & _1n) === _1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd) y = Fp.neg(y);\n                return {\n                    x,\n                    y\n                };\n            } else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return {\n                    x,\n                    y\n                };\n            } else {\n                const cl = compressedLen;\n                const ul = uncompressedLen;\n                throw new Error(\"invalid Point, expected length of \" + cl + \", or uncompressed \" + ul + \", got \" + len);\n            }\n        }\n    });\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to)=>(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */ class Signature {\n        constructor(r, s, recovery){\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange)(\"r\", r, _1n, CURVE_ORDER); // r in [1..N]\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange)(\"s\", s, _1n, CURVE_ORDER); // s in [1..N]\n            this.r = r;\n            this.s = s;\n            if (recovery != null) this.recovery = recovery;\n            Object.freeze(this);\n        }\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = nByteLength;\n            hex = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"compactSignature\", hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = DER.toSig((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"DER\", hex));\n            return new Signature(r, s);\n        }\n        /**\n         * @todo remove\n         * @deprecated\n         */ assertValidity() {}\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"msgHash\", msgHash)); // Truncate hash\n            if (rec == null || ![\n                0,\n                1,\n                2,\n                3\n            ].includes(rec)) throw new Error(\"recovery id invalid\");\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER) throw new Error(\"recovery id 2 or 3 invalid\");\n            const prefix = (rec & 1) === 0 ? \"02\" : \"03\";\n            const R = Point.fromHex(prefix + numToSizedHex(radj, Fp.BYTES));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q) throw new Error(\"point at infinify\"); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(this.toDERHex());\n        }\n        toDERHex() {\n            return DER.hexFromSig(this);\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(this.toCompactHex());\n        }\n        toCompactHex() {\n            const l = nByteLength;\n            return numToSizedHex(this.r, l) + numToSizedHex(this.s, l);\n        }\n    }\n    const utils = {\n        isValidPrivateKey (privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            } catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size\n         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n         */ randomPrivateKey: ()=>{\n            const length = (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.getMinHashLength)(CURVE.n);\n            return (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.mapHashToField)(CURVE.randomBytes(length), CURVE.n);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */ precompute (windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        }\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */ function getPublicKey(privateKey, isCompressed = true) {\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */ function isProbPub(item) {\n        if (typeof item === \"bigint\") return false;\n        if (item instanceof Point) return true;\n        const arr = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"key\", item);\n        const len = arr.length;\n        const fpl = Fp.BYTES;\n        const compLen = fpl + 1; // e.g. 33 for 32\n        const uncompLen = 2 * fpl + 1; // e.g. 65 for 32\n        if (CURVE.allowedPrivateKeyLengths || nByteLength === compLen) {\n            return undefined;\n        } else {\n            return len === compLen || len === uncompLen;\n        }\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */ function getSharedSecret(privateA, publicB, isCompressed = true) {\n        if (isProbPub(privateA) === true) throw new Error(\"first arg must be private key\");\n        if (isProbPub(publicB) === false) throw new Error(\"second arg must be public key\");\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int || function(bytes) {\n        // Our custom check \"just in case\", for protection against DoS\n        if (bytes.length > 8192) throw new Error(\"input is too large\");\n        // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n        // for some cases, since bytes.length * 8 is not actual bitLength.\n        const num = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(bytes); // check for == u8 done here\n        const delta = bytes.length * 8 - nBitLength; // truncate to nBitLength leftmost bits\n        return delta > 0 ? num >> BigInt(delta) : num;\n    };\n    const bits2int_modN = CURVE.bits2int_modN || function(bytes) {\n        return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n    };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */ function int2octets(num) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange)(\"num < 2^\" + nBitLength, num, _0n, ORDER_MASK);\n        // works with order, can have different size than numToField!\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(num, nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order,\n    // this will be invalid at least for P521. Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if ([\n            \"recovered\",\n            \"canonical\"\n        ].some((k)=>k in opts)) throw new Error(\"sign() legacy options not supported\");\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null) lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"msgHash\", msgHash);\n        validateSigVerOpts(opts);\n        if (prehash) msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"prehashed msgHash\", hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [\n            int2octets(d),\n            int2octets(h1int)\n        ];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null && ent !== false) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"extraEntropy\", e)); // check for being bytes\n        }\n        const seed = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k)) return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === _0n) return;\n            // Can use scalar blinding b^-1(bm + bdr) where b ‚àà [1,q‚àí1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === _0n) return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return {\n            seed,\n            k2sig\n        };\n    }\n    const defaultSigOpts = {\n        lowS: CURVE.lowS,\n        prehash: false\n    };\n    const defaultVerOpts = {\n        lowS: CURVE.lowS,\n        prehash: false\n    };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G √ó k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */ function sign(msgHash, privKey, opts = defaultSigOpts) {\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createHmacDrbg)(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1‚ãÖG - U2‚ãÖP\n     *   mod(R.x, n) == r\n     * ```\n     */ function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"msgHash\", msgHash);\n        publicKey = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"publicKey\", publicKey);\n        const { lowS, prehash, format } = opts;\n        // Verify opts, deduce signature format\n        validateSigVerOpts(opts);\n        if (\"strict\" in opts) throw new Error(\"options.strict was renamed to lowS\");\n        if (format !== undefined && format !== \"compact\" && format !== \"der\") throw new Error(\"format must be compact or der\");\n        const isHex = typeof sg === \"string\" || (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isBytes)(sg);\n        const isObj = !isHex && !format && typeof sg === \"object\" && sg !== null && typeof sg.r === \"bigint\" && typeof sg.s === \"bigint\";\n        if (!isHex && !isObj) throw new Error(\"invalid signature, expected Uint8Array, hex string or Signature instance\");\n        let _sig = undefined;\n        let P;\n        try {\n            if (isObj) _sig = new Signature(sg.r, sg.s);\n            if (isHex) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    if (format !== \"compact\") _sig = Signature.fromDER(sg);\n                } catch (derError) {\n                    if (!(derError instanceof DER.Err)) throw derError;\n                }\n                if (!_sig && format !== \"der\") _sig = Signature.fromCompact(sg);\n            }\n            P = Point.fromHex(publicKey);\n        } catch (error) {\n            return false;\n        }\n        if (!_sig) return false;\n        if (lowS && _sig.hasHighS()) return false;\n        if (prehash) msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1‚ãÖG + u2‚ãÖP\n        if (!R) return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils\n    };\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */ function SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for(let o = q - _1n; o % _2n === _0n; o /= _2n)l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << c1 - _1n - _1n;\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v)=>{\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for(let i = c1; i > _1n; i--){\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << tv5 - _1n; // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return {\n            isValid: isQR,\n            value: tv3\n        };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v)=>{\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return {\n                isValid: isQR,\n                value: y\n            }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */ function mapToCurveSimpleSWU(Fp, opts) {\n    (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.validateField)(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z)) throw new Error(\"mapToCurveSimpleSWU: invalid opts\");\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd) throw new Error(\"Fp.isOdd is not implemented!\");\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u)=>{\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        const tv4_inv = (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.FpInvertBatch)(Fp, [\n            tv4\n        ], true)[0];\n        x = Fp.mul(x, tv4_inv); // 25.   x = x / tv4\n        return {\n            x,\n            y\n        };\n    };\n} //# sourceMappingURL=weierstrass.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L3dlaWVyc3RyYXNzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXNDQyxHQUNELG9FQUFvRSxHQUNwRSxrQkFBa0I7QUFDMEM7QUFDNUQsa0JBQWtCO0FBQ2dHO0FBQ2xILGtCQUFrQjtBQUN5TTtBQUMzTixTQUFTeUIsbUJBQW1CQyxJQUFJO0lBQzVCLElBQUlBLEtBQUtDLElBQUksS0FBS0MsV0FDZGpCLGdEQUFLQSxDQUFDLFFBQVFlLEtBQUtDLElBQUk7SUFDM0IsSUFBSUQsS0FBS0csT0FBTyxLQUFLRCxXQUNqQmpCLGdEQUFLQSxDQUFDLFdBQVdlLEtBQUtHLE9BQU87QUFDckM7QUFDQSxTQUFTQyxrQkFBa0JDLEtBQUs7SUFDNUIsTUFBTUwsT0FBT3pCLHdEQUFhQSxDQUFDOEI7SUFDM0JQLHlEQUFjQSxDQUFDRSxNQUFNO1FBQ2pCTSxHQUFHO1FBQ0hDLEdBQUc7SUFDUCxHQUFHO1FBQ0NDLG9CQUFvQjtRQUNwQkMsMEJBQTBCO1FBQzFCQyxlQUFlO1FBQ2ZDLFdBQVc7UUFDWEMsZUFBZTtRQUNmQyxTQUFTO1FBQ1RDLGdCQUFnQjtJQUNwQjtJQUNBLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxFQUFFLEVBQUVWLENBQUMsRUFBRSxHQUFHTjtJQUN4QixJQUFJZSxNQUFNO1FBQ04sSUFBSSxDQUFDQyxHQUFHQyxHQUFHLENBQUNYLEdBQUdVLEdBQUdFLElBQUksR0FBRztZQUNyQixNQUFNLElBQUlDLE1BQU07UUFDcEI7UUFDQSxJQUFJLE9BQU9KLFNBQVMsWUFDaEIsT0FBT0EsS0FBS0ssSUFBSSxLQUFLLFlBQ3JCLE9BQU9MLEtBQUtNLFdBQVcsS0FBSyxZQUFZO1lBQ3hDLE1BQU0sSUFBSUYsTUFBTTtRQUNwQjtJQUNKO0lBQ0EsT0FBT0csT0FBT0MsTUFB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QUdvSixHQUFHLENBQUM1RSxJQUFJQSxHQUFHbVAsS0FBSyw0QkFBNEI7UUFDM0QsTUFBTU8sVUFBVXhXLDBEQUFhQSxDQUFDc0MsSUFBSTtZQUFDdVQ7U0FBSSxFQUFFLEtBQUssQ0FBQyxFQUFFO1FBQ2pEaFAsSUFBSXZFLEdBQUdnRixHQUFHLENBQUNULEdBQUcyUCxVQUFVLG9CQUFvQjtRQUM1QyxPQUFPO1lBQUUzUDtZQUFHQztRQUFFO0lBQ2xCO0FBQ0osRUFDQSx1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGF3LXdvcmtzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC93ZWllcnN0cmFzcy5qcz9hZTE1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogU2hvcnQgV2VpZXJzdHJhc3MgY3VydmUgbWV0aG9kcy4gVGhlIGZvcm11bGEgaXM6IHnCsiA9IHjCsyArIGF4ICsgYi5cbiAqXG4gKiAjIyMgUGFyYW1ldGVyc1xuICpcbiAqIFRvIGluaXRpYWxpemUgYSB3ZWllcnN0cmFzcyBjdXJ2ZSwgb25lIG5lZWRzIHRvIHBhc3MgZm9sbG93aW5nIHBhcmFtczpcbiAqXG4gKiAqIGE6IGZvcm11bGEgcGFyYW1cbiAqICogYjogZm9ybXVsYSBwYXJhbVxuICogKiBGcDogZmluaXRlIGZpZWxkIG9mIHByaW1lIGNoYXJhY3RlcmlzdGljIFA7IG1heSBiZSBjb21wbGV4IChGcDIpLiBBcml0aG1ldGljcyBpcyBkb25lIGluIGZpZWxkXG4gKiAqIG46IG9yZGVyIG9mIHByaW1lIHN1Ymdyb3VwIGEuay5hIHRvdGFsIGFtb3VudCBvZiB2YWxpZCBjdXJ2ZSBwb2ludHNcbiAqICogR3g6IEJhc2UgcG9pbnQgKHgsIHkpIGFrYSBnZW5lcmF0b3IgcG9pbnQuIEd4ID0geCBjb29yZGluYXRlXG4gKiAqIEd5OiAuLi55IGNvb3JkaW5hdGVcbiAqICogaDogY29mYWN0b3IsIHVzdWFsbHkgMS4gaCpuID0gY3VydmUgZ3JvdXAgb3JkZXIgKG4gaXMgb25seSBzdWJncm91cCBvcmRlcilcbiAqICogbG93Uzogd2hldGhlciB0byBlbmFibGUgKGRlZmF1bHQpIG9yIGRpc2FibGUgXCJsb3ctc1wiIG5vbi1tYWxsZWFibGUgc2lnbmF0dXJlc1xuICpcbiAqICMjIyBEZXNpZ24gcmF0aW9uYWxlIGZvciB0eXBlc1xuICpcbiAqICogSW50ZXJhY3Rpb24gYmV0d2VlbiBjbGFzc2VzIGZyb20gZGlmZmVyZW50IGN1cnZlcyBzaG91bGQgZmFpbDpcbiAqICAgYGsyNTYuUG9pbnQuQkFTRS5hZGQocDI1Ni5Qb2ludC5CQVNFKWBcbiAqICogRm9yIHRoaXMgcHVycG9zZSB3ZSB3YW50IHRvIHVzZSBgaW5zdGFuY2VvZmAgb3BlcmF0b3IsIHdoaWNoIGlzIGZhc3QgYW5kIHdvcmtzIGR1cmluZyBydW50aW1lXG4gKiAqIERpZmZlcmVudCBjYWxscyBvZiBgY3VydmUoKWAgd291bGQgcmV0dXJuIGRpZmZlcmVudCBjbGFzc2VzIC1cbiAqICAgYGN1cnZlKHBhcmFtcykgIT09IGN1cnZlKHBhcmFtcylgOiBpZiBzb21lYm9keSBkZWNpZGVkIHRvIG1vbmtleS1wYXRjaCB0aGVpciBjdXJ2ZSxcbiAqICAgaXQgd29uJ3QgYWZmZWN0IG90aGVyc1xuICpcbiAqIFR5cGVTY3JpcHQgY2FuJ3QgaW5mZXIgdHlwZXMgZm9yIGNsYXNzZXMgY3JlYXRlZCBpbnNpZGUgYSBmdW5jdGlvbi4gQ2xhc3NlcyBpcyBvbmUgaW5zdGFuY2VcbiAqIG9mIG5vbWluYXRpdmUgdHlwZXMgaW4gVHlwZVNjcmlwdCBhbmQgaW50ZXJmYWNlcyBvbmx5IGNoZWNrIGZvciBzaGFwZSwgc28gaXQncyBoYXJkIHRvIGNyZWF0ZVxuICogdW5pcXVlIHR5cGUgZm9yIGV2ZXJ5IGZ1bmN0aW9uIGNhbGwuXG4gKlxuICogV2UgY2FuIHVzZSBnZW5lcmljIHR5cGVzIHZpYSBzb21lIHBhcmFtLCBsaWtlIGN1cnZlIG9wdHMsIGJ1dCB0aGF0IHdvdWxkOlxuICogICAgIDEuIEVuYWJsZSBpbnRlcmFjdGlvbiBiZXR3ZWVuIGBjdXJ2ZShwYXJhbXMpYCBhbmQgYGN1cnZlKHBhcmFtcylgIChjdXJ2ZXMgb2Ygc2FtZSBwYXJhbXMpXG4gKiAgICAgd2hpY2ggaXMgaGFyZCB0byBkZWJ1Zy5cbiAqICAgICAyLiBQYXJhbXMgY2FuIGJlIGdlbmVyaWMgYW5kIHdlIGNhbid0IGVuZm9yY2UgdGhlbSB0byBiZSBjb25zdGFudCB2YWx1ZTpcbiAqICAgICBpZiBzb21lYm9keSBjcmVhdGVzIGN1cnZlIGZyb20gbm9uLWNvbnN0YW50IHBhcmFtcyxcbiAqICAgICBpdCB3b3VsZCBiZSBhbGxvd2VkIHRvIGludGVyYWN0IHdpdGggb3RoZXIgY3VydmVzIHdpdGggbm9uLWNvbnN0YW50IHBhcmFtc1xuICpcbiAqIEB0b2RvIGh0dHBzOi8vd3d3LnR5cGVzY3JpcHRsYW5nLm9yZy9kb2NzL2hhbmRib29rL3JlbGVhc2Utbm90ZXMvdHlwZXNjcmlwdC0yLTcuaHRtbCN1bmlxdWUtc3ltYm9sXG4gKiBAbW9kdWxlXG4gKi9cbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIHByZXR0aWVyLWlnbm9yZVxuaW1wb3J0IHsgcGlwcGVuZ2VyLCB2YWxpZGF0ZUJhc2ljLCB3TkFGIH0gZnJvbSBcIi4vY3VydmUuanNcIjtcbi8vIHByZXR0aWVyLWlnbm9yZVxuaW1wb3J0IHsgRmllbGQsIEZwSW52ZXJ0QmF0Y2gsIGdldE1pbkhhc2hMZW5ndGgsIGludmVydCwgbWFwSGFzaFRvRmllbGQsIG1vZCwgdmFsaWRhdGVGaWVsZCB9IGZyb20gXCIuL21vZHVsYXIuanNcIjtcbi8vIHByZXR0aWVyLWlnbm9yZVxuaW1wb3J0IHsgYUluUmFuZ2UsIGFib29sLCBiaXRNYXNrLCBieXRlc1RvSGV4LCBieXRlc1RvTnVtYmVyQkUsIGNvbmNhdEJ5dGVzLCBjcmVhdGVIbWFjRHJiZywgZW5zdXJlQnl0ZXMsIGhleFRvQnl0ZXMsIGluUmFuZ2UsIGlzQnl0ZXMsIG1lbW9pemVkLCBudW1iZXJUb0J5dGVzQkUsIG51bWJlclRvSGV4VW5wYWRkZWQsIHZhbGlkYXRlT2JqZWN0IH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbmZ1bmN0aW9uIHZhbGlkYXRlU2lnVmVyT3B0cyhvcHRzKSB7XG4gICAgaWYgKG9wdHMubG93UyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBhYm9vbCgnbG93UycsIG9wdHMubG93Uyk7XG4gICAgaWYgKG9wdHMucHJlaGFzaCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBhYm9vbCgncHJlaGFzaCcsIG9wdHMucHJlaGFzaCk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVBvaW50T3B0cyhjdXJ2ZSkge1xuICAgIGNvbnN0IG9wdHMgPSB2YWxpZGF0ZUJhc2ljKGN1cnZlKTtcbiAgICB2YWxpZGF0ZU9iamVjdChvcHRzLCB7XG4gICAgICAgIGE6ICdmaWVsZCcsXG4gICAgICAgIGI6ICdmaWVsZCcsXG4gICAgfSwge1xuICAgICAgICBhbGxvd0luZmluaXR5UG9pbnQ6ICdib29sZWFuJyxcbiAgICAgICAgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzOiAnYXJyYXknLFxuICAgICAgICBjbGVhckNvZmFjdG9yOiAnZnVuY3Rpb24nLFxuICAgICAgICBmcm9tQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgICAgIGlzVG9yc2lvbkZyZWU6ICdmdW5jdGlvbicsXG4gICAgICAgIHRvQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgICAgIHdyYXBQcml2YXRlS2V5OiAnYm9vbGVhbicsXG4gICAgfSk7XG4gICAgY29uc3QgeyBlbmRvLCBGcCwgYSB9ID0gb3B0cztcbiAgICBpZiAoZW5kbykge1xuICAgICAgICBpZiAoIUZwLmVxbChhLCBGcC5aRVJPKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGVuZG86IENVUlZFLmEgbXVzdCBiZSAwJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBlbmRvICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICAgdHlwZW9mIGVuZG8uYmV0YSAhPT0gJ2JpZ2ludCcgfHxcbiAgICAgICAgICAgIHR5cGVvZiBlbmRvLnNwbGl0U2NhbGFyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZW5kbzogZXhwZWN0ZWQgXCJiZXRhXCI6IGJpZ2ludCBhbmQgXCJzcGxpdFNjYWxhclwiOiBmdW5jdGlvbicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHsgLi4ub3B0cyB9KTtcbn1cbmV4cG9ydCBjbGFzcyBERVJFcnIgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobSA9ICcnKSB7XG4gICAgICAgIHN1cGVyKG0pO1xuICAgIH1cbn1cbi8qKlxuICogQVNOLjEgREVSIGVuY29kaW5nIHV0aWxpdGllcy4gQVNOIGlzIHZlcnkgY29tcGxleCAmIGZyYWdpbGUuIEZvcm1hdDpcbiAqXG4gKiAgICAgWzB4MzAgKFNFUVVFTkNFKSwgYnl0ZWxlbmd0aCwgMHgwMiAoSU5URUdFUiksIGludExlbmd0aCwgUiwgMHgwMiAoSU5URUdFUiksIGludExlbmd0aCwgU11cbiAqXG4gKiBEb2NzOiBodHRwczovL2xldHNlbmNyeXB0Lm9yZy9kb2NzL2Etd2FybS13ZWxjb21lLXRvLWFzbjEtYW5kLWRlci8sIGh0dHBzOi8vbHVjYS5udG9wLm9yZy9UZWFjaGluZy9BcHB1bnRpL2FzbjEuaHRtbFxuICovXG5leHBvcnQgY29uc3QgREVSID0ge1xuICAgIC8vIGFzbi4xIERFUiBlbmNvZGluZyB1dGlsc1xuICAgIEVycjogREVSRXJyLFxuICAgIC8vIEJhc2ljIGJ1aWxkaW5nIGJsb2NrIGlzIFRMViAoVGFnLUxlbmd0aC1WYWx1ZSlcbiAgICBfdGx2OiB7XG4gICAgICAgIGVuY29kZTogKHRhZywgZGF0YSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBFcnI6IEUgfSA9IERFUjtcbiAgICAgICAgICAgIGlmICh0YWcgPCAwIHx8IHRhZyA+IDI1NilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmVuY29kZTogd3JvbmcgdGFnJyk7XG4gICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggJiAxKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZW5jb2RlOiB1bnBhZGRlZCBkYXRhJyk7XG4gICAgICAgICAgICBjb25zdCBkYXRhTGVuID0gZGF0YS5sZW5ndGggLyAyO1xuICAgICAgICAgICAgY29uc3QgbGVuID0gbnVtYmVyVG9IZXhVbnBhZGRlZChkYXRhTGVuKTtcbiAgICAgICAgICAgIGlmICgobGVuLmxlbmd0aCAvIDIpICYgMTI4KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZW5jb2RlOiBsb25nIGZvcm0gbGVuZ3RoIHRvbyBiaWcnKTtcbiAgICAgICAgICAgIC8vIGxlbmd0aCBvZiBsZW5ndGggd2l0aCBsb25nIGZvcm0gZmxhZ1xuICAgICAgICAgICAgY29uc3QgbGVuTGVuID0gZGF0YUxlbiA+IDEyNyA/IG51bWJlclRvSGV4VW5wYWRkZWQoKGxlbi5sZW5ndGggLyAyKSB8IDEyOCkgOiAnJztcbiAgICAgICAgICAgIGNvbnN0IHQgPSBudW1iZXJUb0hleFVucGFkZGVkKHRhZyk7XG4gICAgICAgICAgICByZXR1cm4gdCArIGxlbkxlbiArIGxlbiArIGRhdGE7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHYgLSB2YWx1ZSwgbCAtIGxlZnQgYnl0ZXMgKHVucGFyc2VkKVxuICAgICAgICBkZWNvZGUodGFnLCBkYXRhKSB7XG4gICAgICAgICAgICBjb25zdCB7IEVycjogRSB9ID0gREVSO1xuICAgICAgICAgICAgbGV0IHBvcyA9IDA7XG4gICAgICAgICAgICBpZiAodGFnIDwgMCB8fCB0YWcgPiAyNTYpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5lbmNvZGU6IHdyb25nIHRhZycpO1xuICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgMiB8fCBkYXRhW3BvcysrXSAhPT0gdGFnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZGVjb2RlOiB3cm9uZyB0bHYnKTtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0ID0gZGF0YVtwb3MrK107XG4gICAgICAgICAgICBjb25zdCBpc0xvbmcgPSAhIShmaXJzdCAmIDEyOCk7IC8vIEZpcnN0IGJpdCBvZiBmaXJzdCBsZW5ndGggYnl0ZSBpcyBmbGFnIGZvciBzaG9ydC9sb25nIGZvcm1cbiAgICAgICAgICAgIGxldCBsZW5ndGggPSAwO1xuICAgICAgICAgICAgaWYgKCFpc0xvbmcpXG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gZmlyc3Q7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBMb25nIGZvcm06IFtsb25nRmxhZygxYml0KSwgbGVuZ3RoTGVuZ3RoKDdiaXQpLCBsZW5ndGggKEJFKV1cbiAgICAgICAgICAgICAgICBjb25zdCBsZW5MZW4gPSBmaXJzdCAmIDEyNztcbiAgICAgICAgICAgICAgICBpZiAoIWxlbkxlbilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5kZWNvZGUobG9uZyk6IGluZGVmaW5pdGUgbGVuZ3RoIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgICAgICBpZiAobGVuTGVuID4gNClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5kZWNvZGUobG9uZyk6IGJ5dGUgbGVuZ3RoIGlzIHRvbyBiaWcnKTsgLy8gdGhpcyB3aWxsIG92ZXJmbG93IHUzMiBpbiBqc1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aEJ5dGVzID0gZGF0YS5zdWJhcnJheShwb3MsIHBvcyArIGxlbkxlbik7XG4gICAgICAgICAgICAgICAgaWYgKGxlbmd0aEJ5dGVzLmxlbmd0aCAhPT0gbGVuTGVuKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmRlY29kZTogbGVuZ3RoIGJ5dGVzIG5vdCBjb21wbGV0ZScpO1xuICAgICAgICAgICAgICAgIGlmIChsZW5ndGhCeXRlc1swXSA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5kZWNvZGUobG9uZyk6IHplcm8gbGVmdG1vc3QgYnl0ZScpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYiBvZiBsZW5ndGhCeXRlcylcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gKGxlbmd0aCA8PCA4KSB8IGI7XG4gICAgICAgICAgICAgICAgcG9zICs9IGxlbkxlbjtcbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoIDwgMTI4KVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmRlY29kZShsb25nKTogbm90IG1pbmltYWwgZW5jb2RpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHYgPSBkYXRhLnN1YmFycmF5KHBvcywgcG9zICsgbGVuZ3RoKTtcbiAgICAgICAgICAgIGlmICh2Lmxlbmd0aCAhPT0gbGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZGVjb2RlOiB3cm9uZyB2YWx1ZSBsZW5ndGgnKTtcbiAgICAgICAgICAgIHJldHVybiB7IHYsIGw6IGRhdGEuc3ViYXJyYXkocG9zICsgbGVuZ3RoKSB9O1xuICAgICAgICB9LFxuICAgIH0sXG4gICAgLy8gaHR0cHM6Ly9jcnlwdG8uc3RhY2tleGNoYW5nZS5jb20vYS81NzczNCBMZWZ0bW9zdCBiaXQgb2YgZmlyc3QgYnl0ZSBpcyAnbmVnYXRpdmUnIGZsYWcsXG4gICAgLy8gc2luY2Ugd2UgYWx3YXlzIHVzZSBwb3NpdGl2ZSBpbnRlZ2VycyBoZXJlLiBJdCBtdXN0IGFsd2F5cyBiZSBlbXB0eTpcbiAgICAvLyAtIGFkZCB6ZXJvIGJ5dGUgaWYgZXhpc3RzXG4gICAgLy8gLSBpZiBuZXh0IGJ5dGUgZG9lc24ndCBoYXZlIGEgZmxhZywgbGVhZGluZyB6ZXJvIGlzIG5vdCBhbGxvd2VkIChtaW5pbWFsIGVuY29kaW5nKVxuICAgIF9pbnQ6IHtcbiAgICAgICAgZW5jb2RlKG51bSkge1xuICAgICAgICAgICAgY29uc3QgeyBFcnI6IEUgfSA9IERFUjtcbiAgICAgICAgICAgIGlmIChudW0gPCBfMG4pXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ2ludGVnZXI6IG5lZ2F0aXZlIGludGVnZXJzIGFyZSBub3QgYWxsb3dlZCcpO1xuICAgICAgICAgICAgbGV0IGhleCA9IG51bWJlclRvSGV4VW5wYWRkZWQobnVtKTtcbiAgICAgICAgICAgIC8vIFBhZCB3aXRoIHplcm8gYnl0ZSBpZiBuZWdhdGl2ZSBmbGFnIGlzIHByZXNlbnRcbiAgICAgICAgICAgIGlmIChOdW1iZXIucGFyc2VJbnQoaGV4WzBdLCAxNikgJiAwYjEwMDApXG4gICAgICAgICAgICAgICAgaGV4ID0gJzAwJyArIGhleDtcbiAgICAgICAgICAgIGlmIChoZXgubGVuZ3RoICYgMSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndW5leHBlY3RlZCBERVIgcGFyc2luZyBhc3NlcnRpb246IHVucGFkZGVkIGhleCcpO1xuICAgICAgICAgICAgcmV0dXJuIGhleDtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlKGRhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgRXJyOiBFIH0gPSBERVI7XG4gICAgICAgICAgICBpZiAoZGF0YVswXSAmIDEyOClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgnaW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogbmVnYXRpdmUnKTtcbiAgICAgICAgICAgIGlmIChkYXRhWzBdID09PSAweDAwICYmICEoZGF0YVsxXSAmIDEyOCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ2ludmFsaWQgc2lnbmF0dXJlIGludGVnZXI6IHVubmVjZXNzYXJ5IGxlYWRpbmcgemVybycpO1xuICAgICAgICAgICAgcmV0dXJuIGJ5dGVzVG9OdW1iZXJCRShkYXRhKTtcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIHRvU2lnKGhleCkge1xuICAgICAgICAvLyBwYXJzZSBERVIgc2lnbmF0dXJlXG4gICAgICAgIGNvbnN0IHsgRXJyOiBFLCBfaW50OiBpbnQsIF90bHY6IHRsdiB9ID0gREVSO1xuICAgICAgICBjb25zdCBkYXRhID0gZW5zdXJlQnl0ZXMoJ3NpZ25hdHVyZScsIGhleCk7XG4gICAgICAgIGNvbnN0IHsgdjogc2VxQnl0ZXMsIGw6IHNlcUxlZnRCeXRlcyB9ID0gdGx2LmRlY29kZSgweDMwLCBkYXRhKTtcbiAgICAgICAgaWYgKHNlcUxlZnRCeXRlcy5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnaW52YWxpZCBzaWduYXR1cmU6IGxlZnQgYnl0ZXMgYWZ0ZXIgcGFyc2luZycpO1xuICAgICAgICBjb25zdCB7IHY6IHJCeXRlcywgbDogckxlZnRCeXRlcyB9ID0gdGx2LmRlY29kZSgweDAyLCBzZXFCeXRlcyk7XG4gICAgICAgIGNvbnN0IHsgdjogc0J5dGVzLCBsOiBzTGVmdEJ5dGVzIH0gPSB0bHYuZGVjb2RlKDB4MDIsIHJMZWZ0Qnl0ZXMpO1xuICAgICAgICBpZiAoc0xlZnRCeXRlcy5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnaW52YWxpZCBzaWduYXR1cmU6IGxlZnQgYnl0ZXMgYWZ0ZXIgcGFyc2luZycpO1xuICAgICAgICByZXR1cm4geyByOiBpbnQuZGVjb2RlKHJCeXRlcyksIHM6IGludC5kZWNvZGUoc0J5dGVzKSB9O1xuICAgIH0sXG4gICAgaGV4RnJvbVNpZyhzaWcpIHtcbiAgICAgICAgY29uc3QgeyBfdGx2OiB0bHYsIF9pbnQ6IGludCB9ID0gREVSO1xuICAgICAgICBjb25zdCBycyA9IHRsdi5lbmNvZGUoMHgwMiwgaW50LmVuY29kZShzaWcucikpO1xuICAgICAgICBjb25zdCBzcyA9IHRsdi5lbmNvZGUoMHgwMiwgaW50LmVuY29kZShzaWcucykpO1xuICAgICAgICBjb25zdCBzZXEgPSBycyArIHNzO1xuICAgICAgICByZXR1cm4gdGx2LmVuY29kZSgweDMwLCBzZXEpO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gbnVtVG9TaXplZEhleChudW0sIHNpemUpIHtcbiAgICByZXR1cm4gYnl0ZXNUb0hleChudW1iZXJUb0J5dGVzQkUobnVtLCBzaXplKSk7XG59XG4vLyBCZSBmcmllbmRseSB0byBiYWQgRUNNQVNjcmlwdCBwYXJzZXJzIGJ5IG5vdCB1c2luZyBiaWdpbnQgbGl0ZXJhbHNcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzBuID0gQmlnSW50KDApLCBfMW4gPSBCaWdJbnQoMSksIF8ybiA9IEJpZ0ludCgyKSwgXzNuID0gQmlnSW50KDMpLCBfNG4gPSBCaWdJbnQoNCk7XG5leHBvcnQgZnVuY3Rpb24gd2VpZXJzdHJhc3NQb2ludHMob3B0cykge1xuICAgIGNvbnN0IENVUlZFID0gdmFsaWRhdGVQb2ludE9wdHMob3B0cyk7XG4gICAgY29uc3QgeyBGcCB9ID0gQ1VSVkU7IC8vIEFsbCBjdXJ2ZXMgaGFzIHNhbWUgZmllbGQgLyBncm91cCBsZW5ndGggYXMgZm9yIG5vdywgYnV0IHRoZXkgY2FuIGRpZmZlclxuICAgIGNvbnN0IEZuID0gRmllbGQoQ1VSVkUubiwgQ1VSVkUubkJpdExlbmd0aCk7XG4gICAgY29uc3QgdG9CeXRlcyA9IENVUlZFLnRvQnl0ZXMgfHxcbiAgICAgICAgKChfYywgcG9pbnQsIF9pc0NvbXByZXNzZWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBwb2ludC50b0FmZmluZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbmNhdEJ5dGVzKFVpbnQ4QXJyYXkuZnJvbShbMHgwNF0pLCBGcC50b0J5dGVzKGEueCksIEZwLnRvQnl0ZXMoYS55KSk7XG4gICAgICAgIH0pO1xuICAgIGNvbnN0IGZyb21CeXRlcyA9IENVUlZFLmZyb21CeXRlcyB8fFxuICAgICAgICAoKGJ5dGVzKSA9PiB7XG4gICAgICAgICAgICAvLyBjb25zdCBoZWFkID0gYnl0ZXNbMF07XG4gICAgICAgICAgICBjb25zdCB0YWlsID0gYnl0ZXMuc3ViYXJyYXkoMSk7XG4gICAgICAgICAgICAvLyBpZiAoaGVhZCAhPT0gMHgwNCkgdGhyb3cgbmV3IEVycm9yKCdPbmx5IG5vbi1jb21wcmVzc2VkIGVuY29kaW5nIGlzIHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgY29uc3QgeCA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KDAsIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICBjb25zdCB5ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoRnAuQllURVMsIDIgKiBGcC5CWVRFUykpO1xuICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgICAgICB9KTtcbiAgICAvKipcbiAgICAgKiB5wrIgPSB4wrMgKyBheCArIGI6IFNob3J0IHdlaWVyc3RyYXNzIGN1cnZlIGZvcm11bGEuIFRha2VzIHgsIHJldHVybnMgecKyLlxuICAgICAqIEByZXR1cm5zIHnCslxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdlaWVyc3RyYXNzRXF1YXRpb24oeCkge1xuICAgICAgICBjb25zdCB7IGEsIGIgfSA9IENVUlZFO1xuICAgICAgICBjb25zdCB4MiA9IEZwLnNxcih4KTsgLy8geCAqIHhcbiAgICAgICAgY29uc3QgeDMgPSBGcC5tdWwoeDIsIHgpOyAvLyB4wrIgKiB4XG4gICAgICAgIHJldHVybiBGcC5hZGQoRnAuYWRkKHgzLCBGcC5tdWwoeCwgYSkpLCBiKTsgLy8geMKzICsgYSAqIHggKyBiXG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzVmFsaWRYWSh4LCB5KSB7XG4gICAgICAgIGNvbnN0IGxlZnQgPSBGcC5zcXIoeSk7IC8vIHnCslxuICAgICAgICBjb25zdCByaWdodCA9IHdlaWVyc3RyYXNzRXF1YXRpb24oeCk7IC8vIHjCsyArIGF4ICsgYlxuICAgICAgICByZXR1cm4gRnAuZXFsKGxlZnQsIHJpZ2h0KTtcbiAgICB9XG4gICAgLy8gVmFsaWRhdGUgd2hldGhlciB0aGUgcGFzc2VkIGN1cnZlIHBhcmFtcyBhcmUgdmFsaWQuXG4gICAgLy8gVGVzdCAxOiBlcXVhdGlvbiB5wrIgPSB4wrMgKyBheCArIGIgc2hvdWxkIHdvcmsgZm9yIGdlbmVyYXRvciBwb2ludC5cbiAgICBpZiAoIWlzVmFsaWRYWShDVVJWRS5HeCwgQ1VSVkUuR3kpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBjdXJ2ZSBwYXJhbXM6IGdlbmVyYXRvciBwb2ludCcpO1xuICAgIC8vIFRlc3QgMjogZGlzY3JpbWluYW50IM6UIHBhcnQgc2hvdWxkIGJlIG5vbi16ZXJvOiA0YcKzICsgMjdiwrIgIT0gMC5cbiAgICAvLyBHdWFyYW50ZWVzIGN1cnZlIGlzIGdlbnVzLTEsIHNtb290aCAobm9uLXNpbmd1bGFyKS5cbiAgICBjb25zdCBfNGEzID0gRnAubXVsKEZwLnBvdyhDVVJWRS5hLCBfM24pLCBfNG4pO1xuICAgIGNvbnN0IF8yN2IyID0gRnAubXVsKEZwLnNxcihDVVJWRS5iKSwgQmlnSW50KDI3KSk7XG4gICAgaWYgKEZwLmlzMChGcC5hZGQoXzRhMywgXzI3YjIpKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgY3VydmUgcGFyYW1zOiBhIG9yIGInKTtcbiAgICAvLyBWYWxpZCBncm91cCBlbGVtZW50cyByZXNpZGUgaW4gcmFuZ2UgMS4ubi0xXG4gICAgZnVuY3Rpb24gaXNXaXRoaW5DdXJ2ZU9yZGVyKG51bSkge1xuICAgICAgICByZXR1cm4gaW5SYW5nZShudW0sIF8xbiwgQ1VSVkUubik7XG4gICAgfVxuICAgIC8vIFZhbGlkYXRlcyBpZiBwcml2IGtleSBpcyB2YWxpZCBhbmQgY29udmVydHMgaXQgdG8gYmlnaW50LlxuICAgIC8vIFN1cHBvcnRzIG9wdGlvbnMgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzIGFuZCB3cmFwUHJpdmF0ZUtleS5cbiAgICBmdW5jdGlvbiBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKGtleSkge1xuICAgICAgICBjb25zdCB7IGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RoczogbGVuZ3RocywgbkJ5dGVMZW5ndGgsIHdyYXBQcml2YXRlS2V5LCBuOiBOIH0gPSBDVVJWRTtcbiAgICAgICAgaWYgKGxlbmd0aHMgJiYgdHlwZW9mIGtleSAhPT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgIGlmIChpc0J5dGVzKGtleSkpXG4gICAgICAgICAgICAgICAga2V5ID0gYnl0ZXNUb0hleChrZXkpO1xuICAgICAgICAgICAgLy8gTm9ybWFsaXplIHRvIGhleCBzdHJpbmcsIHBhZC4gRS5nLiBQNTIxIHdvdWxkIG5vcm0gMTMwLTEzMiBjaGFyIGhleCB0byAxMzItY2hhciBieXRlc1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnIHx8ICFsZW5ndGhzLmluY2x1ZGVzKGtleS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwcml2YXRlIGtleScpO1xuICAgICAgICAgICAga2V5ID0ga2V5LnBhZFN0YXJ0KG5CeXRlTGVuZ3RoICogMiwgJzAnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbnVtO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbnVtID1cbiAgICAgICAgICAgICAgICB0eXBlb2Yga2V5ID09PSAnYmlnaW50J1xuICAgICAgICAgICAgICAgICAgICA/IGtleVxuICAgICAgICAgICAgICAgICAgICA6IGJ5dGVzVG9OdW1iZXJCRShlbnN1cmVCeXRlcygncHJpdmF0ZSBrZXknLCBrZXksIG5CeXRlTGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcHJpdmF0ZSBrZXksIGV4cGVjdGVkIGhleCBvciAnICsgbkJ5dGVMZW5ndGggKyAnIGJ5dGVzLCBnb3QgJyArIHR5cGVvZiBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3cmFwUHJpdmF0ZUtleSlcbiAgICAgICAgICAgIG51bSA9IG1vZChudW0sIE4pOyAvLyBkaXNhYmxlZCBieSBkZWZhdWx0LCBlbmFibGVkIGZvciBCTFNcbiAgICAgICAgYUluUmFuZ2UoJ3ByaXZhdGUga2V5JywgbnVtLCBfMW4sIE4pOyAvLyBudW0gaW4gcmFuZ2UgWzEuLk4tMV1cbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXByanBvaW50KG90aGVyKSB7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgUG9pbnQpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9qZWN0aXZlUG9pbnQgZXhwZWN0ZWQnKTtcbiAgICB9XG4gICAgLy8gTWVtb2l6ZWQgdG9BZmZpbmUgLyB2YWxpZGl0eSBjaGVjay4gVGhleSBhcmUgaGVhdnkuIFBvaW50cyBhcmUgaW1tdXRhYmxlLlxuICAgIC8vIENvbnZlcnRzIFByb2plY3RpdmUgcG9pbnQgdG8gYWZmaW5lICh4LCB5KSBjb29yZGluYXRlcy5cbiAgICAvLyBDYW4gYWNjZXB0IHByZWNvbXB1dGVkIFpeLTEgLSBmb3IgZXhhbXBsZSwgZnJvbSBpbnZlcnRCYXRjaC5cbiAgICAvLyAoWCwgWSwgWikg4oiLICh4PVgvWiwgeT1ZL1opXG4gICAgY29uc3QgdG9BZmZpbmVNZW1vID0gbWVtb2l6ZWQoKHAsIGl6KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcHg6IHgsIHB5OiB5LCBwejogeiB9ID0gcDtcbiAgICAgICAgLy8gRmFzdC1wYXRoIGZvciBub3JtYWxpemVkIHBvaW50c1xuICAgICAgICBpZiAoRnAuZXFsKHosIEZwLk9ORSkpXG4gICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgIGNvbnN0IGlzMCA9IHAuaXMwKCk7XG4gICAgICAgIC8vIElmIGludlogd2FzIDAsIHdlIHJldHVybiB6ZXJvIHBvaW50LiBIb3dldmVyIHdlIHN0aWxsIHdhbnQgdG8gZXhlY3V0ZVxuICAgICAgICAvLyBhbGwgb3BlcmF0aW9ucywgc28gd2UgcmVwbGFjZSBpbnZaIHdpdGggYSByYW5kb20gbnVtYmVyLCAxLlxuICAgICAgICBpZiAoaXogPT0gbnVsbClcbiAgICAgICAgICAgIGl6ID0gaXMwID8gRnAuT05FIDogRnAuaW52KHopO1xuICAgICAgICBjb25zdCBheCA9IEZwLm11bCh4LCBpeik7XG4gICAgICAgIGNvbnN0IGF5ID0gRnAubXVsKHksIGl6KTtcbiAgICAgICAgY29uc3QgenogPSBGcC5tdWwoeiwgaXopO1xuICAgICAgICBpZiAoaXMwKVxuICAgICAgICAgICAgcmV0dXJuIHsgeDogRnAuWkVSTywgeTogRnAuWkVSTyB9O1xuICAgICAgICBpZiAoIUZwLmVxbCh6eiwgRnAuT05FKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52WiB3YXMgaW52YWxpZCcpO1xuICAgICAgICByZXR1cm4geyB4OiBheCwgeTogYXkgfTtcbiAgICB9KTtcbiAgICAvLyBOT1RFOiBvbiBleGNlcHRpb24gdGhpcyB3aWxsIGNyYXNoICdjYWNoZWQnIGFuZCBubyB2YWx1ZSB3aWxsIGJlIHNldC5cbiAgICAvLyBPdGhlcndpc2UgdHJ1ZSB3aWxsIGJlIHJldHVyblxuICAgIGNvbnN0IGFzc2VydFZhbGlkTWVtbyA9IG1lbW9pemVkKChwKSA9PiB7XG4gICAgICAgIGlmIChwLmlzMCgpKSB7XG4gICAgICAgICAgICAvLyAoMCwgMSwgMCkgYWthIFpFUk8gaXMgaW52YWxpZCBpbiBtb3N0IGNvbnRleHRzLlxuICAgICAgICAgICAgLy8gSW4gQkxTLCBaRVJPIGNhbiBiZSBzZXJpYWxpemVkLCBzbyB3ZSBhbGxvdyBpdC5cbiAgICAgICAgICAgIC8vICgwLCAwLCAwKSBpcyBpbnZhbGlkIHJlcHJlc2VudGF0aW9uIG9mIFpFUk8uXG4gICAgICAgICAgICBpZiAoQ1VSVkUuYWxsb3dJbmZpbml0eVBvaW50ICYmICFGcC5pczAocC5weSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IFpFUk8nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTb21lIDNyZC1wYXJ0eSB0ZXN0IHZlY3RvcnMgcmVxdWlyZSBkaWZmZXJlbnQgd29yZGluZyBiZXR3ZWVuIGhlcmUgJiBgZnJvbUNvbXByZXNzZWRIZXhgXG4gICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gcC50b0FmZmluZSgpO1xuICAgICAgICAvLyBDaGVjayBpZiB4LCB5IGFyZSB2YWxpZCBmaWVsZCBlbGVtZW50c1xuICAgICAgICBpZiAoIUZwLmlzVmFsaWQoeCkgfHwgIUZwLmlzVmFsaWQoeSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogeCBvciB5IG5vdCBGRScpO1xuICAgICAgICBpZiAoIWlzVmFsaWRYWSh4LCB5KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBlcXVhdGlvbiBsZWZ0ICE9IHJpZ2h0Jyk7XG4gICAgICAgIGlmICghcC5pc1RvcnNpb25GcmVlKCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogbm90IGluIHByaW1lLW9yZGVyIHN1Ymdyb3VwJyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFByb2plY3RpdmUgUG9pbnQgd29ya3MgaW4gM2QgLyBwcm9qZWN0aXZlIChob21vZ2VuZW91cykgY29vcmRpbmF0ZXM6IChYLCBZLCBaKSDiiIsgKHg9WC9aLCB5PVkvWilcbiAgICAgKiBEZWZhdWx0IFBvaW50IHdvcmtzIGluIDJkIC8gYWZmaW5lIGNvb3JkaW5hdGVzOiAoeCwgeSlcbiAgICAgKiBXZSdyZSBkb2luZyBjYWxjdWxhdGlvbnMgaW4gcHJvamVjdGl2ZSwgYmVjYXVzZSBpdHMgb3BlcmF0aW9ucyBkb24ndCByZXF1aXJlIGNvc3RseSBpbnZlcnNpb24uXG4gICAgICovXG4gICAgY2xhc3MgUG9pbnQge1xuICAgICAgICBjb25zdHJ1Y3RvcihweCwgcHksIHB6KSB7XG4gICAgICAgICAgICBpZiAocHggPT0gbnVsbCB8fCAhRnAuaXNWYWxpZChweCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd4IHJlcXVpcmVkJyk7XG4gICAgICAgICAgICBpZiAocHkgPT0gbnVsbCB8fCAhRnAuaXNWYWxpZChweSkgfHwgRnAuaXMwKHB5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3kgcmVxdWlyZWQnKTtcbiAgICAgICAgICAgIGlmIChweiA9PSBudWxsIHx8ICFGcC5pc1ZhbGlkKHB6KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ogcmVxdWlyZWQnKTtcbiAgICAgICAgICAgIHRoaXMucHggPSBweDtcbiAgICAgICAgICAgIHRoaXMucHkgPSBweTtcbiAgICAgICAgICAgIHRoaXMucHogPSBwejtcbiAgICAgICAgICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG9lcyBub3QgdmFsaWRhdGUgaWYgdGhlIHBvaW50IGlzIG9uLWN1cnZlLlxuICAgICAgICAvLyBVc2UgZnJvbUhleCBpbnN0ZWFkLCBvciBjYWxsIGFzc2VydFZhbGlkaXR5KCkgbGF0ZXIuXG4gICAgICAgIHN0YXRpYyBmcm9tQWZmaW5lKHApIHtcbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gcCB8fCB7fTtcbiAgICAgICAgICAgIGlmICghcCB8fCAhRnAuaXNWYWxpZCh4KSB8fCAhRnAuaXNWYWxpZCh5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYWZmaW5lIHBvaW50Jyk7XG4gICAgICAgICAgICBpZiAocCBpbnN0YW5jZW9mIFBvaW50KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncHJvamVjdGl2ZSBwb2ludCBub3QgYWxsb3dlZCcpO1xuICAgICAgICAgICAgY29uc3QgaXMwID0gKGkpID0+IEZwLmVxbChpLCBGcC5aRVJPKTtcbiAgICAgICAgICAgIC8vIGZyb21BZmZpbmUoeDowLCB5OjApIHdvdWxkIHByb2R1Y2UgKHg6MCwgeTowLCB6OjEpLCBidXQgd2UgbmVlZCAoeDowLCB5OjEsIHo6MClcbiAgICAgICAgICAgIGlmIChpczAoeCkgJiYgaXMwKHkpKVxuICAgICAgICAgICAgICAgIHJldHVybiBQb2ludC5aRVJPO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh4LCB5LCBGcC5PTkUpO1xuICAgICAgICB9XG4gICAgICAgIGdldCB4KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9BZmZpbmUoKS54O1xuICAgICAgICB9XG4gICAgICAgIGdldCB5KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9BZmZpbmUoKS55O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUYWtlcyBhIGJ1bmNoIG9mIFByb2plY3RpdmUgUG9pbnRzIGJ1dCBleGVjdXRlcyBvbmx5IG9uZVxuICAgICAgICAgKiBpbnZlcnNpb24gb24gYWxsIG9mIHRoZW0uIEludmVyc2lvbiBpcyB2ZXJ5IHNsb3cgb3BlcmF0aW9uLFxuICAgICAgICAgKiBzbyB0aGlzIGltcHJvdmVzIHBlcmZvcm1hbmNlIG1hc3NpdmVseS5cbiAgICAgICAgICogT3B0aW1pemF0aW9uOiBjb252ZXJ0cyBhIGxpc3Qgb2YgcHJvamVjdGl2ZSBwb2ludHMgdG8gYSBsaXN0IG9mIGlkZW50aWNhbCBwb2ludHMgd2l0aCBaPTEuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgbm9ybWFsaXplWihwb2ludHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvSW52ID0gRnBJbnZlcnRCYXRjaChGcCwgcG9pbnRzLm1hcCgocCkgPT4gcC5weikpO1xuICAgICAgICAgICAgcmV0dXJuIHBvaW50cy5tYXAoKHAsIGkpID0+IHAudG9BZmZpbmUodG9JbnZbaV0pKS5tYXAoUG9pbnQuZnJvbUFmZmluZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIGhhc2ggc3RyaW5nIG9yIFVpbnQ4QXJyYXkgdG8gUG9pbnQuXG4gICAgICAgICAqIEBwYXJhbSBoZXggc2hvcnQvbG9uZyBFQ0RTQSBoZXhcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBmcm9tSGV4KGhleCkge1xuICAgICAgICAgICAgY29uc3QgUCA9IFBvaW50LmZyb21BZmZpbmUoZnJvbUJ5dGVzKGVuc3VyZUJ5dGVzKCdwb2ludEhleCcsIGhleCkpKTtcbiAgICAgICAgICAgIFAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiBQO1xuICAgICAgICB9XG4gICAgICAgIC8vIE11bHRpcGxpZXMgZ2VuZXJhdG9yIHBvaW50IGJ5IHByaXZhdGVLZXkuXG4gICAgICAgIHN0YXRpYyBmcm9tUHJpdmF0ZUtleShwcml2YXRlS2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gUG9pbnQuQkFTRS5tdWx0aXBseShub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVLZXkpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNdWx0aXNjYWxhciBNdWx0aXBsaWNhdGlvblxuICAgICAgICBzdGF0aWMgbXNtKHBvaW50cywgc2NhbGFycykge1xuICAgICAgICAgICAgcmV0dXJuIHBpcHBlbmdlcihQb2ludCwgRm4sIHBvaW50cywgc2NhbGFycyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gXCJQcml2YXRlIG1ldGhvZFwiLCBkb24ndCB1c2UgaXQgZGlyZWN0bHlcbiAgICAgICAgX3NldFdpbmRvd1NpemUod2luZG93U2l6ZSkge1xuICAgICAgICAgICAgd25hZi5zZXRXaW5kb3dTaXplKHRoaXMsIHdpbmRvd1NpemUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEEgcG9pbnQgb24gY3VydmUgaXMgdmFsaWQgaWYgaXQgY29uZm9ybXMgdG8gZXF1YXRpb24uXG4gICAgICAgIGFzc2VydFZhbGlkaXR5KCkge1xuICAgICAgICAgICAgYXNzZXJ0VmFsaWRNZW1vKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGhhc0V2ZW5ZKCkge1xuICAgICAgICAgICAgY29uc3QgeyB5IH0gPSB0aGlzLnRvQWZmaW5lKCk7XG4gICAgICAgICAgICBpZiAoRnAuaXNPZGQpXG4gICAgICAgICAgICAgICAgcmV0dXJuICFGcC5pc09kZCh5KTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZpZWxkIGRvZXNuJ3Qgc3VwcG9ydCBpc09kZFwiKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ29tcGFyZSBvbmUgcG9pbnQgdG8gYW5vdGhlci5cbiAgICAgICAgICovXG4gICAgICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICAgICAgYXByanBvaW50KG90aGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgyLCBweTogWTIsIHB6OiBaMiB9ID0gb3RoZXI7XG4gICAgICAgICAgICBjb25zdCBVMSA9IEZwLmVxbChGcC5tdWwoWDEsIFoyKSwgRnAubXVsKFgyLCBaMSkpO1xuICAgICAgICAgICAgY29uc3QgVTIgPSBGcC5lcWwoRnAubXVsKFkxLCBaMiksIEZwLm11bChZMiwgWjEpKTtcbiAgICAgICAgICAgIHJldHVybiBVMSAmJiBVMjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRmxpcHMgcG9pbnQgdG8gb25lIGNvcnJlc3BvbmRpbmcgdG8gKHgsIC15KSBpbiBBZmZpbmUgY29vcmRpbmF0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBuZWdhdGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMucHgsIEZwLm5lZyh0aGlzLnB5KSwgdGhpcy5weik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVuZXMtQ29zdGVsbG8tQmF0aW5hIGV4Y2VwdGlvbi1mcmVlIGRvdWJsaW5nIGZvcm11bGEuXG4gICAgICAgIC8vIFRoZXJlIGlzIDMwJSBmYXN0ZXIgSmFjb2JpYW4gZm9ybXVsYSwgYnV0IGl0IGlzIG5vdCBjb21wbGV0ZS5cbiAgICAgICAgLy8gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxNS8xMDYwLCBhbGdvcml0aG0gM1xuICAgICAgICAvLyBDb3N0OiA4TSArIDNTICsgMyphICsgMipiMyArIDE1YWRkLlxuICAgICAgICBkb3VibGUoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGEsIGIgfSA9IENVUlZFO1xuICAgICAgICAgICAgY29uc3QgYjMgPSBGcC5tdWwoYiwgXzNuKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGxldCBYMyA9IEZwLlpFUk8sIFkzID0gRnAuWkVSTywgWjMgPSBGcC5aRVJPOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGxldCB0MCA9IEZwLm11bChYMSwgWDEpOyAvLyBzdGVwIDFcbiAgICAgICAgICAgIGxldCB0MSA9IEZwLm11bChZMSwgWTEpO1xuICAgICAgICAgICAgbGV0IHQyID0gRnAubXVsKFoxLCBaMSk7XG4gICAgICAgICAgICBsZXQgdDMgPSBGcC5tdWwoWDEsIFkxKTtcbiAgICAgICAgICAgIHQzID0gRnAuYWRkKHQzLCB0Myk7IC8vIHN0ZXAgNVxuICAgICAgICAgICAgWjMgPSBGcC5tdWwoWDEsIFoxKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCBaMyk7XG4gICAgICAgICAgICBYMyA9IEZwLm11bChhLCBaMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChiMywgdDIpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWDMsIFkzKTsgLy8gc3RlcCAxMFxuICAgICAgICAgICAgWDMgPSBGcC5zdWIodDEsIFkzKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKHQxLCBZMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChYMywgWTMpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwodDMsIFgzKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKGIzLCBaMyk7IC8vIHN0ZXAgMTVcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQzID0gRnAuc3ViKHQwLCB0Mik7XG4gICAgICAgICAgICB0MyA9IEZwLm11bChhLCB0Myk7XG4gICAgICAgICAgICB0MyA9IEZwLmFkZCh0MywgWjMpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQodDAsIHQwKTsgLy8gc3RlcCAyMFxuICAgICAgICAgICAgdDAgPSBGcC5hZGQoWjMsIHQwKTtcbiAgICAgICAgICAgIHQwID0gRnAuYWRkKHQwLCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MCwgdDMpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWTMsIHQwKTtcbiAgICAgICAgICAgIHQyID0gRnAubXVsKFkxLCBaMSk7IC8vIHN0ZXAgMjVcbiAgICAgICAgICAgIHQyID0gRnAuYWRkKHQyLCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MiwgdDMpO1xuICAgICAgICAgICAgWDMgPSBGcC5zdWIoWDMsIHQwKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKHQyLCB0MSk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpOyAvLyBzdGVwIDMwXG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW5lcy1Db3N0ZWxsby1CYXRpbmEgZXhjZXB0aW9uLWZyZWUgYWRkaXRpb24gZm9ybXVsYS5cbiAgICAgICAgLy8gVGhlcmUgaXMgMzAlIGZhc3RlciBKYWNvYmlhbiBmb3JtdWxhLCBidXQgaXQgaXMgbm90IGNvbXBsZXRlLlxuICAgICAgICAvLyBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDE1LzEwNjAsIGFsZ29yaXRobSAxXG4gICAgICAgIC8vIENvc3Q6IDEyTSArIDBTICsgMyphICsgMypiMyArIDIzYWRkLlxuICAgICAgICBhZGQob3RoZXIpIHtcbiAgICAgICAgICAgIGFwcmpwb2ludChvdGhlcik7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMiwgcHk6IFkyLCBwejogWjIgfSA9IG90aGVyO1xuICAgICAgICAgICAgbGV0IFgzID0gRnAuWkVSTywgWTMgPSBGcC5aRVJPLCBaMyA9IEZwLlpFUk87IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgYSA9IENVUlZFLmE7XG4gICAgICAgICAgICBjb25zdCBiMyA9IEZwLm11bChDVVJWRS5iLCBfM24pO1xuICAgICAgICAgICAgbGV0IHQwID0gRnAubXVsKFgxLCBYMik7IC8vIHN0ZXAgMVxuICAgICAgICAgICAgbGV0IHQxID0gRnAubXVsKFkxLCBZMik7XG4gICAgICAgICAgICBsZXQgdDIgPSBGcC5tdWwoWjEsIFoyKTtcbiAgICAgICAgICAgIGxldCB0MyA9IEZwLmFkZChYMSwgWTEpO1xuICAgICAgICAgICAgbGV0IHQ0ID0gRnAuYWRkKFgyLCBZMik7IC8vIHN0ZXAgNVxuICAgICAgICAgICAgdDMgPSBGcC5tdWwodDMsIHQ0KTtcbiAgICAgICAgICAgIHQ0ID0gRnAuYWRkKHQwLCB0MSk7XG4gICAgICAgICAgICB0MyA9IEZwLnN1Yih0MywgdDQpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQoWDEsIFoxKTtcbiAgICAgICAgICAgIGxldCB0NSA9IEZwLmFkZChYMiwgWjIpOyAvLyBzdGVwIDEwXG4gICAgICAgICAgICB0NCA9IEZwLm11bCh0NCwgdDUpO1xuICAgICAgICAgICAgdDUgPSBGcC5hZGQodDAsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAuc3ViKHQ0LCB0NSk7XG4gICAgICAgICAgICB0NSA9IEZwLmFkZChZMSwgWjEpO1xuICAgICAgICAgICAgWDMgPSBGcC5hZGQoWTIsIFoyKTsgLy8gc3RlcCAxNVxuICAgICAgICAgICAgdDUgPSBGcC5tdWwodDUsIFgzKTtcbiAgICAgICAgICAgIFgzID0gRnAuYWRkKHQxLCB0Mik7XG4gICAgICAgICAgICB0NSA9IEZwLnN1Yih0NSwgWDMpO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwoYSwgdDQpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwoYjMsIHQyKTsgLy8gc3RlcCAyMFxuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWDMsIFozKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKHQxLCBaMyk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZCh0MSwgWjMpO1xuICAgICAgICAgICAgWTMgPSBGcC5tdWwoWDMsIFozKTtcbiAgICAgICAgICAgIHQxID0gRnAuYWRkKHQwLCB0MCk7IC8vIHN0ZXAgMjVcbiAgICAgICAgICAgIHQxID0gRnAuYWRkKHQxLCB0MCk7XG4gICAgICAgICAgICB0MiA9IEZwLm11bChhLCB0Mik7XG4gICAgICAgICAgICB0NCA9IEZwLm11bChiMywgdDQpO1xuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDEsIHQyKTtcbiAgICAgICAgICAgIHQyID0gRnAuc3ViKHQwLCB0Mik7IC8vIHN0ZXAgMzBcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAuYWRkKHQ0LCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MSwgdDQpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWTMsIHQwKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQ1LCB0NCk7IC8vIHN0ZXAgMzVcbiAgICAgICAgICAgIFgzID0gRnAubXVsKHQzLCBYMyk7XG4gICAgICAgICAgICBYMyA9IEZwLnN1YihYMywgdDApO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDMsIHQxKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKHQ1LCBaMyk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgdDApOyAvLyBzdGVwIDQwXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KFgzLCBZMywgWjMpO1xuICAgICAgICB9XG4gICAgICAgIHN1YnRyYWN0KG90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQob3RoZXIubmVnYXRlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlzMCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVxdWFscyhQb2ludC5aRVJPKTtcbiAgICAgICAgfVxuICAgICAgICB3TkFGKG4pIHtcbiAgICAgICAgICAgIHJldHVybiB3bmFmLndOQUZDYWNoZWQodGhpcywgbiwgUG9pbnQubm9ybWFsaXplWik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vbi1jb25zdGFudC10aW1lIG11bHRpcGxpY2F0aW9uLiBVc2VzIGRvdWJsZS1hbmQtYWRkIGFsZ29yaXRobS5cbiAgICAgICAgICogSXQncyBmYXN0ZXIsIGJ1dCBzaG91bGQgb25seSBiZSB1c2VkIHdoZW4geW91IGRvbid0IGNhcmUgYWJvdXRcbiAgICAgICAgICogYW4gZXhwb3NlZCBwcml2YXRlIGtleSBlLmcuIHNpZyB2ZXJpZmljYXRpb24sIHdoaWNoIHdvcmtzIG92ZXIgKnB1YmxpYyoga2V5cy5cbiAgICAgICAgICovXG4gICAgICAgIG11bHRpcGx5VW5zYWZlKHNjKSB7XG4gICAgICAgICAgICBjb25zdCB7IGVuZG8sIG46IE4gfSA9IENVUlZFO1xuICAgICAgICAgICAgYUluUmFuZ2UoJ3NjYWxhcicsIHNjLCBfMG4sIE4pO1xuICAgICAgICAgICAgY29uc3QgSSA9IFBvaW50LlpFUk87XG4gICAgICAgICAgICBpZiAoc2MgPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm4gSTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzMCgpIHx8IHNjID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAvLyBDYXNlIGE6IG5vIGVuZG9tb3JwaGlzbS4gQ2FzZSBiOiBoYXMgcHJlY29tcHV0ZXMuXG4gICAgICAgICAgICBpZiAoIWVuZG8gfHwgd25hZi5oYXNQcmVjb21wdXRlcyh0aGlzKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gd25hZi53TkFGQ2FjaGVkVW5zYWZlKHRoaXMsIHNjLCBQb2ludC5ub3JtYWxpemVaKTtcbiAgICAgICAgICAgIC8vIENhc2UgYzogZW5kb21vcnBoaXNtXG4gICAgICAgICAgICAvKiogU2VlIGRvY3MgZm9yIHtAbGluayBFbmRvbW9ycGhpc21PcHRzfSAqL1xuICAgICAgICAgICAgbGV0IHsgazFuZWcsIGsxLCBrMm5lZywgazIgfSA9IGVuZG8uc3BsaXRTY2FsYXIoc2MpO1xuICAgICAgICAgICAgbGV0IGsxcCA9IEk7XG4gICAgICAgICAgICBsZXQgazJwID0gSTtcbiAgICAgICAgICAgIGxldCBkID0gdGhpcztcbiAgICAgICAgICAgIHdoaWxlIChrMSA+IF8wbiB8fCBrMiA+IF8wbikge1xuICAgICAgICAgICAgICAgIGlmIChrMSAmIF8xbilcbiAgICAgICAgICAgICAgICAgICAgazFwID0gazFwLmFkZChkKTtcbiAgICAgICAgICAgICAgICBpZiAoazIgJiBfMW4pXG4gICAgICAgICAgICAgICAgICAgIGsycCA9IGsycC5hZGQoZCk7XG4gICAgICAgICAgICAgICAgZCA9IGQuZG91YmxlKCk7XG4gICAgICAgICAgICAgICAgazEgPj49IF8xbjtcbiAgICAgICAgICAgICAgICBrMiA+Pj0gXzFuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGsxbmVnKVxuICAgICAgICAgICAgICAgIGsxcCA9IGsxcC5uZWdhdGUoKTtcbiAgICAgICAgICAgIGlmIChrMm5lZylcbiAgICAgICAgICAgICAgICBrMnAgPSBrMnAubmVnYXRlKCk7XG4gICAgICAgICAgICBrMnAgPSBuZXcgUG9pbnQoRnAubXVsKGsycC5weCwgZW5kby5iZXRhKSwgazJwLnB5LCBrMnAucHopO1xuICAgICAgICAgICAgcmV0dXJuIGsxcC5hZGQoazJwKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RhbnQgdGltZSBtdWx0aXBsaWNhdGlvbi5cbiAgICAgICAgICogVXNlcyB3TkFGIG1ldGhvZC4gV2luZG93ZWQgbWV0aG9kIG1heSBiZSAxMCUgZmFzdGVyLFxuICAgICAgICAgKiBidXQgdGFrZXMgMnggbG9uZ2VyIHRvIGdlbmVyYXRlIGFuZCBjb25zdW1lcyAyeCBtZW1vcnkuXG4gICAgICAgICAqIFVzZXMgcHJlY29tcHV0ZXMgd2hlbiBhdmFpbGFibGUuXG4gICAgICAgICAqIFVzZXMgZW5kb21vcnBoaXNtIGZvciBLb2JsaXR6IGN1cnZlcy5cbiAgICAgICAgICogQHBhcmFtIHNjYWxhciBieSB3aGljaCB0aGUgcG9pbnQgd291bGQgYmUgbXVsdGlwbGllZFxuICAgICAgICAgKiBAcmV0dXJucyBOZXcgcG9pbnRcbiAgICAgICAgICovXG4gICAgICAgIG11bHRpcGx5KHNjYWxhcikge1xuICAgICAgICAgICAgY29uc3QgeyBlbmRvLCBuOiBOIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGFJblJhbmdlKCdzY2FsYXInLCBzY2FsYXIsIF8xbiwgTik7XG4gICAgICAgICAgICBsZXQgcG9pbnQsIGZha2U7IC8vIEZha2UgcG9pbnQgaXMgdXNlZCB0byBjb25zdC10aW1lIG11bHRcbiAgICAgICAgICAgIC8qKiBTZWUgZG9jcyBmb3Ige0BsaW5rIEVuZG9tb3JwaGlzbU9wdHN9ICovXG4gICAgICAgICAgICBpZiAoZW5kbykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgazFuZWcsIGsxLCBrMm5lZywgazIgfSA9IGVuZG8uc3BsaXRTY2FsYXIoc2NhbGFyKTtcbiAgICAgICAgICAgICAgICBsZXQgeyBwOiBrMXAsIGY6IGYxcCB9ID0gdGhpcy53TkFGKGsxKTtcbiAgICAgICAgICAgICAgICBsZXQgeyBwOiBrMnAsIGY6IGYycCB9ID0gdGhpcy53TkFGKGsyKTtcbiAgICAgICAgICAgICAgICBrMXAgPSB3bmFmLmNvbnN0VGltZU5lZ2F0ZShrMW5lZywgazFwKTtcbiAgICAgICAgICAgICAgICBrMnAgPSB3bmFmLmNvbnN0VGltZU5lZ2F0ZShrMm5lZywgazJwKTtcbiAgICAgICAgICAgICAgICBrMnAgPSBuZXcgUG9pbnQoRnAubXVsKGsycC5weCwgZW5kby5iZXRhKSwgazJwLnB5LCBrMnAucHopO1xuICAgICAgICAgICAgICAgIHBvaW50ID0gazFwLmFkZChrMnApO1xuICAgICAgICAgICAgICAgIGZha2UgPSBmMXAuYWRkKGYycCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHAsIGYgfSA9IHRoaXMud05BRihzY2FsYXIpO1xuICAgICAgICAgICAgICAgIHBvaW50ID0gcDtcbiAgICAgICAgICAgICAgICBmYWtlID0gZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSBgemAgZm9yIGJvdGggcG9pbnRzLCBidXQgcmV0dXJuIG9ubHkgcmVhbCBvbmVcbiAgICAgICAgICAgIHJldHVybiBQb2ludC5ub3JtYWxpemVaKFtwb2ludCwgZmFrZV0pWzBdO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFZmZpY2llbnRseSBjYWxjdWxhdGUgYGFQICsgYlFgLiBVbnNhZmUsIGNhbiBleHBvc2UgcHJpdmF0ZSBrZXksIGlmIHVzZWQgaW5jb3JyZWN0bHkuXG4gICAgICAgICAqIE5vdCB1c2luZyBTdHJhdXNzLVNoYW1pciB0cmljazogcHJlY29tcHV0YXRpb24gdGFibGVzIGFyZSBmYXN0ZXIuXG4gICAgICAgICAqIFRoZSB0cmljayBjb3VsZCBiZSB1c2VmdWwgaWYgYm90aCBQIGFuZCBRIGFyZSBub3QgRyAobm90IGluIG91ciBjYXNlKS5cbiAgICAgICAgICogQHJldHVybnMgbm9uLXplcm8gYWZmaW5lIHBvaW50XG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aXBseUFuZEFkZFVuc2FmZShRLCBhLCBiKSB7XG4gICAgICAgICAgICBjb25zdCBHID0gUG9pbnQuQkFTRTsgLy8gTm8gU3RyYXVzcy1TaGFtaXIgdHJpY2s6IHdlIGhhdmUgMTAlIGZhc3RlciBHIHByZWNvbXB1dGVzXG4gICAgICAgICAgICBjb25zdCBtdWwgPSAoUCwgYSAvLyBTZWxlY3QgZmFzdGVyIG11bHRpcGx5KCkgbWV0aG9kXG4gICAgICAgICAgICApID0+IChhID09PSBfMG4gfHwgYSA9PT0gXzFuIHx8ICFQLmVxdWFscyhHKSA/IFAubXVsdGlwbHlVbnNhZmUoYSkgOiBQLm11bHRpcGx5KGEpKTtcbiAgICAgICAgICAgIGNvbnN0IHN1bSA9IG11bCh0aGlzLCBhKS5hZGQobXVsKFEsIGIpKTtcbiAgICAgICAgICAgIHJldHVybiBzdW0uaXMwKCkgPyB1bmRlZmluZWQgOiBzdW07XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29udmVydHMgUHJvamVjdGl2ZSBwb2ludCB0byBhZmZpbmUgKHgsIHkpIGNvb3JkaW5hdGVzLlxuICAgICAgICAvLyBDYW4gYWNjZXB0IHByZWNvbXB1dGVkIFpeLTEgLSBmb3IgZXhhbXBsZSwgZnJvbSBpbnZlcnRCYXRjaC5cbiAgICAgICAgLy8gKHgsIHksIHopIOKIiyAoeD14L3osIHk9eS96KVxuICAgICAgICB0b0FmZmluZShpeikge1xuICAgICAgICAgICAgcmV0dXJuIHRvQWZmaW5lTWVtbyh0aGlzLCBpeik7XG4gICAgICAgIH1cbiAgICAgICAgaXNUb3JzaW9uRnJlZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaDogY29mYWN0b3IsIGlzVG9yc2lvbkZyZWUgfSA9IENVUlZFO1xuICAgICAgICAgICAgaWYgKGNvZmFjdG9yID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIE5vIHN1Ymdyb3VwcywgYWx3YXlzIHRvcnNpb24tZnJlZVxuICAgICAgICAgICAgaWYgKGlzVG9yc2lvbkZyZWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzVG9yc2lvbkZyZWUoUG9pbnQsIHRoaXMpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpc1RvcnNpb25GcmVlKCkgaGFzIG5vdCBiZWVuIGRlY2xhcmVkIGZvciB0aGUgZWxsaXB0aWMgY3VydmUnKTtcbiAgICAgICAgfVxuICAgICAgICBjbGVhckNvZmFjdG9yKCkge1xuICAgICAgICAgICAgY29uc3QgeyBoOiBjb2ZhY3RvciwgY2xlYXJDb2ZhY3RvciB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoY29mYWN0b3IgPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpczsgLy8gRmFzdC1wYXRoXG4gICAgICAgICAgICBpZiAoY2xlYXJDb2ZhY3RvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xlYXJDb2ZhY3RvcihQb2ludCwgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVVuc2FmZShDVVJWRS5oKTtcbiAgICAgICAgfVxuICAgICAgICB0b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgICAgIGFib29sKCdpc0NvbXByZXNzZWQnLCBpc0NvbXByZXNzZWQpO1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRvQnl0ZXMoUG9pbnQsIHRoaXMsIGlzQ29tcHJlc3NlZCk7XG4gICAgICAgIH1cbiAgICAgICAgdG9IZXgoaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICAgICAgYWJvb2woJ2lzQ29tcHJlc3NlZCcsIGlzQ29tcHJlc3NlZCk7XG4gICAgICAgICAgICByZXR1cm4gYnl0ZXNUb0hleCh0aGlzLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYmFzZSAvIGdlbmVyYXRvciBwb2ludFxuICAgIFBvaW50LkJBU0UgPSBuZXcgUG9pbnQoQ1VSVkUuR3gsIENVUlZFLkd5LCBGcC5PTkUpO1xuICAgIC8vIHplcm8gLyBpbmZpbml0eSAvIGlkZW50aXR5IHBvaW50XG4gICAgUG9pbnQuWkVSTyA9IG5ldyBQb2ludChGcC5aRVJPLCBGcC5PTkUsIEZwLlpFUk8pOyAvLyAwLCAxLCAwXG4gICAgY29uc3QgeyBlbmRvLCBuQml0TGVuZ3RoIH0gPSBDVVJWRTtcbiAgICBjb25zdCB3bmFmID0gd05BRihQb2ludCwgZW5kbyA/IE1hdGguY2VpbChuQml0TGVuZ3RoIC8gMikgOiBuQml0TGVuZ3RoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBDVVJWRSxcbiAgICAgICAgUHJvamVjdGl2ZVBvaW50OiBQb2ludCxcbiAgICAgICAgbm9ybVByaXZhdGVLZXlUb1NjYWxhcixcbiAgICAgICAgd2VpZXJzdHJhc3NFcXVhdGlvbixcbiAgICAgICAgaXNXaXRoaW5DdXJ2ZU9yZGVyLFxuICAgIH07XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU9wdHMoY3VydmUpIHtcbiAgICBjb25zdCBvcHRzID0gdmFsaWRhdGVCYXNpYyhjdXJ2ZSk7XG4gICAgdmFsaWRhdGVPYmplY3Qob3B0cywge1xuICAgICAgICBoYXNoOiAnaGFzaCcsXG4gICAgICAgIGhtYWM6ICdmdW5jdGlvbicsXG4gICAgICAgIHJhbmRvbUJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgIH0sIHtcbiAgICAgICAgYml0czJpbnQ6ICdmdW5jdGlvbicsXG4gICAgICAgIGJpdHMyaW50X21vZE46ICdmdW5jdGlvbicsXG4gICAgICAgIGxvd1M6ICdib29sZWFuJyxcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IGxvd1M6IHRydWUsIC4uLm9wdHMgfSk7XG59XG4vKipcbiAqIENyZWF0ZXMgc2hvcnQgd2VpZXJzdHJhc3MgY3VydmUgYW5kIEVDRFNBIHNpZ25hdHVyZSBtZXRob2RzIGZvciBpdC5cbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBGaWVsZCB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvYWJzdHJhY3QvbW9kdWxhcic7XG4gKiAvLyBCZWZvcmUgdGhhdCwgZGVmaW5lIEJpZ0ludC1zOiBhLCBiLCBwLCBuLCBHeCwgR3lcbiAqIGNvbnN0IGN1cnZlID0gd2VpZXJzdHJhc3MoeyBhLCBiLCBGcDogRmllbGQocCksIG4sIEd4LCBHeSwgaDogMW4gfSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdlaWVyc3RyYXNzKGN1cnZlRGVmKSB7XG4gICAgY29uc3QgQ1VSVkUgPSB2YWxpZGF0ZU9wdHMoY3VydmVEZWYpO1xuICAgIGNvbnN0IHsgRnAsIG46IENVUlZFX09SREVSLCBuQnl0ZUxlbmd0aCwgbkJpdExlbmd0aCB9ID0gQ1VSVkU7XG4gICAgY29uc3QgY29tcHJlc3NlZExlbiA9IEZwLkJZVEVTICsgMTsgLy8gZS5nLiAzMyBmb3IgMzJcbiAgICBjb25zdCB1bmNvbXByZXNzZWRMZW4gPSAyICogRnAuQllURVMgKyAxOyAvLyBlLmcuIDY1IGZvciAzMlxuICAgIGZ1bmN0aW9uIG1vZE4oYSkge1xuICAgICAgICByZXR1cm4gbW9kKGEsIENVUlZFX09SREVSKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW52TihhKSB7XG4gICAgICAgIHJldHVybiBpbnZlcnQoYSwgQ1VSVkVfT1JERVIpO1xuICAgIH1cbiAgICBjb25zdCB7IFByb2plY3RpdmVQb2ludDogUG9pbnQsIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIsIHdlaWVyc3RyYXNzRXF1YXRpb24sIGlzV2l0aGluQ3VydmVPcmRlciwgfSA9IHdlaWVyc3RyYXNzUG9pbnRzKHtcbiAgICAgICAgLi4uQ1VSVkUsXG4gICAgICAgIHRvQnl0ZXMoX2MsIHBvaW50LCBpc0NvbXByZXNzZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBwb2ludC50b0FmZmluZSgpO1xuICAgICAgICAgICAgY29uc3QgeCA9IEZwLnRvQnl0ZXMoYS54KTtcbiAgICAgICAgICAgIGNvbnN0IGNhdCA9IGNvbmNhdEJ5dGVzO1xuICAgICAgICAgICAgYWJvb2woJ2lzQ29tcHJlc3NlZCcsIGlzQ29tcHJlc3NlZCk7XG4gICAgICAgICAgICBpZiAoaXNDb21wcmVzc2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhdChVaW50OEFycmF5LmZyb20oW3BvaW50Lmhhc0V2ZW5ZKCkgPyAweDAyIDogMHgwM10pLCB4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYXQoVWludDhBcnJheS5mcm9tKFsweDA0XSksIHgsIEZwLnRvQnl0ZXMoYS55KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZyb21CeXRlcyhieXRlcykge1xuICAgICAgICAgICAgY29uc3QgbGVuID0gYnl0ZXMubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgaGVhZCA9IGJ5dGVzWzBdO1xuICAgICAgICAgICAgY29uc3QgdGFpbCA9IGJ5dGVzLnN1YmFycmF5KDEpO1xuICAgICAgICAgICAgLy8gdGhpcy5hc3NlcnRWYWxpZGl0eSgpIGlzIGRvbmUgaW5zaWRlIG9mIGZyb21IZXhcbiAgICAgICAgICAgIGlmIChsZW4gPT09IGNvbXByZXNzZWRMZW4gJiYgKGhlYWQgPT09IDB4MDIgfHwgaGVhZCA9PT0gMHgwMykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gYnl0ZXNUb051bWJlckJFKHRhaWwpO1xuICAgICAgICAgICAgICAgIGlmICghaW5SYW5nZSh4LCBfMW4sIEZwLk9SREVSKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb2ludCBpcyBub3Qgb24gY3VydmUnKTtcbiAgICAgICAgICAgICAgICBjb25zdCB5MiA9IHdlaWVyc3RyYXNzRXF1YXRpb24oeCk7IC8vIHnCsiA9IHjCsyArIGF4ICsgYlxuICAgICAgICAgICAgICAgIGxldCB5O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBGcC5zcXJ0KHkyKTsgLy8geSA9IHnCsiBeIChwKzEpLzRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKHNxcnRFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdWZmaXggPSBzcXJ0RXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/ICc6ICcgKyBzcXJ0RXJyb3IubWVzc2FnZSA6ICcnO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvaW50IGlzIG5vdCBvbiBjdXJ2ZScgKyBzdWZmaXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBpc1lPZGQgPSAoeSAmIF8xbikgPT09IF8xbjtcbiAgICAgICAgICAgICAgICAvLyBFQ0RTQVxuICAgICAgICAgICAgICAgIGNvbnN0IGlzSGVhZE9kZCA9IChoZWFkICYgMSkgPT09IDE7XG4gICAgICAgICAgICAgICAgaWYgKGlzSGVhZE9kZCAhPT0gaXNZT2RkKVxuICAgICAgICAgICAgICAgICAgICB5ID0gRnAubmVnKHkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxlbiA9PT0gdW5jb21wcmVzc2VkTGVuICYmIGhlYWQgPT09IDB4MDQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoMCwgRnAuQllURVMpKTtcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoRnAuQllURVMsIDIgKiBGcC5CWVRFUykpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsID0gY29tcHJlc3NlZExlbjtcbiAgICAgICAgICAgICAgICBjb25zdCB1bCA9IHVuY29tcHJlc3NlZExlbjtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgUG9pbnQsIGV4cGVjdGVkIGxlbmd0aCBvZiAnICsgY2wgKyAnLCBvciB1bmNvbXByZXNzZWQgJyArIHVsICsgJywgZ290ICcgKyBsZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihudW1iZXIpIHtcbiAgICAgICAgY29uc3QgSEFMRiA9IENVUlZFX09SREVSID4+IF8xbjtcbiAgICAgICAgcmV0dXJuIG51bWJlciA+IEhBTEY7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVMocykge1xuICAgICAgICByZXR1cm4gaXNCaWdnZXJUaGFuSGFsZk9yZGVyKHMpID8gbW9kTigtcykgOiBzO1xuICAgIH1cbiAgICAvLyBzbGljZSBieXRlcyBudW1cbiAgICBjb25zdCBzbGNOdW0gPSAoYiwgZnJvbSwgdG8pID0+IGJ5dGVzVG9OdW1iZXJCRShiLnNsaWNlKGZyb20sIHRvKSk7XG4gICAgLyoqXG4gICAgICogRUNEU0Egc2lnbmF0dXJlIHdpdGggaXRzIChyLCBzKSBwcm9wZXJ0aWVzLiBTdXBwb3J0cyBERVIgJiBjb21wYWN0IHJlcHJlc2VudGF0aW9ucy5cbiAgICAgKi9cbiAgICBjbGFzcyBTaWduYXR1cmUge1xuICAgICAgICBjb25zdHJ1Y3RvcihyLCBzLCByZWNvdmVyeSkge1xuICAgICAgICAgICAgYUluUmFuZ2UoJ3InLCByLCBfMW4sIENVUlZFX09SREVSKTsgLy8gciBpbiBbMS4uTl1cbiAgICAgICAgICAgIGFJblJhbmdlKCdzJywgcywgXzFuLCBDVVJWRV9PUkRFUik7IC8vIHMgaW4gWzEuLk5dXG4gICAgICAgICAgICB0aGlzLnIgPSByO1xuICAgICAgICAgICAgdGhpcy5zID0gcztcbiAgICAgICAgICAgIGlmIChyZWNvdmVyeSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHRoaXMucmVjb3ZlcnkgPSByZWNvdmVyeTtcbiAgICAgICAgICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcGFpciAoYnl0ZXMgb2YgciwgYnl0ZXMgb2YgcylcbiAgICAgICAgc3RhdGljIGZyb21Db21wYWN0KGhleCkge1xuICAgICAgICAgICAgY29uc3QgbCA9IG5CeXRlTGVuZ3RoO1xuICAgICAgICAgICAgaGV4ID0gZW5zdXJlQnl0ZXMoJ2NvbXBhY3RTaWduYXR1cmUnLCBoZXgsIGwgKiAyKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHNsY051bShoZXgsIDAsIGwpLCBzbGNOdW0oaGV4LCBsLCAyICogbCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERFUiBlbmNvZGVkIEVDRFNBIHNpZ25hdHVyZVxuICAgICAgICAvLyBodHRwczovL2JpdGNvaW4uc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzU3NjQ0L3doYXQtYXJlLXRoZS1wYXJ0cy1vZi1hLWJpdGNvaW4tdHJhbnNhY3Rpb24taW5wdXQtc2NyaXB0XG4gICAgICAgIHN0YXRpYyBmcm9tREVSKGhleCkge1xuICAgICAgICAgICAgY29uc3QgeyByLCBzIH0gPSBERVIudG9TaWcoZW5zdXJlQnl0ZXMoJ0RFUicsIGhleCkpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUociwgcyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0b2RvIHJlbW92ZVxuICAgICAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAgICAgKi9cbiAgICAgICAgYXNzZXJ0VmFsaWRpdHkoKSB7IH1cbiAgICAgICAgYWRkUmVjb3ZlcnlCaXQocmVjb3ZlcnkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHRoaXMuciwgdGhpcy5zLCByZWNvdmVyeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVjb3ZlclB1YmxpY0tleShtc2dIYXNoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHIsIHMsIHJlY292ZXJ5OiByZWMgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBoID0gYml0czJpbnRfbW9kTihlbnN1cmVCeXRlcygnbXNnSGFzaCcsIG1zZ0hhc2gpKTsgLy8gVHJ1bmNhdGUgaGFzaFxuICAgICAgICAgICAgaWYgKHJlYyA9PSBudWxsIHx8ICFbMCwgMSwgMiwgM10uaW5jbHVkZXMocmVjKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY292ZXJ5IGlkIGludmFsaWQnKTtcbiAgICAgICAgICAgIGNvbnN0IHJhZGogPSByZWMgPT09IDIgfHwgcmVjID09PSAzID8gciArIENVUlZFLm4gOiByO1xuICAgICAgICAgICAgaWYgKHJhZGogPj0gRnAuT1JERVIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWNvdmVyeSBpZCAyIG9yIDMgaW52YWxpZCcpO1xuICAgICAgICAgICAgY29uc3QgcHJlZml4ID0gKHJlYyAmIDEpID09PSAwID8gJzAyJyA6ICcwMyc7XG4gICAgICAgICAgICBjb25zdCBSID0gUG9pbnQuZnJvbUhleChwcmVmaXggKyBudW1Ub1NpemVkSGV4KHJhZGosIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICBjb25zdCBpciA9IGludk4ocmFkaik7IC8vIHJeLTFcbiAgICAgICAgICAgIGNvbnN0IHUxID0gbW9kTigtaCAqIGlyKTsgLy8gLWhyXi0xXG4gICAgICAgICAgICBjb25zdCB1MiA9IG1vZE4ocyAqIGlyKTsgLy8gc3JeLTFcbiAgICAgICAgICAgIGNvbnN0IFEgPSBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFIsIHUxLCB1Mik7IC8vIChzcl4tMSlSLShocl4tMSlHID0gLShocl4tMSlHICsgKHNyXi0xKVxuICAgICAgICAgICAgaWYgKCFRKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncG9pbnQgYXQgaW5maW5pZnknKTsgLy8gdW5zYWZlIGlzIGZpbmU6IG5vIHByaXYgZGF0YSBsZWFrZWRcbiAgICAgICAgICAgIFEuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiBRO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNpZ25hdHVyZXMgc2hvdWxkIGJlIGxvdy1zLCB0byBwcmV2ZW50IG1hbGxlYWJpbGl0eS5cbiAgICAgICAgaGFzSGlnaFMoKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNCaWdnZXJUaGFuSGFsZk9yZGVyKHRoaXMucyk7XG4gICAgICAgIH1cbiAgICAgICAgbm9ybWFsaXplUygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhc0hpZ2hTKCkgPyBuZXcgU2lnbmF0dXJlKHRoaXMuciwgbW9kTigtdGhpcy5zKSwgdGhpcy5yZWNvdmVyeSkgOiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIERFUi1lbmNvZGVkXG4gICAgICAgIHRvREVSUmF3Qnl0ZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gaGV4VG9CeXRlcyh0aGlzLnRvREVSSGV4KCkpO1xuICAgICAgICB9XG4gICAgICAgIHRvREVSSGV4KCkge1xuICAgICAgICAgICAgcmV0dXJuIERFUi5oZXhGcm9tU2lnKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhZGRlZCBieXRlcyBvZiByLCB0aGVuIHBhZGRlZCBieXRlcyBvZiBzXG4gICAgICAgIHRvQ29tcGFjdFJhd0J5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIGhleFRvQnl0ZXModGhpcy50b0NvbXBhY3RIZXgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9Db21wYWN0SGV4KCkge1xuICAgICAgICAgICAgY29uc3QgbCA9IG5CeXRlTGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIG51bVRvU2l6ZWRIZXgodGhpcy5yLCBsKSArIG51bVRvU2l6ZWRIZXgodGhpcy5zLCBsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB1dGlscyA9IHtcbiAgICAgICAgaXNWYWxpZFByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVLZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyOiBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLFxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZXMgY3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlIHByaXZhdGUga2V5IGZyb20gcmFuZG9tIG9mIHNpemVcbiAgICAgICAgICogKGdyb3VwTGVuICsgY2VpbChncm91cExlbiAvIDIpKSB3aXRoIG1vZHVsbyBiaWFzIGJlaW5nIG5lZ2xpZ2libGUuXG4gICAgICAgICAqL1xuICAgICAgICByYW5kb21Qcml2YXRlS2V5OiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBnZXRNaW5IYXNoTGVuZ3RoKENVUlZFLm4pO1xuICAgICAgICAgICAgcmV0dXJuIG1hcEhhc2hUb0ZpZWxkKENVUlZFLnJhbmRvbUJ5dGVzKGxlbmd0aCksIENVUlZFLm4pO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBwcmVjb21wdXRlIHRhYmxlIGZvciBhbiBhcmJpdHJhcnkgRUMgcG9pbnQuIE1ha2VzIHBvaW50IFwiY2FjaGVkXCIuXG4gICAgICAgICAqIEFsbG93cyB0byBtYXNzaXZlbHkgc3BlZWQtdXAgYHBvaW50Lm11bHRpcGx5KHNjYWxhcilgLlxuICAgICAgICAgKiBAcmV0dXJucyBjYWNoZWQgcG9pbnRcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogY29uc3QgZmFzdCA9IHV0aWxzLnByZWNvbXB1dGUoOCwgUHJvamVjdGl2ZVBvaW50LmZyb21IZXgoc29tZW9uZXNQdWJLZXkpKTtcbiAgICAgICAgICogZmFzdC5tdWx0aXBseShwcml2S2V5KTsgLy8gbXVjaCBmYXN0ZXIgRUNESCBub3dcbiAgICAgICAgICovXG4gICAgICAgIHByZWNvbXB1dGUod2luZG93U2l6ZSA9IDgsIHBvaW50ID0gUG9pbnQuQkFTRSkge1xuICAgICAgICAgICAgcG9pbnQuX3NldFdpbmRvd1NpemUod2luZG93U2l6ZSk7XG4gICAgICAgICAgICBwb2ludC5tdWx0aXBseShCaWdJbnQoMykpOyAvLyAzIGlzIGFyYml0cmFyeSwganVzdCBuZWVkIGFueSBudW1iZXIgaGVyZVxuICAgICAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgICAgICB9LFxuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgcHVibGljIGtleSBmb3IgYSBwcml2YXRlIGtleS4gQ2hlY2tzIGZvciB2YWxpZGl0eSBvZiB0aGUgcHJpdmF0ZSBrZXkuXG4gICAgICogQHBhcmFtIHByaXZhdGVLZXkgcHJpdmF0ZSBrZXlcbiAgICAgKiBAcGFyYW0gaXNDb21wcmVzc2VkIHdoZXRoZXIgdG8gcmV0dXJuIGNvbXBhY3QgKGRlZmF1bHQpLCBvciBmdWxsIGtleVxuICAgICAqIEByZXR1cm5zIFB1YmxpYyBrZXksIGZ1bGwgd2hlbiBpc0NvbXByZXNzZWQ9ZmFsc2U7IHNob3J0IHdoZW4gaXNDb21wcmVzc2VkPXRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRQdWJsaWNLZXkocHJpdmF0ZUtleSwgaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gUG9pbnQuZnJvbVByaXZhdGVLZXkocHJpdmF0ZUtleSkudG9SYXdCeXRlcyhpc0NvbXByZXNzZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBRdWljayBhbmQgZGlydHkgY2hlY2sgZm9yIGl0ZW0gYmVpbmcgcHVibGljIGtleS4gRG9lcyBub3QgdmFsaWRhdGUgaGV4LCBvciBiZWluZyBvbi1jdXJ2ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1Byb2JQdWIoaXRlbSkge1xuICAgICAgICBpZiAodHlwZW9mIGl0ZW0gPT09ICdiaWdpbnQnKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIFBvaW50KVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNvbnN0IGFyciA9IGVuc3VyZUJ5dGVzKCdrZXknLCBpdGVtKTtcbiAgICAgICAgY29uc3QgbGVuID0gYXJyLmxlbmd0aDtcbiAgICAgICAgY29uc3QgZnBsID0gRnAuQllURVM7XG4gICAgICAgIGNvbnN0IGNvbXBMZW4gPSBmcGwgKyAxOyAvLyBlLmcuIDMzIGZvciAzMlxuICAgICAgICBjb25zdCB1bmNvbXBMZW4gPSAyICogZnBsICsgMTsgLy8gZS5nLiA2NSBmb3IgMzJcbiAgICAgICAgaWYgKENVUlZFLmFsbG93ZWRQcml2YXRlS2V5TGVuZ3RocyB8fCBuQnl0ZUxlbmd0aCA9PT0gY29tcExlbikge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBsZW4gPT09IGNvbXBMZW4gfHwgbGVuID09PSB1bmNvbXBMZW47XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRUNESCAoRWxsaXB0aWMgQ3VydmUgRGlmZmllIEhlbGxtYW4pLlxuICAgICAqIENvbXB1dGVzIHNoYXJlZCBwdWJsaWMga2V5IGZyb20gcHJpdmF0ZSBrZXkgYW5kIHB1YmxpYyBrZXkuXG4gICAgICogQ2hlY2tzOiAxKSBwcml2YXRlIGtleSB2YWxpZGl0eSAyKSBzaGFyZWQga2V5IGlzIG9uLWN1cnZlLlxuICAgICAqIERvZXMgTk9UIGhhc2ggdGhlIHJlc3VsdC5cbiAgICAgKiBAcGFyYW0gcHJpdmF0ZUEgcHJpdmF0ZSBrZXlcbiAgICAgKiBAcGFyYW0gcHVibGljQiBkaWZmZXJlbnQgcHVibGljIGtleVxuICAgICAqIEBwYXJhbSBpc0NvbXByZXNzZWQgd2hldGhlciB0byByZXR1cm4gY29tcGFjdCAoZGVmYXVsdCksIG9yIGZ1bGwga2V5XG4gICAgICogQHJldHVybnMgc2hhcmVkIHB1YmxpYyBrZXlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRTaGFyZWRTZWNyZXQocHJpdmF0ZUEsIHB1YmxpY0IsIGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgaWYgKGlzUHJvYlB1Yihwcml2YXRlQSkgPT09IHRydWUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpcnN0IGFyZyBtdXN0IGJlIHByaXZhdGUga2V5Jyk7XG4gICAgICAgIGlmIChpc1Byb2JQdWIocHVibGljQikgPT09IGZhbHNlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZWNvbmQgYXJnIG11c3QgYmUgcHVibGljIGtleScpO1xuICAgICAgICBjb25zdCBiID0gUG9pbnQuZnJvbUhleChwdWJsaWNCKTsgLy8gY2hlY2sgZm9yIGJlaW5nIG9uLWN1cnZlXG4gICAgICAgIHJldHVybiBiLm11bHRpcGx5KG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUEpKS50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCk7XG4gICAgfVxuICAgIC8vIFJGQzY5Nzk6IGVuc3VyZSBFQ0RTQSBtc2cgaXMgWCBieXRlcyBhbmQgPCBOLiBSRkMgc3VnZ2VzdHMgb3B0aW9uYWwgdHJ1bmNhdGluZyB2aWEgYml0czJvY3RldHMuXG4gICAgLy8gRklQUyAxODYtNCA0LjYgc3VnZ2VzdHMgdGhlIGxlZnRtb3N0IG1pbihuQml0TGVuLCBvdXRMZW4pIGJpdHMsIHdoaWNoIG1hdGNoZXMgYml0czJpbnQuXG4gICAgLy8gYml0czJpbnQgY2FuIHByb2R1Y2UgcmVzPk4sIHdlIGNhbiBkbyBtb2QocmVzLCBOKSBzaW5jZSB0aGUgYml0TGVuIGlzIHRoZSBzYW1lLlxuICAgIC8vIGludDJvY3RldHMgY2FuJ3QgYmUgdXNlZDsgcGFkcyBzbWFsbCBtc2dzIHdpdGggMDogdW5hY2NlcHRhdGJsZSBmb3IgdHJ1bmMgYXMgcGVyIFJGQyB2ZWN0b3JzXG4gICAgY29uc3QgYml0czJpbnQgPSBDVVJWRS5iaXRzMmludCB8fFxuICAgICAgICBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgICAgICAgICAgIC8vIE91ciBjdXN0b20gY2hlY2sgXCJqdXN0IGluIGNhc2VcIiwgZm9yIHByb3RlY3Rpb24gYWdhaW5zdCBEb1NcbiAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggPiA4MTkyKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW5wdXQgaXMgdG9vIGxhcmdlJyk7XG4gICAgICAgICAgICAvLyBGb3IgY3VydmVzIHdpdGggbkJpdExlbmd0aCAlIDggIT09IDA6IGJpdHMyb2N0ZXRzKGJpdHMyb2N0ZXRzKG0pKSAhPT0gYml0czJvY3RldHMobSlcbiAgICAgICAgICAgIC8vIGZvciBzb21lIGNhc2VzLCBzaW5jZSBieXRlcy5sZW5ndGggKiA4IGlzIG5vdCBhY3R1YWwgYml0TGVuZ3RoLlxuICAgICAgICAgICAgY29uc3QgbnVtID0gYnl0ZXNUb051bWJlckJFKGJ5dGVzKTsgLy8gY2hlY2sgZm9yID09IHU4IGRvbmUgaGVyZVxuICAgICAgICAgICAgY29uc3QgZGVsdGEgPSBieXRlcy5sZW5ndGggKiA4IC0gbkJpdExlbmd0aDsgLy8gdHJ1bmNhdGUgdG8gbkJpdExlbmd0aCBsZWZ0bW9zdCBiaXRzXG4gICAgICAgICAgICByZXR1cm4gZGVsdGEgPiAwID8gbnVtID4+IEJpZ0ludChkZWx0YSkgOiBudW07XG4gICAgICAgIH07XG4gICAgY29uc3QgYml0czJpbnRfbW9kTiA9IENVUlZFLmJpdHMyaW50X21vZE4gfHxcbiAgICAgICAgZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kTihiaXRzMmludChieXRlcykpOyAvLyBjYW4ndCB1c2UgYnl0ZXNUb051bWJlckJFIGhlcmVcbiAgICAgICAgfTtcbiAgICAvLyBOT1RFOiBwYWRzIG91dHB1dCB3aXRoIHplcm8gYXMgcGVyIHNwZWNcbiAgICBjb25zdCBPUkRFUl9NQVNLID0gYml0TWFzayhuQml0TGVuZ3RoKTtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0byBieXRlcy4gQ2hlY2tzIGlmIG51bSBpbiBgWzAuLk9SREVSX01BU0stMV1gIGUuZy46IGBbMC4uMl4yNTYtMV1gLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludDJvY3RldHMobnVtKSB7XG4gICAgICAgIGFJblJhbmdlKCdudW0gPCAyXicgKyBuQml0TGVuZ3RoLCBudW0sIF8wbiwgT1JERVJfTUFTSyk7XG4gICAgICAgIC8vIHdvcmtzIHdpdGggb3JkZXIsIGNhbiBoYXZlIGRpZmZlcmVudCBzaXplIHRoYW4gbnVtVG9GaWVsZCFcbiAgICAgICAgcmV0dXJuIG51bWJlclRvQnl0ZXNCRShudW0sIG5CeXRlTGVuZ3RoKTtcbiAgICB9XG4gICAgLy8gU3RlcHMgQSwgRCBvZiBSRkM2OTc5IDMuMlxuICAgIC8vIENyZWF0ZXMgUkZDNjk3OSBzZWVkOyBjb252ZXJ0cyBtc2cvcHJpdktleSB0byBudW1iZXJzLlxuICAgIC8vIFVzZWQgb25seSBpbiBzaWduLCBub3QgaW4gdmVyaWZ5LlxuICAgIC8vIE5PVEU6IHdlIGNhbm5vdCBhc3N1bWUgaGVyZSB0aGF0IG1zZ0hhc2ggaGFzIHNhbWUgYW1vdW50IG9mIGJ5dGVzIGFzIGN1cnZlIG9yZGVyLFxuICAgIC8vIHRoaXMgd2lsbCBiZSBpbnZhbGlkIGF0IGxlYXN0IGZvciBQNTIxLiBBbHNvIGl0IGNhbiBiZSBiaWdnZXIgZm9yIFAyMjQgKyBTSEEyNTZcbiAgICBmdW5jdGlvbiBwcmVwU2lnKG1zZ0hhc2gsIHByaXZhdGVLZXksIG9wdHMgPSBkZWZhdWx0U2lnT3B0cykge1xuICAgICAgICBpZiAoWydyZWNvdmVyZWQnLCAnY2Fub25pY2FsJ10uc29tZSgoaykgPT4gayBpbiBvcHRzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbigpIGxlZ2FjeSBvcHRpb25zIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgY29uc3QgeyBoYXNoLCByYW5kb21CeXRlcyB9ID0gQ1VSVkU7XG4gICAgICAgIGxldCB7IGxvd1MsIHByZWhhc2gsIGV4dHJhRW50cm9weTogZW50IH0gPSBvcHRzOyAvLyBnZW5lcmF0ZXMgbG93LXMgc2lncyBieSBkZWZhdWx0XG4gICAgICAgIGlmIChsb3dTID09IG51bGwpXG4gICAgICAgICAgICBsb3dTID0gdHJ1ZTsgLy8gUkZDNjk3OSAzLjI6IHdlIHNraXAgc3RlcCBBLCBiZWNhdXNlIHdlIGFscmVhZHkgcHJvdmlkZSBoYXNoXG4gICAgICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcygnbXNnSGFzaCcsIG1zZ0hhc2gpO1xuICAgICAgICB2YWxpZGF0ZVNpZ1Zlck9wdHMob3B0cyk7XG4gICAgICAgIGlmIChwcmVoYXNoKVxuICAgICAgICAgICAgbXNnSGFzaCA9IGVuc3VyZUJ5dGVzKCdwcmVoYXNoZWQgbXNnSGFzaCcsIGhhc2gobXNnSGFzaCkpO1xuICAgICAgICAvLyBXZSBjYW4ndCBsYXRlciBjYWxsIGJpdHMyb2N0ZXRzLCBzaW5jZSBuZXN0ZWQgYml0czJpbnQgaXMgYnJva2VuIGZvciBjdXJ2ZXNcbiAgICAgICAgLy8gd2l0aCBuQml0TGVuZ3RoICUgOCAhPT0gMC4gQmVjYXVzZSBvZiB0aGF0LCB3ZSB1bndyYXAgaXQgaGVyZSBhcyBpbnQyb2N0ZXRzIGNhbGwuXG4gICAgICAgIC8vIGNvbnN0IGJpdHMyb2N0ZXRzID0gKGJpdHMpID0+IGludDJvY3RldHMoYml0czJpbnRfbW9kTihiaXRzKSlcbiAgICAgICAgY29uc3QgaDFpbnQgPSBiaXRzMmludF9tb2ROKG1zZ0hhc2gpO1xuICAgICAgICBjb25zdCBkID0gbm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KTsgLy8gdmFsaWRhdGUgcHJpdmF0ZSBrZXksIGNvbnZlcnQgdG8gYmlnaW50XG4gICAgICAgIGNvbnN0IHNlZWRBcmdzID0gW2ludDJvY3RldHMoZCksIGludDJvY3RldHMoaDFpbnQpXTtcbiAgICAgICAgLy8gZXh0cmFFbnRyb3B5LiBSRkM2OTc5IDMuNjogYWRkaXRpb25hbCBrJyAob3B0aW9uYWwpLlxuICAgICAgICBpZiAoZW50ICE9IG51bGwgJiYgZW50ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgLy8gSyA9IEhNQUNfSyhWIHx8IDB4MDAgfHwgaW50Mm9jdGV0cyh4KSB8fCBiaXRzMm9jdGV0cyhoMSkgfHwgaycpXG4gICAgICAgICAgICBjb25zdCBlID0gZW50ID09PSB0cnVlID8gcmFuZG9tQnl0ZXMoRnAuQllURVMpIDogZW50OyAvLyBnZW5lcmF0ZSByYW5kb20gYnl0ZXMgT1IgcGFzcyBhcy1pc1xuICAgICAgICAgICAgc2VlZEFyZ3MucHVzaChlbnN1cmVCeXRlcygnZXh0cmFFbnRyb3B5JywgZSkpOyAvLyBjaGVjayBmb3IgYmVpbmcgYnl0ZXNcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWVkID0gY29uY2F0Qnl0ZXMoLi4uc2VlZEFyZ3MpOyAvLyBTdGVwIEQgb2YgUkZDNjk3OSAzLjJcbiAgICAgICAgY29uc3QgbSA9IGgxaW50OyAvLyBOT1RFOiBubyBuZWVkIHRvIGNhbGwgYml0czJpbnQgc2Vjb25kIHRpbWUgaGVyZSwgaXQgaXMgaW5zaWRlIHRydW5jYXRlSGFzaCFcbiAgICAgICAgLy8gQ29udmVydHMgc2lnbmF0dXJlIHBhcmFtcyBpbnRvIHBvaW50IHcgci9zLCBjaGVja3MgcmVzdWx0IGZvciB2YWxpZGl0eS5cbiAgICAgICAgZnVuY3Rpb24gazJzaWcoa0J5dGVzKSB7XG4gICAgICAgICAgICAvLyBSRkMgNjk3OSBTZWN0aW9uIDMuMiwgc3RlcCAzOiBrID0gYml0czJpbnQoVClcbiAgICAgICAgICAgIGNvbnN0IGsgPSBiaXRzMmludChrQnl0ZXMpOyAvLyBDYW5ub3QgdXNlIGZpZWxkcyBtZXRob2RzLCBzaW5jZSBpdCBpcyBncm91cCBlbGVtZW50XG4gICAgICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcihrKSlcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIEltcG9ydGFudDogYWxsIG1vZCgpIGNhbGxzIGhlcmUgbXVzdCBiZSBkb25lIG92ZXIgTlxuICAgICAgICAgICAgY29uc3QgaWsgPSBpbnZOKGspOyAvLyBrXi0xIG1vZCBuXG4gICAgICAgICAgICBjb25zdCBxID0gUG9pbnQuQkFTRS5tdWx0aXBseShrKS50b0FmZmluZSgpOyAvLyBxID0gR2tcbiAgICAgICAgICAgIGNvbnN0IHIgPSBtb2ROKHEueCk7IC8vIHIgPSBxLnggbW9kIG5cbiAgICAgICAgICAgIGlmIChyID09PSBfMG4pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLy8gQ2FuIHVzZSBzY2FsYXIgYmxpbmRpbmcgYl4tMShibSArIGJkcikgd2hlcmUgYiDiiIggWzEsceKIkjFdIGFjY29yZGluZyB0b1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly90Y2hlcy5pYWNyLm9yZy9pbmRleC5waHAvVENIRVMvYXJ0aWNsZS92aWV3LzczMzcvNjUwOS4gV2UndmUgZGVjaWRlZCBhZ2FpbnN0IGl0OlxuICAgICAgICAgICAgLy8gYSkgZGVwZW5kZW5jeSBvbiBDU1BSTkcgYikgMTUlIHNsb3dkb3duIGMpIGRvZXNuJ3QgcmVhbGx5IGhlbHAgc2luY2UgYmlnaW50cyBhcmUgbm90IENUXG4gICAgICAgICAgICBjb25zdCBzID0gbW9kTihpayAqIG1vZE4obSArIHIgKiBkKSk7IC8vIE5vdCB1c2luZyBibGluZGluZyBoZXJlXG4gICAgICAgICAgICBpZiAocyA9PT0gXzBuKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCByZWNvdmVyeSA9IChxLnggPT09IHIgPyAwIDogMikgfCBOdW1iZXIocS55ICYgXzFuKTsgLy8gcmVjb3ZlcnkgYml0ICgyIG9yIDMsIHdoZW4gcS54ID4gbilcbiAgICAgICAgICAgIGxldCBub3JtUyA9IHM7XG4gICAgICAgICAgICBpZiAobG93UyAmJiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIocykpIHtcbiAgICAgICAgICAgICAgICBub3JtUyA9IG5vcm1hbGl6ZVMocyk7IC8vIGlmIGxvd1Mgd2FzIHBhc3NlZCwgZW5zdXJlIHMgaXMgYWx3YXlzXG4gICAgICAgICAgICAgICAgcmVjb3ZlcnkgXj0gMTsgLy8gLy8gaW4gdGhlIGJvdHRvbSBoYWxmIG9mIE5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHIsIG5vcm1TLCByZWNvdmVyeSk7IC8vIHVzZSBub3JtUywgbm90IHNcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzZWVkLCBrMnNpZyB9O1xuICAgIH1cbiAgICBjb25zdCBkZWZhdWx0U2lnT3B0cyA9IHsgbG93UzogQ1VSVkUubG93UywgcHJlaGFzaDogZmFsc2UgfTtcbiAgICBjb25zdCBkZWZhdWx0VmVyT3B0cyA9IHsgbG93UzogQ1VSVkUubG93UywgcHJlaGFzaDogZmFsc2UgfTtcbiAgICAvKipcbiAgICAgKiBTaWducyBtZXNzYWdlIGhhc2ggd2l0aCBhIHByaXZhdGUga2V5LlxuICAgICAqIGBgYFxuICAgICAqIHNpZ24obSwgZCwgaykgd2hlcmVcbiAgICAgKiAgICh4LCB5KSA9IEcgw5cga1xuICAgICAqICAgciA9IHggbW9kIG5cbiAgICAgKiAgIHMgPSAobSArIGRyKS9rIG1vZCBuXG4gICAgICogYGBgXG4gICAgICogQHBhcmFtIG1zZ0hhc2ggTk9UIG1lc3NhZ2UuIG1zZyBuZWVkcyB0byBiZSBoYXNoZWQgdG8gYG1zZ0hhc2hgLCBvciB1c2UgYHByZWhhc2hgLlxuICAgICAqIEBwYXJhbSBwcml2S2V5IHByaXZhdGUga2V5XG4gICAgICogQHBhcmFtIG9wdHMgbG93UyBmb3Igbm9uLW1hbGxlYWJsZSBzaWdzLiBleHRyYUVudHJvcHkgZm9yIG1peGluZyByYW5kb21uZXNzIGludG8gay4gcHJlaGFzaCB3aWxsIGhhc2ggZmlyc3QgYXJnLlxuICAgICAqIEByZXR1cm5zIHNpZ25hdHVyZSB3aXRoIHJlY292ZXJ5IHBhcmFtXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2lnbihtc2dIYXNoLCBwcml2S2V5LCBvcHRzID0gZGVmYXVsdFNpZ09wdHMpIHtcbiAgICAgICAgY29uc3QgeyBzZWVkLCBrMnNpZyB9ID0gcHJlcFNpZyhtc2dIYXNoLCBwcml2S2V5LCBvcHRzKTsgLy8gU3RlcHMgQSwgRCBvZiBSRkM2OTc5IDMuMi5cbiAgICAgICAgY29uc3QgQyA9IENVUlZFO1xuICAgICAgICBjb25zdCBkcmJnID0gY3JlYXRlSG1hY0RyYmcoQy5oYXNoLm91dHB1dExlbiwgQy5uQnl0ZUxlbmd0aCwgQy5obWFjKTtcbiAgICAgICAgcmV0dXJuIGRyYmcoc2VlZCwgazJzaWcpOyAvLyBTdGVwcyBCLCBDLCBELCBFLCBGLCBHXG4gICAgfVxuICAgIC8vIEVuYWJsZSBwcmVjb21wdXRlcy4gU2xvd3MgZG93biBmaXJzdCBwdWJsaWNLZXkgY29tcHV0YXRpb24gYnkgMjBtcy5cbiAgICBQb2ludC5CQVNFLl9zZXRXaW5kb3dTaXplKDgpO1xuICAgIC8vIHV0aWxzLnByZWNvbXB1dGUoOCwgUHJvamVjdGl2ZVBvaW50LkJBU0UpXG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgYSBzaWduYXR1cmUgYWdhaW5zdCBtZXNzYWdlIGhhc2ggYW5kIHB1YmxpYyBrZXkuXG4gICAgICogUmVqZWN0cyBsb3dTIHNpZ25hdHVyZXMgYnkgZGVmYXVsdDogdG8gb3ZlcnJpZGUsXG4gICAgICogc3BlY2lmeSBvcHRpb24gYHtsb3dTOiBmYWxzZX1gLiBJbXBsZW1lbnRzIHNlY3Rpb24gNC4xLjQgZnJvbSBodHRwczovL3d3dy5zZWNnLm9yZy9zZWMxLXYyLnBkZjpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIHZlcmlmeShyLCBzLCBoLCBQKSB3aGVyZVxuICAgICAqICAgVTEgPSBoc14tMSBtb2QgblxuICAgICAqICAgVTIgPSByc14tMSBtb2QgblxuICAgICAqICAgUiA9IFUx4ouFRyAtIFUy4ouFUFxuICAgICAqICAgbW9kKFIueCwgbikgPT0gclxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZlcmlmeShzaWduYXR1cmUsIG1zZ0hhc2gsIHB1YmxpY0tleSwgb3B0cyA9IGRlZmF1bHRWZXJPcHRzKSB7XG4gICAgICAgIGNvbnN0IHNnID0gc2lnbmF0dXJlO1xuICAgICAgICBtc2dIYXNoID0gZW5zdXJlQnl0ZXMoJ21zZ0hhc2gnLCBtc2dIYXNoKTtcbiAgICAgICAgcHVibGljS2V5ID0gZW5zdXJlQnl0ZXMoJ3B1YmxpY0tleScsIHB1YmxpY0tleSk7XG4gICAgICAgIGNvbnN0IHsgbG93UywgcHJlaGFzaCwgZm9ybWF0IH0gPSBvcHRzO1xuICAgICAgICAvLyBWZXJpZnkgb3B0cywgZGVkdWNlIHNpZ25hdHVyZSBmb3JtYXRcbiAgICAgICAgdmFsaWRhdGVTaWdWZXJPcHRzKG9wdHMpO1xuICAgICAgICBpZiAoJ3N0cmljdCcgaW4gb3B0cylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucy5zdHJpY3Qgd2FzIHJlbmFtZWQgdG8gbG93UycpO1xuICAgICAgICBpZiAoZm9ybWF0ICE9PSB1bmRlZmluZWQgJiYgZm9ybWF0ICE9PSAnY29tcGFjdCcgJiYgZm9ybWF0ICE9PSAnZGVyJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZm9ybWF0IG11c3QgYmUgY29tcGFjdCBvciBkZXInKTtcbiAgICAgICAgY29uc3QgaXNIZXggPSB0eXBlb2Ygc2cgPT09ICdzdHJpbmcnIHx8IGlzQnl0ZXMoc2cpO1xuICAgICAgICBjb25zdCBpc09iaiA9ICFpc0hleCAmJlxuICAgICAgICAgICAgIWZvcm1hdCAmJlxuICAgICAgICAgICAgdHlwZW9mIHNnID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgc2cgIT09IG51bGwgJiZcbiAgICAgICAgICAgIHR5cGVvZiBzZy5yID09PSAnYmlnaW50JyAmJlxuICAgICAgICAgICAgdHlwZW9mIHNnLnMgPT09ICdiaWdpbnQnO1xuICAgICAgICBpZiAoIWlzSGV4ICYmICFpc09iailcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzaWduYXR1cmUsIGV4cGVjdGVkIFVpbnQ4QXJyYXksIGhleCBzdHJpbmcgb3IgU2lnbmF0dXJlIGluc3RhbmNlJyk7XG4gICAgICAgIGxldCBfc2lnID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgUDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChpc09iailcbiAgICAgICAgICAgICAgICBfc2lnID0gbmV3IFNpZ25hdHVyZShzZy5yLCBzZy5zKTtcbiAgICAgICAgICAgIGlmIChpc0hleCkge1xuICAgICAgICAgICAgICAgIC8vIFNpZ25hdHVyZSBjYW4gYmUgcmVwcmVzZW50ZWQgaW4gMiB3YXlzOiBjb21wYWN0ICgyKm5CeXRlTGVuZ3RoKSAmIERFUiAodmFyaWFibGUtbGVuZ3RoKS5cbiAgICAgICAgICAgICAgICAvLyBTaW5jZSBERVIgY2FuIGFsc28gYmUgMipuQnl0ZUxlbmd0aCBieXRlcywgd2UgY2hlY2sgZm9yIGl0IGZpcnN0LlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3JtYXQgIT09ICdjb21wYWN0JylcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zaWcgPSBTaWduYXR1cmUuZnJvbURFUihzZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChkZXJFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShkZXJFcnJvciBpbnN0YW5jZW9mIERFUi5FcnIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZGVyRXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghX3NpZyAmJiBmb3JtYXQgIT09ICdkZXInKVxuICAgICAgICAgICAgICAgICAgICBfc2lnID0gU2lnbmF0dXJlLmZyb21Db21wYWN0KHNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFAgPSBQb2ludC5mcm9tSGV4KHB1YmxpY0tleSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFfc2lnKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAobG93UyAmJiBfc2lnLmhhc0hpZ2hTKCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChwcmVoYXNoKVxuICAgICAgICAgICAgbXNnSGFzaCA9IENVUlZFLmhhc2gobXNnSGFzaCk7XG4gICAgICAgIGNvbnN0IHsgciwgcyB9ID0gX3NpZztcbiAgICAgICAgY29uc3QgaCA9IGJpdHMyaW50X21vZE4obXNnSGFzaCk7IC8vIENhbm5vdCB1c2UgZmllbGRzIG1ldGhvZHMsIHNpbmNlIGl0IGlzIGdyb3VwIGVsZW1lbnRcbiAgICAgICAgY29uc3QgaXMgPSBpbnZOKHMpOyAvLyBzXi0xXG4gICAgICAgIGNvbnN0IHUxID0gbW9kTihoICogaXMpOyAvLyB1MSA9IGhzXi0xIG1vZCBuXG4gICAgICAgIGNvbnN0IHUyID0gbW9kTihyICogaXMpOyAvLyB1MiA9IHJzXi0xIG1vZCBuXG4gICAgICAgIGNvbnN0IFIgPSBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFAsIHUxLCB1Mik/LnRvQWZmaW5lKCk7IC8vIFIgPSB1MeKLhUcgKyB1MuKLhVBcbiAgICAgICAgaWYgKCFSKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCB2ID0gbW9kTihSLngpO1xuICAgICAgICByZXR1cm4gdiA9PT0gcjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgQ1VSVkUsXG4gICAgICAgIGdldFB1YmxpY0tleSxcbiAgICAgICAgZ2V0U2hhcmVkU2VjcmV0LFxuICAgICAgICBzaWduLFxuICAgICAgICB2ZXJpZnksXG4gICAgICAgIFByb2plY3RpdmVQb2ludDogUG9pbnQsXG4gICAgICAgIFNpZ25hdHVyZSxcbiAgICAgICAgdXRpbHMsXG4gICAgfTtcbn1cbi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgdGhlIFNoYWxsdWUgYW5kIHZhbiBkZSBXb2VzdGlqbmUgbWV0aG9kIGZvciBhbnkgd2VpZXJzdHJhc3MgY3VydmUuXG4gKiBUT0RPOiBjaGVjayBpZiB0aGVyZSBpcyBhIHdheSB0byBtZXJnZSB0aGlzIHdpdGggdXZSYXRpbyBpbiBFZHdhcmRzOyBtb3ZlIHRvIG1vZHVsYXIuXG4gKiBiID0gVHJ1ZSBhbmQgeSA9IHNxcnQodSAvIHYpIGlmICh1IC8gdikgaXMgc3F1YXJlIGluIEYsIGFuZFxuICogYiA9IEZhbHNlIGFuZCB5ID0gc3FydChaICogKHUgLyB2KSkgb3RoZXJ3aXNlLlxuICogQHBhcmFtIEZwXG4gKiBAcGFyYW0gWlxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFNXVUZwU3FydFJhdGlvKEZwLCBaKSB7XG4gICAgLy8gR2VuZXJpYyBpbXBsZW1lbnRhdGlvblxuICAgIGNvbnN0IHEgPSBGcC5PUkRFUjtcbiAgICBsZXQgbCA9IF8wbjtcbiAgICBmb3IgKGxldCBvID0gcSAtIF8xbjsgbyAlIF8ybiA9PT0gXzBuOyBvIC89IF8ybilcbiAgICAgICAgbCArPSBfMW47XG4gICAgY29uc3QgYzEgPSBsOyAvLyAxLiBjMSwgdGhlIGxhcmdlc3QgaW50ZWdlciBzdWNoIHRoYXQgMl5jMSBkaXZpZGVzIHEgLSAxLlxuICAgIC8vIFdlIG5lZWQgMm4gKiogYzEgYW5kIDJuICoqIChjMS0xKS4gV2UgY2FuJ3QgdXNlICoqOyBidXQgd2UgY2FuIHVzZSA8PC5cbiAgICAvLyAybiAqKiBjMSA9PSAybiA8PCAoYzEtMSlcbiAgICBjb25zdCBfMm5fcG93X2MxXzEgPSBfMm4gPDwgKGMxIC0gXzFuIC0gXzFuKTtcbiAgICBjb25zdCBfMm5fcG93X2MxID0gXzJuX3Bvd19jMV8xICogXzJuO1xuICAgIGNvbnN0IGMyID0gKHEgLSBfMW4pIC8gXzJuX3Bvd19jMTsgLy8gMi4gYzIgPSAocSAtIDEpIC8gKDJeYzEpICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGMzID0gKGMyIC0gXzFuKSAvIF8ybjsgLy8gMy4gYzMgPSAoYzIgLSAxKSAvIDIgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM0ID0gXzJuX3Bvd19jMSAtIF8xbjsgLy8gNC4gYzQgPSAyXmMxIC0gMSAgICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM1ID0gXzJuX3Bvd19jMV8xOyAvLyA1LiBjNSA9IDJeKGMxIC0gMSkgICAgICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM2ID0gRnAucG93KFosIGMyKTsgLy8gNi4gYzYgPSBaXmMyXG4gICAgY29uc3QgYzcgPSBGcC5wb3coWiwgKGMyICsgXzFuKSAvIF8ybik7IC8vIDcuIGM3ID0gWl4oKGMyICsgMSkgLyAyKVxuICAgIGxldCBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuICAgICAgICBsZXQgdHYxID0gYzY7IC8vIDEuIHR2MSA9IGM2XG4gICAgICAgIGxldCB0djIgPSBGcC5wb3codiwgYzQpOyAvLyAyLiB0djIgPSB2XmM0XG4gICAgICAgIGxldCB0djMgPSBGcC5zcXIodHYyKTsgLy8gMy4gdHYzID0gdHYyXjJcbiAgICAgICAgdHYzID0gRnAubXVsKHR2Mywgdik7IC8vIDQuIHR2MyA9IHR2MyAqIHZcbiAgICAgICAgbGV0IHR2NSA9IEZwLm11bCh1LCB0djMpOyAvLyA1LiB0djUgPSB1ICogdHYzXG4gICAgICAgIHR2NSA9IEZwLnBvdyh0djUsIGMzKTsgLy8gNi4gdHY1ID0gdHY1XmMzXG4gICAgICAgIHR2NSA9IEZwLm11bCh0djUsIHR2Mik7IC8vIDcuIHR2NSA9IHR2NSAqIHR2MlxuICAgICAgICB0djIgPSBGcC5tdWwodHY1LCB2KTsgLy8gOC4gdHYyID0gdHY1ICogdlxuICAgICAgICB0djMgPSBGcC5tdWwodHY1LCB1KTsgLy8gOS4gdHYzID0gdHY1ICogdVxuICAgICAgICBsZXQgdHY0ID0gRnAubXVsKHR2MywgdHYyKTsgLy8gMTAuIHR2NCA9IHR2MyAqIHR2MlxuICAgICAgICB0djUgPSBGcC5wb3codHY0LCBjNSk7IC8vIDExLiB0djUgPSB0djReYzVcbiAgICAgICAgbGV0IGlzUVIgPSBGcC5lcWwodHY1LCBGcC5PTkUpOyAvLyAxMi4gaXNRUiA9IHR2NSA9PSAxXG4gICAgICAgIHR2MiA9IEZwLm11bCh0djMsIGM3KTsgLy8gMTMuIHR2MiA9IHR2MyAqIGM3XG4gICAgICAgIHR2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDE0LiB0djUgPSB0djQgKiB0djFcbiAgICAgICAgdHYzID0gRnAuY21vdih0djIsIHR2MywgaXNRUik7IC8vIDE1LiB0djMgPSBDTU9WKHR2MiwgdHYzLCBpc1FSKVxuICAgICAgICB0djQgPSBGcC5jbW92KHR2NSwgdHY0LCBpc1FSKTsgLy8gMTYuIHR2NCA9IENNT1YodHY1LCB0djQsIGlzUVIpXG4gICAgICAgIC8vIDE3LiBmb3IgaSBpbiAoYzEsIGMxIC0gMSwgLi4uLCAyKTpcbiAgICAgICAgZm9yIChsZXQgaSA9IGMxOyBpID4gXzFuOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCB0djUgPSBpIC0gXzJuOyAvLyAxOC4gICAgdHY1ID0gaSAtIDJcbiAgICAgICAgICAgIHR2NSA9IF8ybiA8PCAodHY1IC0gXzFuKTsgLy8gMTkuICAgIHR2NSA9IDJedHY1XG4gICAgICAgICAgICBsZXQgdHZ2NSA9IEZwLnBvdyh0djQsIHR2NSk7IC8vIDIwLiAgICB0djUgPSB0djRedHY1XG4gICAgICAgICAgICBjb25zdCBlMSA9IEZwLmVxbCh0dnY1LCBGcC5PTkUpOyAvLyAyMS4gICAgZTEgPSB0djUgPT0gMVxuICAgICAgICAgICAgdHYyID0gRnAubXVsKHR2MywgdHYxKTsgLy8gMjIuICAgIHR2MiA9IHR2MyAqIHR2MVxuICAgICAgICAgICAgdHYxID0gRnAubXVsKHR2MSwgdHYxKTsgLy8gMjMuICAgIHR2MSA9IHR2MSAqIHR2MVxuICAgICAgICAgICAgdHZ2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDI0LiAgICB0djUgPSB0djQgKiB0djFcbiAgICAgICAgICAgIHR2MyA9IEZwLmNtb3YodHYyLCB0djMsIGUxKTsgLy8gMjUuICAgIHR2MyA9IENNT1YodHYyLCB0djMsIGUxKVxuICAgICAgICAgICAgdHY0ID0gRnAuY21vdih0dnY1LCB0djQsIGUxKTsgLy8gMjYuICAgIHR2NCA9IENNT1YodHY1LCB0djQsIGUxKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGlzUVIsIHZhbHVlOiB0djMgfTtcbiAgICB9O1xuICAgIGlmIChGcC5PUkRFUiAlIF80biA9PT0gXzNuKSB7XG4gICAgICAgIC8vIHNxcnRfcmF0aW9fM21vZDQodSwgdilcbiAgICAgICAgY29uc3QgYzEgPSAoRnAuT1JERVIgLSBfM24pIC8gXzRuOyAvLyAxLiBjMSA9IChxIC0gMykgLyA0ICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgICAgICBjb25zdCBjMiA9IEZwLnNxcnQoRnAubmVnKFopKTsgLy8gMi4gYzIgPSBzcXJ0KC1aKVxuICAgICAgICBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuICAgICAgICAgICAgbGV0IHR2MSA9IEZwLnNxcih2KTsgLy8gMS4gdHYxID0gdl4yXG4gICAgICAgICAgICBjb25zdCB0djIgPSBGcC5tdWwodSwgdik7IC8vIDIuIHR2MiA9IHUgKiB2XG4gICAgICAgICAgICB0djEgPSBGcC5tdWwodHYxLCB0djIpOyAvLyAzLiB0djEgPSB0djEgKiB0djJcbiAgICAgICAgICAgIGxldCB5MSA9IEZwLnBvdyh0djEsIGMxKTsgLy8gNC4geTEgPSB0djFeYzFcbiAgICAgICAgICAgIHkxID0gRnAubXVsKHkxLCB0djIpOyAvLyA1LiB5MSA9IHkxICogdHYyXG4gICAgICAgICAgICBjb25zdCB5MiA9IEZwLm11bCh5MSwgYzIpOyAvLyA2LiB5MiA9IHkxICogYzJcbiAgICAgICAgICAgIGNvbnN0IHR2MyA9IEZwLm11bChGcC5zcXIoeTEpLCB2KTsgLy8gNy4gdHYzID0geTFeMjsgOC4gdHYzID0gdHYzICogdlxuICAgICAgICAgICAgY29uc3QgaXNRUiA9IEZwLmVxbCh0djMsIHUpOyAvLyA5LiBpc1FSID0gdHYzID09IHVcbiAgICAgICAgICAgIGxldCB5ID0gRnAuY21vdih5MiwgeTEsIGlzUVIpOyAvLyAxMC4geSA9IENNT1YoeTIsIHkxLCBpc1FSKVxuICAgICAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogaXNRUiwgdmFsdWU6IHkgfTsgLy8gMTEuIHJldHVybiAoaXNRUiwgeSkgaXNRUiA/IHkgOiB5KmMyXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIE5vIGN1cnZlcyB1c2VzIHRoYXRcbiAgICAvLyBpZiAoRnAuT1JERVIgJSBfOG4gPT09IF81bikgLy8gc3FydF9yYXRpb181bW9kOFxuICAgIHJldHVybiBzcXJ0UmF0aW87XG59XG4vKipcbiAqIFNpbXBsaWZpZWQgU2hhbGx1ZS12YW4gZGUgV29lc3Rpam5lLVVsYXMgTWV0aG9kXG4gKiBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTYuNi4yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBUb0N1cnZlU2ltcGxlU1dVKEZwLCBvcHRzKSB7XG4gICAgdmFsaWRhdGVGaWVsZChGcCk7XG4gICAgaWYgKCFGcC5pc1ZhbGlkKG9wdHMuQSkgfHwgIUZwLmlzVmFsaWQob3B0cy5CKSB8fCAhRnAuaXNWYWxpZChvcHRzLlopKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcFRvQ3VydmVTaW1wbGVTV1U6IGludmFsaWQgb3B0cycpO1xuICAgIGNvbnN0IHNxcnRSYXRpbyA9IFNXVUZwU3FydFJhdGlvKEZwLCBvcHRzLlopO1xuICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRnAuaXNPZGQgaXMgbm90IGltcGxlbWVudGVkIScpO1xuICAgIC8vIElucHV0OiB1LCBhbiBlbGVtZW50IG9mIEYuXG4gICAgLy8gT3V0cHV0OiAoeCwgeSksIGEgcG9pbnQgb24gRS5cbiAgICByZXR1cm4gKHUpID0+IHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGxldCB0djEsIHR2MiwgdHYzLCB0djQsIHR2NSwgdHY2LCB4LCB5O1xuICAgICAgICB0djEgPSBGcC5zcXIodSk7IC8vIDEuICB0djEgPSB1XjJcbiAgICAgICAgdHYxID0gRnAubXVsKHR2MSwgb3B0cy5aKTsgLy8gMi4gIHR2MSA9IFogKiB0djFcbiAgICAgICAgdHYyID0gRnAuc3FyKHR2MSk7IC8vIDMuICB0djIgPSB0djFeMlxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djEpOyAvLyA0LiAgdHYyID0gdHYyICsgdHYxXG4gICAgICAgIHR2MyA9IEZwLmFkZCh0djIsIEZwLk9ORSk7IC8vIDUuICB0djMgPSB0djIgKyAxXG4gICAgICAgIHR2MyA9IEZwLm11bCh0djMsIG9wdHMuQik7IC8vIDYuICB0djMgPSBCICogdHYzXG4gICAgICAgIHR2NCA9IEZwLmNtb3Yob3B0cy5aLCBGcC5uZWcodHYyKSwgIUZwLmVxbCh0djIsIEZwLlpFUk8pKTsgLy8gNy4gIHR2NCA9IENNT1YoWiwgLXR2MiwgdHYyICE9IDApXG4gICAgICAgIHR2NCA9IEZwLm11bCh0djQsIG9wdHMuQSk7IC8vIDguICB0djQgPSBBICogdHY0XG4gICAgICAgIHR2MiA9IEZwLnNxcih0djMpOyAvLyA5LiAgdHYyID0gdHYzXjJcbiAgICAgICAgdHY2ID0gRnAuc3FyKHR2NCk7IC8vIDEwLiB0djYgPSB0djReMlxuICAgICAgICB0djUgPSBGcC5tdWwodHY2LCBvcHRzLkEpOyAvLyAxMS4gdHY1ID0gQSAqIHR2NlxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djUpOyAvLyAxMi4gdHYyID0gdHYyICsgdHY1XG4gICAgICAgIHR2MiA9IEZwLm11bCh0djIsIHR2Myk7IC8vIDEzLiB0djIgPSB0djIgKiB0djNcbiAgICAgICAgdHY2ID0gRnAubXVsKHR2NiwgdHY0KTsgLy8gMTQuIHR2NiA9IHR2NiAqIHR2NFxuICAgICAgICB0djUgPSBGcC5tdWwodHY2LCBvcHRzLkIpOyAvLyAxNS4gdHY1ID0gQiAqIHR2NlxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djUpOyAvLyAxNi4gdHYyID0gdHYyICsgdHY1XG4gICAgICAgIHggPSBGcC5tdWwodHYxLCB0djMpOyAvLyAxNy4gICB4ID0gdHYxICogdHYzXG4gICAgICAgIGNvbnN0IHsgaXNWYWxpZCwgdmFsdWUgfSA9IHNxcnRSYXRpbyh0djIsIHR2Nik7IC8vIDE4LiAoaXNfZ3gxX3NxdWFyZSwgeTEpID0gc3FydF9yYXRpbyh0djIsIHR2NilcbiAgICAgICAgeSA9IEZwLm11bCh0djEsIHUpOyAvLyAxOS4gICB5ID0gdHYxICogdSAgLT4gWiAqIHVeMyAqIHkxXG4gICAgICAgIHkgPSBGcC5tdWwoeSwgdmFsdWUpOyAvLyAyMC4gICB5ID0geSAqIHkxXG4gICAgICAgIHggPSBGcC5jbW92KHgsIHR2MywgaXNWYWxpZCk7IC8vIDIxLiAgIHggPSBDTU9WKHgsIHR2MywgaXNfZ3gxX3NxdWFyZSlcbiAgICAgICAgeSA9IEZwLmNtb3YoeSwgdmFsdWUsIGlzVmFsaWQpOyAvLyAyMi4gICB5ID0gQ01PVih5LCB5MSwgaXNfZ3gxX3NxdWFyZSlcbiAgICAgICAgY29uc3QgZTEgPSBGcC5pc09kZCh1KSA9PT0gRnAuaXNPZGQoeSk7IC8vIDIzLiAgZTEgPSBzZ24wKHUpID09IHNnbjAoeSlcbiAgICAgICAgeSA9IEZwLmNtb3YoRnAubmVnKHkpLCB5LCBlMSk7IC8vIDI0LiAgIHkgPSBDTU9WKC15LCB5LCBlMSlcbiAgICAgICAgY29uc3QgdHY0X2ludiA9IEZwSW52ZXJ0QmF0Y2goRnAsIFt0djRdLCB0cnVlKVswXTtcbiAgICAgICAgeCA9IEZwLm11bCh4LCB0djRfaW52KTsgLy8gMjUuICAgeCA9IHggLyB0djRcbiAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWllcnN0cmFzcy5qcy5tYXAiXSwibmFtZXMiOlsicGlwcGVuZ2VyIiwidmFsaWRhdGVCYXNpYyIsIndOQUYiLCJGaWVsZCIsIkZwSW52ZXJ0QmF0Y2giLCJnZXRNaW5IYXNoTGVuZ3RoIiwiaW52ZXJ0IiwibWFwSGFzaFRvRmllbGQiLCJtb2QiLCJ2YWxpZGF0ZUZpZWxkIiwiYUluUmFuZ2UiLCJhYm9vbCIsImJpdE1hc2siLCJieXRlc1RvSGV4IiwiYnl0ZXNUb051bWJlckJFIiwiY29uY2F0Qnl0ZXMiLCJjcmVhdGVIbWFjRHJiZyIsImVuc3VyZUJ5dGVzIiwiaGV4VG9CeXRlcyIsImluUmFuZ2UiLCJpc0J5dGVzIiwibWVtb2l6ZWQiLCJudW1iZXJUb0J5dGVzQkUiLCJudW1iZXJUb0hleFVucGFkZGVkIiwidmFsaWRhdGVPYmplY3QiLCJ2YWxpZGF0ZVNpZ1Zlck9wdHMiLCJvcHRzIiwibG93UyIsInVuZGVmaW5lZCIsInByZWhhc2giLCJ2YWxpZGF0ZVBvaW50T3B0cyIsImN1cnZlIiwiYSIsImIiLCJhbGxvd0luZmluaXR5UG9pbnQiLCJhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHMiLCJjbGVhckNvZmFjdG9yIiwiZnJvbUJ5dGVzIiwiaXNUb3JzaW9uRnJlZSIsInRvQnl0ZXMiLCJ3cmFwUHJpdmF0ZUtleSIsImVuZG8iLCJGcCIsImVxbCIsIlpFUk8iLCJFcnJvciIsImJldGEiLCJzcGxpdFNjYWxhciIsIk9iamVjdCIsImZyZWV6ZSIsIkRFUkVyciIsImNvbnN0cnVjdG9yIiwibSIsIkRFUiIsIkVyciIsIl90bHYiLCJlbmNvZGUiLCJ0YWciLCJkYXRhIiwiRSIsImxlbmd0aCIsImRhdGFMZW4iLCJsZW4iLCJsZW5MZW4iLCJ0IiwiZGVjb2RlIiwicG9zIiwiZmlyc3QiLCJpc0xvbmciLCJsZW5ndGhCeXRlcyIsInN1YmFycmF5IiwidiIsImwiLCJfaW50IiwibnVtIiwiXzBuIiwiaGV4IiwiTnVtYmVyIiwicGFyc2VJbnQiLCJ0b1NpZyIsImludCIsInRsdiIsInNlcUJ5dGVzIiwic2VxTGVmdEJ5dGVzIiwickJ5dGVzIiwickxlZnRCeXRlcyIsInNCeXRlcyIsInNMZWZ0Qnl0ZXMiLCJyIiwicyIsImhleEZyb21TaWciLCJzaWciLCJycyIsInNzIiwic2VxIiwibnVtVG9TaXplZEhleCIsInNpemUiLCJCaWdJbnQiLCJfMW4iLCJfMm4iLCJfM24iLCJfNG4iLCJ3ZWllcnN0cmFzc1BvaW50cyIsIkNVUlZFIiwiRm4iLCJuIiwibkJpdExlbmd0aCIsIl9jIiwicG9pbnQiLCJfaXNDb21wcmVzc2VkIiwidG9BZmZpbmUiLCJVaW50OEFycmF5IiwiZnJvbSIsIngiLCJ5IiwiYnl0ZXMiLCJ0YWlsIiwiQllURVMiLCJ3ZWllcnN0cmFzc0VxdWF0aW9uIiwieDIiLCJzcXIiLCJ4MyIsIm11bCIsImFkZCIsImlzVmFsaWRYWSIsImxlZnQiLCJyaWdodCIsIkd4IiwiR3kiLCJfNGEzIiwicG93IiwiXzI3YjIiLCJpczAiLCJpc1dpdGhpbkN1cnZlT3JkZXIiLCJub3JtUHJpdmF0ZUtleVRvU2NhbGFyIiwia2V5IiwibGVuZ3RocyIsIm5CeXRlTGVuZ3RoIiwiTiIsImluY2x1ZGVzIiwicGFkU3RhcnQiLCJlcnJvciIsImFwcmpwb2ludCIsIm90aGVyIiwiUG9pbnQiLCJ0b0FmZmluZU1lbW8iLCJwIiwiaXoiLCJweCIsInB5IiwicHoiLCJ6IiwiT05FIiwiaW52IiwiYXgiLCJheSIsInp6IiwiYXNzZXJ0VmFsaWRNZW1vIiwiaXNWYWxpZCIsImZyb21BZmZpbmUiLCJpIiwibm9ybWFsaXplWiIsInBvaW50cyIsInRvSW52IiwibWFwIiwiZnJvbUhleCIsIlAiLCJhc3NlcnRWYWxpZGl0eSIsImZyb21Qcml2YXRlS2V5IiwicHJpdmF0ZUtleSIsIkJBU0UiLCJtdWx0aXBseSIsIm1zbSIsInNjYWxhcnMiLCJfc2V0V2luZG93U2l6ZSIsIndpbmRvd1NpemUiLCJ3bmFmIiwic2V0V2luZG93U2l6ZSIsImhhc0V2ZW5ZIiwiaXNPZGQiLCJlcXVhbHMiLCJYMSIsIlkxIiwiWjEiLCJYMiIsIlkyIiwiWjIiLCJVMSIsIlUyIiwibmVnYXRlIiwibmVnIiwiZG91YmxlIiwiYjMiLCJYMyIsIlkzIiwiWjMiLCJ0MCIsInQxIiwidDIiLCJ0MyIsInN1YiIsInQ0IiwidDUiLCJzdWJ0cmFjdCIsIndOQUZDYWNoZWQiLCJtdWx0aXBseVVuc2FmZSIsInNjIiwiSSIsImhhc1ByZWNvbXB1dGVzIiwid05BRkNhY2hlZFVuc2FmZSIsImsxbmVnIiwiazEiLCJrMm5lZyIsImsyIiwiazFwIiwiazJwIiwiZCIsInNjYWxhciIsImZha2UiLCJmIiwiZjFwIiwiZjJwIiwiY29uc3RUaW1lTmVnYXRlIiwibXVsdGlwbHlBbmRBZGRVbnNhZmUiLCJRIiwiRyIsInN1bSIsImgiLCJjb2ZhY3RvciIsInRvUmF3Qnl0ZXMiLCJpc0NvbXByZXNzZWQiLCJ0b0hleCIsIk1hdGgiLCJjZWlsIiwiUHJvamVjdGl2ZVBvaW50IiwidmFsaWRhdGVPcHRzIiwiaGFzaCIsImhtYWMiLCJyYW5kb21CeXRlcyIsImJpdHMyaW50IiwiYml0czJpbnRfbW9kTiIsIndlaWVyc3RyYXNzIiwiY3VydmVEZWYiLCJDVVJWRV9PUkRFUiIsImNvbXByZXNzZWRMZW4iLCJ1bmNvbXByZXNzZWRMZW4iLCJtb2ROIiwiaW52TiIsImNhdCIsImhlYWQiLCJPUkRFUiIsInkyIiwic3FydCIsInNxcnRFcnJvciIsInN1ZmZpeCIsIm1lc3NhZ2UiLCJpc1lPZGQiLCJpc0hlYWRPZGQiLCJjbCIsInVsIiwiaXNCaWdnZXJUaGFuSGFsZk9yZGVyIiwibnVtYmVyIiwiSEFMRiIsIm5vcm1hbGl6ZVMiLCJzbGNOdW0iLCJ0byIsInNsaWNlIiwiU2lnbmF0dXJlIiwicmVjb3ZlcnkiLCJmcm9tQ29tcGFjdCIsImZyb21ERVIiLCJhZGRSZWNvdmVyeUJpdCIsInJlY292ZXJQdWJsaWNLZXkiLCJtc2dIYXNoIiwicmVjIiwicmFkaiIsInByZWZpeCIsIlIiLCJpciIsInUxIiwidTIiLCJoYXNIaWdoUyIsInRvREVSUmF3Qnl0ZXMiLCJ0b0RFUkhleCIsInRvQ29tcGFjdFJhd0J5dGVzIiwidG9Db21wYWN0SGV4IiwidXRpbHMiLCJpc1ZhbGlkUHJpdmF0ZUtleSIsInJhbmRvbVByaXZhdGVLZXkiLCJwcmVjb21wdXRlIiwiZ2V0UHVibGljS2V5IiwiaXNQcm9iUHViIiwiaXRlbSIsImFyciIsImZwbCIsImNvbXBMZW4iLCJ1bmNvbXBMZW4iLCJnZXRTaGFyZWRTZWNyZXQiLCJwcml2YXRlQSIsInB1YmxpY0IiLCJkZWx0YSIsIk9SREVSX01BU0siLCJpbnQyb2N0ZXRzIiwicHJlcFNpZyIsImRlZmF1bHRTaWdPcHRzIiwic29tZSIsImsiLCJleHRyYUVudHJvcHkiLCJlbnQiLCJoMWludCIsInNlZWRBcmdzIiwiZSIsInB1c2giLCJzZWVkIiwiazJzaWciLCJrQnl0ZXMiLCJpayIsInEiLCJub3JtUyIsImRlZmF1bHRWZXJPcHRzIiwic2lnbiIsInByaXZLZXkiLCJDIiwiZHJiZyIsIm91dHB1dExlbiIsInZlcmlmeSIsInNpZ25hdHVyZSIsInB1YmxpY0tleSIsInNnIiwiZm9ybWF0IiwiaXNIZXgiLCJpc09iaiIsIl9zaWciLCJkZXJFcnJvciIsImlzIiwiU1dVRnBTcXJ0UmF0aW8iLCJaIiwibyIsImMxIiwiXzJuX3Bvd19jMV8xIiwiXzJuX3Bvd19jMSIsImMyIiwiYzMiLCJjNCIsImM1IiwiYzYiLCJjNyIsInNxcnRSYXRpbyIsInUiLCJ0djEiLCJ0djIiLCJ0djMiLCJ0djUiLCJ0djQiLCJpc1FSIiwiY21vdiIsInR2djUiLCJlMSIsInZhbHVlIiwieTEiLCJtYXBUb0N1cnZlU2ltcGxlU1dVIiwiQSIsIkIiLCJ0djYiLCJ0djRfaW52Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/abstract/weierstrass.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/nist.js":
/*!****************************************************************!*\
  !*** ./node_modules/ox/node_modules/@noble/curves/esm/nist.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   p256: () => (/* binding */ p256),\n/* harmony export */   p256_hasher: () => (/* binding */ p256_hasher),\n/* harmony export */   p384: () => (/* binding */ p384),\n/* harmony export */   p384_hasher: () => (/* binding */ p384_hasher),\n/* harmony export */   p521: () => (/* binding */ p521),\n/* harmony export */   p521_hasher: () => (/* binding */ p521_hasher),\n/* harmony export */   secp256r1: () => (/* binding */ secp256r1),\n/* harmony export */   secp384r1: () => (/* binding */ secp384r1),\n/* harmony export */   secp521r1: () => (/* binding */ secp521r1)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/sha2 */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/sha2.js\");\n/* harmony import */ var _shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_shortw_utils.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/_shortw_utils.js\");\n/* harmony import */ var _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/* harmony import */ var _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract/modular.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/**\n * Internal module for NIST P256, P384, P521 curves.\n * Do not use for now.\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\n\n\n\nconst Fp256 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(BigInt(\"0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff\"));\nconst p256_a = Fp256.create(BigInt(\"-3\"));\nconst p256_b = BigInt(\"0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b\");\n/**\n * secp256r1 curve, ECDSA and ECDH methods.\n * Field: `2n**224n * (2n**32n-1n) + 2n**192n + 2n**96n-1n`\n */ // prettier-ignore\nconst p256 = (0,_shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__.createCurve)({\n    a: p256_a,\n    b: p256_b,\n    Fp: Fp256,\n    n: BigInt(\"0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551\"),\n    Gx: BigInt(\"0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296\"),\n    Gy: BigInt(\"0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5\"),\n    h: BigInt(1),\n    lowS: false\n}, _noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__.sha256);\n/** Alias to p256. */ const secp256r1 = p256;\nconst p256_mapSWU = /* @__PURE__ */ (()=>(0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_3__.mapToCurveSimpleSWU)(Fp256, {\n        A: p256_a,\n        B: p256_b,\n        Z: Fp256.create(BigInt(\"-10\"))\n    }))();\n/** Hashing / encoding to p256 points / field. RFC 9380 methods. */ const p256_hasher = /* @__PURE__ */ (()=>(0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_4__.createHasher)(secp256r1.ProjectivePoint, (scalars)=>p256_mapSWU(scalars[0]), {\n        DST: \"P256_XMD:SHA-256_SSWU_RO_\",\n        encodeDST: \"P256_XMD:SHA-256_SSWU_NU_\",\n        p: Fp256.ORDER,\n        m: 1,\n        k: 128,\n        expand: \"xmd\",\n        hash: _noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__.sha256\n    }))();\n// Field over which we'll do calculations.\nconst Fp384 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(BigInt(\"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff\"));\nconst p384_a = Fp384.create(BigInt(\"-3\"));\n// prettier-ignore\nconst p384_b = BigInt(\"0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef\");\n/**\n * secp384r1 curve, ECDSA and ECDH methods.\n * Field: `2n**384n - 2n**128n - 2n**96n + 2n**32n - 1n`.\n * */ // prettier-ignore\nconst p384 = (0,_shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__.createCurve)({\n    a: p384_a,\n    b: p384_b,\n    Fp: Fp384,\n    n: BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973\"),\n    Gx: BigInt(\"0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7\"),\n    Gy: BigInt(\"0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f\"),\n    h: BigInt(1),\n    lowS: false\n}, _noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__.sha384);\n/** Alias to p384. */ const secp384r1 = p384;\nconst p384_mapSWU = /* @__PURE__ */ (()=>(0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_3__.mapToCurveSimpleSWU)(Fp384, {\n        A: p384_a,\n        B: p384_b,\n        Z: Fp384.create(BigInt(\"-12\"))\n    }))();\n/** Hashing / encoding to p384 points / field. RFC 9380 methods. */ const p384_hasher = /* @__PURE__ */ (()=>(0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_4__.createHasher)(secp384r1.ProjectivePoint, (scalars)=>p384_mapSWU(scalars[0]), {\n        DST: \"P384_XMD:SHA-384_SSWU_RO_\",\n        encodeDST: \"P384_XMD:SHA-384_SSWU_NU_\",\n        p: Fp384.ORDER,\n        m: 1,\n        k: 192,\n        expand: \"xmd\",\n        hash: _noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__.sha384\n    }))();\n// Field over which we'll do calculations.\nconst Fp521 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(BigInt(\"0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"));\nconst p521_a = Fp521.create(BigInt(\"-3\"));\nconst p521_b = BigInt(\"0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00\");\n/**\n * NIST secp521r1 aka p521 curve, ECDSA and ECDH methods.\n * Field: `2n**521n - 1n`.\n */ // prettier-ignore\nconst p521 = (0,_shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__.createCurve)({\n    a: p521_a,\n    b: p521_b,\n    Fp: Fp521,\n    n: BigInt(\"0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409\"),\n    Gx: BigInt(\"0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66\"),\n    Gy: BigInt(\"0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650\"),\n    h: BigInt(1),\n    lowS: false,\n    allowedPrivateKeyLengths: [\n        130,\n        131,\n        132\n    ] // P521 keys are variable-length. Normalize to 132b\n}, _noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__.sha512);\n/** Alias to p521. */ const secp521r1 = p521;\nconst p521_mapSWU = /* @__PURE__ */ (()=>(0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_3__.mapToCurveSimpleSWU)(Fp521, {\n        A: p521_a,\n        B: p521_b,\n        Z: Fp521.create(BigInt(\"-4\"))\n    }))();\n/** Hashing / encoding to p521 points / field. RFC 9380 methods. */ const p521_hasher = /* @__PURE__ */ (()=>(0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_4__.createHasher)(secp521r1.ProjectivePoint, (scalars)=>p521_mapSWU(scalars[0]), {\n        DST: \"P521_XMD:SHA-512_SSWU_RO_\",\n        encodeDST: \"P521_XMD:SHA-512_SSWU_NU_\",\n        p: Fp521.ORDER,\n        m: 1,\n        k: 256,\n        expand: \"xmd\",\n        hash: _noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__.sha512\n    }))(); //# sourceMappingURL=nist.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL25pc3QuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7OztDQUlDLEdBQ0Qsb0VBQW9FLEdBQ1I7QUFDWDtBQUNVO0FBQ2I7QUFDa0I7QUFDaEUsTUFBTU8sUUFBUUYsMkRBQUtBLENBQUNHLE9BQU87QUFDM0IsTUFBTUMsU0FBU0YsTUFBTUcsTUFBTSxDQUFDRixPQUFPO0FBQ25DLE1BQU1HLFNBQVNILE9BQU87QUFDdEI7OztDQUdDLEdBQ0Qsa0JBQWtCO0FBQ1gsTUFBTUksT0FBT1QsNkRBQVdBLENBQUM7SUFDNUJVLEdBQUdKO0lBQ0hLLEdBQUdIO0lBQ0hJLElBQUlSO0lBQ0pTLEdBQUdSLE9BQU87SUFDVlMsSUFBSVQsT0FBTztJQUNYVSxJQUFJVixPQUFPO0lBQ1hXLEdBQUdYLE9BQU87SUFDVlksTUFBTTtBQUNWLEdBQUdwQixzREFBTUEsRUFBRTtBQUNYLG1CQUFtQixHQUNaLE1BQU1xQixZQUFZVCxLQUFLO0FBQzlCLE1BQU1VLGNBQThCLGFBQUgsR0FBSSxLQUFNaEIsNkVBQW1CQSxDQUFDQyxPQUFPO1FBQ2xFZ0IsR0FBR2Q7UUFDSGUsR0FBR2I7UUFDSGMsR0FBR2xCLE1BQU1HLE1BQU0sQ0FBQ0YsT0FBTztJQUMzQixFQUFDO0FBQ0QsaUVBQWlFLEdBQzFELE1BQU1rQixjQUE4QixhQUFILEdBQUksS0FBTXRCLHdFQUFZQSxDQUFDaUIsVUFBVU0sZUFBZSxFQUFFLENBQUNDLFVBQVlOLFlBQVlNLE9BQU8sQ0FBQyxFQUFFLEdBQUc7UUFDNUhDLEtBQUs7UUFDTEMsV0FBVztRQUNYQyxHQUFHeEIsTUFBTXlCLEtBQUs7UUFDZEMsR0FBRztRQUNIQyxHQUFHO1FBQ0hDLFFBQVE7UUFDUkMsTUFBTXBDLHNEQUFNQTtJQUNoQixFQUFDLElBQUs7QUFDTiwwQ0FBMEM7QUFDMUMsTUFBTXFDLFFBQVFoQywyREFBS0EsQ0FBQ0csT0FBTztBQUMzQixNQUFNOEIsU0FBU0QsTUFBTTNCLE1BQU0sQ0FBQ0YsT0FBTztBQUNuQyxrQkFBa0I7QUFDbEIsTUFBTStCLFNBQVMvQixPQUFPO0FBQ3RCOzs7R0FHRyxHQUNILGtCQUFrQjtBQUNYLE1BQU1nQyxPQUFPckMsNkRBQVdBLENBQUM7SUFDNUJVLEdBQUd5QjtJQUNIeEIsR0FBR3lCO0lBQ0h4QixJQUFJc0I7SUFDSnJCLEdBQUdSLE9BQU87SUFDVlMsSUFBSVQsT0FBTztJQUNYVSxJQUFJVixPQUFPO0lBQ1hXLEdBQUdYLE9BQU87SUFDVlksTUFBTTtBQUNWLEdBQUduQixzREFBTUEsRUFBRTtBQUNYLG1CQUFtQixHQUNaLE1BQU13QyxZQUFZRCxLQUFLO0FBQzlCLE1BQU1FLGNBQThCLGFBQUgsR0FBSSxLQUFNcEMsNkVBQW1CQSxDQUFDK0IsT0FBTztRQUNsRWQsR0FBR2U7UUFDSGQsR0FBR2U7UUFDSGQsR0FBR1ksTUFBTTNCLE1BQU0sQ0FBQ0YsT0FBTztJQUMzQixFQUFDO0FBQ0QsaUVBQWlFLEdBQzFELE1BQU1tQyxjQUE4QixhQUFILEdBQUksS0FBTXZDLHdFQUFZQSxDQUFDcUMsVUFBVWQsZUFBZSxFQUFFLENBQUNDLFVBQVljLFlBQVlkLE9BQU8sQ0FBQyxFQUFFLEdBQUc7UUFDNUhDLEtBQUs7UUFDTEMsV0FBVztRQUNYQyxHQUFHTSxNQUFNTCxLQUFLO1FBQ2RDLEdBQUc7UUFDSEMsR0FBRztRQUNIQyxRQUFRO1FBQ1JDLE1BQU1uQyxzREFBTUE7SUFDaEIsRUFBQyxJQUFLO0FBQ04sMENBQTBDO0FBQzFDLE1BQU0yQyxRQUFRdkMsMkRBQUtBLENBQUNHLE9BQU87QUFDM0IsTUFBTXFDLFNBQVNELE1BQU1sQyxNQUFNLENBQUNGLE9BQU87QUFDbkMsTUFBTXNDLFNBQVN0QyxPQUFPO0FBQ3RCOzs7Q0FHQyxHQUNELGtCQUFrQjtBQUNYLE1BQU11QyxPQUFPNUMsNkRBQVdBLENBQUM7SUFDNUJVLEdBQUdnQztJQUNIL0IsR0FBR2dDO0lBQ0gvQixJQUFJNkI7SUFDSjVCLEdBQUdSLE9BQU87SUFDVlMsSUFBSVQsT0FBTztJQUNYVSxJQUFJVixPQUFPO0lBQ1hXLEdBQUdYLE9BQU87SUFDVlksTUFBTTtJQUNONEIsMEJBQTBCO1FBQUM7UUFBSztRQUFLO0tBQUksQ0FBQyxtREFBbUQ7QUFDakcsR0FBRzlDLHNEQUFNQSxFQUFFO0FBQ1gsbUJBQW1CLEdBQ1osTUFBTStDLFlBQVlGLEtBQUs7QUFDOUIsTUFBTUcsY0FBOEIsYUFBSCxHQUFJLEtBQU01Qyw2RUFBbUJBLENBQUNzQyxPQUFPO1FBQ2xFckIsR0FBR3NCO1FBQ0hyQixHQUFHc0I7UUFDSHJCLEdBQUdtQixNQUFNbEMsTUFBTSxDQUFDRixPQUFPO0lBQzNCLEVBQUM7QUFDRCxpRUFBaUUsR0FDMUQsTUFBTTJDLGNBQThCLGFBQUgsR0FBSSxLQUFNL0Msd0VBQVlBLENBQUM2QyxVQUFVdEIsZUFBZSxFQUFFLENBQUNDLFVBQVlzQixZQUFZdEIsT0FBTyxDQUFDLEVBQUUsR0FBRztRQUM1SEMsS0FBSztRQUNMQyxXQUFXO1FBQ1hDLEdBQUdhLE1BQU1aLEtBQUs7UUFDZEMsR0FBRztRQUNIQyxHQUFHO1FBQ0hDLFFBQVE7UUFDUkMsTUFBTWxDLHNEQUFNQTtJQUNoQixFQUFDLElBQUssQ0FDTixnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGF3LXdvcmtzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9uaXN0LmpzP2Q0NDQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBJbnRlcm5hbCBtb2R1bGUgZm9yIE5JU1QgUDI1NiwgUDM4NCwgUDUyMSBjdXJ2ZXMuXG4gKiBEbyBub3QgdXNlIGZvciBub3cuXG4gKiBAbW9kdWxlXG4gKi9cbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7IHNoYTI1Niwgc2hhMzg0LCBzaGE1MTIgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3NoYTInO1xuaW1wb3J0IHsgY3JlYXRlQ3VydmUgfSBmcm9tIFwiLi9fc2hvcnR3X3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBjcmVhdGVIYXNoZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzXCI7XG5pbXBvcnQgeyBGaWVsZCB9IGZyb20gXCIuL2Fic3RyYWN0L21vZHVsYXIuanNcIjtcbmltcG9ydCB7IG1hcFRvQ3VydmVTaW1wbGVTV1UgfSBmcm9tIFwiLi9hYnN0cmFjdC93ZWllcnN0cmFzcy5qc1wiO1xuY29uc3QgRnAyNTYgPSBGaWVsZChCaWdJbnQoJzB4ZmZmZmZmZmYwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZicpKTtcbmNvbnN0IHAyNTZfYSA9IEZwMjU2LmNyZWF0ZShCaWdJbnQoJy0zJykpO1xuY29uc3QgcDI1Nl9iID0gQmlnSW50KCcweDVhYzYzNWQ4YWEzYTkzZTdiM2ViYmQ1NTc2OTg4NmJjNjUxZDA2YjBjYzUzYjBmNjNiY2UzYzNlMjdkMjYwNGInKTtcbi8qKlxuICogc2VjcDI1NnIxIGN1cnZlLCBFQ0RTQSBhbmQgRUNESCBtZXRob2RzLlxuICogRmllbGQ6IGAybioqMjI0biAqICgybioqMzJuLTFuKSArIDJuKioxOTJuICsgMm4qKjk2bi0xbmBcbiAqL1xuLy8gcHJldHRpZXItaWdub3JlXG5leHBvcnQgY29uc3QgcDI1NiA9IGNyZWF0ZUN1cnZlKHtcbiAgICBhOiBwMjU2X2EsXG4gICAgYjogcDI1Nl9iLFxuICAgIEZwOiBGcDI1NixcbiAgICBuOiBCaWdJbnQoJzB4ZmZmZmZmZmYwMDAwMDAwMGZmZmZmZmZmZmZmZmZmZmZiY2U2ZmFhZGE3MTc5ZTg0ZjNiOWNhYzJmYzYzMjU1MScpLFxuICAgIEd4OiBCaWdJbnQoJzB4NmIxN2QxZjJlMTJjNDI0N2Y4YmNlNmU1NjNhNDQwZjI3NzAzN2Q4MTJkZWIzM2EwZjRhMTM5NDVkODk4YzI5NicpLFxuICAgIEd5OiBCaWdJbnQoJzB4NGZlMzQyZTJmZTFhN2Y5YjhlZTdlYjRhN2MwZjllMTYyYmNlMzM1NzZiMzE1ZWNlY2JiNjQwNjgzN2JmNTFmNScpLFxuICAgIGg6IEJpZ0ludCgxKSxcbiAgICBsb3dTOiBmYWxzZVxufSwgc2hhMjU2KTtcbi8qKiBBbGlhcyB0byBwMjU2LiAqL1xuZXhwb3J0IGNvbnN0IHNlY3AyNTZyMSA9IHAyNTY7XG5jb25zdCBwMjU2X21hcFNXVSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gbWFwVG9DdXJ2ZVNpbXBsZVNXVShGcDI1Niwge1xuICAgIEE6IHAyNTZfYSxcbiAgICBCOiBwMjU2X2IsXG4gICAgWjogRnAyNTYuY3JlYXRlKEJpZ0ludCgnLTEwJykpLFxufSkpKCk7XG4vKiogSGFzaGluZyAvIGVuY29kaW5nIHRvIHAyNTYgcG9pbnRzIC8gZmllbGQuIFJGQyA5MzgwIG1ldGhvZHMuICovXG5leHBvcnQgY29uc3QgcDI1Nl9oYXNoZXIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGNyZWF0ZUhhc2hlcihzZWNwMjU2cjEuUHJvamVjdGl2ZVBvaW50LCAoc2NhbGFycykgPT4gcDI1Nl9tYXBTV1Uoc2NhbGFyc1swXSksIHtcbiAgICBEU1Q6ICdQMjU2X1hNRDpTSEEtMjU2X1NTV1VfUk9fJyxcbiAgICBlbmNvZGVEU1Q6ICdQMjU2X1hNRDpTSEEtMjU2X1NTV1VfTlVfJyxcbiAgICBwOiBGcDI1Ni5PUkRFUixcbiAgICBtOiAxLFxuICAgIGs6IDEyOCxcbiAgICBleHBhbmQ6ICd4bWQnLFxuICAgIGhhc2g6IHNoYTI1Nixcbn0pKSgpO1xuLy8gRmllbGQgb3ZlciB3aGljaCB3ZSdsbCBkbyBjYWxjdWxhdGlvbnMuXG5jb25zdCBGcDM4NCA9IEZpZWxkKEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZmZmZmZmZmYwMDAwMDAwMDAwMDAwMDAwZmZmZmZmZmYnKSk7XG5jb25zdCBwMzg0X2EgPSBGcDM4NC5jcmVhdGUoQmlnSW50KCctMycpKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgcDM4NF9iID0gQmlnSW50KCcweGIzMzEyZmE3ZTIzZWU3ZTQ5ODhlMDU2YmUzZjgyZDE5MTgxZDljNmVmZTgxNDExMjAzMTQwODhmNTAxMzg3NWFjNjU2Mzk4ZDhhMmVkMTlkMmE4NWM4ZWRkM2VjMmFlZicpO1xuLyoqXG4gKiBzZWNwMzg0cjEgY3VydmUsIEVDRFNBIGFuZCBFQ0RIIG1ldGhvZHMuXG4gKiBGaWVsZDogYDJuKiozODRuIC0gMm4qKjEyOG4gLSAybioqOTZuICsgMm4qKjMybiAtIDFuYC5cbiAqICovXG4vLyBwcmV0dGllci1pZ25vcmVcbmV4cG9ydCBjb25zdCBwMzg0ID0gY3JlYXRlQ3VydmUoe1xuICAgIGE6IHAzODRfYSxcbiAgICBiOiBwMzg0X2IsXG4gICAgRnA6IEZwMzg0LFxuICAgIG46IEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZjNzYzNGQ4MWY0MzcyZGRmNTgxYTBkYjI0OGIwYTc3YWVjZWMxOTZhY2NjNTI5NzMnKSxcbiAgICBHeDogQmlnSW50KCcweGFhODdjYTIyYmU4YjA1Mzc4ZWIxYzcxZWYzMjBhZDc0NmUxZDNiNjI4YmE3OWI5ODU5Zjc0MWUwODI1NDJhMzg1NTAyZjI1ZGJmNTUyOTZjM2E1NDVlMzg3Mjc2MGFiNycpLFxuICAgIEd5OiBCaWdJbnQoJzB4MzYxN2RlNGE5NjI2MmM2ZjVkOWU5OGJmOTI5MmRjMjlmOGY0MWRiZDI4OWExNDdjZTlkYTMxMTNiNWYwYjhjMDBhNjBiMWNlMWQ3ZTgxOWQ3YTQzMWQ3YzkwZWEwZTVmJyksXG4gICAgaDogQmlnSW50KDEpLFxuICAgIGxvd1M6IGZhbHNlXG59LCBzaGEzODQpO1xuLyoqIEFsaWFzIHRvIHAzODQuICovXG5leHBvcnQgY29uc3Qgc2VjcDM4NHIxID0gcDM4NDtcbmNvbnN0IHAzODRfbWFwU1dVID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBtYXBUb0N1cnZlU2ltcGxlU1dVKEZwMzg0LCB7XG4gICAgQTogcDM4NF9hLFxuICAgIEI6IHAzODRfYixcbiAgICBaOiBGcDM4NC5jcmVhdGUoQmlnSW50KCctMTInKSksXG59KSkoKTtcbi8qKiBIYXNoaW5nIC8gZW5jb2RpbmcgdG8gcDM4NCBwb2ludHMgLyBmaWVsZC4gUkZDIDkzODAgbWV0aG9kcy4gKi9cbmV4cG9ydCBjb25zdCBwMzg0X2hhc2hlciA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gY3JlYXRlSGFzaGVyKHNlY3AzODRyMS5Qcm9qZWN0aXZlUG9pbnQsIChzY2FsYXJzKSA9PiBwMzg0X21hcFNXVShzY2FsYXJzWzBdKSwge1xuICAgIERTVDogJ1AzODRfWE1EOlNIQS0zODRfU1NXVV9ST18nLFxuICAgIGVuY29kZURTVDogJ1AzODRfWE1EOlNIQS0zODRfU1NXVV9OVV8nLFxuICAgIHA6IEZwMzg0Lk9SREVSLFxuICAgIG06IDEsXG4gICAgazogMTkyLFxuICAgIGV4cGFuZDogJ3htZCcsXG4gICAgaGFzaDogc2hhMzg0LFxufSkpKCk7XG4vLyBGaWVsZCBvdmVyIHdoaWNoIHdlJ2xsIGRvIGNhbGN1bGF0aW9ucy5cbmNvbnN0IEZwNTIxID0gRmllbGQoQmlnSW50KCcweDFmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmJykpO1xuY29uc3QgcDUyMV9hID0gRnA1MjEuY3JlYXRlKEJpZ0ludCgnLTMnKSk7XG5jb25zdCBwNTIxX2IgPSBCaWdJbnQoJzB4MDA1MTk1M2ViOTYxOGUxYzlhMWY5MjlhMjFhMGI2ODU0MGVlYTJkYTcyNWI5OWIzMTVmM2I4YjQ4OTkxOGVmMTA5ZTE1NjE5Mzk1MWVjN2U5MzdiMTY1MmMwYmQzYmIxYmYwNzM1NzNkZjg4M2QyYzM0ZjFlZjQ1MWZkNDZiNTAzZjAwJyk7XG4vKipcbiAqIE5JU1Qgc2VjcDUyMXIxIGFrYSBwNTIxIGN1cnZlLCBFQ0RTQSBhbmQgRUNESCBtZXRob2RzLlxuICogRmllbGQ6IGAybioqNTIxbiAtIDFuYC5cbiAqL1xuLy8gcHJldHRpZXItaWdub3JlXG5leHBvcnQgY29uc3QgcDUyMSA9IGNyZWF0ZUN1cnZlKHtcbiAgICBhOiBwNTIxX2EsXG4gICAgYjogcDUyMV9iLFxuICAgIEZwOiBGcDUyMSxcbiAgICBuOiBCaWdJbnQoJzB4MDFmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmE1MTg2ODc4M2JmMmY5NjZiN2ZjYzAxNDhmNzA5YTVkMDNiYjVjOWI4ODk5YzQ3YWViYjZmYjcxZTkxMzg2NDA5JyksXG4gICAgR3g6IEJpZ0ludCgnMHgwMGM2ODU4ZTA2YjcwNDA0ZTljZDllM2VjYjY2MjM5NWI0NDI5YzY0ODEzOTA1M2ZiNTIxZjgyOGFmNjA2YjRkM2RiYWExNGI1ZTc3ZWZlNzU5MjhmZTFkYzEyN2EyZmZhOGRlMzM0OGIzYzE4NTZhNDI5YmY5N2U3ZTMxYzJlNWJkNjYnKSxcbiAgICBHeTogQmlnSW50KCcweDAxMTgzOTI5NmE3ODlhM2JjMDA0NWM4YTVmYjQyYzdkMWJkOTk4ZjU0NDQ5NTc5YjQ0NjgxN2FmYmQxNzI3M2U2NjJjOTdlZTcyOTk1ZWY0MjY0MGM1NTBiOTAxM2ZhZDA3NjEzNTNjNzA4NmEyNzJjMjQwODhiZTk0NzY5ZmQxNjY1MCcpLFxuICAgIGg6IEJpZ0ludCgxKSxcbiAgICBsb3dTOiBmYWxzZSxcbiAgICBhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHM6IFsxMzAsIDEzMSwgMTMyXSAvLyBQNTIxIGtleXMgYXJlIHZhcmlhYmxlLWxlbmd0aC4gTm9ybWFsaXplIHRvIDEzMmJcbn0sIHNoYTUxMik7XG4vKiogQWxpYXMgdG8gcDUyMS4gKi9cbmV4cG9ydCBjb25zdCBzZWNwNTIxcjEgPSBwNTIxO1xuY29uc3QgcDUyMV9tYXBTV1UgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IG1hcFRvQ3VydmVTaW1wbGVTV1UoRnA1MjEsIHtcbiAgICBBOiBwNTIxX2EsXG4gICAgQjogcDUyMV9iLFxuICAgIFo6IEZwNTIxLmNyZWF0ZShCaWdJbnQoJy00JykpLFxufSkpKCk7XG4vKiogSGFzaGluZyAvIGVuY29kaW5nIHRvIHA1MjEgcG9pbnRzIC8gZmllbGQuIFJGQyA5MzgwIG1ldGhvZHMuICovXG5leHBvcnQgY29uc3QgcDUyMV9oYXNoZXIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGNyZWF0ZUhhc2hlcihzZWNwNTIxcjEuUHJvamVjdGl2ZVBvaW50LCAoc2NhbGFycykgPT4gcDUyMV9tYXBTV1Uoc2NhbGFyc1swXSksIHtcbiAgICBEU1Q6ICdQNTIxX1hNRDpTSEEtNTEyX1NTV1VfUk9fJyxcbiAgICBlbmNvZGVEU1Q6ICdQNTIxX1hNRDpTSEEtNTEyX1NTV1VfTlVfJyxcbiAgICBwOiBGcDUyMS5PUkRFUixcbiAgICBtOiAxLFxuICAgIGs6IDI1NixcbiAgICBleHBhbmQ6ICd4bWQnLFxuICAgIGhhc2g6IHNoYTUxMixcbn0pKSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmlzdC5qcy5tYXAiXSwibmFtZXMiOlsic2hhMjU2Iiwic2hhMzg0Iiwic2hhNTEyIiwiY3JlYXRlQ3VydmUiLCJjcmVhdGVIYXNoZXIiLCJGaWVsZCIsIm1hcFRvQ3VydmVTaW1wbGVTV1UiLCJGcDI1NiIsIkJpZ0ludCIsInAyNTZfYSIsImNyZWF0ZSIsInAyNTZfYiIsInAyNTYiLCJhIiwiYiIsIkZwIiwibiIsIkd4IiwiR3kiLCJoIiwibG93UyIsInNlY3AyNTZyMSIsInAyNTZfbWFwU1dVIiwiQSIsIkIiLCJaIiwicDI1Nl9oYXNoZXIiLCJQcm9qZWN0aXZlUG9pbnQiLCJzY2FsYXJzIiwiRFNUIiwiZW5jb2RlRFNUIiwicCIsIk9SREVSIiwibSIsImsiLCJleHBhbmQiLCJoYXNoIiwiRnAzODQiLCJwMzg0X2EiLCJwMzg0X2IiLCJwMzg0Iiwic2VjcDM4NHIxIiwicDM4NF9tYXBTV1UiLCJwMzg0X2hhc2hlciIsIkZwNTIxIiwicDUyMV9hIiwicDUyMV9iIiwicDUyMSIsImFsbG93ZWRQcml2YXRlS2V5TGVuZ3RocyIsInNlY3A1MjFyMSIsInA1MjFfbWFwU1dVIiwicDUyMV9oYXNoZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/nist.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/p256.js":
/*!****************************************************************!*\
  !*** ./node_modules/ox/node_modules/@noble/curves/esm/p256.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeToCurve: () => (/* binding */ encodeToCurve),\n/* harmony export */   hashToCurve: () => (/* binding */ hashToCurve),\n/* harmony export */   p256: () => (/* binding */ p256),\n/* harmony export */   secp256r1: () => (/* binding */ secp256r1)\n/* harmony export */ });\n/* harmony import */ var _nist_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nist.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/nist.js\");\n/**\n * NIST secp256r1 aka p256.\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\nconst p256 = _nist_js__WEBPACK_IMPORTED_MODULE_0__.p256;\nconst secp256r1 = _nist_js__WEBPACK_IMPORTED_MODULE_0__.p256;\nconst hashToCurve = /* @__PURE__ */ (()=>_nist_js__WEBPACK_IMPORTED_MODULE_0__.p256_hasher.hashToCurve)();\nconst encodeToCurve = /* @__PURE__ */ (()=>_nist_js__WEBPACK_IMPORTED_MODULE_0__.p256_hasher.encodeToCurve)(); //# sourceMappingURL=p256.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL3AyNTYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7O0NBR0MsR0FDRCxvRUFBb0UsR0FDdkI7QUFDVTtBQUNoRCxNQUFNQyxPQUFPQywwQ0FBS0EsQ0FBQztBQUNuQixNQUFNQyxZQUFZRCwwQ0FBS0EsQ0FBQztBQUN4QixNQUFNRSxjQUE4QixhQUFILEdBQUksS0FBTUosaURBQVdBLENBQUNJLFdBQVcsSUFBSTtBQUN0RSxNQUFNQyxnQkFBZ0MsYUFBSCxHQUFJLEtBQU1MLGlEQUFXQSxDQUFDSyxhQUFhLElBQUksQ0FDakYsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xhdy13b3Jrcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vcDI1Ni5qcz9jYjEzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTklTVCBzZWNwMjU2cjEgYWthIHAyNTYuXG4gKiBAbW9kdWxlXG4gKi9cbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7fSBmcm9tIFwiLi9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzXCI7XG5pbXBvcnQgeyBwMjU2X2hhc2hlciwgcDI1NiBhcyBwMjU2biB9IGZyb20gXCIuL25pc3QuanNcIjtcbmV4cG9ydCBjb25zdCBwMjU2ID0gcDI1Nm47XG5leHBvcnQgY29uc3Qgc2VjcDI1NnIxID0gcDI1Nm47XG5leHBvcnQgY29uc3QgaGFzaFRvQ3VydmUgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHAyNTZfaGFzaGVyLmhhc2hUb0N1cnZlKSgpO1xuZXhwb3J0IGNvbnN0IGVuY29kZVRvQ3VydmUgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHAyNTZfaGFzaGVyLmVuY29kZVRvQ3VydmUpKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wMjU2LmpzLm1hcCJdLCJuYW1lcyI6WyJwMjU2X2hhc2hlciIsInAyNTYiLCJwMjU2biIsInNlY3AyNTZyMSIsImhhc2hUb0N1cnZlIiwiZW5jb2RlVG9DdXJ2ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/p256.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/secp256k1.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ox/node_modules/@noble/curves/esm/secp256k1.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeToCurve: () => (/* binding */ encodeToCurve),\n/* harmony export */   hashToCurve: () => (/* binding */ hashToCurve),\n/* harmony export */   schnorr: () => (/* binding */ schnorr),\n/* harmony export */   secp256k1: () => (/* binding */ secp256k1),\n/* harmony export */   secp256k1_hasher: () => (/* binding */ secp256k1_hasher)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/sha2 */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/sha2.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_shortw_utils.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/_shortw_utils.js\");\n/* harmony import */ var _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/* harmony import */ var _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract/modular.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./abstract/utils.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/**\n * NIST secp256k1. See [pdf](https://www.secg.org/sec2-v2.pdf).\n *\n * Seems to be rigid (not backdoored)\n * [as per discussion](https://bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975).\n *\n * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n * [See explanation](https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066).\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\n\n\n\n\n\nconst secp256k1P = BigInt(\"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f\");\nconst secp256k1N = BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a, b)=>(a + b / _2n) / b;\n/**\n * ‚àön = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */ function sqrtMod(y) {\n    const P = secp256k1P;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = y * y * y % P; // x^3, 11\n    const b3 = b2 * b2 * y % P; // x^7\n    const b6 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b3, _3n, P) * b3 % P;\n    const b9 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b6, _3n, P) * b3 % P;\n    const b11 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b9, _2n, P) * b2 % P;\n    const b22 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b11, _11n, P) * b11 % P;\n    const b44 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b22, _22n, P) * b22 % P;\n    const b88 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b44, _44n, P) * b44 % P;\n    const b176 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b88, _88n, P) * b88 % P;\n    const b220 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b176, _44n, P) * b44 % P;\n    const b223 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b220, _3n, P) * b3 % P;\n    const t1 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b223, _23n, P) * b22 % P;\n    const t2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t1, _6n, P) * b2 % P;\n    const root = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t2, _2n, P);\n    if (!Fpk1.eql(Fpk1.sqr(root), y)) throw new Error(\"Cannot find square root\");\n    return root;\n}\nconst Fpk1 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(secp256k1P, undefined, undefined, {\n    sqrt: sqrtMod\n});\n/**\n * secp256k1 curve, ECDSA and ECDH methods.\n *\n * Field: `2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n`\n *\n * @example\n * ```js\n * import { secp256k1 } from '@noble/curves/secp256k1';\n * const priv = secp256k1.utils.randomPrivateKey();\n * const pub = secp256k1.getPublicKey(priv);\n * const msg = new Uint8Array(32).fill(1); // message hash (not message) in ecdsa\n * const sig = secp256k1.sign(msg, priv); // `{prehash: true}` option is available\n * const isValid = secp256k1.verify(sig, msg, pub) === true;\n * ```\n */ const secp256k1 = (0,_shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__.createCurve)({\n    a: _0n,\n    b: BigInt(7),\n    Fp: Fpk1,\n    n: secp256k1N,\n    Gx: BigInt(\"55066263022277343669578718895168534326250603453777594175500187360389116729240\"),\n    Gy: BigInt(\"32670510020758816978083085130507043184471273380659243275938904335757337482424\"),\n    h: BigInt(1),\n    lowS: true,\n    endo: {\n        // Endomorphism, see above\n        beta: BigInt(\"0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\"),\n        splitScalar: (k)=>{\n            const n = secp256k1N;\n            const a1 = BigInt(\"0x3086d221a7d46bcde86c90e49284eb15\");\n            const b1 = -_1n * BigInt(\"0xe4437ed6010e88286f547fa90abfe4c3\");\n            const a2 = BigInt(\"0x114ca50f7a8e2f3f657c1108d9d44cfd8\");\n            const b2 = a1;\n            const POW_2_128 = BigInt(\"0x100000000000000000000000000000000\"); // (2n**128n).toString(16)\n            const c1 = divNearest(b2 * k, n);\n            const c2 = divNearest(-b1 * k, n);\n            let k1 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(k - c1 * a1 - c2 * a2, n);\n            let k2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-c1 * b1 - c2 * b2, n);\n            const k1neg = k1 > POW_2_128;\n            const k2neg = k2 > POW_2_128;\n            if (k1neg) k1 = n - k1;\n            if (k2neg) k2 = n - k2;\n            if (k1 > POW_2_128 || k2 > POW_2_128) {\n                throw new Error(\"splitScalar: Endomorphism failed, k=\" + k);\n            }\n            return {\n                k1neg,\n                k1,\n                k2neg,\n                k2\n            };\n        }\n    }\n}, _noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__.sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */ const TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag, ...messages) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = (0,_noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__.sha256)(Uint8Array.from(tag, (c)=>c.charCodeAt(0)));\n        tagP = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return (0,_noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__.sha256)((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point)=>point.toRawBytes(true).slice(1);\nconst numTo32b = (n)=>(0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.numberToBytesBE)(n, 32);\nconst modP = (x)=>(0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x, secp256k1P);\nconst modN = (x)=>(0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x, secp256k1N);\nconst Point = /* @__PURE__ */ (()=>secp256k1.ProjectivePoint)();\nconst GmulAdd = (Q, a, b)=>Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    let d_ = secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n    let p = Point.fromPrivateKey(d_); // P = d'‚ãÖG; 0 < d' < n check is done inside\n    const scalar = p.hasEvenY() ? d_ : modN(-d_);\n    return {\n        scalar: scalar,\n        bytes: pointToBytes(p)\n    };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */ function lift_x(x) {\n    (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.aInRange)(\"x\", x, _1n, secp256k1P); // Fail if x ‚â• p.\n    const xx = modP(x * x);\n    const c = modP(xx * x + BigInt(7)); // Let c = x¬≥ + 7 mod p.\n    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n    if (y % _2n !== _0n) y = modP(-y); // Return the unique point P such that x(P) = x and\n    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    p.assertValidity();\n    return p;\n}\nconst num = _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE;\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */ function challenge(...args) {\n    return modN(num(taggedHash(\"BIP0340/challenge\", ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */ function schnorrGetPublicKey(privateKey) {\n    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'‚â•n. Ret bytes(d'‚ãÖG)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */ function schnorrSign(message, privateKey, auxRand = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__.randomBytes)(32)) {\n    const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)(\"message\", message);\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n    const a = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)(\"auxRand\", auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = numTo32b(d ^ num(taggedHash(\"BIP0340/aux\", a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash(\"BIP0340/nonce\", t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    const k_ = modN(num(rand)); // Let k' = int(rand) mod n\n    if (k_ === _0n) throw new Error(\"sign failed: k is zero\"); // Fail if k' = 0.\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'‚ãÖG.\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(numTo32b(modN(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px)) throw new Error(\"sign: Invalid signature produced\");\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */ function schnorrVerify(signature, message, publicKey) {\n    const sig = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)(\"signature\", signature, 64);\n    const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)(\"message\", message);\n    const pub = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)(\"publicKey\", publicKey, 32);\n    try {\n        const P = lift_x(num(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = num(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r ‚â• p.\n        if (!(0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.inRange)(r, _1n, secp256k1P)) return false;\n        const s = num(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s ‚â• n.\n        if (!(0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.inRange)(s, _1n, secp256k1N)) return false;\n        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n        const R = GmulAdd(P, s, modN(-e)); // R = s‚ãÖG - e‚ãÖP\n        if (!R || !R.hasEvenY() || R.toAffine().x !== r) return false; // -eP == (n-e)P\n        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R) ‚â† r.\n    } catch (error) {\n        return false;\n    }\n}\n/**\n * Schnorr signatures over secp256k1.\n * https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n * @example\n * ```js\n * import { schnorr } from '@noble/curves/secp256k1';\n * const priv = schnorr.utils.randomPrivateKey();\n * const pub = schnorr.getPublicKey(priv);\n * const msg = new TextEncoder().encode('hello');\n * const sig = schnorr.sign(msg, priv);\n * const isValid = schnorr.verify(sig, msg, pub);\n * ```\n */ const schnorr = /* @__PURE__ */ (()=>({\n        getPublicKey: schnorrGetPublicKey,\n        sign: schnorrSign,\n        verify: schnorrVerify,\n        utils: {\n            randomPrivateKey: secp256k1.utils.randomPrivateKey,\n            lift_x,\n            pointToBytes,\n            numberToBytesBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.numberToBytesBE,\n            bytesToNumberBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE,\n            taggedHash,\n            mod: _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod\n        }\n    }))();\nconst isoMap = /* @__PURE__ */ (()=>(0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.isogenyMap)(Fpk1, [\n        // xNum\n        [\n            \"0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7\",\n            \"0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581\",\n            \"0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262\",\n            \"0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c\"\n        ],\n        // xDen\n        [\n            \"0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b\",\n            \"0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14\",\n            \"0x0000000000000000000000000000000000000000000000000000000000000001\"\n        ],\n        // yNum\n        [\n            \"0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c\",\n            \"0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3\",\n            \"0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931\",\n            \"0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84\"\n        ],\n        // yDen\n        [\n            \"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b\",\n            \"0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573\",\n            \"0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f\",\n            \"0x0000000000000000000000000000000000000000000000000000000000000001\"\n        ]\n    ].map((i)=>i.map((j)=>BigInt(j)))))();\nconst mapSWU = /* @__PURE__ */ (()=>(0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_6__.mapToCurveSimpleSWU)(Fpk1, {\n        A: BigInt(\"0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533\"),\n        B: BigInt(\"1771\"),\n        Z: Fpk1.create(BigInt(\"-11\"))\n    }))();\n/** Hashing / encoding to secp256k1 points / field. RFC 9380 methods. */ const secp256k1_hasher = /* @__PURE__ */ (()=>(0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.createHasher)(secp256k1.ProjectivePoint, (scalars)=>{\n        const { x, y } = mapSWU(Fpk1.create(scalars[0]));\n        return isoMap(x, y);\n    }, {\n        DST: \"secp256k1_XMD:SHA-256_SSWU_RO_\",\n        encodeDST: \"secp256k1_XMD:SHA-256_SSWU_NU_\",\n        p: Fpk1.ORDER,\n        m: 1,\n        k: 128,\n        expand: \"xmd\",\n        hash: _noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__.sha256\n    }))();\nconst hashToCurve = /* @__PURE__ */ (()=>secp256k1_hasher.hashToCurve)();\nconst encodeToCurve = /* @__PURE__ */ (()=>secp256k1_hasher.encodeToCurve)(); //# sourceMappingURL=secp256k1.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL3NlY3AyNTZrMS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Q0FXQyxHQUNELG9FQUFvRSxHQUN4QjtBQUNNO0FBQ0Q7QUFDc0I7QUFDZDtBQUM0RDtBQUNyRDtBQUNoRSxNQUFNZSxhQUFhQyxPQUFPO0FBQzFCLE1BQU1DLGFBQWFELE9BQU87QUFDMUIsTUFBTUUsTUFBTUYsT0FBTztBQUNuQixNQUFNRyxNQUFNSCxPQUFPO0FBQ25CLE1BQU1JLE1BQU1KLE9BQU87QUFDbkIsTUFBTUssYUFBYSxDQUFDQyxHQUFHQyxJQUFNLENBQUNELElBQUlDLElBQUlILEdBQUUsSUFBS0c7QUFDN0M7OztDQUdDLEdBQ0QsU0FBU0MsUUFBUUMsQ0FBQztJQUNkLE1BQU1DLElBQUlYO0lBQ1Ysa0JBQWtCO0lBQ2xCLE1BQU1ZLE1BQU1YLE9BQU8sSUFBSVksTUFBTVosT0FBTyxJQUFJYSxPQUFPYixPQUFPLEtBQUtjLE9BQU9kLE9BQU87SUFDekUsa0JBQWtCO0lBQ2xCLE1BQU1lLE9BQU9mLE9BQU8sS0FBS2dCLE9BQU9oQixPQUFPLEtBQUtpQixPQUFPakIsT0FBTztJQUMxRCxNQUFNa0IsS0FBSyxJQUFLVCxJQUFJQSxJQUFLQyxHQUFHLFVBQVU7SUFDdEMsTUFBTVMsS0FBSyxLQUFNRCxLQUFLVCxJQUFLQyxHQUFHLE1BQU07SUFDcEMsTUFBTVUsS0FBSywyREFBTUQsSUFBSVIsS0FBS0QsS0FBS1MsS0FBTVQ7SUFDckMsTUFBTVcsS0FBSywyREFBTUQsSUFBSVQsS0FBS0QsS0FBS1MsS0FBTVQ7SUFDckMsTUFBTVksTUFBTSwyREFBTUQsSUFBSWpCLEtBQUtNLEtBQUtRLEtBQU1SO0lBQ3RDLE1BQU1hLE1BQU0sMkRBQU1ELEtBQUtULE1BQU1ILEtBQUtZLE1BQU9aO0lBQ3pDLE1BQU1jLE1BQU0sMkRBQU1ELEtBQUtULE1BQU1KLEtB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SSxLQUFLO1FBQ0xDLFdBQVc7UUFDWHJELEdBQUd4RCxLQUFLOEcsS0FBSztRQUNidEMsR0FBRztRQUNIeEQsR0FBRztRQUNIK0YsUUFBUTtRQUNSQyxNQUFNaEssc0RBQU1BO0lBQ2hCLEVBQUMsSUFBSztBQUNDLE1BQU1pSyxjQUE4QixhQUFILEdBQUksS0FBTVAsaUJBQWlCTyxXQUFXLElBQUk7QUFDM0UsTUFBTUMsZ0JBQWdDLGFBQUgsR0FBSSxLQUFNUixpQkFBaUJRLGFBQWEsSUFBSSxDQUN0RixxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGF3LXdvcmtzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9zZWNwMjU2azEuanM/YzVkYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE5JU1Qgc2VjcDI1NmsxLiBTZWUgW3BkZl0oaHR0cHM6Ly93d3cuc2VjZy5vcmcvc2VjMi12Mi5wZGYpLlxuICpcbiAqIFNlZW1zIHRvIGJlIHJpZ2lkIChub3QgYmFja2Rvb3JlZClcbiAqIFthcyBwZXIgZGlzY3Vzc2lvbl0oaHR0cHM6Ly9iaXRjb2ludGFsay5vcmcvaW5kZXgucGhwP3RvcGljPTI4OTc5NS5tc2czMTgzOTc1I21zZzMxODM5NzUpLlxuICpcbiAqIHNlY3AyNTZrMSBiZWxvbmdzIHRvIEtvYmxpdHogY3VydmVzOiBpdCBoYXMgZWZmaWNpZW50bHkgY29tcHV0YWJsZSBlbmRvbW9ycGhpc20uXG4gKiBFbmRvbW9ycGhpc20gdXNlcyAyeCBsZXNzIFJBTSwgc3BlZWRzIHVwIHByZWNvbXB1dGF0aW9uIGJ5IDJ4IGFuZCBFQ0RIIC8ga2V5IHJlY292ZXJ5IGJ5IDIwJS5cbiAqIEZvciBwcmVjb21wdXRlZCB3TkFGIGl0IHRyYWRlcyBvZmYgMS8yIGluaXQgdGltZSAmIDEvMyByYW0gZm9yIDIwJSBwZXJmIGhpdC5cbiAqIFtTZWUgZXhwbGFuYXRpb25dKGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3BhdWxtaWxsci9lYjY3MDgwNjc5M2U4NGRmNjI4YTdjNDM0YTg3MzA2NikuXG4gKiBAbW9kdWxlXG4gKi9cbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7IHNoYTI1NiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMic7XG5pbXBvcnQgeyByYW5kb21CeXRlcyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvdXRpbHMnO1xuaW1wb3J0IHsgY3JlYXRlQ3VydmUgfSBmcm9tIFwiLi9fc2hvcnR3X3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBjcmVhdGVIYXNoZXIsIGlzb2dlbnlNYXAgfSBmcm9tIFwiLi9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzXCI7XG5pbXBvcnQgeyBGaWVsZCwgbW9kLCBwb3cyIH0gZnJvbSBcIi4vYWJzdHJhY3QvbW9kdWxhci5qc1wiO1xuaW1wb3J0IHsgYUluUmFuZ2UsIGJ5dGVzVG9OdW1iZXJCRSwgY29uY2F0Qnl0ZXMsIGVuc3VyZUJ5dGVzLCBpblJhbmdlLCBudW1iZXJUb0J5dGVzQkUsIH0gZnJvbSBcIi4vYWJzdHJhY3QvdXRpbHMuanNcIjtcbmltcG9ydCB7IG1hcFRvQ3VydmVTaW1wbGVTV1UgfSBmcm9tIFwiLi9hYnN0cmFjdC93ZWllcnN0cmFzcy5qc1wiO1xuY29uc3Qgc2VjcDI1NmsxUCA9IEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZmYzJmJyk7XG5jb25zdCBzZWNwMjU2azFOID0gQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlYmFhZWRjZTZhZjQ4YTAzYmJmZDI1ZThjZDAzNjQxNDEnKTtcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IEJpZ0ludCgyKTtcbmNvbnN0IGRpdk5lYXJlc3QgPSAoYSwgYikgPT4gKGEgKyBiIC8gXzJuKSAvIGI7XG4vKipcbiAqIOKImm4gPSBuXigocCsxKS80KSBmb3IgZmllbGRzIHAgPSAzIG1vZCA0LiBXZSB1bndyYXAgdGhlIGxvb3AgYW5kIG11bHRpcGx5IGJpdC1ieS1iaXQuXG4gKiAoUCsxbi80bikudG9TdHJpbmcoMikgd291bGQgcHJvZHVjZSBiaXRzIFsyMjN4IDEsIDAsIDIyeCAxLCA0eCAwLCAxMSwgMDBdXG4gKi9cbmZ1bmN0aW9uIHNxcnRNb2QoeSkge1xuICAgIGNvbnN0IFAgPSBzZWNwMjU2azFQO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGNvbnN0IF8zbiA9IEJpZ0ludCgzKSwgXzZuID0gQmlnSW50KDYpLCBfMTFuID0gQmlnSW50KDExKSwgXzIybiA9IEJpZ0ludCgyMik7XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgY29uc3QgXzIzbiA9IEJpZ0ludCgyMyksIF80NG4gPSBCaWdJbnQoNDQpLCBfODhuID0gQmlnSW50KDg4KTtcbiAgICBjb25zdCBiMiA9ICh5ICogeSAqIHkpICUgUDsgLy8geF4zLCAxMVxuICAgIGNvbnN0IGIzID0gKGIyICogYjIgKiB5KSAlIFA7IC8vIHheN1xuICAgIGNvbnN0IGI2ID0gKHBvdzIoYjMsIF8zbiwgUCkgKiBiMykgJSBQO1xuICAgIGNvbnN0IGI5ID0gKHBvdzIoYjYsIF8zbiwgUCkgKiBiMykgJSBQO1xuICAgIGNvbnN0IGIxMSA9IChwb3cyKGI5LCBfMm4sIFApICogYjIpICUgUDtcbiAgICBjb25zdCBiMjIgPSAocG93MihiMTEsIF8xMW4sIFApICogYjExKSAlIFA7XG4gICAgY29uc3QgYjQ0ID0gKHBvdzIoYjIyLCBfMjJuLCBQKSAqIGIyMikgJSBQO1xuICAgIGNvbnN0IGI4OCA9IChwb3cyKGI0NCwgXzQ0biwgUCkgKiBiNDQpICUgUDtcbiAgICBjb25zdCBiMTc2ID0gKHBvdzIoYjg4LCBfODhuLCBQKSAqIGI4OCkgJSBQO1xuICAgIGNvbnN0IGIyMjAgPSAocG93MihiMTc2LCBfNDRuLCBQKSAqIGI0NCkgJSBQO1xuICAgIGNvbnN0IGIyMjMgPSAocG93MihiMjIwLCBfM24sIFApICogYjMpICUgUDtcbiAgICBjb25zdCB0MSA9IChwb3cyKGIyMjMsIF8yM24sIFApICogYjIyKSAlIFA7XG4gICAgY29uc3QgdDIgPSAocG93Mih0MSwgXzZuLCBQKSAqIGIyKSAlIFA7XG4gICAgY29uc3Qgcm9vdCA9IHBvdzIodDIsIF8ybiwgUCk7XG4gICAgaWYgKCFGcGsxLmVxbChGcGsxLnNxcihyb290KSwgeSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICByZXR1cm4gcm9vdDtcbn1cbmNvbnN0IEZwazEgPSBGaWVsZChzZWNwMjU2azFQLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgeyBzcXJ0OiBzcXJ0TW9kIH0pO1xuLyoqXG4gKiBzZWNwMjU2azEgY3VydmUsIEVDRFNBIGFuZCBFQ0RIIG1ldGhvZHMuXG4gKlxuICogRmllbGQ6IGAybioqMjU2biAtIDJuKiozMm4gLSAybioqOW4gLSAybioqOG4gLSAybioqN24gLSAybioqNm4gLSAybioqNG4gLSAxbmBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGltcG9ydCB7IHNlY3AyNTZrMSB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxJztcbiAqIGNvbnN0IHByaXYgPSBzZWNwMjU2azEudXRpbHMucmFuZG9tUHJpdmF0ZUtleSgpO1xuICogY29uc3QgcHViID0gc2VjcDI1NmsxLmdldFB1YmxpY0tleShwcml2KTtcbiAqIGNvbnN0IG1zZyA9IG5ldyBVaW50OEFycmF5KDMyKS5maWxsKDEpOyAvLyBtZXNzYWdlIGhhc2ggKG5vdCBtZXNzYWdlKSBpbiBlY2RzYVxuICogY29uc3Qgc2lnID0gc2VjcDI1NmsxLnNpZ24obXNnLCBwcml2KTsgLy8gYHtwcmVoYXNoOiB0cnVlfWAgb3B0aW9uIGlzIGF2YWlsYWJsZVxuICogY29uc3QgaXNWYWxpZCA9IHNlY3AyNTZrMS52ZXJpZnkoc2lnLCBtc2csIHB1YikgPT09IHRydWU7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IHNlY3AyNTZrMSA9IGNyZWF0ZUN1cnZlKHtcbiAgICBhOiBfMG4sXG4gICAgYjogQmlnSW50KDcpLFxuICAgIEZwOiBGcGsxLFxuICAgIG46IHNlY3AyNTZrMU4sXG4gICAgR3g6IEJpZ0ludCgnNTUwNjYyNjMwMjIyNzczNDM2Njk1Nzg3MTg4OTUxNjg1MzQzMjYyNTA2MDM0NTM3Nzc1OTQxNzU1MDAxODczNjAzODkxMTY3MjkyNDAnKSxcbiAgICBHeTogQmlnSW50KCczMjY3MDUxMDAyMDc1ODgxNjk3ODA4MzA4NTEzMDUwNzA0MzE4NDQ3MTI3MzM4MDY1OTI0MzI3NTkzODkwNDMzNTc1NzMzNzQ4MjQyNCcpLFxuICAgIGg6IEJpZ0ludCgxKSxcbiAgICBsb3dTOiB0cnVlLCAvLyBBbGxvdyBvbmx5IGxvdy1TIHNpZ25hdHVyZXMgYnkgZGVmYXVsdCBpbiBzaWduKCkgYW5kIHZlcmlmeSgpXG4gICAgZW5kbzoge1xuICAgICAgICAvLyBFbmRvbW9ycGhpc20sIHNlZSBhYm92ZVxuICAgICAgICBiZXRhOiBCaWdJbnQoJzB4N2FlOTZhMmI2NTdjMDcxMDZlNjQ0NzllYWMzNDM0ZTk5Y2YwNDk3NTEyZjU4OTk1YzEzOTZjMjg3MTk1MDFlZScpLFxuICAgICAgICBzcGxpdFNjYWxhcjogKGspID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBzZWNwMjU2azFOO1xuICAgICAgICAgICAgY29uc3QgYTEgPSBCaWdJbnQoJzB4MzA4NmQyMjFhN2Q0NmJjZGU4NmM5MGU0OTI4NGViMTUnKTtcbiAgICAgICAgICAgIGNvbnN0IGIxID0gLV8xbiAqIEJpZ0ludCgnMHhlNDQzN2VkNjAxMGU4ODI4NmY1NDdmYTkwYWJmZTRjMycpO1xuICAgICAgICAgICAgY29uc3QgYTIgPSBCaWdJbnQoJzB4MTE0Y2E1MGY3YThlMmYzZjY1N2MxMTA4ZDlkNDRjZmQ4Jyk7XG4gICAgICAgICAgICBjb25zdCBiMiA9IGExO1xuICAgICAgICAgICAgY29uc3QgUE9XXzJfMTI4ID0gQmlnSW50KCcweDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcpOyAvLyAoMm4qKjEyOG4pLnRvU3RyaW5nKDE2KVxuICAgICAgICAgICAgY29uc3QgYzEgPSBkaXZOZWFyZXN0KGIyICogaywgbik7XG4gICAgICAgICAgICBjb25zdCBjMiA9IGRpdk5lYXJlc3QoLWIxICogaywgbik7XG4gICAgICAgICAgICBsZXQgazEgPSBtb2QoayAtIGMxICogYTEgLSBjMiAqIGEyLCBuKTtcbiAgICAgICAgICAgIGxldCBrMiA9IG1vZCgtYzEgKiBiMSAtIGMyICogYjIsIG4pO1xuICAgICAgICAgICAgY29uc3QgazFuZWcgPSBrMSA+IFBPV18yXzEyODtcbiAgICAgICAgICAgIGNvbnN0IGsybmVnID0gazIgPiBQT1dfMl8xMjg7XG4gICAgICAgICAgICBpZiAoazFuZWcpXG4gICAgICAgICAgICAgICAgazEgPSBuIC0gazE7XG4gICAgICAgICAgICBpZiAoazJuZWcpXG4gICAgICAgICAgICAgICAgazIgPSBuIC0gazI7XG4gICAgICAgICAgICBpZiAoazEgPiBQT1dfMl8xMjggfHwgazIgPiBQT1dfMl8xMjgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NwbGl0U2NhbGFyOiBFbmRvbW9ycGhpc20gZmFpbGVkLCBrPScgKyBrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGsxbmVnLCBrMSwgazJuZWcsIGsyIH07XG4gICAgICAgIH0sXG4gICAgfSxcbn0sIHNoYTI1Nik7XG4vLyBTY2hub3JyIHNpZ25hdHVyZXMgYXJlIHN1cGVyaW9yIHRvIEVDRFNBIGZyb20gYWJvdmUuIEJlbG93IGlzIFNjaG5vcnItc3BlY2lmaWMgQklQMDM0MCBjb2RlLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDM0MC5tZWRpYXdpa2lcbi8qKiBBbiBvYmplY3QgbWFwcGluZyB0YWdzIHRvIHRoZWlyIHRhZ2dlZCBoYXNoIHByZWZpeCBvZiBbU0hBMjU2KHRhZykgfCBTSEEyNTYodGFnKV0gKi9cbmNvbnN0IFRBR0dFRF9IQVNIX1BSRUZJWEVTID0ge307XG5mdW5jdGlvbiB0YWdnZWRIYXNoKHRhZywgLi4ubWVzc2FnZXMpIHtcbiAgICBsZXQgdGFnUCA9IFRBR0dFRF9IQVNIX1BSRUZJWEVTW3RhZ107XG4gICAgaWYgKHRhZ1AgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCB0YWdIID0gc2hhMjU2KFVpbnQ4QXJyYXkuZnJvbSh0YWcsIChjKSA9PiBjLmNoYXJDb2RlQXQoMCkpKTtcbiAgICAgICAgdGFnUCA9IGNvbmNhdEJ5dGVzKHRhZ0gsIHRhZ0gpO1xuICAgICAgICBUQUdHRURfSEFTSF9QUkVGSVhFU1t0YWddID0gdGFnUDtcbiAgICB9XG4gICAgcmV0dXJuIHNoYTI1Nihjb25jYXRCeXRlcyh0YWdQLCAuLi5tZXNzYWdlcykpO1xufVxuLy8gRUNEU0EgY29tcGFjdCBwb2ludHMgYXJlIDMzLWJ5dGUuIFNjaG5vcnIgaXMgMzI6IHdlIHN0cmlwIGZpcnN0IGJ5dGUgMHgwMiBvciAweDAzXG5jb25zdCBwb2ludFRvQnl0ZXMgPSAocG9pbnQpID0+IHBvaW50LnRvUmF3Qnl0ZXModHJ1ZSkuc2xpY2UoMSk7XG5jb25zdCBudW1UbzMyYiA9IChuKSA9PiBudW1iZXJUb0J5dGVzQkUobiwgMzIpO1xuY29uc3QgbW9kUCA9ICh4KSA9PiBtb2QoeCwgc2VjcDI1NmsxUCk7XG5jb25zdCBtb2ROID0gKHgpID0+IG1vZCh4LCBzZWNwMjU2azFOKTtcbmNvbnN0IFBvaW50ID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBzZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50KSgpO1xuY29uc3QgR211bEFkZCA9IChRLCBhLCBiKSA9PiBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFEsIGEsIGIpO1xuLy8gQ2FsY3VsYXRlIHBvaW50LCBzY2FsYXIgYW5kIGJ5dGVzXG5mdW5jdGlvbiBzY2hub3JyR2V0RXh0UHViS2V5KHByaXYpIHtcbiAgICBsZXQgZF8gPSBzZWNwMjU2azEudXRpbHMubm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2KTsgLy8gc2FtZSBtZXRob2QgZXhlY3V0ZWQgaW4gZnJvbVByaXZhdGVLZXlcbiAgICBsZXQgcCA9IFBvaW50LmZyb21Qcml2YXRlS2V5KGRfKTsgLy8gUCA9IGQn4ouFRzsgMCA8IGQnIDwgbiBjaGVjayBpcyBkb25lIGluc2lkZVxuICAgIGNvbnN0IHNjYWxhciA9IHAuaGFzRXZlblkoKSA/IGRfIDogbW9kTigtZF8pO1xuICAgIHJldHVybiB7IHNjYWxhcjogc2NhbGFyLCBieXRlczogcG9pbnRUb0J5dGVzKHApIH07XG59XG4vKipcbiAqIGxpZnRfeCBmcm9tIEJJUDM0MC4gQ29udmVydCAzMi1ieXRlIHggY29vcmRpbmF0ZSB0byBlbGxpcHRpYyBjdXJ2ZSBwb2ludC5cbiAqIEByZXR1cm5zIHZhbGlkIHBvaW50IGNoZWNrZWQgZm9yIGJlaW5nIG9uLWN1cnZlXG4gKi9cbmZ1bmN0aW9uIGxpZnRfeCh4KSB7XG4gICAgYUluUmFuZ2UoJ3gnLCB4LCBfMW4sIHNlY3AyNTZrMVApOyAvLyBGYWlsIGlmIHgg4omlIHAuXG4gICAgY29uc3QgeHggPSBtb2RQKHggKiB4KTtcbiAgICBjb25zdCBjID0gbW9kUCh4eCAqIHggKyBCaWdJbnQoNykpOyAvLyBMZXQgYyA9IHjCsyArIDcgbW9kIHAuXG4gICAgbGV0IHkgPSBzcXJ0TW9kKGMpOyAvLyBMZXQgeSA9IGNeKHArMSkvNCBtb2QgcC5cbiAgICBpZiAoeSAlIF8ybiAhPT0gXzBuKVxuICAgICAgICB5ID0gbW9kUCgteSk7IC8vIFJldHVybiB0aGUgdW5pcXVlIHBvaW50IFAgc3VjaCB0aGF0IHgoUCkgPSB4IGFuZFxuICAgIGNvbnN0IHAgPSBuZXcgUG9pbnQoeCwgeSwgXzFuKTsgLy8geShQKSA9IHkgaWYgeSBtb2QgMiA9IDAgb3IgeShQKSA9IHAteSBvdGhlcndpc2UuXG4gICAgcC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgIHJldHVybiBwO1xufVxuY29uc3QgbnVtID0gYnl0ZXNUb051bWJlckJFO1xuLyoqXG4gKiBDcmVhdGUgdGFnZ2VkIGhhc2gsIGNvbnZlcnQgaXQgdG8gYmlnaW50LCByZWR1Y2UgbW9kdWxvLW4uXG4gKi9cbmZ1bmN0aW9uIGNoYWxsZW5nZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIG1vZE4obnVtKHRhZ2dlZEhhc2goJ0JJUDAzNDAvY2hhbGxlbmdlJywgLi4uYXJncykpKTtcbn1cbi8qKlxuICogU2Nobm9yciBwdWJsaWMga2V5IGlzIGp1c3QgYHhgIGNvb3JkaW5hdGUgb2YgUG9pbnQgYXMgcGVyIEJJUDM0MC5cbiAqL1xuZnVuY3Rpb24gc2Nobm9yckdldFB1YmxpY0tleShwcml2YXRlS2V5KSB7XG4gICAgcmV0dXJuIHNjaG5vcnJHZXRFeHRQdWJLZXkocHJpdmF0ZUtleSkuYnl0ZXM7IC8vIGQnPWludChzaykuIEZhaWwgaWYgZCc9MCBvciBkJ+KJpW4uIFJldCBieXRlcyhkJ+KLhUcpXG59XG4vKipcbiAqIENyZWF0ZXMgU2Nobm9yciBzaWduYXR1cmUgYXMgcGVyIEJJUDM0MC4gVmVyaWZpZXMgaXRzZWxmIGJlZm9yZSByZXR1cm5pbmcgYW55dGhpbmcuXG4gKiBhdXhSYW5kIGlzIG9wdGlvbmFsIGFuZCBpcyBub3QgdGhlIHNvbGUgc291cmNlIG9mIGsgZ2VuZXJhdGlvbjogYmFkIENTUFJORyB3b24ndCBiZSBkYW5nZXJvdXMuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJTaWduKG1lc3NhZ2UsIHByaXZhdGVLZXksIGF1eFJhbmQgPSByYW5kb21CeXRlcygzMikpIHtcbiAgICBjb25zdCBtID0gZW5zdXJlQnl0ZXMoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgICBjb25zdCB7IGJ5dGVzOiBweCwgc2NhbGFyOiBkIH0gPSBzY2hub3JyR2V0RXh0UHViS2V5KHByaXZhdGVLZXkpOyAvLyBjaGVja3MgZm9yIGlzV2l0aGluQ3VydmVPcmRlclxuICAgIGNvbnN0IGEgPSBlbnN1cmVCeXRlcygnYXV4UmFuZCcsIGF1eFJhbmQsIDMyKTsgLy8gQXV4aWxpYXJ5IHJhbmRvbSBkYXRhIGE6IGEgMzItYnl0ZSBhcnJheVxuICAgIGNvbnN0IHQgPSBudW1UbzMyYihkIF4gbnVtKHRhZ2dlZEhhc2goJ0JJUDAzNDAvYXV4JywgYSkpKTsgLy8gTGV0IHQgYmUgdGhlIGJ5dGUtd2lzZSB4b3Igb2YgYnl0ZXMoZCkgYW5kIGhhc2gvYXV4KGEpXG4gICAgY29uc3QgcmFuZCA9IHRhZ2dlZEhhc2goJ0JJUDAzNDAvbm9uY2UnLCB0LCBweCwgbSk7IC8vIExldCByYW5kID0gaGFzaC9ub25jZSh0IHx8IGJ5dGVzKFApIHx8IG0pXG4gICAgY29uc3Qga18gPSBtb2ROKG51bShyYW5kKSk7IC8vIExldCBrJyA9IGludChyYW5kKSBtb2QgblxuICAgIGlmIChrXyA9PT0gXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ24gZmFpbGVkOiBrIGlzIHplcm8nKTsgLy8gRmFpbCBpZiBrJyA9IDAuXG4gICAgY29uc3QgeyBieXRlczogcngsIHNjYWxhcjogayB9ID0gc2Nobm9yckdldEV4dFB1YktleShrXyk7IC8vIExldCBSID0gayfii4VHLlxuICAgIGNvbnN0IGUgPSBjaGFsbGVuZ2UocngsIHB4LCBtKTsgLy8gTGV0IGUgPSBpbnQoaGFzaC9jaGFsbGVuZ2UoYnl0ZXMoUikgfHwgYnl0ZXMoUCkgfHwgbSkpIG1vZCBuLlxuICAgIGNvbnN0IHNpZyA9IG5ldyBVaW50OEFycmF5KDY0KTsgLy8gTGV0IHNpZyA9IGJ5dGVzKFIpIHx8IGJ5dGVzKChrICsgZWQpIG1vZCBuKS5cbiAgICBzaWcuc2V0KHJ4LCAwKTtcbiAgICBzaWcuc2V0KG51bVRvMzJiKG1vZE4oayArIGUgKiBkKSksIDMyKTtcbiAgICAvLyBJZiBWZXJpZnkoYnl0ZXMoUCksIG0sIHNpZykgKHNlZSBiZWxvdykgcmV0dXJucyBmYWlsdXJlLCBhYm9ydFxuICAgIGlmICghc2Nobm9yclZlcmlmeShzaWcsIG0sIHB4KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduOiBJbnZhbGlkIHNpZ25hdHVyZSBwcm9kdWNlZCcpO1xuICAgIHJldHVybiBzaWc7XG59XG4vKipcbiAqIFZlcmlmaWVzIFNjaG5vcnIgc2lnbmF0dXJlLlxuICogV2lsbCBzd2FsbG93IGVycm9ycyAmIHJldHVybiBmYWxzZSBleGNlcHQgZm9yIGluaXRpYWwgdHlwZSB2YWxpZGF0aW9uIG9mIGFyZ3VtZW50cy5cbiAqL1xuZnVuY3Rpb24gc2Nobm9yclZlcmlmeShzaWduYXR1cmUsIG1lc3NhZ2UsIHB1YmxpY0tleSkge1xuICAgIGNvbnN0IHNpZyA9IGVuc3VyZUJ5dGVzKCdzaWduYXR1cmUnLCBzaWduYXR1cmUsIDY0KTtcbiAgICBjb25zdCBtID0gZW5zdXJlQnl0ZXMoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgICBjb25zdCBwdWIgPSBlbnN1cmVCeXRlcygncHVibGljS2V5JywgcHVibGljS2V5LCAzMik7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgUCA9IGxpZnRfeChudW0ocHViKSk7IC8vIFAgPSBsaWZ0X3goaW50KHBrKSk7IGZhaWwgaWYgdGhhdCBmYWlsc1xuICAgICAgICBjb25zdCByID0gbnVtKHNpZy5zdWJhcnJheSgwLCAzMikpOyAvLyBMZXQgciA9IGludChzaWdbMDozMl0pOyBmYWlsIGlmIHIg4omlIHAuXG4gICAgICAgIGlmICghaW5SYW5nZShyLCBfMW4sIHNlY3AyNTZrMVApKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBzID0gbnVtKHNpZy5zdWJhcnJheSgzMiwgNjQpKTsgLy8gTGV0IHMgPSBpbnQoc2lnWzMyOjY0XSk7IGZhaWwgaWYgcyDiiaUgbi5cbiAgICAgICAgaWYgKCFpblJhbmdlKHMsIF8xbiwgc2VjcDI1NmsxTikpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IGUgPSBjaGFsbGVuZ2UobnVtVG8zMmIociksIHBvaW50VG9CeXRlcyhQKSwgbSk7IC8vIGludChjaGFsbGVuZ2UoYnl0ZXMocil8fGJ5dGVzKFApfHxtKSklblxuICAgICAgICBjb25zdCBSID0gR211bEFkZChQLCBzLCBtb2ROKC1lKSk7IC8vIFIgPSBz4ouFRyAtIGXii4VQXG4gICAgICAgIGlmICghUiB8fCAhUi5oYXNFdmVuWSgpIHx8IFIudG9BZmZpbmUoKS54ICE9PSByKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyAtZVAgPT0gKG4tZSlQXG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBGYWlsIGlmIGlzX2luZmluaXRlKFIpIC8gbm90IGhhc19ldmVuX3koUikgLyB4KFIpIOKJoCByLlxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogU2Nobm9yciBzaWduYXR1cmVzIG92ZXIgc2VjcDI1NmsxLlxuICogaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDM0MC5tZWRpYXdpa2lcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogaW1wb3J0IHsgc2Nobm9yciB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxJztcbiAqIGNvbnN0IHByaXYgPSBzY2hub3JyLnV0aWxzLnJhbmRvbVByaXZhdGVLZXkoKTtcbiAqIGNvbnN0IHB1YiA9IHNjaG5vcnIuZ2V0UHVibGljS2V5KHByaXYpO1xuICogY29uc3QgbXNnID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKCdoZWxsbycpO1xuICogY29uc3Qgc2lnID0gc2Nobm9yci5zaWduKG1zZywgcHJpdik7XG4gKiBjb25zdCBpc1ZhbGlkID0gc2Nobm9yci52ZXJpZnkoc2lnLCBtc2csIHB1Yik7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IHNjaG5vcnIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+ICh7XG4gICAgZ2V0UHVibGljS2V5OiBzY2hub3JyR2V0UHVibGljS2V5LFxuICAgIHNpZ246IHNjaG5vcnJTaWduLFxuICAgIHZlcmlmeTogc2Nobm9yclZlcmlmeSxcbiAgICB1dGlsczoge1xuICAgICAgICByYW5kb21Qcml2YXRlS2V5OiBzZWNwMjU2azEudXRpbHMucmFuZG9tUHJpdmF0ZUtleSxcbiAgICAgICAgbGlmdF94LFxuICAgICAgICBwb2ludFRvQnl0ZXMsXG4gICAgICAgIG51bWJlclRvQnl0ZXNCRSxcbiAgICAgICAgYnl0ZXNUb051bWJlckJFLFxuICAgICAgICB0YWdnZWRIYXNoLFxuICAgICAgICBtb2QsXG4gICAgfSxcbn0pKSgpO1xuY29uc3QgaXNvTWFwID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBpc29nZW55TWFwKEZwazEsIFtcbiAgICAvLyB4TnVtXG4gICAgW1xuICAgICAgICAnMHg4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZGFhYWFhOGM3JyxcbiAgICAgICAgJzB4N2QzZDRjODBiYzMyMWQ1YjlmMzE1Y2VhN2ZkNDRjNWQ1OTVkMmZjMGJmNjNiOTJkZmZmMTA0NGYxN2M2NTgxJyxcbiAgICAgICAgJzB4NTM0YzMyOGQyM2YyMzRlNmUyYTQxM2RlY2EyNWNhZWNlNDUwNjE0NDAzN2M0MDMxNGVjYmQwYjUzZDlkZDI2MicsXG4gICAgICAgICcweDhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhkYWFhYWE4OGMnLFxuICAgIF0sXG4gICAgLy8geERlblxuICAgIFtcbiAgICAgICAgJzB4ZDM1NzcxMTkzZDk0OTE4YTljYTM0Y2NiYjdiNjQwZGQ4NmNkNDA5NTQyZjg0ODdkOWZlNmI3NDU3ODFlYjQ5YicsXG4gICAgICAgICcweGVkYWRjNmY2NDM4M2RjMWRmN2M0YjJkNTFiNTQyMjU0MDZkMzZiNjQxZjVlNDFiYmM1MmE1NjYxMmE4YzZkMTQnLFxuICAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJywgLy8gTEFTVCAxXG4gICAgXSxcbiAgICAvLyB5TnVtXG4gICAgW1xuICAgICAgICAnMHg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YjhlMzhlMjNjJyxcbiAgICAgICAgJzB4Yzc1ZTBjMzJkNWNiN2MwZmE5ZDBhNTRiMTJhMGE2ZDU2NDdhYjA0NmQ2ODZkYTZmZGZmYzkwZmMyMDFkNzFhMycsXG4gICAgICAgICcweDI5YTYxOTQ2OTFmOTFhNzM3MTUyMDllZjY1MTJlNTc2NzIyODMwYTIwMWJlMjAxOGE3NjVlODVhOWVjZWU5MzEnLFxuICAgICAgICAnMHgyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjM4ZTM4ZDg0JyxcbiAgICBdLFxuICAgIC8vIHlEZW5cbiAgICBbXG4gICAgICAgICcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZmZmZmY5M2InLFxuICAgICAgICAnMHg3YTA2NTM0YmI4YmRiNDlmZDVlOWU2NjMyNzIyYzI5ODk0NjdjMWJmYzhlOGQ5NzhkZmI0MjVkMjY4NWMyNTczJyxcbiAgICAgICAgJzB4NjQ4NGFhNzE2NTQ1Y2EyY2YzYTcwYzNmYThmZTMzN2UwYTNkMjExNjJmMGQ2Mjk5YTdiZjgxOTJiZmQyYTc2ZicsXG4gICAgICAgICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnLCAvLyBMQVNUIDFcbiAgICBdLFxuXS5tYXAoKGkpID0+IGkubWFwKChqKSA9PiBCaWdJbnQoaikpKSkpKCk7XG5jb25zdCBtYXBTV1UgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IG1hcFRvQ3VydmVTaW1wbGVTV1UoRnBrMSwge1xuICAgIEE6IEJpZ0ludCgnMHgzZjg3MzFhYmRkNjYxYWRjYTA4YTU1NThmMGY1ZDI3MmU5NTNkMzYzY2I2ZjBlNWQ0MDU0NDdjMDFhNDQ0NTMzJyksXG4gICAgQjogQmlnSW50KCcxNzcxJyksXG4gICAgWjogRnBrMS5jcmVhdGUoQmlnSW50KCctMTEnKSksXG59KSkoKTtcbi8qKiBIYXNoaW5nIC8gZW5jb2RpbmcgdG8gc2VjcDI1NmsxIHBvaW50cyAvIGZpZWxkLiBSRkMgOTM4MCBtZXRob2RzLiAqL1xuZXhwb3J0IGNvbnN0IHNlY3AyNTZrMV9oYXNoZXIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGNyZWF0ZUhhc2hlcihzZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50LCAoc2NhbGFycykgPT4ge1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gbWFwU1dVKEZwazEuY3JlYXRlKHNjYWxhcnNbMF0pKTtcbiAgICByZXR1cm4gaXNvTWFwKHgsIHkpO1xufSwge1xuICAgIERTVDogJ3NlY3AyNTZrMV9YTUQ6U0hBLTI1Nl9TU1dVX1JPXycsXG4gICAgZW5jb2RlRFNUOiAnc2VjcDI1NmsxX1hNRDpTSEEtMjU2X1NTV1VfTlVfJyxcbiAgICBwOiBGcGsxLk9SREVSLFxuICAgIG06IDEsXG4gICAgazogMTI4LFxuICAgIGV4cGFuZDogJ3htZCcsXG4gICAgaGFzaDogc2hhMjU2LFxufSkpKCk7XG5leHBvcnQgY29uc3QgaGFzaFRvQ3VydmUgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHNlY3AyNTZrMV9oYXNoZXIuaGFzaFRvQ3VydmUpKCk7XG5leHBvcnQgY29uc3QgZW5jb2RlVG9DdXJ2ZSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gc2VjcDI1NmsxX2hhc2hlci5lbmNvZGVUb0N1cnZlKSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VjcDI1NmsxLmpzLm1hcCJdLCJuYW1lcyI6WyJzaGEyNTYiLCJyYW5kb21CeXRlcyIsImNyZWF0ZUN1cnZlIiwiY3JlYXRlSGFzaGVyIiwiaXNvZ2VueU1hcCIsIkZpZWxkIiwibW9kIiwicG93MiIsImFJblJhbmdlIiwiYnl0ZXNUb051bWJlckJFIiwiY29uY2F0Qnl0ZXMiLCJlbnN1cmVCeXRlcyIsImluUmFuZ2UiLCJudW1iZXJUb0J5dGVzQkUiLCJtYXBUb0N1cnZlU2ltcGxlU1dVIiwic2VjcDI1NmsxUCIsIkJpZ0ludCIsInNlY3AyNTZrMU4iLCJfMG4iLCJfMW4iLCJfMm4iLCJkaXZOZWFyZXN0IiwiYSIsImIiLCJzcXJ0TW9kIiwieSIsIlAiLCJfM24iLCJfNm4iLCJfMTFuIiwiXzIybiIsIl8yM24iLCJfNDRuIiwiXzg4biIsImIyIiwiYjMiLCJiNiIsImI5IiwiYjExIiwiYjIyIiwiYjQ0IiwiYjg4IiwiYjE3NiIsImIyMjAiLCJiMjIzIiwidDEiLCJ0MiIsInJvb3QiLCJGcGsxIiwiZXFsIiwic3FyIiwiRXJyb3IiLCJ1bmRlZmluZWQiLCJzcXJ0Iiwic2VjcDI1NmsxIiwiRnAiLCJuIiwiR3giLCJHeSIsImgiLCJsb3dTIiwiZW5kbyIsImJldGEiLCJzcGxpdFNjYWxhciIsImsiLCJhMSIsImIxIiwiYTIiLCJQT1dfMl8xMjgiLCJjMSIsImMyIiwiazEiLCJrMiIsImsxbmVnIiwiazJuZWciLCJUQUdHRURfSEFTSF9QUkVGSVhFUyIsInRhZ2dlZEhhc2giLCJ0YWciLCJtZXNzYWdlcyIsInRhZ1AiLCJ0YWdIIiwiVWludDhBcnJheSIsImZyb20iLCJjIiwiY2hhckNvZGVBdCIsInBvaW50VG9CeXRlcyIsInBvaW50IiwidG9SYXdCeXRlcyIsInNsaWNlIiwibnVtVG8zMmIiLCJtb2RQIiwieCIsIm1vZE4iLCJQb2ludCIsIlByb2plY3RpdmVQb2ludCIsIkdtdWxBZGQiLCJRIiwiQkFTRSIsIm11bHRpcGx5QW5kQWRkVW5zYWZlIiwic2Nobm9yckdldEV4dFB1YktleSIsInByaXYiLCJkXyIsInV0aWxzIiwibm9ybVByaXZhdGVLZXlUb1NjYWxhciIsInAiLCJmcm9tUHJpdmF0ZUtleSIsInNjYWxhciIsImhhc0V2ZW5ZIiwiYnl0ZXMiLCJsaWZ0X3giLCJ4eCIsImFzc2VydFZhbGlkaXR5IiwibnVtIiwiY2hhbGxlbmdlIiwiYXJncyIsInNjaG5vcnJHZXRQdWJsaWNLZXkiLCJwcml2YXRlS2V5Iiwic2Nobm9yclNpZ24iLCJtZXNzYWdlIiwiYXV4UmFuZCIsIm0iLCJweCIsImQiLCJ0IiwicmFuZCIsImtfIiwicngiLCJlIiwic2lnIiwic2V0Iiwic2Nobm9yclZlcmlmeSIsInNpZ25hdHVyZSIsInB1YmxpY0tleSIsInB1YiIsInIiLCJzdWJhcnJheSIsInMiLCJSIiwidG9BZmZpbmUiLCJlcnJvciIsInNjaG5vcnIiLCJnZXRQdWJsaWNLZXkiLCJzaWduIiwidmVyaWZ5IiwicmFuZG9tUHJpdmF0ZUtleSIsImlzb01hcCIsIm1hcCIsImkiLCJqIiwibWFwU1dVIiwiQSIsIkIiLCJaIiwiY3JlYXRlIiwic2VjcDI1NmsxX2hhc2hlciIsInNjYWxhcnMiLCJEU1QiLCJlbmNvZGVEU1QiLCJPUkRFUiIsImV4cGFuZCIsImhhc2giLCJoYXNoVG9DdXJ2ZSIsImVuY29kZVRvQ3VydmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/secp256k1.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/_md.js":
/*!***************************************************************!*\
  !*** ./node_modules/ox/node_modules/@noble/hashes/esm/_md.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Chi: () => (/* binding */ Chi),\n/* harmony export */   HashMD: () => (/* binding */ HashMD),\n/* harmony export */   Maj: () => (/* binding */ Maj),\n/* harmony export */   SHA224_IV: () => (/* binding */ SHA224_IV),\n/* harmony export */   SHA256_IV: () => (/* binding */ SHA256_IV),\n/* harmony export */   SHA384_IV: () => (/* binding */ SHA384_IV),\n/* harmony export */   SHA512_IV: () => (/* binding */ SHA512_IV),\n/* harmony export */   setBigUint64: () => (/* binding */ setBigUint64)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/utils.js\");\n/**\n * Internal Merkle-Damgard hash utils.\n * @module\n */ \n/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */ function setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === \"function\") return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number(value >> _32n & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n/** Choice: a ? b : c */ function Chi(a, b, c) {\n    return a & b ^ ~a & c;\n}\n/** Majority function, true if any two inputs is true. */ function Maj(a, b, c) {\n    return a & b ^ a & c ^ b & c;\n}\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */ class HashMD extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE){\n        super();\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(this.buffer);\n    }\n    update(data) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aexists)(this);\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(data);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(data);\n        const { view, buffer, blockLen } = this;\n        const len = data.length;\n        for(let pos = 0; pos < len;){\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(data);\n                for(; blockLen <= len - pos; pos += blockLen)this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aexists)(this);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aoutput)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 128;\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.clean)(this.buffer.subarray(pos));\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for(let i = pos; i < blockLen; i++)buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4) throw new Error(\"_sha2: outputLen should be aligned to 32bit\");\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length) throw new Error(\"_sha2: outputLen bigger than state\");\n        for(let i = 0; i < outLen; i++)oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.destroyed = destroyed;\n        to.finished = finished;\n        to.length = length;\n        to.pos = pos;\n        if (length % blockLen) to.buffer.set(buffer);\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n}\n/**\n * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.\n * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.\n */ /** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */ const SHA256_IV = /* @__PURE__ */ Uint32Array.from([\n    0x6a09e667,\n    0xbb67ae85,\n    0x3c6ef372,\n    0xa54ff53a,\n    0x510e527f,\n    0x9b05688c,\n    0x1f83d9ab,\n    0x5be0cd19\n]);\n/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */ const SHA224_IV = /* @__PURE__ */ Uint32Array.from([\n    0xc1059ed8,\n    0x367cd507,\n    0x3070dd17,\n    0xf70e5939,\n    0xffc00b31,\n    0x68581511,\n    0x64f98fa7,\n    0xbefa4fa4\n]);\n/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */ const SHA384_IV = /* @__PURE__ */ Uint32Array.from([\n    0xcbbb9d5d,\n    0xc1059ed8,\n    0x629a292a,\n    0x367cd507,\n    0x9159015a,\n    0x3070dd17,\n    0x152fecd8,\n    0xf70e5939,\n    0x67332667,\n    0xffc00b31,\n    0x8eb44a87,\n    0x68581511,\n    0xdb0c2e0d,\n    0x64f98fa7,\n    0x47b5481d,\n    0xbefa4fa4\n]);\n/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */ const SHA512_IV = /* @__PURE__ */ Uint32Array.from([\n    0x6a09e667,\n    0xf3bcc908,\n    0xbb67ae85,\n    0x84caa73b,\n    0x3c6ef372,\n    0xfe94f82b,\n    0xa54ff53a,\n    0x5f1d36f1,\n    0x510e527f,\n    0xade682d1,\n    0x9b05688c,\n    0x2b3e6c1f,\n    0x1f83d9ab,\n    0xfb41bd6b,\n    0x5be0cd19,\n    0x137e2179\n]); //# sourceMappingURL=_md.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19tZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTs7O0NBR0MsR0FDdUY7QUFDeEYsOEZBQThGLEdBQ3ZGLFNBQVNPLGFBQWFDLElBQUksRUFBRUMsVUFBVSxFQUFFQyxLQUFLLEVBQUVDLElBQUk7SUFDdEQsSUFBSSxPQUFPSCxLQUFLRCxZQUFZLEtBQUssWUFDN0IsT0FBT0MsS0FBS0QsWUFBWSxDQUFDRSxZQUFZQyxPQUFPQztJQUNoRCxNQUFNQyxPQUFPQyxPQUFPO0lBQ3BCLE1BQU1DLFdBQVdELE9BQU87SUFDeEIsTUFBTUUsS0FBS0MsT0FBTyxTQUFVSixPQUFRRTtJQUNwQyxNQUFNRyxLQUFLRCxPQUFPTixRQUFRSTtJQUMxQixNQUFNSSxJQUFJUCxPQUFPLElBQUk7SUFDckIsTUFBTVEsSUFBSVIsT0FBTyxJQUFJO0lBQ3JCSCxLQUFLWSxTQUFTLENBQUNYLGFBQWFTLEdBQUdILElBQUlKO0lBQ25DSCxLQUFLWSxTQUFTLENBQUNYLGFBQWFVLEdBQUdGLElBQUlOO0FBQ3ZDO0FBQ0Esc0JBQXNCLEdBQ2YsU0FBU1UsSUFBSUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUM7SUFDdkIsT0FBTyxJQUFLRCxJQUFNLENBQUNELElBQUlFO0FBQzNCO0FBQ0EsdURBQXVELEdBQ2hELFNBQVNDLElBQUlILENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDO0lBQ3ZCLE9BQU8sSUFBS0QsSUFBTUQsSUFBSUUsSUFBTUQsSUFBSUM7QUFDcEM7QUFDQTs7O0NBR0MsR0FDTSxNQUFNRSxlQUFlMUIsMkNBQUlBO0lBQzVCMkIsWUFBWUMsUUFBUSxFQUFFQyxTQUFTLEVBQUVDLFNBQVMsRUFBRW5CLElBQUksQ0FBRTtRQUM5QyxLQUFLO1FBQ0wsSUFBSSxDQUFDb0IsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0MsTUFBTSxHQUFHO1FBQ2QsSUFBSSxDQUFD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dEQ7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtDQUN2RixFQUFFO0FBQ0gsNEVBQTRFLEdBQ3JFLE1BQU1DLFlBQVksYUFBYSxHQUFHRixZQUFZQyxJQUFJLENBQUM7SUFDdEQ7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtDQUN2RixFQUFFO0FBQ0gsMkVBQTJFLEdBQ3BFLE1BQU1FLFlBQVksYUFBYSxHQUFHSCxZQUFZQyxJQUFJLENBQUM7SUFDdEQ7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUNwRjtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0NBQ3ZGLEVBQUU7QUFDSCwwRUFBMEUsR0FDbkUsTUFBTUcsWUFBWSxhQUFhLEdBQUdKLFlBQVlDLElBQUksQ0FBQztJQUN0RDtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQ3BGO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7Q0FDdkYsRUFBRSxDQUNILCtCQUErQiIsInNvdXJjZXMiOlsid2VicGFjazovL2NsYXctd29ya3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19tZC5qcz9jZGYyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSW50ZXJuYWwgTWVya2xlLURhbWdhcmQgaGFzaCB1dGlscy5cbiAqIEBtb2R1bGVcbiAqL1xuaW1wb3J0IHsgSGFzaCwgYWJ5dGVzLCBhZXhpc3RzLCBhb3V0cHV0LCBjbGVhbiwgY3JlYXRlVmlldywgdG9CeXRlcyB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG4vKiogUG9seWZpbGwgZm9yIFNhZmFyaSAxNC4gaHR0cHM6Ly9jYW5pdXNlLmNvbS9tZG4tamF2YXNjcmlwdF9idWlsdGluc19kYXRhdmlld19zZXRiaWd1aW50NjQgKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRCaWdVaW50NjQodmlldywgYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUpIHtcbiAgICBpZiAodHlwZW9mIHZpZXcuc2V0QmlnVWludDY0ID09PSAnZnVuY3Rpb24nKVxuICAgICAgICByZXR1cm4gdmlldy5zZXRCaWdVaW50NjQoYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUpO1xuICAgIGNvbnN0IF8zMm4gPSBCaWdJbnQoMzIpO1xuICAgIGNvbnN0IF91MzJfbWF4ID0gQmlnSW50KDB4ZmZmZmZmZmYpO1xuICAgIGNvbnN0IHdoID0gTnVtYmVyKCh2YWx1ZSA+PiBfMzJuKSAmIF91MzJfbWF4KTtcbiAgICBjb25zdCB3bCA9IE51bWJlcih2YWx1ZSAmIF91MzJfbWF4KTtcbiAgICBjb25zdCBoID0gaXNMRSA/IDQgOiAwO1xuICAgIGNvbnN0IGwgPSBpc0xFID8gMCA6IDQ7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGgsIHdoLCBpc0xFKTtcbiAgICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgbCwgd2wsIGlzTEUpO1xufVxuLyoqIENob2ljZTogYSA/IGIgOiBjICovXG5leHBvcnQgZnVuY3Rpb24gQ2hpKGEsIGIsIGMpIHtcbiAgICByZXR1cm4gKGEgJiBiKSBeICh+YSAmIGMpO1xufVxuLyoqIE1ham9yaXR5IGZ1bmN0aW9uLCB0cnVlIGlmIGFueSB0d28gaW5wdXRzIGlzIHRydWUuICovXG5leHBvcnQgZnVuY3Rpb24gTWFqKGEsIGIsIGMpIHtcbiAgICByZXR1cm4gKGEgJiBiKSBeIChhICYgYykgXiAoYiAmIGMpO1xufVxuLyoqXG4gKiBNZXJrbGUtRGFtZ2FyZCBoYXNoIGNvbnN0cnVjdGlvbiBiYXNlIGNsYXNzLlxuICogQ291bGQgYmUgdXNlZCB0byBjcmVhdGUgTUQ1LCBSSVBFTUQsIFNIQTEsIFNIQTIuXG4gKi9cbmV4cG9ydCBjbGFzcyBIYXNoTUQgZXh0ZW5kcyBIYXNoIHtcbiAgICBjb25zdHJ1Y3RvcihibG9ja0xlbiwgb3V0cHV0TGVuLCBwYWRPZmZzZXQsIGlzTEUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdGhpcy5wYWRPZmZzZXQgPSBwYWRPZmZzZXQ7XG4gICAgICAgIHRoaXMuaXNMRSA9IGlzTEU7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xuICAgICAgICB0aGlzLnZpZXcgPSBjcmVhdGVWaWV3KHRoaXMuYnVmZmVyKTtcbiAgICB9XG4gICAgdXBkYXRlKGRhdGEpIHtcbiAgICAgICAgYWV4aXN0cyh0aGlzKTtcbiAgICAgICAgZGF0YSA9IHRvQnl0ZXMoZGF0YSk7XG4gICAgICAgIGFieXRlcyhkYXRhKTtcbiAgICAgICAgY29uc3QgeyB2aWV3LCBidWZmZXIsIGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3MsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICAvLyBGYXN0IHBhdGg6IHdlIGhhdmUgYXQgbGVhc3Qgb25lIGJsb2NrIGluIGlucHV0LCBjYXN0IGl0IHRvIHZpZXcgYW5kIHByb2Nlc3NcbiAgICAgICAgICAgIGlmICh0YWtlID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFWaWV3ID0gY3JlYXRlVmlldyhkYXRhKTtcbiAgICAgICAgICAgICAgICBmb3IgKDsgYmxvY2tMZW4gPD0gbGVuIC0gcG9zOyBwb3MgKz0gYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2VzcyhkYXRhVmlldywgcG9zKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlci5zZXQoZGF0YS5zdWJhcnJheShwb3MsIHBvcyArIHRha2UpLCB0aGlzLnBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSB0YWtlO1xuICAgICAgICAgICAgcG9zICs9IHRha2U7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlbmd0aCArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgdGhpcy5yb3VuZENsZWFuKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBhZXhpc3RzKHRoaXMpO1xuICAgICAgICBhb3V0cHV0KG91dCwgdGhpcyk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAvLyBQYWRkaW5nXG4gICAgICAgIC8vIFdlIGNhbiBhdm9pZCBhbGxvY2F0aW9uIG9mIGJ1ZmZlciBmb3IgcGFkZGluZyBjb21wbGV0ZWx5IGlmIGl0XG4gICAgICAgIC8vIHdhcyBwcmV2aW91c2x5IG5vdCBhbGxvY2F0ZWQgaGVyZS4gQnV0IGl0IHdvbid0IGNoYW5nZSBwZXJmb3JtYW5jZS5cbiAgICAgICAgY29uc3QgeyBidWZmZXIsIHZpZXcsIGJsb2NrTGVuLCBpc0xFIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBwb3MgfSA9IHRoaXM7XG4gICAgICAgIC8vIGFwcGVuZCB0aGUgYml0ICcxJyB0byB0aGUgbWVzc2FnZVxuICAgICAgICBidWZmZXJbcG9zKytdID0gMGIxMDAwMDAwMDtcbiAgICAgICAgY2xlYW4odGhpcy5idWZmZXIuc3ViYXJyYXkocG9zKSk7XG4gICAgICAgIC8vIHdlIGhhdmUgbGVzcyB0aGFuIHBhZE9mZnNldCBsZWZ0IGluIGJ1ZmZlciwgc28gd2UgY2Fubm90IHB1dCBsZW5ndGggaW5cbiAgICAgICAgLy8gY3VycmVudCBibG9jaywgbmVlZCBwcm9jZXNzIGl0IGFuZCBwYWQgYWdhaW5cbiAgICAgICAgaWYgKHRoaXMucGFkT2Zmc2V0ID4gYmxvY2tMZW4gLSBwb3MpIHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgIHBvcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFkIHVudGlsIGZ1bGwgYmxvY2sgYnl0ZSB3aXRoIHplcm9zXG4gICAgICAgIGZvciAobGV0IGkgPSBwb3M7IGkgPCBibG9ja0xlbjsgaSsrKVxuICAgICAgICAgICAgYnVmZmVyW2ldID0gMDtcbiAgICAgICAgLy8gTm90ZTogc2hhNTEyIHJlcXVpcmVzIGxlbmd0aCB0byBiZSAxMjhiaXQgaW50ZWdlciwgYnV0IGxlbmd0aCBpbiBKUyB3aWxsIG92ZXJmbG93IGJlZm9yZSB0aGF0XG4gICAgICAgIC8vIFlvdSBuZWVkIHRvIHdyaXRlIGFyb3VuZCAyIGV4YWJ5dGVzICh1NjRfbWF4IC8gOCAvICgxMDI0Kio2KSkgZm9yIHRoaXMgdG8gaGFwcGVuLlxuICAgICAgICAvLyBTbyB3ZSBqdXN0IHdyaXRlIGxvd2VzdCA2NCBiaXRzIG9mIHRoYXQgdmFsdWUuXG4gICAgICAgIHNldEJpZ1VpbnQ2NCh2aWV3LCBibG9ja0xlbiAtIDgsIEJpZ0ludCh0aGlzLmxlbmd0aCAqIDgpLCBpc0xFKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICBjb25zdCBvdmlldyA9IGNyZWF0ZVZpZXcob3V0KTtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5vdXRwdXRMZW47XG4gICAgICAgIC8vIE5PVEU6IHdlIGRvIGRpdmlzaW9uIGJ5IDQgbGF0ZXIsIHdoaWNoIHNob3VsZCBiZSBmdXNlZCBpbiBzaW5nbGUgb3Agd2l0aCBtb2R1bG8gYnkgSklUXG4gICAgICAgIGlmIChsZW4gJSA0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIHNob3VsZCBiZSBhbGlnbmVkIHRvIDMyYml0Jyk7XG4gICAgICAgIGNvbnN0IG91dExlbiA9IGxlbiAvIDQ7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXQoKTtcbiAgICAgICAgaWYgKG91dExlbiA+IHN0YXRlLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBiaWdnZXIgdGhhbiBzdGF0ZScpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dExlbjsgaSsrKVxuICAgICAgICAgICAgb3ZpZXcuc2V0VWludDMyKDQgKiBpLCBzdGF0ZVtpXSwgaXNMRSk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3QgeyBidWZmZXIsIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKGJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IHJlcyA9IGJ1ZmZlci5zbGljZSgwLCBvdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICB0byB8fCAodG8gPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpKTtcbiAgICAgICAgdG8uc2V0KC4uLnRoaXMuZ2V0KCkpO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBidWZmZXIsIGxlbmd0aCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgcG9zIH0gPSB0aGlzO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSBkZXN0cm95ZWQ7XG4gICAgICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgICAgIHRvLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdG8ucG9zID0gcG9zO1xuICAgICAgICBpZiAobGVuZ3RoICUgYmxvY2tMZW4pXG4gICAgICAgICAgICB0by5idWZmZXIuc2V0KGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9uZUludG8oKTtcbiAgICB9XG59XG4vKipcbiAqIEluaXRpYWwgU0hBLTIgc3RhdGU6IGZyYWN0aW9uYWwgcGFydHMgb2Ygc3F1YXJlIHJvb3RzIG9mIGZpcnN0IDE2IHByaW1lcyAyLi41My5cbiAqIENoZWNrIG91dCBgdGVzdC9taXNjL3NoYTItZ2VuLWl2LmpzYCBmb3IgcmVjb21wdXRhdGlvbiBndWlkZS5cbiAqL1xuLyoqIEluaXRpYWwgU0hBMjU2IHN0YXRlLiBCaXRzIDAuLjMyIG9mIGZyYWMgcGFydCBvZiBzcXJ0IG9mIHByaW1lcyAyLi4xOSAqL1xuZXhwb3J0IGNvbnN0IFNIQTI1Nl9JViA9IC8qIEBfX1BVUkVfXyAqLyBVaW50MzJBcnJheS5mcm9tKFtcbiAgICAweDZhMDllNjY3LCAweGJiNjdhZTg1LCAweDNjNmVmMzcyLCAweGE1NGZmNTNhLCAweDUxMGU1MjdmLCAweDliMDU2ODhjLCAweDFmODNkOWFiLCAweDViZTBjZDE5LFxuXSk7XG4vKiogSW5pdGlhbCBTSEEyMjQgc3RhdGUuIEJpdHMgMzIuLjY0IG9mIGZyYWMgcGFydCBvZiBzcXJ0IG9mIHByaW1lcyAyMy4uNTMgKi9cbmV4cG9ydCBjb25zdCBTSEEyMjRfSVYgPSAvKiBAX19QVVJFX18gKi8gVWludDMyQXJyYXkuZnJvbShbXG4gICAgMHhjMTA1OWVkOCwgMHgzNjdjZDUwNywgMHgzMDcwZGQxNywgMHhmNzBlNTkzOSwgMHhmZmMwMGIzMSwgMHg2ODU4MTUxMSwgMHg2NGY5OGZhNywgMHhiZWZhNGZhNCxcbl0pO1xuLyoqIEluaXRpYWwgU0hBMzg0IHN0YXRlLiBCaXRzIDAuLjY0IG9mIGZyYWMgcGFydCBvZiBzcXJ0IG9mIHByaW1lcyAyMy4uNTMgKi9cbmV4cG9ydCBjb25zdCBTSEEzODRfSVYgPSAvKiBAX19QVVJFX18gKi8gVWludDMyQXJyYXkuZnJvbShbXG4gICAgMHhjYmJiOWQ1ZCwgMHhjMTA1OWVkOCwgMHg2MjlhMjkyYSwgMHgzNjdjZDUwNywgMHg5MTU5MDE1YSwgMHgzMDcwZGQxNywgMHgxNTJmZWNkOCwgMHhmNzBlNTkzOSxcbiAgICAweDY3MzMyNjY3LCAweGZmYzAwYjMxLCAweDhlYjQ0YTg3LCAweDY4NTgxNTExLCAweGRiMGMyZTBkLCAweDY0Zjk4ZmE3LCAweDQ3YjU0ODFkLCAweGJlZmE0ZmE0LFxuXSk7XG4vKiogSW5pdGlhbCBTSEE1MTIgc3RhdGUuIEJpdHMgMC4uNjQgb2YgZnJhYyBwYXJ0IG9mIHNxcnQgb2YgcHJpbWVzIDIuLjE5ICovXG5leHBvcnQgY29uc3QgU0hBNTEyX0lWID0gLyogQF9fUFVSRV9fICovIFVpbnQzMkFycmF5LmZyb20oW1xuICAgIDB4NmEwOWU2NjcsIDB4ZjNiY2M5MDgsIDB4YmI2N2FlODUsIDB4ODRjYWE3M2IsIDB4M2M2ZWYzNzIsIDB4ZmU5NGY4MmIsIDB4YTU0ZmY1M2EsIDB4NWYxZDM2ZjEsXG4gICAgMHg1MTBlNTI3ZiwgMHhhZGU2ODJkMSwgMHg5YjA1Njg4YywgMHgyYjNlNmMxZiwgMHgxZjgzZDlhYiwgMHhmYjQxYmQ2YiwgMHg1YmUwY2QxOSwgMHgxMzdlMjE3OSxcbl0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X21kLmpzLm1hcCJdLCJuYW1lcyI6WyJIYXNoIiwiYWJ5dGVzIiwiYWV4aXN0cyIsImFvdXRwdXQiLCJjbGVhbiIsImNyZWF0ZVZpZXciLCJ0b0J5dGVzIiwic2V0QmlnVWludDY0IiwidmlldyIsImJ5dGVPZmZzZXQiLCJ2YWx1ZSIsImlzTEUiLCJfMzJuIiwiQmlnSW50IiwiX3UzMl9tYXgiLCJ3aCIsIk51bWJlciIsIndsIiwiaCIsImwiLCJzZXRVaW50MzIiLCJDaGkiLCJhIiwiYiIsImMiLCJNYWoiLCJIYXNoTUQiLCJjb25zdHJ1Y3RvciIsImJsb2NrTGVuIiwib3V0cHV0TGVuIiwicGFkT2Zmc2V0IiwiZmluaXNoZWQiLCJsZW5ndGgiLCJwb3MiLCJkZXN0cm95ZWQiLCJidWZmZXIiLCJVaW50OEFycmF5IiwidXBkYXRlIiwiZGF0YSIsImxlbiIsInRha2UiLCJNYXRoIiwibWluIiwiZGF0YVZpZXciLCJwcm9jZXNzIiwic2V0Iiwic3ViYXJyYXkiLCJyb3VuZENsZWFuIiwiZGlnZXN0SW50byIsIm91dCIsImkiLCJvdmlldyIsIkVycm9yIiwib3V0TGVuIiwic3RhdGUiLCJnZXQiLCJkaWdlc3QiLCJyZXMiLCJzbGljZSIsImRlc3Ryb3kiLCJfY2xvbmVJbnRvIiwidG8iLCJjbG9uZSIsIlNIQTI1Nl9JViIsIlVpbnQzMkFycmF5IiwiZnJvbSIsIlNIQTIyNF9JViIsIlNIQTM4NF9JViIsIlNIQTUxMl9JViJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/_md.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/_u64.js":
/*!****************************************************************!*\
  !*** ./node_modules/ox/node_modules/@noble/hashes/esm/_u64.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   add: () => (/* binding */ add),\n/* harmony export */   add3H: () => (/* binding */ add3H),\n/* harmony export */   add3L: () => (/* binding */ add3L),\n/* harmony export */   add4H: () => (/* binding */ add4H),\n/* harmony export */   add4L: () => (/* binding */ add4L),\n/* harmony export */   add5H: () => (/* binding */ add5H),\n/* harmony export */   add5L: () => (/* binding */ add5L),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   fromBig: () => (/* binding */ fromBig),\n/* harmony export */   rotlBH: () => (/* binding */ rotlBH),\n/* harmony export */   rotlBL: () => (/* binding */ rotlBL),\n/* harmony export */   rotlSH: () => (/* binding */ rotlSH),\n/* harmony export */   rotlSL: () => (/* binding */ rotlSL),\n/* harmony export */   rotr32H: () => (/* binding */ rotr32H),\n/* harmony export */   rotr32L: () => (/* binding */ rotr32L),\n/* harmony export */   rotrBH: () => (/* binding */ rotrBH),\n/* harmony export */   rotrBL: () => (/* binding */ rotrBL),\n/* harmony export */   rotrSH: () => (/* binding */ rotrSH),\n/* harmony export */   rotrSL: () => (/* binding */ rotrSL),\n/* harmony export */   shrSH: () => (/* binding */ shrSH),\n/* harmony export */   shrSL: () => (/* binding */ shrSL),\n/* harmony export */   split: () => (/* binding */ split),\n/* harmony export */   toBig: () => (/* binding */ toBig)\n/* harmony export */ });\n/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */ const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\nfunction fromBig(n, le = false) {\n    if (le) return {\n        h: Number(n & U32_MASK64),\n        l: Number(n >> _32n & U32_MASK64)\n    };\n    return {\n        h: Number(n >> _32n & U32_MASK64) | 0,\n        l: Number(n & U32_MASK64) | 0\n    };\n}\nfunction split(lst, le = false) {\n    const len = lst.length;\n    let Ah = new Uint32Array(len);\n    let Al = new Uint32Array(len);\n    for(let i = 0; i < len; i++){\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [\n            h,\n            l\n        ];\n    }\n    return [\n        Ah,\n        Al\n    ];\n}\nconst toBig = (h, l)=>BigInt(h >>> 0) << _32n | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s)=>h >>> s;\nconst shrSL = (h, l, s)=>h << 32 - s | l >>> s;\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s)=>h >>> s | l << 32 - s;\nconst rotrSL = (h, l, s)=>h << 32 - s | l >>> s;\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s)=>h << 64 - s | l >>> s - 32;\nconst rotrBL = (h, l, s)=>h >>> s - 32 | l << 64 - s;\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l)=>l;\nconst rotr32L = (h, _l)=>h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s)=>h << s | l >>> 32 - s;\nconst rotlSL = (h, l, s)=>l << s | h >>> 32 - s;\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s)=>l << s - 32 | h >>> 64 - s;\nconst rotlBL = (h, l, s)=>h << s - 32 | l >>> 64 - s;\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return {\n        h: Ah + Bh + (l / 2 ** 32 | 0) | 0,\n        l: l | 0\n    };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch)=>Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;\nconst add4L = (Al, Bl, Cl, Dl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh)=>Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh)=>Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;\n// prettier-ignore\n\n// prettier-ignore\nconst u64 = {\n    fromBig,\n    split,\n    toBig,\n    shrSH,\n    shrSL,\n    rotrSH,\n    rotrSL,\n    rotrBH,\n    rotrBL,\n    rotr32H,\n    rotr32L,\n    rotlSH,\n    rotlSL,\n    rotlBH,\n    rotlBL,\n    add,\n    add3L,\n    add3H,\n    add4L,\n    add4H,\n    add5H,\n    add5L\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (u64); //# sourceMappingURL=_u64.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL191NjQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7OztDQUlDLEdBQ0QsTUFBTUEsYUFBYSxhQUFhLEdBQUdDLE9BQU8sS0FBSyxLQUFLO0FBQ3BELE1BQU1DLE9BQU8sYUFBYSxHQUFHRCxPQUFPO0FBQ3BDLFNBQVNFLFFBQVFDLENBQUMsRUFBRUMsS0FBSyxLQUFLO0lBQzFCLElBQUlBLElBQ0EsT0FBTztRQUFFQyxHQUFHQyxPQUFPSCxJQUFJSjtRQUFhUSxHQUFHRCxPQUFPLEtBQU1MLE9BQVFGO0lBQVk7SUFDNUUsT0FBTztRQUFFTSxHQUFHQyxPQUFPLEtBQU1MLE9BQVFGLGNBQWM7UUFBR1EsR0FBR0QsT0FBT0gsSUFBSUosY0FBYztJQUFFO0FBQ3BGO0FBQ0EsU0FBU1MsTUFBTUMsR0FBRyxFQUFFTCxLQUFLLEtBQUs7SUFDMUIsTUFBTU0sTUFBTUQsSUFBSUUsTUFBTTtJQUN0QixJQUFJQyxLQUFLLElBQUlDLFlBQVlIO0lBQ3pCLElBQUlJLEtBQUssSUFBSUQsWUFBWUg7SUFDekIsSUFBSyxJQUFJSyxJQUFJLEdBQUdBLElBQUlMLEtBQUtLLElBQUs7UUFDMUIsTUFBTSxFQUFFVixDQUFDLEVBQUVFLENBQUMsRUFBRSxHQUFHTCxRQUFRTyxHQUFHLENBQUNNLEVBQUUsRUFBRVg7UUFDakMsQ0FBQ1EsRUFBRSxDQUFDRyxFQUFFLEVBQUVELEVBQUUsQ0FBQ0MsRUFBRSxDQUFDLEdBQUc7WUFBQ1Y7WUFBR0U7U0FBRTtJQUMzQjtJQUNBLE9BQU87UUFBQ0s7UUFBSUU7S0FBRztBQUNuQjtBQUNBLE1BQU1FLFFBQVEsQ0FBQ1gsR0FBR0UsSUFBTSxPQUFRRixNQUFNLE1BQU1KLE9BQVFELE9BQU9PLE1BQU07QUFDakUsdUJBQXVCO0FBQ3ZCLE1BQU1VLFFBQVEsQ0FBQ1osR0FBR2EsSUFBSUMsSUFBTWQsTUFBTWM7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QUMsQ0FDbkIsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xhdy13b3Jrcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX3U2NC5qcz8zMTUwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSW50ZXJuYWwgaGVscGVycyBmb3IgdTY0LiBCaWdVaW50NjRBcnJheSBpcyB0b28gc2xvdyBhcyBwZXIgMjAyNSwgc28gd2UgaW1wbGVtZW50IGl0IHVzaW5nIFVpbnQzMkFycmF5LlxuICogQHRvZG8gcmUtY2hlY2sgaHR0cHM6Ly9pc3N1ZXMuY2hyb21pdW0ub3JnL2lzc3Vlcy80MjIxMjU4OFxuICogQG1vZHVsZVxuICovXG5jb25zdCBVMzJfTUFTSzY0ID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgyICoqIDMyIC0gMSk7XG5jb25zdCBfMzJuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgzMik7XG5mdW5jdGlvbiBmcm9tQmlnKG4sIGxlID0gZmFsc2UpIHtcbiAgICBpZiAobGUpXG4gICAgICAgIHJldHVybiB7IGg6IE51bWJlcihuICYgVTMyX01BU0s2NCksIGw6IE51bWJlcigobiA+PiBfMzJuKSAmIFUzMl9NQVNLNjQpIH07XG4gICAgcmV0dXJuIHsgaDogTnVtYmVyKChuID4+IF8zMm4pICYgVTMyX01BU0s2NCkgfCAwLCBsOiBOdW1iZXIobiAmIFUzMl9NQVNLNjQpIHwgMCB9O1xufVxuZnVuY3Rpb24gc3BsaXQobHN0LCBsZSA9IGZhbHNlKSB7XG4gICAgY29uc3QgbGVuID0gbHN0Lmxlbmd0aDtcbiAgICBsZXQgQWggPSBuZXcgVWludDMyQXJyYXkobGVuKTtcbiAgICBsZXQgQWwgPSBuZXcgVWludDMyQXJyYXkobGVuKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHsgaCwgbCB9ID0gZnJvbUJpZyhsc3RbaV0sIGxlKTtcbiAgICAgICAgW0FoW2ldLCBBbFtpXV0gPSBbaCwgbF07XG4gICAgfVxuICAgIHJldHVybiBbQWgsIEFsXTtcbn1cbmNvbnN0IHRvQmlnID0gKGgsIGwpID0+IChCaWdJbnQoaCA+Pj4gMCkgPDwgXzMybikgfCBCaWdJbnQobCA+Pj4gMCk7XG4vLyBmb3IgU2hpZnQgaW4gWzAsIDMyKVxuY29uc3Qgc2hyU0ggPSAoaCwgX2wsIHMpID0+IGggPj4+IHM7XG5jb25zdCBzaHJTTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoMzIgLSBzKSkgfCAobCA+Pj4gcyk7XG4vLyBSaWdodCByb3RhdGUgZm9yIFNoaWZ0IGluIFsxLCAzMilcbmNvbnN0IHJvdHJTSCA9IChoLCBsLCBzKSA9PiAoaCA+Pj4gcykgfCAobCA8PCAoMzIgLSBzKSk7XG5jb25zdCByb3RyU0wgPSAoaCwgbCwgcykgPT4gKGggPDwgKDMyIC0gcykpIHwgKGwgPj4+IHMpO1xuLy8gUmlnaHQgcm90YXRlIGZvciBTaGlmdCBpbiAoMzIsIDY0KSwgTk9URTogMzIgaXMgc3BlY2lhbCBjYXNlLlxuY29uc3Qgcm90ckJIID0gKGgsIGwsIHMpID0+IChoIDw8ICg2NCAtIHMpKSB8IChsID4+PiAocyAtIDMyKSk7XG5jb25zdCByb3RyQkwgPSAoaCwgbCwgcykgPT4gKGggPj4+IChzIC0gMzIpKSB8IChsIDw8ICg2NCAtIHMpKTtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3Igc2hpZnQ9PT0zMiAoanVzdCBzd2FwcyBsJmgpXG5jb25zdCByb3RyMzJIID0gKF9oLCBsKSA9PiBsO1xuY29uc3Qgcm90cjMyTCA9IChoLCBfbCkgPT4gaDtcbi8vIExlZnQgcm90YXRlIGZvciBTaGlmdCBpbiBbMSwgMzIpXG5jb25zdCByb3RsU0ggPSAoaCwgbCwgcykgPT4gKGggPDwgcykgfCAobCA+Pj4gKDMyIC0gcykpO1xuY29uc3Qgcm90bFNMID0gKGgsIGwsIHMpID0+IChsIDw8IHMpIHwgKGggPj4+ICgzMiAtIHMpKTtcbi8vIExlZnQgcm90YXRlIGZvciBTaGlmdCBpbiAoMzIsIDY0KSwgTk9URTogMzIgaXMgc3BlY2lhbCBjYXNlLlxuY29uc3Qgcm90bEJIID0gKGgsIGwsIHMpID0+IChsIDw8IChzIC0gMzIpKSB8IChoID4+PiAoNjQgLSBzKSk7XG5jb25zdCByb3RsQkwgPSAoaCwgbCwgcykgPT4gKGggPDwgKHMgLSAzMikpIHwgKGwgPj4+ICg2NCAtIHMpKTtcbi8vIEpTIHVzZXMgMzItYml0IHNpZ25lZCBpbnRlZ2VycyBmb3IgYml0d2lzZSBvcGVyYXRpb25zIHdoaWNoIG1lYW5zIHdlIGNhbm5vdFxuLy8gc2ltcGxlIHRha2UgY2Fycnkgb3V0IG9mIGxvdyBiaXQgc3VtIGJ5IHNoaWZ0LCB3ZSBuZWVkIHRvIHVzZSBkaXZpc2lvbi5cbmZ1bmN0aW9uIGFkZChBaCwgQWwsIEJoLCBCbCkge1xuICAgIGNvbnN0IGwgPSAoQWwgPj4+IDApICsgKEJsID4+PiAwKTtcbiAgICByZXR1cm4geyBoOiAoQWggKyBCaCArICgobCAvIDIgKiogMzIpIHwgMCkpIHwgMCwgbDogbCB8IDAgfTtcbn1cbi8vIEFkZGl0aW9uIHdpdGggbW9yZSB0aGFuIDIgZWxlbWVudHNcbmNvbnN0IGFkZDNMID0gKEFsLCBCbCwgQ2wpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKTtcbmNvbnN0IGFkZDNIID0gKGxvdywgQWgsIEJoLCBDaCkgPT4gKEFoICsgQmggKyBDaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuY29uc3QgYWRkNEwgPSAoQWwsIEJsLCBDbCwgRGwpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKSArIChEbCA+Pj4gMCk7XG5jb25zdCBhZGQ0SCA9IChsb3csIEFoLCBCaCwgQ2gsIERoKSA9PiAoQWggKyBCaCArIENoICsgRGggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbmNvbnN0IGFkZDVMID0gKEFsLCBCbCwgQ2wsIERsLCBFbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApICsgKERsID4+PiAwKSArIChFbCA+Pj4gMCk7XG5jb25zdCBhZGQ1SCA9IChsb3csIEFoLCBCaCwgQ2gsIERoLCBFaCkgPT4gKEFoICsgQmggKyBDaCArIERoICsgRWggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbi8vIHByZXR0aWVyLWlnbm9yZVxuZXhwb3J0IHsgYWRkLCBhZGQzSCwgYWRkM0wsIGFkZDRILCBhZGQ0TCwgYWRkNUgsIGFkZDVMLCBmcm9tQmlnLCByb3RsQkgsIHJvdGxCTCwgcm90bFNILCByb3RsU0wsIHJvdHIzMkgsIHJvdHIzMkwsIHJvdHJCSCwgcm90ckJMLCByb3RyU0gsIHJvdHJTTCwgc2hyU0gsIHNoclNMLCBzcGxpdCwgdG9CaWcgfTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgdTY0ID0ge1xuICAgIGZyb21CaWcsIHNwbGl0LCB0b0JpZyxcbiAgICBzaHJTSCwgc2hyU0wsXG4gICAgcm90clNILCByb3RyU0wsIHJvdHJCSCwgcm90ckJMLFxuICAgIHJvdHIzMkgsIHJvdHIzMkwsXG4gICAgcm90bFNILCByb3RsU0wsIHJvdGxCSCwgcm90bEJMLFxuICAgIGFkZCwgYWRkM0wsIGFkZDNILCBhZGQ0TCwgYWRkNEgsIGFkZDVILCBhZGQ1TCxcbn07XG5leHBvcnQgZGVmYXVsdCB1NjQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdTY0LmpzLm1hcCJdLCJuYW1lcyI6WyJVMzJfTUFTSzY0IiwiQmlnSW50IiwiXzMybiIsImZyb21CaWciLCJuIiwibGUiLCJoIiwiTnVtYmVyIiwibCIsInNwbGl0IiwibHN0IiwibGVuIiwibGVuZ3RoIiwiQWgiLCJVaW50MzJBcnJheSIsIkFsIiwiaSIsInRvQmlnIiwic2hyU0giLCJfbCIsInMiLCJzaHJTTCIsInJvdHJTSCIsInJvdHJTTCIsInJvdHJCSCIsInJvdHJCTCIsInJvdHIzMkgiLCJfaCIsInJvdHIzMkwiLCJyb3RsU0giLCJyb3RsU0wiLCJyb3RsQkgiLCJyb3RsQkwiLCJhZGQiLCJCaCIsIkJsIiwiYWRkM0wiLCJDbCIsImFkZDNIIiwibG93IiwiQ2giLCJhZGQ0TCIsIkRsIiwiYWRkNEgiLCJEaCIsImFkZDVMIiwiRWwiLCJhZGQ1SCIsIkVoIiwidTY0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/_u64.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/cryptoNode.js":
/*!**********************************************************************!*\
  !*** ./node_modules/ox/node_modules/@noble/hashes/esm/cryptoNode.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crypto: () => (/* binding */ crypto)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n/**\n * Internal webcrypto alias.\n * We prefer WebCrypto aka globalThis.crypto, which exists in node.js 16+.\n * Falls back to Node.js built-in crypto for Node.js <=v14.\n * See utils.ts for details.\n * @module\n */ // @ts-ignore\n\nconst crypto = /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) && typeof /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) === \"object\" && \"webcrypto\" in /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) ? node_crypto__WEBPACK_IMPORTED_MODULE_0__.webcrypto : /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) && typeof /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) === \"object\" && \"randomBytes\" in /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) ? /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) : undefined; //# sourceMappingURL=cryptoNode.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2NyeXB0b05vZGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7Ozs7OztDQU1DLEdBQ0QsYUFBYTtBQUNxQjtBQUMzQixNQUFNQyxTQUFTRCwyTUFBRUEsSUFBSSxPQUFPQSwyTUFBRUEsS0FBSyxZQUFZLDBOQUFpQkEsR0FDakVBLGtEQUFZLEdBQ1pBLDJNQUFFQSxJQUFJLE9BQU9BLDJNQUFFQSxLQUFLLFlBQVksNE5BQW1CQSxHQUMvQ0EsMk1BQUVBLEdBQ0ZHLFVBQVUsQ0FDcEIsc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xhdy13b3Jrcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vY3J5cHRvTm9kZS5qcz8zYzZlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSW50ZXJuYWwgd2ViY3J5cHRvIGFsaWFzLlxuICogV2UgcHJlZmVyIFdlYkNyeXB0byBha2EgZ2xvYmFsVGhpcy5jcnlwdG8sIHdoaWNoIGV4aXN0cyBpbiBub2RlLmpzIDE2Ky5cbiAqIEZhbGxzIGJhY2sgdG8gTm9kZS5qcyBidWlsdC1pbiBjcnlwdG8gZm9yIE5vZGUuanMgPD12MTQuXG4gKiBTZWUgdXRpbHMudHMgZm9yIGRldGFpbHMuXG4gKiBAbW9kdWxlXG4gKi9cbi8vIEB0cy1pZ25vcmVcbmltcG9ydCAqIGFzIG5jIGZyb20gJ25vZGU6Y3J5cHRvJztcbmV4cG9ydCBjb25zdCBjcnlwdG8gPSBuYyAmJiB0eXBlb2YgbmMgPT09ICdvYmplY3QnICYmICd3ZWJjcnlwdG8nIGluIG5jXG4gICAgPyBuYy53ZWJjcnlwdG9cbiAgICA6IG5jICYmIHR5cGVvZiBuYyA9PT0gJ29iamVjdCcgJiYgJ3JhbmRvbUJ5dGVzJyBpbiBuY1xuICAgICAgICA/IG5jXG4gICAgICAgIDogdW5kZWZpbmVkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3J5cHRvTm9kZS5qcy5tYXAiXSwibmFtZXMiOlsibmMiLCJjcnlwdG8iLCJ3ZWJjcnlwdG8iLCJ1bmRlZmluZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/cryptoNode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/hmac.js":
/*!****************************************************************!*\
  !*** ./node_modules/ox/node_modules/@noble/hashes/esm/hmac.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HMAC: () => (/* binding */ HMAC),\n/* harmony export */   hmac: () => (/* binding */ hmac)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/utils.js\");\n/**\n * HMAC: RFC2104 message authentication code.\n * @module\n */ \nclass HMAC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(hash, _key){\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ahash)(hash);\n        const key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== \"function\") throw new Error(\"Expected instance of class which extends utils.Hash\");\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for(let i = 0; i < pad.length; i++)pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for(let i = 0; i < pad.length; i++)pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.clean)(pad);\n    }\n    update(buf) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aexists)(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aexists)(this);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n * @example\n * import { hmac } from '@noble/hashes/hmac';\n * import { sha256 } from '@noble/hashes/sha2';\n * const mac1 = hmac(sha256, 'key', 'message');\n */ const hmac = (hash, key, message)=>new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key)=>new HMAC(hash, key); //# sourceMappingURL=hmac.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2htYWMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7OztDQUdDLEdBQ3lFO0FBQ25FLE1BQU1NLGFBQWFGLDJDQUFJQTtJQUMxQkcsWUFBWUMsSUFBSSxFQUFFQyxJQUFJLENBQUU7UUFDcEIsS0FBSztRQUNMLElBQUksQ0FBQ0MsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0MsU0FBUyxHQUFHO1FBQ2pCVCxnREFBS0EsQ0FBQ007UUFDTixNQUFNSSxNQUFNUCxrREFBT0EsQ0FBQ0k7UUFDcEIsSUFBSSxDQUFDSSxLQUFLLEdBQUdMLEtBQUtNLE1BQU07UUFDeEIsSUFBSSxPQUFPLElBQUksQ0FBQ0QsS0FBSyxDQUFDRSxNQUFNLEtBQUssWUFDN0IsTUFBTSxJQUFJQyxNQUFNO1FBQ3BCLElBQUksQ0FBQ0MsUUFBUSxHQUFHLElBQUksQ0FBQ0osS0FBSyxDQUFDSSxRQUFRO1FBQ25DLElBQUksQ0FBQ0MsU0FBUyxHQUFHLElBQUksQ0FBQ0wsS0FBSyxDQUFDSyxTQUFTO1FBQ3JDLE1BQU1ELFdBQVcsSUFBSSxDQUFDQSxRQUFRO1FBQzlCLE1BQU1FLE1BQU0sSUFBSUMsV0FBV0g7UUFDM0Isd0NBQXdDO1FBQ3hDRSxJQUFJRSxHQUFHLENBQUNULElBQUlVLE1BQU0sR0FBR0wsV0FBV1QsS0FBS00sTUFBTSxHQUFHQyxNQUFNLENBQUNILEtBQUtXLE1BQU0sS0FBS1g7UUFDckUsSUFBSyxJQUFJWSxJQUFJLEdBQUdBLElBQUlMLElBQUlHLE1BQU0sRUFBRUUsSUFDNUJMLEdBQUcsQ0FBQ0ssRUFBRSxJQUFJO1FBQ2QsSUFBSSxDQUFDWCxLQUFLLENBQUNFLE1BQU0sQ0FBQ0k7UUFDbEIsbUhBQW1IO1FBQ25ILElBQUksQ0FBQ00sS0FBSyxHQUFHakIsS0FBS00sTUFBTTtRQUN4Qix1Q0FBdUM7UUFDdkMsSUFBSyxJQUFJVSxJQUFJLEdBQUdBLElBQUlMLElBQUlHLE1BQU0sRUFBRUUsSUFDNUJMLEdBQUcsQ0FBQ0ssRUFBRSxJQUFJLE9BQU87UUFDckIsSUFBSSxDQUFDQyxLQUFLLENBQUNWLE1BQU0sQ0FBQ0k7UUFDbEJoQixnREFBS0EsQ0FBQ2dCO0lBQ1Y7SUFDQUosT0FBT1csR0FBRyxFQUFFO1FBQ1J6QixrREFBT0EsQ0FBQyxJQUFJO1FBQ1osSUFBSSxDQUFDWSxLQUFLLENBQUNFLE1BQU0sQ0FBQ1c7UUFDbEIsT0FBTyxJQUFJO0lBQ2Y7SUFDQUMsV0FBV0MsR0FBRyxFQUFFO1FBQ1ozQixrREFBT0EsQ0FBQyxJQUFJO1FBQ1pELGlEQUFNQSxDQUFDNEIsS0FBSyxJQUFJLENBQUNWLFNBQVM7UUFDMUIsSUFBSSxDQUFDUixRQUFRLEdBQUc7UUFDaEIsSUFBSSxDQUFDRyxLQUFLLENBQUNjLFVBQVUsQ0FBQ0M7UUFDdEIsSUFBSSxDQUFDSCxLQUFLLENBQUNWLE1BQU0sQ0FBQ2E7UUFDbEIsSUFBSSxDQUFDSCxLQUFLLENBQUNFLFVBQVUsQ0FBQ0M7UUFDdEIsSUFBSSxDQUFDQyxPQUFPO0lBQ2hCO0lBQ0FOLFNBQVM7UUFDTCxNQUFNSyxNQUFNLElBQUlSLFdBQVcsSUFBSSxDQUFDSyxLQUFLLENBQUNQLFNBQVM7UUFDL0MsSUFBSSxDQUFDUyxVQUFVLENBQUNDO1FBQ2hCLE9BQU9BO0lBQ1g7SUFDQUUsV0FBV0MsRUFBRSxFQUFFO1FBQ1gsbUdBQW1HO1FBQ25HQSxNQUFPQSxDQUFBQSxLQUFLQyxPQUFPbEIsTUFBTSxDQUFDa0IsT0FBT0MsY0FBYyxDQUFDLElBQUksR0FBRyxDQUFDLEVBQUM7UUFDekQsTUFBTSxFQUFFUixLQUFLLEVBQUVaLEtBQUssRUFBRUgsUUFBUSxFQUFFQyxTQUFTLEVBQUVNLFFBQVEsRUFBRUMsU0FBUyxFQUFFLEdBQUcsSUFBSTtRQUN2RWEsS0FBS0E7UUFDTEEsR0FBR3JCLFFBQVEsR0FBR0E7UUFDZHFCLEdBQUdwQixTQUFTLEdBQUdBO1FBQ2ZvQixHQUFHZCxRQUFRLEdBQUdBO1FBQ2RjLEdBQUdiLFNBQVMsR0FBR0E7UUFDZmEsR0FBR04sS0FBSyxHQUFHQSxNQUFNSyxVQUFVLENBQUNDLEdBQUdOLEtBQUs7UUFDcENNLEdBQUdsQixLQUFLLEdBQUdBLE1BQU1pQixVQUFVLENBQUNDLEdBQUdsQixLQUFLO1FBQ3BDLE9BQU9rQjtJQUNYO0lBQ0FHLFFBQVE7UUFDSixPQUFPLElBQUksQ0FBQ0osVUFBVTtJQUMxQjtJQUNBRCxVQUFVO1FBQ04sSUFBSSxDQUFDbEIsU0FBUyxHQUFHO1FBQ2pCLElBQUksQ0FBQ2MsS0FBSyxDQUFDSSxPQUFPO1FBQ2xCLElBQUksQ0FBQ2hCLEtBQUssQ0FBQ2dCLE9BQU87SUFDdEI7QUFDSjtBQUNBOzs7Ozs7Ozs7Q0FTQyxHQUNNLE1BQU1NLE9BQU8sQ0FBQzNCLE1BQU1JLEtBQUt3QixVQUFZLElBQUk5QixLQUFLRSxNQUFNSSxLQUFLRyxNQUFNLENBQUNxQixTQUFTYixNQUFNLEdBQUc7QUFDekZZLEtBQUtyQixNQUFNLEdBQUcsQ0FBQ04sTUFBTUksTUFBUSxJQUFJTixLQUFLRSxNQUFNSSxNQUM1QyxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGF3LXdvcmtzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9obWFjLmpzP2UyYzkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBITUFDOiBSRkMyMTA0IG1lc3NhZ2UgYXV0aGVudGljYXRpb24gY29kZS5cbiAqIEBtb2R1bGVcbiAqL1xuaW1wb3J0IHsgYWJ5dGVzLCBhZXhpc3RzLCBhaGFzaCwgY2xlYW4sIEhhc2gsIHRvQnl0ZXMgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuZXhwb3J0IGNsYXNzIEhNQUMgZXh0ZW5kcyBIYXNoIHtcbiAgICBjb25zdHJ1Y3RvcihoYXNoLCBfa2V5KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgYWhhc2goaGFzaCk7XG4gICAgICAgIGNvbnN0IGtleSA9IHRvQnl0ZXMoX2tleSk7XG4gICAgICAgIHRoaXMuaUhhc2ggPSBoYXNoLmNyZWF0ZSgpO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuaUhhc2gudXBkYXRlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBpbnN0YW5jZSBvZiBjbGFzcyB3aGljaCBleHRlbmRzIHV0aWxzLkhhc2gnKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IHRoaXMuaUhhc2guYmxvY2tMZW47XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gdGhpcy5pSGFzaC5vdXRwdXRMZW47XG4gICAgICAgIGNvbnN0IGJsb2NrTGVuID0gdGhpcy5ibG9ja0xlbjtcbiAgICAgICAgY29uc3QgcGFkID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xuICAgICAgICAvLyBibG9ja0xlbiBjYW4gYmUgYmlnZ2VyIHRoYW4gb3V0cHV0TGVuXG4gICAgICAgIHBhZC5zZXQoa2V5Lmxlbmd0aCA+IGJsb2NrTGVuID8gaGFzaC5jcmVhdGUoKS51cGRhdGUoa2V5KS5kaWdlc3QoKSA6IGtleSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcGFkW2ldIF49IDB4MzY7XG4gICAgICAgIHRoaXMuaUhhc2gudXBkYXRlKHBhZCk7XG4gICAgICAgIC8vIEJ5IGRvaW5nIHVwZGF0ZSAocHJvY2Vzc2luZyBvZiBmaXJzdCBibG9jaykgb2Ygb3V0ZXIgaGFzaCBoZXJlIHdlIGNhbiByZS11c2UgaXQgYmV0d2VlbiBtdWx0aXBsZSBjYWxscyB2aWEgY2xvbmVcbiAgICAgICAgdGhpcy5vSGFzaCA9IGhhc2guY3JlYXRlKCk7XG4gICAgICAgIC8vIFVuZG8gaW50ZXJuYWwgWE9SICYmIGFwcGx5IG91dGVyIFhPUlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHBhZFtpXSBePSAweDM2IF4gMHg1YztcbiAgICAgICAgdGhpcy5vSGFzaC51cGRhdGUocGFkKTtcbiAgICAgICAgY2xlYW4ocGFkKTtcbiAgICB9XG4gICAgdXBkYXRlKGJ1Zikge1xuICAgICAgICBhZXhpc3RzKHRoaXMpO1xuICAgICAgICB0aGlzLmlIYXNoLnVwZGF0ZShidWYpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgYWV4aXN0cyh0aGlzKTtcbiAgICAgICAgYWJ5dGVzKG91dCwgdGhpcy5vdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pSGFzaC5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHRoaXMub0hhc2gudXBkYXRlKG91dCk7XG4gICAgICAgIHRoaXMub0hhc2guZGlnZXN0SW50byhvdXQpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheSh0aGlzLm9IYXNoLm91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZGlnZXN0SW50byhvdXQpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIC8vIENyZWF0ZSBuZXcgaW5zdGFuY2Ugd2l0aG91dCBjYWxsaW5nIGNvbnN0cnVjdG9yIHNpbmNlIGtleSBhbHJlYWR5IGluIHN0YXRlIGFuZCB3ZSBkb24ndCBrbm93IGl0LlxuICAgICAgICB0byB8fCAodG8gPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSwge30pKTtcbiAgICAgICAgY29uc3QgeyBvSGFzaCwgaUhhc2gsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIGJsb2NrTGVuLCBvdXRwdXRMZW4gfSA9IHRoaXM7XG4gICAgICAgIHRvID0gdG87XG4gICAgICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcbiAgICAgICAgdG8uYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdG8ub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0by5vSGFzaCA9IG9IYXNoLl9jbG9uZUludG8odG8ub0hhc2gpO1xuICAgICAgICB0by5pSGFzaCA9IGlIYXNoLl9jbG9uZUludG8odG8uaUhhc2gpO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvbmVJbnRvKCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vSGFzaC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuaUhhc2guZGVzdHJveSgpO1xuICAgIH1cbn1cbi8qKlxuICogSE1BQzogUkZDMjEwNCBtZXNzYWdlIGF1dGhlbnRpY2F0aW9uIGNvZGUuXG4gKiBAcGFyYW0gaGFzaCAtIGZ1bmN0aW9uIHRoYXQgd291bGQgYmUgdXNlZCBlLmcuIHNoYTI1NlxuICogQHBhcmFtIGtleSAtIG1lc3NhZ2Uga2V5XG4gKiBAcGFyYW0gbWVzc2FnZSAtIG1lc3NhZ2UgZGF0YVxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IGhtYWMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL2htYWMnO1xuICogaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGEyJztcbiAqIGNvbnN0IG1hYzEgPSBobWFjKHNoYTI1NiwgJ2tleScsICdtZXNzYWdlJyk7XG4gKi9cbmV4cG9ydCBjb25zdCBobWFjID0gKGhhc2gsIGtleSwgbWVzc2FnZSkgPT4gbmV3IEhNQUMoaGFzaCwga2V5KS51cGRhdGUobWVzc2FnZSkuZGlnZXN0KCk7XG5obWFjLmNyZWF0ZSA9IChoYXNoLCBrZXkpID0+IG5ldyBITUFDKGhhc2gsIGtleSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1obWFjLmpzLm1hcCJdLCJuYW1lcyI6WyJhYnl0ZXMiLCJhZXhpc3RzIiwiYWhhc2giLCJjbGVhbiIsIkhhc2giLCJ0b0J5dGVzIiwiSE1BQyIsImNvbnN0cnVjdG9yIiwiaGFzaCIsIl9rZXkiLCJmaW5pc2hlZCIsImRlc3Ryb3llZCIsImtleSIsImlIYXNoIiwiY3JlYXRlIiwidXBkYXRlIiwiRXJyb3IiLCJibG9ja0xlbiIsIm91dHB1dExlbiIsInBhZCIsIlVpbnQ4QXJyYXkiLCJzZXQiLCJsZW5ndGgiLCJkaWdlc3QiLCJpIiwib0hhc2giLCJidWYiLCJkaWdlc3RJbnRvIiwib3V0IiwiZGVzdHJveSIsIl9jbG9uZUludG8iLCJ0byIsIk9iamVjdCIsImdldFByb3RvdHlwZU9mIiwiY2xvbmUiLCJobWFjIiwibWVzc2FnZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/hmac.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/legacy.js":
/*!******************************************************************!*\
  !*** ./node_modules/ox/node_modules/@noble/hashes/esm/legacy.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MD5: () => (/* binding */ MD5),\n/* harmony export */   RIPEMD160: () => (/* binding */ RIPEMD160),\n/* harmony export */   SHA1: () => (/* binding */ SHA1),\n/* harmony export */   md5: () => (/* binding */ md5),\n/* harmony export */   ripemd160: () => (/* binding */ ripemd160),\n/* harmony export */   sha1: () => (/* binding */ sha1)\n/* harmony export */ });\n/* harmony import */ var _md_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_md.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/_md.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/utils.js\");\n/**\n\nSHA1 (RFC 3174), MD5 (RFC 1321) and RIPEMD160 (RFC 2286) legacy, weak hash functions.\nDon't use them in a new protocol. What \"weak\" means:\n\n- Collisions can be made with 2^18 effort in MD5, 2^60 in SHA1, 2^80 in RIPEMD160.\n- No practical pre-image attacks (only theoretical, 2^123.4)\n- HMAC seems kinda ok: https://datatracker.ietf.org/doc/html/rfc6151\n * @module\n */ \n\n/** Initial SHA1 state */ const SHA1_IV = /* @__PURE__ */ Uint32Array.from([\n    0x67452301,\n    0xefcdab89,\n    0x98badcfe,\n    0x10325476,\n    0xc3d2e1f0\n]);\n// Reusable temporary buffer\nconst SHA1_W = /* @__PURE__ */ new Uint32Array(80);\n/** SHA1 legacy hash class. */ class SHA1 extends _md_js__WEBPACK_IMPORTED_MODULE_0__.HashMD {\n    constructor(){\n        super(64, 20, 8, false);\n        this.A = SHA1_IV[0] | 0;\n        this.B = SHA1_IV[1] | 0;\n        this.C = SHA1_IV[2] | 0;\n        this.D = SHA1_IV[3] | 0;\n        this.E = SHA1_IV[4] | 0;\n    }\n    get() {\n        const { A, B, C, D, E } = this;\n        return [\n            A,\n            B,\n            C,\n            D,\n            E\n        ];\n    }\n    set(A, B, C, D, E) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n    }\n    process(view, offset) {\n        for(let i = 0; i < 16; i++, offset += 4)SHA1_W[i] = view.getUint32(offset, false);\n        for(let i = 16; i < 80; i++)SHA1_W[i] = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotl)(SHA1_W[i - 3] ^ SHA1_W[i - 8] ^ SHA1_W[i - 14] ^ SHA1_W[i - 16], 1);\n        // Compression function main loop, 80 rounds\n        let { A, B, C, D, E } = this;\n        for(let i = 0; i < 80; i++){\n            let F, K;\n            if (i < 20) {\n                F = (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Chi)(B, C, D);\n                K = 0x5a827999;\n            } else if (i < 40) {\n                F = B ^ C ^ D;\n                K = 0x6ed9eba1;\n            } else if (i < 60) {\n                F = (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Maj)(B, C, D);\n                K = 0x8f1bbcdc;\n            } else {\n                F = B ^ C ^ D;\n                K = 0xca62c1d6;\n            }\n            const T = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotl)(A, 5) + F + E + K + SHA1_W[i] | 0;\n            E = D;\n            D = C;\n            C = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotl)(B, 30);\n            B = A;\n            A = T;\n        }\n        // Add the compressed chunk to the current hash value\n        A = A + this.A | 0;\n        B = B + this.B | 0;\n        C = C + this.C | 0;\n        D = D + this.D | 0;\n        E = E + this.E | 0;\n        this.set(A, B, C, D, E);\n    }\n    roundClean() {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(SHA1_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(this.buffer);\n    }\n}\n/** SHA1 (RFC 3174) legacy hash function. It was cryptographically broken. */ const sha1 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(()=>new SHA1());\n/** Per-round constants */ const p32 = /* @__PURE__ */ Math.pow(2, 32);\nconst K = /* @__PURE__ */ Array.from({\n    length: 64\n}, (_, i)=>Math.floor(p32 * Math.abs(Math.sin(i + 1))));\n/** md5 initial state: same as sha1, but 4 u32 instead of 5. */ const MD5_IV = /* @__PURE__ */ SHA1_IV.slice(0, 4);\n// Reusable temporary buffer\nconst MD5_W = /* @__PURE__ */ new Uint32Array(16);\n/** MD5 legacy hash class. */ class MD5 extends _md_js__WEBPACK_IMPORTED_MODULE_0__.HashMD {\n    constructor(){\n        super(64, 16, 8, true);\n        this.A = MD5_IV[0] | 0;\n        this.B = MD5_IV[1] | 0;\n        this.C = MD5_IV[2] | 0;\n        this.D = MD5_IV[3] | 0;\n    }\n    get() {\n        const { A, B, C, D } = this;\n        return [\n            A,\n            B,\n            C,\n            D\n        ];\n    }\n    set(A, B, C, D) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n    }\n    process(view, offset) {\n        for(let i = 0; i < 16; i++, offset += 4)MD5_W[i] = view.getUint32(offset, true);\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D } = this;\n        for(let i = 0; i < 64; i++){\n            let F, g, s;\n            if (i < 16) {\n                F = (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Chi)(B, C, D);\n                g = i;\n                s = [\n                    7,\n                    12,\n                    17,\n                    22\n                ];\n            } else if (i < 32) {\n                F = (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Chi)(D, B, C);\n                g = (5 * i + 1) % 16;\n                s = [\n                    5,\n                    9,\n                    14,\n                    20\n                ];\n            } else if (i < 48) {\n                F = B ^ C ^ D;\n                g = (3 * i + 5) % 16;\n                s = [\n                    4,\n                    11,\n                    16,\n                    23\n                ];\n            } else {\n                F = C ^ (B | ~D);\n                g = 7 * i % 16;\n                s = [\n                    6,\n                    10,\n                    15,\n                    21\n                ];\n            }\n            F = F + A + K[i] + MD5_W[g];\n            A = D;\n            D = C;\n            C = B;\n            B = B + (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotl)(F, s[i % 4]);\n        }\n        // Add the compressed chunk to the current hash value\n        A = A + this.A | 0;\n        B = B + this.B | 0;\n        C = C + this.C | 0;\n        D = D + this.D | 0;\n        this.set(A, B, C, D);\n    }\n    roundClean() {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(MD5_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(this.buffer);\n    }\n}\n/**\n * MD5 (RFC 1321) legacy hash function. It was cryptographically broken.\n * MD5 architecture is similar to SHA1, with some differences:\n * - Reduced output length: 16 bytes (128 bit) instead of 20\n * - 64 rounds, instead of 80\n * - Little-endian: could be faster, but will require more code\n * - Non-linear index selection: huge speed-up for unroll\n * - Per round constants: more memory accesses, additional speed-up for unroll\n */ const md5 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(()=>new MD5());\n// RIPEMD-160\nconst Rho160 = /* @__PURE__ */ Uint8Array.from([\n    7,\n    4,\n    13,\n    1,\n    10,\n    6,\n    15,\n    3,\n    12,\n    0,\n    9,\n    5,\n    2,\n    14,\n    11,\n    8\n]);\nconst Id160 = /* @__PURE__ */ (()=>Uint8Array.from(new Array(16).fill(0).map((_, i)=>i)))();\nconst Pi160 = /* @__PURE__ */ (()=>Id160.map((i)=>(9 * i + 5) % 16))();\nconst idxLR = /* @__PURE__ */ (()=>{\n    const L = [\n        Id160\n    ];\n    const R = [\n        Pi160\n    ];\n    const res = [\n        L,\n        R\n    ];\n    for(let i = 0; i < 4; i++)for (let j of res)j.push(j[i].map((k)=>Rho160[k]));\n    return res;\n})();\nconst idxL = /* @__PURE__ */ (()=>idxLR[0])();\nconst idxR = /* @__PURE__ */ (()=>idxLR[1])();\n// const [idxL, idxR] = idxLR;\nconst shifts160 = /* @__PURE__ */ [\n    [\n        11,\n        14,\n        15,\n        12,\n        5,\n        8,\n        7,\n        9,\n        11,\n        13,\n        14,\n        15,\n        6,\n        7,\n        9,\n        8\n    ],\n    [\n        12,\n        13,\n        11,\n        15,\n        6,\n        9,\n        9,\n        7,\n        12,\n        15,\n        11,\n        13,\n        7,\n        8,\n        7,\n        7\n    ],\n    [\n        13,\n        15,\n        14,\n        11,\n        7,\n        7,\n        6,\n        8,\n        13,\n        14,\n        13,\n        12,\n        5,\n        5,\n        6,\n        9\n    ],\n    [\n        14,\n        11,\n        12,\n        14,\n        8,\n        6,\n        5,\n        5,\n        15,\n        12,\n        15,\n        14,\n        9,\n        9,\n        8,\n        6\n    ],\n    [\n        15,\n        12,\n        13,\n        13,\n        9,\n        5,\n        8,\n        6,\n        14,\n        11,\n        12,\n        11,\n        8,\n        6,\n        5,\n        5\n    ]\n].map((i)=>Uint8Array.from(i));\nconst shiftsL160 = /* @__PURE__ */ idxL.map((idx, i)=>idx.map((j)=>shifts160[i][j]));\nconst shiftsR160 = /* @__PURE__ */ idxR.map((idx, i)=>idx.map((j)=>shifts160[i][j]));\nconst Kl160 = /* @__PURE__ */ Uint32Array.from([\n    0x00000000,\n    0x5a827999,\n    0x6ed9eba1,\n    0x8f1bbcdc,\n    0xa953fd4e\n]);\nconst Kr160 = /* @__PURE__ */ Uint32Array.from([\n    0x50a28be6,\n    0x5c4dd124,\n    0x6d703ef3,\n    0x7a6d76e9,\n    0x00000000\n]);\n// It's called f() in spec.\nfunction ripemd_f(group, x, y, z) {\n    if (group === 0) return x ^ y ^ z;\n    if (group === 1) return x & y | ~x & z;\n    if (group === 2) return (x | ~y) ^ z;\n    if (group === 3) return x & z | y & ~z;\n    return x ^ (y | ~z);\n}\n// Reusable temporary buffer\nconst BUF_160 = /* @__PURE__ */ new Uint32Array(16);\nclass RIPEMD160 extends _md_js__WEBPACK_IMPORTED_MODULE_0__.HashMD {\n    constructor(){\n        super(64, 20, 8, true);\n        this.h0 = 0x67452301 | 0;\n        this.h1 = 0xefcdab89 | 0;\n        this.h2 = 0x98badcfe | 0;\n        this.h3 = 0x10325476 | 0;\n        this.h4 = 0xc3d2e1f0 | 0;\n    }\n    get() {\n        const { h0, h1, h2, h3, h4 } = this;\n        return [\n            h0,\n            h1,\n            h2,\n            h3,\n            h4\n        ];\n    }\n    set(h0, h1, h2, h3, h4) {\n        this.h0 = h0 | 0;\n        this.h1 = h1 | 0;\n        this.h2 = h2 | 0;\n        this.h3 = h3 | 0;\n        this.h4 = h4 | 0;\n    }\n    process(view, offset) {\n        for(let i = 0; i < 16; i++, offset += 4)BUF_160[i] = view.getUint32(offset, true);\n        // prettier-ignore\n        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;\n        // Instead of iterating 0 to 80, we split it into 5 groups\n        // And use the groups in constants, functions, etc. Much simpler\n        for(let group = 0; group < 5; group++){\n            const rGroup = 4 - group;\n            const hbl = Kl160[group], hbr = Kr160[group]; // prettier-ignore\n            const rl = idxL[group], rr = idxR[group]; // prettier-ignore\n            const sl = shiftsL160[group], sr = shiftsR160[group]; // prettier-ignore\n            for(let i = 0; i < 16; i++){\n                const tl = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotl)(al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i]] + hbl, sl[i]) + el | 0;\n                al = el, el = dl, dl = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotl)(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore\n            }\n            // 2 loops are 10% faster\n            for(let i = 0; i < 16; i++){\n                const tr = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotl)(ar + ripemd_f(rGroup, br, cr, dr) + BUF_160[rr[i]] + hbr, sr[i]) + er | 0;\n                ar = er, er = dr, dr = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotl)(cr, 10) | 0, cr = br, br = tr; // prettier-ignore\n            }\n        }\n        // Add the compressed chunk to the current hash value\n        this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);\n    }\n    roundClean() {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(BUF_160);\n    }\n    destroy() {\n        this.destroyed = true;\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(this.buffer);\n        this.set(0, 0, 0, 0, 0);\n    }\n}\n/**\n * RIPEMD-160 - a legacy hash function from 1990s.\n * * https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n * * https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\n */ const ripemd160 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(()=>new RIPEMD160()); //# sourceMappingURL=legacy.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2xlZ2FjeS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Q0FTQyxHQUMyQztBQUNXO0FBQ3ZELHVCQUF1QixHQUN2QixNQUFNTSxVQUFVLGFBQWEsR0FBR0MsWUFBWUMsSUFBSSxDQUFDO0lBQzdDO0lBQVk7SUFBWTtJQUFZO0lBQVk7Q0FDbkQ7QUFDRCw0QkFBNEI7QUFDNUIsTUFBTUMsU0FBUyxhQUFhLEdBQUcsSUFBSUYsWUFBWTtBQUMvQyw0QkFBNEIsR0FDckIsTUFBTUcsYUFBYVQsMENBQU1BO0lBQzVCVSxhQUFjO1FBQ1YsS0FBSyxDQUFDLElBQUksSUFBSSxHQUFHO1FBQ2pCLElBQUksQ0FBQ0MsQ0FBQyxHQUFHTixPQUFPLENBQUMsRUFBRSxHQUFHO1FBQ3RCLElBQUksQ0FBQ08sQ0FBQyxHQUFHUCxPQUFPLENBQUMsRUFBRSxHQUFHO1FBQ3RCLElBQUksQ0FBQ1EsQ0FBQyxHQUFHUixPQUFPLENBQUMsRUFBRSxHQUFHO1FBQ3RCLElBQUksQ0FBQ1MsQ0FBQyxHQUFHVCxPQUFPLENBQUMsRUFBRSxHQUFHO1FBQ3RCLElBQUksQ0FBQ1UsQ0FBQyxHQUFHVixPQUFPLENBQUMsRUFBRSxHQUFHO0lBQzFCO0lBQ0FXLE1BQU07UUFDRixNQUFNLEVBQUVMLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFLEdBQUcsSUFBSTtRQUM5QixPQUFPO1lBQUNKO1lBQUdDO1lBQUdDO1lBQUdDO1lBQUdDO1NBQUU7SUFDMUI7SUFDQUUsSUFBSU4sQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUU7UUFDZixJQUFJLENBQUNKLENBQUMsR0FBR0EsSUFBSTtRQUNiLElBQUksQ0FBQ0MsQ0FBQyxHQUFHQSxJQUFJO1FBQ2IsSUFBSSxDQUFDQyxDQUFDLEdB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Q2pCLElBQUksQ0FBQ1gsR0FBRyxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUc7SUFDekI7QUFDSjtBQUNBOzs7O0NBSUMsR0FDTSxNQUFNa0YsWUFBWSxhQUFhLEdBQUdoRyx1REFBWUEsQ0FBQyxJQUFNLElBQUlzRSxhQUFhLENBQzdFLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsYXctd29ya3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2xlZ2FjeS5qcz9iODc3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuXG5TSEExIChSRkMgMzE3NCksIE1ENSAoUkZDIDEzMjEpIGFuZCBSSVBFTUQxNjAgKFJGQyAyMjg2KSBsZWdhY3ksIHdlYWsgaGFzaCBmdW5jdGlvbnMuXG5Eb24ndCB1c2UgdGhlbSBpbiBhIG5ldyBwcm90b2NvbC4gV2hhdCBcIndlYWtcIiBtZWFuczpcblxuLSBDb2xsaXNpb25zIGNhbiBiZSBtYWRlIHdpdGggMl4xOCBlZmZvcnQgaW4gTUQ1LCAyXjYwIGluIFNIQTEsIDJeODAgaW4gUklQRU1EMTYwLlxuLSBObyBwcmFjdGljYWwgcHJlLWltYWdlIGF0dGFja3MgKG9ubHkgdGhlb3JldGljYWwsIDJeMTIzLjQpXG4tIEhNQUMgc2VlbXMga2luZGEgb2s6IGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNjE1MVxuICogQG1vZHVsZVxuICovXG5pbXBvcnQgeyBDaGksIEhhc2hNRCwgTWFqIH0gZnJvbSBcIi4vX21kLmpzXCI7XG5pbXBvcnQgeyBjbGVhbiwgY3JlYXRlSGFzaGVyLCByb3RsIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbi8qKiBJbml0aWFsIFNIQTEgc3RhdGUgKi9cbmNvbnN0IFNIQTFfSVYgPSAvKiBAX19QVVJFX18gKi8gVWludDMyQXJyYXkuZnJvbShbXG4gICAgMHg2NzQ1MjMwMSwgMHhlZmNkYWI4OSwgMHg5OGJhZGNmZSwgMHgxMDMyNTQ3NiwgMHhjM2QyZTFmMCxcbl0pO1xuLy8gUmV1c2FibGUgdGVtcG9yYXJ5IGJ1ZmZlclxuY29uc3QgU0hBMV9XID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheSg4MCk7XG4vKiogU0hBMSBsZWdhY3kgaGFzaCBjbGFzcy4gKi9cbmV4cG9ydCBjbGFzcyBTSEExIGV4dGVuZHMgSGFzaE1EIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoNjQsIDIwLCA4LCBmYWxzZSk7XG4gICAgICAgIHRoaXMuQSA9IFNIQTFfSVZbMF0gfCAwO1xuICAgICAgICB0aGlzLkIgPSBTSEExX0lWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5DID0gU0hBMV9JVlsyXSB8IDA7XG4gICAgICAgIHRoaXMuRCA9IFNIQTFfSVZbM10gfCAwO1xuICAgICAgICB0aGlzLkUgPSBTSEExX0lWWzRdIHwgMDtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEEsIEIsIEMsIEQsIEUgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbQSwgQiwgQywgRCwgRV07XG4gICAgfVxuICAgIHNldChBLCBCLCBDLCBELCBFKSB7XG4gICAgICAgIHRoaXMuQSA9IEEgfCAwO1xuICAgICAgICB0aGlzLkIgPSBCIHwgMDtcbiAgICAgICAgdGhpcy5DID0gQyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IEQgfCAwO1xuICAgICAgICB0aGlzLkUgPSBFIHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNClcbiAgICAgICAgICAgIFNIQTFfV1tpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCwgZmFsc2UpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA4MDsgaSsrKVxuICAgICAgICAgICAgU0hBMV9XW2ldID0gcm90bChTSEExX1dbaSAtIDNdIF4gU0hBMV9XW2kgLSA4XSBeIFNIQTFfV1tpIC0gMTRdIF4gU0hBMV9XW2kgLSAxNl0sIDEpO1xuICAgICAgICAvLyBDb21wcmVzc2lvbiBmdW5jdGlvbiBtYWluIGxvb3AsIDgwIHJvdW5kc1xuICAgICAgICBsZXQgeyBBLCBCLCBDLCBELCBFIH0gPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDgwOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBGLCBLO1xuICAgICAgICAgICAgaWYgKGkgPCAyMCkge1xuICAgICAgICAgICAgICAgIEYgPSBDaGkoQiwgQywgRCk7XG4gICAgICAgICAgICAgICAgSyA9IDB4NWE4Mjc5OTk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpIDwgNDApIHtcbiAgICAgICAgICAgICAgICBGID0gQiBeIEMgXiBEO1xuICAgICAgICAgICAgICAgIEsgPSAweDZlZDllYmExO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaSA8IDYwKSB7XG4gICAgICAgICAgICAgICAgRiA9IE1haihCLCBDLCBEKTtcbiAgICAgICAgICAgICAgICBLID0gMHg4ZjFiYmNkYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIEYgPSBCIF4gQyBeIEQ7XG4gICAgICAgICAgICAgICAgSyA9IDB4Y2E2MmMxZDY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBUID0gKHJvdGwoQSwgNSkgKyBGICsgRSArIEsgKyBTSEExX1dbaV0pIHwgMDtcbiAgICAgICAgICAgIEUgPSBEO1xuICAgICAgICAgICAgRCA9IEM7XG4gICAgICAgICAgICBDID0gcm90bChCLCAzMCk7XG4gICAgICAgICAgICBCID0gQTtcbiAgICAgICAgICAgIEEgPSBUO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgY29tcHJlc3NlZCBjaHVuayB0byB0aGUgY3VycmVudCBoYXNoIHZhbHVlXG4gICAgICAgIEEgPSAoQSArIHRoaXMuQSkgfCAwO1xuICAgICAgICBCID0gKEIgKyB0aGlzLkIpIHwgMDtcbiAgICAgICAgQyA9IChDICsgdGhpcy5DKSB8IDA7XG4gICAgICAgIEQgPSAoRCArIHRoaXMuRCkgfCAwO1xuICAgICAgICBFID0gKEUgKyB0aGlzLkUpIHwgMDtcbiAgICAgICAgdGhpcy5zZXQoQSwgQiwgQywgRCwgRSk7XG4gICAgfVxuICAgIHJvdW5kQ2xlYW4oKSB7XG4gICAgICAgIGNsZWFuKFNIQTFfVyk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDApO1xuICAgICAgICBjbGVhbih0aGlzLmJ1ZmZlcik7XG4gICAgfVxufVxuLyoqIFNIQTEgKFJGQyAzMTc0KSBsZWdhY3kgaGFzaCBmdW5jdGlvbi4gSXQgd2FzIGNyeXB0b2dyYXBoaWNhbGx5IGJyb2tlbi4gKi9cbmV4cG9ydCBjb25zdCBzaGExID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUhhc2hlcigoKSA9PiBuZXcgU0hBMSgpKTtcbi8qKiBQZXItcm91bmQgY29uc3RhbnRzICovXG5jb25zdCBwMzIgPSAvKiBAX19QVVJFX18gKi8gTWF0aC5wb3coMiwgMzIpO1xuY29uc3QgSyA9IC8qIEBfX1BVUkVfXyAqLyBBcnJheS5mcm9tKHsgbGVuZ3RoOiA2NCB9LCAoXywgaSkgPT4gTWF0aC5mbG9vcihwMzIgKiBNYXRoLmFicyhNYXRoLnNpbihpICsgMSkpKSk7XG4vKiogbWQ1IGluaXRpYWwgc3RhdGU6IHNhbWUgYXMgc2hhMSwgYnV0IDQgdTMyIGluc3RlYWQgb2YgNS4gKi9cbmNvbnN0IE1ENV9JViA9IC8qIEBfX1BVUkVfXyAqLyBTSEExX0lWLnNsaWNlKDAsIDQpO1xuLy8gUmV1c2FibGUgdGVtcG9yYXJ5IGJ1ZmZlclxuY29uc3QgTUQ1X1cgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDE2KTtcbi8qKiBNRDUgbGVnYWN5IGhhc2ggY2xhc3MuICovXG5leHBvcnQgY2xhc3MgTUQ1IGV4dGVuZHMgSGFzaE1EIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoNjQsIDE2LCA4LCB0cnVlKTtcbiAgICAgICAgdGhpcy5BID0gTUQ1X0lWWzBdIHwgMDtcbiAgICAgICAgdGhpcy5CID0gTUQ1X0lWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5DID0gTUQ1X0lWWzJdIHwgMDtcbiAgICAgICAgdGhpcy5EID0gTUQ1X0lWWzNdIHwgMDtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEEsIEIsIEMsIEQgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbQSwgQiwgQywgRF07XG4gICAgfVxuICAgIHNldChBLCBCLCBDLCBEKSB7XG4gICAgICAgIHRoaXMuQSA9IEEgfCAwO1xuICAgICAgICB0aGlzLkIgPSBCIHwgMDtcbiAgICAgICAgdGhpcy5DID0gQyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IEQgfCAwO1xuICAgIH1cbiAgICBwcm9jZXNzKHZpZXcsIG9mZnNldCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyssIG9mZnNldCArPSA0KVxuICAgICAgICAgICAgTUQ1X1dbaV0gPSB2aWV3LmdldFVpbnQzMihvZmZzZXQsIHRydWUpO1xuICAgICAgICAvLyBDb21wcmVzc2lvbiBmdW5jdGlvbiBtYWluIGxvb3AsIDY0IHJvdW5kc1xuICAgICAgICBsZXQgeyBBLCBCLCBDLCBEIH0gPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBGLCBnLCBzO1xuICAgICAgICAgICAgaWYgKGkgPCAxNikge1xuICAgICAgICAgICAgICAgIEYgPSBDaGkoQiwgQywgRCk7XG4gICAgICAgICAgICAgICAgZyA9IGk7XG4gICAgICAgICAgICAgICAgcyA9IFs3LCAxMiwgMTcsIDIyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGkgPCAzMikge1xuICAgICAgICAgICAgICAgIEYgPSBDaGkoRCwgQiwgQyk7XG4gICAgICAgICAgICAgICAgZyA9ICg1ICogaSArIDEpICUgMTY7XG4gICAgICAgICAgICAgICAgcyA9IFs1LCA5LCAxNCwgMjBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaSA8IDQ4KSB7XG4gICAgICAgICAgICAgICAgRiA9IEIgXiBDIF4gRDtcbiAgICAgICAgICAgICAgICBnID0gKDMgKiBpICsgNSkgJSAxNjtcbiAgICAgICAgICAgICAgICBzID0gWzQsIDExLCAxNiwgMjNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgRiA9IEMgXiAoQiB8IH5EKTtcbiAgICAgICAgICAgICAgICBnID0gKDcgKiBpKSAlIDE2O1xuICAgICAgICAgICAgICAgIHMgPSBbNiwgMTAsIDE1LCAyMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBGID0gRiArIEEgKyBLW2ldICsgTUQ1X1dbZ107XG4gICAgICAgICAgICBBID0gRDtcbiAgICAgICAgICAgIEQgPSBDO1xuICAgICAgICAgICAgQyA9IEI7XG4gICAgICAgICAgICBCID0gQiArIHJvdGwoRiwgc1tpICUgNF0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgY29tcHJlc3NlZCBjaHVuayB0byB0aGUgY3VycmVudCBoYXNoIHZhbHVlXG4gICAgICAgIEEgPSAoQSArIHRoaXMuQSkgfCAwO1xuICAgICAgICBCID0gKEIgKyB0aGlzLkIpIHwgMDtcbiAgICAgICAgQyA9IChDICsgdGhpcy5DKSB8IDA7XG4gICAgICAgIEQgPSAoRCArIHRoaXMuRCkgfCAwO1xuICAgICAgICB0aGlzLnNldChBLCBCLCBDLCBEKTtcbiAgICB9XG4gICAgcm91bmRDbGVhbigpIHtcbiAgICAgICAgY2xlYW4oTUQ1X1cpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwKTtcbiAgICAgICAgY2xlYW4odGhpcy5idWZmZXIpO1xuICAgIH1cbn1cbi8qKlxuICogTUQ1IChSRkMgMTMyMSkgbGVnYWN5IGhhc2ggZnVuY3Rpb24uIEl0IHdhcyBjcnlwdG9ncmFwaGljYWxseSBicm9rZW4uXG4gKiBNRDUgYXJjaGl0ZWN0dXJlIGlzIHNpbWlsYXIgdG8gU0hBMSwgd2l0aCBzb21lIGRpZmZlcmVuY2VzOlxuICogLSBSZWR1Y2VkIG91dHB1dCBsZW5ndGg6IDE2IGJ5dGVzICgxMjggYml0KSBpbnN0ZWFkIG9mIDIwXG4gKiAtIDY0IHJvdW5kcywgaW5zdGVhZCBvZiA4MFxuICogLSBMaXR0bGUtZW5kaWFuOiBjb3VsZCBiZSBmYXN0ZXIsIGJ1dCB3aWxsIHJlcXVpcmUgbW9yZSBjb2RlXG4gKiAtIE5vbi1saW5lYXIgaW5kZXggc2VsZWN0aW9uOiBodWdlIHNwZWVkLXVwIGZvciB1bnJvbGxcbiAqIC0gUGVyIHJvdW5kIGNvbnN0YW50czogbW9yZSBtZW1vcnkgYWNjZXNzZXMsIGFkZGl0aW9uYWwgc3BlZWQtdXAgZm9yIHVucm9sbFxuICovXG5leHBvcnQgY29uc3QgbWQ1ID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUhhc2hlcigoKSA9PiBuZXcgTUQ1KCkpO1xuLy8gUklQRU1ELTE2MFxuY29uc3QgUmhvMTYwID0gLyogQF9fUFVSRV9fICovIFVpbnQ4QXJyYXkuZnJvbShbXG4gICAgNywgNCwgMTMsIDEsIDEwLCA2LCAxNSwgMywgMTIsIDAsIDksIDUsIDIsIDE0LCAxMSwgOCxcbl0pO1xuY29uc3QgSWQxNjAgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IFVpbnQ4QXJyYXkuZnJvbShuZXcgQXJyYXkoMTYpLmZpbGwoMCkubWFwKChfLCBpKSA9PiBpKSkpKCk7XG5jb25zdCBQaTE2MCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gSWQxNjAubWFwKChpKSA9PiAoOSAqIGkgKyA1KSAlIDE2KSkoKTtcbmNvbnN0IGlkeExSID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB7XG4gICAgY29uc3QgTCA9IFtJZDE2MF07XG4gICAgY29uc3QgUiA9IFtQaTE2MF07XG4gICAgY29uc3QgcmVzID0gW0wsIFJdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKVxuICAgICAgICBmb3IgKGxldCBqIG9mIHJlcylcbiAgICAgICAgICAgIGoucHVzaChqW2ldLm1hcCgoaykgPT4gUmhvMTYwW2tdKSk7XG4gICAgcmV0dXJuIHJlcztcbn0pKCk7XG5jb25zdCBpZHhMID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBpZHhMUlswXSkoKTtcbmNvbnN0IGlkeFIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGlkeExSWzFdKSgpO1xuLy8gY29uc3QgW2lkeEwsIGlkeFJdID0gaWR4TFI7XG5jb25zdCBzaGlmdHMxNjAgPSAvKiBAX19QVVJFX18gKi8gW1xuICAgIFsxMSwgMTQsIDE1LCAxMiwgNSwgOCwgNywgOSwgMTEsIDEzLCAxNCwgMTUsIDYsIDcsIDksIDhdLFxuICAgIFsxMiwgMTMsIDExLCAxNSwgNiwgOSwgOSwgNywgMTIsIDE1LCAxMSwgMTMsIDcsIDgsIDcsIDddLFxuICAgIFsxMywgMTUsIDE0LCAxMSwgNywgNywgNiwgOCwgMTMsIDE0LCAxMywgMTIsIDUsIDUsIDYsIDldLFxuICAgIFsxNCwgMTEsIDEyLCAxNCwgOCwgNiwgNSwgNSwgMTUsIDEyLCAxNSwgMTQsIDksIDksIDgsIDZdLFxuICAgIFsxNSwgMTIsIDEzLCAxMywgOSwgNSwgOCwgNiwgMTQsIDExLCAxMiwgMTEsIDgsIDYsIDUsIDVdLFxuXS5tYXAoKGkpID0+IFVpbnQ4QXJyYXkuZnJvbShpKSk7XG5jb25zdCBzaGlmdHNMMTYwID0gLyogQF9fUFVSRV9fICovIGlkeEwubWFwKChpZHgsIGkpID0+IGlkeC5tYXAoKGopID0+IHNoaWZ0czE2MFtpXVtqXSkpO1xuY29uc3Qgc2hpZnRzUjE2MCA9IC8qIEBfX1BVUkVfXyAqLyBpZHhSLm1hcCgoaWR4LCBpKSA9PiBpZHgubWFwKChqKSA9PiBzaGlmdHMxNjBbaV1bal0pKTtcbmNvbnN0IEtsMTYwID0gLyogQF9fUFVSRV9fICovIFVpbnQzMkFycmF5LmZyb20oW1xuICAgIDB4MDAwMDAwMDAsIDB4NWE4Mjc5OTksIDB4NmVkOWViYTEsIDB4OGYxYmJjZGMsIDB4YTk1M2ZkNGUsXG5dKTtcbmNvbnN0IEtyMTYwID0gLyogQF9fUFVSRV9fICovIFVpbnQzMkFycmF5LmZyb20oW1xuICAgIDB4NTBhMjhiZTYsIDB4NWM0ZGQxMjQsIDB4NmQ3MDNlZjMsIDB4N2E2ZDc2ZTksIDB4MDAwMDAwMDAsXG5dKTtcbi8vIEl0J3MgY2FsbGVkIGYoKSBpbiBzcGVjLlxuZnVuY3Rpb24gcmlwZW1kX2YoZ3JvdXAsIHgsIHksIHopIHtcbiAgICBpZiAoZ3JvdXAgPT09IDApXG4gICAgICAgIHJldHVybiB4IF4geSBeIHo7XG4gICAgaWYgKGdyb3VwID09PSAxKVxuICAgICAgICByZXR1cm4gKHggJiB5KSB8ICh+eCAmIHopO1xuICAgIGlmIChncm91cCA9PT0gMilcbiAgICAgICAgcmV0dXJuICh4IHwgfnkpIF4gejtcbiAgICBpZiAoZ3JvdXAgPT09IDMpXG4gICAgICAgIHJldHVybiAoeCAmIHopIHwgKHkgJiB+eik7XG4gICAgcmV0dXJuIHggXiAoeSB8IH56KTtcbn1cbi8vIFJldXNhYmxlIHRlbXBvcmFyeSBidWZmZXJcbmNvbnN0IEJVRl8xNjAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDE2KTtcbmV4cG9ydCBjbGFzcyBSSVBFTUQxNjAgZXh0ZW5kcyBIYXNoTUQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcig2NCwgMjAsIDgsIHRydWUpO1xuICAgICAgICB0aGlzLmgwID0gMHg2NzQ1MjMwMSB8IDA7XG4gICAgICAgIHRoaXMuaDEgPSAweGVmY2RhYjg5IHwgMDtcbiAgICAgICAgdGhpcy5oMiA9IDB4OThiYWRjZmUgfCAwO1xuICAgICAgICB0aGlzLmgzID0gMHgxMDMyNTQ3NiB8IDA7XG4gICAgICAgIHRoaXMuaDQgPSAweGMzZDJlMWYwIHwgMDtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IGgwLCBoMSwgaDIsIGgzLCBoNCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFtoMCwgaDEsIGgyLCBoMywgaDRdO1xuICAgIH1cbiAgICBzZXQoaDAsIGgxLCBoMiwgaDMsIGg0KSB7XG4gICAgICAgIHRoaXMuaDAgPSBoMCB8IDA7XG4gICAgICAgIHRoaXMuaDEgPSBoMSB8IDA7XG4gICAgICAgIHRoaXMuaDIgPSBoMiB8IDA7XG4gICAgICAgIHRoaXMuaDMgPSBoMyB8IDA7XG4gICAgICAgIHRoaXMuaDQgPSBoNCB8IDA7XG4gICAgfVxuICAgIHByb2Nlc3Modmlldywgb2Zmc2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpXG4gICAgICAgICAgICBCVUZfMTYwW2ldID0gdmlldy5nZXRVaW50MzIob2Zmc2V0LCB0cnVlKTtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGxldCBhbCA9IHRoaXMuaDAgfCAwLCBhciA9IGFsLCBibCA9IHRoaXMuaDEgfCAwLCBiciA9IGJsLCBjbCA9IHRoaXMuaDIgfCAwLCBjciA9IGNsLCBkbCA9IHRoaXMuaDMgfCAwLCBkciA9IGRsLCBlbCA9IHRoaXMuaDQgfCAwLCBlciA9IGVsO1xuICAgICAgICAvLyBJbnN0ZWFkIG9mIGl0ZXJhdGluZyAwIHRvIDgwLCB3ZSBzcGxpdCBpdCBpbnRvIDUgZ3JvdXBzXG4gICAgICAgIC8vIEFuZCB1c2UgdGhlIGdyb3VwcyBpbiBjb25zdGFudHMsIGZ1bmN0aW9ucywgZXRjLiBNdWNoIHNpbXBsZXJcbiAgICAgICAgZm9yIChsZXQgZ3JvdXAgPSAwOyBncm91cCA8IDU7IGdyb3VwKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHJHcm91cCA9IDQgLSBncm91cDtcbiAgICAgICAgICAgIGNvbnN0IGhibCA9IEtsMTYwW2dyb3VwXSwgaGJyID0gS3IxNjBbZ3JvdXBdOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IHJsID0gaWR4TFtncm91cF0sIHJyID0gaWR4Ultncm91cF07IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgY29uc3Qgc2wgPSBzaGlmdHNMMTYwW2dyb3VwXSwgc3IgPSBzaGlmdHNSMTYwW2dyb3VwXTsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0bCA9IChyb3RsKGFsICsgcmlwZW1kX2YoZ3JvdXAsIGJsLCBjbCwgZGwpICsgQlVGXzE2MFtybFtpXV0gKyBoYmwsIHNsW2ldKSArIGVsKSB8IDA7XG4gICAgICAgICAgICAgICAgYWwgPSBlbCwgZWwgPSBkbCwgZGwgPSByb3RsKGNsLCAxMCkgfCAwLCBjbCA9IGJsLCBibCA9IHRsOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIDIgbG9vcHMgYXJlIDEwJSBmYXN0ZXJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyID0gKHJvdGwoYXIgKyByaXBlbWRfZihyR3JvdXAsIGJyLCBjciwgZHIpICsgQlVGXzE2MFtycltpXV0gKyBoYnIsIHNyW2ldKSArIGVyKSB8IDA7XG4gICAgICAgICAgICAgICAgYXIgPSBlciwgZXIgPSBkciwgZHIgPSByb3RsKGNyLCAxMCkgfCAwLCBjciA9IGJyLCBiciA9IHRyOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICB0aGlzLnNldCgodGhpcy5oMSArIGNsICsgZHIpIHwgMCwgKHRoaXMuaDIgKyBkbCArIGVyKSB8IDAsICh0aGlzLmgzICsgZWwgKyBhcikgfCAwLCAodGhpcy5oNCArIGFsICsgYnIpIHwgMCwgKHRoaXMuaDAgKyBibCArIGNyKSB8IDApO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICBjbGVhbihCVUZfMTYwKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICBjbGVhbih0aGlzLmJ1ZmZlcik7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDApO1xuICAgIH1cbn1cbi8qKlxuICogUklQRU1ELTE2MCAtIGEgbGVnYWN5IGhhc2ggZnVuY3Rpb24gZnJvbSAxOTkwcy5cbiAqICogaHR0cHM6Ly9ob21lcy5lc2F0Lmt1bGV1dmVuLmJlL35ib3NzZWxhZS9yaXBlbWQxNjAuaHRtbFxuICogKiBodHRwczovL2hvbWVzLmVzYXQua3VsZXV2ZW4uYmUvfmJvc3NlbGFlL3JpcGVtZDE2MC9wZGYvQUItOTYwMS9BQi05NjAxLnBkZlxuICovXG5leHBvcnQgY29uc3QgcmlwZW1kMTYwID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUhhc2hlcigoKSA9PiBuZXcgUklQRU1EMTYwKCkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGVnYWN5LmpzLm1hcCJdLCJuYW1lcyI6WyJDaGkiLCJIYXNoTUQiLCJNYWoiLCJjbGVhbiIsImNyZWF0ZUhhc2hlciIsInJvdGwiLCJTSEExX0lWIiwiVWludDMyQXJyYXkiLCJmcm9tIiwiU0hBMV9XIiwiU0hBMSIsImNvbnN0cnVjdG9yIiwiQSIsIkIiLCJDIiwiRCIsIkUiLCJnZXQiLCJzZXQiLCJwcm9jZXNzIiwidmlldyIsIm9mZnNldCIsImkiLCJnZXRVaW50MzIiLCJGIiwiSyIsIlQiLCJyb3VuZENsZWFuIiwiZGVzdHJveSIsImJ1ZmZlciIsInNoYTEiLCJwMzIiLCJNYXRoIiwicG93IiwiQXJyYXkiLCJsZW5ndGgiLCJfIiwiZmxvb3IiLCJhYnMiLCJzaW4iLCJNRDVfSVYiLCJzbGljZSIsIk1ENV9XIiwiTUQ1IiwiZyIsInMiLCJtZDUiLCJSaG8xNjAiLCJVaW50OEFycmF5IiwiSWQxNjAiLCJmaWxsIiwibWFwIiwiUGkxNjAiLCJpZHhMUiIsIkwiLCJSIiwicmVzIiwiaiIsInB1c2giLCJrIiwiaWR4TCIsImlkeFIiLCJzaGlmdHMxNjAiLCJzaGlmdHNMMTYwIiwiaWR4Iiwic2hpZnRzUjE2MCIsIktsMTYwIiwiS3IxNjAiLCJyaXBlbWRfZiIsImdyb3VwIiwieCIsInkiLCJ6IiwiQlVGXzE2MCIsIlJJUEVNRDE2MCIsImgwIiwiaDEiLCJoMiIsImgzIiwiaDQiLCJhbCIsImFyIiwiYmwiLCJiciIsImNsIiwiY3IiLCJkbCIsImRyIiwiZWwiLCJlciIsInJHcm91cCIsImhibCIsImhiciIsInJsIiwicnIiLCJzbCIsInNyIiwidGwiLCJ0ciIsImRlc3Ryb3llZCIsInJpcGVtZDE2MCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/legacy.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/ripemd160.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ox/node_modules/@noble/hashes/esm/ripemd160.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RIPEMD160: () => (/* binding */ RIPEMD160),\n/* harmony export */   ripemd160: () => (/* binding */ ripemd160)\n/* harmony export */ });\n/* harmony import */ var _legacy_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./legacy.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/legacy.js\");\n/**\n * RIPEMD-160 legacy hash function.\n * https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n * https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\n * @module\n * @deprecated\n */ \n/** @deprecated Use import from `noble/hashes/legacy` module */ const RIPEMD160 = _legacy_js__WEBPACK_IMPORTED_MODULE_0__.RIPEMD160;\n/** @deprecated Use import from `noble/hashes/legacy` module */ const ripemd160 = _legacy_js__WEBPACK_IMPORTED_MODULE_0__.ripemd160; //# sourceMappingURL=ripemd160.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3JpcGVtZDE2MC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7Ozs7O0NBTUMsR0FDOEU7QUFDL0UsNkRBQTZELEdBQ3RELE1BQU1BLFlBQVlDLGlEQUFVQSxDQUFDO0FBQ3BDLDZEQUE2RCxHQUN0RCxNQUFNQyxZQUFZQyxpREFBVUEsQ0FBQyxDQUNwQyxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGF3LXdvcmtzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9yaXBlbWQxNjAuanM/ZmM0MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFJJUEVNRC0xNjAgbGVnYWN5IGhhc2ggZnVuY3Rpb24uXG4gKiBodHRwczovL2hvbWVzLmVzYXQua3VsZXV2ZW4uYmUvfmJvc3NlbGFlL3JpcGVtZDE2MC5odG1sXG4gKiBodHRwczovL2hvbWVzLmVzYXQua3VsZXV2ZW4uYmUvfmJvc3NlbGFlL3JpcGVtZDE2MC9wZGYvQUItOTYwMS9BQi05NjAxLnBkZlxuICogQG1vZHVsZVxuICogQGRlcHJlY2F0ZWRcbiAqL1xuaW1wb3J0IHsgUklQRU1EMTYwIGFzIFJJUEVNRDE2MG4sIHJpcGVtZDE2MCBhcyByaXBlbWQxNjBuIH0gZnJvbSBcIi4vbGVnYWN5LmpzXCI7XG4vKiogQGRlcHJlY2F0ZWQgVXNlIGltcG9ydCBmcm9tIGBub2JsZS9oYXNoZXMvbGVnYWN5YCBtb2R1bGUgKi9cbmV4cG9ydCBjb25zdCBSSVBFTUQxNjAgPSBSSVBFTUQxNjBuO1xuLyoqIEBkZXByZWNhdGVkIFVzZSBpbXBvcnQgZnJvbSBgbm9ibGUvaGFzaGVzL2xlZ2FjeWAgbW9kdWxlICovXG5leHBvcnQgY29uc3QgcmlwZW1kMTYwID0gcmlwZW1kMTYwbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJpcGVtZDE2MC5qcy5tYXAiXSwibmFtZXMiOlsiUklQRU1EMTYwIiwiUklQRU1EMTYwbiIsInJpcGVtZDE2MCIsInJpcGVtZDE2MG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/ripemd160.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/sha2.js":
/*!****************************************************************!*\
  !*** ./node_modules/ox/node_modules/@noble/hashes/esm/sha2.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA224: () => (/* binding */ SHA224),\n/* harmony export */   SHA256: () => (/* binding */ SHA256),\n/* harmony export */   SHA384: () => (/* binding */ SHA384),\n/* harmony export */   SHA512: () => (/* binding */ SHA512),\n/* harmony export */   SHA512_224: () => (/* binding */ SHA512_224),\n/* harmony export */   SHA512_256: () => (/* binding */ SHA512_256),\n/* harmony export */   sha224: () => (/* binding */ sha224),\n/* harmony export */   sha256: () => (/* binding */ sha256),\n/* harmony export */   sha384: () => (/* binding */ sha384),\n/* harmony export */   sha512: () => (/* binding */ sha512),\n/* harmony export */   sha512_224: () => (/* binding */ sha512_224),\n/* harmony export */   sha512_256: () => (/* binding */ sha512_256)\n/* harmony export */ });\n/* harmony import */ var _md_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_md.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/_md.js\");\n/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_u64.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/_u64.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/utils.js\");\n/**\n * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.\n * SHA256 is the fastest hash implementable in JS, even faster than Blake3.\n * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and\n * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n */ \n\n\n/**\n * Round constants:\n * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)\n */ // prettier-ignore\nconst SHA256_K = /* @__PURE__ */ Uint32Array.from([\n    0x428a2f98,\n    0x71374491,\n    0xb5c0fbcf,\n    0xe9b5dba5,\n    0x3956c25b,\n    0x59f111f1,\n    0x923f82a4,\n    0xab1c5ed5,\n    0xd807aa98,\n    0x12835b01,\n    0x243185be,\n    0x550c7dc3,\n    0x72be5d74,\n    0x80deb1fe,\n    0x9bdc06a7,\n    0xc19bf174,\n    0xe49b69c1,\n    0xefbe4786,\n    0x0fc19dc6,\n    0x240ca1cc,\n    0x2de92c6f,\n    0x4a7484aa,\n    0x5cb0a9dc,\n    0x76f988da,\n    0x983e5152,\n    0xa831c66d,\n    0xb00327c8,\n    0xbf597fc7,\n    0xc6e00bf3,\n    0xd5a79147,\n    0x06ca6351,\n    0x14292967,\n    0x27b70a85,\n    0x2e1b2138,\n    0x4d2c6dfc,\n    0x53380d13,\n    0x650a7354,\n    0x766a0abb,\n    0x81c2c92e,\n    0x92722c85,\n    0xa2bfe8a1,\n    0xa81a664b,\n    0xc24b8b70,\n    0xc76c51a3,\n    0xd192e819,\n    0xd6990624,\n    0xf40e3585,\n    0x106aa070,\n    0x19a4c116,\n    0x1e376c08,\n    0x2748774c,\n    0x34b0bcb5,\n    0x391c0cb3,\n    0x4ed8aa4a,\n    0x5b9cca4f,\n    0x682e6ff3,\n    0x748f82ee,\n    0x78a5636f,\n    0x84c87814,\n    0x8cc70208,\n    0x90befffa,\n    0xa4506ceb,\n    0xbef9a3f7,\n    0xc67178f2\n]);\n/** Reusable temporary buffer. \"W\" comes straight from spec. */ const SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _md_js__WEBPACK_IMPORTED_MODULE_0__.HashMD {\n    constructor(outputLen = 32){\n        super(64, outputLen, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[0] | 0;\n        this.B = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[1] | 0;\n        this.C = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[2] | 0;\n        this.D = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[3] | 0;\n        this.E = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[4] | 0;\n        this.F = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[5] | 0;\n        this.G = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[6] | 0;\n        this.H = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [\n            A,\n            B,\n            C,\n            D,\n            E,\n            F,\n            G,\n            H\n        ];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for(let i = 0; i < 16; i++, offset += 4)SHA256_W[i] = view.getUint32(offset, false);\n        for(let i = 16; i < 64; i++){\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ W15 >>> 3;\n            const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ W2 >>> 10;\n            SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for(let i = 0; i < 64; i++){\n            const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);\n            const T1 = H + sigma1 + (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;\n            const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);\n            const T2 = sigma0 + (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Maj)(A, B, C) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = D + T1 | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = T1 + T2 | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = A + this.A | 0;\n        B = B + this.B | 0;\n        C = C + this.C | 0;\n        D = D + this.D | 0;\n        E = E + this.E | 0;\n        F = F + this.F | 0;\n        G = G + this.G | 0;\n        H = H + this.H | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(SHA256_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(this.buffer);\n    }\n}\nclass SHA224 extends SHA256 {\n    constructor(){\n        super(28);\n        this.A = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[0] | 0;\n        this.B = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[1] | 0;\n        this.C = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[2] | 0;\n        this.D = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[3] | 0;\n        this.E = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[4] | 0;\n        this.F = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[5] | 0;\n        this.G = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[6] | 0;\n        this.H = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[7] | 0;\n    }\n}\n// SHA2-512 is slower than sha256 in js because u64 operations are slow.\n// Round contants\n// First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409\n// prettier-ignore\nconst K512 = /* @__PURE__ */ (()=>_u64_js__WEBPACK_IMPORTED_MODULE_2__.split([\n        \"0x428a2f98d728ae22\",\n        \"0x7137449123ef65cd\",\n        \"0xb5c0fbcfec4d3b2f\",\n        \"0xe9b5dba58189dbbc\",\n        \"0x3956c25bf348b538\",\n        \"0x59f111f1b605d019\",\n        \"0x923f82a4af194f9b\",\n        \"0xab1c5ed5da6d8118\",\n        \"0xd807aa98a3030242\",\n        \"0x12835b0145706fbe\",\n        \"0x243185be4ee4b28c\",\n        \"0x550c7dc3d5ffb4e2\",\n        \"0x72be5d74f27b896f\",\n        \"0x80deb1fe3b1696b1\",\n        \"0x9bdc06a725c71235\",\n        \"0xc19bf174cf692694\",\n        \"0xe49b69c19ef14ad2\",\n        \"0xefbe4786384f25e3\",\n        \"0x0fc19dc68b8cd5b5\",\n        \"0x240ca1cc77ac9c65\",\n        \"0x2de92c6f592b0275\",\n        \"0x4a7484aa6ea6e483\",\n        \"0x5cb0a9dcbd41fbd4\",\n        \"0x76f988da831153b5\",\n        \"0x983e5152ee66dfab\",\n        \"0xa831c66d2db43210\",\n        \"0xb00327c898fb213f\",\n        \"0xbf597fc7beef0ee4\",\n        \"0xc6e00bf33da88fc2\",\n        \"0xd5a79147930aa725\",\n        \"0x06ca6351e003826f\",\n        \"0x142929670a0e6e70\",\n        \"0x27b70a8546d22ffc\",\n        \"0x2e1b21385c26c926\",\n        \"0x4d2c6dfc5ac42aed\",\n        \"0x53380d139d95b3df\",\n        \"0x650a73548baf63de\",\n        \"0x766a0abb3c77b2a8\",\n        \"0x81c2c92e47edaee6\",\n        \"0x92722c851482353b\",\n        \"0xa2bfe8a14cf10364\",\n        \"0xa81a664bbc423001\",\n        \"0xc24b8b70d0f89791\",\n        \"0xc76c51a30654be30\",\n        \"0xd192e819d6ef5218\",\n        \"0xd69906245565a910\",\n        \"0xf40e35855771202a\",\n        \"0x106aa07032bbd1b8\",\n        \"0x19a4c116b8d2d0c8\",\n        \"0x1e376c085141ab53\",\n        \"0x2748774cdf8eeb99\",\n        \"0x34b0bcb5e19b48a8\",\n        \"0x391c0cb3c5c95a63\",\n        \"0x4ed8aa4ae3418acb\",\n        \"0x5b9cca4f7763e373\",\n        \"0x682e6ff3d6b2b8a3\",\n        \"0x748f82ee5defb2fc\",\n        \"0x78a5636f43172f60\",\n        \"0x84c87814a1f0ab72\",\n        \"0x8cc702081a6439ec\",\n        \"0x90befffa23631e28\",\n        \"0xa4506cebde82bde9\",\n        \"0xbef9a3f7b2c67915\",\n        \"0xc67178f2e372532b\",\n        \"0xca273eceea26619c\",\n        \"0xd186b8c721c0c207\",\n        \"0xeada7dd6cde0eb1e\",\n        \"0xf57d4f7fee6ed178\",\n        \"0x06f067aa72176fba\",\n        \"0x0a637dc5a2c898a6\",\n        \"0x113f9804bef90dae\",\n        \"0x1b710b35131c471b\",\n        \"0x28db77f523047d84\",\n        \"0x32caab7b40c72493\",\n        \"0x3c9ebe0a15c9bebc\",\n        \"0x431d67c49c100d4c\",\n        \"0x4cc5d4becb3e42b6\",\n        \"0x597f299cfc657e2a\",\n        \"0x5fcb6fab3ad6faec\",\n        \"0x6c44198c4a475817\"\n    ].map((n)=>BigInt(n))))();\nconst SHA512_Kh = /* @__PURE__ */ (()=>K512[0])();\nconst SHA512_Kl = /* @__PURE__ */ (()=>K512[1])();\n// Reusable temporary buffers\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nclass SHA512 extends _md_js__WEBPACK_IMPORTED_MODULE_0__.HashMD {\n    constructor(outputLen = 64){\n        super(128, outputLen, 16, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[0] | 0;\n        this.Al = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[1] | 0;\n        this.Bh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[2] | 0;\n        this.Bl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[3] | 0;\n        this.Ch = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[4] | 0;\n        this.Cl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[5] | 0;\n        this.Dh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[6] | 0;\n        this.Dl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[7] | 0;\n        this.Eh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[8] | 0;\n        this.El = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[9] | 0;\n        this.Fh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[10] | 0;\n        this.Fl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[11] | 0;\n        this.Gh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[12] | 0;\n        this.Gl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[13] | 0;\n        this.Hh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[14] | 0;\n        this.Hl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[15] | 0;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [\n            Ah,\n            Al,\n            Bh,\n            Bl,\n            Ch,\n            Cl,\n            Dh,\n            Dl,\n            Eh,\n            El,\n            Fh,\n            Fl,\n            Gh,\n            Gl,\n            Hh,\n            Hl\n        ];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for(let i = 0; i < 16; i++, offset += 4){\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32(offset += 4);\n        }\n        for(let i = 16; i < 80; i++){\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSH(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSH(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.shrSH(W15h, W15l, 7);\n            const s0l = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSL(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSL(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSH(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBH(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.shrSH(W2h, W2l, 6);\n            const s1l = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSL(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBL(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for(let i = 0; i < 80; i++){\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSH(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSH(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBH(Eh, El, 41);\n            const sigma1l = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSL(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSL(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = Eh & Fh ^ ~Eh & Gh;\n            const CHIl = El & Fl ^ ~El & Gl;\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSH(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBH(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBH(Ah, Al, 39);\n            const sigma0l = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSL(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBL(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBL(Ah, Al, 39);\n            const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;\n            const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add3L(T1l, sigma0l, MAJl);\n            Ah = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(SHA512_W_H, SHA512_W_L);\n    }\n    destroy() {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(this.buffer);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nclass SHA384 extends SHA512 {\n    constructor(){\n        super(48);\n        this.Ah = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[0] | 0;\n        this.Al = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[1] | 0;\n        this.Bh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[2] | 0;\n        this.Bl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[3] | 0;\n        this.Ch = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[4] | 0;\n        this.Cl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[5] | 0;\n        this.Dh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[6] | 0;\n        this.Dl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[7] | 0;\n        this.Eh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[8] | 0;\n        this.El = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[9] | 0;\n        this.Fh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[10] | 0;\n        this.Fl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[11] | 0;\n        this.Gh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[12] | 0;\n        this.Gl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[13] | 0;\n        this.Hh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[14] | 0;\n        this.Hl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[15] | 0;\n    }\n}\n/**\n * Truncated SHA512/256 and SHA512/224.\n * SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as \"intermediary\" IV of SHA512/t.\n * Then t hashes string to produce result IV.\n * See `test/misc/sha2-gen-iv.js`.\n */ /** SHA512/224 IV */ const T224_IV = /* @__PURE__ */ Uint32Array.from([\n    0x8c3d37c8,\n    0x19544da2,\n    0x73e19966,\n    0x89dcd4d6,\n    0x1dfab7ae,\n    0x32ff9c82,\n    0x679dd514,\n    0x582f9fcf,\n    0x0f6d2b69,\n    0x7bd44da8,\n    0x77e36f73,\n    0x04c48942,\n    0x3f9d85a8,\n    0x6a1d36c8,\n    0x1112e6ad,\n    0x91d692a1\n]);\n/** SHA512/256 IV */ const T256_IV = /* @__PURE__ */ Uint32Array.from([\n    0x22312194,\n    0xfc2bf72c,\n    0x9f555fa3,\n    0xc84c64c2,\n    0x2393b86b,\n    0x6f53b151,\n    0x96387719,\n    0x5940eabd,\n    0x96283ee2,\n    0xa88effe3,\n    0xbe5e1e25,\n    0x53863992,\n    0x2b0199fc,\n    0x2c85b8aa,\n    0x0eb72ddc,\n    0x81c52ca2\n]);\nclass SHA512_224 extends SHA512 {\n    constructor(){\n        super(28);\n        this.Ah = T224_IV[0] | 0;\n        this.Al = T224_IV[1] | 0;\n        this.Bh = T224_IV[2] | 0;\n        this.Bl = T224_IV[3] | 0;\n        this.Ch = T224_IV[4] | 0;\n        this.Cl = T224_IV[5] | 0;\n        this.Dh = T224_IV[6] | 0;\n        this.Dl = T224_IV[7] | 0;\n        this.Eh = T224_IV[8] | 0;\n        this.El = T224_IV[9] | 0;\n        this.Fh = T224_IV[10] | 0;\n        this.Fl = T224_IV[11] | 0;\n        this.Gh = T224_IV[12] | 0;\n        this.Gl = T224_IV[13] | 0;\n        this.Hh = T224_IV[14] | 0;\n        this.Hl = T224_IV[15] | 0;\n    }\n}\nclass SHA512_256 extends SHA512 {\n    constructor(){\n        super(32);\n        this.Ah = T256_IV[0] | 0;\n        this.Al = T256_IV[1] | 0;\n        this.Bh = T256_IV[2] | 0;\n        this.Bl = T256_IV[3] | 0;\n        this.Ch = T256_IV[4] | 0;\n        this.Cl = T256_IV[5] | 0;\n        this.Dh = T256_IV[6] | 0;\n        this.Dl = T256_IV[7] | 0;\n        this.Eh = T256_IV[8] | 0;\n        this.El = T256_IV[9] | 0;\n        this.Fh = T256_IV[10] | 0;\n        this.Fl = T256_IV[11] | 0;\n        this.Gh = T256_IV[12] | 0;\n        this.Gl = T256_IV[13] | 0;\n        this.Hh = T256_IV[14] | 0;\n        this.Hl = T256_IV[15] | 0;\n    }\n}\n/**\n * SHA2-256 hash function from RFC 4634.\n *\n * It is the fastest JS hash, even faster than Blake3.\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n */ const sha256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(()=>new SHA256());\n/** SHA2-224 hash function from RFC 4634 */ const sha224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(()=>new SHA224());\n/** SHA2-512 hash function from RFC 4634. */ const sha512 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(()=>new SHA512());\n/** SHA2-384 hash function from RFC 4634. */ const sha384 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(()=>new SHA384());\n/**\n * SHA2-512/256 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */ const sha512_256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(()=>new SHA512_256());\n/**\n * SHA2-512/224 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */ const sha512_224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(()=>new SHA512_224()); //# sourceMappingURL=sha2.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7OztDQU1DLEdBQ3VGO0FBQ3ZEO0FBQ3NCO0FBQ3ZEOzs7Q0FHQyxHQUNELGtCQUFrQjtBQUNsQixNQUFNVyxXQUFXLGFBQWEsR0FBR0MsWUFBWUMsSUFBSSxDQUFDO0lBQzlDO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFDcEY7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUNwRjtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQ3BGO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFDcEY7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUNwRjtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQ3BGO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFDcEY7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtDQUN2RjtBQUNELDZEQUE2RCxHQUM3RCxNQUFNQyxXQUFXLGFBQWEsR0FBRyxJQUFJRixZQUFZO0FBQzFDLE1BQU1HLGVBQWVkLDBDQUFNQTtJQUM5QmUsWUFBWUMsWUFBWSxFQUFFLENBQUU7UUFDeEIsS0FBSyxDQUFDLElBQUlBLFdBQVcsR0FBRztRQUN4QixtRUFBbUU7UUFDbkUsdURBQXVEO1FBQ3ZELElBQUksQ0FBQ0MsQ0FBQyxHQUFHZCw2Q0FBUyxDQUFDLEVBQUUsR0FBRztRQUN4QixJQUFJLENBQUNlLENBQUMsR0FBR2YsNkNBQVMsQ0FBQyxFQUFFLEdBQUc7UUFDeEIsSUFBSSxDQUFDZ0IsQ0FBQyxHQUFHaEIsNkNBQVMsQ0FBQyxFQUFFLEdBQUc7UUFDeEIsSUFBSSxDQUFDaUIsQ0FBQyxHQUFHakIsNkNBQVMsQ0FBQyxFQUFFLEdBQUc7UUFDeEIsSUFBSSxDQUFDa0IsQ0FBQyxHQUFHbEIsNkNBQVMsQ0FBQyxFQUFFLEdBQUc7UUFDeEIsSUFBSSxDQUFDbUIsQ0FBQyxHQUFHbkIsNkNBQVMsQ0FBQyxFQUFFLEdBQUc7UUFDeEIsSUFBSSxDQUFDb0IsQ0FBQyxHQUFHcEIsNkNBQVMsQ0FBQyxFQUFFLEdBQUc7UUFDeEIsSUFBSSxDQUFDcUIsQ0FBQyxHQUFHckIsNkNBQVMsQ0FBQyxFQUFFLEdBQUc7SUFDNUI7SUFDQXNCLE1BQU07UUFDRixNQUFNLEVBQUVSLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFLEdBQUcsSUFBSTtRQUN2QyxPQUFPO1lBQUNQO1lBQUdDO1lBQUdDO1lBQUdDO1lBQUdDO1lBQUdDO1lBQUdDO1lBQUdDO1NBQUU7SUFDbkM7SUFDQSxrQkFBa0I7SUFDbEJFLElBQUlULENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFO1FBQ3hCLElBQUksQ0FBQ1AsQ0FBQyxHQUFHQSxJQUFJO1FBQ2IsSUFBSSxDQUFDQyxDQUFDLEdBQUdBLElBQUk7UUFDYixJQUFJLENBQUNDLENBQUMsR0FBR0EsSUFBSTtRQUNiLElBQUksQ0FBQ0MsQ0FBQyxHQUFHQSxJQUFJO1FBQ2IsSUFBSSxDQUFDQyxDQUFDLEdBQUdBLElBQUk7UUFDYixJQUFJLENBQUNDLENBQUMsR0FBR0EsSUFBSTtRQUNiLElBQUksQ0FBQ0MsQ0FBQyxHQUFHQSxJQUFJO1FBQ2IsSUFBSSxDQUFDQyxDQUFDLEdBQUdBLElBQUk7SUFDakI7SUFDQUcsUUFBUUMsSUFBSSxFQUFFQyxNQUFNLEVBQUU7UUFDbEIsZ0dBQWdHO1FBQ2hHLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJLElBQUlBLEtBQUtELFVBQVUsRUFDbkNoQixRQUFRLENBQUNpQixFQUFFLEdBQUdGLEtBQUtHLFNBQVMsQ0FBQ0YsUUFBUTtRQUN6QyxJQUFLLElBQUlDLElBQUksSUFBSUEsSUFBSSxJQUFJQSxJQUFLO1lBQzFCLE1BQU1FLE1BQU1uQixRQUFRLENBQUNpQixJQUFJLEdBQUc7WUFDNUIsTUFBTUcsS0FBS3BCLFFBQVEsQ0FBQ2lCLElBQUksRUFBRTtZQUMxQixNQUFNSSxLQUFLekIsK0NBQUlBLENBQUN1QixLQUFLLEtBQUt2QiwrQ0FBSUEsQ0FBQ3VCLEtBQUssTUFBT0EsUUFBUTtZQUNuRCxNQUFNRyxLQUFLMUIsK0NBQUlBLENBQUN3QixJQUFJLE1BQU14QiwrQ0FBSUEsQ0FBQ3dCLElBQUksTUFBT0EsT0FBTztZQUNqRHBCLFFBQVEsQ0FBQ2lCLEVBQUUsR0FBRyxLQUFNakIsUUFBUSxDQUFDaUIsSUFBSSxFQUFFLEdBQUdJLEtBQUtyQixRQUFRLENBQUNpQixJQUFJLEdBQUcsR0FBSTtRQUNuRTtRQUNBLDRDQUE0QztRQUM1QyxJQUFJLEVBQUViLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFLEdBQUcsSUFBSTtRQUNyQyxJQUFLLElBQUlNLElBQUksR0FBR0EsSUFBSSxJQUFJQSxJQUFLO1lBQ3pCLE1BQU1NLFNBQVMzQiwrQ0FBSUEsQ0FBQ1ksR0FBRyxLQUFLWiwrQ0FBSUEsQ0FBQ1ksR0FBRyxNQUFNWiwrQ0FBSUEsQ0FBQ1ksR0FBRztZQUNsRCxNQUFNZ0IsS0FBSyxJQUFLRCxTQUFTckMsMkNBQUdBLENBQUNzQixHQUFHQyxHQUFHQyxLQUFLYixRQUFRLENBQUNvQixFQUFFLEdBQUdqQixRQUFRLENBQUNpQixFQUFFLEdBQUk7WUFDckUsTUFBTVEsU0FBUzdCLCtDQUFJQSxDQUFDUSxHQUFHLEtBQUtSLCtDQUFJQSxDQUFDUSxHQUFHLE1BQU1SLCtDQUFJQSxDQUFDUSxHQUFHO1lBQ2xELE1BQU1zQixLQUFLLFNBQVV0QywyQ0FBR0EsQ0FBQ2dCLEdBQUdDLEdBQUdDLEtBQU07WUFDckNLLElBQUlEO1lBQ0pBLElBQUlEO1lBQ0pBLElBQUlEO1lBQ0pBLElBQUksSUFBS2dCLEtBQU07WUFDZmpCLElBQUlEO1lBQ0pBLElBQUlEO1lBQ0pBLElBQUlEO1lBQ0pBLElBQUksS0FBTXNCLEtBQU07UUFDcEI7UUFDQSxxREFBcUQ7UUFDckR0QixJQUFJLElBQUssSUFBSSxDQUFDQSxDQUFDLEdBQUk7UUFDbkJDLElBQUksSUFBSyxJQUFJLENBQUNBLENBQUMsR0FBSTtRQUNuQkMsSUFBSSxJQUFLLElBQUksQ0FBQ0EsQ0FBQyxHQUFJO1FBQ25CQyxJQUFJLElBQUssSUFBSSxDQUFDQSxDQUFDLEdBQUk7UUFDbkJDLElBQUksSUFBSyxJQUFJLENBQUNBLENBQUMsR0FBSTtRQUNuQkMsSUFBSSxJQUFLLElBQUksQ0FBQ0EsQ0FBQyxHQUFJO1FBQ25CQyxJQUFJLElBQUssSUFBSSxDQUFDQSxDQUFDLEdBQUk7UUFDbkJDLElBQUksSUFBSyxJQUFJLENBQUNBLENBQUMsR0FBSTtRQUNuQixJQUFJLENBQUNFLEdBQUcsQ0FBQ1QsR0FBR0MsR0FBR0MsR0FBR0MsR0FBR0MsR0FBR0MsR0FBR0MsR0FBR0M7SUFDbEM7SUFDQWdCLGFBQWE7UUFDVGpDLGdEQUFLQSxDQUFDTTtJQUNWO0lBQ0E0QixVQUFVO1FBQ04sSUFBSSxDQUFDZixHQUFHLENBQUMsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRztRQUM5Qm5CLGdEQUFLQSxDQUFDLElBQUksQ0FBQ21DLE1BQU07SUFDckI7QUFDSjtBQUNPLE1BQU1DLGVBQWU3QjtJQUN4QkMsYUFBYztRQUNWLEtBQUssQ0FBQztRQUNOLElBQUksQ0FBQ0UsQ0FBQyxHQUFHZiw2Q0FBUyxDQUFDLEVBQUUsR0FBRztRQUN4QixJQUFJLENBQUNnQixDQUFDLEdBQUdoQiw2Q0FBUyxDQUFDLEVBQUUsR0FBRztRQUN4QixJQUFJLENBQUNpQixDQUFDLEdBQUdqQiw2Q0FBUyxDQUFDLEVBQUUsR0FBRztRQUN4QixJQUFJLENBQUNrQixDQUFDLEdBQUdsQiw2Q0FBUyxDQUFDLEVBQUUsR0FBRztRQUN4QixJQUFJLENBQUNtQixDQUFDLEdBQUduQiw2Q0FBUyxDQUFDLEVBQUUsR0FBRztRQUN4QixJQUFJLENBQUNvQixDQUFDLEdBQUdwQiw2Q0FBUyxDQUFDLEVBQUUsR0FBRztRQUN4QixJQUFJLENBQUNxQixDQUFDLEdBQUdyQiw2Q0FBUyxDQUFDLEVBQUUsR0FBRztRQUN4QixJQUFJLENBQUNzQixDQUFDLEdBQUd0Qiw2Q0FBUyxDQUFDLEVBQUUsR0FBRztJQUM1QjtBQUNKO0FBQ0Esd0VBQXdFO0FBQ3hFLGlCQUFpQjtBQUNqQix3RkFBd0Y7QUFDeEYsa0JBQWtCO0FBQ2xCLE1BQU0wQyxPQUF1QixhQUFILEdBQUksS0FBTXRDLDBDQUFTLENBQUM7UUFDMUM7UUFBc0I7UUFBc0I7UUFBc0I7UUFDbEU7UUFBc0I7UUFBc0I7UUFBc0I7UUFDbEU7UUFBc0I7UUFBc0I7UUFBc0I7UUFDbEU7UUFBc0I7UUFBc0I7UUFBc0I7UUFDbEU7UUFBc0I7UUFBc0I7UUFBc0I7UUFDbEU7UUFBc0I7UUFBc0I7UUFBc0I7UUFDbEU7UUFBc0I7UUFBc0I7UUFBc0I7UUFDbEU7UUFBc0I7UUFBc0I7UUFBc0I7UUFDbEU7UUFBc0I7UUFBc0I7UUFBc0I7UUFDbEU7UUFBc0I7UUFBc0I7UUFBc0I7UUFDbEU7UUFBc0I7UUFBc0I7UUFBc0I7UUFDbEU7UUFBc0I7UUFBc0I7UUFBc0I7UUFDbEU7UUFBc0I7UUFBc0I7UUFBc0I7UUFDbEU7UUFBc0I7UUFBc0I7UUFBc0I7UUFDbEU7UUFBc0I7UUFBc0I7UUFBc0I7UUFDbEU7UUFBc0I7UUFBc0I7UUFBc0I7UUFDbEU7UUFBc0I7UUFBc0I7UUFBc0I7UUFDbEU7UUFBc0I7UUFBc0I7UUFBc0I7UUFDbEU7UUFBc0I7UUFBc0I7UUFBc0I7UUFDbEU7UUFBc0I7UUFBc0I7UUFBc0I7S0FDckUsQ0FBQ3dDLEdBQUcsQ0FBQ0MsQ0FBQUEsSUFBS0MsT0FBT0QsSUFBRztBQUNyQixNQUFNRSxZQUE0QixhQUFILEdBQUksS0FBTUwsSUFBSSxDQUFDLEVBQUU7QUFDaEQsTUFBTU0sWUFBNEIsYUFBSCxHQUFJLEtBQU1OLElBQUksQ0FBQyxFQUFFO0FBQ2hELDZCQUE2QjtBQUM3QixNQUFNTyxhQUFhLGFBQWEsR0FBRyxJQUFJeEMsWUFBWTtBQUNuRCxNQUFNeUMsYUFBYSxhQUFhLEdBQUcsSUFBSXpDLFlBQVk7QUFDNUMsTUFBTTBDLGVBQWVyRCwwQ0FBTUE7SUFDOUJlLFlBQVlDLFlBQVksRUFBRSxDQUFFO1FBQ3hCLEtBQUssQ0FBQyxLQUFLQSxXQUFXLElBQUk7UUFDMUIsbUVBQW1FO1FBQ25FLHVEQUF1RDtRQUN2RCxzQ0FBc0M7UUFDdEMsSUFBSSxDQUFDc0MsRUFBRSxHQUFHakQsNkNBQVMsQ0FBQyxFQUFFLEdBQUc7UUFDekIsSUFBSSxDQUFDa0QsRUFBRSxHQUFHbEQsNkNBQVMsQ0FBQyxFQUFFLEdBQUc7UUFDekIsSUFBSSxDQUFDbUQsRUFBRSxHQUFHbkQsNkNBQVMsQ0FBQyxFQUFFLEdBQUc7UUFDekIsSUFBSSxDQUFDb0QsRUFBRSxHQUFHcEQsNkNBQVMsQ0FBQyxFQUFFLEdBQUc7UUFDekIsSUFBSSxDQUFDcUQsRUFBRSxHQUFHckQsNkNBQVMsQ0FBQyxFQUFFLEdBQUc7UUFDekIsSUFBSSxDQUFDc0QsRUFBRSxHQUFHdEQsNkNBQVMsQ0FBQyxFQUFFLEdBQUc7UUFDekIsSUFBSSxDQUFDdUQsRUFBRSxHQUFHdkQsNkNBQVMsQ0FBQyxFQUFFLEdBQUc7UUFDekIsSUFBSSxDQUFDd0QsRUFBRSxHQUFHeEQsNkNBQVMsQ0FBQyxFQUFFLEdBQUc7UUFDekIsSUFBSSxDQUFDeUQsRUFBRSxHQUFHekQsNkNBQVMsQ0FBQyxFQUFFLEdBQUc7UUFDekIsSUFBSSxDQUFDMEQsRUFBRSxHQUFHMUQsNkNBQVMsQ0FBQyxFQUFFLEdBQUc7UUFDekIsSUFBSSxDQUFDMkQsRUFBRSxHQUFHM0QsNkNBQVMsQ0FBQyxHQUFHLEdBQUc7UUFDMUIsSUFBSSxDQUFDNEQsRUFBRSxHQUFHNUQsNkNBQVMsQ0FBQyxHQUFHLEdBQUc7UUFDMUIsSUFBSSxDQUFDNkQsRUFBRSxHQUFHN0QsNkNBQVMsQ0FBQyxHQUFHLEdBQUc7UUFDMUIsSUFBSSxDQUFDOEQsRUFBRSxHQUFHOUQsNkNBQVMsQ0FBQyxHQUFHLEdBQUc7UUFDMUIsSUFBSSxDQUFDK0QsRUFBRSxHQUFHL0QsNkNBQVMsQ0FBQyxHQUFHLEdBQUc7UUFDMUIsSUFBSSxDQUFDZ0UsRUFBRSxHQUFHaEUsNkNBQVMsQ0FBQyxHQUFHLEdBQUc7SUFDOUI7SUFDQSxrQkFBa0I7SUFDbEJvQixNQUFNO1FBQ0YsTUFBTSxFQUFFNkIsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFLEdBQUcsSUFBSTtRQUMvRSxPQUFPO1lBQUNmO1lBQUlDO1lBQUlDO1lBQUlDO1lBQUlDO1lBQUlDO1lBQUlDO1lBQUlDO1lBQUlDO1lBQUlDO1lBQUlDO1lBQUlDO1lBQUlDO1lBQUlDO1lBQUlDO1lBQUlDO1NBQUc7SUFDM0U7SUFDQSxrQkFBa0I7SUFDbEIzQyxJQUFJNEIsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFO1FBQ2hFLElBQUksQ0FBQ2YsRUFBRSxHQUFHQSxLQUFLO1FBQ2YsSUFBSSxDQUFDQyxFQUFFLEdBQUdBLEtBQUs7UUFDZixJQUFJLENBQUNDLEVBQUUsR0FBR0EsS0FBSztRQUNmLElBQUksQ0FBQ0MsRUFBRSxHQUFHQSxLQUFLO1FBQ2YsSUFBSSxDQUFDQyxFQUFFLEdBQUdBLEtBQUs7UUFDZixJQUFJLENBQUNDLEVBQUUsR0FBR0EsS0FBSztRQUNmLElBQUksQ0FBQ0MsRUFBRSxHQUFHQSxLQUFLO1FBQ2YsSUFBSSxDQUFDQyxFQUFFLEdBQUdBLEtBQUs7UUFDZixJQUFJLENBQUNDLEVBQUUsR0FBR0EsS0FBSztRQUNmLElBQUksQ0FBQ0MsRUFBRSxHQUFHQSxLQUFLO1FBQ2YsSUFBSSxDQUFDQyxFQUFFLEdBQUdBLEtBQUs7UUFDZixJQUFJLENBQUNDLEVBQUUsR0FBR0EsS0FBSztRQUNmLElBQUksQ0FBQ0MsRUFBRSxHQUFHQSxLQUFLO1FBQ2YsSUFBSSxDQUFDQyxFQUFFLEdBQUdBLEtBQUs7UUFDZixJQUFJLENBQUNDLEVBQUUsR0FBR0EsS0FBSztRQUNmLElBQUksQ0FBQ0MsRUFBRSxHQUFHQSxLQUFLO0lBQ25CO0lBQ0ExQyxRQUFRQyxJQUFJLEVBQUVDLE1BQU0sRUFBRTtRQUNsQixnR0FBZ0c7UUFDaEcsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUksSUFBSUEsS0FBS0QsVUFBVSxFQUFHO1lBQ3RDc0IsVUFBVSxDQUFDckIsRUFBRSxHQUFHRixLQUFLRyxTQUFTLENBQUNGO1lBQy9CdUIsVUFBVSxDQUFDdEIsRUFBRSxHQUFHRixLQUFLRyxTQUFTLENBQUVGLFVBQVU7UUFDOUM7UUFDQSxJQUFLLElBQUlDLElBQUksSUFBSUEsSUFBSSxJQUFJQSxJQUFLO1lBQzFCLHVGQUF1RjtZQUN2RixNQUFNd0MsT0FBT25CLFVBQVUsQ0FBQ3JCLElBQUksR0FBRyxHQUFHO1lBQ2xDLE1BQU15QyxPQUFPbkIsVUFBVSxDQUFDdEIsSUFBSSxHQUFHLEdBQUc7WUFDbEMsTUFBTTBDLE1BQU1sRSwyQ0FBVSxDQUFDZ0UsTUFBTUMsTUFBTSxLQUFLakUsMkNBQVUsQ0FBQ2dFLE1BQU1DLE1BQU0sS0FBS2pFLDBDQUFTLENBQUNnRSxNQUFNQyxNQUFNO1lBQzFGLE1BQU1JLE1BQU1yRSwyQ0FBVSxDQUFDZ0UsTUFBTUMsTUFBTSxLQUFLakUsMkNBQVUsQ0FBQ2dFLE1BQU1DLE1BQU0sS0FBS2pFLDBDQUFTLENBQUNnRSxNQUFNQyxNQUFNO1lBQzFGLHNGQUFzRjtZQUN0RixNQUFNTyxNQUFNM0IsVUFBVSxDQUFDckIsSUFBSSxFQUFFLEdBQUc7WUFDaEMsTUFBTWlELE1BQU0zQixVQUFVLENBQUN0QixJQUFJLEVBQUUsR0FBRztZQUNoQyxNQUFNa0QsTUFBTTFFLDJDQUFVLENBQUN3RSxLQUFLQyxLQUFLLE1BQU16RSwyQ0FBVSxDQUFDd0UsS0FBS0MsS0FBSyxNQUFNekUsMENBQVMsQ0FBQ3dFLEtBQUtDLEtBQUs7WUFDdEYsTUFBTUcsTUFBTTVFLDJDQUFVLENBQUN3RSxLQUFLQyxLQUFLLE1BQU16RSwyQ0FBVSxDQUFDd0UsS0FBS0MsS0FBSyxNQUFNekUsMENBQVMsQ0FBQ3dFLEtBQUtDLEtBQUs7WUFDdEYsOERBQThEO1lBQzlELE1BQU1LLE9BQU85RSwwQ0FBUyxDQUFDcUUsS0FBS08sS0FBSzlCLFVBQVUsQ0FBQ3RCLElBQUksRUFBRSxFQUFFc0IsVUFBVSxDQUFDdEIsSUFBSSxHQUFHO1lBQ3RFLE1BQU13RCxPQUFPaEYsMENBQVMsQ0FBQzhFLE1BQU1aLEtBQUtRLEtBQUs3QixVQUFVLENBQUNyQixJQUFJLEVBQUUsRUFBRXFCLFVBQVUsQ0FBQ3JCLElBQUksR0FBRztZQUM1RXFCLFVBQVUsQ0FBQ3JCLEVBQUUsR0FBR3dELE9BQU87WUFDdkJsQyxVQUFVLENBQUN0QixFQUFFLEdBQUdzRCxPQUFPO1FBQzNCO1FBQ0EsSUFBSSxFQUFFOUIsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFLEdBQUcsSUFBSTtRQUM3RSw0Q0FBNEM7UUFDNUMsSUFBSyxJQUFJdkMsSUFBSSxHQUFHQSxJQUFJLElBQUlBLElBQUs7WUFDekIseUVBQXlFO1lBQ3pFLE1BQU0wRCxVQUFVbEYsMkNBQVUsQ0FBQ3dELElBQUlDLElBQUksTUFBTXpELDJDQUFVLENBQUN3RCxJQUFJQyxJQUFJLE1BQU16RCwyQ0FBVSxDQUFDd0QsSUFBSUMsSUFBSTtZQUNyRixNQUFNMEIsVUFBVW5GLDJDQUFVLENBQUN3RCxJQUFJQyxJQUFJLE1BQU16RCwyQ0FBVSxDQUFDd0QsSUFBSUMsSUFBSSxNQUFNekQsMkNBQVUsQ0FBQ3dELElBQUlDLElBQUk7WUFDckYseUVBQXlFO1lBQ3pFLE1BQU0yQixPQUFPLEtBQU0xQixLQUFPLENBQUNGLEtBQUtJO1lBQ2hDLE1BQU15QixPQUFPLEtBQU0xQixLQUFPLENBQUNGLEtBQUtJO1lBQ2hDLDZEQUE2RDtZQUM3RCxrQkFBa0I7WUFDbEIsTUFBTXlCLE9BQU90RiwwQ0FBUyxDQUFDK0QsSUFBSW9CLFNBQVNFLE1BQU16QyxTQUFTLENBQUNwQixFQUFFLEVBQUVzQixVQUFVLENBQUN0QixFQUFFO1lBQ3JFLE1BQU1nRSxNQUFNeEYsMENBQVMsQ0FBQ3NGLE1BQU14QixJQUFJb0IsU0FBU0UsTUFBTXpDLFNBQVMsQ0FBQ25CLEVBQUUsRUFBRXFCLFVBQVUsQ0FBQ3JCLEVBQUU7WUFDMUUsTUFBTWtFLE1BQU1KLE9BQU87WUFDbkIseUVBQXlFO1lBQ3pFLE1BQU1LLFVBQVUzRiwyQ0FBVSxDQUFDZ0QsSUFBSUMsSUFBSSxNQUFNakQsMkNBQVUsQ0FBQ2dELElBQUlDLElBQUksTUFBTWpELDJDQUFVLENBQUNnRCxJQUFJQyxJQUFJO1lBQ3JGLE1BQU0yQyxVQUFVNUYsMkNBQVUsQ0FBQ2dELElBQUlDLElBQUksTUFBTWpELDJDQUFVLENBQUNnRCxJQUFJQyxJQUFJLE1BQU1qRCwyQ0FBVSxDQUFDZ0QsSUFBSUMsSUFBSTtZQUNyRixNQUFNNEMsT0FBTyxLQUFNM0MsS0FBT0YsS0FBS0ksS0FBT0YsS0FBS0U7WUFDM0MsTUFBTTBDLE9BQU8sS0FBTTNDLEtBQU9GLEtBQUtJLEtBQU9GLEtBQUtFO1lBQzNDUyxLQUFLRixLQUFLO1lBQ1ZHLEtBQUtGLEtBQUs7WUFDVkQsS0FBS0YsS0FBSztZQUNWRyxLQUFLRixLQUFLO1lBQ1ZELEtBQUtGLEtBQUs7WUFDVkcsS0FBS0YsS0FBSztZQUNULEdBQUVzQyxHQUFHdkMsRUFBRSxFQUFFd0MsR0FBR3ZDLEVBQUUsRUFBRSxHQUFHekQsd0NBQU8sQ0FBQ3NELEtBQUssR0FBR0MsS0FBSyxHQUFHaUMsTUFBTSxHQUFHRSxNQUFNLEVBQUM7WUFDNURwQyxLQUFLRixLQUFLO1lBQ1ZHLEtBQUtGLEtBQUs7WUFDVkQsS0FBS0YsS0FBSztZQUNWRyxLQUFLRixLQUFLO1lBQ1ZELEtBQUtGLEtBQUs7WUFDVkcsS0FBS0YsS0FBSztZQUNWLE1BQU1pRCxNQUFNbEcsMENBQVMsQ0FBQzBGLEtBQUtFLFNBQVNFO1lBQ3BDOUMsS0FBS2hELDBDQUFTLENBQUNrRyxLQUFLVixLQUFLRyxTQUFTRTtZQUNsQzVDLEtBQUtpRCxNQUFNO1FBQ2Y7UUFDQSxxREFBcUQ7UUFDcEQsR0FBRUgsR0FBRy9DLEVBQUUsRUFBRWdELEdBQUcvQyxFQUFFLEVBQUUsR0FBR2pELHdDQUFPLENBQUMsSUFBSSxDQUFDZ0QsRUFBRSxHQUFHLEdBQUcsSUFBSSxDQUFDQyxFQUFFLEdBQUcsR0FBR0QsS0FBSyxHQUFHQyxLQUFLLEVBQUM7UUFDbkUsR0FBRThDLEdBQUc3QyxFQUFFLEVBQUU4QyxHQUFHN0MsRUFBRSxFQUFFLEdBQUduRCx3Q0FBTyxDQUFDLElBQUksQ0FBQ2tELEVBQUUsR0FBRyxHQUFHLElBQUksQ0FBQ0MsRUFBRSxHQUFHLEdBQUdELEtBQUssR0FBR0MsS0FBSyxFQUFDO1FBQ25FLEdBQUU0QyxHQUFHM0MsRUFBRSxFQUFFNEMsR0FBRzNDLEVBQUUsRUFBRSxHQUFHckQsd0NBQU8sQ0FBQyxJQUFJLENBQUNvRCxFQUFFLEdBQUcsR0FBRyxJQUFJLENBQUNDLEVBQUUsR0FBRyxHQUFHRCxLQUFLLEdBQUdDLEtBQUssRUFBQztRQUNuRSxHQUFFMEMsR0FBR3pDLEVBQUUsRUFBRTBDLEdBQUd6QyxFQUFFLEVBQUUsR0FBR3ZELHdDQUFPLENBQUMsSUFBSSxDQUFDc0QsRUFBRSxHQUFHLEdBQUcsSUFBSSxDQUFDQyxFQUFFLEdBQUcsR0FBR0QsS0FBSyxHQUFHQyxLQUFLLEVBQUM7UUFDbkUsR0FBRXdDLEdBQUd2QyxFQUFFLEVBQUV3QyxHQUFHdkMsRUFBRSxFQUFFLEdBQUd6RCx3Q0FBTyxDQUFDLElBQUksQ0FBQ3dELEVBQUUsR0FBRyxHQUFHLElBQUksQ0FBQ0MsRUFBRSxHQUFHLEdBQUdELEtBQUssR0FBR0MsS0FBSyxFQUFDO1FBQ25FLEdBQUVzQyxHQUFHckMsRUFBRSxFQUFFc0MsR0FBR3JDLEVBQUUsRUFBRSxHQUFHM0Qsd0NBQU8sQ0FBQyxJQUFJLENBQUMwRCxFQUFFLEdBQUcsR0FBRyxJQUFJLENBQUNDLEVBQUUsR0FBRyxHQUFHRCxLQUFLLEdBQUdDLEtBQUssRUFBQztRQUNuRSxHQUFFb0MsR0FBR25DLEVBQUUsRUFBRW9DLEdBQUduQyxFQUFFLEVBQUUsR0FBRzdELHdDQUFPLENBQUMsSUFBSSxDQUFDNEQsRUFBRSxHQUFHLEdBQUcsSUFBSSxDQUFDQyxFQUFFLEdBQUcsR0FBR0QsS0FBSyxHQUFHQyxLQUFLLEVBQUM7UUFDbkUsR0FBRWtDLEdBQUdqQyxFQUFFLEVBQUVrQyxHQUFHakMsRUFBRSxFQUFFLEdBQUcvRCx3Q0FBTyxDQUFDLElBQUksQ0FBQzhELEVBQUUsR0FBRyxHQUFHLElBQUksQ0FBQ0MsRUFBRSxHQUFHLEdBQUdELEtBQUssR0FBR0MsS0FBSyxFQUFDO1FBQ3BFLElBQUksQ0FBQzNDLEdBQUcsQ0FBQzRCLElBQUlDLElBQUlDLElBQUlDLElBQUlDLElBQUlDLElBQUlDLElBQUlDLElBQUlDLElBQUlDLElBQUlDLElBQUlDLElBQUlDLElBQUlDLElBQUlDLElBQUlDO0lBQ3pFO0lBQ0E3QixhQUFhO1FBQ1RqQyxnREFBS0EsQ0FBQzRDLFlBQVlDO0lBQ3RCO0lBQ0FYLFVBQVU7UUFDTmxDLGdEQUFLQSxDQUFDLElBQUksQ0FBQ21DLE1BQU07UUFDakIsSUFBSSxDQUFDaEIsR0FBRyxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO0lBQzFEO0FBQ0o7QUFDTyxNQUFNaUYsZUFBZXREO0lBQ3hCdEMsYUFBYztRQUNWLEtBQUssQ0FBQztRQUNOLElBQUksQ0FBQ3VDLEVBQUUsR0FBR2xELDZDQUFTLENBQUMsRUFBRSxHQUFHO1FBQ3pCLElBQUksQ0FBQ21ELEVBQUUsR0FBR25ELDZDQUFTLENBQUMsRUFBRSxHQUFHO1FBQ3pCLElBQUksQ0FBQ29ELEVBQUUsR0FBR3BELDZDQUFTLENBQUMsRUFBRSxHQUFHO1FBQ3pCLElBQUksQ0FBQ3FELEVBQUUsR0FBR3JELDZDQUFTLENBQUMsRUFBRSxHQUFHO1FBQ3pCLElBQUksQ0FBQ3NELEVBQUUsR0FBR3RELDZDQUFTLENBQUMsRUFBRSxHQUFHO1FBQ3pCLElBQUksQ0FBQ3VELEVBQUUsR0FBR3ZELDZDQUFTLENBQUMsRUFBRSxHQUFHO1FBQ3pCLElBQUksQ0FBQ3dELEVBQUUsR0FBR3hELDZDQUFTLENBQUMsRUFBRSxHQUFHO1FBQ3pCLElBQUksQ0FBQ3lELEVBQUUsR0FBR3pELDZDQUFTLENBQUMsRUFBRSxHQUFHO1FBQ3pCLElBQUksQ0FBQzBELEVBQUUsR0FBRzFELDZDQUFTLENBQUMsRUFBRSxHQUFHO1FBQ3pCLElBQUksQ0FBQzJELEVBQUUsR0FBRzNELDZDQUFTLENBQUMsRUFBRSxHQUFHO1FBQ3pCLElBQUksQ0FBQzRELEVBQUUsR0FBRzVELDZDQUFTLENBQUMsR0FBRyxHQUFHO1FBQzFCLElBQUksQ0FBQzZELEVBQUUsR0FBRzdELDZDQUFTLENBQUMsR0FBRyxHQUFHO1FBQzFCLElBQUksQ0FBQzhELEVBQUUsR0FBRzlELDZDQUFTLENBQUMsR0FBRyxHQUFHO1FBQzFCLElBQUksQ0FBQytELEVBQUUsR0FBRy9ELDZDQUFTLENBQUMsR0FBRyxHQUFHO1FBQzFCLElBQUksQ0FBQ2dFLEVBQUUsR0FBR2hFLDZDQUFTLENBQUMsR0FBRyxHQUFHO1FBQzFCLElBQUksQ0FBQ2lFLEVBQUUsR0FBR2pFLDZDQUFTLENBQUMsR0FBRyxHQUFHO0lBQzlCO0FBQ0o7QUFDQTs7Ozs7Q0FLQyxHQUNELGtCQUFrQixHQUNsQixNQUFNd0csVUFBVSxhQUFhLEdBQUdqRyxZQUFZQyxJQUFJLENBQUM7SUFDN0M7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUNwRjtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0NBQ3ZGO0FBQ0Qsa0JBQWtCLEdBQ2xCLE1BQU1pRyxVQUFVLGFBQWEsR0FBR2xHLFlBQVlDLElBQUksQ0FBQztJQUM3QztJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQ3BGO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7Q0FDdkY7QUFDTSxNQUFNa0csbUJBQW1CekQ7SUFDNUJ0QyxhQUFjO1FBQ1YsS0FBSyxDQUFDO1FBQ04sSUFBSSxDQUFDdUMsRUFBRSxHQUFHc0QsT0FBTyxDQUFDLEVBQUUsR0FBRztRQUN2QixJQUFJLENBQUNyRCxFQUFFLEdBQUdxRCxPQUFPLENBQUMsRUFBRSxHQUFHO1FBQ3ZCLElBQUksQ0FBQ3BELEVBQUUsR0FBR29ELE9BQU8sQ0FBQyxFQUFFLEdBQUc7UUFDdkIsSUFBSSxDQUFDbkQsRUFBRSxHQUFHbUQsT0FBTyxDQUFDLEVBQUUsR0FBRztRQUN2QixJQUFJLENBQUNsRCxFQUFFLEdBQUdrRCxPQUFPLENBQUMsRUFBRSxHQUFHO1FBQ3ZCLElBQUksQ0FBQ2pELEVBQUUsR0FBR2lELE9BQU8sQ0FBQyxFQUFFLEdBQUc7UUFDdkIsSUFBSSxDQUFDaEQsRUFBRSxHQUFHZ0QsT0FBTyxDQUFDLEVBQUUsR0FBRztRQUN2QixJQUFJLENBQUMvQyxFQUFFLEdBQUcrQyxPQUFPLENBQUMsRUFBRSxHQUFHO1FBQ3ZCLElBQUksQ0FBQzlDLEVBQUUsR0FBRzhDLE9BQU8sQ0FBQyxFQUFFLEdBQUc7UUFDdkIsSUFBSSxDQUFDN0MsRUFBRSxHQUFHNkMsT0FBTyxDQUFDLEVBQUUsR0FBRztRQUN2QixJQUFJLENBQUM1QyxFQUFFLEdBQUc0QyxPQUFPLENBQUMsR0FBRyxHQUFHO1FBQ3hCLElBQUksQ0FBQzNDLEVBQUUsR0FBRzJDLE9BQU8sQ0FBQyxHQUFHLEdBQUc7UUFDeEIsSUFBSSxDQUFDMUMsRUFBRSxHQUFHMEMsT0FBTyxDQUFDLEdBQUcsR0FBRztRQUN4QixJQUFJLENBQUN6QyxFQUFFLEdBQUd5QyxPQUFPLENBQUMsR0FBRyxHQUFHO1FBQ3hCLElBQUksQ0FBQ3hDLEVBQUUsR0FBR3dDLE9BQU8sQ0FBQyxHQUFHLEdBQUc7UUFDeEIsSUFBSSxDQUFDdkMsRUFBRSxHQUFHdUMsT0FBTyxDQUFDLEdBQUcsR0FBRztJQUM1QjtBQUNKO0FBQ08sTUFBTUcsbUJBQW1CMUQ7SUFDNUJ0QyxhQUFjO1FBQ1YsS0FBSyxDQUFDO1FBQ04sSUFBSSxDQUFDdUMsRUFBRSxHQUFHdUQsT0FBTyxDQUFDLEVBQUUsR0FBRztRQUN2QixJQUFJLENBQUN0RCxFQUFFLEdBQUdzRCxPQUFPLENBQUMsRUFBRSxHQUFHO1FBQ3ZCLElBQUksQ0FBQ3JELEVBQUUsR0FBR3FELE9BQU8sQ0FBQyxFQUFFLEdBQUc7UUFDdkIsSUFBSSxDQUFDcEQsRUFBRSxHQUFHb0QsT0FBTyxDQUFDLEVBQUUsR0FBRztRQUN2QixJQUFJLENBQUNuRCxFQUFFLEdBQUdtRCxPQUFPLENBQUMsRUFBRSxHQUFHO1FBQ3ZCLElBQUksQ0FBQ2xELEVBQUUsR0FBR2tELE9BQU8sQ0FBQyxFQUFFLEdBQUc7UUFDdkIsSUFBSSxDQUFDakQsRUFBRSxHQUFHaUQsT0FBTyxDQUFDLEVBQUUsR0FBRztRQUN2QixJQUFJLENBQUNoRCxFQUFFLEdBQUdnRCxPQUFPLENBQUMsRUFBRSxHQUFHO1FBQ3ZCLElBQUksQ0FBQy9DLEVBQUUsR0FBRytDLE9BQU8sQ0FBQyxFQUFFLEdBQUc7UUFDdkIsSUFBSSxDQUFDOUMsRUFBRSxHQUFHOEMsT0FBTyxDQUFDLEVBQUUsR0FBRztRQUN2QixJQUFJLENBQUM3QyxFQUFFLEdBQUc2QyxPQUFPLENBQUMsR0FBRyxHQUFHO1FBQ3hCLElBQUksQ0FBQzVDLEVBQUUsR0FBRzRDLE9BQU8sQ0FBQyxHQUFHLEdBQUc7UUFDeEIsSUFBSSxDQUFDM0MsRUFBRSxHQUFHMkMsT0FBTyxDQUFDLEdBQUcsR0FBRztRQUN4QixJQUFJLENBQUMxQyxFQUFFLEdBQUcwQyxPQUFPLENBQUMsR0FBRyxHQUFHO1FBQ3hCLElBQUksQ0FBQ3pDLEVBQUUsR0FBR3lDLE9BQU8sQ0FBQyxHQUFHLEdBQUc7UUFDeEIsSUFBSSxDQUFDeEMsRUFBRSxHQUFHd0MsT0FBTyxDQUFDLEdBQUcsR0FBRztJQUM1QjtBQUNKO0FBQ0E7Ozs7OztDQU1DLEdBQ00sTUFBTUcsU0FBUyxhQUFhLEdBQUd4Ryx1REFBWUEsQ0FBQyxJQUFNLElBQUlNLFVBQVU7QUFDdkUseUNBQXlDLEdBQ2xDLE1BQU1tRyxTQUFTLGFBQWEsR0FBR3pHLHVEQUFZQSxDQUFDLElBQU0sSUFBSW1DLFVBQVU7QUFDdkUsMENBQTBDLEdBQ25DLE1BQU11RSxTQUFTLGFBQWEsR0FBRzFHLHVEQUFZQSxDQUFDLElBQU0sSUFBSTZDLFVBQVU7QUFDdkUsMENBQTBDLEdBQ25DLE1BQU04RCxTQUFTLGFBQWEsR0FBRzNHLHVEQUFZQSxDQUFDLElBQU0sSUFBSW1HLFVBQVU7QUFDdkU7OztDQUdDLEdBQ00sTUFBTVMsYUFBYSxhQUFhLEdBQUc1Ryx1REFBWUEsQ0FBQyxJQUFNLElBQUl1RyxjQUFjO0FBQy9FOzs7Q0FHQyxHQUNNLE1BQU1NLGFBQWEsYUFBYSxHQUFHN0csdURBQVlBLENBQUMsSUFBTSxJQUFJc0csY0FBYyxDQUMvRSxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGF3LXdvcmtzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEyLmpzP2YxMmQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBTSEEyIGhhc2ggZnVuY3Rpb24uIEEuay5hLiBzaGEyNTYsIHNoYTM4NCwgc2hhNTEyLCBzaGE1MTJfMjI0LCBzaGE1MTJfMjU2LlxuICogU0hBMjU2IGlzIHRoZSBmYXN0ZXN0IGhhc2ggaW1wbGVtZW50YWJsZSBpbiBKUywgZXZlbiBmYXN0ZXIgdGhhbiBCbGFrZTMuXG4gKiBDaGVjayBvdXQgW1JGQyA0NjM0XShodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzQ2MzQpIGFuZFxuICogW0ZJUFMgMTgwLTRdKGh0dHBzOi8vbnZscHVicy5uaXN0Lmdvdi9uaXN0cHVicy9GSVBTL05JU1QuRklQUy4xODAtNC5wZGYpLlxuICogQG1vZHVsZVxuICovXG5pbXBvcnQgeyBDaGksIEhhc2hNRCwgTWFqLCBTSEEyMjRfSVYsIFNIQTI1Nl9JViwgU0hBMzg0X0lWLCBTSEE1MTJfSVYgfSBmcm9tIFwiLi9fbWQuanNcIjtcbmltcG9ydCAqIGFzIHU2NCBmcm9tIFwiLi9fdTY0LmpzXCI7XG5pbXBvcnQgeyBjbGVhbiwgY3JlYXRlSGFzaGVyLCByb3RyIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbi8qKlxuICogUm91bmQgY29uc3RhbnRzOlxuICogRmlyc3QgMzIgYml0cyBvZiBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBjdWJlIHJvb3RzIG9mIHRoZSBmaXJzdCA2NCBwcmltZXMgMi4uMzExKVxuICovXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IFNIQTI1Nl9LID0gLyogQF9fUFVSRV9fICovIFVpbnQzMkFycmF5LmZyb20oW1xuICAgIDB4NDI4YTJmOTgsIDB4NzEzNzQ0OTEsIDB4YjVjMGZiY2YsIDB4ZTliNWRiYTUsIDB4Mzk1NmMyNWIsIDB4NTlmMTExZjEsIDB4OTIzZjgyYTQsIDB4YWIxYzVlZDUsXG4gICAgMHhkODA3YWE5OCwgMHgxMjgzNWIwMSwgMHgyNDMxODViZSwgMHg1NTBjN2RjMywgMHg3MmJlNWQ3NCwgMHg4MGRlYjFmZSwgMHg5YmRjMDZhNywgMHhjMTliZjE3NCxcbiAgICAweGU0OWI2OWMxLCAweGVmYmU0Nzg2LCAweDBmYzE5ZGM2LCAweDI0MGNhMWNjLCAweDJkZTkyYzZmLCAweDRhNzQ4NGFhLCAweDVjYjBhOWRjLCAweDc2Zjk4OGRhLFxuICAgIDB4OTgzZTUxNTIsIDB4YTgzMWM2NmQsIDB4YjAwMzI3YzgsIDB4YmY1OTdmYzcsIDB4YzZlMDBiZjMsIDB4ZDVhNzkxNDcsIDB4MDZjYTYzNTEsIDB4MTQyOTI5NjcsXG4gICAgMHgyN2I3MGE4NSwgMHgyZTFiMjEzOCwgMHg0ZDJjNmRmYywgMHg1MzM4MGQxMywgMHg2NTBhNzM1NCwgMHg3NjZhMGFiYiwgMHg4MWMyYzkyZSwgMHg5MjcyMmM4NSxcbiAgICAweGEyYmZlOGExLCAweGE4MWE2NjRiLCAweGMyNGI4YjcwLCAweGM3NmM1MWEzLCAweGQxOTJlODE5LCAweGQ2OTkwNjI0LCAweGY0MGUzNTg1LCAweDEwNmFhMDcwLFxuICAgIDB4MTlhNGMxMTYsIDB4MWUzNzZjMDgsIDB4Mjc0ODc3NGMsIDB4MzRiMGJjYjUsIDB4MzkxYzBjYjMsIDB4NGVkOGFhNGEsIDB4NWI5Y2NhNGYsIDB4NjgyZTZmZjMsXG4gICAgMHg3NDhmODJlZSwgMHg3OGE1NjM2ZiwgMHg4NGM4NzgxNCwgMHg4Y2M3MDIwOCwgMHg5MGJlZmZmYSwgMHhhNDUwNmNlYiwgMHhiZWY5YTNmNywgMHhjNjcxNzhmMlxuXSk7XG4vKiogUmV1c2FibGUgdGVtcG9yYXJ5IGJ1ZmZlci4gXCJXXCIgY29tZXMgc3RyYWlnaHQgZnJvbSBzcGVjLiAqL1xuY29uc3QgU0hBMjU2X1cgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDY0KTtcbmV4cG9ydCBjbGFzcyBTSEEyNTYgZXh0ZW5kcyBIYXNoTUQge1xuICAgIGNvbnN0cnVjdG9yKG91dHB1dExlbiA9IDMyKSB7XG4gICAgICAgIHN1cGVyKDY0LCBvdXRwdXRMZW4sIDgsIGZhbHNlKTtcbiAgICAgICAgLy8gV2UgY2Fubm90IHVzZSBhcnJheSBoZXJlIHNpbmNlIGFycmF5IGFsbG93cyBpbmRleGluZyBieSB2YXJpYWJsZVxuICAgICAgICAvLyB3aGljaCBtZWFucyBvcHRpbWl6ZXIvY29tcGlsZXIgY2Fubm90IHVzZSByZWdpc3RlcnMuXG4gICAgICAgIHRoaXMuQSA9IFNIQTI1Nl9JVlswXSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IFNIQTI1Nl9JVlsxXSB8IDA7XG4gICAgICAgIHRoaXMuQyA9IFNIQTI1Nl9JVlsyXSB8IDA7XG4gICAgICAgIHRoaXMuRCA9IFNIQTI1Nl9JVlszXSB8IDA7XG4gICAgICAgIHRoaXMuRSA9IFNIQTI1Nl9JVls0XSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IFNIQTI1Nl9JVls1XSB8IDA7XG4gICAgICAgIHRoaXMuRyA9IFNIQTI1Nl9JVls2XSB8IDA7XG4gICAgICAgIHRoaXMuSCA9IFNIQTI1Nl9JVls3XSB8IDA7XG4gICAgfVxuICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW0EsIEIsIEMsIEQsIEUsIEYsIEcsIEhdO1xuICAgIH1cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBzZXQoQSwgQiwgQywgRCwgRSwgRiwgRywgSCkge1xuICAgICAgICB0aGlzLkEgPSBBIHwgMDtcbiAgICAgICAgdGhpcy5CID0gQiB8IDA7XG4gICAgICAgIHRoaXMuQyA9IEMgfCAwO1xuICAgICAgICB0aGlzLkQgPSBEIHwgMDtcbiAgICAgICAgdGhpcy5FID0gRSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IEYgfCAwO1xuICAgICAgICB0aGlzLkcgPSBHIHwgMDtcbiAgICAgICAgdGhpcy5IID0gSCB8IDA7XG4gICAgfVxuICAgIHByb2Nlc3Modmlldywgb2Zmc2V0KSB7XG4gICAgICAgIC8vIEV4dGVuZCB0aGUgZmlyc3QgMTYgd29yZHMgaW50byB0aGUgcmVtYWluaW5nIDQ4IHdvcmRzIHdbMTYuLjYzXSBvZiB0aGUgbWVzc2FnZSBzY2hlZHVsZSBhcnJheVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyssIG9mZnNldCArPSA0KVxuICAgICAgICAgICAgU0hBMjU2X1dbaV0gPSB2aWV3LmdldFVpbnQzMihvZmZzZXQsIGZhbHNlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE2OyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgVzE1ID0gU0hBMjU2X1dbaSAtIDE1XTtcbiAgICAgICAgICAgIGNvbnN0IFcyID0gU0hBMjU2X1dbaSAtIDJdO1xuICAgICAgICAgICAgY29uc3QgczAgPSByb3RyKFcxNSwgNykgXiByb3RyKFcxNSwgMTgpIF4gKFcxNSA+Pj4gMyk7XG4gICAgICAgICAgICBjb25zdCBzMSA9IHJvdHIoVzIsIDE3KSBeIHJvdHIoVzIsIDE5KSBeIChXMiA+Pj4gMTApO1xuICAgICAgICAgICAgU0hBMjU2X1dbaV0gPSAoczEgKyBTSEEyNTZfV1tpIC0gN10gKyBzMCArIFNIQTI1Nl9XW2kgLSAxNl0pIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wcmVzc2lvbiBmdW5jdGlvbiBtYWluIGxvb3AsIDY0IHJvdW5kc1xuICAgICAgICBsZXQgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMSA9IHJvdHIoRSwgNikgXiByb3RyKEUsIDExKSBeIHJvdHIoRSwgMjUpO1xuICAgICAgICAgICAgY29uc3QgVDEgPSAoSCArIHNpZ21hMSArIENoaShFLCBGLCBHKSArIFNIQTI1Nl9LW2ldICsgU0hBMjU2X1dbaV0pIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMCA9IHJvdHIoQSwgMikgXiByb3RyKEEsIDEzKSBeIHJvdHIoQSwgMjIpO1xuICAgICAgICAgICAgY29uc3QgVDIgPSAoc2lnbWEwICsgTWFqKEEsIEIsIEMpKSB8IDA7XG4gICAgICAgICAgICBIID0gRztcbiAgICAgICAgICAgIEcgPSBGO1xuICAgICAgICAgICAgRiA9IEU7XG4gICAgICAgICAgICBFID0gKEQgKyBUMSkgfCAwO1xuICAgICAgICAgICAgRCA9IEM7XG4gICAgICAgICAgICBDID0gQjtcbiAgICAgICAgICAgIEIgPSBBO1xuICAgICAgICAgICAgQSA9IChUMSArIFQyKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBjb21wcmVzc2VkIGNodW5rIHRvIHRoZSBjdXJyZW50IGhhc2ggdmFsdWVcbiAgICAgICAgQSA9IChBICsgdGhpcy5BKSB8IDA7XG4gICAgICAgIEIgPSAoQiArIHRoaXMuQikgfCAwO1xuICAgICAgICBDID0gKEMgKyB0aGlzLkMpIHwgMDtcbiAgICAgICAgRCA9IChEICsgdGhpcy5EKSB8IDA7XG4gICAgICAgIEUgPSAoRSArIHRoaXMuRSkgfCAwO1xuICAgICAgICBGID0gKEYgKyB0aGlzLkYpIHwgMDtcbiAgICAgICAgRyA9IChHICsgdGhpcy5HKSB8IDA7XG4gICAgICAgIEggPSAoSCArIHRoaXMuSCkgfCAwO1xuICAgICAgICB0aGlzLnNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKTtcbiAgICB9XG4gICAgcm91bmRDbGVhbigpIHtcbiAgICAgICAgY2xlYW4oU0hBMjU2X1cpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICAgICAgY2xlYW4odGhpcy5idWZmZXIpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBTSEEyMjQgZXh0ZW5kcyBTSEEyNTYge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigyOCk7XG4gICAgICAgIHRoaXMuQSA9IFNIQTIyNF9JVlswXSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IFNIQTIyNF9JVlsxXSB8IDA7XG4gICAgICAgIHRoaXMuQyA9IFNIQTIyNF9JVlsyXSB8IDA7XG4gICAgICAgIHRoaXMuRCA9IFNIQTIyNF9JVlszXSB8IDA7XG4gICAgICAgIHRoaXMuRSA9IFNIQTIyNF9JVls0XSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IFNIQTIyNF9JVls1XSB8IDA7XG4gICAgICAgIHRoaXMuRyA9IFNIQTIyNF9JVls2XSB8IDA7XG4gICAgICAgIHRoaXMuSCA9IFNIQTIyNF9JVls3XSB8IDA7XG4gICAgfVxufVxuLy8gU0hBMi01MTIgaXMgc2xvd2VyIHRoYW4gc2hhMjU2IGluIGpzIGJlY2F1c2UgdTY0IG9wZXJhdGlvbnMgYXJlIHNsb3cuXG4vLyBSb3VuZCBjb250YW50c1xuLy8gRmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgY3ViZSByb290cyBvZiB0aGUgZmlyc3QgODAgcHJpbWVzIDIuLjQwOVxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBLNTEyID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB1NjQuc3BsaXQoW1xuICAgICcweDQyOGEyZjk4ZDcyOGFlMjInLCAnMHg3MTM3NDQ5MTIzZWY2NWNkJywgJzB4YjVjMGZiY2ZlYzRkM2IyZicsICcweGU5YjVkYmE1ODE4OWRiYmMnLFxuICAgICcweDM5NTZjMjViZjM0OGI1MzgnLCAnMHg1OWYxMTFmMWI2MDVkMDE5JywgJzB4OTIzZjgyYTRhZjE5NGY5YicsICcweGFiMWM1ZWQ1ZGE2ZDgxMTgnLFxuICAgICcweGQ4MDdhYTk4YTMwMzAyNDInLCAnMHgxMjgzNWIwMTQ1NzA2ZmJlJywgJzB4MjQzMTg1YmU0ZWU0YjI4YycsICcweDU1MGM3ZGMzZDVmZmI0ZTInLFxuICAgICcweDcyYmU1ZDc0ZjI3Yjg5NmYnLCAnMHg4MGRlYjFmZTNiMTY5NmIxJywgJzB4OWJkYzA2YTcyNWM3MTIzNScsICcweGMxOWJmMTc0Y2Y2OTI2OTQnLFxuICAgICcweGU0OWI2OWMxOWVmMTRhZDInLCAnMHhlZmJlNDc4NjM4NGYyNWUzJywgJzB4MGZjMTlkYzY4YjhjZDViNScsICcweDI0MGNhMWNjNzdhYzljNjUnLFxuICAgICcweDJkZTkyYzZmNTkyYjAyNzUnLCAnMHg0YTc0ODRhYTZlYTZlNDgzJywgJzB4NWNiMGE5ZGNiZDQxZmJkNCcsICcweDc2Zjk4OGRhODMxMTUzYjUnLFxuICAgICcweDk4M2U1MTUyZWU2NmRmYWInLCAnMHhhODMxYzY2ZDJkYjQzMjEwJywgJzB4YjAwMzI3Yzg5OGZiMjEzZicsICcweGJmNTk3ZmM3YmVlZjBlZTQnLFxuICAgICcweGM2ZTAwYmYzM2RhODhmYzInLCAnMHhkNWE3OTE0NzkzMGFhNzI1JywgJzB4MDZjYTYzNTFlMDAzODI2ZicsICcweDE0MjkyOTY3MGEwZTZlNzAnLFxuICAgICcweDI3YjcwYTg1NDZkMjJmZmMnLCAnMHgyZTFiMjEzODVjMjZjOTI2JywgJzB4NGQyYzZkZmM1YWM0MmFlZCcsICcweDUzMzgwZDEzOWQ5NWIzZGYnLFxuICAgICcweDY1MGE3MzU0OGJhZjYzZGUnLCAnMHg3NjZhMGFiYjNjNzdiMmE4JywgJzB4ODFjMmM5MmU0N2VkYWVlNicsICcweDkyNzIyYzg1MTQ4MjM1M2InLFxuICAgICcweGEyYmZlOGExNGNmMTAzNjQnLCAnMHhhODFhNjY0YmJjNDIzMDAxJywgJzB4YzI0YjhiNzBkMGY4OTc5MScsICcweGM3NmM1MWEzMDY1NGJlMzAnLFxuICAgICcweGQxOTJlODE5ZDZlZjUyMTgnLCAnMHhkNjk5MDYyNDU1NjVhOTEwJywgJzB4ZjQwZTM1ODU1NzcxMjAyYScsICcweDEwNmFhMDcwMzJiYmQxYjgnLFxuICAgICcweDE5YTRjMTE2YjhkMmQwYzgnLCAnMHgxZTM3NmMwODUxNDFhYjUzJywgJzB4Mjc0ODc3NGNkZjhlZWI5OScsICcweDM0YjBiY2I1ZTE5YjQ4YTgnLFxuICAgICcweDM5MWMwY2IzYzVjOTVhNjMnLCAnMHg0ZWQ4YWE0YWUzNDE4YWNiJywgJzB4NWI5Y2NhNGY3NzYzZTM3MycsICcweDY4MmU2ZmYzZDZiMmI4YTMnLFxuICAgICcweDc0OGY4MmVlNWRlZmIyZmMnLCAnMHg3OGE1NjM2ZjQzMTcyZjYwJywgJzB4ODRjODc4MTRhMWYwYWI3MicsICcweDhjYzcwMjA4MWE2NDM5ZWMnLFxuICAgICcweDkwYmVmZmZhMjM2MzFlMjgnLCAnMHhhNDUwNmNlYmRlODJiZGU5JywgJzB4YmVmOWEzZjdiMmM2NzkxNScsICcweGM2NzE3OGYyZTM3MjUzMmInLFxuICAgICcweGNhMjczZWNlZWEyNjYxOWMnLCAnMHhkMTg2YjhjNzIxYzBjMjA3JywgJzB4ZWFkYTdkZDZjZGUwZWIxZScsICcweGY1N2Q0ZjdmZWU2ZWQxNzgnLFxuICAgICcweDA2ZjA2N2FhNzIxNzZmYmEnLCAnMHgwYTYzN2RjNWEyYzg5OGE2JywgJzB4MTEzZjk4MDRiZWY5MGRhZScsICcweDFiNzEwYjM1MTMxYzQ3MWInLFxuICAgICcweDI4ZGI3N2Y1MjMwNDdkODQnLCAnMHgzMmNhYWI3YjQwYzcyNDkzJywgJzB4M2M5ZWJlMGExNWM5YmViYycsICcweDQzMWQ2N2M0OWMxMDBkNGMnLFxuICAgICcweDRjYzVkNGJlY2IzZTQyYjYnLCAnMHg1OTdmMjk5Y2ZjNjU3ZTJhJywgJzB4NWZjYjZmYWIzYWQ2ZmFlYycsICcweDZjNDQxOThjNGE0NzU4MTcnXG5dLm1hcChuID0+IEJpZ0ludChuKSkpKSgpO1xuY29uc3QgU0hBNTEyX0toID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBLNTEyWzBdKSgpO1xuY29uc3QgU0hBNTEyX0tsID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBLNTEyWzFdKSgpO1xuLy8gUmV1c2FibGUgdGVtcG9yYXJ5IGJ1ZmZlcnNcbmNvbnN0IFNIQTUxMl9XX0ggPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDgwKTtcbmNvbnN0IFNIQTUxMl9XX0wgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDgwKTtcbmV4cG9ydCBjbGFzcyBTSEE1MTIgZXh0ZW5kcyBIYXNoTUQge1xuICAgIGNvbnN0cnVjdG9yKG91dHB1dExlbiA9IDY0KSB7XG4gICAgICAgIHN1cGVyKDEyOCwgb3V0cHV0TGVuLCAxNiwgZmFsc2UpO1xuICAgICAgICAvLyBXZSBjYW5ub3QgdXNlIGFycmF5IGhlcmUgc2luY2UgYXJyYXkgYWxsb3dzIGluZGV4aW5nIGJ5IHZhcmlhYmxlXG4gICAgICAgIC8vIHdoaWNoIG1lYW5zIG9wdGltaXplci9jb21waWxlciBjYW5ub3QgdXNlIHJlZ2lzdGVycy5cbiAgICAgICAgLy8gaCAtLSBoaWdoIDMyIGJpdHMsIGwgLS0gbG93IDMyIGJpdHNcbiAgICAgICAgdGhpcy5BaCA9IFNIQTUxMl9JVlswXSB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSBTSEE1MTJfSVZbMV0gfCAwO1xuICAgICAgICB0aGlzLkJoID0gU0hBNTEyX0lWWzJdIHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IFNIQTUxMl9JVlszXSB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSBTSEE1MTJfSVZbNF0gfCAwO1xuICAgICAgICB0aGlzLkNsID0gU0hBNTEyX0lWWzVdIHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IFNIQTUxMl9JVls2XSB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSBTSEE1MTJfSVZbN10gfCAwO1xuICAgICAgICB0aGlzLkVoID0gU0hBNTEyX0lWWzhdIHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IFNIQTUxMl9JVls5XSB8IDA7XG4gICAgICAgIHRoaXMuRmggPSBTSEE1MTJfSVZbMTBdIHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IFNIQTUxMl9JVlsxMV0gfCAwO1xuICAgICAgICB0aGlzLkdoID0gU0hBNTEyX0lWWzEyXSB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSBTSEE1MTJfSVZbMTNdIHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IFNIQTUxMl9JVlsxNF0gfCAwO1xuICAgICAgICB0aGlzLkhsID0gU0hBNTEyX0lWWzE1XSB8IDA7XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgeyBBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFtBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbF07XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHNldChBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCkge1xuICAgICAgICB0aGlzLkFoID0gQWggfCAwO1xuICAgICAgICB0aGlzLkFsID0gQWwgfCAwO1xuICAgICAgICB0aGlzLkJoID0gQmggfCAwO1xuICAgICAgICB0aGlzLkJsID0gQmwgfCAwO1xuICAgICAgICB0aGlzLkNoID0gQ2ggfCAwO1xuICAgICAgICB0aGlzLkNsID0gQ2wgfCAwO1xuICAgICAgICB0aGlzLkRoID0gRGggfCAwO1xuICAgICAgICB0aGlzLkRsID0gRGwgfCAwO1xuICAgICAgICB0aGlzLkVoID0gRWggfCAwO1xuICAgICAgICB0aGlzLkVsID0gRWwgfCAwO1xuICAgICAgICB0aGlzLkZoID0gRmggfCAwO1xuICAgICAgICB0aGlzLkZsID0gRmwgfCAwO1xuICAgICAgICB0aGlzLkdoID0gR2ggfCAwO1xuICAgICAgICB0aGlzLkdsID0gR2wgfCAwO1xuICAgICAgICB0aGlzLkhoID0gSGggfCAwO1xuICAgICAgICB0aGlzLkhsID0gSGwgfCAwO1xuICAgIH1cbiAgICBwcm9jZXNzKHZpZXcsIG9mZnNldCkge1xuICAgICAgICAvLyBFeHRlbmQgdGhlIGZpcnN0IDE2IHdvcmRzIGludG8gdGhlIHJlbWFpbmluZyA2NCB3b3JkcyB3WzE2Li43OV0gb2YgdGhlIG1lc3NhZ2Ugc2NoZWR1bGUgYXJyYXlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNCkge1xuICAgICAgICAgICAgU0hBNTEyX1dfSFtpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCk7XG4gICAgICAgICAgICBTSEE1MTJfV19MW2ldID0gdmlldy5nZXRVaW50MzIoKG9mZnNldCArPSA0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDE2OyBpIDwgODA7IGkrKykge1xuICAgICAgICAgICAgLy8gczAgOj0gKHdbaS0xNV0gcmlnaHRyb3RhdGUgMSkgeG9yICh3W2ktMTVdIHJpZ2h0cm90YXRlIDgpIHhvciAod1tpLTE1XSByaWdodHNoaWZ0IDcpXG4gICAgICAgICAgICBjb25zdCBXMTVoID0gU0hBNTEyX1dfSFtpIC0gMTVdIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IFcxNWwgPSBTSEE1MTJfV19MW2kgLSAxNV0gfCAwO1xuICAgICAgICAgICAgY29uc3QgczBoID0gdTY0LnJvdHJTSChXMTVoLCBXMTVsLCAxKSBeIHU2NC5yb3RyU0goVzE1aCwgVzE1bCwgOCkgXiB1NjQuc2hyU0goVzE1aCwgVzE1bCwgNyk7XG4gICAgICAgICAgICBjb25zdCBzMGwgPSB1NjQucm90clNMKFcxNWgsIFcxNWwsIDEpIF4gdTY0LnJvdHJTTChXMTVoLCBXMTVsLCA4KSBeIHU2NC5zaHJTTChXMTVoLCBXMTVsLCA3KTtcbiAgICAgICAgICAgIC8vIHMxIDo9ICh3W2ktMl0gcmlnaHRyb3RhdGUgMTkpIHhvciAod1tpLTJdIHJpZ2h0cm90YXRlIDYxKSB4b3IgKHdbaS0yXSByaWdodHNoaWZ0IDYpXG4gICAgICAgICAgICBjb25zdCBXMmggPSBTSEE1MTJfV19IW2kgLSAyXSB8IDA7XG4gICAgICAgICAgICBjb25zdCBXMmwgPSBTSEE1MTJfV19MW2kgLSAyXSB8IDA7XG4gICAgICAgICAgICBjb25zdCBzMWggPSB1NjQucm90clNIKFcyaCwgVzJsLCAxOSkgXiB1NjQucm90ckJIKFcyaCwgVzJsLCA2MSkgXiB1NjQuc2hyU0goVzJoLCBXMmwsIDYpO1xuICAgICAgICAgICAgY29uc3QgczFsID0gdTY0LnJvdHJTTChXMmgsIFcybCwgMTkpIF4gdTY0LnJvdHJCTChXMmgsIFcybCwgNjEpIF4gdTY0LnNoclNMKFcyaCwgVzJsLCA2KTtcbiAgICAgICAgICAgIC8vIFNIQTI1Nl9XW2ldID0gczAgKyBzMSArIFNIQTI1Nl9XW2kgLSA3XSArIFNIQTI1Nl9XW2kgLSAxNl07XG4gICAgICAgICAgICBjb25zdCBTVU1sID0gdTY0LmFkZDRMKHMwbCwgczFsLCBTSEE1MTJfV19MW2kgLSA3XSwgU0hBNTEyX1dfTFtpIC0gMTZdKTtcbiAgICAgICAgICAgIGNvbnN0IFNVTWggPSB1NjQuYWRkNEgoU1VNbCwgczBoLCBzMWgsIFNIQTUxMl9XX0hbaSAtIDddLCBTSEE1MTJfV19IW2kgLSAxNl0pO1xuICAgICAgICAgICAgU0hBNTEyX1dfSFtpXSA9IFNVTWggfCAwO1xuICAgICAgICAgICAgU0hBNTEyX1dfTFtpXSA9IFNVTWwgfCAwO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IEFoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsIH0gPSB0aGlzO1xuICAgICAgICAvLyBDb21wcmVzc2lvbiBmdW5jdGlvbiBtYWluIGxvb3AsIDgwIHJvdW5kc1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDgwOyBpKyspIHtcbiAgICAgICAgICAgIC8vIFMxIDo9IChlIHJpZ2h0cm90YXRlIDE0KSB4b3IgKGUgcmlnaHRyb3RhdGUgMTgpIHhvciAoZSByaWdodHJvdGF0ZSA0MSlcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMWggPSB1NjQucm90clNIKEVoLCBFbCwgMTQpIF4gdTY0LnJvdHJTSChFaCwgRWwsIDE4KSBeIHU2NC5yb3RyQkgoRWgsIEVsLCA0MSk7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTFsID0gdTY0LnJvdHJTTChFaCwgRWwsIDE0KSBeIHU2NC5yb3RyU0woRWgsIEVsLCAxOCkgXiB1NjQucm90ckJMKEVoLCBFbCwgNDEpO1xuICAgICAgICAgICAgLy9jb25zdCBUMSA9IChIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBMjU2X0tbaV0gKyBTSEEyNTZfV1tpXSkgfCAwO1xuICAgICAgICAgICAgY29uc3QgQ0hJaCA9IChFaCAmIEZoKSBeICh+RWggJiBHaCk7XG4gICAgICAgICAgICBjb25zdCBDSElsID0gKEVsICYgRmwpIF4gKH5FbCAmIEdsKTtcbiAgICAgICAgICAgIC8vIFQxID0gSCArIHNpZ21hMSArIENoaShFLCBGLCBHKSArIFNIQTUxMl9LW2ldICsgU0hBNTEyX1dbaV1cbiAgICAgICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgVDFsbCA9IHU2NC5hZGQ1TChIbCwgc2lnbWExbCwgQ0hJbCwgU0hBNTEyX0tsW2ldLCBTSEE1MTJfV19MW2ldKTtcbiAgICAgICAgICAgIGNvbnN0IFQxaCA9IHU2NC5hZGQ1SChUMWxsLCBIaCwgc2lnbWExaCwgQ0hJaCwgU0hBNTEyX0toW2ldLCBTSEE1MTJfV19IW2ldKTtcbiAgICAgICAgICAgIGNvbnN0IFQxbCA9IFQxbGwgfCAwO1xuICAgICAgICAgICAgLy8gUzAgOj0gKGEgcmlnaHRyb3RhdGUgMjgpIHhvciAoYSByaWdodHJvdGF0ZSAzNCkgeG9yIChhIHJpZ2h0cm90YXRlIDM5KVxuICAgICAgICAgICAgY29uc3Qgc2lnbWEwaCA9IHU2NC5yb3RyU0goQWgsIEFsLCAyOCkgXiB1NjQucm90ckJIKEFoLCBBbCwgMzQpIF4gdTY0LnJvdHJCSChBaCwgQWwsIDM5KTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMGwgPSB1NjQucm90clNMKEFoLCBBbCwgMjgpIF4gdTY0LnJvdHJCTChBaCwgQWwsIDM0KSBeIHU2NC5yb3RyQkwoQWgsIEFsLCAzOSk7XG4gICAgICAgICAgICBjb25zdCBNQUpoID0gKEFoICYgQmgpIF4gKEFoICYgQ2gpIF4gKEJoICYgQ2gpO1xuICAgICAgICAgICAgY29uc3QgTUFKbCA9IChBbCAmIEJsKSBeIChBbCAmIENsKSBeIChCbCAmIENsKTtcbiAgICAgICAgICAgIEhoID0gR2ggfCAwO1xuICAgICAgICAgICAgSGwgPSBHbCB8IDA7XG4gICAgICAgICAgICBHaCA9IEZoIHwgMDtcbiAgICAgICAgICAgIEdsID0gRmwgfCAwO1xuICAgICAgICAgICAgRmggPSBFaCB8IDA7XG4gICAgICAgICAgICBGbCA9IEVsIHwgMDtcbiAgICAgICAgICAgICh7IGg6IEVoLCBsOiBFbCB9ID0gdTY0LmFkZChEaCB8IDAsIERsIHwgMCwgVDFoIHwgMCwgVDFsIHwgMCkpO1xuICAgICAgICAgICAgRGggPSBDaCB8IDA7XG4gICAgICAgICAgICBEbCA9IENsIHwgMDtcbiAgICAgICAgICAgIENoID0gQmggfCAwO1xuICAgICAgICAgICAgQ2wgPSBCbCB8IDA7XG4gICAgICAgICAgICBCaCA9IEFoIHwgMDtcbiAgICAgICAgICAgIEJsID0gQWwgfCAwO1xuICAgICAgICAgICAgY29uc3QgQWxsID0gdTY0LmFkZDNMKFQxbCwgc2lnbWEwbCwgTUFKbCk7XG4gICAgICAgICAgICBBaCA9IHU2NC5hZGQzSChBbGwsIFQxaCwgc2lnbWEwaCwgTUFKaCk7XG4gICAgICAgICAgICBBbCA9IEFsbCB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBjb21wcmVzc2VkIGNodW5rIHRvIHRoZSBjdXJyZW50IGhhc2ggdmFsdWVcbiAgICAgICAgKHsgaDogQWgsIGw6IEFsIH0gPSB1NjQuYWRkKHRoaXMuQWggfCAwLCB0aGlzLkFsIHwgMCwgQWggfCAwLCBBbCB8IDApKTtcbiAgICAgICAgKHsgaDogQmgsIGw6IEJsIH0gPSB1NjQuYWRkKHRoaXMuQmggfCAwLCB0aGlzLkJsIHwgMCwgQmggfCAwLCBCbCB8IDApKTtcbiAgICAgICAgKHsgaDogQ2gsIGw6IENsIH0gPSB1NjQuYWRkKHRoaXMuQ2ggfCAwLCB0aGlzLkNsIHwgMCwgQ2ggfCAwLCBDbCB8IDApKTtcbiAgICAgICAgKHsgaDogRGgsIGw6IERsIH0gPSB1NjQuYWRkKHRoaXMuRGggfCAwLCB0aGlzLkRsIHwgMCwgRGggfCAwLCBEbCB8IDApKTtcbiAgICAgICAgKHsgaDogRWgsIGw6IEVsIH0gPSB1NjQuYWRkKHRoaXMuRWggfCAwLCB0aGlzLkVsIHwgMCwgRWggfCAwLCBFbCB8IDApKTtcbiAgICAgICAgKHsgaDogRmgsIGw6IEZsIH0gPSB1NjQuYWRkKHRoaXMuRmggfCAwLCB0aGlzLkZsIHwgMCwgRmggfCAwLCBGbCB8IDApKTtcbiAgICAgICAgKHsgaDogR2gsIGw6IEdsIH0gPSB1NjQuYWRkKHRoaXMuR2ggfCAwLCB0aGlzLkdsIHwgMCwgR2ggfCAwLCBHbCB8IDApKTtcbiAgICAgICAgKHsgaDogSGgsIGw6IEhsIH0gPSB1NjQuYWRkKHRoaXMuSGggfCAwLCB0aGlzLkhsIHwgMCwgSGggfCAwLCBIbCB8IDApKTtcbiAgICAgICAgdGhpcy5zZXQoQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwpO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICBjbGVhbihTSEE1MTJfV19ILCBTSEE1MTJfV19MKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgY2xlYW4odGhpcy5idWZmZXIpO1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgU0hBMzg0IGV4dGVuZHMgU0hBNTEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoNDgpO1xuICAgICAgICB0aGlzLkFoID0gU0hBMzg0X0lWWzBdIHwgMDtcbiAgICAgICAgdGhpcy5BbCA9IFNIQTM4NF9JVlsxXSB8IDA7XG4gICAgICAgIHRoaXMuQmggPSBTSEEzODRfSVZbMl0gfCAwO1xuICAgICAgICB0aGlzLkJsID0gU0hBMzg0X0lWWzNdIHwgMDtcbiAgICAgICAgdGhpcy5DaCA9IFNIQTM4NF9JVls0XSB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSBTSEEzODRfSVZbNV0gfCAwO1xuICAgICAgICB0aGlzLkRoID0gU0hBMzg0X0lWWzZdIHwgMDtcbiAgICAgICAgdGhpcy5EbCA9IFNIQTM4NF9JVls3XSB8IDA7XG4gICAgICAgIHRoaXMuRWggPSBTSEEzODRfSVZbOF0gfCAwO1xuICAgICAgICB0aGlzLkVsID0gU0hBMzg0X0lWWzldIHwgMDtcbiAgICAgICAgdGhpcy5GaCA9IFNIQTM4NF9JVlsxMF0gfCAwO1xuICAgICAgICB0aGlzLkZsID0gU0hBMzg0X0lWWzExXSB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSBTSEEzODRfSVZbMTJdIHwgMDtcbiAgICAgICAgdGhpcy5HbCA9IFNIQTM4NF9JVlsxM10gfCAwO1xuICAgICAgICB0aGlzLkhoID0gU0hBMzg0X0lWWzE0XSB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSBTSEEzODRfSVZbMTVdIHwgMDtcbiAgICB9XG59XG4vKipcbiAqIFRydW5jYXRlZCBTSEE1MTIvMjU2IGFuZCBTSEE1MTIvMjI0LlxuICogU0hBNTEyX0lWIGlzIFhPUmVkIHdpdGggMHhhNWE1YTVhNWE1YTVhNWE1LCB0aGVuIHVzZWQgYXMgXCJpbnRlcm1lZGlhcnlcIiBJViBvZiBTSEE1MTIvdC5cbiAqIFRoZW4gdCBoYXNoZXMgc3RyaW5nIHRvIHByb2R1Y2UgcmVzdWx0IElWLlxuICogU2VlIGB0ZXN0L21pc2Mvc2hhMi1nZW4taXYuanNgLlxuICovXG4vKiogU0hBNTEyLzIyNCBJViAqL1xuY29uc3QgVDIyNF9JViA9IC8qIEBfX1BVUkVfXyAqLyBVaW50MzJBcnJheS5mcm9tKFtcbiAgICAweDhjM2QzN2M4LCAweDE5NTQ0ZGEyLCAweDczZTE5OTY2LCAweDg5ZGNkNGQ2LCAweDFkZmFiN2FlLCAweDMyZmY5YzgyLCAweDY3OWRkNTE0LCAweDU4MmY5ZmNmLFxuICAgIDB4MGY2ZDJiNjksIDB4N2JkNDRkYTgsIDB4NzdlMzZmNzMsIDB4MDRjNDg5NDIsIDB4M2Y5ZDg1YTgsIDB4NmExZDM2YzgsIDB4MTExMmU2YWQsIDB4OTFkNjkyYTEsXG5dKTtcbi8qKiBTSEE1MTIvMjU2IElWICovXG5jb25zdCBUMjU2X0lWID0gLyogQF9fUFVSRV9fICovIFVpbnQzMkFycmF5LmZyb20oW1xuICAgIDB4MjIzMTIxOTQsIDB4ZmMyYmY3MmMsIDB4OWY1NTVmYTMsIDB4Yzg0YzY0YzIsIDB4MjM5M2I4NmIsIDB4NmY1M2IxNTEsIDB4OTYzODc3MTksIDB4NTk0MGVhYmQsXG4gICAgMHg5NjI4M2VlMiwgMHhhODhlZmZlMywgMHhiZTVlMWUyNSwgMHg1Mzg2Mzk5MiwgMHgyYjAxOTlmYywgMHgyYzg1YjhhYSwgMHgwZWI3MmRkYywgMHg4MWM1MmNhMixcbl0pO1xuZXhwb3J0IGNsYXNzIFNIQTUxMl8yMjQgZXh0ZW5kcyBTSEE1MTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigyOCk7XG4gICAgICAgIHRoaXMuQWggPSBUMjI0X0lWWzBdIHwgMDtcbiAgICAgICAgdGhpcy5BbCA9IFQyMjRfSVZbMV0gfCAwO1xuICAgICAgICB0aGlzLkJoID0gVDIyNF9JVlsyXSB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSBUMjI0X0lWWzNdIHwgMDtcbiAgICAgICAgdGhpcy5DaCA9IFQyMjRfSVZbNF0gfCAwO1xuICAgICAgICB0aGlzLkNsID0gVDIyNF9JVls1XSB8IDA7XG4gICAgICAgIHRoaXMuRGggPSBUMjI0X0lWWzZdIHwgMDtcbiAgICAgICAgdGhpcy5EbCA9IFQyMjRfSVZbN10gfCAwO1xuICAgICAgICB0aGlzLkVoID0gVDIyNF9JVls4XSB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSBUMjI0X0lWWzldIHwgMDtcbiAgICAgICAgdGhpcy5GaCA9IFQyMjRfSVZbMTBdIHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IFQyMjRfSVZbMTFdIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IFQyMjRfSVZbMTJdIHwgMDtcbiAgICAgICAgdGhpcy5HbCA9IFQyMjRfSVZbMTNdIHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IFQyMjRfSVZbMTRdIHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IFQyMjRfSVZbMTVdIHwgMDtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgU0hBNTEyXzI1NiBleHRlbmRzIFNIQTUxMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDMyKTtcbiAgICAgICAgdGhpcy5BaCA9IFQyNTZfSVZbMF0gfCAwO1xuICAgICAgICB0aGlzLkFsID0gVDI1Nl9JVlsxXSB8IDA7XG4gICAgICAgIHRoaXMuQmggPSBUMjU2X0lWWzJdIHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IFQyNTZfSVZbM10gfCAwO1xuICAgICAgICB0aGlzLkNoID0gVDI1Nl9JVls0XSB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSBUMjU2X0lWWzVdIHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IFQyNTZfSVZbNl0gfCAwO1xuICAgICAgICB0aGlzLkRsID0gVDI1Nl9JVls3XSB8IDA7XG4gICAgICAgIHRoaXMuRWggPSBUMjU2X0lWWzhdIHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IFQyNTZfSVZbOV0gfCAwO1xuICAgICAgICB0aGlzLkZoID0gVDI1Nl9JVlsxMF0gfCAwO1xuICAgICAgICB0aGlzLkZsID0gVDI1Nl9JVlsxMV0gfCAwO1xuICAgICAgICB0aGlzLkdoID0gVDI1Nl9JVlsxMl0gfCAwO1xuICAgICAgICB0aGlzLkdsID0gVDI1Nl9JVlsxM10gfCAwO1xuICAgICAgICB0aGlzLkhoID0gVDI1Nl9JVlsxNF0gfCAwO1xuICAgICAgICB0aGlzLkhsID0gVDI1Nl9JVlsxNV0gfCAwO1xuICAgIH1cbn1cbi8qKlxuICogU0hBMi0yNTYgaGFzaCBmdW5jdGlvbiBmcm9tIFJGQyA0NjM0LlxuICpcbiAqIEl0IGlzIHRoZSBmYXN0ZXN0IEpTIGhhc2gsIGV2ZW4gZmFzdGVyIHRoYW4gQmxha2UzLlxuICogVG8gYnJlYWsgc2hhMjU2IHVzaW5nIGJpcnRoZGF5IGF0dGFjaywgYXR0YWNrZXJzIG5lZWQgdG8gdHJ5IDJeMTI4IGhhc2hlcy5cbiAqIEJUQyBuZXR3b3JrIGlzIGRvaW5nIDJeNzAgaGFzaGVzL3NlYyAoMl45NSBoYXNoZXMveWVhcikgYXMgcGVyIDIwMjUuXG4gKi9cbmV4cG9ydCBjb25zdCBzaGEyNTYgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlSGFzaGVyKCgpID0+IG5ldyBTSEEyNTYoKSk7XG4vKiogU0hBMi0yMjQgaGFzaCBmdW5jdGlvbiBmcm9tIFJGQyA0NjM0ICovXG5leHBvcnQgY29uc3Qgc2hhMjI0ID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUhhc2hlcigoKSA9PiBuZXcgU0hBMjI0KCkpO1xuLyoqIFNIQTItNTEyIGhhc2ggZnVuY3Rpb24gZnJvbSBSRkMgNDYzNC4gKi9cbmV4cG9ydCBjb25zdCBzaGE1MTIgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlSGFzaGVyKCgpID0+IG5ldyBTSEE1MTIoKSk7XG4vKiogU0hBMi0zODQgaGFzaCBmdW5jdGlvbiBmcm9tIFJGQyA0NjM0LiAqL1xuZXhwb3J0IGNvbnN0IHNoYTM4NCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVIYXNoZXIoKCkgPT4gbmV3IFNIQTM4NCgpKTtcbi8qKlxuICogU0hBMi01MTIvMjU2IFwidHJ1bmNhdGVkXCIgaGFzaCBmdW5jdGlvbiwgd2l0aCBpbXByb3ZlZCByZXNpc3RhbmNlIHRvIGxlbmd0aCBleHRlbnNpb24gYXR0YWNrcy5cbiAqIFNlZSB0aGUgcGFwZXIgb24gW3RydW5jYXRlZCBTSEE1MTJdKGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTAvNTQ4LnBkZikuXG4gKi9cbmV4cG9ydCBjb25zdCBzaGE1MTJfMjU2ID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUhhc2hlcigoKSA9PiBuZXcgU0hBNTEyXzI1NigpKTtcbi8qKlxuICogU0hBMi01MTIvMjI0IFwidHJ1bmNhdGVkXCIgaGFzaCBmdW5jdGlvbiwgd2l0aCBpbXByb3ZlZCByZXNpc3RhbmNlIHRvIGxlbmd0aCBleHRlbnNpb24gYXR0YWNrcy5cbiAqIFNlZSB0aGUgcGFwZXIgb24gW3RydW5jYXRlZCBTSEE1MTJdKGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTAvNTQ4LnBkZikuXG4gKi9cbmV4cG9ydCBjb25zdCBzaGE1MTJfMjI0ID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUhhc2hlcigoKSA9PiBuZXcgU0hBNTEyXzIyNCgpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYTIuanMubWFwIl0sIm5hbWVzIjpbIkNoaSIsIkhhc2hNRCIsIk1haiIsIlNIQTIyNF9JViIsIlNIQTI1Nl9JViIsIlNIQTM4NF9JViIsIlNIQTUxMl9JViIsInU2NCIsImNsZWFuIiwiY3JlYXRlSGFzaGVyIiwicm90ciIsIlNIQTI1Nl9LIiwiVWludDMyQXJyYXkiLCJmcm9tIiwiU0hBMjU2X1ciLCJTSEEyNTYiLCJjb25zdHJ1Y3RvciIsIm91dHB1dExlbiIsIkEiLCJCIiwiQyIsIkQiLCJFIiwiRiIsIkciLCJIIiwiZ2V0Iiwic2V0IiwicHJvY2VzcyIsInZpZXciLCJvZmZzZXQiLCJpIiwiZ2V0VWludDMyIiwiVzE1IiwiVzIiLCJzMCIsInMxIiwic2lnbWExIiwiVDEiLCJzaWdtYTAiLCJUMiIsInJvdW5kQ2xlYW4iLCJkZXN0cm95IiwiYnVmZmVyIiwiU0hBMjI0IiwiSzUxMiIsInNwbGl0IiwibWFwIiwibiIsIkJpZ0ludCIsIlNIQTUxMl9LaCIsIlNIQTUxMl9LbCIsIlNIQTUxMl9XX0giLCJTSEE1MTJfV19MIiwiU0hBNTEyIiwiQWgiLCJBbCIsIkJoIiwiQmwiLCJDaCIsIkNsIiwiRGgiLCJEbCIsIkVoIiwiRWwiLCJGaCIsIkZsIiwiR2giLCJHbCIsIkhoIiwiSGwiLCJXMTVoIiwiVzE1bCIsInMwaCIsInJvdHJTSCIsInNoclNIIiwiczBsIiwicm90clNMIiwic2hyU0wiLCJXMmgiLCJXMmwiLCJzMWgiLCJyb3RyQkgiLCJzMWwiLCJyb3RyQkwiLCJTVU1sIiwiYWRkNEwiLCJTVU1oIiwiYWRkNEgiLCJzaWdtYTFoIiwic2lnbWExbCIsIkNISWgiLCJDSElsIiwiVDFsbCIsImFkZDVMIiwiVDFoIiwiYWRkNUgiLCJUMWwiLCJzaWdtYTBoIiwic2lnbWEwbCIsIk1BSmgiLCJNQUpsIiwiaCIsImwiLCJhZGQiLCJBbGwiLCJhZGQzTCIsImFkZDNIIiwiU0hBMzg0IiwiVDIyNF9JViIsIlQyNTZfSVYiLCJTSEE1MTJfMjI0IiwiU0hBNTEyXzI1NiIsInNoYTI1NiIsInNoYTIyNCIsInNoYTUxMiIsInNoYTM4NCIsInNoYTUxMl8yNTYiLCJzaGE1MTJfMjI0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/sha2.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/sha256.js":
/*!******************************************************************!*\
  !*** ./node_modules/ox/node_modules/@noble/hashes/esm/sha256.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA224: () => (/* binding */ SHA224),\n/* harmony export */   SHA256: () => (/* binding */ SHA256),\n/* harmony export */   sha224: () => (/* binding */ sha224),\n/* harmony export */   sha256: () => (/* binding */ sha256)\n/* harmony export */ });\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sha2.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/sha2.js\");\n/**\n * SHA2-256 a.k.a. sha256. In JS, it is the fastest hash, even faster than Blake3.\n *\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n *\n * Check out [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n * @deprecated\n */ \n/** @deprecated Use import from `noble/hashes/sha2` module */ const SHA256 = _sha2_js__WEBPACK_IMPORTED_MODULE_0__.SHA256;\n/** @deprecated Use import from `noble/hashes/sha2` module */ const sha256 = _sha2_js__WEBPACK_IMPORTED_MODULE_0__.sha256;\n/** @deprecated Use import from `noble/hashes/sha2` module */ const SHA224 = _sha2_js__WEBPACK_IMPORTED_MODULE_0__.SHA224;\n/** @deprecated Use import from `noble/hashes/sha2` module */ const sha224 = _sha2_js__WEBPACK_IMPORTED_MODULE_0__.sha224; //# sourceMappingURL=sha256.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTI1Ni5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7Ozs7Ozs7Q0FTQyxHQUN1RztBQUN4RywyREFBMkQsR0FDcEQsTUFBTUksU0FBU0MsNENBQU9BLENBQUM7QUFDOUIsMkRBQTJELEdBQ3BELE1BQU1DLFNBQVNDLDRDQUFPQSxDQUFDO0FBQzlCLDJEQUEyRCxHQUNwRCxNQUFNUCxTQUFTQyw0Q0FBT0EsQ0FBQztBQUM5QiwyREFBMkQsR0FDcEQsTUFBTUMsU0FBU0MsNENBQU9BLENBQUMsQ0FDOUIsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xhdy13b3Jrcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhMjU2LmpzPzAyMGQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBTSEEyLTI1NiBhLmsuYS4gc2hhMjU2LiBJbiBKUywgaXQgaXMgdGhlIGZhc3Rlc3QgaGFzaCwgZXZlbiBmYXN0ZXIgdGhhbiBCbGFrZTMuXG4gKlxuICogVG8gYnJlYWsgc2hhMjU2IHVzaW5nIGJpcnRoZGF5IGF0dGFjaywgYXR0YWNrZXJzIG5lZWQgdG8gdHJ5IDJeMTI4IGhhc2hlcy5cbiAqIEJUQyBuZXR3b3JrIGlzIGRvaW5nIDJeNzAgaGFzaGVzL3NlYyAoMl45NSBoYXNoZXMveWVhcikgYXMgcGVyIDIwMjUuXG4gKlxuICogQ2hlY2sgb3V0IFtGSVBTIDE4MC00XShodHRwczovL252bHB1YnMubmlzdC5nb3YvbmlzdHB1YnMvRklQUy9OSVNULkZJUFMuMTgwLTQucGRmKS5cbiAqIEBtb2R1bGVcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmltcG9ydCB7IFNIQTIyNCBhcyBTSEEyMjRuLCBzaGEyMjQgYXMgc2hhMjI0biwgU0hBMjU2IGFzIFNIQTI1Nm4sIHNoYTI1NiBhcyBzaGEyNTZuLCB9IGZyb20gXCIuL3NoYTIuanNcIjtcbi8qKiBAZGVwcmVjYXRlZCBVc2UgaW1wb3J0IGZyb20gYG5vYmxlL2hhc2hlcy9zaGEyYCBtb2R1bGUgKi9cbmV4cG9ydCBjb25zdCBTSEEyNTYgPSBTSEEyNTZuO1xuLyoqIEBkZXByZWNhdGVkIFVzZSBpbXBvcnQgZnJvbSBgbm9ibGUvaGFzaGVzL3NoYTJgIG1vZHVsZSAqL1xuZXhwb3J0IGNvbnN0IHNoYTI1NiA9IHNoYTI1Nm47XG4vKiogQGRlcHJlY2F0ZWQgVXNlIGltcG9ydCBmcm9tIGBub2JsZS9oYXNoZXMvc2hhMmAgbW9kdWxlICovXG5leHBvcnQgY29uc3QgU0hBMjI0ID0gU0hBMjI0bjtcbi8qKiBAZGVwcmVjYXRlZCBVc2UgaW1wb3J0IGZyb20gYG5vYmxlL2hhc2hlcy9zaGEyYCBtb2R1bGUgKi9cbmV4cG9ydCBjb25zdCBzaGEyMjQgPSBzaGEyMjRuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhMjU2LmpzLm1hcCJdLCJuYW1lcyI6WyJTSEEyMjQiLCJTSEEyMjRuIiwic2hhMjI0Iiwic2hhMjI0biIsIlNIQTI1NiIsIlNIQTI1Nm4iLCJzaGEyNTYiLCJzaGEyNTZuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/sha256.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/sha3.js":
/*!****************************************************************!*\
  !*** ./node_modules/ox/node_modules/@noble/hashes/esm/sha3.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Keccak: () => (/* binding */ Keccak),\n/* harmony export */   keccakP: () => (/* binding */ keccakP),\n/* harmony export */   keccak_224: () => (/* binding */ keccak_224),\n/* harmony export */   keccak_256: () => (/* binding */ keccak_256),\n/* harmony export */   keccak_384: () => (/* binding */ keccak_384),\n/* harmony export */   keccak_512: () => (/* binding */ keccak_512),\n/* harmony export */   sha3_224: () => (/* binding */ sha3_224),\n/* harmony export */   sha3_256: () => (/* binding */ sha3_256),\n/* harmony export */   sha3_384: () => (/* binding */ sha3_384),\n/* harmony export */   sha3_512: () => (/* binding */ sha3_512),\n/* harmony export */   shake128: () => (/* binding */ shake128),\n/* harmony export */   shake256: () => (/* binding */ shake256)\n/* harmony export */ });\n/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_u64.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/_u64.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/utils.js\");\n/**\n * SHA3 (keccak) hash function, based on a new \"Sponge function\" design.\n * Different from older hashes, the internal state is bigger than output size.\n *\n * Check out [FIPS-202](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf),\n * [Website](https://keccak.team/keccak.html),\n * [the differences between SHA-3 and Keccak](https://crypto.stackexchange.com/questions/15727/what-are-the-key-differences-between-the-draft-sha-3-standard-and-the-keccak-sub).\n *\n * Check out `sha3-addons` module for cSHAKE, k12, and others.\n * @module\n */ \n// prettier-ignore\n\n// No __PURE__ annotations in sha3 header:\n// EVERYTHING is in fact used on every export.\n// Various per round constants calculations\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _7n = BigInt(7);\nconst _256n = BigInt(256);\nconst _0x71n = BigInt(0x71);\nconst SHA3_PI = [];\nconst SHA3_ROTL = [];\nconst _SHA3_IOTA = [];\nfor(let round = 0, R = _1n, x = 1, y = 0; round < 24; round++){\n    // Pi\n    [x, y] = [\n        y,\n        (2 * x + 3 * y) % 5\n    ];\n    SHA3_PI.push(2 * (5 * y + x));\n    // Rotational\n    SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);\n    // Iota\n    let t = _0n;\n    for(let j = 0; j < 7; j++){\n        R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;\n        if (R & _2n) t ^= _1n << (_1n << /* @__PURE__ */ BigInt(j)) - _1n;\n    }\n    _SHA3_IOTA.push(t);\n}\nconst IOTAS = (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.split)(_SHA3_IOTA, true);\nconst SHA3_IOTA_H = IOTAS[0];\nconst SHA3_IOTA_L = IOTAS[1];\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h, l, s)=>s > 32 ? (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlBH)(h, l, s) : (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlSH)(h, l, s);\nconst rotlL = (h, l, s)=>s > 32 ? (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlBL)(h, l, s) : (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlSL)(h, l, s);\n/** `keccakf1600` internal function, additionally allows to adjust round count. */ function keccakP(s, rounds = 24) {\n    const B = new Uint32Array(5 * 2);\n    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n    for(let round = 24 - rounds; round < 24; round++){\n        // Theta Œ∏\n        for(let x = 0; x < 10; x++)B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n        for(let x = 0; x < 10; x += 2){\n            const idx1 = (x + 8) % 10;\n            const idx0 = (x + 2) % 10;\n            const B0 = B[idx0];\n            const B1 = B[idx0 + 1];\n            const Th = rotlH(B0, B1, 1) ^ B[idx1];\n            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n            for(let y = 0; y < 50; y += 10){\n                s[x + y] ^= Th;\n                s[x + y + 1] ^= Tl;\n            }\n        }\n        // Rho (œÅ) and Pi (œÄ)\n        let curH = s[2];\n        let curL = s[3];\n        for(let t = 0; t < 24; t++){\n            const shift = SHA3_ROTL[t];\n            const Th = rotlH(curH, curL, shift);\n            const Tl = rotlL(curH, curL, shift);\n            const PI = SHA3_PI[t];\n            curH = s[PI];\n            curL = s[PI + 1];\n            s[PI] = Th;\n            s[PI + 1] = Tl;\n        }\n        // Chi (œá)\n        for(let y = 0; y < 50; y += 10){\n            for(let x = 0; x < 10; x++)B[x] = s[y + x];\n            for(let x = 0; x < 10; x++)s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n        }\n        // Iota (Œπ)\n        s[0] ^= SHA3_IOTA_H[round];\n        s[1] ^= SHA3_IOTA_L[round];\n    }\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(B);\n}\n/** Keccak sponge function. */ class Keccak extends _utils_js__WEBPACK_IMPORTED_MODULE_1__.Hash {\n    // NOTE: we accept arguments in bytes instead of bits here.\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24){\n        super();\n        this.pos = 0;\n        this.posOut = 0;\n        this.finished = false;\n        this.destroyed = false;\n        this.enableXOF = false;\n        this.blockLen = blockLen;\n        this.suffix = suffix;\n        this.outputLen = outputLen;\n        this.enableXOF = enableXOF;\n        this.rounds = rounds;\n        // Can be passed from user as dkLen\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.anumber)(outputLen);\n        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n        // 0 < blockLen < 200\n        if (!(0 < blockLen && blockLen < 200)) throw new Error(\"only keccak-f1600 function is supported\");\n        this.state = new Uint8Array(200);\n        this.state32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(this.state);\n    }\n    clone() {\n        return this._cloneInto();\n    }\n    keccak() {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.swap32IfBE)(this.state32);\n        keccakP(this.state32, this.rounds);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.swap32IfBE)(this.state32);\n        this.posOut = 0;\n        this.pos = 0;\n    }\n    update(data) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.aexists)(this);\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(data);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.abytes)(data);\n        const { blockLen, state } = this;\n        const len = data.length;\n        for(let pos = 0; pos < len;){\n            const take = Math.min(blockLen - this.pos, len - pos);\n            for(let i = 0; i < take; i++)state[this.pos++] ^= data[pos++];\n            if (this.pos === blockLen) this.keccak();\n        }\n        return this;\n    }\n    finish() {\n        if (this.finished) return;\n        this.finished = true;\n        const { state, suffix, pos, blockLen } = this;\n        // Do the padding\n        state[pos] ^= suffix;\n        if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();\n        state[blockLen - 1] ^= 0x80;\n        this.keccak();\n    }\n    writeInto(out) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.aexists)(this, false);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.abytes)(out);\n        this.finish();\n        const bufferOut = this.state;\n        const { blockLen } = this;\n        for(let pos = 0, len = out.length; pos < len;){\n            if (this.posOut >= blockLen) this.keccak();\n            const take = Math.min(blockLen - this.posOut, len - pos);\n            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n            this.posOut += take;\n            pos += take;\n        }\n        return out;\n    }\n    xofInto(out) {\n        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n        if (!this.enableXOF) throw new Error(\"XOF is not possible for this instance\");\n        return this.writeInto(out);\n    }\n    xof(bytes) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.anumber)(bytes);\n        return this.xofInto(new Uint8Array(bytes));\n    }\n    digestInto(out) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.aoutput)(out, this);\n        if (this.finished) throw new Error(\"digest() was already called\");\n        this.writeInto(out);\n        this.destroy();\n        return out;\n    }\n    digest() {\n        return this.digestInto(new Uint8Array(this.outputLen));\n    }\n    destroy() {\n        this.destroyed = true;\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(this.state);\n    }\n    _cloneInto(to) {\n        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n        to.state32.set(this.state32);\n        to.pos = this.pos;\n        to.posOut = this.posOut;\n        to.finished = this.finished;\n        to.rounds = rounds;\n        // Suffix can change in cSHAKE\n        to.suffix = suffix;\n        to.outputLen = outputLen;\n        to.enableXOF = enableXOF;\n        to.destroyed = this.destroyed;\n        return to;\n    }\n}\nconst gen = (suffix, blockLen, outputLen)=>(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(()=>new Keccak(blockLen, suffix, outputLen));\n/** SHA3-224 hash function. */ const sha3_224 = /* @__PURE__ */ (()=>gen(0x06, 144, 224 / 8))();\n/** SHA3-256 hash function. Different from keccak-256. */ const sha3_256 = /* @__PURE__ */ (()=>gen(0x06, 136, 256 / 8))();\n/** SHA3-384 hash function. */ const sha3_384 = /* @__PURE__ */ (()=>gen(0x06, 104, 384 / 8))();\n/** SHA3-512 hash function. */ const sha3_512 = /* @__PURE__ */ (()=>gen(0x06, 72, 512 / 8))();\n/** keccak-224 hash function. */ const keccak_224 = /* @__PURE__ */ (()=>gen(0x01, 144, 224 / 8))();\n/** keccak-256 hash function. Different from SHA3-256. */ const keccak_256 = /* @__PURE__ */ (()=>gen(0x01, 136, 256 / 8))();\n/** keccak-384 hash function. */ const keccak_384 = /* @__PURE__ */ (()=>gen(0x01, 104, 384 / 8))();\n/** keccak-512 hash function. */ const keccak_512 = /* @__PURE__ */ (()=>gen(0x01, 72, 512 / 8))();\nconst genShake = (suffix, blockLen, outputLen)=>(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createXOFer)((opts = {})=>new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));\n/** SHAKE128 XOF with 128-bit security. */ const shake128 = /* @__PURE__ */ (()=>genShake(0x1f, 168, 128 / 8))();\n/** SHAKE256 XOF with 256-bit security. */ const shake256 = /* @__PURE__ */ (()=>genShake(0x1f, 136, 256 / 8))(); //# sourceMappingURL=sha3.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7OztDQVVDLEdBQ2lFO0FBQ2xFLGtCQUFrQjtBQUMrRztBQUNqSSwwQ0FBMEM7QUFDMUMsOENBQThDO0FBQzlDLDJDQUEyQztBQUMzQyxNQUFNZ0IsTUFBTUMsT0FBTztBQUNuQixNQUFNQyxNQUFNRCxPQUFPO0FBQ25CLE1BQU1FLE1BQU1GLE9BQU87QUFDbkIsTUFBTUcsTUFBTUgsT0FBTztBQUNuQixNQUFNSSxRQUFRSixPQUFPO0FBQ3JCLE1BQU1LLFNBQVNMLE9BQU87QUFDdEIsTUFBTU0sVUFBVSxFQUFFO0FBQ2xCLE1BQU1DLFlBQVksRUFBRTtBQUNwQixNQUFNQyxhQUFhLEVBQUU7QUFDckIsSUFBSyxJQUFJQyxRQUFRLEdBQUdDLElBQUlULEtBQUtVLElBQUksR0FBR0MsSUFBSSxHQUFHSCxRQUFRLElBQUlBLFFBQVM7SUFDNUQsS0FBSztJQUNMLENBQUNFLEdBQUdDLEVBQUUsR0FBRztRQUFDQTtRQUFJLEtBQUlELElBQUksSUFBSUMsQ0FBQUEsSUFBSztLQUFFO0lBQ2pDTixRQUFRTyxJQUFJLENBQUMsSUFBSyxLQUFJRCxJQUFJRCxDQUFBQTtJQUMxQixhQUFhO0lBQ2JKLFVBQVVNLElBQUksQ0FBQyxDQUFHSixRQUFRLEtBQU1BLENBQUFBLFFBQVEsS0FBTSxJQUFLO0lBQ25ELE9BQU87SUFDUCxJQUFJSyxJQUFJZjtJQUNSLElBQUssSUFBSWdCLElBQUksR0FBR0EsSUFBSSxHQUFHQSxJQUFLO1FBQ3hCTCxJQUFJLENBQUMsS0FBTVQsTUFBUSxDQUFDUyxLQUFLUCxHQUFFLElBQUtFLE1BQU0sSUFBS0Q7UUFDM0MsSUFBSU0sSUFBSVIsS0FDSlksS0FBS2IsT0FBUSxDQUFDQSxPQUFPLGFBQWEsR0FBR0QsT0FBT2UsRUFBQyxJQUFLZDtJQUMxRDtJQUNBTyxX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ZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhMy5qcz81YjQ3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogU0hBMyAoa2VjY2FrKSBoYXNoIGZ1bmN0aW9uLCBiYXNlZCBvbiBhIG5ldyBcIlNwb25nZSBmdW5jdGlvblwiIGRlc2lnbi5cbiAqIERpZmZlcmVudCBmcm9tIG9sZGVyIGhhc2hlcywgdGhlIGludGVybmFsIHN0YXRlIGlzIGJpZ2dlciB0aGFuIG91dHB1dCBzaXplLlxuICpcbiAqIENoZWNrIG91dCBbRklQUy0yMDJdKGh0dHBzOi8vbnZscHVicy5uaXN0Lmdvdi9uaXN0cHVicy9GSVBTL05JU1QuRklQUy4yMDIucGRmKSxcbiAqIFtXZWJzaXRlXShodHRwczovL2tlY2Nhay50ZWFtL2tlY2Nhay5odG1sKSxcbiAqIFt0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBTSEEtMyBhbmQgS2VjY2FrXShodHRwczovL2NyeXB0by5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvMTU3Mjcvd2hhdC1hcmUtdGhlLWtleS1kaWZmZXJlbmNlcy1iZXR3ZWVuLXRoZS1kcmFmdC1zaGEtMy1zdGFuZGFyZC1hbmQtdGhlLWtlY2Nhay1zdWIpLlxuICpcbiAqIENoZWNrIG91dCBgc2hhMy1hZGRvbnNgIG1vZHVsZSBmb3IgY1NIQUtFLCBrMTIsIGFuZCBvdGhlcnMuXG4gKiBAbW9kdWxlXG4gKi9cbmltcG9ydCB7IHJvdGxCSCwgcm90bEJMLCByb3RsU0gsIHJvdGxTTCwgc3BsaXQgfSBmcm9tIFwiLi9fdTY0LmpzXCI7XG4vLyBwcmV0dGllci1pZ25vcmVcbmltcG9ydCB7IGFieXRlcywgYWV4aXN0cywgYW51bWJlciwgYW91dHB1dCwgY2xlYW4sIGNyZWF0ZUhhc2hlciwgY3JlYXRlWE9GZXIsIEhhc2gsIHN3YXAzMklmQkUsIHRvQnl0ZXMsIHUzMiB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG4vLyBObyBfX1BVUkVfXyBhbm5vdGF0aW9ucyBpbiBzaGEzIGhlYWRlcjpcbi8vIEVWRVJZVEhJTkcgaXMgaW4gZmFjdCB1c2VkIG9uIGV2ZXJ5IGV4cG9ydC5cbi8vIFZhcmlvdXMgcGVyIHJvdW5kIGNvbnN0YW50cyBjYWxjdWxhdGlvbnNcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IEJpZ0ludCgyKTtcbmNvbnN0IF83biA9IEJpZ0ludCg3KTtcbmNvbnN0IF8yNTZuID0gQmlnSW50KDI1Nik7XG5jb25zdCBfMHg3MW4gPSBCaWdJbnQoMHg3MSk7XG5jb25zdCBTSEEzX1BJID0gW107XG5jb25zdCBTSEEzX1JPVEwgPSBbXTtcbmNvbnN0IF9TSEEzX0lPVEEgPSBbXTtcbmZvciAobGV0IHJvdW5kID0gMCwgUiA9IF8xbiwgeCA9IDEsIHkgPSAwOyByb3VuZCA8IDI0OyByb3VuZCsrKSB7XG4gICAgLy8gUGlcbiAgICBbeCwgeV0gPSBbeSwgKDIgKiB4ICsgMyAqIHkpICUgNV07XG4gICAgU0hBM19QSS5wdXNoKDIgKiAoNSAqIHkgKyB4KSk7XG4gICAgLy8gUm90YXRpb25hbFxuICAgIFNIQTNfUk9UTC5wdXNoKCgoKHJvdW5kICsgMSkgKiAocm91bmQgKyAyKSkgLyAyKSAlIDY0KTtcbiAgICAvLyBJb3RhXG4gICAgbGV0IHQgPSBfMG47XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCA3OyBqKyspIHtcbiAgICAgICAgUiA9ICgoUiA8PCBfMW4pIF4gKChSID4+IF83bikgKiBfMHg3MW4pKSAlIF8yNTZuO1xuICAgICAgICBpZiAoUiAmIF8ybilcbiAgICAgICAgICAgIHQgXj0gXzFuIDw8ICgoXzFuIDw8IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoaikpIC0gXzFuKTtcbiAgICB9XG4gICAgX1NIQTNfSU9UQS5wdXNoKHQpO1xufVxuY29uc3QgSU9UQVMgPSBzcGxpdChfU0hBM19JT1RBLCB0cnVlKTtcbmNvbnN0IFNIQTNfSU9UQV9IID0gSU9UQVNbMF07XG5jb25zdCBTSEEzX0lPVEFfTCA9IElPVEFTWzFdO1xuLy8gTGVmdCByb3RhdGlvbiAod2l0aG91dCAwLCAzMiwgNjQpXG5jb25zdCByb3RsSCA9IChoLCBsLCBzKSA9PiAocyA+IDMyID8gcm90bEJIKGgsIGwsIHMpIDogcm90bFNIKGgsIGwsIHMpKTtcbmNvbnN0IHJvdGxMID0gKGgsIGwsIHMpID0+IChzID4gMzIgPyByb3RsQkwoaCwgbCwgcykgOiByb3RsU0woaCwgbCwgcykpO1xuLyoqIGBrZWNjYWtmMTYwMGAgaW50ZXJuYWwgZnVuY3Rpb24sIGFkZGl0aW9uYWxseSBhbGxvd3MgdG8gYWRqdXN0IHJvdW5kIGNvdW50LiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGtlY2Nha1Aocywgcm91bmRzID0gMjQpIHtcbiAgICBjb25zdCBCID0gbmV3IFVpbnQzMkFycmF5KDUgKiAyKTtcbiAgICAvLyBOT1RFOiBhbGwgaW5kaWNlcyBhcmUgeDIgc2luY2Ugd2Ugc3RvcmUgc3RhdGUgYXMgdTMyIGluc3RlYWQgb2YgdTY0IChiaWdpbnRzIHRvIHNsb3cgaW4ganMpXG4gICAgZm9yIChsZXQgcm91bmQgPSAyNCAtIHJvdW5kczsgcm91bmQgPCAyNDsgcm91bmQrKykge1xuICAgICAgICAvLyBUaGV0YSDOuFxuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4KyspXG4gICAgICAgICAgICBCW3hdID0gc1t4XSBeIHNbeCArIDEwXSBeIHNbeCArIDIwXSBeIHNbeCArIDMwXSBeIHNbeCArIDQwXTtcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCArPSAyKSB7XG4gICAgICAgICAgICBjb25zdCBpZHgxID0gKHggKyA4KSAlIDEwO1xuICAgICAgICAgICAgY29uc3QgaWR4MCA9ICh4ICsgMikgJSAxMDtcbiAgICAgICAgICAgIGNvbnN0IEIwID0gQltpZHgwXTtcbiAgICAgICAgICAgIGNvbnN0IEIxID0gQltpZHgwICsgMV07XG4gICAgICAgICAgICBjb25zdCBUaCA9IHJvdGxIKEIwLCBCMSwgMSkgXiBCW2lkeDFdO1xuICAgICAgICAgICAgY29uc3QgVGwgPSByb3RsTChCMCwgQjEsIDEpIF4gQltpZHgxICsgMV07XG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IDUwOyB5ICs9IDEwKSB7XG4gICAgICAgICAgICAgICAgc1t4ICsgeV0gXj0gVGg7XG4gICAgICAgICAgICAgICAgc1t4ICsgeSArIDFdIF49IFRsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFJobyAoz4EpIGFuZCBQaSAoz4ApXG4gICAgICAgIGxldCBjdXJIID0gc1syXTtcbiAgICAgICAgbGV0IGN1ckwgPSBzWzNdO1xuICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IDI0OyB0KyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNoaWZ0ID0gU0hBM19ST1RMW3RdO1xuICAgICAgICAgICAgY29uc3QgVGggPSByb3RsSChjdXJILCBjdXJMLCBzaGlmdCk7XG4gICAgICAgICAgICBjb25zdCBUbCA9IHJvdGxMKGN1ckgsIGN1ckwsIHNoaWZ0KTtcbiAgICAgICAgICAgIGNvbnN0IFBJID0gU0hBM19QSVt0XTtcbiAgICAgICAgICAgIGN1ckggPSBzW1BJXTtcbiAgICAgICAgICAgIGN1ckwgPSBzW1BJICsgMV07XG4gICAgICAgICAgICBzW1BJXSA9IFRoO1xuICAgICAgICAgICAgc1tQSSArIDFdID0gVGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hpICjPhylcbiAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCA1MDsgeSArPSAxMCkge1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCsrKVxuICAgICAgICAgICAgICAgIEJbeF0gPSBzW3kgKyB4XTtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHgrKylcbiAgICAgICAgICAgICAgICBzW3kgKyB4XSBePSB+QlsoeCArIDIpICUgMTBdICYgQlsoeCArIDQpICUgMTBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIElvdGEgKM65KVxuICAgICAgICBzWzBdIF49IFNIQTNfSU9UQV9IW3JvdW5kXTtcbiAgICAgICAgc1sxXSBePSBTSEEzX0lPVEFfTFtyb3VuZF07XG4gICAgfVxuICAgIGNsZWFuKEIpO1xufVxuLyoqIEtlY2NhayBzcG9uZ2UgZnVuY3Rpb24uICovXG5leHBvcnQgY2xhc3MgS2VjY2FrIGV4dGVuZHMgSGFzaCB7XG4gICAgLy8gTk9URTogd2UgYWNjZXB0IGFyZ3VtZW50cyBpbiBieXRlcyBpbnN0ZWFkIG9mIGJpdHMgaGVyZS5cbiAgICBjb25zdHJ1Y3RvcihibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4sIGVuYWJsZVhPRiA9IGZhbHNlLCByb3VuZHMgPSAyNCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMucG9zT3V0ID0gMDtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVuYWJsZVhPRiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRoaXMuc3VmZml4ID0gc3VmZml4O1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdGhpcy5lbmFibGVYT0YgPSBlbmFibGVYT0Y7XG4gICAgICAgIHRoaXMucm91bmRzID0gcm91bmRzO1xuICAgICAgICAvLyBDYW4gYmUgcGFzc2VkIGZyb20gdXNlciBhcyBka0xlblxuICAgICAgICBhbnVtYmVyKG91dHB1dExlbik7XG4gICAgICAgIC8vIDE2MDAgPSA1eDUgbWF0cml4IG9mIDY0Yml0LiAgMTYwMCBiaXRzID09PSAyMDAgYnl0ZXNcbiAgICAgICAgLy8gMCA8IGJsb2NrTGVuIDwgMjAwXG4gICAgICAgIGlmICghKDAgPCBibG9ja0xlbiAmJiBibG9ja0xlbiA8IDIwMCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29ubHkga2VjY2FrLWYxNjAwIGZ1bmN0aW9uIGlzIHN1cHBvcnRlZCcpO1xuICAgICAgICB0aGlzLnN0YXRlID0gbmV3IFVpbnQ4QXJyYXkoMjAwKTtcbiAgICAgICAgdGhpcy5zdGF0ZTMyID0gdTMyKHRoaXMuc3RhdGUpO1xuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb25lSW50bygpO1xuICAgIH1cbiAgICBrZWNjYWsoKSB7XG4gICAgICAgIHN3YXAzMklmQkUodGhpcy5zdGF0ZTMyKTtcbiAgICAgICAga2VjY2FrUCh0aGlzLnN0YXRlMzIsIHRoaXMucm91bmRzKTtcbiAgICAgICAgc3dhcDMySWZCRSh0aGlzLnN0YXRlMzIpO1xuICAgICAgICB0aGlzLnBvc091dCA9IDA7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICB9XG4gICAgdXBkYXRlKGRhdGEpIHtcbiAgICAgICAgYWV4aXN0cyh0aGlzKTtcbiAgICAgICAgZGF0YSA9IHRvQnl0ZXMoZGF0YSk7XG4gICAgICAgIGFieXRlcyhkYXRhKTtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiwgc3RhdGUgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvcywgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFrZTsgaSsrKVxuICAgICAgICAgICAgICAgIHN0YXRlW3RoaXMucG9zKytdIF49IGRhdGFbcG9zKytdO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBmaW5pc2goKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbmlzaGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgeyBzdGF0ZSwgc3VmZml4LCBwb3MsIGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICAvLyBEbyB0aGUgcGFkZGluZ1xuICAgICAgICBzdGF0ZVtwb3NdIF49IHN1ZmZpeDtcbiAgICAgICAgaWYgKChzdWZmaXggJiAweDgwKSAhPT0gMCAmJiBwb3MgPT09IGJsb2NrTGVuIC0gMSlcbiAgICAgICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgICAgIHN0YXRlW2Jsb2NrTGVuIC0gMV0gXj0gMHg4MDtcbiAgICAgICAgdGhpcy5rZWNjYWsoKTtcbiAgICB9XG4gICAgd3JpdGVJbnRvKG91dCkge1xuICAgICAgICBhZXhpc3RzKHRoaXMsIGZhbHNlKTtcbiAgICAgICAgYWJ5dGVzKG91dCk7XG4gICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlck91dCA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4gfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDAsIGxlbiA9IG91dC5sZW5ndGg7IHBvcyA8IGxlbjspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvc091dCA+PSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3NPdXQsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICBvdXQuc2V0KGJ1ZmZlck91dC5zdWJhcnJheSh0aGlzLnBvc091dCwgdGhpcy5wb3NPdXQgKyB0YWtlKSwgcG9zKTtcbiAgICAgICAgICAgIHRoaXMucG9zT3V0ICs9IHRha2U7XG4gICAgICAgICAgICBwb3MgKz0gdGFrZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICB4b2ZJbnRvKG91dCkge1xuICAgICAgICAvLyBTaGEzL0tlY2NhayB1c2FnZSB3aXRoIFhPRiBpcyBwcm9iYWJseSBtaXN0YWtlLCBvbmx5IFNIQUtFIGluc3RhbmNlcyBjYW4gZG8gWE9GXG4gICAgICAgIGlmICghdGhpcy5lbmFibGVYT0YpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1hPRiBpcyBub3QgcG9zc2libGUgZm9yIHRoaXMgaW5zdGFuY2UnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVJbnRvKG91dCk7XG4gICAgfVxuICAgIHhvZihieXRlcykge1xuICAgICAgICBhbnVtYmVyKGJ5dGVzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMueG9mSW50byhuZXcgVWludDhBcnJheShieXRlcykpO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBhb3V0cHV0KG91dCwgdGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmZpbmlzaGVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaWdlc3QoKSB3YXMgYWxyZWFkeSBjYWxsZWQnKTtcbiAgICAgICAgdGhpcy53cml0ZUludG8ob3V0KTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlnZXN0SW50byhuZXcgVWludDhBcnJheSh0aGlzLm91dHB1dExlbikpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIGNsZWFuKHRoaXMuc3RhdGUpO1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuLCByb3VuZHMsIGVuYWJsZVhPRiB9ID0gdGhpcztcbiAgICAgICAgdG8gfHwgKHRvID0gbmV3IEtlY2NhayhibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4sIGVuYWJsZVhPRiwgcm91bmRzKSk7XG4gICAgICAgIHRvLnN0YXRlMzIuc2V0KHRoaXMuc3RhdGUzMik7XG4gICAgICAgIHRvLnBvcyA9IHRoaXMucG9zO1xuICAgICAgICB0by5wb3NPdXQgPSB0aGlzLnBvc091dDtcbiAgICAgICAgdG8uZmluaXNoZWQgPSB0aGlzLmZpbmlzaGVkO1xuICAgICAgICB0by5yb3VuZHMgPSByb3VuZHM7XG4gICAgICAgIC8vIFN1ZmZpeCBjYW4gY2hhbmdlIGluIGNTSEFLRVxuICAgICAgICB0by5zdWZmaXggPSBzdWZmaXg7XG4gICAgICAgIHRvLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdG8uZW5hYmxlWE9GID0gZW5hYmxlWE9GO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSB0aGlzLmRlc3Ryb3llZDtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbn1cbmNvbnN0IGdlbiA9IChzdWZmaXgsIGJsb2NrTGVuLCBvdXRwdXRMZW4pID0+IGNyZWF0ZUhhc2hlcigoKSA9PiBuZXcgS2VjY2FrKGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbikpO1xuLyoqIFNIQTMtMjI0IGhhc2ggZnVuY3Rpb24uICovXG5leHBvcnQgY29uc3Qgc2hhM18yMjQgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGdlbigweDA2LCAxNDQsIDIyNCAvIDgpKSgpO1xuLyoqIFNIQTMtMjU2IGhhc2ggZnVuY3Rpb24uIERpZmZlcmVudCBmcm9tIGtlY2Nhay0yNTYuICovXG5leHBvcnQgY29uc3Qgc2hhM18yNTYgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGdlbigweDA2LCAxMzYsIDI1NiAvIDgpKSgpO1xuLyoqIFNIQTMtMzg0IGhhc2ggZnVuY3Rpb24uICovXG5leHBvcnQgY29uc3Qgc2hhM18zODQgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGdlbigweDA2LCAxMDQsIDM4NCAvIDgpKSgpO1xuLyoqIFNIQTMtNTEyIGhhc2ggZnVuY3Rpb24uICovXG5leHBvcnQgY29uc3Qgc2hhM181MTIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGdlbigweDA2LCA3MiwgNTEyIC8gOCkpKCk7XG4vKioga2VjY2FrLTIyNCBoYXNoIGZ1bmN0aW9uLiAqL1xuZXhwb3J0IGNvbnN0IGtlY2Nha18yMjQgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGdlbigweDAxLCAxNDQsIDIyNCAvIDgpKSgpO1xuLyoqIGtlY2Nhay0yNTYgaGFzaCBmdW5jdGlvbi4gRGlmZmVyZW50IGZyb20gU0hBMy0yNTYuICovXG5leHBvcnQgY29uc3Qga2VjY2FrXzI1NiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gZ2VuKDB4MDEsIDEzNiwgMjU2IC8gOCkpKCk7XG4vKioga2VjY2FrLTM4NCBoYXNoIGZ1bmN0aW9uLiAqL1xuZXhwb3J0IGNvbnN0IGtlY2Nha18zODQgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGdlbigweDAxLCAxMDQsIDM4NCAvIDgpKSgpO1xuLyoqIGtlY2Nhay01MTIgaGFzaCBmdW5jdGlvbi4gKi9cbmV4cG9ydCBjb25zdCBrZWNjYWtfNTEyID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBnZW4oMHgwMSwgNzIsIDUxMiAvIDgpKSgpO1xuY29uc3QgZ2VuU2hha2UgPSAoc3VmZml4LCBibG9ja0xlbiwgb3V0cHV0TGVuKSA9PiBjcmVhdGVYT0Zlcigob3B0cyA9IHt9KSA9PiBuZXcgS2VjY2FrKGJsb2NrTGVuLCBzdWZmaXgsIG9wdHMuZGtMZW4gPT09IHVuZGVmaW5lZCA/IG91dHB1dExlbiA6IG9wdHMuZGtMZW4sIHRydWUpKTtcbi8qKiBTSEFLRTEyOCBYT0Ygd2l0aCAxMjgtYml0IHNlY3VyaXR5LiAqL1xuZXhwb3J0IGNvbnN0IHNoYWtlMTI4ID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBnZW5TaGFrZSgweDFmLCAxNjgsIDEyOCAvIDgpKSgpO1xuLyoqIFNIQUtFMjU2IFhPRiB3aXRoIDI1Ni1iaXQgc2VjdXJpdHkuICovXG5leHBvcnQgY29uc3Qgc2hha2UyNTYgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGdlblNoYWtlKDB4MWYsIDEzNiwgMjU2IC8gOCkpKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEzLmpzLm1hcCJdLCJuYW1lcyI6WyJyb3RsQkgiLCJyb3RsQkwiLCJyb3RsU0giLCJyb3RsU0wiLCJzcGxpdCIsImFieXRlcyIsImFleGlzdHMiLCJhbnVtYmVyIiwiYW91dHB1dCIsImNsZWFuIiwiY3JlYXRlSGFzaGVyIiwiY3JlYXRlWE9GZXIiLCJIYXNoIiwic3dhcDMySWZCRSIsInRvQnl0ZXMiLCJ1MzIiLCJfMG4iLCJCaWdJbnQiLCJfMW4iLCJfMm4iLCJfN24iLCJfMjU2biIsIl8weDcxbiIsIlNIQTNfUEkiLCJTSEEzX1JPVEwiLCJfU0hBM19JT1RBIiwicm91bmQiLCJSIiwieCIsInkiLCJwdXNoIiwidCIsImoiLCJJT1RBUyIsIlNIQTNfSU9UQV9IIiwiU0hBM19JT1RBX0wiLCJyb3RsSCIsImgiLCJsIiwicyIsInJvdGxMIiwia2VjY2FrUCIsInJvdW5kcyIsIkIiLCJVaW50MzJBcnJheSIsImlkeDEiLCJpZHgwIiwiQjAiLCJCMSIsIlRoIiwiVGwiLCJjdXJIIiwiY3VyTCIsInNoaWZ0IiwiUEkiLCJLZWNjYWsiLCJjb25zdHJ1Y3RvciIsImJsb2NrTGVuIiwic3VmZml4Iiwib3V0cHV0TGVuIiwiZW5hYmxlWE9GIiwicG9zIiwicG9zT3V0IiwiZmluaXNoZWQiLCJkZXN0cm95ZWQiLCJFcnJvciIsInN0YXRlIiwiVWludDhBcnJheSIsInN0YXRlMzIiLCJjbG9uZSIsIl9jbG9uZUludG8iLCJrZWNjYWsiLCJ1cGRhdGUiLCJkYXRhIiwibGVuIiwibGVuZ3RoIiwidGFrZSIsIk1hdGgiLCJtaW4iLCJpIiwiZmluaXNoIiwid3JpdGVJbnRvIiwib3V0IiwiYnVmZmVyT3V0Iiwic2V0Iiwic3ViYXJyYXkiLCJ4b2ZJbnRvIiwieG9mIiwiYnl0ZXMiLCJkaWdlc3RJbnRvIiwiZGVzdHJveSIsImRpZ2VzdCIsInRvIiwiZ2VuIiwic2hhM18yMjQiLCJzaGEzXzI1NiIsInNoYTNfMzg0Iiwic2hhM181MTIiLCJrZWNjYWtfMjI0Iiwia2VjY2FrXzI1NiIsImtlY2Nha18zODQiLCJrZWNjYWtfNTEyIiwiZ2VuU2hha2UiLCJvcHRzIiwiZGtMZW4iLCJ1bmRlZmluZWQiLCJzaGFrZTEyOCIsInNoYWtlMjU2Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/sha3.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/utils.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ox/node_modules/@noble/hashes/esm/utils.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: () => (/* binding */ Hash),\n/* harmony export */   abytes: () => (/* binding */ abytes),\n/* harmony export */   aexists: () => (/* binding */ aexists),\n/* harmony export */   ahash: () => (/* binding */ ahash),\n/* harmony export */   anumber: () => (/* binding */ anumber),\n/* harmony export */   aoutput: () => (/* binding */ aoutput),\n/* harmony export */   asyncLoop: () => (/* binding */ asyncLoop),\n/* harmony export */   byteSwap: () => (/* binding */ byteSwap),\n/* harmony export */   byteSwap32: () => (/* binding */ byteSwap32),\n/* harmony export */   byteSwapIfBE: () => (/* binding */ byteSwapIfBE),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   bytesToUtf8: () => (/* binding */ bytesToUtf8),\n/* harmony export */   checkOpts: () => (/* binding */ checkOpts),\n/* harmony export */   clean: () => (/* binding */ clean),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createHasher: () => (/* binding */ createHasher),\n/* harmony export */   createOptHasher: () => (/* binding */ createOptHasher),\n/* harmony export */   createView: () => (/* binding */ createView),\n/* harmony export */   createXOFer: () => (/* binding */ createXOFer),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   isBytes: () => (/* binding */ isBytes),\n/* harmony export */   isLE: () => (/* binding */ isLE),\n/* harmony export */   kdfInputToBytes: () => (/* binding */ kdfInputToBytes),\n/* harmony export */   nextTick: () => (/* binding */ nextTick),\n/* harmony export */   randomBytes: () => (/* binding */ randomBytes),\n/* harmony export */   rotl: () => (/* binding */ rotl),\n/* harmony export */   rotr: () => (/* binding */ rotr),\n/* harmony export */   swap32IfBE: () => (/* binding */ swap32IfBE),\n/* harmony export */   swap8IfBE: () => (/* binding */ swap8IfBE),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   u32: () => (/* binding */ u32),\n/* harmony export */   u8: () => (/* binding */ u8),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   wrapConstructor: () => (/* binding */ wrapConstructor),\n/* harmony export */   wrapConstructorWithOpts: () => (/* binding */ wrapConstructorWithOpts),\n/* harmony export */   wrapXOFConstructorWithOpts: () => (/* binding */ wrapXOFConstructorWithOpts)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/crypto */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/cryptoNode.js\");\n/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */ /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\n\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */ function isBytes(a) {\n    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === \"Uint8Array\";\n}\n/** Asserts something is positive integer. */ function anumber(n) {\n    if (!Number.isSafeInteger(n) || n < 0) throw new Error(\"positive integer expected, got \" + n);\n}\n/** Asserts something is Uint8Array. */ function abytes(b, ...lengths) {\n    if (!isBytes(b)) throw new Error(\"Uint8Array expected\");\n    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error(\"Uint8Array expected of length \" + lengths + \", got length=\" + b.length);\n}\n/** Asserts something is hash */ function ahash(h) {\n    if (typeof h !== \"function\" || typeof h.create !== \"function\") throw new Error(\"Hash should be wrapped by utils.createHasher\");\n    anumber(h.outputLen);\n    anumber(h.blockLen);\n}\n/** Asserts a hash instance has not been destroyed / finished */ function aexists(instance, checkFinished = true) {\n    if (instance.destroyed) throw new Error(\"Hash instance has been destroyed\");\n    if (checkFinished && instance.finished) throw new Error(\"Hash#digest() has already been called\");\n}\n/** Asserts output is properly-sized byte array */ function aoutput(out, instance) {\n    abytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(\"digestInto() expects output buffer of length at least \" + min);\n    }\n}\n/** Cast u8 / u16 / u32 to u8. */ function u8(arr) {\n    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** Cast u8 / u16 / u32 to u32. */ function u32(arr) {\n    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n/** Zeroize a byte array. Warning: JS provides no guarantees. */ function clean(...arrays) {\n    for(let i = 0; i < arrays.length; i++){\n        arrays[i].fill(0);\n    }\n}\n/** Create DataView of an array for easy byte-level manipulation. */ function createView(arr) {\n    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** The rotate right (circular right shift) operation for uint32 */ function rotr(word, shift) {\n    return word << 32 - shift | word >>> shift;\n}\n/** The rotate left (circular left shift) operation for uint32 */ function rotl(word, shift) {\n    return word << shift | word >>> 32 - shift >>> 0;\n}\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */ const isLE = /* @__PURE__ */ (()=>new Uint8Array(new Uint32Array([\n        0x11223344\n    ]).buffer)[0] === 0x44)();\n/** The byte swap operation for uint32 */ function byteSwap(word) {\n    return word << 24 & 0xff000000 | word << 8 & 0xff0000 | word >>> 8 & 0xff00 | word >>> 24 & 0xff;\n}\n/** Conditionally byte swap if on a big-endian platform */ const swap8IfBE = isLE ? (n)=>n : (n)=>byteSwap(n);\n/** @deprecated */ const byteSwapIfBE = swap8IfBE;\n/** In place byte swap for Uint32Array */ function byteSwap32(arr) {\n    for(let i = 0; i < arr.length; i++){\n        arr[i] = byteSwap(arr[i]);\n    }\n    return arr;\n}\nconst swap32IfBE = isLE ? (u)=>u : byteSwap32;\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin = /* @__PURE__ */ (()=>// @ts-ignore\n    typeof Uint8Array.from([]).toHex === \"function\" && typeof Uint8Array.fromHex === \"function\")();\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({\n    length: 256\n}, (_, i)=>i.toString(16).padStart(2, \"0\"));\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */ function bytesToHex(bytes) {\n    abytes(bytes);\n    // @ts-ignore\n    if (hasHexBuiltin) return bytes.toHex();\n    // pre-caching improves the speed 6x\n    let hex = \"\";\n    for(let i = 0; i < bytes.length; i++){\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = {\n    _0: 48,\n    _9: 57,\n    A: 65,\n    F: 70,\n    a: 97,\n    f: 102\n};\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */ function hexToBytes(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    // @ts-ignore\n    if (hasHexBuiltin) return Uint8Array.fromHex(hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2) throw new Error(\"hex string expected, got unpadded hex of length \" + hl);\n    const array = new Uint8Array(al);\n    for(let ai = 0, hi = 0; ai < al; ai++, hi += 2){\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */ const nextTick = async ()=>{};\n/** Returns control to thread each 'tick' ms to avoid blocking. */ async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for(let i = 0; i < iters; i++){\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick) continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */ function utf8ToBytes(str) {\n    if (typeof str !== \"string\") throw new Error(\"string expected\");\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */ function bytesToUtf8(bytes) {\n    return new TextDecoder().decode(bytes);\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */ function toBytes(data) {\n    if (typeof data === \"string\") data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */ function kdfInputToBytes(data) {\n    if (typeof data === \"string\") data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/** Copies several Uint8Arrays into one. */ function concatBytes(...arrays) {\n    let sum = 0;\n    for(let i = 0; i < arrays.length; i++){\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for(let i = 0, pad = 0; i < arrays.length; i++){\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && ({}).toString.call(opts) !== \"[object Object]\") throw new Error(\"options should be object or undefined\");\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\n/** For runtime check if class implements interface */ class Hash {\n}\n/** Wraps hash function, creating an interface on top of it */ function createHasher(hashCons) {\n    const hashC = (msg)=>hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = ()=>hashCons();\n    return hashC;\n}\nfunction createOptHasher(hashCons) {\n    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts)=>hashCons(opts);\n    return hashC;\n}\nfunction createXOFer(hashCons) {\n    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts)=>hashCons(opts);\n    return hashC;\n}\nconst wrapConstructor = createHasher;\nconst wrapConstructorWithOpts = createOptHasher;\nconst wrapXOFConstructorWithOpts = createXOFer;\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */ function randomBytes(bytesLength = 32) {\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues === \"function\") {\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    // Legacy Node.js compatibility\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.randomBytes === \"function\") {\n        return Uint8Array.from(_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.randomBytes(bytesLength));\n    }\n    throw new Error(\"crypto.getRandomValues must be defined\");\n} //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7O0NBR0MsR0FDRCxvRUFBb0UsR0FDcEUsb0ZBQW9GO0FBQ3BGLHNFQUFzRTtBQUN0RSxrRUFBa0U7QUFDbEUsOERBQThEO0FBQzlELCtEQUErRDtBQUMvRCwyRUFBMkU7QUFDN0I7QUFDOUMsbUZBQW1GLEdBQzVFLFNBQVNDLFFBQVFDLENBQUM7SUFDckIsT0FBT0EsYUFBYUMsY0FBZUMsWUFBWUMsTUFBTSxDQUFDSCxNQUFNQSxFQUFFSSxXQUFXLENBQUNDLElBQUksS0FBSztBQUN2RjtBQUNBLDJDQUEyQyxHQUNwQyxTQUFTQyxRQUFRQyxDQUFDO0lBQ3JCLElBQUksQ0FBQ0MsT0FBT0MsYUFBYSxDQUFDRixNQUFNQSxJQUFJLEdBQ2hDLE1BQU0sSUFBSUcsTUFBTSxvQ0FBb0NIO0FBQzVEO0FBQ0EscUNBQXFDLEdBQzlCLFNBQVNJLE9BQU9DLENBQUMsRUFBRSxHQUFHQyxPQUFPO0lBQ2hDLElBQUksQ0FBQ2QsUUFBUWEsSUFDVCxNQUFNLElBQUlGLE1BQU07SUFDcEIsSUFBSUcsUUFBUUMsTUFBTSxHQUFHLEtBQUssQ0FBQ0QsUUFBUUUsUUFBUSxDQUFDSCxFQUFFRSxNQUFNLEdBQ2hELE1BQU0sSUFBSUosTUFBTSxtQ0FBbUNHLFVBQVUsa0JBQWtCRCxFQUFFRSxNQUFNO0FBQy9GO0FBQ0EsOEJBQThCLEdBQ3ZCLFNBQVNFLE1BQU1DLENBQUM7SUFDbkIsSUFBSSxPQUFPQSxNQUFNLGNBQWMsT0FBT0EsRUFBRUMsTUFBTSxLQUFLLFlBQy9DLE1BQU0sSUFBSVIsTUFBTTtJQUNwQkosUUFBUVcsRUFBRUUsU0FBUztJQUNuQmIsUUFBUVcsRUFBRUcsUUFBUTtBQUN0QjtBQUNBLDhEQUE4RCxHQUN2RCxTQUFTQyxRQUFRQyxRQUFRLEVBQUVD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LEVBQUU7SUFDeEMsSUFBSXJJLHdEQUFNQSxJQUFJLE9BQU9BLHdEQUFNQSxDQUFDc0ksZUFBZSxLQUFLLFlBQVk7UUFDeEQsT0FBT3RJLHdEQUFNQSxDQUFDc0ksZUFBZSxDQUFDLElBQUluSSxXQUFXa0k7SUFDakQ7SUFDQSwrQkFBK0I7SUFDL0IsSUFBSXJJLHdEQUFNQSxJQUFJLE9BQU9BLHdEQUFNQSxDQUFDb0ksV0FBVyxLQUFLLFlBQVk7UUFDcEQsT0FBT2pJLFdBQVd1RCxJQUFJLENBQUMxRCx3REFBTUEsQ0FBQ29JLFdBQVcsQ0FBQ0M7SUFDOUM7SUFDQSxNQUFNLElBQUl6SCxNQUFNO0FBQ3BCLEVBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xhdy13b3Jrcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vdXRpbHMuanM/MTBhYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFV0aWxpdGllcyBmb3IgaGV4LCBieXRlcywgQ1NQUk5HLlxuICogQG1vZHVsZVxuICovXG4vKiEgbm9ibGUtaGFzaGVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBXZSB1c2UgV2ViQ3J5cHRvIGFrYSBnbG9iYWxUaGlzLmNyeXB0bywgd2hpY2ggZXhpc3RzIGluIGJyb3dzZXJzIGFuZCBub2RlLmpzIDE2Ky5cbi8vIG5vZGUuanMgdmVyc2lvbnMgZWFybGllciB0aGFuIHYxOSBkb24ndCBkZWNsYXJlIGl0IGluIGdsb2JhbCBzY29wZS5cbi8vIEZvciBub2RlLmpzLCBwYWNrYWdlLmpzb24jZXhwb3J0cyBmaWVsZCBtYXBwaW5nIHJld3JpdGVzIGltcG9ydFxuLy8gZnJvbSBgY3J5cHRvYCB0byBgY3J5cHRvTm9kZWAsIHdoaWNoIGltcG9ydHMgbmF0aXZlIG1vZHVsZS5cbi8vIE1ha2VzIHRoZSB1dGlscyB1bi1pbXBvcnRhYmxlIGluIGJyb3dzZXJzIHdpdGhvdXQgYSBidW5kbGVyLlxuLy8gT25jZSBub2RlLmpzIDE4IGlzIGRlcHJlY2F0ZWQgKDIwMjUtMDQtMzApLCB3ZSBjYW4ganVzdCBkcm9wIHRoZSBpbXBvcnQuXG5pbXBvcnQgeyBjcnlwdG8gfSBmcm9tICdAbm9ibGUvaGFzaGVzL2NyeXB0byc7XG4vKiogQ2hlY2tzIGlmIHNvbWV0aGluZyBpcyBVaW50OEFycmF5LiBCZSBjYXJlZnVsOiBub2RlanMgQnVmZmVyIHdpbGwgcmV0dXJuIHRydWUuICovXG5leHBvcnQgZnVuY3Rpb24gaXNCeXRlcyhhKSB7XG4gICAgcmV0dXJuIGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IChBcnJheUJ1ZmZlci5pc1ZpZXcoYSkgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpO1xufVxuLyoqIEFzc2VydHMgc29tZXRoaW5nIGlzIHBvc2l0aXZlIGludGVnZXIuICovXG5leHBvcnQgZnVuY3Rpb24gYW51bWJlcihuKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSB8fCBuIDwgMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwb3NpdGl2ZSBpbnRlZ2VyIGV4cGVjdGVkLCBnb3QgJyArIG4pO1xufVxuLyoqIEFzc2VydHMgc29tZXRoaW5nIGlzIFVpbnQ4QXJyYXkuICovXG5leHBvcnQgZnVuY3Rpb24gYWJ5dGVzKGIsIC4uLmxlbmd0aHMpIHtcbiAgICBpZiAoIWlzQnl0ZXMoYikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgIGlmIChsZW5ndGhzLmxlbmd0aCA+IDAgJiYgIWxlbmd0aHMuaW5jbHVkZXMoYi5sZW5ndGgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQgb2YgbGVuZ3RoICcgKyBsZW5ndGhzICsgJywgZ290IGxlbmd0aD0nICsgYi5sZW5ndGgpO1xufVxuLyoqIEFzc2VydHMgc29tZXRoaW5nIGlzIGhhc2ggKi9cbmV4cG9ydCBmdW5jdGlvbiBhaGFzaChoKSB7XG4gICAgaWYgKHR5cGVvZiBoICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBoLmNyZWF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIHNob3VsZCBiZSB3cmFwcGVkIGJ5IHV0aWxzLmNyZWF0ZUhhc2hlcicpO1xuICAgIGFudW1iZXIoaC5vdXRwdXRMZW4pO1xuICAgIGFudW1iZXIoaC5ibG9ja0xlbik7XG59XG4vKiogQXNzZXJ0cyBhIGhhc2ggaW5zdGFuY2UgaGFzIG5vdCBiZWVuIGRlc3Ryb3llZCAvIGZpbmlzaGVkICovXG5leHBvcnQgZnVuY3Rpb24gYWV4aXN0cyhpbnN0YW5jZSwgY2hlY2tGaW5pc2hlZCA9IHRydWUpIHtcbiAgICBpZiAoaW5zdGFuY2UuZGVzdHJveWVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkJyk7XG4gICAgaWYgKGNoZWNrRmluaXNoZWQgJiYgaW5zdGFuY2UuZmluaXNoZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCNkaWdlc3QoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZCcpO1xufVxuLyoqIEFzc2VydHMgb3V0cHV0IGlzIHByb3Blcmx5LXNpemVkIGJ5dGUgYXJyYXkgKi9cbmV4cG9ydCBmdW5jdGlvbiBhb3V0cHV0KG91dCwgaW5zdGFuY2UpIHtcbiAgICBhYnl0ZXMob3V0KTtcbiAgICBjb25zdCBtaW4gPSBpbnN0YW5jZS5vdXRwdXRMZW47XG4gICAgaWYgKG91dC5sZW5ndGggPCBtaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaWdlc3RJbnRvKCkgZXhwZWN0cyBvdXRwdXQgYnVmZmVyIG9mIGxlbmd0aCBhdCBsZWFzdCAnICsgbWluKTtcbiAgICB9XG59XG4vKiogQ2FzdCB1OCAvIHUxNiAvIHUzMiB0byB1OC4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1OChhcnIpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbn1cbi8qKiBDYXN0IHU4IC8gdTE2IC8gdTMyIHRvIHUzMi4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1MzIoYXJyKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50MzJBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgTWF0aC5mbG9vcihhcnIuYnl0ZUxlbmd0aCAvIDQpKTtcbn1cbi8qKiBaZXJvaXplIGEgYnl0ZSBhcnJheS4gV2FybmluZzogSlMgcHJvdmlkZXMgbm8gZ3VhcmFudGVlcy4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhbiguLi5hcnJheXMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJheXNbaV0uZmlsbCgwKTtcbiAgICB9XG59XG4vKiogQ3JlYXRlIERhdGFWaWV3IG9mIGFuIGFycmF5IGZvciBlYXN5IGJ5dGUtbGV2ZWwgbWFuaXB1bGF0aW9uLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVZpZXcoYXJyKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRhVmlldyhhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xufVxuLyoqIFRoZSByb3RhdGUgcmlnaHQgKGNpcmN1bGFyIHJpZ2h0IHNoaWZ0KSBvcGVyYXRpb24gZm9yIHVpbnQzMiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdHIod29yZCwgc2hpZnQpIHtcbiAgICByZXR1cm4gKHdvcmQgPDwgKDMyIC0gc2hpZnQpKSB8ICh3b3JkID4+PiBzaGlmdCk7XG59XG4vKiogVGhlIHJvdGF0ZSBsZWZ0IChjaXJjdWxhciBsZWZ0IHNoaWZ0KSBvcGVyYXRpb24gZm9yIHVpbnQzMiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdGwod29yZCwgc2hpZnQpIHtcbiAgICByZXR1cm4gKHdvcmQgPDwgc2hpZnQpIHwgKCh3b3JkID4+PiAoMzIgLSBzaGlmdCkpID4+PiAwKTtcbn1cbi8qKiBJcyBjdXJyZW50IHBsYXRmb3JtIGxpdHRsZS1lbmRpYW4/IE1vc3QgYXJlLiBCaWctRW5kaWFuIHBsYXRmb3JtOiBJQk0gKi9cbmV4cG9ydCBjb25zdCBpc0xFID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBuZXcgVWludDhBcnJheShuZXcgVWludDMyQXJyYXkoWzB4MTEyMjMzNDRdKS5idWZmZXIpWzBdID09PSAweDQ0KSgpO1xuLyoqIFRoZSBieXRlIHN3YXAgb3BlcmF0aW9uIGZvciB1aW50MzIgKi9cbmV4cG9ydCBmdW5jdGlvbiBieXRlU3dhcCh3b3JkKSB7XG4gICAgcmV0dXJuICgoKHdvcmQgPDwgMjQpICYgMHhmZjAwMDAwMCkgfFxuICAgICAgICAoKHdvcmQgPDwgOCkgJiAweGZmMDAwMCkgfFxuICAgICAgICAoKHdvcmQgPj4+IDgpICYgMHhmZjAwKSB8XG4gICAgICAgICgod29yZCA+Pj4gMjQpICYgMHhmZikpO1xufVxuLyoqIENvbmRpdGlvbmFsbHkgYnl0ZSBzd2FwIGlmIG9uIGEgYmlnLWVuZGlhbiBwbGF0Zm9ybSAqL1xuZXhwb3J0IGNvbnN0IHN3YXA4SWZCRSA9IGlzTEVcbiAgICA/IChuKSA9PiBuXG4gICAgOiAobikgPT4gYnl0ZVN3YXAobik7XG4vKiogQGRlcHJlY2F0ZWQgKi9cbmV4cG9ydCBjb25zdCBieXRlU3dhcElmQkUgPSBzd2FwOElmQkU7XG4vKiogSW4gcGxhY2UgYnl0ZSBzd2FwIGZvciBVaW50MzJBcnJheSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVTd2FwMzIoYXJyKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gYnl0ZVN3YXAoYXJyW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbn1cbmV4cG9ydCBjb25zdCBzd2FwMzJJZkJFID0gaXNMRVxuICAgID8gKHUpID0+IHVcbiAgICA6IGJ5dGVTd2FwMzI7XG4vLyBCdWlsdC1pbiBoZXggY29udmVyc2lvbiBodHRwczovL2Nhbml1c2UuY29tL21kbi1qYXZhc2NyaXB0X2J1aWx0aW5zX3VpbnQ4YXJyYXlfZnJvbWhleFxuY29uc3QgaGFzSGV4QnVpbHRpbiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gXG4vLyBAdHMtaWdub3JlXG50eXBlb2YgVWludDhBcnJheS5mcm9tKFtdKS50b0hleCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgVWludDhBcnJheS5mcm9tSGV4ID09PSAnZnVuY3Rpb24nKSgpO1xuLy8gQXJyYXkgd2hlcmUgaW5kZXggMHhmMCAoMjQwKSBpcyBtYXBwZWQgdG8gc3RyaW5nICdmMCdcbmNvbnN0IGhleGVzID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoXywgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4vKipcbiAqIENvbnZlcnQgYnl0ZSBhcnJheSB0byBoZXggc3RyaW5nLiBVc2VzIGJ1aWx0LWluIGZ1bmN0aW9uLCB3aGVuIGF2YWlsYWJsZS5cbiAqIEBleGFtcGxlIGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSkpIC8vICdjYWZlMDEyMydcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9IZXgoYnl0ZXMpIHtcbiAgICBhYnl0ZXMoYnl0ZXMpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAoaGFzSGV4QnVpbHRpbilcbiAgICAgICAgcmV0dXJuIGJ5dGVzLnRvSGV4KCk7XG4gICAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGhleGVzW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbi8vIFdlIHVzZSBvcHRpbWl6ZWQgdGVjaG5pcXVlIHRvIGNvbnZlcnQgaGV4IHN0cmluZyB0byBieXRlIGFycmF5XG5jb25zdCBhc2NpaXMgPSB7IF8wOiA0OCwgXzk6IDU3LCBBOiA2NSwgRjogNzAsIGE6IDk3LCBmOiAxMDIgfTtcbmZ1bmN0aW9uIGFzY2lpVG9CYXNlMTYoY2gpIHtcbiAgICBpZiAoY2ggPj0gYXNjaWlzLl8wICYmIGNoIDw9IGFzY2lpcy5fOSlcbiAgICAgICAgcmV0dXJuIGNoIC0gYXNjaWlzLl8wOyAvLyAnMicgPT4gNTAtNDhcbiAgICBpZiAoY2ggPj0gYXNjaWlzLkEgJiYgY2ggPD0gYXNjaWlzLkYpXG4gICAgICAgIHJldHVybiBjaCAtIChhc2NpaXMuQSAtIDEwKTsgLy8gJ0InID0+IDY2LSg2NS0xMClcbiAgICBpZiAoY2ggPj0gYXNjaWlzLmEgJiYgY2ggPD0gYXNjaWlzLmYpXG4gICAgICAgIHJldHVybiBjaCAtIChhc2NpaXMuYSAtIDEwKTsgLy8gJ2InID0+IDk4LSg5Ny0xMClcbiAgICByZXR1cm47XG59XG4vKipcbiAqIENvbnZlcnQgaGV4IHN0cmluZyB0byBieXRlIGFycmF5LiBVc2VzIGJ1aWx0LWluIGZ1bmN0aW9uLCB3aGVuIGF2YWlsYWJsZS5cbiAqIEBleGFtcGxlIGhleFRvQnl0ZXMoJ2NhZmUwMTIzJykgLy8gVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmIChoYXNIZXhCdWlsdGluKVxuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tSGV4KGhleCk7XG4gICAgY29uc3QgaGwgPSBoZXgubGVuZ3RoO1xuICAgIGNvbnN0IGFsID0gaGwgLyAyO1xuICAgIGlmIChobCAlIDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IHVucGFkZGVkIGhleCBvZiBsZW5ndGggJyArIGhsKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFsKTtcbiAgICBmb3IgKGxldCBhaSA9IDAsIGhpID0gMDsgYWkgPCBhbDsgYWkrKywgaGkgKz0gMikge1xuICAgICAgICBjb25zdCBuMSA9IGFzY2lpVG9CYXNlMTYoaGV4LmNoYXJDb2RlQXQoaGkpKTtcbiAgICAgICAgY29uc3QgbjIgPSBhc2NpaVRvQmFzZTE2KGhleC5jaGFyQ29kZUF0KGhpICsgMSkpO1xuICAgICAgICBpZiAobjEgPT09IHVuZGVmaW5lZCB8fCBuMiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFyID0gaGV4W2hpXSArIGhleFtoaSArIDFdO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3Qgbm9uLWhleCBjaGFyYWN0ZXIgXCInICsgY2hhciArICdcIiBhdCBpbmRleCAnICsgaGkpO1xuICAgICAgICB9XG4gICAgICAgIGFycmF5W2FpXSA9IG4xICogMTYgKyBuMjsgLy8gbXVsdGlwbHkgZmlyc3Qgb2N0ZXQsIGUuZy4gJ2EzJyA9PiAxMCoxNiszID0+IDE2MCArIDMgPT4gMTYzXG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbi8qKlxuICogVGhlcmUgaXMgbm8gc2V0SW1tZWRpYXRlIGluIGJyb3dzZXIgYW5kIHNldFRpbWVvdXQgaXMgc2xvdy5cbiAqIENhbGwgb2YgYXN5bmMgZm4gd2lsbCByZXR1cm4gUHJvbWlzZSwgd2hpY2ggd2lsbCBiZSBmdWxsZmlsZWQgb25seSBvblxuICogbmV4dCBzY2hlZHVsZXIgcXVldWUgcHJvY2Vzc2luZyBzdGVwIGFuZCB0aGlzIGlzIGV4YWN0bHkgd2hhdCB3ZSBuZWVkLlxuICovXG5leHBvcnQgY29uc3QgbmV4dFRpY2sgPSBhc3luYyAoKSA9PiB7IH07XG4vKiogUmV0dXJucyBjb250cm9sIHRvIHRocmVhZCBlYWNoICd0aWNrJyBtcyB0byBhdm9pZCBibG9ja2luZy4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhc3luY0xvb3AoaXRlcnMsIHRpY2ssIGNiKSB7XG4gICAgbGV0IHRzID0gRGF0ZS5ub3coKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJzOyBpKyspIHtcbiAgICAgICAgY2IoaSk7XG4gICAgICAgIC8vIERhdGUubm93KCkgaXMgbm90IG1vbm90b25pYywgc28gaW4gY2FzZSBpZiBjbG9jayBnb2VzIGJhY2t3YXJkcyB3ZSByZXR1cm4gcmV0dXJuIGNvbnRyb2wgdG9vXG4gICAgICAgIGNvbnN0IGRpZmYgPSBEYXRlLm5vdygpIC0gdHM7XG4gICAgICAgIGlmIChkaWZmID49IDAgJiYgZGlmZiA8IHRpY2spXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgYXdhaXQgbmV4dFRpY2soKTtcbiAgICAgICAgdHMgKz0gZGlmZjtcbiAgICB9XG59XG4vKipcbiAqIENvbnZlcnRzIHN0cmluZyB0byBieXRlcyB1c2luZyBVVEY4IGVuY29kaW5nLlxuICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIFVpbnQ4QXJyYXkuZnJvbShbOTcsIDk4LCA5OV0pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc3RyaW5nIGV4cGVjdGVkJyk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpKTsgLy8gaHR0cHM6Ly9idWd6aWwubGEvMTY4MTgwOVxufVxuLyoqXG4gKiBDb252ZXJ0cyBieXRlcyB0byBzdHJpbmcgdXNpbmcgVVRGOCBlbmNvZGluZy5cbiAqIEBleGFtcGxlIGJ5dGVzVG9VdGY4KFVpbnQ4QXJyYXkuZnJvbShbOTcsIDk4LCA5OV0pKSAvLyAnYWJjJ1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb1V0ZjgoYnl0ZXMpIHtcbiAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGJ5dGVzKTtcbn1cbi8qKlxuICogTm9ybWFsaXplcyAobm9uLWhleCkgc3RyaW5nIG9yIFVpbnQ4QXJyYXkgdG8gVWludDhBcnJheS5cbiAqIFdhcm5pbmc6IHdoZW4gVWludDhBcnJheSBpcyBwYXNzZWQsIGl0IHdvdWxkIE5PVCBnZXQgY29waWVkLlxuICogS2VlcCBpbiBtaW5kIGZvciBmdXR1cmUgbXV0YWJsZSBvcGVyYXRpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CeXRlcyhkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJylcbiAgICAgICAgZGF0YSA9IHV0ZjhUb0J5dGVzKGRhdGEpO1xuICAgIGFieXRlcyhkYXRhKTtcbiAgICByZXR1cm4gZGF0YTtcbn1cbi8qKlxuICogSGVscGVyIGZvciBLREZzOiBjb25zdW1lcyB1aW50OGFycmF5IG9yIHN0cmluZy5cbiAqIFdoZW4gc3RyaW5nIGlzIHBhc3NlZCwgZG9lcyB1dGY4IGRlY29kaW5nLCB1c2luZyBUZXh0RGVjb2Rlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGtkZklucHV0VG9CeXRlcyhkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJylcbiAgICAgICAgZGF0YSA9IHV0ZjhUb0J5dGVzKGRhdGEpO1xuICAgIGFieXRlcyhkYXRhKTtcbiAgICByZXR1cm4gZGF0YTtcbn1cbi8qKiBDb3BpZXMgc2V2ZXJhbCBVaW50OEFycmF5cyBpbnRvIG9uZS4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXRCeXRlcyguLi5hcnJheXMpIHtcbiAgICBsZXQgc3VtID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhID0gYXJyYXlzW2ldO1xuICAgICAgICBhYnl0ZXMoYSk7XG4gICAgICAgIHN1bSArPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoc3VtKTtcbiAgICBmb3IgKGxldCBpID0gMCwgcGFkID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhID0gYXJyYXlzW2ldO1xuICAgICAgICByZXMuc2V0KGEsIHBhZCk7XG4gICAgICAgIHBhZCArPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmV4cG9ydCBmdW5jdGlvbiBjaGVja09wdHMoZGVmYXVsdHMsIG9wdHMpIHtcbiAgICBpZiAob3B0cyAhPT0gdW5kZWZpbmVkICYmIHt9LnRvU3RyaW5nLmNhbGwob3B0cykgIT09ICdbb2JqZWN0IE9iamVjdF0nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMgc2hvdWxkIGJlIG9iamVjdCBvciB1bmRlZmluZWQnKTtcbiAgICBjb25zdCBtZXJnZWQgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRzLCBvcHRzKTtcbiAgICByZXR1cm4gbWVyZ2VkO1xufVxuLyoqIEZvciBydW50aW1lIGNoZWNrIGlmIGNsYXNzIGltcGxlbWVudHMgaW50ZXJmYWNlICovXG5leHBvcnQgY2xhc3MgSGFzaCB7XG59XG4vKiogV3JhcHMgaGFzaCBmdW5jdGlvbiwgY3JlYXRpbmcgYW4gaW50ZXJmYWNlIG9uIHRvcCBvZiBpdCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUhhc2hlcihoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZykgPT4gaGFzaENvbnMoKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucygpO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKCkgPT4gaGFzaENvbnMoKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlT3B0SGFzaGVyKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVhPRmVyKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0IGNvbnN0IHdyYXBDb25zdHJ1Y3RvciA9IGNyZWF0ZUhhc2hlcjtcbmV4cG9ydCBjb25zdCB3cmFwQ29uc3RydWN0b3JXaXRoT3B0cyA9IGNyZWF0ZU9wdEhhc2hlcjtcbmV4cG9ydCBjb25zdCB3cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cyA9IGNyZWF0ZVhPRmVyO1xuLyoqIENyeXB0b2dyYXBoaWNhbGx5IHNlY3VyZSBQUk5HLiBVc2VzIGludGVybmFsIE9TLWxldmVsIGBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzYC4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5kb21CeXRlcyhieXRlc0xlbmd0aCA9IDMyKSB7XG4gICAgaWYgKGNyeXB0byAmJiB0eXBlb2YgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShieXRlc0xlbmd0aCkpO1xuICAgIH1cbiAgICAvLyBMZWdhY3kgTm9kZS5qcyBjb21wYXRpYmlsaXR5XG4gICAgaWYgKGNyeXB0byAmJiB0eXBlb2YgY3J5cHRvLnJhbmRvbUJ5dGVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oY3J5cHRvLnJhbmRvbUJ5dGVzKGJ5dGVzTGVuZ3RoKSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignY3J5cHRvLmdldFJhbmRvbVZhbHVlcyBtdXN0IGJlIGRlZmluZWQnKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6WyJjcnlwdG8iLCJpc0J5dGVzIiwiYSIsIlVpbnQ4QXJyYXkiLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsImNvbnN0cnVjdG9yIiwibmFtZSIsImFudW1iZXIiLCJuIiwiTnVtYmVyIiwiaXNTYWZlSW50ZWdlciIsIkVycm9yIiwiYWJ5dGVzIiwiYiIsImxlbmd0aHMiLCJsZW5ndGgiLCJpbmNsdWRlcyIsImFoYXNoIiwiaCIsImNyZWF0ZSIsIm91dHB1dExlbiIsImJsb2NrTGVuIiwiYWV4aXN0cyIsImluc3RhbmNlIiwiY2hlY2tGaW5pc2hlZCIsImRlc3Ryb3llZCIsImZpbmlzaGVkIiwiYW91dHB1dCIsIm91dCIsIm1pbiIsInU4IiwiYXJyIiwiYnVmZmVyIiwiYnl0ZU9mZnNldCIsImJ5dGVMZW5ndGgiLCJ1MzIiLCJVaW50MzJBcnJheSIsIk1hdGgiLCJmbG9vciIsImNsZWFuIiwiYXJyYXlzIiwiaSIsImZpbGwiLCJjcmVhdGVWaWV3IiwiRGF0YVZpZXciLCJyb3RyIiwid29yZCIsInNoaWZ0Iiwicm90bCIsImlzTEUiLCJieXRlU3dhcCIsInN3YXA4SWZCRSIsImJ5dGVTd2FwSWZCRSIsImJ5dGVTd2FwMzIiLCJzd2FwMzJJZkJFIiwidSIsImhhc0hleEJ1aWx0aW4iLCJmcm9tIiwidG9IZXgiLCJmcm9tSGV4IiwiaGV4ZXMiLCJBcnJheSIsIl8iLCJ0b1N0cmluZyIsInBhZFN0YXJ0IiwiYnl0ZXNUb0hleCIsImJ5dGVzIiwiaGV4IiwiYXNjaWlzIiwiXzAiLCJfOSIsIkEiLCJGIiwiZiIsImFzY2lpVG9CYXNlMTYiLCJjaCIsImhleFRvQnl0ZXMiLCJobCIsImFsIiwiYXJyYXkiLCJhaSIsImhpIiwibjEiLCJjaGFyQ29kZUF0IiwibjIiLCJ1bmRlZmluZWQiLCJjaGFyIiwibmV4dFRpY2siLCJhc3luY0xvb3AiLCJpdGVycyIsInRpY2siLCJjYiIsInRzIiwiRGF0ZSIsIm5vdyIsImRpZmYiLCJ1dGY4VG9CeXRlcyIsInN0ciIsIlRleHRFbmNvZGVyIiwiZW5jb2RlIiwiYnl0ZXNUb1V0ZjgiLCJUZXh0RGVjb2RlciIsImRlY29kZSIsInRvQnl0ZXMiLCJkYXRhIiwia2RmSW5wdXRUb0J5dGVzIiwiY29uY2F0Qnl0ZXMiLCJzdW0iLCJyZXMiLCJwYWQiLCJzZXQiLCJjaGVja09wdHMiLCJkZWZhdWx0cyIsIm9wdHMiLCJjYWxsIiwibWVyZ2VkIiwiT2JqZWN0IiwiYXNzaWduIiwiSGFzaCIsImNyZWF0ZUhhc2hlciIsImhhc2hDb25zIiwiaGFzaEMiLCJtc2ciLCJ1cGRhdGUiLCJkaWdlc3QiLCJ0bXAiLCJjcmVhdGVPcHRIYXNoZXIiLCJjcmVhdGVYT0ZlciIsIndyYXBDb25zdHJ1Y3RvciIsIndyYXBDb25zdHJ1Y3RvcldpdGhPcHRzIiwid3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMiLCJyYW5kb21CeXRlcyIsImJ5dGVzTGVuZ3RoIiwiZ2V0UmFuZG9tVmFsdWVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/utils.js\n");

/***/ })

};
;